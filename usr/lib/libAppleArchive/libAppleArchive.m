uint64_t compare_extents_by_position(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return 1;
}

void rawimg_destroy(uint64_t *a1)
{
  unint64_t v2;
  uint64_t v3;

  if (a1)
  {
    if (a1[270])
    {
      v2 = 0;
      v3 = 384;
      do
      {
        free(*(void **)(a1[268] + v3));
        ++v2;
        v3 += 440;
      }
      while (v2 < a1[270]);
    }
    pc_array_free(a1[267]);
    pc_array_free(a1[268]);
    free(a1);
  }
}

uint64_t rawimg_show(uint64_t result, int a2, int a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  FILE **v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _OWORD v16[4];
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = (_QWORD *)result;
    v17 = 0;
    memset(v16, 0, sizeof(v16));
    v6 = *(_QWORD *)(result + 2160);
    if (v6)
    {
      v7 = 0;
      v8 = 0;
      v9 = (_QWORD *)(*(_QWORD *)(result + 2144) + 400);
      do
      {
        v7 += *v9;
        v8 += *(v9 - 1);
        v9 += 55;
        --v6;
      }
      while (v6);
    }
    else
    {
      v8 = 0;
      v7 = 0;
    }
    result = serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)(result + 2088));
    if (a3 > 1)
    {
      v10 = (FILE **)MEMORY[0x24BDAC8D8];
      v11 = "Output";
      if (!a2)
        v11 = "Input";
      v12 = (const char *)&unk_20A3FA2C1;
      if (v5[256])
        v12 = (const char *)v5[256];
      result = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s variant <%s> | %llu bytes | %zu extents | %zu forks (%llu/%llu) | digest=%s\n", v11, v12, v5[265], v5[269], v5[270], v7, v8, (const char *)v16);
      if (a3 != 2)
      {
        result = fprintf(*v10, " fork | %64s | algo |       size | compressed | V | C\n", "digest");
        if (v5[270])
        {
          v13 = 0;
          v14 = 0;
          do
          {
            v15 = v5[268] + v13;
            serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)v15);
            result = fprintf(*v10, "%5zu | %s | %4d | %10llu | %10llu | %d | %d\n", ++v14, (const char *)v16, *(unsigned __int8 *)(v15 + 432), *(_QWORD *)(v15 + 392), *(_QWORD *)(v15 + 400), *(_DWORD *)(v15 + 408) & 1, (*(_DWORD *)(v15 + 408) >> 1) & 1);
            v13 += 440;
          }
          while (v14 < v5[270]);
        }
      }
    }
  }
  return result;
}

uint64_t *rawimg_create_with_path(const char *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  int v20;
  const char *v22;
  stat v23;

  v2 = (uint64_t *)calloc(1uLL, 0x878uLL);
  memset(&v23, 0, sizeof(v23));
  if (!v2)
  {
    v20 = *__error();
    v18 = "aaCalloc";
    v19 = 468;
    goto LABEL_17;
  }
  if (lstat(a1, &v23) || (v23.st_mode & 0xF000) != 0x8000)
  {
    v18 = "lstat";
    v19 = 469;
LABEL_15:
    v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_path", v19, 138, v20, v18, v3, v4, v23.st_dev);
    rawimg_destroy(v2);
    return 0;
  }
  v2[256] = (uint64_t)a1;
  v2[265] = v23.st_size;
  v2[267] = (uint64_t)pc_array_init(16);
  v5 = pc_array_init(440);
  v2[268] = (uint64_t)v5;
  if (!v2[267] || !v5)
  {
    v18 = "pc_array_init";
    v19 = 476;
    goto LABEL_15;
  }
  if ((apfs_scan_diskimage(a1, (uint64_t (*)(__int128 *, uint64_t))rawimg_add_fork, (uint64_t)rawimg_add_volume, (uint64_t)v2) & 0x80000000) != 0)
  {
    v18 = "rawimg_query_forks";
    v19 = 479;
    goto LABEL_15;
  }
  v6 = (_QWORD *)v2[268];
  v7 = *(v6 - 8);
  v2[270] = v7;
  v2[269] = *(_QWORD *)(v2[267] - 64);
  if (v7)
  {
    pc_array_sort(v6, (int (__cdecl *)(const void *, const void *))compare_forks_by_extent);
    if ((pc_array_aggregate((char *)v2[268], (unsigned int (*)(char *, char *))compare_forks_by_extent, (uint64_t (*)(char *, char *))aggregate_identical_forks) & 0x80000000) != 0)
    {
      v22 = "rawimg_remove_fork_duplicates";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_remove_fork_duplicates", 454, 138, 0, "bad duplicate", v8, v9, v23.st_dev);
      v19 = 484;
      goto LABEL_23;
    }
    v6 = (_QWORD *)v2[268];
    v2[270] = *(v6 - 8);
  }
  v2[268] = (uint64_t)pc_array_compact((uint64_t)v6);
  v10 = pc_array_compact(v2[267]);
  v2[267] = (uint64_t)v10;
  if (!v10 || !v2[268])
  {
    v22 = "rawimg_compact";
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_compact", 77, 138, 0, "pc_array_compress", v16, v17, v23.st_dev);
    v19 = 485;
LABEL_23:
    v20 = 0;
    v18 = v22;
    goto LABEL_17;
  }
  if ((rawimg_verify(v2, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) != 0)
  {
    v18 = "rawimg_verify";
    v19 = 486;
    goto LABEL_15;
  }
  qsort_r((void *)v2[268], v2[270], 0x1B8uLL, v2, (int (__cdecl *)(void *, const void *, const void *))compare_forks_by_position);
  return v2;
}

uint64_t rawimg_add_fork(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  const char *v20;
  __int16 v21;
  __int128 v22;
  _OWORD __src[24];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v27 = 0;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  memset(__src, 0, sizeof(__src));
  v8 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v8 && *(_QWORD *)a1)
  {
    v11 = *(_QWORD *)(a1 + 8);
    *((_QWORD *)&v24 + 1) = *(_QWORD *)a1;
    *(_QWORD *)&v25 = v11;
    *(_QWORD *)&v26 = *(_QWORD *)(*(_QWORD *)(a2 + 2136) - 64);
    *((_QWORD *)&v26 + 1) = v8;
    LOBYTE(v27) = *(_DWORD *)(a1 + 16);
    v12 = pc_array_append(*(_QWORD *)(a2 + 2144), __src, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a2 + 2144) = v12;
    if (v12)
    {
      if (*(int *)(a1 + 20) < 1)
        return 0;
      v17 = 0;
      v18 = *(_QWORD **)(a2 + 2136);
      while (1)
      {
        v22 = 0uLL;
        v22 = *(_OWORD *)(*(_QWORD *)(a1 + 24) + 16 * v17);
        v18 = pc_array_append((uint64_t)v18, &v22, v13, v14, v15, v16, a7, a8);
        *(_QWORD *)(a2 + 2136) = v18;
        if (!v18)
          break;
        if (++v17 >= *(int *)(a1 + 20))
          return 0;
      }
      v20 = "pc_array_append";
      v21 = 440;
    }
    else
    {
      v20 = "pc_array_append";
      v21 = 427;
    }
  }
  else
  {
    v20 = "bad fork";
    v21 = 416;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_add_fork", v21, 138, 0, v20, a7, a8, v22);
  return 0xFFFFFFFFLL;
}

uint64_t rawimg_add_volume()
{
  return 0;
}

uint64_t rawimg_verify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD **v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  _QWORD *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  unsigned int v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  const char *v49;
  __int16 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  unsigned int *v58;
  unint64_t v59;
  __int16 v60;
  char v61;

  v8 = a1[270];
  v9 = a1[269];
  if (!v8 || !v9)
  {
    if (!(v8 + v9))
      return 0;
    v26 = "bad variant";
    v27 = 184;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v27, 138, 0, v26, a7, a8, v61);
    v28 = 0;
    v17 = 0;
    goto LABEL_23;
  }
  v11 = a1[267];
  v12 = (_QWORD *)(v11 + 8);
  do
  {
    v13 = *(v12 - 1);
    if ((unint64_t)(*v12 + v13) > a1[265])
    {
      v26 = "bad extent";
      v27 = 195;
      goto LABEL_22;
    }
    if ((v13 & 0xFFF) != 0)
    {
      v26 = "bad extent pos";
      v27 = 196;
      goto LABEL_22;
    }
    if ((*v12 & 0xFFFLL) != 0)
    {
      v26 = "bad extent size";
      v27 = 197;
      goto LABEL_22;
    }
    v12 += 2;
    --v9;
  }
  while (v9);
  v14 = pc_array_indirect_sort(v11, compare_extents_by_position);
  v17 = v14;
  if (!v14)
  {
    v23 = "pc_array_indirect_sort";
    v24 = 202;
    goto LABEL_27;
  }
  v18 = 0;
  v19 = a1[269];
  if (v19 <= 1)
    v20 = 1;
  else
    v20 = a1[269];
  v21 = v20 - 1;
  while (v21 != v18)
  {
    v22 = (_QWORD **)&v14[v18++];
    if ((*v22)[1] + **v22 > *v22[1])
    {
      v23 = "extents overlapping";
      v24 = 205;
      goto LABEL_27;
    }
  }
  v30 = a1[270];
  v31 = a1[268];
  if (!v30)
  {
LABEL_42:
    v28 = pc_array_indirect_sort(v31, compare_forks_by_extent);
    if (v28)
    {
      v45 = a1[270];
      if (v45 <= 1)
        v46 = 1;
      else
        v46 = a1[270];
      v47 = 856;
      while (--v46)
      {
        v48 = (_QWORD *)(a1[268] + v47);
        v47 += 440;
        if (*(v48 - 55) == *v48)
        {
          v49 = "duplicate fork";
          v50 = 239;
          goto LABEL_69;
        }
      }
      if (!v45)
      {
LABEL_59:
        v25 = 0;
        goto LABEL_24;
      }
      v51 = 0;
      v52 = a1[268];
      while (1)
      {
        v53 = *(_QWORD *)(v52 + 440 * v51 + 56);
        if (v53)
          break;
LABEL_58:
        if (++v51 == v45)
          goto LABEL_59;
      }
      v54 = 0;
      v55 = v52 + 440 * v51;
      v56 = *(_QWORD *)(v55 + 384);
      v57 = (unint64_t *)(v55 + 400);
      v58 = (unsigned int *)(v56 + 8);
      while (1)
      {
        v59 = *((_QWORD *)v58 - 1);
        if (v59 < v54)
        {
          v49 = "bad chunk order";
          v50 = 256;
          goto LABEL_69;
        }
        v54 = v59 + *v58;
        if (v54 > *v57)
          break;
        v58 += 3;
        if (!--v53)
          goto LABEL_58;
      }
      v49 = "chunk out of bounds";
      v50 = 257;
    }
    else
    {
      v49 = "pc_array_indirect_sort";
      v50 = 236;
    }
LABEL_69:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v50, 138, 0, v49, v43, v44, v61);
    goto LABEL_23;
  }
  v32 = 0;
  while (2)
  {
    v33 = v31 + 440 * v32;
    v35 = *(_QWORD *)(v33 + 416);
    v34 = *(_QWORD *)(v33 + 424);
    if (v34 + v35 > v19)
    {
      v23 = "bad fork";
      v24 = 216;
      goto LABEL_27;
    }
    if (!v34)
    {
      v23 = "no fork extents";
      v24 = 219;
      goto LABEL_27;
    }
    if (!*(_QWORD *)(v31 + 440 * v32 + 392))
    {
      v23 = "bad fork size";
      v24 = 222;
      goto LABEL_27;
    }
    v36 = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
    if (!*(_BYTE *)(v31 + 440 * v32 + 432))
    {
      v60 = 155;
      goto LABEL_66;
    }
    v37 = &a1[*(unsigned __int8 *)(v31 + 440 * v32 + 432)];
    if (*v37)
    {
LABEL_38:
      v40 = 0;
      v41 = (uint64_t *)(a1[267] + 16 * v35 + 8);
      do
      {
        v42 = *v41;
        v41 += 2;
        v40 += v42;
        --v34;
      }
      while (v34);
      if (v40 < *(_QWORD *)(v31 + 440 * v32 + 400))
      {
        v23 = "bad fork size";
        v24 = 231;
        goto LABEL_27;
      }
      if (++v32 == v30)
        goto LABEL_42;
      continue;
    }
    break;
  }
  HIDWORD(v39) = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
  LODWORD(v39) = v36 - 4;
  v38 = v39 >> 1;
  if (v38 < 6 && ((0x35u >> v38) & 1) != 0)
  {
    *v37 = dword_20A40B7C0[v38];
    BYTE4(a1[v36]) = 0xFFFFFF06FFFFuLL >> (8 * v38);
    goto LABEL_38;
  }
  v60 = 167;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_init_algorithm", v60, 138, 0, "bad algo", v15, v16, v61);
  v24 = 225;
  v23 = "rawimg_init_algorithm";
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v24, 138, 0, v23, v15, v16, v61);
  v28 = 0;
LABEL_23:
  v25 = 0xFFFFFFFFLL;
LABEL_24:
  free(v17);
  free(v28);
  return v25;
}

uint64_t rawimg_get_digests(uint64_t a1, signed int a2, int a3, int a4)
{
  unsigned int **v8;
  uint64_t v9;
  uint64_t v10;
  AAByteStream_impl *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD **v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  char *v57;
  size_t v58;
  uint64_t v59;
  size_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  _DWORD *v64;
  unsigned int *v65;
  uint64_t v66;
  size_t v67;
  _DWORD *v68;
  int *v69;
  uint64_t v70;
  int v71;
  unsigned int *v72;
  size_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t **v80;
  void *v81;
  void *v82;
  uint64_t v83;
  uint64_t **v84;
  uint64_t ***v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int *v93;
  unint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t Worker;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  const char *v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  const char *v107;
  __int16 v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  int *v117;
  uint64_t v118;
  uint64_t v119;
  int *v120;
  uint64_t v121;
  uint64_t v122;
  const char *v123;
  __int16 v124;
  unint64_t v125;
  uint64_t v126;
  size_t v127;
  size_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  const char *v143;
  __int16 v144;
  char *v145;
  uint64_t v146;
  unint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  char v150;
  uint64_t v151;
  _QWORD **v152;
  unint64_t v153;
  uint64_t v154;
  _QWORD *v155;
  int v156;
  _QWORD *v157;
  AAByteStream_impl *v158;
  AAByteStream_impl *v159;
  signed int v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  size_t v165;
  size_t v166;
  CC_SHA256_CTX c;

  memset(&c, 0, sizeof(c));
  v8 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 2048), 0, 0);
  v11 = (AAByteStream_impl *)v8;
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 570, 138, 0, "AAFileStreamOpenWithPath", v9, v10, v150);
LABEL_78:
    v79 = 0;
    v82 = 0;
    v80 = 0;
    v93 = 0;
    v76 = 0;
    v20 = 0;
LABEL_95:
    v113 = 0;
    goto LABEL_96;
  }
  if (a4 && (io_set_nocache(v8) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 571, 138, "io_set_nocache %s", v12, v13, v14, *(_QWORD *)(a1 + 2048));
  if (AAByteStreamSeek(v11, 0, 2) != *(_QWORD *)(a1 + 2120))
  {
    if (!a3)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 575, 138, "image size mismatch", v15, v16, v17, v150);
    goto LABEL_78;
  }
  v20 = aaSegmentStreamOpen(v11, (_QWORD *)a1);
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 581, 138, 0, "aaSegmentStreamOpen", v18, v19, v150);
LABEL_94:
    v79 = 0;
    v82 = 0;
    v80 = 0;
    v93 = 0;
    v76 = 0;
    goto LABEL_95;
  }
  rawimg_free_chunks((_QWORD *)a1);
  if (*(_QWORD *)(a1 + 2160))
  {
    v26 = 0;
    v160 = a2;
    while (1)
    {
      v27 = *(_QWORD *)(a1 + 2144);
      v28 = v27 + 440 * v26;
      v29 = *(_QWORD *)(v28 + 392) + 0xFFFFLL;
      *(_QWORD *)(v28 + 56) = v29 >> 16;
      v30 = (uint64_t *)(v28 + 56);
      if (v29 >= 0x2AAAAAAAB0000)
      {
        *__error() = 12;
        *(_QWORD *)(v27 + 440 * v26 + 384) = 0;
LABEL_102:
        v117 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 307, 138, *v117, "aaCalloc", v118, v119, v150);
        v55 = 0;
        goto LABEL_92;
      }
      v31 = calloc(v29 >> 16, 0xCuLL);
      v34 = v27 + 440 * v26;
      *(_QWORD *)(v34 + 384) = v31;
      if (!v31)
        goto LABEL_102;
      v35 = (_QWORD **)(v34 + 384);
      v36 = *v30;
      v164 = v27;
      if (*(_BYTE *)(v27 + 440 * v26 + 432) == 4)
      {
        v156 = a3;
        v158 = v11;
        v162 = v26;
        v37 = (_QWORD *)(v27 + 440 * v26);
        v38 = v37[5];
        v152 = v35;
        v154 = v37[50];
        v37[51] |= 4uLL;
        if (v20[4])
        {
          v39 = 0;
          v40 = 8 * v36;
          v151 = 8 * v36 + 264;
          v41 = v38 + 264;
          v42 = v27 + 440 * v26 + 64;
          v43 = v38;
          v44 = 264;
          while (1)
          {
            v45 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v42, v44, v43);
            if (v45 < 0)
              break;
            if (v45)
            {
              v42 += v45;
              v39 += v45;
              v43 += v45;
              v44 -= v45;
              if (v44)
                continue;
            }
            if (v39 != 264)
              break;
            if (v20[4])
            {
              v46 = 0;
              v47 = v164 + 440 * v162 + 328;
              v48 = v38 + v154 - 50;
              v49 = 50;
              while (1)
              {
                v50 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v47, v49, v48);
                if (v50 < 0)
                  break;
                if (v50)
                {
                  v47 += v50;
                  v46 += v50;
                  v48 += v50;
                  v49 -= v50;
                  if (v49)
                    continue;
                }
                if (v46 != 50)
                  break;
                if (v40 >= 0x2000000001)
                {
                  v55 = 0;
                  *__error() = 12;
                  goto LABEL_91;
                }
                v51 = (int *)malloc(v40);
                v55 = v51;
                if (!v51)
                  goto LABEL_91;
                if (!v20[4])
                  goto LABEL_111;
                if (v40)
                {
                  v56 = 0;
                  v57 = (char *)v51;
                  v58 = v40;
                  while (1)
                  {
                    v59 = ((uint64_t (*)(uint64_t *, char *, size_t, uint64_t))v20[4])(*v20, v57, v58, v41);
                    if (v59 < 0)
                      break;
                    if (v59)
                    {
                      v57 += v59;
                      v56 += v59;
                      v41 += v59;
                      v58 -= v59;
                      if (v58)
                        continue;
                    }
                    goto LABEL_42;
                  }
                  v56 = v59;
LABEL_42:
                  if (v40 != v56)
                  {
LABEL_111:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 333, 138, 0, "fork chunks", v53, v54, v150);
                    goto LABEL_91;
                  }
                }
                v61 = *v30;
                v62 = *v152;
                if (!*v30)
                {
                  v63 = 50;
                  v60 = v151;
                  v67 = v151;
                  v11 = v158;
                  a3 = v156;
                  v26 = v162;
                  goto LABEL_53;
                }
                v68 = v62 + 1;
                v69 = v55 + 1;
                v70 = *v30;
                v11 = v158;
                v26 = v162;
                v60 = v151;
                do
                {
                  *((_QWORD *)v68 - 1) = (*(v69 - 1) + 260);
                  v71 = *v69;
                  v69 += 2;
                  *v68 = v71;
                  v68 += 3;
                  --v70;
                }
                while (v70);
                v63 = 50;
                a3 = v156;
                goto LABEL_47;
              }
            }
            v105 = "fork footer";
            v106 = 328;
            goto LABEL_90;
          }
        }
        v105 = "fork header";
        v106 = 325;
LABEL_90:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v106, 138, 0, v105, v32, v33, v150);
        v55 = 0;
LABEL_91:
        v11 = v158;
        a3 = v156;
        goto LABEL_92;
      }
      v60 = 4 * v36 + 4;
      if (v60 >= 0x2000000001)
      {
        v55 = 0;
        *__error() = 12;
        goto LABEL_92;
      }
      v55 = (int *)malloc(v60);
      if (!v55)
        goto LABEL_92;
      if (v60 != AAByteStreamPRead((AAByteStream)v20, v55, v60, *(_QWORD *)(v164 + 440 * v26 + 40)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 351, 138, 0, "fork chunks", v53, v54, v150);
        goto LABEL_92;
      }
      v61 = *v30;
      v62 = *v35;
      v63 = 0;
      if (*v30)
      {
        v64 = v62 + 1;
        do
        {
          v65 = (unsigned int *)&v55[v63];
          v66 = *v65;
          *((_QWORD *)v64 - 1) = v66;
          ++v63;
          *v64 = v65[1] - v66;
          v64 += 3;
        }
        while (v61 != v63);
        v63 = 0;
LABEL_47:
        v72 = (unsigned int *)(v62 + 1);
        v67 = v60;
        while (1)
        {
          v73 = *((_QWORD *)v72 - 1);
          if (v73 < v67)
            break;
          v67 = v73 + *v72;
          if (v67 > *(_QWORD *)(v164 + 440 * v26 + 400))
            break;
          v72 += 3;
          if (!--v61)
            goto LABEL_53;
        }
        if (!a3)
        {
          v103 = "bad chunk";
          v104 = 372;
LABEL_82:
          pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v104, 138, v103, v52, v53, v54, v150);
          goto LABEL_92;
        }
        goto LABEL_92;
      }
      v67 = v60;
LABEL_53:
      if (*v62 != v60 || v67 + v63 != *(_QWORD *)(v164 + 440 * v26 + 400))
        break;
      free(v55);
      ++v26;
      a2 = v160;
      if (v26 >= *(_QWORD *)(a1 + 2160))
        goto LABEL_56;
    }
    if (!a3)
    {
      v103 = "bad index";
      v104 = 381;
      goto LABEL_82;
    }
LABEL_92:
    free(v55);
    rawimg_free_chunks((_QWORD *)a1);
    if (!a3)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 587, 138, "bad chunk info", v110, v111, v112, v150);
    goto LABEL_94;
  }
LABEL_56:
  *(_QWORD *)(a1 + 2128) |= 8uLL;
  v76 = aaForkInputStreamOpen(v20, a1, 1, v21, v22, v23, v24, v25);
  if (!v76)
  {
    v107 = "aaForkInputStreamOpen";
    v108 = 593;
    v109 = 0;
LABEL_87:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v108, 138, v109, v107, v74, v75, v150);
    v79 = 0;
    v82 = 0;
    v80 = 0;
LABEL_88:
    v93 = 0;
    goto LABEL_95;
  }
  v77 = *(_QWORD *)(a1 + 2160) + ((unint64_t)(*(_QWORD *)(a1 + 2080) + 0x7FFFFFLL) >> 23);
  if (!is_mul_ok(v77, 0x38uLL) || 56 * v77 > 0x2000000000)
  {
    *__error() = 12;
    goto LABEL_86;
  }
  v78 = calloc(*(_QWORD *)(a1 + 2160) + ((unint64_t)(*(_QWORD *)(a1 + 2080) + 0x7FFFFFLL) >> 23), 0x38uLL);
  if (!v78)
  {
LABEL_86:
    v109 = *__error();
    v107 = "aaCalloc";
    v108 = 601;
    goto LABEL_87;
  }
  v79 = v78;
  if (a2 < 0)
  {
    *__error() = 12;
    v80 = 0;
    v82 = 0;
    *__error() = 12;
LABEL_104:
    v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 606, 138, *v120, "aaCalloc", v121, v122, v150);
    goto LABEL_88;
  }
  v80 = (uint64_t **)calloc(a2, 0x10uLL);
  v81 = calloc(a2, 8uLL);
  v82 = v81;
  if (!v80 || !v81)
    goto LABEL_104;
  if (a2)
  {
    v83 = a2;
    v84 = v80;
    v85 = (uint64_t ***)v81;
    do
    {
      *v85++ = v84;
      *v84 = v76;
      v84 += 2;
      --v83;
    }
    while (v83);
  }
  v93 = ThreadPoolCreate(a2, (uint64_t)v81, (uint64_t)rawimg_digest_worker);
  if (!v93)
  {
    v123 = "ThreadPoolCreate";
    v124 = 613;
    goto LABEL_110;
  }
  v153 = v77;
  v159 = v11;
  v94 = *(_QWORD *)(a1 + 2056);
  if (v94 < *(_QWORD *)(a1 + 2072))
  {
    v165 = 0;
    v95 = -(uint64_t)v94;
    v96 = v79;
    while (1)
    {
      Worker = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
      if (!Worker)
      {
        v143 = "ThreadPoolGetWorker";
        v144 = 622;
        goto LABEL_133;
      }
      *(_QWORD *)(Worker + 8) = v96;
      v96[6] = -1;
      v96[4] = v94;
      v102 = v95 + *(_QWORD *)(a1 + 2072);
      if (v102 >= 0x800000)
        v102 = 0x800000;
      v96[5] = v102;
      if ((ThreadPoolRunWorker((uint64_t)v93, Worker, v98, v99, v100, v101, v91, v92) & 0x80000000) != 0)
        break;
      ++v165;
      v94 += 0x800000;
      v95 -= 0x800000;
      v96 += 7;
      if (v94 >= *(_QWORD *)(a1 + 2072))
        goto LABEL_113;
    }
    v143 = "ThreadPoolRunWorker";
    v144 = 627;
    goto LABEL_133;
  }
  v165 = 0;
LABEL_113:
  v125 = *(_QWORD *)(a1 + 2160);
  if (!v125)
  {
    v11 = v159;
    v127 = v153;
    v128 = v165;
LABEL_127:
    if (v128 <= v127)
    {
      if ((ThreadPoolSync(v93) & 0x80000000) == 0)
      {
        qsort(v79, v128, 0x38uLL, (int (__cdecl *)(const void *, const void *))compare_digest_tasks);
        CC_SHA256_Init(&c);
        if (v128)
        {
          v145 = (char *)v79;
          do
          {
            CC_SHA256_Update(&c, v145, 0x20u);
            v145 += 56;
            --v128;
          }
          while (v128);
        }
        CC_SHA256_Final((unsigned __int8 *)(a1 + 2088), &c);
        if (*(_QWORD *)(a1 + 2160))
        {
          v146 = 0;
          v147 = 0;
          do
          {
            CC_SHA256_Init(&c);
            if (v79[7 * v146 + 6] == v147)
            {
              v148 = &v79[7 * v146];
              do
              {
                CC_SHA256_Update(&c, v148, 0x20u);
                ++v146;
                v149 = v148[13];
                v148 += 7;
              }
              while (v149 == v147);
            }
            CC_SHA256_Final((unsigned __int8 *)(*(_QWORD *)(a1 + 2144) + 440 * v147++), &c);
          }
          while (v147 < *(_QWORD *)(a1 + 2160));
        }
        *(_QWORD *)(a1 + 2128) |= 0x10uLL;
        v113 = 1;
        goto LABEL_134;
      }
      v123 = "ThreadPoolSync";
      v124 = 655;
    }
    else
    {
      v123 = "too many tasks";
      v124 = 649;
    }
LABEL_110:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v124, 138, 0, v123, v91, v92, v150);
    goto LABEL_95;
  }
  v126 = 0;
  v11 = v159;
  v127 = v153;
  v128 = v165;
  while (1)
  {
    v129 = *(_QWORD *)(a1 + 2144);
    v130 = v129 + 440 * v126;
    if (*(_QWORD *)(v130 + 392))
      break;
LABEL_123:
    if (++v126 >= v125)
      goto LABEL_127;
  }
  v131 = 0;
  v132 = 0;
  v133 = (_QWORD *)(v130 + 392);
  v161 = v126;
  v155 = v133;
  v157 = (_QWORD *)(v129 + 440 * v126 + 48);
  v166 = v128;
  v134 = &v79[7 * v128];
  while (1)
  {
    v163 = v131;
    v135 = v132;
    v136 = v133;
    v137 = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
    if (!v137)
    {
      v143 = "ThreadPoolGetWorker";
      v144 = 641;
      goto LABEL_133;
    }
    *(_QWORD *)(v137 + 8) = v134;
    v134[6] = v161;
    v134[4] = v135 + *v157;
    v142 = v163 + *v136;
    if (v142 >= 0x800000)
      v142 = 0x800000;
    v134[5] = v142;
    if ((ThreadPoolRunWorker((uint64_t)v93, v137, v138, v139, v140, v141, v91, v92) & 0x80000000) != 0)
      break;
    ++v166;
    v133 = v155;
    v131 = v163 - 0x800000;
    v134 += 7;
    v132 = v135 + 0x800000;
    if ((unint64_t)(v135 + 0x800000) >= *v155)
    {
      v125 = *(_QWORD *)(a1 + 2160);
      v11 = v159;
      v126 = v161;
      v127 = v153;
      v128 = v166;
      goto LABEL_123;
    }
  }
  v143 = "ThreadPoolRunWorker";
  v144 = 646;
LABEL_133:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v144, 138, 0, v143, v91, v92, v150);
  v113 = 0;
LABEL_134:
  v11 = v159;
LABEL_96:
  if ((ThreadPoolDestroy((uint64_t)v93) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 683, 138, 0, "ThreadPoolDestroy", v114, v115, v150);
    v113 = 0;
  }
  free(v80);
  free(v82);
  free(v79);
  AAByteStreamClose((AAByteStream)v76);
  AAByteStreamClose((AAByteStream)v20);
  AAByteStreamClose(v11);
  if (v113)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void rawimg_free_chunks(_QWORD *a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (a1[270])
  {
    v2 = 0;
    v3 = 384;
    do
    {
      v4 = a1[268] + v3;
      free(*(void **)v4);
      *(_QWORD *)v4 = 0;
      *(_QWORD *)(v4 - 328) = 0;
      *(_QWORD *)(v4 + 24) &= ~4uLL;
      ++v2;
      v3 += 440;
    }
    while (v2 < a1[270]);
  }
  a1[266] &= ~8uLL;
}

uint64_t rawimg_digest_worker(_QWORD *a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const char *v18;
  __int16 v19;
  CC_SHA256_CTX v21;

  v2 = a1[1];
  memset(&v21, 0, sizeof(v21));
  v3 = (char *)malloc(0x10000uLL);
  if (!v3)
  {
    v17 = *__error();
    v18 = "aaMalloc";
    v19 = 530;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_digest_worker", v19, 138, v17, v18, v4, v5, v21.count[0]);
    v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  CC_SHA256_Init(&v21);
  v6 = *(_QWORD *)(v2 + 40);
  if (v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = v6 - v7;
      v9 = v8 >= 0x10000 ? 0x10000 : v8;
      v10 = *a1;
      if (!*(_QWORD *)(*a1 + 32))
        break;
      if (v9)
      {
        v11 = 0;
        v12 = *(_QWORD *)(v2 + 32) + v7;
        v13 = v3;
        v14 = v9;
        while (1)
        {
          v15 = (*(uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))(v10 + 32))(*(_QWORD *)v10, v13, v14, v12);
          if (v15 < 0)
            break;
          if (v15)
          {
            v13 += v15;
            v11 += v15;
            v12 += v15;
            v14 -= v15;
            if (v14)
              continue;
          }
          goto LABEL_15;
        }
        v11 = v15;
LABEL_15:
        if (v9 != v11)
          break;
      }
      CC_SHA256_Update(&v21, v3, v9);
      v7 += 0x10000;
      v6 = *(_QWORD *)(v2 + 40);
      if (v7 >= v6)
        goto LABEL_17;
    }
    v18 = "aaByteStreamPReadExpected";
    v19 = 537;
    v17 = 0;
    goto LABEL_20;
  }
LABEL_17:
  CC_SHA256_Final((unsigned __int8 *)v2, &v21);
  v16 = 0;
LABEL_21:
  free(v3);
  return v16;
}

uint64_t compare_digest_tasks(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a2 + 48);
  v4 = v2 >= v3;
  if (v2 == v3)
    v4 = *(_QWORD *)(a1 + 32) >= *(_QWORD *)(a2 + 32);
  if (!v4)
    return 0xFFFFFFFFLL;
  else
    return 1;
}

uint64_t rawimg_set_fork_types(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  const char *v30;
  __int16 v31;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  if (a2 >= 0x21)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", 751, 138, 0, "too many variants", a7, a8, v41);
    v8 = 0;
    goto LABEL_33;
  }
  if (a2 != 1)
  {
    v8 = pc_array_init(16);
    if (v8)
    {
      if (!a2)
      {
LABEL_18:
        pc_array_sort(v8, (int (__cdecl *)(const void *, const void *))compare_copy_fork_5);
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_4, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        v24 = *(v8 - 8);
        if (v24)
        {
          v25 = v8 + 1;
          do
          {
            if ((*v25 & 1) == 0)
              *(_QWORD *)(*((_QWORD *)v25 - 1) + 408) |= 1uLL;
            v25 += 16;
            --v24;
          }
          while (v24);
        }
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_3, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        v26 = *(v8 - 8);
        if (v26)
        {
          v27 = 0;
          v28 = 0;
          v29 = v8 + 1;
          do
          {
            if (*v29 == ~(-1 << a2))
            {
              *(_OWORD *)&v8[2 * v28++] = *(_OWORD *)(v29 - 2);
              v26 = *(v8 - 8);
            }
            ++v27;
            v29 += 4;
          }
          while (v27 < v26);
        }
        else
        {
          v28 = 0;
        }
        *(v8 - 8) = v28;
        if (a2)
        {
          v33 = 0;
          do
          {
            v34 = *(_QWORD *)(a1 + 8 * v33);
            if (*(_QWORD *)(v34 + 2160))
            {
              v35 = 0;
              v36 = 408;
              do
              {
                v37 = *(_QWORD *)(v34 + 2144);
                v41 = v37 + v36 - 408;
                v42 = 0;
                v38 = bsearch(&v41, v8, *(v8 - 8), 0x10uLL, (int (__cdecl *)(const void *, const void *))compare_copy_fork_3);
                if (v38)
                  v39 = 1;
                else
                  v39 = v33 == 0;
                if (v39)
                {
                  if (v38)
                    v40 = 2;
                  else
                    v40 = 1;
                  *(_QWORD *)(v37 + v36) |= v40;
                }
                ++v35;
                v36 += 440;
              }
              while (v35 < *(_QWORD *)(v34 + 2160));
            }
            ++v33;
          }
          while (v33 != a2);
        }
        v13 = 0;
        goto LABEL_34;
      }
      v20 = 0;
      while (1)
      {
        v21 = *(_QWORD *)(a1 + 8 * v20);
        if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0)
        {
          v30 = "no digests found";
          v31 = 778;
          goto LABEL_32;
        }
        if (*(_QWORD *)(v21 + 2160))
          break;
LABEL_17:
        if (++v20 == a2)
          goto LABEL_18;
      }
      v22 = 0;
      v23 = 0;
      while (1)
      {
        v41 = *(_QWORD *)(v21 + 2144) + v22;
        v42 = (1 << v20);
        if ((*(_BYTE *)(v41 + 408) & 3) != 0)
        {
          v30 = "bad flags";
          v31 = 789;
          goto LABEL_32;
        }
        v8 = pc_array_append((uint64_t)v8, &v41, v14, v15, v16, v17, v18, v19);
        if (!v8)
          break;
        ++v23;
        v22 += 440;
        if (v23 >= *(_QWORD *)(v21 + 2160))
          goto LABEL_17;
      }
      v30 = "pc_array_append";
      v31 = 793;
    }
    else
    {
      v30 = "pc_array_init";
      v31 = 771;
    }
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", v31, 138, 0, v30, v18, v19, v41);
LABEL_33:
    v13 = 0xFFFFFFFFLL;
LABEL_34:
    pc_array_free((uint64_t)v8);
    return v13;
  }
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 2160);
  if (v11)
  {
    v12 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)a1 + 2144) + 408);
    do
    {
      *v12 = *v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v12 += 55;
      --v11;
    }
    while (v11);
  }
  return 0;
}

uint64_t compare_copy_fork_5(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;

  result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result)
  {
    v5 = *(_DWORD *)(a1 + 8);
    v6 = *(_DWORD *)(a2 + 8);
    result = (v5 - v6);
    if (v5 == v6)
    {
      if (*(_QWORD *)(*(_QWORD *)a1 + 416) < *(_QWORD *)(*(_QWORD *)a2 + 416))
        return 0xFFFFFFFFLL;
      else
        return 1;
    }
  }
  return result;
}

uint64_t compare_copy_fork_4(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result)
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  return result;
}

uint64_t aggregate_copy_fork(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) |= *(_DWORD *)(a2 + 8);
  return 0;
}

uint64_t compare_copy_fork_3(unint64_t **a1, unint64_t **a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;

  v2 = *a1;
  v3 = *a2;
  v4 = bswap64(**a1);
  v5 = bswap64(**a2);
  if (v4 == v5
    && (v4 = bswap64(v2[1]), v5 = bswap64(v3[1]), v4 == v5)
    && (v4 = bswap64(v2[2]), v5 = bswap64(v3[2]), v4 == v5)
    && (v4 = bswap64(v2[3]), v5 = bswap64(v3[3]), v4 == v5))
  {
    v7 = v2[50] - v3[50];
    if (v7)
    {
      if (v7 < 0)
        return 0xFFFFFFFFLL;
      else
        return 1;
    }
    else
    {
      return *((unsigned __int8 *)v2 + 432) - *((unsigned __int8 *)v3 + 432);
    }
  }
  else if (v4 < v5)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t rawimg_save_to_stream(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  __int16 v10;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  __n128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  __n128 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __n128 v48;
  _OWORD v49[2];
  _OWORD v50[2];
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a2 + 2128);
  if ((v8 & 0x10) != 0)
  {
    if ((v8 & 8) != 0)
    {
      v14 = *(_OWORD *)(a2 + 2104);
      v50[0] = *(_OWORD *)(a2 + 2088);
      v50[1] = v14;
      v15 = 24;
      if (!a3)
        v15 = 16;
      v51 = *(_QWORD *)(a2 + 2120);
      v52 = v15;
      v53 = *(_OWORD *)(a2 + 2152);
      if (a1[3])
      {
        v16 = 0;
        v17 = v50;
        v18 = 64;
        while (1)
        {
          v19 = ((uint64_t (*)(_QWORD, _OWORD *, uint64_t))a1[3])(*a1, v17, v18);
          if (v19 < 1)
            break;
          v17 = (_OWORD *)((char *)v17 + v19);
          v16 += v19;
          v18 -= v19;
          if (!v18)
          {
            if (v16 != 64)
              break;
            if (!a1[3])
              goto LABEL_55;
            v20 = 16 * v53;
            if (16 * (_QWORD)v53)
            {
              v21 = 0;
              v22 = *(_QWORD *)(a2 + 2136);
              v23 = 16 * v53;
              while (1)
              {
                v24 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[3])(*a1, v22, v23);
                if (v24 < 1)
                  break;
                v22 += v24;
                v21 += v24;
                v23 -= v24;
                if (!v23)
                  goto LABEL_21;
              }
              v21 = v24;
LABEL_21:
              if (v20 != v21)
              {
LABEL_55:
                v9 = "aaByteStreamWriteExpected";
                v10 = 893;
                goto LABEL_19;
              }
            }
            if (!*((_QWORD *)&v53 + 1))
              return 0;
            v26 = 0;
            v27 = 0uLL;
LABEL_24:
            v28 = *(_QWORD *)(a2 + 2144);
            *(__n128 *)((char *)v49 + 9) = v27;
            v48 = v27;
            v49[0] = v27;
            v29 = v28 + 440 * v26;
            v48 = *(__n128 *)(v29 + 392);
            v30 = *(_OWORD *)(v29 + 408);
            v49[0] = v30;
            *(_QWORD *)&v49[1] = *(_QWORD *)(v29 + 424);
            BYTE8(v49[1]) = *(_BYTE *)(v29 + 432);
            if ((v30 & 1) == 0)
              *(_QWORD *)&v49[0] = v30 & 0xFFFFFFFFFFFFFFFBLL;
            if (a1[3])
            {
              v31 = 0;
              v32 = &v48;
              v33 = 41;
              while (1)
              {
                v34 = ((uint64_t (*)(_QWORD, __n128 *, uint64_t))a1[3])(*a1, v32, v33);
                if (v34 < 1)
                  break;
                v32 = (__n128 *)((char *)v32 + v34);
                v31 += v34;
                v33 -= v34;
                if (!v33)
                {
                  if (v31 != 41)
                    break;
                  v27 = 0uLL;
                  if (a3 && (v49[0] & 1) != 0)
                  {
                    if (!a1[3])
                      goto LABEL_60;
                    v35 = 12 * *(_QWORD *)(v28 + 440 * v26 + 56);
                    if (v35)
                    {
                      v36 = 0;
                      v37 = *(_QWORD *)(v28 + 440 * v26 + 384);
                      v38 = 12 * *(_QWORD *)(v28 + 440 * v26 + 56);
                      while (1)
                      {
                        v39 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, __n128))a1[3])(*a1, v37, v38, v27);
                        if (v39 < 1)
                          break;
                        v37 += v39;
                        v36 += v39;
                        v38 -= v39;
                        if (!v38)
                          goto LABEL_40;
                      }
                      v36 = v39;
LABEL_40:
                      v27 = 0uLL;
                      if (v35 != v36)
                      {
LABEL_60:
                        v10 = 925;
                        goto LABEL_57;
                      }
                    }
                    if ((v49[0] & 4) != 0)
                    {
                      if (a1[3])
                      {
                        v40 = 0;
                        v41 = v28 + 440 * v26 + 64;
                        v42 = 264;
                        while (1)
                        {
                          v43 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, __n128))a1[3])(*a1, v41, v42, v27);
                          if (v43 < 1)
                            break;
                          v41 += v43;
                          v40 += v43;
                          v42 -= v43;
                          if (!v42)
                          {
                            if (v40 != 264)
                              break;
                            if (a1[3])
                            {
                              v44 = 0;
                              v45 = v28 + 440 * v26 + 328;
                              v46 = 50;
                              while (1)
                              {
                                v47 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[3])(*a1, v45, v46);
                                if (v47 < 1)
                                  break;
                                v45 += v47;
                                v44 += v47;
                                v46 -= v47;
                                if (!v46)
                                {
                                  v27 = 0uLL;
                                  if (v44 == 50)
                                    goto LABEL_42;
                                  break;
                                }
                              }
                            }
                            v10 = 934;
                            goto LABEL_57;
                          }
                        }
                      }
                      v10 = 932;
                      goto LABEL_57;
                    }
                  }
LABEL_42:
                  result = 0;
                  if ((unint64_t)++v26 < *((_QWORD *)&v53 + 1))
                    goto LABEL_24;
                  return result;
                }
              }
            }
            v10 = 917;
LABEL_57:
            v9 = "aaByteStreamWriteExpected";
            goto LABEL_19;
          }
        }
      }
      v9 = "aaByteStreamWriteExpected";
      v10 = 888;
    }
    else
    {
      v9 = "no chunk info";
      v10 = 877;
    }
  }
  else
  {
    v9 = "no digest info";
    v10 = 876;
  }
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_save_to_stream", v10, 138, 0, v9, a7, a8, v48.n128_i8[0]);
  return 0xFFFFFFFFLL;
}

char *rawimg_create_with_stream(_QWORD *a1, int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  int v29;
  unint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  __int128 *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  char v41;
  size_t v42;
  uint64_t v43;
  _QWORD *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 v59;
  _BYTE v60[25];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v4 = (char *)calloc(1uLL, 0x878uLL);
  v7 = v4;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  if (!v4)
  {
    v29 = *__error();
    v27 = "aaCalloc";
    v28 = 953;
    goto LABEL_20;
  }
  if (!a1[2])
    goto LABEL_17;
  v8 = 0;
  v9 = v4 + 2120;
  v10 = &v61;
  v11 = 64;
  do
  {
    v12 = ((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[2])(*a1, v10, v11);
    if (v12 < 0)
      goto LABEL_17;
    if (!v12)
      break;
    v10 = (__int128 *)((char *)v10 + v12);
    v8 += v12;
    v11 -= v12;
  }
  while (v11);
  if (v8 == 64)
  {
    v13 = v62;
    *(_OWORD *)(v7 + 2088) = v61;
    *(_OWORD *)(v7 + 2104) = v13;
    v14 = v64;
    *v9 = v63;
    *(_OWORD *)(v7 + 2152) = v14;
    *((_QWORD *)v7 + 267) = pc_array_init(16, v14);
    v15 = pc_array_init(440, *((_QWORD *)v7 + 270));
    *((_QWORD *)v7 + 268) = v15;
    v21 = *((_QWORD *)v7 + 267);
    if (v21 && v15)
    {
      v22 = *((_QWORD *)v7 + 269);
      *(_QWORD *)(v21 - 64) = v22;
      *(v15 - 8) = *((_QWORD *)v7 + 270);
      if (!a1[2])
        goto LABEL_62;
      v23 = 16 * v22;
      if (!(16 * v22))
        goto LABEL_25;
      v24 = 0;
      v25 = 16 * v22;
      while (1)
      {
        v26 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v21, v25);
        if (v26 < 0)
          break;
        if (v26)
        {
          v21 += v26;
          v24 += v26;
          v25 -= v26;
          if (v25)
            continue;
        }
        goto LABEL_24;
      }
      v24 = v26;
LABEL_24:
      if (v23 == v24)
      {
LABEL_25:
        if (!*((_QWORD *)&v64 + 1))
        {
LABEL_60:
          if ((rawimg_verify(v7, v16, v17, v18, v19, v20, v5, v6) & 0x80000000) == 0)
            return v7;
          v27 = "rawimg_verify";
          v28 = 1023;
          goto LABEL_18;
        }
        v31 = 0;
        v32 = 0uLL;
        while (2)
        {
          v33 = *((_QWORD *)v7 + 268);
          *(_OWORD *)&v60[9] = v32;
          v59 = v32;
          *(_OWORD *)v60 = v32;
          if (a1[2])
          {
            v34 = 0;
            v35 = &v59;
            v36 = 41;
            do
            {
              v37 = ((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[2])(*a1, v35, v36);
              if (v37 < 0)
                goto LABEL_63;
              if (!v37)
                break;
              v35 = (__int128 *)((char *)v35 + v37);
              v34 += v37;
              v36 -= v37;
            }
            while (v36);
            if (v34 != 41)
              break;
            v38 = v33 + 440 * v31;
            *(_QWORD *)(v38 + 432) = 0;
            *(_OWORD *)(v38 + 400) = 0u;
            *(_OWORD *)(v38 + 416) = 0u;
            *(_OWORD *)(v38 + 368) = 0u;
            *(_OWORD *)(v38 + 384) = 0u;
            *(_OWORD *)(v38 + 336) = 0u;
            *(_OWORD *)(v38 + 352) = 0u;
            *(_OWORD *)(v38 + 304) = 0u;
            *(_OWORD *)(v38 + 320) = 0u;
            *(_OWORD *)(v38 + 272) = 0u;
            *(_OWORD *)(v38 + 288) = 0u;
            *(_OWORD *)(v38 + 240) = 0u;
            *(_OWORD *)(v38 + 256) = 0u;
            *(_OWORD *)(v38 + 208) = 0u;
            *(_OWORD *)(v38 + 224) = 0u;
            *(_OWORD *)(v38 + 176) = 0u;
            *(_OWORD *)(v38 + 192) = 0u;
            *(_OWORD *)(v38 + 144) = 0u;
            *(_OWORD *)(v38 + 160) = 0u;
            *(_OWORD *)(v38 + 112) = 0u;
            *(_OWORD *)(v38 + 128) = 0u;
            *(_OWORD *)(v38 + 80) = 0u;
            *(_OWORD *)(v38 + 96) = 0u;
            *(_OWORD *)(v38 + 48) = 0u;
            *(_OWORD *)(v38 + 64) = 0u;
            *(_OWORD *)(v38 + 16) = 0u;
            *(_OWORD *)(v38 + 32) = 0u;
            *(_OWORD *)v38 = 0u;
            v39 = v59;
            *(_OWORD *)(v38 + 392) = v59;
            v40 = (_BYTE *)(v38 + 408);
            v41 = v60[0];
            *(_OWORD *)(v38 + 408) = *(_OWORD *)v60;
            *(_QWORD *)(v38 + 424) = *(_QWORD *)&v60[16];
            *(_BYTE *)(v38 + 432) = v60[24];
            if (a2 && (v41 & 1) != 0)
            {
              v42 = (unint64_t)(v39 + 0xFFFF) >> 16;
              v43 = v33 + 440 * v31;
              *(_QWORD *)(v43 + 56) = v42;
              v44 = (_QWORD *)(v43 + 56);
              if ((unint64_t)(v39 + 0xFFFF) >= 0x2AAAAAAAB0000)
              {
                *__error() = 12;
                *(_QWORD *)(v33 + 440 * v31 + 384) = 0;
              }
              else
              {
                v45 = (char *)calloc(v42, 0xCuLL);
                *(_QWORD *)(v33 + 440 * v31 + 384) = v45;
                if (v45)
                {
                  if (!a1[2])
                    goto LABEL_66;
                  v46 = 12 * *v44;
                  if (v46)
                  {
                    v47 = v45;
                    v48 = 0;
                    v49 = 12 * *v44;
                    while (1)
                    {
                      v50 = ((uint64_t (*)(_QWORD, char *, uint64_t))a1[2])(*a1, v47, v49);
                      if (v50 < 0)
                        break;
                      if (v50)
                      {
                        v47 += v50;
                        v48 += v50;
                        v49 -= v50;
                        if (v49)
                          continue;
                      }
                      goto LABEL_45;
                    }
                    v48 = v50;
LABEL_45:
                    if (v46 != v48)
                    {
LABEL_66:
                      v27 = "aaByteStreamReadExpected";
                      v28 = 1008;
                      goto LABEL_18;
                    }
                  }
                  if ((*v40 & 4) != 0)
                  {
                    if (a1[2])
                    {
                      v51 = 0;
                      v52 = v33 + 440 * v31 + 64;
                      v53 = 264;
                      while (1)
                      {
                        v54 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v52, v53);
                        if (v54 < 0)
                          break;
                        if (v54)
                        {
                          v52 += v54;
                          v51 += v54;
                          v53 -= v54;
                          if (v53)
                            continue;
                        }
                        if (v51 != 264)
                          break;
                        if (a1[2])
                        {
                          v55 = 0;
                          v56 = v33 + 440 * v31 + 328;
                          v57 = 50;
                          while (1)
                          {
                            v58 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v56, v57);
                            if (v58 < 0)
                              break;
                            if (v58)
                            {
                              v56 += v58;
                              v55 += v58;
                              v57 -= v58;
                              if (v57)
                                continue;
                            }
                            if (v55 != 50)
                              break;
                            goto LABEL_59;
                          }
                        }
                        v27 = "aaByteStreamReadExpected";
                        v28 = 1017;
                        goto LABEL_18;
                      }
                    }
                    v27 = "aaByteStreamReadExpected";
                    v28 = 1015;
                    goto LABEL_18;
                  }
                  goto LABEL_59;
                }
              }
              v29 = *__error();
              v27 = "aaCalloc";
              v28 = 1003;
              goto LABEL_20;
            }
LABEL_59:
            ++v31;
            v32 = 0uLL;
            if (v31 < *((_QWORD *)&v64 + 1))
              continue;
            goto LABEL_60;
          }
          break;
        }
LABEL_63:
        v27 = "aaByteStreamReadExpected";
        v28 = 986;
      }
      else
      {
LABEL_62:
        v27 = "aaByteStreamReadExpected";
        v28 = 976;
      }
    }
    else
    {
      v27 = "pc_array_init";
      v28 = 969;
    }
  }
  else
  {
LABEL_17:
    v27 = "aaByteStreamReadExpected";
    v28 = 957;
  }
LABEL_18:
  v29 = 0;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_stream", v28, 138, v29, v27, v5, v6, v59);
  rawimg_destroy((uint64_t *)v7);
  return 0;
}

uint64_t compare_forks_by_extent(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 416);
  v3 = *(_QWORD *)(a2 + 416);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aggregate_identical_forks(const void *a1, const void *a2)
{
  if (!memcmp(a1, a2, 0x1B8uLL))
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t compare_forks_by_position(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 2136) + 16 * *(_QWORD *)(a2 + 416)) < *(_QWORD *)(*(_QWORD *)(a1 + 2136)
                                                                                      + 16 * *(_QWORD *)(a3 + 416)))
    return 0xFFFFFFFFLL;
  else
    return 1;
}

uint64_t pc_array_compare(uint64_t (*a1)(_QWORD, _QWORD), _QWORD *a2, _QWORD *a3)
{
  return a1(*a2, *a3);
}

_QWORD *pc_array_init(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(a2 * a1 + 64);
  if (v4)
  {
    *v4 = 0;
    v4[1] = a2;
    v5 = v4 + 8;
    v4[2] = a1;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_init", 26, 139, *v6, "malloc", v7, v8, v10);
    return 0;
  }
  return v5;
}

_QWORD *pc_array_init(uint64_t a1)
{
  return pc_array_init(a1, 8);
}

void pc_array_free(uint64_t a1)
{
  if (a1)
    free((void *)(a1 - 64));
}

char *pc_array_compact(uint64_t a1)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char vars0;

  v3 = *(_QWORD *)(a1 - 64);
  v4 = *(_QWORD *)(a1 - 56);
  v2 = (char *)(a1 - 64);
  if (v4 <= v3)
    return v2 + 64;
  *(_QWORD *)(a1 - 56) = v3;
  v2 = (char *)reallocf(v2, *(_QWORD *)(a1 - 48) * v3 + 64);
  if (v2)
    return v2 + 64;
  v6 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_compact", 56, 139, *v6, "reallocf", v7, v8, vars0);
  return 0;
}

_QWORD *pc_array_append(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  __int16 v18;
  int v19;
  char v21;

  v9 = *(_QWORD *)(a1 - 64);
  v10 = *(_QWORD *)(a1 - 56);
  v11 = (_QWORD *)(a1 - 64);
  if (v10 > v9)
    goto LABEL_7;
  v12 = 2 * v10;
  v13 = v10 == 0;
  v14 = 16;
  if (!v13)
    v14 = v12;
  *(_QWORD *)(a1 - 56) = v14;
  if (v14 <= v9)
  {
    v17 = "too many elements";
    v18 = 70;
    v19 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_append", v18, 139, v19, v17, a7, a8, v21);
    return 0;
  }
  v15 = reallocf((void *)(a1 - 64), *(_QWORD *)(a1 - 48) * v14 + 64);
  if (!v15)
  {
    v19 = *__error();
    v17 = "reallocf";
    v18 = 72;
    goto LABEL_10;
  }
  v11 = v15;
  v9 = *v15;
LABEL_7:
  v16 = v11 + 8;
  memcpy((char *)v11 + v11[2] * v9 + 64, __src, v11[2]);
  ++*v11;
  return v16;
}

void pc_array_sort(void *a1, int (__cdecl *__compar)(const void *, const void *))
{
  qsort(a1, *((_QWORD *)a1 - 8), *((_QWORD *)a1 - 6), __compar);
}

_QWORD *pc_array_indirect_sort(uint64_t a1, void *a2)
{
  uint64_t v3;
  size_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v3 = a1;
  v4 = *(_QWORD *)(a1 - 64);
  v5 = malloc(8 * v4);
  v6 = v5;
  if (v5)
  {
    if (v4)
    {
      v7 = *(_QWORD *)(v3 - 48);
      v8 = v5;
      v9 = v4;
      do
      {
        *v8++ = v3;
        v3 += v7;
        --v9;
      }
      while (v9);
    }
    qsort_r(v5, v4, 8uLL, a2, (int (__cdecl *)(void *, const void *, const void *))pc_array_compare);
  }
  else
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_indirect_sort", 95, 139, *v10, "malloc", v11, v12, v14);
  }
  return v6;
}

uint64_t pc_array_aggregate(char *a1, unsigned int (*a2)(char *, char *), uint64_t (*a3)(char *, char *))
{
  uint64_t result;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;

  if (*((_QWORD *)a1 - 8) < 2uLL)
    return 0;
  v7 = &a1[*((_QWORD *)a1 - 6)];
  v8 = 1;
  v9 = 1;
  v10 = a1;
  while (1)
  {
    if (a2(v10, v7))
    {
      v11 = *((_QWORD *)a1 - 6);
      v10 += v11;
      if (v10 < v7)
        memcpy(v10, v7, v11);
      ++v9;
      goto LABEL_9;
    }
    if ((a3(v10, v7) & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
LABEL_9:
    ++v8;
    v7 += *((_QWORD *)a1 - 6);
    if (v8 >= *((_QWORD *)a1 - 8))
    {
      result = 0;
      *((_QWORD *)a1 - 8) = v9;
      return result;
    }
  }
}

char *PCompressGetEncoderDescription(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return off_24C305AB0[a1];
}

uint64_t PCompressGetEncoderDecoder(uint64_t result)
{
  if (result >= 7)
    return 0xFFFFFFFFLL;
  else
    return result;
}

unint64_t PCompressGetDecoderKey(unsigned int a1)
{
  unint64_t v1;

  v1 = 0x2D62653466787AuLL >> (8 * a1);
  if (a1 >= 7)
    LOBYTE(v1) = 63;
  return v1 & 0x7F;
}

char *PCompressGetDecoderDescription(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return off_24C305AE8[a1];
}

_QWORD *AEADecryptAsyncStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  unsigned int DefaultNThreads;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  _QWORD *result;
  void *v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  char v29;

  DefaultNThreads = a6;
  if (!a6)
    DefaultNThreads = getDefaultNThreads();
  v12 = malloc(0x4A0uLL);
  v13 = (uint64_t)v12;
  if (!v12)
  {
    v18 = *__error();
    v16 = "malloc";
    v17 = 884;
    goto LABEL_8;
  }
  memset_s(v12, 0x4A0uLL, 0, 0x4A0uLL);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 56), 0))
  {
    v16 = "pthread_mutex_init";
    v17 = 885;
LABEL_6:
    v18 = 0;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"AEADecryptAsyncStreamOpen", v17, 114, v18, v16, v14, v15, v29);
    decryptAsyncClose(v13);
    AAAsyncByteStreamClose(0);
    return 0;
  }
  *(_QWORD *)v13 = a1;
  *(_QWORD *)(v13 + 8) = a2;
  *(_QWORD *)(v13 + 16) = a3;
  *(_QWORD *)(v13 + 24) = a4;
  *(_QWORD *)(v13 + 1128) = -1;
  *(_QWORD *)(v13 + 1144) = -1;
  *(_QWORD *)(v13 + 1152) = -1;
  *(_DWORD *)(v13 + 32) = a5 >> 62;
  *(_QWORD *)(v13 + 40) = a5;
  *(_DWORD *)(v13 + 1160) = DefaultNThreads;
  v20 = calloc(DefaultNThreads, 8uLL);
  *(_QWORD *)(v13 + 1168) = v20;
  if (!v20)
  {
    v18 = *__error();
    v16 = "malloc";
    v17 = 899;
    goto LABEL_8;
  }
  if (*(_DWORD *)(v13 + 1160))
  {
    v21 = 0;
    while (1)
    {
      v22 = (uint64_t *)malloc(0x468uLL);
      v23 = v22;
      if (v22)
      {
        memset_s(v22, 0x468uLL, 0, 0x468uLL);
        *v23 = v13;
      }
      else
      {
        v24 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerAlloc", 129, 114, *v24, "malloc", v25, v26, v29);
      }
      *(_QWORD *)(*(_QWORD *)(v13 + 1168) + 8 * v21) = v23;
      v27 = *(_QWORD *)(v13 + 1168);
      if (!*(_QWORD *)(v27 + 8 * v21))
        break;
      ++v21;
      v20 = (void *)*(unsigned int *)(v13 + 1160);
      if (v21 >= (unint64_t)v20)
        goto LABEL_20;
    }
    v16 = "Worker alloc";
    v17 = 903;
    goto LABEL_6;
  }
  v27 = (uint64_t)v20;
  LODWORD(v20) = 0;
LABEL_20:
  v28 = ThreadPoolCreate(v20, v27, (uint64_t)workerProc);
  *(_QWORD *)(v13 + 1176) = v28;
  if (!v28)
  {
    v16 = "creating worker pool";
    v17 = 906;
    goto LABEL_6;
  }
  *(_DWORD *)(v13 + 52) = 0;
  if (pushRange((_QWORD *)v13, 12))
  {
    v16 = "add range";
    v17 = 910;
    goto LABEL_6;
  }
  *(_QWORD *)(v13 + 1128) = 0;
  result = aaAsyncByteStreamAlloc(v13, (uint64_t)decryptAsyncClose, ~(a5 >> 55) & 4, 20.0, 1.0);
  if (!result)
  {
    v18 = *__error();
    v16 = "malloc";
    v17 = 921;
    goto LABEL_8;
  }
  result[2] = decryptAsyncGetRange;
  result[3] = decryptAsyncProcess;
  result[4] = decryptAsyncCancel;
  result[5] = decryptAsyncIsCancelled;
  return result;
}

uint64_t workerProc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  int v13;
  unint64_t v14;
  size_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  char *v21;
  compression_algorithm v22;
  int v23;
  uint64_t (*v24)(_QWORD, uint64_t, unint64_t, _QWORD, char *, _QWORD);
  int v25;
  unsigned int *v26;
  unsigned int v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t (*v33)(_OWORD *, _QWORD);
  int v34;
  int v35;
  uint64_t v36;
  uint64_t (*v37)(uint64_t, _QWORD, _OWORD *, _OWORD *, _BYTE *);
  int v38;
  uint64_t (*v39)(_QWORD, _QWORD);
  _QWORD **v40;
  uint64_t v41;
  uint64_t v42;
  size_t v43;
  unsigned int *v44;
  uint64_t v46;
  size_t v47;
  uint64_t (*v48)(_QWORD, size_t, unint64_t, uint64_t);
  unsigned int *v49;
  unsigned int v50;
  char v51;
  compression_algorithm algorithm;
  int v53;
  unsigned int v54;
  unint64_t v55;
  _OWORD v56[16];
  int v57;
  _OWORD v58[17];
  _BYTE __s[260];
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)result;
  v8 = *(_QWORD *)(result + 8);
  if (v8 >= *(_QWORD *)(*(_QWORD *)result + 1120))
  {
    v28 = "Invalid range index";
    v29 = 183;
    goto LABEL_50;
  }
  v10 = *(_QWORD *)(v9 + 1136) + 32 * v8;
  v13 = *(_DWORD *)(v10 + 28);
  v11 = (_DWORD *)(v10 + 28);
  v12 = v13;
  v14 = *(v11 - 1);
  if (*(_QWORD *)(v9 + 1096) <= v14)
  {
    v28 = "Invalid segment index";
    v29 = 191;
    goto LABEL_50;
  }
  v15 = *(_QWORD *)(v9 + 784);
  if (v15 >= 0x101)
    goto LABEL_71;
  v16 = result;
  v17 = (unsigned int *)(*(_QWORD *)(v9 + 1104) + *(_QWORD *)(v9 + 800) * v14);
  v55 = *(unsigned int *)(v9 + 152) * (unint64_t)v14;
  v18 = *v17;
  v19 = v17[1];
  v20 = v17 + 2;
  v21 = (char *)(result + 612);
  memcpy((void *)(result + 612), v17 + 2, v15);
  *(_DWORD *)(v16 + 608) = v15;
  memset_s(&v21[v15], 256 - v15, 0, 256 - v15);
  result = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v9 + 160));
  if ((_DWORD)v18 == (_DWORD)v19)
    v22 = 0;
  else
    v22 = result;
  v23 = *(_DWORD *)(v16 + 16);
  if (v23 != 1)
  {
    if (v23)
    {
      v28 = "Invalid op";
      v29 = 307;
    }
    else if (v12 == 3)
    {
      v24 = *(uint64_t (**)(_QWORD, uint64_t, unint64_t, _QWORD, char *, _QWORD))(v9 + 16);
      if (!v24)
      {
LABEL_31:
        result = 0;
        *v11 = 4;
        return result;
      }
      v25 = v24(*(_QWORD *)v9, v18, v55, *(unsigned int *)(v9 + 148), v21, *(unsigned int *)(v16 + 608));
      if ((v25 & 0x80000000) == 0)
      {
        if (v25)
        {
          *v11 = 6;
          v26 = (unsigned int *)(v9 + 120);
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 + 1, v26));
          if (*(_DWORD *)(v9 + 32) >= 3u)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u skipped, offset=%jd, payload=%u, raw=%u\n");
          return 0;
        }
        goto LABEL_31;
      }
      v28 = "Client selection callback reported an error";
      v29 = 220;
    }
    else
    {
      v28 = "Invalid segment state";
      v29 = 207;
    }
    goto LABEL_50;
  }
  if (v12 != 2)
  {
    v28 = "Invalid segment state";
    v29 = 239;
    goto LABEL_50;
  }
  if (*(_QWORD *)(v16 + 32) != v19)
  {
    v28 = "Segment payload size mismatch";
    v29 = 242;
    goto LABEL_50;
  }
  algorithm = v22;
  v30 = *(unsigned int *)(v9 + 324);
  if (v30 >= 0x101)
  {
LABEL_71:
    __break(1u);
    return result;
  }
  memcpy((void *)(v16 + 352), (char *)v20 + *(_QWORD *)(v9 + 784), *(unsigned int *)(v9 + 324));
  *(_DWORD *)(v16 + 348) = v30;
  memset_s((void *)(v16 + 352 + v30), 256 - v30, 0, 256 - v30);
  v31 = *(_DWORD *)(v9 + 156);
  v57 = 0;
  memset(v56, 0, sizeof(v56));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(_QWORD *)__s = 0x5F41454100000006;
  memset(v58, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  v54 = v31;
  v32 = v14 / v31;
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v32;
  *(_DWORD *)__s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  v33 = *(uint64_t (**)(_OWORD *, _QWORD))(v9 + 384);
  if (v33 && *(_DWORD *)(v9 + 520))
  {
    v34 = v33(v56, *(unsigned int *)(v9 + 312));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    v35 = 0;
    if ((v34 & 0x80000000) == 0)
      goto LABEL_35;
  }
  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  v35 = 1;
LABEL_35:
  v53 = v35;
  memset((char *)v58 + 8, 0, 224);
  memset((char *)&v58[14] + 8, 0, 28);
  WORD4(v58[0]) = 19283;
  *(_QWORD *)&v58[0] = 0x5F41454100000006;
  result = memset_s((char *)v58 + 10, 0xFAuLL, 0, 0xFAuLL);
  v36 = LODWORD(v58[0]);
  if (LODWORD(v58[0]) >= 0xFD)
    goto LABEL_71;
  *(_DWORD *)((char *)v58 + LODWORD(v58[0]) + 4) = v14 - v32 * v54;
  LODWORD(v58[0]) = v36 + 4;
  memset_s((char *)v58 + v36 + 8, 252 - v36, 0, 252 - v36);
  memset(__s, 0, sizeof(__s));
  v37 = *(uint64_t (**)(uint64_t, _QWORD, _OWORD *, _OWORD *, _BYTE *))(v9 + 384);
  if (v37 && LODWORD(v56[0]))
  {
    v38 = v37(v16 + 88, *(unsigned int *)(v9 + 316), v56, v58, __s);
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
    if ((v38 & 0x80000000) == 0)
    {
      memset_s(v56, 0x104uLL, 0, 0x104uLL);
      if (!v53)
      {
        v39 = *(uint64_t (**)(_QWORD, _QWORD))(v9 + 408);
        if (v39
          && *(_DWORD *)(v16 + 348) == *(_DWORD *)(v9 + 324)
          && (v40 = (_QWORD **)(v16 + 40), (v39(*(_QWORD *)(v16 + 40), *(_QWORD *)(v16 + 32)) & 0x80000000) == 0))
        {
          v42 = algorithm;
          if (algorithm)
          {
            v40 = (_QWORD **)(v16 + 64);
            v43 = compression_decode_buffer(*(uint8_t **)(v16 + 64), *(_QWORD *)(v16 + 48), *(const uint8_t **)(v16 + 40), *(_QWORD *)(v16 + 32), *(void **)(v16 + 80), algorithm);
            *(_QWORD *)(v16 + 56) = v43;
          }
          else
          {
            v43 = *(_QWORD *)(v16 + 32);
          }
          if (v43 == v18
            && (v46 = (uint64_t)*v40,
                (aeaChecksum(v16 + 868, *(_DWORD *)(v9 + 148), *v40, v43, v41, v42, a7, a8) & 0x80000000) == 0)
            && (v47 = *(unsigned int *)(v16 + 868), *(_QWORD *)(v9 + 784) == v47)
            && (_DWORD)v47 == *(_DWORD *)(v16 + 608)
            && !memcmp((const void *)(v16 + 872), v21, v47))
          {
            v48 = *(uint64_t (**)(_QWORD, size_t, unint64_t, uint64_t))(v9 + 24);
            if (!v48 || (v48(*(_QWORD *)v9, v43, v55, v46) & 0x80000000) == 0)
            {
              *v11 = 5;
              v49 = (unsigned int *)(v9 + 120);
              do
                v50 = __ldaxr(v49);
              while (__stlxr(v50 + 1, v49));
              if (*(_DWORD *)(v9 + 32) >= 3u)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u processed, offset=%jd, payload=%u, raw=%u\n");
              return 0;
            }
            v28 = "Client processing callback reported an error";
            v29 = 297;
          }
          else
          {
            v28 = "Segment data failed verification";
            v29 = 285;
          }
        }
        else
        {
          v28 = "Segment decryption";
          v29 = 259;
        }
        goto LABEL_50;
      }
      goto LABEL_47;
    }
  }
  else
  {
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
  }
  memset_s(v56, 0x104uLL, 0, 0x104uLL);
LABEL_47:
  v28 = "derive segment encryption key";
  v29 = 252;
LABEL_50:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerProc", v29, 114, 0, v28, a7, a8, v51);
  v44 = (unsigned int *)(v9 + 48);
  while (!__ldaxr(v44))
  {
    if (!__stlxr(1u, v44))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t pushRange(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  v4 = a1[140];
  v5 = a1[139];
  if (v4 >= v5)
  {
    v6 = 2 * v5;
    v7 = v5 == 0;
    v8 = 32;
    if (!v7)
      v8 = v6;
    a1[139] = v8;
    if ((unint64_t)(32 * v8) >= 0x2000000001)
    {
      *__error() = 12;
LABEL_13:
      a1[142] = 0;
      v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushRange", 346, 114, *v14, "malloc", v15, v16, v18);
      a1[139] = 0;
      a1[140] = 0;
      return -1;
    }
    v9 = (void *)a1[142];
    v10 = realloc(v9, 32 * v8);
    if (!v10)
    {
      free(v9);
      goto LABEL_13;
    }
    a1[142] = v10;
    v4 = a1[140];
  }
  v11 = a1[142];
  if (v4)
    v12 = *(_QWORD *)(v11 + 32 * v4 - 32) + *(_QWORD *)(v11 + 32 * v4 - 24);
  else
    v12 = 0;
  a1[140] = v4 + 1;
  v13 = (_QWORD *)(v11 + 32 * v4);
  memset_s(v13, 0x20uLL, 0, 0x20uLL);
  *v13 = a2;
  v13[1] = v12;
  v13[2] = -1;
  *((_DWORD *)v13 + 6) = -1;
  return v4;
}

uint64_t decryptAsyncClose(uint64_t a1)
{
  unsigned int v2;
  _BOOL4 v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unint64_t v7;
  unint64_t i;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  rsize_t v16;
  char v18;

  v2 = atomic_load((unsigned int *)(a1 + 48));
  v3 = v2 == 0;
  if ((ThreadPoolDestroy(*(_QWORD *)(a1 + 1176)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncClose", 850, 114, 0, "ThreadPoolDestroy", v4, v5, v18);
    v3 = 0;
  }
  v6 = *(void **)(a1 + 1168);
  if (v6)
  {
    v7 = *(unsigned int *)(a1 + 1160);
    if ((_DWORD)v7)
    {
      for (i = 0; i < v7; ++i)
      {
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 1168) + 8 * i);
        if (v9)
        {
          v10 = *(void **)(v9 + 40);
          if (v10)
            memset_s(*(void **)(v9 + 40), *(_QWORD *)(v9 + 24), 0, *(_QWORD *)(v9 + 24));
          free(v10);
          v11 = *(void **)(v9 + 64);
          if (v11)
            memset_s(*(void **)(v9 + 64), *(_QWORD *)(v9 + 48), 0, *(_QWORD *)(v9 + 48));
          free(v11);
          v12 = *(void **)(v9 + 80);
          if (v12)
            memset_s(*(void **)(v9 + 80), *(_QWORD *)(v9 + 72), 0, *(_QWORD *)(v9 + 72));
          free(v12);
          memset_s((void *)v9, 0x468uLL, 0, 0x468uLL);
          free((void *)v9);
          v7 = *(unsigned int *)(a1 + 1160);
        }
      }
      v6 = *(void **)(a1 + 1168);
    }
    free(v6);
  }
  v13 = *(void **)(a1 + 808);
  if (v13)
    memset_s(*(void **)(a1 + 808), *(_QWORD *)(a1 + 792), 0, *(_QWORD *)(a1 + 792));
  free(v13);
  v14 = *(void **)(a1 + 1136);
  if (v14)
    memset_s(*(void **)(a1 + 1136), 32 * *(_QWORD *)(a1 + 1112), 0, 32 * *(_QWORD *)(a1 + 1112));
  free(v14);
  v15 = *(void **)(a1 + 1104);
  if (v15)
  {
    v16 = *(_QWORD *)(a1 + 800) * *(_QWORD *)(a1 + 1088);
    memset_s(*(void **)(a1 + 1104), v16, 0, v16);
  }
  free(v15);
  AEAContextDestroy(*(AEAContext *)(a1 + 128));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  memset_s((void *)a1, 0x4A0uLL, 0, 0x4A0uLL);
  free((void *)a1);
  return (v3 - 1);
}

uint64_t decryptAsyncGetRange(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int *v3;
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v23;

  v3 = (unsigned int *)(a1 + 48);
  if (atomic_load((unsigned int *)(a1 + 48)))
    return 0xFFFFFFFFLL;
  v8 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    v11 = "lockState";
    v12 = 743;
    goto LABEL_18;
  }
  if (*(_DWORD *)(a1 + 52) == 4)
  {
    v13 = *(_QWORD *)(a1 + 1128);
    if (v13 < 0)
    {
LABEL_9:
      v16 = atomic_load((unsigned int *)(a1 + 120));
      if (*(_QWORD *)(a1 + 1096) == v16)
        *(_DWORD *)(a1 + 52) = 5;
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 1136);
      while (1)
      {
        v15 = v14 + 32 * v13;
        if (*(_DWORD *)(v15 + 28) == 4)
          break;
        v13 = *(_QWORD *)(v15 + 16);
        *(_QWORD *)(a1 + 1128) = v13;
        if (v13 < 0)
          goto LABEL_9;
      }
    }
  }
  v17 = *(_QWORD *)(a1 + 1128);
  if (v17 < 0)
  {
    if (*(_DWORD *)(a1 + 52) == 5)
    {
      *a2 = 0;
      *a3 = 0;
      v20 = 1;
    }
    else
    {
      v20 = 0;
    }
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 1136) + 32 * v17;
    v19 = *(_QWORD *)(v18 + 8);
    *a2 = *(_QWORD *)v18;
    *a3 = v19;
    v20 = 1;
    *(_DWORD *)(v18 + 28) = 1;
    *(_QWORD *)(a1 + 1128) = *(_QWORD *)(v18 + 16);
  }
  if (pthread_mutex_unlock(v8))
  {
    v11 = "unlockState";
    v12 = 782;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncGetRange", v12, 114, 0, v11, v9, v10, v23);
    while (!__ldaxr(v3))
    {
      if (!__stlxr(1u, v3))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  return v20;
}

uint64_t decryptAsyncProcess(uint64_t a1, uint64_t *a2, size_t a3, uint64_t a4)
{
  unsigned int *v4;
  pthread_mutex_t *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  char v25;
  _QWORD __key[2];
  __int128 v27;

  v4 = (unsigned int *)(a1 + 48);
  if (atomic_load((unsigned int *)(a1 + 48)))
    return 0xFFFFFFFFLL;
  v10 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    v13 = "lockState";
    v14 = 796;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", v14, 114, 0, v13, v11, v12, v25);
    goto LABEL_22;
  }
  __key[0] = 0;
  v27 = 0u;
  __key[1] = a4;
  v15 = bsearch(__key, *(const void **)(a1 + 1136), *(_QWORD *)(a1 + 1120), 0x20uLL, (int (__cdecl *)(const void *, const void *))cmpRange);
  if (!v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 800, 114, 0, "Invalid offset received: %jd\n", v19, v20, a4);
LABEL_18:
    v22 = 1;
    goto LABEL_19;
  }
  if (v15[7] == 1)
  {
    v15[7] = 2;
    if (*(_QWORD *)v15 == a3)
    {
      switch(*(_DWORD *)(a1 + 52))
      {
        case 0:
          v21 = processMagic(a1, a2, a3, v16, v17, v18, v19, v20);
          goto LABEL_15;
        case 1:
          v21 = processPrologue((_QWORD *)a1, a2, a3);
          goto LABEL_15;
        case 2:
          v21 = processClusterHeader(a1, a2, a3, v16, v17, v18, v19, v20);
          goto LABEL_15;
        case 3:
          v21 = processPadding(a1, (uint64_t)a2, a3);
          goto LABEL_15;
        case 4:
          v21 = processSegment(a1, ((uint64_t)v15 - *(_QWORD *)(a1 + 1136)) >> 5, a2, a3, v17, v18, v19, v20);
LABEL_15:
          if ((v21 & 0x80000000) == 0)
            goto LABEL_16;
          goto LABEL_17;
        default:
LABEL_17:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 822, 114, 0, "Invalid archive", v19, v20, v25);
          break;
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 808, 114, 0, "Invalid size received: %zu\n", v19, v20, a3);
    }
    goto LABEL_18;
  }
LABEL_16:
  v22 = 0;
LABEL_19:
  if (pthread_mutex_unlock(v10))
  {
    v13 = "unlockState";
    v14 = 825;
    goto LABEL_21;
  }
  if (!v22)
    return 0;
LABEL_22:
  while (!__ldaxr(v4))
  {
    if (!__stlxr(1u, v4))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t decryptAsyncCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 48);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

uint64_t decryptAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 48));
}

uint64_t processMagic(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  const char *v12;
  __int16 v13;
  char v14;
  _OWORD v15[4];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _OWORD v19[4];
  uint64_t v20;
  uint64_t v21;
  int v22;

  if (*(_DWORD *)(a1 + 32) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Magic received: %zu B\n", a3);
  if (a3 == 12)
  {
    v20 = 0;
    memset(v19, 0, sizeof(v19));
    memset(v15, 0, sizeof(v15));
    v16 = 0u;
    v17 = 0u;
    v18 = 0;
    v21 = *a2;
    v22 = *((_DWORD *)a2 + 2);
    if ((aeaContainerParamsInitWithMagic((int *)v19, &v21, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0
      && (aeaCryptoInit((char *)(a1 + 312), (unsigned int *)v19) & 0x80000000) == 0
      && (aeaContainerOffsetsInit((uint64_t)v15, (unsigned int *)v19, (unsigned int *)(a1 + 312)) & 0x80000000) == 0)
    {
      result = 0;
      **(_QWORD **)(a1 + 1136) = v16;
      *(_DWORD *)(a1 + 52) = 1;
      *(_QWORD *)(a1 + 1128) = 0;
      return result;
    }
    v12 = "Invalid archive";
    v13 = 494;
  }
  else
  {
    v12 = "Invalid magic";
    v13 = 487;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processMagic", v13, 114, 0, v12, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t processPrologue(_QWORD *a1, _DWORD *a2, size_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(_QWORD, uint64_t);
  unsigned int v11;
  const char *v12;
  __int16 v13;
  uint64_t result;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  char v35;

  if (*((_DWORD *)a1 + 8) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Prologue received: %zu B\n", a3);
  v6 = aeaContextCreateWithPrologue(a2, a3);
  a1[16] = v6;
  if (!v6)
  {
    v12 = "creating encryption context";
    v13 = 514;
    goto LABEL_29;
  }
  v9 = v6;
  v10 = (uint64_t (*)(_QWORD, uint64_t))a1[1];
  if (v10)
  {
    if ((v10(*a1, v6) & 0x80000000) != 0)
    {
      v12 = "Context setup callback returned an error";
      v13 = 518;
      goto LABEL_29;
    }
    v9 = a1[16];
  }
  if ((aeaContextUnlock(v9, (uint64_t)(a1 + 17), (_DWORD *)a1 + 130, 0, 1, 0) & 0x80000000) != 0)
  {
    v12 = "Archive unlock";
    v13 = 521;
    goto LABEL_29;
  }
  v11 = aeaChecksumSize(*((_DWORD *)a1 + 37));
  a1[98] = v11;
  if (v11 <= 0x1F)
  {
    v12 = "Invalid checksum mode for decrypt to file, at least 256 bits are required";
    v13 = 525;
LABEL_29:
    v25 = 0;
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processPrologue", v13, 114, v25, v12, v7, v8, v35);
    return 0xFFFFFFFFLL;
  }
  result = aeaContainerOffsetsInit((uint64_t)(a1 + 26), (unsigned int *)a1 + 34, (unsigned int *)a1 + 78);
  if ((result & 0x80000000) != 0)
  {
    v12 = "Invalid archive";
    v13 = 528;
    goto LABEL_29;
  }
  if (a1[1])
  {
    v15 = a1[16];
    *(_OWORD *)v15 = *(_OWORD *)(a1 + 17);
    v16 = *(_OWORD *)(a1 + 19);
    v17 = *(_OWORD *)(a1 + 21);
    v18 = *(_OWORD *)(a1 + 23);
    *(_QWORD *)(v15 + 64) = a1[25];
    *(_OWORD *)(v15 + 32) = v17;
    *(_OWORD *)(v15 + 48) = v18;
    *(_OWORD *)(v15 + 16) = v16;
    result = ((uint64_t (*)(_QWORD, _QWORD))a1[1])(*a1, a1[16]);
    if ((result & 0x80000000) != 0)
    {
      v12 = "Client post-unlock callback returned an error";
      v13 = 534;
      goto LABEL_29;
    }
  }
  if ((*((_BYTE *)a1 + 47) & 4) != 0)
    *(_DWORD *)(a1[16] + 2740) = 1;
  v19 = *((unsigned int *)a1 + 39);
  v20 = ((a1[21] + (unint64_t)*((unsigned int *)a1 + 38) - 1) / *((unsigned int *)a1 + 38) + v19 - 1) / v19;
  if (HIDWORD(v20))
    v21 = 0;
  else
    v21 = (v20 * v19) >> 32 == 0;
  if (!v21)
  {
    v12 = "Invalid archive, too many clusters";
    v13 = 546;
    goto LABEL_29;
  }
  *((_DWORD *)a1 + 195) = v20;
  v22 = *((unsigned int *)a1 + 81);
  if (v22 >= 0x101)
  {
    __break(1u);
  }
  else
  {
    memcpy((char *)a1 + 820, (char *)a2 + a1[33], *((unsigned int *)a1 + 81));
    *((_DWORD *)a1 + 204) = v22;
    memset_s((char *)a1 + v22 + 820, 256 - v22, 0, 256 - v22);
    if (*((_DWORD *)a1 + 195))
    {
      v23 = a1[98] + *((unsigned int *)a1 + 81) + 8;
      a1[100] = v23;
      v24 = v20 * *((unsigned int *)a1 + 39);
      a1[136] = v24;
      a1[137] = 0;
      if (v24 * v23 >= 0x2000000001)
      {
        *__error() = 12;
        a1[138] = 0;
LABEL_38:
        v25 = *__error();
        v12 = "malloc";
        v13 = 569;
        goto LABEL_30;
      }
      v32 = malloc(v24 * v23);
      a1[138] = v32;
      if (!v32)
        goto LABEL_38;
      v33 = pushRange(a1, a1[38]);
      if (v33 < 0)
      {
        v12 = "inserting first cluster header range";
        v13 = 573;
        goto LABEL_29;
      }
      v34 = v33;
      result = 0;
      *((_DWORD *)a1 + 13) = 2;
      a1[141] = v34;
      *((_DWORD *)a1 + 269) = 0;
    }
    else
    {
      v26 = pushPaddingRange((uint64_t)a1);
      if (v26 < 0)
      {
        v12 = "inserting padding range";
        v13 = 556;
        goto LABEL_29;
      }
      if (!v26 && (startStreaming((uint64_t)a1, v27, v28, v29, v30, v31, v7, v8) & 0x80000000) != 0)
      {
        v12 = "Streaming data setup";
        v13 = 559;
        goto LABEL_29;
      }
      return 0;
    }
  }
  return result;
}

uint64_t processClusterHeader(uint64_t a1, void *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v11;
  size_t v12;
  int v13;
  uint64_t (*v14)(_OWORD *, _QWORD);
  int v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t (*v19)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *);
  int v20;
  uint64_t (*v21)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD, _QWORD);
  uint64_t result;
  size_t v23;
  int v24;
  int v25;
  size_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  _OWORD v54[16];
  int v55;
  _OWORD v56[16];
  int v57;
  _OWORD v58[17];
  _BYTE __s[260];
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v55 = 0;
  memset(v54, 0, sizeof(v54));
  if (*(_DWORD *)(a1 + 32) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Cluster header received: %zu B\n", __n);
  v11 = *(void **)(a1 + 808);
  if (v11)
  {
    v12 = *(_QWORD *)(a1 + 792);
    goto LABEL_5;
  }
  v12 = *(_QWORD *)(a1 + 304);
  *(_QWORD *)(a1 + 792) = v12;
  if (v12 >= 0x2000000001)
  {
    *__error() = 12;
    *(_QWORD *)(a1 + 808) = 0;
LABEL_50:
    v51 = *__error();
    v17 = "malloc";
    v18 = 596;
LABEL_55:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processClusterHeader", v18, 114, v51, v17, a7, a8, v53);
    v50 = 0xFFFFFFFFLL;
    goto LABEL_56;
  }
  v11 = malloc(v12);
  *(_QWORD *)(a1 + 808) = v11;
  if (!v11)
    goto LABEL_50;
LABEL_5:
  if (v12 != __n)
  {
    v17 = "Invalid cluster header size";
    v18 = 600;
LABEL_54:
    v51 = 0;
    goto LABEL_55;
  }
  memcpy(v11, __src, __n);
  v13 = *(_DWORD *)(a1 + 1076);
  v57 = 0;
  memset(v56, 0, sizeof(v56));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(_QWORD *)__s = 0x5F41454100000006;
  memset(v58, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v13;
  *(_DWORD *)__s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  v14 = *(uint64_t (**)(_OWORD *, _QWORD))(a1 + 384);
  if (!v14 || !*(_DWORD *)(a1 + 520))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_15:
    v16 = 1;
    goto LABEL_16;
  }
  v15 = v14(v56, *(unsigned int *)(a1 + 312));
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  v16 = 0;
  if (v15 < 0)
    goto LABEL_15;
LABEL_16:
  memset((char *)v58 + 12, 0, 248);
  *(_QWORD *)((char *)v58 + 4) = 0x4B4548435F414541;
  LODWORD(v58[0]) = 8;
  memset_s((char *)v58 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(__s, 0, sizeof(__s));
  v19 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *))(a1 + 384);
  if (!v19 || !LODWORD(v56[0]))
  {
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
    goto LABEL_52;
  }
  v20 = v19(v54, *(unsigned int *)(a1 + 316), v56, v58, __s);
  memset_s(v58, 0x104uLL, 0, 0x104uLL);
  if (v20 < 0)
  {
LABEL_52:
    memset_s(v56, 0x104uLL, 0, 0x104uLL);
    goto LABEL_53;
  }
  memset_s(v56, 0x104uLL, 0, 0x104uLL);
  if (v16)
  {
LABEL_53:
    v17 = "Cluster header encryption key derivation";
    v18 = 611;
    goto LABEL_54;
  }
  v21 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD, _QWORD))(a1 + 408);
  if (!v21
    || *(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324)
    || (result = v21(*(_QWORD *)(a1 + 808), *(_QWORD *)(a1 + 288), a1 + 816, v54, *(_QWORD *)(a1 + 808) + *(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 304) - *(_QWORD *)(a1 + 288)), (result & 0x80000000) != 0))
  {
    v17 = "Cluster header decryption";
    v18 = 622;
    goto LABEL_54;
  }
  v23 = *(unsigned int *)(a1 + 324);
  v24 = *(_DWORD *)(a1 + 156);
  if (v24)
  {
    v25 = 0;
    v26 = *(_QWORD *)(a1 + 784) + 8;
    v27 = v24 * *(_DWORD *)(a1 + 1076);
    v28 = *(_QWORD *)(a1 + 296);
    v29 = *(_QWORD *)(a1 + 280);
    while (1)
    {
      v30 = *(_QWORD *)(a1 + 1096);
      if (v30 >= *(_QWORD *)(a1 + 1088))
      {
        v17 = "Invalid archive";
        v18 = 634;
        goto LABEL_54;
      }
      v31 = (unsigned int *)(*(_QWORD *)(a1 + 1104) + *(_QWORD *)(a1 + 800) * v30);
      memcpy(v31, (const void *)(*(_QWORD *)(a1 + 808) + v29), v26);
      result = (uint64_t)memcpy((char *)v31 + v26, (const void *)(*(_QWORD *)(a1 + 808) + v28), v23);
      v32 = *v31;
      if (!(_DWORD)v32)
        goto LABEL_42;
      v33 = *(_QWORD *)(a1 + 1120);
      if (v33)
        v33 = *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 32 * v33 - 32) + *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 32 * v33 - 24);
      v34 = v31[1];
      if ((unint64_t)(v33 + v34) > *(_QWORD *)(a1 + 176)
        || (v35 = *(_QWORD *)(a1 + 1080) + v32, v36 = *(_QWORD *)(a1 + 168), v35 > v36))
      {
        v17 = "Invalid archive: segment size mismatch";
        v18 = 648;
        goto LABEL_54;
      }
      if (v34 > v32
        || (v35 != v36 ? (v37 = v32 >= *(_DWORD *)(a1 + 152)) : (v37 = 1), !v37))
      {
        v53 = v31[1];
        v17 = "Invalid segment sizes: payload=%u raw=%u";
        v18 = 651;
        goto LABEL_54;
      }
      ++*(_QWORD *)(a1 + 1096);
      *(_QWORD *)(a1 + 1080) = v35;
      result = pushRange((_QWORD *)a1, v34);
      if (result < 0)
        break;
      v29 += v26;
      v28 += v23;
      v38 = *(_QWORD *)(a1 + 1136);
      v39 = v38 + 32 * result;
      *(_DWORD *)(v39 + 24) = v27 + v25;
      *(_DWORD *)(v39 + 28) = 3;
      v40 = *(_QWORD *)(a1 + 1152);
      v41 = v38 + 32 * v40 + 16;
      if (v40 >= 0)
        v42 = (_QWORD *)v41;
      else
        v42 = (_QWORD *)(a1 + 1144);
      *v42 = result;
      *(_QWORD *)(a1 + 1152) = result;
      if (++v25 >= *(_DWORD *)(a1 + 156))
      {
LABEL_42:
        LODWORD(v23) = *(_DWORD *)(a1 + 324);
        goto LABEL_43;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushSegmentRange", 386, 114, 0, "inserting segment range", a7, a8, v53);
    v18 = 658;
    v51 = 0;
    v17 = "inserting segment range";
    goto LABEL_55;
  }
LABEL_43:
  if (v23 < 0x101)
  {
    memcpy((void *)(a1 + 820), (const void *)(*(_QWORD *)(a1 + 808) + *(_QWORD *)(a1 + 288)), v23);
    *(_DWORD *)(a1 + 816) = v23;
    memset_s((void *)(a1 + 820 + v23), 256 - v23, 0, 256 - v23);
    v43 = *(_DWORD *)(a1 + 1076) + 1;
    *(_DWORD *)(a1 + 1076) = v43;
    if (v43 == *(_DWORD *)(a1 + 780))
    {
      v44 = pushPaddingRange(a1);
      if (v44 < 0)
      {
        v17 = "inserting padding range";
        v18 = 669;
      }
      else
      {
        if (v44 || (startStreaming(a1, v45, v46, v47, v48, v49, a7, a8) & 0x80000000) == 0)
        {
          v50 = 0;
LABEL_56:
          memset_s(v54, 0x104uLL, 0, 0x104uLL);
          return v50;
        }
        v17 = "Streaming data setup";
        v18 = 672;
      }
    }
    else
    {
      v52 = pushRange((_QWORD *)a1, *(_QWORD *)(a1 + 304));
      if ((v52 & 0x8000000000000000) == 0)
      {
        v50 = 0;
        *(_QWORD *)(a1 + 1128) = v52;
        goto LABEL_56;
      }
      v17 = "inserting next cluster header range";
      v18 = 679;
    }
    goto LABEL_54;
  }
  __break(1u);
  return result;
}

uint64_t processPadding(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v6)(__int128 *, _QWORD);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t);
  _BOOL4 v11;
  uint64_t (*v12)(uint64_t, __int128 *);
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  _OWORD v25[16];
  int v26;
  __int128 __s;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 32) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Padding received: %zu B\n", a3);
  v43 = 0;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  __s = 0u;
  v28 = 0u;
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  if (*(_QWORD *)(a1 + 488)
    && (*(_DWORD *)((char *)v25 + 7) = 1262571615,
        *(_QWORD *)&v25[0] = 0x5F41454100000007,
        memset_s((void *)((unint64_t)v25 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (v6 = *(uint64_t (**)(__int128 *, _QWORD))(a1 + 384)) != 0)
    && *(_DWORD *)(a1 + 520)
    && (v6(&__s, *(unsigned int *)(a1 + 312)) & 0x80000000) == 0)
  {
    v7 = (*(uint64_t (**)(__int128 *))(a1 + 488))(&__s);
  }
  else
  {
    v7 = 0;
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v25, 0x104uLL, 0, 0x104uLL);
  if (!v7)
  {
    v16 = "authenticating padding";
    v17 = 699;
    goto LABEL_25;
  }
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 496);
  v11 = !v10 || (v10(v7, a2, a3) & 0x80000000) != 0;
  v43 = 0;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  __s = 0u;
  v28 = 0u;
  v12 = *(uint64_t (**)(uint64_t, __int128 *))(a1 + 504);
  if (!v12)
    goto LABEL_22;
  if (*(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324))
    goto LABEL_22;
  if ((v12(v7, &__s) & 0x80000000) != 0)
    goto LABEL_22;
  if ((_DWORD)__s != *(_DWORD *)(a1 + 324))
    goto LABEL_22;
  if (__s >= 8)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v14 |= *(_QWORD *)((char *)&__s + v13 + 4) ^ *(_QWORD *)(a1 + 820 + v13);
      v15 = v13 + 16;
      v13 += 8;
    }
    while (v15 <= __s);
    if (v14)
    {
LABEL_22:
      memset_s(&__s, 0x104uLL, 0, 0x104uLL);
LABEL_23:
      v16 = "authenticating padding";
      v17 = 702;
      goto LABEL_25;
    }
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  if (v11)
    goto LABEL_23;
  if ((startStreaming(a1, v19, v20, v21, v22, v23, v8, v9) & 0x80000000) == 0)
    return 0;
  v16 = "Streaming data setup";
  v17 = 705;
LABEL_25:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processPadding", v17, 114, 0, v16, v8, v9, v24);
  return 0xFFFFFFFFLL;
}

uint64_t processSegment(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t Worker;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  char v26;

  v8 = a4;
  if (*(_DWORD *)(a1 + 32) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment received: %zu B\n", a4);
  Worker = ThreadPoolGetWorker(*(_QWORD *)(a1 + 1176), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!Worker)
  {
    v23 = "ThreadPoolGetWorker";
    v24 = 720;
    goto LABEL_9;
  }
  v15 = Worker;
  v16 = 1;
  if (*(_QWORD *)(Worker + 24) < v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processSegment", 723, 114, 0, "Invalid segment size", v13, v14, v26);
    v16 = 0;
    v8 = 0;
  }
  memcpy(*(void **)(v15 + 40), a3, v8);
  *(_QWORD *)(v15 + 32) = v8;
  *(_DWORD *)(v15 + 16) = 1;
  *(_QWORD *)(v15 + 8) = a2;
  if ((ThreadPoolRunWorker(*(_QWORD *)(a1 + 1176), v15, v17, v18, v19, v20, v21, v22) & 0x80000000) != 0)
  {
    v23 = "ThreadPoolRunWorker";
    v24 = 728;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processSegment", v24, 114, 0, v23, v13, v14, v26);
    v16 = 0;
  }
  if (v16)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t cmpRange(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 < v3;
  v5 = v2 != v3;
  if (v4)
    return 0xFFFFFFFFLL;
  else
    return v5;
}

uint64_t pushPaddingRange(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  if (*(_DWORD *)(*(_QWORD *)(a1 + 128) + 2740))
    return 0;
  v2 = *(_QWORD *)(a1 + 1120);
  if (v2)
    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 32 * v2 - 32) + *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 32 * v2 - 24);
  v3 = *(_QWORD *)(a1 + 176);
  if (v3 == v2)
    return 0;
  if (v3 >= v2)
  {
    v5 = pushRange((_QWORD *)a1, v3 - v2);
    if ((v5 & 0x8000000000000000) == 0)
    {
      *(_DWORD *)(a1 + 52) = 3;
      *(_QWORD *)(a1 + 1128) = v5;
      return 1;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushPaddingRange", 375, 114, 0, "inserting padding range", v6, v7, v8);
  }
  return 0xFFFFFFFFLL;
}

uint64_t startStreaming(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  compression_algorithm v14;
  compression_algorithm v15;
  void *v16;
  size_t v17;
  size_t v18;
  void *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Worker;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int *v31;
  int v32;
  int v33;
  int v34;
  uint64_t result;
  const char *v36;
  __int16 v37;
  __int16 v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  char v42;

  if (!*(_DWORD *)(a1 + 780))
  {
    result = 0;
    *(_DWORD *)(a1 + 52) = 5;
    return result;
  }
  if (!*(_DWORD *)(a1 + 1160))
  {
LABEL_14:
    v20 = *(_QWORD *)(a1 + 1120);
    if (v20)
    {
      v21 = 0;
      v22 = 24;
      do
      {
        if (*(_DWORD *)(*(_QWORD *)(a1 + 1136) + v22) != -1)
        {
          Worker = ThreadPoolGetWorker(*(_QWORD *)(a1 + 1176), a2, a3, a4, a5, a6, a7, a8);
          if (!Worker)
          {
            v36 = "ThreadPoolGetWorker";
            v37 = 449;
            goto LABEL_45;
          }
          *(_DWORD *)(Worker + 16) = 0;
          *(_QWORD *)(Worker + 8) = v21;
          if ((ThreadPoolRunWorker(*(_QWORD *)(a1 + 1176), Worker, v24, v25, v26, v27, a7, a8) & 0x80000000) != 0)
          {
            v36 = "ThreadPoolRunWorker";
            v37 = 452;
            goto LABEL_45;
          }
          v20 = *(_QWORD *)(a1 + 1120);
        }
        ++v21;
        v22 += 32;
      }
      while (v21 < v20);
    }
    if ((ThreadPoolSync(*(unsigned int **)(a1 + 1176)) & 0x80000000) != 0)
    {
      v36 = "ThreadPoolSync";
      v37 = 454;
      goto LABEL_45;
    }
    v28 = *(_QWORD *)(a1 + 1120);
    if (v28)
    {
      v29 = 0;
      v30 = 0;
      v31 = (int *)(*(_QWORD *)(a1 + 1136) + 28);
      do
      {
        v33 = *v31;
        v31 += 8;
        v32 = v33;
        if (v33 == 4)
          v34 = v30 + 1;
        else
          v34 = v30;
        if (v32 == 6)
          ++v29;
        else
          v30 = v34;
        --v28;
      }
      while (v28);
      v28 = (v29 + v30);
    }
    if (*(_QWORD *)(a1 + 1096) != v28 || *(_QWORD *)(a1 + 1080) != *(_QWORD *)(a1 + 168))
    {
      v36 = "Segment count/size mismatch";
      v37 = 467;
      goto LABEL_45;
    }
    result = 0;
    *(_DWORD *)(a1 + 52) = 4;
    *(_QWORD *)(a1 + 1128) = *(_QWORD *)(a1 + 1144);
    return result;
  }
  v9 = 0;
  while (1)
  {
    v10 = *(_QWORD **)(*(_QWORD *)(a1 + 1168) + 8 * v9);
    if (v10[3])
      goto LABEL_5;
    v11 = *v10;
    v12 = *(unsigned int *)(*v10 + 152);
    v13 = malloc(v12);
    v10[5] = v13;
    if (!v13)
    {
      v38 = 144;
      goto LABEL_44;
    }
    v10[3] = v12;
    v14 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v11 + 160));
    if (!v14)
      goto LABEL_5;
    v15 = v14;
    v16 = malloc(v12);
    v10[8] = v16;
    if (!v16)
    {
      v38 = 152;
      goto LABEL_44;
    }
    v10[6] = v12;
    v17 = compression_decode_scratch_buffer_size(v15);
    if (!v17)
      goto LABEL_5;
    v18 = v17;
    if (v17 >= 0x2000000001)
      break;
    v19 = malloc(v17);
    v10[10] = v19;
    if (!v19)
      goto LABEL_43;
    v10[9] = v18;
LABEL_5:
    if (++v9 >= (unint64_t)*(unsigned int *)(a1 + 1160))
      goto LABEL_14;
  }
  *__error() = 12;
  v10[10] = 0;
LABEL_43:
  v38 = 159;
LABEL_44:
  v39 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerAllocBuffers", v38, 114, *v39, "malloc", v40, v41, v42);
  v36 = "Worker buffer allocation";
  v37 = 440;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"startStreaming", v37, 114, 0, v36, a7, a8, v42);
  return 0xFFFFFFFFLL;
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  uint64_t (*v2)(_QWORD, AAHeader *);

  v2 = (uint64_t (*)(_QWORD, AAHeader *))*((_QWORD *)s + 5);
  if (v2)
    return v2(*(_QWORD *)s, header);
  else
    return -1;
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  uint64_t (*v4)(_QWORD, _QWORD, void *, size_t);

  v4 = (uint64_t (*)(_QWORD, _QWORD, void *, size_t))*((_QWORD *)s + 6);
  if (v4)
    return v4(*(_QWORD *)s, key.ikey, buf, nbyte);
  else
    return -1;
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  uint64_t (*v2)(_QWORD, AAHeader);

  v2 = (uint64_t (*)(_QWORD, AAHeader))*((_QWORD *)s + 3);
  if (v2)
    return v2(*(_QWORD *)s, header);
  else
    return -1;
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  uint64_t (*v4)(_QWORD, _QWORD, const void *, size_t);

  v4 = (uint64_t (*)(_QWORD, _QWORD, const void *, size_t))*((_QWORD *)s + 4);
  if (v4)
    return v4(*(_QWORD *)s, key.ikey, buf, nbyte);
  else
    return -1;
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  int v2;

  if (!s)
    return 0;
  if (*(_QWORD *)s)
    v2 = (*((uint64_t (**)(void))s + 1))();
  else
    v2 = 0;
  free(s);
  return v2;
}

void AAArchiveStreamCancel(AAArchiveStream s)
{
  void (*v1)(_QWORD);

  v1 = (void (*)(_QWORD))*((_QWORD *)s + 2);
  if (v1)
    v1(*(_QWORD *)s);
}

AAArchiveStream AACustomArchiveStreamOpen(void)
{
  AAArchiveStream_impl *v0;
  AAArchiveStream_impl *v1;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char v6;

  v0 = (AAArchiveStream_impl *)malloc(0x38uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x38uLL, 0, 0x38uLL);
  }
  else
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AACustomArchiveStreamOpen", 49, 14, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void AACustomArchiveStreamSetData(AAArchiveStream s, void *data)
{
  *(_QWORD *)s = data;
}

void AACustomArchiveStreamSetCloseProc(AAArchiveStream s, AAArchiveStreamCloseProc proc)
{
  *((_QWORD *)s + 1) = proc;
}

void AACustomArchiveStreamSetCancelProc(AAArchiveStream s, AAArchiveStreamCancelProc proc)
{
  *((_QWORD *)s + 2) = proc;
}

void AACustomArchiveStreamSetWriteHeaderProc(AAArchiveStream s, AAArchiveStreamWriteHeaderProc proc)
{
  *((_QWORD *)s + 3) = proc;
}

void AACustomArchiveStreamSetWriteBlobProc(AAArchiveStream s, AAArchiveStreamWriteBlobProc proc)
{
  *((_QWORD *)s + 4) = proc;
}

void AACustomArchiveStreamSetReadHeaderProc(AAArchiveStream s, AAArchiveStreamReadHeaderProc proc)
{
  *((_QWORD *)s + 5) = proc;
}

void AACustomArchiveStreamSetReadBlobProc(AAArchiveStream s, AAArchiveStreamReadBlobProc proc)
{
  *((_QWORD *)s + 6) = proc;
}

uint64_t appendPathListWorkerProc(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  AAHeader_impl *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  AAEntryXATBlob v9;
  uint64_t v10;
  uint64_t v11;
  AAEntryACLBlob_impl *v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t, char *, _QWORD);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  AAFieldKey v34;
  AAFieldKey v35;
  uint64_t v36;
  uint64_t v37;
  AAFieldKey v38;
  uint64_t v39;
  uint64_t v40;
  size_t EncodedSize;
  AAFieldKey v42;
  __int16 v43;
  const char *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  __int16 v49;
  const char *v50;
  AAFieldKey v51;
  int v52;
  AAEntryACLBlob_impl *v53;
  size_t v54;
  AAFieldKey v55;
  uint64_t v56;
  uint64_t v57;
  AAFieldKey v58;
  uint64_t v59;
  AAFieldKey v60;
  uint64_t v61;
  uint64_t v62;
  AAFieldKey v63;
  AAFieldKey v64;
  uint64_t v65;
  uint64_t v66;
  AAFieldKey v67;
  AAFieldKey v68;
  int v69;
  mode_t st_mode;
  AAFieldKey v71;
  uint64_t v72;
  AAFieldKey v73;
  AAFieldKey v74;
  uint32_t KeyIndex;
  unsigned int FieldHash;
  int v77;
  AAFieldKey v78;
  AAFieldKey v79;
  uint32_t v80;
  unsigned int v81;
  int v82;
  AAFieldKey v83;
  AAFieldKey v84;
  uint32_t v85;
  unsigned int v86;
  int v87;
  AAFieldKey v88;
  AAFieldKey v89;
  uint32_t v90;
  unsigned int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  __int128 v95;
  size_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  size_t v103;
  void *v104;
  const uint8_t *EncodedData;
  size_t v106;
  size_t v107;
  unint64_t v108;
  void **v109;
  size_t v110;
  unint64_t v111;
  unint64_t v112;
  size_t v113;
  void *v114;
  char *v115;
  size_t *v116;
  size_t v117;
  size_t v118;
  unint64_t v119;
  size_t v120;
  unint64_t v121;
  unint64_t v122;
  size_t v123;
  void *v124;
  char *v125;
  size_t *v126;
  size_t v127;
  const uint8_t *v128;
  size_t v129;
  unint64_t v130;
  size_t v131;
  unint64_t v132;
  unint64_t v133;
  size_t v134;
  void *v135;
  char *v136;
  size_t *v137;
  size_t v138;
  const void *v139;
  uint64_t v140;
  unint64_t v141;
  size_t v142;
  unint64_t v143;
  unint64_t v144;
  size_t v145;
  void *v146;
  char *v147;
  size_t *v148;
  size_t v149;
  size_t v150;
  BOOL v151;
  unint64_t v152;
  void *v153;
  unint64_t v154;
  unint64_t v155;
  size_t v156;
  void **v157;
  void *v158;
  char *v159;
  size_t *v160;
  char *v162;
  void *v163;
  void *v164;
  uint8_t *value;
  uint8_t *valuea;
  uint8_t *valueb;
  uint8_t *valuee;
  uint8_t *valuec;
  uint8_t *valuef;
  uint8_t *valued;
  int v172;
  char v173;
  void *v174;
  void *v175;
  uint64_t v176;
  char v177;
  void *v178;
  char __src;
  const uint8_t *__srca;
  void *__srcb;
  void *__srce;
  void *__srcc;
  void *__srcf;
  void *__srcd;
  size_t *v186;
  void **v187;
  size_t *v188;
  uint64_t v189;
  AAEntryXATBlob_impl *xat;
  char *__s;
  AAHashFunction hash_function;
  size_t path_length;
  uint64_t size[2];
  void *v195;
  stat v196;
  __int128 v197;
  int v198;
  char v199[2048];
  char path[1024];
  uint64_t v201;

  v201 = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  v189 = **a1;
  bzero(path, 0x400uLL);
  bzero(v199, 0x800uLL);
  v5 = AAHeaderCreate();
  if (v5)
  {
    v6 = 1;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 168, 14, 0, "creating header", v3, v4, (char)v162);
    v6 = 0;
  }
  v9 = AAEntryXATBlobCreate();
  if (!v9)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 170, 14, 0, "creating XAT field", v7, v8, (char)v162);
    v6 = 0;
  }
  v12 = AAEntryACLBlobCreate();
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 172, 14, 0, "creating XAT field", v10, v11, (char)v162);
    v6 = 0;
  }
  xat = v9;
  v15 = (void **)AAEntryYECBlobCreate();
  if (!v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 174, 14, 0, "creating YEC field", v13, v14, (char)v162);
    v6 = 0;
  }
  memset(&v196, 0, sizeof(v196));
  size[0] = 0;
  size[1] = 0;
  v195 = 0;
  v16 = v2[136];
  v17 = a1[1];
  v18 = (unint64_t *)(v16 + 40 * (_QWORD)v17);
  v19 = *v18;
  v21 = v18[1];
  v20 = v18 + 1;
  if (v19 < v21)
  {
    v22 = (unsigned int *)(v2 + 140);
    v23 = *((_DWORD *)v2 + 280) != 0;
    __s = (char *)(v2 + 3);
    v24 = v16 + 40 * (_QWORD)v17;
    v186 = (size_t *)(v24 + 24);
    v187 = (void **)(v24 + 32);
    v188 = (size_t *)(v24 + 16);
    do
    {
      v25 = v2[144];
      v26 = v25 + (v19 << 7);
      if (v23 || *v22)
      {
        v6 = 0;
        v27 = 1;
        v23 = 1;
        goto LABEL_15;
      }
      path_length = 0;
      if (AAPathListNodeGetPath((AAPathList)v2[1], *(_QWORD *)(v25 + (v19 << 7) + 24), 0x400uLL, path, &path_length) < 0)
      {
        v43 = 192;
        v44 = "AAPathListNodeGetPath";
        goto LABEL_39;
      }
      if ((concatPath(v199, 0x800uLL, __s, path) & 0x80000000) != 0)
      {
        v43 = 193;
        v44 = "invalid path";
        goto LABEL_39;
      }
      v30 = (uint64_t (*)(uint64_t, uint64_t, char *, _QWORD))v2[132];
      if (v30 && (v30(v2[131], 30, path, 0) & 0x80000000) != 0)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 199, 14, "operation aborted", v31, v32, v33, (char)v162);
        while (!__ldaxr(v22))
        {
          v27 = 1;
          v23 = __stlxr(1u, v22);
          if (!v23)
          {
            v6 = 0;
            goto LABEL_15;
          }
        }
        v23 = 0;
        v6 = 0;
        __clrex();
        goto LABEL_41;
      }
      if (lstat(v199, &v196) < 0)
      {
        v45 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 202, 14, v45, "lstat %s", v46, v47, (char)v199);
LABEL_40:
        v23 = 0;
        v6 = 0;
LABEL_41:
        v27 = 1;
        goto LABEL_15;
      }
      if ((aaHeaderInitWithPath(v5, (AAFieldKeySet_impl *)v2[2], __s, path) & 0x80000000) != 0)
      {
        v43 = 203;
        v44 = "initializing header from path";
LABEL_39:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", v43, 14, 0, v44, v28, v29, (char)v162);
        goto LABEL_40;
      }
      v34.ikey = 5521732;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v34))
      {
        if ((v196.st_mode & 0xF000) == 0x8000)
        {
          v35.ikey = 5521732;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v35, v196.st_size) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 209, 14, 0, "inserting DAT: %s", v36, v37, (char)v199);
            goto LABEL_40;
          }
        }
      }
      v38.ikey = 5521752;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v38))
      {
        if ((aaEntryXATBlobInitWithPath(xat, __s, path) & 0x80000000) != 0)
        {
          v49 = 216;
          v50 = "initializing XAT field from path";
LABEL_127:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", v49, 14, 0, v50, v39, v40, (char)v162);
          v23 = 0;
          v6 = 0;
          v27 = 1;
          goto LABEL_15;
        }
        if (AAEntryXATBlobGetEntryCount(xat))
        {
          EncodedSize = AAEntryXATBlobGetEncodedSize(xat);
          v42.ikey = 5521752;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v42, EncodedSize) < 0)
          {
            v162 = v199;
            v49 = 220;
            v50 = "inserting XAT: %s";
            goto LABEL_127;
          }
          __src = 0;
        }
        else
        {
          __src = 1;
        }
      }
      else
      {
        __src = 1;
      }
      v51.ikey = 4997953;
      if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v51))
        goto LABEL_54;
      v52 = v196.st_mode & 0xF000;
      if (v52 != 0x8000 && v52 != 0x4000)
        goto LABEL_54;
      v53 = AAEntryACLBlobCreate();
      v12 = v53;
      if (!v53)
      {
        v43 = 229;
        v44 = "creating ACL field";
        goto LABEL_39;
      }
      if ((aaEntryACLBlobInitWithPath(v53, __s, path, v189) & 0x80000000) != 0)
      {
        v43 = 230;
        v44 = "initializing ACL field from path";
        goto LABEL_39;
      }
      if (AAEntryACLBlobGetEntryCount(v12))
      {
        v54 = AAEntryACLBlobGetEncodedSize(v12);
        v55.ikey = 4997953;
        if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v55, v54) < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 234, 14, 0, "inserting ACL: %s", v56, v57, (char)v199);
          goto LABEL_40;
        }
        v173 = 0;
      }
      else
      {
LABEL_54:
        v173 = 1;
      }
      v58.ikey = 4408665;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v58))
      {
        v177 = 1;
        if ((v196.st_mode & 0xF000) == 0x8000 && v196.st_size >= 1)
        {
          if ((aaEntryYECBlobInitWithPath(v15, 65552, __s, path) & 0x80000000) != 0)
          {
            v43 = 242;
            v44 = "initializing YEC field from path";
            goto LABEL_39;
          }
          v59 = AAEntryYECBlobGetEncodedSize((uint64_t)v15);
          v60.ikey = 4408665;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v60, v59) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 244, 14, 0, "inserting YEC: %s", v61, v62, (char)v199);
            goto LABEL_40;
          }
          v177 = 0;
        }
      }
      else
      {
        v177 = 1;
      }
      v63.ikey = 5260889;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v63))
      {
        v172 = 1;
        if ((v196.st_mode & 0xF000) == 0x8000 && v196.st_size >= 1)
        {
          if ((aaEntryYFPBlobInitWithPath(size, __s, path) & 0x80000000) != 0)
          {
            v43 = 251;
            v44 = "initializing YFP field from path";
            goto LABEL_39;
          }
          v64.ikey = 5260889;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v64, size[0]) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 253, 14, 0, "inserting YFP: %s", v65, v66, (char)v199);
            goto LABEL_40;
          }
          v172 = 0;
        }
      }
      else
      {
        v172 = 1;
      }
      v67.ikey = 4410440;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v67)
        && (v196.st_mode & 0xF000) == 0x8000
        && v196.st_nlink >= 2u)
      {
        *(_QWORD *)(v25 + (v19 << 7) + 32) = v196.st_ino;
      }
      v68.ikey = 4410435;
      v69 = AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v68);
      st_mode = v196.st_mode;
      if (v69 && (v196.st_mode & 0xF000) == 0x8000)
      {
        v197 = 0uLL;
        if (!fsctl(v199, 0x40104A0EuLL, &v197, 0) && (_QWORD)v197 == 2)
          *(_QWORD *)(v25 + (v19 << 7) + 40) = *((_QWORD *)&v197 + 1);
        st_mode = v196.st_mode;
      }
      v176 = (uint64_t)v15;
      if ((st_mode & 0xF000) == 0x8000)
      {
        v71.ikey = 4410451;
        if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v71))
        {
          v72 = v25 + (v19 << 7);
          *(_QWORD *)(v72 + 48) = 0;
          value = (uint8_t *)(v72 + 56);
          memset_s((void *)(v72 + 56), 0x40uLL, 0, 0x40uLL);
          hash_function = 0;
          v73.ikey = 3491923;
          if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v73))
            goto LABEL_92;
          v74.ikey = 3491923;
          KeyIndex = AAHeaderGetKeyIndex(v5, v74);
          if ((KeyIndex & 0x80000000) != 0)
            goto LABEL_92;
          FieldHash = AAHeaderGetFieldHash(v5, KeyIndex, 0x40uLL, &hash_function, value);
          v77 = FieldHash <= 1 ? 1 : FieldHash;
          if (v77 <= 0)
          {
LABEL_92:
            if ((v78.ikey = 3360851, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v78))
              || (v79.ikey = 3360851, v80 = AAHeaderGetKeyIndex(v5, v79), (v80 & 0x80000000) != 0)
              || ((v81 = AAHeaderGetFieldHash(v5, v80, 0x40uLL, &hash_function, value), v81 <= 1)
                ? (v82 = 1)
                : (v82 = v81),
                  v82 <= 0))
            {
              if ((v83.ikey = 3295315, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v83))
                || (v84.ikey = 3295315, v85 = AAHeaderGetKeyIndex(v5, v84), (v85 & 0x80000000) != 0)
                || ((v86 = AAHeaderGetFieldHash(v5, v85, 0x40uLL, &hash_function, value), v86 <= 1)
                  ? (v87 = 1)
                  : (v87 = v86),
                    v87 <= 0))
              {
                if ((v88.ikey = 3229779, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v88))
                  || (v89.ikey = 3229779, v90 = AAHeaderGetKeyIndex(v5, v89), (v90 & 0x80000000) != 0)
                  || ((v91 = AAHeaderGetFieldHash(v5, v90, 0x40uLL, &hash_function, value), v91 <= 1)
                    ? (v92 = 1)
                    : (v92 = v91),
                      v92 <= 0))
                {
                  v197 = 0uLL;
                  v198 = 0;
                  if ((getFileSHA1Digest(v199, (uint64_t)&v197) & 0x80000000) != 0)
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 284, 14, 0, "hashing file: %s", v93, v94, (char)v199);
                    v23 = 0;
                    v6 = 0;
                    v27 = 1;
LABEL_261:
                    v15 = (void **)v176;
                    goto LABEL_15;
                  }
                  v95 = v197;
                  *((_DWORD *)value + 4) = v198;
                  *(_OWORD *)value = v95;
                }
              }
            }
          }
        }
      }
      v96 = AAHeaderGetEncodedSize(v5);
      if ((__src & 1) == 0)
        v96 += AAEntryXATBlobGetEncodedSize(xat);
      if ((v173 & 1) == 0)
        v96 += AAEntryACLBlobGetEncodedSize(v12);
      if ((v177 & 1) == 0)
        v96 += AAEntryYECBlobGetEncodedSize(v176);
      v97 = size[0];
      if (v172)
        v97 = 0;
      v98 = v97 + v96;
      *(_QWORD *)v26 = *v188;
      v99 = v25 + (v19 << 7);
      *(_QWORD *)(v99 + 8) = v98;
      *(_QWORD *)(v99 + 16) = AAHeaderGetEncodedSize(v5);
      v100 = *v188 + v98;
      v15 = (void **)v176;
      if ((v100 & 0x8000000000000000) != 0)
        goto LABEL_152;
      v101 = *v186;
      if (*v186 < v100)
      {
        do
        {
          while (!v101)
          {
            v101 = 0x4000;
            v103 = 0x4000;
            if (v100 <= 0x4000)
              goto LABEL_131;
          }
          v102 = v101 >> 1;
          if ((v101 & (v101 >> 1)) != 0)
            v102 = v101 & (v101 >> 1);
          v101 += v102;
        }
        while (v101 < v100);
        v103 = v101;
        if (v101 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_151;
        }
LABEL_131:
        valuea = (uint8_t *)*v187;
        v104 = realloc(*v187, v103);
        if (v104)
        {
          *v187 = v104;
          *v186 = v103;
          v15 = (void **)v176;
          goto LABEL_133;
        }
        free(valuea);
LABEL_151:
        *v188 = 0;
        v188[1] = 0;
        v188[2] = 0;
        v15 = (void **)v176;
LABEL_152:
        v43 = 302;
        v44 = "reallocating block blob";
        goto LABEL_39;
      }
LABEL_133:
      EncodedData = AAHeaderGetEncodedData(v5);
      v106 = AAHeaderGetEncodedSize(v5);
      v107 = *v188;
      v108 = *v188 + v106;
      if (__CFADD__(*v188, v106))
        goto LABEL_135;
      v109 = v187;
      if ((v108 & 0x8000000000000000) == 0)
      {
        v110 = v106;
        v111 = *v186;
        if (*v186 < v108)
        {
          do
          {
            while (!v111)
            {
              v111 = 0x4000;
              v113 = 0x4000;
              if (v108 <= 0x4000)
                goto LABEL_155;
            }
            v112 = v111 >> 1;
            if ((v111 & (v111 >> 1)) != 0)
              v112 = v111 & (v111 >> 1);
            v111 += v112;
          }
          while (v111 < v108);
          v113 = v111;
          if (v111 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_252;
          }
LABEL_155:
          valueb = (uint8_t *)v106;
          v163 = *v187;
          v114 = realloc(*v187, v113);
          if (v114)
          {
            *v187 = v114;
            *v186 = v113;
            v15 = (void **)v176;
            v109 = v187;
            v110 = (size_t)valueb;
            goto LABEL_157;
          }
          free(v163);
LABEL_252:
          v107 = 0;
          *v188 = 0;
          v188[1] = 0;
          v188[2] = 0;
          v15 = (void **)v176;
LABEL_135:
          v109 = v187;
          goto LABEL_163;
        }
LABEL_157:
        v115 = (char *)*v109;
        if (EncodedData)
        {
          valuee = (uint8_t *)v110;
          memcpy(&v115[*v188], EncodedData, v110);
          v110 = (size_t)valuee;
          v109 = v187;
          v116 = v188;
        }
        else
        {
          v116 = v188;
          if (v115)
          {
            v117 = v110;
            memset_s(&v115[*v188], v110, 0, v110);
            v110 = v117;
            v109 = v187;
            v116 = v188;
          }
        }
        v107 = *v116 + v110;
        *v116 = v107;
      }
LABEL_163:
      if ((__src & 1) != 0)
        goto LABEL_185;
      __srca = AAEntryXATBlobGetEncodedData(xat);
      v118 = AAEntryXATBlobGetEncodedSize(xat);
      v107 = *v188;
      v119 = *v188 + v118;
      if (__CFADD__(*v188, v118))
        goto LABEL_166;
      v109 = v187;
      if ((v119 & 0x8000000000000000) == 0)
      {
        v120 = v118;
        v121 = *v186;
        if (*v186 < v119)
        {
          do
          {
            while (!v121)
            {
              v121 = 0x4000;
              v123 = 0x4000;
              if (v119 <= 0x4000)
                goto LABEL_178;
            }
            v122 = v121 >> 1;
            if ((v121 & (v121 >> 1)) != 0)
              v122 = v121 & (v121 >> 1);
            v121 += v122;
          }
          while (v121 < v119);
          v123 = v121;
          if (v121 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_254;
          }
LABEL_178:
          v164 = *v187;
          valuec = (uint8_t *)v118;
          v124 = realloc(*v187, v123);
          if (v124)
          {
            *v187 = v124;
            *v186 = v123;
            v15 = (void **)v176;
            v109 = v187;
            v120 = (size_t)valuec;
            goto LABEL_180;
          }
          free(v164);
LABEL_254:
          v107 = 0;
          *v188 = 0;
          v188[1] = 0;
          v188[2] = 0;
          v15 = (void **)v176;
LABEL_166:
          v109 = v187;
          goto LABEL_185;
        }
LABEL_180:
        v125 = (char *)*v109;
        if (__srca)
        {
          valuef = (uint8_t *)v120;
          memcpy(&v125[*v188], __srca, v120);
          v120 = (size_t)valuef;
          v109 = v187;
          v126 = v188;
        }
        else
        {
          v126 = v188;
          if (v125)
          {
            v127 = v120;
            memset_s(&v125[*v188], v120, 0, v120);
            v120 = v127;
            v109 = v187;
            v126 = v188;
          }
        }
        v107 = *v126 + v120;
        *v126 = v107;
      }
LABEL_185:
      if ((v173 & 1) != 0)
        goto LABEL_207;
      v128 = AAEntryACLBlobGetEncodedData(v12);
      v129 = AAEntryACLBlobGetEncodedSize(v12);
      v107 = *v188;
      v130 = *v188 + v129;
      if (__CFADD__(*v188, v129))
        goto LABEL_188;
      v109 = v187;
      if ((v130 & 0x8000000000000000) == 0)
      {
        v131 = v129;
        v132 = *v186;
        if (*v186 < v130)
        {
          do
          {
            while (!v132)
            {
              v132 = 0x4000;
              v134 = 0x4000;
              if (v130 <= 0x4000)
                goto LABEL_200;
            }
            v133 = v132 >> 1;
            if ((v132 & (v132 >> 1)) != 0)
              v133 = v132 & (v132 >> 1);
            v132 += v133;
          }
          while (v132 < v130);
          v134 = v132;
          if (v132 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_256;
          }
LABEL_200:
          __srcb = (void *)v129;
          valued = (uint8_t *)*v187;
          v135 = realloc(*v187, v134);
          if (v135)
          {
            *v187 = v135;
            *v186 = v134;
            v109 = v187;
            v131 = (size_t)__srcb;
            v15 = (void **)v176;
            goto LABEL_202;
          }
          free(valued);
LABEL_256:
          v107 = 0;
          *v188 = 0;
          v188[1] = 0;
          v188[2] = 0;
          v15 = (void **)v176;
LABEL_188:
          v109 = v187;
          goto LABEL_207;
        }
LABEL_202:
        v136 = (char *)*v109;
        if (v128)
        {
          __srce = (void *)v131;
          memcpy(&v136[*v188], v128, v131);
          v131 = (size_t)__srce;
          v109 = v187;
          v137 = v188;
        }
        else
        {
          v137 = v188;
          if (v136)
          {
            v138 = v131;
            memset_s(&v136[*v188], v131, 0, v131);
            v131 = v138;
            v109 = v187;
            v137 = v188;
          }
        }
        v107 = *v137 + v131;
        *v137 = v107;
      }
LABEL_207:
      if ((v177 & 1) != 0)
        goto LABEL_229;
      v139 = (const void *)AAEntryYECBlobGetEncodedData((uint64_t)v15);
      v140 = AAEntryYECBlobGetEncodedSize((uint64_t)v15);
      v107 = *v188;
      v141 = *v188 + v140;
      if (__CFADD__(*v188, v140))
        goto LABEL_210;
      v109 = v187;
      if ((v141 & 0x8000000000000000) == 0)
      {
        v142 = v140;
        v143 = *v186;
        if (*v186 >= v141)
        {
LABEL_224:
          v147 = (char *)*v109;
          if (v139)
          {
            __srcf = (void *)v142;
            memcpy(&v147[*v188], v139, v142);
            v142 = (size_t)__srcf;
            v109 = v187;
            v148 = v188;
          }
          else
          {
            v148 = v188;
            if (v147)
            {
              v149 = v142;
              memset_s(&v147[*v188], v142, 0, v142);
              v142 = v149;
              v109 = v187;
              v148 = v188;
            }
          }
          v107 = *v148 + v142;
          *v148 = v107;
          goto LABEL_229;
        }
        do
        {
          while (!v143)
          {
            v143 = 0x4000;
            v145 = 0x4000;
            if (v141 <= 0x4000)
              goto LABEL_222;
          }
          v144 = v143 >> 1;
          if ((v143 & (v143 >> 1)) != 0)
            v144 = v143 & (v143 >> 1);
          v143 += v144;
        }
        while (v143 < v141);
        v145 = v143;
        if (v143 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_258;
        }
LABEL_222:
        __srcc = (void *)v140;
        v174 = *v187;
        v146 = realloc(*v187, v145);
        if (v146)
        {
          *v187 = v146;
          *v186 = v145;
          v109 = v187;
          v142 = (size_t)__srcc;
          v15 = (void **)v176;
          goto LABEL_224;
        }
        free(v174);
LABEL_258:
        v107 = 0;
        *v188 = 0;
        v188[1] = 0;
        v188[2] = 0;
        v15 = (void **)v176;
LABEL_210:
        v109 = v187;
      }
LABEL_229:
      if ((v172 & 1) == 0)
      {
        v150 = size[0];
        v151 = __CFADD__(v107, size[0]);
        v152 = v107 + size[0];
        if (!v151 && (v152 & 0x8000000000000000) == 0)
        {
          v153 = v195;
          v154 = *v186;
          __srcd = (void *)size[0];
          if (*v186 < v152)
          {
            do
            {
              while (!v154)
              {
                v154 = 0x4000;
                v156 = 0x4000;
                if (v152 <= 0x4000)
                  goto LABEL_243;
              }
              v155 = v154 >> 1;
              if ((v154 & (v154 >> 1)) != 0)
                v155 = v154 & (v154 >> 1);
              v154 += v155;
            }
            while (v154 < v152);
            v156 = v154;
            if (v154 >= 0x2000000001)
            {
              *__error() = 12;
              goto LABEL_260;
            }
LABEL_243:
            v178 = v195;
            v175 = *v109;
            v157 = v109;
            v158 = realloc(*v109, v156);
            if (v158)
            {
              *v157 = v158;
              *v186 = v156;
              v15 = (void **)v176;
              v153 = v178;
              v109 = v157;
              v150 = (size_t)__srcd;
              goto LABEL_245;
            }
            free(v175);
LABEL_260:
            v27 = 0;
            v23 = 0;
            *v188 = 0;
            v188[1] = 0;
            v188[2] = 0;
            goto LABEL_261;
          }
LABEL_245:
          v159 = (char *)*v109;
          if (v153)
          {
            v160 = v188;
            memcpy(&v159[*v188], v153, v150);
            goto LABEL_249;
          }
          v160 = v188;
          if (v159)
          {
            memset_s(&v159[*v188], v150, 0, (rsize_t)__srcd);
LABEL_249:
            v150 = (size_t)__srcd;
          }
          v27 = 0;
          v23 = 0;
          *v160 += v150;
          goto LABEL_15;
        }
      }
      v27 = 0;
      v23 = 0;
LABEL_15:
      *(_DWORD *)(v26 + 120) = v27;
      ++v19;
    }
    while (v19 < *v20);
  }
  AAHeaderDestroy(v5);
  AAEntryXATBlobDestroy(xat);
  AAEntryACLBlobDestroy(v12);
  AAEntryYECBlobDestroy(v15);
  free(v195);
  memset_s(size, 0x18uLL, 0, 0x18uLL);
  if (v6)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

int AAArchiveStreamWritePathList(AAArchiveStream s, AAPathList path_list, AAFieldKeySet key_set, const char *dir, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v8;
  int v9;
  int DefaultNThreads;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  AAFieldKeySet_impl *v19;
  AAFieldKeySet_impl *v20;
  AAPathList_impl *v21;
  AAPathList_impl *v22;
  _QWORD *v23;
  double RealTime;
  uint64_t v25;
  uint64_t i;
  size_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  __int16 v41;
  void *v42;
  AAHeader_impl *v43;
  unsigned int *v44;
  _BYTE *v45;
  _BYTE *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  size_t v50;
  uint64_t v51;
  char *v52;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unsigned int v68;
  unint64_t v69;
  size_t v70;
  char *v71;
  size_t v72;
  size_t v73;
  uint64_t Worker;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v79;
  char v80;
  const char *v81;
  __int16 v82;
  size_t v84;
  unint64_t v85;
  uint64_t v86;
  char *v87;
  char *v88;
  char *v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  size_t v94;
  size_t v95;
  void *v96;
  void (*v98)(_QWORD);
  size_t v99;
  char *v100;
  size_t v101;
  char *v102;
  size_t v103;
  unint64_t v104;
  const void *v105;
  size_t v106;
  size_t v107;
  void *v108;
  void *v109;
  char *v110;
  void **v111;
  void *v112;
  AAFieldKey v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  _QWORD *v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  AAFieldKey v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  char *v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  uint64_t v143;
  AAFieldKey v144;
  AAFieldKey v145;
  AAFieldKey v146;
  AAFieldKey v147;
  size_t v148;
  uint64_t v149;
  size_t v150;
  char *v151;
  char *v152;
  _QWORD *v153;
  uint64_t v154;
  size_t v155;
  char *v156;
  char *v157;
  size_t v158;
  unint64_t v159;
  unint64_t v160;
  size_t v161;
  unint64_t v162;
  size_t v163;
  uint64_t v164;
  size_t v165;
  uint64_t v166;
  uint64_t v167;
  size_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t *v174;
  uint64_t v175;
  uint64_t v176;
  int *v177;
  uint64_t v178;
  uint64_t v179;
  unsigned int *v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  size_t v185;
  int v186;
  char *v187;
  char *v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  AAFieldKey v197;
  uint32_t KeyIndex;
  char *v199;
  uint64_t v200;
  AAFieldKey v201;
  uint64_t v202;
  AAFieldKey v203;
  uint64_t v204;
  AAFieldKey v205;
  uint64_t (*v206)(_QWORD, AAHeader_impl *);
  char *v207;
  uint32_t v208;
  AAFieldKey FieldKey;
  uint32_t v210;
  AAFieldKey v211;
  int v212;
  int v213;
  int v214;
  int v215;
  uint64_t v216;
  uint64_t v217;
  size_t v218;
  ssize_t v219;
  uint64_t v220;
  uint64_t v221;
  ssize_t v222;
  uint64_t (*v223)(_QWORD, uint64_t, void *, ssize_t);
  uint64_t v224;
  uint64_t (*v225)(_QWORD, _QWORD, char *);
  int v226;
  const char *v227;
  __int16 v228;
  double v229;
  double v230;
  FILE **v231;
  double v232;
  const char *v233;
  __int16 v234;
  int v235;
  uint64_t v236;
  uint64_t v237;
  AAFieldKey *v238;
  uint64_t v239;
  uint64_t *v240;
  int v241;
  uint64_t v242;
  uint32_t v243;
  uint64_t v244;
  uint64_t ikey;
  unint64_t v246;
  uint64_t v247;
  uint32_t FieldCount;
  uint64_t v249;
  uint64_t v250;
  unint64_t v251;
  _QWORD *v252;
  uint64_t v253;
  uint64_t v254;
  BOOL v255;
  uint64_t v256;
  uint64_t v257;
  AAFieldKeySet_impl *v258;
  size_t v259;
  uint64_t v260;
  unint64_t v261;
  int v262;
  size_t v263;
  int v264;
  size_t v265;
  int v266;
  int v267[2];
  int v268[2];
  int v269;
  uint64_t v270;
  uint64_t v271;
  AAFieldKey v272;
  uint64_t size;
  uint64_t offset;
  char path[2048];
  char v276[1024];
  unint64_t v277;
  AAPathList v278;
  AAFieldKeySet_impl *v279;
  char v280[1024];
  uint64_t v281;
  uint64_t v282;
  size_t v283;
  unint64_t v284;
  size_t v285;
  char *v286;
  size_t __count;
  char *v288;
  _QWORD *v289;
  unsigned int v290;
  unint64_t v291;
  unint64_t v292;
  char *v293;
  char *v294;
  uint64_t v295;

  v8 = MEMORY[0x24BDAC7A8](s, path_list, key_set, dir, msg_data, msg_proc, flags, *(_QWORD *)&n_threads);
  DefaultNThreads = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v22 = v21;
  v23 = (_QWORD *)v8;
  v295 = *MEMORY[0x24BDAC8D0];
  bzero(v280, 0x470uLL);
  RealTime = getRealTime();
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v278 = v22;
  v279 = v20;
  v284 = 1024;
  LODWORD(__count) = DefaultNThreads;
  v277 = v12;
  v281 = v16;
  v282 = v14;
  if (!realpath_DARWIN_EXTSN(v18, v280))
  {
    v28 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 375, 14, v28, "%s", v29, v30, (char)v18);
LABEL_19:
    v42 = 0;
    v43 = 0;
    v44 = 0;
LABEL_20:
    v45 = 0;
    v46 = 0;
    goto LABEL_21;
  }
  v25 = AAPathListNodeFirst(v22);
  if (v25 != -1)
  {
    for (i = v25; i != -1; i = AAPathListNodeNext(v22, i))
      ++v283;
  }
  v285 = (v283 + v284 - 1) / v284;
  v27 = v283 << 7;
  if (v283 << 7 >= 0x2000000001)
  {
    *__error() = 12;
    v294 = 0;
LABEL_17:
    v37 = *__error();
    v40 = "malloc";
    v41 = 381;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v41, 14, v37, v40, v38, v39, (char)v238);
    goto LABEL_19;
  }
  v31 = (char *)malloc(v27);
  v294 = v31;
  if (!v31)
    goto LABEL_17;
  memset(v31, 255, v27);
  v32 = AAPathListNodeFirst(v22);
  if (v32 != -1)
  {
    v33 = v32;
    v34 = 24;
    do
    {
      *(_QWORD *)&v294[v34] = v33;
      v33 = AAPathListNodeNext(v22, v33);
      v34 += 128;
    }
    while (v33 != -1);
  }
  if (is_mul_ok(v285, 0x28uLL) && 40 * v285 < 0x2000000001)
  {
    v36 = (char *)calloc(v285, 0x28uLL);
  }
  else
  {
    v35 = __error();
    v36 = 0;
    *v35 = 12;
  }
  v286 = v36;
  v288 = (char *)calloc(__count, 0x10uLL);
  v54 = calloc(__count, 8uLL);
  v289 = v54;
  if (!v286 || !v288 || (v55 = (uint64_t)v54) == 0)
  {
    v37 = *__error();
    v40 = "malloc";
    v41 = 389;
    goto LABEL_18;
  }
  v56 = __count;
  if ((_DWORD)__count)
  {
    v57 = 0;
    do
    {
      v58 = &v288[16 * v57];
      *(_QWORD *)v58 = &v277;
      v289[v57++] = v58;
    }
    while (v57 != v56);
    v55 = (uint64_t)v289;
  }
  v44 = ThreadPoolCreate(v56, v55, (uint64_t)appendPathListWorkerProc);
  if (!v44)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 398, 14, 0, "ThreadPoolCreate", v64, v65, (char)v238);
    v42 = 0;
    v43 = 0;
    goto LABEL_20;
  }
  if (v285)
  {
    v66 = v12;
    v67 = 0;
    v68 = 1;
    while (1)
    {
      if (v290)
      {
LABEL_50:
        v80 = 0;
        goto LABEL_57;
      }
      v69 = v284;
      v70 = v284 * v67;
      v71 = &v286[40 * v67];
      *(_QWORD *)v71 = v284 * v67;
      v72 = v69 * v67 + v69;
      *((_QWORD *)v71 + 1) = v72;
      v73 = v283;
      if (v70 >= v283)
        *(_QWORD *)v71 = v283;
      if (v72 >= v73)
        *((_QWORD *)v71 + 1) = v73;
      Worker = ThreadPoolGetWorker((uint64_t)v44, v59, v60, v61, v62, v63, v64, v65);
      if (!Worker)
      {
        v81 = "ThreadPoolGetWorker";
        v82 = 410;
        goto LABEL_56;
      }
      *(_QWORD *)(Worker + 8) = v67;
      if ((ThreadPoolRunWorker((uint64_t)v44, Worker, v75, v76, v77, v78, v64, v65) & 0x80000000) != 0)
        break;
      v67 = v68;
      v79 = v285 > v68++;
      if (!v79)
        goto LABEL_50;
    }
    v81 = "ThreadPoolRunWorker";
    v82 = 412;
LABEL_56:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v82, 14, 0, v81, v64, v65, (char)v238);
    v80 = 1;
LABEL_57:
    v12 = v66;
  }
  else
  {
    v80 = 0;
  }
  if ((ThreadPoolDestroy((uint64_t)v44) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 416, 14, 0, "ThreadPoolDestroy", v38, v39, (char)v238);
    if (!atomic_load(&v290))
      goto LABEL_19;
LABEL_78:
    v98 = (void (*)(_QWORD))v23[2];
    if (v98)
      v98(*v23);
    goto LABEL_19;
  }
  if (atomic_load(&v290))
    goto LABEL_78;
  if ((v80 & 1) != 0)
    goto LABEL_19;
  v251 = v12;
  v252 = v23;
  v84 = v285;
  if (v285)
  {
    v85 = 0;
    v86 = 0;
    v87 = v286;
    v88 = v294;
    do
    {
      v89 = &v87[40 * v86];
      v91 = *(_QWORD *)v89;
      v90 = *((_QWORD *)v89 + 1);
      v79 = v90 > v91;
      v92 = v90 - v91;
      if (v79)
      {
        v93 = &v88[128 * v91];
        do
        {
          *(_QWORD *)v93 += v85;
          v93 += 128;
          --v92;
        }
        while (v92);
      }
      v85 += *(_QWORD *)&v87[40 * v86++ + 16];
    }
    while (v86 != v84);
    if ((v85 & 0x8000000000000000) == 0)
    {
      v94 = v292;
      if (v292 >= v85)
      {
        v99 = 1;
        goto LABEL_86;
      }
      do
      {
        while (!v94)
        {
          v94 = 0x4000;
          if (v85 <= 0x4000)
          {
            v96 = v293;
            v94 = 0x4000;
            goto LABEL_84;
          }
        }
        v95 = v94 >> 1;
        if ((v94 & (v94 >> 1)) != 0)
          v95 = v94 & (v94 >> 1);
        v94 += v95;
      }
      while (v94 < v85);
      if (v94 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_272;
      }
      v96 = v293;
LABEL_84:
      v100 = (char *)realloc(v96, v94);
      if (v100)
      {
        v293 = v100;
        v292 = v94;
        v99 = v285;
LABEL_86:
        if (v99)
        {
          v101 = 0;
          do
          {
            v102 = &v286[40 * v101];
            v103 = *((_QWORD *)v102 + 2);
            v104 = v291 + v103;
            if (!__CFADD__(v291, v103) && (v104 & 0x8000000000000000) == 0)
            {
              v105 = (const void *)*((_QWORD *)v102 + 4);
              v106 = v292;
              if (v292 >= v104)
              {
LABEL_103:
                if (v105)
                {
                  memcpy(&v293[v291], v105, v103);
                }
                else if (v293)
                {
                  memset_s(&v293[v291], v103, 0, v103);
                }
                v291 += v103;
              }
              else
              {
                do
                {
                  while (!v106)
                  {
                    v106 = 0x4000;
                    if (v104 <= 0x4000)
                    {
                      v108 = v293;
                      v106 = 0x4000;
                      goto LABEL_101;
                    }
                  }
                  v107 = v106 >> 1;
                  if ((v106 & (v106 >> 1)) != 0)
                    v107 = v106 & (v106 >> 1);
                  v106 += v107;
                }
                while (v106 < v104);
                if (v106 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_109;
                }
                v108 = v293;
LABEL_101:
                v109 = v108;
                v110 = (char *)realloc(v108, v106);
                if (v110)
                {
                  v293 = v110;
                  v292 = v106;
                  goto LABEL_103;
                }
                free(v109);
LABEL_109:
                v291 = 0;
                v292 = 0;
                v293 = 0;
              }
            }
            v111 = (void **)&v286[40 * v101];
            v112 = v111 + 2;
            free(v111[4]);
            memset_s(v112, 0x18uLL, 0, 0x18uLL);
            ++v101;
          }
          while (v101 < v285);
        }
        goto LABEL_111;
      }
      free(v96);
LABEL_272:
      v293 = 0;
      v291 = 0;
      v292 = 0;
    }
    v40 = "allocating final blob";
    v41 = 430;
    v37 = 0;
    goto LABEL_18;
  }
LABEL_111:
  v113.ikey = 4410440;
  if (AAFieldKeySetContainsKey(v20, v113))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_hlc);
    v114 = v283;
    if (v283)
    {
      v115 = 0;
      v116 = 0;
      v117 = 0;
      v118 = v294;
      while (1)
      {
        v119 = &v118[128 * v116];
        v122 = *((_QWORD *)v119 + 4);
        v120 = v119 + 32;
        v121 = v122;
        if (v122 == -1)
        {
LABEL_128:
          v250 = v117;
          v254 = v115;
          goto LABEL_131;
        }
        v123 = v116 + 1;
        if (v116 + 1 < v114)
        {
          v124 = 1;
          v125 = &v118[128 * v116 + 160];
          while (1)
          {
            v126 = *(_QWORD *)v125;
            v125 += 128;
            if (v126 != v121)
              break;
            ++v124;
            if (!(v116 - v114 + v124))
            {
              v124 = v114 - v116;
              v123 = v114;
              goto LABEL_121;
            }
          }
          v123 = v116 + v124;
LABEL_121:
          if (!v124)
            goto LABEL_126;
          if (v124 != 1)
            break;
        }
        *v120 = -1;
LABEL_127:
        v116 = v123;
        if (v123 >= v114)
          goto LABEL_128;
      }
      v127 = v124;
      do
      {
        *v120 = v115;
        v120 += 16;
        --v127;
      }
      while (v127);
LABEL_126:
      ++v115;
      v117 += v124;
      goto LABEL_127;
    }
    v254 = 0;
    v250 = 0;
LABEL_131:
    v128 = 1;
  }
  else
  {
    v254 = 0;
    v250 = 0;
    v128 = 0;
  }
  v129.ikey = 4410435;
  if (AAFieldKeySetContainsKey(v20, v129))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_clc);
    v130 = v283;
    if (v283)
    {
      v131 = 0;
      v132 = 0;
      v133 = 0;
      v134 = v294;
      while (1)
      {
        v135 = &v134[128 * v132];
        v138 = *((_QWORD *)v135 + 5);
        v136 = v135 + 40;
        v137 = v138;
        if (v138 == -1)
        {
LABEL_149:
          v249 = v133;
          v253 = v131;
          goto LABEL_152;
        }
        v139 = v132 + 1;
        if (v132 + 1 < v130)
        {
          v140 = 1;
          v141 = &v134[128 * v132 + 168];
          while (1)
          {
            v142 = *(_QWORD *)v141;
            v141 += 128;
            if (v142 != v137)
              break;
            ++v140;
            if (!(v132 - v130 + v140))
            {
              v140 = v130 - v132;
              v139 = v130;
              goto LABEL_142;
            }
          }
          v139 = v132 + v140;
LABEL_142:
          if (!v140)
            goto LABEL_147;
          if (v140 != 1)
            break;
        }
        *v136 = -1;
LABEL_148:
        v132 = v139;
        if (v139 >= v130)
          goto LABEL_149;
      }
      v143 = v140;
      do
      {
        *v136 = v131;
        v136 += 16;
        --v143;
      }
      while (v143);
LABEL_147:
      ++v131;
      v133 += v140;
      goto LABEL_148;
    }
    v253 = 0;
    v249 = 0;
LABEL_152:
    v128 = 1;
  }
  else
  {
    v253 = 0;
    v249 = 0;
  }
  v144.ikey = 4410451;
  if (AAFieldKeySetContainsKey(v20, v144))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_slc);
    v145.ikey = 3295315;
    v255 = 1;
    if (!AAFieldKeySetContainsKey(v20, v145))
    {
      v146.ikey = 3360851;
      if (!AAFieldKeySetContainsKey(v20, v146))
      {
        v147.ikey = 3491923;
        if (!AAFieldKeySetContainsKey(v20, v147))
          v255 = 0;
      }
    }
    v148 = v283;
    if (v283)
    {
      v149 = 0;
      v150 = 0;
      v257 = 0;
      v258 = v20;
      v47 = 1;
      while (1)
      {
        v151 = v294;
        v152 = &v294[128 * v150];
        v154 = *((_QWORD *)v152 + 6);
        v153 = v152 + 48;
        if (v154 == -1)
          goto LABEL_189;
        v155 = v150 + 1;
        if (v150 + 1 >= v148)
          goto LABEL_168;
        v263 = v148;
        v265 = v150 + 1;
        *(_QWORD *)v267 = v150;
        v270 = v149;
        v156 = &v294[128 * v150 + 56];
        v261 = v148 - v150;
        v259 = v150 << 7;
        v157 = &v294[128 * v150 + 184];
        v158 = v150 - v148;
        v159 = 1;
        while (!memcmp(v156, v157, 0x40uLL))
        {
          ++v159;
          v157 += 128;
          if (!(v158 + v159))
          {
            v159 = v261;
            v160 = v263;
            v161 = *(_QWORD *)v267;
            goto LABEL_167;
          }
        }
        v161 = *(_QWORD *)v267;
        v160 = *(_QWORD *)v267 + v159;
LABEL_167:
        v162 = v159 - 1;
        v20 = v258;
        v149 = v270;
        v155 = v265;
        if (v159 == 1)
        {
LABEL_168:
          *v153 = -1;
          v150 = v155;
        }
        else
        {
          v163 = v160;
          if (v255)
            goto LABEL_178;
          v164 = *(_QWORD *)&v151[128 * v161 + 24];
          v165 = v161;
          if ((AAPathListNodeGetPath(v22, v164, 0x400uLL, path, 0) & 0x80000000) == 0)
          {
            if (v159 >= 2)
            {
              v168 = v259 + 152;
              do
              {
                if (AAPathListNodeGetPath(v22, *(_QWORD *)&v294[v168], 0x400uLL, v276, 0) < 0)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 528, 14, 0, "AAPathListNodeGetPath", v169, v170, (char)v238);
                  v47 = 0;
                }
                else if ((int)areFilesEqual2() < 1)
                {
                  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 529, 14, "Hash collision detected: %s != %s", v171, v172, v173, (char)path);
                  v175 = 0;
                  v176 = -1;
                  goto LABEL_179;
                }
                v168 += 128;
                --v162;
              }
              while (v162);
            }
LABEL_178:
            v257 += v159;
            v175 = 1;
            v176 = v270;
LABEL_179:
            v149 = v270 + v175;
            if (v159)
            {
              v174 = (uint64_t *)&v294[v259 + 48];
              do
              {
                *v174 = v176;
                v174 += 16;
                --v159;
              }
              while (v159);
            }
            v150 = v163;
            goto LABEL_183;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 525, 14, 0, "AAPathListNodeGetPath", v166, v167, (char)v238);
          v47 = 0;
          v150 = v165;
        }
LABEL_183:
        v148 = v283;
        if (v150 >= v283)
          goto LABEL_189;
      }
    }
    v257 = 0;
    v149 = 0;
    v47 = 1;
  }
  else
  {
    if (!v128)
    {
      v257 = 0;
      v149 = 0;
      v47 = 1;
      goto LABEL_190;
    }
    v257 = 0;
    v149 = 0;
    v47 = 1;
    v148 = v283;
  }
LABEL_189:
  qsort(v294, v148, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_offset);
LABEL_190:
  if ((unint64_t)(v254 + 1) < 0x2000000001)
  {
    v46 = calloc(v254 + 1, 1uLL);
  }
  else
  {
    v46 = 0;
    *__error() = 12;
  }
  if ((unint64_t)(v253 + 1) < 0x2000000001)
  {
    v45 = calloc(v253 + 1, 1uLL);
  }
  else
  {
    v45 = 0;
    *__error() = 12;
  }
  if ((unint64_t)(v149 + 1) >= 0x2000000001)
  {
    v44 = 0;
    *__error() = 12;
LABEL_198:
    v177 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 556, 14, *v177, "malloc", v178, v179, (char)v238);
    v42 = 0;
    v43 = 0;
    goto LABEL_21;
  }
  v180 = (unsigned int *)calloc(v149 + 1, 1uLL);
  v44 = v180;
  if (!v46 || !v45 || !v180)
    goto LABEL_198;
  v43 = AAHeaderCreate();
  if (!v43)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 560, 14, 0, "Header creation", v181, v182, (char)v238);
    v42 = 0;
    goto LABEL_21;
  }
  v42 = malloc(0x40000uLL);
  if (!v42)
  {
    v226 = *__error();
    v227 = "malloc";
    v228 = 562;
LABEL_313:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v228, 14, v226, v227, v183, v184, (char)v238);
    goto LABEL_21;
  }
  v271 = v149;
  if (!v283)
  {
    v264 = 0;
    v262 = 0;
    v266 = 0;
    v242 = 0;
LABEL_276:
    v229 = getRealTime();
    if (v251 >> 62)
    {
      v230 = v229;
      v231 = (FILE **)MEMORY[0x24BDAC8D8];
      fwrite("Archive path list\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      bzero(path, 0x400uLL);
      if (!AAFieldKeySetSerialize(v20, 0x400uLL, path))
        fprintf(*v231, "%12s %s\n", "fields", path);
      fprintf(*v231, "%12llu entries\n", v283);
      if (v254)
        fprintf(*v231, "%12llu entries in %llu hard link clusters (HLC)\n", v250, v254);
      if (v253)
        fprintf(*v231, "%12llu entries in %llu clone clusters (CLC)\n", v249, v253);
      if (v271)
        fprintf(*v231, "%12llu entries in %llu same data clusters (SLC)\n", v257, v271);
      if (v262)
        fprintf(*v231, "%12u entries with XAT field\n", v262);
      if (v266)
        fprintf(*v231, "%12u entries with ACL field\n", v266);
      v232 = v230 - RealTime;
      if (v264)
        fprintf(*v231, "%12u entries with YEC field\n", v266);
      fprintf(*v231, "%12llu bytes in regular files DAT\n", v242);
      fprintf(*v231, "%12.2f time (s)\n", v232);
    }
    goto LABEL_22;
  }
  v185 = 0;
  v242 = 0;
  v266 = 0;
  v262 = 0;
  v264 = 0;
  v186 = 0;
  while (1)
  {
    v187 = v294;
    *(_QWORD *)v268 = v185;
    v188 = &v294[128 * v185];
    v190 = *(_QWORD *)v188;
    v189 = *((_QWORD *)v188 + 1);
    v191 = *((_QWORD *)v188 + 2);
    v256 = v189 - v191;
    if (v189 < v191 || v190 >= v291)
    {
      v227 = "invalid header blob size";
      v228 = 570;
LABEL_312:
      v226 = 0;
      goto LABEL_313;
    }
    v244 = *((_QWORD *)v188 + 2);
    v246 = *(_QWORD *)v188;
    if ((aaHeaderInitWithEncodedData((uint64_t)v43, (unsigned __int16 *)&v293[v190], v191) & 0x80000000) != 0)
    {
      v227 = "parse stored header";
      v228 = 571;
      goto LABEL_312;
    }
    if ((v251 & 2) != 0)
    {
      v193 = &v187[128 * *(_QWORD *)v268];
      v194 = *((_QWORD *)v193 + 4);
      if (v194 == -1)
      {
        v195 = *((_QWORD *)v193 + 5);
        if (v195 == -1)
        {
          v196 = *(_QWORD *)&v187[128 * *(_QWORD *)v268 + 48];
          if (v196 == -1)
            goto LABEL_222;
          if (!*((_BYTE *)v44 + v196))
          {
            *((_BYTE *)v44 + v196) = 1;
            goto LABEL_222;
          }
        }
        else if (!v45[v195])
        {
          v45[v195] = 1;
          goto LABEL_222;
        }
      }
      else if (!v46[v194])
      {
        v46[v194] = 1;
        goto LABEL_222;
      }
      v197.ikey = 5521732;
      KeyIndex = AAHeaderGetKeyIndex(v43, v197);
      if ((KeyIndex & 0x80000000) == 0)
        AAHeaderRemoveField(v43, KeyIndex);
    }
LABEL_222:
    v241 = v186;
    v199 = &v187[128 * *(_QWORD *)v268];
    v200 = *((_QWORD *)v199 + 4);
    if (v200 != -1)
    {
      v201.ikey = 4410440;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v201, v200) < 0)
      {
        v227 = "add HLC field";
        v228 = 605;
        goto LABEL_312;
      }
    }
    v202 = *((_QWORD *)v199 + 5);
    if (v202 != -1)
    {
      v203.ikey = 4410435;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v203, v202) < 0)
      {
        v227 = "add CLC field";
        v228 = 606;
        goto LABEL_312;
      }
    }
    v204 = *(_QWORD *)&v187[128 * *(_QWORD *)v268 + 48];
    if (v204 != -1)
    {
      v205.ikey = 4410451;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v205, v204) < 0)
      {
        v227 = "add SLC field";
        v228 = 607;
        goto LABEL_312;
      }
    }
    v206 = (uint64_t (*)(_QWORD, AAHeader_impl *))v252[3];
    if (!v206 || (v206(*v252, v43) & 0x80000000) != 0)
    {
      v227 = "encoding header";
      v228 = 610;
      goto LABEL_312;
    }
    FieldCount = AAHeaderGetFieldCount(v43);
    if (FieldCount)
      break;
LABEL_265:
    if (v256)
    {
      v227 = "blob byte count mismatch";
      v228 = 681;
      goto LABEL_312;
    }
    v185 = (v241 + 1);
    v186 = v241 + 1;
    if (v283 <= v185)
      goto LABEL_276;
  }
  v260 = 0;
  v247 = v244 + v246;
  v207 = &v187[128 * *(_QWORD *)v268];
  v208 = 0;
  v240 = (uint64_t *)(v207 + 24);
  while (AAHeaderGetFieldType(v43, v208) != 5)
  {
LABEL_264:
    if (++v208 == FieldCount)
      goto LABEL_265;
  }
  size = 0;
  offset = 0;
  FieldKey = AAHeaderGetFieldKey(v43, v208);
  v210 = v208;
  v211 = FieldKey;
  v272 = FieldKey;
  v243 = v210;
  if (AAHeaderGetFieldBlob(v43, v210, &size, &offset) < 0)
  {
    v227 = "get blob location";
    v228 = 622;
    goto LABEL_312;
  }
  if (v260 != offset)
  {
    v227 = "blob segment mismatch";
    v228 = 623;
    goto LABEL_312;
  }
  v212 = v211.ikey & 0xFFFFFF;
  if ((v211.ikey & 0xFFFFFF) == 0x4C4341)
    v213 = v266 + 1;
  else
    v213 = v266;
  v266 = v213;
  if (v212 == 5521752)
    v214 = v262 + 1;
  else
    v214 = v262;
  v262 = v214;
  v215 = v264;
  if (v212 == 4408665)
    v215 = v264 + 1;
  v264 = v215;
  if (v212 != 5521732)
  {
    if (size > v256)
    {
      v238 = &v272;
      v227 = "Blob segment out of range, key=%s";
      v228 = 667;
      goto LABEL_312;
    }
    v225 = (uint64_t (*)(_QWORD, _QWORD, char *))v252[4];
    if (!v225 || (v225(*v252, v211.ikey, &v293[v247]) & 0x80000000) != 0)
    {
      v227 = "sending blob data";
      v228 = 668;
      goto LABEL_312;
    }
    v224 = size;
    v247 += size;
    v256 -= size;
    goto LABEL_263;
  }
  v239 = size;
  if (AAPathListNodeGetPath(v278, *v240, 0x400uLL, v276, 0) < 0)
  {
    v227 = "getting entry path";
    v228 = 638;
    goto LABEL_312;
  }
  if ((concatPath(path, 0x800uLL, v280, v276) & 0x80000000) != 0)
  {
    v227 = "getting entry full path";
    v228 = 639;
    goto LABEL_312;
  }
  v269 = open(path, 0);
  if (v269 < 0)
  {
    v226 = *__error();
    v238 = (AAFieldKey *)path;
    v227 = "%s";
    v228 = 641;
    goto LABEL_313;
  }
  v216 = size;
  if (!size)
  {
LABEL_257:
    close(v269);
    if (!v47)
      goto LABEL_21;
    v242 += v239;
    v47 = 1;
    v224 = size;
LABEL_263:
    v260 += v224;
    v208 = v243;
    goto LABEL_264;
  }
  v217 = 0;
  ikey = v211.ikey;
  while (1)
  {
    if (v217 + 0x40000 <= v216)
      v218 = 0x40000;
    else
      v218 = v216 - v217;
    v219 = read(v269, v42, v218);
    if (v219 < 0)
    {
      v235 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 651, 14, v235, "read: %s", v236, v237, (char)path);
      goto LABEL_297;
    }
    v222 = v219;
    if (!v219)
      break;
    v223 = (uint64_t (*)(_QWORD, uint64_t, void *, ssize_t))v252[4];
    if (!v223 || (v223(*v252, ikey, v42, v219) & 0x80000000) != 0)
    {
      v233 = "sending blob data";
      v234 = 653;
      goto LABEL_296;
    }
    v217 += v222;
    v216 = size;
    if (v217 >= size)
      goto LABEL_257;
  }
  v238 = (AAFieldKey *)path;
  v233 = "truncated: %s";
  v234 = 652;
LABEL_296:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v234, 14, 0, v233, v220, v221, (char)v238);
LABEL_297:
  close(v269);
LABEL_21:
  v47 = 0;
LABEL_22:
  if ((ThreadPoolDestroy(0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 705, 14, 0, "ThreadPoolDestroy", v48, v49, (char)v238);
    v47 = 0;
  }
  if (v286 && v285)
  {
    v50 = 0;
    v51 = 32;
    do
    {
      v52 = &v286[v51 - 16];
      free(*(void **)&v286[v51]);
      memset_s(v52, 0x18uLL, 0, 0x18uLL);
      ++v50;
      v51 += 40;
    }
    while (v50 < v285);
  }
  free(v289);
  free(v288);
  free(v286);
  free(v294);
  free(v42);
  free(v46);
  free(v45);
  free(v44);
  AAHeaderDestroy(v43);
  free(v293);
  memset_s(&v291, 0x18uLL, 0, 0x18uLL);
  if (v47)
    return 0;
  else
    return -1;
}

uint64_t cmp_entries_hlc(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v4 = a1[4];
  v2 = a2[4];
  v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3)
    v4 = v4;
  else
    v4 = 0xFFFFFFFFLL;
  if (!(_DWORD)v4)
  {
    if (*a1 < *a2)
      return 0xFFFFFFFFLL;
    else
      return *a1 != *a2;
  }
  return v4;
}

uint64_t cmp_entries_clc(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v4 = a1[5];
  v2 = a2[5];
  v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3)
    v4 = v4;
  else
    v4 = 0xFFFFFFFFLL;
  if (!(_DWORD)v4)
  {
    if (*a1 < *a2)
      return 0xFFFFFFFFLL;
    else
      return *a1 != *a2;
  }
  return v4;
}

uint64_t cmp_entries_slc(_QWORD *a1, _QWORD *a2)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  _BOOL4 v6;
  uint64_t result;

  v3 = a1[6];
  v4 = a2[6];
  v5 = v3 >= v4;
  v6 = v3 != v4;
  if (v5)
    result = v6;
  else
    result = 0xFFFFFFFFLL;
  if (!(_DWORD)result)
  {
    result = memcmp(a1 + 7, a2 + 7, 0x40uLL);
    if (!(_DWORD)result)
    {
      if (*a1 < *a2)
        return 0xFFFFFFFFLL;
      else
        return *a1 != *a2;
    }
  }
  return result;
}

uint64_t cmp_entries_offset(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 != *a2;
}

AAByteStream AEADecryptionRandomAccessInputStreamOpen(AAByteStream encrypted_stream, AEAContext context, size_t alloc_limit, AAFlagSet flags, int n_threads)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int DefaultNThreads;
  void *v11;
  uint64_t v12;
  uint64_t Existing;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  compression_algorithm v19;
  unsigned int v20;
  _QWORD *v21;
  size_t v22;
  uint64_t v23;
  void *v24;
  size_t v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v31;
  const char *v32;
  __int16 v33;
  char v34;

  DefaultNThreads = n_threads;
  if (n_threads <= 0)
    DefaultNThreads = getDefaultNThreads();
  if (!*((_DWORD *)context + 684) || !*((_QWORD *)context + 341))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionRandomAccessInputStreamOpen", 90, 32, 0, "Invalid context", v5, v6, v34);
    v12 = 0;
    goto LABEL_28;
  }
  v11 = malloc(0x38uLL);
  v12 = (uint64_t)v11;
  if (!v11)
  {
    v31 = *__error();
    v32 = "malloc";
    v33 = 94;
    goto LABEL_27;
  }
  memset_s(v11, 0x38uLL, 0, 0x38uLL);
  *(_QWORD *)v12 = encrypted_stream;
  *(_QWORD *)(v12 + 8) = flags;
  if ((flags & 0x400000000000000) != 0)
    *((_DWORD *)context + 685) = 1;
  Existing = aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 1, 0);
  *(_QWORD *)(v12 + 16) = Existing;
  if (!Existing)
  {
    v32 = "unlock container";
    v33 = 106;
    v31 = 0;
    goto LABEL_27;
  }
  *(_DWORD *)(v12 + 24) = DefaultNThreads;
  v16 = calloc(DefaultNThreads, 0x10uLL);
  *(_QWORD *)(v12 + 32) = v16;
  if (!v16)
  {
    v31 = *__error();
    v32 = "malloc";
    v33 = 111;
    goto LABEL_27;
  }
  v17 = *(_QWORD *)(v12 + 16);
  v18 = *(unsigned int *)(v17 + 24);
  if ((_DWORD)v18)
  {
    v19 = aeaEffectiveCompressionAlgorithm(v18);
    *(_QWORD *)(v12 + 40) = compression_decode_scratch_buffer_size(v19);
    v17 = *(_QWORD *)(v12 + 16);
  }
  v20 = *(_DWORD *)(v12 + 24);
  if (!v20)
  {
LABEL_19:
    *(_OWORD *)context = *(_OWORD *)v17;
    v27 = *(_OWORD *)(v17 + 16);
    v28 = *(_OWORD *)(v17 + 32);
    v29 = *(_OWORD *)(v17 + 48);
    *((_QWORD *)context + 8) = *(_QWORD *)(v17 + 64);
    *((_OWORD *)context + 2) = v28;
    *((_OWORD *)context + 3) = v29;
    *((_OWORD *)context + 1) = v27;
    return (AAByteStream)AAGenericRandomAccessInputStreamOpen(*(_QWORD *)(v17 + 32), *(_DWORD *)(v17 + 16), v20, 4 * v20, v12, (uint64_t)RandomAccessDecryptionStreamGetBlock, (uint64_t)RandomAccessDecryptionStreamAbort, (uint64_t)RandomAccessDecryptionStreamDestroy, flags);
  }
  v21 = *(_QWORD **)(v12 + 32);
  v22 = *(unsigned int *)(v17 + 16);
  v23 = *(unsigned int *)(v12 + 24);
  while (1)
  {
    v24 = malloc(v22);
    v21[1] = v24;
    if (!v24)
    {
      v31 = *__error();
      v32 = "malloc";
      v33 = 120;
      goto LABEL_27;
    }
    v25 = *(_QWORD *)(v12 + 40);
    if (!v25)
      goto LABEL_18;
    if (v25 >= 0x2000000001)
      break;
    v26 = malloc(v25);
    *v21 = v26;
    if (!v26)
      goto LABEL_26;
LABEL_18:
    v21 += 2;
    if (!--v23)
      goto LABEL_19;
  }
  *__error() = 12;
  *v21 = 0;
LABEL_26:
  v31 = *__error();
  v32 = "malloc";
  v33 = 124;
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionRandomAccessInputStreamOpen", v33, 32, v31, v32, v14, v15, v34);
LABEL_28:
  RandomAccessDecryptionStreamDestroy(v12);
  return 0;
}

uint64_t RandomAccessDecryptionStreamDestroy(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  void *v6;
  rsize_t v7;
  void *v8;
  unint64_t v9;
  rsize_t v10;

  if (a1)
  {
    v2 = *(void **)(a1 + 32);
    if (!v2)
    {
LABEL_15:
      aeaContainerDestroy(*(_QWORD *)(a1 + 16));
      memset_s((void *)a1, 0x38uLL, 0, 0x38uLL);
      free((void *)a1);
      return 0;
    }
    if (*(_DWORD *)(a1 + 24))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v5 = *(_QWORD *)(a1 + 32) + v3;
        v6 = *(void **)(v5 + 8);
        if (v6)
        {
          v7 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 16);
          memset_s(v6, v7, 0, v7);
        }
        free(v6);
        v8 = *(void **)v5;
        if (*(_QWORD *)v5)
          memset_s(*(void **)v5, *(_QWORD *)(a1 + 40), 0, *(_QWORD *)(a1 + 40));
        free(v8);
        ++v4;
        v9 = *(unsigned int *)(a1 + 24);
        v3 += 16;
      }
      while (v4 < v9);
      v2 = *(void **)(a1 + 32);
      if (!v2)
        goto LABEL_14;
      v10 = 16 * v9;
    }
    else
    {
      v10 = 0;
    }
    memset_s(v2, v10, 0, v10);
LABEL_14:
    free(v2);
    goto LABEL_15;
  }
  return 0;
}

uint64_t RandomAccessDecryptionStreamGetBlock(uint64_t a1, unsigned int a2, unint64_t a3, uint8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char vars0;

  if (*(_DWORD *)(a1 + 24) > a2 && *(unsigned int *)(*(_QWORD *)(a1 + 16) + 400) > a3)
  {
    v8 = *(_QWORD *)(a1 + 32) + 16 * a2;
    if ((aeaContainerLoadSegment(*(_QWORD *)(a1 + 16), *(_QWORD **)a1, a3, a4, *(const uint8_t **)(v8 + 8), *(void **)v8, a7, a8) & 0x8000000000000000) == 0)return 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"RandomAccessDecryptionStreamGetBlock", 71, 32, 0, "Loading segment", v9, v10, vars0);
  }
  return 0xFFFFFFFFLL;
}

void RandomAccessDecryptionStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t aaAssetDecodeStreamDone(uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (a1[1] == closeProc)
    return *((_DWORD *)*a1 + 8) == 4;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamDone", 410, 131, 0, "invalid stream", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  void *v3;
  void (**v4)(void);
  void (**v5)(void);

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 8));
    v3 = (void *)(result + 64);
    free(*(void **)(result + 80));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    AAHeaderDestroy(*(AAHeader *)(v1 + 88));
    free(*(void **)(v1 + 112));
    memset_s((void *)(v1 + 104), 0x10uLL, 0, 0x10uLL);
    v4 = *(void (***)(void))(v1 + 128);
    if (v4)
    {
      if (*v4)
        v4[1]();
      free(v4);
    }
    v5 = *(void (***)(void))(v1 + 136);
    if (v5)
    {
      if (*v5)
        v5[1]();
      free(v5);
    }
    memset_s((void *)v1, 0x90uLL, 0, 0x90uLL);
    free((void *)v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t aaAssetDecodeStreamSetParameterPtr(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  char vars0;

  if ((uint64_t (*)(uint64_t))a1[1] == closeProc)
  {
    v9 = *a1;
    if (a2 == 103)
    {
      result = 0;
      *(_QWORD *)(v9 + 24) = a3;
      return result;
    }
    if (a2 == 101)
    {
      result = 0;
      *(_QWORD *)(v9 + 16) = a3;
      return result;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamSetParameterPtr", 420, 131, 0, "invalid stream", a7, a8, vars0);
  }
  return 0xFFFFFFFFLL;
}

_QWORD *aaAssetDecodeStreamOpen(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  AAHeader_impl *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  int v9;
  const char *v10;
  __int16 v11;
  char v13;

  v2 = malloc(0x90uLL);
  v3 = v2;
  if (!v2)
  {
    v9 = *__error();
    v10 = "malloc";
    v11 = 443;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpen", v11, 131, v9, v10, v5, v6, v13);
    closeProc((uint64_t)v3);
    return 0;
  }
  memset_s(v2, 0x90uLL, 0, 0x90uLL);
  *v3 = a1;
  v4 = AAHeaderCreate();
  v3[11] = v4;
  if (!v4)
  {
    v9 = *__error();
    v10 = "malloc";
    v11 = 446;
    goto LABEL_10;
  }
  if ((aaHeaderBlobArrayInitWithHeader((uint64_t)(v3 + 13), v4) & 0x80000000) != 0)
  {
    v10 = "blob array init";
    v11 = 447;
    v9 = 0;
    goto LABEL_10;
  }
  v3[6] = -1;
  v7 = malloc(0x38uLL);
  if (!v7)
  {
    v9 = *__error();
    v10 = "malloc";
    v11 = 452;
    goto LABEL_10;
  }
  v8 = v7;
  memset_s(v7, 0x38uLL, 0, 0x38uLL);
  *v8 = v3;
  v8[1] = closeProc;
  v8[6] = closeWithStateProc;
  v8[2] = cancelProc;
  v8[3] = writeProc;
  return v8;
}

uint64_t closeWithStateProc(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  int v8;
  uint64_t v9;
  unsigned int EncodedSize;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  const uint8_t *EncodedData;
  uint64_t v23;
  const uint8_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  void (**v37)(void);
  void (**v38)(void);
  int v40;
  _QWORD *v41;
  int v42;
  _QWORD *v43;
  int v44;
  char v45;
  _DWORD v46[2];
  __int128 v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  BOOL v53;
  BOOL v54;

  if (!a1)
    return 0;
  if (atomic_load((unsigned int *)(a1 + 8)))
    return 0xFFFFFFFFLL;
  v8 = *(_DWORD *)(a1 + 96);
  v46[0] = *(_DWORD *)(a1 + 32);
  v46[1] = v8;
  v47 = *(_OWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 120);
  v48 = *(_QWORD *)(a1 + 56);
  v49 = v9;
  EncodedSize = AAHeaderGetEncodedSize(*(AAHeader *)(a1 + 88));
  v14 = (uint64_t *)(a1 + 64);
  v13 = *(_QWORD *)(a1 + 64);
  v16 = (_DWORD *)(a1 + 104);
  v15 = *(_DWORD *)(a1 + 104);
  v50 = EncodedSize;
  v51 = v15;
  v52 = v13;
  v17 = *(_QWORD *)(a1 + 136);
  v53 = *(_QWORD *)(a1 + 128) != 0;
  v54 = v17 != 0;
  if (a2[3])
  {
    v18 = 0;
    v19 = v46;
    v20 = 58;
    while (1)
    {
      v21 = ((uint64_t (*)(_QWORD, _DWORD *, uint64_t))a2[3])(*a2, v19, v20);
      if (v21 < 1)
        break;
      v19 = (_DWORD *)((char *)v19 + v21);
      v18 += v21;
      v20 -= v21;
      if (!v20)
      {
        if (v18 < 0)
          goto LABEL_36;
        goto LABEL_12;
      }
    }
    if (v21 < 0)
      goto LABEL_36;
LABEL_12:
    EncodedData = AAHeaderGetEncodedData(*(AAHeader *)(a1 + 88));
    if (a2[3])
    {
      v23 = v50;
      if (!v50)
        goto LABEL_72;
      v24 = EncodedData;
      v25 = 0;
      while (1)
      {
        v26 = ((uint64_t (*)(_QWORD, const uint8_t *, uint64_t))a2[3])(*a2, v24, v23);
        if (v26 < 1)
          break;
        v24 += v26;
        v25 += v26;
        v23 -= v26;
        if (!v23)
          goto LABEL_19;
      }
      v25 = v26;
LABEL_19:
      if ((v25 & 0x8000000000000000) == 0)
      {
LABEL_72:
        if (*v16)
        {
          v27 = 0;
          while (a2[3])
          {
            v28 = 0;
            v29 = *(_QWORD *)(a1 + 112) + 24 * v27 + 8;
            v30 = 8;
            while (1)
            {
              v31 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v29, v30);
              if (v31 < 1)
                break;
              v29 += v31;
              v28 += v31;
              v30 -= v31;
              if (!v30)
                goto LABEL_28;
            }
            v28 = v31;
LABEL_28:
            if (v28 < 0)
              break;
            if (++v27 >= (unint64_t)*v16)
              goto LABEL_30;
          }
          v36 = 376;
          goto LABEL_37;
        }
LABEL_30:
        if (!a2[3])
          goto LABEL_52;
        v32 = *v14;
        if (!*v14)
          goto LABEL_51;
        v33 = 0;
        v34 = *(_QWORD *)(a1 + 80);
        while (1)
        {
          v35 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v34, v32);
          if (v35 < 1)
            break;
          v34 += v35;
          v33 += v35;
          v32 -= v35;
          if (!v32)
            goto LABEL_50;
        }
        v33 = v35;
LABEL_50:
        if (v33 < 0)
LABEL_52:
          v40 = 0;
        else
LABEL_51:
          v40 = 1;
        if (v54)
        {
          v41 = *(_QWORD **)(a1 + 136);
          if (v41)
          {
            if (*v41)
            {
              v42 = ((uint64_t (*)(_QWORD, _QWORD *, _QWORD))v41[6])(*v41, a2, 0);
              free(v41);
              if (v42 < 0)
                v40 = 0;
            }
            else
            {
              free(*(void **)(a1 + 136));
            }
          }
        }
        *(_QWORD *)(a1 + 136) = 0;
        if (v53)
        {
          v43 = *(_QWORD **)(a1 + 128);
          if (v43)
          {
            if (*v43)
            {
              v44 = ((uint64_t (*)(_QWORD, _QWORD *, _QWORD))v43[6])(*v43, a2, 0);
              free(v43);
              if (v44 < 0)
              {
                *(_QWORD *)(a1 + 128) = 0;
LABEL_69:
                v36 = 385;
                goto LABEL_37;
              }
            }
            else
            {
              free(*(void **)(a1 + 128));
            }
          }
        }
        *(_QWORD *)(a1 + 128) = 0;
        if (v40)
        {
          v5 = 0;
          if (a3)
            *a3 = *(_QWORD *)(a1 + 56);
          goto LABEL_38;
        }
        goto LABEL_69;
      }
    }
  }
LABEL_36:
  v36 = 373;
LABEL_37:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"closeWithStateProc", v36, 131, 0, "write state", v11, v12, v45);
  v5 = 0xFFFFFFFFLL;
LABEL_38:
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy(*(AAHeader *)(a1 + 88));
  free(*(void **)(a1 + 112));
  memset_s((void *)(a1 + 104), 0x10uLL, 0, 0x10uLL);
  v37 = *(void (***)(void))(a1 + 128);
  if (v37)
  {
    if (*v37)
      v37[1]();
    free(v37);
  }
  v38 = *(void (***)(void))(a1 + 136);
  if (v38)
  {
    if (*v38)
      v38[1]();
    free(v38);
  }
  memset_s((void *)a1, 0x90uLL, 0, 0x90uLL);
  free((void *)a1);
  return v5;
}

uint64_t writeProc(_QWORD **a1, _WORD *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v10;
  int v14;
  const char *v15;
  __int16 v16;
  _WORD *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  size_t v25;
  size_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t (*v34)(_QWORD, _WORD *);
  uint64_t v35;
  AAHeader_impl *v36;
  AAFieldKey v37;
  uint32_t v38;
  unsigned int v39;
  int v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t (**v44)(void);
  int v45;
  _BOOL4 v46;
  int v47;
  BOOL v49;
  int v50;
  BOOL v51;
  uint64_t v52;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  size_t v59;
  _QWORD *v60;
  size_t v61;
  size_t v62;
  uint64_t (*v63)(_QWORD, _QWORD, _WORD *, size_t);
  AAFieldKey v64;
  AAHeader_impl *v65;
  uint32_t KeyIndex;
  unsigned int FieldUInt;
  int v68;
  AAHeader_impl *v69;
  AAFieldKey v70;
  uint32_t v71;
  unsigned int v72;
  int v73;
  AAHeader_impl *v74;
  AAFieldKey v75;
  uint32_t v76;
  unsigned int FieldBlob;
  int v78;
  _QWORD *v79;
  uint64_t (*v80)(_QWORD, uint64_t *, uint64_t);
  uint64_t (**v81)(void);
  int v82;
  AAFieldKey v83;
  uint32_t v84;
  AAFieldKey v85;
  uint64_t (*v86)(_QWORD, _QWORD *);
  AAHeader_impl *v87;
  AAFieldKey v88;
  uint32_t v89;
  unsigned int v90;
  int v91;
  unint64_t v92;
  AAFieldKey v93;
  uint32_t v94;
  AAFieldKey v95;
  AAFieldKey v96;
  uint32_t v97;
  AAFieldKey v98;
  uint64_t (*v99)(_QWORD, _QWORD *);
  int v100;
  uint64_t (*v101)(_QWORD, _QWORD *);
  unint64_t v102;
  _QWORD *v103;
  void (*v105)(_QWORD);
  char v106;
  unsigned int *v107;
  uint64_t offset;
  uint64_t size;
  uint64_t v110;
  uint64_t v111;
  uint64_t value;
  int v113;
  unsigned __int16 v114;

  v8 = (unsigned int *)(a1 + 1);
  if (atomic_load((unsigned int *)a1 + 2))
    return -1;
  v14 = *((_DWORD *)a1 + 8);
  if (v14 == 4)
  {
    v10 = 0;
LABEL_6:
    if (a3 && !v10)
    {
      v15 = "no more writes possible";
      v16 = 325;
      goto LABEL_193;
    }
LABEL_172:
    if (v10 < 1)
    {
LABEL_177:
      if (v10 < 0)
        goto LABEL_195;
    }
    else
    {
      v102 = (unint64_t)a1[6];
      if (v102 + 1 >= 2)
      {
        v103 = a1[3];
        if (v103)
        {
          if ((((uint64_t (*)(_QWORD *, _WORD *, float))v103)(a1[2], __src, (float)((float)(unint64_t)a1[7] * 100.0) / (float)v102) & 0x80000000) != 0)
          {
            v15 = "user cancelled in progress callback";
            v16 = 335;
            goto LABEL_193;
          }
        }
      }
    }
    return v10;
  }
  v17 = __src;
  v10 = 0;
  v18 = (unint64_t *)(a1 + 8);
  v107 = (unsigned int *)(a1 + 13);
  while (2)
  {
    v19 = *v18;
    if (!(*v18 | a3))
    {
      if (a1[7] >= a1[6])
        *((_DWORD *)a1 + 8) = 4;
      goto LABEL_172;
    }
    switch(v14)
    {
      case 0:
        if (a1[7] >= a1[6])
        {
          *((_DWORD *)a1 + 8) = 4;
          goto LABEL_6;
        }
        if (v19 <= 5)
        {
          v20 = 6;
          goto LABEL_22;
        }
        __src = a1[10];
        v113 = *(_DWORD *)__src;
        v114 = __src[2];
        if (v113 != 825246017 && v113 != 826360153)
        {
          v15 = "invalid header magic";
          v16 = 120;
          goto LABEL_193;
        }
        if (v114 <= 5uLL)
        {
          v15 = "invalid header size";
          v16 = 122;
          goto LABEL_193;
        }
        v25 = v114 - v19;
        if (v114 <= v19)
        {
          if (v114 != v19)
          {
            v15 = "invalid state";
            v16 = 127;
            goto LABEL_193;
          }
          if ((aaHeaderInitWithEncodedData((uint64_t)a1[11], __src, v19) & 0x80000000) != 0
            || (aaHeaderBlobArrayInitWithHeader((uint64_t)v107, (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
          {
            v15 = "invalid header";
            v16 = 130;
            goto LABEL_193;
          }
          v111 = 0;
          value = 0;
          size = 0;
          v110 = 0;
          offset = 0;
          v64.ikey = 5265748;
          v65 = (AAHeader_impl *)a1[11];
          KeyIndex = AAHeaderGetKeyIndex(v65, v64);
          if ((KeyIndex & 0x80000000) != 0
            || ((FieldUInt = AAHeaderGetFieldUInt(v65, KeyIndex, &value), FieldUInt <= 1)
              ? (v68 = 1)
              : (v68 = FieldUInt),
                v68 <= 0))
          {
            v15 = "missing TYP field";
            v16 = 137;
            goto LABEL_193;
          }
          v69 = (AAHeader_impl *)a1[11];
          v70.ikey = 5263193;
          v71 = AAHeaderGetKeyIndex(v69, v70);
          if ((v71 & 0x80000000) != 0
            || ((v72 = AAHeaderGetFieldUInt(v69, v71, &v111), v72 <= 1) ? (v73 = 1) : (v73 = v72), v73 <= 0))
          {
            v111 = 0;
          }
          v74 = (AAHeader_impl *)a1[11];
          v75.ikey = 5521732;
          v76 = AAHeaderGetKeyIndex(v74, v75);
          if ((v76 & 0x80000000) != 0)
          {
            v78 = 0;
          }
          else
          {
            FieldBlob = AAHeaderGetFieldBlob(v74, v76, &size, &offset);
            if (FieldBlob <= 1)
              v78 = 1;
            else
              v78 = FieldBlob;
          }
          v87 = (AAHeader_impl *)a1[11];
          v88.ikey = 5915721;
          v89 = AAHeaderGetKeyIndex(v87, v88);
          if ((v89 & 0x80000000) == 0)
          {
            v90 = AAHeaderGetFieldUInt(v87, v89, &v110);
            v91 = v90 <= 1 ? 1 : v90;
            if (v91 >= 1)
              a1[5] = (_QWORD *)((char *)a1[5] + v110);
          }
          a1[8] = 0;
          *((_DWORD *)a1 + 24) = 0;
          if (v78 >= 1 && value == 77 && v111 && v111 != 80)
          {
            v92 = aaHeaderBlobArrayPayloadSize(v107);
            if (v92 != size)
            {
              v15 = "invalid AssetArchive, extra blobs";
              v16 = 151;
              goto LABEL_193;
            }
            if (v92 <= 3)
            {
              v15 = "invalid AssetArchive DAT blob size";
              v16 = 152;
              goto LABEL_193;
            }
            v93.ikey = 5521732;
            v94 = AAHeaderGetKeyIndex((AAHeader)a1[11], v93);
            if ((v94 & 0x80000000) != 0
              || AAHeaderRemoveField((AAHeader)a1[11], v94) < 0
              || (aaHeaderBlobArrayInitWithHeader((uint64_t)v107, (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
            {
              v15 = "removing DAT";
              v16 = 160;
              goto LABEL_193;
            }
            v95.ikey = 5328729;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v95, v111) < 0)
            {
              v15 = "append YOQ";
              v16 = 162;
              goto LABEL_193;
            }
            v96.ikey = 5263193;
            v97 = AAHeaderGetKeyIndex((AAHeader)a1[11], v96);
            if ((v97 & 0x80000000) != 0)
            {
              v15 = "invalid index";
              v16 = 164;
              goto LABEL_193;
            }
            v98.ikey = 5263193;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], v97, v98, 0x5BuLL) < 0)
            {
              v15 = "set YOP";
              v16 = 165;
              goto LABEL_193;
            }
            v99 = (uint64_t (*)(_QWORD, _QWORD *))(*a1)[4];
            if (!v99 || (v99(**a1, a1[11]) & 0x80000000) != 0)
            {
              v15 = "header processing";
              v16 = 167;
              goto LABEL_193;
            }
            a1[15] = (_QWORD *)size;
            v100 = 2;
          }
          else
          {
            v101 = (uint64_t (*)(_QWORD, _QWORD *))(*a1)[4];
            if (!v101 || (v101(**a1, a1[11]) & 0x80000000) != 0)
            {
              v15 = "header processing";
              v16 = 175;
              goto LABEL_193;
            }
            v100 = 1;
          }
          *((_DWORD *)a1 + 8) = v100;
        }
        else if (v114 != v19)
        {
          goto LABEL_23;
        }
        goto LABEL_164;
      case 1:
        v21 = *((unsigned int *)a1 + 26);
        v22 = *((unsigned int *)a1 + 24);
        if (v22 >= v21)
          goto LABEL_95;
        v23 = &a1[14][3 * v22 + 1];
        while (1)
        {
          v24 = *v23;
          v23 += 3;
          if (v24)
            break;
          *((_DWORD *)a1 + 24) = ++v22;
          if (v21 == v22)
            goto LABEL_137;
        }
        v22 = v22;
LABEL_95:
        if (v22 == v21)
          goto LABEL_137;
        v57 = a1[14];
        v58 = &v57[3 * v22];
        v61 = v58[1];
        v60 = v58 + 1;
        v59 = v61;
        if (a3 >= v61)
          v62 = v59;
        else
          v62 = a3;
        v63 = (uint64_t (*)(_QWORD, _QWORD, _WORD *, size_t))(*a1)[5];
        if (!v63 || (v63(**a1, LODWORD(v57[3 * v22]), v17, v62) & 0x80000000) != 0)
        {
          v15 = "blob processing";
          v16 = 202;
          goto LABEL_193;
        }
        *v60 -= v62;
        a3 -= v62;
        v17 = (_WORD *)((char *)v17 + v62);
        v10 += v62;
        a1[7] = (_QWORD *)((char *)a1[7] + v62);
        goto LABEL_164;
      case 2:
        if (v19 > 3)
        {
          v47 = *(_DWORD *)a1[10];
          LODWORD(value) = v47;
          if (v47 != 825246017 && v47 != 826360153)
          {
            v49 = (unsigned __int16)value == 25200 && BYTE2(value) == 122;
            if (!v49
              || ((v50 = v47 >> 24, ((v47 >> 24) - 45) <= 0x39)
                ? (v51 = ((1 << (HIBYTE(v47) - 45)) & 0x320000000000081) == 0)
                : (v51 = 1),
                  v51 && v50 != 120 && v50 != 122))
            {
              v15 = "invalid DAT blob";
              v16 = 227;
              goto LABEL_193;
            }
          }
          v52 = aaAssetDecodeStreamOpen(*a1);
          a1[17] = (_QWORD *)v52;
          if (!v52)
          {
            v15 = "dat decoder stream";
            v16 = 231;
            goto LABEL_193;
          }
          if (v47 == 825246017 || v47 == 826360153)
          {
            v79 = a1[16];
            if (!v79)
              v79 = a1[17];
          }
          else
          {
            v79 = aaAssetDecompressionStreamOpen(v52);
            a1[16] = v79;
            if (!v79)
            {
              v15 = "dat decompression stream";
              v16 = 237;
              goto LABEL_193;
            }
          }
          v80 = (uint64_t (*)(_QWORD, uint64_t *, uint64_t))v79[3];
          if (!v80 || v80(*v79, &value, 4) != 4)
          {
            v15 = "sending dat magic";
            v16 = 241;
            goto LABEL_193;
          }
          a1[15] = (_QWORD *)((char *)a1[15] - 4);
          a1[8] = 0;
          v14 = 3;
          *((_DWORD *)a1 + 8) = 3;
LABEL_165:
          if (v14 == 4)
            goto LABEL_6;
          continue;
        }
        v20 = 4;
LABEL_22:
        v25 = v20 - v19;
LABEL_23:
        if (!a3)
          goto LABEL_177;
        if (v25 >= a3)
          v26 = a3;
        else
          v26 = v25;
        v27 = v19 + v26;
        if (__CFADD__(v19, v26) || (v27 & 0x8000000000000000) != 0)
          goto LABEL_192;
        v28 = (unint64_t)a1[9];
        if (v28 >= v27)
          goto LABEL_88;
        do
        {
          while (!v28)
          {
            v28 = 0x4000;
            v30 = 0x4000;
            if (v27 <= 0x4000)
              goto LABEL_86;
          }
          v29 = v28 >> 1;
          if ((v28 & (v28 >> 1)) != 0)
            v29 = v28 & (v28 >> 1);
          v28 += v29;
        }
        while (v28 < v27);
        v30 = v28;
        if (v28 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_191;
        }
LABEL_86:
        v54 = a1[10];
        v55 = realloc(v54, v30);
        if (v55)
        {
          a1[9] = (_QWORD *)v30;
          a1[10] = v55;
LABEL_88:
          v56 = a1[10];
          if (v17)
          {
            memcpy((char *)v56 + *v18, v17, v26);
          }
          else if (v56)
          {
            memset_s((char *)v56 + *v18, v26, 0, v26);
          }
          *v18 += v26;
          if ((v26 & 0x8000000000000000) != 0)
            goto LABEL_192;
          a3 -= v26;
          v17 = (_WORD *)((char *)v17 + v26);
          v10 += v26;
          a1[7] = (_QWORD *)((char *)a1[7] + v26);
LABEL_164:
          v14 = *((_DWORD *)a1 + 8);
          goto LABEL_165;
        }
        free(v54);
LABEL_191:
        *v18 = 0;
        a1[9] = 0;
        a1[10] = 0;
LABEL_192:
        v15 = "malloc";
        v16 = 314;
LABEL_193:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"writeProc", v16, 131, 0, v15, a7, a8, v106);
LABEL_194:
        v10 = -1;
        do
        {
LABEL_195:
          if (__ldaxr(v8))
          {
            __clrex();
            return v10;
          }
        }
        while (__stlxr(1u, v8));
        v105 = (void (*)(_QWORD))(*a1)[2];
        if (v105)
          v105(**a1);
        return v10;
      case 3:
        v31 = a1[15];
        if (a3 >= (unint64_t)v31)
          v32 = a1[15];
        else
          v32 = (_QWORD *)a3;
        if (!v32)
          goto LABEL_46;
        v33 = a1[16];
        if (!v33)
          v33 = a1[17];
        v34 = (uint64_t (*)(_QWORD, _WORD *))v33[3];
        if (!v34 || (v35 = v34(*v33, v17), v35 < 0))
        {
          v15 = "writing DAT bytes";
          v16 = 255;
          goto LABEL_193;
        }
        a3 -= v35;
        v17 = (_WORD *)((char *)v17 + v35);
        v10 += v35;
        a1[7] = (_QWORD *)((char *)a1[7] + v35);
        v31 = (_QWORD *)((char *)a1[15] - v35);
        a1[15] = v31;
LABEL_46:
        if (v31)
          goto LABEL_164;
        value = 0;
        v36 = (AAHeader_impl *)a1[11];
        v37.ikey = 5328729;
        v38 = AAHeaderGetKeyIndex(v36, v37);
        if ((v38 & 0x80000000) == 0)
        {
          v39 = AAHeaderGetFieldUInt(v36, v38, &value);
          v40 = v39 <= 1 ? 1 : v39;
          if (v40 >= 1 && value == 77)
          {
            v41 = a1[17];
            if (v41)
            {
              v42 = *(_QWORD *)(*v41 + 40);
              v43 = a1[7];
              a1[6] = (_QWORD *)((char *)v43 + v42);
              if (__CFADD__(v43, v42))
              {
                v15 = "invalid sizes in manifest";
                v16 = 274;
                goto LABEL_193;
              }
            }
          }
        }
        v44 = (uint64_t (**)(void))a1[16];
        if (!v44)
          goto LABEL_126;
        if (*v44)
        {
          v45 = v44[1]();
          free(v44);
          v46 = v45 >= 0;
        }
        else
        {
          free(a1[16]);
LABEL_126:
          v46 = 1;
        }
        a1[16] = 0;
        v81 = (uint64_t (**)(void))a1[17];
        if (!v81)
          goto LABEL_132;
        if (*v81)
        {
          v82 = v81[1]();
          free(v81);
          if (v82 < 0)
          {
            a1[17] = 0;
LABEL_207:
            v15 = "dat archive invalid";
            v16 = 282;
            goto LABEL_193;
          }
        }
        else
        {
          free(a1[17]);
        }
LABEL_132:
        a1[17] = 0;
        if (!v46)
          goto LABEL_207;
        v83.ikey = 5263193;
        v84 = AAHeaderGetKeyIndex((AAHeader)a1[11], v83);
        if ((v84 & 0x80000000) != 0)
        {
          v15 = "invalid index";
          v16 = 288;
          goto LABEL_193;
        }
        v85.ikey = 5263193;
        if (AAHeaderSetFieldUInt((AAHeader)a1[11], v84, v85, 0x5DuLL) < 0)
        {
          v15 = "set YOP";
          v16 = 289;
          goto LABEL_193;
        }
        v86 = (uint64_t (*)(_QWORD, _QWORD *))(*a1)[4];
        if (!v86 || (v86(**a1, a1[11]) & 0x80000000) != 0)
        {
          v15 = "header processing";
          v16 = 291;
          goto LABEL_193;
        }
LABEL_137:
        AAHeaderClear((AAHeader)a1[11]);
        v14 = 0;
        *((_DWORD *)a1 + 26) = 0;
        *((_DWORD *)a1 + 8) = 0;
        goto LABEL_165;
      default:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"writeProc", 304, 131, 0, "invalid state %d", a7, a8, v14);
        goto LABEL_194;
    }
  }
}

_QWORD **cancelProc(_QWORD **result)
{
  unsigned int *v1;
  uint64_t (*v3)(_QWORD);

  v1 = (unsigned int *)(result + 1);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v1));
  v3 = (uint64_t (*)(_QWORD))(*result)[2];
  if (v3)
    return (_QWORD **)v3(**result);
  return result;
}

void (**aaAssetDecodeStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, _QWORD *a3))(void)
{
  void (**v5)(void);
  uint64_t v6;
  uint64_t v7;
  void (**v8)(void);
  void (*v9)(void);
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  size_t v16;
  int v17;
  void *v18;
  void (**result)(void);
  char *v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  char *v27;
  size_t v28;
  ssize_t v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  void *v44;
  void *v45;
  size_t v46;
  ssize_t v47;
  uint64_t v48;
  void (**v49)(void);
  const char *v50;
  __int16 v51;
  _OWORD v52[4];
  unint64_t __s;
  size_t v54;
  void *v55;

  __s = 0;
  v54 = 0;
  v55 = 0;
  v5 = (void (**)(void))aaAssetDecodeStreamOpen(a1);
  v8 = v5;
  if (v5)
  {
    v9 = *v5;
    memset(v52, 0, 58);
    if (*((_QWORD *)a2 + 2))
    {
      v10 = 0;
      v11 = v52;
      v12 = 58;
      while (1)
      {
        v13 = (*((uint64_t (**)(_QWORD, _OWORD *, uint64_t))a2 + 2))(*(_QWORD *)a2, v11, v12);
        if (v13 < 0)
          break;
        if (v13)
        {
          v11 = (_OWORD *)((char *)v11 + v13);
          v10 += v13;
          v12 -= v13;
          if (v12)
            continue;
        }
        if (v10 != 58)
          break;
        v14 = DWORD1(v52[0]);
        *((_DWORD *)v9 + 8) = v52[0];
        *((_DWORD *)v9 + 24) = v14;
        *(_OWORD *)((char *)v9 + 40) = *(_OWORD *)((char *)v52 + 8);
        v15 = *(_QWORD *)&v52[2];
        *((_QWORD *)v9 + 7) = *((_QWORD *)&v52[1] + 1);
        *((_QWORD *)v9 + 15) = v15;
        v16 = DWORD2(v52[2]);
        if ((DWORD2(v52[2]) - 0x10000) >= 0xFFFF0006)
        {
          v20 = 0;
          v21 = 0;
          v22 = 0;
          v23 = 0;
          do
          {
            if (v22 == v21)
            {
              v24 = v21 + 0x40000;
              if ((uint64_t)(v21 + 0x40000) < 0)
                goto LABEL_9;
              if (v21 <= 0xFFFFFFFFFFFBFFFFLL)
              {
                do
                {
                  while (!v21)
                  {
                    v21 = 0x4000;
                    v26 = 0x4000;
                    if (v24 <= 0x4000)
                      goto LABEL_35;
                  }
                  v25 = v21 >> 1;
                  if ((v21 & (v21 >> 1)) != 0)
                    v25 = v21 & (v21 >> 1);
                  v21 += v25;
                }
                while (v21 < v24);
                v26 = v21;
                if (v21 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_93;
                }
LABEL_35:
                v27 = (char *)realloc(v20, v26);
                if (v27)
                {
                  v54 = v26;
                  v55 = v27;
                  v20 = v27;
                  goto LABEL_37;
                }
                free(v20);
LABEL_93:
                __s = 0;
                v54 = 0;
                v55 = 0;
                goto LABEL_9;
              }
            }
            v26 = v21;
LABEL_37:
            if (v26 - v22 >= v16)
              v28 = v16;
            else
              v28 = v26 - v22;
            v29 = AAByteStreamRead(a2, &v20[v22], v28);
            if (v29 < 0)
              goto LABEL_9;
            if (!v29)
              break;
            v22 = __s + v29;
            if (!__CFADD__(__s, v29))
            {
              v21 = v54;
              if (v22 <= v54)
                continue;
            }
            goto LABEL_9;
            __s += v29;
            v23 += v29;
            v16 -= v29;
          }
          while (v16);
          if (v23 < 0)
            goto LABEL_9;
          v18 = v55;
          if ((aaHeaderInitWithEncodedData(*((_QWORD *)v9 + 11), (unsigned __int16 *)v55, __s) & 0x80000000) != 0)
            goto LABEL_9;
          v30 = (_DWORD *)((char *)v9 + 104);
          if ((aaHeaderBlobArrayInitWithHeader((uint64_t)v9 + 104, *((AAHeader_impl **)v9 + 11)) & 0x80000000) != 0
            || *v30 != HIDWORD(v52[2]))
          {
            goto LABEL_9;
          }
          if (*v30)
          {
            v31 = 0;
LABEL_51:
            if (*((_QWORD *)a2 + 2))
            {
              v32 = 0;
              v33 = *((_QWORD *)v9 + 14) + 24 * v31 + 8;
              v34 = 8;
              while (1)
              {
                v35 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v33, v34);
                if (v35 < 0)
                  break;
                if (v35)
                {
                  v33 += v35;
                  v32 += v35;
                  v34 -= v35;
                  if (v34)
                    continue;
                }
                if (v32 < 0)
                  break;
                if (++v31 < (unint64_t)*v30)
                  goto LABEL_51;
                goto LABEL_58;
              }
            }
            v50 = "invalid blob state";
            v51 = 505;
            goto LABEL_99;
          }
LABEL_58:
          v36 = *(_QWORD *)&v52[3];
          if (*(_QWORD *)&v52[3])
          {
            v37 = 0;
            v38 = (unint64_t *)((char *)v9 + 64);
            v40 = *((_QWORD *)v9 + 8);
            v39 = *((_QWORD *)v9 + 9);
            do
            {
              if (v40 == v39)
              {
                v41 = v39 + 0x40000;
                if ((uint64_t)(v39 + 0x40000) < 0)
                  goto LABEL_98;
                if (v39 <= 0xFFFFFFFFFFFBFFFFLL)
                {
                  do
                  {
                    while (!v39)
                    {
                      v39 = 0x4000;
                      v43 = 0x4000;
                      if (v41 <= 0x4000)
                        goto LABEL_73;
                    }
                    v42 = v39 >> 1;
                    if ((v39 & (v39 >> 1)) != 0)
                      v42 = v39 & (v39 >> 1);
                    v39 += v42;
                  }
                  while (v39 < v41);
                  v43 = v39;
                  if (v39 >= 0x2000000001)
                  {
                    *__error() = 12;
                    goto LABEL_97;
                  }
LABEL_73:
                  v44 = (void *)*((_QWORD *)v9 + 10);
                  v45 = realloc(v44, v43);
                  if (v45)
                  {
                    *((_QWORD *)v9 + 9) = v43;
                    *((_QWORD *)v9 + 10) = v45;
                    v40 = *((_QWORD *)v9 + 8);
                    goto LABEL_75;
                  }
                  free(v44);
LABEL_97:
                  *v38 = 0;
                  *((_QWORD *)v9 + 9) = 0;
                  *((_QWORD *)v9 + 10) = 0;
                  goto LABEL_98;
                }
                v40 = v39;
              }
              v43 = v39;
LABEL_75:
              if (v43 - v40 >= v36)
                v46 = v36;
              else
                v46 = v43 - v40;
              v47 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 10) + v40), v46);
              if (v47 < 0)
                goto LABEL_98;
              if (!v47)
                break;
              v40 = *v38 + v47;
              if (!__CFADD__(*v38, v47))
              {
                v39 = *((_QWORD *)v9 + 9);
                if (v40 <= v39)
                  continue;
              }
              goto LABEL_98;
              *v38 = v40;
              v37 += v47;
              v36 -= v47;
            }
            while (v36);
            if (v37 < 0)
              goto LABEL_98;
          }
          if (BYTE9(v52[3])
            && (v48 = aaAssetDecodeStreamOpenWithState(*(_QWORD *)v9, a2, 0), (*((_QWORD *)v9 + 17) = v48) == 0)
            || BYTE8(v52[3])
            && (v49 = aaAssetDecompressionStreamOpenWithState(*((_QWORD *)v9 + 17), a2, 0),
                (*((_QWORD *)v9 + 16) = v49) == 0))
          {
LABEL_98:
            v50 = "read state";
            v51 = 512;
LABEL_99:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", v51, 131, 0, v50, v6, v7, v52[0]);
            goto LABEL_12;
          }
          if (a3)
            *a3 = *((_QWORD *)v9 + 7);
          v17 = 1;
        }
        else
        {
LABEL_9:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", 502, 131, 0, "invalid header state", v6, v7, v52[0]);
          v17 = 0;
          v18 = v55;
        }
        goto LABEL_13;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", 487, 131, 0, "truncated state", v6, v7, v52[0]);
  }
  v18 = 0;
LABEL_12:
  v17 = 0;
LABEL_13:
  free(v18);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v17)
    result = v8;
  else
    result = 0;
  if (v8 && (v17 & 1) == 0)
  {
    if (*v8)
      v8[1]();
    free(v8);
    return 0;
  }
  return result;
}

char *AAAssetBuilderCreate(uint64_t a1)
{
  char *v2;
  char *v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v2 = (char *)malloc(0xA0uLL);
  v3 = v2;
  if (v2)
  {
    memset_s(v2, 0xA0uLL, 0, 0xA0uLL);
    *(_QWORD *)v3 = a1;
    *(_OWORD *)(v3 + 104) = xmmword_20A40B7F0;
    *(_OWORD *)(v3 + 120) = xmmword_20A40B800;
    *((_DWORD *)v3 + 34) = 774;
    *((_OWORD *)v3 + 9) = xmmword_20A40B810;
  }
  else
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderCreate", 13, 26, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

void AAAssetBuilderDestroy(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t AAAssetBuilderAddVariantArchive(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const char *v9;
  __int16 v10;
  uint64_t v13;
  _QWORD *v14;
  uint64_t result;
  uint64_t v16;
  char v17;

  v8 = *(_QWORD *)(a1 + 16);
  if (v8 >= 0xA)
  {
    v9 = "too many inputs/outputs";
    v10 = 44;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderAddVariantArchive", v10, 26, 0, v9, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  if ((a2 - 1) >= 2)
  {
    v9 = "invalid variant";
    v10 = 53;
    goto LABEL_7;
  }
  v13 = a1 + 24;
  if (a2 == 2)
  {
    v14 = (_QWORD *)(v13 + 8 * v8);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 8);
    v14 = (_QWORD *)(v13 + 8 * v16);
    memmove(v14 + 1, v14, 8 * (v8 - v16));
    v8 = *(_QWORD *)(a1 + 16);
    ++*(_QWORD *)(a1 + 8);
  }
  result = 0;
  *(_QWORD *)(a1 + 16) = v8 + 1;
  *v14 = a3;
  return result;
}

uint64_t AAAssetBuilderAddFilter()
{
  return 0xFFFFFFFFLL;
}

uint64_t AAAssetBuilderSetParameter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char vars0;

  switch(a2)
  {
    case 1:
      result = 0;
      *(_QWORD *)(a1 + 104) = a3;
      break;
    case 2:
      result = 0;
      *(_QWORD *)(a1 + 112) = a3;
      break;
    case 3:
      result = 0;
      *(_QWORD *)(a1 + 120) = a3;
      break;
    case 4:
      result = 0;
      *(_QWORD *)(a1 + 128) = a3;
      break;
    case 5:
      result = 0;
      *(_DWORD *)(a1 + 136) = a3;
      break;
    case 6:
      result = 0;
      *(_QWORD *)(a1 + 144) = a3;
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderSetParameter", 104, 26, 0, "unsupported parameter", a7, a8, vars0);
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t AAAssetBuilderGetParameter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char vars0;

  switch(a2)
  {
    case 1:
      result = *(_QWORD *)(a1 + 104);
      break;
    case 2:
      result = *(_QWORD *)(a1 + 112);
      break;
    case 3:
      result = *(_QWORD *)(a1 + 120);
      break;
    case 4:
      result = *(_QWORD *)(a1 + 128);
      break;
    case 5:
      result = *(unsigned int *)(a1 + 136);
      break;
    case 6:
      result = *(_QWORD *)(a1 + 144);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderGetParameter", 129, 26, 0, "unsupported parameter key", a7, a8, vars0);
      result = 0;
      break;
  }
  return result;
}

uint64_t AEADecryptAndExtractChunk(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9, unint64_t a10, unsigned int a11)
{
  uint64_t (**ChunkAsyncStreamOpen)(void);
  uint64_t v13;
  uint64_t v14;
  uint64_t (**v15)(void);
  int Range;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  int v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  char v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD v30[4];
  int v31;
  int v32;

  v30[3] = a6;
  v31 = 0;
  v30[0] = a2;
  v30[1] = a5;
  v30[2] = a7;
  v32 = a10 >> 62;
  ChunkAsyncStreamOpen = (uint64_t (**)(void))AEADecryptAndExtractChunkAsyncStreamOpen(a3, a4, (uint64_t)v30, (uint64_t)asyncContext, (uint64_t)asyncSelect, (uint64_t)asyncProgress, a8, a9, a10, a11);
  v15 = ChunkAsyncStreamOpen;
  if (!ChunkAsyncStreamOpen)
  {
    v19 = "AEADecryptAndExtractAsyncStreamOpen";
    v20 = 96;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", v20, 117, 0, v19, v13, v14, v27);
    v21 = 0;
    goto LABEL_19;
  }
  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(ChunkAsyncStreamOpen, a1, a10, a11) & 0x8000000000000000) == 0)
    {
      v21 = 1;
      goto LABEL_19;
    }
    v19 = "AAAsyncByteStreamProcessAllRanges";
    v20 = 124;
    goto LABEL_18;
  }
  while (1)
  {
    v28 = 0;
    v29 = 0;
    Range = AAAsyncByteStreamGetRange(v15, &v29, &v28);
    if (Range < 0)
      break;
    if (Range)
    {
      if (!v29)
      {
        v21 = 1;
        goto LABEL_16;
      }
      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        v22 = "AAByteStreamPReadAsync";
        v23 = 113;
        goto LABEL_15;
      }
    }
    else
    {
      usleep(0x186A0u);
    }
  }
  v22 = "AAAsyncByteStreamGetRange";
  v23 = 108;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", v23, 117, 0, v22, v17, v18, v27);
  v21 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    v19 = "AAByteStreamPReadAsync barrier";
    v20 = 118;
    goto LABEL_18;
  }
LABEL_19:
  if ((AAAsyncByteStreamClose(v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", 128, 117, 0, "AAAsyncByteStreamClose", v24, v25, v27);
    v21 = 0;
  }
  if (v21)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t asyncContext(uint64_t result, _OWORD *context)
{
  _DWORD *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  FILE **v8;
  FILE *v9;
  int FieldUInt;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  FILE *v17;
  unsigned int v18;
  const char *v19;
  FILE *v20;
  uint64_t v21;
  FILE *v22;
  uint64_t v23;

  v3 = (_DWORD *)result;
  v4 = *(_QWORD *)result;
  if (*(_DWORD *)(result + 32))
  {
    *(_OWORD *)v4 = *context;
    v5 = context[1];
    v6 = context[2];
    v7 = context[3];
    *(_QWORD *)(v4 + 64) = *((_QWORD *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 36))
    {
      v8 = (FILE **)MEMORY[0x24BDAC8D8];
      v9 = (FILE *)*MEMORY[0x24BDAC8D8];
      FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            v15 = "none";
            goto LABEL_25;
          case 256:
            v15 = "lz4";
            goto LABEL_25;
          case 774:
            v15 = "lzma";
LABEL_25:
            v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            v17 = *v8;
            v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2)
              v19 = "???";
            else
              v19 = off_24C305B20[v18];
            fprintf(v17, "  checksum: %s\n", v19);
            v20 = *v8;
            v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            v22 = *v8;
            v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            return 0;
        }
      }
      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            v15 = "zlib";
            goto LABEL_25;
          }
          if (FieldUInt != 1794)
            goto LABEL_24;
          goto LABEL_20;
        }
        if (FieldUInt == 2049)
        {
LABEL_20:
          v15 = "lzfse";
          goto LABEL_25;
        }
        if (FieldUInt == 2304)
        {
          v15 = "lzvn";
          goto LABEL_25;
        }
      }
LABEL_24:
      v15 = "???";
      goto LABEL_25;
    }
    return 0;
  }
  v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    v12 = *(unsigned int *)(*(_QWORD *)v3 + 72);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(_QWORD *)v3 + 76), *(unsigned int *)(*(_QWORD *)v3 + 72));
      *((_DWORD *)context + 18) = v12;
      result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      v13 = *(unsigned int *)(*(_QWORD *)v3 + 2152);
      if (v13 < 0x101)
      {
        memcpy((char *)context + 2156, (const void *)(*(_QWORD *)v3 + 2156), *(unsigned int *)(*(_QWORD *)v3 + 2152));
        *((_DWORD *)context + 538) = v13;
        result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        v14 = *(unsigned int *)(*(_QWORD *)v3 + 332);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(_QWORD *)v3 + 336), *(unsigned int *)(*(_QWORD *)v3 + 332));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[8] = 1;
          return 0;
        }
      }
    }
  }
  __break(1u);
  return result;
}

uint64_t asyncSelect(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(a1 + 24);
  if (v1)
    return v1(*(_QWORD *)(a1 + 8));
  else
    return 0;
}

uint64_t asyncProgress(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(a1 + 16);
  if (v1)
    return v1(*(_QWORD *)(a1 + 8));
  else
    return 0;
}

uint64_t AEADecryptAndExtract(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9)
{
  return AEADecryptAndExtractChunk(a1, a2, a3, a4, a5, a6, a7, 0, 0, a8, a9);
}

_QWORD *AAAssetExtractorCreate(const char *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  AAByteStream v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *Common;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *StreamOpenWithState;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(void);
  void (**v21)(void);
  void (**v22)(void);
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *StreamOpen;
  const char *v48;
  __int16 v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  char v55;
  stat v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char path[1024];
  char __s[1024];
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  memset(&v56, 0, sizeof(v56));
  bzero(__s, 0x400uLL);
  bzero(path, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, __s)
    || stat(__s, &v56)
    || (v56.st_mode & 0xF000) != 0x4000
    || (concatPath(path, 0x400uLL, __s, ".AssetExtractCheckpoint") & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", 216, 15, 0, "invalid work dir: %s", v6, v7, (char)a1);
    Common = 0;
  }
  else
  {
    if (!stat(path, &v56))
    {
      v61 = 0;
      v62 = 0;
      v60 = 0;
      v8 = AAFileStreamOpenWithPath(path, 0, 0);
      if (v8)
      {
        Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
        if (Common)
        {
          v59 = 0;
          v57 = 0;
          v58 = 0;
          if (*((_QWORD *)v8 + 2))
          {
            v12 = 0;
            v13 = &v57;
            v14 = 17;
            while (1)
            {
              v15 = (*((uint64_t (**)(_QWORD, uint64_t *, uint64_t))v8 + 2))(*(_QWORD *)v8, v13, v14);
              if (v15 < 0)
                break;
              if (v15)
              {
                v13 = (uint64_t *)((char *)v13 + v15);
                v12 += v15;
                v14 -= v15;
                if (v14)
                  continue;
              }
              if (v12 < 0)
                break;
              *Common = v57;
              *((_DWORD *)Common + 1038) = v58;
              Common[520] = BYTE4(v58);
              if (!BYTE5(v58))
                goto LABEL_31;
              StreamOpenWithState = aaAssetExtractStreamOpenWithState(__s, v8, 0);
              Common[521] = StreamOpenWithState;
              if (!StreamOpenWithState)
                goto LABEL_31;
              if (BYTE6(v58))
              {
                v20 = aaAssetDecodeStreamOpenWithState((uint64_t)StreamOpenWithState, v8, &v62);
                Common[522] = v20;
                if (!v20)
                  goto LABEL_31;
              }
              if (HIBYTE(v58)
                && (v21 = aaAssetDecompressionStreamOpenWithState(Common[522], v8, &v61), (Common[523] = v21) == 0)
                || v59
                && (v22 = aaAssetDecryptionStreamOpenWithState(Common[522], v8, &v60), (Common[524] = v22) == 0))
              {
LABEL_31:
                v34 = "invalid state";
                v35 = 121;
                goto LABEL_32;
              }
              if (a2)
              {
                if (v59)
                {
                  v23 = &v60;
                }
                else if (HIBYTE(v58))
                {
                  v23 = &v61;
                }
                else
                {
                  v23 = Common + 520;
                  if (BYTE6(v58))
                    v23 = &v62;
                }
                *a2 = *v23;
              }
              v50 = (uint64_t *)Common[522];
              if (!v50
                || (aaAssetDecodeStreamSetParameterPtr(v50, 101, (uint64_t)Common, v17, v18, v19, v9, v10) & 0x80000000) == 0
                && (aaAssetDecodeStreamSetParameterPtr((uint64_t *)Common[522], 103, (uint64_t)aaAssetExtractorProgress, v51, v52, v53, v9, v10) & 0x80000000) == 0)
              {
                AAByteStreamClose(v8);
                return Common;
              }
              v34 = "mapping decode stream progress";
              v35 = 137;
              goto LABEL_32;
            }
          }
          v34 = "invalid state";
          v35 = 112;
        }
        else
        {
          v34 = "common constructor";
          v35 = 109;
        }
LABEL_32:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateWithCheckpoint", v35, 15, 0, v34, v9, v10, v54);
      }
      else
      {
        v31 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateWithCheckpoint", 102, 15, *v31, "open: %s", v32, v33, (char)path);
        Common = 0;
      }
      AAByteStreamClose(v8);
      AAAssetExtractorDestroy((char *)Common, 0, v36, v37, v38, v39, v40, v41);
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", 229, 15, "could not resume from saved checkpoint", v42, v43, v44, v55);
      unlink(path);
    }
    Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
    if (Common)
    {
      StreamOpen = aaAssetExtractStreamOpen(a1, a3);
      Common[521] = StreamOpen;
      if (StreamOpen)
        return Common;
      v48 = "extractor stream";
      v49 = 245;
    }
    else
    {
      v48 = "common constructor";
      v49 = 240;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", v49, 15, 0, v48, v45, v46, v54);
  }
  AAAssetExtractorDestroy((char *)Common, 0, v24, v25, v26, v27, v28, v29);
  return 0;
}

_QWORD *aaAssetExtractorCreateCommon(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  v4 = malloc(0x1068uLL);
  v5 = v4;
  if (v4)
  {
    memset_s(v4, 0x1068uLL, 0, 0x1068uLL);
    *v5 = a3;
    __strlcpy_chk();
    __strlcpy_chk();
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateCommon", 76, 15, *v6, "malloc", v7, v8, v16);
    AAAssetExtractorDestroy(0, 0, v9, v10, v11, v12, v13, v14);
  }
  return v5;
}

uint64_t AAAssetExtractorDestroy(char *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  uint64_t (**v12)(void);
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (**v17)(uint64_t);
  uint64_t (**v18)(void);
  int v19;
  AAByteStream v22;
  uint64_t v23;
  uint64_t v24;
  AAByteStream_impl *v25;
  void **v26;
  int16x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (**v32)(void);
  int v33;
  uint64_t (**v34)(void);
  int v35;
  int v37;
  _QWORD *v38;
  int v39;
  _QWORD *v40;
  int v41;
  _QWORD *v42;
  int v43;
  _QWORD *v44;
  int v45;
  uint64_t *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD v51[3];

  if (a1)
  {
    if (atomic_load((unsigned int *)a1 + 1034))
    {
LABEL_3:
      v10 = 0xFFFFFFFFLL;
LABEL_4:
      v11 = 1;
      goto LABEL_5;
    }
    v17 = (uint64_t (**)(uint64_t))*((_QWORD *)a1 + 522);
    if (v17 && aaAssetDecodeStreamDone(v17, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
    {
      v10 = 0;
      goto LABEL_4;
    }
    if (atomic_load((unsigned int *)a1 + 1036))
    {
      if (atomic_load((unsigned int *)a1 + 1034))
      {
LABEL_81:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorDestroy", 269, 15, 0, "storing checkpoint", a7, a8, v47);
        goto LABEL_3;
      }
      memset(v51, 0, 17);
      v49 = -1;
      v50 = -1;
      v48 = -1;
      v22 = AAFileStreamOpenWithPath(a1 + 3080, 1537, 0x1A4u);
      v25 = v22;
      if (!v22)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorStoreCheckpoint", 160, 15, 0, "open checkpoint path: %s", v23, v24, (_BYTE)a1 + 8);
LABEL_80:
        AAByteStreamClose(v25);
        unlink(a1 + 3080);
        goto LABEL_81;
      }
      v51[0] = *(_QWORD *)a1;
      LODWORD(v51[1]) = *((_DWORD *)a1 + 1038);
      BYTE4(v51[1]) = *((_QWORD *)a1 + 520);
      v26 = (void **)(a1 + 4168);
      v27 = (int16x8_t)vuzp1q_s32((int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4168), *(int64x2_t *)(a1 + 4168)), (int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4184), *(int64x2_t *)(a1 + 4184)));
      *(int8x8_t *)v27.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v27), (int8x8_t)0x1000100010001);
      *(_DWORD *)((char *)&v51[1] + 5) = vmovn_s16(v27).u32[0];
      if (!*((_QWORD *)v22 + 3))
        goto LABEL_47;
      v28 = 0;
      v29 = v51;
      v30 = 17;
      while (1)
      {
        v31 = (*((uint64_t (**)(_QWORD, _QWORD *, uint64_t))v25 + 3))(*(_QWORD *)v25, v29, v30);
        if (v31 < 1)
          break;
        v29 = (_QWORD *)((char *)v29 + v31);
        v28 += v31;
        v30 -= v31;
        if (!v30)
          goto LABEL_45;
      }
      v28 = v31;
LABEL_45:
      if (v28 < 0)
LABEL_47:
        v37 = 0;
      else
        v37 = 1;
      if (BYTE5(v51[1]))
      {
        v38 = *v26;
        if (*v26)
        {
          if (*v38)
          {
            v39 = ((uint64_t (*)(_QWORD, AAByteStream_impl *, _QWORD))v38[6])(*v38, v25, 0);
            free(v38);
            if (v39 < 0)
              v37 = 0;
          }
          else
          {
            free(*v26);
          }
        }
      }
      *v26 = 0;
      if (BYTE6(v51[1]))
      {
        v40 = (_QWORD *)*((_QWORD *)a1 + 522);
        if (v40)
        {
          if (*v40)
          {
            v41 = ((uint64_t (*)(_QWORD, AAByteStream_impl *, uint64_t *))v40[6])(*v40, v25, &v50);
            free(v40);
            if (v41 < 0)
              v37 = 0;
          }
          else
          {
            free(*((void **)a1 + 522));
          }
        }
      }
      *((_QWORD *)a1 + 522) = 0;
      if (HIBYTE(v51[1]))
      {
        v42 = (_QWORD *)*((_QWORD *)a1 + 523);
        if (v42)
        {
          if (*v42)
          {
            v43 = ((uint64_t (*)(_QWORD, AAByteStream_impl *, uint64_t *))v42[6])(*v42, v25, &v49);
            free(v42);
            if (v43 < 0)
              v37 = 0;
          }
          else
          {
            free(*((void **)a1 + 523));
          }
        }
      }
      *((_QWORD *)a1 + 523) = 0;
      if (LOBYTE(v51[2]))
      {
        v44 = (_QWORD *)*((_QWORD *)a1 + 524);
        if (v44)
        {
          if (*v44)
          {
            v45 = ((uint64_t (*)(_QWORD, AAByteStream_impl *, uint64_t *))v44[6])(*v44, v25, &v48);
            free(v44);
            if (v45 < 0)
            {
              *((_QWORD *)a1 + 524) = 0;
LABEL_79:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorStoreCheckpoint", 179, 15, 0, "write checkpoint", v23, v24, v47);
              goto LABEL_80;
            }
          }
          else
          {
            free(*((void **)a1 + 524));
          }
        }
      }
      *((_QWORD *)a1 + 524) = 0;
      if (!v37)
        goto LABEL_79;
      AAByteStreamClose(v25);
      if (a2)
      {
        if (LOBYTE(v51[2]))
        {
          v46 = &v48;
        }
        else if (HIBYTE(v51[1]))
        {
          v46 = &v49;
        }
        else
        {
          v46 = (uint64_t *)(a1 + 4160);
          if (BYTE6(v51[1]))
            v46 = &v50;
        }
        *a2 = *v46;
      }
      AAByteStreamClose(0);
    }
    v11 = 0;
    v10 = 1;
LABEL_5:
    v12 = (uint64_t (**)(void))*((_QWORD *)a1 + 523);
    if (v12)
    {
      if (*v12)
      {
        v13 = v12[1]();
        free(v12);
        if (v13 < 0)
          goto LABEL_37;
      }
      else
      {
        free(*((void **)a1 + 523));
      }
    }
    v18 = (uint64_t (**)(void))*((_QWORD *)a1 + 524);
    if (v18)
    {
      if (*v18)
      {
        v19 = v18[1]();
        free(v18);
        if (v19 < 0)
          goto LABEL_37;
      }
      else
      {
        free(*((void **)a1 + 524));
      }
    }
    v32 = (uint64_t (**)(void))*((_QWORD *)a1 + 522);
    if (v32)
    {
      if (*v32)
      {
        v33 = v32[1]();
        free(v32);
        if (v33 < 0)
          goto LABEL_37;
      }
      else
      {
        free(*((void **)a1 + 522));
      }
    }
    v34 = (uint64_t (**)(void))*((_QWORD *)a1 + 521);
    if (v34)
    {
      if (!*v34)
      {
        free(*((void **)a1 + 521));
        if (v11)
          goto LABEL_38;
        goto LABEL_40;
      }
      v35 = v34[1]();
      free(v34);
      if (v35 < 0)
      {
LABEL_37:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorDestroy", 276, 15, 0, "internal streams", v14, v15, v47);
        v10 = 0xFFFFFFFFLL;
        goto LABEL_38;
      }
    }
    if (v11)
    {
LABEL_38:
      unlink(a1 + 3080);
LABEL_41:
      memset_s(a1, 0x1068uLL, 0, 0x1068uLL);
      free(a1);
      return v10;
    }
LABEL_40:
    v10 = 1;
    goto LABEL_41;
  }
  return 0;
}

uint64_t AAAssetExtractorWrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v10;
  uint64_t v12;
  char *v15;
  unsigned int *v16;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t (*v20)(_QWORD, uint64_t, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (**v28)(uint64_t);
  unsigned int *v29;
  uint64_t (*v31)(_QWORD, uint64_t, void *, _QWORD);
  const char *v32;
  __int16 v33;
  unint64_t v35;
  char v36;
  int v38;
  BOOL v39;
  int v40;
  int v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t (*v48)(_QWORD, _QWORD);
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t (*v54)(_QWORD, char *, _QWORD);
  uint64_t v55;
  char v56;

  v8 = (unsigned int *)(a1 + 4136);
  if (atomic_load((unsigned int *)(a1 + 4136)))
    return -1;
  v12 = a3;
  if (!a3)
    return 0;
  v15 = (char *)(a1 + 4152);
  v16 = (unsigned int *)(a1 + 4144);
  while (!__ldaxr(v16))
  {
    if (!__stlxr(1u, v16))
    {
      unlink((const char *)(a1 + 3080));
      goto LABEL_11;
    }
  }
  __clrex();
LABEL_11:
  v18 = *(_QWORD **)(a1 + 4176);
  if (v18)
  {
    v10 = 0;
  }
  else
  {
    v35 = *(_QWORD *)(a1 + 4160);
    if (v35 > 3)
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      do
      {
        v36 = *(_BYTE *)(a2 + v10);
        *(_QWORD *)(a1 + 4160) = v35 + 1;
        *(_BYTE *)(a1 + v35 + 4152) = v36;
        v35 = *(_QWORD *)(a1 + 4160);
      }
      while (v35 <= 3 && v12 - 1 != v10++);
      if (v35 < 4)
        return v10;
      v12 -= v10;
      a2 += v10;
    }
    if (*(_DWORD *)v15 == 825246017 || *(_DWORD *)v15 == 826360153)
    {
      v40 = 0;
      v41 = 0;
    }
    else if (*(_DWORD *)v15 == 826361153)
    {
      v41 = 0;
      v40 = 1;
    }
    else
    {
      v38 = v15[3];
      v39 = *(_WORD *)v15 == 25200 && v15[2] == 122;
      if (!v39
        || ((v40 = 0, v41 = 1, (v38 - 45) > 0x39)
         || ((1 << (v38 - 45)) & 0x320000000000081) == 0)
        && v38 != 120
        && v38 != 122)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorWrite", 323, 15, 0, "invalid stream type (0x%02x 0x%02x 0x%02x 0x%02x)", a7, a8, *v15);
        goto LABEL_29;
      }
    }
    v42 = aaAssetDecodeStreamOpen(*(_QWORD *)(a1 + 4168));
    *(_QWORD *)(a1 + 4176) = v42;
    if (!v42)
    {
      v32 = "decoder stream";
      v33 = 330;
      goto LABEL_28;
    }
    if (v40)
    {
      v46 = aaAssetDecryptionStreamOpen((uint64_t)v42, *(_QWORD *)(a1 + 4104), *(_QWORD *)(a1 + 4112));
      *(_QWORD *)(a1 + 4192) = v46;
      if (!v46)
      {
        v32 = "decryption stream";
        v33 = 334;
        goto LABEL_28;
      }
    }
    else
    {
      if (v41)
      {
        v47 = aaAssetDecompressionStreamOpen((uint64_t)v42);
        *(_QWORD *)(a1 + 4184) = v47;
        if (!v47)
        {
          v32 = "decompression stream";
          v33 = 339;
          goto LABEL_28;
        }
      }
      v48 = *(uint64_t (**)(_QWORD, _QWORD))(a1 + 4112);
      if (v48 && (v48(*(_QWORD *)(a1 + 4104), 0) & 0x80000000) != 0)
      {
        v32 = "callback cancel on non AEA container";
        v33 = 346;
        goto LABEL_28;
      }
    }
    if ((aaAssetDecodeStreamSetParameterPtr(*(uint64_t **)(a1 + 4176), 101, a1, v43, v44, v45, a7, a8) & 0x80000000) != 0
      || (aaAssetDecodeStreamSetParameterPtr(*(uint64_t **)(a1 + 4176), 103, (uint64_t)aaAssetExtractorProgress, v49, v50, v51, a7, a8) & 0x80000000) != 0)
    {
      v32 = "mapping decode stream progress";
      v33 = 352;
      goto LABEL_28;
    }
    v52 = *(_QWORD **)(a1 + 4176);
    if (*(_QWORD *)(a1 + 4184))
      v52 = *(_QWORD **)(a1 + 4184);
    v53 = *(_QWORD **)(a1 + 4192);
    if (!v53)
      v53 = v52;
    v54 = (uint64_t (*)(_QWORD, char *, _QWORD))v53[3];
    if (v54)
      v55 = v54(*v53, v15, *(_QWORD *)(a1 + 4160));
    else
      v55 = -1;
    if (v55 != *(_QWORD *)(a1 + 4160))
    {
      v32 = "invalid stream";
      v33 = 360;
      goto LABEL_28;
    }
    v18 = *(_QWORD **)(a1 + 4176);
  }
  if (*(_QWORD *)(a1 + 4184))
    v18 = *(_QWORD **)(a1 + 4184);
  v19 = *(_QWORD **)(a1 + 4192);
  if (!v19)
    v19 = v18;
  v20 = (uint64_t (*)(_QWORD, uint64_t, uint64_t))v19[3];
  if (!v20 || (v21 = v20(*v19, a2, v12), v21 < 0))
  {
    v32 = "invalid stream";
    v33 = 370;
    goto LABEL_28;
  }
  v27 = v21;
  v28 = *(uint64_t (***)(uint64_t))(a1 + 4176);
  if (v28 && aaAssetDecodeStreamDone(v28, v22, v23, v24, v25, v26, a7, a8))
  {
    v29 = (unsigned int *)(a1 + 4140);
    do
    {
      if (__ldaxr(v29))
      {
        __clrex();
        goto LABEL_71;
      }
    }
    while (__stlxr(1u, v29));
    v31 = *(uint64_t (**)(_QWORD, uint64_t, void *, _QWORD))(a1 + 4128);
    if (v31 && (v31(*(_QWORD *)(a1 + 4104), 92, &unk_20A3FA2C1, 0) & 0x80000000) != 0)
    {
      v32 = "end of stream cancel";
      v33 = 381;
LABEL_28:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorWrite", v33, 15, 0, v32, a7, a8, v56);
      goto LABEL_29;
    }
  }
LABEL_71:
  v10 += v27;
  if (v10 < 0)
  {
LABEL_29:
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
        return -1;
    }
    __clrex();
    return -1;
  }
  return v10;
}

uint64_t aaAssetExtractorProgress(uint64_t a1, float a2)
{
  float v2;
  BOOL v3;
  uint64_t (*v4)(_QWORD);

  if ((a2 >= 100.0 || ((v2 = *(float *)(a1 + 4148), v2 > 0.0) ? (v3 = (float)(v2 + 1.0) <= a2) : (v3 = 1), v3))
    && (*(float *)(a1 + 4148) = a2, (v4 = *(uint64_t (**)(_QWORD))(a1 + 4120)) != 0))
  {
    return v4(*(_QWORD *)(a1 + 4104));
  }
  else
  {
    return 0;
  }
}

uint64_t AAAssetExtractorSetParameterPtr(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (atomic_load((unsigned int *)(a1 + 4136)))
    return 0xFFFFFFFFLL;
  if ((a2 - 105) < 2)
    return aaAssetExtractStreamSetParameterPtr(*(uint64_t **)(a1 + 4168), a2, a3, a4, a5, a6, a7, a8);
  if (a2 != 101
    || (aaAssetExtractStreamSetParameterPtr(*(uint64_t **)(a1 + 4168), 101, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    return 0xFFFFFFFFLL;
  }
  result = 0;
  *(_QWORD *)(a1 + 4104) = a3;
  return result;
}

uint64_t AAAssetExtractorSetParameterCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;

  if (atomic_load((unsigned int *)(a1 + 4136)))
    return 0xFFFFFFFFLL;
  if (a2 == 102)
  {
    v12 = 4112;
  }
  else if (a2 == 103)
  {
    v12 = 4120;
  }
  else
  {
    if (a2 != 104
      || (aaAssetExtractStreamSetParameterCallback(*(uint64_t (***)(uint64_t))(a1 + 4168), 104, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      return 0xFFFFFFFFLL;
    }
    v12 = 4128;
  }
  result = 0;
  *(_QWORD *)(a1 + v12) = a3;
  return result;
}

uint64_t compressionWorkerProc(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int *v10;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v21;

  v9 = *a1;
  v10 = (unsigned int *)(*a1 + 112);
  if (atomic_load(v10))
  {
    result = 0;
    a1[6] = -1;
    return result;
  }
  v13 = a1[2];
  a1[6] = v13;
  if (v13 == -2)
    return 0;
  if (v13 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", 244, 37, 0, "NOP received", a7, a8, v21);
    return 0;
  }
  if (v13 < 0)
  {
    v15 = "Invalid iBlock received";
    v16 = 246;
  }
  else
  {
    if (!*(_DWORD *)(v9 + 4))
    {
      v17 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v9 + 96))(a1[5], *(_QWORD *)(v9 + 16), a1[1], a1[3]);
      v18 = a1[3];
      if ((v17 & 0x8000000000000000) != 0 || v17 >= v18)
      {
        memcpy((void *)a1[5], (const void *)a1[1], v18);
        v17 = a1[3];
        v18 = v17;
      }
      a1[7] = v17;
      a1[8] = v18;
      if (*(int *)(v9 + 24) >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Worker: encode block %5lld: %7llu => %7llu\n");
      return 0;
    }
    if (a1[3] == a1[4])
    {
      memcpy((void *)a1[5], (const void *)a1[1], a1[3]);
      v14 = a1[3];
      a1[7] = v14;
      goto LABEL_19;
    }
    v19 = (*(uint64_t (**)(uint64_t))(v9 + 96))(a1[5]);
    if ((v19 & 0x8000000000000000) == 0 && v19 == a1[4])
    {
      a1[7] = v19;
      v14 = a1[3];
LABEL_19:
      a1[8] = v14;
      if (*(int *)(v9 + 24) >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Worker: decode block %5lld: %7llu => %7llu\n");
      return 0;
    }
    v21 = a1[6];
    v15 = "invalid output size/decoder error: block=%lld, inSize=%lld, outSize=%lld, expectedOutSize=%lld";
    v16 = 292;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", v16, 37, 0, v15, a7, a8, v21);
  a1[6] = -1;
  result = 0xFFFFFFFFLL;
  while (!__ldaxr(v10))
  {
    if (!__stlxr(1u, v10))
      return result;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t outputStreamProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  char v26;
  int8x16_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v8 = (unsigned int *)(a1 + 112);
  if (atomic_load((unsigned int *)(a1 + 112)))
    return 0;
  v13 = *(_QWORD *)(a2 + 48);
  if (v13 > 0xFFFFFFFFFFFFFFFDLL)
  {
    v14 = 0;
LABEL_5:
    result = 0;
    *(_QWORD *)(a1 + 88) += v14;
    return result;
  }
  if ((v13 & 0x8000000000000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 327, 37, 0, "invalid block ID in write thread %lld", a7, a8, *(_QWORD *)(a2 + 48));
LABEL_20:
    v14 = 0;
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    v18 = vrev64q_s8(*(int8x16_t *)(a2 + 56));
    v27 = vextq_s8(v18, v18, 8uLL);
    v19 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), (uint64_t)&v27, 16);
    if ((v19 & 0x8000000000000000) == 0)
    {
      v14 = v19;
      if (v19 == 16)
      {
        v20 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 56));
        if (v20 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 351, 37, 0, "writing block payload", v21, v22, v26);
          v14 = 16;
        }
        else
        {
          v14 = v20 + 16;
          if (v20 == *(_QWORD *)(a2 + 56))
            goto LABEL_5;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 353, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v21, v22, v20);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 347, 37, 0, "Truncated block header (%lld/16 bytes written)", v16, v17, v19);
      }
      goto LABEL_22;
    }
    v23 = "writing block header";
    v24 = 345;
    goto LABEL_19;
  }
  v15 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 56));
  if (v15 < 0)
  {
    v23 = "writing block";
    v24 = 334;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", v24, 37, 0, v23, v16, v17, v26);
    goto LABEL_20;
  }
  v14 = v15;
  if (v15 == *(_QWORD *)(a2 + 56))
    goto LABEL_5;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 336, 37, 0, "Truncated block payload (%lld/%llu bytes written)", v16, v17, v15);
LABEL_22:
  *(_QWORD *)(a1 + 88) += v14;
  while (!__ldaxr(v8))
  {
    if (!__stlxr(1u, v8))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t pcWrite(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  if (a4)
  {
    v6 = a4;
    v8 = 0;
    while (1)
    {
      v9 = a1(a2, a3, v6);
      v12 = v9;
      if (v9 < 0)
        break;
      a3 += v9;
      v8 += v9;
      v6 -= v9;
      if (!v6)
        return v8;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 131, 37, 0, "pcWrite failed", v10, v11, v16);
    return v12;
  }
  else
  {
    v8 = a1(a2, 0, 0);
    if (v8 < 0)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v13, v14, v16);
  }
  return v8;
}

uint64_t PCompressFilter(unsigned int *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int DefaultNThreads;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  const char *v15;
  __int16 v16;
  unint64_t v17;
  unsigned int EncoderDecoder;
  FILE *v19;
  FILE **v20;
  FILE *v21;
  char *DecoderDescription;
  __int128 v23;
  __int128 v24;
  unsigned int v25;
  uint64_t (*DecoderFilter)();
  void (*v27)(_QWORD);
  void (*v28)(_QWORD);
  unsigned int v29;
  uint64_t result;
  void *v31;
  unint64_t v32;
  _QWORD *v33;
  size_t v34;
  void *v35;
  void *v36;
  __int16 v37;
  unint64_t v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  int *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  signed int v47;
  void *v48;
  void *v49;
  char *v50;
  _QWORD *v51;
  uint64_t v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  unint64_t v64;
  uint64_t Worker;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  __int16 v90;
  int v91;
  const char *v92;
  __int16 v93;
  char v94;
  int v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  char v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char v105;
  char v106;
  unint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  void *v114[2];
  unsigned int v115[3];
  int v116;
  unint64_t v117[4];

  v117[2] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v105);
  *(_QWORD *)v115 = 0;
  v113 = 0u;
  *(_OWORD *)v114 = 0u;
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  v108 = 0u;
  DefaultNThreads = a1[2];
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  a1[2] = DefaultNThreads;
  if (a1[1] == 1)
  {
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(_QWORD *)(a2 + 16), (uint64_t)&v116, 4) != 4)goto LABEL_34;
    if (a3)
      *a3 += 4;
    v14 = 0;
    while (getHeader(v14, (uint64_t)v117) || v116 != LODWORD(v117[0]))
    {
      if (++v14 == 7)
      {
        if (compression_stream_identify_algorithm() == -1)
        {
          v15 = "invalid header in input stream";
          v16 = 179;
        }
        else
        {
          v15 = "compressed stream detected : try compression_tool";
          v16 = 178;
        }
LABEL_33:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processFileHeader", v16, 37, 0, v15, v12, v13, v106);
LABEL_34:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", 507, 37, 0, "processFileHeader", v12, v13, v106);
        goto LABEL_35;
      }
    }
    v117[0] = 0;
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(_QWORD *)(a2 + 16), (uint64_t)v117, 8) != 8)goto LABEL_34;
    if (a3)
      *a3 += 8;
    if (!v117[0])
    {
      v15 = "invalid blockSize in input stream";
      v16 = 191;
      goto LABEL_33;
    }
    *((_QWORD *)a1 + 2) = bswap64(v117[0]);
    *a1 = v14;
    if ((int)a1[6] >= 1)
    {
      v20 = (FILE **)MEMORY[0x24BDAC8D8];
      v21 = (FILE *)*MEMORY[0x24BDAC8D8];
      DecoderDescription = PCompressGetDecoderDescription(v14);
      fprintf(v21, "Decoder: %s\n", DecoderDescription);
      fprintf(*v20, "Blocksize: %llu\n");
    }
  }
  else
  {
    v17 = *((_QWORD *)a1 + 2);
    EncoderDecoder = PCompressGetEncoderDecoder(*a1);
    if (getHeader(EncoderDecoder, (uint64_t)&v116)
      || pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(_QWORD *)(a2 + 40), (uint64_t)&v116, 4) != 4)
    {
      goto LABEL_34;
    }
    if (a3)
      a3[1] += 4;
    v117[0] = bswap64(v17);
    if (pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(_QWORD *)(a2 + 40), (uint64_t)v117, 8) != 8)goto LABEL_34;
    if (a3)
      a3[1] += 8;
    if ((int)a1[6] >= 1)
    {
      v19 = (FILE *)*MEMORY[0x24BDAC8D8];
      PCompressGetEncoderDescription(*a1);
      fprintf(v19, "Encoder: %s\n");
    }
  }
  v23 = *((_OWORD *)a1 + 1);
  v108 = *(_OWORD *)a1;
  v109 = v23;
  v113 = 0u;
  *(_OWORD *)v114 = 0u;
  *(_QWORD *)v115 = 0;
  v24 = *(_OWORD *)(a2 + 16);
  v110 = *(_OWORD *)a2;
  v111 = v24;
  v112 = *(_OWORD *)(a2 + 32);
  if (a3)
    v113 = *(_OWORD *)a3;
  v25 = *a1;
  if (a1[1])
    DecoderFilter = PCompressGetDecoderFilter(v25);
  else
    DecoderFilter = PCompressGetEncoderFilter(v25);
  v114[0] = DecoderFilter;
  v31 = calloc((int)a1[2], 0x48uLL);
  v114[1] = v31;
  if (!v31)
  {
    v37 = 468;
LABEL_98:
    v86 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", v37, 37, *v86, "malloc", v87, v88, v106);
LABEL_99:
    v89 = "initFilterState";
    v90 = 510;
LABEL_105:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", v90, 37, 0, v89, v45, v46, v106);
    v94 = 0;
    v95 = 1;
    goto LABEL_106;
  }
  v32 = a1[2];
  if ((int)v32 < 1)
    goto LABEL_53;
  v33 = v31;
  v34 = *((_QWORD *)a1 + 2);
  v35 = malloc(v34);
  v33[1] = v35;
  v36 = malloc(v34);
  v33[5] = v36;
  *v33 = &v108;
  v37 = 477;
  if (!v35 || !v36)
    goto LABEL_98;
  v38 = 0;
  v39 = v33 + 9;
  do
  {
    if (v32 - 1 == v38)
      goto LABEL_53;
    v40 = malloc(v34);
    v39[1] = v40;
    v41 = malloc(v34);
    v39[5] = v41;
    *v39 = &v108;
    ++v38;
    if (!v40)
      break;
    v39 += 9;
  }
  while (v41);
  v42 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", 477, 37, *v42, "malloc", v43, v44, v106);
  if (v38 < v32)
    goto LABEL_99;
LABEL_53:
  v107 = v109;
  v47 = DWORD2(v108);
  v48 = malloc(8 * SDWORD2(v108));
  if (!v48)
  {
    v91 = *__error();
    v92 = "malloc";
    v93 = 372;
LABEL_103:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", v93, 37, v91, v92, v59, v60, v106);
    goto LABEL_104;
  }
  v49 = v48;
  if (v47 >= 1)
  {
    v50 = (char *)v114[1];
    v51 = v48;
    v52 = v47;
    do
    {
      *v51++ = v50;
      v50 += 72;
      --v52;
    }
    while (v52);
  }
  v53 = ThreadPipelineCreate(v47, (uint64_t)v48, (uint64_t)compressionWorkerProc, (uint64_t)&v108, (uint64_t)outputStreamProc, 0);
  if (!v53)
  {
    v92 = "creating pipeline";
    v93 = 375;
    v91 = 0;
    goto LABEL_103;
  }
  v61 = (uint64_t)v53;
  v62 = 0;
  v63 = 1;
  v64 = v107;
  while (1)
  {
    if (atomic_load(v115))
    {
      v63 = 0;
      goto LABEL_120;
    }
    if (!v63)
      break;
    Worker = ThreadPipelineGetWorker(v61, v54, v55, v56, v57, v58, v59, v60);
    if (!Worker)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 387, 37, 0, "getting worker from pipeline", v67, v68, v106);
      v82 = 0;
LABEL_94:
      v63 = 0;
      goto LABEL_95;
    }
    v69 = (uint64_t *)Worker;
    if (DWORD1(v108) == 1)
    {
      v70 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, (uint64_t)v117, 16);
      v77 = v70;
      if (v70)
      {
        if (v70 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 397, 37, 0, "reading block header", v75, v76, v106);
          v82 = 0;
          v83 = 0;
          v77 = 0;
        }
        else if (v70 == 16)
        {
          v78 = bswap64(v117[0]);
          v79 = bswap64(v117[1]);
          if (v79 > v64 || v78 > v64)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 405, 37, 0, "Invalid block header payload=0x%llx raw=0x%llx block=0x%llx\n", v75, v76, v79);
            v82 = 0;
            v83 = 0;
            v77 = 16;
          }
          else
          {
            v80 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, v69[1], v79);
            if (v80 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 411, 37, 0, "reading block payload", v75, v76, v106);
              v82 = 0;
              v83 = 0;
              v77 = 16;
            }
            else
            {
              v77 = v80 + 16;
              if (v80 == v79)
              {
                v81 = v78;
                v82 = 0;
                v69[3] = v79;
                v69[4] = v81;
                v83 = 1;
                v69[2] = v62;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 415, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v75, v76, v80);
                v82 = 0;
                v83 = 0;
              }
            }
            v64 = v107;
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 399, 37, 0, "Truncated block header (%lld/16 bytes read)", v75, v76, v70);
          v82 = 0;
          v83 = 0;
        }
      }
      else
      {
        v82 = 1;
        v83 = 1;
      }
    }
    else
    {
      v84 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, *(_QWORD *)(Worker + 8), v64);
      if (v84 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 428, 37, 0, "reading block", v75, v76, v106);
        v82 = 0;
LABEL_90:
        v63 = 0;
        v85 = -1;
        goto LABEL_91;
      }
      v77 = v84;
      if (!v84)
      {
        v85 = -2;
        v82 = 1;
        goto LABEL_89;
      }
      v82 = 0;
      v69[3] = v84;
      v69[4] = 0;
      v83 = 1;
      v69[2] = v62;
    }
    *(_QWORD *)&v113 = v113 + v77;
    if (!v82 && v83)
    {
      v82 = 0;
      v63 = 1;
      goto LABEL_92;
    }
    if (!v83)
      goto LABEL_90;
    v85 = -2;
LABEL_89:
    v63 = 1;
LABEL_91:
    v69[2] = v85;
LABEL_92:
    if ((ThreadPipelineRunWorker(v61, (uint64_t)v69, v71, v72, v73, v74, v75, v76) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 445, 37, 0, "RunWorker", v59, v60, v106);
      goto LABEL_94;
    }
LABEL_95:
    ++v62;
    if (v82)
      goto LABEL_120;
  }
  atomic_load(v115);
LABEL_120:
  if ((ThreadPipelineDestroy(v61) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 447, 37, 0, "ThreadPipelineDestroy", v100, v101, v106);
    free(v49);
    goto LABEL_104;
  }
  free(v49);
  if (!v63)
  {
LABEL_104:
    v89 = "processStream";
    v90 = 513;
    goto LABEL_105;
  }
  v102 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 40), 0, 0);
  if (v102 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v103, v104, v106);
    v89 = "writing EOF";
    v90 = 520;
    goto LABEL_105;
  }
  v95 = 0;
  *((_QWORD *)&v113 + 1) += v102;
  v94 = 1;
LABEL_106:
  v96 = v114[1];
  if (v114[1])
  {
    if (SDWORD2(v108) >= 1)
    {
      v97 = 0;
      v98 = 0;
      do
      {
        free(*(void **)((char *)v114[1] + v97 + 8));
        free(*(void **)((char *)v114[1] + v97 + 40));
        ++v98;
        v97 += 72;
      }
      while (v98 < SDWORD2(v108));
      v96 = v114[1];
    }
    free(v96);
    v114[1] = 0;
  }
  v99 = v94 ^ 1;
  if (!a3)
    v99 = 1;
  if ((v99 & 1) == 0)
  {
    v29 = 0;
    *(_OWORD *)a3 = v113;
    goto LABEL_40;
  }
  if (!v95)
  {
    v29 = 0;
    goto LABEL_40;
  }
LABEL_35:
  v27 = *(void (**)(_QWORD))(a2 + 32);
  if (v27)
    v27(*(_QWORD *)(a2 + 40));
  v28 = *(void (**)(_QWORD))(a2 + 8);
  if (v28)
    v28(*(_QWORD *)(a2 + 16));
  v29 = -1;
LABEL_40:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v29;
  else
    return result;
}

uint64_t pcRead(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  if (!a4)
    return 0;
  v4 = a4;
  v8 = 0;
  while (1)
  {
    v9 = a1(a2, a3, v4);
    v12 = v9;
    if (v9 < 0)
      break;
    if (v9)
    {
      a3 += v9;
      v8 += v9;
      v4 -= v9;
      if (v4)
        continue;
    }
    return v8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcRead", 82, 37, 0, "pcRead failed", v10, v11, v14);
  return v12;
}

uint64_t getHeader(unsigned int a1, uint64_t a2)
{
  int DecoderKey;
  uint64_t result;
  char v5;

  DecoderKey = PCompressGetDecoderKey(a1);
  if (DecoderKey == 63)
    return 0xFFFFFFFFLL;
  v5 = DecoderKey;
  result = 0;
  *(_DWORD *)a2 = 538976288;
  *(_WORD *)a2 = 25200;
  *(_BYTE *)(a2 + 2) = 122;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}

size_t PCompressCopyEncode(void *a1, size_t a2, void *__src, size_t __n)
{
  size_t v4;

  if (a2 < __n)
    return -1;
  v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

size_t PCompressCopyDecode(void *a1, size_t a2, void *__src, size_t __n)
{
  size_t v4;

  if (a2 < __n)
    return -1;
  v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

AEAAuthData AEAAuthDataCreate(void)
{
  AEAAuthData_impl *v0;
  AEAAuthData_impl *v1;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char v6;

  v0 = (AEAAuthData_impl *)malloc(0x30uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
  }
  else
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataCreate", 19, 95, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void AEAAuthDataDestroy(AEAAuthData auth_data)
{
  if (auth_data)
  {
    free(*((void **)auth_data + 2));
    free(*((void **)auth_data + 5));
    memset_s((char *)auth_data + 24, 0x18uLL, 0, 0x18uLL);
    memset_s(auth_data, 0x30uLL, 0, 0x30uLL);
    free(auth_data);
  }
}

AEAAuthData AEAAuthDataCreateWithContext(AEAContext context)
{
  AEAAuthData v2;
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;
  __int16 v9;
  void *v10;
  size_t v11;
  char *v12;
  _QWORD *v13;
  char v14;
  unint64_t *v15;
  char v16;
  size_t v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  void *v27;
  void *v28;
  unint64_t v29;
  unint64_t v30;
  size_t v31;
  void *v32;
  void *v33;
  unint64_t v34;
  size_t v35;
  unint64_t v36;
  void *v37;
  size_t v38;
  void *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unsigned int *v43;
  uint64_t v44;
  unsigned __int8 *v45;
  uint64_t v46;
  size_t v49;
  size_t __s;
  size_t v51;
  void *__ptr;

  __s = 0;
  v51 = 0;
  __ptr = 0;
  v49 = 0;
  v2 = AEAAuthDataCreate();
  if (v2)
  {
    if (AEAContextGetFieldBlob(context, 5u, 0, 0, 0, &v49) < 0)
    {
      v8 = "AEAContextGetFieldBlob";
      v9 = 46;
      goto LABEL_74;
    }
    if (!v49)
      goto LABEL_95;
    if ((v49 & 0x8000000000000000) == 0)
    {
      v5 = v51;
      if (v51 >= v49)
      {
        v10 = __ptr;
      }
      else
      {
        do
        {
          while (!v5)
          {
            v5 = 0x4000;
            if (v49 <= 0x4000)
            {
              v7 = __ptr;
              v5 = 0x4000;
              goto LABEL_18;
            }
          }
          v6 = v5 >> 1;
          if ((v5 & (v5 >> 1)) != 0)
            v6 = v5 & (v5 >> 1);
          v5 += v6;
        }
        while (v5 < v49);
        if (v5 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_72;
        }
        v7 = __ptr;
LABEL_18:
        v10 = realloc(v7, v5);
        if (!v10)
        {
          free(v7);
LABEL_72:
          v51 = 0;
          __ptr = 0;
          __s = 0;
          goto LABEL_73;
        }
        v51 = v5;
        __ptr = v10;
      }
      if ((AEAContextGetFieldBlob(context, 5u, 0, v5 - __s, (uint8_t *)v10 + __s, &v49) & 0x80000000) == 0)
      {
        v11 = __s;
        if (!v49)
          goto LABEL_25;
        v11 = __s + v49;
        if (!__CFADD__(__s, v49) && v11 <= v51)
        {
          __s += v49;
LABEL_25:
          v12 = (char *)__ptr;
          *(_QWORD *)v2 = 0;
          *((_QWORD *)v2 + 3) = 0;
          v13 = (_QWORD *)((char *)v2 + 24);
          if (v11)
          {
            v14 = 0;
            v15 = (unint64_t *)((char *)v2 + 32);
            v16 = 1;
            while (2)
            {
              v17 = 0;
              v18 = 0;
              v19 = v16;
              do
              {
                if (v17 + 4 > v11)
                  goto LABEL_105;
                v20 = *(unsigned int *)&v12[v17];
                if (v20 < 4)
                  goto LABEL_105;
                v21 = __CFADD__(v20, v17);
                v22 = v20 + v17;
                if (v21 || v22 > v11)
                  goto LABEL_105;
                if ((v14 & 1) != 0)
                {
                  v23 = *((_QWORD *)v2 + 2);
                  v24 = (*(_QWORD *)v2)++;
                  *(_QWORD *)(v23 + 8 * v24) = v17;
                }
                ++v18;
                v17 = v22;
              }
              while (v22 < v11);
              if (v22 != v11)
                goto LABEL_105;
              if ((v19 & 1) == 0)
              {
LABEL_61:
                *v13 = 0;
                if ((v11 & 0x8000000000000000) == 0)
                {
                  v34 = *v15;
                  if (*v15 < v11)
                  {
                    v35 = 0x4000;
                    do
                    {
                      while (!v34)
                      {
                        v34 = 0x4000;
                        if (v11 <= 0x4000)
                          goto LABEL_78;
                      }
                      v36 = v34 >> 1;
                      if ((v34 & (v34 >> 1)) != 0)
                        v36 = v34 & (v34 >> 1);
                      v34 += v36;
                    }
                    while (v34 < v11);
                    v35 = v34;
                    if (v34 >= 0x2000000001)
                    {
                      *__error() = 12;
                      goto LABEL_104;
                    }
LABEL_78:
                    v37 = (void *)*((_QWORD *)v2 + 5);
                    v38 = v35;
                    v39 = realloc(v37, v35);
                    if (v39)
                    {
                      *((_QWORD *)v2 + 4) = v38;
                      *((_QWORD *)v2 + 5) = v39;
                      goto LABEL_80;
                    }
                    free(v37);
LABEL_104:
                    *v15 = 0;
                    *((_QWORD *)v2 + 5) = 0;
                    goto LABEL_105;
                  }
LABEL_80:
                  v40 = *((_QWORD *)v2 + 5);
                  if (v12)
                  {
                    memcpy((void *)(v40 + *v13), v12, v11);
                  }
                  else if (v40)
                  {
                    memset_s((void *)(v40 + *v13), v11, 0, v11);
                  }
                  *((_QWORD *)v2 + 3) += v11;
                  v41 = *(_QWORD *)v2;
                  if (*(_QWORD *)v2)
                  {
                    v42 = 0;
                    while (1)
                    {
                      if (v41 <= v42)
                      {
                        v43 = 0;
                        v44 = 0xFFFFFFFFLL;
                      }
                      else
                      {
                        v43 = (unsigned int *)(*((_QWORD *)v2 + 5) + *(_QWORD *)(*((_QWORD *)v2 + 2) + 8 * v42));
                        v44 = *v43;
                        if (v44 < 5)
                        {
LABEL_97:
                          v8 = "invalid auth_data key";
                          v9 = 74;
                          goto LABEL_74;
                        }
                      }
                      v45 = (unsigned __int8 *)(v43 + 1);
                      v46 = v44 - 4;
                      while (*v45++)
                      {
                        if (!--v46)
                          goto LABEL_97;
                      }
                      if (++v42 == v41)
                        goto LABEL_95;
                    }
                  }
                  break;
                }
LABEL_105:
                *(_QWORD *)v2 = 0;
                *((_QWORD *)v2 + 3) = 0;
                v8 = "invalid auth data blob";
                v9 = 62;
LABEL_74:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataCreateWithContext", v9, 95, 0, v8, v3, v4, v49);
                free(__ptr);
                memset_s(&__s, 0x18uLL, 0, 0x18uLL);
                AEAAuthDataDestroy(v2);
                return 0;
              }
              if (v18 > 0xFFFFFFFE)
                goto LABEL_105;
              v25 = *((_QWORD *)v2 + 1);
              if (v25 < v18)
              {
                v26 = *((_QWORD *)v2 + 1);
                do
                {
                  if (v26)
                    v26 *= 2;
                  else
                    v26 = 16;
                }
                while (v26 < v18);
                if (v26 > v25)
                {
                  *((_QWORD *)v2 + 1) = v26;
                  if (8 * v26 >= 0x2000000001)
                  {
                    *__error() = 12;
                  }
                  else
                  {
                    v27 = (void *)*((_QWORD *)v2 + 2);
                    v28 = realloc(v27, 8 * v26);
                    if (v28)
                    {
                      *((_QWORD *)v2 + 2) = v28;
                      goto LABEL_48;
                    }
                    free(v27);
                  }
                  *((_QWORD *)v2 + 2) = 0;
                  goto LABEL_105;
                }
              }
LABEL_48:
              if ((v11 & 0x8000000000000000) != 0)
                goto LABEL_105;
              v29 = *v15;
              if (*v15 < v11)
              {
                do
                {
                  while (!v29)
                  {
                    v29 = 0x4000;
                    v31 = 0x4000;
                    if (v11 <= 0x4000)
                      goto LABEL_58;
                  }
                  v30 = v29 >> 1;
                  if ((v29 & (v29 >> 1)) != 0)
                    v30 = v29 & (v29 >> 1);
                  v29 += v30;
                }
                while (v29 < v11);
                v31 = v29;
                if (v29 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_99;
                }
LABEL_58:
                v32 = (void *)*((_QWORD *)v2 + 5);
                v33 = realloc(v32, v31);
                if (v33)
                {
                  *((_QWORD *)v2 + 4) = v31;
                  *((_QWORD *)v2 + 5) = v33;
                  goto LABEL_60;
                }
                free(v32);
LABEL_99:
                *v13 = 0;
                *((_QWORD *)v2 + 4) = 0;
                *((_QWORD *)v2 + 5) = 0;
                goto LABEL_105;
              }
LABEL_60:
              v16 = 0;
              v14 = 1;
              if ((v19 & 1) != 0)
                continue;
              goto LABEL_61;
            }
          }
LABEL_95:
          free(__ptr);
          memset_s(&__s, 0x18uLL, 0, 0x18uLL);
          return v2;
        }
      }
    }
LABEL_73:
    v8 = "AEAContextGetFieldBlob";
    v9 = 59;
    goto LABEL_74;
  }
  return v2;
}

uint32_t AEAAuthDataGetEntryCount(AEAAuthData auth_data)
{
  return *(_DWORD *)auth_data;
}

int AEAAuthDataGetEntry(AEAAuthData auth_data, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  unsigned int *v8;
  _BYTE *v9;
  unint64_t v10;
  size_t v14;
  size_t v15;
  char v17;

  if (*(_QWORD *)auth_data <= (unint64_t)i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataGetEntry", 98, 95, 0, "invalid entry index %u", (uint64_t)data, (uint64_t)data_size, i);
    return -1;
  }
  v8 = (unsigned int *)(*((_QWORD *)auth_data + 5) + *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * i));
  v9 = v8 + 1;
  v10 = *v8;
  if (v10 < 5)
    goto LABEL_15;
  v14 = 0;
  while (v9[v14])
  {
    if ((unint64_t)++v14 + 4 >= v10)
      goto LABEL_15;
  }
  if ((int)v10 - 5 - (int)v14 >= v10)
  {
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataGetEntry", 109, 95, 0, "invalid auth_data blob", (uint64_t)data, (uint64_t)data_size, v17);
    return -1;
  }
  v15 = (v10 - 5 - v14);
  if (key_length)
    *key_length = v14;
  if (data_size)
    *data_size = v15;
  if (v14 >= key_capacity)
  {
    if (key_capacity)
      return -1;
  }
  else
  {
    memcpy(key, v9, v14);
    key[v14] = 0;
  }
  if (v15 > data_capacity)
  {
    if (!data_capacity)
      return 0;
    return -1;
  }
  memcpy(data, (char *)v8 + v10 - (v10 - 5 - v14), (v10 - 5 - v14));
  return 0;
}

int AEAAuthDataAppendEntry(AEAAuthData auth_data, const char *key, const uint8_t *data, size_t data_size)
{
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  size_t v12;
  const char *v13;
  __int16 v14;
  rsize_t v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void **v23;
  _QWORD *v24;
  void *v25;
  size_t v26;
  size_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  unint64_t v31;
  size_t v32;
  void **v33;
  char *v34;
  _QWORD *v35;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  void **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v8 = strlen(key);
  v11 = v8 + 1;
  v12 = v8 + 5;
  if (v8 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (v15 = data_size + v12, __CFADD__(data_size, v12)) || v15 >= 0xFFFFFFFF)
  {
    v13 = "invalid attribute size";
    v14 = 148;
LABEL_49:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataAppendEntry", v14, 95, 0, v13, v9, v10, (char)v43);
    return -1;
  }
  if (v15 < 4)
    goto LABEL_48;
  v16 = (_QWORD *)((char *)auth_data + 24);
  v17 = *((_QWORD *)auth_data + 3);
  v18 = v17 + v15;
  if (__CFADD__(v17, v15))
    goto LABEL_48;
  v20 = *(_QWORD *)auth_data;
  v19 = *((_QWORD *)auth_data + 1);
  v21 = *(_QWORD *)auth_data + 1;
  if (v19 < v21)
  {
    v22 = *((_QWORD *)auth_data + 1);
    do
    {
      if (v22)
        v22 *= 2;
      else
        v22 = 16;
    }
    while (v22 < v21);
    if (v22 > v19)
    {
      v24 = (_QWORD *)((char *)auth_data + 16);
      v23 = (void **)*((_QWORD *)auth_data + 2);
      *((_QWORD *)auth_data + 1) = v22;
      if (8 * v22 >= 0x2000000001)
      {
        *__error() = 12;
LABEL_47:
        *(_QWORD *)auth_data = 0;
        *v24 = 0;
        *((_QWORD *)auth_data + 3) = 0;
        goto LABEL_48;
      }
      v43 = v23;
      v44 = v20;
      v25 = realloc(v23, 8 * v22);
      if (!v25)
      {
        free(v43);
        goto LABEL_47;
      }
      *v24 = v25;
      v20 = v44;
    }
  }
  if ((v18 & 0x8000000000000000) != 0)
    goto LABEL_43;
  v26 = *((_QWORD *)auth_data + 4);
  if (v26 < v18)
  {
    do
    {
      while (!v26)
      {
        v26 = 0x4000;
        if (v18 <= 0x4000)
        {
          v26 = 0x4000;
          goto LABEL_29;
        }
      }
      v27 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0)
        v27 = v26 & (v26 >> 1);
      v26 += v27;
    }
    while (v26 < v18);
    if (v26 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_42;
    }
LABEL_29:
    v45 = v20;
    v28 = (void *)*((_QWORD *)auth_data + 5);
    v29 = realloc(v28, v26);
    if (v29)
    {
      *((_QWORD *)auth_data + 4) = v26;
      *((_QWORD *)auth_data + 5) = v29;
      v20 = v45;
      goto LABEL_31;
    }
    free(v28);
LABEL_42:
    *((_QWORD *)auth_data + 4) = 0;
    *((_QWORD *)auth_data + 5) = 0;
LABEL_43:
    *(_QWORD *)auth_data = 0;
    *((_QWORD *)auth_data + 3) = 0;
    goto LABEL_48;
  }
LABEL_31:
  v30 = *v16;
  v31 = *v16 + v15;
  if (__CFADD__(*v16, v15) || (v31 & 0x8000000000000000) != 0)
    goto LABEL_48;
  if (v26 < v31)
  {
    do
    {
      while (!v26)
      {
        v26 = 0x4000;
        if (v31 <= 0x4000)
        {
          v46 = v20;
          v33 = (void **)((char *)auth_data + 40);
          v26 = 0x4000;
          goto LABEL_53;
        }
      }
      v32 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0)
        v32 = v26 & (v26 >> 1);
      v26 += v32;
    }
    while (v26 < v31);
    v33 = (void **)((char *)auth_data + 40);
    if (v26 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_61;
    }
    v46 = v20;
LABEL_53:
    v43 = v33;
    v37 = *v33;
    v34 = (char *)realloc(v37, v26);
    if (v34)
    {
      *((_QWORD *)auth_data + 5) = v34;
      v35 = (_QWORD *)((char *)auth_data + 40);
      *((_QWORD *)auth_data + 4) = v26;
      v30 = *((_QWORD *)auth_data + 3);
      goto LABEL_55;
    }
    free(v37);
    v33 = v43;
LABEL_61:
    *v33 = 0;
    *v16 = 0;
    *((_QWORD *)auth_data + 4) = 0;
    goto LABEL_48;
  }
  v46 = v20;
  v35 = (_QWORD *)((char *)auth_data + 40);
  v34 = (char *)*((_QWORD *)auth_data + 5);
  if (v34)
  {
LABEL_55:
    memset_s(&v34[v30], v15, 0, v15);
    v30 = *v16;
  }
  *((_QWORD *)auth_data + 3) = v30 + v15;
  v38 = *((_QWORD *)auth_data + 2);
  v39 = (*(_QWORD *)auth_data)++;
  *(_QWORD *)(v38 + 8 * v39) = v17;
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > *v16 || (*(_DWORD *)(*v35 + v17) = v15, v46 < 0))
  {
LABEL_48:
    v13 = "alloc auth_data entry";
    v14 = 152;
    goto LABEL_49;
  }
  v40 = *((_QWORD *)auth_data + 5);
  v41 = *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * v46);
  *(_DWORD *)(v40 + v41) = v15;
  v42 = (char *)(v40 + v41 + 4);
  memcpy(v42, key, v11);
  memcpy(&v42[v11], data, data_size);
  return 0;
}

int AEAAuthDataSetEntry(AEAAuthData auth_data, uint32_t i, const char *key, const uint8_t *data, size_t data_size)
{
  uint64_t v5;
  uint64_t v6;
  size_t v12;
  size_t v13;
  size_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  size_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char v48;
  size_t v49;
  uint64_t v50;
  unint64_t v51;

  if (*(_QWORD *)auth_data <= (unint64_t)i)
  {
    v24 = "invalid auth_data index";
    v25 = 172;
    goto LABEL_11;
  }
  v12 = strlen(key);
  v13 = v12 + 1;
  v14 = v12 + 5;
  if (v12 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (v15 = data_size + v14, __CFADD__(data_size, v14)) || v15 >= 0xFFFFFFFF)
  {
    v24 = "invalid attribute size";
    v25 = 180;
    goto LABEL_11;
  }
  if (v15 < 4)
    goto LABEL_8;
  v16 = i;
  v17 = *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * i);
  v18 = (char *)*((_QWORD *)auth_data + 5);
  v19 = *(unsigned int *)&v18[v17];
  v20 = v17 + v19;
  if (__CFADD__(v17, v19)
    || (v21 = (unint64_t *)((char *)auth_data + 24), v22 = *((_QWORD *)auth_data + 3), v23 = v22 - v20, v22 < v20))
  {
LABEL_8:
    v24 = "alloc auth_data entry";
    v25 = 183;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataSetEntry", v25, 95, 0, v24, v5, v6, v48);
    return -1;
  }
  v27 = v15 - v19;
  if (v15 > v19)
  {
    v28 = v22 + v27;
    if ((uint64_t)(v22 + v27) < 0)
      goto LABEL_8;
    v29 = *((_QWORD *)auth_data + 4);
    if (v29 < v28)
    {
      v30 = 0x4000;
      do
      {
        while (!v29)
        {
          v29 = 0x4000;
          if (v28 <= 0x4000)
            goto LABEL_29;
        }
        v31 = v29 >> 1;
        if ((v29 & (v29 >> 1)) != 0)
          v31 = v29 & (v29 >> 1);
        v29 += v31;
      }
      while (v29 < v28);
      v30 = v29;
      if (v29 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_44;
      }
LABEL_29:
      v50 = v27;
      v51 = v16;
      v49 = v30;
      v37 = (char *)realloc(v18, v30);
      if (v37)
      {
        v27 = v50;
        *((_QWORD *)auth_data + 4) = v49;
        *((_QWORD *)auth_data + 5) = v37;
        v18 = v37;
        v16 = v51;
        v21 = (unint64_t *)((char *)auth_data + 24);
        v23 = v22 - v20;
        goto LABEL_31;
      }
      free(v18);
LABEL_44:
      *((_QWORD *)auth_data + 3) = 0;
      *((_QWORD *)auth_data + 4) = 0;
      *((_QWORD *)auth_data + 5) = 0;
      goto LABEL_8;
    }
LABEL_31:
    if (v22 != v20)
    {
      v38 = &v18[v20];
      v39 = &v18[v20 + v27];
      v40 = v21;
      v41 = v16;
      v42 = v27;
      memmove(v39, v38, v23);
      v27 = v42;
      v16 = v41;
      v21 = v40;
    }
    v22 = *v21 + v27;
    goto LABEL_34;
  }
  if (v15 < v19)
  {
    v32 = v19 - v15;
    if (v22 != v20)
    {
      v33 = &v18[v20];
      v34 = &v18[v20 - v32];
      v35 = v16;
      v36 = v32;
      memmove(v34, v33, v23);
      v32 = v36;
      v16 = v35;
      v21 = (unint64_t *)((char *)auth_data + 24);
      v20 = *((_QWORD *)auth_data + 3);
    }
    v22 = v20 - v32;
LABEL_34:
    *v21 = v22;
  }
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > v22)
    goto LABEL_8;
  *(_DWORD *)(*((_QWORD *)auth_data + 5) + v17) = v15;
  if (*(_QWORD *)auth_data > v16)
  {
    v43 = v16;
    while (v17 < 0xFFFFFFFFFFFFFFFCLL && v17 + 4 <= *v21)
    {
      v44 = *(unsigned int *)(*((_QWORD *)auth_data + 5) + v17);
      *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * v43) = v17;
      v17 += v44;
      if (++v43 >= *(_QWORD *)auth_data)
        goto LABEL_42;
    }
    goto LABEL_8;
  }
LABEL_42:
  v45 = *((_QWORD *)auth_data + 5);
  v46 = *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * v16);
  *(_DWORD *)(v45 + v46) = v15;
  v47 = (char *)(v45 + v46 + 4);
  memcpy(v47, key, v13);
  memcpy(&v47[v13], data, data_size);
  return 0;
}

int AEAAuthDataClear(AEAAuthData auth_data)
{
  *(_QWORD *)auth_data = 0;
  *((_QWORD *)auth_data + 3) = 0;
  return 0;
}

int AEAAuthDataRemoveEntry(AEAAuthData auth_data, uint32_t i)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v14;
  uint64_t v15;

  v4 = *(_QWORD *)auth_data;
  if (*(_QWORD *)auth_data <= (unint64_t)i
    || (v6 = i,
        v7 = *(_QWORD *)(*((_QWORD *)auth_data + 2) + 8 * i),
        v8 = *((_QWORD *)auth_data + 5),
        v9 = *(unsigned int *)(v8 + v7),
        v10 = __CFADD__(v7, v9),
        v11 = v7 + v9,
        v10)
    || (v12 = *((_QWORD *)auth_data + 3), v12 < v11))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataRemoveEntry", 205, 95, 0, "invalid auth_data index %u", v2, v3, i);
    return -1;
  }
  else
  {
    if ((_DWORD)v9)
    {
      if (v12 != v11)
      {
        memmove((void *)(v8 + v11 - v9), (const void *)(v8 + v11), v12 - v11);
        v11 = *((_QWORD *)auth_data + 3);
        v4 = *(_QWORD *)auth_data;
      }
      *((_QWORD *)auth_data + 3) = v11 - v9;
    }
    v14 = v4 - 1;
    *(_QWORD *)auth_data = v14;
    if (v14 > v6)
    {
      v15 = *((_QWORD *)auth_data + 2);
      do
      {
        *(_QWORD *)(v15 + 8 * v6) = *(_QWORD *)(v15 + 8 * v6 + 8) - v9;
        ++v6;
      }
      while (v6 < *(_QWORD *)auth_data);
    }
    return 0;
  }
}

size_t AEAAuthDataGetEncodedSize(AEAAuthData auth_data)
{
  return *((_QWORD *)auth_data + 3);
}

const uint8_t *__cdecl AEAAuthDataGetEncodedData(AEAAuthData auth_data)
{
  return (const uint8_t *)*((_QWORD *)auth_data + 5);
}

uint64_t apfs_scan_diskimage(const char *a1, uint64_t (*a2)(__int128 *, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  AAByteStream_impl *v11;
  char *v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const char *v28;
  const char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  FILE *v35;
  FILE *v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  size_t v42;
  uint64_t v43;
  const char *v44;
  __int16 v45;
  int v46;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  __int16 v52;
  int v53;
  void **v54;
  const char *v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  stat v60;
  char *__s1[2];
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  uint64_t __src;
  uint64_t v66;
  __int128 v67;
  int v68[4];
  char v69[1024];
  char __str[1024];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  memset(&v60, 0, sizeof(v60));
  if (snprintf(__str, 0x400uLL, "%s.json", a1) > 0)
  {
    if (!stat(__str, &v60) && (v60.st_mode & 0xF000) == 0x8000)
    {
      v11 = AAFileStreamOpenWithPath(__str, 0, 0);
      if (v11)
      {
        v12 = 0;
LABEL_6:
        v67 = 0u;
        *(_OWORD *)v68 = 0u;
        __src = 0;
        v66 = 0;
        v13 = (void **)AAJSONInputStreamOpen((uint64_t)v11);
        if (v13)
        {
          v20 = v13;
          v64 = 0;
          v62 = 0u;
          v63 = 0u;
          *(_OWORD *)__s1 = 0u;
          if ((AAJSONInputStreamRead((uint64_t)v13, (int *)__s1, v14, v15, v16, v17, v18, v19) & 0x80000000) == 0)
          {
            while (1)
            {
              v27 = v64;
              if (!(_DWORD)v64)
              {
                AAJSONInputStreamClose(v20);
                v46 = 1;
                goto LABEL_66;
              }
              if (LODWORD(__s1[0]) < 2)
                break;
              if (LODWORD(__s1[0]) == 2)
              {
                if ((_DWORD)v64 == 4)
                {
                  v68[1] = *(_QWORD *)(*(_QWORD *)&v68[2] - 64);
                  if ((a2(&v67, a4) & 0x80000000) != 0)
                  {
                    v55 = "add_fork";
                    v56 = 58;
                    goto LABEL_88;
                  }
                  pc_array_free(*(uint64_t *)&v68[2]);
                  *(_QWORD *)&v68[2] = 0;
                  v27 = v64;
                }
                if (v27 == 6)
                {
                  *(_QWORD *)&v68[2] = pc_array_append(*(uint64_t *)&v68[2], &__src, v21, v22, v23, v24, v25, v26);
                  if (!*(_QWORD *)&v68[2])
                  {
                    v55 = "pc_array_append";
                    v56 = 67;
                    goto LABEL_88;
                  }
                }
              }
              else if (LODWORD(__s1[0]) == 4)
              {
                if ((_DWORD)v64 == 7)
                {
                  v29 = __s1[1];
                  if (!strcmp(__s1[1], "offset"))
                  {
                    __src = *((_QWORD *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v29, "length"))
                    {
                      v55 = "bad map";
                      v56 = 83;
                      goto LABEL_88;
                    }
                    v66 = *((_QWORD *)&v62 + 1);
                  }
                }
                else if ((_DWORD)v64 == 5)
                {
                  v28 = __s1[1];
                  if (!strcmp(__s1[1], "compression"))
                  {
                    v68[0] = BYTE8(v62);
                  }
                  else if (!strcmp(v28, "uncompressed_size"))
                  {
                    *(_QWORD *)&v67 = *((_QWORD *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v28, "size"))
                    {
                      v55 = "bad map";
                      v56 = 77;
                      goto LABEL_88;
                    }
                    *((_QWORD *)&v67 + 1) = *((_QWORD *)&v62 + 1);
                  }
                }
              }
LABEL_38:
              v64 = 0;
              v62 = 0u;
              v63 = 0u;
              *(_OWORD *)__s1 = 0u;
              if ((AAJSONInputStreamRead((uint64_t)v20, (int *)__s1, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0)
                goto LABEL_89;
            }
            switch((int)v64)
            {
              case 2:
                if (!strcmp(__s1[1], "volumes"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 41;
                break;
              case 4:
                if (!strcmp(__s1[1], "files"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 42;
                break;
              case 5:
                v67 = 0u;
                *(_OWORD *)v68 = 0u;
                *(_QWORD *)&v68[2] = pc_array_init(16);
                goto LABEL_38;
              case 6:
                if (!strcmp(__s1[1], "extents"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 43;
                break;
              case 8:
                v55 = "bad map";
                v56 = 44;
                break;
              default:
                goto LABEL_38;
            }
LABEL_88:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", v56, 144, 0, v55, v25, v26, (char)v59);
          }
LABEL_89:
          v54 = v20;
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", 27, 144, 0, "AAJSONInputStreamOpen", v18, v19, (char)v59);
          v54 = 0;
        }
        AAJSONInputStreamClose(v54);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 181, 144, 0, "invalid image map JSON", v57, v58, (char)v59);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 114, 144, 0, "AAFileStreamOpenWithPath", v9, v10, (char)v59);
        v12 = 0;
      }
      goto LABEL_65;
    }
    if (getenv("PC_APFS_DISKIMAGE_MAP") && (__strlcpy_chk(), !stat(__str, &v60)) && (v60.st_mode & 0xF000) == 0x8000
      || (v30 = getenv("MASTERING_TOOLCHAIN_DIR")) != 0
      && (snprintf(__str, 0x400uLL, "%s%s/%s", v30, "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000|| (snprintf(__str, 0x400uLL, "%s/%s", "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000)
    {
      v12 = (char *)malloc(0x40000uLL);
      if (v12)
      {
        v11 = (AAByteStream_impl *)AATempStreamOpen(0x800000uLL);
        if (v11)
        {
          snprintf(v69, 0x400uLL, "%s \"%s\"", __str, a1);
          v35 = popen(v69, "r");
          if (v35)
          {
            v36 = v35;
            while (1)
            {
              if (feof(v36))
              {
                pclose(v36);
                AAByteStreamSeek(v11, 0, 0);
                goto LABEL_6;
              }
              v37 = fread(v12, 1uLL, 0x40000uLL, v36);
              if (ferror(v36))
                break;
              if (*((_QWORD *)v11 + 3))
              {
                v40 = 0;
                if (v37)
                {
                  v41 = v12;
                  v42 = v37;
                  while (1)
                  {
                    v43 = (*((uint64_t (**)(_QWORD, char *, size_t))v11 + 3))(*(_QWORD *)v11, v41, v42);
                    if (v43 < 1)
                      break;
                    v41 += v43;
                    v40 += v43;
                    v42 -= v43;
                    if (!v42)
                      goto LABEL_62;
                  }
                  v40 = v43;
                }
              }
              else
              {
                v40 = -1;
              }
LABEL_62:
              if (v40 != v37)
              {
                v44 = "writing tool output";
                v45 = 172;
                goto LABEL_82;
              }
            }
            v44 = "reading from tool pipe";
            v45 = 170;
LABEL_82:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v45, 144, 0, v44, v38, v39, (char)v59);
            AAByteStreamClose(v11);
            pclose(v36);
            goto LABEL_70;
          }
          v53 = *__error();
          v59 = v69;
          v51 = "%s";
          v52 = 164;
        }
        else
        {
          v51 = "temp stream open";
          v52 = 159;
          v53 = 0;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v52, 144, v53, v51, v33, v34, (char)v59);
LABEL_69:
        AAByteStreamClose(v11);
LABEL_70:
        v46 = 0;
        goto LABEL_71;
      }
      v48 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 156, 144, *v48, "malloc", v49, v50, (char)v59);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 153, 144, 0, "could not locate the apfs diskimage map tool", v31, v32, (char)v59);
      v12 = 0;
    }
    v11 = 0;
    goto LABEL_69;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 110, 144, 0, "snprintf", v7, v8, (char)v59);
  v12 = 0;
  v11 = 0;
LABEL_65:
  v46 = 0;
LABEL_66:
  AAByteStreamClose(v11);
LABEL_71:
  free(v12);
  if (v46)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t reStringAppend(uint64_t a1, const char *a2, uint64_t a3, char a4)
{
  _QWORD *v8;
  size_t v9;
  void *v10;
  void *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  _BYTE *v20;
  const char *v21;
  size_t v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  uint64_t result;
  size_t v29;

  v8 = (_QWORD *)(a1 + 8);
  v9 = a3 + *(_QWORD *)(a1 + 16) + 16;
  if (v9 <= *(_QWORD *)(a1 + 8))
    goto LABEL_5;
  *(_QWORD *)(a1 + 8) = v9;
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_30:
    *(_QWORD *)a1 = 0;
    perror("malloc");
    *v8 = 0;
    v8[1] = 0;
    return 0xFFFFFFFFLL;
  }
  v10 = *(void **)a1;
  v11 = realloc(*(void **)a1, v9);
  if (!v11)
  {
    free(v10);
    goto LABEL_30;
  }
  *(_QWORD *)a1 = v11;
LABEL_5:
  v12 = "(^\\Q";
  if ((a4 & 4) == 0)
    v12 = "(^";
  v13 = "(\\Q";
  if ((a4 & 4) == 0)
    v13 = "(";
  if ((a4 & 1) != 0)
    v14 = v12;
  else
    v14 = v13;
  v15 = "\\E)";
  if ((a4 & 4) == 0)
    v15 = ")";
  v16 = "\\E/)";
  if ((a4 & 4) == 0)
    v16 = "/)";
  if ((a4 & 8) != 0)
    v17 = v16;
  else
    v17 = v15;
  if ((a4 & 4) != 0)
    v18 = "\\E$)";
  else
    v18 = "$)";
  v19 = *(_QWORD *)(a1 + 16);
  v20 = *(_BYTE **)a1;
  if ((a4 & 2) != 0)
    v21 = v18;
  else
    v21 = v17;
  if (v19)
  {
    *(_QWORD *)(a1 + 16) = v19 + 1;
    v20[v19] = 124;
    v20 = *(_BYTE **)a1;
    v19 = *(_QWORD *)(a1 + 16);
  }
  strlcpy(&v20[v19], v14, *(_QWORD *)(a1 + 8) - v19);
  v22 = strlen(v14);
  v23 = *(_QWORD *)(a1 + 8);
  v24 = *(_QWORD *)(a1 + 16) + v22;
  *(_QWORD *)(a1 + 16) = v24;
  strlcpy((char *)(*(_QWORD *)a1 + v24), a2, v23 - v24);
  v25 = *(_QWORD *)(a1 + 8);
  v26 = *(_QWORD *)(a1 + 16) + a3;
  *(_QWORD *)(a1 + 16) = v26;
  strlcpy((char *)(*(_QWORD *)a1 + v26), v21, v25 - v26);
  v27 = strlen(v21);
  result = 0;
  v29 = *(_QWORD *)(a1 + 16) + v27;
  *(_QWORD *)(a1 + 16) = v29;
  *(_BYTE *)(*(_QWORD *)a1 + v29) = 0;
  return result;
}

_QWORD *AAPathFilterCreate()
{
  _QWORD *v0;
  _QWORD *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  v0 = malloc(0xA8uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0xA8uLL, 0, 0xA8uLL);
    v1[3] = StringTableCreate();
    v1[12] = StringTableCreate();
    v1[1] = StringTableCreate();
    v2 = StringTableCreate();
    v1[2] = v2;
    if (!v1[3] || !v1[12] || !v1[1] || !v2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterCreate", 192, 130, 0, "StringTableCreate", v3, v4, v9);
      AAPathFilterDestroy((uint64_t)v1);
      return 0;
    }
  }
  else
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterCreate", 183, 130, *v5, "malloc", v6, v7, v9);
  }
  return v1;
}

void AAPathFilterDestroy(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 56))
      MEMORY[0x20BD24A58](a1 + 64);
    if (*(_DWORD *)(a1 + 128))
      MEMORY[0x20BD24A58](a1 + 64);
    StringTableDestroy(*(void ***)(a1 + 24));
    StringTableDestroy(*(void ***)(a1 + 96));
    StringTableDestroy(*(void ***)(a1 + 8));
    StringTableDestroy(*(void ***)(a1 + 16));
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    free(*(void **)(a1 + 104));
    free((void *)a1);
  }
}

uint64_t AAPathFilterAddRule(uint64_t a1, unsigned int a2, unsigned int a3, char *__s, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t result;
  uint64_t v26;
  size_t v27;
  char v28;
  char v29[1040];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      MEMORY[0x20BD24A58](a1 + 64);
      *(_DWORD *)(a1 + 56) = 0;
    }
    if (*(_DWORD *)(a1 + 128))
    {
      MEMORY[0x20BD24A58](a1 + 64);
      *(_DWORD *)(a1 + 128) = 0;
    }
    *(_DWORD *)a1 = 0;
  }
  if (a2 >= 3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 235, 130, 0, "invalid rule type: %u", a7, a8, a2);
  }
  else if (a3 >= 3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 243, 130, 0, "invalid match type: %u", a7, a8, a3);
  }
  else
  {
    if (a2 == 2 && a3)
    {
      v13 = "expected match type PREFIX for MAPTO rule";
      v14 = 246;
LABEL_58:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", v14, 130, 0, v13, a7, a8, v28);
      return 0xFFFFFFFFLL;
    }
    if (a2 == 2 && !a5)
    {
      v13 = "mapto string is required for MAPTO rule";
      v14 = 248;
      goto LABEL_58;
    }
    if (a2 != 2 && a5)
    {
      v13 = "mapto string is not allowed for non MAPTO rules";
      v14 = 250;
      goto LABEL_58;
    }
    if (!__s)
    {
      v13 = "match string is required for all rules";
      v14 = 252;
      goto LABEL_58;
    }
    v19 = strlen(__s);
    if (a3 != 1 && !pathIsValid(__s, v19))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 256, 130, 0, "invalid match path: %s", v17, v18, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a5)
    {
      v20 = strlen(a5);
      if (!pathIsValid(a5, v20))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 260, 130, 0, "invalid mapto path: %s", v17, v18, (char)a5);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v20 = 0;
    }
    if (a3 != 2 || v19 && !strchr(__s, 47))
    {
      if (a2 == 2)
      {
        if ((StringTableAppend(*(unsigned int **)(a1 + 8), __s, v19, 0, v15, v16, v17, v18) & 0x80000000) != 0)
        {
          v13 = "StringTableAppend";
          v14 = 270;
          goto LABEL_58;
        }
        if ((StringTableAppend(*(unsigned int **)(a1 + 16), a5, v20, 0, v21, v22, a7, a8) & 0x80000000) != 0)
        {
          v13 = "StringTableAppend";
          v14 = 271;
          goto LABEL_58;
        }
      }
      else
      {
        if (a2)
          v23 = a1 + 104;
        else
          v23 = a1 + 32;
        if (a3)
        {
          if (a3 != 2)
          {
            v24 = reStringAppend(v23, __s, v19, 0);
            result = 0;
            if ((v24 & 0x80000000) == 0)
              return result;
            v13 = "error building regex";
            v14 = 283;
            goto LABEL_58;
          }
          v29[0] = 47;
          __memcpy_chk();
          v27 = v19 + 1;
          v29[v19 + 1] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 6) & 0x80000000) != 0)
          {
            v13 = "error building regex";
            v14 = 299;
            goto LABEL_58;
          }
          v29[v27] = 47;
          v29[v19 + 2] = 0;
          if ((reStringAppend(v23, v29, v19 + 2, 4) & 0x80000000) != 0)
          {
            v13 = "error building regex";
            v14 = 303;
            goto LABEL_58;
          }
          __memcpy_chk();
          v29[v19] = 47;
          v29[v27] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 5) & 0x80000000) != 0)
          {
            v13 = "error building regex";
            v14 = 307;
            goto LABEL_58;
          }
          if ((reStringAppend(v23, __s, v19, 7) & 0x80000000) != 0)
          {
            v13 = "error building regex";
            v14 = 310;
            goto LABEL_58;
          }
        }
        else
        {
          v26 = 96;
          if (!a2)
            v26 = 24;
          if ((StringTableAppend(*(unsigned int **)(a1 + v26), __s, v19, 0, v15, v16, v17, v18) & 0x80000000) != 0)
          {
            v13 = "StringTableAppend";
            v14 = 289;
            goto LABEL_58;
          }
        }
      }
      return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 264, 130, 0, "invalid path for name match: %s", v17, v18, (char)__s);
  }
  return 0xFFFFFFFFLL;
}

uint64_t AAPathFilterApply(uint64_t a1, char *__s, size_t a3, char *a4)
{
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  _BOOL4 v20;
  __int16 v21;
  uint64_t result;
  int v23;
  unsigned int v24;
  uint64_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  size_t v32;
  uint64_t v35;
  uint64_t v36;
  size_t v37;
  size_t v38;
  size_t v39;
  size_t v40;
  size_t v41;
  char *__dst;

  if (!*(_DWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 48) && !*(_DWORD *)(a1 + 56))
    {
      v13 = regcomp((regex_t *)(a1 + 64), *(const char **)(a1 + 32), 257);
      if (v13)
      {
        AAPathFilterApply_cold_2(v13, (const regex_t *)(a1 + 64));
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 56) = 1;
    }
    if (*(_QWORD *)(a1 + 120) && !*(_DWORD *)(a1 + 128))
    {
      v14 = regcomp((regex_t *)(a1 + 136), *(const char **)(a1 + 104), 257);
      if (v14)
      {
        AAPathFilterApply_cold_1(v14, (const regex_t *)(a1 + 136));
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 128) = 1;
    }
    if ((StringTableSort(*(unsigned int **)(a1 + 24), 0) & 0x80000000) != 0)
    {
      v21 = 134;
    }
    else
    {
      if ((StringTableSort(*(unsigned int **)(a1 + 96), 0) & 0x80000000) == 0)
      {
        *(_DWORD *)a1 = 1;
        goto LABEL_2;
      }
      v21 = 135;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"prepareFilter", v21, 130, 0, "string table sort", v15, v16, v41);
LABEL_34:
    v17 = "filter prepare";
    v18 = 325;
    goto LABEL_35;
  }
LABEL_2:
  v8 = strlen(__s);
  if (!pathIsValid(__s, v8))
  {
    v17 = "invalid input path";
    v18 = 327;
    goto LABEL_35;
  }
  if (!StringTableSize(*(unsigned int **)(a1 + 24)) && !*(_DWORD *)(a1 + 56))
    goto LABEL_25;
  if (StringTableSize(*(unsigned int **)(a1 + 24)))
  {
    v11 = StringTableMatchesPrefixSorted(*(_QWORD *)(a1 + 24), __s);
    v12 = v11 > 0;
    if (!*(_DWORD *)(a1 + 56))
    {
      if (v11 < 1)
        return 2;
      goto LABEL_25;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 56))
      return 2;
    v12 = 0;
  }
  if (regexec((const regex_t *)(a1 + 64), __s, 0, 0, 0) && !v12)
    return 2;
LABEL_25:
  if (!StringTableSize(*(unsigned int **)(a1 + 96)) && !*(_DWORD *)(a1 + 128))
    goto LABEL_40;
  if (StringTableSize(*(unsigned int **)(a1 + 96)))
  {
    v19 = StringTableMatchesPrefixSorted(*(_QWORD *)(a1 + 96), __s);
    v20 = v19 > 0;
    if (!*(_DWORD *)(a1 + 128))
    {
      if (v19 <= 0)
        goto LABEL_40;
      return 2;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 128))
      goto LABEL_40;
    v20 = 0;
  }
  v23 = regexec((const regex_t *)(a1 + 136), __s, 0, 0, 0);
  result = 2;
  if (v23)
  {
    if (!v20)
    {
LABEL_40:
      result = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!(_DWORD)result)
        return result;
      v24 = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!v24)
        return 2;
      v41 = a3;
      __dst = a4;
      v25 = 0;
      v26 = 0;
      v27 = *(_QWORD *)(a1 + 8);
      v28 = *(_QWORD *)(v27 + 32);
      v29 = v24;
      v30 = (unsigned int *)(*(_QWORD *)(v27 + 8) + 8);
      v31 = -1;
      do
      {
        v32 = *v30;
        if ((!(_DWORD)v32
           || v8 >= v32
           && !memcmp((const void *)(v28 + *((_QWORD *)v30 - 1)), __s, *v30)
           && (v8 == v32 || __s[v32] == 47))
          && (v31 == -1 || v26 < v32))
        {
          v31 = v25;
          v26 = v32;
        }
        v30 += 4;
        ++v25;
      }
      while (v29 != v25);
      if (v31 == -1)
        return 2;
      if (!__dst)
        return 0;
      v35 = *(_QWORD *)(a1 + 16);
      v36 = *(_QWORD *)(v35 + 8);
      v37 = *(unsigned int *)(v36 + 16 * v31 + 8);
      if (v37 >= v41)
      {
        v17 = "insufficient out_capacity";
        v18 = 373;
      }
      else
      {
        v38 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 16 * v31 + 8);
        memcpy(__dst, (const void *)(*(_QWORD *)(v35 + 32) + *(_QWORD *)(v36 + 16 * v31)), v37);
        if (v8 <= v38)
        {
LABEL_63:
          __dst[v37] = 0;
          return 1;
        }
        v39 = v8 - v38 - ((_DWORD)v37 == 0);
        v40 = v39 + v37;
        if (v39 + v37 < v41)
        {
          memcpy(&__dst[v37], &__s[v8 - v39], v39);
          v37 = v40;
          goto LABEL_63;
        }
        v17 = "insufficient out_capacity";
        v18 = 379;
      }
LABEL_35:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterApply", v18, 130, 0, v17, v9, v10, v41);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

size_t OUTLINED_FUNCTION_0@<X0>(int a1@<W0>, const regex_t *a2@<X1>, uint64_t a3@<X8>, uint64_t a4, uint64_t a5, __int128 a6, __int128 a7, __int128 a8, __int128 a9, __int128 a10, __int128 a11, int a12)
{
  uint64_t v12;

  *(_QWORD *)(v12 - 24) = a3;
  a12 = 0;
  a10 = 0u;
  a11 = 0u;
  a8 = 0u;
  a9 = 0u;
  a6 = 0u;
  a7 = 0u;
  return regerror(a1, a2, (char *)&a6, 0x64uLL);
}

size_t OUTLINED_FUNCTION_2(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  return pc_log_error(a1, a2, a3, 130, 0, a6, a7, a8, a9);
}

size_t PCompressLZ4Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZ4Decode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result)
    return -1;
  return result;
}

BOOL aeaProfileIsValid(unsigned int a1)
{
  return a1 < 6;
}

uint64_t aeaContainerParamsInitWithProfile(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a2 < 6)
  {
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 48) = 32;
    *(_QWORD *)(a1 + 56) = 1;
    *(_OWORD *)(a1 + 12) = xmmword_20A40B840;
    if (a2)
    {
      v8 = 0;
      if (a2 == 5)
        *(_DWORD *)(a1 + 8) = 0;
    }
    else
    {
      v8 = 0;
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithProfile", 31, 79, 0, "Invalid profile: %u", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t aeaChecksumSize(int a1)
{
  if (a1 == 2)
    return 32;
  else
    return 8 * (a1 == 1);
}

uint64_t aeaContainerParamsInitWithMagic(int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  if (*a2 == 826361153)
  {
    v10 = a2[2];
    if (v10 < 0x4000001)
    {
      v11 = a2[1];
      if ((v11 & 0xFFFFFF) < 6)
      {
        v12 = 0;
        *a1 = v11 & 0xFFFFFF;
        a1[1] = v10;
        a1[2] = HIBYTE(v11);
        return v12;
      }
      v14 = a2[1];
      v8 = "Invalid profile: %u";
      v9 = 57;
    }
    else
    {
      v8 = "Invalid AEA container (auth_data_size)";
      v9 = 55;
    }
  }
  else
  {
    v8 = "Invalid magic bytes";
    v9 = 54;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithMagic", v9, 79, 0, v8, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerParamsInitWithRootHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;

  v8 = *(unsigned __int8 *)(a2 + 25);
  if (v8 > 2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 74, 79, 0, "Invalid checksum in root header: %u", a7, a8, *(_BYTE *)(a2 + 25));
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 12) = v8;
  if (v8 == 2)
    v9 = 32;
  else
    v9 = 8 * (v8 == 1);
  *(_DWORD *)(a1 + 48) = v9;
  v10 = *(char *)(a2 + 24);
  if (v10 <= 100)
  {
    switch(v10)
    {
      case '-':
        v11 = 0;
        break;
      case '4':
        v11 = 256;
        break;
      case 'b':
        v11 = 1794;
        break;
      default:
        goto LABEL_21;
    }
  }
  else if (v10 > 119)
  {
    if (v10 == 120)
    {
      v11 = 774;
    }
    else
    {
      if (v10 != 122)
        goto LABEL_21;
      v11 = 1285;
    }
  }
  else
  {
    if (v10 != 101)
    {
      if (v10 == 102)
      {
        v11 = 2304;
        goto LABEL_23;
      }
LABEL_21:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 81, 79, 0, "Invalid compression algorithm key in root header: %u", a7, a8, v10);
      return 0xFFFFFFFFLL;
    }
    v11 = 2049;
  }
LABEL_23:
  *(_DWORD *)(a1 + 24) = v11;
  v12 = *(_DWORD *)(a2 + 16);
  if ((v12 - 268435457) > 0xF0003FFE)
  {
    *(_DWORD *)(a1 + 16) = v12;
    v13 = *(_DWORD *)(a2 + 20);
    if ((v13 - 262145) > 0xFFFC001E)
    {
      v14 = 0;
      *(_DWORD *)(a1 + 20) = v13;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
      return v14;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 89, 79, 0, "Invalid segments per cluster count in root header: %u", a7, a8, *(_DWORD *)(a2 + 20));
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 85, 79, 0, "Invalid segment size in root header: %u", a7, a8, *(_DWORD *)(a2 + 16));
  }
  return 0xFFFFFFFFLL;
}

uint64_t aeaMagicInit(_DWORD *a1, _DWORD *a2)
{
  int v2;

  *a1 = 826361153;
  v2 = a2[1];
  a1[1] = *a2 & 0xFFFFFF | (a2[2] << 24);
  a1[2] = v2;
  return 0;
}

uint64_t aeaRootHeaderInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char v9;
  uint64_t v10;
  char vars0;

  v8 = *(_DWORD *)(a2 + 24);
  if (v8 <= 1284)
  {
    switch(v8)
    {
      case 0:
        v9 = 45;
        goto LABEL_18;
      case 256:
        v9 = 52;
        goto LABEL_18;
      case 774:
        v9 = 120;
        goto LABEL_18;
    }
  }
  else if (v8 > 2048)
  {
    if (v8 == 2049)
    {
      v9 = 101;
      goto LABEL_18;
    }
    if (v8 == 2304)
    {
      v9 = 102;
      goto LABEL_18;
    }
  }
  else
  {
    if (v8 == 1285)
    {
      v9 = 122;
      goto LABEL_18;
    }
    if (v8 == 1794)
    {
      v9 = 98;
LABEL_18:
      v10 = 0;
      *(_BYTE *)(a1 + 25) = *(_DWORD *)(a2 + 12);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_BYTE *)(a1 + 24) = v9;
      *(_OWORD *)a1 = *(_OWORD *)(a2 + 32);
      return v10;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaRootHeaderInit", 117, 79, 0, "Invalid compression algorithm in context", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerOffsetsInit(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = a2[5];
  *(_OWORD *)a1 = xmmword_20A40B850;
  v4 = a2[1] + 12;
  v5 = a3[12];
  v6 = v4 + a3[11];
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v6;
  v7 = v6 + v5;
  v8 = a3[3];
  v9 = v7 + a3[2];
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = v9;
  v10 = v9 + v8;
  v11 = v9 + v8 + 48;
  *(_QWORD *)(a1 + 48) = v10;
  *(_QWORD *)(a1 + 56) = v11;
  *(_QWORD *)(a1 + 64) = v11 + v8;
  *(_QWORD *)(a1 + 72) = 0;
  v12 = (a2[12] + 8) * v3;
  *(_QWORD *)(a1 + 80) = v12;
  *(_QWORD *)(a1 + 88) = v12 + v8;
  *(_QWORD *)(a1 + 96) = v12 + v8 + v8 * (unint64_t)v3;
  return 0;
}

uint64_t aeaChecksum(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CC_LONG v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  void *v16;
  rsize_t v17;
  rsize_t v18;
  uint64_t result;
  CC_SHA256_CTX v20;

  if (!a2)
  {
    result = 0;
    *(_DWORD *)a1 = 0;
    return result;
  }
  v9 = a4;
  v10 = a3;
  if (a2 == 2)
  {
    memset(&v20, 0, sizeof(v20));
    CC_SHA256_Init(&v20);
    CC_SHA256_Update(&v20, v10, v9);
    CC_SHA256_Final((unsigned __int8 *)(a1 + 4), &v20);
    *(_DWORD *)a1 = 32;
    v16 = (void *)(a1 + 36);
    v17 = 224;
    v18 = 224;
LABEL_15:
    memset_s(v16, v17, 0, v18);
    return 0;
  }
  if (a2 == 1)
  {
    v11 = (0xC6A4A7935BD1E995 * a4) ^ 0xE2236FDC26A5F6D2;
    v12 = (unint64_t)a3 + a4;
    if (a4 >= 16)
    {
      do
      {
        v11 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995
              * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * *v10) ^ ((0xC6A4A7935BD1E995 * *v10) >> 47))) ^ v11)) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v10[1]) ^ ((0xC6A4A7935BD1E995 * v10[1]) >> 47))));
        v13 = v10 + 2;
        v14 = v10 + 4;
        v10 += 2;
      }
      while ((unint64_t)v14 <= v12);
    }
    else
    {
      v13 = a3;
    }
    if ((unint64_t)(v13 + 1) <= v12)
    {
      do
      {
        v11 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * *v13) ^ ((0xC6A4A7935BD1E995 * *v13) >> 47))) ^ v11);
        v15 = (unint64_t)(v13 + 2) > v12;
        ++v13;
      }
      while (!v15);
    }
    if ((a4 & 7) != 0)
    {
      *(_QWORD *)v20.count = 0;
      __memcpy_chk();
      v11 *= 0xC6A4A7935BD1E995;
    }
    *(_QWORD *)(a1 + 4) = (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
    *(_DWORD *)a1 = 8;
    v16 = (void *)(a1 + 12);
    v17 = 248;
    v18 = 248;
    goto LABEL_15;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaChecksum", 228, 79, 0, "Invalid checksum mode", a7, a8, v20.count[0]);
  return 0xFFFFFFFFLL;
}

uint64_t aeaEffectiveCompressionAlgorithm(uint64_t result)
{
  if ((_DWORD)result == 256)
    return 257;
  else
    return result;
}

uint64_t aeaDeriveMainKeyExisting(unsigned int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, _DWORD *a9, _DWORD *a10, uint64_t (*a11)(uint64_t, _QWORD, char *, __int128 *, unsigned int *, _QWORD), uint64_t a12)
{
  int v16;
  uint64_t result;
  size_t v19;
  unint64_t v20;
  uint64_t (*v21)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *);
  uint64_t v22;
  _DWORD *v23;
  _OWORD *v24;
  const void *v26;
  uint64_t v27;
  size_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  size_t v32;
  unint64_t v33;
  int v34;
  uint64_t (*v35)(__int128 *, unsigned int *, _DWORD *);
  uint64_t v36;
  size_t v37;
  unint64_t v38;
  unint64_t v39;
  size_t v40;
  unint64_t v41;
  uint64_t (*v42)(_DWORD *, _QWORD, __int128 *, _BYTE *, _DWORD *);
  int v43;
  int v44;
  const char *v45;
  __int16 v46;
  size_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  size_t v55;
  unint64_t v56;
  uint64_t (*v57)(_DWORD *, _QWORD, __int128 *, _BYTE *, _OWORD *);
  int v58;
  size_t v59;
  unint64_t v60;
  char v61;
  _OWORD v62[16];
  int v63;
  _OWORD v64[16];
  int v65;
  _OWORD v66[16];
  int v67;
  size_t v68[2];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  int v84;
  size_t __n[2];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  int v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  int v118;
  _BYTE __s[24];
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  _BYTE v133[28];
  uint64_t v134;

  v134 = *MEMORY[0x24BDAC8D0];
  v63 = 0;
  memset(v62, 0, sizeof(v62));
  v16 = *a2 & 0xFFFFFF | (a2[2] << 24);
  switch(*a2)
  {
    case 0:
      memset(v133, 0, sizeof(v133));
      v132 = 0uLL;
      v131 = 0uLL;
      v130 = 0uLL;
      v129 = 0uLL;
      v128 = 0uLL;
      v127 = 0uLL;
      v126 = 0uLL;
      v125 = 0uLL;
      v124 = 0uLL;
      v123 = 0uLL;
      v122 = 0uLL;
      v121 = 0uLL;
      v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a6 != *a1)
        goto LABEL_60;
      if (*a10 != a1[2])
        goto LABEL_67;
      if (a1[5])
        goto LABEL_59;
      if (*a7 != a1[8])
        goto LABEL_112;
      *(_DWORD *)&__s[7] = 1263354207;
      *(_QWORD *)__s = 0x5F41454100000007;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)__s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      result = memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      v59 = *a7;
      v60 = *(unsigned int *)__s + v59;
      if (v60 >= 0x101)
        goto LABEL_135;
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v59);
      *(_DWORD *)__s = v60;
      memset_s(&__s[v60 + 4], 256 - v60, 0, 256 - v60);
      v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((_QWORD *)a1 + 9);
      if (!v21 || !*a6)
        goto LABEL_113;
      v22 = *a1;
      v23 = a3;
      v24 = a6;
      goto LABEL_111;
    case 1:
    case 2:
      memset(v133, 0, sizeof(v133));
      v132 = 0uLL;
      v131 = 0uLL;
      v130 = 0uLL;
      v129 = 0uLL;
      v128 = 0uLL;
      v127 = 0uLL;
      v126 = 0uLL;
      v125 = 0uLL;
      v124 = 0uLL;
      v123 = 0uLL;
      v122 = 0uLL;
      v121 = 0uLL;
      v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a4 != *a1)
        goto LABEL_60;
      if (*a10 != a1[2])
        goto LABEL_67;
      if (a1[5])
        goto LABEL_59;
      if (*a7 != a1[8])
        goto LABEL_112;
      *(_DWORD *)&__s[7] = 1263354207;
      *(_QWORD *)__s = 0x5F41454100000007;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)__s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      result = memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      v19 = *a7;
      v20 = *(unsigned int *)__s + v19;
      if (v20 >= 0x101)
        goto LABEL_135;
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v19);
      *(_DWORD *)__s = v20;
      memset_s(&__s[v20 + 4], 256 - v20, 0, 256 - v20);
      v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((_QWORD *)a1 + 9);
      if (v21 && *a4)
      {
        v22 = *a1;
        v23 = a3;
        v24 = a4;
        goto LABEL_111;
      }
LABEL_113:
      v34 = -1;
      goto LABEL_114;
    case 3:
    case 4:
      if (!a11 || !*a8)
      {
        v118 = 0;
        v117 = 0uLL;
        v116 = 0uLL;
        v115 = 0uLL;
        v114 = 0uLL;
        v113 = 0uLL;
        v112 = 0uLL;
        v111 = 0uLL;
        v110 = 0uLL;
        v109 = 0uLL;
        v108 = 0uLL;
        v107 = 0uLL;
        v106 = 0uLL;
        v105 = 0uLL;
        v104 = 0uLL;
        v103 = 0uLL;
        v102 = 0uLL;
        v101 = 0;
        v100 = 0uLL;
        v99 = 0uLL;
        v98 = 0uLL;
        v97 = 0uLL;
        v96 = 0uLL;
        v95 = 0uLL;
        v94 = 0uLL;
        v93 = 0uLL;
        v92 = 0uLL;
        v91 = 0uLL;
        v90 = 0uLL;
        v89 = 0uLL;
        v88 = 0uLL;
        v87 = 0uLL;
        v86 = 0uLL;
        *(_OWORD *)__n = 0uLL;
        if (*((_QWORD *)a1 + 9)
          && (v35 = (uint64_t (*)(__int128 *, unsigned int *, _DWORD *))*((_QWORD *)a1 + 14)) != 0
          && *((_QWORD *)a1 + 20))
        {
          if (*a6 == a1[5])
          {
            if (*a9 == a1[4])
            {
              if ((v35(&v102, a6, a9) & 0x80000000) != 0)
              {
                v44 = -4;
              }
              else if ((_DWORD)v102 == a1[6])
              {
                if (((*((uint64_t (**)(size_t *, _DWORD *))a1 + 20))(__n, a9) & 0x80000000) != 0)
                {
                  v44 = -6;
                }
                else
                {
                  memset(v133, 0, sizeof(v133));
                  v132 = 0u;
                  v131 = 0u;
                  v130 = 0u;
                  v129 = 0u;
                  v128 = 0u;
                  v127 = 0u;
                  v126 = 0u;
                  v125 = 0u;
                  v124 = 0u;
                  v123 = 0u;
                  v122 = 0u;
                  v121 = 0u;
                  v120 = 0u;
                  *(_OWORD *)&__s[8] = 0u;
                  if ((_DWORD)v102 == *a1)
                  {
                    if (*a10 == a1[2])
                    {
                      if (*a6 == a1[5])
                      {
                        if (LODWORD(__n[0]) == *a6)
                        {
                          if (*a7 == a1[8])
                          {
                            *(_DWORD *)&__s[7] = 1263354207;
                            *(_QWORD *)__s = 0x5F41454100000007;
                            result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                            v36 = *(unsigned int *)__s;
                            if (*(_DWORD *)__s >= 0xFDu)
                              goto LABEL_135;
                            *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                            *(_DWORD *)__s = v36 + 4;
                            result = memset_s(&__s[v36 + 8], 252 - v36, 0, 252 - v36);
                            v37 = *a6;
                            v38 = *(unsigned int *)__s + v37;
                            if (v38 >= 0x101)
                              goto LABEL_135;
                            memcpy(&__s[*(unsigned int *)__s + 4], a6 + 1, v37);
                            *(_DWORD *)__s = v38;
                            result = memset_s(&__s[v38 + 4], 256 - v38, 0, 256 - v38);
                            v39 = *(unsigned int *)__s + (unint64_t)LODWORD(__n[0]);
                            if (v39 >= 0x101)
                              goto LABEL_135;
                            memcpy(&__s[*(unsigned int *)__s + 4], (char *)__n + 4, LODWORD(__n[0]));
                            *(_DWORD *)__s = v39;
                            result = memset_s(&__s[v39 + 4], 256 - v39, 0, 256 - v39);
                            v40 = *a7;
                            v41 = *(unsigned int *)__s + v40;
                            if (v41 >= 0x101)
                              goto LABEL_135;
                            memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v40);
                            *(_DWORD *)__s = v41;
                            memset_s(&__s[v41 + 4], 256 - v41, 0, 256 - v41);
                            v42 = (uint64_t (*)(_DWORD *, _QWORD, __int128 *, _BYTE *, _DWORD *))*((_QWORD *)a1 + 9);
                            v43 = -1;
                            if (v42 && (_DWORD)v102)
                              v43 = v42(a3, *a1, &v102, __s, a10);
                            if (*a3 == *a1)
                              v44 = v43;
                            else
                              v44 = -1006;
                            memset_s(__s, 0x104uLL, 0, 0x104uLL);
                            if (v44)
                              memset_s(a3, 0x104uLL, 0, 0x104uLL);
                          }
                          else
                          {
                            v44 = -1005;
                          }
                        }
                        else
                        {
                          v44 = -1004;
                        }
                      }
                      else
                      {
                        v44 = -1003;
                      }
                    }
                    else
                    {
                      v44 = -1002;
                    }
                  }
                  else
                  {
                    v44 = -1001;
                  }
                }
              }
              else
              {
                v44 = -5;
              }
            }
            else
            {
              v44 = -3;
            }
          }
          else
          {
            v44 = -2;
          }
        }
        else
        {
          v44 = -1;
        }
        memset_s(&v102, 0x104uLL, 0, 0x104uLL);
        v48 = __n;
        goto LABEL_70;
      }
      *(_QWORD *)&v102 = 0;
      v26 = a6 + 1;
      result = a11(a12, a1[6], (char *)v62 + 4, &v102, a6 + 1, *a6);
      if ((result & 0x80000000) != 0)
      {
        v45 = "DH callback";
        v46 = 321;
        goto LABEL_74;
      }
      if ((_QWORD)v102 != a1[6])
      {
        v45 = "DH callback returning invalid shared secret size";
        v46 = 322;
        goto LABEL_74;
      }
      if ((unint64_t)v102 >= 0x101)
        goto LABEL_135;
      LODWORD(v62[0]) = v102;
      memset_s((char *)v62 + v102 + 4, 256 - v102, 0, 256 - v102);
      memset(v133, 0, sizeof(v133));
      v132 = 0u;
      v131 = 0u;
      v130 = 0u;
      v129 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      v125 = 0u;
      v124 = 0u;
      v123 = 0u;
      v122 = 0u;
      v121 = 0u;
      v120 = 0u;
      *(_OWORD *)&__s[8] = 0u;
      if (LODWORD(v62[0]) != *a1)
      {
LABEL_60:
        v44 = -1001;
        goto LABEL_71;
      }
      if (*a10 != a1[2])
      {
LABEL_67:
        v44 = -1002;
LABEL_71:
        if ((v44 & 0x80000000) == 0)
        {
          v49 = 0;
LABEL_77:
          memset_s(v62, 0x104uLL, 0, 0x104uLL);
          return v49;
        }
        v61 = v44;
        v45 = "Main key derivation failed (%d)";
        v46 = 353;
LABEL_74:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyExisting", v46, 79, 0, v45, (uint64_t)a7, (uint64_t)a8, v61);
        if (a3)
          memset_s(a3, 0x104uLL, 0, 0x104uLL);
        v49 = 0xFFFFFFFFLL;
        goto LABEL_77;
      }
      if (*a6 != a1[5])
      {
LABEL_59:
        v44 = -1003;
        goto LABEL_71;
      }
      if (*a8 != *a6)
      {
        v44 = -1004;
        goto LABEL_71;
      }
      if (*a7 != a1[8])
      {
LABEL_112:
        v44 = -1005;
        goto LABEL_71;
      }
      *(_DWORD *)&__s[7] = 1263354207;
      *(_QWORD *)__s = 0x5F41454100000007;
      result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      v27 = *(unsigned int *)__s;
      if (*(_DWORD *)__s < 0xFDu)
      {
        *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
        *(_DWORD *)__s = v27 + 4;
        result = memset_s(&__s[v27 + 8], 252 - v27, 0, 252 - v27);
        v28 = *a6;
        v29 = *(unsigned int *)__s + v28;
        if (v29 < 0x101)
        {
          memcpy(&__s[*(unsigned int *)__s + 4], v26, v28);
          *(_DWORD *)__s = v29;
          result = memset_s(&__s[v29 + 4], 256 - v29, 0, 256 - v29);
          v30 = *a8;
          v31 = *(unsigned int *)__s + v30;
          if (v31 < 0x101)
          {
            memcpy(&__s[*(unsigned int *)__s + 4], a8 + 1, v30);
            *(_DWORD *)__s = v31;
            result = memset_s(&__s[v31 + 4], 256 - v31, 0, 256 - v31);
            v32 = *a7;
            v33 = *(unsigned int *)__s + v32;
            if (v33 < 0x101)
            {
              memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v32);
              *(_DWORD *)__s = v33;
              memset_s(&__s[v33 + 4], 256 - v33, 0, 256 - v33);
              v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((_QWORD *)a1 + 9);
              v34 = -1;
              if (v21 && LODWORD(v62[0]))
              {
                v22 = *a1;
                v24 = v62;
                v23 = a3;
LABEL_111:
                v34 = v21(v23, v22, v24, __s, a10);
              }
LABEL_114:
              if (*a3 == *a1)
                v44 = v34;
              else
                v44 = -1006;
              memset_s(__s, 0x104uLL, 0, 0x104uLL);
              if (v44)
              {
                v48 = (size_t *)a3;
LABEL_70:
                memset_s(v48, 0x104uLL, 0, 0x104uLL);
              }
              goto LABEL_71;
            }
          }
        }
      }
LABEL_135:
      __break(1u);
      return result;
    case 5:
      v118 = 0;
      v117 = 0uLL;
      v116 = 0uLL;
      v115 = 0uLL;
      v114 = 0uLL;
      v113 = 0uLL;
      v112 = 0uLL;
      v111 = 0uLL;
      v110 = 0uLL;
      v109 = 0uLL;
      v108 = 0uLL;
      v107 = 0uLL;
      v106 = 0uLL;
      v105 = 0uLL;
      v104 = 0uLL;
      v103 = 0uLL;
      v102 = 0uLL;
      v101 = 0;
      v100 = 0uLL;
      v99 = 0uLL;
      v98 = 0uLL;
      v97 = 0uLL;
      v96 = 0uLL;
      v95 = 0uLL;
      v94 = 0uLL;
      v93 = 0uLL;
      v92 = 0uLL;
      v91 = 0uLL;
      v90 = 0uLL;
      v89 = 0uLL;
      v88 = 0uLL;
      v87 = 0uLL;
      v86 = 0uLL;
      *(_OWORD *)__n = 0uLL;
      v84 = 0;
      v83 = 0uLL;
      v82 = 0uLL;
      v81 = 0uLL;
      v79 = 0uLL;
      v80 = 0uLL;
      v77 = 0uLL;
      v78 = 0uLL;
      v75 = 0uLL;
      v76 = 0uLL;
      v73 = 0uLL;
      v74 = 0uLL;
      v71 = 0uLL;
      v72 = 0uLL;
      v69 = 0uLL;
      v70 = 0uLL;
      *(_OWORD *)v68 = 0uLL;
      v67 = 0;
      memset(v66, 0, sizeof(v66));
      v65 = 0;
      memset(v64, 0, sizeof(v64));
      if (*((_QWORD *)a1 + 10) && *((_QWORD *)a1 + 9))
      {
        if (*a5 >= 0x14u)
        {
          if (*a10 == a1[2])
          {
            WORD2(__n[1]) = 21584;
            *(size_t *)((char *)__n + 4) = *(_QWORD *)"AEA_SCRYPT";
            LODWORD(__n[0]) = 10;
            memset_s((void *)((unint64_t)__n | 0xE), 0xF6uLL, 0, 0xF6uLL);
            result = (*((uint64_t (**)(__int128 *, _QWORD, _DWORD *, size_t *, size_t *))a1 + 9))(&v102, 2 * a1[2], a10, __n, v68);
            if ((result & 0x80000000) != 0)
            {
              v44 = -4;
            }
            else
            {
              v50 = a1[2];
              if (v50 >= 0x101)
                goto LABEL_135;
              __memcpy_chk();
              LODWORD(v66[0]) = v50;
              result = memset_s((char *)v66 + v50 + 4, 256 - v50, 0, 256 - v50);
              v51 = a1[2];
              if (v51 >= 0x101)
                goto LABEL_135;
              __memcpy_chk();
              LODWORD(v64[0]) = v51;
              memset_s((char *)v64 + v51 + 4, 256 - v51, 0, 256 - v51);
              memset_s(&v102, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(__int128 *, _DWORD *, _QWORD, _QWORD, _OWORD *))a1 + 10))(&v102, a5 + 1, *a5, a1[14], v66) & 0x80000000) != 0)
              {
                v44 = -5;
              }
              else
              {
                memset(v133, 0, sizeof(v133));
                v132 = 0u;
                v131 = 0u;
                v130 = 0u;
                v129 = 0u;
                v128 = 0u;
                v127 = 0u;
                v126 = 0u;
                v125 = 0u;
                v124 = 0u;
                v123 = 0u;
                v122 = 0u;
                v121 = 0u;
                v120 = 0u;
                *(_OWORD *)&__s[8] = 0u;
                if ((_DWORD)v102 == *a1)
                {
                  if (LODWORD(v64[0]) == a1[2])
                  {
                    if (LODWORD(v68[0]) == a1[5])
                    {
                      if (*a7 == a1[8])
                      {
                        *(_DWORD *)&__s[7] = 1263354207;
                        *(_QWORD *)__s = 0x5F41454100000007;
                        result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                        v52 = *(unsigned int *)__s;
                        if (*(_DWORD *)__s >= 0xFDu)
                          goto LABEL_135;
                        *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                        *(_DWORD *)__s = v52 + 4;
                        result = memset_s(&__s[v52 + 8], 252 - v52, 0, 252 - v52);
                        v53 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v53 >= 0x101)
                          goto LABEL_135;
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)__s = v53;
                        result = memset_s(&__s[v53 + 4], 256 - v53, 0, 256 - v53);
                        v54 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v54 >= 0x101)
                          goto LABEL_135;
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)__s = v54;
                        result = memset_s(&__s[v54 + 4], 256 - v54, 0, 256 - v54);
                        v55 = *a7;
                        v56 = *(unsigned int *)__s + v55;
                        if (v56 >= 0x101)
                          goto LABEL_135;
                        memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v55);
                        *(_DWORD *)__s = v56;
                        memset_s(&__s[v56 + 4], 256 - v56, 0, 256 - v56);
                        v57 = (uint64_t (*)(_DWORD *, _QWORD, __int128 *, _BYTE *, _OWORD *))*((_QWORD *)a1 + 9);
                        v58 = -1;
                        if (v57 && (_DWORD)v102)
                          v58 = v57(a3, *a1, &v102, __s, v64);
                        if (*a3 == *a1)
                          v44 = v58;
                        else
                          v44 = -1006;
                        memset_s(__s, 0x104uLL, 0, 0x104uLL);
                        if (v44)
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                      }
                      else
                      {
                        v44 = -1005;
                      }
                    }
                    else
                    {
                      v44 = -1003;
                    }
                  }
                  else
                  {
                    v44 = -1002;
                  }
                }
                else
                {
                  v44 = -1001;
                }
              }
            }
          }
          else
          {
            v44 = -3;
          }
        }
        else
        {
          v44 = -2;
        }
      }
      else
      {
        v44 = -1;
      }
      memset_s(&v102, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v66, 0x104uLL, 0, 0x104uLL);
      v48 = (size_t *)v64;
      goto LABEL_70;
    default:
      v45 = "Unsupported profile";
      v46 = 351;
      goto LABEL_74;
  }
}

uint64_t aeaDeriveMainKeyNew(unsigned int *a1, int *a2, __int128 *a3, int *a4, char *__s, int *a6, _DWORD *a7, unsigned int *a8, unsigned int *a9)
{
  int v16;
  int v17;
  uint64_t v18;
  uint64_t (*v19)(char *, uint64_t);
  int v20;
  int v21;
  const char *v22;
  __int16 v23;
  uint64_t result;
  uint64_t (*v25)(__int128 *, int *, unsigned int *);
  int v26;
  uint64_t v27;
  size_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  size_t v32;
  unint64_t v33;
  uint64_t (*v34)(__int128 *, _QWORD, __int128 *, _BYTE *, char *);
  int v35;
  __int128 *v36;
  uint64_t v37;
  uint64_t (*v38)(int *, uint64_t);
  size_t v39;
  unint64_t v40;
  uint64_t (*v41)(__int128 *, uint64_t, int *, _BYTE *, char *);
  __int128 *v42;
  uint64_t v43;
  __int128 *v44;
  int *v45;
  __int128 *p_sa;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  size_t v52;
  unint64_t v53;
  uint64_t (*v54)(__int128 *, _QWORD, __int128 *, _BYTE *, _OWORD *);
  int v55;
  __int128 *v56;
  size_t v57;
  unint64_t v58;
  int v59;
  char v60;
  _OWORD v62[16];
  int v63;
  _OWORD v64[16];
  int v65;
  size_t __n[2];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  int v82;
  _OWORD v83[16];
  int v84;
  __int128 __sa;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  int v101;
  _BYTE v102[24];
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  _BYTE v116[28];
  uint64_t v117;

  v117 = *MEMORY[0x24BDAC8D0];
  v16 = *a2;
  v17 = a2[2];
  v18 = a1[2];
  if (__s)
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v18 > 0x100
    || (v19 = (uint64_t (*)(char *, uint64_t))*((_QWORD *)a1 + 8)) == 0
    || (v19(__s + 4, v18) & 0x80000000) != 0)
  {
    v22 = "generating random salt";
    v23 = 380;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyNew", v23, 79, 0, v22, (uint64_t)a7, (uint64_t)a8, v60);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)__s = v18;
  v20 = v16 & 0xFFFFFF | (v17 << 24);
  switch(*a2)
  {
    case 0:
      v37 = a1[12];
      if (a4)
        memset_s(a4, 0x104uLL, 0, 0x104uLL);
      if (v37 > 0x100
        || (v38 = (uint64_t (*)(int *, uint64_t))*((_QWORD *)a1 + 8)) == 0
        || (v38(a4 + 1, v37) & 0x80000000) != 0)
      {
        v22 = "generating random encryption key";
        v23 = 390;
        goto LABEL_12;
      }
      *a4 = v37;
      memset(v116, 0, sizeof(v116));
      v115 = 0u;
      v114 = 0u;
      v113 = 0u;
      v112 = 0u;
      v111 = 0u;
      v110 = 0u;
      v109 = 0u;
      v108 = 0u;
      v107 = 0u;
      v106 = 0u;
      v105 = 0u;
      v104 = 0u;
      v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if ((_DWORD)v37 != *a1)
      {
LABEL_50:
        v21 = -1001;
        goto LABEL_115;
      }
      if (*(_DWORD *)__s != a1[2])
      {
LABEL_58:
        v21 = -1002;
        goto LABEL_115;
      }
      if (a1[5])
      {
LABEL_10:
        v21 = -1003;
        goto LABEL_115;
      }
      if (*a8 != a1[8])
      {
LABEL_87:
        v21 = -1005;
        goto LABEL_115;
      }
      *(_DWORD *)&v102[7] = 1263354207;
      *(_QWORD *)v102 = 0x5F41454100000007;
      memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
      *(_DWORD *)v102 = 11;
      memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      result = memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      v39 = *a8;
      v40 = *(unsigned int *)v102 + v39;
      if (v40 >= 0x101)
        goto LABEL_124;
      memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v39);
      *(_DWORD *)v102 = v40;
      memset_s(&v102[v40 + 4], 256 - v40, 0, 256 - v40);
      v41 = (uint64_t (*)(__int128 *, uint64_t, int *, _BYTE *, char *))*((_QWORD *)a1 + 9);
      if (v41)
      {
        v42 = a3;
        if (*a4)
        {
          v43 = *a1;
          v44 = a3;
          v45 = a4;
LABEL_84:
          v59 = v41(v44, v43, v45, v102, __s);
        }
        else
        {
LABEL_93:
          v59 = -1;
        }
      }
      else
      {
LABEL_90:
        v59 = -1;
        v42 = a3;
      }
      if (*(_DWORD *)v42 == *a1)
        v21 = v59;
      else
        v21 = -1006;
      memset_s(v102, 0x104uLL, 0, 0x104uLL);
      if (!v21)
        goto LABEL_115;
      p_sa = v42;
      goto LABEL_114;
    case 1:
    case 2:
      memset(v116, 0, sizeof(v116));
      v115 = 0u;
      v114 = 0u;
      v113 = 0u;
      v112 = 0u;
      v111 = 0u;
      v110 = 0u;
      v109 = 0u;
      v108 = 0u;
      v107 = 0u;
      v106 = 0u;
      v105 = 0u;
      v104 = 0u;
      v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if (*a6 != *a1)
        goto LABEL_50;
      if ((_DWORD)v18 != a1[2])
        goto LABEL_58;
      if (a1[5])
        goto LABEL_10;
      if (*a8 != a1[8])
        goto LABEL_87;
      *(_DWORD *)&v102[7] = 1263354207;
      *(_QWORD *)v102 = 0x5F41454100000007;
      memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
      *(_DWORD *)v102 = 11;
      memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      result = memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      v57 = *a8;
      v58 = *(unsigned int *)v102 + v57;
      if (v58 >= 0x101)
        goto LABEL_124;
      memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v57);
      *(_DWORD *)v102 = v58;
      memset_s(&v102[v58 + 4], 256 - v58, 0, 256 - v58);
      v41 = (uint64_t (*)(__int128 *, uint64_t, int *, _BYTE *, char *))*((_QWORD *)a1 + 9);
      if (!v41)
        goto LABEL_90;
      v42 = a3;
      if (!*a6)
        goto LABEL_93;
      v43 = *a1;
      v44 = a3;
      v45 = a6;
      goto LABEL_84;
    case 3:
    case 4:
      v101 = 0;
      v100 = 0u;
      v99 = 0u;
      v98 = 0u;
      v97 = 0u;
      v96 = 0u;
      v95 = 0u;
      v94 = 0u;
      v93 = 0u;
      v92 = 0u;
      v91 = 0u;
      v90 = 0u;
      v89 = 0u;
      v88 = 0u;
      v87 = 0u;
      v86 = 0u;
      __sa = 0u;
      if (!*((_QWORD *)a1 + 9)
        || (v25 = (uint64_t (*)(__int128 *, int *, unsigned int *))*((_QWORD *)a1 + 13)) == 0)
      {
        v21 = -1;
LABEL_113:
        p_sa = &__sa;
        goto LABEL_114;
      }
      if (*a9 != a1[5])
      {
        v21 = -2;
        goto LABEL_113;
      }
      if ((v25(&__sa, a4, a9) & 0x80000000) != 0)
      {
        v21 = -3;
        goto LABEL_113;
      }
      v26 = *a4;
      if (*a4 != a1[5])
      {
        v21 = -4;
        goto LABEL_113;
      }
      if ((_DWORD)__sa != a1[6])
      {
        v21 = -5;
        goto LABEL_113;
      }
      memset(v116, 0, sizeof(v116));
      v115 = 0u;
      v114 = 0u;
      v113 = 0u;
      v112 = 0u;
      v111 = 0u;
      v110 = 0u;
      v109 = 0u;
      v108 = 0u;
      v107 = 0u;
      v106 = 0u;
      v105 = 0u;
      v104 = 0u;
      v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if ((_DWORD)__sa != *a1)
      {
        v21 = -1001;
        goto LABEL_113;
      }
      if (*(_DWORD *)__s != a1[2])
      {
        v21 = -1002;
        goto LABEL_113;
      }
      if (*a9 != v26)
      {
        v21 = -1004;
        goto LABEL_113;
      }
      if (*a8 != a1[8])
      {
        v21 = -1005;
        goto LABEL_113;
      }
      *(_DWORD *)&v102[7] = 1263354207;
      *(_QWORD *)v102 = 0x5F41454100000007;
      result = memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      v27 = *(unsigned int *)v102;
      if (*(_DWORD *)v102 < 0xFDu)
      {
        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
        *(_DWORD *)v102 = v27 + 4;
        result = memset_s(&v102[v27 + 8], 252 - v27, 0, 252 - v27);
        v28 = *a4;
        v29 = *(unsigned int *)v102 + v28;
        if (v29 < 0x101)
        {
          memcpy(&v102[*(unsigned int *)v102 + 4], a4 + 1, v28);
          *(_DWORD *)v102 = v29;
          result = memset_s(&v102[v29 + 4], 256 - v29, 0, 256 - v29);
          v30 = *a9;
          v31 = *(unsigned int *)v102 + v30;
          if (v31 < 0x101)
          {
            memcpy(&v102[*(unsigned int *)v102 + 4], a9 + 1, v30);
            *(_DWORD *)v102 = v31;
            result = memset_s(&v102[v31 + 4], 256 - v31, 0, 256 - v31);
            v32 = *a8;
            v33 = *(unsigned int *)v102 + v32;
            if (v33 < 0x101)
            {
              memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v32);
              *(_DWORD *)v102 = v33;
              memset_s(&v102[v33 + 4], 256 - v33, 0, 256 - v33);
              v34 = (uint64_t (*)(__int128 *, _QWORD, __int128 *, _BYTE *, char *))*((_QWORD *)a1 + 9);
              v35 = -1;
              if (v34)
              {
                v36 = a3;
                if ((_DWORD)__sa)
                  v35 = v34(a3, *a1, &__sa, v102, __s);
              }
              else
              {
                v36 = a3;
              }
              if (*(_DWORD *)v36 == *a1)
                v21 = v35;
              else
                v21 = -1006;
              memset_s(v102, 0x104uLL, 0, 0x104uLL);
              if (v21)
                memset_s(v36, 0x104uLL, 0, 0x104uLL);
              goto LABEL_113;
            }
          }
        }
      }
LABEL_124:
      __break(1u);
      return result;
    case 5:
      v101 = 0;
      v100 = 0u;
      v99 = 0u;
      v98 = 0u;
      v97 = 0u;
      v96 = 0u;
      v95 = 0u;
      v94 = 0u;
      v93 = 0u;
      v92 = 0u;
      v91 = 0u;
      v90 = 0u;
      v89 = 0u;
      v88 = 0u;
      v87 = 0u;
      v86 = 0u;
      __sa = 0u;
      v84 = 0;
      memset(v83, 0, sizeof(v83));
      v82 = 0;
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      *(_OWORD *)__n = 0u;
      v67 = 0u;
      v65 = 0;
      memset(v64, 0, sizeof(v64));
      v63 = 0;
      memset(v62, 0, sizeof(v62));
      if (*((_QWORD *)a1 + 10) && *((_QWORD *)a1 + 9))
      {
        if (*a7 >= 0x14u)
        {
          if ((_DWORD)v18 == a1[2])
          {
            WORD6(v83[0]) = 21584;
            *(_QWORD *)((char *)v83 + 4) = *(_QWORD *)"AEA_SCRYPT";
            LODWORD(v83[0]) = 10;
            memset_s((void *)((unint64_t)v83 | 0xE), 0xF6uLL, 0, 0xF6uLL);
            result = (*((uint64_t (**)(__int128 *, _QWORD, char *, _OWORD *, size_t *))a1 + 9))(&__sa, 2 * a1[2], __s, v83, __n);
            if ((result & 0x80000000) != 0)
            {
              v21 = -4;
            }
            else
            {
              v47 = a1[2];
              if (v47 >= 0x101)
                goto LABEL_124;
              __memcpy_chk();
              LODWORD(v64[0]) = v47;
              result = memset_s((char *)v64 + v47 + 4, 256 - v47, 0, 256 - v47);
              v48 = a1[2];
              if (v48 >= 0x101)
                goto LABEL_124;
              __memcpy_chk();
              LODWORD(v62[0]) = v48;
              memset_s((char *)v62 + v48 + 4, 256 - v48, 0, 256 - v48);
              memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(__int128 *, _DWORD *, _QWORD, _QWORD, _OWORD *))a1 + 10))(&__sa, a7 + 1, *a7, a1[14], v64) & 0x80000000) != 0)
              {
                v21 = -5;
              }
              else
              {
                memset(v116, 0, sizeof(v116));
                v115 = 0u;
                v114 = 0u;
                v113 = 0u;
                v112 = 0u;
                v111 = 0u;
                v110 = 0u;
                v109 = 0u;
                v108 = 0u;
                v107 = 0u;
                v106 = 0u;
                v105 = 0u;
                v104 = 0u;
                v103 = 0u;
                *(_OWORD *)&v102[8] = 0u;
                if ((_DWORD)__sa == *a1)
                {
                  if (LODWORD(v62[0]) == a1[2])
                  {
                    if (LODWORD(__n[0]) == a1[5])
                    {
                      if (*a8 == a1[8])
                      {
                        *(_DWORD *)&v102[7] = 1263354207;
                        *(_QWORD *)v102 = 0x5F41454100000007;
                        result = memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
                        v49 = *(unsigned int *)v102;
                        if (*(_DWORD *)v102 >= 0xFDu)
                          goto LABEL_124;
                        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
                        *(_DWORD *)v102 = v49 + 4;
                        result = memset_s(&v102[v49 + 8], 252 - v49, 0, 252 - v49);
                        v50 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v50 >= 0x101)
                          goto LABEL_124;
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)v102 = v50;
                        result = memset_s(&v102[v50 + 4], 256 - v50, 0, 256 - v50);
                        v51 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v51 >= 0x101)
                          goto LABEL_124;
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)v102 = v51;
                        result = memset_s(&v102[v51 + 4], 256 - v51, 0, 256 - v51);
                        v52 = *a8;
                        v53 = *(unsigned int *)v102 + v52;
                        if (v53 >= 0x101)
                          goto LABEL_124;
                        memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v52);
                        *(_DWORD *)v102 = v53;
                        memset_s(&v102[v53 + 4], 256 - v53, 0, 256 - v53);
                        v54 = (uint64_t (*)(__int128 *, _QWORD, __int128 *, _BYTE *, _OWORD *))*((_QWORD *)a1 + 9);
                        v55 = -1;
                        if (v54)
                        {
                          v56 = a3;
                          if ((_DWORD)__sa)
                            v55 = v54(a3, *a1, &__sa, v102, v62);
                        }
                        else
                        {
                          v56 = a3;
                        }
                        if (*(_DWORD *)v56 == *a1)
                          v21 = v55;
                        else
                          v21 = -1006;
                        memset_s(v102, 0x104uLL, 0, 0x104uLL);
                        if (v21)
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                      }
                      else
                      {
                        v21 = -1005;
                      }
                    }
                    else
                    {
                      v21 = -1003;
                    }
                  }
                  else
                  {
                    v21 = -1002;
                  }
                }
                else
                {
                  v21 = -1001;
                }
              }
            }
          }
          else
          {
            v21 = -3;
          }
        }
        else
        {
          v21 = -2;
        }
      }
      else
      {
        v21 = -1;
      }
      memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
      memset_s(v83, 0x104uLL, 0, 0x104uLL);
      memset_s(v64, 0x104uLL, 0, 0x104uLL);
      p_sa = v62;
LABEL_114:
      memset_s(p_sa, 0x104uLL, 0, 0x104uLL);
LABEL_115:
      if ((v21 & 0x80000000) == 0)
        return 0;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyNew", 437, 79, 0, "Main key derivation failed (%d)", (uint64_t)a7, (uint64_t)a8, v21);
      return 0xFFFFFFFFLL;
    default:
      v22 = "Unsupported profile";
      v23 = 435;
      goto LABEL_12;
  }
}

int AEAStreamSign(AAByteStream encrypted_stream, AEAContext context)
{
  int v4;
  char *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t (*v12)(_QWORD, uint64_t, char *, _OWORD *, char *);
  int result;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _OWORD v42[16];
  int v43;
  size_t v44[2];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  int v60;
  _OWORD __s[16];
  int v62;
  size_t __n[2];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  int v79;
  _OWORD v80[16];
  int v81;
  _OWORD v82[16];
  int v83;
  _OWORD v84[16];
  int v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v62 = 0;
  memset(__s, 0, sizeof(__s));
  v60 = 0;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  *(_OWORD *)v44 = 0u;
  v45 = 0u;
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  if (*(_DWORD *)context <= 5u && ((1 << *(_DWORD *)context) & 0x2A) != 0)
  {
    v4 = 0;
    v40 = 0uLL;
    v41 = 0uLL;
    v38 = 0uLL;
    v39 = 0uLL;
    v36 = 0uLL;
    v37 = 0uLL;
    v34 = 0uLL;
    v35 = 0uLL;
    v32 = 0uLL;
    v33 = 0uLL;
    v30 = 0uLL;
    v31 = 0uLL;
    v29 = 0uLL;
    v28 = 0;
    v26 = 0uLL;
    v27 = 0uLL;
    v24 = 0uLL;
    v25 = 0uLL;
    v22 = 0uLL;
    v23 = 0uLL;
LABEL_15:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v44, 0x104uLL, 0, 0x104uLL);
    memset_s(v42, 0x104uLL, 0, 0x104uLL);
    memset_s(&v22, 0x68uLL, 0, 0x68uLL);
    memset_s(&v29, 0xD0uLL, 0, 0xD0uLL);
    return v4;
  }
  v5 = (char *)*((_QWORD *)context + 340);
  v6 = *((_QWORD *)context + 341);
  v40 = 0uLL;
  v41 = 0uLL;
  v38 = 0uLL;
  v39 = 0uLL;
  v36 = 0uLL;
  v37 = 0uLL;
  v34 = 0uLL;
  v35 = 0uLL;
  v32 = 0uLL;
  v33 = 0uLL;
  v30 = 0uLL;
  v31 = 0uLL;
  v29 = 0uLL;
  v28 = 0;
  v26 = 0uLL;
  v27 = 0uLL;
  v24 = 0uLL;
  v25 = 0uLL;
  v22 = 0uLL;
  v23 = 0uLL;
  if ((aeaCryptoInit((char *)&v29, (unsigned int *)context) & 0x80000000) != 0)
  {
    v14 = "initializing crypto params";
    v15 = 467;
    goto LABEL_14;
  }
  v9 = *((unsigned int *)context + 5);
  v22 = xmmword_20A40B850;
  *(_QWORD *)&v23 = *((unsigned int *)context + 1) + 12;
  *((_QWORD *)&v23 + 1) = v23 + HIDWORD(v31);
  *(_QWORD *)&v24 = *((_QWORD *)&v23 + 1) + v32;
  *((_QWORD *)&v24 + 1) = v24 + DWORD2(v29);
  *(_QWORD *)&v25 = *((_QWORD *)&v24 + 1) + HIDWORD(v29);
  *((_QWORD *)&v25 + 1) = v25 + 48;
  v26 = (_QWORD)v25 + 48 + (unint64_t)HIDWORD(v29);
  v10 = (*((unsigned int *)context + 12) + 8) * v9 + HIDWORD(v29);
  *(_QWORD *)&v27 = (*((unsigned int *)context + 12) + 8) * v9;
  *((_QWORD *)&v27 + 1) = v10;
  v28 = v10 + HIDWORD(v29) * (unint64_t)v9;
  memset_s(&v5[v23], HIDWORD(v31), 0, HIDWORD(v31));
  if (!*((_QWORD *)&v36 + 1)
    || (v11 = (*((uint64_t (**)(_OWORD *, char *, size_t))&v36 + 1))(v42, v5, v6),
        LODWORD(v42[0]) != DWORD1(v31))
    || v11 < 0)
  {
    v14 = "digesting prologue";
    v15 = 474;
    goto LABEL_14;
  }
  v12 = (uint64_t (*)(_QWORD, uint64_t, char *, _OWORD *, char *))*((_QWORD *)context + 302);
  if (v12)
  {
    *(_QWORD *)&v84[0] = 0;
    result = v12(*((_QWORD *)context + 303), 256, (char *)__s + 4, v84, (char *)v42 + 4);
    if (result < 0)
    {
      v14 = "signing prologue digest";
      v15 = 484;
      goto LABEL_14;
    }
    if (*(_QWORD *)&v84[0] > (unint64_t)DWORD2(v31))
    {
      v14 = "invalid signature size";
      v15 = 485;
LABEL_14:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"AEAStreamSign", v15, 79, 0, v14, v7, v8, v22);
      v4 = -1;
      goto LABEL_15;
    }
    if (DWORD2(v31) >= 0x101)
      goto LABEL_46;
    LODWORD(__s[0]) = DWORD2(v31);
    result = memset_s((char *)__s + DWORD2(v31) + 4, 256 - DWORD2(v31), 0, 256 - DWORD2(v31));
  }
  else if (!(_QWORD)v37
         || (result = ((uint64_t (*)(_OWORD *, char *, _OWORD *))v37)(__s, (char *)context + 592, v42),
             LODWORD(__s[0]) != DWORD2(v31))
         || result < 0)
  {
    v14 = "signing prologue";
    v15 = 490;
    goto LABEL_14;
  }
  if (*(_DWORD *)context)
  {
    if (!(_QWORD)v38)
      goto LABEL_36;
    v83 = 0;
    memset(v82, 0, sizeof(v82));
    v81 = 0;
    memset(v80, 0, sizeof(v80));
    v79 = 0;
    v78 = 0u;
    v77 = 0u;
    v76 = 0u;
    v75 = 0u;
    v74 = 0u;
    v73 = 0u;
    v72 = 0u;
    v71 = 0u;
    v70 = 0u;
    v69 = 0u;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v65 = 0u;
    v64 = 0u;
    *(_OWORD *)__n = 0u;
    if (LODWORD(__s[0]) != DWORD2(v31))
      goto LABEL_35;
    if (*((_DWORD *)context + 408) != (_DWORD)v29)
      goto LABEL_35;
    *(_QWORD *)((char *)v80 + 4) = 0x324B45535F414541;
    LODWORD(v80[0]) = 8;
    memset_s((void *)((unint64_t)v80 | 0xC), 0xF8uLL, 0, 0xF8uLL);
    v85 = 0;
    memset(v84, 0, sizeof(v84));
    if (!*((_QWORD *)&v33 + 1))
      goto LABEL_35;
    if (!*((_DWORD *)context + 408))
      goto LABEL_35;
    result = (*((uint64_t (**)(_OWORD *, _QWORD, char *, _OWORD *, _OWORD *))&v33 + 1))(v82, DWORD1(v29), (char *)context + 1632, v80, v84);
    if (result < 0)
      goto LABEL_35;
    v16 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0x101)
      goto LABEL_46;
    __memcpy_chk();
    LODWORD(v44[0]) = v16;
    memset_s((char *)v44 + v16 + 4, 256 - v16, 0, 256 - v16);
    result = ((uint64_t (*)(char *, _QWORD, size_t *, _OWORD *, _QWORD, _QWORD))v38)((char *)v44 + 4, LODWORD(__s[0]), __n, v82, 0, 0);
    if (result < 0)
    {
LABEL_35:
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      goto LABEL_36;
    }
    v17 = LODWORD(v44[0]) + (unint64_t)LODWORD(__n[0]);
    if (v17 < 0x101)
    {
      memcpy((char *)v44 + LODWORD(v44[0]) + 4, (char *)__n + 4, LODWORD(__n[0]));
      LODWORD(v44[0]) = v17;
      memset_s((char *)v44 + v17 + 4, 256 - v17, 0, 256 - v17);
      v18 = v44[0];
      v19 = HIDWORD(v31);
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      if (v18 == v19)
      {
LABEL_39:
        memcpy(&v5[v23], (char *)v44 + 4, LODWORD(v44[0]));
        if (AAByteStreamPWrite(encrypted_stream, v5, v6, 0) == v6)
        {
          if (*((_QWORD *)&v41 + 1))
          {
            v21 = (*((uint64_t (**)(char *, char *, size_t))&v41 + 1))((char *)context + 1892, v5, v6);
            if (*((_DWORD *)context + 473) == DWORD1(v32) && (v21 & 0x80000000) == 0)
            {
              v4 = 0;
              goto LABEL_15;
            }
          }
          v14 = "digesting prologue";
          v15 = 505;
        }
        else
        {
          v14 = "writing updated prologue";
          v15 = 502;
        }
        goto LABEL_14;
      }
LABEL_36:
      v14 = "encrypt signature";
      v15 = 497;
      goto LABEL_14;
    }
  }
  else
  {
    v20 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) < 0x101)
    {
      __memcpy_chk();
      LODWORD(v44[0]) = v20;
      memset_s((char *)v44 + v20 + 4, 256 - v20, 0, 256 - v20);
      goto LABEL_39;
    }
  }
LABEL_46:
  __break(1u);
  return result;
}

size_t PCompressLZFSEEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZFSEDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result)
    return -1;
  return result;
}

uint64_t *AAVerifyDirectoryArchiveOutputStreamOpen(const char *a1, AAFieldKeySet_impl *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  int DefaultNThreads;
  uint64_t *v12;
  uint64_t *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  AAFieldKey v18;
  AAFieldKey v19;
  AAFieldKey v20;
  AAFieldKey v21;
  AAFieldKey v22;
  AAFieldKey v23;
  AAFieldKey v24;
  AAFieldKey v25;
  AAFieldKey v26;
  AAFieldKey v27;
  AAFieldKey v28;
  AAFieldKey v29;
  AAFieldKey v30;
  AAFieldKey v31;
  AAFieldKey v32;
  AAFieldKey v33;
  AAFieldKey v34;
  AAFieldKey v35;
  AAFieldKey v36;
  AAFieldKey v37;
  AAPathList_impl *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  int v43;
  const char *v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v54;
  void *v55;
  void *v56;
  unint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  unint64_t v60;
  int *v61;
  uint64_t v62;
  uint64_t v63;
  rsize_t v64;
  void *v65;
  uint64_t v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int *v71;
  char v72;
  stat v73;

  DefaultNThreads = a6;
  if (!a6)
    DefaultNThreads = getDefaultNThreads();
  v12 = (uint64_t *)malloc(0x38uLL);
  v13 = v12;
  if (v12)
    memset_s(v12, 0x38uLL, 0, 0x38uLL);
  memset(&v73, 0, sizeof(v73));
  v14 = malloc(0x4B8uLL);
  v15 = (uint64_t)v14;
  if (v14 && (memset_s(v14, 0x4B8uLL, 0, 0x4B8uLL), v13))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v15))
    {
      if (stat((const char *)v15, &v73) || (v73.st_mode & 0xF000) != 0x4000)
      {
        v72 = (char)a1;
        v44 = "Invalid directory: %s";
        v45 = 450;
        goto LABEL_64;
      }
      *(_QWORD *)(v15 + 1024) = a5;
      *(_QWORD *)(v15 + 1032) = a3;
      *(_QWORD *)(v15 + 1040) = a4;
      *(_DWORD *)(v15 + 1064) = DefaultNThreads;
      *(_DWORD *)(v15 + 1048) = a5 >> 62;
      *(_QWORD *)(v15 + 1088) = 0xFFFFFFFFLL;
      if (a2)
      {
        v18.ikey = 4475221;
        if (AAFieldKeySetContainsKey(a2, v18))
          *(_DWORD *)(v15 + 1088) &= ~1u;
        v19.ikey = 4475207;
        if (AAFieldKeySetContainsKey(a2, v19))
          *(_DWORD *)(v15 + 1088) &= ~2u;
        v20.ikey = 4672582;
        if (AAFieldKeySetContainsKey(a2, v20))
          *(_DWORD *)(v15 + 1088) &= ~4u;
        v21.ikey = 4476749;
        if (AAFieldKeySetContainsKey(a2, v21))
          *(_DWORD *)(v15 + 1088) &= ~8u;
        v22.ikey = 5067842;
        if (AAFieldKeySetContainsKey(a2, v22))
          *(_DWORD *)(v15 + 1088) &= ~0x10u;
        v23.ikey = 5067843;
        if (AAFieldKeySetContainsKey(a2, v23))
          *(_DWORD *)(v15 + 1088) &= ~0x20u;
        v24.ikey = 5067853;
        if (AAFieldKeySetContainsKey(a2, v24))
          *(_DWORD *)(v15 + 1088) &= ~0x40u;
        v25.ikey = 5523009;
        if (AAFieldKeySetContainsKey(a2, v25))
          *(_DWORD *)(v15 + 1088) &= ~0x80u;
        v26.ikey = 5391937;
        if (AAFieldKeySetContainsKey(a2, v26))
          *(_DWORD *)(v15 + 1088) &= ~0x100u;
        v27.ikey = 4803654;
        if (AAFieldKeySetContainsKey(a2, v27))
          *(_DWORD *)(v15 + 1088) &= ~0x200u;
        v28.ikey = 4411984;
        if (AAFieldKeySetContainsKey(a2, v28))
          *(_DWORD *)(v15 + 1088) &= ~0x400u;
        v29.ikey = 5458755;
        if (AAFieldKeySetContainsKey(a2, v29))
          *(_DWORD *)(v15 + 1088) &= ~0x800u;
        v30.ikey = 3229779;
        if (AAFieldKeySetContainsKey(a2, v30))
          *(_DWORD *)(v15 + 1088) &= ~0x1000u;
        v31.ikey = 3295315;
        if (AAFieldKeySetContainsKey(a2, v31))
          *(_DWORD *)(v15 + 1088) &= ~0x2000u;
        v32.ikey = 3360851;
        if (AAFieldKeySetContainsKey(a2, v32))
          *(_DWORD *)(v15 + 1088) &= ~0x4000u;
        v33.ikey = 3491923;
        if (AAFieldKeySetContainsKey(a2, v33))
          *(_DWORD *)(v15 + 1088) &= ~0x8000u;
        v34.ikey = 5521732;
        if (AAFieldKeySetContainsKey(a2, v34))
          *(_DWORD *)(v15 + 1088) &= ~0x80000u;
        v35.ikey = 4408665;
        if (AAFieldKeySetContainsKey(a2, v35))
          *(_DWORD *)(v15 + 1088) &= ~0x10000u;
        v36.ikey = 5521752;
        if (AAFieldKeySetContainsKey(a2, v36))
          *(_DWORD *)(v15 + 1088) &= ~0x20000u;
        v37.ikey = 4997953;
        if (AAFieldKeySetContainsKey(a2, v37))
          *(_DWORD *)(v15 + 1088) &= ~0x40000u;
      }
      if ((a5 & 0x80000000000000) == 0)
      {
        if (a5 >> 62)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Scanning target directory: %s\n", a1);
        v38 = AAPathListCreateWithDirectoryContents(a1, 0, *(void **)(v15 + 1032), *(AAEntryMessageProc *)(v15 + 1040), 0, DefaultNThreads);
        *(_QWORD *)(v15 + 1056) = v38;
        if (!v38)
        {
          v72 = (char)a1;
          v44 = "Scanning target directory failed: %s";
          v45 = 488;
          goto LABEL_64;
        }
        v39 = AAPathListNodeFirst(v38);
        if (v39 == -1)
        {
          *(_QWORD *)(v15 + 1120) = 64;
          v42 = 8;
        }
        else
        {
          v40 = v39;
          v41 = 0;
          do
          {
            ++*(_QWORD *)(v15 + 1152);
            if (v40 > v41)
              v41 = v40;
            v40 = AAPathListNodeNext(*(AAPathList *)(v15 + 1056), v40);
          }
          while (v40 != -1);
          *(_QWORD *)(v15 + 1120) = (v41 + 64) & 0xFFFFFFFFFFFFFFC0;
          v42 = ((v41 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8;
          if (v42 >= 0x2000000001)
          {
            *__error() = 12;
LABEL_87:
            *(_QWORD *)(v15 + 1128) = 0;
            v43 = *__error();
            v44 = "malloc";
            v45 = 499;
            goto LABEL_65;
          }
        }
        v54 = malloc(v42);
        if (!v54)
          goto LABEL_87;
        v55 = v54;
        memset_s(v54, v42, 0, v42);
        *(_QWORD *)(v15 + 1128) = v55;
      }
      v56 = calloc(*(unsigned int *)(v15 + 1064), 8uLL);
      *(_QWORD *)(v15 + 1072) = v56;
      if (v56)
      {
        if (*(_DWORD *)(v15 + 1064))
        {
          v57 = 0;
          while (1)
          {
            v58 = (uint64_t *)malloc(0x5A8uLL);
            v59 = v58;
            if (!v58)
            {
              v61 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerDataAlloc", 80, 119, *v61, "malloc", v62, v63, v72);
              goto LABEL_83;
            }
            memset_s(v58, 0x5A8uLL, 0, 0x5A8uLL);
            *v59 = v15;
            v60 = *(_QWORD *)(v15 + 1120);
            if (!v60)
              goto LABEL_83;
            if (v60 < 0x10000000008)
            {
              v64 = v60 >> 3;
              v65 = malloc(v60 >> 3);
              if (v65)
              {
                v66 = (uint64_t)v65;
                memset_s(v65, v64, 0, v64);
                v59[180] = v66;
                goto LABEL_83;
              }
            }
            else
            {
              *__error() = 12;
            }
            v59[180] = 0;
            v67 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerDataAlloc", 85, 119, *v67, "malloc", v68, v69, v72);
            workerDataFree((void **)v59);
            v59 = 0;
LABEL_83:
            *(_QWORD *)(*(_QWORD *)(v15 + 1072) + 8 * v57) = v59;
            v70 = *(_QWORD *)(v15 + 1072);
            if (!*(_QWORD *)(v70 + 8 * v57))
            {
              v44 = "allocation";
              v45 = 508;
              goto LABEL_64;
            }
            ++v57;
            v56 = (void *)*(unsigned int *)(v15 + 1064);
            if (v57 >= (unint64_t)v56)
              goto LABEL_89;
          }
        }
        v70 = (uint64_t)v56;
        LODWORD(v56) = 0;
LABEL_89:
        v71 = ThreadPoolCreate(v56, v70, (uint64_t)workerProc_0);
        *(_QWORD *)(v15 + 1080) = v71;
        if (v71)
        {
          v13[3] = (uint64_t)verifyDirectoryStreamWriteHeader;
          v13[4] = (uint64_t)verifyDirectoryStreamWriteBlob;
          *v13 = v15;
          v13[1] = (uint64_t)verifyDirectoryStreamClose;
          v13[2] = (uint64_t)verifyDirectoryStreamCancel;
          return v13;
        }
        v44 = "ThreadPoolCreate";
        v45 = 511;
LABEL_64:
        v43 = 0;
      }
      else
      {
        v43 = *__error();
        v44 = "malloc";
        v45 = 504;
      }
    }
    else
    {
      v43 = *__error();
      v72 = (char)a1;
      v44 = "%s";
      v45 = 449;
    }
  }
  else
  {
    v43 = *__error();
    v44 = "malloc";
    v45 = 448;
  }
LABEL_65:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"AAVerifyDirectoryArchiveOutputStreamOpen", v45, 119, v43, v44, v16, v17, v72);
  free(v13);
  verifyDirectoryStreamClose(v15, v46, v47, v48, v49, v50, v51, v52);
  return 0;
}

uint64_t workerProc_0(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t Node;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  AAFieldKeySet_impl *v13;
  uint64_t v14;
  uint64_t v15;
  AAFieldKeySet_impl *v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v27;
  __int16 v28;
  AAFieldKey v29;
  AAFieldKey v30;
  AAFieldKey v31;
  AAFieldKey v32;
  AAFieldKey v33;
  AAFieldKey v34;
  AAFieldKey v35;
  AAFieldKey v36;
  AAFieldKey v37;
  AAFieldKey v38;
  AAFieldKey v39;
  AAFieldKey v40;
  AAFieldKey v41;
  AAFieldKey v42;
  AAFieldKey v43;
  unsigned int *v44;
  char v46;
  char v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  stat v53;
  char v54[2048];
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v3 = (char *)(a1 + 12);
  v2 = *(_QWORD *)a1;
  memset(&v53, 0, sizeof(v53));
  v51 = 0;
  v52 = 0;
  v49 = 0u;
  v50 = 0u;
  v48 = 0u;
  if ((concatPath(v54, 0x800uLL, (char *)v2, (const char *)(a1 + 12)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", 153, 119, 0, "invalid path: %s", v4, v5, (char)v3);
LABEL_23:
    v16 = 0;
    goto LABEL_24;
  }
  v6 = *(_QWORD *)(v2 + 1056);
  if (!v6)
  {
    if ((lstat(v54, &v53) & 0x80000000) == 0)
      goto LABEL_8;
LABEL_19:
    v19 = v2;
    v20 = 71;
    goto LABEL_28;
  }
  Node = AAPathListGetNode(v6, v3);
  if (Node == -1)
    goto LABEL_19;
  if (Node >= *(_QWORD *)(v2 + 1120))
  {
    v21 = "invalid node index";
    v22 = 166;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", v22, 119, 0, v21, v8, v9, v46);
    goto LABEL_23;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 1440) + ((Node >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << Node;
LABEL_8:
  v10 = *(_QWORD *)(a1 + 1392);
  if (v10)
  {
    LOBYTE(v48) = v48 | 1;
    *((_QWORD *)&v48 + 1) = *(_QWORD *)(a1 + 1408);
    *(_QWORD *)&v49 = v10;
  }
  v11 = *(_QWORD *)(a1 + 1344);
  if (v11)
  {
    LOBYTE(v48) = v48 | 2;
    *((_QWORD *)&v49 + 1) = *(_QWORD *)(a1 + 1360);
    *(_QWORD *)&v50 = v11;
  }
  v12 = *(_QWORD *)(a1 + 1368);
  if (v12)
  {
    LOBYTE(v48) = v48 | 4;
    *((_QWORD *)&v50 + 1) = *(_QWORD *)(a1 + 1384);
    v51 = v12;
  }
  if ((aaCheckAndFixWithPath((char *)(a1 + 1040), (unsigned __int8 *)(a1 + 1112), (unsigned __int8 *)(a1 + 1168), (unsigned __int8 *)&v48, *(_QWORD *)(v2 + 1088), (unsigned int *)&v52, (char *)v2, v3, *(_QWORD *)(v2 + 1024)) & 0x80000000) != 0)
  {
    v46 = (char)v3;
    v21 = "CheckAndFix: %s";
    v22 = 190;
    goto LABEL_22;
  }
  if (!v52)
  {
    v19 = v2;
    v20 = 73;
LABEL_28:
    v16 = 0;
    if ((sendMessage(v19, v20, (uint64_t)v3, 0) & 0x80000000) != 0)
      goto LABEL_92;
LABEL_29:
    v25 = 0;
    goto LABEL_30;
  }
  v13 = AAFieldKeySetCreate();
  v16 = v13;
  if (!v13)
  {
    v27 = "AAFieldKeySetCreate";
    v28 = 200;
LABEL_99:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", v28, 119, 0, v27, v14, v15, v47);
LABEL_24:
    v23 = (unint64_t *)(v2 + 1160);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    goto LABEL_29;
  }
  v17 = v52;
  if ((v52 & 1) != 0)
  {
    v29.ikey = 4475221;
    v18 = AAFieldKeySetInsertKey(v13, v29) >= 0;
    v17 = v52;
  }
  else
  {
    v18 = 1;
  }
  if ((v17 & 2) != 0)
  {
    v30.ikey = 4475207;
    if (AAFieldKeySetInsertKey(v16, v30) < 0)
      v18 = 0;
    v17 = v52;
  }
  if ((v17 & 8) != 0)
  {
    v31.ikey = 4476749;
    if (AAFieldKeySetInsertKey(v16, v31) < 0)
      v18 = 0;
    v17 = v52;
  }
  if ((v17 & 4) != 0)
  {
    v32.ikey = 4672582;
    if (AAFieldKeySetInsertKey(v16, v32) < 0)
      v18 = 0;
    v17 = v52;
  }
  if ((v17 & 0x40) != 0)
  {
    v35.ikey = 5067853;
    if (AAFieldKeySetInsertKey(v16, v35) < 0)
      v18 = 0;
    v17 = v52;
    if ((v52 & 0x10) == 0)
    {
LABEL_47:
      if ((v17 & 0x20) == 0)
        goto LABEL_51;
      goto LABEL_48;
    }
  }
  else if ((v17 & 0x10) == 0)
  {
    goto LABEL_47;
  }
  v36.ikey = 5067842;
  if (AAFieldKeySetInsertKey(v16, v36) < 0)
    v18 = 0;
  v17 = v52;
  if ((v52 & 0x20) != 0)
  {
LABEL_48:
    v33.ikey = 5067843;
    if (AAFieldKeySetInsertKey(v16, v33) < 0)
      v18 = 0;
    v17 = v52;
  }
LABEL_51:
  if ((v17 & 0x80) != 0)
  {
    v37.ikey = 5523009;
    if (AAFieldKeySetInsertKey(v16, v37) < 0)
      v18 = 0;
    v17 = v52;
    if ((v52 & 0x100) == 0)
    {
LABEL_53:
      if ((v17 & 0x200) == 0)
        goto LABEL_57;
      goto LABEL_54;
    }
  }
  else if ((v17 & 0x100) == 0)
  {
    goto LABEL_53;
  }
  v38.ikey = 5391937;
  if (AAFieldKeySetInsertKey(v16, v38) < 0)
    v18 = 0;
  v17 = v52;
  if ((v52 & 0x200) != 0)
  {
LABEL_54:
    v34.ikey = 4803654;
    if (AAFieldKeySetInsertKey(v16, v34) < 0)
      v18 = 0;
    v17 = v52;
  }
LABEL_57:
  if ((v17 & 0x400) != 0)
  {
    v39.ikey = 4411984;
    if (AAFieldKeySetInsertKey(v16, v39) < 0)
      v18 = 0;
    v17 = v52;
    if ((v52 & 0x80000) == 0)
    {
LABEL_59:
      if ((v17 & 0x10000) == 0)
        goto LABEL_60;
      goto LABEL_83;
    }
  }
  else if ((v17 & 0x80000) == 0)
  {
    goto LABEL_59;
  }
  v40.ikey = 5521732;
  if (AAFieldKeySetInsertKey(v16, v40) < 0)
    v18 = 0;
  v17 = v52;
  if ((v52 & 0x10000) == 0)
  {
LABEL_60:
    if ((v17 & 0x20000) == 0)
      goto LABEL_61;
LABEL_86:
    v42.ikey = 5521752;
    if (AAFieldKeySetInsertKey(v16, v42) < 0)
      v18 = 0;
    if ((v52 & 0x40000) == 0)
      goto LABEL_90;
    goto LABEL_89;
  }
LABEL_83:
  v41.ikey = 4408665;
  if (AAFieldKeySetInsertKey(v16, v41) < 0)
    v18 = 0;
  v17 = v52;
  if ((v52 & 0x20000) != 0)
    goto LABEL_86;
LABEL_61:
  if ((v17 & 0x40000) == 0)
    goto LABEL_90;
LABEL_89:
  v43.ikey = 4997953;
  if (AAFieldKeySetInsertKey(v16, v43) < 0)
  {
LABEL_98:
    v27 = "AAFieldKeySetInsertKey";
    v28 = 216;
    goto LABEL_99;
  }
LABEL_90:
  if (!v18)
    goto LABEL_98;
  if ((sendMessage(v2, 74, (uint64_t)v3, v16) & 0x80000000) == 0)
    goto LABEL_29;
LABEL_92:
  v44 = (unsigned int *)(v2 + 1136);
  while (!__ldaxr(v44))
  {
    if (!__stlxr(1u, v44))
      goto LABEL_97;
  }
  __clrex();
LABEL_97:
  v25 = 0xFFFFFFFFLL;
LABEL_30:
  AAFieldKeySetDestroy(v16);
  return v25;
}

uint64_t verifyDirectoryStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  char v14;
  void *v15;
  unint64_t v16;
  FILE **v17;
  FILE *v18;
  FILE *v19;
  unint64_t v20;
  FILE *v21;
  unint64_t v22;
  FILE *v23;
  unint64_t v24;
  FILE *v25;
  unint64_t v26;
  FILE *v28;
  unint64_t v29;
  FILE *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t i;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  _QWORD *v43;
  uint64_t v44;
  AAPathList_impl *v45;
  uint64_t v46;
  uint64_t j;
  uint64_t v48;
  uint64_t v49;
  char v50;
  char path[1024];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v8 = result;
    v9 = *(_QWORD *)(result + 1096);
    if (v9)
    {
      v10 = *(_QWORD *)(result + 1080);
      if (v10)
      {
        *(_DWORD *)(v9 + 8) = 0;
        ThreadPoolRunWorker(v10, v9, a3, a4, a5, a6, a7, a8);
        *(_QWORD *)(v8 + 1096) = 0;
      }
    }
    ThreadPoolDestroy(*(_QWORD *)(v8 + 1080));
    v11 = atomic_load((unsigned int *)(v8 + 1136));
    if (v11 || (v12 = atomic_load((unint64_t *)(v8 + 1160))) != 0)
    {
LABEL_7:
      v13 = 0;
      v14 = 1;
    }
    else
    {
      v36 = *(_QWORD *)(v8 + 1072);
      if (v36)
      {
        v37 = *(_QWORD *)(v8 + 1120);
        if (v37)
        {
          v38 = *(unsigned int *)(v8 + 1064);
          if ((_DWORD)v38)
          {
            for (i = 0; i != v38; ++i)
            {
              v40 = *(_QWORD *)(v36 + 8 * i);
              if (v40)
              {
                v41 = 0;
                v42 = *(uint64_t **)(v40 + 1440);
                v43 = *(_QWORD **)(v8 + 1128);
                do
                {
                  v44 = *v42++;
                  *v43++ |= v44;
                  v41 += 64;
                }
                while (v41 < v37);
              }
            }
          }
        }
      }
      v45 = *(AAPathList_impl **)(v8 + 1056);
      if (v45)
      {
        v46 = AAPathListNodeFirst(v45);
        if (v46 != -1)
        {
          for (j = v46; j != -1; j = AAPathListNodeNext(*(AAPathList *)(v8 + 1056), j))
          {
            if (((*(_QWORD *)(*(_QWORD *)(v8 + 1128) + ((j >> 3) & 0x1FFFFFFFFFFFFFF8)) >> j) & 1) == 0)
            {
              if (AAPathListNodeGetPath(*(AAPathList *)(v8 + 1056), j, 0x400uLL, path, 0) < 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamClose", 385, 119, 0, "path too long", v48, v49, v50);
                goto LABEL_7;
              }
              if ((sendMessage(v8, 72, (uint64_t)path, 0) & 0x80000000) != 0)
                goto LABEL_7;
            }
          }
        }
      }
      v14 = 0;
      v13 = 1;
    }
    AAPathListDestroy(*(AAPathList *)(v8 + 1056));
    v15 = *(void **)(v8 + 1072);
    if (v15)
    {
      if (*(_DWORD *)(v8 + 1064))
      {
        v16 = 0;
        do
          workerDataFree(*(void ***)(*(_QWORD *)(v8 + 1072) + 8 * v16++));
        while (v16 < *(unsigned int *)(v8 + 1064));
        v15 = *(void **)(v8 + 1072);
      }
      free(v15);
    }
    if ((v14 & 1) == 0 && *(_DWORD *)(v8 + 1048))
    {
      v17 = (FILE **)MEMORY[0x24BDAC8D8];
      v18 = (FILE *)*MEMORY[0x24BDAC8D8];
      if (*(_QWORD *)(v8 + 1144) == *(_QWORD *)(v8 + 1152))
      {
        fprintf(v18, "%12llu entries\n");
      }
      else
      {
        fprintf(v18, "%12llu entries in archive\n", *(_QWORD *)(v8 + 1144));
        fprintf(*v17, "%12llu entries in directory\n");
      }
      v19 = *v17;
      v20 = atomic_load((unint64_t *)(v8 + 1176));
      fprintf(v19, "%12llu common, OK\n", v20);
      v21 = *v17;
      v22 = atomic_load((unint64_t *)(v8 + 1184));
      fprintf(v21, "%12llu common, not matching\n", v22);
      v23 = *v17;
      v24 = atomic_load((unint64_t *)(v8 + 1192));
      fprintf(v23, "%12llu added\n", v24);
      v25 = *v17;
      v26 = atomic_load((unint64_t *)(v8 + 1200));
      fprintf(v25, "%12llu removed\n", v26);
      if (atomic_load((unint64_t *)(v8 + 1168)))
      {
        v28 = *v17;
        v29 = atomic_load((unint64_t *)(v8 + 1168));
        fprintf(v28, "%12llu differences ignored\n", v29);
      }
      if (atomic_load((unint64_t *)(v8 + 1160)))
      {
        v31 = *v17;
        v32 = atomic_load((unint64_t *)(v8 + 1160));
        fprintf(v31, "%12llu errors reported\n", v32);
      }
    }
    v33 = atomic_load((unint64_t *)(v8 + 1184));
    if (v33
      || (v34 = atomic_load((unint64_t *)(v8 + 1192))) != 0
      || (v35 = atomic_load((unint64_t *)(v8 + 1200))) != 0)
    {
      v13 = 0;
    }
    free(*(void **)(v8 + 1128));
    free((void *)v8);
    if (v13)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t verifyDirectoryStreamWriteHeader(uint64_t a1, AAHeader_impl *a2)
{
  unsigned int *v2;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t result;
  AAFieldKey v12;
  uint32_t KeyIndex;
  uint64_t v14;
  unsigned int FieldUInt;
  int v16;
  __int16 v17;
  AAFieldKey v18;
  uint32_t v19;
  unsigned int FieldString;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t (*v26)(_QWORD, uint64_t, char *, AAHeader_impl *);
  int v27;
  uint64_t Worker;
  uint64_t v29;
  AAFieldKey v30;
  uint32_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  void **v35;
  void *v36;
  void *v37;
  AAFieldKey v38;
  uint32_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  void **v43;
  void *v44;
  void *v45;
  AAFieldKey v46;
  uint32_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  size_t v54;
  void **v55;
  void *v56;
  void *v57;
  size_t __size;
  uint64_t offset;
  uint64_t size;
  size_t length;
  uint64_t value;
  char v63[1024];
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v2 = (unsigned int *)(a1 + 1136);
  if (atomic_load((unsigned int *)(a1 + 1136)))
    return 0xFFFFFFFFLL;
  value = 0;
  bzero(v63, 0x400uLL);
  size = 0;
  length = 0;
  offset = 0;
  if (*(_QWORD *)(a1 + 1096) || *(_QWORD *)(a1 + 1112))
  {
    v8 = "invalid state";
    v9 = 247;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteHeader", v9, 119, 0, v8, v6, v7, __size);
    goto LABEL_6;
  }
  *(_DWORD *)(a1 + 1104) = 0;
  ++*(_QWORD *)(a1 + 1144);
  v12.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(a2, v12);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(a2, KeyIndex, &value), FieldUInt <= 1) ? (v16 = 1) : (v16 = FieldUInt),
        v16 <= 0))
  {
    v17 = 252;
    goto LABEL_19;
  }
  if (value == 77)
  {
LABEL_17:
    result = 0;
    *(_DWORD *)(a1 + 1104) = 1;
    return result;
  }
  v18.ikey = 5521744;
  v19 = AAHeaderGetKeyIndex(a2, v18);
  if ((v19 & 0x80000000) != 0
    || ((FieldString = AAHeaderGetFieldString(a2, v19, 0x400uLL, v63, &length), FieldString <= 1)
      ? (v25 = 1)
      : (v25 = FieldString),
        v25 <= 0))
  {
    v17 = 254;
LABEL_19:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteHeader", v17, 119, "invalid archive", v14, v6, v7, __size);
LABEL_6:
    while (!__ldaxr(v2))
    {
      if (!__stlxr(1u, v2))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  v26 = *(uint64_t (**)(_QWORD, uint64_t, char *, AAHeader_impl *))(a1 + 1040);
  if (v26)
  {
    v27 = v26(*(_QWORD *)(a1 + 1032), 70, v63, a2);
    if (v27 < 0)
    {
      v8 = "user cancelled";
      v9 = 260;
      goto LABEL_5;
    }
    if (v27)
      goto LABEL_17;
  }
  Worker = ThreadPoolGetWorker(*(_QWORD *)(a1 + 1080), v21, v22, v23, v24, v14, v6, v7);
  if (!Worker)
  {
    v8 = "ThreadPoolGetWorker";
    v9 = 266;
    goto LABEL_5;
  }
  v29 = Worker;
  *(_QWORD *)(a1 + 1112) = AAHeaderGetPayloadSize(a2);
  *(_DWORD *)(v29 + 8) = value;
  __strlcpy_chk();
  *(_QWORD *)(v29 + 1344) = 0;
  *(_QWORD *)(v29 + 1368) = 0;
  *(_QWORD *)(v29 + 1392) = 0;
  *(_QWORD *)(v29 + 1416) = 0;
  *(_QWORD *)(v29 + 1432) = 0;
  *(_QWORD *)(v29 + 1424) = 0;
  if ((aaEntryAttributesInitWithHeader((char *)(v29 + 1040), (char *)(v29 + 1112), (char *)(v29 + 1168), a2) & 0x80000000) != 0)
  {
    v8 = "invalid header";
    v9 = 277;
    goto LABEL_5;
  }
  v30.ikey = 4997953;
  v31 = AAHeaderGetKeyIndex(a2, v30);
  if ((v31 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v31, &size, &offset) <= 1)
  {
    v32 = size;
    *(_QWORD *)(v29 + 1424) = size;
    if ((v32 & 0x8000000000000000) != 0)
      goto LABEL_86;
    v33 = *(_QWORD *)(v29 + 1376);
    if (v33 < v32)
    {
      do
      {
        while (!v33)
        {
          v33 = 0x4000;
          if (v32 <= 0x4000)
          {
            v35 = (void **)(v29 + 1384);
            __size = 0x4000;
            goto LABEL_47;
          }
        }
        v34 = v33 >> 1;
        if ((v33 & (v33 >> 1)) != 0)
          v34 = v33 & (v33 >> 1);
        v33 += v34;
      }
      while (v33 < v32);
      v35 = (void **)(v29 + 1384);
      __size = v33;
      if (v33 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_85;
      }
LABEL_47:
      v36 = *v35;
      v37 = realloc(*v35, __size);
      if (v37)
      {
        *(_QWORD *)(v29 + 1384) = v37;
        *(_QWORD *)(v29 + 1376) = __size;
        goto LABEL_49;
      }
      free(v36);
LABEL_85:
      *v35 = 0;
      *(_QWORD *)(v29 + 1368) = 0;
      *(_QWORD *)(v29 + 1376) = 0;
LABEL_86:
      v8 = "ACL blob allocation";
      v9 = 284;
      goto LABEL_5;
    }
  }
LABEL_49:
  v38.ikey = 5521752;
  v39 = AAHeaderGetKeyIndex(a2, v38);
  if ((v39 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v39, &size, &offset) <= 1)
  {
    v40 = size;
    *(_QWORD *)(v29 + 1416) = size;
    if ((v40 & 0x8000000000000000) != 0)
      goto LABEL_89;
    v41 = *(_QWORD *)(v29 + 1352);
    if (v41 < v40)
    {
      do
      {
        while (!v41)
        {
          v41 = 0x4000;
          if (v40 <= 0x4000)
          {
            v43 = (void **)(v29 + 1360);
            __size = 0x4000;
            goto LABEL_62;
          }
        }
        v42 = v41 >> 1;
        if ((v41 & (v41 >> 1)) != 0)
          v42 = v41 & (v41 >> 1);
        v41 += v42;
      }
      while (v41 < v40);
      v43 = (void **)(v29 + 1360);
      __size = v41;
      if (v41 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_88;
      }
LABEL_62:
      v44 = *v43;
      v45 = realloc(*v43, __size);
      if (v45)
      {
        *(_QWORD *)(v29 + 1360) = v45;
        *(_QWORD *)(v29 + 1352) = __size;
        goto LABEL_64;
      }
      free(v44);
LABEL_88:
      *v43 = 0;
      *(_QWORD *)(v29 + 1344) = 0;
      *(_QWORD *)(v29 + 1352) = 0;
LABEL_89:
      v8 = "XAT blob allocation";
      v9 = 290;
      goto LABEL_5;
    }
  }
LABEL_64:
  v46.ikey = 4408665;
  v47 = AAHeaderGetKeyIndex(a2, v46);
  if ((v47 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v47, &size, &offset) <= 1)
  {
    v52 = size;
    *(_QWORD *)(v29 + 1432) = size;
    if ((v52 & 0x8000000000000000) == 0)
    {
      v53 = *(_QWORD *)(v29 + 1400);
      if (v53 >= v52)
        goto LABEL_79;
      do
      {
        while (!v53)
        {
          v53 = 0x4000;
          if (v52 <= 0x4000)
          {
            v55 = (void **)(v29 + 1408);
            v53 = 0x4000;
            goto LABEL_77;
          }
        }
        v54 = v53 >> 1;
        if ((v53 & (v53 >> 1)) != 0)
          v54 = v53 & (v53 >> 1);
        v53 += v54;
      }
      while (v53 < v52);
      v55 = (void **)(v29 + 1408);
      if (v53 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_91;
      }
LABEL_77:
      v56 = *v55;
      v57 = realloc(*v55, v53);
      if (v57)
      {
        *(_QWORD *)(v29 + 1408) = v57;
        *(_QWORD *)(v29 + 1400) = v53;
        goto LABEL_79;
      }
      free(v56);
LABEL_91:
      *v55 = 0;
      *(_QWORD *)(v29 + 1392) = 0;
      *(_QWORD *)(v29 + 1400) = 0;
    }
    v8 = "YEC blob allocation";
    v9 = 296;
    goto LABEL_5;
  }
LABEL_79:
  if (*(_QWORD *)(a1 + 1112))
  {
    result = 0;
    *(_QWORD *)(a1 + 1096) = v29;
  }
  else
  {
    if ((ThreadPoolRunWorker(*(_QWORD *)(a1 + 1080), v29, v48, v49, v50, v51, v6, v7) & 0x80000000) != 0)
    {
      v8 = "ThreadPoolRunWorker";
      v9 = 302;
      goto LABEL_5;
    }
    return 0;
  }
  return result;
}

uint64_t verifyDirectoryStreamWriteBlob(uint64_t a1, int a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  uint64_t v12;
  uint64_t v15;
  _QWORD *v16;
  rsize_t *v17;
  const char *v18;
  __int16 v19;
  unint64_t v20;
  rsize_t v21;
  size_t v22;
  size_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  rsize_t v27;
  rsize_t v28;
  char v30;

  v8 = (unsigned int *)(a1 + 1136);
  if (atomic_load((unsigned int *)(a1 + 1136)))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 1104))
    return 0;
  v12 = *(_QWORD *)(a1 + 1096);
  if (!v12)
  {
    v18 = "invalid state";
    v19 = 318;
    goto LABEL_41;
  }
  v15 = *(_QWORD *)&a2 & 0xFFFFFFLL;
  if ((*(_QWORD *)&a2 & 0xFFFFFFLL) == 0x434559)
  {
    v16 = (_QWORD *)(v12 + 1392);
    v17 = (rsize_t *)(v12 + 1432);
  }
  else if (v15 == 4997953)
  {
    v16 = (_QWORD *)(v12 + 1368);
    v17 = (rsize_t *)(v12 + 1424);
  }
  else
  {
    if (v15 != 5521752)
      goto LABEL_34;
    v16 = (_QWORD *)(v12 + 1344);
    v17 = (rsize_t *)(v12 + 1416);
  }
  v20 = *v16 + __smax;
  if (__CFADD__(*v16, __smax) || (v20 & 0x8000000000000000) != 0)
    goto LABEL_40;
  v21 = *v17;
  v22 = v16[1];
  if (v22 < v20)
  {
    do
    {
      while (!v22)
      {
        v22 = 0x4000;
        if (v20 <= 0x4000)
        {
          v22 = 0x4000;
          goto LABEL_25;
        }
      }
      v23 = v22 >> 1;
      if ((v22 & (v22 >> 1)) != 0)
        v23 = v22 & (v22 >> 1);
      v22 += v23;
    }
    while (v22 < v20);
    if (v22 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_39;
    }
LABEL_25:
    v24 = (void *)v16[2];
    v25 = realloc(v24, v22);
    if (v25)
    {
      v16[1] = v22;
      v16[2] = v25;
      goto LABEL_27;
    }
    free(v24);
LABEL_39:
    v16[1] = 0;
    v16[2] = 0;
    *v16 = 0;
    goto LABEL_40;
  }
LABEL_27:
  v26 = v16[2];
  if (__src)
  {
    memcpy((void *)(v26 + *v16), __src, __smax);
  }
  else if (v26)
  {
    memset_s((void *)(v26 + *v16), __smax, 0, __smax);
  }
  v27 = *v16 + __smax;
  *v16 = v27;
  if ((__smax & 0x8000000000000000) != 0)
  {
LABEL_40:
    v18 = "blob append";
    v19 = 328;
LABEL_41:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteBlob", v19, 119, 0, v18, a7, a8, v30);
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  if (v27 > v21)
  {
    v18 = "blob size mismatch";
    v19 = 329;
    goto LABEL_41;
  }
LABEL_34:
  v28 = *(_QWORD *)(a1 + 1112) - __smax;
  *(_QWORD *)(a1 + 1112) = v28;
  if (v28)
    return 0;
  if ((ThreadPoolRunWorker(*(_QWORD *)(a1 + 1080), v12, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    v18 = "ThreadPoolRunWorker";
    v19 = 337;
    goto LABEL_41;
  }
  result = 0;
  *(_QWORD *)(a1 + 1096) = 0;
  return result;
}

uint64_t verifyDirectoryStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 1136);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

void workerDataFree(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = a1 + 168;
    free(a1[170]);
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(a1[173]);
    memset_s(a1 + 171, 0x18uLL, 0, 0x18uLL);
    free(a1[176]);
    memset_s(a1 + 174, 0x18uLL, 0, 0x18uLL);
    free(a1[180]);
    free(a1);
  }
}

uint64_t sendMessage(uint64_t a1, uint64_t a2, uint64_t a3, AAFieldKeySet key_set)
{
  unsigned int v8;
  uint64_t (*v9)(_QWORD, uint64_t, uint64_t, AAFieldKeySet);
  uint64_t result;
  unint64_t *v11;
  unint64_t v12;
  char s[16];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v8 = *(_DWORD *)(a1 + 1048);
  if (v8)
  {
    switch((int)a2)
    {
      case 'G':
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "REMOVED %s\n");
        break;
      case 'H':
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ADDED   %s\n");
        break;
      case 'I':
        if (v8 >= 2)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "OK      %s\n");
        break;
      case 'J':
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        *(_OWORD *)s = 0u;
        v14 = 0u;
        if (key_set)
          AAFieldKeySetSerialize(key_set, 0x80uLL, s);
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "DIFFER  %s (%s)\n");
        break;
      default:
        break;
    }
  }
  v9 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, AAFieldKeySet))(a1 + 1040);
  if (v9)
  {
    result = v9(*(_QWORD *)(a1 + 1032), a2, a3, key_set);
    if ((result & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
    if ((_DWORD)a2 == 73)
    {
LABEL_17:
      v11 = (unint64_t *)(a1 + 1176);
    }
    else if ((_DWORD)result)
    {
      v11 = (unint64_t *)(a1 + 1168);
    }
    else
    {
      switch((_DWORD)a2)
      {
        case 'G':
LABEL_16:
          result = 0;
          v11 = (unint64_t *)(a1 + 1200);
          break;
        case 'J':
LABEL_23:
          result = 0;
          v11 = (unint64_t *)(a1 + 1184);
          break;
        case 'H':
LABEL_22:
          result = 0;
          v11 = (unint64_t *)(a1 + 1192);
          break;
        default:
          return 0;
      }
    }
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  else
  {
    result = 0;
    switch((int)a2)
    {
      case 'G':
        goto LABEL_16;
      case 'H':
        goto LABEL_22;
      case 'I':
        goto LABEL_17;
      case 'J':
        goto LABEL_23;
      default:
        return result;
    }
  }
  return result;
}

size_t PCompressLZMA6Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZMADecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result)
    return -1;
  return result;
}

uint64_t aeaCryptoInit(char *__s, unsigned int *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  __int128 v8;
  uint64_t result;
  unsigned int v10;
  char v11;

  if (__s)
    memset_s(__s, 0xD0uLL, 0, 0xD0uLL);
  if (aeaProfileIsValid(*a2))
  {
    v6 = 0;
    v7 = 0;
    switch(*a2)
    {
      case 0u:
        *((_QWORD *)__s + 8) = RNG;
        *((_QWORD *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        *(_QWORD *)&v8 = 0x2000000020;
        *((_QWORD *)&v8 + 1) = 0x2000000020;
        *((_QWORD *)__s + 11) = AEADEncrypt_None_MAC256_KEY256;
        *((_QWORD *)__s + 12) = AEADDecrypt_None_MAC256_KEY256;
        *(_OWORD *)__s = v8;
        *((_QWORD *)__s + 15) = Digest_SHA256;
        *((_QWORD *)__s + 16) = DSASign_ECDSA_P256;
        *((_QWORD *)__s + 17) = DSAVerify_ECDSA_P256;
        *(_OWORD *)(__s + 28) = xmmword_20A40B890;
        *(_QWORD *)(__s + 44) = 0x2000000080;
        goto LABEL_13;
      case 1u:
        goto LABEL_8;
      case 2u:
        v6 = 1;
LABEL_8:
        *((_QWORD *)__s + 8) = RNG;
        *((_QWORD *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        *(_OWORD *)__s = xmmword_20A40B880;
        *((_QWORD *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((_QWORD *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        if (!v6)
          break;
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        v7 = 1;
LABEL_11:
        *((_QWORD *)__s + 8) = RNG;
        *((_QWORD *)__s + 9) = HKDFDerive;
        *(_OWORD *)__s = xmmword_20A40B880;
        *((_QWORD *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((_QWORD *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((_QWORD *)__s + 6) = 0x2000000041;
        *((_QWORD *)__s + 13) = DHESender_ECDHE_P256;
        *((_QWORD *)__s + 14) = DHERecipient_ECDHE_P256;
        *((_QWORD *)__s + 2) = 0x4100000061;
        *((_DWORD *)__s + 6) = 32;
        *((_QWORD *)__s + 20) = DerivePublicFromPrivate_ECP256;
        if (v7)
        {
LABEL_12:
          *((_QWORD *)__s + 15) = Digest_SHA256;
          *((_QWORD *)__s + 16) = DSASign_ECDSA_P256;
          *(_OWORD *)(__s + 28) = xmmword_20A40B890;
          *((_DWORD *)__s + 11) = 160;
          *((_QWORD *)__s + 17) = DSAVerify_ECDSA_P256;
          *((_QWORD *)__s + 18) = AEADEncrypt_AESCTR_MAC256_KEY640;
          *((_QWORD *)__s + 19) = AEADDecrypt_AESCTR_MAC256_KEY640;
LABEL_13:
          *((_QWORD *)__s + 21) = DerivePublicFromPrivate_ECP256;
        }
        break;
      case 5u:
        *((_QWORD *)__s + 8) = RNG;
        *((_QWORD *)__s + 9) = HKDFDerive;
        *((_QWORD *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((_QWORD *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((_QWORD *)__s + 10) = ScryptDerive_KEY256;
        *(_OWORD *)__s = xmmword_20A40B880;
        v10 = a2[2];
        *((_DWORD *)__s + 13) = 32;
        *((_DWORD *)__s + 14) = v10;
        break;
      default:
        *(_DWORD *)__s = 32;
        *((_QWORD *)__s + 1) = 0x2000000020;
        *((_QWORD *)__s + 8) = RNG;
        *((_QWORD *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        break;
    }
    result = 0;
    *((_QWORD *)__s + 22) = HMACInit_SHA256;
    *((_QWORD *)__s + 23) = HMACUpdate_SHA256;
    *((_QWORD *)__s + 24) = HMACFinal_SHA256;
    *((_QWORD *)__s + 25) = Digest_SHA256;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"aeaCryptoInit", 1400, 94, 0, "Invalid profile", v4, v5, v11);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t HKDFDerive(_DWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char *v17;
  rsize_t v18;
  rsize_t v19;
  char v20;

  if ((unint64_t)(a2 - 257) < 0xFFFFFFFFFFFFFF00 || *a3 == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HKDFDerive", 518, 94, 0, "Invalid KDF parameters", a7, a8, v20);
    return 0xFFFFFFFFLL;
  }
  else
  {
    ccsha256_di();
    v12 = a1 + 1;
    v13 = cchkdf();
    v16 = v13;
    if (v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HKDFDerive", 547, 94, 0, "HKDF", v14, v15, (_BYTE)a1 + 4);
      *a1 = a2;
      memset_s((char *)v12 + a2, 256 - a2, 0, 256 - a2);
      v17 = (char *)a1;
      v18 = 260;
      v19 = 260;
    }
    else
    {
      *a1 = a2;
      v17 = (char *)v12 + a2;
      v18 = 256 - a2;
      v19 = 256 - a2;
    }
    memset_s(v17, v18, 0, v19);
    if (v16)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
}

uint64_t RNG()
{
  uint64_t v0;
  uint64_t v1;
  char v3;

  ccrng();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"RNG", 222, 94, 0, "generate random bytes", v0, v1, v3);
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_None_MAC256_KEY256(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  __int16 v11;
  char v12;

  if (*a4 == 32)
  {
    if ((HMACDerive_SHA256(a3, a4) & 0x80000000) == 0)
      return 0;
    v10 = "HMAC derivation";
    v11 = 904;
  }
  else
  {
    v10 = "AEAD invalid sizes";
    v11 = 901;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_None_MAC256_KEY256", v11, 94, 0, v10, a7, a8, v12);
  if (a3)
    memset_s(a3, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t AEADDecrypt_None_MAC256_KEY256(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  __int16 v10;
  char vars0;

  if (*a4 == 32 && *a3 == 32)
  {
    if ((HMACVerify_SHA256((uint64_t)a3, a4) & 0x80000000) == 0)
      return 0;
    v9 = "HMAC verification";
    v10 = 924;
  }
  else
  {
    v9 = "AEAD invalid sizes";
    v10 = 921;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_None_MAC256_KEY256", v10, 94, 0, v9, a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_AESCTR_MAC256_KEY640(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t *v12;
  rsize_t v13;
  size_t *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  int v27;
  __int128 v28;
  _OWORD v29[15];
  int v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[224];
  unsigned int __s;
  _OWORD v35[2];
  _BYTE v36[224];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  memset(v36, 0, sizeof(v36));
  memset(v33, 0, sizeof(v33));
  memset(v29, 0, sizeof(v29));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", 946, 94, 0, "AEAD invalid sizes", a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  v31 = *(_OWORD *)(a4 + 4);
  v32 = *(_OWORD *)(a4 + 20);
  v30 = 32;
  memset_s(v33, 0xE0uLL, 0, 0xE0uLL);
  v35[0] = *(_OWORD *)(a4 + 36);
  v35[1] = *(_OWORD *)(a4 + 52);
  __s = 32;
  memset_s(v36, 0xE0uLL, 0, 0xE0uLL);
  v28 = *(_OWORD *)(a4 + 68);
  v27 = 16;
  memset_s(v29, 0xF0uLL, 0, 0xF0uLL);
  v12 = (size_t *)ccaes_ctr_crypt_mode();
  v13 = *v12;
  if (*v12 < 0x2000000001)
  {
    v15 = v12;
    v16 = malloc(*v12);
    if (!v16)
      goto LABEL_8;
    v17 = v16;
    if (((unsigned int (*)(size_t *, void *, _QWORD, _OWORD *, __int128 *))v15[3])(v15, v16, __s, v35, &v28))
    {
      v20 = "init";
      v21 = 991;
    }
    else if (((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v15[5])(v17, a2, a1, a1))
    {
      v20 = "encryption";
      v21 = 992;
    }
    else
    {
      if ((HMACDerive_SHA256(a3, &v30) & 0x80000000) == 0)
      {
        v25 = 0;
        goto LABEL_12;
      }
      v20 = "HMAC";
      v21 = 995;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", v21, 94, 0, v20, v18, v19, v26);
    v25 = 1;
LABEL_12:
    memset_s(v17, v13, 0, v13);
    goto LABEL_13;
  }
  *__error() = 12;
LABEL_8:
  v22 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", 990, 94, *v22, "malloc", v23, v24, v26);
  v17 = 0;
  v25 = 1;
LABEL_13:
  free(v17);
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v30, 0x104uLL, 0, 0x104uLL);
  memset_s(&v27, 0x104uLL, 0, 0x104uLL);
  if (a3)
  {
    if (v25)
      memset_s(a3, 0x104uLL, 0, 0x104uLL);
  }
  return (v25 << 31 >> 31);
}

uint64_t AEADDecrypt_AESCTR_MAC256_KEY640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  size_t *v14;
  rsize_t v15;
  int v17;
  size_t *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  int v29;
  __int128 v30;
  _OWORD v31[15];
  int v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[224];
  unsigned int __s;
  _OWORD v37[2];
  _BYTE v38[224];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  memset(v38, 0, sizeof(v38));
  memset(v35, 0, sizeof(v35));
  memset(v31, 0, sizeof(v31));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1049, 94, 0, "AEAD invalid sizes", a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  v33 = *(_OWORD *)(a4 + 4);
  v34 = *(_OWORD *)(a4 + 20);
  v32 = 32;
  memset_s(v35, 0xE0uLL, 0, 0xE0uLL);
  v37[0] = *(_OWORD *)(a4 + 36);
  v37[1] = *(_OWORD *)(a4 + 52);
  __s = 32;
  memset_s(v38, 0xE0uLL, 0, 0xE0uLL);
  v30 = *(_OWORD *)(a4 + 68);
  v29 = 16;
  memset_s(v31, 0xF0uLL, 0, 0xF0uLL);
  if ((HMACVerify_SHA256(a3, &v32) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1057, 94, 0, "HMAC", v12, v13, v28);
    v17 = 0;
    goto LABEL_16;
  }
  v14 = (size_t *)ccaes_ctr_crypt_mode();
  v15 = *v14;
  if (*v14 < 0x2000000001)
  {
    v18 = v14;
    v19 = malloc(*v14);
    if (!v19)
      goto LABEL_10;
    v20 = v19;
    if (((unsigned int (*)(size_t *, void *, _QWORD, _OWORD *, __int128 *))v18[3])(v18, v19, __s, v37, &v30))
    {
      v23 = "init";
      v24 = 1094;
    }
    else
    {
      if (!((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v18[5])(v20, a2, a1, a1))
      {
        v17 = 1;
        goto LABEL_14;
      }
      v23 = "encryption";
      v24 = 1095;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", v24, 94, 0, v23, v21, v22, v28);
    v17 = 0;
LABEL_14:
    memset_s(v20, v15, 0, v15);
    goto LABEL_15;
  }
  *__error() = 12;
LABEL_10:
  v25 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1093, 94, *v25, "malloc", v26, v27, v28);
  v17 = 0;
  v20 = 0;
LABEL_15:
  free(v20);
LABEL_16:
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v32, 0x104uLL, 0, 0x104uLL);
  memset_s(&v29, 0x104uLL, 0, 0x104uLL);
  if (v17)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ScryptDerive_KEY256(_DWORD *a1, uint64_t a2, unint64_t a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  const char *v15;
  __int16 v16;
  int v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  if (a3 < 0x14 || !*a5)
  {
    v12 = "Invalid password/salt";
    v13 = 823;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", v13, 94, 0, v12, a7, a8, v22);
    return 0xFFFFFFFFLL;
  }
  if (a4 >= 4)
  {
    v12 = "Invalid hardness parameter";
    v13 = 832;
    goto LABEL_8;
  }
  v9 = ccscrypt_storage_size();
  if ((v9 & 0x8000000000000000) != 0)
  {
    v15 = "Invalid scrypt parameters";
    v16 = 842;
    v17 = 0;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", v16, 94, v17, v15, v10, v11, v22);
    v19 = 0;
LABEL_17:
    free(v19);
    if (a1)
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    return 0xFFFFFFFFLL;
  }
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_15:
    v17 = *__error();
    v15 = "malloc";
    v16 = 844;
    goto LABEL_16;
  }
  v18 = malloc(v9);
  if (!v18)
    goto LABEL_15;
  v19 = v18;
  if (ccscrypt())
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", 846, 94, 0, "scrypt", v20, v21, 32);
    goto LABEL_17;
  }
  *a1 = 32;
  memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
  free(v19);
  return 0;
}

uint64_t DHESender_ECDHE_P256(void *a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  size_t v11;
  size_t v12;
  void *v13;
  void *v14;
  BOOL v15;
  BOOL v16;
  void *v17;
  BOOL v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  char v28;

  if (*a3 != 65)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", 581, 94, 0, "ECDHE_P256_Sender invalid sizes", a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  v10 = (_QWORD *)MEMORY[0x20BD243BC]();
  v11 = (32 * *v10) | 0x10;
  v12 = 24 * *v10 + 16;
  if (v11 < 0x2000000001)
  {
    v13 = malloc(v11);
  }
  else
  {
    v13 = 0;
    *__error() = 12;
  }
  if (v12 < 0x2000000001)
  {
    v17 = malloc(v12);
    v14 = v17;
    v15 = v13 == 0;
    v16 = v17 == 0;
    if (v13)
      v18 = v17 == 0;
    else
      v18 = 1;
    if (!v18)
    {
      if (ccec_x963_import_pub())
      {
        v25 = "importing public key";
        v26 = 602;
      }
      else
      {
        ccrng();
        v25 = "RNG lookup";
        v26 = 606;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", v26, 94, 0, v25, v23, v24, 32);
      v16 = 0;
LABEL_21:
      memset_s(v13, v11, 0, v11);
      free(v13);
      if (!v16)
        memset_s(v14, v12, 0, v12);
      goto LABEL_16;
    }
  }
  else
  {
    v14 = 0;
    *__error() = 12;
    v15 = v13 == 0;
    v16 = 1;
  }
  v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", 599, 94, *v19, "malloc", v20, v21, 32);
  if (!v15)
    goto LABEL_21;
  free(v13);
  if (!v16)
    memset_s(v14, v12, 0, v12);
LABEL_16:
  free(v14);
  if (a1)
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  if (a2)
    memset_s(a2, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t DHERecipient_ECDHE_P256(void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  size_t v10;
  size_t v11;
  void *v12;
  void *v14;
  BOOL v15;
  BOOL v16;
  void *v17;
  BOOL v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  char v27;

  if (*a3 != 97 || *a2 != 65)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", 704, 94, 0, "ECDHE_P256_Recipient invalid sizes", a7, a8, v27);
    return 0xFFFFFFFFLL;
  }
  v9 = (_QWORD *)MEMORY[0x20BD243BC]();
  v10 = 24 * *v9 + 16;
  v11 = (32 * *v9) | 0x10;
  if (v10 < 0x2000000001)
  {
    v12 = malloc(v10);
  }
  else
  {
    v12 = 0;
    *__error() = 12;
  }
  if (v11 < 0x2000000001)
  {
    v17 = malloc(v11);
    v14 = v17;
    v15 = v12 == 0;
    v16 = v17 == 0;
    if (v12)
      v18 = v17 == 0;
    else
      v18 = 1;
    if (!v18)
    {
      if (ccec_x963_import_priv())
      {
        v25 = "importing full key";
        v26 = 725;
      }
      else if (ccec_x963_import_pub())
      {
        v25 = "importing pub key";
        v26 = 728;
      }
      else
      {
        ccrng();
        v25 = "RNG lookup";
        v26 = 732;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", v26, 94, 0, v25, v23, v24, 32);
      v16 = 0;
LABEL_25:
      memset_s(v12, v10, 0, v10);
      free(v12);
      if (!v16)
        memset_s(v14, v11, 0, v11);
      goto LABEL_18;
    }
  }
  else
  {
    v14 = 0;
    *__error() = 12;
    v15 = v12 == 0;
    v16 = 1;
  }
  v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", 722, 94, *v19, "malloc", v20, v21, 32);
  if (!v15)
    goto LABEL_25;
  free(v12);
  if (!v16)
    memset_s(v14, v11, 0, v11);
LABEL_18:
  free(v14);
  if (a1)
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t DerivePublicFromPrivate_ECP256(_DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  rsize_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  char v19;

  if (*a2 != 97)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1346, 94, 0, "invalid private key size", a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  v9 = (_QWORD *)MEMORY[0x20BD243BC]();
  v10 = (32 * *v9) | 0x10;
  if (v10 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_9;
  }
  v11 = malloc((32 * *v9) | 0x10);
  if (!v11)
  {
LABEL_9:
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1356, 94, *v15, "malloc", v16, v17, v19);
    if (a1)
LABEL_10:
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    return 0xFFFFFFFFLL;
  }
  v12 = v11;
  if (ccec_x963_import_priv())
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1359, 94, 0, "importing private key", v13, v14, v19);
    memset_s(v12, v10, 0, v10);
    free(v12);
    if (!a1)
      return 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  ccec_x963_export();
  *a1 = 65;
  memset_s((char *)a1 + 69, 0xBFuLL, 0, 0xBFuLL);
  memset_s(v12, v10, 0, v10);
  free(v12);
  return 0;
}

uint64_t Digest_SHA256(uint64_t a1, const void *a2, CC_LONG a3)
{
  CC_SHA256_CTX v7;

  memset(&v7, 0, sizeof(v7));
  CC_SHA256_Init(&v7);
  CC_SHA256_Update(&v7, a2, a3);
  CC_SHA256_Final((unsigned __int8 *)(a1 + 4), &v7);
  *(_DWORD *)a1 = 32;
  return 0;
}

uint64_t DSASign_ECDSA_P256(void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  const char *v10;
  __int16 v11;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  if (*a2 != 97)
  {
    v10 = "invalid private key size";
    v11 = 1154;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", v11, 94, 0, v10, a7, a8, v22);
    return 0xFFFFFFFFLL;
  }
  if (*a3 != 32)
  {
    v10 = "invalid digest size";
    v11 = 1155;
    goto LABEL_7;
  }
  v9 = (32 * *(_QWORD *)MEMORY[0x20BD243BC]()) | 0x10;
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_12;
  }
  v13 = malloc(v9);
  if (!v13)
  {
LABEL_12:
    v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", 1167, 94, *v19, "malloc", v20, v21, v22);
    if (!a1)
      return 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  v14 = v13;
  if (ccec_x963_import_priv())
  {
    v17 = "importing private key";
    v18 = 1170;
  }
  else
  {
    v22 = 0x80;
    if (a1)
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    ccrng();
    v17 = "RNG lookup";
    v18 = 1176;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", v18, 94, 0, v17, v15, v16, v22);
  memset_s(v14, v9, 0, v9);
  free(v14);
  if (a1)
LABEL_18:
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t DSAVerify_ECDSA_P256(unsigned int *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  const char *v10;
  __int16 v11;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;

  if (*a1 == 128)
  {
    if (*a2 == 65)
    {
      if (*a3 == 32)
      {
        v9 = 24 * *(_QWORD *)MEMORY[0x20BD243BC]() + 16;
        if (v9 < 0x2000000001)
        {
          v13 = malloc(v9);
          if (v13)
          {
            v14 = v13;
            if (ccec_x963_import_pub())
            {
              v17 = "importing public key";
              v18 = 1267;
            }
            else
            {
              v22 = *a1;
              if (v22 >= 2 && *((_BYTE *)a1 + 4) == 48)
              {
                if ((unint64_t)*((unsigned __int8 *)a1 + 5) + 2 <= v22)
                {
                  ccec_verify();
                  v17 = "Signature verification";
                  v18 = 1275;
                }
                else
                {
                  v17 = "Invalid signature";
                  v18 = 1272;
                }
              }
              else
              {
                v17 = "Invalid signature";
                v18 = 1270;
              }
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", v18, 94, 0, v17, v15, v16, v23);
            memset_s(v14, v9, 0, v9);
            goto LABEL_21;
          }
        }
        else
        {
          *__error() = 12;
        }
        v19 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", 1264, 94, *v19, "malloc", v20, v21, v23);
        v14 = 0;
LABEL_21:
        free(v14);
        return 0xFFFFFFFFLL;
      }
      v10 = "invalid digest size";
      v11 = 1253;
    }
    else
    {
      v10 = "Invalid public key size";
      v11 = 1252;
    }
  }
  else
  {
    v10 = "Invalid signature size";
    v11 = 1251;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", v11, 94, 0, v10, a7, a8, v23);
  return 0xFFFFFFFFLL;
}

void *HMACInit_SHA256(_DWORD *a1)
{
  void *v1;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char v6;

  if (*a1 != 32)
    return 0;
  ccsha256_di();
  v1 = malloc(0x1F8uLL);
  if (v1)
  {
    cchmac_init();
  }
  else
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HMACInit_SHA256", 388, 94, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

uint64_t HMACUpdate_SHA256(uint64_t a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  ccsha256_di();
  cchmac_update();
  return 0;
}

uint64_t HMACFinal_SHA256(void *a1, _DWORD *a2)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  ccsha256_di();
  cchmac_final();
  *a2 = 32;
  memset_s(a2 + 9, 0xE0uLL, 0, 0xE0uLL);
  memset_s(a1, 0x1F8uLL, 0, 0x1F8uLL);
  free(a1);
  return 0;
}

uint64_t HMACDerive_SHA256(_DWORD *a1, _DWORD *a2)
{
  void *v3;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  if (*a2 != 32)
    return 0xFFFFFFFFLL;
  ccsha256_di();
  v3 = malloc(0x1F8uLL);
  if (v3)
  {
    cchmac_init();
    cchmac_update();
    cchmac_update();
    cchmac_update();
    cchmac_final();
    *a1 = 32;
    memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
    memset_s(v3, 0x1F8uLL, 0, 0x1F8uLL);
    free(v3);
  }
  else
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HMACDerive_SHA256", 271, 94, *v5, "malloc", v6, v7, v8);
    if (a1)
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
  }
  if (v3)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t HMACVerify_SHA256(uint64_t a1, _DWORD *a2)
{
  _BOOL4 v3;
  int v4;
  int v5;
  uint16x4_t v6;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  _OWORD __s[16];
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)a1 != 32 || *a2 != 32;
  v13 = 0;
  memset(__s, 0, sizeof(__s));
  v4 = HMACDerive_SHA256(__s, a2);
  v10 = *(int64x2_t *)((char *)&__s[1] + 4);
  v11 = *(int64x2_t *)((char *)__s + 4);
  v8 = *(int64x2_t *)(a1 + 20);
  v9 = *(int64x2_t *)(a1 + 4);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  v5 = v4 < 0 || v3;
  v6 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v11, v9), (int32x4_t)vceqq_s64(v10, v8))));
  v6.i16[0] = vmaxv_u16(v6);
  return ((v6.i32[0] | v5) << 31 >> 31);
}

AAByteStream AEADecryptionInputStreamOpen(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int DefaultNThreads;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  AAByteStream result;
  uint64_t v20;
  size_t v21;
  int *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  size_t v37;
  void *v38;
  void *v39;
  uint64_t v41;
  compression_algorithm v42;
  size_t v43;
  size_t v44;
  void *v45;
  int *v46;
  void *v47;
  char *v48;
  unsigned int *v49;
  __int128 v50;
  __int128 v51;
  char v52;

  DefaultNThreads = n_threads;
  if (n_threads <= 0)
    DefaultNThreads = getDefaultNThreads();
  if (!*((_DWORD *)context + 684) || !*((_QWORD *)context + 341))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"AEADecryptionInputStreamOpen", 461, 30, 0, "Invalid context", v4, v5, v52);
    v10 = 0;
    v12 = 0;
LABEL_22:
    free(v10);
    aeaInputStreamClose(v12);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v11 = malloc(0x428uLL);
  v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x428uLL, 0, 0x428uLL), !v10))
  {
    v18 = *__error();
    v16 = "malloc";
    v17 = 466;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"AEADecryptionInputStreamOpen", v17, 30, v18, v16, v13, v14, v52);
    goto LABEL_22;
  }
  *(_QWORD *)v12 = encrypted_stream;
  *(_QWORD *)(v12 + 8) = flags;
  if ((aeaContextUnlock((uint64_t)context, v12 + 144, (_DWORD *)(v12 + 788), 0, 1, 0) & 0x80000000) != 0)
  {
    v16 = "unlock container";
    v17 = 473;
    goto LABEL_20;
  }
  v15 = (*(_QWORD *)(v12 + 176) + (unint64_t)*(unsigned int *)(v12 + 160) - 1) / *(unsigned int *)(v12 + 160);
  if (v15 >= 0xFFFFFFFF)
  {
    v16 = "Invalid data size";
    v17 = 477;
LABEL_20:
    v18 = 0;
    goto LABEL_21;
  }
  *(_DWORD *)(v12 + 52) = v15;
  *(_DWORD *)(v12 + 44) = (v15 + *(_DWORD *)(v12 + 164) - 1) / *(_DWORD *)(v12 + 164);
  atomic_store(*((_QWORD *)context + 341), (unint64_t *)(v12 + 32));
  if ((aeaCryptoInit((char *)(v12 + 216), (unsigned int *)(v12 + 144)) & 0x80000000) != 0)
  {
    v16 = "Invalid container";
    v17 = 486;
    goto LABEL_20;
  }
  result = (AAByteStream)aeaContainerOffsetsInit(v12 + 424, (unsigned int *)(v12 + 144), (unsigned int *)(v12 + 216));
  if ((result & 0x80000000) != 0)
  {
    v16 = "deriving container offsets";
    v17 = 487;
    goto LABEL_20;
  }
  v20 = *(unsigned int *)(v12 + 228);
  if (v20 < 0x101)
  {
    __memcpy_chk();
    *(_DWORD *)(v12 + 528) = v20;
    memset_s((void *)(v12 + 532 + v20), 256 - v20, 0, 256 - v20);
    v21 = *(_QWORD *)(v12 + 520);
    *(_QWORD *)(v12 + 1056) = v21;
    if (v21 < 0x2000000001)
    {
      v23 = malloc(v21);
    }
    else
    {
      v22 = __error();
      v23 = 0;
      *v22 = 12;
    }
    *(_QWORD *)(v12 + 1048) = v23;
    if (*(_QWORD *)(v12 + 176) < 0x10000uLL || DefaultNThreads == 1)
    {
      *(_QWORD *)(v12 + 96) = 0;
      v41 = *(unsigned int *)(v12 + 168);
      if ((_DWORD)v41)
      {
        v42 = aeaEffectiveCompressionAlgorithm(v41);
        v43 = compression_decode_scratch_buffer_size(v42);
        *(_QWORD *)(v12 + 96) = v43;
      }
      else
      {
        v43 = 0;
      }
      v44 = *(unsigned int *)(v12 + 160);
      v45 = malloc(v44);
      *(_QWORD *)(v12 + 72) = v45;
      *(_QWORD *)(v12 + 80) = malloc(v44);
      if (v43)
      {
        if (v43 < 0x2000000001)
        {
          v47 = malloc(v43);
        }
        else
        {
          v46 = __error();
          v47 = 0;
          *v46 = 12;
          v45 = *(void **)(v12 + 72);
        }
        *(_QWORD *)(v12 + 88) = v47;
      }
      if (!v45 || !*(_QWORD *)(v12 + 80) || !*(_QWORD *)(v12 + 1048) || *(_QWORD *)(v12 + 96) && !*(_QWORD *)(v12 + 88))
      {
        v18 = *__error();
        v16 = "malloc";
        v17 = 513;
        goto LABEL_21;
      }
    }
    else
    {
      *(_DWORD *)(v12 + 112) = DefaultNThreads;
      v24 = calloc(DefaultNThreads, 8uLL);
      *(_QWORD *)(v12 + 120) = v24;
      if (!v24)
      {
        v18 = *__error();
        v16 = "malloc";
        v17 = 520;
        goto LABEL_21;
      }
      v32 = *(unsigned int *)(v12 + 112);
      if ((_DWORD)v32)
      {
        v33 = 0;
        v34 = 8 * v32;
        while (1)
        {
          v35 = malloc(0x240uLL);
          if (!v35)
          {
            v18 = *__error();
            v16 = "malloc";
            v17 = 524;
            goto LABEL_21;
          }
          v36 = v35;
          *(_QWORD *)(*(_QWORD *)(v12 + 120) + v33) = v35;
          *v35 = v12;
          v37 = *(unsigned int *)(v12 + 160);
          v38 = malloc(v37);
          v36[69] = v38;
          v39 = malloc(v37);
          v36[70] = v39;
          if (!v38 || v39 == 0)
            break;
          v33 += 8;
          if (v34 == v33)
            goto LABEL_53;
        }
        v18 = *__error();
        v16 = "malloc";
        v17 = 529;
        goto LABEL_21;
      }
      LODWORD(v37) = *(_DWORD *)(v12 + 160);
LABEL_53:
      v48 = SharedBufferCreate((2 * v37), v25, v26, v27, v28, v29, v30, v31);
      *(_QWORD *)(v12 + 104) = v48;
      if (!v48)
      {
        v16 = "creating shared buffer";
        v17 = 532;
        goto LABEL_20;
      }
      v49 = ThreadPipelineCreate(*(_DWORD *)(v12 + 112), *(_QWORD *)(v12 + 120), (uint64_t)streamWorkerProc, v12, (uint64_t)streamConsumerProc, 0);
      *(_QWORD *)(v12 + 128) = v49;
      if (!v49)
      {
        v16 = "creating pipeline";
        v17 = 534;
        goto LABEL_20;
      }
      if ((createThread((pthread_t *)(v12 + 136), (uint64_t)streamThreadProc, v12, 0) & 0x80000000) != 0)
      {
        v16 = "Stream thread creation";
        v17 = 535;
        goto LABEL_20;
      }
    }
    v50 = *(_OWORD *)(v12 + 192);
    *((_OWORD *)context + 2) = *(_OWORD *)(v12 + 176);
    *((_OWORD *)context + 3) = v50;
    *((_QWORD *)context + 8) = *(_QWORD *)(v12 + 208);
    v51 = *(_OWORD *)(v12 + 160);
    *(_OWORD *)context = *(_OWORD *)(v12 + 144);
    *((_OWORD *)context + 1) = v51;
    v10[7] = aeaInputStreamCancel;
    *v10 = v12;
    v10[1] = aeaInputStreamClose;
    v10[2] = aeaInputStreamRead;
    return (AAByteStream)v10;
  }
  __break(1u);
  return result;
}

uint64_t streamWorkerProc(uint64_t a1)
{
  AAByteStream *v1;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  v1 = *(AAByteStream **)a1;
  if (atomic_load((unsigned int *)(*(_QWORD *)a1 + 16)))
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a1 + 568))
  {
    v4 = (_DWORD *)(a1 + 8);
    if ((aeaInputStreamDecryptSegment(*(_QWORD *)a1, (unsigned int *)(a1 + 8), *(const uint8_t **)(a1 + 552), *(uint8_t **)(a1 + 560)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamWorkerProc", 298, 30, 0, "decrypting segment %u", v5, v6, *v4);
      aeaInputStreamCancel(v1, v7, v8, v9, v10, v11, v12, v13, v14);
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t streamConsumerProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int *v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  char v24;

  if (atomic_load((unsigned int *)(a1 + 16)))
    return 0xFFFFFFFFLL;
  v11 = (unsigned int *)(a1 + 24);
  if (atomic_load((unsigned int *)(a1 + 24)))
    return 0;
  if (*(_DWORD *)(a2 + 568))
  {
    while (!__ldaxr(v11))
    {
      if (!__stlxr(1u, v11))
      {
        SharedBufferWrite(*(unsigned int **)(a1 + 104), 0, 0, a4, a5, a6, a7, a8);
        return 0;
      }
    }
    result = 0;
    __clrex();
  }
  else if (SharedBufferWrite(*(unsigned int **)(a1 + 104), *(_QWORD *)(a2 + 560), *(unsigned int *)(a2 + 12), a4, a5, a6, a7, a8) == *(_DWORD *)(a2 + 12))
  {
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamConsumerProc", 321, 30, 0, "SharedBufferWrite", v14, v15, v23);
    aeaInputStreamCancel((AAByteStream *)a1, v16, v17, v18, v19, v20, v21, v22, v24);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t streamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t Worker;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  __int16 v41;
  char v43;

  if (*(_DWORD *)(a1 + 52))
  {
    v9 = 0;
    v10 = 1;
    while (1)
    {
      v11 = atomic_load((unsigned int *)(a1 + 16));
      if (v11 || (v12 = atomic_load((unsigned int *)(a1 + 20))) != 0)
      {
LABEL_13:
        if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52))
          goto LABEL_16;
        goto LABEL_17;
      }
      Worker = ThreadPipelineGetWorker(*(_QWORD *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
      if (!Worker)
      {
        v40 = "getting worker from pipeline";
        v41 = 263;
        goto LABEL_26;
      }
      v14 = Worker;
      *(_DWORD *)(Worker + 568) = 0;
      v15 = (_DWORD *)(Worker + 8);
      memset_s((void *)(Worker + 8), 0x220uLL, 0, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, v15, *(_QWORD *)(v14 + 552), v16, v17, v18, v19, v20) & 0x80000000) != 0)
        break;
      if (!v10)
        goto LABEL_10;
LABEL_11:
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 68);
      if ((ThreadPipelineRunWorker(*(_QWORD *)(a1 + 128), v14, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0)
      {
        v40 = "running worker";
        v41 = 269;
        goto LABEL_26;
      }
      if (++v9 >= *(_DWORD *)(a1 + 52))
        goto LABEL_13;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamThreadProc", 266, 30, 0, "loading segment", v25, v26, v43);
LABEL_10:
    memset_s(v15, 0x220uLL, 0, 0x220uLL);
    v10 = 0;
    goto LABEL_11;
  }
  v10 = 1;
LABEL_16:
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    v40 = "authenticating padding";
    v41 = 275;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamThreadProc", v41, 30, 0, v40, a7, a8, v43);
LABEL_27:
    aeaInputStreamCancel((AAByteStream *)a1, v35, v36, v37, v38, v39, a7, a8, v43);
    return a1;
  }
LABEL_17:
  v27 = ThreadPipelineGetWorker(*(_QWORD *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
  if (!v27)
  {
    v40 = "getting worker from pipeline";
    v41 = 280;
    goto LABEL_26;
  }
  v28 = v27;
  *(_DWORD *)(v27 + 568) = 1;
  memset_s((void *)(v27 + 8), 0x220uLL, 0, 0x220uLL);
  if ((ThreadPipelineRunWorker(*(_QWORD *)(a1 + 128), v28, v29, v30, v31, v32, v33, v34) & 0x80000000) != 0)
  {
    v40 = "running worker";
    v41 = 283;
    goto LABEL_26;
  }
  if (!v10)
    goto LABEL_27;
  return a1;
}

uint64_t aeaInputStreamRead(uint64_t a1, uint64_t __dst, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  size_t v11;
  char *v12;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  size_t v34;
  unsigned int *v35;
  char v38;
  char v39;
  unsigned int __s[136];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if (atomic_load((unsigned int *)(a1 + 16)))
    return -1;
  v11 = a3;
  if (!a3)
    return 0;
  v12 = (char *)__dst;
  v14 = *(_QWORD *)(a1 + 104);
  if (v14)
  {
    v9 = SharedBufferRead(v14, __dst, a3);
    if ((v9 & 0x8000000000000000) == 0)
      return v9;
    v17 = "Multi-thread read";
    v18 = 353;
    goto LABEL_8;
  }
  v9 = 0;
  v26 = *(_DWORD *)(a1 + 64);
  do
  {
    v27 = *(_DWORD *)(a1 + 68);
    if (v26 >= v27)
    {
      if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52))
        break;
      bzero(__s, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, __s, *(_QWORD *)(a1 + 72), v28, v29, v30, v31, v32) & 0x80000000) != 0)
      {
        v17 = "Segment load";
        v18 = 365;
        goto LABEL_8;
      }
      if ((aeaInputStreamDecryptSegment(a1, __s, *(const uint8_t **)(a1 + 72), *(uint8_t **)(a1 + 80)) & 0x80000000) != 0)
      {
        v17 = "Segment decrypt";
        v18 = 366;
        goto LABEL_8;
      }
      memset_s(__s, 0x220uLL, 0, 0x220uLL);
      v26 = *(_DWORD *)(a1 + 64);
      v27 = *(_DWORD *)(a1 + 68);
    }
    v33 = v27 - v26;
    if (v33 >= v11)
      v34 = v11;
    else
      v34 = v33;
    if (!v34)
      break;
    memcpy(v12, (const void *)(*(_QWORD *)(a1 + 80) + v26), v34);
    v9 += v34;
    v12 += v34;
    v26 = *(_DWORD *)(a1 + 64) + v34;
    *(_DWORD *)(a1 + 64) = v26;
    v11 -= v34;
  }
  while (v11);
  if (v9)
    return v9;
  v35 = (unsigned int *)(a1 + 28);
  if (atomic_load((unsigned int *)(a1 + 28)))
    return 0;
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, __dst, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    v17 = "Padding authentication";
    v18 = 385;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamRead", v18, 30, 0, v17, v15, v16, v38);
    aeaInputStreamCancel((AAByteStream *)a1, v19, v20, v21, v22, v23, v24, v25, v39);
    return -1;
  }
  v9 = 0;
  while (!__ldaxr(v35))
  {
    if (!__stlxr(1u, v35))
      return v9;
  }
  v9 = 0;
  __clrex();
  return v9;
}

AAByteStream *aeaInputStreamCancel(AAByteStream *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  AAByteStream *v9;
  unsigned int *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v9 = result;
  v10 = (unsigned int *)(result + 2);
  do
  {
    if (__ldaxr(v10))
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v10));
  AAByteStreamCancel(*result);
  result = (AAByteStream *)v9[13];
  if (result)
    return (AAByteStream *)SharedBufferAbort((size_t)result, v12, v13, v14, v15, v16, v17, v18, a9);
  return result;
}

uint64_t aeaInputStreamClose(uint64_t result)
{
  uint64_t v1;
  unsigned int *v2;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unint64_t v7;
  unint64_t i;
  void **v9;
  unsigned int v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  char v15;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 136))
    {
      v2 = (unsigned int *)(result + 20);
      while (!__ldaxr(v2))
      {
        if (!__stlxr(1u, v2))
          goto LABEL_8;
      }
      __clrex();
LABEL_8:
      while (SharedBufferFlushToStream(*(_QWORD *)(v1 + 104), 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))sharedBufferWriteToDrain, 0) > 0);
      joinThread(*(_opaque_pthread_t **)(v1 + 136));
    }
    ThreadPipelineDestroy(*(_QWORD *)(v1 + 128));
    SharedBufferDestroy(*(_QWORD *)(v1 + 104));
    v6 = *(void **)(v1 + 120);
    if (v6)
    {
      v7 = *(unsigned int *)(v1 + 112);
      if ((_DWORD)v7)
      {
        for (i = 0; i < v7; ++i)
        {
          v9 = *(void ***)(*(_QWORD *)(v1 + 120) + 8 * i);
          if (v9)
          {
            free(v9[69]);
            free(v9[70]);
            free(v9);
            v7 = *(unsigned int *)(v1 + 112);
          }
        }
        v6 = *(void **)(v1 + 120);
      }
      free(v6);
    }
    v10 = atomic_load((unsigned int *)(v1 + 16));
    if (v10)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamClose", 438, 30, 0, "Stream processing cancelled", v4, v5, v15);
    v11 = *(void **)(v1 + 1048);
    if (v11)
      memset_s(*(void **)(v1 + 1048), *(_QWORD *)(v1 + 1056), 0, *(_QWORD *)(v1 + 1056));
    free(v11);
    v12 = *(void **)(v1 + 72);
    if (v12)
      memset_s(*(void **)(v1 + 72), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    free(v12);
    v13 = *(void **)(v1 + 80);
    if (v13)
      memset_s(*(void **)(v1 + 80), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    free(v13);
    v14 = *(void **)(v1 + 88);
    if (v14)
      memset_s(*(void **)(v1 + 88), *(_QWORD *)(v1 + 96), 0, *(_QWORD *)(v1 + 96));
    free(v14);
    memset_s((void *)v1, 0x428uLL, 0, 0x428uLL);
    free((void *)v1);
    if (v10)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t aeaInputStreamDecryptSegment(uint64_t a1, unsigned int *a2, const uint8_t *a3, uint8_t *a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t (*v10)(_OWORD *, _QWORD);
  int v11;
  int v12;
  uint64_t v13;
  uint64_t (*v14)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *);
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(const uint8_t *, uint64_t);
  uint64_t v19;
  size_t v20;
  size_t v21;
  int64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  compression_algorithm v30;
  char v31;
  _OWORD v33[16];
  int v34;
  _OWORD v35[16];
  int v36;
  _OWORD v37[16];
  int v38;
  _OWORD v39[17];
  _BYTE __s[260];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v36 = 0;
  memset(v35, 0, sizeof(v35));
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  v7 = a2[2];
  v8 = *a2;
  v9 = *(_DWORD *)(a1 + 164);
  v38 = 0;
  memset(v37, 0, sizeof(v37));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(_QWORD *)__s = 0x5F41454100000006;
  memset(v39, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v8 / v9;
  *(_DWORD *)__s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  v10 = *(uint64_t (**)(_OWORD *, _QWORD))(a1 + 288);
  if (v10 && *(_DWORD *)(a1 + 788))
  {
    v11 = v10(v37, *(unsigned int *)(a1 + 216));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    v12 = 0;
    if ((v11 & 0x80000000) == 0)
      goto LABEL_8;
  }
  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  v12 = 1;
LABEL_8:
  memset((char *)v39 + 8, 0, 224);
  memset((char *)&v39[14] + 8, 0, 28);
  WORD4(v39[0]) = 19283;
  *(_QWORD *)&v39[0] = 0x5F41454100000006;
  memset_s((char *)v39 + 10, 0xFAuLL, 0, 0xFAuLL);
  v13 = LODWORD(v39[0]);
  if (LODWORD(v39[0]) >= 0xFD)
    __break(1u);
  *(_DWORD *)((char *)v39 + LODWORD(v39[0]) + 4) = v8 % v9;
  LODWORD(v39[0]) = v13 + 4;
  memset_s((char *)v39 + v13 + 8, 252 - v13, 0, 252 - v13);
  memset(__s, 0, sizeof(__s));
  v14 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *))(a1 + 288);
  if (!v14 || !LODWORD(v37[0]))
  {
    memset_s(v39, 0x104uLL, 0, 0x104uLL);
    goto LABEL_23;
  }
  v15 = v14(v35, *(unsigned int *)(a1 + 220), v37, v39, __s);
  memset_s(v39, 0x104uLL, 0, 0x104uLL);
  if (v15 < 0)
  {
LABEL_23:
    memset_s(v37, 0x104uLL, 0, 0x104uLL);
    goto LABEL_24;
  }
  memset_s(v37, 0x104uLL, 0, 0x104uLL);
  if (v12)
  {
LABEL_24:
    v26 = "derivating segment key";
    v27 = 122;
    goto LABEL_25;
  }
  v18 = *(uint64_t (**)(const uint8_t *, uint64_t))(a1 + 312);
  if (v18 && a2[71] == *(_DWORD *)(a1 + 228) && (v18(a3, v7) & 0x80000000) == 0)
  {
    v19 = *(unsigned int *)(a1 + 168);
    v20 = a2[1];
    if ((_DWORD)v19 && (v21 = a2[2], v20 > v21))
    {
      if ((_DWORD)v19 == 774)
      {
        v22 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 160), a3, v21);
        if (v22 >= 0)
          v25 = v22;
        else
          v25 = 0;
      }
      else
      {
        v30 = aeaEffectiveCompressionAlgorithm(v19);
        v25 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 160), a3, a2[2], *(void **)(a1 + 88), v30);
      }
    }
    else
    {
      memcpy(a4, a3, v20);
      v25 = a2[1];
    }
    if (v25 == a2[1])
    {
      if ((aeaChecksum((uint64_t)v33, *(_DWORD *)(a1 + 156), a4, v25, v23, v24, v16, v17) & 0x80000000) == 0)
      {
        v28 = 0;
        goto LABEL_26;
      }
      v26 = "computing segment checksum";
      v27 = 151;
    }
    else
    {
      v26 = "Segment decompression";
      v27 = 148;
    }
  }
  else
  {
    v26 = "decrypting segment";
    v27 = 125;
  }
LABEL_25:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamDecryptSegment", v27, 30, 0, v26, v16, v17, v31);
  v28 = 0xFFFFFFFFLL;
LABEL_26:
  memset_s(v35, 0x104uLL, 0, 0x104uLL);
  memset_s(v33, 0x104uLL, 0, 0x104uLL);
  return v28;
}

uint64_t aeaInputStreamLoadSegment(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  uint64_t (*v22)(_OWORD *, _QWORD);
  int v23;
  int v24;
  const char *v25;
  __int16 v26;
  uint64_t (*v27)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *);
  int v28;
  uint64_t (*v29)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD, _QWORD);
  uint64_t v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  int v44;
  _OWORD v45[16];
  int v46;
  _OWORD v47[16];
  int v48;
  _OWORD v49[17];
  _BYTE __s[260];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(result + 64) < *(_DWORD *)(result + 68))
  {
    v8 = "Truncated segment";
    v9 = 168;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamLoadSegment", v9, 30, 0, v8, a7, a8, v45[0]);
    return 0xFFFFFFFFLL;
  }
  v10 = result;
  if (*(_DWORD *)(result + 48) >= *(_DWORD *)(result + 52))
    return 0;
  v13 = *(_DWORD *)(result + 60);
  if (*(_DWORD *)(result + 56) >= v13)
  {
    v46 = 0;
    memset(v45, 0, sizeof(v45));
    if (*(_DWORD *)(result + 40) >= *(_DWORD *)(result + 44))
    {
LABEL_39:
      if (!v13)
      {
LABEL_41:
        v8 = "Invalid state";
        v9 = 177;
        goto LABEL_3;
      }
      goto LABEL_40;
    }
    v14 = *(_QWORD *)result;
    v15 = *(_QWORD *)(result + 520);
    if (*(_QWORD *)(*(_QWORD *)result + 16))
    {
      if (!v15)
        goto LABEL_19;
      v16 = 0;
      v17 = *(_QWORD *)(result + 1048);
      while (1)
      {
        v18 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v14 + 16))(*(_QWORD *)v14, v17, v15);
        if (v18 < 0)
          break;
        if (v18)
        {
          v17 += v18;
          v16 += v18;
          v15 -= v18;
          if (v15)
            continue;
        }
        goto LABEL_17;
      }
      v16 = v18;
LABEL_17:
      v15 = *(_QWORD *)(v10 + 520);
    }
    else
    {
      v16 = -1;
    }
    if (v16 != v15)
    {
      v25 = "loading cluster header";
      v26 = 86;
      goto LABEL_58;
    }
LABEL_19:
    v19 = (unint64_t *)(v10 + 32);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + v15, v19));
    v21 = *(_DWORD *)(v10 + 40);
    v48 = 0;
    memset(v47, 0, sizeof(v47));
    memset(&__s[8], 0, 252);
    *(_WORD *)&__s[8] = 19267;
    memset(v49, 0, 260);
    memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
    *(_DWORD *)&__s[10] = v21;
    *(_QWORD *)__s = 0x5F4145410000000ALL;
    memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
    v22 = *(uint64_t (**)(_OWORD *, _QWORD))(v10 + 288);
    if (v22 && *(_DWORD *)(v10 + 788))
    {
      v23 = v22(v47, *(unsigned int *)(v10 + 216));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      v24 = 0;
      if ((v23 & 0x80000000) == 0)
      {
LABEL_28:
        memset((char *)v49 + 12, 0, 248);
        *(_QWORD *)((char *)v49 + 4) = 0x4B4548435F414541;
        LODWORD(v49[0]) = 8;
        memset_s((char *)v49 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(__s, 0, sizeof(__s));
        v27 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *))(v10 + 288);
        if (v27 && LODWORD(v47[0]))
        {
          v28 = v27(v45, *(unsigned int *)(v10 + 220), v47, v49, __s);
          memset_s(v49, 0x104uLL, 0, 0x104uLL);
          if ((v28 & 0x80000000) == 0)
          {
            memset_s(v47, 0x104uLL, 0, 0x104uLL);
            if (!v24)
            {
              v29 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD, _QWORD))(v10 + 312);
              if (v29)
              {
                if (*(_DWORD *)(v10 + 528) == *(_DWORD *)(v10 + 228))
                {
                  result = v29(*(_QWORD *)(v10 + 1048), *(_QWORD *)(v10 + 504), v10 + 528, v45, *(_QWORD *)(v10 + 1048) + *(_QWORD *)(v10 + 504), *(_QWORD *)(v10 + 520) - *(_QWORD *)(v10 + 504));
                  if ((result & 0x80000000) == 0)
                  {
                    v30 = *(unsigned int *)(v10 + 228);
                    if (v30 >= 0x101)
                    {
LABEL_66:
                      __break(1u);
                      return result;
                    }
                    memcpy((void *)(v10 + 532), (const void *)(*(_QWORD *)(v10 + 1048) + *(_QWORD *)(v10 + 504)), *(unsigned int *)(v10 + 228));
                    *(_DWORD *)(v10 + 528) = v30;
                    memset_s((void *)(v10 + 532 + v30), 256 - v30, 0, 256 - v30);
                    ++*(_DWORD *)(v10 + 40);
                    v31 = *(_DWORD *)(v10 + 164);
                    if (v31 >= *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48))
                      v31 = *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48);
                    *(_DWORD *)(v10 + 56) = 0;
                    *(_DWORD *)(v10 + 60) = v31;
                    *(_QWORD *)(v10 + 64) = 0;
                    result = memset_s(v45, 0x104uLL, 0, 0x104uLL);
                    v13 = *(_DWORD *)(v10 + 60);
                    goto LABEL_39;
                  }
                }
              }
              v25 = "decrypting cluster";
              v26 = 95;
LABEL_58:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamUnlockCluster", v26, 30, 0, v25, a7, a8, v45[0]);
              memset_s(v45, 0x104uLL, 0, 0x104uLL);
              v8 = "unlocking next cluster";
              v9 = 174;
              goto LABEL_3;
            }
LABEL_57:
            v25 = "derivating cluster key";
            v26 = 90;
            goto LABEL_58;
          }
        }
        else
        {
          memset_s(v49, 0x104uLL, 0, 0x104uLL);
        }
        memset_s(v47, 0x104uLL, 0, 0x104uLL);
        goto LABEL_57;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    v24 = 1;
    goto LABEL_28;
  }
LABEL_40:
  if (v13 > *(_DWORD *)(v10 + 164))
    goto LABEL_41;
  v32 = *(_QWORD *)(v10 + 496)
      + *(unsigned int *)(v10 + 56) * (unint64_t)(*(_DWORD *)(v10 + 192) + 8);
  *a2 = *(_DWORD *)(v10 + 48);
  a2[1] = *(_DWORD *)(*(_QWORD *)(v10 + 1048) + v32);
  a2[2] = *(_DWORD *)(v32 + *(_QWORD *)(v10 + 1048) + 4);
  v33 = *(unsigned int *)(v10 + 192);
  if (v33 >= 0x101)
    goto LABEL_66;
  memcpy(a2 + 7, (const void *)(v32 + *(_QWORD *)(v10 + 1048) + 8), *(unsigned int *)(v10 + 192));
  a2[6] = v33;
  result = memset_s((char *)a2 + v33 + 28, 256 - v33, 0, 256 - v33);
  v34 = *(unsigned int *)(v10 + 228);
  if (v34 >= 0x101)
    goto LABEL_66;
  memcpy(a2 + 72, (const void *)(*(_QWORD *)(v10 + 1048) + *(_QWORD *)(v10 + 512) + (*(_DWORD *)(v10 + 56) * v34)), *(unsigned int *)(v10 + 228));
  a2[71] = v34;
  memset_s((char *)a2 + v34 + 288, 256 - v34, 0, 256 - v34);
  v35 = a2[1];
  v36 = *(_DWORD *)(v10 + 160);
  if (v35 > v36 || (v37 = a2[2], v37 > v35) || v37 > v36)
  {
    v8 = "Invalid segment sizes";
    v9 = 194;
    goto LABEL_3;
  }
  v38 = *(_QWORD *)v10;
  if (!*(_QWORD *)(*(_QWORD *)v10 + 16))
    goto LABEL_64;
  v39 = 0;
  if ((_DWORD)v37)
  {
    v40 = a2[2];
    while (1)
    {
      v41 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v38 + 16))(*(_QWORD *)v38, a3, v40);
      if (v41 < 0)
        break;
      if (v41)
      {
        a3 += v41;
        v39 += v41;
        v40 -= v41;
        if (v40)
          continue;
      }
      goto LABEL_60;
    }
    v39 = v41;
  }
LABEL_60:
  if (v39 != v37)
  {
LABEL_64:
    v8 = "reading segment data";
    v9 = 198;
    goto LABEL_3;
  }
  v42 = (unint64_t *)(v10 + 32);
  do
    v43 = __ldaxr(v42);
  while (__stlxr(v43 + v37, v42));
  result = 0;
  ++*(_DWORD *)(v10 + 48);
  ++*(_DWORD *)(v10 + 56);
  v44 = a2[1];
  *(_DWORD *)(v10 + 64) = 0;
  *(_DWORD *)(v10 + 68) = v44;
  return result;
}

uint64_t aeaInputStreamAuthenticatePadding(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  char *v15;
  unint64_t v17;
  unint64_t v18;
  uint64_t (*v19)(__int128 *, _QWORD);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, char *, uint64_t);
  unint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, __int128 *);
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  __int16 v38;
  char v39;
  uint64_t v40;
  _OWORD v41[16];
  int v42;
  __int128 __s;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)a1 + 12) < *((_DWORD *)a1 + 13))
  {
    v8 = "Invalid state";
    v9 = 220;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", v9, 30, 0, v8, a7, a8, v39);
    v14 = 0;
    v15 = 0;
    goto LABEL_6;
  }
  v11 = (unint64_t *)(a1 + 4);
  v12 = atomic_load((unint64_t *)a1 + 4);
  v13 = a1[23];
  if (v12 > v13)
  {
    v8 = "Invalid container offset";
    v9 = 221;
    goto LABEL_5;
  }
  v17 = atomic_load(v11);
  v18 = v13 - v17;
  if (v13 == v17)
  {
    v15 = 0;
    v14 = 1;
    goto LABEL_6;
  }
  v15 = (char *)malloc(0x100000uLL);
  if (!v15)
  {
    v31 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 227, 30, *v31, "malloc", v32, v33, v39);
    v14 = 0;
    goto LABEL_6;
  }
  v59 = 0;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  __s = 0u;
  v44 = 0u;
  v42 = 0;
  memset(v41, 0, sizeof(v41));
  if (a1[49]
    && (*(_DWORD *)((char *)v41 + 7) = 1262571615,
        *(_QWORD *)&v41[0] = 0x5F41454100000007,
        memset_s((void *)((unint64_t)v41 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (v19 = (uint64_t (*)(__int128 *, _QWORD))a1[36]) != 0)
    && *((_DWORD *)a1 + 197)
    && (v19(&__s, *((unsigned int *)a1 + 54)) & 0x80000000) == 0)
  {
    v20 = ((uint64_t (*)(__int128 *))a1[49])(&__s);
  }
  else
  {
    v20 = 0;
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v41, 0x104uLL, 0, 0x104uLL);
  if (v20)
  {
    v40 = v20;
    v14 = 1;
    while (1)
    {
      v23 = v18 >= 0x100000 ? 0x100000 : v18;
      v24 = *a1;
      if (!*(_QWORD *)(*a1 + 16))
        break;
      v25 = 0;
      v26 = v15;
      v27 = v23;
      while (1)
      {
        v28 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(v24 + 16))(*(_QWORD *)v24, v26, v27);
        if (v28 < 0)
          break;
        if (v28)
        {
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (v27)
            continue;
        }
        goto LABEL_30;
      }
      v25 = v28;
LABEL_30:
      if (v25 != v23)
        break;
      v29 = (uint64_t (*)(uint64_t, char *, uint64_t))a1[50];
      if (!v29 || (v29(v40, v15, v23) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 240, 30, 0, "authenticating padding", v21, v22, v39);
        v14 = 0;
      }
      do
        v30 = __ldaxr(v11);
      while (__stlxr(v30 + v23, v11));
      v18 -= v23;
      if (!v18)
        goto LABEL_39;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 239, 30, 0, "reading padding", v21, v22, v39);
    v14 = 0;
LABEL_39:
    v59 = 0;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    __s = 0u;
    v44 = 0u;
    v34 = (uint64_t (*)(uint64_t, __int128 *))a1[51];
    if (v34)
    {
      if (*((_DWORD *)a1 + 132) == *((_DWORD *)a1 + 57)
        && (v34(v40, &__s) & 0x80000000) == 0
        && (_DWORD)__s == *((_DWORD *)a1 + 57))
      {
        if (__s < 8)
          goto LABEL_51;
        v35 = 0;
        v36 = 0;
        do
        {
          v36 |= *(_QWORD *)((char *)&__s + v35 * 8 + 4) ^ *(uint64_t *)((char *)&a1[v35 + 66] + 4);
          v37 = v35 * 8 + 16;
          ++v35;
        }
        while (v37 <= __s);
        if (!v36)
        {
LABEL_51:
          memset_s(&__s, 0x104uLL, 0, 0x104uLL);
          goto LABEL_50;
        }
      }
    }
    memset_s(&__s, 0x104uLL, 0, 0x104uLL);
    v38 = 245;
  }
  else
  {
    v38 = 230;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", v38, 30, 0, "authenticating padding", v21, v22, v39);
  v14 = 0;
LABEL_50:
  memset_s(v15, 0x100000uLL, 0, 0x100000uLL);
LABEL_6:
  free(v15);
  if (v14)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sharedBufferWriteToDrain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

_QWORD *aaCacheStreamOpen(AAByteStream_impl *a1, unint64_t a2, int a3, int a4, unint64_t a5)
{
  _QWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  off_t v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v35;

  v10 = calloc(1uLL, 0x68uLL);
  v11 = calloc(1uLL, 0x70uLL);
  v14 = (uint64_t)v11;
  if (!v11 || !v10)
  {
    v18 = *__error();
    v16 = "aaCalloc";
    v17 = 472;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamOpen", v17, 146, v18, v16, v12, v13, v35);
    free(v10);
    aaCacheStreamClose(v14, v27, v28, v29, v30, v31, v32, v33);
    return 0;
  }
  *(_QWORD *)v11 = a1;
  v11[26] = a4;
  v11[27] = a5 >> 62;
  v15 = ((1 << a3) - 1);
  v11[23] = 1 << a3;
  v11[24] = v15;
  v11[21] = (v15 | a2) >> a3;
  v11[22] = a3;
  if (a2 - 1073741825 <= 0xFFFFFFFFBFFFFFFFLL)
  {
    v16 = "cache too big";
    v17 = 484;
LABEL_17:
    v18 = 0;
    goto LABEL_18;
  }
  v19 = AAByteStreamSeek(a1, 0, 2);
  *(_QWORD *)(v14 + 24) = v19;
  *(_QWORD *)(v14 + 32) = v19;
  if (v19 < 0)
  {
    v16 = "AAByteStreamSeek";
    v17 = 488;
    goto LABEL_17;
  }
  v20 = *(unsigned int *)(v14 + 84);
  if (v20 >= 0xCCCCCCCD)
  {
    *__error() = 12;
    *(_QWORD *)(v14 + 72) = 0;
LABEL_16:
    v16 = "aaCalloc";
    v17 = 492;
    goto LABEL_17;
  }
  v21 = calloc(v20, 0x28uLL);
  *(_QWORD *)(v14 + 72) = v21;
  if (!v21)
    goto LABEL_16;
  if (*(_DWORD *)(v14 + 84))
  {
    v22 = 0;
    v23 = 0;
    v24 = *(unsigned int *)(v14 + 92);
    while (1)
    {
      v25 = calloc(1uLL, v24);
      v26 = *(_QWORD *)(v14 + 72) + v22;
      *(_QWORD *)(v26 + 16) = v25;
      if (!v25)
        break;
      bzero(v25, *(unsigned int *)(v14 + 92));
      *(_QWORD *)v26 = -1;
      v24 = *(unsigned int *)(v14 + 92);
      *(_DWORD *)(v26 + 28) = 0;
      *(_DWORD *)(v26 + 32) = 0;
      *(_DWORD *)(v26 + 24) = v24;
      ++v23;
      v22 += 40;
      if (v23 >= *(unsigned int *)(v14 + 84))
        goto LABEL_15;
    }
    v16 = "aaCalloc";
    v17 = 498;
    goto LABEL_17;
  }
LABEL_15:
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetSeekProc((AAByteStream)v10, (AAByteStreamSeekProc)aaCacheStreamSeek);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)aaCacheStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)aaCacheStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v10, (AAByteStreamReadProc)aaCacheStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v10, (AAByteStreamWriteProc)aaCacheStreamWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)aaCacheStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)aaCacheStreamClose);
  v10[8] = aaCacheStreamTruncate;
  return v10;
}

uint64_t aaCacheStreamSeek(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  char vars0;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  if (a3)
  {
    if (a3 == 2)
    {
      v8 = (_QWORD *)(a1 + 24);
    }
    else
    {
      if (a3 != 1)
      {
LABEL_10:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamSeek", 392, 146, 0, "bad seek", a7, a8, vars0);
        return -1;
      }
      v8 = (_QWORD *)(a1 + 16);
    }
    a2 += *v8;
  }
  if (a2 < 0)
    goto LABEL_10;
  *(_QWORD *)(a1 + 16) = a2;
  return a2;
}

uint64_t aaCacheStreamPRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  int64_t v13;
  unint64_t v14;
  unint64_t v16;
  size_t v17;
  __int128 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v29;
  __int16 v30;
  char v31;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  v9 = a4;
  v11 = *(_QWORD *)(a1 + 24);
  v12 = v11 <= a4;
  v13 = v11 - a4;
  if (v12)
    return 0;
  if (v13 >= a3)
    v14 = a3;
  else
    v14 = v13;
  if (v14)
  {
    v8 = 0;
    while (1)
    {
      v16 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v9 & v16) >= v14)
        v17 = v14;
      else
        v17 = *(unsigned int *)(a1 + 92) - (v9 & v16);
      v18 = cachePageGet(a1, v9 & ~v16, a3, a4, a5, a6, a7, a8);
      if (!v18)
      {
        v29 = "cachePageGet";
        v30 = 224;
        goto LABEL_25;
      }
      v25 = v18;
      v26 = v16 & v9;
      if ((v26 < *((_DWORD *)v18 + 6) || (v26 + v17) > *((_DWORD *)v18 + 7))
        && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v18, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        break;
      }
      memcpy(a2, (const void *)(*((_QWORD *)v25 + 2) + v26), v17);
      ++*(_QWORD *)(a1 + 40);
      v27 = *(_QWORD *)(a1 + 8) + 1;
      *(_QWORD *)(a1 + 8) = v27;
      *((_QWORD *)v25 + 1) = v27;
      if ((v17 & 0x8000000000000000) != 0)
        goto LABEL_26;
      v8 += v17;
      a2 += v17;
      v9 += v17;
      v14 -= v17;
      if (!v14)
        goto LABEL_21;
    }
    v29 = "cachePageReadFromDisk";
    v30 = 229;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheRead", v30, 146, 0, v29, v23, v24, v31);
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPRead", 313, 146, 0, "cacheRead", a7, a8, v31);
    return -1;
  }
  v8 = 0;
LABEL_21:
  *(_QWORD *)(a1 + 16) = v9;
  return v8;
}

uint64_t aaCacheStreamPWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  __int128 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  __int16 v31;
  char v33;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  v8 = a4;
  v9 = a3;
  if (a3)
  {
    v12 = 0;
    while (1)
    {
      v13 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v8 & v13) >= v9)
        v14 = v9;
      else
        v14 = *(unsigned int *)(a1 + 92) - (v8 & v13);
      v15 = cachePageGet(a1, v8 & ~v13, a3, a4, a5, a6, a7, a8);
      if (!v15)
      {
        v30 = "cachePageGet";
        v31 = 254;
        goto LABEL_28;
      }
      v22 = v15;
      v23 = v13 & v8;
      v24 = v23 + v14;
      v25 = *((_DWORD *)v15 + 6);
      v26 = *((_DWORD *)v15 + 7);
      if (v25 < v26)
      {
        v27 = v24 < v25 || v23 > v26;
        if (v27
          && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
        {
          break;
        }
      }
      memcpy((void *)(*((_QWORD *)v22 + 2) + v23), a2, v14);
      ++*(_QWORD *)(a1 + 48);
      if (v23 < *((_DWORD *)v22 + 6))
        *((_DWORD *)v22 + 6) = v23;
      if (v24 > *((_DWORD *)v22 + 7))
        *((_DWORD *)v22 + 7) = v24;
      v28 = *(_QWORD *)(a1 + 8) + 1;
      *(_QWORD *)(a1 + 8) = v28;
      *((_QWORD *)v22 + 1) = v28;
      *((_DWORD *)v22 + 8) = 1;
      v29 = v8 + (int)v14;
      if (*(_QWORD *)(a1 + 24) < v29)
        *(_QWORD *)(a1 + 24) = v29;
      if ((v14 & 0x8000000000000000) != 0)
        goto LABEL_29;
      v12 += v14;
      a2 += v14;
      v8 += v14;
      v9 -= v14;
      if (!v9)
        goto LABEL_25;
    }
    v30 = "cachePageReadFromDisk";
    v31 = 262;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheWrite", v31, 146, 0, v30, v20, v21, v33);
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPWrite", 346, 146, 0, "cacheWrite", a7, a8, v33);
    return -1;
  }
  v12 = 0;
LABEL_25:
  *(_QWORD *)(a1 + 16) = v8;
  return v12;
}

uint64_t aaCacheStreamRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPRead(a1, a2, a3, *(_QWORD *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPWrite(a1, a2, a3, *(_QWORD *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamCancel(uint64_t result)
{
  *(_DWORD *)(result + 100) = 1;
  return result;
}

uint64_t aaCacheStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (result)
  {
    v8 = result;
    if (*(_QWORD *)(result + 72))
    {
      if ((cacheFlush(result, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 440, 146, 0, "cacheFlush", v9, v10, v16);
        v11 = 0;
      }
      else
      {
        v11 = 1;
      }
      if (*(_DWORD *)(v8 + 84))
      {
        v12 = 0;
        v13 = 16;
        do
        {
          free(*(void **)(*(_QWORD *)(v8 + 72) + v13));
          ++v12;
          v13 += 40;
        }
        while (v12 < *(unsigned int *)(v8 + 84));
      }
      free(*(void **)(v8 + 72));
    }
    else
    {
      v11 = 1;
    }
    if (*(_DWORD *)(v8 + 104) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 446, 146, 0, "AAByteStreamClose", v14, v15, v16);
      v11 = 0;
    }
    if (*(int *)(v8 + 108) >= 1)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "CacheStream: read ops %zu/%zu, write ops %zu/%zu\n", *(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 40), *(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 48));
    free((void *)v8);
    if (v11)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t aaCacheStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  const char *v13;
  __int16 v14;
  char v15;

  if (!*(_DWORD *)(a1 + 100))
  {
    if ((cacheFlush(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      v13 = "cacheFlush";
      v14 = 411;
    }
    else
    {
      if ((AAByteStreamTruncate(*(_QWORD **)a1) & 0x80000000) == 0)
      {
        result = 0;
        *(_QWORD *)(a1 + 24) = a2;
        *(_QWORD *)(a1 + 32) = a2;
        return result;
      }
      v13 = "AAByteStreamTruncate";
      v14 = 412;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamTruncate", v14, 146, 0, v13, v10, v11, v15);
  }
  return 0xFFFFFFFFLL;
}

__int128 *cachePageGet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  __int128 *v11;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char v29;

  v8 = *(_QWORD *)(a1 + 72);
  v9 = *(_DWORD *)(a1 + 84) - 1;
  v10 = v9 & ((unint64_t)(0x16069317E428CA9 * a2) >> 32);
  v11 = (__int128 *)(v8 + 40 * v10);
  if (*(_QWORD *)v11 != a2)
  {
    v14 = v10 & 0xFFFFFC00;
    v15 = v10 | 0x3FF;
    if ((v10 | 0x3FF) >= v9)
      v15 = *(_DWORD *)(a1 + 84) - 1;
    if (v14 <= v15)
    {
      v16 = v10 & 0xFFFFFC00;
      while (*(_QWORD *)(v8 + 40 * v14) != a2)
      {
        if (*(_QWORD *)(v8 + 40 * v14 + 8) < *(_QWORD *)(v8 + 40 * v16 + 8))
          v16 = v14;
        if (++v14 > v15)
          goto LABEL_11;
      }
    }
    v16 = v14;
LABEL_11:
    v17 = *((_QWORD *)v11 + 4);
    v19 = *v11;
    v18 = v11[1];
    v20 = (__int128 *)(v8 + 40 * v16);
    v21 = *((_QWORD *)v20 + 4);
    v22 = v20[1];
    *v11 = *v20;
    v11[1] = v22;
    *((_QWORD *)v11 + 4) = v21;
    v23 = *(_QWORD *)(a1 + 72) + 40 * v16;
    *(_OWORD *)v23 = v19;
    *(_OWORD *)(v23 + 16) = v18;
    *(_QWORD *)(v23 + 32) = v17;
    if (*(_QWORD *)v11 != a2)
    {
      if ((cachePageEvict((uint64_t *)a1, v8 + 40 * v10, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageGet", 162, 146, 0, "cachePageEvict", v24, v25, v29);
        return 0;
      }
      else
      {
        v26 = v8 + 40 * v10;
        bzero(*(void **)(v26 + 16), *(unsigned int *)(a1 + 92));
        v27 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(v26 + 28) = 0;
        *(_DWORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 24) = v27;
        *(_QWORD *)v11 = a2;
      }
    }
  }
  return v11;
}

uint64_t cachePageReadFromDisk(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v11;
  size_t v12;
  int v13;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v27;
  int v28;
  char v30;
  unsigned int v31;
  size_t v32;

  v11 = *((unsigned int *)a2 + 6);
  v10 = *((_DWORD *)a2 + 7);
  if (v10 >= v11)
    v12 = v10 - v11;
  else
    v12 = 0;
  v13 = *((_DWORD *)a2 + 8);
  if (v10 <= v11 || v13 == 0)
  {
    v15 = 0;
  }
  else
  {
    v16 = malloc(v12);
    v15 = v16;
    if (!v16)
    {
      v24 = "aaMalloc";
      v25 = 184;
LABEL_33:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageReadFromDisk", v25, 146, 0, v24, a7, a8, v30);
      v27 = 0xFFFFFFFFLL;
      goto LABEL_34;
    }
    memcpy(v16, (const void *)(a2[2] + v11), v12);
  }
  v17 = *a2;
  if (a1[4] - *a2 >= *((unsigned int *)a1 + 23))
    v18 = *((unsigned int *)a1 + 23);
  else
    v18 = a1[4] - *a2;
  if (v18 < 1)
    goto LABEL_26;
  v19 = *a1;
  if (!*(_QWORD *)(*a1 + 32))
    goto LABEL_32;
  v31 = v10;
  v32 = v12;
  v20 = 0;
  v21 = a2[2];
  v22 = v18;
  while (1)
  {
    v23 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v19 + 32))(*(_QWORD *)v19, v21, v22, v17);
    if (v23 < 0)
      break;
    if (v23)
    {
      v21 += v23;
      v20 += v23;
      v17 += v23;
      v22 -= v23;
      if (v22)
        continue;
    }
    goto LABEL_24;
  }
  v20 = v23;
LABEL_24:
  v12 = v32;
  v10 = v31;
  if (v18 != v20)
  {
LABEL_32:
    v24 = "AAByteStreamPRead";
    v25 = 193;
    goto LABEL_33;
  }
  ++a1[7];
  v13 = *((_DWORD *)a2 + 8);
LABEL_26:
  if (v10 > v11 && v13 != 0)
    memcpy((void *)(a2[2] + *((unsigned int *)a2 + 6)), v15, v12);
  v27 = 0;
  v28 = *((_DWORD *)a1 + 23);
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v28;
LABEL_34:
  free(v15);
  return v27;
}

uint64_t cachePageEvict(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v23;

  if (*((_DWORD *)a1 + 25))
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a2 + 32))
    return 0;
  v9 = *(unsigned int *)(a2 + 24);
  v10 = *(_DWORD *)(a2 + 28);
  if (v10 <= v9)
    return 0;
  v12 = *(_QWORD *)a2 + v9;
  v13 = v10 - v9;
  if (v13 >= a1[3] - v12)
    v14 = a1[3] - v12;
  else
    v14 = v13;
  if (v14 <= 0)
  {
    v21 = "bad page";
    v22 = 87;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageEvict", v22, 146, 0, v21, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  v15 = *a1;
  if (!*(_QWORD *)(*a1 + 40))
    goto LABEL_20;
  v16 = 0;
  v17 = *(_QWORD *)(a2 + 16) + v9;
  v18 = *(_QWORD *)a2 + v9;
  v19 = v14;
  while (1)
  {
    v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(_QWORD *)v15, v17, v19, v18);
    if (v20 < 1)
      break;
    v17 += v20;
    v16 += v20;
    v18 += v20;
    v19 -= v20;
    if (!v19)
      goto LABEL_16;
  }
  v16 = v20;
LABEL_16:
  if (v14 != v16)
  {
LABEL_20:
    v21 = "aaByteStreamPWriteExpected";
    v22 = 90;
    goto LABEL_21;
  }
  ++a1[8];
  if (a1[4] < v14 + v12)
  {
    result = 0;
    a1[4] = v14 + v12;
    return result;
  }
  return 0;
}

uint64_t cacheFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v16;

  if (*(_DWORD *)(a1 + 100))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 84))
  {
    v10 = 0;
    v11 = 0;
    while ((cachePageEvict((uint64_t *)a1, *(_QWORD *)(a1 + 72) + v10, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
    {
      v14 = *(_QWORD *)(a1 + 72) + v10;
      bzero(*(void **)(v14 + 16), *(unsigned int *)(a1 + 92));
      *(_QWORD *)v14 = -1;
      v15 = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(v14 + 28) = 0;
      *(_DWORD *)(v14 + 32) = 0;
      *(_DWORD *)(v14 + 24) = v15;
      ++v11;
      v10 += 40;
      if (v11 >= *(unsigned int *)(a1 + 84))
        return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheFlush", 115, 146, 0, "cachePageEvict", v12, v13, v16);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t aeaOutputStreamRunThreads(uint64_t a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  compression_algorithm v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  size_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  void *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  int *v34;
  void *v35;
  BOOL v36;
  int v37;
  pthread_t *v38;
  char v39;

  v2 = *(unsigned int *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(unsigned int *)(v3 + 24);
  v5 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    v6 = aeaEffectiveCompressionAlgorithm(v4);
    v7 = compression_encode_scratch_buffer_size(v6);
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = v2;
  v8 = calloc(v2, 4uLL);
  *(_QWORD *)(a1 + 72) = v8;
  if (!v8)
  {
    v12 = "SharedArrayInit: malloc failed\n";
    v13 = 55;
    goto LABEL_10;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0))
  {
    v12 = "SharedArrayInit: pthread_mutex_init failed\n";
    v13 = 56;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v13, 0, v12, v9, v10, v11, v39);
    v16 = "SharedArrayInit";
    v17 = 323;
LABEL_11:
    v18 = 0;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunThreads", v17, 41, v18, v16, v14, v15, v39);
    return 0xFFFFFFFFLL;
  }
  if (pthread_cond_init((pthread_cond_t *)(a1 + 144), 0))
  {
    v12 = "SharedArrayInit: pthread_cond_init failed\n";
    v13 = 57;
    goto LABEL_10;
  }
  v20 = (v2 + 1);
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = v20;
  v21 = calloc(v20, 4uLL);
  *(_QWORD *)(a1 + 200) = v21;
  if (!v21)
  {
    v25 = "SharedArrayInit: malloc failed\n";
    v26 = 55;
    goto LABEL_19;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 208), 0))
  {
    v25 = "SharedArrayInit: pthread_mutex_init failed\n";
    v26 = 56;
LABEL_19:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v26, 0, v25, v22, v23, v24, v39);
    v16 = "SharedArrayInit";
    v17 = 324;
    goto LABEL_11;
  }
  if (pthread_cond_init((pthread_cond_t *)(a1 + 272), 0))
  {
    v25 = "SharedArrayInit: pthread_cond_init failed\n";
    v26 = 57;
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 56) = -1;
  if (v2 >= 0x89AE409)
  {
    *__error() = 12;
    *(_QWORD *)(a1 + 48) = 0;
LABEL_50:
    v18 = *__error();
    v16 = "malloc";
    v17 = 329;
    goto LABEL_12;
  }
  v27 = calloc(v2, 0x3B8uLL);
  *(_QWORD *)(a1 + 48) = v27;
  if (!v27)
    goto LABEL_50;
  if ((_DWORD)v2)
  {
    v28 = 0;
    v29 = 0;
    while (1)
    {
      v30 = *(_QWORD *)(a1 + 48);
      v31 = v30 + v28;
      *(_DWORD *)(v30 + v28 + 592) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 600), 0)
        || pthread_cond_init((pthread_cond_t *)(v31 + 664), 0)
        || (*(_DWORD *)(v30 + v28 + 712) = 0, pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 720), 0))
        || pthread_cond_init((pthread_cond_t *)(v30 + v28 + 784), 0)
        || (*(_DWORD *)(v30 + v28 + 832) = 0, pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 840), 0))
        || pthread_cond_init((pthread_cond_t *)(v30 + v28 + 904), 0))
      {
        v16 = "SemInit";
        v17 = 333;
        goto LABEL_11;
      }
      v32 = v30 + v28;
      *(_DWORD *)(v32 + 8) = v29;
      *(_QWORD *)(v32 + 16) = a1;
      v33 = malloc(v5);
      *(_QWORD *)(v32 + 32) = v33;
      *(_QWORD *)(v32 + 40) = malloc(v5);
      if (v7)
      {
        if (v7 < 0x2000000001)
        {
          v35 = malloc(v7);
        }
        else
        {
          v34 = __error();
          v35 = 0;
          *v34 = 12;
          v33 = *(void **)(v32 + 32);
        }
      }
      else
      {
        v35 = 0;
      }
      *(_QWORD *)(v32 + 24) = v35;
      if (!v33 || (v7 ? (v36 = v35 == 0) : (v36 = 0), !v36 ? (v37 = 0) : (v37 = 1), !*(_QWORD *)(v32 + 40) || v37))
      {
        v18 = *__error();
        v16 = "malloc";
        v17 = 339;
        goto LABEL_12;
      }
      if ((createThread((pthread_t *)v31, (uint64_t)aeaOutputStreamWorkerThreadProc, v31, 0) & 0x80000000) != 0)
        break;
      ++v29;
      v28 += 952;
      if (952 * v2 == v28)
        goto LABEL_47;
    }
    v16 = "Thread creation";
    v17 = 340;
    goto LABEL_11;
  }
LABEL_47:
  v38 = (pthread_t *)calloc(1uLL, 0x10uLL);
  *(_QWORD *)(a1 + 320) = v38;
  if (!v38)
  {
    v18 = *__error();
    v16 = "malloc";
    v17 = 345;
    goto LABEL_12;
  }
  v38[1] = (pthread_t)a1;
  if ((createThread(v38, (uint64_t)aeaOutputStreamWriterThreadProc, (uint64_t)v38, 0) & 0x80000000) != 0)
  {
    v16 = "Thread creation";
    v17 = 347;
    goto LABEL_11;
  }
  return 0;
}

uint64_t aeaOutputStreamWorkerThreadProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  pthread_cond_t *v5;
  pthread_mutex_t *v6;
  pthread_cond_t *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  __int16 v23;
  const char *v24;
  int64_t v25;
  size_t v26;
  compression_algorithm v27;
  void *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t result;
  uint64_t v32;
  uint64_t (*v33)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *);
  int v34;
  int v35;
  uint64_t v36;
  uint64_t (*v37)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _OWORD *);
  int v38;
  int v39;
  uint64_t (*v40)(_QWORD, size_t, uint64_t, _OWORD *, _QWORD, _QWORD);
  int v41;
  int v42;
  int v43;
  const char *v44;
  __int16 v45;
  unsigned int *v46;
  unsigned int v47;
  const char *v48;
  __int16 v49;
  char v50;
  size_t v51;
  int v52;
  unsigned int v53;
  _OWORD *v54;
  uint64_t v55;
  pthread_cond_t *v56;
  _DWORD *v57;
  unsigned int v58;
  size_t dst_size;
  pthread_mutex_t *v60;
  uint64_t v61;
  int v62;
  int v63;
  unsigned int *v64;
  pthread_mutex_t *v65;
  _OWORD v66[16];
  int v67;
  _OWORD v68[16];
  int v69;
  _OWORD v70[16];
  int v71;
  _OWORD __s[17];
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(v2 + 24);
  dst_size = *(unsigned int *)(v3 + 16);
  v58 = *(_DWORD *)(v3 + 24);
  v63 = *(_DWORD *)(a1 + 8);
  v4 = (pthread_mutex_t *)(a1 + 600);
  v67 = 0;
  v5 = (pthread_cond_t *)(a1 + 664);
  v64 = (unsigned int *)(a1 + 48);
  v65 = (pthread_mutex_t *)(v2 + 80);
  v57 = (_DWORD *)(v3 + 668);
  v55 = a1 + 332;
  v60 = (pthread_mutex_t *)(a1 + 720);
  v61 = a1 + 72;
  v56 = (pthread_cond_t *)(a1 + 784);
  v6 = (pthread_mutex_t *)(a1 + 840);
  v7 = (pthread_cond_t *)(a1 + 904);
  v8 = (char *)v70 + 8;
  v62 = 1;
  memset(v66, 0, sizeof(v66));
  while (1)
  {
    if (pthread_mutex_lock(v65))
    {
      v48 = "SharedArrayPush: pthread_mutex_lock failed\n";
      v49 = 117;
      goto LABEL_73;
    }
    v12 = *(unsigned int *)(v2 + 64);
    v13 = *(_DWORD *)(v2 + 68);
    v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(_QWORD *)(v2 + 72) + 4 * v12) = v63;
      v14 = *(_DWORD *)(v2 + 64);
    }
    *(_DWORD *)(v2 + 64) = v14 + 1;
    if (!v14 && pthread_cond_broadcast((pthread_cond_t *)(v2 + 144)))
    {
      v48 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v49 = 122;
      goto LABEL_73;
    }
    if (pthread_mutex_unlock(v65))
    {
      v48 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      v49 = 124;
LABEL_73:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v49, 0, v48, v9, v10, v11, v50);
      v44 = "SharedArrayPush";
      v45 = 76;
LABEL_62:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWorkerThreadProc", v45, 41, 0, v44, v15, v16, v50);
LABEL_63:
      v46 = (unsigned int *)(v2 + 40);
      do
        v47 = __ldaxr(v46);
      while (__stlxr(v47 + 1, v46));
      return a1;
    }
    if (v12 >= v13)
    {
      v48 = "SharedArrayPush: stack is full\n";
      v49 = 125;
      goto LABEL_73;
    }
    if (pthread_mutex_lock(v4))
      goto LABEL_61;
    while (1)
    {
      v17 = *(_DWORD *)(a1 + 592);
      if (v17 > 0)
        break;
      if (pthread_cond_wait(v5, v4))
        goto LABEL_61;
    }
    *(_DWORD *)(a1 + 592) = v17 - 1;
    if (pthread_mutex_unlock(v4))
    {
LABEL_61:
      v44 = "SemAcquire";
      v45 = 77;
      goto LABEL_62;
    }
    if (*v64 == -1)
    {
      if (!v62)
        goto LABEL_63;
      return a1;
    }
    if ((aeaChecksum(v61, *(_DWORD *)(v3 + 12), *(_QWORD **)(a1 + 32), *(unsigned int *)(a1 + 52), v18, v19, v15, v16) & 0x80000000) != 0)
    {
      v23 = 83;
      v24 = "Segment checksum failed";
      goto LABEL_50;
    }
    *(_DWORD *)(a1 + 56) = 0;
    if (v58 != 774)
    {
      if (!v58)
      {
        v22 = *(unsigned int *)(a1 + 52);
LABEL_26:
        memcpy(*(void **)(a1 + 40), *(const void **)(a1 + 32), v22);
        v26 = *(unsigned int *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v26;
        goto LABEL_27;
      }
      v27 = aeaEffectiveCompressionAlgorithm(v58);
      LODWORD(v25) = compression_encode_buffer(*(uint8_t **)(a1 + 40), dst_size, *(const uint8_t **)(a1 + 32), *(unsigned int *)(a1 + 52), *(void **)(a1 + 24), v27);
LABEL_23:
      v26 = v25;
      *(_DWORD *)(a1 + 56) = v25;
      goto LABEL_24;
    }
    v25 = PCompressLZMA6Encode(*(uint8_t **)(a1 + 40), dst_size, *(const uint8_t **)(a1 + 32), *(unsigned int *)(a1 + 52));
    if (v25 >= 1)
      goto LABEL_23;
    v26 = *(unsigned int *)(a1 + 56);
LABEL_24:
    v22 = *(unsigned int *)(a1 + 52);
    if (!v26 || v26 >= v22)
      goto LABEL_26;
LABEL_27:
    v28 = *(void **)(a1 + 32);
    if (v28)
    {
      memset_s(v28, dst_size, 0, dst_size);
      v26 = *(unsigned int *)(a1 + 56);
    }
    if (!v26)
    {
      v23 = 107;
      v24 = "Segment compression failed";
      goto LABEL_50;
    }
    v54 = v8;
    v51 = v26;
    v29 = *v64;
    v30 = *(_DWORD *)(v3 + 20);
    v69 = 0;
    memset(v68, 0, sizeof(v68));
    memset((char *)__s + 8, 0, 252);
    v71 = 0;
    memset(v70, 0, sizeof(v70));
    WORD4(__s[0]) = 19267;
    *(_QWORD *)&__s[0] = 0x5F41454100000006;
    result = memset_s((char *)__s + 10, 0xFAuLL, 0, 0xFAuLL);
    v32 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0xFD)
      break;
    v52 = v29 / v30;
    v53 = v29;
    *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v29 / v30;
    LODWORD(__s[0]) = v32 + 4;
    memset_s((char *)__s + v32 + 8, 252 - v32, 0, 252 - v32);
    v33 = *(uint64_t (**)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (v33 && *v57)
    {
      v34 = v33(v68, *(unsigned int *)(v3 + 72), v57, __s, v70);
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      v35 = 0;
      if ((v34 & 0x80000000) == 0)
        goto LABEL_37;
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    v35 = 1;
LABEL_37:
    *(_OWORD *)((char *)v54 + 236) = 0u;
    v54[13] = 0u;
    v54[14] = 0u;
    v54[11] = 0u;
    v54[12] = 0u;
    v54[9] = 0u;
    v54[10] = 0u;
    v54[7] = 0u;
    v54[8] = 0u;
    v54[5] = 0u;
    v54[6] = 0u;
    v54[3] = 0u;
    v54[4] = 0u;
    v54[1] = 0u;
    v54[2] = 0u;
    *v54 = 0u;
    WORD4(v70[0]) = 19283;
    *(_QWORD *)&v70[0] = 0x5F41454100000006;
    result = memset_s((char *)v70 + 10, 0xFAuLL, 0, 0xFAuLL);
    v36 = LODWORD(v70[0]);
    if (LODWORD(v70[0]) >= 0xFD)
      break;
    *(_DWORD *)((char *)v70 + LODWORD(v70[0]) + 4) = v53 - v52 * v30;
    LODWORD(v70[0]) = v36 + 4;
    memset_s((char *)v70 + v36 + 8, 252 - v36, 0, 252 - v36);
    memset(__s, 0, 260);
    v37 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (!v37 || !LODWORD(v68[0]))
    {
      memset_s(v70, 0x104uLL, 0, 0x104uLL);
      v8 = (char *)v54;
LABEL_48:
      memset_s(v68, 0x104uLL, 0, 0x104uLL);
LABEL_49:
      v23 = 119;
      v24 = "Segment key derivation failed";
      goto LABEL_50;
    }
    v38 = v35;
    v39 = v37(v66, *(unsigned int *)(v3 + 76), v68, v70, __s);
    memset_s(v70, 0x104uLL, 0, 0x104uLL);
    v8 = (char *)v54;
    if (v39 < 0)
      goto LABEL_48;
    memset_s(v68, 0x104uLL, 0, 0x104uLL);
    if (v38)
      goto LABEL_49;
    v40 = *(uint64_t (**)(_QWORD, size_t, uint64_t, _OWORD *, _QWORD, _QWORD))(v3 + 160);
    if (v40)
    {
      v41 = v40(*(_QWORD *)(a1 + 40), v51, v55, v66, 0, 0);
      if (*(_DWORD *)(a1 + 332) == *(_DWORD *)(v3 + 84) && (v41 & 0x80000000) == 0)
        goto LABEL_51;
    }
    v23 = 120;
    v24 = "Segment encryption failed";
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWorkerThreadProc", v23, 41, 0, v24, v20, v21, v50);
    memset_s(v64, 0x220uLL, 0, 0x220uLL);
    v62 = 0;
    *v64 = -1;
LABEL_51:
    memset_s(v66, 0x104uLL, 0, 0x104uLL);
    if (pthread_mutex_lock(v60)
      || (v42 = *(_DWORD *)(a1 + 712), *(_DWORD *)(a1 + 712) = v42 + 1, !v42) && pthread_cond_broadcast(v56)
      || pthread_mutex_unlock(v60))
    {
      v44 = "SemRelease";
      v45 = 133;
      goto LABEL_62;
    }
    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        v43 = *(_DWORD *)(a1 + 832);
        if (v43 > 0)
          break;
        if (pthread_cond_wait(v7, v6))
          goto LABEL_60;
      }
      *(_DWORD *)(a1 + 832) = v43 - 1;
      if (!pthread_mutex_unlock(v6))
        continue;
    }
LABEL_60:
    v44 = "SemAcquire";
    v45 = 135;
    goto LABEL_62;
  }
  __break(1u);
  return result;
}

uint64_t aeaOutputStreamWriterThreadProc(uint64_t a1)
{
  uint64_t v2;
  rsize_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  rsize_t v11;
  uint64_t v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  unsigned int *v29;
  unsigned int v30;
  char v32;
  int v33;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(unsigned int *)(*(_QWORD *)(v2 + 24) + 16);
  v4 = 1;
  while (1)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 208)))
    {
      v27 = "SharedArrayPop: pthread_mutex_lock failed\n";
      v28 = 91;
      goto LABEL_24;
    }
    while (1)
    {
      v8 = *(_DWORD *)(v2 + 192);
      if (v8)
        break;
      if (pthread_cond_wait((pthread_cond_t *)(v2 + 272), (pthread_mutex_t *)(v2 + 208)))
      {
        v27 = "SharedArrayPop: pthread_cond_wait failed\n";
        v28 = 94;
        goto LABEL_24;
      }
    }
    v9 = v8 - 1;
    *(_DWORD *)(v2 + 192) = v9;
    v10 = *(_DWORD *)(*(_QWORD *)(v2 + 200) + 4 * v9);
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 208)))
    {
      v27 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      v28 = 98;
LABEL_24:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v28, 0, v27, v5, v6, v7, v32);
      v25 = "SharedArrayDequeue";
      v26 = 151;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWriterThreadProc", v26, 41, 0, v25, v6, v7, v32);
      goto LABEL_27;
    }
    if (v10 == -1)
      break;
    if (v10 >= *(_DWORD *)(v2 + 16))
    {
      v25 = "Invalid worker id";
      v26 = 155;
      goto LABEL_26;
    }
    v33 = v4;
    v11 = v3;
    v12 = *(_QWORD *)(v2 + 48);
    v13 = v12 + 952 * v10;
    v14 = (pthread_mutex_t *)(v13 + 720);
    if (pthread_mutex_lock((pthread_mutex_t *)(v13 + 720)))
      goto LABEL_25;
    v15 = (int *)(v13 + 712);
    while (*v15 <= 0)
    {
      if (pthread_cond_wait((pthread_cond_t *)(v12 + 952 * v10 + 784), v14))
        goto LABEL_25;
    }
    --*v15;
    if (pthread_mutex_unlock(v14))
    {
LABEL_25:
      v25 = "SemAcquire";
      v26 = 159;
      goto LABEL_26;
    }
    v18 = v12 + 952 * v10;
    v20 = *(_QWORD *)(v18 + 40);
    v19 = v18 + 40;
    if ((aeaContainerAppendSegment(*(_QWORD *)(v2 + 24), *(_QWORD *)v2, (_QWORD *)(v19 + 8), v20, v16, v17, v6, v7) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWriterThreadProc", 164, 41, 0, "Segment insertion", v21, v22, v32);
      v33 = 0;
    }
    v3 = v11;
    if (*(_QWORD *)v19)
      memset_s(*(void **)v19, v11, 0, v11);
    memset_s((void *)(v19 + 8), 0x220uLL, 0, 0x220uLL);
    v4 = v33;
    if (pthread_mutex_lock((pthread_mutex_t *)(v12 + 952 * v10 + 840))
      || (v23 = v12 + 952 * v10, v24 = *(_DWORD *)(v23 + 832), *(_DWORD *)(v23 + 832) = v24 + 1, !v24)
      && pthread_cond_broadcast((pthread_cond_t *)(v12 + 952 * v10 + 904))
      || pthread_mutex_unlock((pthread_mutex_t *)(v12 + 952 * v10 + 840)))
    {
      v25 = "SemRelease";
      v26 = 175;
      goto LABEL_26;
    }
  }
  if (v4)
    return a1;
LABEL_27:
  v29 = (unsigned int *)(v2 + 40);
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 + 1, v29));
  return a1;
}

AAByteStream AEAEncryptionOutputStreamOpen(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  uint64_t v4;
  uint64_t v5;
  int DefaultNThreads;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t New;
  uint64_t v14;
  uint64_t v15;
  AAByteStream result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(char *, _QWORD);
  int v21;
  int v22;
  const char *v23;
  __int16 v24;
  char v25;
  _QWORD __s[3];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _BYTE v40[28];
  uint64_t v41;

  DefaultNThreads = n_threads;
  v41 = *MEMORY[0x24BDAC8D0];
  if (n_threads <= 0)
    DefaultNThreads = getDefaultNThreads();
  if (!*((_QWORD *)encrypted_stream + 5))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpen", 367, 41, 0, "Invalid encrypted stream", v4, v5, v25);
    v12 = 0;
    v10 = 0;
LABEL_23:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v11 = malloc(0x148uLL);
  v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    v22 = *__error();
    v23 = "malloc";
    v24 = 372;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpen", v24, 41, v22, v23, v14, v15, v25);
    goto LABEL_23;
  }
  *(_QWORD *)v12 = encrypted_stream;
  *(_QWORD *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  New = aeaContainerCreateNew((uint64_t)context);
  *(_QWORD *)(v12 + 24) = New;
  if (!New)
  {
    v23 = "Invalid encryption parameters";
    v24 = 379;
LABEL_21:
    v22 = 0;
    goto LABEL_22;
  }
  result = (AAByteStream)aeaOutputStreamRunThreads(v12);
  if ((result & 0x80000000) != 0)
  {
    v23 = "Running stream threads";
    v24 = 380;
    goto LABEL_21;
  }
  v10[3] = aeaOutputStreamWrite;
  v10[7] = aeaOutputStreamAbort;
  *v10 = v12;
  v10[1] = aeaOutputStreamClose;
  v17 = *(_QWORD *)(v12 + 24);
  v18 = *(unsigned int *)(v17 + 668);
  if (v18 < 0x101)
  {
    memcpy((char *)context + 1376, (const void *)(v17 + 672), *(unsigned int *)(v17 + 668));
    *((_DWORD *)context + 343) = v18;
    memset_s((char *)context + v18 + 1376, 256 - v18, 0, 256 - v18);
    v19 = *(_QWORD *)(v12 + 24);
    if (*(_DWORD *)v19 <= 5u && ((1 << *(_DWORD *)v19) & 0x2B) != 0)
      return (AAByteStream)v10;
    memset(v40, 0, sizeof(v40));
    v39 = 0u;
    v38 = 0u;
    v37 = 0u;
    v36 = 0u;
    v35 = 0u;
    v34 = 0u;
    v33 = 0u;
    v32 = 0u;
    v31 = 0u;
    v30 = 0u;
    v29 = 0u;
    v28 = 0u;
    v27 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007;
    v25 = 0;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    v20 = *(uint64_t (**)(char *, _QWORD))(v19 + 144);
    if (v20 && *(_DWORD *)(v19 + 668))
    {
      v21 = v20((char *)context + 1632, *(unsigned int *)(v19 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v21 & 0x80000000) == 0)
        return (AAByteStream)v10;
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    v23 = "deriving signature encryption key";
    v24 = 398;
    goto LABEL_21;
  }
  __break(1u);
  return result;
}

uint64_t aeaOutputStreamWrite(uint64_t a1, char *__src, unint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  int v7;
  pthread_mutex_t *v8;
  pthread_cond_t *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  size_t v20;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  char v27;

  if (*(_DWORD *)(a1 + 36))
    return -1;
  v3 = a3;
  if (!a3)
    return 0;
  v6 = 0;
  v7 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 16);
  v8 = (pthread_mutex_t *)(a1 + 80);
  v9 = (pthread_cond_t *)(a1 + 144);
  while (1)
  {
    v10 = *(_DWORD *)(a1 + 56);
    if (v10 != -1)
    {
      v11 = *(_QWORD *)(a1 + 48) + 952 * v10;
      goto LABEL_13;
    }
    if (pthread_mutex_lock(v8))
    {
      v22 = "SharedArrayPop: pthread_mutex_lock failed\n";
      v23 = 91;
LABEL_20:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v23, 0, v22, v12, v13, v14, v27);
      v24 = "SharedArrayPop failed";
      v25 = 282;
      goto LABEL_21;
    }
    while (1)
    {
      v15 = *(_DWORD *)(a1 + 64);
      if (v15)
        break;
      if (pthread_cond_wait(v9, v8))
      {
        v22 = "SharedArrayPop: pthread_cond_wait failed\n";
        v23 = 94;
        goto LABEL_20;
      }
    }
    v16 = v15 - 1;
    *(_DWORD *)(a1 + 64) = v16;
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v16);
    if (pthread_mutex_unlock(v8))
    {
      v22 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      v23 = 98;
      goto LABEL_20;
    }
    v17 = *(_DWORD *)(a1 + 56);
    if (v17 >= *(_DWORD *)(a1 + 16))
      break;
    v11 = *(_QWORD *)(a1 + 48) + 952 * v17;
    memset_s((void *)(v11 + 48), 0x220uLL, 0, 0x220uLL);
    v18 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(_DWORD *)(v11 + 48) = v18;
LABEL_13:
    v19 = *(unsigned int *)(v11 + 52);
    if ((v7 - v19) >= v3)
      v20 = v3;
    else
      v20 = (v7 - v19);
    memcpy((void *)(*(_QWORD *)(v11 + 32) + v19), __src, v20);
    v21 = *(_DWORD *)(v11 + 52) + v20;
    *(_DWORD *)(v11 + 52) = v21;
    if (v21 == v7 && (aeaOutputStreamRunCurrentWorker(a1) & 0x80000000) != 0)
    {
      v24 = "Sending task to worker failed";
      v25 = 305;
      goto LABEL_21;
    }
    __src += v20;
    v6 += v20;
    v3 -= v20;
    if (!v3)
      return v6;
  }
  v24 = "Invalid worker_id";
  v25 = 283;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWrite", v25, 41, 0, v24, v13, v14, v27);
  return -1;
}

void aeaOutputStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 36) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t aeaOutputStreamClose(uint64_t a1)
{
  return aeaOutputStreamCloseAndUpdateContext(a1, 0);
}

AAByteStream AEAEncryptionOutputStreamOpenExisting(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  uint64_t v4;
  uint64_t v5;
  int DefaultNThreads;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  AAByteStream result;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  int v20;
  uint64_t v21;
  uint8_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  compression_algorithm v26;
  size_t v27;
  rsize_t v28;
  void *v29;
  int v30;
  const char *v31;
  __int16 v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t (*v37)(char *, _QWORD);
  int v38;
  const char *v39;
  __int16 v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t Segment;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  rsize_t v56;
  _QWORD __s[3];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  _BYTE v71[28];
  uint64_t v72;

  DefaultNThreads = n_threads;
  v72 = *MEMORY[0x24BDAC8D0];
  if (n_threads <= 0)
    DefaultNThreads = getDefaultNThreads();
  if (!*((_QWORD *)encrypted_stream + 5) || !*((_QWORD *)encrypted_stream + 4))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 430, 41, 0, "Invalid encrypted stream", v4, v5, v55);
    v12 = 0;
    v10 = 0;
LABEL_40:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v11 = malloc(0x148uLL);
  v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    v30 = *__error();
    v31 = "malloc";
    v32 = 435;
LABEL_39:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", v32, 41, v30, v31, v14, v15, v55);
    goto LABEL_40;
  }
  *(_QWORD *)v12 = encrypted_stream;
  *(_QWORD *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  result = (AAByteStream)aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 0, 1);
  *(_QWORD *)(v12 + 24) = result;
  if (!result)
  {
    v31 = "load container";
    v32 = 443;
    goto LABEL_38;
  }
  if ((flags & 0x4000000000000) == 0)
  {
    if ((aeaContainerReencrypt((uint64_t)result, encrypted_stream, (int *)context + 18, (_DWORD *)context + 538, (unsigned int *)context + 83, (unsigned int *)context + 213) & 0x80000000) != 0)
    {
      v31 = "re-encrypting container";
      v32 = 454;
      goto LABEL_38;
    }
    result = *(AAByteStream *)(v12 + 24);
  }
  v16 = *((unsigned int *)result + 167);
  if (v16 < 0x101)
  {
    memcpy((char *)context + 1376, (char *)result + 672, v16);
    *((_DWORD *)context + 343) = v16;
    memset_s((char *)context + v16 + 1376, 256 - v16, 0, 256 - v16);
    v17 = *(_QWORD *)(v12 + 24);
    if (*(_DWORD *)v17 <= 5u && ((1 << *(_DWORD *)v17) & 0x2B) != 0)
      goto LABEL_14;
    memset(v71, 0, sizeof(v71));
    v70 = 0u;
    v69 = 0u;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v65 = 0u;
    v64 = 0u;
    v63 = 0u;
    v62 = 0u;
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    v58 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    v37 = *(uint64_t (**)(char *, _QWORD))(v17 + 144);
    if (v37 && *(_DWORD *)(v17 + 668))
    {
      v38 = v37((char *)context + 1632, *(unsigned int *)(v17 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v38 & 0x80000000) == 0)
      {
        v17 = *(_QWORD *)(v12 + 24);
LABEL_14:
        if ((aeaContainerRemovePadding(v17, encrypted_stream) & 0x80000000) == 0)
        {
          v18 = *(_QWORD *)(v12 + 24);
          v19 = *(unsigned int *)(v18 + 16);
          v20 = *(_DWORD *)(v18 + 400);
          if (!v20 || *(_DWORD *)(*(_QWORD *)(v18 + 392) + 544 * (v20 - 1) + 4) >= v19)
          {
            v29 = 0;
            v28 = 0;
            v22 = 0;
            v25 = 0;
            v33 = 0;
LABEL_25:
            *(_DWORD *)(v12 + 32) = v20;
            if ((aeaOutputStreamRunThreads(v12) & 0x80000000) != 0)
            {
              v39 = "Running stream threads";
              v40 = 499;
            }
            else
            {
              v10[3] = aeaOutputStreamWrite;
              v10[7] = aeaOutputStreamAbort;
              *v10 = v12;
              v10[1] = aeaOutputStreamClose;
              if (!v33 || aeaOutputStreamWrite(v12, v25, v33) == v33)
              {
                v36 = 1;
                goto LABEL_59;
              }
              v39 = "writing back last segment data";
              v40 = 511;
            }
            v41 = 0;
LABEL_58:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", v40, 41, v41, v39, v34, v35, v55);
            v36 = 0;
LABEL_59:
            if (!v22)
              goto LABEL_61;
            goto LABEL_60;
          }
          v21 = *(unsigned int *)(v18 + 24);
          v22 = (uint8_t *)malloc(*(unsigned int *)(v18 + 16));
          v25 = (char *)malloc(v19);
          if ((_DWORD)v21)
          {
            v26 = aeaEffectiveCompressionAlgorithm(v21);
            v27 = compression_decode_scratch_buffer_size(v26);
            v28 = v27;
            if (v27)
            {
              if (v27 < 0x2000000001)
              {
                v29 = malloc(v27);
              }
              else
              {
                v29 = 0;
                *__error() = 12;
              }
              v42 = 1;
LABEL_49:
              if (v29)
                v42 = 0;
              if (!v22 || !v25 || v42)
              {
                v41 = *__error();
                v39 = "malloc";
                v40 = 483;
                goto LABEL_58;
              }
              v56 = v28;
              v43 = *(_QWORD *)(v12 + 24);
              v44 = *(_DWORD *)(v43 + 400) - 1;
              v45 = *(_QWORD *)(v43 + 392);
              Segment = aeaContainerLoadSegment(v43, encrypted_stream, v44, (uint8_t *)v25, v22, v29, v23, v24);
              if (Segment == *(_DWORD *)(v45 + 544 * v44 + 4))
              {
                v33 = Segment;
                v28 = v56;
                if ((aeaContainerRemoveLastSegment(*(uint64x2_t **)(v12 + 24), encrypted_stream, v47, v48, v49, v50, v51, v52) & 0x80000000) == 0)
                {
                  v20 = *(_DWORD *)(*(_QWORD *)(v12 + 24) + 400);
                  goto LABEL_25;
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 493, 41, 0, "removing last segment", v53, v54, v55);
                v36 = 0;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 489, 41, 0, "load and decrypt last segment", v51, v52, v55);
                v36 = 0;
                v28 = v56;
              }
LABEL_60:
              memset_s(v22, v19, 0, v19);
LABEL_61:
              free(v22);
              if (v25)
                memset_s(v25, v19, 0, v19);
              free(v25);
              if (v29)
                memset_s(v29, v28, 0, v28);
              free(v29);
              if (v36)
                return (AAByteStream)v10;
              goto LABEL_40;
            }
            v42 = 0;
          }
          else
          {
            v42 = 0;
            v28 = 0;
          }
          v29 = 0;
          goto LABEL_49;
        }
        v31 = "removing padding";
        v32 = 471;
        goto LABEL_38;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    v31 = "deriving signature encryption key";
    v32 = 467;
LABEL_38:
    v30 = 0;
    goto LABEL_39;
  }
  __break(1u);
  return result;
}

int AEAEncryptionOutputStreamCloseAndUpdateContext(AAByteStream stream, AEAContext context)
{
  uint64_t v2;
  uint64_t v3;
  AAByteStream v4;
  uint64_t v5;
  int updated;
  char v8;

  if (stream)
  {
    v4 = stream;
    if (*((uint64_t (**)(uint64_t))stream + 1) == aeaOutputStreamClose)
    {
      v5 = *(_QWORD *)stream;
      *(_QWORD *)v4 = 0;
      updated = aeaOutputStreamCloseAndUpdateContext(v5, (uint64_t)context);
      free(v4);
      LODWORD(stream) = updated;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamCloseAndUpdateContext", 534, 41, 0, "Invalid stream type", v2, v3, v8);
      LODWORD(stream) = -1;
    }
  }
  return (int)stream;
}

uint64_t aeaOutputStreamCloseAndUpdateContext(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  pthread_mutex_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void **v29;
  _QWORD *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  int v45;

  if (!result)
    return result;
  v2 = result;
  v3 = *(_QWORD **)(result + 48);
  v43 = a2;
  if (v3 && (v4 = *(unsigned int *)(result + 16), (_DWORD)v4))
  {
    v5 = 0;
    do
    {
      if (*v3)
        ++v5;
      v3 += 119;
      --v4;
    }
    while (v4);
  }
  else
  {
    v5 = 0;
  }
  if ((aeaOutputStreamRunCurrentWorker(result) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 207, 41, 0, "Sending task to worker", v6, v7, v43);
    v45 = 0;
  }
  else
  {
    v45 = 1;
  }
  if (v5 >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 80)))
      {
        v12 = 91;
        v13 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_20:
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v12, 0, v13, v9, v10, v11, v43);
        v17 = -1;
      }
      else
      {
        while (1)
        {
          v14 = *(_DWORD *)(v2 + 64);
          if (v14)
            break;
          if (pthread_cond_wait((pthread_cond_t *)(v2 + 144), (pthread_mutex_t *)(v2 + 80)))
          {
            v12 = 94;
            v13 = "SharedArrayPop: pthread_cond_wait failed\n";
            goto LABEL_20;
          }
        }
        v25 = v14 - 1;
        *(_DWORD *)(v2 + 64) = v25;
        v17 = *(_DWORD *)(*(_QWORD *)(v2 + 72) + 4 * v25);
        if (!pthread_mutex_unlock((pthread_mutex_t *)(v2 + 80)))
          goto LABEL_22;
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v26, v27, v28, v43);
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 213, 41, 0, "SharedArrayPop", v15, v16, v44);
      v45 = 0;
LABEL_22:
      v18 = *(_QWORD *)(v2 + 48);
      v19 = v18 + 952 * v17;
      memset_s((void *)(v19 + 48), 0x220uLL, 0, 0x220uLL);
      *(_DWORD *)(v19 + 48) = -1;
      v20 = (pthread_mutex_t *)(v19 + 600);
      if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 600))
        || (v23 = v18 + 952 * v17, v24 = *(_DWORD *)(v23 + 592), *(_DWORD *)(v23 + 592) = v24 + 1, !v24)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + 952 * v17 + 664))
        || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 600)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 217, 41, 0, "SemRelease", v21, v22, v43);
        v45 = 0;
      }
      joinThread(*(_opaque_pthread_t **)v19);
      v29 = (void **)(v18 + 952 * v17);
      free(v29[4]);
      free(v29[5]);
      free(v29[3]);
      if (!pthread_mutex_destroy(v20))
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 664));
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952 * v17 + 720)))
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 784));
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952 * v17 + 840)))
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 904));
    }
  }
  v30 = *(_QWORD **)(v2 + 320);
  if (v30)
  {
    v31 = v43;
    v32 = v45;
    if (*v30)
    {
      if ((SharedArrayEnqueue((unsigned int *)(v2 + 192), -1) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 230, 41, 0, "SharedArrayEnqueue", v33, v34, v43);
        v32 = 0;
      }
      joinThread(**(_opaque_pthread_t ***)(v2 + 320));
    }
  }
  else
  {
    v31 = v43;
    v32 = v45;
  }
  result = *(_QWORD *)(v2 + 24);
  if (result && (result = aeaContainerFinish(result, *(AAByteStream_impl **)v2), (result & 0x80000000) != 0))
  {
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 235, 41, 0, "finishing container", v35, v36, v43);
    v32 = 0;
    if (v31)
      goto LABEL_46;
  }
  else if (v31)
  {
LABEL_46:
    v37 = *(_QWORD *)(v2 + 24);
    *(_OWORD *)v31 = *(_OWORD *)v37;
    v38 = *(_OWORD *)(v37 + 16);
    v39 = *(_OWORD *)(v37 + 32);
    v40 = *(_OWORD *)(v37 + 48);
    *(_QWORD *)(v31 + 64) = *(_QWORD *)(v37 + 64);
    *(_OWORD *)(v31 + 32) = v39;
    *(_OWORD *)(v31 + 48) = v40;
    *(_OWORD *)(v31 + 16) = v38;
    v41 = *(_QWORD *)(v2 + 24);
    v42 = *(unsigned int *)(v41 + 1448);
    if (v42 >= 0x101)
    {
      __break(1u);
      return result;
    }
    memcpy((void *)(v31 + 1896), (const void *)(v41 + 1452), *(unsigned int *)(v41 + 1448));
    *(_DWORD *)(v31 + 1892) = v42;
    memset_s((void *)(v31 + 1896 + v42), 256 - v42, 0, 256 - v42);
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 80)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 144)))
    free(*(void **)(v2 + 72));
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 208)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 272)))
    free(*(void **)(v2 + 200));
  free(*(void **)(v2 + 48));
  free(*(void **)(v2 + 320));
  aeaContainerDestroy(*(_QWORD *)(v2 + 24));
  memset_s((void *)v2, 0x148uLL, 0, 0x148uLL);
  free((void *)v2);
  if (v32)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aeaOutputStreamRunCurrentWorker(uint64_t a1)
{
  unsigned int v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v1 = *(_DWORD *)(a1 + 56);
  if (v1 == -1)
    return 0;
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
    return 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(v3 + 952 * v1 + 600))
    || (v6 = v3 + 952 * v1, v7 = *(_DWORD *)(v6 + 592), *(_DWORD *)(v6 + 592) = v7 + 1, !v7)
    && pthread_cond_broadcast((pthread_cond_t *)(v3 + 952 * v1 + 664))
    || pthread_mutex_unlock((pthread_mutex_t *)(v3 + 952 * v1 + 600)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunCurrentWorker", 188, 41, 0, "SemRelease", v4, v5, v12);
    v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  if ((SharedArrayEnqueue((unsigned int *)(a1 + 192), *(_DWORD *)(a1 + 56)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunCurrentWorker", 189, 41, 0, "SharedArrayEnqueue", v10, v11, v12);
    v8 = 0;
  }
  *(_DWORD *)(a1 + 56) = -1;
  if (v8)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SharedArrayEnqueue(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 157;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    if (v10 >= v11)
    {
      v12 = *a1;
    }
    else
    {
      if ((_DWORD)v10)
        memmove((void *)(*((_QWORD *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      **((_DWORD **)a1 + 1) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 168;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 169;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

ssize_t AAArchiveStreamProcess(AAArchiveStream istream, AAArchiveStream ostream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  void *v10;
  int v11;
  ssize_t v12;
  AAHeader_impl *v13;
  AAFieldKey v14;
  uint32_t KeyIndex;
  unsigned int FieldString;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  unint64_t *v25;
  size_t v26;
  AAFieldKey v27;
  AAFieldKey v28;
  BOOL v29;
  const char *v30;
  __int16 v31;
  int v32;
  void *v34;
  uint64_t __s;
  void *v36;
  AAHeader header;
  char value[1024];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v36 = 0;
  header = 0;
  __s = 0;
  v10 = malloc(0x40000uLL);
  if (!v10)
  {
    v32 = *__error();
    v30 = "malloc";
    v31 = 24;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStreamProcess.c", (uint64_t)"AAArchiveStreamProcess", v31, 16, v32, v30, v19, v20, (char)v34);
    v12 = -1;
    goto LABEL_35;
  }
  v11 = AAArchiveStreamReadHeader(istream, &header);
  if (v11 < 0)
  {
LABEL_29:
    AAArchiveStreamCancel(ostream);
    v30 = "archive stream read error (header)";
    v31 = 32;
LABEL_33:
    v32 = 0;
    goto LABEL_34;
  }
  v12 = 0;
  while (v11)
  {
    if (!msg_proc)
      goto LABEL_41;
    v13 = header;
    v14.ikey = 5521744;
    KeyIndex = AAHeaderGetKeyIndex(header, v14);
    if ((KeyIndex & 0x80000000) != 0)
      goto LABEL_41;
    FieldString = AAHeaderGetFieldString(v13, KeyIndex, 0x400uLL, value, 0);
    v17 = FieldString <= 1 ? 1 : FieldString;
    if (v17 < 1)
      goto LABEL_41;
    v18 = ((uint64_t (*)(void *, uint64_t, char *, AAHeader))msg_proc)(msg_data, 50, value, header);
    if (v18 < 0)
    {
      v30 = "callback cancel";
      v31 = 45;
      goto LABEL_33;
    }
    if (!v18)
    {
LABEL_41:
      if ((aaHeaderBlobArrayInitWithHeader((uint64_t)&__s, header) & 0x80000000) != 0)
      {
        v30 = "capturing non-empty blobs";
        v31 = 55;
        goto LABEL_33;
      }
      if (AAArchiveStreamWriteHeader(ostream, header) < 0)
      {
        AAArchiveStreamCancel(istream);
        v30 = "archive stream write error (header)";
        v31 = 61;
        goto LABEL_33;
      }
      ++v12;
      v21 = __s;
      if ((_DWORD)__s)
      {
        v34 = msg_data;
        v22 = 0;
        while (1)
        {
          v23 = (char *)v36 + 24 * v22;
          v25 = (unint64_t *)(v23 + 8);
          v24 = *((_QWORD *)v23 + 1);
          if (v24)
            break;
LABEL_26:
          if (++v22 >= v21)
          {
            msg_data = v34;
            goto LABEL_28;
          }
        }
        while (1)
        {
          if (v24 >= 0x40000)
            v26 = 0x40000;
          else
            v26 = v24;
          v27 = *(AAFieldKey *)v23;
          if (AAArchiveStreamReadBlob(istream, v27, v10, v26) < 0)
          {
            AAArchiveStreamCancel(ostream);
            v30 = "archive stream read error (blob)";
            v31 = 75;
            goto LABEL_33;
          }
          v28 = *(AAFieldKey *)v23;
          if (AAArchiveStreamWriteBlob(ostream, v28, v10, v26) < 0)
            break;
          v24 = *v25 - v26;
          v29 = *v25 == v26;
          *v25 = v24;
          if (v29)
          {
            v21 = __s;
            goto LABEL_26;
          }
        }
        AAArchiveStreamCancel(istream);
        v30 = "archive stream write error (blob)";
        v31 = 80;
        goto LABEL_33;
      }
    }
LABEL_28:
    v11 = AAArchiveStreamReadHeader(istream, &header);
    if (v11 < 0)
      goto LABEL_29;
  }
LABEL_35:
  AAHeaderDestroy(header);
  free(v36);
  memset_s(&__s, 0x10uLL, 0, 0x10uLL);
  free(v10);
  return v12;
}

uint64_t treeDeleteRangeWithPoint(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t result;

  v8 = *a2;
  if (*a2 < 0)
    return 0;
  v9 = a3;
  v12 = *(_QWORD *)(a1 + 8);
  v13 = (_QWORD *)(v12 + 56 * v8);
  if (*v13 > a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 24, a3) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 456, 107, 0, "treeDelete: %zd", v18, v19, v9);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  if (*(_QWORD *)(v12 + 56 * v8 + 8) <= a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 32, a3) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 463, 107, 0, "treeDelete: %zd", v18, v19, v9);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  v20 = v12 + 56 * v8;
  v23 = *(_QWORD *)(v20 + 24);
  v21 = v20 + 24;
  v22 = v23;
  v24 = v21 + 8;
  v25 = *(_QWORD *)(v21 + 8);
  if ((v23 & 0x8000000000000000) == 0)
  {
    if (v25 < 0)
      v26 = 0;
    else
      v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    v27 = *(_DWORD *)(v12 + 56 * v22 + 48);
LABEL_15:
    if (v26 >= v27)
    {
      if ((v25 & 0x8000000000000000) == 0)
      {
        do
        {
          v28 = v25;
          v25 = *(_QWORD *)(v12 + 56 * v25 + 24);
        }
        while ((v25 & 0x8000000000000000) == 0);
        goto LABEL_29;
      }
      v31 = v8;
      while (1)
      {
        v28 = *(_QWORD *)(v12 + 56 * v31 + 16);
        if (v28 < 0)
          break;
        v30 = *(_QWORD *)(v12 + 56 * v28 + 32) == v31;
        v31 = *(_QWORD *)(v12 + 56 * v31 + 16);
        if (!v30)
          goto LABEL_29;
      }
    }
    else
    {
      if ((v22 & 0x8000000000000000) == 0)
      {
        do
        {
          v28 = v22;
          v22 = *(_QWORD *)(v12 + 56 * v22 + 32);
        }
        while ((v22 & 0x8000000000000000) == 0);
LABEL_25:
        v24 = v21;
LABEL_29:
        v32 = *(_OWORD *)(v12 + 56 * v28);
        *(_OWORD *)v13 = v32;
        if ((treeDeleteRangeWithPoint(a1, v24, v32) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 493, 107, 0, "treeDelete: %zd", v18, v19, v9);
          return 0xFFFFFFFFLL;
        }
LABEL_30:
        v33 = *(_QWORD *)(a1 + 8);
        v34 = (_QWORD *)(v33 + 56 * v8);
        v35 = v34[3];
        if (v35 < 0)
          v36 = 0;
        else
          v36 = *(_DWORD *)(v33 + 56 * v35 + 48);
        v37 = *(_QWORD *)(v33 + 56 * v8 + 32);
        if (v37 < 0)
          v38 = 0;
        else
          v38 = *(_DWORD *)(v33 + 56 * v37 + 48);
        if (v38 > v36)
          v36 = v38;
        v39 = v33 + 56 * v8;
        *(_DWORD *)(v39 + 48) = v36 + 1;
        v40 = *(_QWORD *)(v39 + 8) - *v34;
        if (v35 < 0)
          v41 = 0;
        else
          v41 = *(_QWORD *)(v33 + 56 * v35 + 40);
        v42 = v40 + v41;
        if (v37 < 0)
          v43 = 0;
        else
          v43 = *(_QWORD *)(v33 + 56 * v37 + 40);
        *(_QWORD *)(v33 + 56 * v8 + 40) = v42 + v43;
        if ((treeRebalance(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 499, 107, 0, "treeRebalance: %zd", v44, v45, v8);
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      v29 = v8;
      while (1)
      {
        v28 = *(_QWORD *)(v12 + 56 * v29 + 16);
        if (v28 < 0)
          break;
        v30 = *(_QWORD *)(v12 + 56 * v28 + 24) == v29;
        v29 = *(_QWORD *)(v12 + 56 * v29 + 16);
        if (!v30)
          goto LABEL_25;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 490, 107, 0, "no nodePrev/Next: %zd", a7, a8, v8);
    return 0xFFFFFFFFLL;
  }
  if ((v25 & 0x8000000000000000) == 0)
  {
    v27 = 0;
    v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    goto LABEL_15;
  }
  result = 0;
  *(_QWORD *)(v12 + 56 * v8 + 16) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v8;
  *a2 = -1;
  return result;
}

uint64_t treeRebalance(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t result;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v8 = *a2;
  v35 = v8;
  if (v8 < 0)
    return 0;
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(_QWORD *)(v11 + 56 * v8 + 32);
  v13 = v12 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v12 + 48);
  v14 = *(_QWORD *)(v11 + 56 * v8 + 24);
  v15 = v14 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v14 + 48);
  v16 = v13 - v15;
  if ((v16 + 1) < 3)
    return 0;
  if (v16 == -2)
  {
    if ((v14 & 0x8000000000000000) == 0)
    {
      v20 = *(_QWORD *)(v11 + 56 * v14 + 32);
      v21 = v20 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v20 + 48);
      v28 = *(_QWORD *)(v11 + 56 * v14 + 24);
      v29 = v28 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v28 + 48);
      if (v21 > v29)
      {
        v34 = v14;
        if ((treeRotateLeft(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 360, 107, 0, "treeRotateLeft %zd", v30, v31, v34);
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * v8 + 24) = v34;
      }
    }
    if ((treeRotateRight(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 364, 107, 0, "treeRotateRight %zd", v32, v33, v35);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_36;
  }
  if (v16 == 2)
  {
    if ((v12 & 0x8000000000000000) == 0)
    {
      v18 = *(_QWORD *)(v11 + 56 * v12 + 32);
      v19 = v18 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v18 + 48);
      v22 = *(_QWORD *)(v11 + 56 * v12 + 24);
      v23 = v22 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v22 + 48);
      if (v19 < v23)
      {
        v34 = v12;
        if ((treeRotateRight(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 347, 107, 0, "treeRotateRight %zd", v24, v25, v34);
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * v8 + 32) = v34;
      }
    }
    if ((treeRotateLeft(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 351, 107, 0, "treeRotateRight %zd", v26, v27, v35);
      return 0xFFFFFFFFLL;
    }
LABEL_36:
    result = 0;
    *a2 = v35;
    return result;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 366, 107, 0, "invalid imbalance: %d", a7, a8, v16);
  return 0xFFFFFFFFLL;
}

uint64_t treeSub(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t result;
  const char *v23;
  __int16 v24;
  char v25;

  v9 = (uint64_t *)(a1 + 2);
  v8 = a1[2];
  if (v8 < 0)
    return 0;
  while (2)
  {
    v13 = a1[1];
    while (1)
    {
      v14 = (uint64_t *)(v13 + 56 * v8);
      v15 = *v14;
      if (*v14 >= a3)
      {
        v20 = (uint64_t *)(v13 + 56 * v8 + 24);
        goto LABEL_7;
      }
      v16 = v13 + 56 * v8;
      v19 = *(_QWORD *)(v16 + 8);
      v18 = (uint64_t *)(v16 + 8);
      v17 = v19;
      if (v19 > a2)
        break;
      v20 = (uint64_t *)(v13 + 56 * v8 + 32);
LABEL_7:
      v8 = *v20;
      if (v8 < 0)
        return 0;
    }
    if (v15 < a2 || v17 > a3)
    {
      if (v15 >= a2)
      {
        *v14 = a3;
      }
      else
      {
        *v18 = a2;
        if (v17 > a3 && (treeAdd(a1, -1, v9, a3, v17, a6, a7, a8) & 0x80000000) != 0)
        {
          v23 = "treeAdd";
          v24 = 538;
          goto LABEL_23;
        }
      }
LABEL_20:
      result = 0;
      v8 = *v9;
      if (*v9 < 0)
        return result;
      continue;
    }
    break;
  }
  if ((treeDeleteRangeWithPoint((uint64_t)a1, v9, v15, a4, v17, a6, a7, a8) & 0x80000000) == 0)
    goto LABEL_20;
  v23 = "treeDeleteRangeWithPoint";
  v24 = 525;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeSub", v24, 107, 0, v23, a7, a8, v25);
  return 0xFFFFFFFFLL;
}

uint64_t treeAdd(unint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v13;
  char *v15;
  char *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int64_t v23;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  int *v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;

  v8 = a5 - a4;
  if (a5 <= a4)
    return 0;
  v13 = *a3;
  v55 = v13;
  if (v13 < 0)
  {
    v13 = a1[3];
    if ((v13 & 0x8000000000000000) == 0)
    {
      v15 = (char *)a1[1];
      goto LABEL_5;
    }
    if (*a1)
      v36 = 2 * *a1;
    else
      v36 = 32;
    if (56 * v36 < 0x2000000001)
    {
      v46 = (void *)a1[1];
      v15 = (char *)realloc(v46, 56 * v36);
      if (v15)
      {
        a1[1] = (unint64_t)v15;
        v47 = *a1;
        if (*a1 >= v36)
        {
          v13 = -1;
        }
        else
        {
          v48 = (uint64_t *)&v15[56 * v47 + 16];
          v49 = -1;
          do
          {
            *v48 = v49;
            v48 += 7;
            v49 = v47++;
          }
          while (v36 != v47);
          v13 = v47 - 1;
        }
        *a1 = v36;
LABEL_5:
        v16 = &v15[56 * v13];
        a1[3] = *((_QWORD *)v16 + 2);
        *((_QWORD *)v16 + 2) = a2;
        *((_QWORD *)v16 + 3) = -1;
        *(_QWORD *)v16 = a4;
        *((_QWORD *)v16 + 1) = a5;
        *((_DWORD *)v16 + 12) = 1;
        *((_QWORD *)v16 + 4) = -1;
        *((_QWORD *)v16 + 5) = v8;
        v55 = v13;
        if ((v13 & 0x8000000000000000) == 0)
          goto LABEL_6;
LABEL_75:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 391, 107, 0, "nodeAlloc", a7, a8, v53);
        return 0xFFFFFFFFLL;
      }
      free(v46);
    }
    else
    {
      *__error() = 12;
    }
    a1[1] = 0;
    v50 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"nodeAlloc", 43, 107, *v50, "malloc", v51, v52, v53);
    goto LABEL_75;
  }
LABEL_6:
  v17 = a1[1];
  v18 = (uint64_t *)(v17 + 56 * v13);
  v19 = *v18;
  v20 = v18[3];
  if (v20 < 0)
  {
    v23 = 0x8000000000000000;
  }
  else
  {
    v21 = v18[3];
    do
    {
      v22 = v21;
      v21 = *(_QWORD *)(v17 + 56 * v21 + 32);
    }
    while ((v21 & 0x8000000000000000) == 0);
    v23 = *(_QWORD *)(v17 + 56 * v22 + 8);
  }
  if (v19 > a4 && v19 <= a5 && v23 < v19)
  {
    if (a4 <= v23)
      v19 = v23;
    else
      v19 = a4;
    *v18 = v19;
  }
  v25 = *(_QWORD *)(v17 + 56 * v13 + 32);
  if (v25 < 0)
  {
    v27 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    do
    {
      v26 = v25;
      v25 = *(_QWORD *)(v17 + 56 * v25 + 24);
    }
    while ((v25 & 0x8000000000000000) == 0);
    v27 = *(_QWORD *)(v17 + 56 * v26);
  }
  v30 = v18[1];
  v28 = v18 + 1;
  v29 = v30;
  if (v30 < a5 && v29 >= a4 && v27 > v29)
  {
    if (v27 >= a5)
      v29 = a5;
    else
      v29 = v27;
    *v28 = v29;
  }
  if (v19 > a4)
  {
    if (v19 >= a5)
      v31 = a5;
    else
      v31 = v19;
    v54 = v20;
    if ((treeAdd(a1, v13, &v54, a4, v31) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 418, 107, 0, "treeAdd: %zd", a7, a8, v54);
      return 0xFFFFFFFFLL;
    }
    v17 = a1[1];
    *(_QWORD *)(v17 + 56 * v13 + 24) = v54;
  }
  if (v29 < a5)
  {
    if (v29 <= a4)
      v32 = a4;
    else
      v32 = v29;
    v54 = *(_QWORD *)(v17 + 56 * v13 + 32);
    if ((treeAdd(a1, v13, &v54, v32, a5) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 428, 107, 0, "treeAdd: %zd", a7, a8, v54);
      return 0xFFFFFFFFLL;
    }
    v17 = a1[1];
    *(_QWORD *)(v17 + 56 * v13 + 32) = v54;
  }
  if ((v13 & 0x8000000000000000) == 0)
  {
    v33 = (_QWORD *)(v17 + 56 * v13);
    v34 = v33[3];
    if (v34 < 0)
      v35 = 0;
    else
      v35 = *(_DWORD *)(v17 + 56 * v34 + 48);
    v37 = *(_QWORD *)(v17 + 56 * v13 + 32);
    if (v37 < 0)
      v38 = 0;
    else
      v38 = *(_DWORD *)(v17 + 56 * v37 + 48);
    if (v38 > v35)
      v35 = v38;
    v39 = v17 + 56 * v13;
    *(_DWORD *)(v39 + 48) = v35 + 1;
    v40 = *(_QWORD *)(v39 + 8) - *v33;
    if (v34 < 0)
      v41 = 0;
    else
      v41 = *(_QWORD *)(v17 + 56 * v34 + 40);
    v42 = v40 + v41;
    if (v37 < 0)
      v43 = 0;
    else
      v43 = *(_QWORD *)(v17 + 56 * v37 + 40);
    *(_QWORD *)(v17 + 56 * v13 + 40) = v42 + v43;
  }
  if ((treeRebalance((uint64_t)a1, &v55, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
  {
    result = 0;
    *a3 = v55;
    return result;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 434, 107, 0, "treeRebalance: %zd", v44, v45, v55);
  return 0xFFFFFFFFLL;
}

_QWORD *AAByteRangeCreate()
{
  _QWORD *v0;
  _QWORD *v1;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char v6;

  v0 = malloc(0x20uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x20uLL, 0, 0x20uLL);
    v1[2] = -1;
    v1[3] = -1;
  }
  else
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeCreate", 551, 107, *v2, "malloc", v3, v4, v6);
    AAByteRangeDestroy(0);
  }
  return v1;
}

void AAByteRangeDestroy(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1);
  }
}

_QWORD *AAByteRangeClone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  size_t v4;
  void *v5;
  __int16 v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v11;

  v2 = malloc(0x20uLL);
  v3 = v2;
  if (!v2)
  {
    v6 = 563;
    goto LABEL_10;
  }
  memset_s(v2, 0x20uLL, 0, 0x20uLL);
  v3[2] = -1;
  v3[3] = -1;
  if ((*(_QWORD *)(a1 + 16) & 0x8000000000000000) == 0)
  {
    v4 = *(_QWORD *)a1;
    if (is_mul_ok(*(_QWORD *)a1, 0x38uLL) && 56 * v4 < 0x2000000001)
    {
      v5 = calloc(v4, 0x38uLL);
      v3[1] = v5;
      if (v5)
      {
        memcpy(v5, *(const void **)(a1 + 8), 56 * *(_QWORD *)a1);
        *v3 = *(_QWORD *)a1;
        *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 16);
        return v3;
      }
    }
    else
    {
      *__error() = 12;
      v3[1] = 0;
    }
    v6 = 570;
LABEL_10:
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeClone", v6, 107, *v7, "malloc", v8, v9, v11);
    AAByteRangeDestroy((void **)v3);
    return 0;
  }
  return v3;
}

uint64_t AAByteRangeAdd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  const char *v10;
  __int16 v11;

  if (a2 == a3)
    return 0;
  if (a2 <= a3)
  {
    if ((treeAdd((unint64_t *)a1, -1, (uint64_t *)(a1 + 16), a2, a3, a6, a7, a8) & 0x80000000) == 0)
      return 0;
    v10 = "addSegment";
    v11 = 595;
  }
  else
  {
    v10 = "Invalid segment bounds";
    v11 = 593;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeAdd", v11, 107, 0, v10, a7, a8, v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSub(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  const char *v10;
  __int16 v11;

  if (a2 == a3)
    return 0;
  if (a2 <= a3)
  {
    if ((a1[2] & 0x8000000000000000) != 0 || (treeSub(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
      return 0;
    v10 = "subSegment";
    v11 = 612;
  }
  else
  {
    v10 = "Invalid segment bounds";
    v11 = 609;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeSub", v11, 107, 0, v10, a7, a8, v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSizeAtOffset(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 < 0)
    return 0;
  result = 0;
  v5 = *(_QWORD *)(a1 + 8);
  while (1)
  {
    v6 = (uint64_t *)(v5 + 56 * v2);
    v9 = *v6;
    v8 = v6 + 3;
    v7 = v9;
    v10 = a2 - v9;
    if (a2 > v9)
      break;
LABEL_9:
    v2 = *v8;
    if (*v8 < 0)
      return result;
  }
  v11 = *v8;
  if (v11 < 0)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v5 + 56 * v11 + 40);
  v13 = v12 + result;
  v14 = *(_QWORD *)(v5 + 56 * v2 + 8);
  if (v14 < a2)
  {
    result = v14 - v7 + v13;
    v8 = (uint64_t *)(v5 + 56 * v2 + 32);
    goto LABEL_9;
  }
  return v10 + v13;
}

uint64_t AAByteRangeOffsetAtSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 16);
  if ((v2 & 0x8000000000000000) == 0)
  {
    v3 = *(_QWORD *)(a1 + 8);
    do
    {
      v4 = (uint64_t *)(v3 + 56 * v2);
      if (a2 > v4[5])
        break;
      v5 = *(_QWORD *)(v3 + 56 * v2 + 24);
      if (v5 < 0)
        v6 = 0;
      else
        v6 = *(_QWORD *)(v3 + 56 * v5 + 40);
      v7 = __OFSUB__(a2, v6);
      v8 = a2 - v6;
      if (!((v8 < 0) ^ v7 | (v8 == 0)))
      {
        v9 = *v4;
        v10 = *(_QWORD *)(v3 + 56 * v2 + 8) - v9;
        a2 = v8 - v10;
        if (v8 <= v10)
          return v9 + v8;
        v5 = *(_QWORD *)(v3 + 56 * v2 + 32);
      }
      v2 = v5;
    }
    while ((v5 & 0x8000000000000000) == 0);
  }
  return -1;
}

uint64_t AAByteRangeFirst(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t First;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;

  First = findFirst(a1, *(_QWORD *)(a1 + 16), a2);
  if (First < 0)
    return -1;
  v8 = First;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(v9 + 56 * First);
  while (1)
  {
    result = v8;
    v12 = v9 + 56 * v8;
    v13 = *(_QWORD *)(v12 + 8);
    v14 = *(_QWORD *)(v12 + 32);
    v15 = result;
    if (v14 < 0)
      break;
    do
    {
      v8 = v14;
      v14 = *(_QWORD *)(v9 + 56 * v14 + 24);
    }
    while ((v14 & 0x8000000000000000) == 0);
LABEL_8:
    if (*(_QWORD *)(v9 + 56 * v8) != v13)
      goto LABEL_9;
  }
  while (1)
  {
    v8 = *(_QWORD *)(v9 + 56 * v15 + 16);
    if (v8 < 0)
      break;
    v16 = *(_QWORD *)(v9 + 56 * v8 + 32) == v15;
    v15 = *(_QWORD *)(v9 + 56 * v15 + 16);
    if (!v16)
      goto LABEL_8;
  }
LABEL_9:
  *a3 = v10;
  *a4 = v13;
  return result;
}

uint64_t findFirst(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t First;

  if (a2 < 0)
    return -1;
  v4 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  while (1)
  {
    if (*(_QWORD *)(v6 + 56 * v4) > a3)
    {
      First = findFirst(a1, *(_QWORD *)(v6 + 56 * v4 + 24), a3);
      if ((First & 0x8000000000000000) == 0)
        break;
    }
    if (*(_QWORD *)(v6 + 56 * v4 + 8) > a3)
      return v4;
    v4 = *(_QWORD *)(v6 + 56 * v4 + 32);
    if (v4 < 0)
      return -1;
  }
  return First;
}

uint64_t AAByteRangeNext(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  BOOL v7;
  _QWORD *v8;

  if (a2 < 0)
    return -1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v4 + 56 * a2 + 32);
  if (v5 < 0)
  {
    while (1)
    {
      result = *(_QWORD *)(v4 + 56 * a2 + 16);
      if (result < 0)
        break;
      v7 = *(_QWORD *)(v4 + 56 * result + 32) == a2;
      a2 = *(_QWORD *)(v4 + 56 * a2 + 16);
      if (!v7)
        goto LABEL_9;
    }
  }
  else
  {
    do
    {
      result = v5;
      v5 = *(_QWORD *)(v4 + 56 * v5 + 24);
    }
    while ((v5 & 0x8000000000000000) == 0);
LABEL_9:
    v8 = (_QWORD *)(v4 + 56 * result);
    *a3 = *v8;
    *a4 = v8[1];
  }
  return result;
}

uint64_t treeRotateRight(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t result;
  _QWORD *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;

  v2 = *a2;
  if (*a2 < 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = v3 + 56 * v2;
  v7 = *(_QWORD *)(v4 + 24);
  v6 = (_QWORD *)(v4 + 24);
  v5 = v7;
  if (v7 < 0)
    return 0xFFFFFFFFLL;
  v8 = v3 + 56 * v5;
  v9 = *(_QWORD *)(v8 + 32);
  *(_QWORD *)(v8 + 32) = v2;
  v10 = v3 + 56 * v2;
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(v10 + 16);
  *(_QWORD *)(v10 + 16) = v5;
  *v6 = v9;
  if (v9 < 0)
  {
    v12 = 0;
  }
  else
  {
    v11 = v3 + 56 * v9;
    *(_QWORD *)(v11 + 16) = v2;
    v12 = *(_DWORD *)(v11 + 48);
  }
  v14 = (_QWORD *)(v3 + 56 * v2);
  v15 = v14[4];
  if (v15 < 0)
    v16 = 0;
  else
    v16 = *(_DWORD *)(v3 + 56 * v15 + 48);
  if (v16 > v12)
    v12 = v16;
  v17 = v12 + 1;
  v18 = v3 + 56 * v2;
  *(_DWORD *)(v18 + 48) = v17;
  v19 = *(_QWORD *)(v18 + 8) - *v14;
  if (v9 < 0)
    v20 = 0;
  else
    v20 = *(_QWORD *)(v3 + 56 * v9 + 40);
  v21 = v19 + v20;
  if (v15 < 0)
    v22 = 0;
  else
    v22 = *(_QWORD *)(v3 + 56 * v15 + 40);
  v23 = v21 + v22;
  *(_QWORD *)(v3 + 56 * v2 + 40) = v23;
  v24 = (_QWORD *)(v3 + 56 * v5);
  v25 = v24[3];
  if (v25 < 0)
    v26 = 0;
  else
    v26 = *(_DWORD *)(v3 + 56 * v25 + 48);
  if (v17 <= v26)
    v17 = v26;
  v27 = v3 + 56 * v5;
  *(_DWORD *)(v27 + 48) = v17 + 1;
  if (v25 < 0)
    v28 = 0;
  else
    v28 = *(_QWORD *)(v3 + 56 * v25 + 40);
  result = 0;
  *(_QWORD *)(v3 + 56 * v5 + 40) = *(_QWORD *)(v27 + 8) - *v24 + v28 + v23;
  *a2 = v5;
  return result;
}

uint64_t treeRotateLeft(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v2 = *a2;
  if (*a2 < 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = v3 + 56 * v2;
  v7 = *(_QWORD *)(v4 + 32);
  v6 = (_QWORD *)(v4 + 32);
  v5 = v7;
  if (v7 < 0)
    return 0xFFFFFFFFLL;
  v8 = v3 + 56 * v5;
  v9 = *(_QWORD *)(v8 + 24);
  v10 = v3 + 56 * v2;
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(v10 + 16);
  *(_QWORD *)(v8 + 24) = v2;
  *(_QWORD *)(v10 + 16) = v5;
  *v6 = v9;
  if ((v9 & 0x8000000000000000) == 0)
    *(_QWORD *)(v3 + 56 * v9 + 16) = v2;
  v11 = (_QWORD *)(v3 + 56 * v2);
  v12 = v11[3];
  if (v12 < 0)
  {
    v13 = 0;
    if ((v9 & 0x8000000000000000) == 0)
      goto LABEL_7;
LABEL_10:
    v14 = 0;
    goto LABEL_11;
  }
  v13 = *(_DWORD *)(v3 + 56 * v12 + 48);
  if (v9 < 0)
    goto LABEL_10;
LABEL_7:
  v14 = *(_DWORD *)(v3 + 56 * v9 + 48);
LABEL_11:
  if (v14 > v13)
    v13 = v14;
  v16 = v13 + 1;
  v17 = v3 + 56 * v2;
  *(_DWORD *)(v17 + 48) = v16;
  v18 = *(_QWORD *)(v17 + 8) - *v11;
  if (v12 < 0)
    v19 = 0;
  else
    v19 = *(_QWORD *)(v3 + 56 * v12 + 40);
  v20 = v18 + v19;
  if (v9 < 0)
    v21 = 0;
  else
    v21 = *(_QWORD *)(v3 + 56 * v9 + 40);
  v22 = v20 + v21;
  *(_QWORD *)(v3 + 56 * v2 + 40) = v22;
  v23 = (_QWORD *)(v3 + 56 * v5);
  v24 = v23[4];
  if (v24 < 0)
    v25 = 0;
  else
    v25 = *(_DWORD *)(v3 + 56 * v24 + 48);
  if (v25 > v16)
    v16 = v25;
  v26 = v3 + 56 * v5;
  *(_DWORD *)(v26 + 48) = v16 + 1;
  v27 = *(_QWORD *)(v26 + 8) - *v23 + v22;
  if (v24 < 0)
    v28 = 0;
  else
    v28 = *(_QWORD *)(v3 + 56 * v24 + 40);
  result = 0;
  *(_QWORD *)(v3 + 56 * v5 + 40) = v27 + v28;
  *a2 = v5;
  return result;
}

_QWORD *aaArchiveFileOutputStreamOpenAt(int a1, const char *a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6, __int16 a7)
{
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  int v27;
  int v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  AAByteStream_impl *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  size_t v42;
  size_t v43;
  void *v44;
  void *v45;
  char v46;

  v14 = calloc(1uLL, 0x68uLL);
  v15 = malloc(0x80uLL);
  v16 = (uint64_t)v15;
  if (v15)
  {
    memset_s(v15, 0x80uLL, 0, 0x80uLL);
    if (v14)
    {
      *(_DWORD *)v16 = -1;
      if ((a7 & 0x100) == 0)
      {
        if (a1 < 0)
          unlink(a2);
        else
          unlinkat(a1, a2, 0);
      }
      if ((a7 & 1) != 0)
        a6 = 4;
      if (a6 < 1)
      {
        v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0)
        {
          v46 = -92;
          v28 = a1 < 0 ? open(a2, 1537) : openat(a1, a2, 1537);
          *(_DWORD *)v16 = v28;
          if (v28 < 0)
          {
            v21 = *__error();
            v46 = (char)a2;
            v24 = "%s";
            v25 = 358;
            goto LABEL_7;
          }
        }
      }
      else if (a1 < 0)
      {
        v46 = -92;
        v28 = open_dprotected_np(a2, 1537, a6, 0);
        *(_DWORD *)v16 = v28;
        if (v28 < 0)
        {
LABEL_22:
          v21 = *__error();
          v46 = (char)a2;
          v24 = "%s";
          v25 = 349;
          goto LABEL_7;
        }
      }
      else
      {
        v27 = openat(a1, a2, 1537, 420);
        *(_DWORD *)v16 = v27;
        if (v27 < 0)
          goto LABEL_22;
        v46 = a6;
        if (fcntl(v27, 64) < 0)
        {
          v21 = *__error();
          v24 = "fcntl F_SETPROTECTIONCLASS";
          v25 = 347;
          goto LABEL_7;
        }
        v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0)
          goto LABEL_22;
      }
      if ((a7 & 8) != 0)
      {
        v46 = 1;
        if (fcntl(v28, 48))
        {
          v29 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", 366, 67, "Warning: F_NOCACHE failed with error %d: %s\n", v30, v31, v32, *v29);
        }
      }
      if ((a7 & 2) != 0)
      {
        v46 = 1;
        if (fcntl(*(_DWORD *)v16, 68) == -1)
        {
          v33 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", 375, 67, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v34, v35, v36, *v33);
        }
      }
      if (a3 > 0)
      {
        if (a4 != -1 && (a7 & 4) != 0)
        {
          v37 = AAAFSCStreamOpen(*(_DWORD *)v16, a3, a4, a5, v17, v18, v19, v20);
          *(_QWORD *)(v16 + 40) = v37;
          if (!v37)
          {
            v46 = (char)a2;
            v24 = "ParallelCompressionAFSCStreamOpen failed: %s";
            v25 = 384;
            goto LABEL_60;
          }
        }
        if ((a7 & 0x40) != 0 && !*(_QWORD *)(v16 + 40))
        {
          v38 = fpathconf(*(_DWORD *)v16, 27);
          if (v38 >= 1)
          {
            *(_DWORD *)(v16 + 88) = 1;
            if (v38 == 4096)
            {
              *(_QWORD *)(v16 + 96) = 4096;
            }
            else
            {
              v39 = 0x10000;
              if (v38 < 0x10000)
                v39 = v38;
              v40 = 1024;
              do
              {
                v41 = v40;
                v40 *= 2;
              }
              while (v41 < v39);
              *(_QWORD *)(v16 + 96) = v41;
            }
          }
        }
      }
      *(_QWORD *)(v16 + 16) = a3;
      *(_QWORD *)(v16 + 56) = 0x40000;
      if (*(_QWORD *)(v16 + 40))
        goto LABEL_58;
      v42 = *(_QWORD *)(v16 + 72);
      if (v42 >> 18)
        goto LABEL_58;
      do
      {
        v43 = (v42 >> 1) + v42;
        if (((v42 >> 1) & v42) != 0)
          v43 = ((v42 >> 1) & v42) + v42;
        if (v42)
          v42 = v43;
        else
          v42 = 0x4000;
      }
      while (v42 < 0x40000);
      v44 = *(void **)(v16 + 80);
      v45 = realloc(v44, v42);
      if (v45)
      {
        *(_QWORD *)(v16 + 72) = v42;
        *(_QWORD *)(v16 + 80) = v45;
LABEL_58:
        *v14 = v16;
        v14[1] = afStreamClose;
        v14[7] = afStreamCancel;
        v14[3] = afStreamWrite;
        v14[12] = afStreamCloseWithState;
        return v14;
      }
      free(v44);
      *(_QWORD *)(v16 + 64) = 0;
      *(_QWORD *)(v16 + 72) = 0;
      *(_QWORD *)(v16 + 80) = 0;
      v24 = "alloc blob";
      v25 = 429;
LABEL_60:
      v21 = 0;
      goto LABEL_7;
    }
  }
  v21 = *__error();
  v24 = "malloc";
  v25 = 324;
LABEL_7:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", v25, 67, v21, v24, v22, v23, v46);
  afStreamClose(v16);
  free(v14);
  return 0;
}

uint64_t afStreamClose(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  _BOOL4 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 48));
    v3 = v2 == 0;
    if (AAByteStreamClose(*(AAByteStream *)(result + 40)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 197, 67, 0, "closing AFSC stream", v4, v5, v15);
      v3 = 0;
    }
    if (*(_QWORD *)(v1 + 120) && *(_QWORD *)(v1 + 104))
    {
      v6 = 0;
      v7 = 0;
      while (1)
      {
        v8 = (uint64_t *)(*(_QWORD *)(v1 + 120) + v6);
        v18 = 0;
        v19 = 0;
        v17 = 0;
        v18 = *v8;
        v19 = v8[1] - v18;
        if (fcntl(*(_DWORD *)v1, 99, &v17) < 0)
          break;
        ++v7;
        v6 += 16;
        if (v7 >= *(_QWORD *)(v1 + 104))
          goto LABEL_11;
      }
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 209, 67, "F_PUNCHHOLE failed", v9, v10, v11, v16);
    }
LABEL_11:
    if ((*(_BYTE *)(v1 + 8) & 0x10) != 0 && fcntl(*(_DWORD *)v1, 51) == -1)
    {
      v12 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 218, 67, *v12, "Final FULLFSYNC", v13, v14, 0);
    }
    if ((*(_DWORD *)v1 & 0x80000000) == 0 && !*(_DWORD *)(v1 + 4))
      close(*(_DWORD *)v1);
    free(*(void **)(v1 + 80));
    memset_s((void *)(v1 + 64), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 120));
    free((void *)v1);
    return (v3 - 1);
  }
  return result;
}

uint64_t afStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 48);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

uint64_t afStreamWrite(uint64_t a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v10;
  unint64_t v12;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  size_t v21;
  size_t *v22;
  uint64_t v23;
  size_t v24;
  BOOL v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  size_t v29;
  void *v30;
  void *v31;
  uint64_t v32;
  char v33;

  v8 = (unsigned int *)(a1 + 48);
  if (atomic_load((unsigned int *)(a1 + 48)))
    return -1;
  v12 = a3;
  v14 = *(_QWORD *)(a1 + 24);
  if (__CFADD__(a3, v14) || (unint64_t)(a3 + v14) > *(_QWORD *)(a1 + 16))
  {
    v33 = a3 + v14;
    v18 = "received too many bytes %llu/%llu";
    v19 = 275;
    goto LABEL_14;
  }
  v15 = (char *)__src;
  v16 = *(_QWORD **)(a1 + 40);
  if (!v16)
  {
    if (a3)
    {
      v10 = 0;
      v22 = (size_t *)(a1 + 64);
      v21 = *(_QWORD *)(a1 + 64);
      while (1)
      {
        v23 = *(_QWORD *)(a1 + 56);
        v24 = v23 - v21;
        if (v23 == v21)
        {
          if ((flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
          {
            v18 = "flush buf";
            v19 = 284;
            goto LABEL_14;
          }
          v21 = *v22;
        }
        if (v12 < v24)
          v24 = v12;
        v25 = __CFADD__(v21, v24);
        v26 = v21 + v24;
        if (v25 || (v26 & 0x8000000000000000) != 0)
          goto LABEL_59;
        v27 = *(_QWORD *)(a1 + 72);
        if (v27 < v26)
        {
          do
          {
            while (!v27)
            {
              v27 = 0x4000;
              v29 = 0x4000;
              if (v26 <= 0x4000)
                goto LABEL_37;
            }
            v28 = v27 >> 1;
            if ((v27 & (v27 >> 1)) != 0)
              v28 = v27 & (v27 >> 1);
            v27 += v28;
          }
          while (v27 < v26);
          v29 = v27;
          if (v27 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_58;
          }
LABEL_37:
          v30 = *(void **)(a1 + 80);
          v31 = realloc(v30, v29);
          if (!v31)
          {
            free(v30);
LABEL_58:
            *v22 = 0;
            *(_QWORD *)(a1 + 72) = 0;
            *(_QWORD *)(a1 + 80) = 0;
LABEL_59:
            v18 = "append to buf";
            v19 = 286;
LABEL_14:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamWrite", v19, 67, 0, v18, a7, a8, v33);
            v10 = -1;
            goto LABEL_15;
          }
          *(_QWORD *)(a1 + 72) = v29;
          *(_QWORD *)(a1 + 80) = v31;
        }
        v32 = *(_QWORD *)(a1 + 80);
        if (v15)
        {
          memcpy((void *)(v32 + *v22), v15, v24);
        }
        else if (v32)
        {
          memset_s((void *)(v32 + *v22), v24, 0, v24);
        }
        v21 = *v22 + v24;
        *v22 = v21;
        if ((v24 & 0x8000000000000000) != 0)
          goto LABEL_59;
        v15 += v24;
        v10 += v24;
        v12 -= v24;
        if (!v12)
        {
LABEL_45:
          v14 = *(_QWORD *)(a1 + 24);
          if (v10 >= 1)
          {
            v14 += v10;
            *(_QWORD *)(a1 + 24) = v14;
          }
          goto LABEL_50;
        }
      }
    }
LABEL_47:
    v10 = 0;
    v14 = *(_QWORD *)(a1 + 24);
    goto LABEL_50;
  }
  if (!v16[3])
  {
    v10 = -1;
    goto LABEL_50;
  }
  if (!a3)
    goto LABEL_47;
  v10 = 0;
  while (1)
  {
    v17 = ((uint64_t (*)(_QWORD, char *, unint64_t))v16[3])(*v16, v15, v12);
    if (v17 < 1)
      break;
    v15 += v17;
    v10 += v17;
    v12 -= v17;
    if (!v12)
      goto LABEL_45;
  }
  v14 = *(_QWORD *)(a1 + 24);
  v10 = v17;
LABEL_50:
  if (v14 == *(_QWORD *)(a1 + 16) && (flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    v18 = "flush buf";
    v19 = 298;
    goto LABEL_14;
  }
  if (v10 < 0)
  {
LABEL_15:
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
        return v10;
    }
    __clrex();
  }
  return v10;
}

uint64_t afStreamCloseWithState(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  uint64_t *v17;
  __int128 v18;
  uint64_t v19;
  _OWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v31[4];
  BOOL v32;
  char v33;

  if (atomic_load((unsigned int *)(a1 + 48)))
    return 0xFFFFFFFFLL;
  if ((flushBuf(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamCloseWithState", 236, 67, 0, "flush buf", v13, v14, v31[0]);
    v15 = 0;
  }
  else
  {
    v15 = 1;
  }
  v16 = *(_OWORD *)(a1 + 24);
  v31[0] = *(_OWORD *)(a1 + 8);
  v31[1] = v16;
  v17 = (uint64_t *)(a1 + 64);
  v18 = *(_OWORD *)(a1 + 96);
  v31[2] = *(_OWORD *)(a1 + 56);
  v31[3] = v18;
  v32 = *(_QWORD *)(a1 + 40) != 0;
  v33 = *(_DWORD *)(a1 + 88);
  if (!a2[3])
    goto LABEL_32;
  v19 = 0;
  v20 = v31;
  v21 = 66;
  while (1)
  {
    v22 = ((uint64_t (*)(_QWORD, _OWORD *, uint64_t))a2[3])(*a2, v20, v21);
    if (v22 < 1)
      break;
    v20 = (_OWORD *)((char *)v20 + v22);
    v19 += v22;
    v21 -= v22;
    if (!v21)
    {
      if (v19 < 0)
        goto LABEL_32;
      goto LABEL_13;
    }
  }
  if (v22 < 0)
    goto LABEL_32;
LABEL_13:
  if (!a2[3])
    goto LABEL_32;
  v23 = *v17;
  if (*v17)
  {
    v24 = 0;
    v25 = *(_QWORD *)(a1 + 80);
    while (1)
    {
      v26 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v25, v23);
      if (v26 < 1)
        break;
      v25 += v26;
      v24 += v26;
      v23 -= v26;
      if (!v23)
      {
        if (v24 < 0)
          goto LABEL_32;
        goto LABEL_21;
      }
    }
    if (v26 < 0)
      goto LABEL_32;
LABEL_21:
    if (!a2[3])
      goto LABEL_32;
  }
  v27 = 16 * *(_QWORD *)(a1 + 104);
  if (v27)
  {
    v28 = 0;
    v29 = *(_QWORD *)(a1 + 120);
    while (1)
    {
      v30 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
      if (v30 < 1)
        break;
      v29 += v30;
      v28 += v30;
      v27 -= v30;
      if (!v27)
        goto LABEL_28;
    }
    v28 = v30;
LABEL_28:
    if (v28 < 0)
      goto LABEL_32;
  }
  if ((AAByteStreamCloseWithState(*(uint64_t (***)(void))(a1 + 40)) & 0x80000000) != 0)
  {
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamCloseWithState", 253, 67, 0, "serializing state", v13, v14, v31[0]);
    v15 = 0;
  }
  else if (a3)
  {
    *a3 = *(_QWORD *)(a1 + 24);
  }
  if ((*(_DWORD *)a1 & 0x80000000) == 0 && !*(_DWORD *)(a1 + 4))
    close(*(_DWORD *)a1);
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  free(*(void **)(a1 + 120));
  free((void *)a1);
  if (v15)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

_QWORD *aaArchiveFileOutputStreamOpenAtWithState(int a1, const char *a2, AAByteStream_impl *a3, _QWORD *a4)
{
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int128 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  __int128 v27;
  unint64_t v28;
  unint64_t *v29;
  size_t v30;
  size_t v31;
  void **v32;
  int v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  void *v38;
  void *v39;
  size_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  size_t v46;
  void *v47;
  void *v48;
  size_t v49;
  ssize_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  AAByteStream_impl *v55;
  char v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int16 v61;

  v61 = 0;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v8 = calloc(1uLL, 0x68uLL);
  v9 = malloc(0x80uLL);
  v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x80uLL, 0, 0x80uLL), !v8))
  {
    v14 = *__error();
    v15 = "malloc";
    v16 = 462;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", v16, 67, v14, v15, v12, v13, v56);
LABEL_26:
    afStreamClose(v10);
    free(v8);
    return 0;
  }
  *(_DWORD *)v10 = -1;
  v56 = -92;
  if (a1 < 0)
    v11 = open(a2, 1);
  else
    v11 = openat(a1, a2, 1);
  *(_DWORD *)v10 = v11;
  if (v11 < 0)
  {
    v34 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", 470, 67, v34, "%s", v35, v36, (char)a2);
    goto LABEL_26;
  }
  if (!*((_QWORD *)a3 + 2))
  {
LABEL_23:
    v15 = "loading state";
    v16 = 473;
LABEL_24:
    v14 = 0;
    goto LABEL_25;
  }
  v17 = 0;
  v18 = &v57;
  v19 = 66;
  do
  {
    v20 = (*((uint64_t (**)(_QWORD, __int128 *, uint64_t))a3 + 2))(*(_QWORD *)a3, v18, v19);
    if (v20 < 0)
      goto LABEL_23;
    if (!v20)
      break;
    v18 = (__int128 *)((char *)v18 + v20);
    v17 += v20;
    v19 -= v20;
  }
  while (v19);
  if (v17 < 0)
    goto LABEL_23;
  v24 = *((_QWORD *)&v60 + 1);
  v25 = v60;
  *(_QWORD *)(v10 + 104) = *((_QWORD *)&v60 + 1);
  v26 = (_QWORD *)(v10 + 104);
  v27 = v58;
  *(_OWORD *)(v10 + 8) = v57;
  *(_OWORD *)(v10 + 24) = v27;
  v28 = v59;
  *(_QWORD *)(v10 + 56) = v59;
  *(_DWORD *)(v10 + 88) = HIBYTE(v61);
  *(_QWORD *)(v10 + 96) = v25;
  *(_QWORD *)(v10 + 112) = v24;
  if ((v28 & 0x8000000000000000) != 0)
  {
LABEL_78:
    v15 = "alloc buf";
    v16 = 485;
    goto LABEL_24;
  }
  v29 = (unint64_t *)(v10 + 64);
  v30 = *(_QWORD *)(v10 + 72);
  if (v30 < v28)
  {
    do
    {
      while (!v30)
      {
        v30 = 0x4000;
        if (v28 <= 0x4000)
        {
          v32 = (void **)(v10 + 80);
          v30 = 0x4000;
          goto LABEL_31;
        }
      }
      v31 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0)
        v31 = v30 & (v30 >> 1);
      v30 += v31;
    }
    while (v30 < v28);
    v32 = (void **)(v10 + 80);
    if (v30 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_77;
    }
LABEL_31:
    v37 = *v32;
    v38 = realloc(*v32, v30);
    if (v38)
    {
      *(_QWORD *)(v10 + 72) = v30;
      *(_QWORD *)(v10 + 80) = v38;
      v24 = *(_QWORD *)(v10 + 112);
      goto LABEL_33;
    }
    free(v37);
LABEL_77:
    *v32 = 0;
    *v29 = 0;
    *(_QWORD *)(v10 + 72) = 0;
    goto LABEL_78;
  }
LABEL_33:
  if (v24)
  {
    if (v24 >= 0x200000001)
    {
      *__error() = 12;
      *(_QWORD *)(v10 + 120) = 0;
LABEL_75:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", 487, 67, 0, "alloc holes", v12, v13, 164);
      *v26 = 0;
      *(_QWORD *)(v10 + 112) = 0;
      goto LABEL_26;
    }
    v39 = calloc(v24, 0x10uLL);
    *(_QWORD *)(v10 + 120) = v39;
    if (!v39)
      goto LABEL_75;
  }
  v40 = *((_QWORD *)&v59 + 1);
  if (*((_QWORD *)&v59 + 1))
  {
    v41 = 0;
    v43 = *(_QWORD *)(v10 + 64);
    v42 = *(_QWORD *)(v10 + 72);
    do
    {
      if (v43 == v42)
      {
        v44 = v42 + 0x40000;
        if ((uint64_t)(v42 + 0x40000) < 0)
          goto LABEL_83;
        if (v42 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v42)
            {
              v42 = 0x4000;
              v46 = 0x4000;
              if (v44 <= 0x4000)
                goto LABEL_52;
            }
            v45 = v42 >> 1;
            if ((v42 & (v42 >> 1)) != 0)
              v45 = v42 & (v42 >> 1);
            v42 += v45;
          }
          while (v42 < v44);
          v46 = v42;
          if (v42 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_82;
          }
LABEL_52:
          v47 = *(void **)(v10 + 80);
          v48 = realloc(v47, v46);
          if (v48)
          {
            *(_QWORD *)(v10 + 72) = v46;
            *(_QWORD *)(v10 + 80) = v48;
            v43 = *(_QWORD *)(v10 + 64);
            goto LABEL_54;
          }
          free(v47);
LABEL_82:
          *v29 = 0;
          *(_QWORD *)(v10 + 72) = 0;
          *(_QWORD *)(v10 + 80) = 0;
          goto LABEL_83;
        }
        v43 = v42;
      }
      v46 = v42;
LABEL_54:
      if (v46 - v43 >= v40)
        v49 = v40;
      else
        v49 = v46 - v43;
      v50 = AAByteStreamRead(a3, (void *)(*(_QWORD *)(v10 + 80) + v43), v49);
      if (v50 < 0)
        goto LABEL_83;
      if (!v50)
        break;
      v43 = *v29 + v50;
      if (!__CFADD__(*v29, v50))
      {
        v42 = *(_QWORD *)(v10 + 72);
        if (v43 <= v42)
          continue;
      }
      goto LABEL_83;
      *v29 = v43;
      v41 += v50;
      v40 -= v50;
    }
    while (v40);
    if (v41 < 0)
      goto LABEL_83;
  }
  if (!*((_QWORD *)a3 + 2))
  {
LABEL_83:
    v15 = "loading state";
    v16 = 491;
    goto LABEL_24;
  }
  v51 = 16 * *v26;
  if (v51)
  {
    v52 = 0;
    v53 = *(_QWORD *)(v10 + 120);
    while (1)
    {
      v54 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a3 + 2))(*(_QWORD *)a3, v53, v51);
      if (v54 < 0)
        goto LABEL_83;
      if (v54)
      {
        v53 += v54;
        v52 += v54;
        v51 -= v54;
        if (v51)
          continue;
      }
      if (v52 < 0)
        goto LABEL_83;
      break;
    }
  }
  if ((_BYTE)v61)
  {
    v55 = AAAFSCStreamOpenWithState(*(_DWORD *)v10, a3, 0, v21, v22, v23, v12, v13);
    *(_QWORD *)(v10 + 40) = v55;
    if (!v55)
    {
      v15 = "loading AFSC stream state";
      v16 = 495;
      goto LABEL_24;
    }
  }
  if (a4)
    *a4 = *(_QWORD *)(v10 + 24);
  *v8 = v10;
  v8[1] = afStreamClose;
  v8[7] = afStreamCancel;
  v8[3] = afStreamWrite;
  v8[12] = afStreamCloseWithState;
  return v8;
}

uint64_t aaArchiveFileOutputStreamCloseAndReturnFD(uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  char v12;

  if (a1 && a1[1] == afStreamClose)
  {
    v8 = *(unsigned int *)*a1;
    *((_DWORD *)*a1 + 1) = 1;
    if ((AAByteStreamClose((AAByteStream)a1) & 0x80000000) == 0)
      return v8;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD", 526, 67, 0, "closing stream", v10, v11, v12);
    if ((v8 & 0x80000000) == 0)
      close(v8);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD", 519, 67, 0, "invalid stream", a7, a8, v12);
  }
  return 0xFFFFFFFFLL;
}

uint64_t flushBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  off_t v10;
  int v11;
  uint64_t v12;
  char *v13;
  const char *v14;
  __int16 v15;
  int v16;
  size_t v17;
  ssize_t v18;
  uint64_t *v19;
  size_t v20;
  size_t v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  BOOL v28;
  char *v29;
  size_t v30;
  size_t v31;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  char *v42;
  off_t *v43;
  unint64_t v44;
  size_t v45;
  uint64_t result;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  char v50;

  v8 = *(_QWORD *)(a1 + 64);
  if (!v8)
    return 0;
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(_DWORD *)(a1 + 88);
  if (v10 + v8 < *(_QWORD *)(a1 + 16))
  {
    if (v11)
      v12 = -*(_QWORD *)(a1 + 96);
    else
      v12 = -16384;
    v8 &= v12;
  }
  v13 = *(char **)(a1 + 80);
  if (!v11)
  {
    if (!v8)
      return 0;
    v17 = v8;
    while (1)
    {
      v18 = pwrite(*(_DWORD *)a1, v13, v17, v10);
      if (v18 < 0)
        break;
      v13 += v18;
      v10 = *(_QWORD *)(a1 + 32) + v18;
      *(_QWORD *)(a1 + 32) = v10;
      v17 -= v18;
      if (!v17)
        goto LABEL_64;
    }
    v16 = *__error();
    v14 = "write";
    v15 = 170;
    goto LABEL_67;
  }
  if (((*(_QWORD *)(a1 + 96) - 1) & v10) != 0)
  {
    v14 = "buffer offset not aligned to holes";
    v15 = 114;
LABEL_10:
    v16 = 0;
LABEL_67:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"flushBuf", v15, 67, v16, v14, a7, a8, v50);
    return 0xFFFFFFFFLL;
  }
  if (!v8)
    return 0;
  v19 = (uint64_t *)(a1 + 104);
  v20 = v8;
  while (2)
  {
    v21 = *(_QWORD *)(a1 + 96);
    if (v21 <= v20)
    {
      v22 = 0;
      v23 = v13;
      v24 = *(_QWORD *)(a1 + 96);
      do
      {
        v25 = v24;
        if (v21)
        {
          v26 = 0;
          do
          {
            v27 = *(_QWORD *)&v23[v26];
            v26 += 8;
            if (v27)
              v28 = 1;
            else
              v28 = v26 >= v21;
          }
          while (!v28);
          if (v27)
            break;
        }
        v24 = v21 + v25;
        v23 += v21;
        v22 = v25;
      }
      while (v21 + v25 <= v20);
    }
    else
    {
      v22 = 0;
    }
    v29 = &v13[v22];
    v30 = v22;
    do
    {
      v31 = v30;
      v30 += v21;
      if (v30 > v20)
      {
        v31 = v20;
        if (v22)
          goto LABEL_41;
        goto LABEL_51;
      }
      if (!v21)
      {
        v31 = v22;
        if (v22)
          goto LABEL_41;
        goto LABEL_51;
      }
      v32 = 0;
      do
      {
        v33 = *(_QWORD *)&v29[v32];
        v32 += 8;
        if (v33)
          v34 = 1;
        else
          v34 = v32 >= v21;
      }
      while (!v34);
      v29 += v21;
    }
    while (v33);
    if (!v22)
    {
LABEL_51:
      v39 = v10 + v22;
      goto LABEL_56;
    }
LABEL_41:
    v35 = *v19;
    if (*v19)
    {
      v36 = *(_QWORD *)(a1 + 120) + 16 * v35;
      v38 = *(_QWORD *)(v36 - 8);
      v37 = (_QWORD *)(v36 - 8);
      if (v38 == v10)
      {
        v39 = v10 + v22;
        *v37 = v10 + v22;
        goto LABEL_56;
      }
    }
    if (v35 == *(_QWORD *)(a1 + 112))
    {
      v40 = 2 * v35;
      if (v40 <= 0x10)
        v40 = 16;
      *(_QWORD *)(a1 + 112) = v40;
      if (16 * v40 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        v41 = *(void **)(a1 + 120);
        v42 = (char *)realloc(v41, 16 * v40);
        if (v42)
        {
          *(_QWORD *)(a1 + 120) = v42;
          v35 = *(_QWORD *)(a1 + 104);
          v10 = *(_QWORD *)(a1 + 32);
          goto LABEL_55;
        }
        free(v41);
      }
      *(_QWORD *)(a1 + 120) = 0;
      v47 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"flushBuf", 140, 67, *v47, "malloc", v48, v49, v50);
      *v19 = 0;
      *(_QWORD *)(a1 + 112) = 0;
      return 0xFFFFFFFFLL;
    }
    v42 = *(char **)(a1 + 120);
LABEL_55:
    *v19 = v35 + 1;
    v43 = (off_t *)&v42[16 * v35];
    v39 = v10 + v22;
    *v43 = v10;
    v43[1] = v10 + v22;
LABEL_56:
    if (v39 == *(_QWORD *)(a1 + 16))
    {
      if (!v22 || v22 != v31)
      {
        v14 = "invalid state";
        v15 = 151;
        goto LABEL_10;
      }
      v22 -= *(_QWORD *)(a1 + 96);
    }
    if (v31 > v22)
    {
      if (pwrite(*(_DWORD *)a1, &v13[v22], v31 - v22, v22 + v10) != v31 - v22)
      {
        v14 = "writing data";
        v15 = 159;
        goto LABEL_10;
      }
      v10 = *(_QWORD *)(a1 + 32);
    }
    v13 += v31;
    v10 += v31;
    *(_QWORD *)(a1 + 32) = v10;
    v20 -= v31;
    if (v20)
      continue;
    break;
  }
LABEL_64:
  v44 = *(_QWORD *)(a1 + 64);
  v45 = v44 - v8;
  if (v44 < v8)
    return 0;
  if (v44 != v8)
    memmove(*(void **)(a1 + 80), (const void *)(*(_QWORD *)(a1 + 80) + v8), v44 - v8);
  result = 0;
  *(_QWORD *)(a1 + 64) = v45;
  return result;
}

uint64_t fullReplacementBXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CC_SHA1_CTX *v18;
  CC_SHA1_CTX *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  const char *v26;
  __int16 v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v12 = *(_QWORD *)(a1 + 32);
  if (a5 >= 1)
    fwrite("Full replacement patch\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (v12 + 60 <= a2)
  {
    if (v12 + 60 < a2)
      fwrite("Extra bytes in patch (ignored)", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v14 = (char *)malloc(0x20000uLL);
    if (v14)
    {
      v17 = ILowMemoryDecoderStreamCreateWithBuffer(a1 + 60, v12, 0x20000uLL);
      if (v17)
      {
        v18 = (CC_SHA1_CTX *)OSHA1StreamCreate(a3, 0, a4);
        if (v18)
        {
          v19 = v18;
          v20 = *(_QWORD *)(a1 + 16);
          if (v20)
          {
            v21 = 0;
            while (1)
            {
              v22 = v20 - v21;
              if (v22 >= 0x20000)
                v23 = 0x20000;
              else
                v23 = v22;
              if (ILowMemoryDecoderStreamRead(v17, v14, v23) != v23)
              {
                v26 = "reading from payload stream";
                v27 = 62;
                goto LABEL_32;
              }
              if (OSHA1StreamWrite(v19, v14, v23) != v23)
                break;
              v21 += v23;
              v20 = *(_QWORD *)(a1 + 16);
              if (v21 >= v20)
                goto LABEL_18;
            }
            v26 = "writing to digest stream";
            v27 = 64;
          }
          else
          {
LABEL_18:
            OSHA1StreamDestroy(v19, (unsigned __int8 *)&v32);
            if (v32 == *(_QWORD *)(a1 + 40)
              && v33 == *(_QWORD *)(a1 + 48)
              && v34 == (unint64_t)*(unsigned int *)(a1 + 56))
            {
              v13 = 0;
LABEL_34:
              free(v14);
              ILowMemoryDecoderStreamDestroy(v17);
              return v13;
            }
            v26 = "Invalid output digest after patch application";
            v27 = 71;
          }
        }
        else
        {
          v26 = "Digest stream init";
          v27 = 52;
        }
      }
      else
      {
        v26 = "Payload stream init";
        v27 = 51;
      }
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", v27, 42, 0, v26, v15, v16, v32);
    }
    else
    {
      v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 50, 42, *v28, "malloc", v29, v30, v32);
      v17 = 0;
    }
    v13 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 45, 42, 0, "Missing bytes in patch", a7, a8, v32);
  return 0xFFFFFFFFLL;
}

uint64_t BXDiff5GetPatchInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v5;

  if (a2 < 8)
    return 0xFFFFFFFFLL;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  result = 0xFFFFFFFFLL;
  if (a2 >= 0x3C && *(_QWORD *)a1 == 0x3035464649445842)
  {
    result = 0;
    *(_QWORD *)a3 = *(_QWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a1 + 12) & 1;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8) == 0;
    *(_DWORD *)(a3 + 12) = v5;
  }
  return result;
}

uint64_t BXPatch5StreamWithFlags(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t, void *, uint64_t), uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unsigned int v12;
  unint64_t v13;
  int v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v39;
  unint64_t v40;
  uint64_t result;
  int v42;
  const char *v43;
  __int16 v44;
  FILE **v45;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  size_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  CC_SHA1_CTX *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  void *v91;
  unint64_t v92;
  unint64_t v93;
  size_t v94;
  char *v95;
  char *v96;
  size_t i;
  char v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  size_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void ***v109;
  CC_SHA1_CTX *v110;
  unsigned int v111;
  int v112;
  const char *v113;
  __int16 v114;
  uint64_t v115;
  uint64_t v116;
  const char *v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char v130;
  char v131;
  uint64_t v132;
  uint64_t v133;
  CC_SHA1_CTX *v134;
  uint64_t v135;
  size_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  void *v148;
  int v149;
  void *v150;
  uint64_t *v151;
  char *v152;
  CC_SHA1_CTX c;
  unsigned __int8 md[8];
  uint64_t v155;
  int v156;
  uint64_t v157;

  v157 = *MEMORY[0x24BDAC8D0];
  if (a5 <= 0x3B)
  {
    v8 = "Invalid patch size";
    v9 = 264;
    goto LABEL_48;
  }
  if (*(_QWORD *)a4 != 0x3035464649445842)
  {
    v8 = "Invalid patch header";
    v9 = 265;
    goto LABEL_48;
  }
  v12 = *(_DWORD *)(a4 + 8);
  v13 = 28 * v12 + 60;
  if (v13 > a5)
  {
    v8 = "Invalid patch size";
    v9 = 269;
    goto LABEL_48;
  }
  v16 = a8 & 1;
  v17 = *(_QWORD *)(a4 + 24);
  v18 = __CFADD__(v13, v17);
  v19 = v13 + v17;
  if (v18)
    v19 = -1;
  if (!v12)
  {
    v39 = *(_QWORD *)(a4 + 32);
    v18 = __CFADD__(v19, v39);
    v40 = v19 + v39;
    if (v18)
      v40 = -1;
    if (v40 <= a5)
      return fullReplacementBXPatch5(a4, a5, (uint64_t)a6, a7, a8 & 1, (uint64_t)a6, a7, a8);
    goto LABEL_42;
  }
  v23 = *(unsigned int *)(a4 + 8);
  v24 = (uint64_t *)(a4 + 60);
  do
  {
    v25 = *v24;
    v24 = (uint64_t *)((char *)v24 + 28);
    v18 = __CFADD__(v19, v25);
    v19 += v25;
    if (v18)
      v19 = -1;
    --v23;
  }
  while (v23);
  v26 = *(_QWORD *)(a4 + 32);
  v18 = __CFADD__(v19, v26);
  v27 = v19 + v26;
  if (v18)
    v27 = -1;
  if (v27 > a5)
  {
LABEL_42:
    v8 = "Invalid patch size";
    v9 = 278;
    goto LABEL_48;
  }
  v151 = (uint64_t *)(a4 + 60);
  *(_QWORD *)md = 0;
  v155 = 0;
  v156 = 0;
  memset(&c, 0, sizeof(c));
  v28 = malloc(0x40000uLL);
  if (!v28)
  {
    v42 = *__error();
    v43 = "malloc";
    v44 = 156;
LABEL_46:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"getStreamSHA1Digest", v44, 42, v42, v43, v32, v33, v130);
    free(v28);
    goto LABEL_47;
  }
  v149 = v16;
  CC_SHA1_Deprecated_Init(&c);
  v29 = 0;
  if (a3)
  {
    while (1)
    {
      v30 = v29 + 0x40000 <= a3 ? 0x40000 : a3 - v29;
      v31 = a1(a2, v28, v30, v29);
      if (v31 <= 0)
        break;
      v34 = v31;
      CC_SHA1_Deprecated_Update(&c, v28, v31);
      v29 += v34;
      if (v29 >= a3)
        goto LABEL_27;
    }
    v43 = "inProc read";
    v44 = 165;
    v42 = 0;
    goto LABEL_46;
  }
LABEL_27:
  CC_SHA1_Deprecated_Final(md, &c);
  free(v28);
  if (v29 != a3)
  {
LABEL_47:
    v8 = "Input digest failed";
    v9 = 285;
    goto LABEL_48;
  }
  if (!v149)
  {
    v36 = a4 + 40;
    if (*(_QWORD *)md != *(_QWORD *)(a4 + 40)
      || v155 != *(_QWORD *)(a4 + 48)
      || v156 != (unint64_t)*(unsigned int *)(a4 + 56))
    {
      goto LABEL_56;
    }
LABEL_76:
    if ((copyStream(a1, a2, a3, a6, a7) & 0x80000000) == 0)
      return 0;
    v8 = "Output copy failed\n";
    v9 = 293;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v9, 42, 0, v8, a7, a8, v130);
    return 0xFFFFFFFFLL;
  }
  v45 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Input variants in patch: %u\n", *(_DWORD *)(a4 + 8));
  v36 = a4 + 40;
  if (*(_QWORD *)md == *(_QWORD *)(a4 + 40)
    && v155 == *(_QWORD *)(a4 + 48)
    && v156 == (unint64_t)*(unsigned int *)(a4 + 56))
  {
    fwrite("No-op patch matching, writing input\n", 0x24uLL, 1uLL, *v45);
    goto LABEL_76;
  }
LABEL_56:
  v48 = *(unsigned int *)(a4 + 8);
  if (!(_DWORD)v48)
  {
LABEL_66:
    v8 = "Input doesn't match any of the expected patch inputs";
    v9 = 310;
    goto LABEL_48;
  }
  v49 = 0;
  v50 = a4 + 68;
  while (1)
  {
    v51 = *(_QWORD *)md == *(_QWORD *)v50 && v155 == *(_QWORD *)(v50 + 8);
    if (v51 && v156 == (unint64_t)*(unsigned int *)(v50 + 16))
      break;
    ++v49;
    v50 += 28;
    if (v48 == v49)
      goto LABEL_66;
  }
  v146 = v49;
  if (v149)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Patch matching entry %u\n", v49);
    v49 = v146;
    v48 = *(unsigned int *)(a4 + 8);
  }
  v135 = v36;
  v53 = v151;
  v142 = (uint64_t)v151 + 28 * v48;
  v144 = *(_QWORD *)(a4 + 24);
  v54 = v142 + v144;
  if ((_DWORD)v48)
  {
    v55 = 0;
    v56 = 0;
    do
    {
      if (v49 == v55)
        v56 = v54;
      v57 = *v53;
      v53 = (uint64_t *)((char *)v53 + 28);
      v54 += v57;
      ++v55;
    }
    while (v48 != v55);
  }
  else
  {
    v56 = 0;
  }
  v138 = *(_QWORD *)(a4 + 32);
  v140 = *(_QWORD *)(v50 - 8);
  if (v54 + v138 - a4 != a5)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 331, 42, "Warning: extra bytes in patch (ignored)\n", v35, a7, a8, v130);
    LODWORD(v48) = *(_DWORD *)(a4 + 8);
  }
  v137 = *(_QWORD *)(a4 + 16);
  v58 = 8 * (v48 + 2);
  v152 = (char *)malloc(0x20000uLL);
  v59 = malloc(0x20000uLL);
  v136 = v58;
  v60 = v58;
  v61 = v152;
  v150 = malloc(v60);
  enterThreadErrorContext((uint64_t)v150, v62, v63, v64, v65, v66, v67, v68, v130);
  v148 = v59;
  if (!v59 || !v152 || !v150)
  {
    v112 = *__error();
    v113 = "malloc";
    v114 = 351;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v114, 42, v112, v113, v69, v70, v131);
    v115 = 0;
    v73 = 0;
    v116 = 0;
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    goto LABEL_155;
  }
  v145 = ILowMemoryDecoderStreamCreateWithBuffer(v142, v144, 0x20000uLL);
  if (!v145)
  {
    v113 = "Control stream init";
    v114 = 352;
    v112 = 0;
    goto LABEL_133;
  }
  v73 = ILowMemoryDecoderStreamCreateWithBuffer(v56, v140, 0x20000uLL);
  if (!v73)
  {
    v117 = "Diff stream init";
    v118 = 353;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v118, 42, 0, v117, v71, v72, v131);
    v116 = 0;
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    v115 = v145;
    goto LABEL_155;
  }
  v143 = ILowMemoryDecoderStreamCreateWithBuffer(v54, v138, 0x20000uLL);
  if (!v143)
  {
    v117 = "Archive stream init";
    v118 = 354;
    goto LABEL_136;
  }
  v74 = (CC_SHA1_CTX *)OSHA1StreamCreate((uint64_t)a6, 0, a7);
  if (!v74)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 355, 42, 0, "Digest stream init", v75, v76, v131);
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    v115 = v145;
LABEL_141:
    v116 = v143;
    goto LABEL_155;
  }
  v139 = v73;
  v134 = v74;
  v141 = OBufferedStreamCreate((uint64_t)OSHA1StreamWrite, (uint64_t)OSHA1StreamAbort, (uint64_t)v74, 0x20000uLL);
  if (!v141)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 356, 42, 0, "OBufferedStreamCreate", v82, v83, v131);
    v109 = 0;
    v111 = -1;
    v61 = v152;
    v91 = v148;
    v116 = v143;
    v115 = v145;
    goto LABEL_154;
  }
  if (!v137)
  {
LABEL_123:
    OBufferedStreamDestroy((void ***)v141, v77, v78, v79, v80, v81, v82, v83);
    OSHA1StreamDestroy(v134, md);
    if (*(_QWORD *)md == *(_QWORD *)v135
      && v155 == *(_QWORD *)(v135 + 8)
      && v156 == (unint64_t)*(unsigned int *)(v135 + 16))
    {
      v109 = 0;
      v110 = 0;
      v111 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 421, 42, 0, "Invalid output digest after patch application", v105, v106, v131);
      v109 = 0;
      v110 = 0;
      v111 = -1;
    }
    v61 = v152;
    v91 = v148;
    v115 = v145;
    v73 = v139;
    goto LABEL_141;
  }
  v84 = 0;
  v85 = 0;
  v133 = (v146 + 2);
  while (1)
  {
    if (ILowMemoryDecoderStreamRead(v145, (char *)v150, v136) != v136)
    {
      v121 = "reading from control stream";
      v122 = 362;
      goto LABEL_151;
    }
    v86 = *((_QWORD *)v150 + 1);
    if (*(uint64_t *)v150 >= 0)
      v87 = *(_QWORD *)v150;
    else
      v87 = 0x8000000000000000 - *(_QWORD *)v150;
    v88 = 0x8000000000000000 - v86;
    if (v86 >= 0)
      v88 = *((_QWORD *)v150 + 1);
    v147 = v88;
    v89 = *((_QWORD *)v150 + v133);
    if (v89 < 0)
      v89 = 0x8000000000000000 - v89;
    v132 = v89;
    if (v85 < 0 || v87 + v85 > a3)
    {
      v121 = "Invalid in segment in patch";
      v122 = 369;
      goto LABEL_151;
    }
    if (v87 + v84 + v147 > *(_QWORD *)(a4 + 16))
    {
      v121 = "Invalid out segment in patch";
      v122 = 370;
LABEL_151:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v122, 42, 0, v121, v82, v83, v131);
      v111 = -1;
      v61 = v152;
LABEL_152:
      v91 = v148;
      goto LABEL_153;
    }
    if (v87)
      break;
LABEL_114:
    if (v147)
    {
      v99 = 0;
      v100 = v147;
      while (1)
      {
        v101 = v100 - v99;
        if (v101 >= 0x20000)
          v102 = 0x20000;
        else
          v102 = v101;
        if (ILowMemoryDecoderStreamRead(v143, v152, v102) != v102)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 405, 42, 0, "reading from archive stream", v103, v104, v131);
          v111 = -1;
          v61 = v152;
          goto LABEL_152;
        }
        if (OBufferedStreamWrite((unint64_t **)v141, v152, v102) != v102)
          break;
        v99 += v102;
        v84 += v102;
        v100 = v147;
        if (v99 >= v147)
          goto LABEL_122;
      }
      v121 = "writing to digest stream";
      v122 = 407;
      goto LABEL_151;
    }
LABEL_122:
    v85 += v132;
    if (v84 >= v137)
      goto LABEL_123;
  }
  v90 = 0;
  v91 = v148;
  v92 = v87;
  while (1)
  {
    v93 = v92 - v90;
    if (v93 >= 0x20000)
      v94 = 0x20000;
    else
      v94 = v93;
    if (ILowMemoryDecoderStreamRead(v139, v152, v94) != v94)
    {
      v119 = "reading from diff stream";
      v120 = 379;
      goto LABEL_145;
    }
    if (a1(a2, v148, v94, v85) != v94)
    {
      v119 = "reading from input stream";
      v120 = 381;
      goto LABEL_145;
    }
    v95 = (char *)v148;
    v96 = v152;
    for (i = v94; i; --i)
    {
      v98 = *v95++;
      *v96++ += v98;
    }
    if (OBufferedStreamWrite((unint64_t **)v141, v152, v94) != v94)
      break;
    v90 += v94;
    v85 += v94;
    v84 += v94;
    v92 = v87;
    if (v90 >= v87)
      goto LABEL_114;
  }
  v119 = "writing to digest stream";
  v120 = 390;
LABEL_145:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v120, 42, 0, v119, v82, v83, v131);
  v111 = -1;
  v61 = v152;
LABEL_153:
  v116 = v143;
  v115 = v145;
  v73 = v139;
  v109 = (void ***)v141;
LABEL_154:
  v110 = v134;
LABEL_155:
  free(v150);
  free(v61);
  free(v91);
  OBufferedStreamDestroy(v109, v123, v124, v125, v126, v127, v128, v129);
  OSHA1StreamDestroy(v110, md);
  ILowMemoryDecoderStreamDestroy(v115);
  ILowMemoryDecoderStreamDestroy(v73);
  ILowMemoryDecoderStreamDestroy(v116);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v111;
  else
    return result;
}

uint64_t BXPatch5FileWithFlags(const char *a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5, uint64_t a6)
{
  char v11;
  unsigned int v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  stat v22;
  uint64_t v23;
  off_t st_size;

  v11 = (char)a1;
  st_size = 0;
  memset(&v22, 0, sizeof(v22));
  v12 = open(a1, 0);
  v23 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 235, 42, *v18, "open: %s", v19, v20, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v13 = v12;
    if (fstat(v12, &v22))
    {
      v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 236, 42, *v14, "fstat: %s", v15, v16, v11);
      v17 = 0xFFFFFFFFLL;
LABEL_6:
      close(v13);
      return v17;
    }
    st_size = v22.st_size;
    v17 = BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsFileStreamPRead, (uint64_t)&v23, v22.st_size, a2, a3, a4, a5, a6);
    v13 = v23;
    if ((v23 & 0x80000000) == 0)
      goto LABEL_6;
  }
  return v17;
}

ssize_t BXPatch5WithFlagsFileStreamPRead(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  ssize_t result;

  if (!a3)
    return 0;
  result = -1;
  if (!__CFADD__(a4, a3) && a4 + a3 <= *(_QWORD *)(a1 + 8))
    return pread(*(_DWORD *)a1, a2, a3, a4);
  return result;
}

uint64_t copyStream(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5)
{
  void *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  char v22;

  v10 = malloc(0x40000uLL);
  if (!v10)
  {
    v18 = *__error();
    v19 = "malloc";
    v20 = 188;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"copyStream", v20, 42, v18, v19, v14, v15, v22);
    v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  v11 = 0;
  if (a3)
  {
    while (1)
    {
      if (v11 + 0x40000 <= a3)
        v12 = 0x40000;
      else
        v12 = a3 - v11;
      v13 = a1(a2, v10, v12, v11);
      if (v13 <= 0)
      {
        v19 = "inProc read";
        v20 = 196;
        goto LABEL_15;
      }
      v16 = a4(a5, v10, v13);
      if (v16 <= 0)
        break;
      v11 += v16;
      if (v11 >= a3)
        goto LABEL_9;
    }
    v19 = "outProc write";
    v20 = 198;
LABEL_15:
    v18 = 0;
    goto LABEL_16;
  }
LABEL_9:
  if (v11 == a3)
    v17 = 0;
  else
    v17 = 0xFFFFFFFFLL;
LABEL_17:
  free(v10);
  return v17;
}

uint64_t BXPatch5InPlace(const char *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  uint64_t FileSHA1Digest;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  BOOL v26;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  void *v40;
  char *v41;
  size_t i;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  void *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  unint64_t v72;
  unint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  char *v82;
  unint64_t *v83;
  unint64_t v84;
  unint64_t v85;
  size_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t j;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char *v104;
  unint64_t v105;
  uint64_t v106;
  size_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  char v125;
  char v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  void *v130;
  unint64_t v131;
  unint64_t v132;
  char *v133;
  _BYTE *v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  char *v143;
  char *v144;
  void *v145;
  _QWORD *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  uint64_t v152;

  v152 = *MEMORY[0x24BDAC8D0];
  if (a3 <= 0x3B)
  {
    v8 = "Invalid patch size";
    v9 = 441;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v9, 42, 0, v8, a7, a8, v125);
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)a2 != 0x3035464649445842)
  {
    v8 = "Invalid patch header";
    v9 = 442;
    goto LABEL_29;
  }
  if ((*(_BYTE *)(a2 + 12) & 1) == 0)
  {
    v8 = "Patch can't be applied in-place";
    v9 = 445;
    goto LABEL_29;
  }
  if (a4 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Input variants in patch: %u\n", *(_DWORD *)(a2 + 8));
  v149 = 0;
  v150 = 0;
  v151 = 0;
  FileSHA1Digest = getFileSHA1Digest(a1, (uint64_t)&v149);
  if ((_DWORD)FileSHA1Digest)
  {
    v8 = "computing file digest";
    v9 = 450;
    goto LABEL_29;
  }
  if (v149 == *(_QWORD *)(a2 + 40)
    && v150 == *(_QWORD *)(a2 + 48)
    && v151 == (unint64_t)*(unsigned int *)(a2 + 56))
  {
    if (a4 >= 1)
      fwrite("No-op patch matching, do nothing\n", 0x21uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
  v22 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v22)
  {
LABEL_28:
    v8 = "Input doesn't match any of the expected patch inputs (in-place)";
    v9 = 467;
    goto LABEL_29;
  }
  v23 = 0;
  v24 = (uint64_t *)(a2 + 60);
  v25 = a2 + 68;
  while (1)
  {
    v26 = v149 == *(_QWORD *)v25 && v150 == *(_QWORD *)(v25 + 8);
    if (v26 && v151 == (unint64_t)*(unsigned int *)(v25 + 16))
      break;
    ++v23;
    v25 += 28;
    if (v22 == v23)
      goto LABEL_28;
  }
  if (a4 >= 1)
  {
    FileSHA1Digest = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "In-place patch matching entry %u\n", v23);
    v22 = *(unsigned int *)(a2 + 8);
  }
  v29 = (uint64_t)v24 + 28 * v22 + *(_QWORD *)(a2 + 24);
  v147 = *(_QWORD *)(a2 + 24);
  v143 = (char *)v24 + 28 * v22;
  if ((_DWORD)v22)
  {
    v30 = 0;
    v31 = 0;
    do
    {
      if (v23 == v30)
        v31 = v29;
      v32 = *v24;
      v24 = (uint64_t *)((char *)v24 + 28);
      v29 += v32;
      ++v30;
    }
    while (v22 != v30);
  }
  else
  {
    v31 = 0;
  }
  v33 = *(_QWORD *)(v25 - 8);
  v128 = *(_QWORD *)(a2 + 32);
  if (v29 + v128 - a2 != a3)
  {
    FileSHA1Digest = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 489, 42, "Warning: extra bytes in patch (ignored)\n", v19, a7, a8, v125);
    LODWORD(v22) = *(_DWORD *)(a2 + 8);
  }
  enterThreadErrorContext(FileSHA1Digest, v15, v16, v17, v18, v19, a7, a8, v125);
  v134 = malloc(0x1000uLL);
  if (!v134)
  {
    v54 = *__error();
    v57 = 511;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v57, 42, v54, "malloc", v55, v56, v126);
    v40 = 0;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = 0;
    goto LABEL_95;
  }
  v34 = malloc(0x1000uLL);
  if (!v34)
  {
    v54 = *__error();
    v57 = 513;
    goto LABEL_62;
  }
  v130 = v34;
  v135 = (v22 + 2);
  v136 = 8 * v135;
  v133 = (char *)malloc(8 * v135);
  v35 = ILowMemoryDecoderStreamCreateWithBuffer((uint64_t)v143, v147, 0x1000uLL);
  if (!v35)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 517, 42, 0, "Control stream init", v36, v37, v126);
    v40 = 0;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = 0;
LABEL_64:
    v66 = v130;
    v65 = v133;
    goto LABEL_95;
  }
  v127 = v33;
  v139 = v35;
  v140 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = v133;
  for (i = 8 * (v22 + 2); ; v38 = &v144[i])
  {
    v144 = v38;
    v148 = v39;
    if (v39 == v140)
    {
      v43 = v39 + (v39 >> 1);
      if (v39 >> 5 <= 0xC34)
        v43 = 2 * v39;
      if (!v39)
        v43 = 2000;
      v140 = v43;
      v44 = (char *)reallocf(v40, i * v43);
      i = 8 * (v22 + 2);
      v41 = v133;
      v40 = v44;
      if (!v44)
      {
        v65 = v133;
        v94 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 527, 42, v94, "malloc", v95, v96, v126);
LABEL_92:
        v67 = 0;
        v68 = 0;
        v69 = 0;
        v66 = v130;
LABEL_94:
        v70 = v139;
        goto LABEL_95;
      }
    }
    v45 = ILowMemoryDecoderStreamRead(v139, v41, i);
    if (!v45)
      break;
    v48 = (uint64_t *)v41;
    v49 = v144;
    v50 = (v22 + 2);
    if (v45 != i)
    {
      v65 = v41;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 533, 42, 0, "reading from control stream S=%lld", v46, v47, v45);
      goto LABEL_92;
    }
    do
    {
      v52 = *v48++;
      v51 = v52;
      v53 = 0x8000000000000000 - v52;
      if (v52 < 0)
        v51 = v53;
      *(_QWORD *)&v49[(_QWORD)v40] = v51;
      v49 += 8;
      --v50;
    }
    while (v50);
    v39 = v148 + 1;
  }
  if (a4 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%zu controls in patch (%zu B allocated)\n", v148, v136 * v140);
  v71 = PagedFileCreate(a1, *(_QWORD *)(a2 + 16), 0x2800000uLL, a4);
  if (!v71)
  {
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v66 = v130;
    v65 = v133;
    goto LABEL_94;
  }
  v67 = v71;
  if (v148)
  {
    v72 = 0;
    v73 = (unint64_t *)v40;
    v74 = v148;
    do
    {
      v131 = *v73;
      v141 = v72;
      v145 = (void *)v73[(v23 + 2)];
      PagedFileRetainIn(v67, v72, *v73, v60, v61, v62, v63, v64);
      v72 = (unint64_t)v145 + v131 + v141;
      v73 = (unint64_t *)((char *)v73 + v136);
      --v74;
    }
    while (v74);
  }
  PagedFileReleaseAllIn((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
  if (a4 > 1)
    PagedFileDump((uint64_t)v67, "Input retained");
  v75 = ILowMemoryDecoderStreamCreateWithBuffer(v31, v127, 0x1000uLL);
  v70 = v139;
  if (!v75)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 563, 42, 0, "Diff stream init", v76, v77, v126);
    v68 = 0;
    v69 = 0;
    goto LABEL_64;
  }
  v142 = v75;
  v146 = v67;
  if (v148)
  {
    v78 = 0;
    v79 = 0;
    v80 = 0;
    v81 = (v23 + 2);
    v82 = (char *)v130;
    v129 = v81;
    while (1)
    {
      v83 = (unint64_t *)((char *)v40 + 8 * v78 * v135);
      v84 = *v83;
      v85 = v83[1];
      v137 = v83[v81];
      if (a4 >= 3)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "DIFF STREAM: I=%zu OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu IDELTA=%lld\n", v78, v79, v80, v84, v85, v137);
        PagedFileDump((uint64_t)v146, "Before applying control");
        v82 = (char *)v130;
      }
      v132 = v85;
      if (v84)
        break;
LABEL_88:
      v80 += v137;
      v79 += v132;
      ++v78;
      v81 = v129;
      if (v78 == v148)
        goto LABEL_105;
    }
    while (1)
    {
      if (v84 >= 0x1000)
        v86 = 4096;
      else
        v86 = v84;
      if (ILowMemoryDecoderStreamRead(v142, v82, v86) != v86)
      {
        v119 = "reading from diff stream";
        v120 = 584;
        goto LABEL_130;
      }
      if (PagedFileReadAndReleaseIn((uint64_t)v146, v80, v86, (uint64_t)v134, v87, v88, v89, v90))
      {
        v119 = "reading from input stream";
        v120 = 587;
        goto LABEL_130;
      }
      for (j = 0; j != v86; ++j)
        *((_BYTE *)v130 + j) += v134[j];
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v79, v86, (uint64_t)v130, v91, v92, v89, v90))
        break;
      v80 += v86;
      v79 += v86;
      v84 -= v86;
      v82 = (char *)v130;
      if (!v84)
        goto LABEL_88;
    }
    v119 = "writing output";
    v120 = 593;
LABEL_130:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v120, 42, 0, v119, v89, v90, v126);
    v68 = 0;
LABEL_137:
    v66 = v130;
LABEL_138:
    v65 = v133;
    v70 = v139;
    v67 = v146;
LABEL_139:
    v69 = v142;
LABEL_95:
    PagedFileDestroy((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
    free(v40);
    free(v65);
    free(v134);
    free(v66);
    ILowMemoryDecoderStreamDestroy(v70);
    ILowMemoryDecoderStreamDestroy(v69);
    ILowMemoryDecoderStreamDestroy(v68);
LABEL_96:
    v97 = 0;
    goto LABEL_97;
  }
  v80 = 0;
LABEL_105:
  v67 = v146;
  if (a4 >= 2)
    PagedFileDump((uint64_t)v146, "Diff stream applied");
  if (!PagedFileHasNoIn((uint64_t)v146))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 608, 42, 0, "some input bytes are still mapped after diff expansion", v99, v100, v126);
    v68 = 0;
    v66 = v130;
    v65 = v133;
    v70 = v139;
    goto LABEL_139;
  }
  v68 = ILowMemoryDecoderStreamCreateWithBuffer(v29, v128, 0x1000uLL);
  if (!v68)
  {
    v121 = "Archive stream init";
    v122 = 611;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v122, 42, 0, v121, v101, v102, v126);
    goto LABEL_137;
  }
  if (v148)
  {
    v138 = 0;
    v103 = 0;
    while (1)
    {
      v104 = (char *)v40 + 8 * v138 * v135;
      v106 = *(_QWORD *)v104;
      v105 = *((_QWORD *)v104 + 1);
      if (a4 >= 3)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE STREAM: OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu\n", v103, v80, v106, v105);
      v103 += v106;
      if (v105)
        break;
LABEL_121:
      if (++v138 == v148)
        goto LABEL_122;
    }
    v66 = v130;
    while (1)
    {
      if (v105 >= 0x1000)
        v107 = 4096;
      else
        v107 = v105;
      if (ILowMemoryDecoderStreamRead(v68, (char *)v66, v107) != v107)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 630, 42, 0, "reading from archive stream", v110, v111, v126);
        goto LABEL_138;
      }
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v103, v107, (uint64_t)v66, v108, v109, v110, v111))
        break;
      v103 += v107;
      v105 -= v107;
      v66 = v130;
      if (!v105)
        goto LABEL_121;
    }
    v121 = "writing output";
    v122 = 633;
    goto LABEL_136;
  }
LABEL_122:
  if (a4 >= 2)
    PagedFileDump((uint64_t)v146, "Archive stream applied");
  if (!PagedFileHasAllOut((uint64_t)v146))
  {
    v121 = "some output bytes are missing or referenced more than once after archive expansion";
    v122 = 643;
    goto LABEL_136;
  }
  PagedFileDestroy((uint64_t)v146, v112, v113, v114, v115, v116, v101, v102);
  free(v40);
  free(v133);
  free(v134);
  free(v130);
  ILowMemoryDecoderStreamDestroy(v139);
  ILowMemoryDecoderStreamDestroy(v142);
  ILowMemoryDecoderStreamDestroy(v68);
  if (getFileSHA1Digest(a1, (uint64_t)&v149))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 658, 42, 0, "computing file digest", v117, v118, v126);
    v97 = 0;
  }
  else
  {
    v97 = 1;
  }
  if (v149 != *(_QWORD *)(a2 + 40)
    || v150 != *(_QWORD *)(a2 + 48)
    || v151 != (unint64_t)*(unsigned int *)(a2 + 56))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 659, 42, 0, "Invalid output digest", v117, v118, v126);
    goto LABEL_96;
  }
LABEL_97:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v97)
    v98 = 0;
  else
    v98 = -1;
  if ((int)result >= 0)
    return v98;
  else
    return result;
}

size_t PCompressLZVNEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZVNDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result)
    return -1;
  return result;
}

uint64_t AEADecryptInPlace(AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(_QWORD, float), AAFlagSet a5, int a6)
{
  AAByteStream_impl *v11;
  uint64_t v12;
  uint64_t v13;
  AAByteStream_impl *v14;
  uint64_t v15;
  uint64_t v16;
  AAByteStream_impl *v17;
  uint64_t FieldUInt;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;
  char v25;

  v11 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  v14 = v11;
  if (v11)
  {
    v17 = AEADecryptionRandomAccessInputStreamOpen(v11, a2, 0xFFFFFFFFFFFFFFFFLL, a5, a6);
    if (v17)
    {
      FieldUInt = AEAContextGetFieldUInt(a2, 0xDu);
      if ((FieldUInt & 0x8000000000000000) != 0)
      {
        v20 = "bad output size";
        v21 = 80;
      }
      else
      {
        if ((processWithProgress(v17, v14, 0, FieldUInt, a3, a4) & 0x80000000) == 0)
        {
          v19 = 1;
          goto LABEL_12;
        }
        v20 = "processWithProgress";
        v21 = 83;
      }
    }
    else
    {
      v20 = "AEADecryptionRandomAccessInputStreamOpen";
      v21 = 76;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", v21, 127, 0, v20, v15, v16, v25);
    AAByteStreamCancel(v14);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", 72, 127, 0, "aaInPlaceStreamOpen", v12, v13, v25);
    v17 = 0;
  }
  v19 = 0;
LABEL_12:
  if (AAByteStreamClose(v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", 87, 127, 0, "AAByteStreamClose", v22, v23, v25);
    v19 = 0;
  }
  AAByteStreamClose(v14);
  if (v19)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t processWithProgress(AAByteStream_impl *a1, AAByteStream_impl *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(_QWORD, float))
{
  uint64_t v8;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(_QWORD, float);
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  int v39;
  const char *v40;
  __int16 v41;
  char v42;
  uint64_t (*v43)(uint64_t, float);
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v8 = a4;
  if (a3 && a4)
  {
    v12 = 0;
  }
  else
  {
    v12 = (char *)malloc(0x40000uLL);
    if (v12)
    {
      if (a3)
      {
        v15 = a3;
        v44 = a5;
        v45 = v8;
LABEL_7:
        v16 = v15;
        if (v15 >= 0x40000)
          v15 = 0x40000;
        if (*((_QWORD *)a1 + 2))
        {
          v17 = a6;
          v18 = 0;
          v19 = v12;
          v20 = v15;
          while (1)
          {
            v21 = (*((uint64_t (**)(_QWORD, char *, uint64_t))a1 + 2))(*(_QWORD *)a1, v19, v20);
            if (v21 < 0)
              break;
            if (v21)
            {
              v19 += v21;
              v18 += v21;
              v20 -= v21;
              if (v20)
                continue;
            }
            if (v18 <= 0)
              break;
            if (*((_QWORD *)a2 + 3))
            {
              v22 = 0;
              v23 = v12;
              v24 = v15;
              while (1)
              {
                v25 = (*((uint64_t (**)(_QWORD, char *, uint64_t))a2 + 3))(*(_QWORD *)a2, v23, v24);
                if (v25 < 1)
                  break;
                v23 += v25;
                v22 += v25;
                v24 -= v25;
                if (!v24)
                {
                  if (v22 <= 0)
                    break;
                  v15 = v16 - v15;
                  a6 = v17;
                  a5 = v44;
                  if (a6 && (a6(v44, (float)((float)(a3 - v15) * 100.0) / (float)a3) & 0x80000000) != 0)
                  {
                    v40 = "progress_proc";
                    v41 = 33;
                    goto LABEL_48;
                  }
                  v8 = v45;
                  if (v15)
                    goto LABEL_7;
                  goto LABEL_23;
                }
              }
            }
            v40 = "aaByteStreamWriteExpected";
            v41 = 31;
            goto LABEL_48;
          }
        }
        v40 = "aaByteStreamReadExpected";
        v41 = 30;
      }
      else
      {
LABEL_23:
        if (!v8)
        {
LABEL_42:
          free(v12);
          return 0;
        }
        v26 = (float)v8;
        v27 = v8;
        v43 = a6;
        v46 = v8;
LABEL_25:
        if (v27 >= 0x40000)
          v28 = 0x40000;
        else
          v28 = v27;
        if (*((_QWORD *)a1 + 4))
        {
          v29 = 0;
          v27 -= v28;
          v30 = v12;
          v31 = v27;
          v32 = v28;
          while (1)
          {
            v33 = (*((uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))a1 + 4))(*(_QWORD *)a1, v30, v32, v31);
            if (v33 < 0)
              break;
            if (v33)
            {
              v30 += v33;
              v29 += v33;
              v31 += v33;
              v32 -= v33;
              if (v32)
                continue;
            }
            if (v29 <= 0)
              break;
            if (*((_QWORD *)a2 + 5))
            {
              v34 = 0;
              v35 = v12;
              v36 = v27;
              while (1)
              {
                v37 = (*((uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))a2 + 5))(*(_QWORD *)a2, v35, v28, v36);
                if (v37 < 1)
                  break;
                v35 += v37;
                v34 += v37;
                v36 += v37;
                v28 -= v37;
                if (!v28)
                {
                  if (v34 <= 0)
                    break;
                  if (v43 && (v43(a5, (float)((float)(v46 - v27) * 100.0) / v26) & 0x80000000) != 0)
                  {
                    v40 = "progress_proc";
                    v41 = 43;
                    goto LABEL_48;
                  }
                  if (v27)
                    goto LABEL_25;
                  goto LABEL_42;
                }
              }
            }
            v40 = "aaByteStreamPWriteExpected";
            v41 = 42;
            goto LABEL_48;
          }
        }
        v40 = "aaByteStreamPReadExpected";
        v41 = 41;
      }
LABEL_48:
      v39 = 0;
    }
    else
    {
      v39 = *__error();
      v40 = "malloc";
      v41 = 24;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"processWithProgress", v41, 127, v39, v40, v13, v14, v42);
  }
  free(v12);
  AAByteStreamCancel(a1);
  AAByteStreamCancel(a2);
  return 0xFFFFFFFFLL;
}

uint64_t AEAEncryptInPlace(AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(_QWORD, float), unint64_t a5, int a6)
{
  off_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  AAByteStream_impl *v16;
  uint64_t v17;
  uint64_t v18;
  AAByteStream_impl *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  AAByteStream_impl *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  char v30;

  v12 = AAByteStreamSeek(a1, 0, 2);
  if (v12 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 106, 127, 0, "AAByteStreamSeek", v13, v14, v30);
    v19 = 0;
LABEL_11:
    v23 = 0;
LABEL_17:
    v26 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  v15 = v12;
  v16 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  v19 = v16;
  if (!v16)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 110, 127, 0, "aaInPlaceStreamOpen", v17, v18, v30);
    goto LABEL_11;
  }
  v20 = 3;
  if (a5 < 3)
    v20 = a5;
  v23 = AEAEncryptionOutputStreamOpen(v16, a2, v20 << 62, a6);
  if (!v23)
  {
    v27 = "AEAEncryptionOutputStreamOpen";
    v28 = 114;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", v28, 127, 0, v27, v21, v22, v30);
LABEL_16:
    AAByteStreamCancel(v19);
    goto LABEL_17;
  }
  if ((processWithProgress(v19, v23, v15, 0, a3, a4) & 0x80000000) != 0)
  {
    v27 = "processWithProgress";
    v28 = 117;
    goto LABEL_14;
  }
  if (AEAEncryptionOutputStreamCloseAndUpdateContext(v23, a2) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 121, 127, 0, "AEAEncryptionOutputStreamCloseAndUpdateContext", v24, v25, v30);
    v23 = 0;
    goto LABEL_16;
  }
  v23 = 0;
  v26 = 0;
LABEL_18:
  AAByteStreamClose(v23);
  AAByteStreamClose(v19);
  return v26;
}

uint64_t AEAKeychainGenerateItem(int a1, unint64_t a2, unint64_t a3, void *bytes, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  const char *v11;
  __int16 v12;
  unint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  char v26;
  unsigned int bytesa;

  if (a1)
  {
    if (a1 == 1)
    {
      v10 = (a2 + 7) >> 3;
      if (v10 <= a3)
      {
        result = CCRandomGenerateBytes(bytes, (a2 + 7) >> 3);
        if (!(_DWORD)result)
        {
          *a5 = v10;
          return result;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"RNG", 24, 96, 0, "generate random bytes", v15, v16, v26);
        v11 = "RNG failed";
        v12 = 43;
      }
      else
      {
        v11 = "Insufficient buffer capacity";
        v12 = 42;
      }
    }
    else
    {
      v11 = "Invalid item type";
      v12 = 78;
    }
  }
  else
  {
    v13 = vcvtps_u32_f32((float)a2 / 16.61);
    if (6 * v13 <= a3)
    {
      bytesa = 0;
      if (!v13)
      {
LABEL_24:
        result = 0;
        *((_BYTE *)bytes + v13) = 0;
        *a5 = v13;
        return result;
      }
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 5 * v13;
      if (v21 <= 1)
        v22 = 1;
      else
        v22 = v21;
      while (1)
      {
        if (0xCCCCCCCCCCCCCCCDLL * v18 <= 0x3333333333333333 && v19 != 0)
          *((_BYTE *)bytes + v19++) = 45;
        if (!v20)
          break;
LABEL_23:
        v13 = v19 + 1;
        *((_BYTE *)bytes + v19) = (v17 % 0xA) | 0x30;
        bytesa = v17 / 0xA;
        --v20;
        ++v18;
        v17 /= 0xAu;
        ++v19;
        if (v18 == v22)
          goto LABEL_24;
      }
      while (!CCRandomGenerateBytes(&bytesa, 4uLL))
      {
        if (bytesa <= 0xEE6B27FF)
        {
          v17 = bytesa % 0x3B9ACA00;
          v20 = 9;
          goto LABEL_23;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"RNG", 24, 96, 0, "generate random bytes", v24, v25, v26);
      v11 = "RNG failed";
      v12 = 64;
    }
    else
    {
      v11 = "Insufficient buffer capacity";
      v12 = 52;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainGenerateItem", v12, 96, 0, v11, a7, a8, v26);
  return 0xFFFFFFFFLL;
}

uint64_t AEAKeychainStoreItem(unsigned __int8 *a1, uint64_t a2, int a3, const UInt8 *a4, CFIndex a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Attributes;
  __CFDictionary *v11;
  CFDataRef v12;
  uint64_t v13;
  uint64_t v14;
  CFDataRef v15;
  uint64_t v16;
  uint64_t v17;
  SecAccessControlRef v18;
  OSStatus v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  char v26;

  if (!a2 || !a5)
  {
    v22 = "Invalid args";
    v23 = 178;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", v23, 96, 0, v22, a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    v22 = "create attributes";
    v23 = 182;
    goto LABEL_10;
  }
  v11 = Attributes;
  v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a4, a5);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 186, 96, 0, "create item data", v13, v14, v26);
    CFRelease(v11);
    return 0xFFFFFFFFLL;
  }
  v15 = v12;
  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x24BDE9550], v12);
  v18 = SecAccessControlCreateWithFlags(0, (CFTypeRef)*MEMORY[0x24BDE8F98], 1uLL, 0);
  if (!v18)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 191, 96, 0, "create access control", v16, v17, v26);
    goto LABEL_15;
  }
  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x24BDE8F48], v18);
  v19 = SecItemAdd(v11, 0);
  if (v19)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 196, 96, 0, "adding item to the keychain: %d", v20, v21, v19);
LABEL_15:
    v24 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  v24 = 0;
LABEL_17:
  CFRelease(v11);
  CFRelease(v15);
  if (v18)
    CFRelease(v18);
  return v24;
}

__CFDictionary *aeaKeychainCreateAttributes(unsigned __int8 *a1, uint64_t a2, int a3)
{
  const void **v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const char *v10;
  const char *v11;
  __int16 v12;
  const __CFAllocator *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  size_t v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  CFStringRef v24;
  __CFDictionary *Mutable;
  uint64_t v26;
  uint64_t v27;
  __CFDictionary *v28;
  int v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  __CFDictionary *v33;
  char v35;

  v6 = (const void **)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kSecUseDataProtectionKeychain");
  if (!v6)
  {
    v11 = "Keychain support not available";
    v12 = 115;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", v12, 96, 0, v11, v7, v8, v35);
    return 0;
  }
  v9 = *v6;
  if (a3)
  {
    if (a3 != 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 124, 96, 0, "Invalid item type %d", v7, v8, a3);
      return 0;
    }
    v10 = "kAEA";
  }
  else
  {
    v10 = "pAEA";
  }
  v13 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberIntType, v10);
  if (!v14)
  {
    v11 = "create attributes";
    v12 = 128;
    goto LABEL_12;
  }
  v15 = v14;
  v16 = (2 * a2) | 1;
  if (v16 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_20:
    v30 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 132, 96, *v30, "malloc", v31, v32, v35);
    v33 = v15;
LABEL_21:
    CFRelease(v33);
    return 0;
  }
  v17 = (const char *)malloc(v16);
  if (!v17)
    goto LABEL_20;
  v18 = (char *)v17;
  v19 = 2 * a2;
  if (a2)
  {
    v20 = v17 + 1;
    do
    {
      v21 = *a1++;
      *(v20 - 1) = aeaKeychainCreateAttributes_hex[(unint64_t)v21 >> 4];
      *v20 = aeaKeychainCreateAttributes_hex[v21 & 0xF];
      v20 += 2;
      --a2;
    }
    while (a2);
  }
  v17[v19] = 0;
  v24 = CFStringCreateWithCString(v13, v17, 0x600u);
  if (v24)
  {
    Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v28 = Mutable;
    if (Mutable)
    {
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDE9220], (const void *)*MEMORY[0x24BDE9230]);
      CFDictionaryAddValue(v28, v9, (const void *)*MEMORY[0x24BDBD270]);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x24BDE9188], v15);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x24BDE9128], CFSTR("AppleEncryptedArchive"));
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x24BDE8FA8], v24);
      v29 = 0;
      goto LABEL_27;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 144, 96, 0, "create attributes", v26, v27, v35);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 141, 96, 0, "create attributes", v22, v23, v35);
    v28 = 0;
  }
  v29 = 1;
LABEL_27:
  free(v18);
  CFRelease(v15);
  if (v24)
    CFRelease(v24);
  if (v29 && v28)
  {
    v33 = v28;
    goto LABEL_21;
  }
  return v28;
}

uint64_t AEAKeychainLoadItem(unsigned __int8 *a1, uint64_t a2, int a3, unint64_t a4, void *a5, size_t *a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Attributes;
  const __CFDictionary *v12;
  OSStatus v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;
  CFIndex Length;
  size_t v23;
  const UInt8 *BytePtr;
  const char *v25;
  __int16 v26;
  char v28;
  CFTypeRef result;

  result = 0;
  if (!a2)
  {
    v17 = "Invalid args";
    v18 = 219;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", v18, 96, 0, v17, a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    v17 = "create attributes";
    v18 = 223;
    goto LABEL_7;
  }
  v12 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x24BDE94C8], (const void *)*MEMORY[0x24BDBD270]);
  v13 = SecItemCopyMatching(v12, &result);
  if (v13 == -25300)
  {
    v16 = 0;
    goto LABEL_18;
  }
  if (!a5 || v13)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", 231, 96, 0, "searching item in keychain: %d", v14, v15, v13);
  }
  else
  {
    v19 = CFGetTypeID(result);
    if (v19 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)result);
      if (Length - 1 < a4)
      {
        v23 = Length;
        BytePtr = CFDataGetBytePtr((CFDataRef)result);
        memcpy(a5, BytePtr, v23);
        *a6 = v23;
        v16 = 1;
        goto LABEL_18;
      }
      v25 = "Invalid data size";
      v26 = 236;
    }
    else
    {
      v25 = "Invalid return type";
      v26 = 234;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", v26, 96, 0, v25, v20, v21, v28);
  }
  v16 = 0xFFFFFFFFLL;
LABEL_18:
  CFRelease(v12);
  if (result)
    CFRelease(result);
  return v16;
}

uint64_t AEAKeychainHasItem(unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Attributes;
  const __CFDictionary *v9;
  OSStatus v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  char v17;
  CFTypeRef result;

  result = 0;
  if (!a2)
  {
    v14 = "Invalid args";
    v15 = 258;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainHasItem", v15, 96, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    v14 = "create attributes";
    v15 = 262;
    goto LABEL_8;
  }
  v9 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x24BDE94C0], (const void *)*MEMORY[0x24BDBD270]);
  v10 = SecItemCopyMatching(v9, &result);
  if (v10 == -25300)
  {
    v13 = 0;
  }
  else if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainHasItem", 270, 96, 0, "searching item in keychain: %d", v11, v12, v10);
    v13 = 0xFFFFFFFFLL;
  }
  else
  {
    v13 = 1;
  }
  CFRelease(v9);
  if (result)
    CFRelease(result);
  return v13;
}

uint64_t AEAKeychainRemoveItem(unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Attributes;
  __CFDictionary *v9;
  OSStatus v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  char v17;

  if (!a2)
  {
    v14 = "Invalid args";
    v15 = 289;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainRemoveItem", v15, 96, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    v14 = "create attributes";
    v15 = 293;
    goto LABEL_8;
  }
  v9 = Attributes;
  v10 = SecItemDelete(Attributes);
  if (v10 == -25300)
  {
    v13 = 0;
  }
  else if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainRemoveItem", 298, 96, 0, "removing item from keychain: %d", v11, v12, v10);
    v13 = 0xFFFFFFFFLL;
  }
  else
  {
    v13 = 1;
  }
  CFRelease(v9);
  return v13;
}

uint64_t PCompressZLIB5Encode(uint64_t a1, unint64_t a2, const uint8_t *a3, size_t a4)
{
  BOOL v4;
  size_t v5;
  size_t v7;

  v4 = a2 >= 2;
  v5 = a2 - 2;
  if (!v4)
    return -1;
  *(_WORD *)a1 = 24184;
  v7 = compression_encode_buffer((uint8_t *)(a1 + 2), v5, a3, a4, 0, COMPRESSION_ZLIB);
  if (v7)
    return v7 + 2;
  else
    return -1;
}

size_t PCompressZLIBDecode(uint8_t *a1, size_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4;
  size_t v5;
  size_t result;

  v4 = a4 >= 2;
  v5 = a4 - 2;
  if (!v4)
    return -1;
  result = compression_decode_buffer(a1, a2, (const uint8_t *)(a3 + 2), v5, 0, COMPRESSION_ZLIB);
  if (!result)
    return -1;
  return result;
}

uint64_t ParallelCompressionEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  __int128 v9;
  _OWORD v11[3];
  unsigned int v12[2];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v8 = *(_DWORD *)(a1 + 4);
  LODWORD(v15) = *(_DWORD *)a1;
  v14 = *(_QWORD *)(a1 + 16);
  v12[1] = 0;
  v13 = v8;
  v12[0] = *(_DWORD *)(a1 + 8);
  v9 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 56);
  return PCompressFilter(v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t ParallelCompressionDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  __int128 v9;
  _OWORD v11[3];
  __int128 v12;
  __int128 v13;

  v12 = 0u;
  v13 = 0u;
  v8 = *(_DWORD *)(a1 + 4);
  DWORD2(v13) = *(_DWORD *)a1;
  DWORD1(v12) = 1;
  DWORD2(v12) = v8;
  v9 = *(_OWORD *)(a1 + 24);
  v11[0] = *(_OWORD *)(a1 + 8);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 40);
  return PCompressFilter((unsigned int *)&v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t (*PCompressGetEncoderFilter(unsigned int a1))()
{
  if (a1 > 6)
    return 0;
  else
    return off_24C305B38[a1];
}

uint64_t (*PCompressGetDecoderFilter(unsigned int a1))()
{
  if (a1 > 6)
    return 0;
  else
    return off_24C305B70[a1];
}

uint64_t RawImagePatchInternal(uint64_t a1, AAByteStream_impl *a2)
{
  int DefaultNThreads;
  int v5;
  AAByteStream_impl *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  __int128 *v28;
  _QWORD *v29;
  char *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  size_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  FILE **v51;
  const char *v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  int v56;
  const char *v57;
  const char *v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  AAByteStream_impl *v62;
  uint64_t v63;
  uint64_t v64;
  AAByteStream_impl *v65;
  uint64_t v66;
  AAFlagSet v67;
  uint64_t v68;
  uint64_t v69;
  AAByteStream v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char v75;
  const char *v76;
  __int16 v77;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  _OWORD *v86;
  __int128 v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  __int16 v105;
  __int128 *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  char *v111;
  uint64_t v112;
  _QWORD *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  BOOL v118;
  BOOL v119;
  const char *v121;
  __int16 v122;
  uint64_t **v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t *v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _BYTE *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  char *v161;
  uint64_t v162;
  uint64_t v163;
  _BYTE *v164;
  uint64_t v165;
  _BYTE *v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _BYTE *v174;
  uint64_t v175;
  uint64_t v176;
  _BYTE *v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  int v183;
  uint64_t *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  const char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  int *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  const char *v208;
  const char *v209;
  int v210;
  int v211;
  FILE *v212;
  const char *v213;
  size_t v214;
  uint64_t v215;
  unint64_t *v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  const char *v220;
  __int16 v221;
  int v222;
  unint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  const char *v240;
  __int16 v241;
  const char *v242;
  __int16 v243;
  AAByteStream_impl *v244;
  BOOL v245;
  BOOL v246;
  BOOL v247;
  unint64_t v248;
  __int16 v249;
  char v250;
  char v251;
  char v252;
  uint64_t v253;
  uint64_t v254;
  unsigned int v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  int v268;
  int v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  AAByteStream compressed_stream;
  uint64_t **s;
  unsigned int **v275;
  void *v276;
  _BYTE *v277;
  unint64_t v278;
  AAByteStream_impl *v279;
  AAByteStream_impl *v280;
  uint64_t v281;
  AAByteStream_impl *v282;
  int v283;
  AAByteStream_impl *v284;
  uint64_t v285;
  int v286;
  uint64_t *v287;
  _QWORD *v288;
  unsigned int **v289;
  unsigned int **v290;
  uint64_t v291;
  AAByteStream_impl *v292;

  v5 = *(_DWORD *)(a1 + 40);
  DefaultNThreads = *(_DWORD *)(a1 + 44);
  if (!DefaultNThreads)
  {
    DefaultNThreads = getDefaultNThreads();
    *(_DWORD *)(a1 + 44) = DefaultNThreads;
  }
  if (DefaultNThreads >= 3)
    *(_DWORD *)(a1 + 44) = 2;
  if (!*(_QWORD *)(a1 + 16))
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 24);
  v6 = a2;
  if (!a2)
  {
    v18 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 32), 0, 0);
    v6 = (AAByteStream_impl *)v18;
    if (!v18)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 542, 135, 0, "AAFileStreamOpenWithPath", v19, v20, v250);
      v31 = 0;
      v30 = 0;
      v29 = 0;
      v28 = 0;
      v27 = 0;
      goto LABEL_30;
    }
    if ((v5 & 1) != 0 && (io_set_nocache(v18) & 0x80000000) != 0)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 543, 135, "io_set_nocache %s", v21, v22, v23, *(_QWORD *)(a1 + 32));
  }
  v7 = malloc(0x2EuLL);
  v10 = v7;
  if (!v7)
  {
    v17 = *__error();
    v15 = "aaMalloc";
    v16 = 108;
    goto LABEL_24;
  }
  if (!*((_QWORD *)v6 + 2))
    goto LABEL_17;
  v11 = 0;
  v12 = 46;
  v13 = v7;
  do
  {
    v14 = (*((uint64_t (**)(_QWORD, _QWORD *, uint64_t))v6 + 2))(*(_QWORD *)v6, v13, v12);
    if (v14 < 0)
      goto LABEL_17;
    if (!v14)
      break;
    v13 = (_QWORD *)((char *)v13 + v14);
    v11 += v14;
    v12 -= v14;
  }
  while (v12);
  if (v11 != 46)
  {
LABEL_17:
    v15 = "aaByteStreamReadExpected";
    v16 = 110;
    goto LABEL_18;
  }
  if (*v10 != 0x3031464649444952
    || !*((_WORD *)v10 + 4)
    || !*(_QWORD *)((char *)v10 + 18)
    || (v35 = *(_QWORD *)((char *)v10 + 30), v35 < 0x2F)
    || v35 >= *(_QWORD *)((char *)v10 + 38))
  {
    v15 = "bad header";
    v16 = 118;
LABEL_18:
    v17 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v16, 135, v17, v15, v8, v9, v250);
LABEL_25:
    free(v10);
    v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 548, 135, *v24, "patch_read_header", v25, v26, v251);
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
LABEL_26:
    v31 = 0;
    goto LABEL_27;
  }
  if (v35 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_50:
    v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", 122, 135, *v44, "aaReallocf", v45, v46, v250);
    v10 = 0;
    goto LABEL_25;
  }
  v36 = (char *)realloc(v10, v35);
  if (!v36)
  {
    free(v10);
    goto LABEL_50;
  }
  v30 = v36;
  v39 = *(_QWORD *)(v36 + 30) - 46;
  if (*((_QWORD *)v6 + 2))
  {
    if (*(_QWORD *)(v36 + 30) == 46)
      goto LABEL_54;
    v40 = 0;
    v41 = v36 + 46;
    v42 = *(_QWORD *)(v36 + 30) - 46;
    while (1)
    {
      v43 = (*((uint64_t (**)(_QWORD, char *, uint64_t))v6 + 2))(*(_QWORD *)v6, v41, v42);
      if (v43 < 0)
        break;
      if (v43)
      {
        v41 += v43;
        v40 += v43;
        v42 -= v43;
        if (v42)
          continue;
      }
      goto LABEL_53;
    }
    v40 = v43;
  }
  else
  {
    v40 = -1;
  }
LABEL_53:
  if (v39 != v40)
  {
    v53 = "aaByteStreamReadExpected";
    v54 = 124;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v54, 135, 0, v53, v37, v38, v250);
    v10 = v30;
    goto LABEL_25;
  }
LABEL_54:
  v47 = 0;
  v48 = *(_QWORD *)(v30 + 38);
  v49 = *((unsigned __int16 *)v30 + 4);
  do
  {
    v50 = *(_QWORD *)&v30[v47 + 46];
    if (v48 >= v50)
    {
      v53 = "bad header";
      v54 = 130;
      goto LABEL_62;
    }
    v47 += 8;
    v48 = v50;
  }
  while (8 * v49 + 8 != v47);
  if (*(int *)(a1 + 48) >= 1)
  {
    v51 = (FILE **)MEMORY[0x24BDAC8D8];
    if ((_DWORD)v49 == 1)
      v52 = "*full replacement*";
    else
      v52 = *(const char **)(a1 + 16);
    v55 = "(stream based)";
    if (*(_QWORD *)(a1 + 32))
      v55 = *(const char **)(a1 + 32);
    v56 = *(_DWORD *)(a1 + 40);
    if ((v56 & 1) != 0)
      v57 = "no";
    else
      v57 = "yes";
    if ((v56 & 2) != 0)
      v58 = "yes";
    else
      v58 = "no";
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImagePatch\n  Input:        %s\n  Output:       %s\n  Patch:        %s\n  CryptexCache: %s\n  StaticContent: %s\n", v52, *(const char **)(a1 + 24), v55, v57, v58);
    if (*(int *)(a1 + 48) >= 2)
    {
      fprintf(*v51, "  - Variants:   %d\n  - Flags:      %llx\n  - # controls: %llu\n  - Patch size: %llu bytes\n    - Metadata: %llu bytes\n    - Controls: %llu bytes\n", *((unsigned __int16 *)v30 + 4), *(_QWORD *)(v30 + 10), *(_QWORD *)(v30 + 18), *(_QWORD *)&v30[8 * *((unsigned __int16 *)v30 + 4) + 46], *(_QWORD *)(v30 + 38) - *(_QWORD *)(v30 + 30), *(_QWORD *)(v30 + 46) - *(_QWORD *)(v30 + 38));
      if (*((_WORD *)v30 + 4))
      {
        v59 = 0;
        do
        {
          if (v59)
            v60 = "Diff";
          else
            v60 = "Literal";
          v61 = v59 + 1;
          fprintf(*v51, "    - %s stream: %llu bytes\n", v60, *(_QWORD *)&v30[8 * v59 + 54] - *(_QWORD *)&v30[8 * v59 + 46]);
          v59 = v61;
        }
        while (v61 < *((unsigned __int16 *)v30 + 4));
      }
    }
  }
  v62 = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)(v30 + 30), *(_QWORD *)(v30 + 38));
  v65 = v62;
  if (!v62)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 187, 135, 0, "aaIntervalInputStreamOpen", v63, v64, v250);
    v29 = 0;
    v70 = 0;
    goto LABEL_95;
  }
  v66 = *(unsigned int *)(a1 + 48);
  if (v66 <= 3)
    v67 = v66 << 62;
  else
    v67 = 0xC000000000000000;
  v70 = AADecompressionInputStreamOpen(v62, v67, *(_DWORD *)(a1 + 44));
  if (!v70)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 189, 135, 0, "AADecompressionInputStreamOpen", v68, v69, v250);
    v29 = 0;
    goto LABEL_95;
  }
  v29 = calloc(*((unsigned __int16 *)v30 + 4), 8uLL);
  if (!v29)
  {
    v76 = "aaCalloc";
    v77 = 193;
    goto LABEL_94;
  }
  if (*((_WORD *)v30 + 4))
  {
    v73 = 0;
    while (1)
    {
      v74 = rawimg_create_with_stream(v70, v73 == 0);
      v29[v73] = v74;
      if (!v74)
        break;
      if (++v73 >= (unint64_t)*((unsigned __int16 *)v30 + 4))
        goto LABEL_89;
    }
    v76 = "rawimg_create_with_stream";
    v77 = 199;
LABEL_94:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", v77, 135, 0, v76, v71, v72, v250);
LABEL_95:
    free(v29);
    v75 = 1;
  }
  else
  {
LABEL_89:
    v75 = 0;
  }
  v78 = AAByteStreamClose(v70);
  v79 = AAByteStreamClose(v65);
  if (!v29 || (v75 & 1) != 0 || v79 < 0 || v78 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 552, 135, 0, "patch_read_variants", v80, v81, v250);
    v27 = 0;
    v28 = 0;
    v29 = 0;
    goto LABEL_26;
  }
  v82 = calloc(*((unsigned __int16 *)v30 + 4), 0x20uLL);
  v31 = v82;
  if (!v82)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 556, 135, 0, "aaCalloc", v83, v84, v250);
    v28 = 0;
    goto LABEL_368;
  }
  if (*((_WORD *)v30 + 4))
  {
    v85 = 0;
    v86 = v82;
    do
    {
      v87 = *(_OWORD *)(v29[v85] + 2104);
      *v86 = *(_OWORD *)(v29[v85] + 2088);
      v86[1] = v87;
      v86 += 2;
      ++v85;
      v88 = *((unsigned __int16 *)v30 + 4);
    }
    while (v85 < v88);
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 24);
    if ((_DWORD)v88 == 1)
    {
      v28 = 0;
      v269 = 0;
      v275 = 0;
      s = 0;
      v287 = 0;
      compressed_stream = 0;
      v279 = 0;
      v89 = *v29;
      v90 = *(_DWORD *)(a1 + 40);
      v91 = v90 & 1;
      goto LABEL_106;
    }
  }
  else
  {
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 24);
  }
  v106 = (__int128 *)malloc(0x2000uLL);
  v28 = v106;
  if (!v106)
  {
    v121 = "aaMalloc";
    v122 = 568;
    goto LABEL_367;
  }
  saveThreadErrorContext(v106);
  v109 = *((unsigned __int16 *)v30 + 4);
  if (!*((_WORD *)v30 + 4))
  {
LABEL_138:
    restoreThreadErrorContext(v28);
    goto LABEL_139;
  }
  v110 = &v31[4 * v109 - 4];
  v111 = (char *)(v29 - 1);
  while (1)
  {
    v291 = v109;
    v112 = v109 - 1;
    *(_QWORD *)(*(_QWORD *)&v111[8 * v109] + 2048) = *(_QWORD *)(a1 + 16);
    if (!rawimg_get_digests(*(_QWORD *)&v111[8 * v109], 4, 1, 1))
    {
      v113 = *(_QWORD **)&v111[8 * v291];
      v114 = v113[261];
      v115 = v113[262];
      v116 = v113[263];
      v117 = v113[264];
      v118 = *v110 == v114 && v110[1] == v115;
      v119 = v118 && v110[2] == v116;
      if (v119 && v110[3] == v117)
        break;
    }
    v110 -= 4;
    v109 = v112;
    if (!v112)
      goto LABEL_138;
  }
  restoreThreadErrorContext(v28);
  v269 = v112;
  if ((v112 & 0x80000000) != 0)
  {
LABEL_139:
    v121 = "ImagePatch: No variant found";
    v122 = 586;
    goto LABEL_367;
  }
  if ((_DWORD)v291 == 1)
    goto LABEL_279;
  v184 = &v31[4 * v112];
  v185 = *v184;
  v186 = v184[1];
  v188 = v184[2];
  v187 = v184[3];
  if (*v31 == v185 && v31[1] == v186 && v31[2] == v188 && v31[3] == v187)
  {
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 16);
LABEL_279:
    v207 = *v29;
    v208 = *(const char **)(*v29 + 2048);
    v209 = *(const char **)(a1 + 24);
    v210 = strcmp(v208, v209);
    v211 = *(_DWORD *)(a1 + 48);
    if (v210)
    {
      if (v211 >= 2)
      {
        fwrite("ImagePatch: Digest match. Copy input to output.\n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
        v207 = *v29;
      }
      if ((copyFileSegment(v208, 0, *(_QWORD *)(v207 + 2120), v209) & 0x80000000) != 0)
      {
        v121 = "copyFileSegment";
        v122 = 607;
        goto LABEL_367;
      }
    }
    else if (v211 >= 2)
    {
      v212 = (FILE *)*MEMORY[0x24BDAC8D8];
      v213 = "ImagePatch: Digest match. Output already correct.\n";
      v214 = 50;
      goto LABEL_375;
    }
LABEL_376:
    v27 = 1;
    rawimg_show(*v29, 1, *(_DWORD *)(a1 + 48));
    if (*(_QWORD *)a1
      && ((*(uint64_t (**)(_QWORD, uint64_t))a1)(*(_QWORD *)(a1 + 8), 100) & 0x80000000) != 0)
    {
      v121 = "callback signaled abort";
      v122 = 641;
      goto LABEL_367;
    }
    goto LABEL_369;
  }
  rawimg_show(v29[v112], 0, *(_DWORD *)(a1 + 48));
  v90 = *(_DWORD *)(a1 + 40);
  v91 = v90 & 1;
  v285 = *v29;
  v288 = (_QWORD *)v29[v269];
  v192 = (const char *)v288[256];
  v283 = strcmp(v192, *(const char **)(*v29 + 2048));
  if (!v283)
  {
    if ((v30[10] & 1) != 0)
    {
      if (*(_DWORD *)(a1 + 48))
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImagePatch: Patching with excess space <= %d bytes.\n", *(_DWORD *)(v30 + 26));
    }
    else
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 245, 135, "ImagePatch: Patch not created with in place. No bound on needed excess space.", v193, v194, v195, v250);
    }
    v223 = v288[265];
    if (*(_QWORD *)(v285 + 2120) > v223)
      v223 = *(_QWORD *)(v285 + 2120);
    v281 = v223;
    v290 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v285 + 2048), 2, 0x1A4u);
    if (!v290)
    {
      v240 = "AAFileStreamOpenWithPath";
      v241 = 252;
      goto LABEL_346;
    }
    if ((v90 & 1) != 0)
    {
      if ((io_set_nocache(v290) & 0x80000000) != 0)
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 257, 135, "io_set_nocache %s", v224, v225, v226, *(_QWORD *)(v285 + 2048));
      LODWORD(v227) = *(_DWORD *)(a1 + 48);
      v227 = v227 >= 3 ? 3 : v227;
      v290 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v290, 0x1000000uLL, 14, 1, v227 << 62);
      if (!v290)
      {
        v240 = "aaCacheStreamOpen";
        v241 = 259;
        goto LABEL_346;
      }
    }
    v275 = (unsigned int **)aaInSituStreamOpen(v290, v281, *(_DWORD *)(v30 + 26), *(_DWORD *)(a1 + 48), 1);
    if (!v275)
    {
      v240 = "aaInSituStreamOpen";
      v241 = 264;
      goto LABEL_346;
    }
    if (*((unsigned __int16 *)v30 + 4) <= 1u)
    {
      s = 0;
      v287 = 0;
      compressed_stream = 0;
      v279 = 0;
      v268 = 0;
      v289 = v275;
      v123 = aaSegmentStreamOpen(v275, (_QWORD *)v285);
      goto LABEL_145;
    }
    v289 = v275;
LABEL_324:
    s = aaSegmentStreamOpen(v275, v288);
    if (!s)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 290, 135, 0, "aaSegmentStreamOpen", v231, v232, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
      v292 = 0;
      v282 = 0;
      v287 = 0;
      s = 0;
      goto LABEL_347;
    }
    v287 = aaForkInputStreamOpen(s, (uint64_t)v288, 0, v228, v229, v230, v231, v232);
    if (!v287)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 292, 135, 0, "aaForkInputStreamOpen", v233, v234, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
      v292 = 0;
      v282 = 0;
      v287 = 0;
      goto LABEL_347;
    }
    compressed_stream = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)&v30[8 * v269 + 46], *(_QWORD *)&v30[8 * v291 + 46]);
    if (compressed_stream)
    {
      LODWORD(v237) = *(_DWORD *)(a1 + 48);
      if (v237 >= 3)
        v237 = 3;
      else
        v237 = v237;
      v279 = AADecompressionInputStreamOpen(compressed_stream, v237 << 62, *(_DWORD *)(a1 + 44));
      if (v279)
      {
        if (v283)
          goto LABEL_306;
        v268 = 0;
        goto LABEL_144;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 298, 135, 0, "AADecompressionInputStreamOpen", v238, v239, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 296, 135, 0, "aaIntervalInputStreamOpen", v235, v236, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
    }
LABEL_273:
    v292 = 0;
    v282 = 0;
    goto LABEL_347;
  }
  if (*((unsigned __int16 *)v30 + 4) > 1u)
  {
    v275 = (unsigned int **)AAFileStreamOpenWithPath(v192, 0, 0);
    if (v275)
    {
      if ((v90 & 1) == 0)
        goto LABEL_271;
      if ((io_set_nocache(v275) & 0x80000000) != 0)
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 284, 135, "io_set_nocache %s", v198, v199, v200, v288[256]);
      LODWORD(v201) = *(_DWORD *)(a1 + 48);
      v201 = v201 >= 3 ? 3 : v201;
      v91 = 1;
      v275 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v275, 0x1000000uLL, 14, 1, v201 << 62);
      if (v275)
      {
LABEL_271:
        v289 = 0;
        goto LABEL_324;
      }
      v240 = "aaCacheStreamOpen";
      v241 = 286;
    }
    else
    {
      v240 = "AAFileStreamOpenWithPath";
      v241 = 281;
    }
LABEL_346:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v241, 135, 0, v240, v196, v197, v250);
    v276 = 0;
    v284 = 0;
    v279 = 0;
    v280 = 0;
    compressed_stream = 0;
    v289 = 0;
    v292 = 0;
    v282 = 0;
    v287 = 0;
    s = 0;
    v275 = 0;
LABEL_347:
    v286 = 0;
    v277 = 0;
    goto LABEL_348;
  }
  v275 = 0;
  s = 0;
  v287 = 0;
  compressed_stream = 0;
  v279 = 0;
LABEL_306:
  v89 = v285;
LABEL_106:
  v285 = v89;
  v289 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v89 + 2048), 1538, 0x1A4u);
  if (!v289)
  {
    v104 = "AAFileStreamOpenWithPath";
    v105 = 305;
    goto LABEL_142;
  }
  if ((v90 & 2) != 0 && (io_hint_static_content(v289) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 308, 135, "ImagePatch: Static content hint failed.", v94, v95, v96, v250);
  if ((io_preallocate(v289, *(_QWORD *)(v285 + 2120)) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 311, 135, "ImagePatch: Preallocation failed.", v97, v98, v99, v250);
  if (v91)
  {
    if ((io_set_nocache(v289) & 0x80000000) != 0)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 316, 135, "io_set_nocache %s", v100, v101, v102, *(_QWORD *)(v285 + 2048));
    LODWORD(v103) = *(_DWORD *)(a1 + 48);
    if (v103 >= 3)
      v103 = 3;
    else
      v103 = v103;
    v268 = 1;
    v289 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v289, 0x100000uLL, 14, 1, v103 << 62);
    if (!v289)
    {
      v104 = "aaCacheStreamOpen";
      v105 = 318;
LABEL_142:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v105, 135, 0, v104, v92, v93, v250);
      v276 = 0;
      v282 = 0;
      v284 = 0;
      v280 = 0;
      v289 = 0;
      v292 = 0;
      goto LABEL_347;
    }
  }
  else
  {
    v268 = 1;
  }
LABEL_144:
  v123 = aaSegmentStreamOpen(v289, (_QWORD *)v285);
LABEL_145:
  v282 = (AAByteStream_impl *)v123;
  if (!v123)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 322, 135, 0, "aaSegmentStreamOpen", v124, v125, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    goto LABEL_273;
  }
  v292 = aaForkOutputStreamOpen((uint64_t)v123, (_QWORD *)v285);
  if (!v292)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 324, 135, 0, "aaForkOutputStreamOpen", v126, v127, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    v292 = 0;
    goto LABEL_347;
  }
  v280 = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)(v30 + 46), *(_QWORD *)(v30 + 54));
  if (!v280)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 328, 135, 0, "aaIntervalInputStreamOpen", v128, v129, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    goto LABEL_347;
  }
  LODWORD(v130) = *(_DWORD *)(a1 + 48);
  if (v130 >= 3)
    v130 = 3;
  else
    v130 = v130;
  v284 = AADecompressionInputStreamOpen(v280, v130 << 62, *(_DWORD *)(a1 + 44));
  if (!v284)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 330, 135, 0, "AADecompressionInputStreamOpen", v131, v132, v250);
    v276 = 0;
    v284 = 0;
    goto LABEL_347;
  }
  v276 = calloc(1uLL, 0x10040uLL);
  if (!v276)
  {
    v202 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_create", 36, 135, *v202, "aaCalloc", v203, v204, v250);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 338, 135, 0, "control_reader_create", v205, v206, v252);
    v276 = 0;
    goto LABEL_347;
  }
  *((_QWORD *)v276 + 0x2000) = v6;
  *((_QWORD *)v276 + 8195) = v30;
  *((_QWORD *)v276 + 8196) = a1;
  v139 = *((unsigned __int16 *)v30 + 4) + 1;
  *((_QWORD *)v276 + 8197) = 0x2000 / v139 * v139;
  *((_QWORD *)v276 + 8198) = -1;
  v140 = *(_QWORD *)(v30 + 18);
  *((_QWORD *)v276 + 8199) = v140 * v139;
  v141 = v268;
  if (!v140)
    v141 = 1;
  if ((v141 & 1) == 0)
  {
    v278 = 0;
    v215 = 0;
    while (1)
    {
      v216 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v278, v133, v134, v135, v136, v137, v138);
      if (!v216)
      {
        v220 = "ctrl_reader_get";
        v221 = 349;
        goto LABEL_302;
      }
      if ((*v216 & 0x8000000000000000) == 0)
        v217 = *v216;
      else
        v217 = 0x8000000000000000 - *v216;
      v218 = v216[v269 + 1];
      if (v218 < 0)
        v218 = 0x8000000000000000 - v218;
      v267 = v218;
      if (v217)
        break;
LABEL_299:
      v215 += v267;
      if (++v278 >= *(_QWORD *)(v30 + 18))
        goto LABEL_156;
    }
    while (1)
    {
      v219 = v217 >= 0x10000 ? 0x10000 : v217;
      if (v219 != aaByteStreamSimulate(v287))
        break;
      v215 += v219;
      v217 -= v219;
      if (!v217)
        goto LABEL_299;
    }
    v220 = "aaByteStreamSimulate";
    v221 = 358;
LABEL_302:
    v222 = 0;
    goto LABEL_308;
  }
LABEL_156:
  v277 = calloc(1uLL, 0x20000uLL);
  if (!v277)
  {
    v222 = *__error();
    v220 = "aaCalloc";
    v221 = 371;
LABEL_308:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v221, 135, v222, v220, v137, v138, v250);
    goto LABEL_347;
  }
  v264 = 0;
  v257 = 0;
  v254 = v269 + 1;
  v148 = *(_QWORD *)(v30 + 18);
  v255 = 1;
  while (!v148)
  {
LABEL_244:
    v183 = v268;
    if (v255 > 1)
      v183 = 1;
    ++v255;
    if (v183 == 1)
    {
      if ((AAByteStreamTruncate(v289) & 0x80000000) == 0)
      {
        v286 = 1;
        goto LABEL_348;
      }
      v242 = "AAByteStreamTruncate";
      v243 = 457;
LABEL_384:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v243, 135, 0, v242, v146, v147, v250);
      v286 = 0;
LABEL_348:
      if (v275 == v289)
        v244 = 0;
      else
        v244 = (AAByteStream_impl *)v275;
      goto LABEL_351;
    }
  }
  v256 = 0;
  v263 = 0;
  v259 = 0;
  while (2)
  {
    v149 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v256, v142, v143, v144, v145, v146, v147);
    if (!v149)
    {
      v242 = "ctrl_reader_get";
      v243 = 387;
      goto LABEL_384;
    }
    v150 = *v149;
    v151 = v149[1];
    if ((*v149 & 0x8000000000000000) != 0)
      v150 = 0x8000000000000000 - *v149;
    v261 = v150;
    v152 = 0x8000000000000000 - v151;
    if (v151 >= 0)
      v152 = v149[1];
    v260 = v152;
    v153 = v149[v254];
    if (v153 < 0)
      v153 = 0x8000000000000000 - v153;
    v253 = v153;
    if (v255 == 2)
    {
      v263 += v261;
      if ((v268 & 1) == 0 && v263 < *(_QWORD *)(v285 + 2056))
        goto LABEL_170;
LABEL_215:
      if (v260)
      {
        v262 = 0;
        while (1)
        {
          v172 = v260 - v262;
          if (v260 - v262 >= 0x10000)
            v172 = 0x10000;
          v266 = v172;
          if (!*((_QWORD *)v284 + 2))
          {
LABEL_336:
            v242 = "aaByteStreamReadExpected";
            v243 = 439;
            goto LABEL_384;
          }
          if (v172)
          {
            v173 = 0;
            v174 = v277;
            v175 = v172;
            while (1)
            {
              v176 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t))v284 + 2))(*(_QWORD *)v284, v174, v175);
              if (v176 < 0)
                break;
              if (v176)
              {
                v174 += v176;
                v173 += v176;
                v175 -= v176;
                if (v175)
                  continue;
              }
              goto LABEL_229;
            }
            v173 = v176;
LABEL_229:
            if (v266 != v173)
              goto LABEL_336;
            if (!*((_QWORD *)v292 + 5))
              goto LABEL_337;
            v272 = 0;
            v177 = v277;
            v178 = v263;
            v179 = v266;
            while (1)
            {
              v180 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, unint64_t))v292 + 5))(*(_QWORD *)v292, v177, v179, v178);
              if (v180 < 1)
                break;
              v177 += v180;
              v272 += v180;
              v178 += v180;
              v179 -= v180;
              if (!v179)
                goto LABEL_236;
            }
            v272 = v180;
LABEL_236:
            if (v266 != v272)
            {
LABEL_337:
              v242 = "aaByteStreamWriteExpected";
              v243 = 440;
              goto LABEL_384;
            }
          }
          else if (!*((_QWORD *)v292 + 5))
          {
            goto LABEL_337;
          }
          v264 += v266;
          if (*(_QWORD *)a1)
          {
            if (v264 > v257)
            {
              v181 = *(_QWORD *)(v285 + 2080);
              if (v264 < v181)
              {
                v182 = ((v181 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
                if (((*(uint64_t (**)(_QWORD, unint64_t))a1)(*(_QWORD *)(a1 + 8), v264 / (v181 / 0x64 + 1)) & 0x80000000) != 0)
                {
                  v249 = 450;
                  goto LABEL_387;
                }
                v257 = v264 + (v182 >> 2);
              }
            }
          }
          v263 += v266;
          v262 += v266;
          if (v262 >= v260)
            goto LABEL_243;
        }
      }
      goto LABEL_243;
    }
    if (!v261)
    {
LABEL_212:
      v259 += v253;
      if ((v268 & 1) != 0 || v255 != 1 || v263 < *(_QWORD *)(v285 + 2056))
        goto LABEL_215;
LABEL_170:
      v263 += v260;
LABEL_243:
      v148 = *(_QWORD *)(v30 + 18);
      if (++v256 >= v148)
        goto LABEL_244;
      continue;
    }
    break;
  }
  v258 = 0;
  while (2)
  {
    v154 = v261 - v258;
    if (v261 - v258 >= 0x10000)
      v154 = 0x10000;
    v265 = v154;
    if (!v287[4])
      goto LABEL_340;
    if (v154)
    {
      v270 = 0;
      v155 = v277;
      v156 = v259;
      v157 = v154;
      while (1)
      {
        v158 = ((uint64_t (*)(uint64_t, _BYTE *, uint64_t, uint64_t))v287[4])(*v287, v155, v157, v156);
        if (v158 < 0)
          break;
        if (v158)
        {
          v155 += v158;
          v270 += v158;
          v156 += v158;
          v157 -= v158;
          if (v157)
            continue;
        }
        goto LABEL_183;
      }
      v270 = v158;
LABEL_183:
      if (v265 != v270)
      {
LABEL_340:
        v242 = "aaByteStreamPReadExpected";
        v243 = 400;
        goto LABEL_384;
      }
    }
    v159 = *(_QWORD *)(v285 + 2072);
    if (v263 >= v159)
    {
LABEL_198:
      if (!*((_QWORD *)v292 + 5))
        goto LABEL_342;
      if (v265)
      {
        v271 = 0;
        v166 = v277;
        v167 = v263;
        v168 = v265;
        while (1)
        {
          v169 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, unint64_t))v292 + 5))(*(_QWORD *)v292, v166, v168, v167);
          if (v169 < 1)
            break;
          v166 += v169;
          v271 += v169;
          v167 += v169;
          v168 -= v169;
          if (!v168)
            goto LABEL_205;
        }
        v271 = v169;
LABEL_205:
        if (v265 != v271)
        {
LABEL_342:
          v242 = "aaByteStreamWriteExpected";
          v243 = 412;
          goto LABEL_384;
        }
      }
    }
    else
    {
      if (v265 + v263 > v159)
      {
        v242 = "bad controls";
        v243 = 406;
        goto LABEL_384;
      }
      if (!*((_QWORD *)v279 + 2))
        goto LABEL_380;
      if (v265)
      {
        v160 = 0;
        v161 = v277 + 0x10000;
        v162 = v265;
        while (1)
        {
          v163 = (*((uint64_t (**)(_QWORD, char *, uint64_t))v279 + 2))(*(_QWORD *)v279, v161, v162);
          if (v163 < 0)
            break;
          if (v163)
          {
            v161 += v163;
            v160 += v163;
            v162 -= v163;
            if (v162)
              continue;
          }
          goto LABEL_196;
        }
        v160 = v163;
LABEL_196:
        v164 = v277;
        v165 = v265;
        if (v265 != v160)
        {
LABEL_380:
          v242 = "aaByteStreamReadExpected";
          v243 = 407;
          goto LABEL_384;
        }
        do
        {
          *v164 += v164[0x10000];
          ++v164;
          --v165;
        }
        while (v165);
        goto LABEL_198;
      }
      if (!*((_QWORD *)v292 + 5))
        goto LABEL_342;
    }
    v264 += v265;
    if (!*(_QWORD *)a1 || v264 <= v257 || (v170 = *(_QWORD *)(v285 + 2080), v264 >= v170))
    {
LABEL_211:
      v259 += v265;
      v263 += v265;
      v258 += v265;
      if (v258 >= v261)
        goto LABEL_212;
      continue;
    }
    break;
  }
  v171 = ((v170 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
  if (((*(uint64_t (**)(_QWORD, unint64_t))a1)(*(_QWORD *)(a1 + 8), v264 / (v170 / 0x64 + 1)) & 0x80000000) == 0)
  {
    v257 = v264 + (v171 >> 2);
    goto LABEL_211;
  }
  v249 = 422;
LABEL_387:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v249, 135, 0, "callback signaled abort", v146, v147, v250);
  if (v275 == v289)
    v244 = 0;
  else
    v244 = (AAByteStream_impl *)v275;
  if (v279)
    AAByteStreamCancel(v279);
  AAByteStreamCancel(v284);
  v286 = 0;
LABEL_351:
  if (v276)
  {
    AAByteStreamClose(*((AAByteStream *)v276 + 8194));
    AAByteStreamClose(*((AAByteStream *)v276 + 8193));
    free(v276);
  }
  free(v277);
  AAByteStreamClose((AAByteStream)v287);
  AAByteStreamClose((AAByteStream)s);
  AAByteStreamClose(v244);
  AAByteStreamClose(v292);
  AAByteStreamClose(v282);
  AAByteStreamClose((AAByteStream)v289);
  AAByteStreamClose(v279);
  AAByteStreamClose(compressed_stream);
  AAByteStreamClose(v284);
  AAByteStreamClose(v280);
  if (v286)
  {
    if (rawimg_get_digests(*v29, 4, 0, 1)
      || (*v31 == *(_QWORD *)(*v29 + 2088) ? (v245 = v31[1] == *(_QWORD *)(*v29 + 2096)) : (v245 = 0),
          v245 ? (v246 = v31[2] == *(_QWORD *)(*v29 + 2104)) : (v246 = 0),
          v246 ? (v247 = v31[3] == *(_QWORD *)(*v29 + 2112)) : (v247 = 0),
          !v247))
    {
      v121 = "digest mismatch";
      v122 = 630;
      goto LABEL_367;
    }
    if (*(int *)(a1 + 48) >= 2)
    {
      v212 = (FILE *)*MEMORY[0x24BDAC8D8];
      v213 = "ImagePatch: Digest match. Output reconstructed.\n";
      v214 = 48;
LABEL_375:
      fwrite(v213, v214, 1uLL, v212);
    }
    goto LABEL_376;
  }
  v121 = "patch_apply";
  v122 = 621;
LABEL_367:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", v122, 135, 0, v121, v107, v108, v250);
LABEL_368:
  v27 = 0;
LABEL_369:
  if (*((_WORD *)v30 + 4))
  {
    v248 = 0;
    do
      rawimg_destroy((uint64_t *)v29[v248++]);
    while (v248 < *((unsigned __int16 *)v30 + 4));
  }
LABEL_27:
  if (!a2)
  {
LABEL_30:
    if (AAByteStreamClose(v6) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 649, 135, 0, "AAByteStreamClose", v32, v33, v250);
      v27 = 0;
    }
  }
  free(v31);
  free(v30);
  free(v29);
  free(v28);
  if (v27)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ctrl_reader_get(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t v12;
  AAByteStream_impl *v13;
  uint64_t v14;
  AAFlagSet v15;
  AAByteStream v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  char v30;

  v8 = a1 + 0x10000;
  v9 = *(_QWORD *)(a1 + 65560);
  if (*(_QWORD *)(v9 + 18) <= a2)
    return 0;
  v11 = a2 + a2 * *(unsigned __int16 *)(v9 + 8);
  if (v11 >= *(_QWORD *)(a1 + 65584))
    goto LABEL_8;
  v12 = *(_QWORD *)(a1 + 65568);
  *(_QWORD *)(a1 + 65584) = -*(_QWORD *)(a1 + 65576);
  AAByteStreamClose(*(AAByteStream *)(a1 + 65552));
  *(_QWORD *)(v8 + 16) = 0;
  AAByteStreamClose(*(AAByteStream *)(v8 + 8));
  *(_QWORD *)(v8 + 8) = 0;
  v13 = aaIntervalInputStreamOpen(*(_QWORD *)v8, *(_QWORD *)(v9 + 38), *(_QWORD *)(v9 + 46));
  *(_QWORD *)(v8 + 8) = v13;
  if (!v13)
  {
    v27 = "aaIntervalInputStreamOpen";
    v28 = 81;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_get", v28, 135, 0, v27, a7, a8, v30);
    return 0;
  }
  v14 = *(unsigned int *)(v12 + 48);
  if (v14 <= 3)
    v15 = v14 << 62;
  else
    v15 = 0xC000000000000000;
  v16 = AADecompressionInputStreamOpen(v13, v15, *(_DWORD *)(v12 + 44));
  *(_QWORD *)(v8 + 16) = v16;
  if (!v16)
  {
    v27 = "AADecompressionInputStreamOpen";
    v28 = 83;
    goto LABEL_24;
  }
LABEL_8:
  while (1)
  {
    v17 = *(_QWORD *)(v8 + 40);
    v18 = *(_QWORD *)(v8 + 48);
    v19 = v17 + v18;
    if (v11 < v17 + v18)
      return a1 + 8 * (v11 - v18);
    *(_QWORD *)(v8 + 48) = v19;
    v20 = *(_QWORD *)(v8 + 56) - v19;
    if (v20 < v17)
      v17 = v20;
    v21 = *(_QWORD *)(v8 + 16);
    if (*(_QWORD *)(v21 + 16))
    {
      v22 = 0;
      v23 = 8 * v17;
      if (8 * v17)
      {
        v24 = a1;
        v25 = 8 * v17;
        while (1)
        {
          v26 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v21 + 16))(*(_QWORD *)v21, v24, v25);
          if (v26 < 0)
            break;
          if (v26)
          {
            v24 += v26;
            v22 += v26;
            v25 -= v26;
            if (v25)
              continue;
          }
          goto LABEL_19;
        }
        v22 = v26;
      }
LABEL_19:
      if (v23 == v22)
        continue;
    }
    v27 = "aaByteStreamReadExpected";
    v28 = 91;
    goto LABEL_24;
  }
}

off_t AARandomAccessByteStreamProcess(AAByteStream istream, AAByteStream ostream, off_t max_offset, size_t block_size, AAFlagSet flags, int n_threads)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void ***v13;
  void ***v14;
  AAByteStream **v15;
  uint64_t v16;
  AAByteStream *v17;
  AAByteStream *v18;
  AAByteStream_impl *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  off_t v28;
  off_t v29;
  unsigned int v30;
  unsigned int v31;
  off_t v32;
  uint64_t Worker;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  AAByteStream **v41;
  AAByteStream **v42;
  AAByteStream *v43;
  AAByteStream *v44;
  AAByteStream_impl *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  off_t v55;
  off_t v56;
  unsigned int v57;
  unsigned int v58;
  off_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  __int16 v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  char v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  __int16 v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  __int16 v82;
  void ***v83;
  void **v84;
  off_t v85;
  uint64_t *v86;
  uint64_t v87;
  char v89;
  uint64_t v90;
  AAByteStream __s;
  off_t v92;
  uint64_t v93;
  unsigned int v94;

  if ((uint64_t)block_size <= 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"AARandomAccessByteStreamProcess", 315, 89, 0, "Invalid arguments", v6, v7, v89);
    return -1;
  }
  LODWORD(v8) = n_threads;
  if ((flags & 0x400) == 0)
  {
    if (n_threads <= 0)
      LODWORD(v8) = getDefaultNThreads();
    __s = 0;
    v92 = 0;
    v93 = 0;
    memset_s(&__s, 0x18uLL, 0, 0x18uLL);
    __s = ostream;
    v8 = v8;
    v13 = (void ***)calloc(v8, 8uLL);
    if (v13)
    {
      v14 = v13;
      if ((_DWORD)v8)
      {
        v15 = (AAByteStream **)v13;
        v16 = v8;
        while (1)
        {
          v17 = (AAByteStream *)malloc(0x38uLL);
          if (!v17)
          {
            v75 = *__error();
            v78 = 125;
            goto LABEL_58;
          }
          v18 = v17;
          memset_s(v17, 0x38uLL, 0, 0x38uLL);
          *v15 = v18;
          v18[1] = (AAByteStream)block_size;
          v18[2] = 0;
          *v18 = istream;
          if (block_size >= 0x2000000001)
            break;
          v19 = (AAByteStream_impl *)malloc(block_size);
          v18[3] = v19;
          if (!v19)
            goto LABEL_57;
          ++v15;
          if (!--v16)
            goto LABEL_12;
        }
        *__error() = 12;
        v18[3] = 0;
LABEL_57:
        v75 = *__error();
        v78 = 131;
LABEL_58:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", v78, 89, v75, "malloc", v76, v77, v89);
        v27 = 0;
      }
      else
      {
LABEL_12:
        v27 = ThreadPipelineCreate(v8, (uint64_t)v14, (uint64_t)sequentialReaderProc, (uint64_t)&__s, (uint64_t)sequentialWriterProc, 0);
        if (v27)
        {
          v28 = 0;
          if ((unint64_t)max_offset >= 0x7FFFFFFFFFFFFFFFLL)
            v29 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v29 = max_offset;
          while (1)
          {
            v30 = atomic_load((unsigned int *)&v93 + 1);
            if (v30
              || (v31 = atomic_load((unsigned int *)&v93)) != 0
              || ((uint64_t)(v28 + block_size) >= v29 ? (v32 = v29) : (v32 = v28 + block_size), v32 < v28))
            {
              v73 = 0;
              goto LABEL_65;
            }
            Worker = ThreadPipelineGetWorker((uint64_t)v27, v20, v21, v22, v23, v24, v25, v26);
            if (!Worker)
              break;
            *(_QWORD *)(Worker + 32) = v32 - v28;
            *(_QWORD *)(Worker + 40) = v28;
            v28 = v32;
            if ((ThreadPipelineRunWorker((uint64_t)v27, Worker, v34, v35, v36, v37, v25, v26) & 0x80000000) != 0)
            {
              v38 = "running task";
              v39 = 158;
              goto LABEL_63;
            }
          }
          v38 = "allocating reader";
          v39 = 153;
        }
        else
        {
          v38 = "ThreadPipelineCreate";
          v39 = 136;
        }
LABEL_63:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", v39, 89, 0, v38, v25, v26, v89);
      }
      v73 = 1;
LABEL_65:
      ThreadPipelineDestroy((uint64_t)v27);
      if ((_DWORD)v8)
      {
        v83 = v14;
        do
        {
          v84 = *v83++;
          free(v84[3]);
          free(v84);
          --v8;
        }
        while (v8);
      }
      free(v14);
      if ((v73 & 1) == 0)
        return v92;
    }
    else
    {
      v67 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", 121, 89, *v67, "malloc", v68, v69, v89);
      ThreadPipelineDestroy(0);
    }
    return -1;
  }
  if (n_threads <= 0)
    LODWORD(v8) = getDefaultNThreads();
  LODWORD(__s) = 0;
  v94 = 0;
  v40 = v8;
  v41 = (AAByteStream **)calloc(v8, 8uLL);
  if (!v41)
  {
    v70 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", 246, 89, *v70, "malloc", v71, v72, v89);
    ThreadPoolDestroy(0);
    return -1;
  }
  v90 = (uint64_t)v41;
  if ((_DWORD)v8)
  {
    v42 = v41;
    v8 = v8;
    while (1)
    {
      v43 = (AAByteStream *)malloc(0x48uLL);
      if (!v43)
      {
        v79 = *__error();
        v82 = 250;
        goto LABEL_61;
      }
      v44 = v43;
      memset_s(v43, 0x48uLL, 0, 0x48uLL);
      *v42 = v44;
      *v44 = istream;
      v44[1] = ostream;
      v44[4] = (AAByteStream)&__s;
      v44[5] = (AAByteStream)&v94;
      v44[2] = (AAByteStream)block_size;
      if (block_size >= 0x2000000001)
        break;
      v45 = (AAByteStream_impl *)malloc(block_size);
      v44[3] = v45;
      if (!v45)
        goto LABEL_60;
      ++v42;
      if (!--v8)
        goto LABEL_35;
    }
    *__error() = 12;
    v44[3] = 0;
LABEL_60:
    v79 = *__error();
    v82 = 258;
LABEL_61:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", v82, 89, v79, "malloc", v80, v81, max_offset);
    v54 = 0;
    v74 = 1;
    v46 = (uint64_t *)v90;
  }
  else
  {
LABEL_35:
    v46 = (uint64_t *)v90;
    v54 = ThreadPoolCreate(v40, v90, (uint64_t)randomAccessWorkerProc);
    if (v54)
    {
      v55 = 0;
      if ((unint64_t)max_offset >= 0x7FFFFFFFFFFFFFFFLL)
        v56 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v56 = max_offset;
      while (1)
      {
        v57 = atomic_load((unsigned int *)&__s);
        if (v57
          || (v58 = atomic_load(&v94)) != 0
          || ((uint64_t)(v55 + block_size) >= v56 ? (v59 = v56) : (v59 = v55 + block_size), v59 < v55))
        {
          v74 = 0;
          goto LABEL_72;
        }
        v60 = ThreadPoolGetWorker((uint64_t)v54, v47, v48, v49, v50, v51, v52, v53);
        if (!v60)
          break;
        *(_QWORD *)(v60 + 56) = v59 - v55;
        *(_QWORD *)(v60 + 64) = v55;
        v55 = v59;
        if ((ThreadPoolRunWorker((uint64_t)v54, v60, v61, v62, v63, v64, v52, v53) & 0x80000000) != 0)
        {
          v65 = "running task";
          v66 = 285;
          goto LABEL_71;
        }
      }
      v65 = "allocating reader";
      v66 = 280;
    }
    else
    {
      v65 = "ThreadPipelineCreate";
      v66 = 263;
    }
LABEL_71:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", v66, 89, 0, v65, v52, v53, max_offset);
    v74 = 1;
  }
LABEL_72:
  ThreadPoolDestroy((uint64_t)v54);
  v85 = 0;
  if ((_DWORD)v40)
  {
    v86 = v46;
    do
    {
      v87 = *v86++;
      v85 += *(_QWORD *)(v87 + 48);
      free(*(void **)(v87 + 24));
      free((void *)v87);
      --v40;
    }
    while (v40);
  }
  free(v46);
  if ((v74 & 1) != 0)
    return -1;
  return v85;
}

uint64_t sequentialReaderProc(uint64_t a1)
{
  size_t v2;
  ssize_t v3;
  uint64_t v4;
  uint64_t v5;
  ssize_t v6;
  uint64_t result;
  char v8;

  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2 <= *(_QWORD *)(a1 + 8))
  {
    if (!v2)
      return 0;
    v3 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v2, *(_QWORD *)(a1 + 40));
    if ((v3 & 0x8000000000000000) == 0)
    {
      v6 = v3;
      result = 0;
      *(_QWORD *)(a1 + 16) = v6;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"sequentialReaderProc", 49, 89, 0, "PRead", v4, v5, v8);
  }
  *(_DWORD *)(a1 + 48) = 1;
  return 0xFFFFFFFFLL;
}

uint64_t sequentialWriterProc(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  uint64_t result;
  size_t v7;
  char *v8;
  ssize_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v2 = (unsigned int *)(a1 + 20);
  if (atomic_load((unsigned int *)(a1 + 20)))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a2 + 48))
    goto LABEL_4;
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    v8 = *(char **)(a2 + 24);
    while (1)
    {
      v9 = AAByteStreamWrite(*(AAByteStream *)a1, v8, v7);
      if (v9 <= 0)
        break;
      v8 += v9;
      *(_QWORD *)(a1 + 8) += v9;
      v7 -= v9;
      if (!v7)
        return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"sequentialWriterProc", 87, 89, 0, "Write failed", v10, v11, v12);
LABEL_4:
    result = 0xFFFFFFFFLL;
    goto LABEL_5;
  }
  result = 0;
  v2 = (unsigned int *)(a1 + 16);
  do
  {
LABEL_5:
    if (__ldaxr(v2))
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v2));
  return result;
}

uint64_t randomAccessWorkerProc(uint64_t a1)
{
  uint64_t result;
  size_t v4;
  ssize_t v5;
  uint64_t v6;
  uint64_t v7;
  ssize_t v8;
  const char *v9;
  __int16 v10;
  unsigned int *v11;
  unsigned int *v13;
  char v15;

  if (atomic_load(*(unsigned int **)(a1 + 32)))
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 56);
  if (v4 > *(_QWORD *)(a1 + 16))
  {
LABEL_17:
    v13 = *(unsigned int **)(a1 + 32);
    while (!__ldaxr(v13))
    {
      if (!__stlxr(1u, v13))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  if (!v4)
    return 0;
  v5 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v4, *(_QWORD *)(a1 + 64));
  if (v5 < 0)
  {
    v9 = "PRead";
    v10 = 207;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"randomAccessWorkerProc", v10, 89, 0, v9, v6, v7, v15);
    goto LABEL_17;
  }
  v8 = v5;
  if (v5)
  {
    if (AAByteStreamPWrite(*(AAByteStream *)(a1 + 8), *(const void **)(a1 + 24), v5, *(_QWORD *)(a1 + 64)) == v5)
    {
      result = 0;
      *(_QWORD *)(a1 + 48) += v8;
      return result;
    }
    v9 = "Write";
    v10 = 219;
    goto LABEL_16;
  }
  v11 = *(unsigned int **)(a1 + 40);
  result = 0;
  while (!__ldaxr(v11))
  {
    if (!__stlxr(1u, v11))
      return result;
  }
  result = 0;
  __clrex();
  return result;
}

_QWORD *AEADecryptionDirectRandomAccessInputStreamOpen(AAByteStream_impl *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t Existing;
  uint64_t v15;
  uint64_t v16;
  compression_algorithm v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  const char *v22;
  __int16 v23;
  char v25;

  if (a4 <= 0)
    getDefaultNThreads();
  if (!*(_DWORD *)(a2 + 2736) || !*(_QWORD *)(a2 + 2728))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen", 148, 122, 0, "Invalid context", a7, a8, v25);
    v13 = 0;
    v11 = 0;
LABEL_17:
    BlockDecryptionStreamClose(v13);
    free(v11);
    return 0;
  }
  v11 = calloc(1uLL, 0x68uLL);
  v12 = (uint64_t *)malloc(0x30uLL);
  v13 = v12;
  if (!v12 || (memset_s(v12, 0x30uLL, 0, 0x30uLL), !v11))
  {
    v21 = *__error();
    v22 = "malloc";
    v23 = 153;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen", v23, 122, v21, v22, v15, v16, v25);
    goto LABEL_17;
  }
  *v13 = (uint64_t)a1;
  v13[1] = a3;
  if ((a3 & 0x400000000000000) != 0)
    *(_DWORD *)(a2 + 2740) = 1;
  Existing = aeaContainerCreateExisting(a2, a1, 1, 0);
  v13[2] = Existing;
  if (!Existing)
  {
    v22 = "unlock container";
    v23 = 166;
    v21 = 0;
    goto LABEL_16;
  }
  if (*(_DWORD *)(Existing + 24))
  {
    v17 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(Existing + 24));
    v13[3] = compression_decode_scratch_buffer_size(v17);
    Existing = v13[2];
  }
  *v11 = v13;
  v11[1] = BlockDecryptionStreamClose;
  v11[7] = BlockDecryptionStreamCancel;
  v11[4] = BlockDecryptionStreamPRead;
  v11[2] = BlockDecryptionStreamRead;
  *(_OWORD *)a2 = *(_OWORD *)Existing;
  v18 = *(_OWORD *)(Existing + 16);
  v19 = *(_OWORD *)(Existing + 32);
  v20 = *(_OWORD *)(Existing + 48);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(Existing + 64);
  *(_OWORD *)(a2 + 32) = v19;
  *(_OWORD *)(a2 + 48) = v20;
  *(_OWORD *)(a2 + 16) = v18;
  return v11;
}

uint64_t BlockDecryptionStreamClose(uint64_t *a1)
{
  if (a1)
  {
    aeaContainerDestroy(a1[2]);
    free(a1);
  }
  return 0;
}

void BlockDecryptionStreamCancel(AAByteStream *a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 4);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }
  __clrex();
}

uint64_t BlockDecryptionStreamPRead(uint64_t a1, uint8_t *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const char *v9;
  __int16 v10;
  void *v11;
  uint8_t *v12;
  uint8_t *v13;
  uint64_t v14;
  uint64_t v16;
  unint64_t v17;
  size_t v19;
  const uint8_t *v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  BOOL v28;
  char v29;
  size_t v30;
  uint64_t v31;
  int v33;
  const char *v34;
  __int16 v35;
  uint8_t *v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  unint64_t v41;
  int v42;
  size_t v43;
  size_t __size;
  char v45;
  uint8_t *v46;
  uint8_t *v47;

  if ((a4 & 0x8000000000000000) != 0)
  {
    v9 = "negative offset";
    v10 = 55;
    goto LABEL_6;
  }
  v8 = a4;
  if (__CFADD__(a4, a3))
  {
    v9 = "invalid request";
    v10 = 59;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", v10, 122, 0, v9, a7, a8, v40);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = -1;
    goto LABEL_47;
  }
  v16 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(v16 + 32);
  if (v17 <= a4)
    goto LABEL_46;
  if (a4 + a3 < v17)
    v17 = a4 + a3;
  if (v17 <= a4)
  {
LABEL_46:
    v11 = 0;
    v14 = 0;
    v12 = 0;
    v13 = 0;
    goto LABEL_47;
  }
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v42 = *(_DWORD *)(v16 + 24);
  v19 = *(unsigned int *)(v16 + 16);
  v41 = v17;
  __size = v19;
  while (1)
  {
    v20 = v12;
    v21 = v8 / v19;
    v22 = *(_QWORD *)(a1 + 16);
    if (v8 / v19 >= *(unsigned int *)(v22 + 400))
    {
      v36 = v13;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", 69, 122, 0, "invalid state", a7, a8, v40);
      v13 = v36;
LABEL_50:
      v14 = -1;
      v12 = (uint8_t *)v20;
      goto LABEL_47;
    }
    v23 = v21 * v19;
    v24 = *(unsigned int *)(*(_QWORD *)(v22 + 392) + 544 * v21 + 4);
    v25 = v21 * v19 + v24;
    if (v8 <= v23)
      v26 = v23;
    else
      v26 = v8;
    if (v25 >= v17)
      v25 = v17;
    v43 = v26;
    v27 = v25 - v26;
    v28 = v23 >= v8 && v27 == v24;
    v29 = v28;
    v45 = v29;
    if (v28)
    {
      v47 = a2;
      goto LABEL_29;
    }
    v47 = v13;
    if (!v13)
    {
      v13 = (uint8_t *)malloc(__size);
      v47 = v13;
      if (!v13)
      {
        v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", 93, 122, *v37, "malloc", v38, v39, v40);
        v13 = 0;
        goto LABEL_50;
      }
    }
LABEL_29:
    v46 = v13;
    if (v42)
    {
      v12 = (uint8_t *)v20;
      if (!v20)
        v12 = (uint8_t *)malloc(__size);
      if (!v11)
      {
        v30 = *(_QWORD *)(a1 + 24);
        if (v30)
        {
          if (v30 < 0x2000000001)
          {
            v11 = malloc(v30);
          }
          else
          {
            v11 = 0;
            *__error() = 12;
          }
        }
      }
      if (!v12 || !v11 && *(_QWORD *)(a1 + 24))
      {
        v33 = *__error();
        v34 = "malloc";
        v35 = 100;
        goto LABEL_52;
      }
      v20 = v12;
      v22 = *(_QWORD *)(a1 + 16);
    }
    v31 = v22;
    v12 = (uint8_t *)v20;
    if (aeaContainerLoadSegment(v31, *(_QWORD **)a1, v21, v47, v20, v11, a7, a8) < 0)
      break;
    if ((v45 & 1) == 0)
      memcpy(a2, &v47[v43 - v23], v27);
    v8 += v27;
    a2 += v27;
    v14 += v27;
    v17 = v41;
    v13 = v46;
    v19 = __size;
    if (v8 >= v41)
      goto LABEL_47;
  }
  v34 = "loading segment";
  v35 = 105;
  v33 = 0;
LABEL_52:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", v35, 122, v33, v34, a7, a8, v40);
  v14 = -1;
  v13 = v46;
LABEL_47:
  free(v13);
  free(v12);
  free(v11);
  return v14;
}

uint64_t BlockDecryptionStreamRead(uint64_t a1, uint8_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  unint64_t v9;

  v8 = (unint64_t *)(a1 + 40);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + a3, v8));
  return BlockDecryptionStreamPRead(a1, a2, a3, v9, a5, a6, a7, a8);
}

uint64_t ECC65537GetParity(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  int8x16_t v5;
  int8x8_t v6;
  int8x16_t v7;
  int8x16_t v8;
  uint32x4_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int32x4_t v13;
  uint64_t v14;
  __int32 v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int16x8_t v25;
  int8x16_t v26;
  int8x8_t v27;
  int8x8_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  _OWORD v44[4];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  if (a1 > 0x1FFE0)
    return 0xFFFFFFFFLL;
  v4 = (a1 & 1) + a1;
  if (v4)
  {
    v5 = 0uLL;
    v6 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_20A40B950))));
    v7 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_20A40B960), (int16x8_t)vceqzq_s32((int32x4_t)qword_20A40B970)));
    v8.i64[0] = 0xFFFF0000FFFFLL;
    v8.i64[1] = 0xFFFF0000FFFFLL;
    v9.i64[0] = 0x1000000010000;
    v9.i64[1] = 0x1000000010000;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    v11 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
    do
    {
      v14 = v4 - 2;
      if (v4 <= a1)
        v15 = *(unsigned __int16 *)(a2 + v14);
      else
        v15 = *(unsigned __int8 *)(a2 + v14);
      v16 = (int32x4_t)vextq_s8(v12, (int8x16_t)v13, 0xCuLL);
      v17 = (int32x4_t)vextq_s8(v11, v12, 0xCuLL);
      v18 = (int32x4_t)vextq_s8(qword_20A40B970, v5, 0xCuLL);
      v19 = vdupq_laneq_s32(v13, 3);
      v18.i32[0] = v15;
      v20 = (int32x4_t)vextq_s8(v5, v11, 0xCuLL);
      v21 = vmulq_laneq_s32((int32x4_t)xmmword_20A40B960, v13, 3);
      v22 = vmulq_laneq_s32((int32x4_t)qword_20A40B970, v13, 3);
      v23 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v13, 3);
      v24 = vmulq_laneq_s32(unk_20A40B950, v13, 3);
      v25 = (int16x8_t)vceqzq_s32(v19);
      v26 = (int8x16_t)vuzp1q_s16(v25, v25);
      v27 = vmovn_s16((int16x8_t)vmvnq_s8(v26));
      v28 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v23), (int16x8_t)vceqzq_s32(v24)));
      v29 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v21), (int16x8_t)vceqzq_s32(v22));
      v30 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v22, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x10uLL));
      v31 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v21, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x10uLL));
      v32 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v24, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x10uLL));
      v33 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v23, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x10uLL));
      *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v7, v26), v29));
      v34 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v30, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v30)), (int8x16_t)vqsubq_u32((uint32x4_t)v30, v9)));
      v35 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v31, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v31)), (int8x16_t)vqsubq_u32((uint32x4_t)v31, v9)));
      *(int8x8_t *)v26.i8 = vand_s8(vand_s8(v6, v28), v27);
      v36 = (int8x16_t)vsubq_s32(v18, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v33, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v33)), (int8x16_t)vqsubq_u32((uint32x4_t)v33, v9))));
      v37 = (int8x16_t)vsubq_s32(v20, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v32, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v32)), (int8x16_t)vqsubq_u32((uint32x4_t)v32, v9))));
      v38 = (int8x16_t)vsubq_s32(v17, v35);
      v39 = (int8x16_t)vsubq_s32(v16, v34);
      v13 = (int32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v39)), (int8x16_t)vqsubq_u32((uint32x4_t)v39, v9));
      v12 = vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v9));
      v11 = vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v9));
      v5 = vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v9));
      v4 = v14;
    }
    while ((_DWORD)v14);
  }
  else
  {
    v5 = 0uLL;
    v11 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
  }
  v40 = 0;
  v41 = 0;
  v44[0] = v5;
  v44[1] = v11;
  v44[2] = v12;
  v44[3] = v13;
  do
  {
    v42 = *((_DWORD *)v44 + v40);
    if (v42)
      v43 = 65537 - v42;
    else
      v43 = 0;
    v41 |= (1 << v40) & (v43 << 15 >> 31);
    *(_WORD *)(a3 + 2 * v40++) = v43;
  }
  while (v40 != 16);
  result = 0;
  *(_WORD *)(a3 + 32) = v41;
  return result;
}

uint64_t ECC65537CheckAndFix(unsigned int a1, uint64_t a2, uint16x8_t *a3, _DWORD *a4)
{
  int8x16_t v7;
  unsigned int v8;
  int8x16_t v9;
  int8x8_t v10;
  int8x16_t v11;
  int8x16_t v12;
  uint32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int32x4_t v17;
  unsigned int v18;
  uint64_t v19;
  __int32 v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int16x8_t v30;
  int8x16_t v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  uint64_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int32x4_t v48;
  uint32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int8x16_t v52;
  uint16x8_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t *v56;
  int32x4_t v57;
  int32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int *v62;
  int *v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  __int128 v71;
  __int128 v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  unsigned int v79;
  int v80;
  int *v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  int v94;
  _DWORD *v95;
  int8x8_t v96;
  uint64_t v97;
  int v98;
  int v99;
  uint64_t v100;
  BOOL v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  unsigned int v106;
  uint64_t v107;
  int v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  char v113;
  int *v114;
  _DWORD *v115;
  unsigned int v116;
  _OWORD v117[4];
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  v7 = 0uLL;
  v8 = (a1 & 1) + a1;
  if (v8)
  {
    v9 = 0uLL;
    v10 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_20A40B950))));
    v11 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_20A40B960), (int16x8_t)vceqzq_s32((int32x4_t)qword_20A40B970)));
    v12.i64[0] = 0xFFFF0000FFFFLL;
    v12.i64[1] = 0xFFFF0000FFFFLL;
    v13.i64[0] = 0x1000000010000;
    v13.i64[1] = 0x1000000010000;
    v14.i64[0] = 0x100000001;
    v14.i64[1] = 0x100000001;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = (a1 & 1) + a1;
    do
    {
      v19 = v18 - 2;
      if (v18 <= a1)
        v20 = *(unsigned __int16 *)(a2 + v19);
      else
        v20 = *(unsigned __int8 *)(a2 + v19);
      v21 = (int32x4_t)vextq_s8(v16, (int8x16_t)v17, 0xCuLL);
      v22 = (int32x4_t)vextq_s8(v15, v16, 0xCuLL);
      v23 = (int32x4_t)vextq_s8((int8x16_t)0, v9, 0xCuLL);
      v24 = vdupq_laneq_s32(v17, 3);
      v23.i32[0] = v20;
      v25 = (int32x4_t)vextq_s8(v9, v15, 0xCuLL);
      v26 = vmulq_laneq_s32((int32x4_t)xmmword_20A40B960, v17, 3);
      v27 = vmulq_laneq_s32((int32x4_t)qword_20A40B970, v17, 3);
      v28 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v17, 3);
      v29 = vmulq_laneq_s32(unk_20A40B950, v17, 3);
      v30 = (int16x8_t)vceqzq_s32(v24);
      v31 = (int8x16_t)vuzp1q_s16(v30, v30);
      v32 = vmovn_s16((int16x8_t)vmvnq_s8(v31));
      v33 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v28), (int16x8_t)vceqzq_s32(v29)));
      v34 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v26), (int16x8_t)vceqzq_s32(v27));
      v35 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v27, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x10uLL));
      v36 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v26, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x10uLL));
      v37 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v29, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL));
      v38 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v28, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL));
      *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v11, v31), v34));
      v39 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v35, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v35)), (int8x16_t)vqsubq_u32((uint32x4_t)v35, v13)));
      v40 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v13)));
      *(int8x8_t *)v31.i8 = vand_s8(vand_s8(v10, v33), v32);
      v41 = (int8x16_t)vsubq_s32(v23, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v13))));
      v42 = (int8x16_t)vsubq_s32(v25, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v13))));
      v43 = (int8x16_t)vsubq_s32(v22, v40);
      v44 = (int8x16_t)vsubq_s32(v21, v39);
      v17 = (int32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v44)), (int8x16_t)vqsubq_u32((uint32x4_t)v44, v13));
      v16 = vorrq_s8(vandq_s8(v43, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v43)), (int8x16_t)vqsubq_u32((uint32x4_t)v43, v13));
      v15 = vorrq_s8(vandq_s8(v42, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v42)), (int8x16_t)vqsubq_u32((uint32x4_t)v42, v13));
      v9 = vorrq_s8(vandq_s8(v41, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v41)), (int8x16_t)vqsubq_u32((uint32x4_t)v41, v13));
      v18 = v19;
    }
    while ((_DWORD)v19);
  }
  else
  {
    v9 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
  }
  v45 = 0;
  v117[0] = v9;
  v117[1] = v15;
  v117[2] = v16;
  v117[3] = v17;
  v46 = (int32x4_t)xmmword_20A40B8F0;
  v47 = (int8x16_t)vdupq_n_s32(a3[2].u16[0]);
  v48 = (int32x4_t)xmmword_20A40B900;
  v49.i64[0] = 0x100000001;
  v49.i64[1] = 0x100000001;
  v50.i64[0] = 0x1000000010000;
  v50.i64[1] = 0x1000000010000;
  v51.i64[0] = 0x800000008;
  v51.i64[1] = 0x800000008;
  v52 = 0uLL;
  do
  {
    v53 = *a3++;
    v54 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8);
    v55 = (int8x16_t)vmovl_high_u16(v53);
    v56 = (int8x16_t *)&v117[v45];
    v57 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v46), v47)), v55, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45 + 1]);
    v58 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v48), v47)), v54, (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45]);
    v59 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v57, v50), (uint32x4_t)v57);
    v60 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v58, v50), (uint32x4_t)v58);
    *v56 = v60;
    v56[1] = v59;
    v52 = vorrq_s8(v59, v52);
    v7 = vorrq_s8(v60, v7);
    v48 = vaddq_s32(v48, v51);
    v46 = vaddq_s32(v46, v51);
    v45 += 2;
  }
  while (v45 != 4);
  v61 = vorrq_s8(v7, v52);
  if (vorr_s8(*(int8x8_t *)v61.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)))
  {
    v62 = (int *)calloc(1uLL, 0x4C0uLL);
    if (v62)
    {
      v63 = v62;
      v64 = 0;
      v65 = v8 >> 1;
      v66 = 1;
      do
      {
        v63[v64] = ecc65537PolyEval(16, (uint64_t)v117, v66);
        v67 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        if (v67 + 65537 >= v67)
          v66 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        else
          v66 = v67 + 65537;
        ++v64;
      }
      while (v64 != 16);
      v115 = a4;
      v68 = 0;
      v69 = 48;
      do
      {
        v70 = &v63[v69];
        v71 = *(_OWORD *)&v63[v68];
        v72 = *(_OWORD *)&v63[v68 + 4];
        v70[8] = v63[v68 + 8];
        *(_OWORD *)v70 = v71;
        *((_OWORD *)v70 + 1) = v72;
        v69 += 16;
        ++v68;
      }
      while (v68 != 8);
      v73 = ecc65537Triangulate(8, 9, (uint64_t)(v63 + 48));
      if (v73 >= 1)
      {
        v74 = v73;
        if ((ecc65537Solve(v73, v63 + 48, (uint64_t)(v63 + 16)) & 0x80000000) == 0)
        {
          v114 = v63 + 48;
          v75 = v74;
          v76 = 0;
          v77 = 0;
          v116 = v75;
          v78 = v75 + 1;
          v79 = v65 + 16;
          v80 = 1;
          do
          {
            if (!ecc65537PolyEval(v78, (uint64_t)(v63 + 16), v80) && v77 <= 7)
            {
              v81 = &v63[v77++];
              v81[32] = v76;
            }
            v82 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            if (v82 + 65537 >= v82)
              v80 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            else
              v80 = v82 + 65537;
            ++v76;
          }
          while (v79 != v76);
          if (v77 == v116)
          {
            v83 = 0;
            v84 = v116;
            do
            {
              v85 = 0;
              v86 = (16 * v83);
              do
              {
                v87 = v63[v85 + 32] * v83;
                if (v87)
                {
                  v88 = 3;
                  if (v87 < 0)
                  {
                    v88 = ecc65537Inv(3);
                    v87 = -v87;
                  }
                  v89 = (unsigned __int16)v87;
                  v90 = 1;
                  while (1)
                  {
                    if ((v89 & 1) != 0)
                    {
                      if (v88 && v90 && !(v90 * v88))
                      {
                        v90 = 1;
                      }
                      else
                      {
                        v90 = (unsigned __int16)(v90 * v88) - ((v90 * v88) >> 16);
                        if (v90 + 65537 < v90)
                          v90 += 65537;
                      }
                    }
                    if (v89 < 2)
                      break;
                    v89 >>= 1;
                    v91 = v88 * v88;
                    if (v88)
                    {
                      v88 = 1;
                      if (!v91)
                        continue;
                    }
                    v92 = (unsigned __int16)v91 - HIWORD(v91);
                    if (v92 + 65537 >= v92)
                      v88 = v92;
                    else
                      v88 = v92 + 65537;
                  }
                }
                else
                {
                  v90 = 1;
                }
                v63[v85 + 48 + v86] = v90;
                ++v85;
              }
              while (v85 != v116);
              v93 = v63[v83];
              if (v93)
                v94 = 65537 - v93;
              else
                v94 = 0;
              v63[(int)(v86 + v116) + 48] = v94;
              ++v83;
            }
            while (v83 != v116);
            if (ecc65537Triangulate(v116, v78, (uint64_t)v114) == v116)
            {
              v95 = v63 + 40;
              if ((ecc65537Solve(v116, v114, (uint64_t)(v63 + 40)) & 0x80000000) == 0)
              {
                v97 = 0;
                v98 = 0;
                while (1)
                {
                  v99 = *(v95 - 8);
                  if (a1 > 2 * v99)
                  {
                    v100 = (2 * v99);
                    v101 = (int)v100 + 2 <= a1 || a1 - (_DWORD)v100 == 2;
                    v102 = v101;
                    if (v101)
                      v103 = *(unsigned __int16 *)(a2 + v100);
                    else
                      v103 = *(unsigned __int8 *)(a2 + v100);
                    v104 = v103 - *v95;
                    if (v104 + 65537 < v104)
                      v104 += 65537;
                    if (HIWORD(v104))
                      goto LABEL_85;
                    v105 = v104 ^ v103;
                    v96.i32[0] = v105;
                    v96 = vcnt_s8(v96);
                    v96.i16[0] = vaddlv_u8((uint8x8_t)v96);
                    v98 += v96.i32[0];
                    if ((_BYTE)v105)
                      v106 = v97 + 1;
                    else
                      v106 = v97;
                    if ((v105 & 0xFF00) != 0)
                      v97 = v106 + 1;
                    else
                      v97 = v106;
                    if (v102)
                      *(_WORD *)(a2 + v100) = v104;
                    else
                      *(_BYTE *)(a2 + v100) = v104;
                  }
                  ++v95;
                  v107 = v97;
                  if (!--v84)
                    goto LABEL_86;
                }
              }
            }
          }
        }
      }
      v98 = 0;
      LODWORD(v97) = 0;
LABEL_85:
      v107 = 0xFFFFFFFFLL;
LABEL_86:
      free(v63);
      if (v115 && (v107 & 0x80000000) == 0)
      {
        v108 = v115[1] + v97;
        *v115 += v98;
        v115[1] = v108;
      }
    }
    else
    {
      v109 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection_ECC65537.c", (uint64_t)"ECC65537CheckAndFix", 423, 63, *v109, "malloc", v110, v111, v113);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    return 0;
  }
  return v107;
}

uint64_t ecc65537PolyEval(int a1, uint64_t a2, int a3)
{
  uint64_t result;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;

  if (a1 < 1)
    return 0;
  LODWORD(result) = 0;
  v5 = a1 + 1;
  do
  {
    if (a3 && (_DWORD)result && !((_DWORD)result * a3))
    {
      v6 = 1;
    }
    else
    {
      v6 = (unsigned __int16)(result * a3) - ((result * a3) >> 16);
      if (v6 + 65537 < v6)
        v6 += 65537;
    }
    v7 = v6 + *(_DWORD *)(a2 + 4 * (v5 - 2));
    if (v7 - 65537 >= v7)
      result = v7;
    else
      result = v7 - 65537;
    --v5;
  }
  while (v5 > 1);
  return result;
}

uint64_t ecc65537Triangulate(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  _WORD *v24;
  int v25;
  int *v26;
  BOOL v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  unsigned int v35;

  if ((int)a1 < 1)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  LODWORD(v6) = 0;
  v7 = 16;
  v8 = 1;
  while (1)
  {
    if (v5 >= a2)
    {
      LODWORD(v11) = v6;
    }
    else
    {
      v9 = v5 + v3;
LABEL_5:
      v10 = v9;
      v11 = v4;
      while (!*(_DWORD *)(a3 + 4 * (int)v10))
      {
        ++v11;
        v10 += 16;
        if (a1 == v11)
        {
          ++v5;
          ++v9;
          if (v5 != a2)
            goto LABEL_5;
          return v4;
        }
      }
    }
    v6 = v4;
    if (v5 == a2)
      return v6;
    if (v4 == v11 || a2 <= 0)
    {
      v12 = 16 * v4;
    }
    else
    {
      v12 = 16 * v4;
      v13 = (int *)(a3 + 64 * (_DWORD)v11);
      v14 = a2;
      v15 = v3;
      do
      {
        v16 = *v13;
        *v13++ = *(_DWORD *)(a3 + 4 * v15);
        *(_DWORD *)(a3 + 4 * v15++) = v16;
        --v14;
      }
      while (v14);
    }
    if (++v4 < (unint64_t)a1)
    {
      v17 = *(_DWORD *)(a3 + 4 * (v12 + v5));
      v18 = v5 + 1;
      v19 = (int *)(a3 + 4 * (v12 + v18));
      v20 = v7;
      v21 = v8;
      do
      {
        v22 = v5 + 16 * v21;
        v23 = *(_DWORD *)(a3 + 4 * v22);
        if (v23)
        {
          *(_DWORD *)(a3 + 4 * v22) = 0;
          if ((int)v18 < a2)
          {
            v24 = (_WORD *)(a3 + 4 * (v18 + v20));
            v25 = a2 - 1 - v5;
            v26 = v19;
            do
            {
              if (v17 && (*(_DWORD *)v24 ? (v27 = *(_DWORD *)v24 * v17 == 0) : (v27 = 0), v27))
              {
                v28 = 1;
              }
              else
              {
                v28 = (unsigned __int16)(*v24 * v17) - ((*(_DWORD *)v24 * v17) >> 16);
                if (v28 + 65537 < v28)
                  v28 += 65537;
              }
              v30 = *v26++;
              v29 = v30;
              v31 = v30 * v23;
              v32 = (unsigned __int16)(v30 * v23) - ((v30 * v23) >> 16);
              if (v32 + 65537 < v32)
                v32 += 65537;
              if (v29)
                v33 = v31 == 0;
              else
                v33 = 0;
              if (v33)
                v34 = 1;
              else
                v34 = v32;
              v35 = v28 - v34;
              if (v35 + 65537 < v35)
                v35 += 65537;
              *(_DWORD *)v24 = v35;
              v24 += 2;
              --v25;
            }
            while (v25);
          }
        }
        ++v21;
        v20 += 16;
      }
      while (v21 != a1);
    }
    ++v8;
    v3 += 16;
    v7 += 16;
    if (v4 == a1)
      return a1;
  }
}

uint64_t ecc65537Solve(int a1, int *a2, uint64_t a3)
{
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  BOOL v21;
  unsigned int v22;
  int v23;
  uint64_t v24;

  if (!a1)
    return 0;
  if (a1 <= 0)
  {
    v24 = 0;
    *(_DWORD *)(a3 + 4 * a1) = 1;
  }
  else
  {
    v5 = a1;
    v6 = a2;
    do
    {
      v7 = *v6;
      v6 += 17;
      if (!v7)
        return 0xFFFFFFFFLL;
      --v5;
    }
    while (v5);
    *(_DWORD *)(a3 + 4 * a1) = 1;
    v8 = a1;
    v9 = 16 * a1 - 16;
    v10 = a1;
    do
    {
      if (v10 <= v8)
      {
        v11 = 0;
        v12 = v8;
        do
        {
          v13 = *(_DWORD *)(a3 + 4 * v12);
          v14 = a2[v9 + v12];
          if (v13)
            v15 = v14 == 0;
          else
            v15 = 1;
          if (!v15 && v14 * v13 == 0)
          {
            v17 = 1;
          }
          else
          {
            v17 = (unsigned __int16)(v14 * v13) - ((v14 * v13) >> 16);
            if (v17 + 65537 < v17)
              v17 += 65537;
          }
          v18 = v17 + v11;
          if (v18 - 65537 >= v18)
            v11 = v18;
          else
            v11 = v18 - 65537;
          v19 = v12-- <= v10;
        }
        while (!v19);
      }
      else
      {
        v11 = 0;
      }
      v20 = ecc65537Inv(a2[17 * v10 - 17]);
      if (v11 && (v20 ? (v21 = v20 * v11 == 0) : (v21 = 0), v21))
      {
        v22 = 1;
      }
      else
      {
        v22 = (unsigned __int16)(v20 * v11) - ((v20 * v11) >> 16);
        if (v22 + 65537 < v22)
          v22 += 65537;
      }
      if (65537 - v22 >= -v22)
        v23 = -v22;
      else
        v23 = 65537 - v22;
      *(_DWORD *)(a3 + 4 * (v10 - 1)) = v23;
      v9 -= 16;
      v19 = v10-- <= 1;
    }
    while (!v19);
    return 0;
  }
  return v24;
}

uint64_t ecc65537Inv(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;

  if ((_DWORD)a1 == 1)
  {
    LODWORD(v1) = 1;
  }
  else
  {
    v2 = 0;
    v3 = 1;
    v4 = 65537;
    do
    {
      if (a1 <= v4)
      {
        v5 = -1;
        do
        {
          v6 = (_DWORD)a1 << (v5 + 2);
          ++v5;
        }
        while (v6 <= v4);
        v4 = (v4 - ((_DWORD)a1 << v5));
        v2 = (v2 - ((_DWORD)v3 << v5));
      }
      v1 = v2;
      v7 = v4;
      v2 = v3;
      v3 = v1;
      v4 = a1;
      a1 = v7;
    }
    while ((_DWORD)v7 != 1);
  }
  v8 = v1
     + 65537
     * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
      + (v1 >> 31));
  if (v8 <= 0x10000)
    v9 = 0x10000;
  else
    v9 = v1
       + 65537
       * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
        + (v1 >> 31));
  return v9 % 0x10001 - v9 + v8;
}

uint64_t ParallelCompressionGetCompressedSize(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  char v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t *v24;

  v3 = a2;
  if (a2 >= 0x400)
  {
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v19 = 0;
    v7 = IMemStreamCreate(a1, a2);
    if (v7)
    {
      DWORD2(v20) = a3;
      LODWORD(v20) = 0;
      DWORD1(v20) = getDefaultNThreads();
      *(_QWORD *)&v21 = 0x200000;
      *((_QWORD *)&v21 + 1) = IMemStreamRead;
      *((_QWORD *)&v22 + 1) = v7;
      *(_QWORD *)&v23 = getCompressedSizeCounterProc;
      v24 = &v19;
      if (!ParallelCompressionEncode((uint64_t)&v20, v8, v9, v10, v11, v12, v13, v14))
      {
        if (v19 < v3)
          v3 = v19;
        goto LABEL_9;
      }
      v15 = "ParallelCompressionEncode";
      v16 = 75;
    }
    else
    {
      v15 = "IMemStreamCreate";
      v16 = 64;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ParallelCompressionGetCompressedSize", v16, 39, 0, v15, v5, v6, v18);
    v3 = -1;
LABEL_9:
    OMemStreamDestroy(v7);
  }
  return v3;
}

uint64_t getCompressedSizeCounterProc(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  *a1 += a3;
  return a3;
}

uint64_t IDecoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char vars0;

  if (ParallelCompressionDecode(a1, a2, a3, a4, a5, a6, a7, a8))
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamThreadProc", 100, 39, 0, "decoder failed", v8, v9, vars0);
  return 0;
}

uint64_t IDecoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v29;

  v10 = malloc(0x48uLL);
  v18 = (uint64_t)v10;
  if (v10)
  {
    v10[2] = 0u;
    v10[3] = 0u;
    *v10 = 0u;
    v10[1] = 0u;
    v19 = SharedBufferCreate(a4, v11, v12, v13, v14, v15, v16, v17);
    *(_QWORD *)(v18 + 64) = v19;
    if (!v19)
    {
      v23 = "fail to init buffer";
      v24 = 112;
      v22 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)v18 = 0;
    *(_DWORD *)(v18 + 4) = a5;
    *(_QWORD *)(v18 + 8) = a1;
    *(_QWORD *)(v18 + 16) = a2;
    *(_QWORD *)(v18 + 24) = a3;
    *(_QWORD *)(v18 + 32) = SharedBufferWrite;
    *(_QWORD *)(v18 + 40) = SharedBufferAbort;
    *(_QWORD *)(v18 + 48) = v19;
    if (createThread((pthread_t *)(v18 + 56), (uint64_t)IDecoderStreamThreadProc, v18, 0))
    {
      v22 = *__error();
      v23 = "failed to start decoder thread";
      v24 = 125;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", v24, 39, v22, v23, v20, v21, v29);
      IDecoderStreamDestroy((_QWORD *)v18);
      return 0;
    }
  }
  else
  {
    v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", 107, 39, *v25, "malloc", v26, v27, v29);
  }
  return v18;
}

void IDecoderStreamDestroy(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _opaque_pthread_t *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  _BYTE v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a1[8])
    {
      while (1)
      {
        v2 = SharedBufferRead(a1[8], (uint64_t)v10, 0x400uLL);
        if (v2 < 0)
          break;
        if (!v2)
          goto LABEL_7;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 155, 39, 0, "flushing shared buffer", v3, v4, v9);
    }
LABEL_7:
    v5 = (_opaque_pthread_t *)a1[7];
    if (v5)
    {
      if (joinThread(v5))
      {
        v6 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 163, 39, *v6, "failed to join decoder thread", v7, v8, v9);
      }
    }
    SharedBufferDestroy(a1[8]);
    free(a1);
  }
}

uint64_t IDecoderStreamRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1)
    return SharedBufferRead(*(_QWORD *)(a1 + 64), a2, a3);
  else
    return -1;
}

size_t IDecoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
    return SharedBufferAbort(*(_QWORD *)(result + 64), a2, a3, a4, a5, a6, a7, a8, a9);
  return result;
}

uint64_t ILowMemoryDecoderStreamCreate(uint64_t (*a1)(uint64_t, uint64_t, unint64_t), uint64_t a2, uint64_t a3, size_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  void **v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t DataPtr;
  unsigned __int8 *v15;
  BOOL v18;
  const char *v19;
  __int16 v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v25;
  int v26;
  int v27;
  unint64_t DataSize;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  char v47;

  v8 = malloc(0xD8uLL);
  v9 = (uint64_t)v8;
  if (v8)
  {
    v8[26] = 0;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    if (a4 <= 0x1000)
      a4 = 4096;
    *(_OWORD *)v8 = 0uLL;
    v10 = MemBufferCreate(a4);
    *(_QWORD *)(v9 + 56) = v10;
    if (!v10)
      goto LABEL_27;
    v11 = MemBufferCreate(a4);
    *(_QWORD *)(v9 + 64) = v11;
    if (!v11)
      goto LABEL_27;
    *(_DWORD *)(v9 + 32) = -1;
    *(_QWORD *)v9 = a1;
    *(_QWORD *)(v9 + 8) = a2;
    *(_QWORD *)(v9 + 16) = a3;
    if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0xCuLL, a1, a3) != 12)
    {
      v19 = "couldn't read enough header bytes from compressed file";
      v20 = 465;
      goto LABEL_26;
    }
    DataPtr = MemBufferGetDataPtr(*(_QWORD *)(v9 + 56));
    if ((*(_DWORD *)(v9 + 32) & 0x80000000) != 0)
    {
      v15 = (unsigned __int8 *)DataPtr;
      if (*(_WORD *)DataPtr == 25200 && *(_BYTE *)(DataPtr + 2) == 122)
      {
        v25 = 0;
        while (1)
        {
          v26 = v15[3];
          if (v26 == PCompressGetDecoderKey(v25))
            break;
          if (++v25 == 7)
          {
            if ((*(_DWORD *)(v9 + 32) & 0x80000000) == 0)
              return v9;
            goto LABEL_12;
          }
        }
        *(_QWORD *)(v9 + 40) = bswap64(*(_QWORD *)(v15 + 4));
        *(_QWORD *)(v9 + 48) = PCompressGetDecoderFilter(v25);
        MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), 0xCuLL, v34, v35, v36, v37, v38, v39);
        if ((MemBufferIncreaseCapacity(*(_QWORD *)(v9 + 56), *(_QWORD *)(v9 + 40)) & 0x8000000000000000) != 0)
        {
          v19 = "MemBufferIncreaseCapacity in";
          v20 = 487;
        }
        else
        {
          if ((MemBufferIncreaseCapacity(*(_QWORD *)(v9 + 64), *(_QWORD *)(v9 + 40)) & 0x8000000000000000) == 0)
          {
            *(_DWORD *)(v9 + 32) = 0;
            return v9;
          }
          v19 = "MemBufferIncreaseCapacity out";
          v20 = 488;
        }
        goto LABEL_26;
      }
LABEL_12:
      if (*(_DWORD *)v15 == 1484404733 && *((_WORD *)v15 + 2) == 90)
      {
        if (!lzma_stream_decoder())
        {
          *(_DWORD *)(v9 + 32) = 1;
          return v9;
        }
        v19 = "lzma_stream_decoder";
        v20 = 503;
        goto LABEL_26;
      }
      v18 = *(_WORD *)v15 == 23106 && v15[2] == 104;
      if (v18 && v15[3] - 49 <= 8)
      {
        if (BZ2_bzDecompressInit((bz_stream *)(v9 + 72), 0, 0))
        {
          v19 = "BZ2_bzDecompressInit";
          v20 = 514;
LABEL_26:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", v20, 39, 0, v19, v12, v13, v47);
LABEL_27:
          ILowMemoryDecoderStreamDestroy(v9);
          return 0;
        }
        v44 = 3;
LABEL_54:
        *(_DWORD *)(v9 + 32) = v44;
        return v9;
      }
      v27 = *v15;
      if (v27 == 120)
      {
        if (-1108378657 * (v15[1] | 0x7800u) <= 0x8421084)
        {
          if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB) == COMPRESSION_STATUS_OK)
          {
            MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), 2uLL, v40, v41, v42, v43, v12, v13);
            *(_DWORD *)(v9 + 32) = 2;
            return v9;
          }
          v19 = "compression_stream_init";
          v20 = 570;
          goto LABEL_26;
        }
      }
      else if (v27 == 31 && v15[1] == 139 && v15[2] == 8)
      {
        if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0x1000uLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))v9, *(_QWORD *)(v9 + 16)) < 0)
        {
          v19 = "reading gzip header data";
          v20 = 525;
          goto LABEL_26;
        }
        DataSize = MemBufferGetDataSize(*(_QWORD *)(v9 + 56));
        if ((v15[3] & 4) != 0)
        {
          if (DataSize <= 0xB)
          {
            v19 = "parsing gzip header";
            v20 = 531;
            goto LABEL_26;
          }
          v33 = *((unsigned __int16 *)v15 + 5) + 12;
          if (v33 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 534;
            goto LABEL_26;
          }
        }
        else
        {
          v33 = 10;
        }
        if ((v15[3] & 8) != 0)
        {
          v45 = v33 + 2;
          if (v33 + 2 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 539;
            goto LABEL_26;
          }
          if (v33 + 2 < DataSize)
          {
            while (v15[v33 + 1])
            {
              if (DataSize - 2 == ++v33)
              {
                v45 = DataSize;
                goto LABEL_63;
              }
            }
            v45 = v33 + 2;
          }
        }
        else
        {
          v45 = v33;
        }
LABEL_63:
        if ((v15[3] & 0x10) != 0)
        {
          v46 = v45 + 2;
          if (v45 + 2 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 545;
            goto LABEL_26;
          }
          if (v45 + 2 < DataSize)
          {
            while (v15[v45 + 1])
            {
              if (DataSize - 2 == ++v45)
              {
                v46 = DataSize;
                goto LABEL_65;
              }
            }
            v46 = v45 + 2;
          }
        }
        else
        {
          v46 = v45;
        }
LABEL_65:
        if ((v15[3] & 2) != 0)
        {
          v46 += 2;
          if (v46 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 551;
            goto LABEL_26;
          }
        }
        MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), v46, v29, v30, v31, v32, v12, v13);
        if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
        {
          v19 = "compression_stream_init";
          v20 = 557;
          goto LABEL_26;
        }
        v44 = 2;
        goto LABEL_54;
      }
      v19 = "Could not identify compressed stream format";
      v20 = 579;
      goto LABEL_26;
    }
  }
  else
  {
    v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", 452, 39, *v21, "malloc", v22, v23, v47);
  }
  return v9;
}

void ILowMemoryDecoderStreamDestroy(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 32);
    switch(v2)
    {
      case 3:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 72));
        break;
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 72));
        break;
      case 1:
        lzma_end();
        break;
    }
    MemBufferDestroy(*(void ***)(a1 + 56));
    MemBufferDestroy(*(void ***)(a1 + 64));
    OMemStreamDestroy(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t ILowMemoryDecoderStreamCreateWithBuffer(uint64_t a1, uint64_t a2, size_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t result;
  char v9;

  v4 = IMemStreamCreate(a1, a2);
  if (v4)
  {
    v7 = v4;
    result = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMemStreamRead, (uint64_t)IMemStreamAbort, (uint64_t)v4, a3);
    if (result)
    {
      *(_QWORD *)(result + 24) = v7;
      return result;
    }
    OMemStreamDestroy(v7);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreateWithBuffer", 596, 39, 0, "IMemStreamCreate failed", v5, v6, v9);
  }
  return 0;
}

uint64_t ILowMemoryDecoderStreamRead(uint64_t a1, char *a2, size_t a3)
{
  int v6;
  uint64_t v7;
  unint64_t DataSize;
  size_t v9;
  const void *DataPtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t FreeSize;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  compression_status v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  compression_status v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v56;
  unint64_t v57;
  void *FreePtr;
  const void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t (*v97)(uint64_t, unint64_t, uint64_t, unint64_t);
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  __int16 v107;
  char v109;
  bz_stream *stream;

  if (a1)
  {
    v6 = 0;
    v7 = 0;
    stream = (bz_stream *)(a1 + 72);
    do
    {
      if (!a3)
        return v7;
      DataSize = MemBufferGetDataSize(*(_QWORD *)(a1 + 64));
      if (DataSize >= a3)
        v9 = a3;
      else
        v9 = DataSize;
      if (v9)
      {
        DataPtr = (const void *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 64));
        memcpy(a2, DataPtr, v9);
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 64), v9, v11, v12, v13, v14, v15, v16);
        v7 += v9;
        a3 -= v9;
        if (!a3)
          return v7;
        a2 += v9;
      }
      if (*(_DWORD *)(a1 + 208))
        return v7;
      v17 = *(unint64_t **)(a1 + 56);
      if (!*(_DWORD *)(a1 + 32))
      {
        v43 = MemBufferGetDataSize((uint64_t)v17);
        v44 = v43;
        if (v43 <= 0xF)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), 16 - v43, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) < 0)
          {
            v106 = "reading block header failed";
            v107 = 645;
            goto LABEL_76;
          }
          v44 = MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
          if (!v44)
          {
            *(_DWORD *)(a1 + 208) = 1;
            return v7;
          }
        }
        v45 = (unint64_t *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
        v51 = *v45;
        v50 = v45[1];
        v52 = bswap64(*v45);
        v53 = bswap64(v50);
        v54 = *(_QWORD *)(a1 + 40);
        if (v52 > v54 || v53 > v54)
        {
          v106 = "invalid block header";
          v107 = 655;
          goto LABEL_76;
        }
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), 0x10uLL, v46, v47, v48, v49, v18, v19);
        v56 = v53 >= v44 - 16;
        v57 = v53 - (v44 - 16);
        if (v57 != 0 && v56)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), v57, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) != v57)
          {
            v106 = "reading block payload failed";
            v107 = 665;
            goto LABEL_76;
          }
          MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
        }
        if (v51 == v50)
        {
          FreePtr = (void *)MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
          v59 = (const void *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
          memcpy(FreePtr, v59, v52);
        }
        else
        {
          v97 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t))(a1 + 48);
          v98 = MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
          v99 = MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
          if (v97(v98, v52, v99, v53) != v52)
          {
            v106 = "decoding block payload failed";
            v107 = 677;
            goto LABEL_76;
          }
        }
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v53, v60, v61, v62, v63, v18, v19);
        MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v52, v100, v101, v102, v103, v104, v105);
        goto LABEL_62;
      }
      if (MemBufferFillFromIStream(v17, 0xFFFFFFFFFFFFFFFFLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) < 0)
      {
        v106 = "reading payload failed";
        v107 = 687;
        goto LABEL_76;
      }
      v20 = MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
      v21 = MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
      v22 = MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
      FreeSize = MemBufferGetFreeSize(*(_QWORD **)(a1 + 64));
      v26 = FreeSize;
      v27 = *(_DWORD *)(a1 + 32);
      switch(v27)
      {
        case 1:
          *(_QWORD *)(a1 + 72) = v20;
          *(_QWORD *)(a1 + 80) = v21;
          *(_QWORD *)(a1 + 96) = v22;
          *(_QWORD *)(a1 + 104) = FreeSize;
          v64 = lzma_code();
          v71 = v64;
          if (v64 > 0xA || ((1 << v64) & 0x403) == 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 738, 39, 0, "decoding lzma payload", v69, v70, v109);
            v81 = 1;
            goto LABEL_60;
          }
          v72 = *(_QWORD *)(a1 + 72);
          v73 = *(_QWORD *)(a1 + 96);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v72 - v20, v65, v66, v67, v68, v69, v70);
          if (v73 == v22 && v72 == v20)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v73 - v22, v74, v75, v76, v77, v78, v79);
          if (v71 != 1)
          {
            v81 = 14;
LABEL_60:
            if (v71 > 0xA || ((1 << v71) & 0x403) == 0)
              continue;
            goto LABEL_62;
          }
          break;
        case 3:
          *(_QWORD *)(a1 + 72) = v20;
          *(_DWORD *)(a1 + 80) = v21;
          *(_QWORD *)(a1 + 96) = v22;
          *(_DWORD *)(a1 + 104) = FreeSize;
          v82 = BZ2_bzDecompress(stream);
          if (v82 < 0)
          {
            v106 = "decoding bzip2 payload";
            v107 = 722;
            goto LABEL_76;
          }
          v87 = v82;
          v88 = *(_QWORD *)(a1 + 72);
          v89 = *(_QWORD *)(a1 + 96);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v88 - v20, v83, v84, v85, v86, v18, v19);
          if (v89 == v22 && v88 == v20)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v89 - v22, v90, v91, v92, v93, v94, v95);
          if (v87 != 4)
            goto LABEL_62;
          break;
        case 2:
          *(_QWORD *)(a1 + 88) = v20;
          *(_QWORD *)(a1 + 96) = v21;
          *(_QWORD *)(a1 + 72) = v22;
          *(_QWORD *)(a1 + 80) = FreeSize;
          v28 = compression_stream_process((compression_stream *)stream, 0);
          if (v28 < 0)
          {
            v106 = "decoding zlib payload";
            v107 = 706;
            goto LABEL_76;
          }
          v33 = v28;
          v34 = *(_QWORD *)(a1 + 96);
          v35 = *(_QWORD *)(a1 + 80);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v21 - v34, v29, v30, v31, v32, v18, v19);
          if (v26 == v35 && v21 == v34)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v26 - v35, v36, v37, v38, v39, v40, v41);
          if (v33 != COMPRESSION_STATUS_END)
            goto LABEL_62;
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 748, 39, 0, "invalid decoder: %d", v24, v25, *(_DWORD *)(a1 + 32));
          return -1;
      }
      *(_DWORD *)(a1 + 208) = 1;
LABEL_62:
      if (v6 >= 3)
      {
        v106 = "Truncated stream";
        v107 = 753;
LABEL_76:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", v107, 39, 0, v106, v18, v19, v109);
        return -1;
      }
      v81 = 0;
    }
    while (!v81);
  }
  return -1;
}

uint64_t rawimg_force_in_place(_QWORD *a1, unint64_t *a2, _QWORD *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  AAByteStream_impl *v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  AAByteStream_impl *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t **v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  AAByteStream_impl *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  int v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t i;
  uint64_t v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  BOOL v70;
  int v71;
  int v72;
  unint64_t v73;
  int v74;
  uint64_t v75;
  unint64_t v76;
  int64x2_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int8x16_t *v82;
  int64x2_t v83;
  int64x2_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  int64x2_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  int64x2_t v96;
  const char *v97;
  __int16 v98;
  const char *v99;
  __int16 v100;
  const char *v101;
  __int16 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  const char *v124;
  __int16 v125;
  __int16 v126;
  _QWORD *v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t *v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  __int128 v139;
  _QWORD *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  char v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  int64x2_t v150;
  int v151;
  int64x2_t v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  AAByteStream_impl *v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164;
  int v165;
  unint64_t v166;
  int64x2_t v167;
  AAByteStream_impl *v168;
  uint64_t v169;
  unint64_t *v170;
  _QWORD *v171;

  if (*(_QWORD *)(a4 + 2120) <= a3[265])
    v12 = a3[265];
  else
    v12 = *(_QWORD *)(a4 + 2120);
  v15 = AAFileStreamOpenWithPath(*(const char **)(a4 + 2048), 0, 0);
  if (!v15)
  {
    v99 = "AAFileStreamOpenWithPath";
    v100 = 234;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v100, 141, 0, v99, v13, v14, v145);
    v43 = 0;
    v40 = 0;
    v33 = 0;
    v30 = 0;
    v17 = 0;
LABEL_122:
    v110 = 0;
    goto LABEL_123;
  }
  v16 = (unint64_t)(a5 + 0x3FFF) >> 14;
  v17 = (uint64_t *)calloc(1uLL, 0x68uLL);
  v18 = calloc(1uLL, 0x28uLL);
  v21 = v18;
  if ((v16 & 0x80000000) != 0)
  {
    v101 = "too little excess";
    v102 = 184;
LABEL_120:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"aaSimStreamOpen", v102, 141, 0, v101, v19, v20, v145);
    free(v17);
    SimStreamClose((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109);
    v99 = "aaSimStreamOpen";
    v100 = 236;
    goto LABEL_121;
  }
  if (!v17 || !v18)
  {
    v101 = "aaCalloc";
    v102 = 185;
    goto LABEL_120;
  }
  *v18 = v15;
  *((_DWORD *)v18 + 4) = (unint64_t)(v12 + 0x3FFF) >> 14;
  *((_DWORD *)v18 + 8) = v16;
  *((_DWORD *)v18 + 9) = a6;
  if (((v12 + 0x3FFF) & 0x200000000000) != 0)
  {
    *__error() = 12;
    v21[1] = 0;
    goto LABEL_119;
  }
  v22 = calloc(((unint64_t)(v12 + 0x3FFF) >> 14), 5uLL);
  v21[1] = v22;
  if (!v22)
  {
LABEL_119:
    v101 = "aaCalloc";
    v102 = 195;
    goto LABEL_120;
  }
  AACustomByteStreamSetData((AAByteStream)v17, v21);
  AACustomByteStreamSetCloseProc((AAByteStream)v17, (AAByteStreamCloseProc)SimStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v17, (AAByteStreamPReadProc)SimStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v17, (AAByteStreamPWriteProc)SimStreamPWrite);
  v17[11] = (uint64_t)SimStreamSimulate;
  v23 = *v17;
  v24 = aaSegmentStreamOpen(v17, a3);
  v30 = (AAByteStream_impl *)v24;
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 241, 141, 0, "aaSegmentStreamOpen", v28, v29, v145);
    v43 = 0;
    v40 = 0;
    v33 = 0;
    goto LABEL_122;
  }
  v33 = aaForkInputStreamOpen(v24, (uint64_t)a3, 0, v25, v26, v27, v28, v29);
  if (!v33)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 243, 141, 0, "aaForkInputStreamOpen", v31, v32, v145);
    v43 = 0;
    v40 = 0;
    goto LABEL_122;
  }
  v34 = aaSegmentStreamOpen(v17, (_QWORD *)a4);
  v40 = (AAByteStream_impl *)v34;
  if (!v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 247, 141, 0, "aaSegmentStreamOpen", v38, v39, v145);
    v43 = 0;
    goto LABEL_122;
  }
  v169 = v23;
  v43 = aaForkInputStreamOpen(v34, a4, 0, v35, v36, v37, v38, v39);
  if (!v43)
  {
    v97 = "aaForkOutputStreamOpen";
    v98 = 249;
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v98, 141, 0, v97, v41, v42, v145);
    goto LABEL_122;
  }
  v154 = 0;
  v152 = vdupq_n_s64(0x8000000000000000);
  v151 = 1;
  v171 = a1;
  v168 = v40;
  v153 = a6;
  v170 = a2;
  while (2)
  {
    bzero(*(void **)(v169 + 8), 5 * *(int *)(v169 + 16));
    v44 = *(_DWORD *)(v169 + 16);
    *(_QWORD *)(v169 + 24) = 0;
    *(_DWORD *)(v169 + 20) = v44;
    v45 = *a2;
    if (*a2)
    {
      v46 = 0;
      v47 = 0;
      do
      {
        v48 = (unint64_t *)(*a1 + 24 * v47);
        if ((*v48 & 0x8000000000000000) == 0)
          v49 = *v48;
        else
          v49 = 0x8000000000000000 - *v48;
        v50 = v48[2];
        v51 = 0x8000000000000000 - v50;
        if (v50 >= 0)
          v51 = v50;
        if (v49)
        {
          v161 = v51;
          v164 = v47;
          for (i = 0; i < v49; i += v53)
          {
            if (v49 - i >= 0x10000)
              v53 = 0x10000;
            else
              v53 = v49 - i;
            if (v53 != aaByteStreamSimulate(v33))
            {
              v124 = "aaByteStreamSimulate";
              v125 = 270;
              goto LABEL_144;
            }
          }
          a1 = v171;
          v45 = *v170;
          v51 = v161;
          v47 = v164;
        }
        v46 += v49 + v51;
        ++v47;
      }
      while (v47 < v45);
    }
    v54 = 1;
    v55 = v45;
    v156 = v30;
    do
    {
      if (!v55)
        goto LABEL_59;
      v56 = 0;
      v57 = 0;
      v58 = 0;
      v165 = v54;
      do
      {
        v59 = (unint64_t *)(*v171 + 24 * v56);
        v60 = v59[1];
        v61 = 0x8000000000000000 - *v59;
        if ((*v59 & 0x8000000000000000) == 0)
          v61 = *v59;
        if (v60 >= 0)
          v62 = v59[1];
        else
          v62 = 0x8000000000000000 - v60;
        v63 = v59[2];
        if (v63 < 0)
          v63 = 0x8000000000000000 - v63;
        if (v54 == 2)
        {
          v57 += v61;
          if (v57 < *(_QWORD *)(a4 + 2056))
            goto LABEL_57;
        }
        else
        {
          v157 = v63;
          v159 = v62;
          v162 = v56;
          if (v61)
          {
            v64 = 0;
            while (1)
            {
              v65 = v61;
              if (v61 - v64 >= 0x10000)
                v66 = 0x10000;
              else
                v66 = v61 - v64;
              if (v66 != aaByteStreamSimulate(v33))
              {
                v126 = 298;
                goto LABEL_148;
              }
              if (v66 != aaByteStreamSimulate(v43))
                break;
              v58 += v66;
              v57 += v66;
              v64 += v66;
              v61 = v65;
              if (v64 >= v65)
                goto LABEL_52;
            }
            v126 = 299;
LABEL_148:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v126, 141, 0, "aaByteStreamSimulate", v41, v42, v145);
            v110 = 0;
            v40 = v168;
            v30 = v156;
            goto LABEL_123;
          }
LABEL_52:
          v58 += v157;
          v54 = v165;
          if (v165 == 1)
          {
            v56 = v162;
            v62 = v159;
            v30 = v156;
            if (v57 >= *(_QWORD *)(a4 + 2056))
              goto LABEL_57;
          }
          else
          {
            v56 = v162;
            v62 = v159;
            v30 = v156;
          }
        }
        v67 = aaByteStreamSimulate(v43);
        v54 = v165;
        if (v62 != v67)
        {
          v124 = "aaByteStreamSimulate";
          v125 = 310;
          goto LABEL_144;
        }
LABEL_57:
        v57 += v62;
        ++v56;
        v45 = *v170;
      }
      while (v56 < *v170);
      v55 = *v170;
LABEL_59:
      ++v54;
    }
    while (v54 != 3);
    v68 = *(_DWORD *)(v169 + 28);
    if (v153 >= 3)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ForceInPlace %d: excess_pages=%d/%d, converted bytes=%llu, %zu controls\n", v151, v68, *(_DWORD *)(v169 + 32), v154, v45);
      v68 = *(_DWORD *)(v169 + 28);
    }
    v69 = *(_DWORD *)(v169 + 32);
    v70 = __OFSUB__(v68, v69);
    v71 = v68 - v69;
    if (!((v71 < 0) ^ v70 | (v71 == 0)))
    {
      v72 = v71 + 1;
      v73 = (uint64_t)(v72 >> 1) << 14;
      if (v72 < 2)
      {
        v74 = 0;
        a2 = v170;
        a1 = v171;
        v75 = v154;
        goto LABEL_112;
      }
      v149 = 0;
      v146 = -1;
      v76 = 1;
      a2 = v170;
      a1 = v171;
      v75 = v154;
      v77 = v152;
      while (2)
      {
        v78 = *(_QWORD *)(a4 + 2080);
        v79 = *a2;
        if (*a2)
        {
          v74 = 0;
          v147 = v76 - 1;
          v148 = v76;
          v80 = 24 * v79;
          while (1)
          {
            v81 = *a1 + v80;
            v82 = (int8x16_t *)(v81 - 24);
            v83 = *(int64x2_t *)(v81 - 24);
            v84 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v83), (int8x16_t)vsubq_s64(v77, v83), (int8x16_t)v83);
            v85 = *(_QWORD *)(v81 - 8);
            v86 = 0x8000000000000000 - v85;
            if (v85 >= 0)
              v86 = *(_QWORD *)(v81 - 8);
            v78 -= vaddvq_s64(v84);
            if (!v73)
              goto LABEL_94;
            v87 = v84.i64[0];
            if (!v84.i64[0])
              goto LABEL_94;
            if ((_DWORD)v76 == 1)
              break;
            if ((_DWORD)v76 != 2)
            {
              if ((_DWORD)v76 != 3)
                goto LABEL_94;
              v88 = *(_QWORD *)(a4 + 2056);
              goto LABEL_78;
            }
            if (v78 >= *(_QWORD *)(a4 + 2072))
            {
              if (v84.i64[0] > v73)
              {
                v89 = v146;
                v90 = v149;
                if (v146 > v84.i64[0])
                  v90 = v81 - 24;
                v149 = v90;
                if (v146 >= v84.i64[0])
                  v89 = v84.i64[0];
                v146 = v89;
                goto LABEL_94;
              }
              goto LABEL_89;
            }
LABEL_94:
            v80 -= 24;
            --v79;
            a1 = v171;
            if (!v79)
              goto LABEL_97;
          }
          if (v78 < *(_QWORD *)(a4 + 2056))
            goto LABEL_94;
          v88 = *(_QWORD *)(a4 + 2072);
LABEL_78:
          if (v78 < v88)
          {
            if (v84.i64[0] >= v73)
              v87 = v73;
LABEL_89:
            if (v153 >= 4)
            {
              v91 = v73;
              v155 = v75;
              v163 = v81;
              v166 = v78;
              v158 = v86;
              v160 = v87;
              v150 = v84;
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Dropping %llu bytes at %llu, needed=%llu bytes, type %s\n", v87, v78, v73, rawimg_force_in_place_pass_name[v147]);
              v84 = v150;
              v86 = v158;
              v87 = v160;
              v81 = v163;
              v78 = v166;
              v76 = v148;
              v75 = v155;
              v73 = v91;
              v77 = v152;
            }
            v83.i64[0] = v87;
            v92.i64[0] = vsubq_s64(v84, v83).u64[0];
            v92.i64[1] = vaddq_s64(v84, vdupq_n_s64(v87)).i64[1];
            *v82 = vbslq_s8((int8x16_t)vcltzq_s64(v92), (int8x16_t)vsubq_s64(v77, v92), (int8x16_t)v92);
            v93 = v87 + v86;
            if ((uint64_t)(v87 + v86) < 0)
              v93 = 0x8000000000000000 - (v87 + v86);
            *(_QWORD *)(v81 - 8) = v93;
            v75 += v87;
            v73 -= v87;
            v74 = 1;
            goto LABEL_94;
          }
          goto LABEL_94;
        }
        v74 = 0;
LABEL_97:
        if (v78)
        {
          v124 = "control sequence broken";
          v125 = 411;
          goto LABEL_144;
        }
        a2 = v170;
        if (v76 != 3 || v74 || !v73 || !v149)
        {
          if (v76 > 2)
            goto LABEL_112;
          if (v74)
            goto LABEL_112;
          ++v76;
          if (!v73)
            goto LABEL_112;
          continue;
        }
        break;
      }
      v94 = v75;
      if (*(uint64_t *)v149 >= 0)
        v95 = *(_QWORD *)v149;
      else
        v95 = 0x8000000000000000 - *(_QWORD *)v149;
      v167 = *(int64x2_t *)(v149 + 8);
      if (v153 >= 4)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Dropping copy fork with %llu bytes, needed=%llu bytesx\n", v95, v73);
      v73 = 0;
      *(_QWORD *)v149 = 0;
      v96 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v167), (int8x16_t)vsubq_s64(v152, v167), (int8x16_t)v167), vdupq_n_s64(v95));
      *(int8x16_t *)(v149 + 8) = vbslq_s8((int8x16_t)vcltzq_s64(v96), (int8x16_t)vsubq_s64(v152, v96), (int8x16_t)v96);
      v75 = v95 + v94;
      v74 = 1;
      a2 = v170;
      a1 = v171;
LABEL_112:
      v154 = v75;
      ++v151;
      v40 = v168;
      if (!v74 && v73)
      {
        v97 = "no possible conversions";
        v98 = 441;
        goto LABEL_142;
      }
      continue;
    }
    break;
  }
  v127 = (_QWORD *)*v171;
  v128 = *v170;
  if (!*v170)
    goto LABEL_155;
  if (v128 != 1)
  {
    v129 = 0;
    v130 = v127[1] + *v127;
    v131 = v127 + 3;
    v132 = 1;
    while (1)
    {
      v133 = *v131;
      v134 = v131[1];
      if (v130 != *(_QWORD *)(a4 + 2072))
      {
        v135 = &v127[3 * v129];
        v138 = v135[1];
        v137 = v135 + 1;
        v136 = v138;
        if (!v133)
        {
          v141 = v127[3 * v129 + 2];
LABEL_167:
          v127[3 * v129] += v133;
          *v137 = v136 + v134;
          v142 = 0x8000000000000000 - v141;
          if (v141 >= 0)
            v142 = v141;
          v143 = v131[2];
          if (v143 < 0)
            v143 = 0x8000000000000000 - v143;
          v70 = __OFADD__(v143, v142);
          v144 = v143 + v142;
          if (v144 < 0 != v70)
            v144 = 0x8000000000000000 - v144;
          v127[3 * v129 + 2] = v144;
          goto LABEL_174;
        }
        if (!v136)
        {
          v136 = v127[3 * v129 + 2];
          if (!v136)
          {
            v141 = 0;
            goto LABEL_167;
          }
        }
      }
      ++v129;
      v139 = *(_OWORD *)v131;
      v140 = &v127[3 * v129];
      v140[2] = v131[2];
      *(_OWORD *)v140 = v139;
LABEL_174:
      v130 += v134 + v133;
      ++v132;
      v131 += 3;
      if (v132 >= *v170)
        goto LABEL_154;
    }
  }
  v129 = 0;
LABEL_154:
  v128 = v129 + 1;
  *v170 = v128;
LABEL_155:
  *v171 = v127;
  if (v127)
  {
    if (v153 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ForceInPlace: %zu controls. Dropped %llu bytes to stay within budget.\n", v128, v154);
    v110 = 1;
  }
  else
  {
    v124 = "merge_controls";
    v125 = 447;
LABEL_144:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v125, 141, 0, v124, v41, v42, v145);
    v110 = 0;
  }
  v40 = v168;
LABEL_123:
  if (AAByteStreamClose((AAByteStream)v33) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 458, 141, 0, "AAByteStreamClose", v111, v112, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v30) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 459, 141, 0, "AAByteStreamClose", v113, v114, v145);
    v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v43) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 460, 141, 0, "AAByteStreamClose", v115, v116, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v40) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 461, 141, 0, "AAByteStreamClose", v117, v118, v145);
    v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 462, 141, 0, "AAByteStreamClose", v119, v120, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v15) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 463, 141, 0, "AAByteStreamClose", v121, v122, v145);
    v110 = 0;
  }
  if (v110)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SimStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  char v17;

  if (!a1)
    return 0;
  v9 = *(_DWORD *)(a1 + 16);
  if (v9 < 1)
    goto LABEL_8;
  v10 = 0;
  v11 = *(int **)(a1 + 8);
  v12 = *(unsigned int *)(a1 + 16);
  do
  {
    v13 = *v11;
    v11 = (int *)((char *)v11 + 5);
    v10 += v13;
    --v12;
  }
  while (v12);
  if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 148, 141, 0, "%i dangling reads", a7, a8, v10);
    v9 = *(_DWORD *)(a1 + 16);
    v14 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28) + v9 != *(_DWORD *)(a1 + 20) + v15)
  {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 152, 141, "file + excess != written + free", a6, a7, a8, v17);
    v9 = *(_DWORD *)(a1 + 16);
    v15 = *(_DWORD *)(a1 + 24);
  }
  if (v9 < v15)
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 154, 141, "file < written", a6, a7, a8, v17);
  if (*(int *)(a1 + 36) >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "SimStream: pages: %i file, %i written, %i free, %i excess (%iK)\n", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 28), 16 * *(_DWORD *)(a1 + 28));
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return v14;
}

ssize_t SimStreamPRead(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

ssize_t SimStreamPWrite(AAByteStream *a1, const void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPWrite(*a1, a2, a3, a4);
}

uint64_t SimStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  int64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  int v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  int v18;
  const char *v20;
  __int16 v21;

  if (a4 < 1)
    return a4;
  if (a2 > 2)
  {
    v20 = "not implemented";
    v21 = 87;
    goto LABEL_20;
  }
  v9 = a5 + a4;
  v10 = *(_QWORD *)(a1 + 8);
  while (1)
  {
    v11 = (int *)(v10 + 5 * (a5 >> 14));
    if (a2)
      break;
    if (!(*v11)++)
    {
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v14 - 1;
      if (!v14)
      {
        v20 = "no free pages";
        v21 = 94;
        goto LABEL_20;
      }
    }
LABEL_17:
    a5 = (a5 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if (a5 >= v9)
      return a4;
  }
  if (a2 != 1)
  {
    v15 = v10 + 5 * (a5 >> 14);
    v17 = *(unsigned __int8 *)(v15 + 4);
    v16 = (_BYTE *)(v15 + 4);
    if (!v17)
    {
      *v16 = 1;
      v18 = *(_DWORD *)(a1 + 20);
      if (v18)
        *(_DWORD *)(a1 + 20) = v18 - 1;
      else
        ++*(_DWORD *)(a1 + 28);
      ++*(_DWORD *)(a1 + 24);
    }
    goto LABEL_17;
  }
  if (*v11 > 0)
  {
    v12 = *v11 - 1;
    *v11 = v12;
    if (!v12)
      ++*(_DWORD *)(a1 + 20);
    goto LABEL_17;
  }
  v20 = "data not locked";
  v21 = 99;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamSimulate", v21, 141, 0, v20, a7, a8, v8);
  return -1;
}

int AEAContextDecryptAttributes(AEAContext context)
{
  uint64_t v1;
  uint64_t v2;
  const char *v4;
  __int16 v5;
  int v6;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _OWORD __s[16];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  memset(__s, 0, sizeof(__s));
  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  if (*((_DWORD *)context + 684) && *((_QWORD *)context + 341))
  {
    if ((aeaContextUnlock((uint64_t)context, (uint64_t)&v10, __s, 0, 1, 0) & 0x80000000) != 0)
    {
      v4 = "unlock container";
      v5 = 18;
    }
    else
    {
      if (((unint64_t)v12 + v11 - 1) / v11 < 0xFFFFFFFF)
      {
        v6 = 0;
        v8 = v13;
        *((_OWORD *)context + 2) = v12;
        *((_OWORD *)context + 3) = v8;
        *((_QWORD *)context + 8) = v14;
        v9 = v11;
        *(_OWORD *)context = v10;
        *((_OWORD *)context + 1) = v9;
        goto LABEL_8;
      }
      v4 = "Invalid data size";
      v5 = 22;
    }
  }
  else
  {
    v4 = "invalid context";
    v5 = 15;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContextValidate.c", (uint64_t)"AEAContextDecryptAttributes", v5, 121, 0, v4, v1, v2, v10);
  v6 = -1;
LABEL_8:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v10, 0x48uLL, 0, 0x48uLL);
  return v6;
}

char *SharedBufferCreate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  _QWORD *i;
  char v39;

  if (a1 - 0x100000000 > 0xFFFFFFFF00000000)
  {
    v9 = getpagesize();
    if (v9 <= 0x197)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 252, 73, 0, "Incompatible page size", v10, v11, v39);
      return 0;
    }
    v14 = v9;
    if (a1 >> 2 < v9)
      v15 = 1;
    else
      v15 = (a1 >> 2) / v9;
    v16 = v15 * v9;
    v17 = (unsigned int *)valloc(v9 + 4 * v16);
    v12 = v17;
    if (!v17)
    {
      v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 262, 73, *v24, "malloc", v25, v26, v39);
      return (char *)v12;
    }
    *((_QWORD *)v17 + 50) = 0;
    *((_OWORD *)v17 + 23) = 0u;
    *((_OWORD *)v17 + 24) = 0u;
    *((_OWORD *)v17 + 21) = 0u;
    *((_OWORD *)v17 + 22) = 0u;
    *((_OWORD *)v17 + 19) = 0u;
    *((_OWORD *)v17 + 20) = 0u;
    *((_OWORD *)v17 + 17) = 0u;
    *((_OWORD *)v17 + 18) = 0u;
    *((_OWORD *)v17 + 15) = 0u;
    *((_OWORD *)v17 + 16) = 0u;
    *((_OWORD *)v17 + 13) = 0u;
    *((_OWORD *)v17 + 14) = 0u;
    *((_OWORD *)v17 + 11) = 0u;
    *((_OWORD *)v17 + 12) = 0u;
    *((_OWORD *)v17 + 9) = 0u;
    *((_OWORD *)v17 + 10) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 8) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *(_OWORD *)v17 = 0u;
    *((_QWORD *)v17 + 48) = -1;
    atomic_store(2u, v17 + 101);
    *(_QWORD *)v17 = 0x600000000;
    v18 = calloc(6uLL, 4uLL);
    *((_QWORD *)v12 + 1) = v18;
    if (v18)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v12 + 4), 0))
      {
        v22 = "SharedArrayInit: pthread_mutex_init failed\n";
        v23 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v12 + 20), 0))
        {
          *((_QWORD *)v12 + 16) = 0x600000000;
          v31 = calloc(6uLL, 4uLL);
          *((_QWORD *)v12 + 17) = v31;
          if (v31)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v12 + 36), 0))
            {
              v35 = "SharedArrayInit: pthread_mutex_init failed\n";
              v36 = 56;
            }
            else
            {
              if (!pthread_cond_init((pthread_cond_t *)(v12 + 52), 0))
              {
                v37 = 0;
                for (i = v12 + 68; ; i += 4)
                {
                  *i = 0;
                  i[1] = 0;
                  *(i - 2) = (char *)v12 + v14;
                  *(i - 1) = v16;
                  if ((SharedArrayPush(v12 + 32, v37) & 0x80000000) != 0)
                    break;
                  ++v37;
                  v14 += v16;
                  if (v37 == 4)
                    return (char *)v12;
                }
                v29 = "SharedArrayPush";
                v30 = 283;
                goto LABEL_19;
              }
              v35 = "SharedArrayInit: pthread_cond_init failed\n";
              v36 = 57;
            }
          }
          else
          {
            v35 = "SharedArrayInit: malloc failed\n";
            v36 = 55;
          }
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v36, 0, v35, v32, v33, v34, v39);
          v29 = "SharedArrayInit";
          v30 = 270;
LABEL_19:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", v30, 73, 0, v29, v27, v28, v39);
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 4))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 20)))
          {
            free(*((void **)v12 + 1));
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 36))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 52)))
          {
            free(*((void **)v12 + 17));
          }
          free(v12);
          return 0;
        }
        v22 = "SharedArrayInit: pthread_cond_init failed\n";
        v23 = 57;
      }
    }
    else
    {
      v22 = "SharedArrayInit: malloc failed\n";
      v23 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v23, 0, v22, v19, v20, v21, v39);
    v29 = "SharedArrayInit";
    v30 = 269;
    goto LABEL_19;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 247, 73, 0, "SharedBuffer invalid capacity: %zu", a7, a8, a1);
  return 0;
}

uint64_t SharedArrayPush(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 117;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v10) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 124;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 125;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

void SharedBufferDestroy(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 80)))
      free(*(void **)(a1 + 8));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 208)))
      free(*(void **)(a1 + 136));
    free((void *)a1);
  }
}

BOOL SharedBufferDecRefCount(uint64_t a1)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(a1 + 404);
  do
  {
    v2 = __ldaxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  return v3 == 0;
}

uint64_t SharedBufferFillFromStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v11;
  __int16 v12;
  unint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  uint64_t *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  const char *v42;
  __int16 v43;
  char v45;

  if (a2)
  {
    if (!atomic_load((unsigned int *)(a1 + 400)))
    {
      if (atomic_load((unsigned int *)(a1 + 392)))
      {
        v11 = "write after EOF";
        v12 = 365;
LABEL_26:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferFillFromStream", v12, 73, 0, v11, a7, a8, v45);
      }
      else
      {
        v14 = a2;
        v15 = 0;
        v16 = a1 + 256;
        while (1)
        {
          v17 = *(unsigned int *)(a1 + 384);
          if (v17 <= 3)
          {
            v22 = *(_QWORD *)(v16 + 32 * v17 + 24);
          }
          else
          {
            if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 144)))
            {
              v42 = "SharedArrayPop: pthread_mutex_lock failed\n";
              v43 = 91;
LABEL_25:
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v43, 0, v42, v18, v19, v20, v45);
              v11 = "SharedArrayPop";
              v12 = 378;
              goto LABEL_26;
            }
            while (1)
            {
              v21 = *(_DWORD *)(a1 + 128);
              if (v21)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(a1 + 208), (pthread_mutex_t *)(a1 + 144)))
              {
                v42 = "SharedArrayPop: pthread_cond_wait failed\n";
                v43 = 94;
                goto LABEL_25;
              }
            }
            v23 = v21 - 1;
            *(_DWORD *)(a1 + 128) = v23;
            v17 = *(unsigned int *)(*(_QWORD *)(a1 + 136) + 4 * v23);
            if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144)))
            {
              v42 = "SharedArrayPop: pthread_mutex_unlock failed\n";
              v43 = 98;
              goto LABEL_25;
            }
            if (v17 > 3)
              goto LABEL_27;
            v22 = 0;
            *(_DWORD *)(a1 + 384) = v17;
            v28 = v16 + 32 * v17;
            *(_QWORD *)(v28 + 16) = 0;
            *(_QWORD *)(v28 + 24) = 0;
          }
          v29 = v16;
          v30 = (uint64_t *)(v16 + 32 * v17);
          v32 = v30 + 1;
          v31 = v30[1];
          v35 = *v30;
          v34 = v30 + 3;
          v33 = v35;
          v36 = v31 - v22;
          if (v36 >= v14)
            v37 = v14;
          else
            v37 = v36;
          v38 = a3(a4, v33 + v22, v37);
          if (v38 < 0)
          {
            v11 = "stream read";
            v12 = 393;
            goto LABEL_26;
          }
          v39 = v38;
          if (!v38)
            break;
          v40 = *v34 + v38;
          *v34 = v40;
          v41 = v40 == *v32;
          v16 = v29;
          if (v41 && (currentWriteBufferFull((unsigned int *)a1) & 0x80000000) != 0)
            goto LABEL_27;
          v15 += v39;
          v14 -= v39;
          if (!v14)
            goto LABEL_32;
        }
        if ((sendEOF((unsigned int *)a1) & 0x80000000) == 0)
        {
LABEL_32:
          if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0)
            return v15;
        }
      }
LABEL_27:
      SharedBufferAbort(a1, v24, v25, v26, v27, v18, v19, v20, v45);
    }
  }
  return -1;
}

uint64_t sendEOF(unsigned int *a1)
{
  unsigned int *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v7;

  v2 = a1 + 98;
  do
  {
    if (__ldaxr(v2))
    {
      result = 0;
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v2));
  if ((currentWriteBufferFull(a1) & 0x80000000) == 0)
  {
    if ((SharedArrayEnqueue_0(a1, -2) & 0x80000000) == 0)
      return 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"sendEOF", 351, 73, 0, "SharedArrayEnqueue", v4, v5, v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t currentWriteBufferFull(unsigned int *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  char vars0;

  v1 = a1[96];
  a1[96] = -1;
  if (v1 > 3 || (SharedArrayEnqueue_0(a1, v1) & 0x80000000) == 0)
    return 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"currentWriteBufferFull", 324, 73, 0, "SharedArrayEnqueue", v2, v3, vars0);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int *v9;
  unsigned int *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (result)
  {
    v9 = (unsigned int *)result;
    v10 = (unsigned int *)(result + 400);
    do
    {
      if (__ldaxr(v10))
      {
        __clrex();
        return result;
      }
    }
    while (__stlxr(1u, v10));
    if ((SharedArrayPush((unsigned int *)(result + 128), -1) & 0x80000000) != 0)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 500, 73, 0, "SharedArrayPush", v12, v13, v16);
    result = SharedArrayEnqueue_0(v9, -1);
    if ((result & 0x80000000) != 0)
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 501, 73, 0, "SharedArrayPush", v14, v15, a9);
  }
  return result;
}

uint64_t SharedBufferFlushToStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  uint64_t v6;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  const char *v38;
  __int16 v39;
  char v41;
  unsigned int *v42;
  unsigned int *v43;
  size_t v44;

  if (!a2)
    return -1;
  if (atomic_load((unsigned int *)(a1 + 400)))
    return -1;
  if (atomic_load((unsigned int *)(a1 + 396)))
    return 0;
  v11 = a2;
  v6 = 0;
  v44 = a1 + 256;
  v42 = (unsigned int *)(a1 + 396);
  v43 = (unsigned int *)(a1 + 128);
  while (1)
  {
    v12 = *(unsigned int *)(a1 + 388);
    if (v12 < 4)
      goto LABEL_17;
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    {
      v35 = "SharedArrayPop: pthread_mutex_lock failed\n";
      v36 = 91;
      goto LABEL_26;
    }
    while (!*(_DWORD *)a1)
    {
      if (pthread_cond_wait((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16)))
      {
        v35 = "SharedArrayPop: pthread_cond_wait failed\n";
        v36 = 94;
        goto LABEL_26;
      }
    }
    v16 = *(_DWORD *)a1 - 1;
    *(_DWORD *)a1 = v16;
    v12 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v16);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
    {
      v35 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      v36 = 98;
LABEL_26:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v36, 0, v35, v13, v14, v15, v41);
      v37 = "SharedBufferFlushToStream";
      v38 = "SharedArrayDequeue";
      v39 = 448;
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)v37, v39, 73, 0, v38, v30, v31, v41);
LABEL_28:
      SharedBufferAbort(a1, v17, v18, v19, v20, v13, v14, v15, v41);
      return -1;
    }
    if (v12 == 4294967294)
      break;
    if (v12 > 3)
      goto LABEL_28;
    *(_DWORD *)(a1 + 388) = v12;
LABEL_17:
    v21 = v44 + 32 * v12;
    v23 = (_QWORD *)(v21 + 24);
    v22 = *(_QWORD *)(v21 + 24);
    v26 = *(_QWORD *)(v21 + 16);
    v25 = (_QWORD *)(v21 + 16);
    v24 = v26;
    v27 = v22 - v26;
    if (v27 >= v11)
      v28 = v11;
    else
      v28 = v27;
    v29 = a3(a4, *(_QWORD *)(v44 + 32 * v12) + v24, v28);
    if (v29 <= 0)
    {
      v37 = "SharedBufferFlushToStream";
      v38 = "stream write";
      v39 = 469;
      goto LABEL_27;
    }
    v32 = v29;
    v33 = *v25 + v29;
    *v25 = v33;
    if (v33 == *v23)
    {
      v34 = *(_DWORD *)(a1 + 388);
      *(_DWORD *)(a1 + 388) = -1;
      if (v34 <= 3 && (SharedArrayPush(v43, v34) & 0x80000000) != 0)
      {
        v37 = "currentReadBufferEmpty";
        v38 = "SharedArrayPush";
        v39 = 337;
        goto LABEL_27;
      }
    }
    v6 += v32;
    v11 -= v32;
    if (!v11)
      return v6;
  }
  while (!__ldaxr(v42))
  {
    if (!__stlxr(1u, v42))
      return v6;
  }
  __clrex();
  return v6;
}

uint64_t SharedArrayEnqueue_0(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 157;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    if (v10 >= v11)
    {
      v12 = *a1;
    }
    else
    {
      if ((_DWORD)v10)
        memmove((void *)(*((_QWORD *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      **((_DWORD **)a1 + 1) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 168;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 169;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedBufferWrite(unsigned int *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;

  if (atomic_load(a1 + 100))
    return -1;
  if (!a3)
    return (int)sendEOF(a1);
  v10 = a2;
  return SharedBufferFillFromStream((size_t)a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferReadFromBufferProc, (uint64_t)&v10, a5, a6, a7, a8);
}

size_t SharedBufferReadFromBufferProc(const void **a1, void *__dst, size_t a3)
{
  memcpy(__dst, *a1, a3);
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t SharedBufferRead(size_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;

  if (atomic_load((unsigned int *)(a1 + 400)))
    return -1;
  v5 = a2;
  return SharedBufferFlushToStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferWriteToBufferProc, (uint64_t)&v5);
}

size_t SharedBufferWriteToBufferProc(void **a1, const void *a2, size_t a3)
{
  memcpy(*a1, a2, a3);
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t *AARemoveArchiveOutputStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads;
  uint64_t *v10;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  __int16 v22;
  int v23;
  const char *v24;
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v37;
  char v38;
  stat v39;

  DefaultNThreads = a5;
  if (!a5)
    DefaultNThreads = getDefaultNThreads();
  v10 = (uint64_t *)malloc(0x38uLL);
  v11 = v10;
  if (v10)
    memset_s(v10, 0x38uLL, 0, 0x38uLL);
  memset(&v39, 0, sizeof(v39));
  v12 = malloc(0x478uLL);
  v13 = (uint64_t)v12;
  if (v12 && (memset_s(v12, 0x478uLL, 0, 0x478uLL), v11))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v13))
    {
      if (stat((const char *)v13, &v39) || (v39.st_mode & 0xF000) != 0x4000)
      {
        v38 = (char)a1;
        v27 = "Invalid directory: %s";
        v28 = 393;
        goto LABEL_24;
      }
      *(_QWORD *)(v13 + 1024) = a4;
      *(_QWORD *)(v13 + 1032) = a2;
      *(_QWORD *)(v13 + 1040) = a3;
      *(double *)(v13 + 1048) = getRealTime();
      *(_DWORD *)(v13 + 1120) = DefaultNThreads;
      v16 = StringTableCreate();
      *(_QWORD *)(v13 + 1088) = v16;
      if (!v16)
      {
        v27 = "string table creation";
        v28 = 402;
        goto LABEL_24;
      }
      v17 = calloc(*(unsigned int *)(v13 + 1120), 8uLL);
      *(_QWORD *)(v13 + 1128) = v17;
      if (v17)
      {
        if (*(_DWORD *)(v13 + 1120))
        {
          v18 = 0;
          while (1)
          {
            v19 = malloc(0x1040uLL);
            v20 = (uint64_t)v19;
            if (v19)
            {
              memset_s(v19, 0x1040uLL, 0, 0x1040uLL);
              *(_DWORD *)(v20 + 2064) = -1;
              *(_QWORD *)v20 = v13;
              v21 = StringTableCreate();
              *(_QWORD *)(v20 + 2072) = v21;
              if (v21)
                goto LABEL_19;
              v22 = 82;
              v23 = 0;
              v24 = "StringTableCreate";
            }
            else
            {
              v23 = *__error();
              v22 = 78;
              v24 = "malloc";
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerCreate", v22, 123, v23, v24, v14, v15, v38);
            workerDestroy(v20);
            v20 = 0;
LABEL_19:
            *(_QWORD *)(*(_QWORD *)(v13 + 1128) + 8 * v18) = v20;
            v25 = *(_QWORD *)(v13 + 1128);
            if (!*(_QWORD *)(v25 + 8 * v18))
            {
              v27 = "creating new worker";
              v28 = 410;
              goto LABEL_24;
            }
            ++v18;
            v17 = (void *)*(unsigned int *)(v13 + 1120);
            if (v18 >= (unint64_t)v17)
              goto LABEL_31;
          }
        }
        v25 = (uint64_t)v17;
        LODWORD(v17) = 0;
LABEL_31:
        v37 = ThreadPoolCreate(v17, v25, (uint64_t)workerProc_1);
        *(_QWORD *)(v13 + 1136) = v37;
        if (v37)
        {
          v11[3] = (uint64_t)removeStreamWriteHeader;
          v11[4] = (uint64_t)removeStreamWriteBlob;
          *v11 = v13;
          v11[1] = (uint64_t)removeStreamClose;
          v11[2] = (uint64_t)removeStreamAbort;
          return v11;
        }
        v27 = "ThreadPoolCreate";
        v28 = 415;
LABEL_24:
        v26 = 0;
      }
      else
      {
        v26 = *__error();
        v27 = "malloc";
        v28 = 406;
      }
    }
    else
    {
      v26 = *__error();
      v38 = (char)a1;
      v27 = "%s";
      v28 = 392;
    }
  }
  else
  {
    v26 = *__error();
    v27 = "malloc";
    v28 = 391;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"AARemoveArchiveOutputStreamOpen", v28, 123, v26, v27, v14, v15, v38);
  free(v11);
  removeStreamClose(v13, v29, v30, v31, v32, v33, v34, v35);
  return 0;
}

uint64_t workerProc_1(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  unsigned int *v12;
  char v15;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)(a1 + 2080))
  {
    v3 = 0;
    v4 = (unsigned int *)(a1 + 2088);
    while ((processEntry(a1, v4, *(_QWORD *)(a1 + 2072)) & 0x80000000) == 0)
    {
      ++v3;
      v4 += 2;
      if (v3 >= *(_QWORD *)(a1 + 2080))
        goto LABEL_5;
    }
    v11 = 185;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerProc", v11, 123, 0, "entry failed", v5, v6, v15);
    v12 = (unsigned int *)(v2 + 1056);
    while (!__ldaxr(v12))
    {
      if (!__stlxr(1u, v12))
        return 0;
    }
    __clrex();
  }
  else
  {
LABEL_5:
    v7 = *(_QWORD *)(a1 + 4136);
    v8 = *(_QWORD *)(a1 + 4144);
    if (v7 < v8)
    {
      v9 = 8 * v7;
      do
      {
        v10 = *(_QWORD *)(v2 + 1112) + v9;
        if (*(_DWORD *)(a1 + 4152) == *(unsigned __int16 *)(v10 + 6))
        {
          if ((processEntry(a1, (unsigned int *)v10, *(_QWORD *)(v2 + 1088)) & 0x80000000) != 0)
          {
            v11 = 193;
            goto LABEL_14;
          }
          v8 = *(_QWORD *)(a1 + 4144);
        }
        ++v7;
        v9 += 8;
      }
      while (v7 < v8);
    }
  }
  return 0;
}

uint64_t removeStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t Worker;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  __int16 v28;
  const char *v29;
  void *v30;
  unint64_t v31;
  double v32;
  FILE **v33;
  FILE *v34;
  unint64_t v35;
  FILE *v36;
  unint64_t v37;
  char v38;

  if (result)
  {
    v8 = result;
    v9 = *(_QWORD *)(result + 1024);
    if (atomic_load((unsigned int *)(result + 1056)))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", 314, 123, 0, "stream cancelled", a7, a8, v38);
      v11 = 0;
    }
    else
    {
      v11 = 1;
    }
    v12 = *(_QWORD *)(v8 + 1080);
    if (v12)
    {
      if ((ThreadPoolRunWorker(*(_QWORD *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", 319, 123, 0, "ThreadPoolRunWorker", a7, a8, v38);
        v11 = 0;
      }
      *(_QWORD *)(v8 + 1080) = 0;
    }
    v13 = *(_QWORD *)(v8 + 1104);
    if (v13)
    {
      v14 = 0;
      v15 = (unsigned __int16 *)(*(_QWORD *)(v8 + 1112) + 6);
      v16 = (v13 + (unint64_t)*(unsigned int *)(v8 + 1120) - 1) / (4 * *(_DWORD *)(v8 + 1120));
      do
      {
        v18 = *v15;
        v15 += 4;
        v17 = v18;
        if (v18 > v14)
          v14 = v17;
        --v13;
      }
      while (v13);
      v19 = v16 <= 0xC8 ? 200 : v16;
      if (v11)
      {
        while (1)
        {
          if (*(_QWORD *)(v8 + 1104))
          {
            v20 = 0;
            while (1)
            {
              Worker = ThreadPoolGetWorker(*(_QWORD *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8);
              if (!Worker)
              {
                v28 = 335;
                v29 = "ThreadPoolGetWorker";
                goto LABEL_28;
              }
              *(_QWORD *)(Worker + 2080) = 0;
              *(_QWORD *)(Worker + 4136) = v20;
              v20 += v19;
              v26 = *(_QWORD *)(v8 + 1104);
              if (v20 < v26)
                v26 = v20;
              *(_QWORD *)(Worker + 4144) = v26;
              *(_DWORD *)(Worker + 4152) = v14;
              if ((ThreadPoolRunWorker(*(_QWORD *)(v8 + 1136), Worker, v22, v23, v24, v25, a7, a8) & 0x80000000) != 0)
                break;
              if (v20 >= *(_QWORD *)(v8 + 1104))
                goto LABEL_25;
            }
            v28 = 340;
            v29 = "ThreadPoolRunWorker";
LABEL_28:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", v28, 123, 0, v29, a7, a8, v38);
            v11 = 0;
            v27 = 1;
          }
          else
          {
LABEL_25:
            v27 = 0;
            v11 = 1;
          }
          ThreadPoolSync(*(unsigned int **)(v8 + 1136));
          if (!v14)
            break;
          --v14;
          if ((v27 & 1) != 0)
          {
            v11 = 0;
            break;
          }
        }
      }
    }
    ThreadPoolDestroy(*(_QWORD *)(v8 + 1136));
    v30 = *(void **)(v8 + 1128);
    if (v30)
    {
      if (*(_DWORD *)(v8 + 1120))
      {
        v31 = 0;
        do
          workerDestroy(*(_QWORD *)(*(_QWORD *)(v8 + 1128) + 8 * v31++));
        while (v31 < *(unsigned int *)(v8 + 1120));
        v30 = *(void **)(v8 + 1128);
      }
      free(v30);
    }
    StringTableDestroy(*(void ***)(v8 + 1088));
    free(*(void **)(v8 + 1112));
    if (v11 && v9 >> 62)
    {
      v32 = getRealTime() - *(double *)(v8 + 1048);
      v33 = (FILE **)MEMORY[0x24BDAC8D8];
      fwrite("Remove archive\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      v34 = *v33;
      v35 = atomic_load((unint64_t *)(v8 + 1064));
      fprintf(v34, "%12llu entries removed\n", v35);
      v36 = *v33;
      v37 = atomic_load((unint64_t *)(v8 + 1072));
      fprintf(v36, "%12llu entries skipped\n", v37);
      fprintf(*v33, "%12.2f time (s)\n", v32);
    }
    free((void *)v8);
    if (v11)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t removeStreamWriteHeader(uint64_t a1, AAHeader header)
{
  AAFieldKey v7;
  uint32_t KeyIndex;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  AAFieldKey v12;
  uint32_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(_QWORD, uint64_t, char *, AAHeader);
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  int v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  uint64_t Worker;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  void *v44;
  size_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _WORD *v53;
  int v54;
  __int16 v55;
  unsigned __int8 *v56;
  int v57;
  int v58;
  char v59;
  int v60;
  int v61;
  uint64_t value;
  size_t length[128];
  char __s;
  _BYTE v65[1031];

  *(_QWORD *)&v65[1023] = *MEMORY[0x24BDAC8D0];
  value = -1;
  if (atomic_load((unsigned int *)(a1 + 1056)))
    return 0xFFFFFFFFLL;
  v7.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(header, v7);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    v25 = "AA entry missing TYP field";
    v26 = 215;
LABEL_21:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamWriteHeader", v26, 123, v25, v9, v10, v11, v59);
    goto LABEL_22;
  }
  if (value == 77)
    goto LABEL_22;
  length[0] = 0;
  v12.ikey = 5521744;
  v13 = AAHeaderGetKeyIndex(header, v12);
  if ((v13 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v13, 0x400uLL, &__s, length) >= 2)
  {
    v25 = "AA entry missing/invalid PAT field";
    v26 = 224;
    goto LABEL_21;
  }
  v18 = *(uint64_t (**)(_QWORD, uint64_t, char *, AAHeader))(a1 + 1040);
  if (v18)
  {
    v19 = v18(*(_QWORD *)(a1 + 1032), 80, &__s, header);
    if (v19 < 0)
    {
      v28 = "user cancelled";
      v29 = 234;
      goto LABEL_49;
    }
    if (v19)
    {
LABEL_22:
      v27 = 1;
      goto LABEL_23;
    }
    v20 = (*(uint64_t (**)(_QWORD, uint64_t, char *, size_t *))(a1 + 1040))(*(_QWORD *)(a1 + 1032), 81, &__s, length);
    if (v20 < 0)
    {
      v28 = "user cancelled";
      v29 = 239;
      goto LABEL_49;
    }
    if (v20)
      __strlcpy_chk();
  }
  if (value != 68)
  {
    v30 = *(_QWORD *)(a1 + 1080);
    if (!v30)
    {
      Worker = ThreadPoolGetWorker(*(_QWORD *)(a1 + 1136), v14, v15, v16, v17, v9, v10, v11);
      *(_QWORD *)(a1 + 1080) = Worker;
      if (!Worker)
      {
        v28 = "ThreadPoolGetWorker";
        v29 = 269;
        goto LABEL_49;
      }
      v30 = Worker;
      *(_QWORD *)(Worker + 2080) = 0;
      StringTableClear(*(_QWORD *)(Worker + 2072));
      *(_OWORD *)(v30 + 4136) = 0u;
      *(_DWORD *)(v30 + 4152) = -1;
    }
    v60 = 0;
    v32 = strlen(&__s);
    if ((StringTableAppend(*(unsigned int **)(v30 + 2072), &__s, v32, &v60, v33, v34, v35, v36) & 0x80000000) != 0)
    {
      v28 = "StringTableAppend";
      v29 = 278;
      goto LABEL_49;
    }
    v41 = *(_QWORD *)(v30 + 2080);
    v42 = v30 + 8 * v41++;
    *(_QWORD *)(v30 + 2080) = v41;
    *(_DWORD *)(v42 + 2088) = v60;
    *(_WORD *)(v42 + 2092) = value;
    *(_WORD *)(v42 + 2094) = 0;
    if (v41 == 256)
    {
      if ((ThreadPoolRunWorker(*(_QWORD *)(a1 + 1136), v30, v37, v38, v39, v40, v10, v11) & 0x80000000) != 0)
      {
        v28 = "ThreadPoolRunWorker";
        v29 = 287;
        goto LABEL_49;
      }
      *(_QWORD *)(a1 + 1080) = 0;
    }
    goto LABEL_22;
  }
  v21 = *(_QWORD *)(a1 + 1104);
  if (v21 == *(_QWORD *)(a1 + 1096))
  {
    v22 = 2 * v21;
    v23 = v21 == 0;
    v24 = 256;
    if (!v23)
      v24 = v22;
    *(_QWORD *)(a1 + 1096) = v24;
    if ((unint64_t)(8 * v24) >= 0x2000000001)
    {
      *__error() = 12;
LABEL_52:
      *(_QWORD *)(a1 + 1096) = 0;
      *(_QWORD *)(a1 + 1104) = 0;
      *(_QWORD *)(a1 + 1112) = 0;
      v58 = *__error();
      v28 = "malloc";
      v29 = 250;
      goto LABEL_50;
    }
    v43 = *(void **)(a1 + 1112);
    v44 = realloc(v43, 8 * v24);
    if (!v44)
    {
      free(v43);
      goto LABEL_52;
    }
    *(_QWORD *)(a1 + 1112) = v44;
  }
  v61 = 0;
  v45 = strlen(&__s);
  if ((StringTableAppend(*(unsigned int **)(a1 + 1088), &__s, v45, &v61, v46, v47, v48, v49) & 0x80000000) == 0)
  {
    v50 = *(_QWORD *)(a1 + 1112);
    v51 = *(_QWORD *)(a1 + 1104);
    *(_QWORD *)(a1 + 1104) = v51 + 1;
    v52 = v50 + 8 * v51;
    *(_DWORD *)v52 = v61;
    *(_WORD *)(v52 + 4) = value;
    *(_WORD *)(v52 + 6) = 0;
    v53 = (_WORD *)(v52 + 6);
    v54 = __s;
    if (__s)
    {
      v55 = 0;
      v56 = v65;
      do
      {
        if (v54 == 47)
          ++v55;
        *v53 = v55;
        v57 = *v56++;
        v54 = v57;
      }
      while (v57);
    }
    goto LABEL_22;
  }
  v28 = "StringTableAppend";
  v29 = 253;
LABEL_49:
  v58 = 0;
LABEL_50:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamWriteHeader", v29, 123, v58, v28, v10, v11, v59);
  v27 = 0;
LABEL_23:
  if (v27)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t removeStreamWriteBlob(uint64_t a1)
{
  if (atomic_load((unsigned int *)(a1 + 1056)))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t removeStreamAbort(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 1056);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

void workerDestroy(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 2064);
    if ((v2 & 0x80000000) == 0)
      close(v2);
    StringTableDestroy(*(void ***)(a1 + 2072));
    free((void *)a1);
  }
}

uint64_t processEntry(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  int v16;
  char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v23;
  int v24;
  int v25;
  _BOOL4 v26;
  _BOOL4 v27;
  uint64_t (*v28)(_QWORD, uint64_t, const char *, _QWORD);
  int v29;
  uint64_t (*v30)(_QWORD, uint64_t, const char *, _QWORD);
  int v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t (*v36)(_QWORD, uint64_t, const char *, _QWORD);
  int v37;
  char v38;
  stat v39;
  char __s[1024];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  memset(&v39, 0, sizeof(v39));
  v5 = *(char **)a1;
  v6 = (const char *)(*(_QWORD *)(a3 + 32) + *(_QWORD *)(*(_QWORD *)(a3 + 8) + 16 * *a2));
  if ((concatPath(__s, 0x400uLL, *(char **)a1, v6) & 0x80000000) != 0)
  {
    v17 = "invalid path";
    v18 = 114;
LABEL_11:
    v19 = 0;
    goto LABEL_12;
  }
  v9 = strrchr(__s, 47);
  if (!v9)
  {
    v17 = "invalid path";
    v18 = 118;
    goto LABEL_11;
  }
  v10 = v9;
  *v9 = 0;
  v11 = v9 + 1;
  v12 = strlen(__s);
  v15 = v12;
  v16 = *(_DWORD *)(a1 + 2064);
  if ((v16 & 0x80000000) == 0)
  {
    if (v12 == *(_QWORD *)(a1 + 2056) && !strcmp(__s, (const char *)(a1 + 8)))
      goto LABEL_15;
    close(v16);
    *(_DWORD *)(a1 + 2064) = -1;
  }
  if (v15 >= 0x800)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerUpdateDir", 95, 123, 0, "directory path too long", v13, v14, v38);
    goto LABEL_19;
  }
  *(_QWORD *)(a1 + 2056) = v15;
  memcpy((void *)(a1 + 8), __s, v15);
  *(_BYTE *)(a1 + 8 + v15) = 0;
  v23 = open((const char *)(a1 + 8), 0);
  *(_DWORD *)(a1 + 2064) = v23;
  if (v23 < 0)
  {
LABEL_19:
    v28 = (uint64_t (*)(_QWORD, uint64_t, const char *, _QWORD))*((_QWORD *)v5 + 130);
    if (!v28)
      goto LABEL_28;
    v29 = v28(*((_QWORD *)v5 + 129), 82, v6, 0);
    if (!v29)
      goto LABEL_28;
    v26 = 0;
    v27 = v29 >= 0;
    goto LABEL_26;
  }
LABEL_15:
  *v10 = 47;
  if (fstatat(*(_DWORD *)(a1 + 2064), v11, &v39, 32) < 0)
  {
    if (*__error() == 2)
      goto LABEL_19;
    v19 = *__error();
    v17 = __s;
    v18 = 128;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"processEntry", v18, 123, v19, v17, v7, v8, v38);
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"processEntry", 167, 123, 0, "Entry failed: %s", v20, v21, (char)v6);
    return 0xFFFFFFFFLL;
  }
  v24 = aaEntryTypeFromMode(v39.st_mode);
  v25 = *((unsigned __int16 *)a2 + 2);
  if (v24 == v25)
  {
    v26 = 0;
    v27 = 1;
  }
  else
  {
    v30 = (uint64_t (*)(_QWORD, uint64_t, const char *, _QWORD))*((_QWORD *)v5 + 130);
    if (!v30)
      goto LABEL_28;
    v31 = v30(*((_QWORD *)v5 + 129), 83, v6, 0);
    v26 = v31 == 0;
    v27 = v31 >= 0;
    if (v31 < 1)
      goto LABEL_26;
    v25 = *((unsigned __int16 *)a2 + 2);
  }
  if (unlinkat(*(_DWORD *)(a1 + 2064), v11, (v25 == 68) << 7) < 0)
  {
    v36 = (uint64_t (*)(_QWORD, uint64_t, const char *, _QWORD))*((_QWORD *)v5 + 130);
    if (v36)
    {
      v37 = v36(*((_QWORD *)v5 + 129), 84, v6, 0);
      if (!v37)
        v26 = 1;
      if (v37 < 0)
        goto LABEL_13;
    }
    else
    {
      v26 = 1;
    }
  }
LABEL_26:
  if (!v27)
    goto LABEL_13;
  if (!v26)
  {
    v34 = (unint64_t *)(v5 + 1064);
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
    return 0;
  }
LABEL_28:
  v32 = (unint64_t *)(v5 + 1072);
  do
    v33 = __ldxr(v32);
  while (__stxr(v33 + 1, v32));
  return 0;
}

uint64_t AEADecryptToFileChunk(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, unsigned int a9)
{
  int v9;
  uint64_t (**v11)(void);
  uint64_t v12;
  uint64_t v13;
  uint64_t (**v14)(void);
  int Range;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  int v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  char v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD v29[4];
  uint64_t v30;

  v9 = a8;
  v30 = 0;
  v29[0] = a2;
  v29[1] = a4;
  v29[2] = a5;
  v29[3] = a8 >> 62;
  LODWORD(v30) = a1[10] != 0;
  v11 = (uint64_t (**)(void))AEADecryptToFileChunkAsyncStreamOpen(a3, (uint64_t)v29, (uint64_t)asyncContext_0, (uint64_t)asyncProgress_0, a6, a7, a8, a9);
  v14 = v11;
  if (!v11)
  {
    v18 = "AEADecryptToFileAsyncStreamOpen";
    v19 = 87;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", v19, 56, 0, v18, v12, v13, v26);
    v20 = 0;
    goto LABEL_19;
  }
  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(v11, a1, v9, a9) & 0x8000000000000000) == 0)
    {
      v20 = 1;
      goto LABEL_19;
    }
    v18 = "AAAsyncByteStreamProcessAllRanges";
    v19 = 115;
    goto LABEL_18;
  }
  while (1)
  {
    v27 = 0;
    v28 = 0;
    Range = AAAsyncByteStreamGetRange(v14, &v28, &v27);
    if (Range < 0)
      break;
    if (Range)
    {
      if (!v28)
      {
        v20 = 1;
        goto LABEL_16;
      }
      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        v21 = "AAByteStreamPReadAsync";
        v22 = 104;
        goto LABEL_15;
      }
    }
    else
    {
      usleep(0x186A0u);
    }
  }
  v21 = "AAAsyncByteStreamGetRange";
  v22 = 99;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", v22, 56, 0, v21, v16, v17, v26);
  v20 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    v18 = "AAByteStreamPReadAsync barrier";
    v19 = 109;
    goto LABEL_18;
  }
LABEL_19:
  if ((AAAsyncByteStreamClose(v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", 119, 56, 0, "AAAsyncByteStreamClose", v23, v24, v26);
    v20 = 0;
  }
  if (v20)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t asyncContext_0(uint64_t result, _OWORD *context)
{
  _DWORD *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  FILE **v8;
  FILE *v9;
  int FieldUInt;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  FILE *v17;
  unsigned int v18;
  const char *v19;
  FILE *v20;
  uint64_t v21;
  FILE *v22;
  uint64_t v23;
  const char *v24;

  v3 = (_DWORD *)result;
  v4 = *(_QWORD *)result;
  if (*(_DWORD *)(result + 28))
  {
    *(_OWORD *)v4 = *context;
    v5 = context[1];
    v6 = context[2];
    v7 = context[3];
    *(_QWORD *)(v4 + 64) = *((_QWORD *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 24))
    {
      v8 = (FILE **)MEMORY[0x24BDAC8D8];
      v9 = (FILE *)*MEMORY[0x24BDAC8D8];
      FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            v15 = "none";
            goto LABEL_25;
          case 256:
            v15 = "lz4";
            goto LABEL_25;
          case 774:
            v15 = "lzma";
LABEL_25:
            v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            v17 = *v8;
            v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2)
              v19 = "???";
            else
              v19 = off_24C305BC0[v18];
            fprintf(v17, "  checksum: %s\n", v19);
            v20 = *v8;
            v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            v22 = *v8;
            v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            if (v3[8])
              v24 = "yes";
            else
              v24 = "no";
            fprintf(*v8, "  async read stream: %s\n", v24);
            return 0;
        }
      }
      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            v15 = "zlib";
            goto LABEL_25;
          }
          if (FieldUInt != 1794)
            goto LABEL_24;
          goto LABEL_20;
        }
        if (FieldUInt == 2049)
        {
LABEL_20:
          v15 = "lzfse";
          goto LABEL_25;
        }
        if (FieldUInt == 2304)
        {
          v15 = "lzvn";
          goto LABEL_25;
        }
      }
LABEL_24:
      v15 = "???";
      goto LABEL_25;
    }
    return 0;
  }
  v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    v12 = *(unsigned int *)(*(_QWORD *)v3 + 72);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(_QWORD *)v3 + 76), *(unsigned int *)(*(_QWORD *)v3 + 72));
      *((_DWORD *)context + 18) = v12;
      result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      v13 = *(unsigned int *)(*(_QWORD *)v3 + 2152);
      if (v13 < 0x101)
      {
        memcpy((char *)context + 2156, (const void *)(*(_QWORD *)v3 + 2156), *(unsigned int *)(*(_QWORD *)v3 + 2152));
        *((_DWORD *)context + 538) = v13;
        result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        v14 = *(unsigned int *)(*(_QWORD *)v3 + 332);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(_QWORD *)v3 + 336), *(unsigned int *)(*(_QWORD *)v3 + 332));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[7] = 1;
          return 0;
        }
      }
    }
  }
  __break(1u);
  return result;
}

uint64_t asyncProgress_0(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(a1 + 16);
  if (v1)
    return v1(*(_QWORD *)(a1 + 8));
  else
    return 0;
}

uint64_t AEADecryptToFile(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  return AEADecryptToFileChunk(a1, a2, a3, a4, a5, 0, 0, a6, a7);
}

uint64_t aaCompositeChunkAsyncStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v5;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (**v15)(void);
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  const char *v20;
  __int16 v21;
  char v23;

  v5 = a1;
  if (a1 && a2)
  {
    v10 = malloc(0x10uLL);
    v11 = (uint64_t)v10;
    if (v10)
    {
      memset_s(v10, 0x10uLL, 0, 0x10uLL);
      *(_QWORD *)v11 = v5;
      v15 = AAChunkAsyncStreamOpen(v5, a2, a3, a4 | 0x200000000000000, a5, v12, v13, v14);
      *(_QWORD *)(v11 + 8) = v15;
      if (v15)
      {
        v18 = aaAsyncByteStreamAlloc(v11, (uint64_t)compositeChunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
        if (v18)
        {
          v5 = (uint64_t)v18;
          v18[2] = compositeChunkAsyncGetRange;
          v18[3] = compositeChunkAsyncProcess;
          v18[4] = compositeChunkAsyncCancel;
          v18[5] = compositeChunkAsyncIsCancelled;
          return v5;
        }
        v20 = "async stream alloc";
        v21 = 89;
      }
      else
      {
        v20 = "AAChunkAsyncStreamOpen";
        v21 = 86;
      }
      v19 = 0;
    }
    else
    {
      v19 = *__error();
      v20 = "malloc";
      v21 = 78;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompositeChunkAsyncStream.c", (uint64_t)"aaCompositeChunkAsyncStreamOpen", v21, 145, v19, v20, v16, v17, v23);
    compositeChunkAsyncClose((uint64_t (***)(void))v11);
    AAAsyncByteStreamClose(0);
    return 0;
  }
  return v5;
}

uint64_t (***compositeChunkAsyncClose(uint64_t (***result)(void)))(void)
{
  uint64_t (***v1)(void);
  int v2;
  int v3;

  if (result)
  {
    v1 = result;
    v2 = AAAsyncByteStreamClose(result[1]);
    v3 = AAAsyncByteStreamClose(*v1) | v2;
    free(v1);
    return (uint64_t (***)(void))(v3 >> 31);
  }
  return result;
}

uint64_t compositeChunkAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*(_QWORD **)(a1 + 8), a2, a3);
}

uint64_t compositeChunkAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(_QWORD *)(a1 + 8), a2, a3, a4);
}

_QWORD *compositeChunkAsyncCancel(uint64_t a1)
{
  return AAAsyncByteStreamCancel(*(_QWORD **)(a1 + 8));
}

uint64_t compositeChunkAsyncIsCancelled(uint64_t a1)
{
  return aaAsyncByteStreamIsCancelled(*(_QWORD **)(a1 + 8));
}

void aeaContainerDestroy(uint64_t a1)
{
  void *v2;
  void *v3;

  if (a1)
  {
    v2 = *(void **)(a1 + 384);
    if (v2)
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    free(v2);
    v3 = *(void **)(a1 + 392);
    if (v3)
      memset_s(*(void **)(a1 + 392), 544 * *(unsigned int *)(a1 + 400), 0, 544 * *(unsigned int *)(a1 + 400));
    free(v3);
    memset_s((void *)a1, 0x6C0uLL, 0, 0x6C0uLL);
    free((void *)a1);
  }
}

uint64_t aeaContainerCreateNew(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  void *v9;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  int v16;
  unsigned int v17;
  char v19;

  v2 = malloc(0x6C0uLL);
  v3 = (uint64_t)v2;
  if (!v2)
  {
    v14 = *__error();
    v12 = "malloc";
    v13 = 22;
    goto LABEL_28;
  }
  memset_s(v2, 0x6C0uLL, 0, 0x6C0uLL);
  v4 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v3 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v3 + 48) = v4;
  *(_QWORD *)(v3 + 64) = *(_QWORD *)(a1 + 64);
  v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v3 = *(_OWORD *)a1;
  *(_OWORD *)(v3 + 16) = v5;
  if ((aeaCryptoInit((char *)(v3 + 72), (unsigned int *)v3) & 0x80000000) != 0)
  {
    v12 = "Invalid context";
    v13 = 28;
    goto LABEL_27;
  }
  v8 = *(unsigned int *)(v3 + 4);
  if ((_DWORD)v8)
  {
    v9 = malloc(*(unsigned int *)(v3 + 4));
    *(_QWORD *)(v3 + 384) = v9;
    if (v9)
    {
      memcpy(v9, *(const void **)(a1 + 2712), v8);
      goto LABEL_6;
    }
    v14 = *__error();
    v12 = "malloc";
    v13 = 34;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateNew", v13, 28, v14, v12, v6, v7, v19);
    aeaContainerDestroy(v3);
    return 0;
  }
LABEL_6:
  if (*(_DWORD *)v3 <= 5u && ((1 << *(_DWORD *)v3) & 0x2A) != 0)
    goto LABEL_10;
  if (*(_DWORD *)(a1 + 592))
  {
    v15 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 240);
    if (!v15)
      goto LABEL_23;
    v16 = v15(a1 + 332, a1 + 592);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104) || v16 < 0)
      goto LABEL_23;
    v17 = *(_DWORD *)(a1 + 592);
    if (v17 >= 0x101)
    {
      __break(1u);
LABEL_23:
      v12 = "Invalid signing private key in context";
      v13 = 45;
      goto LABEL_27;
    }
  }
  else
  {
    v17 = 0;
  }
  __memcpy_chk();
  *(_DWORD *)(v3 + 1188) = v17;
  memset_s((void *)(v3 + 1192 + v17), 256 - v17, 0, 256 - v17);
  *(_OWORD *)(v3 + 1712) = *(_OWORD *)(a1 + 2416);
  if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104))
  {
    v12 = "Invalid signing public key in context";
    v13 = 55;
    goto LABEL_27;
  }
LABEL_10:
  if ((aeaContainerOffsetsInit(v3 + 280, (unsigned int *)v3, (unsigned int *)(v3 + 72)) & 0x80000000) != 0)
  {
    v12 = "deriving container offsets";
    v13 = 59;
    goto LABEL_27;
  }
  v11 = *(_QWORD *)(v3 + 344);
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = v11;
  if ((aeaDeriveMainKeyNew((unsigned int *)(v3 + 72), (int *)v3, (__int128 *)(v3 + 668), (int *)(v3 + 928), (char *)(v3 + 408), (int *)(a1 + 72), (_DWORD *)(a1 + 2152), (unsigned int *)(a1 + 332), (unsigned int *)(a1 + 852)) & 0x80000000) != 0)
  {
    v12 = "Main key derivation";
    v13 = 75;
LABEL_27:
    v14 = 0;
    goto LABEL_28;
  }
  return v3;
}

uint64_t aeaContainerCreateExisting(uint64_t a1, AAByteStream_impl *a2, int a3, int a4)
{
  void *v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  off_t v18;
  size_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  char *v23;
  char *v24;
  unint64_t v25;
  const char *v26;
  __int16 v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v36;
  unsigned int v37;
  int v38;
  size_t v39;
  void *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t (*v47)(__int128 *, _QWORD, _DWORD *, _BYTE *, _OWORD *);
  int v48;
  int v49;
  uint64_t (*v50)(_OWORD *, _QWORD, __int128 *, _OWORD *, _BYTE *);
  int v51;
  uint64_t (*v52)(char *, _QWORD, _OWORD *, _OWORD *, char *, _QWORD);
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  uint64_t (*v73)(_BYTE *, _QWORD, _DWORD *, _OWORD *, __int128 *);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t (*v83)(uint64_t, char *, uint64_t);
  const char *v84;
  __int16 v85;
  uint64_t (*v86)(uint64_t, _BYTE *);
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char v90;
  size_t v91;
  unsigned int *v92;
  AAByteStream_impl *v93;
  unint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  _OWORD v98[3];
  _OWORD v99[16];
  int v100;
  _OWORD v101[16];
  int v102;
  _OWORD __s[16];
  int v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  int v121;
  _OWORD v122[17];
  _BYTE v123[260];
  uint64_t v124;

  v124 = *MEMORY[0x24BDAC8D0];
  v104 = 0;
  memset(__s, 0, sizeof(__s));
  v102 = 0;
  memset(v101, 0, sizeof(v101));
  v100 = 0;
  memset(v99, 0, sizeof(v99));
  memset(v98, 0, sizeof(v98));
  v8 = malloc(0x6C0uLL);
  v9 = (uint64_t)v8;
  if (!v8)
  {
    v20 = *__error();
    v21 = "malloc";
    v22 = 95;
    goto LABEL_41;
  }
  memset_s(v8, 0x6C0uLL, 0, 0x6C0uLL);
  v10 = (_DWORD *)(v9 + 668);
  if ((aeaContextUnlock(a1, v9, (_DWORD *)(v9 + 668), (_DWORD *)(v9 + 408), a3, a4) & 0x80000000) != 0)
  {
    v21 = "unlocking context";
    v22 = 99;
LABEL_40:
    v20 = 0;
    goto LABEL_41;
  }
  if ((aeaCryptoInit((char *)(v9 + 72), (unsigned int *)v9) & 0x80000000) != 0)
  {
    v21 = "Invalid container";
    v22 = 102;
    goto LABEL_40;
  }
  if ((aeaContainerOffsetsInit(v9 + 280, (unsigned int *)v9, (unsigned int *)(v9 + 72)) & 0x80000000) != 0)
  {
    v21 = "deriving container offsets";
    v22 = 103;
    goto LABEL_40;
  }
  v13 = *(unsigned int *)(v9 + 4);
  if ((_DWORD)v13)
  {
    v14 = malloc(*(unsigned int *)(v9 + 4));
    *(_QWORD *)(v9 + 384) = v14;
    if (v14)
    {
      memcpy(v14, *(const void **)(a1 + 2712), v13);
      goto LABEL_8;
    }
    v20 = *__error();
    v21 = "malloc";
    v22 = 110;
LABEL_41:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v22, 28, v20, v21, v11, v12, v90);
    v19 = 0;
    goto LABEL_42;
  }
LABEL_8:
  if (*(_DWORD *)v9 > 5u || ((1 << *(_DWORD *)v9) & 0x2A) == 0)
  {
    if (*(_DWORD *)(a1 + 592))
    {
      v31 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 240);
      if (!v31)
        goto LABEL_36;
      v32 = v31(a1 + 332, a1 + 592);
      if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104) || v32 < 0)
        goto LABEL_36;
      v33 = *(_DWORD *)(a1 + 592);
      if (v33 >= 0x101)
      {
LABEL_35:
        __break(1u);
LABEL_36:
        v21 = "Invalid signing private key in context";
        v22 = 121;
        goto LABEL_40;
      }
    }
    else
    {
      v33 = 0;
    }
    __memcpy_chk();
    *(_DWORD *)(v9 + 1188) = v33;
    memset_s((void *)(v9 + 1192 + v33), 256 - v33, 0, 256 - v33);
    *(_OWORD *)(v9 + 1712) = *(_OWORD *)(a1 + 2416);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104))
    {
      v21 = "Invalid signing public key in context";
      v22 = 131;
      goto LABEL_40;
    }
  }
  v15 = *(unsigned int *)(v9 + 120);
  if (v15 >= 0x101)
    goto LABEL_35;
  __memcpy_chk();
  *(_DWORD *)(v9 + 928) = v15;
  memset_s((void *)(v9 + 932 + v15), 256 - v15, 0, 256 - v15);
  v16 = *(unsigned int *)(v9 + 84);
  if (v16 >= 0x101)
    goto LABEL_35;
  __memcpy_chk();
  LODWORD(v99[0]) = v16;
  memset_s((char *)v99 + v16 + 4, 256 - v16, 0, 256 - v16);
  v17 = *(unsigned int *)(v9 + 84);
  if (v17 >= 0x101)
    goto LABEL_35;
  __memcpy_chk();
  LODWORD(v101[0]) = v17;
  memset_s((char *)v101 + v17 + 4, 256 - v17, 0, 256 - v17);
  v18 = AAByteStreamSeek(a2, 0, 2);
  if ((v18 & 0x8000000000000000) == 0 && v18 != *(_QWORD *)(v9 + 40))
  {
    v21 = "Container size mismatch";
    v22 = 143;
    goto LABEL_40;
  }
  if (*(_QWORD *)(v9 + 376) <= 0x100000uLL)
    v19 = 0x100000;
  else
    v19 = *(_QWORD *)(v9 + 376);
  if (v19 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_28:
    v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", 151, 28, *v28, "malloc", v29, v30, v90);
LABEL_42:
    v24 = 0;
    goto LABEL_43;
  }
  v23 = (char *)malloc(v19);
  if (!v23)
    goto LABEL_28;
  v24 = v23;
  v25 = (*(_QWORD *)(v9 + 32) + (unint64_t)*(unsigned int *)(v9 + 16) - 1) / *(unsigned int *)(v9 + 16);
  if (HIDWORD(v25))
  {
    v26 = "Invalid sizes in root header";
    v27 = 155;
    goto LABEL_51;
  }
  *(_DWORD *)(v9 + 400) = v25;
  v36 = *(_DWORD *)(v9 + 20);
  v37 = (v25 + v36 - 1) / v36;
  *(_DWORD *)(v9 + 404) = v37;
  if (((v36 * (unint64_t)v37) & 0xFFFFFFFF00000000) != 0)
  {
    v26 = "Invalid sizes in root header";
    v27 = 158;
    goto LABEL_51;
  }
  v39 = v37 * v36;
  if (v39 >= 0xF0F0F10)
  {
    *__error() = 12;
    *(_QWORD *)(v9 + 392) = 0;
LABEL_99:
    v38 = *__error();
    v26 = "malloc";
    v27 = 171;
    goto LABEL_52;
  }
  v40 = calloc(v39, 0x220uLL);
  *(_QWORD *)(v9 + 392) = v40;
  if (!v40)
    goto LABEL_99;
  v91 = v19;
  v41 = *(_QWORD *)(v9 + 344);
  v92 = (unsigned int *)(v9 + 72);
  v93 = a2;
  if (!*(_DWORD *)(v9 + 404))
  {
LABEL_97:
    v69 = *(_QWORD *)(v9 + 40);
    v70 = v41;
    v71 = v69 >= v41;
    v72 = v69 - v41;
    if (!v71)
    {
      v26 = "Invalid container size";
      v27 = 230;
      goto LABEL_51;
    }
    *(_QWORD *)(v9 + 64) = v72;
    if (!v72 || *(_DWORD *)(a1 + 2740))
    {
      v34 = 1;
      goto LABEL_44;
    }
    memset(v123, 0, sizeof(v123));
    memset(v122, 0, 260);
    v121 = 0;
    v120 = 0u;
    v119 = 0u;
    v118 = 0u;
    v117 = 0u;
    v116 = 0u;
    v115 = 0u;
    v114 = 0u;
    v113 = 0u;
    v112 = 0u;
    v111 = 0u;
    v110 = 0u;
    v108 = 0u;
    v109 = 0u;
    v106 = 0u;
    v107 = 0u;
    v105 = 0u;
    if (*(_QWORD *)(v9 + 248)
      && (*(_DWORD *)((char *)v122 + 7) = 1262571615,
          *(_QWORD *)&v122[0] = 0x5F41454100000007,
          memset_s((void *)((unint64_t)v122 | 0xB), 0xF9uLL, 0, 0xF9uLL),
          (v73 = *(uint64_t (**)(_BYTE *, _QWORD, _DWORD *, _OWORD *, __int128 *))(v9 + 144)) != 0)
      && *v10
      && (v73(v123, *v92, v10, v122, &v105) & 0x80000000) == 0)
    {
      v74 = (*(uint64_t (**)(_BYTE *))(v9 + 248))(v123);
    }
    else
    {
      v74 = 0;
    }
    memset_s(v123, 0x104uLL, 0, 0x104uLL);
    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    if (v74)
    {
      while (1)
      {
        if (v72 >= 0x100000)
          v77 = 0x100000;
        else
          v77 = v72;
        if (!*((_QWORD *)v93 + 4))
          goto LABEL_131;
        v78 = 0;
        v79 = v24;
        v80 = v70;
        v81 = v77;
        while (1)
        {
          v82 = (*((uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))v93 + 4))(*(_QWORD *)v93, v79, v81, v80);
          if (v82 < 0)
            break;
          if (v82)
          {
            v79 += v82;
            v78 += v82;
            v80 += v82;
            v81 -= v82;
            if (v81)
              continue;
          }
          goto LABEL_125;
        }
        v78 = v82;
LABEL_125:
        if (v78 != v77)
        {
LABEL_131:
          v84 = "loading padding";
          v85 = 250;
          goto LABEL_142;
        }
        v83 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 256);
        if (!v83 || (v83(v74, v24, v77) & 0x80000000) != 0)
          break;
        v70 += v77;
        v72 -= v77;
        if (!v72)
        {
          v34 = 1;
          goto LABEL_133;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", 252, 28, 0, "authenticating padding", v75, v76, v90);
      v34 = 0;
LABEL_133:
      memset(v123, 0, sizeof(v123));
      v86 = *(uint64_t (**)(uint64_t, _BYTE *))(v9 + 264);
      if (v86)
      {
        if (LODWORD(v99[0]) == *(_DWORD *)(v9 + 84)
          && (v86(v74, v123) & 0x80000000) == 0
          && *(_DWORD *)v123 == *(_DWORD *)(v9 + 84))
        {
          if (*(_DWORD *)v123 < 8u)
            goto LABEL_144;
          v87 = 0;
          v88 = 4;
          do
          {
            v87 |= *(_QWORD *)&v123[v88] ^ *(_QWORD *)((char *)v99 + v88);
            v89 = v88 + 12;
            v88 += 8;
          }
          while (v89 <= *(unsigned int *)v123);
          if (!v87)
          {
LABEL_144:
            memset_s(v123, 0x104uLL, 0, 0x104uLL);
            goto LABEL_143;
          }
        }
      }
      memset_s(v123, 0x104uLL, 0, 0x104uLL);
      v84 = "authenticating padding";
      v85 = 257;
    }
    else
    {
      v84 = "authenticating padding";
      v85 = 241;
    }
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v85, 28, 0, v84, v75, v76, v90);
    v34 = 0;
LABEL_143:
    v19 = v91;
    goto LABEL_44;
  }
  v95 = 0;
  v42 = *(_QWORD *)(v9 + 376);
  v90 = v9 - 100;
  while (1)
  {
    v94 = v41;
    v96 = v42;
    if (*((_QWORD *)a2 + 4))
    {
      v43 = 0;
      if (v42)
      {
        v44 = v24;
        while (1)
        {
          v45 = (*((uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))a2 + 4))(*(_QWORD *)a2, v44, v42, v41);
          if (v45 < 0)
            break;
          if (v45)
          {
            v44 += v45;
            v43 += v45;
            v41 += v45;
            v42 -= v45;
            if (v42)
              continue;
          }
          goto LABEL_67;
        }
        v43 = v45;
      }
    }
    else
    {
      v43 = -1;
    }
LABEL_67:
    if (v43 != v96)
    {
      v26 = "loading cluster header";
      v27 = 183;
      goto LABEL_51;
    }
    v121 = 0;
    v120 = 0u;
    v119 = 0u;
    v118 = 0u;
    v117 = 0u;
    v116 = 0u;
    v115 = 0u;
    v114 = 0u;
    v113 = 0u;
    v112 = 0u;
    v111 = 0u;
    v110 = 0u;
    v108 = 0u;
    v109 = 0u;
    v106 = 0u;
    v107 = 0u;
    v105 = 0u;
    memset(&v123[8], 0, 252);
    memset(v122, 0, 260);
    *(_WORD *)&v123[8] = 19267;
    *(_QWORD *)v123 = 0x5F41454100000006;
    memset_s(&v123[10], 0xFAuLL, 0, 0xFAuLL);
    v46 = *(unsigned int *)v123;
    if (*(_DWORD *)v123 >= 0xFDu)
      goto LABEL_35;
    *(_DWORD *)&v123[*(unsigned int *)v123 + 4] = v95;
    *(_DWORD *)v123 = v46 + 4;
    memset_s(&v123[v46 + 8], 252 - v46, 0, 252 - v46);
    v47 = *(uint64_t (**)(__int128 *, _QWORD, _DWORD *, _BYTE *, _OWORD *))(v9 + 144);
    if (!v47 || !*v10)
    {
      memset_s(v123, 0x104uLL, 0, 0x104uLL);
LABEL_74:
      v49 = 1;
      goto LABEL_75;
    }
    v48 = v47(&v105, *v92, v10, v123, v122);
    memset_s(v123, 0x104uLL, 0, 0x104uLL);
    v49 = 0;
    if (v48 < 0)
      goto LABEL_74;
LABEL_75:
    memset((char *)v122 + 12, 0, 248);
    *(_QWORD *)((char *)v122 + 4) = 0x4B4548435F414541;
    LODWORD(v122[0]) = 8;
    memset_s((char *)v122 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v123, 0, sizeof(v123));
    v50 = *(uint64_t (**)(_OWORD *, _QWORD, __int128 *, _OWORD *, _BYTE *))(v9 + 144);
    if (!v50 || !(_DWORD)v105)
      break;
    v51 = v50(__s, *(unsigned int *)(v9 + 76), &v105, v122, v123);
    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    if (v51 < 0)
      goto LABEL_106;
    memset_s(&v105, 0x104uLL, 0, 0x104uLL);
    if (v49)
      goto LABEL_107;
    v52 = *(uint64_t (**)(char *, _QWORD, _OWORD *, _OWORD *, char *, _QWORD))(v9 + 168);
    if (!v52
      || LODWORD(v99[0]) != *(_DWORD *)(v9 + 84)
      || (v52(v24, *(_QWORD *)(v9 + 360), v99, __s, &v24[*(_QWORD *)(v9 + 360)], *(_QWORD *)(v9 + 376) - *(_QWORD *)(v9 + 360)) & 0x80000000) != 0)
    {
      v26 = "decrypting cluster header";
      v27 = 195;
      goto LABEL_51;
    }
    v53 = *(unsigned int *)(v9 + 84);
    if (v53 >= 0x101)
      goto LABEL_35;
    __memcpy_chk();
    LODWORD(v99[0]) = v53;
    memset_s((char *)v99 + v53 + 4, 256 - v53, 0, 256 - v53);
    LODWORD(v54) = *(_DWORD *)(v9 + 20);
    if ((_DWORD)v54)
    {
      v55 = 0;
      v97 = *(_QWORD *)(v9 + 368);
      v56 = *(_QWORD *)(v9 + 352);
      do
      {
        v57 = v55 + v95 * v54;
        if (v57 >= *(_DWORD *)(v9 + 400))
        {
          v42 = *(_QWORD *)(v9 + 376);
          a2 = v93;
          v41 = v42 + v94;
          v10 = (_DWORD *)(v9 + 668);
          v19 = v91;
          goto LABEL_93;
        }
        v58 = *(_QWORD *)(v9 + 392);
        v59 = (unsigned int *)(v58 + 544 * v57);
        *v59 = v57;
        v59[1] = *(_DWORD *)&v24[v56];
        v59[2] = *(_DWORD *)&v24[v56 + 4];
        v60 = *(unsigned int *)(v9 + 48);
        if (v60 >= 0x101)
          goto LABEL_35;
        v61 = v56 + 8;
        v62 = v58 + 544 * v57;
        memcpy((void *)(v62 + 28), &v24[v61], *(unsigned int *)(v9 + 48));
        *(_DWORD *)(v62 + 24) = v60;
        memset_s((void *)(v62 + 28 + v60), 256 - v60, 0, 256 - v60);
        v63 = *(unsigned int *)(v9 + 84);
        if (v63 >= 0x101)
          goto LABEL_35;
        v64 = v58 + 544 * v57;
        v56 = v61 + *(unsigned int *)(v9 + 48);
        memcpy((void *)(v64 + 288), &v24[v97], *(unsigned int *)(v9 + 84));
        *(_DWORD *)(v64 + 284) = v63;
        memset_s((void *)(v64 + 288 + v63), 256 - v63, 0, 256 - v63);
        v97 += *(unsigned int *)(v9 + 84);
        ++v55;
        LODWORD(v54) = *(_DWORD *)(v9 + 20);
      }
      while (v55 < v54);
      v42 = *(_QWORD *)(v9 + 376);
      a2 = v93;
      v41 = v42 + v94;
      v10 = (_DWORD *)(v9 + 668);
      v19 = v91;
      if (!(_DWORD)v54)
        goto LABEL_96;
LABEL_93:
      v65 = (v54 * v95);
      v66 = *(unsigned int *)(v9 + 400);
      v54 = v54;
      v67 = 544 * v65;
      do
      {
        if (v65 >= v66)
          break;
        v68 = *(_QWORD *)(v9 + 392) + v67;
        *(_QWORD *)(v68 + 16) = v41;
        v41 += *(unsigned int *)(v68 + 8);
        v67 += 544;
        ++v65;
        --v54;
      }
      while (v54);
    }
    else
    {
      v42 = *(_QWORD *)(v9 + 376);
      v41 = v42 + v94;
    }
LABEL_96:
    if (++v95 >= *(_DWORD *)(v9 + 404))
      goto LABEL_97;
  }
  memset_s(v122, 0x104uLL, 0, 0x104uLL);
LABEL_106:
  memset_s(&v105, 0x104uLL, 0, 0x104uLL);
LABEL_107:
  v26 = "deriving cluster header key";
  v27 = 187;
LABEL_51:
  v38 = 0;
LABEL_52:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v27, 28, v38, v26, v11, v12, v90);
LABEL_43:
  v34 = 0;
LABEL_44:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v101, 0x104uLL, 0, 0x104uLL);
  memset_s(v99, 0x104uLL, 0, 0x104uLL);
  memset_s(v98, 0x30uLL, 0, 0x30uLL);
  if (v24)
    memset_s(v24, v19, 0, v19);
  free(v24);
  if (!v34)
  {
    aeaContainerDestroy(v9);
    return 0;
  }
  return v9;
}

uint64_t aeaContainerAppendSegment(uint64_t a1, uint64_t a2, _QWORD *__src, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  unint64_t v24;
  void *v25;
  char *v26;
  int v28;
  char v29;

  if (*(_DWORD *)__src == -1)
  {
    v22 = "Invalid segment id\n";
    v23 = 280;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 400);
    v13 = *(_DWORD *)(a1 + 404);
    v14 = *(_DWORD *)(a1 + 20);
    if (v12 < v14 * v13)
    {
      v15 = *(_QWORD *)(a1 + 40);
      goto LABEL_4;
    }
    *(_DWORD *)(a1 + 404) = v13 + 1;
    v24 = v14 * (unint64_t)(v13 + 1);
    if (v24 < 0xFFFFFFFF)
    {
      if (v24 < 0xF0F0F10)
      {
        v25 = *(void **)(a1 + 392);
        v26 = (char *)realloc(v25, 544 * v24);
        if (v26)
        {
          *(_QWORD *)(a1 + 392) = v26;
          memset_s(&v26[544 * *(unsigned int *)(a1 + 400)], 544 * (v24 - *(unsigned int *)(a1 + 400)), 0, 544 * (v24 - *(unsigned int *)(a1 + 400)));
          v15 = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 376);
          *(_QWORD *)(a1 + 40) = v15;
          v12 = *(_DWORD *)(a1 + 400);
LABEL_4:
          __src[2] = v15;
          v16 = *((unsigned int *)__src + 2);
          memcpy((void *)(*(_QWORD *)(a1 + 392) + 544 * v12), __src, 0x220uLL);
          ++*(_DWORD *)(a1 + 400);
          v17 = *(_QWORD *)(a1 + 40) + v16;
          *(_QWORD *)(a1 + 32) += *((unsigned int *)__src + 1);
          *(_QWORD *)(a1 + 40) = v17;
          if (*(_QWORD *)(a2 + 40))
          {
            v18 = 0;
            if ((_DWORD)v16)
            {
              v19 = __src[2];
              v20 = v16;
              while (1)
              {
                v21 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(a2 + 40))(*(_QWORD *)a2, a4, v20, v19);
                if (v21 < 1)
                  break;
                a4 += v21;
                v18 += v21;
                v19 += v21;
                v20 -= v21;
                if (!v20)
                  goto LABEL_9;
              }
              v18 = v21;
              if ((v21 & 0x8000000000000000) == 0)
              {
LABEL_19:
                if (v18 == v16)
                  return 0;
              }
            }
            else
            {
LABEL_9:
              if ((v18 & 0x8000000000000000) == 0)
                goto LABEL_19;
            }
          }
          v22 = "Segment write";
          v23 = 308;
          goto LABEL_22;
        }
        free(v25);
      }
      else
      {
        *__error() = 12;
      }
      *(_QWORD *)(a1 + 392) = 0;
      v28 = *__error();
      v22 = "malloc";
      v23 = 289;
      goto LABEL_23;
    }
    v22 = "Container size limit reached";
    v23 = 287;
  }
LABEL_22:
  v28 = 0;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerAppendSegment", v23, 28, v28, v22, a7, a8, v29);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerRemovePadding(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char vars0;

  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) -= v2;
    *(_QWORD *)(a1 + 64) = 0;
    if ((AAByteStreamTruncate(a2) & 0x80000000) != 0)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemovePadding", 328, 28, "Warning: container truncate failed", v3, v4, v5, vars0);
  }
  return 0;
}

uint64_t aeaContainerRemoveLastSegment(uint64x2_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v8;
  const char *v10;
  __int16 v11;
  uint64_t v14;
  __int32 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;

  v8 = a1[25].i32[0];
  if (!v8)
  {
    v10 = "No segments to remove";
    v11 = 339;
    goto LABEL_5;
  }
  if (a1[4].i64[0])
  {
    v10 = "Padding was not removed";
    v11 = 340;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemoveLastSegment", v11, 28, 0, v10, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  v14 = a1[24].i64[1] + 544 * (v8 - 1);
  v15 = a1[25].i32[1];
  a1[25].i32[0] = v8 - 1;
  a1[25].i32[1] = (v8 + a1[1].i32[1] - 2) / a1[1].i32[1];
  a1[2] = vsubw_u32(a1[2], *(uint32x2_t *)(v14 + 4));
  memset_s((void *)v14, 0x220uLL, 0, 0x220uLL);
  if (v15 != a1[25].i32[1])
    a1[2].i64[1] -= a1[23].i64[1];
  if ((AAByteStreamTruncate(a2) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemoveLastSegment", 364, 28, "Warning: container truncate failed", v16, v17, v18, v19);
  return 0;
}

uint64_t aeaContainerReencrypt(uint64_t a1, AAByteStream_impl *a2, int *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6)
{
  size_t v12;
  BOOL v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  char *v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  off_t *v23;
  uint64_t v24;
  off_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(__int128 *, _QWORD, _DWORD *, _OWORD *, _OWORD *);
  int v30;
  int v31;
  uint64_t v32;
  uint64_t (*v33)(_OWORD *, _QWORD, __int128 *, _OWORD *, _OWORD *);
  int v34;
  uint64_t (*v35)(char *, size_t, uint64_t, _OWORD *, _QWORD, _QWORD);
  _DWORD *v36;
  uint64_t v37;
  uint64_t (*v38)(__int128 *, _QWORD, size_t *, _OWORD *, _OWORD *);
  int v39;
  int v40;
  uint64_t v41;
  uint64_t (*v42)(_OWORD *, _QWORD, __int128 *, _OWORD *, _OWORD *);
  int v43;
  uint64_t (*v44)(char *, size_t, _DWORD *, _OWORD *, _QWORD, _QWORD);
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int *v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  __int16 v54;
  char v56;
  char v57;
  off_t *v58;
  _DWORD *v59;
  unsigned int *v60;
  uint64_t v61;
  unsigned int v62;
  BOOL v63;
  size_t v64;
  _OWORD v65[16];
  int v66;
  size_t v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  int v83;
  size_t v84[2];
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  int v100;
  size_t __n[2];
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  int v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  int v134;
  _OWORD v135[17];
  _OWORD v136[17];
  uint64_t v137;

  v137 = *MEMORY[0x24BDAC8D0];
  v117 = 0;
  v116 = 0u;
  v115 = 0u;
  v114 = 0u;
  v113 = 0u;
  v112 = 0u;
  v111 = 0u;
  v110 = 0u;
  v109 = 0u;
  v108 = 0u;
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  v102 = 0u;
  v103 = 0u;
  *(_OWORD *)__n = 0u;
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  *(_OWORD *)v84 = 0u;
  v85 = 0u;
  v83 = 0;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  *(_OWORD *)v67 = 0u;
  v68 = 0u;
  v12 = *(unsigned int *)(a1 + 16);
  v14 = (*(_DWORD *)a1 & 0x3F) == 0 && *(_DWORD *)a1 < 6u;
  v63 = v14;
  memset(v65, 0, sizeof(v65));
  v66 = 0;
  v15 = (char *)malloc(v12);
  if (!v15)
  {
    v50 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", 390, 28, *v50, "malloc", v51, v52, v56);
    v49 = 0;
    goto LABEL_70;
  }
  v60 = (unsigned int *)(a1 + 72);
  if ((aeaDeriveMainKeyNew((unsigned int *)(a1 + 72), (int *)a1, (__int128 *)v84, (int *)v67, (char *)__n, a3, a4, a5, a6) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", 400, 28, 0, "generating new main key", v16, v17, v57);
    v49 = 0;
    goto LABEL_69;
  }
  if (!*(_DWORD *)(a1 + 400))
  {
LABEL_53:
    v46 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101)
      goto LABEL_74;
    memcpy((void *)(a1 + 412), (char *)__n + 4, LODWORD(__n[0]));
    *(_DWORD *)(a1 + 408) = v46;
    memset_s((void *)(a1 + 412 + v46), 256 - v46, 0, 256 - v46);
    v47 = LODWORD(v84[0]);
    if (LODWORD(v84[0]) >= 0x101
      || (memcpy((void *)(a1 + 672), (char *)v84 + 4, LODWORD(v84[0])),
          *(_DWORD *)(a1 + 668) = v47,
          memset_s((void *)(a1 + 672 + v47), 256 - v47, 0, 256 - v47),
          v48 = LODWORD(v67[0]),
          LODWORD(v67[0]) >= 0x101))
    {
LABEL_74:
      __break(1u);
    }
    memcpy((void *)(a1 + 932), (char *)v67 + 4, LODWORD(v67[0]));
    *(_DWORD *)(a1 + 928) = v48;
    memset_s((void *)(a1 + 932 + v48), 256 - v48, 0, 256 - v48);
    v49 = 1;
    goto LABEL_69;
  }
  v18 = 0;
  v59 = (_DWORD *)(a1 + 668);
  v19 = (char *)v136 + 4;
  while (1)
  {
    if (!*((_QWORD *)a2 + 4))
      goto LABEL_60;
    v20 = v19;
    v61 = *(_QWORD *)(a1 + 392);
    v21 = v61 + 544 * v18;
    v22 = *(unsigned int *)(v21 + 8);
    v62 = *(_DWORD *)(a1 + 20);
    v23 = (off_t *)(v21 + 16);
    v64 = v22;
    v58 = v23;
    v24 = 0;
    if ((_DWORD)v22)
    {
      v25 = *v23;
      v26 = v15;
      while (1)
      {
        v27 = (*((uint64_t (**)(_QWORD, char *, size_t, off_t))a2 + 4))(*(_QWORD *)a2, v26, v22, v25);
        if (v27 < 0)
          break;
        if (v27)
        {
          v26 += v27;
          v24 += v27;
          v25 += v27;
          v22 -= v27;
          if (v22)
            continue;
        }
        goto LABEL_19;
      }
      v24 = v27;
    }
LABEL_19:
    if (v24 != v64)
    {
LABEL_60:
      v53 = "loading compressed segment";
      v54 = 412;
      goto LABEL_68;
    }
    v19 = v20;
    v134 = 0;
    v133 = 0uLL;
    v132 = 0uLL;
    v131 = 0uLL;
    v130 = 0uLL;
    v129 = 0uLL;
    v128 = 0uLL;
    v127 = 0uLL;
    v126 = 0uLL;
    v125 = 0uLL;
    v124 = 0uLL;
    v123 = 0uLL;
    v122 = 0uLL;
    v121 = 0uLL;
    v120 = 0uLL;
    v119 = 0uLL;
    v118 = 0uLL;
    *(_OWORD *)((char *)&v136[15] + 4) = 0uLL;
    *(_OWORD *)((char *)&v136[13] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[14] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[11] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[12] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[9] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[10] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[7] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[8] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[5] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[6] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[3] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[4] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[1] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[2] + 8) = 0uLL;
    *(_OWORD *)((char *)v136 + 8) = 0uLL;
    memset(v135, 0, 260);
    *((_WORD *)v20 + 2) = 19267;
    *(_DWORD *)v20 = 1598113089;
    LODWORD(v136[0]) = 6;
    memset_s((char *)v136 + 10, 0xFAuLL, 0, 0xFAuLL);
    v28 = LODWORD(v136[0]);
    if (LODWORD(v136[0]) >= 0xFD)
      goto LABEL_74;
    *(_DWORD *)&v20[LODWORD(v136[0])] = v18 / v62;
    LODWORD(v136[0]) = v28 + 4;
    memset_s(&v20[v28 + 4], 252 - v28, 0, 252 - v28);
    v29 = *(uint64_t (**)(__int128 *, _QWORD, _DWORD *, _OWORD *, _OWORD *))(a1 + 144);
    if (v29 && *v59)
    {
      v30 = v29(&v118, *v60, v59, v136, v135);
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
      v31 = 0;
      if ((v30 & 0x80000000) == 0)
        goto LABEL_27;
    }
    else
    {
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
    }
    v31 = 1;
LABEL_27:
    memset((char *)v135 + 8, 0, 252);
    WORD4(v135[0]) = 19283;
    *(_QWORD *)&v135[0] = 0x5F41454100000006;
    memset_s((char *)v135 + 10, 0xFAuLL, 0, 0xFAuLL);
    v32 = LODWORD(v135[0]);
    if (LODWORD(v135[0]) >= 0xFD)
      goto LABEL_74;
    *(_DWORD *)((char *)v135 + LODWORD(v135[0]) + 4) = v18 % v62;
    LODWORD(v135[0]) = v32 + 4;
    memset_s((char *)v135 + v32 + 8, 252 - v32, 0, 252 - v32);
    memset(v136, 0, 260);
    v33 = *(uint64_t (**)(_OWORD *, _QWORD, __int128 *, _OWORD *, _OWORD *))(a1 + 144);
    if (!v33 || !(_DWORD)v118)
    {
      memset_s(v135, 0x104uLL, 0, 0x104uLL);
LABEL_63:
      memset_s(&v118, 0x104uLL, 0, 0x104uLL);
LABEL_64:
      v53 = "deriving segment key";
      v54 = 416;
      goto LABEL_68;
    }
    v34 = v33(v65, *(unsigned int *)(a1 + 76), &v118, v135, v136);
    memset_s(v135, 0x104uLL, 0, 0x104uLL);
    if (v34 < 0)
      goto LABEL_63;
    memset_s(&v118, 0x104uLL, 0, 0x104uLL);
    if (v31)
      goto LABEL_64;
    v35 = *(uint64_t (**)(char *, size_t, uint64_t, _OWORD *, _QWORD, _QWORD))(a1 + 168);
    if (!v35
      || (v36 = (_DWORD *)(v61 + 544 * v18 + 284), *v36 != *(_DWORD *)(a1 + 84))
      || (v35(v15, v64, v61 + 544 * v18 + 284, v65, 0, 0) & 0x80000000) != 0)
    {
      v53 = "decrypting segment data";
      v54 = 418;
      goto LABEL_68;
    }
    v134 = 0;
    v133 = 0u;
    v132 = 0u;
    v131 = 0u;
    v130 = 0u;
    v129 = 0u;
    v128 = 0u;
    v127 = 0u;
    v126 = 0u;
    v125 = 0u;
    v124 = 0u;
    v123 = 0u;
    v122 = 0u;
    v121 = 0u;
    v120 = 0u;
    v119 = 0u;
    v118 = 0u;
    memset((char *)v136 + 8, 0, 252);
    memset(v135, 0, 260);
    *((_WORD *)v20 + 2) = 19267;
    *(_DWORD *)v20 = 1598113089;
    LODWORD(v136[0]) = 6;
    memset_s((char *)v136 + 10, 0xFAuLL, 0, 0xFAuLL);
    v37 = LODWORD(v136[0]);
    if (LODWORD(v136[0]) >= 0xFD)
      goto LABEL_74;
    *(_DWORD *)&v20[LODWORD(v136[0])] = v18 / v62;
    LODWORD(v136[0]) = v37 + 4;
    memset_s(&v20[v37 + 4], 252 - v37, 0, 252 - v37);
    v38 = *(uint64_t (**)(__int128 *, _QWORD, size_t *, _OWORD *, _OWORD *))(a1 + 144);
    if (v38 && LODWORD(v84[0]))
    {
      v39 = v38(&v118, *v60, v84, v136, v135);
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
      v40 = 0;
      if ((v39 & 0x80000000) == 0)
        goto LABEL_42;
    }
    else
    {
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
    }
    v40 = 1;
LABEL_42:
    memset((char *)v135 + 8, 0, 252);
    WORD4(v135[0]) = 19283;
    *(_QWORD *)&v135[0] = 0x5F41454100000006;
    memset_s((char *)v135 + 10, 0xFAuLL, 0, 0xFAuLL);
    v41 = LODWORD(v135[0]);
    if (LODWORD(v135[0]) >= 0xFD)
      goto LABEL_74;
    *(_DWORD *)((char *)v135 + LODWORD(v135[0]) + 4) = v18 % v62;
    LODWORD(v135[0]) = v41 + 4;
    memset_s((char *)v135 + v41 + 8, 252 - v41, 0, 252 - v41);
    memset(v136, 0, 260);
    v42 = *(uint64_t (**)(_OWORD *, _QWORD, __int128 *, _OWORD *, _OWORD *))(a1 + 144);
    if (!v42 || !(_DWORD)v118)
    {
      memset_s(v135, 0x104uLL, 0, 0x104uLL);
LABEL_66:
      memset_s(&v118, 0x104uLL, 0, 0x104uLL);
LABEL_67:
      v53 = "deriving segment key";
      v54 = 422;
      goto LABEL_68;
    }
    v43 = v42(v65, *(unsigned int *)(a1 + 76), &v118, v135, v136);
    memset_s(v135, 0x104uLL, 0, 0x104uLL);
    if (v43 < 0)
      goto LABEL_66;
    memset_s(&v118, 0x104uLL, 0, 0x104uLL);
    if (v40)
      goto LABEL_67;
    v44 = *(uint64_t (**)(char *, size_t, _DWORD *, _OWORD *, _QWORD, _QWORD))(a1 + 160);
    if (!v44 || (v45 = v44(v15, v64, v36, v65, 0, 0), *v36 != *(_DWORD *)(a1 + 84)) || v45 < 0)
    {
      v53 = "decrypting segment data";
      v54 = 424;
      goto LABEL_68;
    }
    if (!v63 && AAByteStreamPWrite(a2, v15, v64, *v58) != v64)
      break;
    if (++v18 >= *(_DWORD *)(a1 + 400))
      goto LABEL_53;
  }
  v53 = "storing compressed segment";
  v54 = 429;
LABEL_68:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", v54, 28, 0, v53, v16, v17, v57);
  v49 = 0;
LABEL_69:
  memset_s(v15, v12, 0, v12);
LABEL_70:
  free(v15);
  memset_s(v84, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v67, 0x104uLL, 0, 0x104uLL);
  memset_s(v65, 0x104uLL, 0, 0x104uLL);
  if (v49)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aeaContainerLoadSegment(uint64_t a1, _QWORD *a2, unsigned int a3, uint8_t *a4, const uint8_t *a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char *v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  unsigned int v23;
  uint64_t (*v24)(_OWORD *, _QWORD);
  int v25;
  int v26;
  uint64_t result;
  uint64_t v28;
  uint64_t (*v29)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *);
  int v30;
  uint64_t (*v31)(char *, size_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int64_t v36;
  compression_algorithm v37;
  size_t v38;
  char *v39;
  size_t __n;
  uint64_t v42;
  _OWORD v46[16];
  int v47;
  _OWORD v48[16];
  int v49;
  _OWORD v50[16];
  int v51;
  _OWORD v52[16];
  int v53;
  _OWORD v54[17];
  _BYTE __s[260];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  v49 = 0;
  memset(v48, 0, sizeof(v48));
  v47 = 0;
  memset(v46, 0, sizeof(v46));
  v8 = *(_DWORD *)(a1 + 24);
  if (v8)
    v9 = (char *)a5;
  else
    v9 = (char *)a4;
  if (*(_DWORD *)(a1 + 400) <= a3)
  {
    v21 = "Invalid segment index";
    v22 = 463;
    goto LABEL_41;
  }
  if (!a2[4])
    goto LABEL_20;
  v13 = *(_QWORD *)(a1 + 392);
  v14 = v13 + 544 * a3;
  v15 = *(unsigned int *)(v14 + 8);
  __n = *(unsigned int *)(v14 + 4);
  v42 = v13;
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = *(_QWORD *)(v13 + 544 * a3 + 16);
    v18 = v9;
    v19 = *(unsigned int *)(v14 + 8);
    while (1)
    {
      v20 = ((uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))a2[4])(*a2, v9, v15, v17);
      if (v20 < 0)
        break;
      if (v20)
      {
        v9 += v20;
        v16 += v20;
        v17 += v20;
        v15 -= v20;
        if (v15)
          continue;
      }
      goto LABEL_15;
    }
    v16 = v20;
  }
  else
  {
    v18 = v9;
    v19 = *(unsigned int *)(v14 + 8);
    v16 = 0;
  }
LABEL_15:
  if (v16 != v19)
  {
LABEL_20:
    v21 = "loading segment";
    v22 = 471;
    goto LABEL_41;
  }
  v39 = v18;
  v23 = *(_DWORD *)(a1 + 20);
  v53 = 0;
  memset(v52, 0, sizeof(v52));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  memset(v54, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[10] = a3 / v23;
  *(_QWORD *)__s = 0x5F4145410000000ALL;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  v24 = *(uint64_t (**)(_OWORD *, _QWORD))(a1 + 144);
  if (v24 && *(_DWORD *)(a1 + 668))
  {
    v25 = v24(v52, *(unsigned int *)(a1 + 72));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    v26 = 0;
    if ((v25 & 0x80000000) == 0)
      goto LABEL_23;
  }
  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  v26 = 1;
LABEL_23:
  memset((char *)v54 + 8, 0, 224);
  memset((char *)&v54[14] + 8, 0, 28);
  WORD4(v54[0]) = 19283;
  *(_QWORD *)&v54[0] = 0x5F41454100000006;
  result = memset_s((char *)v54 + 10, 0xFAuLL, 0, 0xFAuLL);
  v28 = LODWORD(v54[0]);
  if (LODWORD(v54[0]) < 0xFD)
  {
    *(_DWORD *)((char *)v54 + LODWORD(v54[0]) + 4) = a3 % v23;
    LODWORD(v54[0]) = v28 + 4;
    memset_s((char *)v54 + v28 + 8, 252 - v28, 0, 252 - v28);
    memset(__s, 0, sizeof(__s));
    v29 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *))(a1 + 144);
    if (v29 && LODWORD(v52[0]))
    {
      v30 = v29(v48, *(unsigned int *)(a1 + 76), v52, v54, __s);
      memset_s(v54, 0x104uLL, 0, 0x104uLL);
      if ((v30 & 0x80000000) == 0)
      {
        memset_s(v52, 0x104uLL, 0, 0x104uLL);
        if (!v26)
        {
          v31 = *(uint64_t (**)(char *, size_t))(a1 + 168);
          if (v31 && *(_DWORD *)(v42 + 544 * a3 + 284) == *(_DWORD *)(a1 + 84) && (v31(v39, v19) & 0x80000000) == 0)
          {
            v34 = __n;
            if (v8)
            {
              v35 = *(unsigned int *)(a1 + 24);
              if ((_DWORD)v35 && __n > v19)
              {
                if ((_DWORD)v35 == 774)
                {
                  v36 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 16), a5, v19);
                  if (v36 >= 0)
                    v36 = v36;
                  else
                    v36 = 0;
                }
                else
                {
                  v37 = aeaEffectiveCompressionAlgorithm(v35);
                  v36 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 16), a5, v19, a6, v37);
                }
                if (v36 != __n)
                {
                  v21 = "Segment decompression";
                  v22 = 511;
                  goto LABEL_41;
                }
              }
              else
              {
                memcpy(a4, a5, __n);
              }
            }
            if ((aeaChecksum((uint64_t)v46, *(_DWORD *)(a1 + 12), a4, __n, v32, v33, a7, a8) & 0x80000000) != 0)
            {
              v21 = "computing segment checksum";
              v22 = 515;
            }
            else
            {
              v38 = *(unsigned int *)(a1 + 48);
              if (!(_DWORD)v38 || !memcmp((char *)v46 + 4, (const void *)(v42 + 544 * a3 + 28), v38))
                goto LABEL_42;
              v21 = "Checksum verification failed, data corrupted";
              v22 = 519;
            }
          }
          else
          {
            v21 = "decrypting segment data";
            v22 = 485;
          }
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerLoadSegment", v22, 28, 0, v21, a7, a8, (char)v39);
          v34 = -1;
LABEL_42:
          memset_s(v50, 0x104uLL, 0, 0x104uLL);
          memset_s(v48, 0x104uLL, 0, 0x104uLL);
          memset_s(v46, 0x104uLL, 0, 0x104uLL);
          return v34;
        }
LABEL_40:
        v21 = "deriving segment key";
        v22 = 481;
        goto LABEL_41;
      }
    }
    else
    {
      memset_s(v54, 0x104uLL, 0, 0x104uLL);
    }
    memset_s(v52, 0x104uLL, 0, 0x104uLL);
    goto LABEL_40;
  }
  __break(1u);
  return result;
}

unint64_t aeaPaddedContainerSize(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  int v9;
  int v10;

  if (result)
  {
    if (a2 > 0xF)
      goto LABEL_8;
    if (a2)
    {
      if (a2 == 1)
      {
        if (result >= 8)
        {
          v9 = __clz(result);
          v10 = __clz(v9 ^ 0x3F) - v9;
          if (v10 < -31)
            return -1;
          a2 = 1 << (v10 + 31);
LABEL_8:
          if (!__CFADD__(result, a2 - 1))
            return (result + a2 - 1) / a2 * a2;
          return -1;
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaPaddedContainerSize", 585, 28, 0, "Invalid padding_alignment", a7, a8, v8);
        return -1;
      }
    }
  }
  return result;
}

uint64_t aeaContainerFinish(uint64_t a1, AAByteStream_impl *a2)
{
  size_t v3;
  size_t v4;
  unint64_t v5;
  rsize_t v6;
  char *v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(void);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t (*v22)(_BYTE *, _QWORD);
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  rsize_t v27;
  char *v28;
  uint64_t v29;
  char v30;
  const char *v31;
  __int16 v32;
  void *v33;
  uint64_t result;
  size_t v35;
  uint64_t (*v36)(char *, size_t);
  uint64_t (*v37)(uint64_t, char *, size_t);
  ssize_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  uint64_t (*v42)(uint64_t, _OWORD *);
  int v43;
  int v44;
  int v45;
  unint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _DWORD *v53;
  char *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t (*v59)(char *, unint64_t);
  uint64_t v60;
  uint64_t (*v61)(__int128 *, _QWORD, _DWORD *, _BYTE *, _OWORD *);
  int v62;
  int v63;
  uint64_t (*v64)(_OWORD *, _QWORD, __int128 *, _OWORD *, _BYTE *);
  int v65;
  uint64_t (*v66)(char *, _QWORD, _OWORD *, _OWORD *, char *, size_t);
  int v67;
  ssize_t v68;
  const char *v69;
  __int16 v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  size_t v79;
  size_t v80;
  char *v81;
  uint64_t (*v82)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _BYTE *);
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t (*v86)(__int128 *, uint64_t, size_t *, _OWORD *, char *, rsize_t);
  int v87;
  size_t v88;
  uint64_t v89;
  char *v90;
  __int128 v91;
  size_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t (*v95)(_OWORD *, char *, size_t);
  int v96;
  uint64_t (*v97)(_QWORD, uint64_t, char *, _BYTE *, char *);
  unint64_t v98;
  const char *v99;
  __int16 v100;
  const char *v101;
  __int16 v102;
  int v103;
  uint64_t (*v104)(_OWORD *, uint64_t, _OWORD *);
  uint64_t (*v105)(_OWORD *, _QWORD, _DWORD *, _BYTE *, _OWORD *);
  int v106;
  uint64_t (*v107)(_OWORD *, _QWORD, _OWORD *, __int128 *, _BYTE *);
  uint64_t v108;
  unint64_t v109;
  int v110;
  int v111;
  uint64_t v112;
  uint64_t (*v113)(uint64_t, char *, size_t);
  int v114;
  size_t nbyte;
  rsize_t __n;
  _DWORD *v117;
  AAByteStream_impl *v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  _OWORD v128[16];
  int v129;
  _OWORD v130[16];
  int v131;
  size_t v132[2];
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  int v148;
  _OWORD v149[16];
  int v150;
  _OWORD v151[16];
  int v152;
  size_t v153[2];
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  int v169;
  _OWORD __s[16];
  int v171;
  size_t v172[2];
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  int v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  int v205;
  _OWORD v206[17];
  _BYTE v207[260];
  uint64_t v208;

  v208 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 344);
  v4 = *(_QWORD *)(a1 + 376);
  if (v3 <= v4)
    v5 = *(_QWORD *)(a1 + 376);
  else
    v5 = *(_QWORD *)(a1 + 344);
  v171 = 0;
  if (v5 <= 0x100000)
    v6 = 0x100000;
  else
    v6 = v5;
  memset(__s, 0, sizeof(__s));
  v169 = 0;
  v168 = 0u;
  v167 = 0u;
  v166 = 0u;
  v165 = 0u;
  v164 = 0u;
  v163 = 0u;
  v162 = 0u;
  v161 = 0u;
  v160 = 0u;
  v159 = 0u;
  v158 = 0u;
  v157 = 0u;
  v156 = 0u;
  v155 = 0u;
  v154 = 0u;
  *(_OWORD *)v153 = 0u;
  v152 = 0;
  memset(v151, 0, sizeof(v151));
  v150 = 0;
  memset(v149, 0, sizeof(v149));
  v148 = 0;
  v146 = 0u;
  v147 = 0u;
  v144 = 0u;
  v145 = 0u;
  v142 = 0u;
  v143 = 0u;
  v140 = 0u;
  v141 = 0u;
  v138 = 0u;
  v139 = 0u;
  v136 = 0u;
  v137 = 0u;
  v134 = 0u;
  v135 = 0u;
  *(_OWORD *)v132 = 0u;
  v133 = 0u;
  v131 = 0;
  memset(v130, 0, sizeof(v130));
  v129 = 0;
  memset(v128, 0, sizeof(v128));
  v124 = 0;
  v123 = 0;
  v126 = 0u;
  v127 = 0u;
  v125 = 0u;
  if (v6 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_21:
    v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", 620, 28, *v24, "malloc", v25, v26, nbyte);
    v9 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0xFFFFFFFFLL;
    v30 = 1;
LABEL_25:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v153, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    memset_s(v151, 0x104uLL, 0, 0x104uLL);
    memset_s(v149, 0x104uLL, 0, 0x104uLL);
    memset_s(v132, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(&v125, 0x30uLL, 0, 0x30uLL);
    memset_s(&v123, 0xCuLL, 0, 0xCuLL);
    if ((v30 & 1) == 0)
      memset_s(v9, v6, 0, v6);
    free(v9);
    if (v28)
      memset_s(v28, v27, 0, v27);
    free(v28);
    v33 = *(void **)(a1 + 384);
    if (v33)
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    free(v33);
    *(_QWORD *)(a1 + 384) = 0;
    return v29;
  }
  v8 = (char *)malloc(v6);
  if (!v8)
    goto LABEL_21;
  v9 = v8;
  v10 = *(_DWORD *)(a1 + 84);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v10 > 0x100 || (v13 = *(uint64_t (**)(void))(a1 + 136)) == 0 || (v13() & 0x80000000) != 0)
  {
    v31 = "generating last cluster random MAC";
    v32 = 624;
    goto LABEL_23;
  }
  LODWORD(__s[0]) = v10;
  v18 = *(_QWORD *)(a1 + 56);
  if (v18)
  {
    v19 = *(_QWORD *)(a1 + 40);
    v20 = aeaPaddedContainerSize(v19, v18, v14, v15, v16, v17, v11, v12);
    if (v20 == -1)
    {
      v31 = "Container size is too large to allow padding";
      v32 = 631;
      goto LABEL_23;
    }
    v21 = v20;
    if (v20 > v19)
    {
      memset(v207, 0, sizeof(v207));
      memset(v206, 0, 260);
      v205 = 0;
      v204 = 0u;
      v203 = 0u;
      v202 = 0u;
      v201 = 0u;
      v200 = 0u;
      v199 = 0u;
      v198 = 0u;
      v197 = 0u;
      v196 = 0u;
      v195 = 0u;
      v194 = 0u;
      v193 = 0u;
      v192 = 0u;
      v191 = 0u;
      v190 = 0u;
      v189 = 0u;
      if (*(_QWORD *)(a1 + 248)
        && (*(_DWORD *)((char *)v206 + 7) = 1262571615,
            *(_QWORD *)&v206[0] = 0x5F41454100000007,
            memset_s((void *)((unint64_t)v206 | 0xB), 0xF9uLL, 0, 0xF9uLL),
            (v22 = *(uint64_t (**)(_BYTE *, _QWORD))(a1 + 144)) != 0)
        && *(_DWORD *)(a1 + 668)
        && (v22(v207, *(unsigned int *)(a1 + 72)) & 0x80000000) == 0)
      {
        v23 = (*(uint64_t (**)(_BYTE *))(a1 + 248))(v207);
      }
      else
      {
        v23 = 0;
      }
      memset_s(v207, 0x104uLL, 0, 0x104uLL);
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
      if (v23)
      {
        nbyte = v3;
        while (1)
        {
          if (v21 - v19 >= 0x100000)
            v35 = 0x100000;
          else
            v35 = v21 - v19;
          v36 = *(uint64_t (**)(char *, size_t))(a1 + 136);
          if (!v36 || (v36(v9, v35) & 0x80000000) != 0)
          {
            v40 = "generating padding";
            v41 = 640;
            goto LABEL_50;
          }
          v37 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 256);
          if (!v37 || (v37(v23, v9, v35) & 0x80000000) != 0)
          {
            v40 = "hashing padding";
            v41 = 641;
            goto LABEL_50;
          }
          v38 = AAByteStreamPWrite(a2, v9, v35, v19);
          if (v38 <= 0)
            break;
          v19 += v38;
          if (v19 >= v21)
          {
            v39 = 0;
            goto LABEL_51;
          }
        }
        v40 = "writing padding";
        v41 = 643;
LABEL_50:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v41, 28, 0, v40, v11, v12, v3);
        v39 = 1;
LABEL_51:
        v42 = *(uint64_t (**)(uint64_t, _OWORD *))(a1 + 264);
        v3 = nbyte;
        if (v42)
        {
          if ((v42(v23, __s) & 0x80000000) == 0 && LODWORD(__s[0]) == *(_DWORD *)(a1 + 84))
          {
            if (!v39)
            {
              *(_QWORD *)(a1 + 40) = v19;
              goto LABEL_56;
            }
            goto LABEL_114;
          }
          memset_s(__s, 0x104uLL, 0, 0x104uLL);
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", 646, 28, 0, "hashing padding", v11, v12, nbyte);
LABEL_114:
        v31 = "Padding generation and hashing failed";
        v32 = 648;
        goto LABEL_23;
      }
      v31 = "hashing padding";
      v32 = 636;
LABEL_23:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v32, 28, 0, v31, v11, v12, nbyte);
      v30 = 0;
      v27 = 0;
      v28 = 0;
LABEL_24:
      v29 = 0xFFFFFFFFLL;
      goto LABEL_25;
    }
  }
LABEL_56:
  nbyte = v3;
  __n = v6;
  v117 = (_DWORD *)(a1 + 668);
  v118 = a2;
  v43 = *(_DWORD *)(a1 + 404);
  v44 = v43 - 1;
  while (v43)
  {
    v45 = *(_DWORD *)(a1 + 20);
    v120 = v44;
    v121 = v43 - 1;
    v46 = (v45 * (v43 - 1));
    v47 = v45 * v43;
    v48 = *(_DWORD *)(a1 + 400);
    if (v47 >= v48)
      v49 = v48;
    else
      v49 = v47;
    v50 = *(_QWORD *)(a1 + 392);
    v119 = *(_QWORD *)(v50 + 544 * v46 + 16);
    v51 = *(_QWORD *)(a1 + 368);
    v122 = *(_QWORD *)(a1 + 376);
    v52 = 0;
    if (v46 < v49)
    {
      v53 = (_DWORD *)(v50 + 544 * (v45 * v44));
      do
      {
        v54 = &v9[v52];
        *(_DWORD *)v54 = v53[1];
        *((_DWORD *)v54 + 1) = v53[2];
        v55 = v52 + 8;
        memcpy(&v9[v55], v53 + 7, v53[6]);
        v52 = v55 + v53[6];
        memcpy(&v9[v51], v53 + 72, v53[71]);
        v51 += v53[71];
        ++v46;
        v53 += 136;
      }
      while (v46 < v49);
    }
    v56 = *(_QWORD *)(a1 + 360);
    v57 = v122;
    if (v56 > v52)
    {
      memset_s(&v9[v52], v56 - v52, 0, v56 - v52);
      v57 = *(_QWORD *)(a1 + 376);
    }
    v58 = v57 - v51;
    a2 = v118;
    if (v57 > v51)
    {
      v59 = *(uint64_t (**)(char *, unint64_t))(a1 + 136);
      if (!v59 || (v59(&v9[v51], v58) & 0x80000000) != 0)
      {
        v69 = "generating random padding";
        v70 = 687;
        goto LABEL_109;
      }
    }
    memcpy(&v9[*(_QWORD *)(a1 + 360)], (char *)__s + 4, LODWORD(__s[0]));
    v205 = 0;
    v204 = 0u;
    v203 = 0u;
    v202 = 0u;
    v201 = 0u;
    v200 = 0u;
    v199 = 0u;
    v198 = 0u;
    v197 = 0u;
    v196 = 0u;
    v195 = 0u;
    v194 = 0u;
    v193 = 0u;
    v192 = 0u;
    v191 = 0u;
    v190 = 0u;
    v189 = 0u;
    memset(&v207[8], 0, 252);
    memset(v206, 0, 260);
    *(_WORD *)&v207[8] = 19267;
    *(_QWORD *)v207 = 0x5F41454100000006;
    result = memset_s(&v207[10], 0xFAuLL, 0, 0xFAuLL);
    v60 = *(unsigned int *)v207;
    if (*(_DWORD *)v207 >= 0xFDu)
      goto LABEL_162;
    *(_DWORD *)&v207[*(unsigned int *)v207 + 4] = v121;
    *(_DWORD *)v207 = v60 + 4;
    memset_s(&v207[v60 + 8], 252 - v60, 0, 252 - v60);
    v61 = *(uint64_t (**)(__int128 *, _QWORD, _DWORD *, _BYTE *, _OWORD *))(a1 + 144);
    if (!v61 || !*v117)
    {
      memset_s(v207, 0x104uLL, 0, 0x104uLL);
LABEL_75:
      v63 = 1;
      goto LABEL_76;
    }
    v62 = v61(&v189, *(unsigned int *)(a1 + 72), v117, v207, v206);
    memset_s(v207, 0x104uLL, 0, 0x104uLL);
    v63 = 0;
    if (v62 < 0)
      goto LABEL_75;
LABEL_76:
    memset((char *)v206 + 12, 0, 248);
    *(_QWORD *)((char *)v206 + 4) = 0x4B4548435F414541;
    LODWORD(v206[0]) = 8;
    memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v207, 0, sizeof(v207));
    v64 = *(uint64_t (**)(_OWORD *, _QWORD, __int128 *, _OWORD *, _BYTE *))(a1 + 144);
    if (!v64 || !(_DWORD)v189)
    {
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
LABEL_107:
      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
LABEL_108:
      v69 = "derivating secondary key";
      v70 = 695;
LABEL_109:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v70, 28, 0, v69, v11, v12, nbyte);
      v30 = 0;
      v27 = 0;
      v28 = 0;
LABEL_110:
      v29 = 0xFFFFFFFFLL;
LABEL_111:
      v6 = __n;
      goto LABEL_25;
    }
    v65 = v64(v151, *(unsigned int *)(a1 + 76), &v189, v206, v207);
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    if (v65 < 0)
      goto LABEL_107;
    memset_s(&v189, 0x104uLL, 0, 0x104uLL);
    if (v63)
      goto LABEL_108;
    v66 = *(uint64_t (**)(char *, _QWORD, _OWORD *, _OWORD *, char *, size_t))(a1 + 160);
    if (!v66
      || (v67 = v66(v9, *(_QWORD *)(a1 + 360), __s, v151, &v9[*(_QWORD *)(a1 + 360)], v4 - *(_QWORD *)(a1 + 360)),
          LODWORD(__s[0]) != *(_DWORD *)(a1 + 84))
      || v67 < 0)
    {
      v69 = "Cluster header encryption";
      v70 = 702;
      goto LABEL_109;
    }
    v68 = AAByteStreamPWrite(v118, v9, v4, v119 - v122);
    v44 = v120 - 1;
    v43 = v121;
    if (v68 != v4)
    {
      v69 = "writing cluster header";
      v70 = 707;
      goto LABEL_109;
    }
  }
  v6 = __n;
  memset_s(v9, __n, 0, __n);
  if ((aeaMagicInit(&v123, (_DWORD *)a1) & 0x80000000) != 0)
  {
    v31 = "encoding magic";
    v32 = 717;
    goto LABEL_23;
  }
  v71 = *(_QWORD *)(a1 + 288);
  v72 = &v9[*(_QWORD *)(a1 + 280)];
  *(_QWORD *)v72 = v123;
  *((_DWORD *)v72 + 2) = v124;
  memcpy(&v9[v71], *(const void **)(a1 + 384), *(unsigned int *)(a1 + 4));
  memcpy(&v9[*(_QWORD *)(a1 + 336)], (char *)__s + 4, LODWORD(__s[0]));
  if ((aeaRootHeaderInit((uint64_t)&v125, a1, v73, v74, v75, v76, v77, v78) & 0x80000000) != 0)
  {
    v31 = "encoding root header";
    v32 = 727;
    goto LABEL_23;
  }
  v79 = LODWORD(__s[0]);
  v80 = *(unsigned int *)(a1 + 4);
  v27 = (v80 + LODWORD(__s[0]));
  v81 = (char *)malloc(v27);
  v28 = v81;
  if (!v81)
  {
    v103 = *__error();
    v99 = "malloc";
    v100 = 732;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v100, 28, v103, v99, v93, v94, nbyte);
    v30 = 0;
    goto LABEL_110;
  }
  memcpy(v81, (char *)__s + 4, v79);
  memcpy(&v28[v79], *(const void **)(a1 + 384), v80);
  memset((char *)v206 + 12, 0, 248);
  *(_QWORD *)((char *)v206 + 4) = 0x4B4548525F414541;
  LODWORD(v206[0]) = 8;
  memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v207, 0, sizeof(v207));
  v82 = *(uint64_t (**)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _BYTE *))(a1 + 144);
  if (!v82 || !*v117)
  {
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    v6 = __n;
    goto LABEL_118;
  }
  v83 = v82(v151, *(unsigned int *)(a1 + 76), v117, v206, v207);
  memset_s(v206, 0x104uLL, 0, 0x104uLL);
  v6 = __n;
  if (v83 < 0)
  {
LABEL_118:
    v101 = "derivating RHEK";
    v102 = 739;
LABEL_119:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v102, 28, 0, v101, v84, v85, nbyte);
    v30 = 0;
    goto LABEL_24;
  }
  v86 = *(uint64_t (**)(__int128 *, uint64_t, size_t *, _OWORD *, char *, rsize_t))(a1 + 160);
  if (!v86
    || (v87 = v86(&v125, 48, v153, v151, v28, v27), v88 = LODWORD(v153[0]), LODWORD(v153[0]) != *(_DWORD *)(a1 + 84))
    || v87 < 0)
  {
    v101 = "Root header encryption";
    v102 = 745;
    goto LABEL_119;
  }
  v89 = *(_QWORD *)(a1 + 320);
  v90 = &v9[*(_QWORD *)(a1 + 328)];
  v91 = v126;
  *(_OWORD *)v90 = v125;
  *((_OWORD *)v90 + 1) = v91;
  *((_OWORD *)v90 + 2) = v127;
  memcpy(&v9[v89], (char *)v153 + 4, v88);
  memcpy(&v9[*(_QWORD *)(a1 + 312)], (const void *)(a1 + 412), *(unsigned int *)(a1 + 408));
  v92 = *(unsigned int *)(a1 + 928);
  if ((_DWORD)v92 != *(_DWORD *)(a1 + 120))
  {
    v101 = "Invalid encryption data size";
    v102 = 753;
    goto LABEL_119;
  }
  memcpy(&v9[*(_QWORD *)(a1 + 304)], (const void *)(a1 + 932), v92);
  if (!*(_DWORD *)(a1 + 1188) && !*(_QWORD *)(a1 + 1712))
  {
LABEL_153:
    v113 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 272);
    if (v113
      && (v114 = v113(a1 + 1448, v9, nbyte), *(_DWORD *)(a1 + 1448) == *(_DWORD *)(a1 + 124))
      && (v114 & 0x80000000) == 0)
    {
      if (AAByteStreamPWrite(a2, v9, nbyte, 0) == nbyte)
      {
        v30 = 0;
        v29 = 0;
        goto LABEL_111;
      }
      v99 = "writing container headers";
      v100 = 801;
    }
    else
    {
      v99 = "digesting prologue";
      v100 = 797;
    }
    goto LABEL_125;
  }
  v95 = *(uint64_t (**)(_OWORD *, char *, size_t))(a1 + 192);
  if (!v95 || (v96 = v95(v128, v9, nbyte), LODWORD(v128[0]) != *(_DWORD *)(a1 + 108)) || v96 < 0)
  {
    v99 = "digesting prologue";
    v100 = 760;
LABEL_125:
    v103 = 0;
    goto LABEL_121;
  }
  v97 = *(uint64_t (**)(_QWORD, uint64_t, char *, _BYTE *, char *))(a1 + 1712);
  if (!v97)
  {
    v104 = *(uint64_t (**)(_OWORD *, uint64_t, _OWORD *))(a1 + 200);
    if (!v104
      || (result = v104(v149, a1 + 1188, v128), LODWORD(v149[0]) != *(_DWORD *)(a1 + 112))
      || (result & 0x80000000) != 0)
    {
      v99 = "signing prologue";
      v100 = 779;
      goto LABEL_125;
    }
LABEL_133:
    if (*(_DWORD *)a1)
    {
      memset(&v207[8], 0, 252);
      memset(v206, 0, 260);
      *(_DWORD *)&v207[7] = 1262834527;
      *(_QWORD *)v207 = 0x5F41454100000007;
      memset_s(&v207[11], 0xF9uLL, 0, 0xF9uLL);
      v105 = *(uint64_t (**)(_OWORD *, _QWORD, _DWORD *, _BYTE *, _OWORD *))(a1 + 144);
      if (v105 && *v117)
      {
        v106 = v105(v130, *(unsigned int *)(a1 + 72), v117, v207, v206);
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
        if ((v106 & 0x80000000) == 0)
        {
          if (*(_QWORD *)(a1 + 216))
          {
            memset(v206, 0, 260);
            v205 = 0;
            v204 = 0u;
            v203 = 0u;
            v202 = 0u;
            v201 = 0u;
            v200 = 0u;
            v199 = 0u;
            v198 = 0u;
            v197 = 0u;
            v196 = 0u;
            v195 = 0u;
            v194 = 0u;
            v193 = 0u;
            v192 = 0u;
            v191 = 0u;
            v190 = 0u;
            v189 = 0u;
            v188 = 0;
            v187 = 0u;
            v186 = 0u;
            v185 = 0u;
            v184 = 0u;
            v183 = 0u;
            v182 = 0u;
            v181 = 0u;
            v180 = 0u;
            v179 = 0u;
            v178 = 0u;
            v177 = 0u;
            v176 = 0u;
            v175 = 0u;
            v174 = 0u;
            v173 = 0u;
            *(_OWORD *)v172 = 0u;
            if (LODWORD(v149[0]) == *(_DWORD *)(a1 + 112) && LODWORD(v130[0]) == *(_DWORD *)(a1 + 72))
            {
              *(_QWORD *)((char *)&v189 + 4) = 0x324B45535F414541;
              LODWORD(v189) = 8;
              memset_s((void *)((unint64_t)&v189 | 0xC), 0xF8uLL, 0, 0xF8uLL);
              memset(v207, 0, sizeof(v207));
              v107 = *(uint64_t (**)(_OWORD *, _QWORD, _OWORD *, __int128 *, _BYTE *))(a1 + 144);
              if (v107)
              {
                if (LODWORD(v130[0]))
                {
                  result = v107(v206, *(unsigned int *)(a1 + 76), v130, &v189, v207);
                  if ((result & 0x80000000) == 0)
                  {
                    v108 = LODWORD(v149[0]);
                    if (LODWORD(v149[0]) >= 0x101)
                      goto LABEL_162;
                    __memcpy_chk();
                    LODWORD(v132[0]) = v108;
                    memset_s((char *)v132 + v108 + 4, 256 - v108, 0, 256 - v108);
                    result = (*(uint64_t (**)(char *, _QWORD, size_t *, _OWORD *, _QWORD, _QWORD))(a1 + 216))((char *)v132 + 4, LODWORD(v149[0]), v172, v206, 0, 0);
                    if ((result & 0x80000000) == 0)
                    {
                      v109 = LODWORD(v132[0]) + (unint64_t)LODWORD(v172[0]);
                      if (v109 >= 0x101)
                        goto LABEL_162;
                      memcpy((char *)v132 + LODWORD(v132[0]) + 4, (char *)v172 + 4, LODWORD(v172[0]));
                      LODWORD(v132[0]) = v109;
                      memset_s((char *)v132 + v109 + 4, 256 - v109, 0, 256 - v109);
                      v110 = v132[0];
                      v111 = *(_DWORD *)(a1 + 116);
                      memset_s(v206, 0x104uLL, 0, 0x104uLL);
                      memset_s(v172, 0x104uLL, 0, 0x104uLL);
                      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
                      if (v110 != v111)
                        goto LABEL_161;
                      goto LABEL_152;
                    }
                  }
                }
              }
            }
            memset_s(v206, 0x104uLL, 0, 0x104uLL);
            memset_s(v172, 0x104uLL, 0, 0x104uLL);
            memset_s(&v189, 0x104uLL, 0, 0x104uLL);
          }
LABEL_161:
          v99 = "encrypt signature";
          v100 = 789;
          goto LABEL_125;
        }
      }
      else
      {
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
      }
      v99 = "deriving signature encryption key";
      v100 = 787;
      goto LABEL_125;
    }
    v112 = LODWORD(v149[0]);
    if (LODWORD(v149[0]) >= 0x101)
      goto LABEL_162;
    __memcpy_chk();
    LODWORD(v132[0]) = v112;
    memset_s((char *)v132 + v112 + 4, 256 - v112, 0, 256 - v112);
LABEL_152:
    memcpy(&v9[*(_QWORD *)(a1 + 296)], (char *)v132 + 4, LODWORD(v132[0]));
    goto LABEL_153;
  }
  *(_QWORD *)v207 = 0;
  result = v97(*(_QWORD *)(a1 + 1720), 256, (char *)v149 + 4, v207, (char *)v128 + 4);
  if ((result & 0x80000000) != 0)
  {
    v99 = "Signing callback";
    v100 = 772;
    goto LABEL_125;
  }
  v98 = *(unsigned int *)(a1 + 112);
  if (*(_QWORD *)v207 > v98)
  {
    v99 = "Invalid callback size return value";
    v100 = 773;
    goto LABEL_125;
  }
  if (v98 < 0x101)
  {
    LODWORD(v149[0]) = *(_DWORD *)(a1 + 112);
    result = memset_s((char *)v149 + v98 + 4, 256 - v98, 0, 256 - v98);
    goto LABEL_133;
  }
LABEL_162:
  __break(1u);
  return result;
}

_QWORD *AAMemoryInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  char v17;

  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 132, 68, 0, "Invalid arguments", a7, a8, v17);
    v10 = 0;
    v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v12 = malloc(0x20uLL);
  v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 137, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  *v11 = a1;
  v11[1] = a2;
  *v10 = v11;
  v10[1] = memoryInputStreamClose;
  v10[2] = memoryInputStreamRead;
  v10[4] = memoryInputStreamPRead;
  v10[6] = memoryInputStreamSeek;
  v10[7] = memoryInputStreamCancel;
  return v10;
}

uint64_t memoryInputStreamClose(void *a1)
{
  free(a1);
  return 0;
}

uint64_t memoryInputStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 24);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

size_t memoryInputStreamRead(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t *v5;
  uint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  v5 = (unint64_t *)(a1 + 16);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return memoryInputStreamPRead(a1, a2, a3, v6);
}

size_t memoryInputStreamPRead(uint64_t a1, void *__dst, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  size_t v5;
  unint64_t v6;
  unint64_t v7;

  v4 = atomic_load((unsigned int *)(a1 + 24));
  v5 = -1;
  if ((a4 & 0x8000000000000000) == 0 && !v4)
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = (uint64_t)v6 >= a4 ? a4 : *(_QWORD *)(a1 + 8);
    if (!__CFADD__(v7, a3))
    {
      if (v7 + a3 < v6)
        v6 = v7 + a3;
      v5 = v6 - v7;
      if (v6 <= v7)
        return 0;
      else
        memcpy(__dst, (const void *)(*(_QWORD *)a1 + v7), v5);
    }
  }
  return v5;
}

uint64_t memoryInputStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  if (!a3)
    goto LABEL_7;
  if (a3 != 1)
  {
    if (a3 != 2)
      return -1;
    a2 += *(_QWORD *)(a1 + 8);
LABEL_7:
    atomic_store(a2, (unint64_t *)(a1 + 16));
    return a2;
  }
  v4 = (unint64_t *)(a1 + 16);
  do
  {
    v5 = __ldaxr(v4);
    v6 = v5 + a2;
  }
  while (__stlxr(v6, v4));
  return v6;
}

_QWORD *AAMemoryOutputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  char v17;

  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamOpen", 169, 68, 0, "Invalid arguments", a7, a8, v17);
    v10 = 0;
    v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v12 = malloc(0x20uLL);
  v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamOpen", 174, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  v11[1] = 0;
  v11[2] = a2;
  *v11 = a1;
  *v10 = v11;
  v10[1] = memoryOutputStreamClose;
  v10[7] = memoryOutputStreamCancel;
  v10[3] = memoryOutputStreamWrite;
  return v10;
}

uint64_t memoryOutputStreamClose(void *a1)
{
  free(a1);
  return 0;
}

uint64_t memoryOutputStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 24);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

size_t memoryOutputStreamWrite(_QWORD *a1, const void *a2, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t v10;
  size_t v11;
  const char *v12;
  __int16 v13;
  char v15;

  v8 = __n;
  if (__n)
  {
    v10 = a1[1];
    v11 = v10 + __n;
    if (__CFADD__(v10, __n))
    {
      v12 = "invalid size";
      v13 = 102;
    }
    else
    {
      if (v11 <= a1[2])
      {
        memcpy((void *)(*a1 + v10), a2, __n);
        a1[1] = v11;
        return v8;
      }
      v12 = "buffer full";
      v13 = 103;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"memoryOutputStreamWrite", v13, 68, 0, v12, a7, a8, v15);
    return -1;
  }
  return v8;
}

uint64_t AAMemoryOutputStreamCloseWithSize(uint64_t (**a1)(void *a1), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v13;

  if (!a1)
    return 0;
  if (a1[1] == memoryOutputStreamClose)
  {
    v9 = *((_QWORD *)*a1 + 1);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamCloseWithSize", 201, 68, 0, "invalid stream type", a7, a8, v13);
    v9 = -1;
  }
  if (AAByteStreamClose((AAByteStream)a1) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamCloseWithSize", 207, 68, 0, "close stream", v10, v11, v13);
    return -1;
  }
  return v9;
}

AAByteStream_impl *aaForkOutputStreamOpen(uint64_t a1, _QWORD *a2)
{
  AAByteStream_impl *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t i;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  char v38;

  v4 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  v5 = calloc(1uLL, 0x20050uLL);
  v8 = v5;
  if (!v4 || !v5)
  {
    v17 = *__error();
    v18 = "malloc";
    v19 = 405;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", v19, 136, v17, v18, v6, v7, v38);
    goto LABEL_14;
  }
  if (!*(_QWORD *)(a1 + 40) || !*(_QWORD *)(a1 + 32))
  {
    v18 = "stream not compatible\n";
    v19 = 406;
    v17 = 0;
    goto LABEL_13;
  }
  v9 = v5 + 16385;
  AACustomByteStreamSetData(v4, v5);
  AACustomByteStreamSetWriteProc(v4, (AAByteStreamWriteProc)ForkOutputStreamWrite);
  AACustomByteStreamSetPWriteProc(v4, (AAByteStreamPWriteProc)ForkOutputStreamPWrite);
  AACustomByteStreamSetCancelProc(v4, (AAByteStreamCancelProc)ForkOutputStreamCancel);
  AACustomByteStreamSetCloseProc(v4, (AAByteStreamCloseProc)ForkOutputStreamClose);
  *v9 = a1;
  v8[16386] = a2;
  if (a2[258])
    v10 = a2[270] + 1;
  else
    v10 = a2[270];
  v8[16390] = v10;
  if (is_mul_ok(v10, 0x30uLL) && 48 * v10 < 0x2000000001)
  {
    v16 = calloc(v10, 0x30uLL);
  }
  else
  {
    v13 = __error();
    v16 = 0;
    *v13 = 12;
  }
  v8[16389] = v16;
  *(_OWORD *)(v8 + 16391) = 0u;
  *((_DWORD *)v8 + 32786) = 0;
  if (!v16)
  {
    v17 = *__error();
    v18 = "aaCalloc";
    v19 = 423;
    goto LABEL_13;
  }
  v28 = 0;
  v29 = a2[270];
  v30 = a2[258];
  v31 = 1;
  v32 = v16;
  while (1)
  {
    if (v29)
    {
      v33 = (_QWORD *)a2[268];
      for (i = v29; i; --i)
      {
        v35 = v33[51];
        if ((v31 & 1) != 0)
        {
          if ((v35 & 1) != 0)
          {
            *v32 = v33;
            v32[1] = v28;
            v36 = (_QWORD *)v33[48];
            v37 = v33[49];
            v32[2] = 0;
            v32[3] = v37;
            v32[4] = *v36;
LABEL_26:
            v32[5] = v33[5];
            v28 += v37;
            v8[16392] = v28;
            v32 += 6;
          }
        }
        else if ((v35 & 2) != 0)
        {
          v32[1] = v28;
          v32[2] = 0;
          v37 = v33[4];
          v32[3] = v37;
          goto LABEL_26;
        }
        v33 += 55;
      }
    }
    if ((v31 & 1) == 0)
      break;
    v31 = 0;
    v14 = v28;
    v15 = v28;
    if (v30)
    {
      v31 = 0;
      v32[1] = v28;
      v32[2] = 0;
      v32[3] = v30;
      v32[5] = 0;
      v14 = v30 + v28;
      v32 += 6;
      v15 = v28;
      v28 = v14;
      v8[16392] = v14;
    }
  }
  a2[257] = v15;
  a2[259] = v14;
  if (v32 == &v16[6 * v8[16390]])
  {
    a2[260] = v28;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", 477, 136, 0, "bad variant", v11, v12, v38);
    a2[260] = v8[16392];
LABEL_14:
    free(v4);
    ForkOutputStreamClose((void **)v8, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return v4;
}

uint64_t ForkOutputStreamWrite(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD **v8;
  const char *v9;
  __int16 v10;
  unint64_t v11;
  const uint8_t *v13;
  unint64_t v14;
  _QWORD *v15;
  size_t *v16;
  size_t v17;
  size_t *v18;
  unint64_t v19;
  size_t v20;
  size_t *v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  _DWORD *v33;
  size_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  size_t v39;
  size_t v40;
  size_t *v41;
  size_t *v42;
  _QWORD *v43;
  uint64_t v44;
  size_t v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _DWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  __int16 v77;
  const char *v78;
  BOOL v79;
  size_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint8_t *v84;
  size_t v85;
  uint64_t v86;
  BOOL v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  size_t v92;
  _DWORD *v93;
  uint64_t v94;
  uint64_t v95;
  _DWORD *v96;
  _DWORD *v97;
  int *v98;
  int v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _DWORD *v104;
  size_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  _DWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint8_t *v130;
  unint64_t v131;
  uint64_t v132;
  const char *v133;
  __int16 v134;
  int *v135;
  uint64_t v136;
  uint64_t v137;
  char v138;
  void *__dst;
  size_t *v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t *v144;
  unint64_t v145;
  _QWORD *v147;
  size_t *v148;
  _QWORD *v149;
  size_t v150;
  uint8_t *dst_buffer;
  size_t *v152;
  _QWORD *v153;
  uint64_t *v154;
  _QWORD *v155;
  unint64_t v156;
  uint64_t *v157;

  v8 = (_QWORD **)(a1 + 32770);
  if (a1[32786])
  {
    v9 = "bad write mode";
    v10 = 198;
    goto LABEL_3;
  }
  v11 = a3;
  if (!a3)
    return v11;
  v13 = (const uint8_t *)a1;
  v14 = 0;
  dst_buffer = (uint8_t *)a1 + 65537;
  __dst = (char *)a1 + 65538;
  v155 = a1 + 32770;
  while (1)
  {
    v15 = v8[6];
    if (v15 == v8[5])
    {
      v9 = "segment out of range";
      v10 = 202;
      goto LABEL_3;
    }
    v153 = v8[4];
    v16 = &v153[6 * (_QWORD)v15];
    v18 = v16 + 2;
    v17 = v16[2];
    v19 = v11 - v14;
    v21 = v16 + 3;
    v20 = v16[3];
    if (v11 - v14 >= 0x10000 - (unint64_t)(unsigned __int16)v17)
      v19 = 0x10000 - (unsigned __int16)v17;
    if (v20 - v17 >= v19)
      v22 = v19;
    else
      v22 = v20 - v17;
    memcpy((void *)&v13[(unsigned __int16)v17], (const void *)(a2 + v14), v22);
    v23 = v22 + *v18;
    v152 = v16 + 2;
    *v18 = v23;
    v149 = v16 + 3;
    v24 = *v21;
    if (v23 == *v21)
      v8[6] = (_QWORD *)((char *)v8[6] + 1);
    v25 = (unsigned __int16)v23;
    if ((_WORD)v23)
    {
      if (v23 < v24)
        goto LABEL_134;
    }
    else
    {
      v25 = 0x10000;
    }
    v150 = v22;
    v26 = (_QWORD *)*v16;
    if (!*v16)
    {
      v30 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        v31 = 0;
        v32 = v23 - v25 + v153[6 * (_QWORD)v15 + 5];
        v33 = a1;
        v34 = v25;
        while (1)
        {
          v35 = (*(uint64_t (**)(_QWORD, _DWORD *, size_t, size_t))(v30 + 40))(*(_QWORD *)v30, v33, v34, v32);
          if (v35 < 1)
            break;
          v33 = (_DWORD *)((char *)v33 + v35);
          v31 += v35;
          v32 += v35;
          v34 -= v35;
          if (!v34)
            goto LABEL_85;
        }
        v31 = v35;
      }
      else
      {
        v31 = -1;
      }
LABEL_85:
      v87 = v25 == v31;
      v8 = (_QWORD **)v155;
      v13 = (const uint8_t *)a1;
      v22 = v150;
      if (!v87)
      {
        v9 = "aaByteStreamPWriteExpected";
        v10 = 230;
        goto LABEL_3;
      }
      goto LABEL_134;
    }
    v27 = v26[7];
    v145 = v14;
    v148 = &v153[6 * (_QWORD)v15];
    if ((unint64_t)v8[3] < v27)
    {
      v8[3] = (_QWORD *)v27;
      if (24 * v27 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        v28 = v8[2];
        v29 = realloc(v28, 24 * v27);
        if (v29)
        {
          v8[2] = v29;
          v23 = *v152;
          goto LABEL_30;
        }
        free(v28);
      }
      v8[2] = 0;
      v9 = "aaReallocf";
      v10 = 240;
      goto LABEL_3;
    }
    v29 = v8[2];
LABEL_30:
    v36 = (v23 - 1) >> 16;
    v37 = v26[48] + 12 * v36;
    v156 = v36;
    v38 = &v29[3 * v36];
    v39 = compression_encode_buffer(dst_buffer, 0x10000uLL, v13, v25, 0, (compression_algorithm)LODWORD(v8[1][*((unsigned __int8 *)v26 + 432)]));
    if (v39 - 1 >= v25)
      v40 = v25 + 1;
    else
      v40 = v39;
    v38[1] = v40;
    v41 = v38 + 1;
    v144 = v38;
    v38[2] = v40;
    v42 = v38 + 2;
    v43 = &v153[6 * (_QWORD)v15];
    v44 = v43[4];
    v157 = v43 + 4;
    v45 = *(_QWORD *)v37 + *(unsigned int *)(v37 + 8);
    v46 = v40;
    if (v44 + v40 < v45)
    {
      v46 = v45 - v44;
      *v42 = v45 - v44;
    }
    if (v46 == v25 + 1)
    {
      *v41 = v25 + 1;
      *dst_buffer = BYTE4(v8[1][*((unsigned __int8 *)v26 + 432)]);
      memcpy(__dst, a1, v25);
      v40 = *v41;
      v46 = *v42;
    }
    bzero(&dst_buffer[v40], v46 - v40);
    v47 = v26[50];
    v48 = *v157;
    v49 = v47 - *v157;
    v50 = *v42 - v49;
    v147 = v15;
    if (*v42 > v49)
      break;
LABEL_76:
    *v144 = v48;
    v80 = *v42;
    v81 = (uint64_t)*v8;
    if ((*v8)[5])
    {
      if (!v80)
        goto LABEL_89;
      v82 = 0;
      v83 = v153[6 * (_QWORD)v15 + 5] + v48;
      v84 = dst_buffer;
      v85 = *v42;
      while (1)
      {
        v86 = (*(uint64_t (**)(_QWORD, uint8_t *, size_t, uint64_t))(v81 + 40))(*(_QWORD *)v81, v84, v85, v83);
        if (v86 < 1)
          break;
        v84 += v86;
        v82 += v86;
        v83 += v86;
        v85 -= v86;
        if (!v85)
          goto LABEL_88;
      }
      v82 = v86;
    }
    else
    {
      v82 = -1;
    }
LABEL_88:
    v8 = (_QWORD **)v155;
    v15 = v147;
    v16 = v148;
    if (v80 != v82)
    {
      v9 = "aaByteStreamPWriteExpected";
      v10 = 287;
      goto LABEL_3;
    }
LABEL_89:
    *v157 += v80;
    v22 = v150;
    v13 = (const uint8_t *)a1;
    v14 = v145;
    if (*v152 == *v149)
    {
      v88 = (_QWORD *)*v16;
      v89 = *(_QWORD *)(*v16 + 408);
      v90 = *(_QWORD *)(*v16 + 56);
      v91 = 2 * v90;
      if ((v89 & 4) == 0)
        v91 = v90 + 1;
      v92 = 4 * v91;
      if ((unint64_t)(4 * v91) >= 0x2000000001)
      {
        *__error() = 12;
LABEL_148:
        v135 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", 81, 136, *v135, "aaMalloc", v136, v137, v138);
        v96 = 0;
        goto LABEL_142;
      }
      v93 = malloc(v92);
      if (!v93)
        goto LABEL_148;
      v96 = v93;
      if ((v89 & 4) != 0)
      {
        v107 = (uint64_t)*v8;
        if ((*v8)[5])
        {
          v108 = 0;
          v109 = &v153[6 * (_QWORD)v147 + 5];
          v110 = v88 + 41;
          v111 = *v109 + v88[50] - 50;
          v112 = 50;
          while (1)
          {
            v113 = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t))(v107 + 40))(*(_QWORD *)v107, v110, v112, v111);
            if (v113 < 1)
              break;
            v110 = (_QWORD *)((char *)v110 + v113);
            v108 += v113;
            v111 += v113;
            v112 -= v113;
            if (!v112)
            {
              if (v108 != 50)
                break;
              v114 = (_QWORD *)*v155;
              if (*(_QWORD *)(*v155 + 40))
              {
                v115 = 0;
                v116 = v88 + 8;
                v117 = *v109;
                v118 = 264;
                while (1)
                {
                  v119 = ((uint64_t (*)(_QWORD, _QWORD *, uint64_t, uint64_t))v114[5])(*v114, v116, v118, v117);
                  if (v119 < 1)
                    break;
                  v116 = (_QWORD *)((char *)v116 + v119);
                  v115 += v119;
                  v117 += v119;
                  v118 -= v119;
                  if (!v118)
                  {
                    if (v115 != 264)
                      break;
                    v120 = v88[7];
                    v8 = (_QWORD **)v155;
                    if (v120)
                    {
                      v121 = (_QWORD *)(v155[2] + 16);
                      v122 = v96 + 1;
                      do
                      {
                        *(v122 - 1) = *((_DWORD *)v121 - 4) - 260;
                        v123 = *v121;
                        v121 += 3;
                        *v122 = v123;
                        v122 += 2;
                        --v120;
                      }
                      while (v120);
                    }
                    v101 = *v109 + 264;
                    v14 = v145;
                    goto LABEL_99;
                  }
                }
              }
              v133 = "aaByteStreamPWriteExpected";
              v134 = 94;
              goto LABEL_141;
            }
          }
        }
        v133 = "aaByteStreamPWriteExpected";
        v134 = 89;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", v134, 136, 0, v133, v94, v95, v138);
LABEL_142:
        free(v96);
        v9 = "fork_write_index";
        v10 = 294;
        goto LABEL_3;
      }
      if (v90)
      {
        v97 = v93 + 1;
        v98 = (int *)(v8[2] + 2);
        do
        {
          v99 = *(v98 - 4);
          *(v97 - 1) = v99;
          v100 = *v98;
          v98 += 6;
          *v97++ = v100 + v99;
          --v90;
        }
        while (v90);
      }
      v101 = v153[6 * (_QWORD)v15 + 5];
      v14 = v145;
LABEL_99:
      v102 = (uint64_t)*v8;
      if (!(*v8)[5])
        goto LABEL_149;
      if (v92)
      {
        v103 = 0;
        v104 = v96;
        v105 = v92;
        while (1)
        {
          v106 = (*(uint64_t (**)(_QWORD, _DWORD *, size_t, uint64_t))(v102 + 40))(*(_QWORD *)v102, v104, v105, v101);
          if (v106 < 1)
            break;
          v104 = (_DWORD *)((char *)v104 + v106);
          v103 += v106;
          v101 += v106;
          v105 -= v106;
          if (!v105)
            goto LABEL_120;
        }
        v103 = v106;
LABEL_120:
        v87 = v92 == v103;
        v8 = (_QWORD **)v155;
        v14 = v145;
        if (!v87)
        {
LABEL_149:
          v133 = "aaByteStreamPWriteExpected";
          v134 = 117;
          goto LABEL_141;
        }
      }
      v124 = v88[4];
      v125 = v88[50];
      v126 = v124 - v125;
      if (v124 != v125)
      {
        if (v126 >= 0x1000)
        {
          v133 = "too much padding";
          v134 = 123;
          goto LABEL_141;
        }
        bzero(dst_buffer, v124 - v125);
        v127 = (uint64_t)*v8;
        if (!(*v8)[5])
          goto LABEL_150;
        if (v126)
        {
          v128 = 0;
          v129 = v153[6 * (_QWORD)v147 + 5] + v88[50];
          v130 = dst_buffer;
          v131 = v126;
          while (1)
          {
            v132 = (*(uint64_t (**)(_QWORD, uint8_t *, unint64_t, uint64_t))(v127 + 40))(*(_QWORD *)v127, v130, v131, v129);
            if (v132 < 1)
              break;
            v130 += v132;
            v128 += v132;
            v129 += v132;
            v131 -= v132;
            if (!v131)
              goto LABEL_131;
          }
          v128 = v132;
LABEL_131:
          v87 = v126 == v128;
          v8 = (_QWORD **)v155;
          v14 = v145;
          if (!v87)
          {
LABEL_150:
            v133 = "aaByteStreamPWriteExpected";
            v134 = 126;
            goto LABEL_141;
          }
        }
      }
      free(v96);
      v11 = a3;
      v13 = (const uint8_t *)a1;
      v22 = v150;
    }
LABEL_134:
    v14 += v22;
    if (v14 >= v11)
      return v11;
  }
  v51 = (_DWORD)v153 + 48 * (_DWORD)v15 + 40;
  v154 = &v153[6 * (_QWORD)v15 + 5];
  v52 = v156;
  v140 = v42;
  do
  {
    if (!v52)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", 142, 136, 0, "realignment failed", a7, a8, v138);
      goto LABEL_139;
    }
    v53 = v8[2];
    v54 = &v53[3 * v52 - 3];
    v57 = v54[2];
    v55 = v54 + 2;
    v56 = v57;
    v58 = *(v55 - 1);
    v59 = v57 - v58;
    v60 = v50 - (v57 - v58);
    if (v50 > v57 - v58)
    {
      *v55 = v58;
      --v52;
      goto LABEL_73;
    }
    *v55 = v56 - v50;
    v48 = v53[3 * v52 - 3] + v56 - v50;
    *v157 = v48;
    if (v52 >= v156)
      goto LABEL_76;
    v141 = v59;
    v142 = v50;
    while (1)
    {
      v61 = &v8[2][3 * v52];
      v62 = *v154;
      v63 = v61[1];
      v64 = *v61 + *v154;
      v65 = (uint64_t)*v8;
      if ((*v8)[11])
      {
        if (v63 != aaByteStreamSimulate(*v8))
        {
          v77 = 173;
          v78 = "aaByteStreamSimulate";
          goto LABEL_72;
        }
        goto LABEL_59;
      }
      if (*(_QWORD *)(v65 + 32))
      {
        if (!v63)
        {
          if (!*(_QWORD *)(v65 + 40))
            goto LABEL_70;
          goto LABEL_68;
        }
        v66 = 0;
        v67 = a1;
        v68 = v61[1];
        while (1)
        {
          v69 = (*(uint64_t (**)(_QWORD, _DWORD *, uint64_t, uint64_t))(v65 + 32))(*(_QWORD *)v65, v67, v68, v64);
          if (v69 < 0)
            break;
          if (v69)
          {
            v67 = (_DWORD *)((char *)v67 + v69);
            v66 += v69;
            v64 += v69;
            v68 -= v69;
            if (v68)
              continue;
          }
          goto LABEL_58;
        }
        v66 = v69;
      }
      else
      {
        v66 = -1;
      }
LABEL_58:
      v8 = (_QWORD **)v155;
      if (v63 != v66)
        break;
LABEL_59:
      v70 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        if (!v63)
          goto LABEL_68;
        v71 = 0;
        v72 = v62 + v48;
        v73 = a1;
        v74 = v63;
        while (1)
        {
          v75 = (*(uint64_t (**)(_QWORD, _DWORD *, uint64_t, uint64_t))(v70 + 40))(*(_QWORD *)v70, v73, v74, v72);
          if (v75 < 1)
            break;
          v73 = (_DWORD *)((char *)v73 + v75);
          v71 += v75;
          v72 += v75;
          v74 -= v75;
          if (!v74)
            goto LABEL_67;
        }
        v71 = v75;
      }
      else
      {
        v71 = -1;
      }
LABEL_67:
      v8 = (_QWORD **)v155;
      if (v63 != v71)
      {
LABEL_70:
        v77 = 180;
        v78 = "aaByteStreamPWriteExpected";
        goto LABEL_72;
      }
LABEL_68:
      v76 = *v157;
      *v61 = *v157;
      v48 = v76 + v63;
      *v157 = v76 + v63;
      if (++v52 == v156)
        goto LABEL_75;
    }
    v77 = 176;
    v78 = "aaByteStreamPReadExpected";
LABEL_72:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", v77, 136, 0, v78, a7, a8, v138);
    v51 = -1;
    v50 = v142;
    v11 = a3;
    v60 = v142;
    v15 = v147;
    v16 = v148;
    v42 = v140;
    v59 = v141;
LABEL_73:
    v79 = v50 > v59;
    v50 = v60;
  }
  while (v79);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_75:
    v48 = *v157;
    v11 = a3;
    v15 = v147;
    v16 = v148;
    v42 = v140;
    goto LABEL_76;
  }
LABEL_139:
  v9 = "realign_fork";
  v10 = 279;
LABEL_3:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamWrite", v10, 136, 0, v9, a7, a8, v138);
  return -1;
}

uint64_t ForkOutputStreamPWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;

  v8 = a4;
  v9 = (uint64_t *)(a1 + 131080);
  if (*(_DWORD *)(a1 + 131144))
  {
LABEL_2:
    v10 = 0;
    if (a3)
    {
      v41 = a3;
      while (1)
      {
        if (v9[7] <= v8)
        {
LABEL_35:
          v32 = "no segment found";
          v33 = 340;
          goto LABEL_48;
        }
        v11 = v9[4];
        v12 = v9[5];
        if (v12 < 2)
        {
          if (!v11)
            goto LABEL_35;
          v13 = 0;
        }
        else
        {
          v13 = 0;
          do
          {
            if (*(_QWORD *)(v11 + 48 * ((v13 + v12) >> 1) + 8) > v8)
              v12 = (v13 + v12) >> 1;
            else
              v13 = (v13 + v12) >> 1;
          }
          while (v13 + 1 < v12);
        }
        if (*(_QWORD *)(v11 + 48 * v13))
        {
          v32 = "compressed fork";
          v33 = 341;
          goto LABEL_48;
        }
        v14 = (_QWORD *)(v11 + 48 * v13);
        v15 = v8 - v14[1];
        v16 = v14[3];
        if (a3 - v10 >= v16 - v15)
          v17 = v16 - v15;
        else
          v17 = a3 - v10;
        v18 = v17 + v14[2];
        v14[2] = v18;
        if (v18 > v16)
        {
          v32 = "too much data";
          v33 = 349;
          goto LABEL_48;
        }
        v19 = *v9;
        if (*(_QWORD *)(*v9 + 40))
        {
          if (!v17)
            goto LABEL_28;
          v20 = 0;
          v21 = a2 + v10;
          v22 = *(_QWORD *)(v11 + 48 * v13 + 40) + v15;
          v23 = v17;
          while (1)
          {
            v24 = (*(uint64_t (**)(_QWORD, unint64_t, unint64_t, unint64_t))(v19 + 40))(*(_QWORD *)v19, v21, v23, v22);
            if (v24 < 1)
              break;
            v21 += v24;
            v20 += v24;
            v22 += v24;
            v23 -= v24;
            if (!v23)
              goto LABEL_27;
          }
          v20 = v24;
        }
        else
        {
          v20 = -1;
        }
LABEL_27:
        a3 = v41;
        if (v17 != v20)
        {
          v32 = "aaByteStreamPWriteExpected";
          v33 = 353;
          goto LABEL_48;
        }
LABEL_28:
        v8 += v17;
        v10 += v17;
        if (v10 >= a3)
          return v10;
      }
    }
    return v10;
  }
  v25 = a1;
  v26 = *(_QWORD *)(a1 + 131112);
  v27 = *(_QWORD *)(a1 + 131128);
  v28 = (_QWORD *)(v26 + 48 * v27);
  v29 = v28[2];
  if (v29 + v28[1] == a4)
    return ForkOutputStreamWrite((_DWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  v31 = (unsigned __int16)v28[2];
  if (!(unsigned __int16)v28[2])
    goto LABEL_46;
  if (*v28)
  {
    v32 = "pending compressed fork";
    v33 = 323;
    goto LABEL_48;
  }
  v34 = *v9;
  if (*(_QWORD *)(*v9 + 40))
  {
    v35 = a3;
    v36 = 0;
    v37 = (v29 & 0xFFFFFFFFFFFF0000) + *(_QWORD *)(v26 + 48 * v27 + 40);
    v38 = (unsigned __int16)v28[2];
    while (1)
    {
      v39 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, unint64_t))(v34 + 40))(*(_QWORD *)v34, v25, v38, v37);
      if (v39 < 1)
        break;
      v25 += v39;
      v36 += v39;
      v37 += v39;
      v38 -= v39;
      if (!v38)
        goto LABEL_45;
    }
    v36 = v39;
LABEL_45:
    a3 = v35;
    if (v31 == v36)
    {
LABEL_46:
      *((_DWORD *)v9 + 16) = 1;
      goto LABEL_2;
    }
  }
  v32 = "aaByteStreamPWriteExpected";
  v33 = 325;
LABEL_48:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamPWrite", v33, 136, 0, v32, a7, a8, a2);
  return -1;
}

void ForkOutputStreamCancel(uint64_t a1)
{
  AAByteStreamCancel(*(AAByteStream *)(a1 + 131080));
}

uint64_t ForkOutputStreamClose(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **v9;
  _QWORD *v10;
  char *v11;
  _QWORD *v12;
  int v13;
  char v15;

  if (a1)
  {
    v9 = a1 + 16387;
    v10 = a1[16389];
    if (v10)
    {
      v11 = (char *)v9[3];
      if (v11)
      {
        v12 = v10 + 3;
        while (*(v12 - 1) == *v12)
        {
          v12 += 6;
          if (!--v11)
            goto LABEL_7;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamClose", 382, 136, 0, "data missing", a7, a8, v15);
        v13 = 0;
        v10 = v9[2];
      }
      else
      {
LABEL_7:
        v13 = 1;
      }
      free(v10);
    }
    else
    {
      v13 = 1;
    }
    free(*v9);
    free(a1);
  }
  else
  {
    v13 = 1;
  }
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t BlobBufferStore(uint64_t a1, const void *a2, size_t a3, _QWORD *a4)
{
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;

  if (!a3)
    return 0xFFFFFFFFLL;
  v8 = *(_QWORD *)(a1 + 8) + a3;
  if ((BlobBufferIncreaseCapacity(a1, v8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferStore", 19, 6, 0, "BlobBufferStore", v9, v10, v12);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (a2)
      memcpy((void *)(*(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8)), a2, a3);
    if (a4)
    {
      *a4 = *(_QWORD *)(a1 + 8);
      a4[1] = a3;
    }
    result = 0;
    *(_QWORD *)(a1 + 8) = v8;
  }
  return result;
}

uint64_t BlobBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  size_t v2;
  uint64_t v4;
  void *v5;
  uint64_t result;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a1 >= a2)
    return 0;
  do
  {
    v4 = v2 + (v2 >> 1);
    if (__CFADD__(v2, v2 >> 1))
      v4 = -1;
    if (v2)
      v2 = v4;
    else
      v2 = 0x10000;
  }
  while (v2 < a2);
  v5 = reallocf(*(void **)(a1 + 16), v2);
  *(_QWORD *)(a1 + 16) = v5;
  if (v5)
  {
    result = 0;
    *(_QWORD *)a1 = v2;
  }
  else
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferIncreaseCapacity", 58, 6, *v7, "malloc", v8, v9, v10);
    return 0xFFFFFFFFLL;
  }
  return result;
}

void BlobBufferFree(uint64_t a1)
{
  free(*(void **)(a1 + 16));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
}

void *StringTableCreate()
{
  void *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  char v5;

  v0 = calloc(1uLL, 0x28uLL);
  if (!v0)
  {
    v1 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableCreate", 30, 35, *v1, "malloc", v2, v3, v5);
  }
  return v0;
}

uint64_t stringTableReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v4;
  void *v5;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2)
    return 0;
  v4 = v2 ? v2 + (v2 >> 1) : 32;
  if (v4 <= a2)
    v4 = a2;
  *(_DWORD *)(a1 + 4) = v4;
  v5 = reallocf(*(void **)(a1 + 8), 16 * v4);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
    return 0;
  v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"stringTableReserve", 23, 35, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

void StringTableDestroy(void **a1)
{
  if (a1)
  {
    BlobBufferFree((uint64_t)(a1 + 2));
    free(a1[1]);
    free(a1);
  }
}

uint64_t StringTableClear(uint64_t result)
{
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)result = 0;
  return result;
}

uint64_t StringTableAppend(unsigned int *a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v11;
  __int16 v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  _QWORD v17[2];

  if (a4)
    *a4 = *a1;
  if (HIDWORD(a3))
  {
    v11 = "string too long for StringTable";
    v12 = 74;
  }
  else if (stringTableReserve((uint64_t)a1, *a1 + 1))
  {
    v11 = "increasing string table capacity";
    v12 = 77;
  }
  else
  {
    v17[0] = 0;
    v17[1] = 0;
    if (!BlobBufferStore((uint64_t)(a1 + 4), 0, a3 + 1, v17))
    {
      v14 = *((_QWORD *)a1 + 1) + 16 * *a1;
      v15 = v17[0];
      *(_QWORD *)v14 = v17[0];
      *(_DWORD *)(v14 + 8) = a3;
      v16 = (void *)(*((_QWORD *)a1 + 4) + v15);
      memcpy(v16, a2, a3);
      result = 0;
      *((_BYTE *)v16 + a3) = 0;
      ++*a1;
      return result;
    }
    v11 = "insertion failed in string table";
    v12 = 81;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppend", v12, 35, 0, v11, a7, a8, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t StringTableAppendTable(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  __int16 v8;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  _QWORD v15[2];

  if (a3)
    *a3 = *(_DWORD *)a1;
  if (!*a2)
    return 0;
  if (stringTableReserve(a1, *(_DWORD *)a1 + *a2))
  {
    v7 = "increasing string table capacity";
    v8 = 152;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppendTable", v8, 35, 0, v7, v5, v6, v15[0]);
    return 0xFFFFFFFFLL;
  }
  v15[0] = 0;
  v15[1] = 0;
  if (BlobBufferStore(a1 + 16, *((const void **)a2 + 4), *((_QWORD *)a2 + 3), v15))
  {
    v7 = "increasing blob capacity failed";
    v8 = 156;
    goto LABEL_9;
  }
  if (*a2)
  {
    v10 = 0;
    v11 = 0;
    v12 = *(_QWORD *)(a1 + 8);
    do
    {
      v13 = v11 + *(_DWORD *)a1;
      *(_OWORD *)(v12 + 16 * v13) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v10);
      v12 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(v12 + 16 * v13) += v15[0];
      ++v11;
      v14 = *a2;
      v10 += 16;
    }
    while (v11 < v14);
  }
  else
  {
    LODWORD(v14) = 0;
  }
  result = 0;
  *(_DWORD *)a1 += v14;
  return result;
}

size_t StringTableSort(unsigned int *a1, _QWORD *a2)
{
  size_t result;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  result = *a1;
  if ((_DWORD)result)
  {
    if (a2)
    {
      v5 = calloc(result, 4uLL);
      if (!v5)
      {
        v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableSort", 195, 35, *v13, "malloc", v14, v15, v16);
        return 0xFFFFFFFFLL;
      }
      v6 = v5;
      *a2 = v5;
      result = *a1;
      if ((_DWORD)result)
      {
        v7 = 0;
        v8 = (_DWORD *)(*((_QWORD *)a1 + 1) + 12);
        do
        {
          *v8 = v7;
          v8 += 4;
          ++v7;
        }
        while (result != v7);
      }
    }
    else
    {
      v6 = 0;
    }
    qsort_r(*((void **)a1 + 1), result, 0x10uLL, a1, (int (__cdecl *)(void *, const void *, const void *))stringTableIndexCompareProc);
    if (*a1 < 2)
    {
      v11 = 1;
    }
    else
    {
      v9 = 0;
      v10 = 1;
      v11 = 1;
      do
      {
        v12 = *((_QWORD *)a1 + 1);
        if (!strcmp((const char *)(*((_QWORD *)a1 + 4) + *(_QWORD *)(v12 + 16 * (v11 - 1))), (const char *)(*((_QWORD *)a1 + 4) + *(_QWORD *)(v12 + v9 + 16))))
        {
          if (v6)
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11 - 1;
        }
        else
        {
          if (v6)
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11;
          if (v10 != v11)
            *(_OWORD *)(v12 + 16 * v11) = *(_OWORD *)(v12 + v9 + 16);
          ++v11;
        }
        ++v10;
        v9 += 16;
      }
      while (v10 < *a1);
    }
    result = 0;
    *a1 = v11;
  }
  return result;
}

uint64_t stringTableIndexCompareProc(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return strcmp((const char *)(*(_QWORD *)(a1 + 32) + *a2), (const char *)(*(_QWORD *)(a1 + 32) + *a3));
}

uint64_t StringTableSearchSortedWithLength(uint64_t a1, char *__s1, size_t a3, unsigned int *a4)
{
  int v5;
  uint64_t v9;
  size_t v10;
  int v11;
  uint64_t result;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;

  v5 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
    goto LABEL_6;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(unsigned int *)(v9 + 8);
  v11 = strncmp(__s1, (const char *)(*(_QWORD *)(a1 + 32) + *(_QWORD *)v9), a3);
  if (v11)
  {
    if ((v11 & 0x80000000) == 0)
      goto LABEL_11;
LABEL_6:
    result = 0;
    if (!a4)
      return result;
    v13 = -1;
    goto LABEL_8;
  }
  if (v10 > a3)
    goto LABEL_6;
  if (v10 >= a3)
  {
    result = 1;
    if (!a4)
      return result;
    v13 = 0;
    goto LABEL_8;
  }
LABEL_11:
  v13 = v5 - 1;
  v14 = StringTableCmp(a1, v13, __s1, a3);
  if (v14 >= 1)
  {
    result = 0;
    if (!a4)
      return result;
LABEL_8:
    *a4 = v13;
    return result;
  }
  if (v14)
  {
    if (v13 < 2)
    {
      v15 = 0;
LABEL_28:
      result = 0;
      v13 = v15;
      if (a4)
        goto LABEL_8;
    }
    else
    {
      v15 = 0;
      while (1)
      {
        v16 = StringTableCmp(a1, v15 + ((v13 - v15) >> 1), __s1, a3);
        if (!v16)
          break;
        if (v16 < 0)
          v13 = v15 + ((v13 - v15) >> 1);
        else
          v15 += (v13 - v15) >> 1;
        if (v15 + 1 >= v13)
          goto LABEL_28;
      }
      result = 1;
      v13 = v15 + ((v13 - v15) >> 1);
      if (a4)
        goto LABEL_8;
    }
  }
  else
  {
    result = 1;
    if (a4)
      goto LABEL_8;
  }
  return result;
}

uint64_t StringTableMatchesPrefixSorted(uint64_t a1, char *__s)
{
  size_t v4;
  size_t v6;

  v4 = strlen(__s);
  if (StringTableSearchSortedWithLength(a1, __s, v4, 0))
    return 1;
  if (v4)
  {
    v6 = v4 - 1;
    while (__s[v6] != 47 || !StringTableSearchSortedWithLength(a1, __s, v6, 0))
    {
      if (--v6 == -1)
        return 0;
    }
    return 1;
  }
  return 0;
}

uint64_t StringTableSize(unsigned int *a1)
{
  return *a1;
}

uint64_t StringTableCmp(uint64_t a1, unsigned int a2, char *__s1, size_t __n)
{
  uint64_t v5;
  size_t v6;
  uint64_t result;
  unsigned int v8;

  v5 = *(_QWORD *)(a1 + 8) + 16 * a2;
  v6 = *(unsigned int *)(v5 + 8);
  LODWORD(result) = strncmp(__s1, (const char *)(*(_QWORD *)(a1 + 32) + *(_QWORD *)v5), __n);
  if (v6 <= __n)
    v8 = v6 < __n;
  else
    v8 = -1;
  if ((_DWORD)result)
    return result;
  else
    return v8;
}

uint64_t ECCFixThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const char *v10;
  __int16 v11;
  unint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  int v17;
  ssize_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int8x16_t v22;
  int v23;
  ssize_t v24;
  int v25;
  int v27;
  uint64_t v28;

  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    v9 = 0;
  }
  else
  {
    v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      v10 = "creating workBuffer";
      v11 = 157;
LABEL_31:
      v25 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCFixThreadProc", v11, 64, v25, v10, a7, a8, v27);
      goto LABEL_33;
    }
  }
  for (i = *(_QWORD *)(a1 + 8); i < *(_QWORD *)(a1 + 16); ++i)
  {
    v13 = *(unsigned int *)(a1 + 28);
    v14 = i * v13;
    v15 = *(_QWORD *)(a1 + 64);
    if (v15 < i * v13)
    {
      v10 = "Invalid block index";
      v11 = 166;
      goto LABEL_31;
    }
    if (v14 + v13 <= v15)
      v16 = v13;
    else
      v16 = (v15 - v14);
    v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      v19 = *(_QWORD *)(a1 + 48) + v14;
    }
    else
    {
      v18 = pread(v17, v9, v16, *(_QWORD *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        v25 = *__error();
        v10 = "reading data segment";
        v11 = 174;
        goto LABEL_32;
      }
      v19 = (uint64_t)v9;
      if ((_DWORD)v16 != (_DWORD)v18)
      {
        LOBYTE(v27) = v18;
        v10 = "Truncated read n=%zd pos=%llu read=%u fd=%d";
        v11 = 175;
        goto LABEL_31;
      }
    }
    v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(_QWORD *)(a1 + 80))
    {
      v10 = "Parity buffer out of range";
      v11 = 187;
      goto LABEL_31;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      v27 = *(_DWORD *)(a1 + 24);
      v10 = "invalid variant %u";
      v11 = 205;
      goto LABEL_31;
    }
    v28 = 0;
    v21 = ECC65537CheckAndFix(v16, v19, (uint16x8_t *)(*(_QWORD *)(a1 + 72) + i * v20), &v28);
    if (v21 < 0)
    {
      ++*(_QWORD *)(a1 + 88);
    }
    else if (v21)
    {
      ++*(_QWORD *)(a1 + 96);
      v22.i64[0] = v28;
      v22.i64[1] = HIDWORD(v28);
      *(int64x2_t *)(a1 + 104) = vaddq_s64(*(int64x2_t *)(a1 + 104), (int64x2_t)vextq_s8(v22, v22, 8uLL));
      v23 = *(_DWORD *)(a1 + 40);
      if ((v23 & 0x80000000) == 0)
      {
        v24 = pwrite(v23, v9, v16, *(_QWORD *)(a1 + 56) + v14);
        if (v24 < 0)
        {
          v25 = *__error();
          v10 = "writing data segment";
          v11 = 211;
          goto LABEL_32;
        }
        if ((_DWORD)v16 != (_DWORD)v24)
        {
          LOBYTE(v27) = v24;
          v10 = "Truncated write n=%zd pos=%llu read=%u fd=%d";
          v11 = 212;
          goto LABEL_31;
        }
      }
    }
  }
LABEL_33:
  free(v9);
  return 0;
}

uint64_t ParallelArchiveECCFixFileSegment(int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6)
{
  return ParallelArchiveECCFixCommon(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t ParallelArchiveECCFixCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7)
{
  unsigned int DefaultNThreads;
  double RealTime;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  __int128 v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t result;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  FILE **v45;
  unint64_t v46;
  const char *v47;
  double v48;
  unint64_t v49;
  unsigned int v50;
  size_t v51;
  const char *v52;
  __int16 v53;
  FILE **v54;
  void *v57;
  uint64_t v58;
  size_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  int Thread;
  uint64_t v65;
  uint64_t v66;
  int64x2_t v67;
  int64x2_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  const char *v77;
  __int16 v78;
  char v81;
  char v82;
  _OWORD *v83;
  uint64_t v84;
  int64x2_t v85;
  unint64_t v86;
  unint64_t v87;
  int64x2_t v88;
  unsigned int v89;
  unint64_t v90;
  int v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;

  v114 = *MEMORY[0x24BDAC8D0];
  DefaultNThreads = *(_DWORD *)(a7 + 4);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v91 = *(_DWORD *)a7;
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v109 = 0u;
  v110 = 0u;
  v108 = 0u;
  RealTime = getRealTime();
  *(_QWORD *)(a7 + 16) = 0;
  *(_DWORD *)(a7 + 12) = 0;
  enterThreadErrorContext(v16, v17, v18, v19, v20, v21, v22, v23, v81);
  v90 = a4;
  if (a6 <= 0x2F)
  {
    v26 = "Truncated ECC buffer";
    v27 = 452;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v27, 64, 0, v26, v24, v25, v82);
LABEL_10:
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    goto LABEL_11;
  }
  v28 = a5[1];
  v108 = *a5;
  v109 = v28;
  v110 = a5[2];
  if ((_QWORD)v108 != 0x3031304343455842)
  {
    v26 = "Invalid ECC magic";
    v27 = 454;
    goto LABEL_9;
  }
  if (HIDWORD(v110))
  {
    v26 = "Invalid ECC header";
    v27 = 455;
    goto LABEL_9;
  }
  v89 = DWORD2(v110);
  if (!DWORD2(v110))
  {
    v26 = "Invalid ECC header";
    v27 = 456;
    goto LABEL_9;
  }
  if (*((_QWORD *)&v108 + 1) != a4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 457, 64, 0, "Input buffer size mismatch: expected %llu B, got %llu B", v24, v25, SBYTE8(v108));
    goto LABEL_10;
  }
  v35 = DWORD1(v110);
  if (DWORD1(v110) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 476, 64, 0, "Invalid ECC variant: %u", v24, v25, SBYTE4(v110));
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
LABEL_55:
    v34 = v89;
    goto LABEL_11;
  }
  if (DWORD2(v110) >= 0x1FFE1)
  {
    v34 = DWORD2(v110);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 472, 64, 0, "Invalid blockSize: %u", v24, v25, SBYTE8(v110));
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v35 = 1;
    goto LABEL_11;
  }
  v49 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  v84 = 34 * v49;
  if (34 * v49 + 48 != a6)
  {
    v52 = "Invalid ECC buffer size";
    v53 = 481;
    goto LABEL_52;
  }
  v86 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v49 >= DefaultNThreads)
    v50 = DefaultNThreads;
  else
    v50 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v50 <= 1)
    v51 = 1;
  else
    v51 = v50;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      v52 = "computing buffer digest";
      v53 = 495;
      goto LABEL_52;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v111) & 0x80000000) != 0)
  {
    v52 = "computing file digest";
    v53 = 491;
LABEL_52:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v53, 64, 0, v52, v24, v25, v82);
    v29 = 0;
    v30 = 0;
LABEL_53:
    v31 = 0;
    v32 = 0;
    v33 = 0;
LABEL_54:
    v35 = 1;
    goto LABEL_55;
  }
  v87 = (v86 + v51 - 1) / v51;
  if (v91 >= 1)
  {
    v106 = 0u;
    v107 = 0u;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    v54 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("ParallelArchiveECCFixCommon:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf(*v54, "  Input data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
    fprintf(*v54, "  Expected SHA1: %s\n", (const char *)&v92);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v54);
    fwrite("RS65537\n", 8uLL, 1uLL, *v54);
    fprintf(*v54, "%12llu data size\n", a4);
    fprintf(*v54, "%12u block size\n", v89);
    fprintf(*v54, "%12u ECC parity size per block\n", 34);
    fprintf(*v54, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v89);
    fprintf(*v54, "%12zu block count\n", v86);
    fprintf(*v54, "%12zu ECC buffer size\n", a6);
    fprintf(*v54, "%12u worker threads\n", v51);
    fprintf(*v54, "%12zu blocks per thread\n", v87);
  }
  if (v111 == (_QWORD)v109 && v112 == *((_QWORD *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v29 = 1;
    goto LABEL_54;
  }
  v57 = calloc(v51, 0x78uLL);
  v30 = (unint64_t)v57;
  if (!v57)
  {
    v72 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 526, 64, *v72, "malloc %u threads", v73, v74, v51);
    v29 = 0;
    goto LABEL_53;
  }
  v58 = 0;
  v83 = a5 + 3;
  v59 = v51;
  v60 = (uint64_t)v57;
  v29 = 1;
  v61 = (v86 + v51 - 1) / v51;
  do
  {
    v62 = v61 * v58;
    if (v61 * v58 < v86)
    {
      v63 = v62 + v87;
      if (v62 + v87 >= v86)
        v63 = v86;
      *(_QWORD *)(v60 + 8) = v62;
      *(_QWORD *)(v60 + 16) = v63;
      *(_DWORD *)(v60 + 40) = a1;
      *(_QWORD *)(v60 + 48) = a2;
      *(_QWORD *)(v60 + 56) = a3;
      *(_QWORD *)(v60 + 64) = v90;
      *(_QWORD *)(v60 + 72) = v83;
      *(_QWORD *)(v60 + 80) = v84;
      *(_DWORD *)(v60 + 24) = 1;
      *(_DWORD *)(v60 + 28) = v89;
      *(_QWORD *)(v60 + 32) = 34;
      Thread = createThread((pthread_t *)v60, (uint64_t)ECCFixThreadProc, v60, 0);
      v61 = (v86 + v51 - 1) / v51;
      if (Thread)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 549, 64, 0, "createThread", v65, v66, v82);
        v61 = (v86 + v51 - 1) / v51;
        v29 = 0;
      }
    }
    ++v58;
    v60 += 120;
    --v59;
  }
  while (v59);
  v67 = 0uLL;
  v68 = 0uLL;
  do
  {
    if (*(_QWORD *)v30)
    {
      v85 = v68;
      v88 = v67;
      if (joinThread(*(_opaque_pthread_t **)v30))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 556, 64, 0, "joinThread", v69, v70, v82);
        v29 = 0;
      }
      v68 = vaddq_s64(*(int64x2_t *)(v30 + 104), v85);
      v67 = vaddq_s64(*(int64x2_t *)(v30 + 88), v88);
    }
    v30 += 120;
    --v51;
  }
  while (v51);
  v32 = v67.u64[1];
  v33 = v67.i64[0];
  v30 = v68.u64[1];
  v71 = v68.i64[0];
  if (v67.i64[0])
    goto LABEL_81;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, v90, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      v77 = "computing buffer digest";
      v78 = 574;
      goto LABEL_102;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, v90, (uint64_t)&v111) & 0x80000000) != 0)
  {
    v77 = "computing file digest";
    v78 = 570;
LABEL_102:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v78, 64, 0, v77, v75, v76, v82);
    v29 = 0;
    v33 = 0;
LABEL_81:
    v35 = 1;
    v34 = v89;
LABEL_82:
    v31 = v71;
    goto LABEL_11;
  }
  v34 = v89;
  if (v91 >= 1)
  {
    v106 = 0u;
    v107 = 0u;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  Output data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
  }
  if (v111 == (_QWORD)v109 && v112 == *((_QWORD *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    v33 = 0;
    v35 = 1;
    goto LABEL_82;
  }
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v35 = 1;
  v33 = v86;
LABEL_11:
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0)
    return result;
  if (!v29)
    return 0xFFFFFFFFLL;
  v37 = 0x7FFF;
  if (v30 < 0x7FFF)
    v37 = v30;
  v38 = v37 << 8;
  v39 = 255;
  if (v32 < 0xFF)
    v39 = v32;
  v40 = v38 | v39;
  v41 = 255;
  if (v33 < 0xFF)
    v41 = v33;
  v42 = v38 | v41 | 0x800000;
  if (v33)
    v43 = v42;
  else
    v43 = v40;
  if (v91 <= 0)
  {
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 20) = v43;
    if (v33)
      return 0xFFFFFFFFLL;
  }
  else
  {
    v44 = v34;
    v45 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu fixed blocks\n", v32);
    v46 = v31;
    fprintf(*v45, "%12llu fixed bytes\n", v31);
    fprintf(*v45, "%12llu fixed bits\n", v30);
    if (v33)
    {
      fprintf(*v45, "%12llu INVALID BLOCKS\n", v33);
      v47 = "FAIL";
    }
    else
    {
      v47 = "OK";
    }
    fprintf(*v45, "    0x%06x diagnostic code\n", v43);
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v44;
    *(_DWORD *)(a7 + 20) = v43;
    v48 = getRealTime();
    fprintf(*v45, "Total time %.2fs, %.2f MB/s (%s)\n", v48 - RealTime, (double)v90 * 0.000000953674316 / (v48 - RealTime), v47);
    v31 = v46;
    if (v33)
      return 0xFFFFFFFFLL;
  }
  if (v31 >= 0x7FFFFFFF)
    return 0x7FFFFFFFLL;
  else
    return v31;
}

uint64_t ParallelArchiveECCVerifyCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (a6 <= 0x2F)
  {
    v8 = "Truncated ECC buffer";
    v9 = 390;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCVerifyCommon", v9, 64, 0, v8, a7, a8, v13);
    return 0xFFFFFFFFLL;
  }
  v13 = *a5;
  v14 = a5[1];
  v15 = a5[2];
  if (*(_QWORD *)a5 != 0x3031304343455842)
  {
    v8 = "Invalid ECC magic";
    v9 = 392;
    goto LABEL_7;
  }
  if (HIDWORD(v15))
  {
    v8 = "Invalid ECC header";
    v9 = 393;
    goto LABEL_7;
  }
  if (!DWORD2(v15))
  {
    v8 = "Invalid ECC header";
    v9 = 394;
    goto LABEL_7;
  }
  if (*((_QWORD *)&v13 + 1) != a4)
    return 0;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v16) & 0x80000000) != 0)
    {
      v8 = "computing buffer digest";
      v9 = 404;
      goto LABEL_7;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v16) & 0x80000000) != 0)
  {
    v8 = "computing file digest";
    v9 = 400;
    goto LABEL_7;
  }
  return v16 == (_QWORD)v14 && v17 == *((_QWORD *)&v14 + 1) && v18 == (unint64_t)v15;
}

uint64_t ParallelArchiveECCVerifyFileSegment(int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(a1, 0, a2, a3, a4, a5, a7, a8);
}

_QWORD *OECCStreamCreate(int a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  int v13;
  size_t v15;
  void *v16;
  char v17;

  v6 = calloc(1uLL, 0xB0uLL);
  v7 = v6;
  if (v6)
  {
    *(_DWORD *)v6 = a1;
    v6[4] = a3;
    *((_DWORD *)v6 + 10) = a2;
    v8 = malloc(a2);
    v7[8] = v8;
    if (v8)
    {
      if (a1 != 1)
      {
        v11 = "Invalid ECC algorithm";
        v12 = 857;
        goto LABEL_9;
      }
      if (a2 >= 0x1FFE1)
      {
        v11 = "Invalid ECC block size";
        v12 = 853;
LABEL_9:
        v13 = 0;
        goto LABEL_10;
      }
      *((_DWORD *)v7 + 6) = 34;
      v15 = 34 * ((a3 + (unint64_t)a2 - 1) / a2) + 48;
      v7[2] = v15;
      v16 = malloc(v15);
      v7[1] = v16;
      if (v16)
      {
        CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)((char *)v7 + 76));
        v7[7] = 48;
        checkEOF((int *)v7);
        return v7;
      }
      v13 = *__error();
      v11 = "malloc";
      v12 = 862;
    }
    else
    {
      v13 = *__error();
      v11 = "malloc";
      v12 = 846;
    }
  }
  else
  {
    v13 = *__error();
    v11 = "malloc";
    v12 = 841;
  }
LABEL_10:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamCreate", v12, 64, v13, v11, v9, v10, v17);
  OECCStreamDestroy((void **)v7);
  return 0;
}

int *checkEOF(int *result)
{
  uint64_t v1;
  int v2;
  int v3;

  if (*((_QWORD *)result + 6) == *((_QWORD *)result + 4) && !result[43])
  {
    result[43] = 1;
    v1 = *((_QWORD *)result + 1);
    *(_QWORD *)v1 = 0x3031304343455842;
    v2 = *result;
    *(_QWORD *)(v1 + 8) = *((_QWORD *)result + 4);
    *(_DWORD *)(v1 + 44) = 0;
    v3 = result[10];
    *(_DWORD *)(v1 + 36) = v2;
    *(_DWORD *)(v1 + 40) = v3;
    return (int *)CC_SHA1_Deprecated_Final((unsigned __int8 *)(v1 + 16), (CC_SHA1_CTX *)(result + 19));
  }
  return result;
}

void OECCStreamDestroy(void **a1)
{
  if (a1)
  {
    free(a1[8]);
    free(a1[1]);
    free(a1);
  }
}

uint64_t OECCStreamGetDataPtr(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172))
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

uint64_t OECCStreamGetDataSize(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172))
    return *(_QWORD *)(a1 + 16);
  else
    return 0;
}

uint64_t OECCStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  int v11;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unsigned int v19;
  unint64_t v20;
  size_t v21;
  unsigned int v22;
  size_t v23;
  uint64_t v24;
  char v26;

  v8 = *(_QWORD *)(a1 + 48);
  v9 = __CFADD__(v8, a3);
  v10 = v8 + a3;
  v11 = v9;
  if (v10 <= *(_QWORD *)(a1 + 32) && v11 == 0)
  {
    v16 = a3;
    v17 = a2;
    CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 76), a2, a3);
    v15 = 0;
    if (v16)
    {
      v19 = *(_DWORD *)(a1 + 72);
      do
      {
        v20 = *(unsigned int *)(a1 + 40);
        v21 = v16 + (unint64_t)v19 <= v20 ? v16 : v20 - v19;
        memcpy((void *)(*(_QWORD *)(a1 + 64) + v19), v17, v21);
        v22 = *(_DWORD *)(a1 + 72) + v21;
        *(_DWORD *)(a1 + 72) = v22;
        v23 = *(_QWORD *)(a1 + 48) + v21;
        *(_QWORD *)(a1 + 48) = v23;
        v15 += v21;
        if (v22 < *(_DWORD *)(a1 + 40) && v23 < *(_QWORD *)(a1 + 32))
          break;
        v24 = *(_QWORD *)(a1 + 56);
        if (v24 + (unint64_t)*(unsigned int *)(a1 + 24) > *(_QWORD *)(a1 + 16))
        {
          v13 = "ECC buffer overflow";
          v14 = 914;
          goto LABEL_9;
        }
        if (*(_DWORD *)a1 != 1)
        {
          v13 = "Invalid ECC algorithm";
          v14 = 921;
          goto LABEL_9;
        }
        if ((ECC65537GetParity(v22, *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 8) + v24) & 0x80000000) != 0)
        {
          v13 = "ECC generation failed";
          v14 = 918;
          goto LABEL_9;
        }
        v19 = 0;
        v17 += v21;
        *(_QWORD *)(a1 + 56) += *(unsigned int *)(a1 + 24);
        *(_DWORD *)(a1 + 72) = 0;
        v16 -= v21;
      }
      while (v16);
    }
    checkEOF((int *)a1);
  }
  else
  {
    v13 = "Too many bytes received";
    v14 = 892;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamWrite", v14, 64, 0, v13, a7, a8, v26);
    return -1;
  }
  return v15;
}

uint64_t initBestMatchThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int i;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int *v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  _DWORD *v29;
  int v30;
  unsigned int *v31;
  _BYTE *v32;
  int v33;
  int v34;
  _DWORD *v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  BOOL v42;
  int v43;
  _BYTE *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  unint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  _DWORD *v65;
  int v66;
  int v67;
  _DWORD *v68;
  unsigned int v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  unsigned int v76;
  _BYTE v78[7];
  _DWORD v79[3072];
  uint64_t v80;

  v8 = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v80 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)v8;
  v10 = *(_DWORD *)(v8 + 20);
  bzero(v79, 0x3000uLL);
  bzero(v78, 0x7000uLL);
  v11 = *(_DWORD *)(v8 + 12);
  v12 = *(_DWORD *)(v8 + 16);
  v13 = *(_DWORD *)(v9 + 36);
  v14 = v13 - v10;
  if (v13 < v10)
    v14 = 0;
  if (v12 + v10 > v13)
    v12 = v14;
  if (v11 < v12)
  {
    for (i = *(_DWORD *)(v8 + 12); i < v12; ++i)
    {
      v16 = *(_QWORD *)(v9 + 48);
      v17 = *(_DWORD *)(v16 + 8 * i + 4);
      if (v17 < 0x400)
      {
        v18 = i;
        v19 = *(_QWORD *)(v9 + 24);
        v20 = 0;
        if (v10)
        {
          v21 = (int *)(v19 + i);
          v22 = v10;
          do
          {
            v23 = *v21++;
            v20 = -1640531535 * (v23 + v20) - 1640531535;
            v22 -= 4;
          }
          while (v22);
        }
        v24 = *(_QWORD *)(v8 + 32);
        v25 = v20 ^ HIWORD(v20);
        v26 = v20 >> *(_DWORD *)(v9 + 44);
        if (*(unsigned __int16 *)(v24 + 6 * v26 + 4) == (unsigned __int16)v25)
        {
          v27 = *(_DWORD *)(v24 + 6 * v26);
          if (v27 >= *(_DWORD *)(v8 + 8))
          {
            v28 = ((_WORD)i - (_WORD)v27) & 0x3FF;
            v29 = &v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF)];
            if (v27 != v29[1] + i - *v29 || v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF) + 2] + *v29 < i)
            {
              v30 = v27 & 0x3FF;
              v31 = (unsigned int *)&v78[28 * (v27 & 0x3FF)];
              if (*v31 == v27)
              {
                v32 = &v78[28 * (v27 & 0x3FF)];
                v33 = *((_DWORD *)v32 + 2);
                v34 = i - v33;
                if (v33 != *((_DWORD *)v32 + 5) + i - v33)
                  goto LABEL_26;
                v35 = &v78[28 * (v27 & 0x3FF)];
                v37 = v35[3];
                v36 = v35[4];
                v38 = v36 + v34;
                v39 = v35[1];
                if (v36 + v34 <= v39)
                  v38 = v35[1];
                v40 = (v38 + v34);
                v41 = v35[6] + v36;
                if (v41 >= v37 + v39)
                  v41 = v37 + v39;
                v42 = v41 >= v40;
                v43 = v41 - v40;
                if (v43 != 0 && v42)
                {
                  v27 = v27 - i + v40;
                  v18 = v40;
                }
                else
                {
LABEL_26:
                  v43 = 0;
LABEL_27:
                  LODWORD(v40) = i;
                }
                v45 = 0;
                if (v27 >= v40 - v11)
                  v46 = v40 - v11;
                else
                  v46 = v27;
                v47 = *(_QWORD *)(v9 + 16);
                v48 = v47 + v27;
                v49 = v19 + v18;
                v50 = -1;
                while (1)
                {
                  v45 += 8;
                  if (v45 > v46)
                    break;
                  v50 += 8;
                  v51 = *(_QWORD *)(v49 - v45) ^ *(_QWORD *)(v48 - v45);
                  if (v51)
                  {
                    v50 = v45 + (__clz(v51) >> 3) - 8;
                    goto LABEL_39;
                  }
                }
                while (1)
                {
                  v52 = v50 + 2;
                  if (v50 + 2 > v46)
                    break;
                  ++v50;
                  if (*(unsigned __int8 *)(v48 - v52) != *(unsigned __int8 *)(v49 - v52))
                    goto LABEL_39;
                }
                v50 = v46;
LABEL_39:
                v53 = v27 - v50;
                v54 = v40 - v50;
                v55 = v50 + v43;
                v56 = *(_DWORD *)(v9 + 32) - v53;
                LODWORD(v57) = *(_DWORD *)(v9 + 36) - v54;
                if (v56 >= v57)
                  v57 = v57;
                else
                  v57 = v56;
                v58 = v47 + v53;
                v59 = v19 + v54;
                while (1)
                {
                  v60 = v55 + 8;
                  if (v55 + 8 > v57)
                    break;
                  v61 = *(_QWORD *)(v58 + v55);
                  v62 = *(_QWORD *)(v59 + v55);
                  v55 += 8;
                  v63 = v62 ^ v61;
                  if (v63)
                  {
                    LODWORD(v57) = v60 + (__clz(__rbit64(v63)) >> 3) - 8;
                    goto LABEL_52;
                  }
                }
                if (v55 < v57)
                {
                  v64 = v55;
                  while (*(unsigned __int8 *)(v58 + v64) == *(unsigned __int8 *)(v59 + v64))
                  {
                    if (++v64 >= v57)
                      goto LABEL_52;
                  }
                  LODWORD(v57) = v64;
                }
LABEL_52:
                if (v57 >= v10)
                {
                  *v29 = v54;
                  v29[1] = v53;
                  v79[3 * v28 + 2] = v57;
                  v65 = &v78[28 * v30];
                  v66 = v65[1];
                  v67 = v65[3];
                  v65[5] = v33;
                  v65[6] = v67;
                  v65[1] = v54;
                  v65[2] = i;
                  v65[3] = v57;
                  v65[4] = v66;
                  v68 = (_DWORD *)(v16 + 8 * v54);
                  if (v57 > v68[1])
                  {
                    *v68 = v53;
                    *(_DWORD *)(*(_QWORD *)(v9 + 48) + 8 * v54 + 4) = v57;
                    if ((int)v57 + (int)v54 > i + 1024)
                      i = v57 + v54 - 1024;
                  }
                }
                continue;
              }
              v33 = 0;
              v43 = 0;
              *v31 = v27;
              v44 = &v78[28 * (v27 & 0x3FF)];
              *((_QWORD *)v44 + 1) = 0;
              *((_DWORD *)v44 + 1) = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        i = i + v17 - 1024;
      }
    }
  }
  if (*(_DWORD *)(v8 + 24))
  {
    v69 = *(_DWORD *)(v8 + 16);
    v70 = (*(_DWORD *)(v8 + 12) + 1);
    if (v70 < v69)
    {
      v71 = 8 * (*(_DWORD *)(v8 + 12) + 1);
      do
      {
        v72 = *(_QWORD *)(v9 + 48);
        v73 = v72 + v71;
        v74 = *(_DWORD *)(v72 + v71 - 4);
        if (v74 > v10 && v74 > *(_DWORD *)(v72 + v71 + 4))
        {
          v76 = *(_DWORD *)(v73 - 8) + 1;
          if (v76 < *(_DWORD *)(v9 + 32))
          {
            *(_DWORD *)(v72 + v71) = v76;
            *(_DWORD *)(v73 + 4) = v74 - 1;
            v69 = *(_DWORD *)(v8 + 16);
          }
        }
        ++v70;
        v71 += 8;
      }
      while (v70 < v69);
    }
  }
  return 0;
}

uint64_t BXDiffMatchesCreate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  unint64_t v10;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int DefaultNThreads;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  _DWORD *v23;
  _DWORD *v24;
  unsigned int v25;
  _DWORD *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  uint64_t v35;
  int *v36;
  unsigned __int8 *v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unint64_t v48;
  int *v49;
  int v50;
  uint64_t v51;
  uint64_t *v52;
  _DWORD *v53;
  unint64_t v54;
  uint64_t v55;
  int v56;
  unint64_t i;
  unsigned int v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  _DWORD *v70;
  uint64_t v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  int v87;
  const char *v88;
  __int16 v89;
  int *v90;
  uint64_t v91;
  uint64_t v92;
  int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  size_t v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  _DWORD *v102;
  uint64_t *v103;
  uint64_t v104;
  size_t v105;
  char v106;
  void *v107;
  char v108;
  uint64_t *v109;
  uint64_t v110;
  _DWORD *v111;
  unsigned int *v112;
  _DWORD *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  _DWORD *v118;
  size_t v119;
  unsigned int *v120;
  const char *v121;
  __int16 v122;
  int *v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  _DWORD *v130;
  unsigned int v131;
  unsigned int v132;
  uint64_t v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  int *v137;
  int *v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  int *v144;
  unsigned int v145;
  int v146;
  unsigned int v147;
  unsigned int v148;
  int *v149;
  unsigned int v150;
  int v151;
  __int16 v152;
  unsigned int v153;
  unsigned int *v154;
  unsigned int v155;
  unsigned int v156;
  __int16 v157;
  __int16 v158;
  char *v159;
  int v160;
  int v161;
  uint64_t v162;
  unsigned int v163;
  unsigned int v164;
  const char *v165;
  __int16 v166;
  int v167;
  _DWORD *v168;
  unsigned int v169;
  _DWORD *v170;
  uint64_t *v171;
  unint64_t v172;
  unsigned int v173;
  uint64_t v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  void *v180;
  void *v181;
  uint64_t v182;

  v182 = *MEMORY[0x24BDAC8D0];
  v177 = 0;
  v178 = 0;
  v179 = 0;
  v8 = *a5;
  if (!*a5)
    v8 = 6;
  if (a4 >= 0x4B000)
    v9 = v8;
  else
    v9 = 20;
  if (a2 > 0xFFFFFFFE || (v10 = a4, a4 >= 0xFFFFFFFF))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", 994, 92, 0, "isize,osize too large", a7, a8, v167);
    return 0;
  }
  v15 = calloc(1uLL, 0x40uLL);
  v16 = (uint64_t)v15;
  if (!v15)
  {
    v87 = *__error();
    v88 = "malloc";
    v89 = 998;
    goto LABEL_108;
  }
  v17 = *(_QWORD *)a5;
  v15[2] = a5[2];
  *(_QWORD *)v15 = v17;
  DefaultNThreads = a5[2];
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  *(_DWORD *)(v16 + 8) = DefaultNThreads;
  *(_QWORD *)(v16 + 16) = a1;
  *(_QWORD *)(v16 + 24) = a3;
  *(_DWORD *)(v16 + 32) = a2;
  *(_DWORD *)(v16 + 36) = v10;
  if ((getProfile(&v177, v9) & 0x80000000) != 0)
  {
    v167 = *a5;
    v88 = "loading profile: %d";
    v89 = 1008;
    goto LABEL_106;
  }
  if ((int)v177 >= 1)
  {
    getRealTime();
    v21 = malloc(4 * a2 + 1028);
    v22 = malloc(8 * a2);
    v23 = v22;
    if (!v21 || !v22)
    {
      v90 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"qsufsort32", 377, 92, *v90, "malloc", v91, v92, v167);
      free(v21);
      free(v23);
      *(_QWORD *)(v16 + 56) = 0;
      v89 = 1021;
      v87 = 0;
      v88 = "qsufsort32";
      goto LABEL_108;
    }
    v24 = v21 + 257;
    v21[257] = a2;
    *v22 = 0;
    if ((_DWORD)a2)
    {
      v170 = v21;
      v172 = v10;
      v174 = v16;
      v25 = 0;
      v175 = a2 ^ 0x80000000;
      v26 = v22 + 1;
      do
      {
        if (*v23 == v175)
          break;
        v27 = 0;
        v28 = -1;
        do
        {
          v29 = &v23[2 * v27];
          v30 = *v29;
          if ((v30 & 0x80000000) != 0)
          {
            LODWORD(v31) = v30 ^ 0x80000000;
          }
          else
          {
            v31 = v24[v30];
            if (v25)
            {
              if (v31 > v27)
              {
                v32 = v31 - v27;
                v33 = &v26[2 * v27];
                do
                {
                  *v33 = v24[*(v33 - 1) + v25];
                  v33 += 2;
                  --v32;
                }
                while (v32);
              }
            }
            else if (v31 > v27)
            {
              v34 = 0;
              v35 = (v31 - 1);
              v36 = &v26[2 * v35];
              v37 = (unsigned __int8 *)(a1 + v35);
              v38 = 1;
              v39 = v31;
              do
              {
                v40 = *v37--;
                v41 = __PAIR64__(v40, v34) >> 8;
                v42 = v39 + 2;
                v43 = v39 - 1;
                v44 = v41 | 0xFF;
                v34 = v38 + (v41 & 0xFFFFFF00);
                if (v42 < v31)
                  v34 = v44;
                *(v36 - 1) = v43;
                *v36 = v34;
                v36 -= 2;
                ++v38;
                v39 = v43;
              }
              while (v27 < v43);
            }
            quicksort64(v31 - v27, (unint64_t *)&v23[2 * v27], 24);
            v45 = v27 + 1;
            if (v27 + 1 <= v31)
            {
              v46 = v29[1];
              do
              {
                v47 = v46;
                if (v45 >= v31)
                  v46 = 0;
                else
                  v46 = v26[2 * v45];
                if (v47 != v46)
                {
                  if (v45 - v27 < 2)
                  {
                    if (v28 >= a2)
                      v28 = v27;
                  }
                  else if (v28 < a2)
                  {
                    v23[2 * v28] = v27 ^ 0x80000000;
                    v28 = -1;
                  }
                  if (v45 > v27)
                  {
                    v48 = v45 - (unint64_t)v27;
                    v49 = &v23[2 * v27];
                    do
                    {
                      v50 = *v49;
                      v49 += 2;
                      v24[v50] = v45;
                      --v48;
                    }
                    while (v48);
                    v27 = v45;
                  }
                }
                ++v45;
              }
              while (v45 <= v31);
            }
          }
          v27 = v31;
        }
        while (v31 < a2);
        if (v28 < a2)
          v23[2 * v28] = v175;
        if (v25 >= 3)
          v25 *= 2;
        else
          v25 = 3;
      }
      while (v25 < a2);
      v51 = 0;
      v10 = v172;
      v16 = v174;
      v21 = v170;
      do
      {
        *(_QWORD *)&v23[2 * (v24[v51] - 1)] = v51;
        ++v51;
      }
      while (a2 != v51);
    }
    if (a2)
    {
      v52 = (uint64_t *)v23;
      v53 = v24;
      v54 = a2;
      do
      {
        v55 = *v52++;
        *v53++ = v55;
        --v54;
      }
      while (v54);
    }
    v56 = 0;
    *v21 = 0;
    v21[256] = a2;
    for (i = 1; i != 256; ++i)
    {
      v58 = a2;
      if (v56 != (_DWORD)a2)
      {
        if (v56 + 1 >= a2)
        {
          v58 = a2;
        }
        else
        {
          v58 = a2;
          do
          {
            if (i <= *(unsigned __int8 *)(a1 + v24[v56 + ((v58 - v56) >> 1)]))
              v58 = v56 + ((v58 - v56) >> 1);
            else
              v56 += (v58 - v56) >> 1;
          }
          while (v58 > v56 + 1);
        }
        v59 = v24[v56];
        if (v59 != a2 && i == *(unsigned __int8 *)(a1 + v59))
          v58 = v56;
      }
      v21[i] = v58;
      v56 = v58;
    }
    free(v23);
    *(_QWORD *)(v16 + 56) = v21;
    getRealTime();
  }
  if (SHIDWORD(v177) >= 1)
  {
    v60 = malloc(8 * v10);
    *(_QWORD *)(v16 + 48) = v60;
    if (!v60)
    {
      v87 = *__error();
      v88 = "malloc";
      v89 = 1033;
      goto LABEL_108;
    }
    if (*(_DWORD *)(v16 + 36))
    {
      v61 = 0;
      v62 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v16 + 48) + v61) = 0xFFFFFFFFLL;
        ++v62;
        v61 += 8;
      }
      while (v62 < *(unsigned int *)(v16 + 36));
    }
  }
  v63 = *(_QWORD *)(v16 + 48);
  if (*(_QWORD *)(v16 + 56))
  {
    if (v63)
    {
      v65 = HIDWORD(v178);
      v64 = v179;
      getRealTime();
      v66 = *(_DWORD *)(v16 + 36);
      if (v66)
      {
        v67 = 0;
        v68 = 1;
        do
        {
          v69 = v67;
          v70 = (_DWORD *)(*(_QWORD *)(v16 + 48) + 8 * v67);
          if (v70[1] < v64)
          {
            v71 = *(_QWORD *)(v16 + 56);
            v72 = (unsigned int *)(v71 + 4 * *(unsigned __int8 *)(*(_QWORD *)(v16 + 24) + v67));
            v73 = *v72;
            v74 = v72[1] + 1;
            LODWORD(v180) = -1;
            v75 = bestMatchInRange(v16, v71 + 1028, v67, v73, v74, &v180);
            v76 = (int)v180;
            *v70 = (_DWORD)v180;
            *(_DWORD *)(*(_QWORD *)(v16 + 48) + 8 * v67 + 4) = v75;
            if (v75 >= v64)
            {
              if ((v76 + 1) < *(_DWORD *)(v16 + 32))
              {
                v77 = 8 * v68;
                v78 = v75 - 1;
                v79 = 1;
                do
                {
                  v80 = v67 + v79 < *(_DWORD *)(v16 + 36) && v78 >= v64;
                  if (!v80)
                    break;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v77) = v76 + v79;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v77 + 4) = v78;
                  v77 += 8;
                  ++v79;
                  --v78;
                }
                while ((v76 + v79) < *(_DWORD *)(v16 + 32));
              }
              if (v67 && v76)
              {
                v81 = 0;
                v82 = v67 - 1;
                v83 = 8 * v67;
                v84 = v75 + 1;
                do
                {
                  v85 = *(_QWORD *)(v16 + 48) + v83;
                  if (*(_DWORD *)(v85 - 8) != -1)
                    break;
                  if (*(unsigned __int8 *)(*(_QWORD *)(v16 + 16) + (v76 + v81 - 1)) != *(unsigned __int8 *)(*(_QWORD *)(v16 + 24) + v82 + v81))
                    break;
                  *(_DWORD *)(v85 - 8) = v76 - 1 + v81;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v83 - 4) = v84;
                  if (!(v82 + v81))
                    break;
                  v86 = v76 + v81--;
                  v83 -= 8;
                  ++v84;
                }
                while (v86 != 1);
              }
            }
            v66 = *(_DWORD *)(v16 + 36);
          }
          v67 += v65;
          v68 += v65;
        }
        while (v69 + v65 < v66);
      }
LABEL_185:
      getRealTime();
    }
    goto LABEL_186;
  }
  if (!v63)
  {
LABEL_186:
    if ((int)v177 >= 2)
    {
      free(*(void **)(v16 + 56));
      *(_QWORD *)(v16 + 56) = 0;
    }
    return v16;
  }
  v94 = -13;
  do
  {
    v95 = v94 + 33;
    v96 = 1 << (v94++ + 33 + v178);
  }
  while (v95 < SHIDWORD(v179) && v96 < *(_DWORD *)(v16 + 32));
  *(_DWORD *)(v16 + 40) = v94 + 32;
  *(_DWORD *)(v16 + 44) = -v94;
  v97 = v179;
  getRealTime();
  v98 = *(unsigned int *)(v16 + 8);
  v180 = 0;
  v181 = 0;
  v99 = 1;
  v101 = *(_DWORD *)(v16 + 32);
  v100 = *(_DWORD *)(v16 + 36);
  if (v101 >= v100)
    v101 = *(_DWORD *)(v16 + 36);
  if (v101 < 2 * v97)
  {
    v102 = 0;
    v103 = 0;
    goto LABEL_184;
  }
  v104 = 0;
  v105 = 6 * (1 << *(_DWORD *)(v16 + 40));
  v176 = ((v98 + v100 - 1) / v98 + 0xFFFF) & 0xFFFF0000;
  v106 = 1;
  do
  {
    v107 = calloc(1uLL, v105);
    *(&v180 + v104) = v107;
    if (!v107)
    {
      v123 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 852, 92, *v123, "malloc", v124, v125, v167);
      v102 = 0;
      v103 = 0;
LABEL_183:
      v99 = 0;
      goto LABEL_184;
    }
    v108 = ((_DWORD)v98 != 1) & v106;
    v104 = 1;
    v106 = 0;
  }
  while ((v108 & 1) != 0);
  v102 = calloc(v98, 0x28uLL);
  v109 = (uint64_t *)malloc(8 * v98);
  v103 = v109;
  if (!v102 || !v109)
  {
    v126 = *__error();
    v121 = "malloc";
    v122 = 862;
LABEL_182:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v122, 92, v126, v121, v115, v116, v167);
    goto LABEL_183;
  }
  if (!(_DWORD)v98)
    goto LABEL_129;
  v117 = v109;
  v118 = v102;
  v119 = v98;
  do
  {
    *v117++ = (uint64_t)v118;
    v118[5] = v97;
    *(_QWORD *)v118 = v16;
    v118 += 10;
    --v119;
  }
  while (v119);
  if ((_DWORD)v98 == 1)
  {
    v120 = 0;
  }
  else
  {
LABEL_129:
    v120 = ThreadPoolCreate(v98, (uint64_t)v109, (uint64_t)initBestMatchThreadProc);
    if (!v120)
    {
      v121 = "ThreadPoolCreate";
      v122 = 874;
      goto LABEL_181;
    }
  }
  v127 = *(_DWORD *)(v16 + 32);
  if (v127)
  {
    v171 = v103;
    v168 = v102;
    v128 = 0;
    v129 = 0;
    while (1)
    {
      v169 = v128;
      v130 = *(&v180 + v128);
      v80 = v127 >= v97;
      v131 = v127 - v97;
      if (!v80)
        v131 = 0;
      v173 = v129 + v96;
      if (v129 + v96 < v131)
        v131 = v129 + v96;
      v132 = v129 + 4;
      if (v129 + 4 < v131)
      {
        v133 = *(_QWORD *)(v16 + 16);
        v134 = v129;
        do
        {
          v135 = v132;
          if (v97)
          {
            v136 = 0;
            v137 = (int *)(v133 + v134);
            v138 = v137;
            v139 = v97;
            do
            {
              v140 = *v138++;
              v136 = -1640531535 * (v140 + v136) - 1640531535;
              v139 -= 4;
            }
            while (v139);
            v141 = 0;
            v142 = *(_DWORD *)(v16 + 44);
            v143 = v136 >> v142;
            v144 = (int *)((char *)v137 + 1);
            v145 = v97;
            do
            {
              v146 = *v144++;
              v141 = -1640531535 * (v146 + v141) - 1640531535;
              v145 -= 4;
            }
            while (v145);
            v147 = 0;
            v148 = v141 >> v142;
            v149 = (int *)((char *)v137 + 2);
            v150 = v97;
            do
            {
              v151 = *v149++;
              v147 = -1640531535 * (v151 + v147) - 1640531535;
              v150 -= 4;
            }
            while (v150);
            LODWORD(v110) = 0;
            v152 = HIWORD(v136) ^ v136;
            v153 = v147 >> v142;
            v154 = (unsigned int *)((char *)v137 + 3);
            v155 = v97;
            do
            {
              v156 = *v154++;
              v115 = v156;
              v110 = -1640531535 * (v156 + v110) - 1640531535;
              v155 -= 4;
            }
            while (v155);
            v157 = HIWORD(v141) ^ v141;
            v158 = HIWORD(v147) ^ v147;
            v112 = (_DWORD *)((char *)v130 + 6 * v143);
            v113 = (_DWORD *)((char *)v130 + 6 * v148);
            v111 = (_DWORD *)((char *)v130 + 6 * v153);
          }
          else
          {
            v153 = 0;
            v158 = 0;
            v143 = 0;
            v152 = 0;
            v157 = 0;
            v148 = 0;
            v110 = 0;
            v142 = *(_DWORD *)(v16 + 44);
            v111 = v130;
            v112 = v130;
            v113 = v130;
          }
          v114 = v110 ^ WORD1(v110);
          v159 = (char *)v130 + 6 * (v110 >> v142);
          *v112 = v134;
          *((_WORD *)v130 + 3 * v143 + 2) = v152;
          *v113 = v134 + 1;
          *((_WORD *)v130 + 3 * v148 + 2) = v157;
          *v111 = v134 + 2;
          *((_WORD *)v130 + 3 * v153 + 2) = v158;
          *(_DWORD *)v159 = v134 + 3;
          *((_WORD *)v159 + 2) = v110 ^ WORD1(v110);
          v132 = v135 + 4;
          v134 = v135;
        }
        while (v135 + 4 < v131);
      }
      if (v120 && (ThreadPoolSync(v120) & 0x80000000) != 0)
        break;
      if ((_DWORD)v98)
      {
        v160 = 0;
        v161 = v98;
        while (1)
        {
          v162 = v120
               ? ThreadPoolGetWorker((uint64_t)v120, v110, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116)
               : *v171;
          if (!v162)
            break;
          *(_QWORD *)(v162 + 32) = v130;
          *(_DWORD *)(v162 + 24) = v173 >= *(_DWORD *)(v16 + 32);
          *(_DWORD *)(v162 + 8) = v129;
          *(_DWORD *)(v162 + 12) = v160 * v176;
          v163 = v160 * v176 + v176;
          *(_DWORD *)(v162 + 16) = v163;
          v164 = *(_DWORD *)(v16 + 36);
          if (v160 * v176 > v164)
            *(_DWORD *)(v162 + 12) = v164;
          if (v163 > v164)
            *(_DWORD *)(v162 + 16) = v164;
          if (v120)
          {
            if ((ThreadPoolRunWorker((uint64_t)v120, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116) & 0x80000000) != 0)
            {
              v165 = "ThreadPoolRunWorker";
              v166 = 920;
              goto LABEL_178;
            }
          }
          else
          {
            initBestMatchThreadProc(v162, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116);
          }
          ++v160;
          if (!--v161)
            goto LABEL_171;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 910, 92, 0, "ThreadPoolGetWorker", v115, v116, v167);
        v99 = 0;
        goto LABEL_175;
      }
LABEL_171:
      v128 = v169 ^ (v120 != 0);
      v127 = *(_DWORD *)(v16 + 32);
      v129 += v96;
      if (v173 >= v127)
      {
        v99 = 1;
LABEL_175:
        v102 = v168;
        v103 = v171;
        goto LABEL_176;
      }
    }
    v165 = "ThreadPoolSync";
    v166 = 906;
LABEL_178:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v166, 92, 0, v165, v115, v116, v167);
    v99 = 0;
    v102 = v168;
    v103 = v171;
    goto LABEL_179;
  }
  v99 = 1;
LABEL_176:
  if (v120)
  {
LABEL_179:
    if ((ThreadPoolDestroy((uint64_t)v120) & 0x80000000) == 0)
      goto LABEL_184;
    v121 = "ThreadPoolDestroy";
    v122 = 930;
LABEL_181:
    v126 = 0;
    goto LABEL_182;
  }
LABEL_184:
  free(v102);
  free(v103);
  free(v180);
  free(v181);
  if (v99)
    goto LABEL_185;
  v88 = "initBestMatchFromHashes";
  v89 = 1069;
LABEL_106:
  v87 = 0;
LABEL_108:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", v89, 92, v87, v88, v19, v20, v167);
  BXDiffMatchesDestroy((void **)v16);
  return 0;
}

size_t getProfile(_DWORD *a1, int a2)
{
  int v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  size_t result;
  size_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  char v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  char *__endptr;

  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  if (a2)
    v3 = a2;
  else
    v3 = 6;
  switch(v3)
  {
    case 2:
      v4 = xmmword_20A40BA60;
      goto LABEL_10;
    case 3:
      v4 = xmmword_20A40BA50;
      goto LABEL_10;
    case 4:
      v4 = xmmword_20A40BA40;
      goto LABEL_10;
    case 5:
      v4 = xmmword_20A40BA30;
      goto LABEL_10;
    case 6:
      *(_OWORD *)a1 = xmmword_20A40BA30;
      v5 = 0x1A00000010;
      goto LABEL_30;
    case 7:
      v6 = xmmword_20A40BA30;
      goto LABEL_15;
    case 8:
      *(_OWORD *)a1 = xmmword_20A40BA20;
      v5 = 0x1A0000000CLL;
      goto LABEL_30;
    case 9:
      v6 = xmmword_20A40BA20;
LABEL_15:
      *(_OWORD *)a1 = v6;
      v5 = 0x1A00000008;
      goto LABEL_30;
    case 10:
      v7 = xmmword_20A40BA10;
      goto LABEL_24;
    case 11:
      v7 = xmmword_20A40BA00;
      goto LABEL_24;
    case 12:
      v7 = xmmword_20A40B9F0;
      goto LABEL_24;
    case 13:
      v8 = xmmword_20A40B9E0;
      goto LABEL_26;
    case 14:
      v8 = xmmword_20A40B9D0;
      goto LABEL_26;
    case 15:
      v7 = xmmword_20A40B9C0;
      goto LABEL_24;
    case 16:
      v7 = xmmword_20A40B9B0;
      goto LABEL_24;
    case 17:
      v7 = xmmword_20A40B9A0;
LABEL_24:
      *(_OWORD *)a1 = v7;
      v5 = 24;
      goto LABEL_30;
    case 18:
      v8 = xmmword_20A40B9A0;
LABEL_26:
      *(_OWORD *)a1 = v8;
      v5 = 16;
      goto LABEL_30;
    case 19:
      *(_OWORD *)a1 = xmmword_20A40B9A0;
      v5 = 8;
      goto LABEL_30;
    case 20:
      *a1 = 1;
      *(_QWORD *)(a1 + 3) = 0;
      *(_QWORD *)(a1 + 1) = 0;
      a1[5] = 0;
      goto LABEL_31;
    case 21:
      *(_OWORD *)a1 = xmmword_20A40BA30;
      v5 = 0x1800000010;
      goto LABEL_30;
    default:
      v4 = xmmword_20A40BA70;
LABEL_10:
      *(_OWORD *)a1 = v4;
      v5 = 0x1A00000018;
LABEL_30:
      *((_QWORD *)a1 + 2) = v5;
LABEL_31:
      result = (size_t)getenv("BXDIFF_MATCHES_PROFILE");
      if (!result)
        return result;
      v10 = result;
      result = strlen((const char *)result);
      if (!result)
        return result;
      v11 = result;
      v12 = 0;
      v13 = MEMORY[0x24BDAC740];
      break;
  }
  while (1)
  {
    v14 = __tolower(*(char *)(v10 + v12));
    v17 = v14;
    if (v14 > 0x7F)
    {
      if (__maskrune(v14, 0x4000uLL))
        goto LABEL_52;
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_52;
    }
    v18 = v17 - 58;
    if (v17 - 58 > 0x39)
      goto LABEL_44;
    if (((1 << v18) & 0x224820000000000) != 0)
      break;
    if (((1 << v18) & 3) != 0)
      goto LABEL_52;
LABEL_44:
    if (v17 != 44)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 505, 92, 0, "Invalid profile code: %c", v15, v16, v17);
      goto LABEL_56;
    }
LABEL_52:
    if (v11 == ++v12)
      return 0;
  }
  __endptr = 0;
  v19 = strtol((const char *)(v10 + v12 + 1), &__endptr, 10);
  if (!*__error())
  {
    switch(v17)
    {
      case 'c':
        v22 = a1 + 1;
        goto LABEL_51;
      case 'd':
        v22 = a1 + 3;
        goto LABEL_51;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_55;
      case 'i':
        v22 = a1 + 2;
        goto LABEL_51;
      case 'l':
        v22 = a1 + 4;
        goto LABEL_51;
      default:
        v22 = a1;
        if (v17 != 115)
        {
LABEL_55:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 515, 92, 0, "Invalid profile code: %c", v20, v21, v17);
          goto LABEL_56;
        }
LABEL_51:
        *v22 = v19;
        break;
    }
    goto LABEL_52;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 508, 92, 0, "Invalid profile value: %s", v20, v21, v10 + v12 + 1);
LABEL_56:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"getProfile", 560, 92, 0, "parsing profile: %s", v23, v24, v10);
  return 0xFFFFFFFFLL;
}

void BXDiffMatchesDestroy(void **a1)
{
  if (a1)
  {
    free(a1[7]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t BXDiffMatchesGetBestMatch(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t result;
  unsigned int *v9;
  unsigned int v10;

  v10 = 0;
  if (*(_DWORD *)(a1 + 36) <= a2)
  {
    v7 = 0;
    goto LABEL_6;
  }
  v5 = *(_QWORD *)(a1 + 48);
  if (v5)
  {
    v6 = (unsigned int *)(v5 + 8 * a2);
    v7 = *v6;
    v10 = v7;
    if ((_DWORD)v7 != -1)
    {
      LODWORD(result) = v6[1];
      goto LABEL_7;
    }
  }
  v7 = *(_QWORD *)(a1 + 56);
  if (!v7)
  {
LABEL_6:
    LODWORD(result) = 0;
    goto LABEL_7;
  }
  v9 = (unsigned int *)(v7 + 4 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + a2));
  result = bestMatchInRange(a1, v7 + 1028, a2, *v9, v9[1], &v10);
  v7 = v10;
  if (v5)
    *(_QWORD *)(v5 + 8 * a2) = v10 | (unint64_t)(result << 32);
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t bestMatchInRange(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t result;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;

  if (a5 <= a4)
  {
    v19 = 0;
    result = 0;
  }
  else
  {
    v6 = 0;
    v7 = *(unsigned int *)(a2 + 4 * a4);
    v8 = a4;
    v9 = *(_DWORD *)(a1 + 32);
    v10 = *(_DWORD *)(a1 + 36) - a3;
    if (v10 >= v9 - (int)v7)
      v11 = (v9 - v7);
    else
      v11 = v10;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_QWORD *)(a1 + 24);
    v14 = v13 + a3;
    while (1)
    {
      v15 = v6 + 8;
      if (v6 + 8 > v11)
        break;
      v16 = *(_QWORD *)(v12 + v7 + v6);
      v17 = *(_QWORD *)(v14 + v6);
      v6 += 8;
      v18 = v17 ^ v16;
      if (v18)
      {
        LODWORD(v11) = v15 + (__clz(__rbit64(v18)) >> 3) - 8;
        goto LABEL_16;
      }
    }
    if (v6 < v11)
    {
      v21 = v11 - v6;
      v22 = (unsigned __int8 *)(v13 + a3 + v6);
      v23 = (unsigned __int8 *)(v12 + v7 + v6);
      while (1)
      {
        v25 = *v23++;
        v24 = v25;
        v26 = *v22++;
        if (v24 != v26)
          break;
        ++v6;
        if (!--v21)
          goto LABEL_16;
      }
      LODWORD(v11) = v6;
    }
LABEL_16:
    v27 = 0;
    v28 = a5 - 1;
    v29 = *(unsigned int *)(a2 + 4 * v28);
    LODWORD(v30) = v9 - v29;
    if (v10 >= v9 - (int)v29)
      v30 = v30;
    else
      v30 = v10;
    while (1)
    {
      v31 = v27 + 8;
      if (v27 + 8 > v30)
        break;
      v32 = *(_QWORD *)(v12 + v29 + v27);
      v33 = *(_QWORD *)(v14 + v27);
      v27 += 8;
      v34 = v33 ^ v32;
      if (v34)
      {
        LODWORD(v30) = v31 + (__clz(__rbit64(v34)) >> 3) - 8;
        goto LABEL_28;
      }
    }
    if (v27 < v30)
    {
      v35 = v30 - v27;
      v36 = (unsigned __int8 *)(v13 + a3 + v27);
      v37 = (unsigned __int8 *)(v12 + v29 + v27);
      while (1)
      {
        v39 = *v37++;
        v38 = v39;
        v40 = *v36++;
        if (v38 != v40)
          break;
        ++v27;
        if (!--v35)
          goto LABEL_28;
      }
      LODWORD(v30) = v27;
    }
LABEL_28:
    v41 = v28 - v8;
    if ((unint64_t)(v28 - v8) < 2)
    {
      v42 = v8;
    }
    else
    {
      do
      {
        v42 = v8 + (v41 >> 1);
        v43 = *(unsigned int *)(a2 + 4 * v42);
        LODWORD(v44) = v9 - v43;
        if (v10 >= v9 - (int)v43)
          v44 = v44;
        else
          v44 = v10;
        if (v11 >= v30)
          LODWORD(v45) = v30;
        else
          LODWORD(v45) = v11;
        v46 = v12 + v43;
        while (1)
        {
          v47 = v45 + 8;
          if ((int)v45 + 8 > v44)
            break;
          v48 = *(_QWORD *)(v46 + v45);
          v49 = *(_QWORD *)(v14 + v45);
          LODWORD(v45) = v45 + 8;
          v50 = v49 ^ v48;
          if (v50)
          {
            LODWORD(v45) = v47 + (__clz(__rbit64(v50)) >> 3) - 8;
            goto LABEL_39;
          }
        }
        if (v45 >= v44)
        {
LABEL_46:
          LODWORD(v45) = v44;
          goto LABEL_47;
        }
        v45 = v45;
        while (*(unsigned __int8 *)(v46 + v45) == *(unsigned __int8 *)(v14 + v45))
        {
          if (++v45 >= v44)
            goto LABEL_46;
        }
LABEL_39:
        if (v45 < v44
          && *(unsigned __int8 *)(v13 + v45 + a3) < *(unsigned __int8 *)(v12 + (v45 + v43)))
        {
          v28 = v42;
          v42 = v8;
          LODWORD(v30) = v45;
          goto LABEL_48;
        }
LABEL_47:
        LODWORD(v11) = v45;
        v8 = v42;
LABEL_48:
        v41 = v28 - v42;
      }
      while ((unint64_t)(v28 - v42) > 1);
    }
    if (v11 <= v30)
      v51 = v28;
    else
      v51 = v42;
    if (v11 <= v30)
      result = v30;
    else
      result = v11;
    v19 = *(_DWORD *)(a2 + 4 * v51);
  }
  *a6 = v19;
  return result;
}

uint64_t BXDiffMatchesIBuf(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t BXDiffMatchesISize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BXDiffMatchesOBuf(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t BXDiffMatchesOSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

unint64_t quicksort64(unint64_t result, unint64_t *a2, int a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t j;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t i;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;

  if (result >= 2)
  {
    v5 = result;
    while (2)
    {
      switch(v5)
      {
        case 2uLL:
          v32 = *a2;
          v33 = a2[1];
          if (HIDWORD(*a2) > HIDWORD(v33))
          {
            *a2 = v33;
            a2[1] = v32;
          }
          break;
        case 3uLL:
          v54 = *a2;
          v55 = a2[2];
          v56 = HIDWORD(*a2);
          if (v56 <= HIDWORD(v55))
          {
            v57 = a2[2];
            v55 = *a2;
          }
          else
          {
            v56 = HIDWORD(v55);
            *a2 = v55;
            a2[2] = v54;
            v57 = v54;
          }
          v66 = a2[1];
          if (v56 <= HIDWORD(v66))
          {
            v56 = HIDWORD(v66);
          }
          else
          {
            *a2 = v66;
            a2[1] = v55;
            v66 = v55;
          }
          if (v56 > HIDWORD(v57))
          {
            a2[1] = v57;
            a2[2] = v66;
          }
          break;
        case 4uLL:
          v35 = *a2;
          v34 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v34))
          {
            v36 = a2[1];
            v34 = *a2;
          }
          else
          {
            *a2 = v34;
            a2[1] = v35;
            v36 = v35;
          }
          v59 = a2[2];
          v58 = a2[3];
          v60 = HIDWORD(v59);
          if (HIDWORD(v59) <= HIDWORD(v58))
          {
            v61 = a2[3];
            v58 = a2[2];
          }
          else
          {
            v60 = HIDWORD(v58);
            a2[2] = v58;
            a2[3] = v59;
            v61 = v59;
          }
          if (v60 >= HIDWORD(v34))
          {
            v34 = v58;
          }
          else
          {
            *a2 = v58;
            a2[2] = v34;
          }
          v68 = HIDWORD(v36);
          if (HIDWORD(v36) <= HIDWORD(v61))
          {
            v61 = v36;
          }
          else
          {
            v68 = HIDWORD(v61);
            a2[1] = v61;
            a2[3] = v36;
          }
          if (v68 > HIDWORD(v34))
          {
            a2[1] = v34;
            a2[2] = v61;
          }
          break;
        case 5uLL:
          v37 = *a2;
          v38 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v38))
          {
            v39 = a2[1];
            v38 = *a2;
          }
          else
          {
            *a2 = v38;
            a2[1] = v37;
            v39 = v37;
          }
          v63 = a2[2];
          v62 = a2[3];
          v64 = HIDWORD(v63);
          if (HIDWORD(v63) <= HIDWORD(v62))
          {
            v65 = a2[3];
            v62 = a2[2];
          }
          else
          {
            v64 = HIDWORD(v62);
            a2[2] = v62;
            a2[3] = v63;
            v65 = v63;
          }
          if (v64 >= HIDWORD(v38))
          {
            v67 = v62;
            v62 = v38;
          }
          else
          {
            *a2 = v62;
            a2[2] = v38;
            v67 = v38;
          }
          v69 = a2[4];
          v70 = HIDWORD(v39);
          if (HIDWORD(v39) <= HIDWORD(v69))
          {
            v71 = a2[4];
            v69 = v39;
          }
          else
          {
            v70 = HIDWORD(v69);
            a2[1] = v69;
            a2[4] = v39;
            v71 = v39;
          }
          if (v70 >= HIDWORD(v62))
          {
            v62 = v69;
          }
          else
          {
            *a2 = v69;
            a2[1] = v62;
          }
          v72 = HIDWORD(v67);
          if (HIDWORD(v67) <= HIDWORD(v65))
          {
            v73 = v65;
            v65 = v67;
          }
          else
          {
            v72 = HIDWORD(v65);
            a2[2] = v65;
            a2[3] = v67;
            v73 = v67;
          }
          if (v72 >= HIDWORD(v62))
          {
            v62 = v65;
          }
          else
          {
            a2[1] = v65;
            a2[2] = v62;
          }
          v74 = HIDWORD(v73);
          if (HIDWORD(v73) <= HIDWORD(v71))
          {
            v71 = v73;
          }
          else
          {
            v74 = HIDWORD(v71);
            a2[3] = v71;
            a2[4] = v73;
          }
          if (v74 < HIDWORD(v62))
          {
            a2[2] = v71;
            a2[3] = v62;
          }
          break;
        default:
          if (a3 <= 0)
          {
            for (i = 1; i != v5; ++i)
            {
              v41 = a2[i];
              v42 = i;
              while (1)
              {
                v43 = v42 - 1;
                v44 = (v42 - 1) >> 1;
                v45 = a2[v44];
                if (v45 >= v41)
                  break;
                a2[v42] = v45;
                v42 = (v42 - 1) >> 1;
                if (v43 <= 1)
                  goto LABEL_63;
              }
              v44 = v42;
LABEL_63:
              a2[v44] = v41;
            }
            v46 = v5 - 1;
            v47 = a2[v5 - 1];
            a2[v5 - 1] = *a2;
            if (v5 - 1 >= 2)
            {
              do
              {
                v48 = 0;
                v49 = 0;
                v50 = 1;
                while (1)
                {
                  v51 = a2[v50];
                  v52 = v48 + 2;
                  if (v48 + 2 >= v46)
                  {
                    v52 = v50;
                  }
                  else
                  {
                    v53 = a2[v52];
                    if (v51 >= v53)
                      v52 = v50;
                    if (v51 <= v53)
                      v51 = v53;
                  }
                  if (v47 >= v51)
                    break;
                  a2[v49] = v51;
                  v48 = 2 * v52;
                  v50 = (2 * v52) | 1;
                  v49 = v52;
                  if (v50 >= v46)
                    goto LABEL_77;
                }
                v52 = v49;
LABEL_77:
                a2[v52] = v47;
                v47 = a2[--v46];
                a2[v46] = *a2;
              }
              while (v46 > 1);
            }
            *a2 = v47;
          }
          else
          {
            v6 = v5 >> 2;
            v7 = &a2[v5 >> 1];
            v8 = *a2;
            v9 = v7[-(v5 >> 2)];
            if (HIDWORD(*a2) <= HIDWORD(v9))
            {
              v10 = v7[-(v5 >> 2)];
              v9 = *a2;
            }
            else
            {
              *a2 = v9;
              v7[-(v5 >> 2)] = v8;
              v10 = v8;
            }
            v11 = *v7;
            v12 = v7[v6];
            v13 = HIDWORD(*v7);
            if (v13 <= HIDWORD(v12))
            {
              v14 = v7[v6];
              v12 = *v7;
            }
            else
            {
              v13 = HIDWORD(v12);
              *v7 = v12;
              v7[v6] = v11;
              v14 = v11;
            }
            if (v13 >= HIDWORD(v9))
            {
              v15 = v12;
              v12 = v9;
            }
            else
            {
              *a2 = v12;
              *v7 = v9;
              v15 = v9;
            }
            v16 = &a2[v5];
            v17 = *(v16 - 1);
            v18 = HIDWORD(v10);
            if (HIDWORD(v10) <= HIDWORD(v17))
            {
              v19 = *(v16 - 1);
              v17 = v10;
            }
            else
            {
              v18 = HIDWORD(v17);
              v7[-(v5 >> 2)] = v17;
              *(v16 - 1) = v10;
              v19 = v10;
            }
            if (v18 >= HIDWORD(v12))
            {
              v12 = v17;
            }
            else
            {
              *a2 = v17;
              v7[-(v5 >> 2)] = v12;
            }
            v20 = HIDWORD(v15);
            if (HIDWORD(v15) <= HIDWORD(v14))
            {
              v21 = v14;
              v14 = v15;
            }
            else
            {
              v20 = HIDWORD(v14);
              *v7 = v14;
              v7[v6] = v15;
              v21 = v15;
            }
            if (v20 >= HIDWORD(v12))
            {
              v12 = v14;
            }
            else
            {
              v7[-(v5 >> 2)] = v14;
              *v7 = v12;
            }
            v22 = HIDWORD(v21);
            if (HIDWORD(v21) <= HIDWORD(v19))
            {
              v19 = v21;
            }
            else
            {
              v22 = HIDWORD(v19);
              v7[v6] = v19;
              *(v16 - 1) = v21;
            }
            if (v22 < HIDWORD(v12))
            {
              *v7 = v19;
              v7[v6] = v12;
            }
            v23 = 0;
            v24 = *((unsigned int *)v7 + 1);
            v25 = a2 - 1;
            v26 = v5;
            while (1)
            {
              if (v23 < v5)
              {
                while (HIDWORD(a2[v23]) < v24)
                {
                  if (v5 == ++v23)
                  {
                    v23 = v5;
                    goto LABEL_36;
                  }
                }
              }
              do
              {
LABEL_36:
                v27 = v26;
                if (!v26)
                  break;
                --v26;
              }
              while (HIDWORD(v25[v27]) >= v24);
              if (v23 >= v27)
                break;
              if (v23 + 1 != v27)
              {
                v28 = a2[v23];
                a2[v23] = v25[v27];
                v25[v27] = v28;
              }
              v26 = v27 - 1;
              ++v23;
            }
            for (j = v27; j < v5; ++j)
            {
              v30 = a2[j];
              if (v24 == HIDWORD(v30))
              {
                if (j != v27)
                {
                  v31 = a2[v27];
                  a2[v27] = v30;
                  a2[j] = v31;
                }
                ++v27;
              }
            }
            --a3;
            result = quicksort64();
            v5 -= v27;
            a2 += v27;
            if (v5 >= 2)
              continue;
          }
          break;
      }
      break;
    }
  }
  return result;
}

void **MemBufferCreate(size_t a1)
{
  void **v2;
  void **v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v2 = (void **)malloc(0x28uLL);
  v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    if ((MemBufferIncreaseCapacity((uint64_t)v2, a1) & 0x8000000000000000) != 0)
    {
      free(v3[4]);
      free(v3);
      return 0;
    }
  }
  else
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferCreate", 41, 36, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

unint64_t MemBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  unint64_t result;
  void *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  result = *(_QWORD *)a1;
  if (result < a2)
  {
    v5 = reallocf(*(void **)(a1 + 32), a2);
    *(_QWORD *)(a1 + 32) = v5;
    if (v5)
    {
      *(_QWORD *)a1 = a2;
      return a2;
    }
    else
    {
      v6 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseCapacity", 91, 36, *v6, "malloc", v7, v8, v9);
      return -1;
    }
  }
  return result;
}

void MemBufferDestroy(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1);
  }
}

uint64_t MemBufferGetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MemBufferGetFreeSize(_QWORD *a1)
{
  return *a1 - a1[1];
}

uint64_t MemBufferGetDataPtr(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 16);
}

uint64_t MemBufferGetFreePtr(uint64_t a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      memmove(*(void **)(a1 + 32), (const void *)(*(_QWORD *)(a1 + 32) + v3), v2);
      v4 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = v4;
    }
  }
  return *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
}

uint64_t MemBufferDecreaseSize(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  unint64_t v10;
  uint64_t result;
  unint64_t v12;

  v9 = (_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 8);
  result = v10 - a2;
  if (v10 >= a2)
  {
    if (v10 == a2)
    {
      result = 0;
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 16) + a2;
      *(_QWORD *)(a1 + 8) = result;
      *(_QWORD *)(a1 + 16) = v12;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferDecreaseSize", 117, 36, 0, "MemBufferDecreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return result;
}

uint64_t MemBufferIncreaseSize(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;

  v8 = a1[3] + a2;
  if (v8 <= *a1)
  {
    a1[3] = v8;
    v9 = a1[1] + a2;
    a1[1] = v9;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseSize", 137, 36, 0, "MemBufferIncreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return v9;
}

uint64_t MemBufferFillFromBuffer(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6;
  void *FreePtr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = *a1 - a1[1];
  FreePtr = (void *)MemBufferGetFreePtr((uint64_t)a1);
  if (v6 >= a2)
  {
    memcpy(FreePtr, a3, a2);
    return MemBufferIncreaseSize(a1, a2, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFillFromBuffer", 162, 36, 0, "MemBufferFillFromBuffer n is too large: %zu", v8, v9, a2);
    return -1;
  }
}

uint64_t MemBufferFillFromIStream(unint64_t *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  unint64_t v8;
  uint64_t FreePtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = *a1 - a1[1];
  FreePtr = MemBufferGetFreePtr((uint64_t)a1);
  if (v8 >= a2)
    v8 = a2;
  if (v8)
  {
    v16 = FreePtr;
    v17 = 0;
    while (1)
    {
      v18 = a3(a4, v16, v8);
      if (v18 < 0)
        break;
      if (v18)
      {
        v16 += v18;
        v17 += v18;
        v8 -= v18;
        if (v8)
          continue;
      }
      return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
    }
    return -1;
  }
  else
  {
    v17 = 0;
    return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
  }
}

uint64_t MemBufferFlushToOStream(_QWORD *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  if (a1[1] >= a2)
    v9 = a2;
  else
    v9 = a1[1];
  if (v9)
  {
    v12 = 0;
    v13 = a1[4] + a1[2];
    while (1)
    {
      v14 = a3(a4, v13, v9);
      if (v14 < 0)
        break;
      if (!v14)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToOStream", 265, 36, 0, "MemBuffer write proc returned 0", a7, a8, v16);
        return -1;
      }
      v13 += v14;
      v12 += v14;
      v9 -= v14;
      if (!v9)
        return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
    return -1;
  }
  else
  {
    v12 = 0;
    return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t MemBufferTransmit(unint64_t *a1, unint64_t a2, size_t (*a3)(int a1, void *a2, size_t a3), uint64_t a4, uint64_t (*a5)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  size_t (*v12)(int, void *, size_t);
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  __int16 v20;
  char v22;

  v8 = a2;
  if ((unint64_t)a3 | (unint64_t)a5)
  {
    if (a3)
      v11 = a4;
    else
      v11 = 0;
    if (a3)
      v12 = a3;
    else
      v12 = IZeroStreamRead;
    if (a5)
      v13 = a5;
    else
      v13 = ONullStreamWrite;
    if (a5)
      v14 = a6;
    else
      v14 = 0;
    if (*a1)
    {
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      v9 = 0;
      if (!a2)
        return v9;
      while (1)
      {
        if (*a1 >= v8)
          v15 = v8;
        else
          v15 = *a1;
        v16 = v12(v11, (void *)a1[4], v15);
        if (v16 < 0)
        {
          v19 = "read failed";
          v20 = 294;
          goto LABEL_30;
        }
        v17 = v16;
        v18 = v13(v14, a1[4], v16);
        if ((v18 & 0x8000000000000000) != 0)
        {
          v19 = "write failed";
          v20 = 298;
          goto LABEL_30;
        }
        if (v18 < v17)
          break;
        if (v17)
        {
          v9 += v17;
          if (v8 == -1)
            v8 = -1;
          else
            v8 -= v17;
          if (v8)
            continue;
        }
        return v9;
      }
      v19 = "truncated write";
      v20 = 299;
    }
    else
    {
      v19 = "MemBuffer is not allocated";
      v20 = 281;
    }
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferTransmit", v20, 36, 0, v19, a7, a8, v22);
    return -1;
  }
  return a2;
}

void MappedBufferDestroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[1];
    if (v2 != (void *)-1)
      munmap(v2, a1[2]);
    if (*((_DWORD *)a1 + 1))
    {
      if ((*(_DWORD *)a1 & 0x80000000) == 0)
        close(*(_DWORD *)a1);
    }
    free(a1);
  }
}

_QWORD *MappedBufferCreateWithFD(int a1, unint64_t a2, unint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  off_t v18;
  unint64_t v19;
  char *v20;
  char v22;
  stat v23;

  v6 = malloc(0x28uLL);
  v7 = v6;
  if (v6)
  {
    v6[3] = 0;
    v6[4] = 0;
    v6[1] = -1;
    v6[2] = 0;
    memset(&v23, 0, sizeof(v23));
    v8 = getpagesize();
    *(_DWORD *)v7 = a1;
    *((_DWORD *)v7 + 1) = 0;
    if (a1 < 0)
    {
      v13 = "invalid file descriptor";
      v14 = 397;
LABEL_17:
      v12 = 0;
      goto LABEL_18;
    }
    v11 = v8;
    if (fstat(a1, &v23))
    {
      v12 = *__error();
      v13 = "MappedBuffer fstat";
      v14 = 400;
LABEL_18:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFD", v14, 36, v12, v13, v9, v10, v22);
      MappedBufferDestroy(v7);
      return 0;
    }
    if (v23.st_size <= a2)
    {
      v22 = a2;
      v13 = "invalid offset=%llu for fd";
      v14 = 401;
      goto LABEL_17;
    }
    if (a3 == -1)
    {
      a3 = v23.st_size - a2;
    }
    else if (a3 + a2 > v23.st_size)
    {
      v22 = a2;
      v13 = "invalid offset=%llu, size=%llu for fd";
      v14 = 405;
      goto LABEL_17;
    }
    if (!a3)
    {
      v22 = 0;
      v13 = "invalid size=%llu for fd";
      v14 = 407;
      goto LABEL_17;
    }
    v7[4] = a3;
    v18 = a2 / v11 * v11;
    v19 = a2 % v11;
    v7[2] = v19 + a3;
    v20 = (char *)mmap(0, v19 + a3, 1, 1, a1, v18);
    v7[1] = v20;
    if (v20 == (char *)-1)
    {
      v12 = *__error();
      v13 = "mmap file segment";
      v14 = 417;
      goto LABEL_18;
    }
    v7[3] = &v20[v19];
  }
  else
  {
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFD", 382, 36, *v15, "malloc", v16, v17, v22);
  }
  return v7;
}

uint64_t MappedBufferGetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

size_t IZeroStreamRead(int a1, void *a2, size_t a3)
{
  bzero(a2, a3);
  return a3;
}

uint64_t ONullStreamWrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

_QWORD *OSHA1StreamCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v6 = malloc(0x80uLL);
  v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)v6);
    v7[13] = a1;
    v7[14] = a2;
    v7[15] = a3;
  }
  else
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OSHA1StreamCreate", 76, 29, *v8, "malloc", v9, v10, v12);
  }
  return v7;
}

void OSHA1StreamDestroy(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  if (c)
  {
    CC_SHA1_Deprecated_Final(md, c);
    free(c);
  }
}

uint64_t OSHA1StreamWrite(CC_SHA1_CTX *c, const void *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t (*v7)(_QWORD, const void *, uint64_t);

  if (!c || c[1].h0)
    return -1;
  v4 = a3;
  CC_SHA1_Deprecated_Update(c, a2, a3);
  v7 = *(uint64_t (**)(_QWORD, const void *, uint64_t))&c[1].h2;
  if (!v7)
    return v4;
  return v7(*(_QWORD *)&c[1].Nh, a2, v4);
}

uint64_t OSHA1StreamAbort(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);

  if (result)
  {
    v1 = result;
    v2 = *(uint64_t (**)(_QWORD))(result + 112);
    if (v2)
      result = v2(*(_QWORD *)(result + 120));
    *(_DWORD *)(v1 + 96) = 1;
  }
  return result;
}

uint64_t IFileStreamCreateWithFilename(const char *a1, unint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  int v16;
  char v17;

  v6 = (char *)malloc(0x70uLL);
  v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((_QWORD *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    v8 = (pthread_mutex_t *)(v6 + 40);
    *(_QWORD *)v7 = 0x1FFFFFFFFLL;
    v9 = a2 + a3;
    if (__CFADD__(a2, a3))
      v9 = -1;
    *(_QWORD *)(v7 + 16) = a2;
    *(_QWORD *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      v12 = "pthread_mutex_init";
      v13 = 293;
    }
    else
    {
      v16 = open(a1, 0);
      *(_DWORD *)v7 = v16;
      if (v16 < 0)
      {
        v14 = *__error();
        v17 = (char)a1;
        v12 = "%s";
        v13 = 297;
        goto LABEL_9;
      }
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0)
        return v7;
      v12 = "seek error";
      v13 = 303;
    }
    v14 = 0;
  }
  else
  {
    v14 = *__error();
    v12 = "malloc";
    v13 = 282;
  }
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFilename", v13, 29, v14, v12, v10, v11, v17);
  IFileStreamDestroy((char *)v7);
  return 0;
}

uint64_t clampIfRegularFile(uint64_t a1)
{
  uint64_t result;
  unint64_t st_size;
  stat v4;

  memset(&v4, 0, sizeof(v4));
  result = fstat(*(_DWORD *)a1, &v4);
  if (!(_DWORD)result && (v4.st_mode & 0xF000) == 0x8000)
  {
    st_size = v4.st_size;
    if (*(_QWORD *)(a1 + 16) > v4.st_size)
      *(_QWORD *)(a1 + 16) = v4.st_size;
    if (*(_QWORD *)(a1 + 24) > st_size)
      *(_QWORD *)(a1 + 24) = st_size;
  }
  return result;
}

uint64_t seekTo(uint64_t a1, unint64_t a2)
{
  off_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  const char *v9;
  __int16 v10;
  int v11;
  void *v12;
  void *i;
  size_t v14;
  ssize_t v15;
  char v16;

  if (*(_QWORD *)(a1 + 32) == a2)
    return 0;
  v4 = lseek(*(_DWORD *)a1, a2, 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
    v7 = v4;
    *(_QWORD *)(a1 + 32) = v4;
LABEL_4:
    if (v7 == a2)
      return 0;
    v9 = "pos not reached";
    v10 = 261;
    goto LABEL_10;
  }
  if (*__error() != 32)
  {
    v11 = *__error();
    v9 = "lseek failed";
    v10 = 258;
    goto LABEL_12;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7 <= a2)
  {
    v12 = valloc(0x4000uLL);
    if (!v12)
    {
      v11 = *__error();
      v9 = "malloc";
      v10 = 244;
      goto LABEL_12;
    }
    for (i = v12; v7 < a2; *(_QWORD *)(a1 + 32) = v7)
    {
      if (v7 + 0x4000 <= a2)
        v14 = 0x4000;
      else
        v14 = a2 - v7;
      v15 = read(*(_DWORD *)a1, i, v14);
      v7 = *(_QWORD *)(a1 + 32);
      if (v15 < 1)
        break;
      v7 += v15;
    }
    free(i);
    goto LABEL_4;
  }
  v9 = "lseek failed and pos < s->pos";
  v10 = 240;
LABEL_10:
  v11 = 0;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"seekTo", v10, 29, v11, v9, v5, v6, v16);
  return 0xFFFFFFFFLL;
}

void IFileStreamDestroy(char *a1)
{
  int v2;

  if (a1)
  {
    if (*((_DWORD *)a1 + 1))
    {
      v2 = *(_DWORD *)a1;
      if ((v2 & 0x80000000) == 0)
        close(v2);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
    free(a1);
  }
}

uint64_t IFileStreamCreateWithFD(int a1, unint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  v6 = (char *)malloc(0x70uLL);
  v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((_QWORD *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    v8 = (pthread_mutex_t *)(v6 + 40);
    *(_DWORD *)v7 = a1;
    *(_DWORD *)(v7 + 4) = 0;
    v9 = a2 + a3;
    if (__CFADD__(a2, a3))
      v9 = -1;
    *(_QWORD *)(v7 + 16) = a2;
    *(_QWORD *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      v12 = "pthread_mutex_init";
      v13 = 325;
    }
    else
    {
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0)
        return v7;
      v12 = "seek error";
      v13 = 331;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFD", v13, 29, 0, v12, v10, v11, v18);
    IFileStreamDestroy((char *)v7);
    return 0;
  }
  else
  {
    v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFD", 314, 29, *v14, "malloc", v15, v16, v18);
  }
  return v7;
}

uint64_t IFileStreamRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  uint64_t v16;
  ssize_t v17;
  unint64_t *v18;
  unint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  char v25;

  if (*(_DWORD *)(a1 + 8))
    return -1;
  if (!a3)
    return 0;
  v10 = *(_QWORD *)(a1 + 32);
  if (v10 < *(_QWORD *)(a1 + 16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 358, 29, 0, "pos out of range", a7, a8, v25);
    return -1;
  }
  if (~v10 < a3)
    v11 = ~v10;
  else
    v11 = a3;
  v12 = a3 + v10;
  if (__CFADD__(a3, v10))
    v12 = -1;
  v13 = *(_QWORD *)(a1 + 24);
  if (v12 <= v13)
    v14 = v11;
  else
    v14 = v13 - v10;
  if (v14)
  {
    v16 = 0;
    while (1)
    {
      v17 = read(*(_DWORD *)a1, a2, v14);
      if (v17 < 0)
        break;
      if (v17)
      {
        a2 += v17;
        v16 += v17;
        v14 -= v17;
        if (v14)
          continue;
      }
      v10 = *(_QWORD *)(a1 + 32);
      result = v16;
      goto LABEL_23;
    }
    v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 374, 29, *v20, "read", v21, v22, v25);
    *(_QWORD *)(a1 + 32) += v16;
    v23 = (unint64_t *)(a1 + 104);
    result = -1;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 + v16, v23));
  }
  else
  {
    result = 0;
LABEL_23:
    *(_QWORD *)(a1 + 32) = v10 + result;
    v18 = (unint64_t *)(a1 + 104);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + result, v18));
  }
  return result;
}

int *OFileStreamCreateWithFilename(const char *a1, uint64_t a2)
{
  int *v4;
  int *v5;
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v4 = (int *)malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *((_QWORD *)v4 + 2) = a2;
    *((_QWORD *)v4 + 3) = 0;
    v4[1] = 1;
    *((_QWORD *)v4 + 1) = 0;
    v6 = open(a1, 1537, 420);
    *v5 = v6;
    if (v6 < 0)
    {
      v7 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 490, 29, *v7, "%s", v8, v9, (char)a1);
      free(v5);
      return 0;
    }
  }
  else
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 484, 29, *v10, "malloc", v11, v12, v14);
  }
  return v5;
}

void OFileStreamDestroy(int *a1)
{
  int v2;

  if (a1)
  {
    if (a1[1])
    {
      v2 = *a1;
      if ((v2 & 0x80000000) == 0)
        close(v2);
    }
    free(a1);
  }
}

uint64_t OFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3)
{
  uint64_t v3;
  unint64_t v5;
  size_t v7;
  ssize_t v8;
  uint64_t v9;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  if (*(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v5 = a3;
  else
    v5 = *(_QWORD *)(a1 + 16);
  if (v5)
  {
    v3 = 0;
    while (1)
    {
      v7 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      v8 = write(*(_DWORD *)a1, __buf, v7);
      if (v8 < 0)
        break;
      if (v8)
      {
        v9 = *(_QWORD *)(a1 + 16);
        if (v9 != -1)
          *(_QWORD *)(a1 + 16) = v9 - v8;
        __buf += v8;
        v3 += v8;
        v5 -= v8;
        if (v5)
          continue;
      }
      goto LABEL_18;
    }
    v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamWrite", 538, 29, *v11, "write", v12, v13, v14);
    return -1;
  }
  v3 = 0;
LABEL_18:
  *(_QWORD *)(a1 + 24) += v3;
  return v3;
}

int *OArchiveFileStreamCreate(const char *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  int *v10;
  int *v11;
  int v12;
  int v13;
  __int16 v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v48;
  int v49;
  unsigned int v50;
  char v51;

  v10 = (int *)malloc(0x60uLL);
  v11 = v10;
  if (v10)
  {
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if ((a3 & 0x100) == 0)
      unlink(a1);
    v11[1] = (a3 >> 4) & 1;
    *((_QWORD *)v11 + 2) = a2;
    if ((a3 & 1) != 0)
      v12 = 4;
    else
      v12 = a4;
    if (v12 < 1)
    {
      v13 = open(a1, 1537, 420);
      *v11 = v13;
      if (v13 < 0)
      {
        v14 = 648;
        goto LABEL_31;
      }
    }
    else
    {
      v13 = open_dprotected_np(a1, 1537, v12, 0, 420);
      *v11 = v13;
      if (v13 < 0)
      {
        v14 = 640;
LABEL_31:
        v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", v14, 29, *v37, "%s", v38, v39, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v40, v41, v42, v43, v44, v45, v46);
        goto LABEL_32;
      }
    }
    if ((a3 & 8) != 0 && fcntl(v13, 48, 1))
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 656, 29, "Warning: F_NOCACHE failed: %s\n", v18, v19, v20, (char)a1);
    if ((a3 & 2) != 0 && fcntl(v13, 68, 1) == -1)
    {
      v21 = __error();
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 665, 29, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v22, v23, v24, *v21);
    }
    if (a2 && (a3 & 4) != 0 && a5 != -1)
    {
      if ((a3 & 0x80) != 0)
        v25 = 6;
      else
        v25 = 4;
      v26 = ParallelCompressionAFSCStreamOpen(v13, a2, a5, v25);
      *((_QWORD *)v11 + 3) = v26;
      if (!v26)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 677, 29, 0, "ParallelCompressionAFSCStreamOpen failed: %s", v27, v28, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v29, v30, v31, v32, v33, v34, v35);
        close(v13);
LABEL_32:
        free(v11);
        return 0;
      }
    }
    else if ((a3 & 0x40) != 0)
    {
      v36 = fpathconf(v13, 27);
      if (v36 >= 1)
      {
        v11[10] = 1;
        if (v36 == 4096)
        {
          v11[18] = 4096;
        }
        else
        {
          v48 = 0x10000;
          if (v36 < 0x10000)
            v48 = v36;
          v49 = 1024;
          do
          {
            v50 = v49;
            v49 *= 2;
          }
          while (v50 < v48);
          v11[18] = v50;
        }
      }
    }
  }
  else
  {
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 617, 29, *v15, "malloc", v16, v17, v51);
  }
  return v11;
}

uint64_t OArchiveFileStreamDestroy(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OArchiveFileStreamDestroyEx(a1, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t OArchiveFileStreamDestroyEx(unsigned int *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  char v27;

  if (!a1)
    return 0xFFFFFFFFLL;
  v10 = a2;
  if (*((_QWORD *)a1 + 2))
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 863, 29, "OArchiveFileStream didn't receive enough data before being destroyed\n", a6, a7, a8, v27);
  ParallelCompressionAFSCStreamClose(*((_QWORD *)a1 + 3), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((*a1 & 0x80000000) != 0)
  {
    v13 = 0;
    v19 = 0xFFFFFFFFLL;
    if (!a3)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (*((_QWORD *)a1 + 7))
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = *((_QWORD *)a1 + 8);
    while (fcntl(*a1, 99, v15 + v12) != -1)
    {
      v15 = *((_QWORD *)a1 + 8);
      v13 += *(_QWORD *)(v15 + v12 + 16);
      ++v14;
      v12 += 24;
      if (v14 >= *((_QWORD *)a1 + 7))
        goto LABEL_15;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 875, 29, "F_PUNCHHOLE failed", v16, v17, v18, v27);
  }
  else
  {
    v13 = 0;
  }
LABEL_15:
  if (a1[1])
  {
    v27 = 0;
    if (fcntl(*a1, 51) == -1)
    {
      v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 883, 29, *v20, "Final FULLSYNC", v21, v22, 0);
    }
  }
  v19 = *a1;
  if (!v10)
  {
    if (close(*a1))
    {
      v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 890, 29, *v24, "close", v25, v26, v27);
    }
    v19 = 0xFFFFFFFFLL;
    *a1 = -1;
    if (!a3)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (a3)
LABEL_20:
    *a3 = *((_QWORD *)a1 + 4) - v13;
LABEL_21:
  if (a4)
    *a4 = v13;
  free(*((void **)a1 + 8));
  free(a1);
  return v19;
}

uint64_t OArchiveFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  ssize_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  void *v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  unint64_t *v48;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  v11 = a3;
  if (a3)
  {
    v9 = 0;
    v48 = (unint64_t *)(a1 + 48);
    v13 = *(_QWORD *)(a1 + 16);
    while (v13)
    {
      if (v13 >= v11)
        v13 = v11;
      if (v13 >= 0x40000000)
        v14 = 0x40000000;
      else
        v14 = v13;
      v15 = *(_QWORD *)(a1 + 24);
      if (v15)
      {
        v16 = ParallelCompressionAFSCStreamWrite(v15, (uint64_t)__buf, v14, a4, a5, a6, a7, a8);
        v17 = v16;
        if (v16 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 955, 29, 0, "ParallelCompressionAFSCStreamWrite failed with status %d", a7, a8, v16);
          return -1;
        }
      }
      else
      {
        if ((*(_DWORD *)a1 & 0x80000000) != 0)
          return -1;
        v17 = write(*(_DWORD *)a1, __buf, v14);
        if (v17 < 0)
        {
          v44 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 960, 29, v44, "write", v45, v46, v47);
          return -1;
        }
      }
      if (*(_DWORD *)(a1 + 40))
      {
        v18 = 0;
        LODWORD(v19) = *(_DWORD *)(a1 + 72);
        v20 = *(_DWORD *)(a1 + 76);
        do
        {
          v21 = (v19 - v20);
          if (v18 + v21 <= v14)
            v22 = v21;
          else
            v22 = (v14 - v18);
          v23 = &__buf[v18];
          v24 = &__buf[v18 + v22];
          if (((unint64_t)&__buf[v18] & 7) != 0 && (_DWORD)v22)
          {
            v25 = &__buf[v18 + 1];
            while (!*v23)
            {
              if (++v23 < v24)
              {
                if ((unint64_t)(v25++ & 7))
                  continue;
              }
              goto LABEL_29;
            }
LABEL_35:
            v28 = 1;
          }
          else
          {
LABEL_29:
            while (v23 + 8 <= v24)
            {
              v27 = *(_QWORD *)v23;
              v23 += 8;
              if (v27)
                goto LABEL_35;
            }
            while (v23 < v24)
            {
              if (*v23)
                goto LABEL_35;
              ++v23;
            }
            v28 = 0;
          }
          v29 = *(_DWORD *)(a1 + 88) | v28;
          *(_DWORD *)(a1 + 88) = v29;
          v20 += v22;
          *(_DWORD *)(a1 + 76) = v20;
          if (v20 == (_DWORD)v19)
          {
            if (!v29)
            {
              v30 = *(_QWORD *)(a1 + 80);
              v31 = *(_QWORD *)(a1 + 56);
              if (v31
                && (v32 = *(_QWORD *)(a1 + 64) + 24 * v31,
                    v35 = *(_QWORD *)(v32 - 8),
                    v33 = (_QWORD *)(v32 - 8),
                    v34 = v35,
                    v35 + *(v33 - 1) == v30))
              {
                *v33 = v34 + v19;
              }
              else
              {
                v36 = *v48;
                if (v31 >= *v48)
                {
                  v37 = v36 + (v36 >> 1);
                  v38 = v36 == 0;
                  v39 = 32;
                  if (!v38)
                    v39 = v37;
                  *(_QWORD *)(a1 + 48) = v39;
                  v40 = reallocf(*(void **)(a1 + 64), 24 * v39);
                  *(_QWORD *)(a1 + 64) = v40;
                  if (!v40)
                  {
                    *v48 = 0;
                    v48[1] = 0;
                    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 994, 29, "malloc holes failed", a6, a7, a8, v47);
                  }
                }
                v41 = *(_QWORD *)(a1 + 56);
                if (v41 >= *(_QWORD *)(a1 + 48))
                {
                  LODWORD(v19) = *(_DWORD *)(a1 + 72);
                }
                else
                {
                  v42 = *(_QWORD *)(a1 + 64);
                  *(_QWORD *)(a1 + 56) = v41 + 1;
                  v43 = (_QWORD *)(v42 + 24 * v41);
                  *v43 = 0;
                  v43[1] = 0;
                  v43[1] = v30;
                  v43[2] = 0;
                  v19 = *(unsigned int *)(a1 + 72);
                  v43[2] = v19;
                }
              }
            }
            v20 = 0;
            *(_QWORD *)(a1 + 80) += v19;
            *(_DWORD *)(a1 + 76) = 0;
            *(_DWORD *)(a1 + 88) = 0;
          }
          v18 += v22;
        }
        while (v18 < v14);
      }
      __buf += v17;
      v9 += v17;
      v13 = *(_QWORD *)(a1 + 16) - v17;
      *(_QWORD *)(a1 + 16) = v13;
      v11 -= v17;
      if (!v11)
        break;
    }
  }
  else
  {
    v9 = 0;
  }
  *(_QWORD *)(a1 + 32) += v9;
  return v9;
}

_QWORD *OMemStreamCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OMemStreamCreate", 1050, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

uint64_t OMemStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  size_t v4;
  size_t v5;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v4 = a3;
  else
    v4 = *(_QWORD *)(a1 + 16);
  memcpy(*(void **)a1, a2, v4);
  *(_QWORD *)a1 += v4;
  v5 = *(_QWORD *)(a1 + 24) + v4;
  *(_QWORD *)(a1 + 16) -= v4;
  *(_QWORD *)(a1 + 24) = v5;
  return v4;
}

_QWORD *IMemStreamCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMemStreamCreate", 1112, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

size_t IMemStreamRead(uint64_t a1, void *__dst, size_t a3)
{
  size_t v4;
  size_t v5;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v4 = a3;
  else
    v4 = *(_QWORD *)(a1 + 16);
  memcpy(__dst, *(const void **)a1, v4);
  *(_QWORD *)a1 += v4;
  v5 = *(_QWORD *)(a1 + 24) + v4;
  *(_QWORD *)(a1 + 16) -= v4;
  *(_QWORD *)(a1 + 24) = v5;
  return v4;
}

uint64_t IMemStreamAbort(uint64_t result)
{
  if (result)
    *(_DWORD *)(result + 8) = 1;
  return result;
}

char *OBufferedStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  char *v8;
  char *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;

  v8 = (char *)malloc(0x28uLL);
  v9 = v8;
  if (v8)
  {
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    v10 = MemBufferCreate(a4);
    *(_QWORD *)v9 = v10;
    if (v10)
    {
      *((_QWORD *)v9 + 1) = a1;
      *((_QWORD *)v9 + 2) = a2;
      *((_QWORD *)v9 + 3) = a3;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1182, 29, 0, "creating internal buffer", v11, v12, v24);
      OBufferedStreamDestroy((void ***)v9, v16, v17, v18, v19, v20, v21, v22);
      return 0;
    }
  }
  else
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1176, 29, *v13, "malloc", v14, v15, v24);
  }
  return v9;
}

void OBufferedStreamDestroy(void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], a5, a6, a7, a8);
    MemBufferDestroy(*a1);
    free(a1);
  }
}

uint64_t OBufferedStreamWrite(unint64_t **a1, char *a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t FreeSize;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (a1 && !*((_DWORD *)a1 + 8))
  {
    v6 = a3;
    if (!a3)
      return 0;
    v4 = 0;
    while (1)
    {
      FreeSize = MemBufferGetFreeSize(*a1);
      if (!FreeSize)
      {
        if (MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], v9, v10, v11, v12) < 0)return -1;
        FreeSize = MemBufferGetFreeSize(*a1);
      }
      v13 = v6 >= FreeSize ? FreeSize : v6;
      if (MemBufferFillFromBuffer(*a1, v13, a2) < 0)
        break;
      a2 += v13;
      v4 += v13;
      v6 -= v13;
      if (!v6)
        return v4;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamWrite", 1221, 29, 0, "MemBufferFillFromBuffer failed", v14, v15, v16);
  }
  return -1;
}

_QWORD *aaAssetDecompressionStreamOpen(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  __int16 v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v11;

  v2 = malloc(0x70uLL);
  v3 = v2;
  if (!v2)
  {
    v6 = 277;
LABEL_6:
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"aaAssetDecompressionStreamOpen", v6, 132, *v7, "malloc", v8, v9, v11);
    closeProc_0((uint64_t)v3);
    return 0;
  }
  memset_s(v2, 0x70uLL, 0, 0x70uLL);
  *v3 = a1;
  v4 = malloc(0x38uLL);
  if (!v4)
  {
    v6 = 282;
    goto LABEL_6;
  }
  v5 = v4;
  memset_s(v4, 0x38uLL, 0, 0x38uLL);
  *v5 = v3;
  v5[1] = closeProc_0;
  v5[6] = closeWithStateProc_0;
  v5[2] = cancelProc_0;
  v5[3] = writeProc_0;
  return v5;
}

uint64_t closeProc_0(uint64_t result)
{
  void **v1;
  unsigned int v2;
  void *v3;

  if (result)
  {
    v1 = (void **)result;
    v2 = atomic_load((unsigned int *)(result + 8));
    v3 = (void *)(result + 56);
    free(*(void **)(result + 72));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[12]);
    memset_s(v1 + 10, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x70uLL, 0, 0x70uLL);
    free(v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t closeWithStateProc_0(uint64_t result, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t *v12;
  __int128 v13;
  _BOOL4 v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;

  if (result)
  {
    v9 = result;
    v10 = atomic_load((unsigned int *)(result + 8));
    v12 = (uint64_t *)(result + 80);
    v11 = *(_QWORD *)(result + 80);
    v32 = *(_QWORD *)(result + 24);
    v13 = *(_OWORD *)(result + 48);
    v33 = *(_OWORD *)(result + 32);
    v34 = v13;
    v14 = v10 == 0;
    v15 = (uint64_t *)(result + 56);
    v16 = *(_QWORD *)(result + 104);
    v35 = v11;
    v36 = v16;
    if (a2[3])
    {
      v18 = 0;
      v19 = &v32;
      v20 = 56;
      while (1)
      {
        v21 = ((uint64_t (*)(_QWORD, uint64_t *, uint64_t))a2[3])(*a2, v19, v20);
        if (v21 < 1)
          break;
        v19 = (uint64_t *)((char *)v19 + v21);
        v18 += v21;
        v20 -= v21;
        if (!v20)
        {
          if (v18 != 56)
            break;
          if (!a2[3])
            goto LABEL_29;
          v22 = *v15;
          if (*v15)
          {
            v23 = 0;
            v24 = *(_QWORD *)(v9 + 72);
            while (1)
            {
              v25 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v24, v22);
              if (v25 < 1)
                break;
              v24 += v25;
              v23 += v25;
              v22 -= v25;
              if (!v22)
                goto LABEL_18;
            }
            v23 = v25;
LABEL_18:
            if (v23 < 0 || !a2[3])
              goto LABEL_29;
          }
          v27 = *v12;
          if (*v12)
          {
            v28 = 0;
            v29 = *(_QWORD *)(v9 + 96);
            while (1)
            {
              v30 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
              if (v30 < 1)
                break;
              v29 += v30;
              v28 += v30;
              v27 -= v30;
              if (!v27)
                goto LABEL_26;
            }
            v28 = v30;
LABEL_26:
            if (v28 < 0)
            {
LABEL_29:
              v26 = 250;
              goto LABEL_14;
            }
          }
          if (a3)
            *a3 = *(_QWORD *)(v9 + 104);
          goto LABEL_15;
        }
      }
    }
    v26 = 245;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"closeWithStateProc", v26, 132, 0, "write state", a7, a8, v31);
    v14 = 0;
LABEL_15:
    free(*(void **)(v9 + 72));
    memset_s(v12 - 3, 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v9 + 96));
    memset_s(v12, 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v9, 0x70uLL, 0, 0x70uLL);
    free((void *)v9);
    return (v14 - 1);
  }
  return result;
}

uint64_t writeProc_0(_QWORD **a1, char *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v10;
  unint64_t v14;
  unint64_t *v15;
  unint64_t *v16;
  int v17;
  _QWORD *v18;
  size_t v19;
  size_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  _DWORD *v25;
  int v27;
  _QWORD *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  BOOL v34;
  uint64_t (*v35)(char *);
  unint64_t *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  char *v40;
  uint64_t v41;
  BOOL v42;
  unint64_t v43;
  uint64_t (*v44)(_QWORD, unint64_t, unint64_t);
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  size_t v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t v52;
  size_t v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  const char *v57;
  __int16 v58;
  void (*v60)(_QWORD);
  char v62;
  _BYTE v63[12];

  v8 = (unsigned int *)(a1 + 1);
  if (atomic_load((unsigned int *)a1 + 2))
    return -1;
  v10 = 0;
  v15 = (unint64_t *)(a1 + 7);
  v14 = (unint64_t)a1[7];
  v16 = (unint64_t *)(a1 + 10);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        v17 = *((_DWORD *)a1 + 6);
        if (v17 != 2)
          break;
        v18 = a1[5];
        v19 = (size_t)v18 - v14;
        if ((unint64_t)v18 <= v14)
        {
          v35 = (uint64_t (*)(char *))a1[2];
          if (v35 && a1[6] != v18)
          {
            if (v18 != (_QWORD *)v14 || (v40 = (char *)a1[10], (char *)a1[11] - v40 < (unint64_t)a1[4]))
            {
              v57 = "invalid state";
              v58 = 174;
              goto LABEL_126;
            }
            v41 = v35(&v40[(_QWORD)a1[12]]);
            if ((_QWORD *)v41 != a1[6])
            {
              v57 = "corrupted stream";
              v58 = 176;
              goto LABEL_126;
            }
            v14 = *v16;
            if (v41)
            {
              v42 = __CFADD__(v14, v41);
              v14 += v41;
              if (v42 || v14 > (unint64_t)a1[11])
              {
                v57 = "invalid size";
                v58 = 177;
                goto LABEL_126;
              }
              *v16 = v14;
            }
            v36 = v16;
            if (v14)
            {
LABEL_67:
              v43 = v36[2];
              while (1)
              {
                v44 = (uint64_t (*)(_QWORD, unint64_t, unint64_t))(*a1)[3];
                if (!v44)
                  break;
                v45 = v44(**a1, v43, v14);
                if (v45 <= 0)
                  break;
                v43 += v45;
                v14 -= v45;
                if (!v14)
                  goto LABEL_71;
              }
              v57 = "write";
              v58 = 187;
              goto LABEL_126;
            }
          }
          else
          {
            v36 = v15;
            if (v14)
              goto LABEL_67;
          }
LABEL_71:
          v14 = 0;
          a1[7] = 0;
          a1[10] = 0;
          *((_DWORD *)a1 + 6) = 1;
        }
        else
        {
          if (!a3)
            goto LABEL_106;
LABEL_7:
          if (v19 >= a3)
            v20 = a3;
          else
            v20 = v19;
          v21 = v14 + v20;
          if (__CFADD__(v14, v20) || (v21 & 0x8000000000000000) != 0)
            goto LABEL_119;
          v22 = (unint64_t)a1[8];
          if (v22 < v21)
          {
            do
            {
              while (!v22)
              {
                v22 = 0x4000;
                v24 = 0x4000;
                if (v21 <= 0x4000)
                  goto LABEL_51;
              }
              v23 = v22 >> 1;
              if ((v22 & (v22 >> 1)) != 0)
                v23 = v22 & (v22 >> 1);
              v22 += v23;
            }
            while (v22 < v21);
            v24 = v22;
            if (v22 >= 0x2000000001)
            {
              *__error() = 12;
LABEL_118:
              *v15 = 0;
              v15[1] = 0;
              v15[2] = 0;
LABEL_119:
              v57 = "malloc";
              v58 = 209;
              goto LABEL_126;
            }
LABEL_51:
            v37 = a1[9];
            v38 = realloc(v37, v24);
            if (!v38)
            {
              free(v37);
              goto LABEL_118;
            }
            a1[8] = (_QWORD *)v24;
            a1[9] = v38;
          }
          v39 = a1[9];
          if (__src)
          {
            memcpy((char *)v39 + *v15, __src, v20);
          }
          else if (v39)
          {
            memset_s((char *)v39 + *v15, v20, 0, v20);
          }
          v14 = *v15 + v20;
          *v15 = v14;
          if ((v20 & 0x8000000000000000) != 0)
            goto LABEL_119;
          a3 -= v20;
          __src += v20;
          v10 += v20;
          a1[13] = (_QWORD *)((char *)a1[13] + v20);
        }
      }
      if (v17 == 1)
        break;
      if (v17)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"writeProc", 199, 132, 0, "invalid state %d", a7, a8, *((_DWORD *)a1 + 6));
        goto LABEL_127;
      }
      if (!(a3 | v14))
        goto LABEL_106;
      if (v14 <= 0xB)
      {
        v56 = 12;
        goto LABEL_105;
      }
      v25 = a1[9];
      *(_QWORD *)v63 = *(_QWORD *)v25;
      *(_DWORD *)&v63[8] = v25[2];
      if ((unsigned __int16)*(_QWORD *)v25 != 25200 || BYTE2(*(_QWORD *)v25) != 122)
      {
LABEL_111:
        v57 = "invalid compressed stream";
        v58 = 106;
        goto LABEL_126;
      }
      if (v63[3] <= 100)
      {
        switch(v63[3])
        {
          case '-':
            v27 = 0;
            v28 = 0;
            break;
          case '4':
            v27 = 256;
            v28 = PCompressLZ4Decode;
            break;
          case 'b':
            v27 = 1794;
            v28 = PCompressLZBITMAPDecode;
            break;
          default:
            goto LABEL_111;
        }
      }
      else if (v63[3] > 119)
      {
        if (v63[3] == 120)
        {
          v27 = 774;
          v28 = PCompressLZMADecode;
        }
        else
        {
          if (v63[3] != 122)
            goto LABEL_111;
          v27 = 1285;
          v28 = PCompressZLIBDecode;
        }
      }
      else if (v63[3] == 101)
      {
        v27 = 2049;
        v28 = PCompressLZFSEDecode;
      }
      else
      {
        if (v63[3] != 102)
          goto LABEL_111;
        v27 = 2304;
        v28 = PCompressLZVNDecode;
      }
      *((_DWORD *)a1 + 7) = v27;
      v46 = bswap64(*(unint64_t *)&v63[4]);
      a1[4] = (_QWORD *)v46;
      a1[2] = v28;
      if ((v46 & 0x8000000000000000) != 0)
        goto LABEL_125;
      v47 = (unint64_t)a1[8];
      if (v47 < v46)
      {
        do
        {
          while (!v47)
          {
            v47 = 0x4000;
            v49 = 0x4000;
            if (v46 <= 0x4000)
              goto LABEL_89;
          }
          v48 = v47 >> 1;
          if ((v47 & (v47 >> 1)) != 0)
            v48 = v47 & (v47 >> 1);
          v47 += v48;
        }
        while (v47 < v46);
        v49 = v47;
        if (v47 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_124;
        }
LABEL_89:
        v50 = realloc(v25, v49);
        if (!v50)
        {
          free(v25);
LABEL_124:
          *v15 = 0;
          v15[1] = 0;
          v15[2] = 0;
LABEL_125:
          v57 = "reserve buffers";
          v58 = 128;
LABEL_126:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"writeProc", v58, 132, 0, v57, a7, a8, v62);
LABEL_127:
          v10 = -1;
          goto LABEL_128;
        }
        a1[8] = (_QWORD *)v49;
        a1[9] = v50;
        v46 = (unint64_t)a1[4];
        if ((v46 & 0x8000000000000000) != 0)
          goto LABEL_125;
      }
      v51 = (unint64_t)a1[11];
      if (v51 < v46)
      {
        do
        {
          while (!v51)
          {
            v51 = 0x4000;
            v53 = 0x4000;
            if (v46 <= 0x4000)
              goto LABEL_100;
          }
          v52 = v51 >> 1;
          if ((v51 & (v51 >> 1)) != 0)
            v52 = v51 & (v51 >> 1);
          v51 += v52;
        }
        while (v51 < v46);
        v53 = v51;
        if (v51 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_123;
        }
LABEL_100:
        v54 = a1[12];
        v55 = realloc(v54, v53);
        if (!v55)
        {
          free(v54);
LABEL_123:
          v15 = v16;
          goto LABEL_124;
        }
        a1[11] = (_QWORD *)v53;
        a1[12] = v55;
      }
      v14 = 0;
      a1[7] = 0;
      *((_DWORD *)a1 + 6) = 1;
    }
    if (!(a3 | v14))
      goto LABEL_106;
    if (v14 <= 0xF)
      break;
    v29 = a1[9];
    v30 = v29[1];
    v31 = bswap64(*v29);
    v32 = bswap64(v30);
    a1[5] = (_QWORD *)v32;
    a1[6] = (_QWORD *)v31;
    if (v31 < v32
      || ((v33 = a1[4], v31 <= (unint64_t)v33) ? (v34 = v32 > (unint64_t)v33) : (v34 = 1), v34))
    {
      v57 = "invalid compressed stream";
      v58 = 149;
      goto LABEL_126;
    }
    v14 = 0;
    a1[7] = 0;
    *((_DWORD *)a1 + 6) = 2;
  }
  v56 = 16;
LABEL_105:
  v19 = v56 - v14;
  if (a3)
    goto LABEL_7;
LABEL_106:
  if (v10 < 0)
  {
    do
    {
LABEL_128:
      if (__ldaxr(v8))
      {
        __clrex();
        return v10;
      }
    }
    while (__stlxr(1u, v8));
    v60 = (void (*)(_QWORD))(*a1)[2];
    if (v60)
      v60(**a1);
  }
  return v10;
}

_QWORD **cancelProc_0(_QWORD **result)
{
  unsigned int *v1;
  uint64_t (*v3)(_QWORD);

  v1 = (unsigned int *)(result + 1);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v1));
  v3 = (uint64_t (*)(_QWORD))(*result)[2];
  if (v3)
    return (_QWORD **)v3(**result);
  return result;
}

void (**aaAssetDecompressionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, _QWORD *a3))(void)
{
  void (**v5)(void);
  uint64_t v6;
  uint64_t v7;
  void (**v8)(void);
  void (*v9)(void);
  uint64_t v10;
  __int128 *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  __int16 v22;
  unint64_t *v24;
  size_t v25;
  size_t v26;
  void **v27;
  void *v28;
  void *v29;
  size_t v30;
  unint64_t *v31;
  size_t v32;
  void *v33;
  void *v34;
  size_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  size_t v41;
  void *v42;
  void *v43;
  size_t v44;
  ssize_t v45;
  size_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  size_t v52;
  void *v53;
  void *v54;
  size_t v55;
  ssize_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v5 = (void (**)(void))aaAssetDecompressionStreamOpen(a1);
  v8 = v5;
  if (!v5)
    return v8;
  v9 = *v5;
  v61 = 0;
  v59 = 0u;
  v60 = 0u;
  v58 = 0u;
  if (!*((_QWORD *)a2 + 2))
  {
LABEL_14:
    v21 = "truncated state";
    v22 = 316;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"aaAssetDecompressionStreamOpenWithState", v22, 132, 0, v21, v6, v7, v58);
    if (*v8)
      v8[1]();
    free(v8);
    return 0;
  }
  v10 = 0;
  v11 = &v58;
  v12 = 56;
  do
  {
    v13 = (*((uint64_t (**)(_QWORD, __int128 *, uint64_t))a2 + 2))(*(_QWORD *)a2, v11, v12);
    if (v13 < 0)
      goto LABEL_14;
    if (!v13)
      break;
    v11 = (__int128 *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }
  while (v12);
  if (v10 < 0)
    goto LABEL_14;
  v15 = v58;
  v14 = DWORD1(v58);
  *((_DWORD *)v9 + 6) = v58;
  *((_DWORD *)v9 + 7) = v14;
  v16 = *((_QWORD *)&v58 + 1);
  v17 = v59;
  *((_QWORD *)v9 + 4) = *((_QWORD *)&v58 + 1);
  *((_QWORD *)v9 + 5) = v17;
  v18 = *((_QWORD *)&v59 + 1);
  v19 = v61;
  *((_QWORD *)v9 + 6) = *((_QWORD *)&v59 + 1);
  *((_QWORD *)v9 + 13) = v19;
  if (v15 >= 3)
  {
    v21 = "invalid state";
    v22 = 330;
    goto LABEL_15;
  }
  if (v14 <= 1284)
  {
    switch(v14)
    {
      case 0:
        v20 = 0;
        goto LABEL_31;
      case 256:
        v20 = PCompressLZ4Decode;
        goto LABEL_31;
      case 774:
        v20 = PCompressLZMADecode;
        goto LABEL_31;
    }
LABEL_46:
    v21 = "invalid compression algo";
    v22 = 342;
    goto LABEL_15;
  }
  if (v14 > 2048)
  {
    if (v14 == 2049)
    {
      v20 = PCompressLZFSEDecode;
      goto LABEL_31;
    }
    if (v14 == 2304)
    {
      v20 = PCompressLZVNDecode;
      goto LABEL_31;
    }
    goto LABEL_46;
  }
  if (v14 == 1285)
  {
    v20 = PCompressZLIBDecode;
    goto LABEL_31;
  }
  if (v14 != 1794)
    goto LABEL_46;
  v20 = PCompressLZBITMAPDecode;
LABEL_31:
  *((_QWORD *)v9 + 2) = v20;
  if (v17 > v16 || v18 > v16 || (unint64_t)v60 > v17 || v17 > v18 || *((_QWORD *)&v60 + 1) > v18)
  {
    v21 = "invalid sizes";
    v22 = 352;
    goto LABEL_15;
  }
  if ((v16 & 0x8000000000000000) != 0)
    goto LABEL_122;
  v24 = (unint64_t *)((char *)v9 + 56);
  v25 = *((_QWORD *)v9 + 8);
  if (v25 < v16)
  {
    do
    {
      while (!v25)
      {
        v25 = 0x4000;
        if (v16 <= 0x4000)
        {
          v27 = (void **)((char *)v9 + 72);
          v25 = 0x4000;
          goto LABEL_49;
        }
      }
      v26 = v25 >> 1;
      if ((v25 & (v25 >> 1)) != 0)
        v26 = v25 & (v25 >> 1);
      v25 += v26;
    }
    while (v25 < v16);
    v27 = (void **)((char *)v9 + 72);
    if (v25 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_118:
      *v27 = 0;
      *v24 = 0;
      *((_QWORD *)v9 + 8) = 0;
      goto LABEL_122;
    }
LABEL_49:
    v28 = *v27;
    v29 = realloc(*v27, v25);
    if (!v29)
    {
      free(v28);
      goto LABEL_118;
    }
    *((_QWORD *)v9 + 8) = v25;
    *((_QWORD *)v9 + 9) = v29;
    v16 = *((_QWORD *)v9 + 4);
    if ((v16 & 0x8000000000000000) != 0)
      goto LABEL_122;
  }
  v31 = (unint64_t *)((char *)v9 + 88);
  v30 = *((_QWORD *)v9 + 11);
  if (v30 < v16)
  {
    do
    {
      while (!v30)
      {
        v30 = 0x4000;
        if (v16 <= 0x4000)
        {
          v30 = 0x4000;
          goto LABEL_61;
        }
      }
      v32 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0)
        v32 = v30 & (v30 >> 1);
      v30 += v32;
    }
    while (v30 < v16);
    if (v30 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_120;
    }
LABEL_61:
    v33 = (void *)*((_QWORD *)v9 + 12);
    v34 = realloc(v33, v30);
    if (v34)
    {
      *((_QWORD *)v9 + 11) = v30;
      *((_QWORD *)v9 + 12) = v34;
      goto LABEL_63;
    }
    free(v33);
LABEL_120:
    *((_QWORD *)v9 + 11) = 0;
    *((_QWORD *)v9 + 12) = 0;
LABEL_121:
    *((_QWORD *)v9 + 10) = 0;
LABEL_122:
    v21 = "truncated state";
    v22 = 359;
    goto LABEL_15;
  }
LABEL_63:
  v35 = v60;
  if ((_QWORD)v60)
  {
    v36 = 0;
    v38 = *((_QWORD *)v9 + 7);
    v37 = *((_QWORD *)v9 + 8);
    do
    {
      if (v38 == v37)
      {
        v39 = v37 + 0x40000;
        if ((uint64_t)(v37 + 0x40000) < 0)
          goto LABEL_122;
        if (v37 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v37)
            {
              v37 = 0x4000;
              v41 = 0x4000;
              if (v39 <= 0x4000)
                goto LABEL_78;
            }
            v40 = v37 >> 1;
            if ((v37 & (v37 >> 1)) != 0)
              v40 = v37 & (v37 >> 1);
            v37 += v40;
          }
          while (v37 < v39);
          v41 = v37;
          if (v37 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_125;
          }
LABEL_78:
          v42 = (void *)*((_QWORD *)v9 + 9);
          v43 = realloc(v42, v41);
          if (v43)
          {
            *((_QWORD *)v9 + 8) = v41;
            *((_QWORD *)v9 + 9) = v43;
            v38 = *((_QWORD *)v9 + 7);
            goto LABEL_80;
          }
          free(v42);
LABEL_125:
          *v24 = 0;
          *((_QWORD *)v9 + 8) = 0;
          *((_QWORD *)v9 + 9) = 0;
          goto LABEL_122;
        }
        v38 = v37;
      }
      v41 = v37;
LABEL_80:
      if (v41 - v38 >= v35)
        v44 = v35;
      else
        v44 = v41 - v38;
      v45 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 9) + v38), v44);
      if (v45 < 0)
        goto LABEL_122;
      if (!v45)
        break;
      v38 = *v24 + v45;
      if (!__CFADD__(*v24, v45))
      {
        v37 = *((_QWORD *)v9 + 8);
        if (v38 <= v37)
          continue;
      }
      goto LABEL_122;
      *v24 = v38;
      v36 += v45;
      v35 -= v45;
    }
    while (v35);
    if (v36 < 0)
      goto LABEL_122;
  }
  v46 = *((_QWORD *)&v60 + 1);
  if (*((_QWORD *)&v60 + 1))
  {
    v47 = 0;
    v49 = *((_QWORD *)v9 + 10);
    v48 = *((_QWORD *)v9 + 11);
    do
    {
      if (v49 == v48)
      {
        v50 = v48 + 0x40000;
        if ((uint64_t)(v48 + 0x40000) < 0)
          goto LABEL_122;
        if (v48 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v48)
            {
              v48 = 0x4000;
              v52 = 0x4000;
              if (v50 <= 0x4000)
                goto LABEL_104;
            }
            v51 = v48 >> 1;
            if ((v48 & (v48 >> 1)) != 0)
              v51 = v48 & (v48 >> 1);
            v48 += v51;
          }
          while (v48 < v50);
          v52 = v48;
          if (v48 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_128;
          }
LABEL_104:
          v53 = (void *)*((_QWORD *)v9 + 12);
          v54 = realloc(v53, v52);
          if (v54)
          {
            *((_QWORD *)v9 + 11) = v52;
            *((_QWORD *)v9 + 12) = v54;
            v49 = *((_QWORD *)v9 + 10);
            goto LABEL_106;
          }
          free(v53);
LABEL_128:
          *v31 = 0;
          *((_QWORD *)v9 + 12) = 0;
          goto LABEL_121;
        }
        v49 = v48;
      }
      v52 = v48;
LABEL_106:
      if (v52 - v49 >= v46)
        v55 = v46;
      else
        v55 = v52 - v49;
      v56 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 12) + v49), v55);
      if (v56 < 0)
        goto LABEL_122;
      if (!v56)
        break;
      v57 = *((_QWORD *)v9 + 10);
      v49 = v57 + v56;
      if (!__CFADD__(v57, v56))
      {
        v48 = *v31;
        if (v49 <= *v31)
          continue;
      }
      goto LABEL_122;
      *((_QWORD *)v9 + 10) = v49;
      v47 += v56;
      v46 -= v56;
    }
    while (v46);
    if (v47 < 0)
      goto LABEL_122;
  }
  if (a3)
    *a3 = *((_QWORD *)v9 + 13);
  return v8;
}

unsigned int *ThreadPipelineCreate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  unsigned int *v12;
  unsigned int *v13;
  void *v14;
  void *v15;
  size_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  size_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;

  v12 = (unsigned int *)calloc(1uLL, 0x1A8uLL);
  v13 = v12;
  if (v12)
  {
    *v12 = a1;
    v14 = calloc(a1, 0x198uLL);
    *((_QWORD *)v13 + 1) = v14;
    if (v14)
    {
      v15 = calloc(1uLL, 0x20uLL);
      *((_QWORD *)v13 + 2) = v15;
      if (v15)
      {
        v16 = *v13;
        v13[10] = 0;
        v13[11] = v16;
        v17 = calloc(v16, 4uLL);
        *((_QWORD *)v13 + 6) = v17;
        if (v17)
        {
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + 14), 0))
          {
            v21 = "SharedArrayInit: pthread_mutex_init failed\n";
            v22 = 56;
          }
          else
          {
            if (!pthread_cond_init((pthread_cond_t *)(v13 + 30), 0))
            {
              v29 = *v13 + 1;
              v13[42] = 0;
              v13[43] = v29;
              v30 = calloc(v29, 4uLL);
              *((_QWORD *)v13 + 22) = v30;
              if (v30)
              {
                if (pthread_mutex_init((pthread_mutex_t *)(v13 + 46), 0))
                {
                  v34 = "SharedArrayInit: pthread_mutex_init failed\n";
                  v35 = 56;
                }
                else
                {
                  if (!pthread_cond_init((pthread_cond_t *)(v13 + 62), 0))
                  {
                    v13[6] = -1;
                    v13[74] = 0;
                    if (pthread_mutex_init((pthread_mutex_t *)(v13 + 76), 0)
                      || pthread_cond_init((pthread_cond_t *)(v13 + 92), 0))
                    {
                      v26 = "SemInit";
                      v27 = 184;
                    }
                    else if (*v13)
                    {
                      v36 = 0;
                      v37 = 0;
                      while (1)
                      {
                        v38 = *((_QWORD *)v13 + 1);
                        v39 = v38 + v36;
                        *(_QWORD *)(v39 + 16) = v13;
                        *(_DWORD *)(v39 + 8) = v37;
                        v43 = v37;
                        *(_QWORD *)(v39 + 24) = *(_QWORD *)(a2 + 8 * v37);
                        *(_QWORD *)(v39 + 32) = a3;
                        *(_DWORD *)(v39 + 40) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 48), 0)
                          || pthread_cond_init((pthread_cond_t *)(v39 + 112), 0))
                        {
                          v26 = "SemInit";
                          v27 = 194;
                          goto LABEL_14;
                        }
                        *(_DWORD *)(v38 + v36 + 160) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 168), 0)
                          || pthread_cond_init((pthread_cond_t *)(v38 + v36 + 232), 0))
                        {
                          v26 = "SemInit";
                          v27 = 195;
                          goto LABEL_14;
                        }
                        v40 = v38 + v36;
                        *(_DWORD *)(v40 + 280) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v40 + 288), 0)
                          || pthread_cond_init((pthread_cond_t *)(v40 + 352), 0))
                        {
                          v26 = "SemInit";
                          v27 = 196;
                          goto LABEL_14;
                        }
                        if ((createThread((pthread_t *)v39, (uint64_t)threadPipelineWorkerThreadProc, v39, a6) & 0x80000000) != 0)
                          break;
                        v37 = v43 + 1;
                        v36 += 408;
                        if (v43 + 1 >= (unint64_t)*v13)
                          goto LABEL_37;
                      }
                      v26 = "Thread creation";
                      v27 = 197;
                    }
                    else
                    {
LABEL_37:
                      v41 = *((_QWORD *)v13 + 2);
                      *(_QWORD *)(v41 + 8) = v13;
                      *(_QWORD *)(v41 + 16) = a4;
                      *(_QWORD *)(v41 + 24) = a5;
                      if ((createThread((pthread_t *)v41, (uint64_t)threadPipelineConsumerThreadProc, v41, 0) & 0x80000000) == 0)
                        return v13;
                      v26 = "Thread creation";
                      v27 = 206;
                    }
                    goto LABEL_14;
                  }
                  v34 = "SharedArrayInit: pthread_cond_init failed\n";
                  v35 = 57;
                }
              }
              else
              {
                v34 = "SharedArrayInit: malloc failed\n";
                v35 = 55;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v35, 0, v34, v31, v32, v33, v42);
              v26 = "SharedArrayInit";
              v27 = 182;
LABEL_14:
              v23 = 0;
              goto LABEL_15;
            }
            v21 = "SharedArrayInit: pthread_cond_init failed\n";
            v22 = 57;
          }
        }
        else
        {
          v21 = "SharedArrayInit: malloc failed\n";
          v22 = 55;
        }
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v22, 0, v21, v18, v19, v20, v42);
        v26 = "SharedArrayInit";
        v27 = 180;
        goto LABEL_14;
      }
      v23 = *__error();
      v26 = "malloc";
      v27 = 179;
    }
    else
    {
      v23 = *__error();
      v26 = "malloc";
      v27 = 177;
    }
  }
  else
  {
    v23 = *__error();
    v26 = "malloc";
    v27 = 172;
  }
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineCreate", v27, 87, v23, v26, v24, v25, v42);
  ThreadPipelineDestroy((uint64_t)v13);
  return 0;
}

uint64_t threadPipelineWorkerThreadProc(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  pthread_cond_t *v4;
  unsigned int *v5;
  pthread_mutex_t *v6;
  pthread_cond_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  const char *v23;
  __int16 v24;
  unsigned int v25;
  const char *v27;
  __int16 v28;
  pthread_cond_t *v29;
  pthread_mutex_t *v30;
  pthread_mutex_t *v31;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (pthread_mutex_t *)(a1 + 48);
  v4 = (pthread_cond_t *)(a1 + 112);
  v5 = (unsigned int *)(v2 + 416);
  v30 = (pthread_mutex_t *)(a1 + 168);
  v31 = (pthread_mutex_t *)(v2 + 56);
  v29 = (pthread_cond_t *)(a1 + 232);
  v6 = (pthread_mutex_t *)(a1 + 288);
  v7 = (pthread_cond_t *)(a1 + 352);
  while (1)
  {
    v8 = *(_DWORD *)(a1 + 8);
    if (pthread_mutex_lock(v31))
    {
      v27 = "SharedArrayPush: pthread_mutex_lock failed\n";
      v28 = 117;
      goto LABEL_37;
    }
    v12 = *(unsigned int *)(v2 + 40);
    v13 = *(_DWORD *)(v2 + 44);
    v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(_QWORD *)(v2 + 48) + 4 * v12) = v8;
      v14 = *(_DWORD *)(v2 + 40);
    }
    *(_DWORD *)(v2 + 40) = v14 + 1;
    if (!v14)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 120)))
        break;
    }
    if (pthread_mutex_unlock(v31))
    {
      v27 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      v28 = 124;
      goto LABEL_37;
    }
    if (v12 >= v13)
    {
      v27 = "SharedArrayPush: stack is full\n";
      v28 = 125;
      goto LABEL_37;
    }
    if (pthread_mutex_lock(v3))
      goto LABEL_28;
    while (1)
    {
      v17 = *(_DWORD *)(a1 + 40);
      if (v17 > 0)
        break;
      if (pthread_cond_wait(v4, v3))
        goto LABEL_28;
    }
    *(_DWORD *)(a1 + 40) = v17 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_28:
      v23 = "SemAcquire";
      v24 = 72;
      goto LABEL_29;
    }
    if ((*(_QWORD *)(a1 + 400) & 0x8000000000000000) != 0)
      return a1;
    if (((*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", 82, 87, 0, "worker proc reported an error", v18, v19, (char)v29);
      do
        v20 = __ldxr(v5);
      while (__stxr(v20 + 1, v5));
    }
    if (pthread_mutex_lock(v30)
      || (v21 = *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 160) = v21 + 1, !v21) && pthread_cond_broadcast(v29)
      || pthread_mutex_unlock(v30))
    {
      v23 = "SemRelease";
      v24 = 85;
      goto LABEL_29;
    }
    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        v22 = *(_DWORD *)(a1 + 280);
        if (v22 > 0)
          break;
        if (pthread_cond_wait(v7, v6))
          goto LABEL_27;
      }
      *(_DWORD *)(a1 + 280) = v22 - 1;
      if (!pthread_mutex_unlock(v6))
        continue;
    }
LABEL_27:
    v23 = "SemAcquire";
    v24 = 88;
    goto LABEL_29;
  }
  v27 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  v28 = 122;
LABEL_37:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v28, 0, v27, v9, v10, v11, (char)v29);
  v23 = "SharedArrayPush";
  v24 = 69;
LABEL_29:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", v24, 87, 0, v23, v15, v16, (char)v29);
  do
    v25 = __ldxr(v5);
  while (__stxr(v25 + 1, v5));
  return a1;
}

uint64_t threadPipelineConsumerThreadProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  __int16 v11;
  pthread_cond_t *v12;
  pthread_mutex_t *v13;
  unsigned int *v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  pthread_cond_t *v18;
  uint64_t v19;
  uint64_t v20;
  pthread_mutex_t *v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned int *v29;
  unsigned int v30;
  pthread_cond_t *v32;

  v2 = *(_QWORD *)(a1 + 8);
  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)))
  {
    v12 = (pthread_cond_t *)(v2 + 248);
    v13 = (pthread_mutex_t *)(v2 + 304);
    v32 = (pthread_cond_t *)(v2 + 368);
    v14 = (unsigned int *)(v2 + 416);
    do
    {
      while (1)
      {
        v15 = *(_DWORD *)(v2 + 168);
        if (v15)
          break;
        if (pthread_cond_wait(v12, (pthread_mutex_t *)(v2 + 184)))
        {
          v6 = "SharedArrayPop: pthread_cond_wait failed\n";
          v7 = 94;
          goto LABEL_3;
        }
      }
      v16 = v15 - 1;
      *(_DWORD *)(v2 + 168) = v16;
      v17 = *(_DWORD *)(*(_QWORD *)(v2 + 176) + 4 * v16);
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 184)))
      {
        v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        v7 = 98;
        goto LABEL_3;
      }
      if (v17 == -2)
      {
        if (!pthread_mutex_lock(v13))
        {
          v23 = *(_DWORD *)(v2 + 296);
          *(_DWORD *)(v2 + 296) = v23 + 1;
          if (v23 || !pthread_cond_broadcast(v32))
            pthread_mutex_unlock(v13);
        }
      }
      else
      {
        if (v17 == -1)
          return a1;
        v18 = v12;
        v19 = *(_QWORD *)(v2 + 8);
        v20 = v19 + 408 * v17;
        v21 = (pthread_mutex_t *)(v20 + 168);
        if (pthread_mutex_lock((pthread_mutex_t *)(v20 + 168)))
          goto LABEL_31;
        v22 = (int *)(v20 + 160);
        while (*v22 <= 0)
        {
          if (pthread_cond_wait((pthread_cond_t *)(v19 + 408 * v17 + 232), v21))
            goto LABEL_31;
        }
        --*v22;
        if (pthread_mutex_unlock(v21))
        {
LABEL_31:
          v10 = "SemAcquire";
          v11 = 134;
          goto LABEL_32;
        }
        if (((*(uint64_t (**)(_QWORD, _QWORD))(a1 + 24))(*(_QWORD *)(a1 + 16), *(_QWORD *)(v19 + 408 * v17 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", 141, 87, 0, "consumer proc reported an error", v24, v25, (char)v32);
          do
            v26 = __ldxr(v14);
          while (__stxr(v26 + 1, v14));
        }
        v12 = v18;
        v13 = (pthread_mutex_t *)(v2 + 304);
        if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 408 * v17 + 288))
          || (v27 = v19 + 408 * v17, v28 = *(_DWORD *)(v27 + 280), *(_DWORD *)(v27 + 280) = v28 + 1, !v28)
          && pthread_cond_broadcast((pthread_cond_t *)(v19 + 408 * v17 + 352))
          || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 408 * v17 + 288)))
        {
          v10 = "SemRelease";
          v11 = 144;
          goto LABEL_32;
        }
      }
    }
    while (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)));
  }
  v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
  v7 = 91;
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, (char)v32);
  v10 = "SharedArrayDequeue";
  v11 = 114;
LABEL_32:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", v11, 87, 0, v10, v8, v9, (char)v32);
  v29 = (unsigned int *)(v2 + 416);
  do
    v30 = __ldxr(v29);
  while (__stxr(v30 + 1, v29));
  return a1;
}

uint64_t ThreadPipelineDestroy(uint64_t result)
{
  unsigned int *v1;
  _QWORD *v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  pthread_cond_t *v32;
  _opaque_pthread_t **v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char v41;
  char v42;

  if (result)
  {
    v1 = (unsigned int *)result;
    v2 = *(_QWORD **)(result + 8);
    if (v2)
    {
      v3 = *(unsigned int *)result;
      if (!(_DWORD)v3)
      {
        v6 = 1;
        goto LABEL_41;
      }
      v4 = 0;
      do
      {
        if (*v2)
          ++v4;
        v2 += 51;
        --v3;
      }
      while (v3);
      if (v4)
      {
        v5 = 0;
        v6 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 14)))
          {
            v10 = 91;
            v11 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v11, v7, v8, v9, v41);
            v15 = -1;
          }
          else
          {
            while (1)
            {
              v12 = v1[10];
              if (v12)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 30), (pthread_mutex_t *)(v1 + 14)))
              {
                v10 = 94;
                v11 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            v22 = v12 - 1;
            v1[10] = v22;
            v15 = *(_DWORD *)(*((_QWORD *)v1 + 6) + 4 * v22);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14)))
              goto LABEL_17;
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v23, v24, v25, v41);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 237, 87, 0, "SharedArrayPop", v13, v14, v42);
          v6 = 0;
LABEL_17:
          v16 = *((_QWORD *)v1 + 1);
          v17 = v16 + 408 * v15;
          *(_QWORD *)(v17 + 400) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 48))
            || (v20 = v16 + 408 * v15, v21 = *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40) = v21 + 1, !v21)
            && pthread_cond_broadcast((pthread_cond_t *)(v16 + 408 * v15 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 245, 87, 0, "SemRelease", v18, v19, v41);
            v6 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v17) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 246, 87, 0, "joinThread", v26, v27, v41);
            v6 = 0;
          }
          *(_QWORD *)v17 = 0;
          if (++v5 == v4)
          {
            if (!*v1)
              goto LABEL_41;
            goto LABEL_33;
          }
        }
      }
      v6 = 1;
LABEL_33:
      v28 = 0;
      v29 = 352;
      do
      {
        v30 = *((_QWORD *)v1 + 1);
        v31 = v30 + v29;
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v30 + v29 - 304)))
          pthread_cond_destroy((pthread_cond_t *)(v31 - 240));
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v31 - 184)))
          pthread_cond_destroy((pthread_cond_t *)(v30 + v29 - 120));
        v32 = (pthread_cond_t *)(v30 + v29);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v32[-2].__opaque[24]))
          pthread_cond_destroy(v32);
        ++v28;
        v29 += 408;
      }
      while (v28 < *v1);
LABEL_41:
      free(*((void **)v1 + 1));
      *((_QWORD *)v1 + 1) = 0;
    }
    else
    {
      v6 = 1;
    }
    v33 = (_opaque_pthread_t **)*((_QWORD *)v1 + 2);
    if (v33)
    {
      if (*v33)
      {
        if ((SharedArrayEnqueue_0(v1 + 42, -1) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 272, 87, 0, "SharedArrayEnqueue", v34, v35, v41);
          v6 = 0;
        }
        if ((joinThread(*v33) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 273, 87, 0, "joinThread", v36, v37, v41);
          v6 = 0;
        }
        *v33 = 0;
        v33 = (_opaque_pthread_t **)*((_QWORD *)v1 + 2);
      }
      free(v33);
      *((_QWORD *)v1 + 2) = 0;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 14)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 30)))
      free(*((void **)v1 + 6));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 46)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 62)))
      free(*((void **)v1 + 22));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 76)))
      pthread_cond_destroy((pthread_cond_t *)(v1 + 92));
    v40 = atomic_load(v1 + 104);
    if (v40 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 285, 87, 0, "Threads reported errors", v38, v39, v41);
      v6 = 0;
    }
    free(v1);
    if (v6)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  pthread_mutex_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  char v21;

  if (*(_DWORD *)(a1 + 24) != -1)
  {
    v8 = "Missing call to RunWorker before GetWorker";
    v9 = 294;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineGetWorker", v9, 87, 0, v8, a7, a8, v21);
    return 0;
  }
  v11 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    v8 = "SharedArrayPop failed";
    v9 = 298;
    goto LABEL_11;
  }
  while (1)
  {
    v17 = *(_DWORD *)(a1 + 40);
    if (v17)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v11))
    {
      v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      v16 = 94;
      goto LABEL_10;
    }
  }
  v18 = v17 - 1;
  *(_DWORD *)(a1 + 40) = v18;
  v19 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = v19;
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 408 * v19 + 24);
}

uint64_t ThreadPipelineRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  const char *v14;
  __int16 v15;
  char v16;

  v8 = *(_DWORD *)(a1 + 24);
  if (v8 == -1)
  {
    v14 = "Missing call to GetWorker before RunWorker";
    v15 = 311;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = -1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v10 + 1;
  *(_QWORD *)(v9 + 408 * v8 + 400) = v10;
  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), v8) & 0x80000000) != 0)
  {
    v14 = "SharedArrayEnqueue failed";
    v15 = 324;
    goto LABEL_10;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v9 + 408 * v8 + 48))
    || (v11 = v9 + 408 * v8, v12 = *(_DWORD *)(v11 + 40), *(_DWORD *)(v11 + 40) = v12 + 1, !v12)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 408 * v8 + 112))
    || (result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 408 * v8 + 48)), (_DWORD)result))
  {
    v14 = "SemRelease failed";
    v15 = 325;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineRunWorker", v15, 87, 0, v14, a7, a8, v16);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineFlush(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t result;
  char v8;

  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), -2) & 0x80000000) != 0)
  {
    v5 = "SharedArrayEnqueue failed";
    v6 = 333;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineFlush", v6, 87, 0, v5, v2, v3, v8);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 304)))
    goto LABEL_8;
  while (1)
  {
    v4 = *(_DWORD *)(a1 + 296);
    if (v4 > 0)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 368), (pthread_mutex_t *)(a1 + 304)))
      goto LABEL_8;
  }
  *(_DWORD *)(a1 + 296) = v4 - 1;
  result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if ((_DWORD)result)
  {
LABEL_8:
    v5 = "SemAquire failed";
    v6 = 336;
    goto LABEL_9;
  }
  return result;
}

_QWORD *AARangeInputStreamOpen(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  char v14;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = malloc(0x30uLL);
  v6 = v5;
  if (!v5 || (memset_s(v5, 0x30uLL, 0, 0x30uLL), !v4))
  {
    v10 = *__error();
    v11 = "malloc";
    v12 = 81;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c", (uint64_t)"AARangeInputStreamOpen", v12, 118, v10, v11, v8, v9, v14);
    free(v6);
    free(v4);
    return 0;
  }
  *v6 = a1;
  v7 = AAByteRangeClone(a2);
  v6[1] = v7;
  if (!v7)
  {
    v11 = "AAByteRangeClone";
    v12 = 86;
    v10 = 0;
    goto LABEL_7;
  }
  v6[4] = AAByteRangeFirst((uint64_t)v7, 0, v6 + 2, v6 + 3);
  *v4 = v6;
  v4[1] = rangeInputStreamClose;
  v4[7] = rangeInputStreamCancel;
  v4[2] = rangeInputStreamRead;
  return v4;
}

uint64_t rangeInputStreamClose(void ***a1)
{
  AAByteRangeDestroy(a1[1]);
  free(a1);
  return 0;
}

void rangeInputStreamCancel(AAByteStream *a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 5);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }
  __clrex();
}

uint64_t rangeInputStreamRead(uint64_t a1, char *buf, unint64_t a3)
{
  unsigned int *v3;
  uint64_t v5;
  unint64_t v8;
  off_t v10;
  off_t *v11;
  off_t *v12;
  off_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  ssize_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v3 = (unsigned int *)(a1 + 40);
  if (atomic_load((unsigned int *)(a1 + 40)))
    return -1;
  v5 = 0;
  if ((*(_QWORD *)(a1 + 32) & 0x8000000000000000) == 0)
  {
    v8 = a3;
    if (a3)
    {
      v5 = 0;
      v11 = (off_t *)(a1 + 16);
      v10 = *(_QWORD *)(a1 + 16);
      v12 = (off_t *)(a1 + 24);
      while (1)
      {
        v13 = *v12;
        if (v10 >= *v12)
        {
          v14 = AAByteRangeNext(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 32), (_QWORD *)(a1 + 16), (_QWORD *)(a1 + 24));
          *(_QWORD *)(a1 + 32) = v14;
          if (v14 < 0)
            return v5;
          v10 = *v11;
          v13 = *v12;
        }
        v15 = v8 >= 0x10000000 ? 0x10000000 : v8;
        v16 = v10 + v15 <= v13 ? v15 : v13 - v10;
        v17 = AAByteStreamPRead(*(AAByteStream *)a1, buf, v16, v10);
        if (v17 < 1)
          break;
        v10 = *v11 + v17;
        *v11 = v10;
        buf += v17;
        v5 += v17;
        v8 -= v17;
        if (!v8)
          return v5;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c", (uint64_t)"rangeInputStreamRead", 59, 118, 0, "Stream pread", v18, v19, v21);
      while (!__ldaxr(v3))
      {
        if (!__stlxr(1u, v3))
        {
          AAByteStreamCancel(*(AAByteStream *)a1);
          return -1;
        }
      }
      __clrex();
      return -1;
    }
  }
  return v5;
}

_DWORD *ParallelCompressionAFSCStreamOpen(int a1, unint64_t a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  const char *v11;
  __int16 v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  compression_algorithm v19;
  size_t v20;
  char v21;
  compression_algorithm v22;
  char v23;
  size_t v24;
  unint64_t v25;
  _DWORD *v26;
  _DWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char v35;

  v10 = calloc(1uLL, 0x78uLL);
  if (!v10)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", 163, 86, *v13, "malloc", v14, v15, v35);
LABEL_39:
    free(v10);
    return 0;
  }
  if (!a2)
  {
    v11 = "File too small for AFSC";
    v12 = 167;
LABEL_7:
    v16 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", v12, 86, v16, v11, v8, v9, v35);
    free(*((void **)v10 + 5));
    free(*((void **)v10 + 8));
    free(*((void **)v10 + 10));
    free(*((void **)v10 + 11));
    goto LABEL_39;
  }
  if (a2 >= 0xFA000001)
  {
    v11 = "File too large for AFSC";
    v12 = 168;
    goto LABEL_7;
  }
  if (a3)
    v17 = a3;
  else
    v17 = 4;
  v18 = v17 - 3;
  if ((v17 - 3) <= 0xA && ((0x551u >> v18) & 1) != 0)
    v17 = dword_20A40BB40[v18];
  v19 = 0;
  v20 = 0;
  v21 = -52;
  v22 = 1285;
  v23 = -1;
  switch(v17)
  {
    case 4:
      goto LABEL_19;
    case 8:
      v22 = 2304;
      v23 = 6;
      goto LABEL_19;
    case 10:
      goto LABEL_22;
    case 12:
      v22 = COMPRESSION_LZFSE;
      goto LABEL_19;
    case 14:
      v22 = COMPRESSION_LZBITMAP;
LABEL_19:
      v20 = compression_encode_scratch_buffer_size(v22);
      v24 = compression_decode_scratch_buffer_size(v22);
      if (v20 <= v24)
        v20 = v24;
      v19 = v22;
      v21 = v23;
LABEL_22:
      *v10 = a1;
      v25 = (a2 + 0xFFFF) >> 16;
      *((_QWORD *)v10 + 1) = a2;
      v10[4] = v17;
      v10[5] = v19;
      *((_BYTE *)v10 + 24) = v21;
      v10[7] = a4;
      v10[8] = v25;
      v26 = calloc(v25 + 1, 4uLL);
      *((_QWORD *)v10 + 5) = v26;
      if (!v26)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 210;
        goto LABEL_38;
      }
      v27 = v26;
      *((_OWORD *)v10 + 3) = xmmword_20A40BAF0;
      v28 = malloc(0x100000uLL);
      *((_QWORD *)v10 + 8) = v28;
      if (!v28)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 214;
        goto LABEL_38;
      }
      *((_QWORD *)v10 + 9) = 0;
      v29 = malloc(0x10000uLL);
      *((_QWORD *)v10 + 10) = v29;
      if (!v29)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 217;
        goto LABEL_38;
      }
      if (v20)
      {
        v30 = malloc(v20);
        *((_QWORD *)v10 + 11) = v30;
        if (!v30)
        {
          v16 = *__error();
          v11 = "malloc";
          v12 = 221;
          goto LABEL_38;
        }
      }
      v31 = 2;
      if (v10[4] == 4)
        v31 = 3;
      v32 = 4;
      if (v10[4] == 4)
        v32 = 264;
      v33 = ((unint64_t)v10[8] << v31) + v32;
      if (HIDWORD(v33))
      {
        v11 = "File too large for AFSC";
        v12 = 235;
        goto LABEL_7;
      }
      v10[27] = v33;
      *v27 = v33;
      v10[26] = 0;
      *((_QWORD *)v10 + 12) = 0;
      v10[28] = 0;
      break;
    default:
      v35 = v17;
      v11 = "invalid compression type %d";
      v12 = 192;
      goto LABEL_7;
  }
  return v10;
}

uint64_t ParallelCompressionAFSCStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unint64_t v10;
  size_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  compression_algorithm v23;
  BOOL v24;
  size_t v25;
  size_t v26;
  char v28;

  if (*(_QWORD *)(a1 + 96) + a3 <= *(_QWORD *)(a1 + 8))
  {
    if (!a3)
      return 0;
    v10 = 0;
    v14 = *(_QWORD *)(a1 + 56);
    while (v14 + 65537 <= *(_QWORD *)(a1 + 48) || (flushToResourceFork(a1) & 0x80000000) == 0)
    {
      v15 = *(_QWORD *)(a1 + 72);
      if (0x10000 - v15 + v10 <= a3)
        v16 = 0x10000 - v15;
      else
        v16 = a3 - v10;
      if (v16 == 0x10000)
      {
        v17 = (char *)(a2 + v10);
      }
      else
      {
        v17 = *(char **)(a1 + 80);
        memcpy(&v17[v15], (const void *)(a2 + v10), v16);
        v15 = *(_QWORD *)(a1 + 72);
      }
      v18 = *(_QWORD *)(a1 + 96) + v16;
      *(_QWORD *)(a1 + 96) = v18;
      v10 += v16;
      v19 = v15 + v16;
      *(_QWORD *)(a1 + 72) = v15 + v16;
      if ((v15 + v16) >> 16 || v18 >= *(_QWORD *)(a1 + 8))
      {
        v21 = *(_QWORD *)(a1 + 56);
        v20 = *(_QWORD *)(a1 + 64);
        v22 = (_BYTE *)(v20 + v21);
        v23 = *(_DWORD *)(a1 + 20);
        v24 = v19 < 0x78 || v23 == 0;
        if (v24
          || (v25 = compression_encode_buffer((uint8_t *)(v20 + v21), 0x10000uLL, (const uint8_t *)v17, v19, *(void **)(a1 + 88), v23)) == 0|| (*(_BYTE *)(a1 + 28) & 1) != 0 && (v26 = v25 + (v25 >> 6), v25 = v26 + 32, v26 == -32)|| v25 > *(_QWORD *)(a1 + 72) + 1)
        {
          *v22 = *(_BYTE *)(a1 + 24);
          memcpy(v22 + 1, v17, *(_QWORD *)(a1 + 72));
          v25 = *(_QWORD *)(a1 + 72) + 1;
        }
        *(_QWORD *)(a1 + 72) = 0;
        v14 = *(_QWORD *)(a1 + 56) + v25;
        *(_QWORD *)(a1 + 56) = v14;
        *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * ++*(_DWORD *)(a1 + 104)) = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 104))
                                                                                        + v25;
        if (v10 < a3)
          continue;
      }
      return v10;
    }
    v8 = "update resource fork";
    v9 = 270;
  }
  else
  {
    v8 = "too many bytes received";
    v9 = 262;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamWrite", v9, 86, 0, v8, a7, a8, v28);
  return -1;
}

uint64_t flushToResourceFork(uint64_t a1)
{
  int v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v8;

  v2 = fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), *(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 108), 0);
  if (v2 < 0)
  {
    v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"flushToResourceFork", 142, 86, *v3, "fsetxattr resource fork", v4, v5, v8);
  }
  v6 = *(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 108) = v6;
  *(_DWORD *)(a1 + 112) = 1;
  return (v2 >> 31);
}

uint64_t ParallelCompressionAFSCStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  size_t v23;
  unint64_t v24;
  off_t v25;
  u_int32_t *v26;
  u_int32_t v27;
  size_t v28;
  const uint8_t *v30;
  size_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  unint64_t v40;
  int v41;
  stat v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  memset(&v42, 0, sizeof(v42));
  if (*(_QWORD *)(a1 + 96) >= *(_QWORD *)(a1 + 8) && !*(_QWORD *)(a1 + 72))
  {
    v14 = *(_DWORD *)(a1 + 112);
    v15 = *(_DWORD *)(a1 + 20);
    if (v15)
      v15 = (*(unsigned __int8 *)(a1 + 28) >> 1) & 1;
    if (*(_DWORD *)(a1 + 32) > 1u)
      v15 = 1;
    if ((unint64_t)(*(_QWORD *)(a1 + 56) - 3569) < 0xFFFFFFFFFFFFF1FFLL)
      v15 = 1;
    if (v14 | v15)
    {
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        v9 = "update resource fork";
        v10 = 341;
        goto LABEL_5;
      }
      v14 = *(_DWORD *)(a1 + 112);
    }
    v16 = (__PAIR64__(*(_DWORD *)(a1 + 16), v14) - 1) >> 32;
    v17 = *(_QWORD *)(a1 + 8);
    v18 = *(_QWORD *)(a1 + 80);
    *(_DWORD *)v18 = 1668116582;
    *(_DWORD *)(v18 + 4) = v16;
    *(_QWORD *)(v18 + 8) = v17;
    v19 = 16;
    *(_QWORD *)(a1 + 72) = 16;
    if (!*(_DWORD *)(a1 + 112))
    {
      memcpy((void *)(*(_QWORD *)(a1 + 80) + 16), *(const void **)(a1 + 64), *(_QWORD *)(a1 + 56));
      v19 = *(_QWORD *)(a1 + 72) + *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 72) = v19;
      *(_QWORD *)(a1 + 56) = 0;
    }
    if (fsetxattr(*(_DWORD *)a1, "com.apple.decmpfs", *(const void **)(a1 + 80), v19, 0, 0) < 0)
    {
      v11 = *__error();
      v9 = "fsetxattr decmpfs";
      v10 = 363;
      goto LABEL_6;
    }
    if (!*(_DWORD *)(a1 + 112))
    {
      v21 = 0;
      goto LABEL_36;
    }
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      v20 = *(_QWORD *)(a1 + 64);
      *(_OWORD *)v20 = old_resource_fork_map;
      *(_OWORD *)(v20 + 16) = unk_20A40BB1B;
      *(_OWORD *)(v20 + 32) = xmmword_20A40BB2B;
      *(_WORD *)(v20 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 50;
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        v9 = "update resource fork";
        v10 = 373;
        goto LABEL_5;
      }
      v21 = *(_DWORD *)(a1 + 108);
      if (*(_DWORD *)(a1 + 16) == 4)
      {
        v22 = *(_DWORD *)(a1 + 32);
        if ((unint64_t)(8 * v22) + 264 > *(_QWORD *)(a1 + 48))
        {
          LOBYTE(v41) = 8 * v22 + 8;
          v9 = "File a radar to increase obuf_capacity, sz=%zu";
          v10 = 382;
          goto LABEL_5;
        }
        v43 = 0u;
        v44 = 0u;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v51 = 0u;
        v52 = 0u;
        v49 = 0u;
        v50 = 0u;
        v55 = 0u;
        v56 = 0u;
        v53 = 0u;
        v54 = 0u;
        v57 = 0u;
        v32 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)v32 = 0x10000;
        *(int8x8_t *)(v32 + 4) = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v21), (int32x2_t)0xFFFFFECEFFFFFFCELL));
        *(_DWORD *)(v32 + 12) = 838860800;
        v33 = v44;
        *(_OWORD *)(v32 + 16) = v43;
        *(_OWORD *)(v32 + 32) = v33;
        v34 = v48;
        *(_OWORD *)(v32 + 80) = v47;
        *(_OWORD *)(v32 + 96) = v34;
        v35 = v46;
        *(_OWORD *)(v32 + 48) = v45;
        *(_OWORD *)(v32 + 64) = v35;
        v36 = v52;
        *(_OWORD *)(v32 + 144) = v51;
        *(_OWORD *)(v32 + 160) = v36;
        v37 = v50;
        *(_OWORD *)(v32 + 112) = v49;
        *(_OWORD *)(v32 + 128) = v37;
        v38 = v56;
        *(_OWORD *)(v32 + 208) = v55;
        *(_OWORD *)(v32 + 224) = v38;
        v39 = v54;
        *(_OWORD *)(v32 + 176) = v53;
        *(_OWORD *)(v32 + 192) = v39;
        *(_OWORD *)(v32 + 240) = v57;
        *(_DWORD *)(v32 + 256) = bswap32(v21 - 310);
        *(_DWORD *)(v32 + 260) = v22;
        v23 = 264;
        *(_QWORD *)(a1 + 56) = 264;
        if (*(_DWORD *)(a1 + 32))
        {
          v40 = 0;
          v23 = 264;
          do
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 64) + v23) = (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40) - 260) | ((unint64_t)(*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40 + 4) - *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40)) << 32);
            ++v40;
            v23 = *(_QWORD *)(a1 + 56) + 8;
            *(_QWORD *)(a1 + 56) = v23;
          }
          while (v40 < *(unsigned int *)(a1 + 32));
        }
        goto LABEL_35;
      }
    }
    else
    {
      v21 = *(_DWORD *)(a1 + 108);
    }
    v23 = (4 * *(_DWORD *)(a1 + 32) + 4);
    if (*(_QWORD *)(a1 + 48) < v23)
    {
      v41 = 4 * *(_DWORD *)(a1 + 32) + 4;
      v9 = "File a radar to increase obuf_capacity, sz=%zu";
      v10 = 408;
      goto LABEL_5;
    }
    memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 40), (4 * *(_DWORD *)(a1 + 32) + 4));
    *(_QWORD *)(a1 + 56) = v23;
LABEL_35:
    if (fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), v23, 0, 0) < 0)
    {
      v11 = *__error();
      v9 = "fsetxattr resource fork header";
      v10 = 418;
      goto LABEL_6;
    }
LABEL_36:
    if (ftruncate(*(_DWORD *)a1, 0))
    {
      v11 = *__error();
      v9 = "ftruncate";
      v10 = 422;
      goto LABEL_6;
    }
    if ((*(_BYTE *)(a1 + 28) & 4) != 0 || !*(_DWORD *)(a1 + 112) || 93 * *(_QWORD *)(a1 + 8) / 0x64uLL >= v21)
    {
      if (fstat(*(_DWORD *)a1, &v42))
      {
        v11 = *__error();
        v9 = "fstat";
        v10 = 465;
        goto LABEL_6;
      }
      if (fchflags(*(_DWORD *)a1, v42.st_flags | 0x20) < 0)
      {
        v11 = *__error();
        v9 = "fchflags UF_COMPRESSED";
        v10 = 466;
        goto LABEL_6;
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 32))
      {
        v24 = 0;
        v25 = 0;
        while (1)
        {
          v26 = (u_int32_t *)(*(_QWORD *)(a1 + 40) + 4 * v24);
          v27 = v26[1];
          v28 = v27 - *v26;
          if (v27 == *v26 || v28 >= 0x10002)
          {
            v9 = "Invalid chunk size";
            v10 = 437;
            goto LABEL_5;
          }
          if (fgetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(void **)(a1 + 64), v27 - *v26, *v26, 32) != v28)
          {
            v9 = "reading chunk";
            v10 = 440;
            goto LABEL_5;
          }
          v30 = *(const uint8_t **)(a1 + 64);
          if (*v30 == *(unsigned __int8 *)(a1 + 24))
          {
            v31 = (v28 - 1);
            memcpy(*(void **)(a1 + 80), v30 + 1, v31);
          }
          else
          {
            v31 = compression_decode_buffer(*(uint8_t **)(a1 + 80), 0x10000uLL, v30, v28, *(void **)(a1 + 88), (compression_algorithm)*(_DWORD *)(a1 + 20));
          }
          if (v31 != 0x10000)
          {
            if (!v31)
            {
              v9 = "Decompression";
              v10 = 451;
              goto LABEL_5;
            }
            if (v31 + v25 != *(_QWORD *)(a1 + 8))
              break;
          }
          if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), v31, v25) != v31)
          {
            v9 = "writing chunk";
            v10 = 454;
            goto LABEL_5;
          }
          ++v24;
          v25 += v31;
          if (v24 >= *(unsigned int *)(a1 + 32))
            goto LABEL_56;
        }
        v9 = "Invalid uncompressed chunk size";
        v10 = 452;
        goto LABEL_5;
      }
LABEL_56:
      if (fremovexattr(*(_DWORD *)a1, "com.apple.ResourceFork", 32) < 0)
      {
        v11 = *__error();
        v9 = "Removing xattr";
        v10 = 459;
        goto LABEL_6;
      }
      if (fremovexattr(*(_DWORD *)a1, "com.apple.decmpfs", 32) < 0)
      {
        v11 = *__error();
        v9 = "Removing xattr";
        v10 = 460;
        goto LABEL_6;
      }
    }
    v12 = 0;
    goto LABEL_7;
  }
  v9 = "not enough bytes received";
  v10 = 325;
LABEL_5:
  v11 = 0;
LABEL_6:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamClose", v10, 86, v11, v9, a7, a8, v41);
  v12 = 0xFFFFFFFFLL;
LABEL_7:
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free((void *)a1);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadataFD(int a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  off_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  off_t v20;
  unint64_t v21;
  int v23;
  stat v24;

  memset(&v24, 0, sizeof(v24));
  if (fstat(a1, &v24))
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", 488, 86, *v8, "fstat", v9, v10, v23);
    v11 = 0;
LABEL_22:
    v12 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  if ((v24.st_flags & 0x20) != 0)
  {
    v11 = (off_t *)malloc(0x1000uLL);
    if (v11)
    {
      v13 = fgetxattr(a1, "com.apple.decmpfs", v11, 0x1000uLL, 0, 32);
      if ((v13 & 0x8000000000000000) != 0)
      {
        v16 = "Missing decmpfs xattr";
        v17 = 504;
      }
      else if (v13 > 0xF)
      {
        if (*(_DWORD *)v11 == 1668116582)
        {
          v19 = *((_DWORD *)v11 + 1);
          if (v19 > 0xE)
            goto LABEL_27;
          v20 = v11[1];
          if (((1 << v19) & 0x2A88) != 0)
          {
            v12 = 0;
            *a2 = v20;
            *a3 = v19;
            goto LABEL_5;
          }
          if (((1 << v19) & 0x5510) != 0)
          {
            *a2 = v20;
            *a3 = v19;
            v21 = fgetxattr(a1, "com.apple.ResourceFork", 0, 0, 0, 32);
            if ((v21 & 0x8000000000000000) != 0)
            {
              v16 = "Missing resource fork xattr";
              v17 = 532;
            }
            else
            {
              if (!HIDWORD(v21))
              {
                v12 = 0;
                *a4 = v21;
                goto LABEL_23;
              }
              v16 = "Invalid resource fork xattr";
              v17 = 533;
            }
          }
          else
          {
LABEL_27:
            v23 = *((_DWORD *)v11 + 1);
            v16 = "Invalid compression type %u in decmpfs xattr";
            v17 = 524;
          }
        }
        else
        {
          v16 = "Invalid decmpfs xattr";
          v17 = 507;
        }
      }
      else
      {
        v16 = "Truncated decmpfs xattr";
        v17 = 505;
      }
      v18 = 0;
    }
    else
    {
      v18 = *__error();
      v16 = "malloc";
      v17 = 501;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", v17, 86, v18, v16, v14, v15, v23);
    goto LABEL_22;
  }
  v11 = 0;
  v12 = 0;
  *a2 = v24.st_size;
  *a3 = -1;
LABEL_5:
  *a4 = 0;
LABEL_23:
  free(v11);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadata(const char *a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  char v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (char)a1;
  v8 = open(a1, 0);
  if (v8 < 0)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 550, 86, *v13, "open %s", v14, v15, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = v8;
    if ((ParallelCompressionAFSCGetMetadataFD(v8, a2, a3, a4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 553, 86, 0, "retrieving AFSC metadata: %s", v10, v11, v7);
      v12 = 0xFFFFFFFFLL;
    }
    else
    {
      v12 = 0;
    }
    close(v9);
  }
  return v12;
}

uint64_t ParallelCompressionAFSCFixupMetadata(const std::__fs::filesystem::path *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int *v18;
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  char v24;
  int v25;
  int8x8_t v26;
  int8x8_t v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  ssize_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  u_int32_t v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unint64_t v67;
  unsigned int v68;
  int v69;
  u_int32_t v70;
  unsigned int v71;
  size_t v72;
  int v73;
  int v74;
  _DWORD *v75;
  int *v76;
  int *v77;
  BOOL v78;
  int v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  _DWORD *v87;
  uint64_t v88;
  size_t v89;
  unint64_t *v90;
  int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  std::error_code *v95;
  int v96;
  int v97;
  uint64_t v98;
  u_int32_t v99;
  size_t v100;
  unsigned int v101;
  size_t v103;
  size_t v104;
  u_int32_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  int *v114;
  int v115;
  unint64_t *v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  __int16 v125;
  int v126;
  uint64_t v127;
  uint64_t v128;
  int *v129;
  uint64_t v130;
  uint64_t v131;
  int *v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  __int16 v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  const char *v155;
  __int16 v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  const char *v163;
  __int16 v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  const char *v168;
  __int16 v169;
  char v170;
  uint64_t v171;
  size_t size;
  unint64_t v173;
  uint64_t v174;
  uint64_t v175;
  u_int32_t position;
  unsigned int v177;
  int v178;
  int v179;
  unint64_t *v180;
  int v181;
  _DWORD *v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  int v186;
  char v187;
  int *v188;
  int *v189;
  int fd;
  _QWORD value[2];
  stat v192;
  unint64_t v193;
  u_int32_t v194;
  unsigned int v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  int v211;
  std::__fs::filesystem::path __from;
  uint64_t v213;

  v213 = *MEMORY[0x24BDAC8D0];
  v195 = -1;
  v194 = 0;
  v193 = 0;
  memset(&v192, 0, sizeof(v192));
  v211 = 0;
  v209 = 0u;
  v210 = 0u;
  v207 = 0u;
  v208 = 0u;
  v205 = 0u;
  v206 = 0u;
  v203 = 0u;
  v204 = 0u;
  v201 = 0u;
  v202 = 0u;
  v199 = 0u;
  v200 = 0u;
  v197 = 0u;
  v198 = 0u;
  v196 = 0u;
  value[0] = 0;
  value[1] = 0;
  if ((unint64_t)__strlcpy_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 581, 86, 0, "Path too long: %s", v6, v7, (char)a1);
LABEL_5:
    v17 = 0;
    v18 = 0;
LABEL_134:
    v45 = 0;
    v75 = 0;
    v77 = 0;
    v35 = -1;
LABEL_135:
    v37 = -1;
    goto LABEL_136;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 582, 86, 0, "Path too long: %s", v15, v16, (char)a1);
    goto LABEL_5;
  }
  v18 = (int *)malloc(0x100000uLL);
  if (!v18)
  {
    v23 = *__error();
    v21 = "malloc";
    v22 = 586;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v22, 86, v23, v21, v13, v14, v170);
    v17 = 0;
    goto LABEL_134;
  }
  if (a2)
    v19 = a2;
  else
    v19 = 4;
  if ((v19 + 1) > 0xF)
    goto LABEL_131;
  v20 = 1 << (v19 + 1);
  if ((v20 & 0x5511) != 0)
  {
    if (a3)
    {
      v170 = a3;
      v21 = "Invalid resource fork size request: %u";
      v22 = 605;
LABEL_132:
      v23 = 0;
      goto LABEL_133;
    }
    goto LABEL_16;
  }
  if ((v20 & 0xAA20) == 0)
  {
LABEL_131:
    v170 = v19;
    v21 = "Invalid compression type request %d";
    v22 = 608;
    goto LABEL_132;
  }
LABEL_16:
  if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
  {
LABEL_130:
    v170 = (char)a1;
    v21 = "obtain AFSC data: %s";
    v22 = 615;
    goto LABEL_132;
  }
  v24 = 0;
  v181 = 0;
  v25 = 0;
  v182 = v18 + 3;
  v180 = (unint64_t *)(v18 + 66);
  v26 = (int8x8_t)vadd_s32(vdup_n_s32(a3), (int32x2_t)0xFFFFFECEFFFFFFCELL);
  v27 = vrev32_s8(v26);
  position = v26.i32[0];
  v177 = bswap32(a3 - 310);
  v28 = (int)v19 - 4;
  v185 = (0x551u >> (v19 - 4)) & 1;
  while (1)
  {
    v29 = v193;
    if (v193 >= 0xFA000001)
    {
      v21 = "Invalid AFSC data";
      v22 = 616;
      goto LABEL_132;
    }
    v187 = v24;
    if (v195 == (_DWORD)v19)
    {
      if (!a3 || v194 == a3)
        goto LABEL_152;
      if ((v19 & 0x80000000) == 0)
        goto LABEL_55;
    }
    else if ((v19 & 0x80000000) == 0)
    {
      v174 = v28;
      v30 = 4;
      if (v19 > 0xE)
      {
        v33 = v19;
      }
      else
      {
        v31 = 1 << v19;
        if (((1 << v19) & 0x5510) != 0)
          v32 = 6;
        else
          v32 = 4;
        if ((v31 & 0x2A88) != 0)
          v30 = 4;
        else
          v30 = v32;
        if ((v31 & 0x2A88) != 0)
          v33 = v19 + 1;
        else
          v33 = v19;
      }
      v34 = open((const char *)a1, 0);
      v35 = v34;
      if ((v34 & 0x80000000) == 0)
      {
        if (!fstat(v34, &v192))
        {
          v178 = v25;
          v36 = mkstemp((char *)&__from);
          v37 = v36;
          if (v36 < 0)
          {
            v157 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 664, 86, *v157, "mkstemp", v158, v159, v170);
            v17 = 0;
            v45 = 0;
          }
          else
          {
            v45 = ParallelCompressionAFSCStreamOpen(v36, v29, v33, v30);
            if (v45)
            {
              v183 = v19;
              fd = v35;
              v188 = v18;
              v46 = 0;
              v47 = 0;
              v48 = 0x100000;
              v49 = 0x100000;
              while (1)
              {
                v50 = v29 >= v49 ? v49 : v29;
                if (v49 - 0x100000 >= v29)
                  break;
                v51 = v50 + v46;
                v52 = read(fd, v188, v50 + v46);
                if (v52 < 0)
                {
                  v126 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 675, 86, v126, "read: %s", v127, v128, (char)a1);
                  goto LABEL_149;
                }
                if (v52 < v51)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 676, 86, 0, "truncated read: %s", v56, v57, (char)a1);
LABEL_149:
                  v17 = 0;
LABEL_150:
                  v75 = 0;
                  v77 = 0;
                  v18 = v188;
                  goto LABEL_151;
                }
                v47 += 0x100000;
                v58 = ParallelCompressionAFSCStreamWrite((uint64_t)v45, (uint64_t)v188, v51, v53, v54, v55, v56, v57);
                v49 += 0x100000;
                v46 -= 0x100000;
                if (v29 >= v47)
                  v59 = v47;
                else
                  v59 = v29;
                v48 -= 0x100000;
                if (v58 < (uint64_t)(v59 + v48))
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 678, 86, 0, "write to stream failed: %s", v43, v44, (char)a1);
                  goto LABEL_149;
                }
              }
              if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v38, v39, v40, v41, v42, v43, v44) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 683, 86, 0, "Stream close error", v93, v94, v170);
                v17 = 0;
                v45 = 0;
                goto LABEL_150;
              }
              fchown(v37, v192.st_uid, v192.st_gid);
              fchmod(v37, v192.st_mode & 0xFFF);
              close(fd);
              close(v37);
              rename(&__from, a1, v95);
              v97 = v96;
              unlink((const char *)&__from);
              v18 = v188;
              v19 = v183;
              v28 = v174;
              v25 = v178;
              if ((v97 & 0x80000000) == 0)
                goto LABEL_55;
              v23 = *__error();
              v170 = (char)a1;
              v21 = "rename: %s";
              v22 = 694;
              goto LABEL_133;
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 667, 86, 0, "creating compression stream %s", v43, v44, (char)a1);
            v17 = 0;
          }
          v75 = 0;
          v77 = 0;
          goto LABEL_136;
        }
        v141 = *__error();
        v170 = (char)a1;
        v144 = "stat: %s";
        v145 = 661;
        goto LABEL_170;
      }
      v146 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 660, 86, v146, "open: %s", v147, v148, (char)a1);
LABEL_171:
      v17 = 0;
      v45 = 0;
      v75 = 0;
      v77 = 0;
      goto LABEL_135;
    }
    v60 = open((const char *)a1, 9);
    v35 = v60;
    if (v60 < 0)
    {
      v135 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 629, 86, v135, "open %s", v136, v137, (char)a1);
      goto LABEL_171;
    }
    if (write(v60, 0, 0) < 0)
    {
      v141 = *__error();
      v144 = "write";
      v145 = 630;
LABEL_170:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v145, 86, v141, v144, v142, v143, v170);
      goto LABEL_171;
    }
    if (close(v35) < 0)
    {
      v23 = *__error();
      v21 = "close";
      v22 = 631;
      goto LABEL_133;
    }
    v195 = -1;
    v194 = 0;
LABEL_55:
    if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
    {
      v170 = (char)a1;
      v21 = "obtain AFSC data: %s";
      v22 = 699;
      goto LABEL_132;
    }
    if (v195 != (_DWORD)v19)
    {
      v21 = "Couldn't convert to requested compression type";
      v22 = 700;
      goto LABEL_132;
    }
    if (!a3)
      goto LABEL_152;
    v61 = v194;
    v62 = a3 - v194;
    if (a3 == v194)
      goto LABEL_152;
    if (a3 >= v194)
      break;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 711, 86, "Can't shrink resource fork: %s (current %u, target %u)", v12, v13, v14, (char)a1);
LABEL_61:
    if ((v187 & 1) != 0)
    {
      v21 = "Second pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)";
      v170 = (char)a1;
      v22 = 852;
      goto LABEL_132;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 859, 86, "First pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)", v12, v13, v14, (char)a1);
    v63 = open((const char *)a1, 9);
    v35 = v63;
    if (v63 < 0)
    {
      v138 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 864, 86, v138, "open %s", v139, v140, (char)a1);
      goto LABEL_171;
    }
    if (write(v63, 0, 0) < 0)
    {
      v141 = *__error();
      v144 = "write";
      v145 = 865;
      goto LABEL_170;
    }
    if (close(v35) < 0)
    {
      v23 = *__error();
      v21 = "close";
      v22 = 866;
      goto LABEL_133;
    }
    v195 = -1;
    v194 = 0;
    v64 = ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194);
    v24 = 1;
    if (v64 < 0)
      goto LABEL_130;
  }
  if (v28 > 0xA || !v185)
  {
    v170 = v19;
    v21 = "Invalid compression type %u";
    v22 = 722;
    goto LABEL_132;
  }
  v184 = v19;
  v186 = dword_20A40BB6C[v28];
  v65 = open((const char *)a1, 0);
  v66 = v65;
  if (v65 < 0)
  {
    v149 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 727, 86, v149, "open: %s", v150, v151, (char)a1);
LABEL_176:
    v17 = 0;
    v45 = 0;
    v75 = 0;
    v77 = 0;
    v37 = -1;
    v35 = v66;
    goto LABEL_136;
  }
  if (fstat(v65, &v192))
  {
    v152 = *__error();
    v155 = "fstat";
    v156 = 728;
LABEL_175:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v156, 86, v152, v155, v153, v154, v170);
    goto LABEL_176;
  }
  if (fgetxattr(v66, "com.apple.decmpfs", value, 0x10uLL, 0, 32) != 16)
  {
    v152 = *__error();
    v155 = "Reading decmpfs";
    v156 = 729;
    goto LABEL_175;
  }
  fd = v66;
  if (fchflags(v66, v192.st_flags & 0xFFFFFFDF) < 0)
  {
    v121 = *__error();
    v124 = "fchflags UF_COMPRESSED";
    v125 = 730;
LABEL_145:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v125, 86, v121, v124, v122, v123, v170);
    v17 = 0;
    v45 = 0;
    v75 = 0;
    v77 = 0;
    goto LABEL_146;
  }
  v179 = v25;
  v67 = v29 + 0xFFFF;
  v173 = (v29 + 0xFFFF) >> 16;
  v175 = v28;
  v68 = v61 + 0x100000;
  v69 = -v61;
  v70 = v61;
  while (1)
  {
    v71 = a3 >= v68 ? v68 : a3;
    if (v70 >= a3)
      break;
    v72 = v71 + v69;
    if (v70 == v61)
      __memset_chk();
    v73 = fsetxattr(fd, "com.apple.ResourceFork", v18, v72, v70, 0);
    v68 += 0x100000;
    v69 -= 0x100000;
    v70 += 0x100000;
    if (v73)
    {
      v121 = *__error();
      v124 = "Expanding resource fork";
      v125 = 738;
      goto LABEL_145;
    }
  }
  v74 = v173;
  v75 = malloc((4 * v173 + 4));
  size = (4 * v173 + 4);
  v76 = (int *)malloc(size);
  v77 = v76;
  if (v75)
    v78 = v76 == 0;
  else
    v78 = 1;
  if (v78)
  {
    v160 = *__error();
    v163 = "malloc";
    v164 = 744;
    goto LABEL_183;
  }
  v171 = (v67 >> 16);
  if ((_DWORD)v184 != 4)
  {
    v35 = fd;
    v89 = (4 * v173 + 4);
    if (fgetxattr(fd, "com.apple.ResourceFork", v75, size, 0, 32) == size)
    {
LABEL_98:
      v189 = v18;
      memcpy(v77, v75, v89);
      v77[v173] = v75[v173] + v62;
      while (v62 && v74)
      {
        v98 = (v74 - 1);
        v99 = v75[v98];
        v100 = v75[v74] - v99;
        if (fgetxattr(v35, "com.apple.ResourceFork", v189, v100, v99, 32) != v100)
        {
          v129 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 777, 86, *v129, "Reading chunk", v130, v131, v170);
          v17 = 0;
          v45 = 0;
          v37 = -1;
          v18 = v189;
          goto LABEL_136;
        }
        v101 = 0x10000 - v100;
        if (v186 == *(unsigned __int8 *)v189 || v100 > 0x10000)
          v101 = 0;
        if (v62 >= v101)
          v103 = v101;
        else
          v103 = v62;
        if ((_DWORD)v103)
          bzero((char *)v189 + v100, v103);
        v104 = (v103 + v100);
        v105 = v77[v74] - v104;
        v77[v98] = v105;
        v62 -= v103;
        v35 = fd;
        --v74;
        if (fsetxattr(fd, "com.apple.ResourceFork", v189, v104, v105, 0))
        {
          v132 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 791, 86, *v132, "Writing chunk", v133, v134, v170);
          v17 = 0;
          v45 = 0;
          v37 = -1;
          v18 = v189;
          goto LABEL_136;
        }
      }
      v19 = v184;
      if ((_DWORD)v184 == 4)
      {
        v18 = v189;
        v25 = v179;
        *v189 = v179;
        *(int8x8_t *)(v189 + 1) = v27;
        v106 = v209;
        *((_OWORD *)v182 + 12) = v208;
        *((_OWORD *)v182 + 13) = v106;
        *((_OWORD *)v182 + 14) = v210;
        v182[60] = v211;
        v107 = v205;
        *((_OWORD *)v182 + 8) = v204;
        *((_OWORD *)v182 + 9) = v107;
        v108 = v207;
        *((_OWORD *)v182 + 10) = v206;
        *((_OWORD *)v182 + 11) = v108;
        v109 = v201;
        *((_OWORD *)v182 + 4) = v200;
        *((_OWORD *)v182 + 5) = v109;
        v110 = v203;
        *((_OWORD *)v182 + 6) = v202;
        *((_OWORD *)v182 + 7) = v110;
        v111 = v197;
        *(_OWORD *)v182 = v196;
        *((_OWORD *)v182 + 1) = v111;
        v112 = v199;
        *((_OWORD *)v182 + 2) = v198;
        *((_OWORD *)v182 + 3) = v112;
        v189[64] = v177;
        v189[65] = v181;
        v113 = v171;
        if ((_DWORD)v173)
        {
          v114 = v77 + 1;
          v115 = *v77;
          v116 = v180;
          do
          {
            v117 = *v114++;
            *v116++ = (v115 - 260) | ((unint64_t)(v117 - v115) << 32);
            v115 = v117;
            --v113;
          }
          while (v113);
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", v189, (8 * v173) + 264, 0, 0))
        {
          v165 = *__error();
          v168 = "Writing resource fork header";
          v169 = 817;
          goto LABEL_189;
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", &old_resource_fork_map, 0x32uLL, position, 0))
        {
          v165 = *__error();
          v168 = "Writing resource map";
          v169 = 820;
          goto LABEL_189;
        }
      }
      else
      {
        v18 = v189;
        v25 = v179;
        if (fsetxattr(v35, "com.apple.ResourceFork", v77, size, 0, 0))
        {
          v165 = *__error();
          v168 = "Writing chunk sizes";
          v169 = 827;
          goto LABEL_189;
        }
      }
      if (fsetxattr(v35, "com.apple.decmpfs", value, 0x10uLL, 0, 0))
      {
        v165 = *__error();
        v168 = "Writing decmpfs";
        v169 = 831;
      }
      else
      {
        if ((fchflags(v35, v192.st_flags | 0x20) & 0x80000000) == 0)
        {
          close(v35);
          free(v75);
          free(v77);
          if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) == 0)
          {
            if (v195 != (_DWORD)v184)
            {
              v28 = v175;
              goto LABEL_61;
            }
            v28 = v175;
            if (v194 != a3)
              goto LABEL_61;
LABEL_152:
            if ((v187 & 1) != 0)
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 876, 86, "Second pass fixup succeeded: %s", v12, v13, v14, (char)a1);
            v45 = 0;
            v75 = 0;
            v77 = 0;
            v35 = -1;
            v17 = 1;
            goto LABEL_135;
          }
          v170 = (char)a1;
          v21 = "obtain AFSC data: %s";
          v22 = 840;
          goto LABEL_132;
        }
        v165 = *__error();
        v168 = "fchflags UF_COMPRESSED";
        v169 = 832;
      }
    }
    else
    {
      v165 = *__error();
      v168 = "Reading chunk sizes";
      v169 = 763;
    }
LABEL_189:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v169, 86, v165, v168, v166, v167, v170);
    v17 = 0;
    v45 = 0;
    goto LABEL_135;
  }
  if (fgetxattr(fd, "com.apple.ResourceFork", v18, (8 * v173) + 264, 0, 32) == (8 * v173)
                                                                                              + 264)
  {
    v79 = *v18;
    v80 = *((_OWORD *)v182 + 13);
    v208 = *((_OWORD *)v182 + 12);
    v209 = v80;
    v210 = *((_OWORD *)v182 + 14);
    v211 = v182[60];
    v81 = *((_OWORD *)v182 + 9);
    v204 = *((_OWORD *)v182 + 8);
    v205 = v81;
    v82 = *((_OWORD *)v182 + 11);
    v206 = *((_OWORD *)v182 + 10);
    v207 = v82;
    v83 = *((_OWORD *)v182 + 5);
    v200 = *((_OWORD *)v182 + 4);
    v201 = v83;
    v84 = *((_OWORD *)v182 + 7);
    v202 = *((_OWORD *)v182 + 6);
    v203 = v84;
    v85 = *((_OWORD *)v182 + 1);
    v196 = *(_OWORD *)v182;
    v197 = v85;
    v86 = *((_OWORD *)v182 + 3);
    v198 = *((_OWORD *)v182 + 2);
    v199 = v86;
    v181 = v18[65];
    v35 = fd;
    v179 = v79;
    if ((_DWORD)v173)
    {
      v87 = v75 + 1;
      v88 = (v67 >> 16);
      v89 = (4 * v173 + 4);
      v90 = v180;
      do
      {
        v91 = *(_DWORD *)v90;
        v92 = *((_DWORD *)v90++ + 1);
        v91 += 260;
        *(v87 - 1) = v91;
        *v87++ = v91 + v92;
        --v88;
      }
      while (v88);
    }
    else
    {
      v89 = 4;
    }
    goto LABEL_98;
  }
  v160 = *__error();
  v163 = "Reading chunk sizes";
  v164 = 749;
LABEL_183:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v164, 86, v160, v163, v161, v162, v170);
  v17 = 0;
  v45 = 0;
LABEL_146:
  v37 = -1;
LABEL_151:
  v35 = fd;
LABEL_136:
  if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v8, v9, v10, v11, v12, v13, v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 877, 86, 0, "Stream close error", v118, v119, v170);
    v17 = 0;
  }
  if ((v35 & 0x80000000) == 0)
    close(v35);
  if ((v37 & 0x80000000) == 0)
  {
    close(v37);
    unlink((const char *)&__from);
  }
  free(v18);
  free(v75);
  free(v77);
  if (v17)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ParallelCompressionAFSCCompress(const char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  ssize_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  void *v17;
  int v18;
  int v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  ssize_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  const char *v41;
  __int16 v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  __int16 v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  char v58;
  int v59;
  unsigned int v60;
  unint64_t v61;

  v61 = 0;
  v60 = -1;
  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v61, &v60, &v59) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 907, 86, 0, "looking up AFSC data: %s", v4, v5, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v6 = v61;
  if (!v61)
    return 0;
  if (v60 == -1)
  {
    if (!a2)
      return 0;
    v17 = malloc(0x10000uLL);
    if (v17)
    {
      v18 = open(a1, 2);
      if ((v18 & 0x80000000) == 0)
      {
        v19 = v18;
        v20 = ParallelCompressionAFSCStreamOpen(v18, v6, 0, 0);
        if (v20)
        {
          v28 = (uint64_t)v20;
          v29 = 0;
          v30 = 0;
          v31 = 0x10000;
          v32 = 0x10000;
          while (1)
          {
            if (v6 >= v32)
              v33 = v32;
            else
              v33 = v6;
            if (v32 - 0x10000 >= v6)
            {
              v51 = 1;
              goto LABEL_43;
            }
            v34 = v33 + v29;
            v35 = read(v19, v17, v33 + v29);
            if (v35 < 0)
            {
              v52 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 950, 86, v52, "read: %s", v53, v54, (char)a1);
              goto LABEL_42;
            }
            if (v34 != v35)
            {
              v58 = (char)a1;
              v41 = "truncated read: %s";
              v42 = 951;
              goto LABEL_41;
            }
            v39 = ParallelCompressionAFSCStreamWrite(v28, (uint64_t)v17, v34, v36, v37, v38, v26, v27);
            if (v39 < 0)
              break;
            v30 += 0x10000;
            v32 += 0x10000;
            v29 -= 0x10000;
            if (v6 >= v30)
              v40 = v30;
            else
              v40 = v6;
            v31 -= 0x10000;
            if (v40 + v31 != v39)
            {
              v58 = (char)a1;
              v41 = "truncated write: %s";
              v42 = 954;
              goto LABEL_41;
            }
          }
          v58 = (char)a1;
          v41 = "Stream write failed: %s";
          v42 = 953;
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v42, 86, 0, v41, v26, v27, v58);
LABEL_42:
          v51 = 0;
LABEL_43:
          if ((ParallelCompressionAFSCStreamClose(v28, v21, v22, v23, v24, v25, v26, v27) & 0x80000000) == 0)
            goto LABEL_46;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 956, 86, 0, "AFSC compression failed: %s", v55, v56, (char)a1);
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 942, 86, 0, "creating AFSC stream: %s", v26, v27, (char)a1);
        }
        v51 = 0;
LABEL_46:
        close(v19);
LABEL_47:
        free(v17);
        if (v51)
          return 0;
        else
          return 0xFFFFFFFFLL;
      }
      v46 = *__error();
      v57 = (char)a1;
      v49 = "open: %s";
      v50 = 940;
    }
    else
    {
      v46 = *__error();
      v49 = "malloc";
      v50 = 938;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v50, 86, v46, v49, v47, v48, v57);
    v51 = 0;
    goto LABEL_47;
  }
  if (a2)
    return 0;
  v7 = open(a1, 9);
  if (v7 < 0)
  {
    v43 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 921, 86, v43, "open: %s", v44, v45, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v8 = v7;
  v9 = write(v7, 0, 0);
  if (v9 < 0)
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 922, 86, *v10, "write: %s", v11, v12, (char)a1);
  }
  if (close(v8) < 0)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 923, 86, *v13, "close: %s", v14, v15, (char)a1);
  }
  return v9 >> 63;
}

_QWORD *AAChunkInputStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  size_t v18;
  _QWORD *v19;
  void *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  char v27;

  DefaultNThreads = a5;
  if (!a5)
    DefaultNThreads = getDefaultNThreads();
  v10 = calloc(1uLL, 0x68uLL);
  v11 = malloc(0x90uLL);
  v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x90uLL, 0, 0x90uLL), !v10))
  {
    v21 = *__error();
    v24 = "malloc";
    v25 = 277;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"AAChunkInputStreamOpen", v25, 66, v21, v24, v22, v23, v27);
    free(v10);
    streamClose(v12);
    return 0;
  }
  *(_QWORD *)v12 = a1;
  *(_QWORD *)(v12 + 8) = a2;
  *(_QWORD *)(v12 + 16) = a4;
  v13 = DefaultNThreads;
  if (DefaultNThreads * a2 > a3)
    v13 = a3 / a2;
  if (v13 <= 1)
    v14 = 1;
  else
    v14 = v13;
  *(_QWORD *)(v12 + 128) = v14;
  if (!is_mul_ok(v14, 0x30uLL) || 48 * v14 >= 0x2000000001)
  {
    *__error() = 12;
    *(_QWORD *)(v12 + 136) = 0;
    goto LABEL_22;
  }
  v15 = (char *)calloc(v14, 0x30uLL);
  *(_QWORD *)(v12 + 136) = v15;
  if (!v15)
  {
LABEL_22:
    v21 = *__error();
    v24 = "malloc";
    v25 = 290;
    goto LABEL_23;
  }
  v16 = *(_QWORD *)(v12 + 128);
  if (v16)
  {
    v17 = v15;
    v18 = *(_QWORD *)(v12 + 8);
    v19 = v15 + 16;
    while (1)
    {
      *(v19 - 2) = -1;
      if (v18 >= 0x2000000001)
        break;
      v20 = malloc(v18);
      *v19 = v20;
      if (!v20)
        goto LABEL_26;
      v19 += 6;
      if (!--v16)
        goto LABEL_18;
    }
    *__error() = 12;
    *((_QWORD *)v17 + 2) = 0;
LABEL_26:
    v21 = *__error();
    v24 = "malloc";
    v25 = 296;
    goto LABEL_23;
  }
LABEL_18:
  if (pthread_mutex_init((pthread_mutex_t *)(v12 + 32), 0) < 0)
  {
    v21 = *__error();
    v24 = "pthread_mutex_init";
    v25 = 298;
    goto LABEL_23;
  }
  *v10 = v12;
  v10[1] = streamClose;
  v10[4] = streamPRead;
  v10[2] = streamRead;
  v10[6] = streamSeek;
  v10[7] = streamAbort;
  return v10;
}

uint64_t streamClose(uint64_t a1)
{
  FILE **v2;
  FILE *v3;
  unint64_t v4;
  FILE *v5;
  unint64_t v6;
  FILE *v7;
  unint64_t v8;
  double v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  uint64_t v13;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 16) >> 62)
    {
      v2 = (FILE **)MEMORY[0x24BDAC8D8];
      fwrite("ChunkInputStream\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      fprintf(*v2, "%12zu chunk size (B)\n", *(_QWORD *)(a1 + 8));
      fprintf(*v2, "%12zu chunks in cache\n", *(_QWORD *)(a1 + 128));
      v3 = *v2;
      v4 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v3, "%12llu bytes read from upstream\n", v4);
      v5 = *v2;
      v6 = atomic_load((unint64_t *)(a1 + 120));
      fprintf(v5, "%12llu bytes read from clients\n", v6);
      v7 = *v2;
      v8 = atomic_load((unint64_t *)(a1 + 120));
      v9 = (double)v8 * 100.0;
      v10 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v7, "%12.2f percent usage\n", v9 / (double)v10);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
    v11 = *(void **)(a1 + 136);
    if (v11)
    {
      if (*(_QWORD *)(a1 + 128))
      {
        v12 = 0;
        v13 = 16;
        do
        {
          free(*(void **)(*(_QWORD *)(a1 + 136) + v13));
          ++v12;
          v13 += 48;
        }
        while (v12 < *(_QWORD *)(a1 + 128));
        v11 = *(void **)(a1 + 136);
      }
      free(v11);
    }
    free((void *)a1);
  }
  return 0;
}

void streamAbort(AAByteStream *a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 3);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }
  __clrex();
}

uint64_t streamPRead(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  unsigned int *v4;
  size_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  pthread_mutex_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  unint64_t v40;
  size_t v41;
  unint64_t v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int *v45;
  ssize_t v48;
  unint64_t v50;
  const char *v53;
  __int16 v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int *v58;
  unsigned int v59;
  char v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  size_t v66;
  unint64_t v67;
  unint64_t v68;
  pthread_mutex_t *v69;
  char *__dst;
  uint64_t v71;

  v4 = (unsigned int *)(a1 + 24);
  if (!atomic_load((unsigned int *)(a1 + 24)))
  {
    if (!a3)
      return 0;
    v7 = a4;
    v8 = a4 + a3;
    if (a4 + a3 <= a4)
      return 0;
    v9 = a1;
    v6 = 0;
    v10 = (pthread_mutex_t *)(a1 + 32);
    v11 = *(_QWORD *)(v9 + 8);
    v12 = (unint64_t *)(v9 + 96);
    v13 = (unint64_t *)(v9 + 112);
    v14 = (unint64_t *)(v9 + 120);
    v71 = v9;
    v63 = v11;
    v64 = a4 + a3;
    v69 = v10;
    while (1)
    {
      __dst = a2;
      v15 = v7 / v11;
      v16 = v7 / v11 * v11;
      if (v16 <= v7)
        v17 = v7;
      else
        v17 = v7 / v11 * v11;
      v67 = v7 / v11 * v11;
      v68 = v17;
      v18 = v16 + v11;
      if (v8 >= v18)
        v19 = v18;
      else
        v19 = v8;
      if (pthread_mutex_lock(v10) < 0)
      {
        v55 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 51, 66, *v55, "pthread_mutex_lock", v56, v57, v62);
LABEL_70:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamReadChunkData", 119, 66, 0, "get a valid chunk from cache", v33, v34, v62);
        goto LABEL_75;
      }
      v65 = v19;
      v66 = v6;
      v22 = *(_QWORD *)(v9 + 128);
      if (v22)
      {
        v23 = *(_QWORD *)(v9 + 136);
        v24 = v23;
        v25 = *(_QWORD *)(v9 + 128);
        do
        {
          if (*(_QWORD *)v24 == v15)
          {
            do
LABEL_33:
              v30 = __ldaxr(v12);
            while (__stlxr(v30 + 1, v12));
            *(_QWORD *)(v24 + 8) = v30;
            v31 = (unsigned int *)(v24 + 40);
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 + 1, v31));
            goto LABEL_36;
          }
          v24 += 48;
          --v25;
        }
        while (v25);
        v24 = *(_QWORD *)(v9 + 136);
        v26 = *(_QWORD *)(v9 + 128);
        do
        {
          if (*(_QWORD *)v24 == -1)
          {
            v27 = -1;
LABEL_29:
            if (v27 != v15)
            {
              v28 = atomic_load((unsigned int *)(v24 + 40));
              if (v28 >= 1)
              {
                do
                {
                  pthread_yield_np();
                  v29 = atomic_load((unsigned int *)(v24 + 40));
                }
                while (v29 > 0);
              }
              *(_QWORD *)v24 = v15;
              *(_QWORD *)(v24 + 24) = 0;
              atomic_store(0, (unsigned int *)(v24 + 32));
              atomic_store(0, (unsigned int *)(v24 + 36));
              atomic_store(0, (unsigned int *)(v24 + 40));
            }
            goto LABEL_33;
          }
          v24 += 48;
          --v26;
        }
        while (v26);
        v24 = 0;
        do
        {
          if (!v24 || *(_QWORD *)(v23 + 8) < *(_QWORD *)(v24 + 8))
            v24 = v23;
          v23 += 48;
          --v22;
        }
        while (v22);
        if (v24)
        {
          v27 = *(_QWORD *)v24;
          goto LABEL_29;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 75, 66, 0, "Invalid state", v20, v21, v62);
      v24 = 0;
LABEL_36:
      if (pthread_mutex_unlock(v69) < 0)
      {
        v35 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 107, 66, *v35, "pthread_mutex_unlock", v36, v37, v62);
      }
      if (!v24)
        goto LABEL_70;
      v38 = (unsigned int *)(v24 + 32);
      if (!atomic_load((unsigned int *)(v24 + 32)))
        break;
LABEL_40:
      v40 = *(_QWORD *)(v24 + 24);
      if (v40 < v68 - v67)
      {
        v53 = "Read out of range";
        v54 = 148;
LABEL_72:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamReadChunkData", v54, 66, 0, v53, v33, v34, v62);
        goto LABEL_73;
      }
      if (v40 >= v65 - v67)
        v41 = v65 - v68;
      else
        v41 = v40 - (v68 - v67);
      memcpy(__dst, (const void *)(*(_QWORD *)(v24 + 16) + v68 - v67), v41);
      do
        v42 = __ldxr(v14);
      while (__stxr(v42 + v41, v14));
      v43 = (unsigned int *)(v24 + 40);
      v9 = v71;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      v6 = v66;
      if ((v41 & 0x8000000000000000) != 0)
        goto LABEL_79;
      if (v41)
      {
        v6 = v41 + v66;
        v7 += v41;
        v10 = v69;
        a2 = &__dst[v41];
        v11 = v63;
        v8 = v64;
        if (v7 < v64)
          continue;
      }
      return v6;
    }
    v45 = (unsigned int *)(v24 + 36);
    while (!atomic_load(v4))
    {
      do
      {
        if (__ldaxr(v45))
        {
          __clrex();
          pthread_yield_np();
          goto LABEL_64;
        }
      }
      while (__stlxr(1u, v45));
      v48 = AAByteStreamPRead(*(AAByteStream *)v71, *(void **)(v24 + 16), *(_QWORD *)(v71 + 8), *(_QWORD *)(v71 + 8) * v15);
      if (v48 < 0)
      {
        v53 = "Stream read";
        v54 = 132;
        goto LABEL_72;
      }
      *(_QWORD *)(v24 + 24) = v48;
      while (!__ldaxr(v38))
      {
        if (!__stlxr(1u, v38))
          goto LABEL_63;
      }
      __clrex();
      do
LABEL_63:
        v50 = __ldxr(v13);
      while (__stxr(v50 + v48, v13));
LABEL_64:
      if (atomic_load(v38))
        goto LABEL_40;
    }
LABEL_73:
    v58 = (unsigned int *)(v24 + 40);
    v9 = v71;
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
LABEL_75:
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAByteStreamCancel(*(AAByteStream *)v9);
        goto LABEL_79;
      }
    }
    __clrex();
LABEL_79:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamPRead", 215, 66, 0, "Reading chunk data failed", v33, v34, v62);
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAByteStreamCancel(*(AAByteStream *)v9);
        return -1;
      }
    }
    __clrex();
  }
  return -1;
}

uint64_t streamRead(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t *v5;
  unint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  v5 = (unint64_t *)(a1 + 104);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return streamPRead(a1, a2, a3, v6);
}

uint64_t streamSeek(uint64_t a1, off_t a2, int a3)
{
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  if (!a3)
  {
LABEL_8:
    atomic_store(a2, (unint64_t *)(a1 + 104));
    return a2;
  }
  if (a3 != 1)
  {
    if (a3 != 2)
      return -1;
    a2 = AAByteStreamSeek(*(AAByteStream *)a1, a2, 2);
    if (a2 < 0)
      return -1;
    goto LABEL_8;
  }
  v6 = (unint64_t *)(a1 + 104);
  do
  {
    v7 = __ldaxr(v6);
    v8 = v7 + a2;
  }
  while (__stlxr(v8, v6));
  return v8;
}

uint64_t CC_CKSUM_Init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return 1;
}

uint64_t CC_CKSUM_Update(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v3 = *(_DWORD *)a1;
  if (a3)
  {
    v4 = a3;
    v5 = a3;
    do
    {
      v6 = *a2++;
      v3 = CKSUMTable[v6 ^ HIBYTE(v3)] ^ (v3 << 8);
      --v5;
    }
    while (v5);
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) += v4;
  return 1;
}

uint64_t CC_CKSUM_Final(unsigned int *a1, uint64_t a2)
{
  unsigned int v2;
  unint64_t v3;
  BOOL v4;

  v2 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    do
    {
      v2 = CKSUMTable[v3 ^ HIBYTE(v2)] ^ (v2 << 8);
      v4 = v3 > 0xFF;
      v3 >>= 8;
    }
    while (v4);
  }
  *a1 = ~v2;
  return 1;
}

uint64_t (**AAChunkAsyncStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8))(void)
{
  int DefaultNThreads;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (**v17)(void);
  uint64_t (**v18)(void);
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  __int16 v24;
  int v25;
  unint64_t v27;
  char v28;

  DefaultNThreads = a5;
  if (a5)
  {
    if (a2)
      goto LABEL_3;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", 651, 143, 0, "invalid chunk size", a7, a8, v28);
    v16 = 0;
LABEL_16:
    chunkAsyncClose(v16);
    v18 = 0;
    goto LABEL_17;
  }
  DefaultNThreads = getDefaultNThreads();
  if (!a2)
    goto LABEL_12;
LABEL_3:
  v13 = malloc(0xF0uLL);
  v16 = (uint64_t)v13;
  if (!v13)
  {
    v24 = 655;
    v25 = 0;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", v24, 143, v25, "malloc", v14, v15, v28);
    goto LABEL_16;
  }
  memset_s(v13, 0xF0uLL, 0, 0xF0uLL);
  v17 = (uint64_t (**)(void))aaAsyncByteStreamAlloc(v16, (uint64_t)chunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
  if (!v17)
  {
    v25 = *__error();
    v24 = 657;
    goto LABEL_15;
  }
  v18 = v17;
  *(_QWORD *)(v16 + 8) = a2;
  *(_QWORD *)(v16 + 16) = a4;
  *(_QWORD *)v16 = a1;
  *(_DWORD *)(v16 + 24) = a4 >> 62;
  if (a3 == -1)
    v19 = DefaultNThreads;
  else
    v19 = a3 / a2;
  if (pthread_mutex_init((pthread_mutex_t *)(v16 + 32), 0))
  {
    v22 = "mutex init";
    v23 = 668;
  }
  else
  {
    if (v19 <= 1)
      v27 = 1;
    else
      v27 = v19;
    if ((lockedStateReserveActiveChunks(v16, v27) & 0x80000000) != 0)
    {
      v22 = "init active chunks";
      v23 = 669;
    }
    else
    {
      v18[2] = (uint64_t (*)(void))chunkAsyncGetRange;
      v18[3] = (uint64_t (*)(void))chunkAsyncProcess;
      v18[4] = (uint64_t (*)(void))chunkAsyncCancel;
      v18[5] = (uint64_t (*)(void))chunkAsyncIsCancelled;
      if ((createThread((pthread_t *)(v16 + 192), (uint64_t)streamProc, v16, 0) & 0x80000000) == 0)
        return v18;
      v22 = "createThread";
      v23 = 678;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", v23, 143, 0, v22, v20, v21, v28);
LABEL_17:
  AAAsyncByteStreamClose(v18);
  return 0;
}

uint64_t chunkAsyncClose(uint64_t result)
{
  uint64_t v1;
  unsigned int *v2;
  _opaque_pthread_t *v4;
  unsigned int v5;
  FILE **v6;
  FILE *v7;
  unint64_t v8;
  FILE *v9;
  unint64_t v10;
  FILE *v11;
  unint64_t v12;
  unint64_t v13;
  FILE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;

  if (result)
  {
    v1 = result;
    v2 = (unsigned int *)(result + 204);
    while (!__ldaxr(v2))
    {
      if (!__stlxr(1u, v2))
        goto LABEL_7;
    }
    __clrex();
LABEL_7:
    v4 = *(_opaque_pthread_t **)(result + 192);
    if (v4)
      joinThread(v4);
    v5 = atomic_load((unsigned int *)(v1 + 200));
    if (*(_DWORD *)(v1 + 24))
    {
      v6 = (FILE **)MEMORY[0x24BDAC8D8];
      fwrite("AAChunkAsyncStream\n", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      fprintf(*v6, "%12zu chunk size\n", *(_QWORD *)(v1 + 8));
      fprintf(*v6, "%12zu allocated chunks\n", *(_QWORD *)(v1 + 96));
      v7 = *v6;
      v8 = atomic_load((unint64_t *)(v1 + 208));
      fprintf(v7, "%12llu ranges requested\n", v8);
      v9 = *v6;
      v10 = atomic_load((unint64_t *)(v1 + 224));
      fprintf(v9, "%12llu chunks processed\n", v10);
      fprintf(*v6, "%12zu bytes in chunks (%.2f MB)\n", *(_QWORD *)(v1 + 8) * *(_QWORD *)(v1 + 96), (double)(unint64_t)(*(_QWORD *)(v1 + 8) * *(_QWORD *)(v1 + 96)) * 0.000000953674316);
      v11 = *v6;
      v12 = atomic_load((unint64_t *)(v1 + 216));
      v13 = atomic_load((unint64_t *)(v1 + 216));
      fprintf(v11, "%12llu bytes requested in ranges (%.2f MB)\n", v12, (double)v13 * 0.000000953674316);
      v14 = *v6;
      v15 = atomic_load((unint64_t *)(v1 + 232));
      v16 = atomic_load((unint64_t *)(v1 + 232));
      fprintf(v14, "%12llu bytes processed in chunks (%.2f MB)\n", v15, (double)v16 * 0.000000953674316);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
    free(*(void **)(v1 + 168));
    if (*(_QWORD *)(v1 + 96))
    {
      v17 = 0;
      v18 = 40;
      do
      {
        free(*(void **)(*(_QWORD *)(v1 + 104) + v18));
        ++v17;
        v18 += 48;
      }
      while (v17 < *(_QWORD *)(v1 + 96));
    }
    free(*(void **)(v1 + 104));
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 184));
    memset_s((void *)v1, 0xF0uLL, 0, 0xF0uLL);
    free((void *)v1);
    if (v5)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t lockedStateReserveActiveChunks(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  void *v5;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  char v18;

  if (*(_QWORD *)(a1 + 96) >= a2)
    return 0;
  if (*(_DWORD *)(a1 + 24) >= 3u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "    %zu active chunks\n", a2);
  if (48 * a2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_15:
    *(_QWORD *)(a1 + 104) = 0;
    v14 = *__error();
    v17 = 147;
    goto LABEL_16;
  }
  v5 = *(void **)(a1 + 104);
  v6 = realloc(v5, 48 * a2);
  if (!v6)
  {
    free(v5);
    goto LABEL_15;
  }
  *(_QWORD *)(a1 + 104) = v6;
  v7 = *(_QWORD *)(a1 + 96);
  v8 = a2 - v7;
  if (a2 <= v7)
  {
LABEL_13:
    result = 0;
    *(_QWORD *)(a1 + 96) = a2;
    return result;
  }
  v9 = 48 * v7;
  while (1)
  {
    v10 = *(_QWORD *)(a1 + 104);
    v11 = *(_QWORD *)(a1 + 8);
    if (v11 >= 0x2000000001)
      break;
    v12 = malloc(v11);
    v13 = v10 + v9;
    *(_QWORD *)(v10 + v9 + 40) = v12;
    if (!v12)
      goto LABEL_18;
    *(_DWORD *)v13 = 0;
    *(_QWORD *)(v13 + 16) = 0;
    *(_QWORD *)(v13 + 24) = 0;
    v9 += 48;
    *(_QWORD *)(v13 + 8) = -1;
    if (!--v8)
      goto LABEL_13;
  }
  *__error() = 12;
  *(_QWORD *)(v10 + v9 + 40) = 0;
LABEL_18:
  v14 = *__error();
  v17 = 152;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"lockedStateReserveActiveChunks", v17, 143, v14, "malloc", v15, v16, v18);
  return 0xFFFFFFFFLL;
}

uint64_t chunkAsyncGetRange(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int *v3;
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v25;

  v3 = (unsigned int *)(a1 + 200);
  if (atomic_load((unsigned int *)(a1 + 200)))
    return 0xFFFFFFFFLL;
  v8 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncGetRange", 519, 143, 0, "lock", v9, v10, v25);
    return 0xFFFFFFFFLL;
  }
  v13 = *(_QWORD *)(a1 + 96);
  if (v13)
  {
    v14 = 0;
    v15 = *(int **)(a1 + 104);
    while (1)
    {
      v16 = *v15;
      v15 += 12;
      if (v16 == 1)
        break;
      if (v13 == ++v14)
        goto LABEL_13;
    }
  }
  else
  {
    v14 = 0;
  }
  if (v14 != v13)
  {
    v17 = *(_QWORD *)(a1 + 104);
    v18 = v17 + 48 * v14;
    *(_DWORD *)v18 = 2;
    *a3 = *(_QWORD *)(v18 + 16);
    v21 = v18 + 16;
    v20 = *(_QWORD *)(v18 + 16);
    v19 = *(_QWORD *)(v21 + 8);
    *a2 = v19 - v20;
    if (*(_DWORD *)(a1 + 24) >= 3u)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "<-- chunk %10llx %10llx -- %8zu\n", v20, v19, *(_QWORD *)(v17 + 48 * v14 + 8));
    goto LABEL_19;
  }
LABEL_13:
  if (!*(_QWORD *)(a1 + 160) && *(_DWORD *)(a1 + 128))
  {
    *a2 = 0;
    *a3 = 0;
LABEL_19:
    if (*(_DWORD *)(a1 + 24) < 3u || *a2)
    {
      v11 = 1;
    }
    else
    {
      v11 = 1;
      fwrite("<-- EOF\n", 8uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
    goto LABEL_22;
  }
  v11 = 0;
LABEL_22:
  if (!pthread_mutex_unlock(v8))
    return v11;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncGetRange", 546, 143, 0, "unlock", v22, v23, v25);
  while (!__ldaxr(v3))
  {
    if (!__stlxr(1u, v3))
    {
      AAAsyncByteStreamCancel(*(_QWORD **)a1);
      return 0xFFFFFFFFLL;
    }
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t chunkAsyncProcess(uint64_t a1, const void *a2, size_t a3, unint64_t a4)
{
  unsigned int *v4;
  pthread_mutex_t *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t result;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v25;
  unint64_t v26[2];

  v4 = (unsigned int *)(a1 + 200);
  if (atomic_load((unsigned int *)(a1 + 200)))
    return 0xFFFFFFFFLL;
  v10 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    v13 = "lock";
    v14 = 556;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncProcess", v14, 143, 0, v13, v11, v12, v25);
    return 0xFFFFFFFFLL;
  }
  if ((a4 & 0x8000000000000000) != 0)
  {
    v13 = "invalid range";
    v14 = 559;
    goto LABEL_4;
  }
  v26[0] = a4;
  v26[1] = a4 + a3;
  if (__CFADD__(a4, a3))
  {
    v13 = "invalid range";
    v14 = 561;
    goto LABEL_4;
  }
  v16 = (unint64_t *)(a1 + 232);
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + a3, v16));
  v18 = (unint64_t *)(a1 + 224);
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v20 = *(_QWORD *)(a1 + 96);
  if (v20)
  {
    v21 = *(_QWORD *)(a1 + 104);
    while (*(_DWORD *)v21 != 2 || rangeCmp((unint64_t *)(v21 + 16), v26))
    {
      v21 += 48;
      if (!--v20)
        goto LABEL_20;
    }
    memcpy(*(void **)(v21 + 40), a2, a3);
    *(_DWORD *)v21 = 3;
    if (*(_DWORD *)(a1 + 24) >= 3u)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "--> chunk %10llx %10llx -- %8zu\n", *(_QWORD *)(v21 + 16), *(_QWORD *)(v21 + 24), *(_QWORD *)(v21 + 8));
  }
LABEL_20:
  result = pthread_mutex_unlock(v10);
  if ((_DWORD)result)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncProcess", 582, 143, 0, "unlock", v22, v23, v25);
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAAsyncByteStreamCancel(*(_QWORD **)a1);
        return 0xFFFFFFFFLL;
      }
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  return result;
}

_QWORD *chunkAsyncCancel(_QWORD *result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 25);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return AAAsyncByteStreamCancel((_QWORD *)*result);
  }
  __clrex();
  return result;
}

uint64_t chunkAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 200));
}

_QWORD **streamProc(_QWORD **a1)
{
  unint64_t *v3;
  unint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  char v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  int v24;
  unint64_t v25;
  char *v26;
  unint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  BOOL v32;
  BOOL v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  _QWORD *v50;
  unint64_t v51;
  _QWORD *v52;
  int Range;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  unint64_t *v59;
  _QWORD *v60;
  unint64_t *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  unint64_t v74;
  unint64_t v75;
  _QWORD *v76;
  unint64_t v77;
  _QWORD *v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  unint64_t v92;
  unint64_t *v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  _QWORD *v98;
  unint64_t v99;
  uint64_t v100;
  _QWORD *v101;
  unint64_t v102;
  char *v103;
  _QWORD *v104;
  unint64_t v105;
  unint64_t v106;
  BOOL v108;
  uint64_t v109;
  unint64_t v110;
  _QWORD *v111;
  _QWORD *v112;
  unint64_t v113;
  _QWORD *v114;
  __int16 v115;
  const char *v116;
  _QWORD *v117;
  unint64_t v118;
  _QWORD *v119;
  unint64_t v120;
  unint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  unint64_t v124;
  _QWORD *v125;
  unint64_t v126;
  uint64_t v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  int *v131;
  int v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  _QWORD *v138;
  unint64_t v139;
  unint64_t *v140;
  char *v141;
  char **v142;
  char *v143;
  char *v144;
  int v145;
  int *v146;
  uint64_t v147;
  uint64_t v148;
  int *v150;
  uint64_t v151;
  uint64_t v152;
  int *v153;
  uint64_t v154;
  uint64_t v155;
  const char *v156;
  __int16 v157;
  const char *v158;
  __int16 v159;
  const char *v160;
  __int16 v161;
  const char *v162;
  __int16 v163;
  unsigned int *v164;
  int *v167;
  uint64_t v168;
  uint64_t v169;
  char v170;
  _QWORD *v171;
  unint64_t v172;
  _OWORD *v173;
  uint64_t *v174;
  int v175;
  unint64_t v176;
  int v177;
  int v178;
  pthread_mutex_t *v179;
  unint64_t v180;
  unint64_t v181;
  __int128 v182;

  if (atomic_load((unsigned int *)a1 + 51))
    return a1;
  v3 = (unint64_t *)(a1 + 27);
  v4 = (unint64_t *)(a1 + 26);
  v173 = a1 + 17;
  v174 = (uint64_t *)(a1 + 19);
  v179 = (pthread_mutex_t *)(a1 + 4);
  while (1)
  {
    if (*((_DWORD *)a1 + 32))
    {
LABEL_4:
      v178 = 0;
      goto LABEL_5;
    }
    v49 = (_QWORD)a1[1] * (_QWORD)a1[12];
    v50 = a1[20];
    if (v50)
    {
      v51 = 0;
      v52 = a1[21] + 1;
      do
      {
        v51 = *v52 + v51 - *(v52 - 1);
        v52 += 2;
        v50 = (_QWORD *)((char *)v50 - 1);
      }
      while (v50);
      v176 = v49 + (v49 >> 2);
      if (v51 > v176)
        goto LABEL_4;
    }
    else
    {
      v51 = 0;
      v176 = v49 + (v49 >> 2);
    }
    v178 = 0;
    while (1)
    {
      v180 = 0;
      v181 = 0;
      Range = AAAsyncByteStreamGetRange(*a1, &v180, (uint64_t *)&v181);
      if (Range < 0)
      {
        v156 = "GetRange";
        v157 = 220;
LABEL_272:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateFetchRanges", v157, 143, 0, v156, v54, v55, v170);
        goto LABEL_273;
      }
      if (!Range)
        goto LABEL_203;
      if (!v180)
        break;
      v56 = v181;
      if ((v181 & 0x8000000000000000) != 0)
      {
        v156 = "invalid range";
        v157 = 228;
        goto LABEL_272;
      }
      v57 = (_QWORD *)(v181 + v180);
      *(_QWORD *)&v182 = v181;
      *((_QWORD *)&v182 + 1) = v181 + v180;
      if (__CFADD__(v181, v180))
      {
        v156 = "invalid range overflow";
        v157 = 230;
        goto LABEL_272;
      }
      v58 = a1[20];
      if (v58)
      {
        v59 = a1[21];
        if (!rangeCmp(v59, (unint64_t *)&v182))
          goto LABEL_118;
        v60 = 0;
        v61 = v59 + 2;
        do
        {
          if ((_QWORD *)((char *)v58 - 1) == v60)
            goto LABEL_98;
          v62 = rangeCmp(v61, (unint64_t *)&v182);
          v61 += 2;
          v60 = (_QWORD *)((char *)v60 + 1);
        }
        while (v62);
        if (v60 < v58)
          goto LABEL_118;
      }
LABEL_98:
      v63 = *v174;
      if ((unint64_t)v58 >= *v174)
      {
        v64 = 2 * v63;
        v32 = v63 == 0;
        v65 = 32;
        if (!v32)
          v65 = v64;
        *v174 = v65;
        if ((unint64_t)(16 * v65) >= 0x2000000001)
        {
          *__error() = 12;
        }
        else
        {
          v66 = a1[21];
          v67 = realloc(v66, 16 * v65);
          if (v67)
          {
            a1[21] = v67;
            goto LABEL_104;
          }
          free(v66);
        }
        a1[21] = 0;
        v167 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateFetchRanges", 248, 143, *v167, "malloc", v168, v169, v170);
        *v174 = 0;
        v174[1] = 0;
LABEL_273:
        v158 = "fetching ranges";
        v159 = 493;
        goto LABEL_282;
      }
LABEL_104:
      if (*((_DWORD *)a1 + 6) >= 3u)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "<<< range %10llx %10llx\n", v56, v57);
      v69 = a1[20];
      v68 = a1[21];
      a1[20] = (_QWORD *)((char *)v69 + 1);
      *(_OWORD *)&v68[2 * (_QWORD)v69] = v182;
      v51 += (unint64_t)v57 - v56;
      do
        v70 = __ldxr(v3);
      while (__stxr((unint64_t)v57 + v70 - v56, v3));
      do
        v71 = __ldxr(v4);
      while (__stxr(v71 + 1, v4));
      v72 = a1[17];
      v73 = a1[18];
      if (v72 == v73)
      {
        *v173 = v182;
      }
      else if (v57 != (_QWORD *)v56)
      {
        if ((unint64_t)v72 >= v56)
          v72 = (_QWORD *)v56;
        if (v57 > v73)
          v73 = v57;
        a1[17] = v72;
        a1[18] = v73;
      }
      v178 = 1;
LABEL_118:
      if (v51 > v176)
        goto LABEL_203;
    }
    if (*((_DWORD *)a1 + 6) >= 3u)
      fwrite("<<< range EOF\n", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    *((_DWORD *)a1 + 32) = 1;
LABEL_203:
    if (!v178)
      goto LABEL_4;
    stateSortRanges((uint64_t)a1);
LABEL_5:
    if (pthread_mutex_lock(v179))
    {
      v160 = "lock";
      v161 = 276;
LABEL_276:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", v161, 143, 0, v160, v5, v6, v170);
LABEL_277:
      v158 = "retiring ranges";
      v159 = 497;
      goto LABEL_282;
    }
    v7 = a1[20];
    if (!v7)
      goto LABEL_121;
    v175 = 0;
    v8 = 0;
    v9 = 1;
    while (2)
    {
      v10 = a1[21];
      v11 = (unint64_t)a1[1];
      while (2)
      {
        v12 = &v10[2 * v8];
        v14 = (unint64_t *)(v12 + 1);
        v13 = v12[1];
        v15 = *v12;
        v16 = *v12 / v11;
        v17 = (v13 + v11 - 1) / v11;
        if (v16 < v17)
        {
          v18 = (unint64_t)a1[14];
          if (v18 <= v16)
            v18 = v15 / v11;
          v19 = 1;
          v20 = v10[2 * v8];
          v21 = v15 / v11;
          while (v21 != v18)
          {
            v22 = a1[15][v21];
            if (v22 == -1)
              break;
            v23 = a1[13];
            v24 = v23[6 * v22];
            if (!v24 || v21 != v23[6 * v22 + 1])
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 291, 143, 0, "invalid state", v5, v6, v170);
              v48 = 1;
              goto LABEL_78;
            }
            if (v24 != 3)
              break;
            if (v20 == v13
              || (v20 <= v21 * v11 ? (v25 = v21 * v11) : (v25 = v20),
                  v21 * v11 + v11 >= v13 ? (v26 = (char *)v12[1]) : (v26 = (char *)(v21 * v11 + v11)),
                  v25 >= (unint64_t)v26))
            {
              v25 = 0;
              v26 = 0;
            }
            v27 = 0;
            v28 = &v23[6 * v22];
            v30 = v28[2];
            v29 = v28[3];
            if (v30 != v29)
              v20 = v12[1];
            v31 = 0;
            if (v13 != v15 && v30 != v29)
            {
              if (v15 <= v30)
                v31 = v30;
              else
                v31 = v10[2 * v8];
              if (v29 >= v13)
                v27 = v12[1];
              else
                v27 = v29;
              if (v31 >= v27)
              {
                v27 = 0;
                v31 = 0;
              }
              else if (v26 == (char *)v25)
              {
                break;
              }
              v20 = v10[2 * v8];
            }
            v32 = v26 != (char *)v25 && v27 == v31;
            v33 = v32;
            if ((unint64_t)v26 < v27 || v31 != v25 || v33)
              break;
            if (v27 >= (unint64_t)v26)
            {
              v19 = ++v21 < v17;
              if (v21 != v17)
                continue;
            }
            if (!v19)
              goto LABEL_56;
            break;
          }
          if (++v8 < (unint64_t)v7)
            continue;
          if ((v9 & 1) != 0)
          {
LABEL_121:
            v48 = 0;
            v47 = 0;
            goto LABEL_122;
          }
LABEL_260:
          stateSortRanges((uint64_t)a1);
          v48 = 0;
LABEL_78:
          v47 = v175;
          goto LABEL_122;
        }
        break;
      }
LABEL_56:
      v34 = v13 - v15;
      if (v13 - v15 > (unint64_t)a1[22])
      {
        a1[22] = (_QWORD *)v34;
        if (v34 >= 0x2000000001)
        {
          *__error() = 12;
        }
        else
        {
          v35 = a1[23];
          v36 = realloc(v35, v13 - v15);
          if (v36)
          {
            a1[23] = v36;
            goto LABEL_60;
          }
          free(v35);
        }
        a1[23] = 0;
        v153 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 314, 143, *v153, "malloc", v154, v155, v170);
        a1[22] = 0;
LABEL_262:
        v48 = 1;
        goto LABEL_78;
      }
LABEL_60:
      v172 = v34;
      if (v16 < v17)
      {
        v37 = 0;
        while (1)
        {
          v38 = a1[13];
          v39 = a1[15][v16];
          v40 = &v38[6 * v39];
          v41 = v40[2];
          v42 = v40[3];
          if (v41 == v42)
            goto LABEL_69;
          v43 = *v12;
          if (*v12 == *v14)
            goto LABEL_69;
          if (v43 <= v41)
            v43 = v41;
          if (v42 >= *v14)
            v42 = *v14;
          if (v43 >= v42)
          {
LABEL_69:
            v43 = 0;
            v42 = 0;
          }
          v44 = v42 - v43 + v37;
          if (v44 > v172)
            break;
          memcpy((char *)a1[23] + v37, (const void *)(v38[6 * v39 + 5] + v43 - v41), v42 - v43);
          ++v16;
          v37 = v44;
          if (v16 == v17)
            goto LABEL_72;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 328, 143, 0, "invalid state", v5, v6, v170);
        goto LABEL_262;
      }
LABEL_72:
      v45 = *v14;
      v46 = *v12;
      if (*((_DWORD *)a1 + 6) >= 3u)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], ">>> range %10llx %10llx\n", *v12, v45);
        v45 = *v14;
        v46 = *v12;
      }
      v47 = v175;
      if ((AAAsyncByteStreamProcess((uint64_t)*a1, (uint64_t)a1[23], v45 - v46, v46) & 0x80000000) == 0)
      {
        v9 = 0;
        *v12 = 0;
        v12[1] = 0;
        v7 = a1[20];
        ++v8;
        v175 = 1;
        if (v8 >= (unint64_t)v7)
          goto LABEL_260;
        continue;
      }
      break;
    }
    v150 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 336, 143, *v150, "process range", v151, v152, v170);
    v48 = 1;
LABEL_122:
    if (pthread_mutex_unlock(v179))
    {
      v160 = "unlock";
      v161 = 347;
      goto LABEL_276;
    }
    if (v48)
      goto LABEL_277;
    if (!a1[20])
    {
      v82 = 0;
      goto LABEL_255;
    }
    if (pthread_mutex_lock(v179))
      break;
    v74 = (unint64_t)a1[14];
    v75 = (unint64_t)a1[12];
    v76 = a1[20];
    if (v76)
    {
      v77 = (unint64_t)a1[1];
      v78 = a1[21] + 1;
      do
      {
        v79 = (v77 - 1 + *v78) / v77;
        if (v79 > v74)
          v74 = (v77 - 1 + *v78) / v77;
        if (v79 - *(v78 - 1) / v77 > v75)
          v75 = v79 - *(v78 - 1) / v77;
        v78 += 2;
        v76 = (_QWORD *)((char *)v76 - 1);
      }
      while (v76);
    }
    if ((lockedStateReserveActiveChunks((uint64_t)a1, v75) & 0x80000000) != 0)
      goto LABEL_250;
    if ((unint64_t)a1[14] >= v74)
      goto LABEL_144;
    if (*((_DWORD *)a1 + 6) >= 3u)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "    %zu chunks\n", v74);
    if (8 * v74 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_249;
    }
    v83 = a1[15];
    v84 = realloc(v83, 8 * v74);
    if (!v84)
    {
      free(v83);
LABEL_249:
      a1[15] = 0;
      v146 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"lockedStateReserveChunks", 172, 143, *v146, "malloc", v147, v148, v170);
      a1[14] = 0;
LABEL_250:
      v115 = 375;
      v116 = "reserving chunks";
      goto LABEL_251;
    }
    a1[15] = v84;
    v85 = (unint64_t)a1[14];
    if (v85 < v74)
      memset(&v84[v85], 255, 8 * v74 - 8 * v85);
    a1[14] = (_QWORD *)v74;
LABEL_144:
    v86 = a1[12];
    if (v86)
    {
      v87 = a1[13] + 4;
      v88 = a1[12];
      do
      {
        *v87 = 0;
        v87 += 6;
        v88 = (_QWORD *)((char *)v88 - 1);
      }
      while (v88);
    }
    v89 = a1[20];
    if (v89)
    {
      v90 = 0;
      v91 = a1[21];
      v92 = (unint64_t)a1[1];
      while (1)
      {
        v93 = &v91[2 * v90];
        v94 = *v93;
        v95 = v93[1];
        v96 = v94 / v92;
        v97 = (v92 - 1 + v95) / v92;
        if (v94 / v92 < v97)
          break;
LABEL_187:
        if ((_QWORD *)++v90 == v89)
          goto LABEL_188;
      }
      v98 = a1[15];
      v99 = v95;
      while (2)
      {
        v100 = v98[v96];
        if (v100 != -1)
        {
          v101 = a1[13];
          if (!LODWORD(v101[6 * v100]) || v96 != v101[6 * v100 + 1])
          {
            v115 = 389;
            v116 = "invalid state";
LABEL_251:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", v115, 143, 0, v116, v80, v81, v170);
            v82 = 0;
LABEL_252:
            v145 = 1;
            goto LABEL_253;
          }
          if (v94 == v99)
            goto LABEL_160;
          v102 = v96 * v92;
          v103 = (char *)(v96 * v92 + v92);
          if (v94 > v96 * v92)
            v102 = v94;
          if ((unint64_t)v103 >= v99)
            v103 = (char *)v99;
          if (v102 >= (unint64_t)v103)
          {
LABEL_160:
            v102 = 0;
            v103 = 0;
          }
          v80 = 0;
          v104 = &v101[6 * v100];
          v106 = v104[2];
          v105 = v104[3];
          if (v106 != v105)
            v99 = v94;
          v81 = 0;
          if (v94 != v95 && v106 != v105)
          {
            if (v94 <= v106)
              v81 = v106;
            else
              v81 = v94;
            if (v105 >= v95)
              v80 = v95;
            else
              v80 = v105;
            if (v81 >= v80)
            {
              v80 = 0;
              v81 = 0;
            }
            else
            {
              v99 = v95;
              if (v103 == (char *)v102)
                goto LABEL_186;
            }
            v99 = v95;
          }
          v108 = v103 != (char *)v102 && v80 == v81;
          if (v103 == (char *)v80 && v81 == v102 && !v108)
            ++v101[6 * v100 + 4];
        }
LABEL_186:
        if (++v96 == v97)
          goto LABEL_187;
        continue;
      }
    }
LABEL_188:
    if (v86)
    {
      v109 = 0;
      v82 = 0;
      v110 = 0;
      while (1)
      {
        v111 = a1[13];
        if (!v111[v109 + 4] && LODWORD(v111[v109]))
        {
          v112 = &v111[v109];
          v113 = v111[v109 + 1];
          if (v113 >= (unint64_t)a1[14])
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", 410, 143, 0, "invalid chunk index", v80, v81, v170);
            goto LABEL_252;
          }
          a1[15][v113] = -1;
          *(_DWORD *)v112 = 0;
          v112[2] = 0;
          v112[3] = 0;
          v112[1] = -1;
          v86 = a1[12];
          v82 = 1;
        }
        ++v110;
        v109 += 6;
        if (v110 >= (unint64_t)v86)
        {
          if (v86)
          {
            v114 = a1[13] + 4;
            do
            {
              *v114 = 0;
              v114 += 6;
              v86 = (_QWORD *)((char *)v86 - 1);
            }
            while (v86);
          }
          goto LABEL_206;
        }
      }
    }
    v82 = 0;
LABEL_206:
    v117 = a1[20];
    if (!v117)
    {
      v145 = 0;
      goto LABEL_253;
    }
    v118 = 0;
    v177 = v47;
    while (1)
    {
      v119 = &a1[21][2 * v118];
      v120 = (unint64_t)a1[1];
      v121 = *v119 / v120;
      v171 = v119;
      v123 = v119[1];
      v122 = v119 + 1;
      v124 = (v120 + v123 - 1) / v120;
      if (!v118 && v121 < v124)
      {
        v125 = a1[15];
        v126 = v121;
        do
        {
          v127 = v125[v126];
          if (v127 != -1)
            a1[13][6 * v127 + 4] = 1;
          ++v126;
        }
        while (v126 != v124);
      }
      if (v121 < v124)
        break;
LABEL_244:
      v145 = 0;
      ++v118;
      v47 = v177;
      if (v118 >= (unint64_t)v117)
        goto LABEL_253;
    }
    while (2)
    {
      v128 = a1[15];
      if (v128[v121] != -1)
        goto LABEL_242;
      v129 = a1[12];
      if (v129)
      {
        v130 = 0;
        v131 = (int *)a1[13];
        while (1)
        {
          v132 = *v131;
          v131 += 12;
          if (!v132)
            break;
          v130 = (_QWORD *)((char *)v130 + 1);
          if (v129 == v130)
            goto LABEL_223;
        }
      }
      else
      {
        v130 = 0;
      }
      if (v130 != v129)
        goto LABEL_231;
LABEL_223:
      if (!v118)
      {
        v130 = 0;
        if (v129)
        {
          v133 = a1[13] + 4;
          while (1)
          {
            v134 = *v133;
            v133 += 6;
            if (!v134)
              break;
            v130 = (_QWORD *)((char *)v130 + 1);
            if (v129 == v130)
              goto LABEL_246;
          }
        }
        if (v130 == v129)
        {
LABEL_246:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", 451, 143, 0, "no available chunk", v80, v81, v170);
          v145 = 1;
          goto LABEL_247;
        }
        v135 = (uint64_t)&a1[13][6 * (_QWORD)v130];
        v136 = *(_QWORD *)(v135 + 8);
        v128[v136] = -1;
        *(_DWORD *)v135 = 0;
        *(_QWORD *)(v135 + 16) = 0;
        *(_QWORD *)(v135 + 24) = 0;
        *(_QWORD *)(v135 + 8) = -1;
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BYE chunk %8zu evicted\n", v136);
        v128 = a1[15];
LABEL_231:
        v137 = (uint64_t)&a1[13][6 * (_QWORD)v130];
        *(_QWORD *)(v137 + 8) = v121;
        v128[v121] = v130;
        *(_DWORD *)v137 = 1;
        *(_QWORD *)(v137 + 32) = v118 == 0;
        v138 = a1[1];
        v139 = (_QWORD)v138 * *(_QWORD *)(v137 + 8);
        *(_QWORD *)(v137 + 16) = v139;
        v140 = (unint64_t *)(v137 + 16);
        v141 = (char *)v138 + v139;
        *(_QWORD *)(v137 + 24) = (char *)v138 + v139;
        v142 = (char **)(v137 + 24);
        if (!v138)
          goto LABEL_238;
        v144 = (char *)a1[17];
        v143 = (char *)a1[18];
        if (v144 == v143)
          goto LABEL_238;
        if ((unint64_t)v144 > v139)
          v139 = (unint64_t)a1[17];
        *v140 = v139;
        if (v141 >= v143)
          v141 = v143;
        *v142 = v141;
        if (v139 >= (unint64_t)v141)
        {
LABEL_238:
          *v140 = 0;
          v140[1] = 0;
        }
        if (*((_DWORD *)a1 + 6) >= 3u)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "SET range %10llx %10llx -- %8zu\n", *v171, *v122, v121);
        v82 = 1;
LABEL_242:
        if (++v121 == v124)
        {
          v117 = a1[20];
          goto LABEL_244;
        }
        continue;
      }
      break;
    }
    v145 = 0;
LABEL_247:
    v47 = v177;
LABEL_253:
    if (pthread_mutex_unlock(v179))
    {
      v162 = "unlock";
      v163 = 478;
      goto LABEL_280;
    }
    if (v145)
      goto LABEL_281;
LABEL_255:
    if (!(v47 | v178 | v82))
      usleep(0x9C40u);
    if (atomic_load((unsigned int *)a1 + 51))
      return a1;
  }
  v162 = "lock";
  v163 = 359;
LABEL_280:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", v163, 143, 0, v162, v5, v6, v170);
LABEL_281:
  v158 = "updating chunks";
  v159 = 501;
LABEL_282:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"streamProc", v159, 143, 0, v158, v5, v6, v170);
  v164 = (unsigned int *)(a1 + 25);
  while (!__ldaxr(v164))
  {
    if (!__stlxr(1u, v164))
    {
      AAAsyncByteStreamCancel(*a1);
      return a1;
    }
  }
  __clrex();
  return a1;
}

uint64_t rangeCmp(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v7;
  unsigned int v8;

  v2 = *a1;
  v3 = a1[1];
  v4 = *a2;
  v5 = a2[1];
  if (v3 == *a1 && v5 != v4)
    return 1;
  if (v3 >= v5)
    v7 = v5 < v3;
  else
    v7 = -1;
  if (v4 >= v2)
    v8 = v7;
  else
    v8 = 1;
  if ((v5 != v4 || v3 == v2) && v2 >= v4)
    return v8;
  else
    return 0xFFFFFFFFLL;
}

void stateSortRanges(uint64_t a1)
{
  size_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = *(_QWORD *)(a1 + 160);
  if (v1)
  {
    qsort(*(void **)(a1 + 168), v1, 0x10uLL, (int (__cdecl *)(const void *, const void *))rangeCmp);
    v3 = *(_QWORD *)(a1 + 160);
    if (v3)
    {
      v4 = v3 - 1;
      v5 = (_QWORD *)(*(_QWORD *)(a1 + 168) + 16 * v3 - 8);
      do
      {
        if (*(v5 - 1) != *v5)
          break;
        v5 -= 2;
        *(_QWORD *)(a1 + 160) = v4--;
      }
      while (v4 != -1);
    }
  }
}

unint64_t AAAsyncByteStreamProcessAllRanges(_QWORD *a1, void *a2, int a3, size_t __count)
{
  uint64_t v6;
  void ***v7;
  void ***v8;
  uint64_t v9;
  void ***v10;
  void **v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;
  void ***v27;
  void **v28;
  int Range;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t Worker;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unsigned int v47;

  if (!(_DWORD)__count)
    LODWORD(__count) = getDefaultNThreads();
  v47 = 0;
  v46 = 0;
  v6 = __count;
  v7 = (void ***)calloc(__count, 8uLL);
  v8 = v7;
  if (!v7)
  {
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 79, 116, *v17, "malloc", v18, v19, v44);
    v15 = 0;
    goto LABEL_15;
  }
  if ((_DWORD)v6)
  {
    v9 = v6;
    v10 = v7;
    do
    {
      v11 = (void **)malloc(0x48uLL);
      v12 = v11;
      if (!v11)
      {
        v20 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 83, 116, *v20, "malloc", v21, v22, v44);
        v15 = 0;
        goto LABEL_16;
      }
      memset_s(v11, 0x48uLL, 0, 0x48uLL);
      *v12 = a2;
      v12[1] = a1;
      v12[2] = &v47;
      v12[3] = &v46;
      *v10++ = v12;
      --v9;
    }
    while (v9);
  }
  v15 = ThreadPoolCreate(v6, (uint64_t)v8, (uint64_t)workerProc_2);
  if (!v15)
  {
    v23 = "ThreadPoolCreate";
    v24 = 93;
    goto LABEL_14;
  }
  if (atomic_load(&v47))
  {
LABEL_10:
    LODWORD(v12) = 1;
    goto LABEL_16;
  }
  LODWORD(v12) = 1;
  while (1)
  {
    v44 = 0;
    v45 = 0;
    Range = AAAsyncByteStreamGetRange(a1, &v45, &v44);
    if (Range < 0)
    {
      v23 = "AAAsyncByteStreamGetRange";
      v24 = 101;
      goto LABEL_14;
    }
    if (!Range)
    {
      usleep(0x4E20u);
      goto LABEL_38;
    }
    if (!v45)
      goto LABEL_10;
    Worker = ThreadPoolGetWorker((uint64_t)v15, v32, v33, v34, v35, v36, v13, v14);
    if (!Worker)
      break;
    v42 = v44;
    *(_QWORD *)(Worker + 32) = v45;
    *(_QWORD *)(Worker + 40) = v42;
    if ((ThreadPoolRunWorker((uint64_t)v15, Worker, v38, v39, v40, v41, v13, v14) & 0x80000000) != 0)
    {
      v23 = "ThreadPoolRunWorker";
      v24 = 110;
      goto LABEL_14;
    }
LABEL_38:
    if (atomic_load(&v47))
      goto LABEL_16;
  }
  v23 = "ThreadPoolGetWorker";
  v24 = 107;
LABEL_14:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", v24, 116, 0, v23, v13, v14, v44);
LABEL_15:
  LODWORD(v12) = 0;
LABEL_16:
  if ((ThreadPoolDestroy((uint64_t)v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 115, 116, 0, "Threads reported errors", v25, v26, v44);
    LODWORD(v12) = 0;
  }
  if (v8)
  {
    if ((_DWORD)v6)
    {
      v27 = v8;
      do
      {
        v28 = *v27;
        if (*v27)
        {
          free(v28[8]);
          free(v28);
        }
        ++v27;
        --v6;
      }
      while (v6);
    }
    free(v8);
  }
  if (atomic_load(&v47))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 127, 116, 0, "Threads reported errors", v25, v26, v44);
    return -1;
  }
  if ((_DWORD)v12)
    return atomic_load(&v46);
  else
    return -1;
}

uint64_t workerProc_2(uint64_t a1)
{
  size_t v2;
  void *v3;
  void *v4;
  unint64_t v5;
  ssize_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  const char *v13;
  __int16 v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  char v20;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 48) < v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    if (v2 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_18:
      *(_QWORD *)(a1 + 64) = 0;
      v15 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"workerProc", 36, 116, *v15, "malloc", v16, v17, v20);
      *(_QWORD *)(a1 + 48) = 0;
      goto LABEL_19;
    }
    v3 = *(void **)(a1 + 64);
    v4 = realloc(v3, v2);
    if (!v4)
    {
      free(v3);
      goto LABEL_18;
    }
    *(_QWORD *)(a1 + 64) = v4;
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 56) = 0;
  v5 = 0;
  if (v2)
  {
    while (1)
    {
      v6 = AAByteStreamPRead(*(AAByteStream *)a1, (void *)(*(_QWORD *)(a1 + 64) + v5), v2 - v5, *(_QWORD *)(a1 + 40) + v5);
      if (v6 < 0)
        break;
      v5 = *(_QWORD *)(a1 + 56);
      if (v6)
      {
        v5 += v6;
        *(_QWORD *)(a1 + 56) = v5;
        v2 = *(_QWORD *)(a1 + 32);
        if (v5 < v2)
          continue;
      }
      goto LABEL_10;
    }
    v13 = "istream read";
    v14 = 43;
  }
  else
  {
LABEL_10:
    if ((AAAsyncByteStreamProcess(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 64), v5, *(_QWORD *)(a1 + 40)) & 0x80000000) == 0)
    {
      v9 = *(unint64_t **)(a1 + 24);
      v10 = *(_QWORD *)(a1 + 56);
      do
        v11 = __ldxr(v9);
      while (__stxr(v11 + v10, v9));
      return 0;
    }
    v13 = "stream process";
    v14 = 50;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"workerProc", v14, 116, 0, v13, v7, v8, v20);
LABEL_19:
  *(_QWORD *)(a1 + 56) = 0;
  v18 = *(unsigned int **)(a1 + 16);
  while (!__ldaxr(v18))
  {
    if (!__stlxr(1u, v18))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

void *reallocToFit(void *a1, size_t __size)
{
  void *v4;
  void *v5;

  if (__size >= 0x1000)
  {
    v4 = malloc(__size);
    if (v4)
    {
      v5 = v4;
      memcpy(v4, a1, __size);
      free(a1);
      return v5;
    }
  }
  return a1;
}

double getRealTime()
{
  timeval v1;

  v1.tv_sec = 0;
  *(_QWORD *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t getDefaultNThreads()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  size_t v4;
  unsigned int v5;

  v5 = 0;
  v4 = 4;
  if (!sysctlbyname("hw.physicalcpu", &v5, &v4, 0, 0))
    return v5;
  v0 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getDefaultNThreads", 107, 3, *v0, "sysctlbyname", v1, v2, v4);
  return 1;
}

uint64_t sha1ToString(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v3;
  unint64_t v4;

  v2 = 0;
  v3 = (_BYTE *)(result + 1);
  do
  {
    v4 = *(unsigned __int8 *)(a2 + v2);
    *(v3 - 1) = serializeHexString_digit[v4 >> 4];
    *v3 = serializeHexString_digit[v4 & 0xF];
    v3 += 2;
    ++v2;
  }
  while (v2 != 20);
  *(_BYTE *)(result + 40) = 0;
  return result;
}

uint64_t serializeHexString(uint64_t result, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3;
  unsigned int v4;

  if (a2)
  {
    v3 = 0;
    do
    {
      v4 = *a3++;
      *(_BYTE *)(result + v3) = serializeHexString_digit[(unint64_t)v4 >> 4];
      *(_BYTE *)(result + (v3 + 1)) = serializeHexString_digit[v4 & 0xF];
      v3 += 2;
    }
    while (2 * a2 != v3);
  }
  *(_BYTE *)(result + 2 * a2) = 0;
  return result;
}

uint64_t sha1cmp(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = bswap64(*(_QWORD *)a1);
  v3 = bswap64(*(_QWORD *)a2);
  if (v2 == v3)
  {
    v2 = bswap64(*(_QWORD *)(a1 + 8));
    v3 = bswap64(*(_QWORD *)(a2 + 8));
    if (v2 == v3)
    {
      v2 = bswap32(*(_DWORD *)(a1 + 16));
      v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3)
        return 0;
    }
  }
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  return 1;
}

const char *makePath(const char *result, unint64_t a2)
{
  const char *v3;
  unint64_t v4;
  int v5;
  stat v6;

  v3 = result;
  memset(&v6, 0, sizeof(v6));
  if (a2)
  {
    v4 = a2;
    do
    {
      if (v3[v4] == 47)
      {
        v3[v4] = 0;
        result = (const char *)stat(v3, &v6);
        if (!(_DWORD)result)
          break;
      }
      --v4;
    }
    while (v4);
  }
  else
  {
    v4 = 0;
  }
  if (v4 < a2)
  {
    v5 = 1;
    do
    {
      if (!v3[v4])
      {
        if (!v5)
          result = (const char *)mkdir(v3, 0x1EDu);
        v5 = 0;
        v3[v4] = 47;
      }
      ++v4;
    }
    while (a2 != v4);
  }
  return result;
}

uint64_t normalizePath(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  char v7;
  _BOOL4 v8;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v1 = 0;
  v2 = 0;
  while (2)
  {
    v3 = v1 - 1;
    while (1)
    {
      while (1)
      {
        v4 = v2++;
        v5 = *(unsigned __int8 *)(a1 + v4);
        if (v5 != 47)
          break;
        if (v1)
        {
          v6 = *(unsigned __int8 *)(a1 + v3);
          if (v6 != 47)
            goto LABEL_9;
        }
      }
      if (!*(_BYTE *)(a1 + v4))
        goto LABEL_28;
      if (v1)
      {
        v6 = *(unsigned __int8 *)(a1 + v3);
LABEL_9:
        v7 = 0;
        v8 = v6 == 47;
        goto LABEL_11;
      }
      v7 = 1;
      v8 = 1;
LABEL_11:
      if (v5 != 46 || !v8)
        goto LABEL_26;
      v10 = *(unsigned __int8 *)(a1 + v2);
      if (v10 != 47)
        break;
      v2 = v4 + 2;
    }
    if (*(_BYTE *)(a1 + v2))
    {
      if (v10 != 46 || *(_BYTE *)(v4 + a1 + 2) != 47 && *(_BYTE *)(v4 + a1 + 2))
      {
LABEL_26:
        *(_BYTE *)(a1 + v1++) = v5;
        continue;
      }
      if ((v7 & 1) == 0)
      {
        do
        {
          v11 = v1 - 1;
          if (v1 == 1)
            break;
          v12 = *(unsigned __int8 *)(a1 - 2 + v1--);
        }
        while (v12 != 47);
        v2 = v4 + 3;
        v1 = v11;
        if (!*(_BYTE *)(v4 + a1 + 2))
        {
          v1 = v11;
          goto LABEL_28;
        }
        continue;
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      do
      {
LABEL_28:
        v14 = v1;
        if (!v1)
          break;
        --v1;
      }
      while (*(_BYTE *)(a1 + v14 - 1) == 47);
      v13 = 0;
      *(_BYTE *)(a1 + v14) = 0;
    }
    return v13;
  }
}

uint64_t concatPath(char *a1, unint64_t a2, char *__s, const char *a4)
{
  size_t v8;
  size_t v9;
  uint64_t result;
  size_t v11;

  v8 = strlen(__s);
  v9 = strlen(a4);
  if (v8 + v9 + 2 > a2)
    return 0xFFFFFFFFLL;
  v11 = v9;
  if (a1 != __s)
    memcpy(a1, __s, v8);
  if (v11)
  {
    if (!v8 || a1[v8 - 1] != 47)
      a1[v8++] = 47;
    memcpy(&a1[v8], a4, v11);
    v8 += v11;
  }
  result = 0;
  a1[v8] = 0;
  return result;
}

uint64_t concatExtractPath(char *a1, size_t a2, char *__s, const char *a4)
{
  size_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  const char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  size_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  stat v29;

  v8 = strlen(__s);
  v9 = strlen(a4);
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 278, 3, 0, "invalid dir: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  v12 = v9;
  if (v8 + v9 + 1 >= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 279, 3, 0, "dir/path too long: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  strlcpy(a1, __s, a2);
  if (!v12)
    return 0;
  v13 = 0;
  memset(&v29, 0, sizeof(v29));
  while (1)
  {
    v14 = &a4[v13];
    v15 = strchr((char *)&a4[v13], 47);
    v18 = v15 - a4;
    if (v15)
      v19 = v15 - a4;
    else
      v19 = v12;
    v20 = v19 - v13;
    if (v19 == v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 297, 3, 0, "invalid path: %s", v16, v17, (char)a4);
      return 0xFFFFFFFFLL;
    }
    v21 = v15;
    if (v20 != 2)
    {
      if (v20 == 1 && *v14 == 46)
        goto LABEL_29;
      goto LABEL_15;
    }
    if (*v14 == 46 && a4[v13 + 1] == 46)
      break;
LABEL_15:
    v22 = lstat(a1, &v29);
    if (v13)
    {
      if (v22)
      {
        if (mkdir(a1, 0x1EDu) && (lstat(a1, &v29) || (v29.st_mode & 0xF000) != 0x4000))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 326, 3, 0, "a parent of path is not a directory: %s", v25, v26, (char)a4);
          return 0xFFFFFFFFLL;
        }
      }
      else if ((v29.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 316, 3, 0, "a parent of path is not a directory: %s", v23, v24, (char)a4);
        return 0xFFFFFFFFLL;
      }
    }
    else if (v22 || (v27 = v29.st_mode & 0xF000, v27 != 0x4000) && v27 != 40960)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 311, 3, 0, "dir doesn't exist, or is invalid: %s", v23, v24, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a1[v8 - 1] != 47)
      a1[v8++] = 47;
    memcpy(&a1[v8], &a4[v13], v20);
    v8 += v20;
    a1[v8] = 0;
LABEL_29:
    if (v21)
    {
      v13 = v18 + 1;
      if (v18 + 1 < v12)
        continue;
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 304, 3, 0, "invalid path: %s", v16, v17, (char)a4);
  return 0xFFFFFFFFLL;
}

BOOL pathIsValid(_BYTE *a1, size_t __n)
{
  _BOOL8 result;
  void *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (!__n)
    return 1;
  if (__n > 0x3FF)
    return 0;
  v5 = memchr(a1, 0, __n);
  result = 0;
  if (v5)
    return result;
  if (*a1 == 47)
    return 0;
  v6 = 0;
  do
  {
    v7 = &a1[v6];
    v8 = memchr(&a1[v6], 47, __n - v6);
    if (!v8)
      break;
    v9 = v8 - a1;
    v10 = v8 - a1 - v6;
    if (v8 - a1 == v6)
      return 0;
    if (v6 && v10 == 1)
    {
      v11 = *v7;
      goto LABEL_13;
    }
    if (v10 == 2 && *v7 == 46)
    {
      v11 = a1[v6 + 1];
LABEL_13:
      if (v11 == 46)
        return 0;
    }
    v6 = v9 + 1;
  }
  while (v9 + 1 < __n);
  return v6 != __n;
}

uint64_t getTempDir(char *a1, size_t a2)
{
  const char *v4;
  size_t v6;
  size_t v7;

  if (!a2)
    return 0xFFFFFFFFLL;
  v4 = (const char *)confstr(65537, a1, a2);
  if (!v4)
  {
    if (issetugid())
    {
      v4 = 0;
    }
    else
    {
      v4 = getenv("TMPDIR");
      if (v4)
        v4 = (const char *)strlcpy(a1, v4, a2);
    }
  }
  if ((unint64_t)v4 >= a2)
    return 0xFFFFFFFFLL;
  v6 = strlen(a1);
  do
  {
    v7 = v6;
    if (!v6)
      break;
    --v6;
  }
  while (a1[v7 - 1] == 47);
  a1[v7] = 0;
  if (v7)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t isDirEmpty(const char *a1)
{
  char v1;
  DIR *v2;
  DIR *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  dirent *v13;
  dirent v14;
  uint64_t v15;

  v1 = (char)a1;
  v15 = *MEMORY[0x24BDAC8D0];
  v2 = opendir(a1);
  if (v2)
  {
    v3 = v2;
    memset(&v14, 0, 512);
    v13 = 0;
    while (1)
    {
      if (readdir_r(v3, &v14, &v13))
      {
        v8 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"isDirEmpty", 438, 3, *v8, "readdir_r", v9, v10, v12);
        v4 = 0xFFFFFFFFLL;
        goto LABEL_14;
      }
      if (!v13)
        break;
      if (v14.d_namlen != 1 || v14.d_name[0] != 46)
      {
        v4 = 0;
        if (v14.d_namlen != 2 || v14.d_name[0] != 46 || v14.d_name[1] != 46)
          goto LABEL_14;
      }
    }
    v4 = 1;
LABEL_14:
    closedir(v3);
  }
  else
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"isDirEmpty", 428, 3, *v5, "%s", v6, v7, v1);
    return 0xFFFFFFFFLL;
  }
  return v4;
}

uint64_t storeFileContents(const char *a1, uint64_t a2, unint64_t a3)
{
  char v5;
  int v6;
  int v7;
  unint64_t v8;
  size_t v9;
  ssize_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v5 = (char)a1;
  v6 = open(a1, 1537, 420);
  if (v6 < 0)
  {
    v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 535, 3, *v14, "%s", v15, v16, v5);
    v13 = 0;
  }
  else
  {
    v7 = v6;
    if (a3)
    {
      v8 = 0;
      while (1)
      {
        if (a3 - v8 >= 0x10000000)
          v9 = 0x10000000;
        else
          v9 = a3 - v8;
        v10 = write(v7, (const void *)(a2 + v8), v9);
        if (v10 < 0)
        {
          v17 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 544, 3, v17, "%s", v18, v19, v5);
          goto LABEL_14;
        }
        if (!v10)
          break;
        v8 += v10;
        if (v8 >= a3)
          goto LABEL_10;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 545, 3, 0, "write error: %s", v11, v12, v5);
LABEL_14:
      v13 = 0;
    }
    else
    {
LABEL_10:
      v13 = 1;
    }
    close(v7);
  }
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t copyFileSegment(const char *a1, unint64_t a2, unint64_t a3, const char *a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v21;

  v10 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (v10)
  {
    v13 = (char *)IFileStreamCreateWithFilename(a1, a2, a3);
    if (v13)
    {
      v16 = OFileStreamCreateWithFilename(a4, a3);
      if (v16)
      {
        if ((MemBufferTransmit(v10, a3, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OFileStreamWrite, (uint64_t)v16, v14, v15) & 0x8000000000000000) == 0)
        {
          v19 = 0;
          goto LABEL_11;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 569, 3, 0, "copy failed: %s to %s", v17, v18, (char)a1);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 566, 3, 0, "opening file: %s", v14, v15, (char)a4);
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 565, 3, 0, "opening file: %s", v11, v12, (char)a1);
      v16 = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 564, 3, 0, "mem buffer creation", v8, v9, v21);
    v16 = 0;
    v13 = 0;
  }
  v19 = 1;
LABEL_11:
  IFileStreamDestroy(v13);
  OFileStreamDestroy(v16);
  MemBufferDestroy((void **)v10);
  if (v19)
    unlink(a4);
  return (v19 << 31 >> 31);
}

uint64_t updateFileAttributes(const char *a1, uint64_t a2)
{
  uint64_t v4;
  uid_t v5;
  gid_t v6;
  __int16 v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  __uint32_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  stat v23;
  timeval v24;
  uint64_t v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v24.tv_sec = *(_QWORD *)(a2 + 32);
  v24.tv_usec = 0;
  v25 = *(_QWORD *)(a2 + 48);
  v26 = 0;
  memset(&v23, 0, sizeof(v23));
  if (stat(a1, &v23))
  {
    if (*__error() == 1)
      return 0;
    v7 = 604;
LABEL_24:
    v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", v7, 3, *v19, "%s", v20, v21, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v5 = *(_DWORD *)(a2 + 16);
  if (v23.st_uid == v5)
  {
    v6 = *(_DWORD *)(a2 + 20);
    if (v23.st_gid == v6)
      goto LABEL_11;
  }
  else
  {
    v6 = *(_DWORD *)(a2 + 20);
  }
  if (chown(a1, v5, v6) && *__error() != 1)
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 610, 3, *v8, "%s", v9, v10, (char)a1);
    v4 = 0xFFFFFFFFLL;
    goto LABEL_13;
  }
LABEL_11:
  v4 = 0;
LABEL_13:
  v11 = *(unsigned __int16 *)(a2 + 4);
  if (v23.st_mode != v11 && chmod(a1, v11 & 0xFFF) && *__error() != 1)
  {
    v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 614, 3, *v12, "%s", v13, v14, (char)a1);
    v4 = 0xFFFFFFFFLL;
  }
  v15 = *(_DWORD *)(a2 + 116) & 0xFFFFFFDF | (32 * ((v23.st_flags >> 5) & 1));
  if (v23.st_flags != v15 && chflags(a1, v15) && *__error() != 1)
  {
    v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 621, 3, *v16, "%s", v17, v18, (char)a1);
    v4 = 0xFFFFFFFFLL;
  }
  if (utimes(a1, &v24) && *__error() != 1)
  {
    v7 = 624;
    goto LABEL_24;
  }
  return v4;
}

uint64_t copyFileWithAttributes(const char *a1, const char *a2, int a3, uint64_t a4, int a5)
{
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int FileProtectionClassFD;
  off_t st_size;
  __uint32_t st_flags;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  unint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  void **v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t result;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  __int16 v52;
  char v53;
  stat v54;

  memset(&v54, 0, sizeof(v54));
  v9 = open(a1, 0);
  if (v9 < 0)
  {
    v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 645, 3, *v16, "%s", v17, v18, (char)a1);
LABEL_18:
    v24 = 0;
LABEL_19:
    v28 = 0;
LABEL_20:
    v32 = 0;
LABEL_21:
    IFileStreamDestroy(v24);
    OArchiveFileStreamDestroy((unsigned int *)v28, v44, v45, v46, v47, v48, v49, v50);
    MemBufferDestroy(v32);
    unlink(a2);
    return 0xFFFFFFFFLL;
  }
  v10 = v9;
  if (fstat(v9, &v54))
  {
    v13 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 646, 3, v13, "%s", v14, v15, (char)a1);
LABEL_17:
    close(v10);
    goto LABEL_18;
  }
  if ((v54.st_mode & 0xF000) != 0x8000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 647, 3, 0, "not a regular file: %s", v11, v12, (char)a1);
    goto LABEL_17;
  }
  FileProtectionClassFD = getFileProtectionClassFD(v10);
  close(v10);
  st_size = v54.st_size;
  st_flags = v54.st_flags;
  v24 = (char *)IFileStreamCreateWithFilename(a1, 0, v54.st_size);
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 666, 3, 0, "open failed: %s", v22, v23, (char)a1);
    goto LABEL_19;
  }
  if ((st_flags & 0x40000020) == 0x20)
    v25 = a5 | 4;
  else
    v25 = a5;
  v28 = OArchiveFileStreamCreate(a2, st_size, v25 | 8u, FileProtectionClassFD, a3);
  if (!v28)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 667, 3, 0, "open failed: %s", v26, v27, (char)a1);
    goto LABEL_20;
  }
  v29 = (unint64_t *)MemBufferCreate(0x100000uLL);
  v32 = (void **)v29;
  if (!v29)
  {
    v51 = "alloc";
    v52 = 670;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", v52, 3, 0, v51, v30, v31, v53);
    goto LABEL_21;
  }
  v33 = MemBufferTransmit(v29, st_size, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v24, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OArchiveFileStreamWrite, (uint64_t)v28, v30, v31);
  if (v33 < 0 || v33 != st_size)
  {
    v53 = v33;
    v51 = "copy failed %lld";
    v52 = 674;
    goto LABEL_28;
  }
  IFileStreamDestroy(v24);
  OArchiveFileStreamDestroy((unsigned int *)v28, v34, v35, v36, v37, v38, v39, v40);
  MemBufferDestroy(v32);
  result = updateFileAttributes(a2, (uint64_t)&v54);
  if (!(_DWORD)result)
    return result;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 690, 3, 0, "update file attributes", v42, v43, v53);
  return 0xFFFFFFFFLL;
}

uint64_t getFileProtectionClassFD(int a1)
{
  int v1;
  _QWORD v4[3];
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  v1 = fgetattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0)
    return DWORD1(v5[0]);
  else
    return 0xFFFFFFFFLL;
}

uint64_t getFileAPFSInternalFlagsFD()
{
  return 0;
}

uint64_t statIsCompressed(unsigned int a1)
{
  if ((a1 & 0x40000000) != 0)
    return 0;
  else
    return (a1 >> 5) & 1;
}

uint64_t setFileAPFSInternalFlags(uint64_t a1, uint64_t a2)
{
  if (a2)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t areFilesEqual(const char *a1, const char *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  int v14;
  int v15;
  int v16;
  int v17;
  void *v18;
  ssize_t v19;
  size_t v20;
  ssize_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  stat v38;
  stat v39;

  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  if (stat(a1, &v39))
  {
    v4 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 708, 3, v4, "%s", v5, v6, (char)a1);
LABEL_5:
    v10 = 0;
    v11 = 0;
    v12 = 0xFFFFFFFFLL;
    goto LABEL_6;
  }
  if (stat(a2, &v38))
  {
    v7 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 709, 3, v7, "%s", v8, v9, (char)a2);
    goto LABEL_5;
  }
  if ((v39.st_mode & 0xF000) != 0x8000 || (v38.st_mode & 0xF000) != 0x8000 || v39.st_size != v38.st_size)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    goto LABEL_6;
  }
  v14 = open(a1, 0);
  if (v14 < 0)
  {
    v22 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 714, 3, v22, "%s", v23, v24, (char)a1);
    goto LABEL_5;
  }
  v15 = v14;
  v16 = open(a2, 0);
  if (v16 < 0)
  {
    v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 716, 3, *v25, "%s", v26, v27, (char)a2);
    close(v15);
    goto LABEL_5;
  }
  v17 = v16;
  v11 = malloc(0x40000uLL);
  v18 = malloc(0x40000uLL);
  v10 = v18;
  if (!v11 || !v18)
  {
    v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 719, 3, *v28, "malloc", v29, v30, v37);
    close(v15);
    v12 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }
  while (1)
  {
    v19 = read(v15, v11, 0x40000uLL);
    if (v19 < 0)
    {
      v31 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 723, 3, v31, "%s read", v32, v33, (char)a1);
LABEL_26:
      v12 = 0xFFFFFFFFLL;
      goto LABEL_28;
    }
    v20 = v19;
    v21 = read(v17, v10, 0x40000uLL);
    if (v21 < 0)
    {
      v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 725, 3, v34, "%s read", v35, v36, (char)a2);
      goto LABEL_26;
    }
    if (v20 != v21)
      goto LABEL_19;
    if (!v20)
      break;
    if (memcmp(v11, v10, v20))
    {
LABEL_19:
      v12 = 0;
      goto LABEL_28;
    }
  }
  v12 = 1;
LABEL_28:
  close(v15);
  if ((v17 & 0x80000000) == 0)
LABEL_29:
    close(v17);
LABEL_6:
  free(v11);
  free(v10);
  return v12;
}

uint64_t areFilesEqual2()
{
  char *v0;
  const char *v1;
  const char *v2;
  char *v3;
  const char *v4;
  char v6[2048];
  char v7[2048];
  uint64_t v8;

  v0 = (char *)MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v8 = *MEMORY[0x24BDAC8D0];
  if (concatPath(v7, 0x800uLL, v0, v4) || concatPath(v6, 0x800uLL, v3, v2))
    return 0xFFFFFFFFLL;
  else
    return areFilesEqual(v7, v6);
}

uint64_t getFilesystemBlockSize(const char *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  statfs v6;
  uint64_t v7;

  v1 = (char)a1;
  v7 = *MEMORY[0x24BDAC8D0];
  memset(&v6, 0, 512);
  if ((statfs(a1, &v6) & 0x80000000) == 0)
    return v6.f_bsize;
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFilesystemBlockSize", 752, 3, "statfs failed: %s\n", v2, v3, v4, v1);
  return 4096;
}

uint64_t getFileDiskUsage(const char *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  off_t st_size;
  int v7;
  uint64_t v10;
  off_t v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  if (lstat(a1, &v12))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDiskUsage", 765, 3, "stat failed: %s\n", v2, v3, v4, (char)a1);
    return -1;
  }
  else
  {
    if (v12.st_blocks << 9 >= (unint64_t)v12.st_size || v12.st_blocks << 9 == 0)
      st_size = v12.st_size;
    else
      st_size = v12.st_blocks << 9;
    if ((v12.st_mode & 0xF000) == 0x8000)
    {
      v10 = 0;
      v11 = 0;
      v7 = ParallelCompressionAFSCGetMetadata(a1, &v11, (unsigned int *)&v10 + 1, &v10);
      if (HIDWORD(v10) != -1 && v7 == 0)
        return v10;
    }
  }
  return st_size;
}

uint64_t getFileProtectionClass(const char *a1)
{
  int v1;
  _QWORD v4[3];
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  v1 = getattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0)
    return DWORD1(v5[0]);
  else
    return 0xFFFFFFFFLL;
}

uint64_t getBufferSHA1Digest(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  unint64_t v6;
  CC_LONG v7;
  unint64_t v8;
  CC_LONG v9;
  CC_SHA1_CTX v11;

  memset(&v11, 0, sizeof(v11));
  CC_SHA1_Init(&v11);
  if (a2)
  {
    v6 = 0;
    v7 = a2;
    do
    {
      v8 = v6 + 0x100000;
      if (v6 + 0x100000 <= a2)
        v9 = 0x100000;
      else
        v9 = v7;
      CC_SHA1_Update(&v11, (const void *)(a1 + v6), v9);
      v7 -= 0x100000;
      v6 = v8;
    }
    while (v8 < a2);
  }
  CC_SHA1_Final(a3, &v11);
  return 0;
}

uint64_t getFileSHA1Digest(const char *a1, uint64_t a2)
{
  return getFileSegmentSHA1Digest(a1, 0, 0xFFFFFFFFFFFFFFFFLL, a2);
}

uint64_t getFileSegmentSHA1Digest(const char *a1, off_t a2, unint64_t a3, uint64_t a4)
{
  char v7;
  int v8;
  int v9;
  uint64_t FileSegmentSHA1DigestFD;
  int *v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (char)a1;
  v8 = open(a1, 0);
  if (v8 < 0)
  {
    v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1Digest", 1025, 3, *v12, "%s", v13, v14, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = v8;
    FileSegmentSHA1DigestFD = getFileSegmentSHA1DigestFD(v8, a2, a3, a4);
    close(v9);
    return FileSegmentSHA1DigestFD;
  }
}

uint64_t getFileSegmentSHA1DigestFD(int a1, off_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;
  CC_SHA1_CTX c;

  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 16) = 0;
  v24 = 1;
  if (fcntl(a1, 48))
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1044, 3, "Warning: couldn't set F_NOCACHE\n", v8, v9, v10, 1);
  memset(&c, 0, sizeof(c));
  v11 = valloc(0x100000uLL);
  if (!v11)
  {
    v18 = *__error();
    v21 = "malloc";
    v22 = 1049;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", v22, 3, v18, v21, v19, v20, v24);
LABEL_16:
    v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  CC_SHA1_Init(&c);
  if (a3)
  {
    while (1)
    {
      if (a3 >= 0x100000)
        v12 = 0x100000;
      else
        v12 = a3;
      v13 = pread(a1, v11, v12, a2);
      if ((v13 & 0x8000000000000000) != 0)
      {
        v18 = *__error();
        v21 = "read";
        v22 = 1059;
        goto LABEL_15;
      }
      v16 = v13;
      if (!v13)
        goto LABEL_12;
      if (v13 > v12)
        break;
      CC_SHA1_Update(&c, v11, v13);
      a2 += v16;
      a3 -= v16;
      if (!a3)
        goto LABEL_12;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1062, 3, 0, "error: read more bytes than requested: %zd (requested %zu)", v14, v15, v13);
    goto LABEL_16;
  }
LABEL_12:
  CC_SHA1_Final((unsigned __int8 *)a4, &c);
  v17 = 0;
LABEL_17:
  free(v11);
  return v17;
}

uint64_t enumerateTree(_QWORD *a1, char *__s)
{
  size_t v3;
  size_t v5;
  uint64_t v6;
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = strlen(__s);
  if (v3 - 1024 < 0xFFFFFFFFFFFFFBFFLL)
    return 0xFFFFFFFFLL;
  v5 = v3;
  bzero(v7, 0x400uLL);
  __memcpy_chk();
  do
  {
    v6 = v5;
    if (!v5)
      break;
    --v5;
  }
  while (v7[v6 - 1] == 47);
  v7[v6] = 0;
  return enumerateTree_rec(a1, v7, v6);
}

uint64_t removeFile(const char *a1)
{
  stat v3;

  memset(&v3, 0, sizeof(v3));
  if (lstat(a1, &v3))
    return 0;
  if ((v3.st_mode & 0xF000) == 0x4000)
    return 0xFFFFFFFFLL;
  if ((v3.st_flags & 0x20002) != 0)
    lchflags(a1, v3.st_flags & 0xFFFDFFFD);
  return unlink(a1);
}

uint64_t enumerateTree_rec(_QWORD *a1, const char *a2, uint64_t a3)
{
  const char *v6;
  DIR *v7;
  uint64_t (*v8)(_QWORD, const char *);
  uint64_t v9;
  char *v10;
  char *v11;
  size_t d_namlen;
  unint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int d_type;
  int (*v19)(_QWORD, const char *);
  _BOOL4 v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int (*v29)(_QWORD, const char *);
  char v30;
  stat v31;
  dirent *v32;
  dirent v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (a3)
    v6 = a2;
  else
    v6 = "/";
  v7 = opendir(v6);
  if (v7)
  {
    memset(&v33, 0, 512);
    v32 = 0;
    v8 = (uint64_t (*)(_QWORD, const char *))a1[1];
    if (v8 && (v8(*a1, a2) & 0x80000000) != 0)
    {
LABEL_35:
      v28 = 0;
    }
    else
    {
      v9 = a3 + 1;
      v10 = (char *)&a2[a3];
      v11 = (char *)&a2[a3 + 1];
      while (1)
      {
        if (readdir_r(v7, &v33, &v32))
        {
          v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1143, 3, *v25, "readdir_r", v26, v27, v30);
          goto LABEL_35;
        }
        if (!v32)
          break;
        d_namlen = v33.d_namlen;
        if ((v33.d_namlen != 1 || v33.d_name[0] != 46)
          && (v33.d_namlen != 2 || v33.d_name[0] != 46 || v33.d_name[1] != 46))
        {
          v13 = v9 + v33.d_namlen;
          if (v13 > 0x3FF)
            goto LABEL_35;
          *v10 = 47;
          memcpy(v11, v33.d_name, d_namlen);
          a2[v13] = 0;
          memset(&v31, 0, sizeof(v31));
          v14 = lstat(a2, &v31);
          if (v14)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1170, 3, "lstat after readdir failed (errno=%d): %s", v15, v16, v17, v14);
          }
          else if ((v31.st_flags & 0x40000000) != 0)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1175, 3, "skip dataless: %s", v15, v16, v17, (char)a2);
          }
          else
          {
            d_type = v33.d_type;
            if (!v33.d_type)
            {
              if ((v31.st_mode & 0xF000) == 0x4000)
              {
                d_type = 4;
                v33.d_type = 4;
              }
              else
              {
                d_type = 0;
              }
            }
            v19 = (int (*)(_QWORD, const char *))a1[3];
            if (v19)
            {
              v20 = v19(*a1, a2) >= 0;
              d_type = v33.d_type;
            }
            else
            {
              v20 = 1;
            }
            if (d_type == 4 && (int)enumerateTree_rec(a1, a2, v13) < 0)
              v20 = 0;
            *v10 = 0;
            if (!v20)
              goto LABEL_35;
          }
        }
      }
      v28 = 1;
    }
    closedir(v7);
    v29 = (int (*)(_QWORD, const char *))a1[2];
    if (v29 && v29(*a1, a2) < 0)
      v28 = 0;
    if (v28)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1126, 3, *v21, "%s", v22, v23, (char)a2);
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeTree(char *__s)
{
  _QWORD v2[4];

  v2[0] = 0;
  v2[1] = 0;
  v2[2] = removeLeaveDirProc;
  v2[3] = removeEntryProc;
  return enumerateTree(v2, __s);
}

uint64_t removeEntryProc(int a1, char *a2)
{
  __int16 v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  stat v8;

  memset(&v8, 0, sizeof(v8));
  if (lstat(a2, &v8))
  {
    v3 = 1247;
LABEL_3:
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeEntryProc", v3, 3, *v4, "%s", v5, v6, (char)a2);
    return 0xFFFFFFFFLL;
  }
  if ((v8.st_mode & 0xF000) == 0x4000)
    return 0;
  result = unlink(a2);
  if ((_DWORD)result)
  {
    v3 = 1250;
    goto LABEL_3;
  }
  return result;
}

uint64_t removeLeaveDirProc(int a1, char *a2)
{
  char v2;
  uint64_t result;
  int *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (char)a2;
  result = rmdir(a2);
  if ((_DWORD)result)
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeLeaveDirProc", 1258, 3, *v4, "%s", v5, v6, v2);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t statIsDataless(unsigned int a1)
{
  return (a1 >> 30) & 1;
}

uint64_t getVolumeCapabilities(const char *a1)
{
  int v2;
  int32x4_t v3;
  uint64_t result;
  int8x16_t v5;
  _OWORD v6[2];
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  statfs v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  bzero(&v11, 0x878uLL);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  if (statfs(a1, &v11) < 0)
    return -1;
  LOWORD(v8) = 5;
  LODWORD(v9) = -2147352576;
  v2 = getattrlist(v11.f_mntonname, &v8, v6, 0x24uLL, 1u);
  result = -1;
  if (!v2 && LODWORD(v6[0]) == 36)
  {
    v3.i64[0] = *(_QWORD *)((char *)v6 + 4);
    v5 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vzip1q_s32(v3, v3), (uint32x4_t)xmmword_20A40BFB0), (int8x16_t)xmmword_20A40BFC0);
    *(int8x8_t *)v5.i8 = vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    return (v5.i32[0] | v5.i32[1]);
  }
  return result;
}

uint64_t aaAssetExtractStreamSetParameterPtr(uint64_t *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  stat v18;

  if ((uint64_t (*)(uint64_t))a1[1] == closeProc_1)
  {
    v9 = (char)a3;
    v10 = *a1;
    memset(&v18, 0, sizeof(v18));
    switch(a2)
    {
      case 'e':
        result = 0;
        *(_QWORD *)(v10 + 1040) = a3;
        return result;
      case 'j':
        v14 = (const char *)(v10 + 3516);
        if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 3516)) || stat(v14, &v18) < 0 || (v18.st_mode & 0xF000) != 0x4000)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 820, 133, 0, "invalid output dir: %s", v15, v16, v9);
          return 0xFFFFFFFFLL;
        }
        break;
      case 'i':
        v11 = (const char *)(v10 + 2492);
        if (a3)
        {
          if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 2492))
            || stat(v11, &v18) < 0
            || (v18.st_mode & 0xF000) != 0x4000)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 816, 133, 0, "invalid input dir: %s", v12, v13, v9);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          memset_s((void *)(v10 + 2492), 0x400uLL, 0, 0x400uLL);
        }
        break;
      default:
        return 0xFFFFFFFFLL;
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 808, 133, 0, "invalid stream", a7, a8, v17);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc_1(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 8));
    AAHeaderDestroy(*(AAHeader *)(result + 4768));
    free(*(void **)(v1 + 4800));
    memset_s((void *)(v1 + 4784), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4824));
    memset_s((void *)(v1 + 4808), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4848));
    memset_s((void *)(v1 + 4832), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4888));
    memset_s((void *)(v1 + 4872), 0x18uLL, 0, 0x18uLL);
    AAByteStreamClose(*(AAByteStream *)(v1 + 4864));
    AAByteStreamClose(*(AAByteStream *)(v1 + 4856));
    free((void *)v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t aaAssetExtractStreamSetParameterCallback(uint64_t (**a1)(uint64_t result), int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  __int16 v10;
  uint64_t result;
  char vars0;

  if (!a1)
  {
    v9 = "NULL stream";
    v10 = 834;
    goto LABEL_5;
  }
  if (a1[1] != closeProc_1)
  {
    v9 = "invalid stream";
    v10 = 835;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterCallback", v10, 133, 0, v9, a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  if (a2 == 104)
  {
    result = 0;
    *((_QWORD *)*a1 + 131) = a3;
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t *aaAssetExtractStreamOpen(const char *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char v20;
  char v21;
  stat v22;

  memset(&v22, 0, sizeof(v22));
  v4 = malloc(0x1320uLL);
  v5 = (uint64_t)v4;
  if (!v4)
  {
    v10 = 855;
LABEL_9:
    v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"openProc", v10, 133, *v11, "malloc", v12, v13, v20);
    closeProc_1(v5);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 885, 133, 0, "create extract stream", v14, v15, v21);
    closeProc_1(0);
    return 0;
  }
  memset_s(v4, 0x1320uLL, 0, 0x1320uLL);
  v6 = (uint64_t *)malloc(0x38uLL);
  if (!v6)
  {
    v10 = 859;
    goto LABEL_9;
  }
  v7 = v6;
  memset_s(v6, 0x38uLL, 0, 0x38uLL);
  *v7 = v5;
  v7[1] = (uint64_t)closeProc_1;
  v7[4] = (uint64_t)writeHeaderProc;
  v7[5] = (uint64_t)writeBlobProc;
  v7[6] = (uint64_t)closeWithStateProc_1;
  v7[2] = (uint64_t)cancelProc_1;
  *(_QWORD *)v5 = a2;
  *(_QWORD *)(v5 + 4752) = 0x100000;
  if (!realpath_DARWIN_EXTSN(a1, (char *)(v5 + 12)))
  {
    v16 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 893, 133, v16, a1, v17, v18, v20);
    goto LABEL_12;
  }
  if (stat((const char *)(v5 + 12), &v22) || (v22.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 894, 133, 0, "Not a directory: %s", v8, v9, (char)a1);
LABEL_12:
    if (*v7)
      ((void (*)(void))v7[1])();
    free(v7);
    return 0;
  }
  __strlcpy_chk();
  return v7;
}

uint64_t *aaAssetExtractStreamOpenWithState(const char *a1, AAByteStream_impl *a2, _QWORD *a3)
{
  uint64_t *StreamOpen;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint32x4_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  uint8_t *v31;
  unint64_t v32;
  size_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  size_t v37;
  uint8_t *v38;
  size_t v39;
  ssize_t v40;
  size_t v41;
  uint64_t v42;
  size_t *p_data_size;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  size_t v48;
  void *v49;
  void *v50;
  size_t v51;
  ssize_t v52;
  size_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  size_t v59;
  void *v60;
  size_t v61;
  ssize_t v62;
  size_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  size_t v69;
  void *v70;
  size_t v71;
  ssize_t v72;
  AAHeader v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  size_t v84;
  void *v85;
  size_t v86;
  ssize_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  size_t v93;
  uint64_t v94;
  unint64_t *v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  size_t v100;
  void *v101;
  void *v102;
  size_t v103;
  ssize_t v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  int v108;
  uint64_t *result;
  char v110;
  uint64_t v111;
  unint64_t __s;
  size_t v113;
  void *__ptr;
  __int128 v115;
  uint32x4_t v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  int v120;
  size_t data_size;
  size_t v122;
  uint8_t *data;
  char v124[1024];
  uint64_t v125;

  v125 = *MEMORY[0x24BDAC8D0];
  data_size = 0;
  v122 = 0;
  data = 0;
  v120 = 0;
  v118 = 0u;
  v119 = 0u;
  v116 = 0u;
  v117 = 0u;
  v115 = 0u;
  __s = 0;
  v113 = 0;
  __ptr = 0;
  StreamOpen = aaAssetExtractStreamOpen(a1, 0);
  v8 = StreamOpen;
  if (!StreamOpen)
  {
    v14 = "create extract stream";
    v15 = 927;
    goto LABEL_225;
  }
  v9 = *StreamOpen;
  if (*((_QWORD *)a2 + 2))
  {
    v10 = 0;
    v11 = &v115;
    v12 = 84;
    while (1)
    {
      v13 = (*((uint64_t (**)(_QWORD, __int128 *, uint64_t))a2 + 2))(*(_QWORD *)a2, v11, v12);
      if (v13 < 0)
        break;
      if (v13)
      {
        v11 = (__int128 *)((char *)v11 + v13);
        v10 += v13;
        v12 -= v13;
        if (v12)
          continue;
      }
      goto LABEL_11;
    }
    v10 = v13;
LABEL_11:
    v16 = v116;
  }
  else
  {
    v10 = -1;
    v16 = 0uLL;
  }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32(v16, (uint32x4_t)xmmword_20A40BFD0))) & 1) != 0 || v10 < 0)
  {
    v14 = "invalid state";
    v15 = 935;
    goto LABEL_225;
  }
  *(_QWORD *)v9 = v115;
  v17 = v117;
  *(_QWORD *)(v9 + 4752) = *((_QWORD *)&v115 + 1);
  *(_QWORD *)(v9 + 4776) = v17;
  *(_DWORD *)(v9 + 4740) = BYTE2(v120);
  *(_DWORD *)(v9 + 4744) = HIBYTE(v120);
  *(_QWORD *)(v9 + 4760) = *((_QWORD *)&v117 + 1);
  if (!*((_QWORD *)a2 + 2))
    goto LABEL_224;
  v18 = v16.u32[0];
  if (v16.i32[0])
  {
    v19 = 0;
    v20 = v9 + 2492;
    do
    {
      v21 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v20, v18);
      if (v21 < 0)
        goto LABEL_224;
      if (!v21)
        break;
      v20 += v21;
      v19 += v21;
      v18 -= v21;
    }
    while (v18);
    if (v19 < 0 || !*((_QWORD *)a2 + 2))
      goto LABEL_224;
  }
  v22 = v116.u32[1];
  if (v116.i32[1])
  {
    v23 = 0;
    v24 = v9 + 3516;
    do
    {
      v25 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v24, v22);
      if (v25 < 0)
        goto LABEL_224;
      if (!v25)
        break;
      v24 += v25;
      v23 += v25;
      v22 -= v25;
    }
    while (v22);
    if (v23 < 0)
      goto LABEL_224;
  }
  if (!*((_QWORD *)a2 + 2))
    goto LABEL_224;
  v26 = v116.u32[2];
  if (v116.i32[2])
  {
    v27 = 0;
    v28 = v9 + 4540;
    do
    {
      v29 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v28, v26);
      if (v29 < 0)
        goto LABEL_224;
      if (!v29)
        break;
      v28 += v29;
      v27 += v29;
      v26 -= v29;
    }
    while (v26);
    if (v27 < 0)
      goto LABEL_224;
  }
  v30 = v116.u32[3];
  if (v116.i32[3])
  {
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    do
    {
      if (v33 != v32)
        goto LABEL_47;
      v35 = v32 + 0x40000;
      if ((uint64_t)(v32 + 0x40000) < 0)
        goto LABEL_224;
      if (v32 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v32)
          {
            v32 = 0x4000;
            v37 = 0x4000;
            if (v35 <= 0x4000)
              goto LABEL_49;
          }
          v36 = v32 >> 1;
          if ((v32 & (v32 >> 1)) != 0)
            v36 = v32 & (v32 >> 1);
          v32 += v36;
        }
        while (v32 < v35);
        v37 = v32;
        if (v32 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_187;
        }
LABEL_49:
        v38 = (uint8_t *)realloc(v31, v37);
        if (!v38)
        {
          free(v31);
LABEL_187:
          p_data_size = &data_size;
          goto LABEL_223;
        }
        v122 = v37;
        data = v38;
        v31 = v38;
      }
      else
      {
LABEL_47:
        v37 = v32;
      }
      if (v37 - v33 >= v30)
        v39 = v30;
      else
        v39 = v37 - v33;
      v40 = AAByteStreamRead(a2, &v31[v33], v39);
      if (v40 < 0)
        goto LABEL_224;
      if (!v40)
        break;
      v33 = data_size + v40;
      if (__CFADD__(data_size, v40))
        goto LABEL_224;
      v32 = v122;
      if (v33 > v122)
        goto LABEL_224;
      data_size += v40;
      v34 += v40;
      v30 -= v40;
    }
    while (v30);
    if (v34 < 0)
      goto LABEL_224;
  }
  v41 = *((_QWORD *)&v118 + 1);
  if (!*((_QWORD *)&v118 + 1))
    goto LABEL_86;
  v42 = 0;
  p_data_size = (size_t *)(v9 + 4784);
  v44 = *(_QWORD *)(v9 + 4784);
  v45 = *(_QWORD *)(v9 + 4792);
  do
  {
    if (v44 != v45)
      goto LABEL_73;
    v46 = v45 + 0x40000;
    if ((uint64_t)(v45 + 0x40000) < 0)
      goto LABEL_224;
    if (v45 > 0xFFFFFFFFFFFBFFFFLL)
    {
      v44 = v45;
LABEL_73:
      v48 = v45;
      goto LABEL_77;
    }
    do
    {
      while (!v45)
      {
        v45 = 0x4000;
        v48 = 0x4000;
        if (v46 <= 0x4000)
          goto LABEL_75;
      }
      v47 = v45 >> 1;
      if ((v45 & (v45 >> 1)) != 0)
        v47 = v45 & (v45 >> 1);
      v45 += v47;
    }
    while (v45 < v46);
    v48 = v45;
    if (v45 >= 0x2000000001)
    {
LABEL_222:
      *__error() = 12;
      goto LABEL_223;
    }
LABEL_75:
    v49 = *(void **)(v9 + 4800);
    v50 = realloc(v49, v48);
    if (!v50)
    {
LABEL_185:
      free(v49);
LABEL_223:
      *p_data_size = 0;
      p_data_size[1] = 0;
      p_data_size[2] = 0;
      goto LABEL_224;
    }
    *(_QWORD *)(v9 + 4800) = v50;
    *(_QWORD *)(v9 + 4792) = v48;
    v44 = *(_QWORD *)(v9 + 4784);
LABEL_77:
    if (v48 - v44 >= v41)
      v51 = v41;
    else
      v51 = v48 - v44;
    v52 = AAByteStreamRead(a2, (void *)(*(_QWORD *)(v9 + 4800) + v44), v51);
    if (v52 < 0)
      goto LABEL_224;
    if (!v52)
      break;
    v44 = *p_data_size + v52;
    if (!__CFADD__(*p_data_size, v52))
    {
      v45 = *(_QWORD *)(v9 + 4792);
      if (v44 <= v45)
        continue;
    }
    goto LABEL_224;
    *p_data_size = v44;
    v42 += v52;
    v41 -= v52;
  }
  while (v41);
  if (v42 < 0)
    goto LABEL_224;
LABEL_86:
  v53 = v119;
  if (!(_QWORD)v119)
    goto LABEL_112;
  v54 = 0;
  p_data_size = (size_t *)(v9 + 4808);
  v55 = *(_QWORD *)(v9 + 4808);
  v56 = *(_QWORD *)(v9 + 4816);
  while (2)
  {
    if (v55 != v56)
      goto LABEL_99;
    v57 = v56 + 0x40000;
    if ((uint64_t)(v56 + 0x40000) < 0)
      goto LABEL_224;
    if (v56 > 0xFFFFFFFFFFFBFFFFLL)
    {
      v55 = v56;
LABEL_99:
      v59 = v56;
      goto LABEL_103;
    }
    do
    {
      while (!v56)
      {
        v56 = 0x4000;
        v59 = 0x4000;
        if (v57 <= 0x4000)
          goto LABEL_101;
      }
      v58 = v56 >> 1;
      if ((v56 & (v56 >> 1)) != 0)
        v58 = v56 & (v56 >> 1);
      v56 += v58;
    }
    while (v56 < v57);
    v59 = v56;
    if (v56 >= 0x2000000001)
      goto LABEL_222;
LABEL_101:
    v49 = *(void **)(v9 + 4824);
    v60 = realloc(v49, v59);
    if (!v60)
      goto LABEL_185;
    *(_QWORD *)(v9 + 4824) = v60;
    *(_QWORD *)(v9 + 4816) = v59;
    v55 = *(_QWORD *)(v9 + 4808);
LABEL_103:
    if (v59 - v55 >= v53)
      v61 = v53;
    else
      v61 = v59 - v55;
    v62 = AAByteStreamRead(a2, (void *)(*(_QWORD *)(v9 + 4824) + v55), v61);
    if (v62 < 0)
      goto LABEL_224;
    if (v62)
    {
      v55 = *p_data_size + v62;
      if (__CFADD__(*p_data_size, v62))
        goto LABEL_224;
      v56 = *(_QWORD *)(v9 + 4816);
      if (v55 > v56)
        goto LABEL_224;
      *p_data_size = v55;
      v54 += v62;
      v53 -= v62;
      if (v53)
        continue;
    }
    break;
  }
  if (v54 < 0)
    goto LABEL_224;
LABEL_112:
  v63 = *((_QWORD *)&v119 + 1);
  if (*((_QWORD *)&v119 + 1))
  {
    v64 = 0;
    p_data_size = (size_t *)(v9 + 4832);
    v65 = *(_QWORD *)(v9 + 4832);
    v66 = *(_QWORD *)(v9 + 4840);
    while (1)
    {
      if (v65 == v66)
      {
        v67 = v66 + 0x40000;
        if ((uint64_t)(v66 + 0x40000) < 0)
          goto LABEL_224;
        if (v66 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v66)
            {
              v66 = 0x4000;
              v69 = 0x4000;
              if (v67 <= 0x4000)
                goto LABEL_127;
            }
            v68 = v66 >> 1;
            if ((v66 & (v66 >> 1)) != 0)
              v68 = v66 & (v66 >> 1);
            v66 += v68;
          }
          while (v66 < v67);
          v69 = v66;
          if (v66 >= 0x2000000001)
            goto LABEL_222;
LABEL_127:
          v49 = *(void **)(v9 + 4848);
          v70 = realloc(v49, v69);
          if (!v70)
            goto LABEL_185;
          *(_QWORD *)(v9 + 4848) = v70;
          *(_QWORD *)(v9 + 4840) = v69;
          v65 = *(_QWORD *)(v9 + 4832);
          goto LABEL_129;
        }
        v65 = v66;
      }
      v69 = v66;
LABEL_129:
      if (v69 - v65 >= v63)
        v71 = v63;
      else
        v71 = v69 - v65;
      v72 = AAByteStreamRead(a2, (void *)(*(_QWORD *)(v9 + 4848) + v65), v71);
      if (v72 < 0)
        goto LABEL_224;
      if (!v72)
        goto LABEL_137;
      v65 = *p_data_size + v72;
      if (__CFADD__(*p_data_size, v72))
        goto LABEL_224;
      v66 = *(_QWORD *)(v9 + 4840);
      if (v65 > v66)
        goto LABEL_224;
      *p_data_size = v65;
      v64 += v72;
      v63 -= v72;
      if (!v63)
      {
LABEL_137:
        if ((v64 & 0x8000000000000000) == 0)
          break;
LABEL_224:
        v14 = "write state";
        v15 = 953;
        goto LABEL_225;
      }
    }
  }
  *(_BYTE *)(v9 + v116.u32[0] + 2492) = 0;
  *(_BYTE *)(v9 + v116.u32[1] + 3516) = 0;
  *(_BYTE *)(v9 + v116.u32[2] + 4540) = 0;
  if (v116.i32[3])
  {
    v73 = AAHeaderCreateWithEncodedData(data_size, data);
    *(_QWORD *)(v9 + 4768) = v73;
    if (!v73)
    {
      v14 = "invalid header in state";
      v15 = 959;
      goto LABEL_225;
    }
  }
  if (!BYTE1(v120))
  {
    v93 = v118;
    if (!(_QWORD)v118)
      goto LABEL_214;
    v94 = 0;
    v95 = (unint64_t *)(v9 + 4872);
    v96 = *(_QWORD *)(v9 + 4872);
    v97 = *(_QWORD *)(v9 + 4880);
    while (1)
    {
      if (v96 != v97)
        goto LABEL_201;
      v98 = v97 + 0x40000;
      if ((uint64_t)(v97 + 0x40000) < 0)
        goto LABEL_252;
      if (v97 > 0xFFFFFFFFFFFBFFFFLL)
        break;
      do
      {
        while (!v97)
        {
          v97 = 0x4000;
          v100 = 0x4000;
          if (v98 <= 0x4000)
            goto LABEL_203;
        }
        v99 = v97 >> 1;
        if ((v97 & (v97 >> 1)) != 0)
          v99 = v97 & (v97 >> 1);
        v97 += v99;
      }
      while (v97 < v98);
      v100 = v97;
      if (v97 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_251;
      }
LABEL_203:
      v101 = *(void **)(v9 + 4888);
      v102 = realloc(v101, v100);
      if (!v102)
      {
        free(v101);
LABEL_251:
        *v95 = 0;
        *(_QWORD *)(v9 + 4880) = 0;
        *(_QWORD *)(v9 + 4888) = 0;
        goto LABEL_252;
      }
      *(_QWORD *)(v9 + 4888) = v102;
      *(_QWORD *)(v9 + 4880) = v100;
      v96 = *(_QWORD *)(v9 + 4872);
LABEL_205:
      if (v100 - v96 >= v93)
        v103 = v93;
      else
        v103 = v100 - v96;
      v104 = AAByteStreamRead(a2, (void *)(*(_QWORD *)(v9 + 4888) + v96), v103);
      if (v104 < 0)
        goto LABEL_252;
      if (!v104)
        goto LABEL_213;
      v96 = *v95 + v104;
      if (__CFADD__(*v95, v104))
        goto LABEL_252;
      v97 = *(_QWORD *)(v9 + 4880);
      if (v96 > v97)
        goto LABEL_252;
      *v95 = v96;
      v94 += v104;
      v93 -= v104;
      if (!v93)
      {
LABEL_213:
        if ((v94 & 0x8000000000000000) == 0)
          goto LABEL_214;
LABEL_252:
        v14 = "truncated state";
        v15 = 983;
LABEL_225:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpenWithState", v15, 133, 0, v14, v6, v7, v110);
        goto LABEL_226;
      }
    }
    v96 = v97;
LABEL_201:
    v100 = v97;
    goto LABEL_205;
  }
  v74 = AATempFileStreamOpenWithDirectory((const char *)(v9 + 12));
  *(_QWORD *)(v9 + 4864) = v74;
  if (!v74)
  {
    v14 = "create temp file";
    v15 = 965;
    goto LABEL_225;
  }
  v75 = v118;
  if (!(_QWORD)v118)
    goto LABEL_214;
  v76 = 0;
  while (2)
  {
    __s = 0;
    v111 = v76;
    v77 = v75 - v76;
    if (v77 >= 0x40000)
      v78 = 0x40000;
    else
      v78 = v77;
    if (!v78)
    {
LABEL_243:
      v75 = v118;
      v76 = v111;
      break;
    }
    v79 = 0;
    v80 = 0;
    v81 = v113;
    while (2)
    {
      if (v79 == v81)
      {
        v82 = v81 + 0x40000;
        if ((uint64_t)(v81 + 0x40000) < 0)
          goto LABEL_248;
        if (v81 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v81)
            {
              v81 = 0x4000;
              v84 = 0x4000;
              if (v82 <= 0x4000)
                goto LABEL_160;
            }
            v83 = v81 >> 1;
            if ((v81 & (v81 >> 1)) != 0)
              v83 = v81 & (v81 >> 1);
            v81 += v83;
          }
          while (v81 < v82);
          v84 = v81;
          if (v81 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_247;
          }
LABEL_160:
          v85 = realloc(__ptr, v84);
          if (v85)
          {
            v113 = v84;
            __ptr = v85;
            v81 = v84;
            goto LABEL_162;
          }
          free(__ptr);
LABEL_247:
          __s = 0;
          v113 = 0;
          __ptr = 0;
          goto LABEL_248;
        }
      }
LABEL_162:
      if (v81 - v79 >= v78)
        v86 = v78;
      else
        v86 = v81 - v79;
      v87 = AAByteStreamRead(a2, (char *)__ptr + v79, v86);
      if (v87 < 0)
        goto LABEL_248;
      if (!v87)
        break;
      v88 = __CFADD__(v79, v87);
      v79 += v87;
      if (v88 || v79 > v81)
        goto LABEL_248;
      __s = v79;
      v80 += v87;
      v78 -= v87;
      if (v78)
        continue;
      break;
    }
    if (v80 < 0)
    {
LABEL_248:
      v14 = "reading state";
      v15 = 973;
      goto LABEL_225;
    }
    if (!v80)
      goto LABEL_243;
    v89 = *(_QWORD *)(v9 + 4864);
    if (*(_QWORD *)(v89 + 24))
    {
      v90 = 0;
      if (v79)
      {
        v91 = (char *)__ptr;
        while (1)
        {
          v92 = (*(uint64_t (**)(_QWORD, char *, unint64_t))(v89 + 24))(*(_QWORD *)v89, v91, v79);
          if (v92 < 1)
            break;
          v91 += v92;
          v90 += v92;
          v79 -= v92;
          if (!v79)
            goto LABEL_180;
        }
        v90 = v92;
      }
    }
    else
    {
      v90 = -1;
    }
LABEL_180:
    if (v90 != v80)
    {
      v14 = "write DAT file";
      v15 = 976;
      goto LABEL_225;
    }
    v76 = v80 + v111;
    v75 = v118;
    if (v80 + v111 < (unint64_t)v118)
      continue;
    break;
  }
  if (v76 != v75)
  {
    v14 = "truncated state";
    v15 = 979;
    goto LABEL_225;
  }
LABEL_214:
  if ((updateFromHeader((_BYTE *)v9) & 0x80000000) != 0)
  {
    v14 = "deriving fields from header";
    v15 = 987;
    goto LABEL_225;
  }
  if ((_BYTE)v120)
  {
    if (!*(_DWORD *)(v9 + 1056))
    {
      v14 = "missing PAT";
      v15 = 995;
      goto LABEL_225;
    }
    if ((concatExtractPath(v124, 0x400uLL, (char *)(v9 + 3516), (const char *)(v9 + 1064)) & 0x80000000) == 0)
    {
      v107 = aaArchiveFileOutputStreamOpenAtWithState(-1, v124, a2, a3);
      *(_QWORD *)(v9 + 4856) = v107;
      if (!v107)
      {
        v14 = "aaArchiveFileOutputStreamOpenAtWithState";
        v15 = 1000;
        goto LABEL_225;
      }
      goto LABEL_219;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpenWithState", 996, 133, 0, "invalid PAT: %s", v105, v106, v9 + 40);
LABEL_226:
    v108 = 0;
  }
  else
  {
LABEL_219:
    if (a3)
      *a3 = -1;
    v108 = 1;
  }
  free(data);
  memset_s(&data_size, 0x18uLL, 0, 0x18uLL);
  free(__ptr);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v108)
    result = v8;
  else
    result = 0;
  if (v8 && (v108 & 1) == 0)
  {
    if (*v8)
      ((void (*)(void))v8[1])();
    free(v8);
    return 0;
  }
  return result;
}

uint64_t updateFromHeader(_BYTE *a1)
{
  char *v2;
  AAHeader_impl *v3;
  AAFieldKey v4;
  uint32_t KeyIndex;
  uint64_t v6;
  uint64_t v7;
  unsigned int FieldUInt;
  int v9;
  AAHeader_impl *v10;
  AAFieldKey v11;
  uint32_t v12;
  unsigned int FieldString;
  int v14;
  AAHeader_impl *v15;
  AAFieldKey v16;
  uint32_t v17;
  unsigned int FieldBlob;
  int v19;
  AAHeader_impl *v20;
  AAFieldKey v21;
  uint32_t v22;
  unsigned int v23;
  int v24;
  AAHeader_impl *v25;
  AAFieldKey v26;
  uint32_t v27;
  unsigned int v28;
  int v29;
  AAHeader_impl *v30;
  AAFieldKey v31;
  uint32_t v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  AAHeader_impl *v36;
  AAFieldKey v37;
  uint32_t v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  const char *v42;
  __int16 v43;
  uint64_t result;
  char v45;
  uint64_t v46;
  uint64_t offset;
  uint64_t size;
  size_t length;

  size = 0;
  length = 0;
  v46 = 0;
  offset = 0;
  *((_QWORD *)a1 + 132) = 0;
  v2 = a1 + 2112;
  *((_QWORD *)a1 + 261) = 0;
  *((_QWORD *)a1 + 263) = 0;
  *((_QWORD *)a1 + 262) = 0;
  memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
  memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
  memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
  memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
  v3 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  if (!v3)
    return 0;
  v4.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(*((AAHeader *)a1 + 596), v4);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(v3, KeyIndex, (uint64_t *)a1 + 261), FieldUInt <= 1)
      ? (v9 = 1)
      : (v9 = FieldUInt),
        v9 <= 0))
  {
    v42 = "missing TYP";
    v43 = 141;
LABEL_46:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"updateFromHeader", v43, 133, 0, v42, v6, v7, v46);
    return 0xFFFFFFFFLL;
  }
  if ((aaEntryAttributesInitWithHeader(v2, a1 + 2184, a1 + 2240, *((AAHeader *)a1 + 596)) & 0x80000000) != 0)
  {
    v42 = "attributes from header";
    v43 = 142;
    goto LABEL_46;
  }
  v10 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  v11.ikey = 5521744;
  v12 = AAHeaderGetKeyIndex(v10, v11);
  if ((v12 & 0x80000000) == 0)
  {
    FieldString = AAHeaderGetFieldString(v10, v12, 0x400uLL, a1 + 1064, &length);
    v14 = FieldString <= 1 ? 1 : FieldString;
    if (v14 >= 1)
      *((_DWORD *)a1 + 264) = 1;
  }
  v15 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  v16.ikey = 4408665;
  v17 = AAHeaderGetKeyIndex(v15, v16);
  if ((v17 & 0x80000000) == 0)
  {
    FieldBlob = AAHeaderGetFieldBlob(v15, v17, &size, &offset);
    v19 = FieldBlob <= 1 ? 1 : FieldBlob;
    if (v19 >= 1)
    {
      a1[2416] |= 1u;
      *((_QWORD *)a1 + 304) = size;
    }
  }
  v20 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  v21.ikey = 5521752;
  v22 = AAHeaderGetKeyIndex(v20, v21);
  if ((v22 & 0x80000000) == 0)
  {
    v23 = AAHeaderGetFieldBlob(v20, v22, &size, &offset);
    v24 = v23 <= 1 ? 1 : v23;
    if (v24 >= 1)
    {
      a1[2416] |= 2u;
      *((_QWORD *)a1 + 306) = size;
    }
  }
  v25 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  v26.ikey = 4997953;
  v27 = AAHeaderGetKeyIndex(v25, v26);
  if ((v27 & 0x80000000) == 0)
  {
    v28 = AAHeaderGetFieldBlob(v25, v27, &size, &offset);
    v29 = v28 <= 1 ? 1 : v28;
    if (v29 >= 1)
    {
      a1[2416] |= 4u;
      *((_QWORD *)a1 + 308) = size;
    }
  }
  v30 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
  v31.ikey = 5521732;
  v32 = AAHeaderGetKeyIndex(v30, v31);
  if ((v32 & 0x80000000) == 0)
  {
    v33 = AAHeaderGetFieldBlob(v30, v32, &size, &offset);
    v34 = v33 <= 1 ? 1 : v33;
    if (v34 >= 1)
    {
      *((_DWORD *)a1 + 265) = 1;
      *((_QWORD *)a1 + 263) = size;
    }
  }
  v35 = *((_QWORD *)a1 + 595);
  *((_QWORD *)a1 + 262) = v35;
  if (!v35)
  {
    v36 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
    v37.ikey = 5263193;
    v38 = AAHeaderGetKeyIndex(v36, v37);
    if ((v38 & 0x80000000) != 0
      || ((v39 = AAHeaderGetFieldUInt(v36, v38, &v46), v39 <= 1) ? (v40 = 1) : (v40 = v39), v40 < 1))
    {
      v41 = *((_QWORD *)a1 + 262);
    }
    else
    {
      v41 = v46;
      *((_QWORD *)a1 + 262) = v46;
    }
    if (!v41 && *((_QWORD *)a1 + 261) != 77)
      *((_QWORD *)a1 + 262) = 69;
  }
  *((_QWORD *)a1 + 310) = 40;
  *((_DWORD *)a1 + 618) = -1;
  *((_DWORD *)a1 + 622) = -1;
  if ((a1[2112] & 4) != 0)
  {
    v45 = a1[2184];
    if ((a1[2124] & 0x20) != 0)
    {
      *((_QWORD *)a1 + 310) = 44;
      *((_DWORD *)a1 + 622) = 0;
      if ((v45 & 1) != 0)
        *((_DWORD *)a1 + 622) = *((_DWORD *)a1 + 548);
    }
  }
  else
  {
    v45 = a1[2184];
  }
  if ((v45 & 8) != 0)
  {
    result = 0;
    *((_DWORD *)a1 + 618) = *((_DWORD *)a1 + 547);
    return result;
  }
  return 0;
}

uint64_t closeWithStateProc_1(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  AAHeader_impl *v15;
  uint64_t v16;
  uint64_t v17;
  AAByteStream_impl *v18;
  off_t v19;
  char v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  AAHeader_impl *v34;
  const uint8_t *EncodedData;
  uint64_t v36;
  const uint8_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  off_t v60;
  unint64_t v61;
  unint64_t v62;
  size_t v63;
  char *v64;
  size_t v65;
  ssize_t v66;
  unint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  const char *v71;
  __int16 v72;
  void *v73;
  void *v74;
  void *v75;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t (**v81)(void);
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  AAByteStream_impl *s;
  unint64_t __s;
  size_t v88;
  void *v89;
  _QWORD v90[2];
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  __int128 v97;
  __int128 v98;
  int v99;

  if (atomic_load((unsigned int *)a1 + 2))
    return 0xFFFFFFFFLL;
  v99 = 0;
  v97 = 0u;
  v98 = 0u;
  __s = 0;
  v88 = 0;
  v8 = *a1;
  v9 = a1[594];
  v89 = 0;
  v90[0] = v8;
  v90[1] = v9;
  v10 = (uint64_t)a1 + 2492;
  v91 = strlen((const char *)a1 + 2492);
  v11 = (uint64_t)a1 + 3516;
  v92 = strlen((const char *)a1 + 3516);
  v12 = (uint64_t)a1 + 4540;
  v93 = strlen((const char *)a1 + 4540);
  BYTE2(v99) = *((_DWORD *)a1 + 1185);
  HIBYTE(v99) = *((_DWORD *)a1 + 1186);
  v15 = (AAHeader_impl *)a1[596];
  if (v15)
    LODWORD(v15) = AAHeaderGetEncodedSize(v15);
  v94 = v15;
  v16 = a1[595];
  v95 = a1[597];
  v96 = v16;
  v17 = a1[601];
  *((_QWORD *)&v97 + 1) = a1[598];
  *(_QWORD *)&v98 = v17;
  *((_QWORD *)&v98 + 1) = a1[604];
  v18 = (AAByteStream_impl *)a1[608];
  if (v18)
  {
    v19 = AAByteStreamSeek(v18, 0, 2);
    v20 = 1;
  }
  else
  {
    v20 = 0;
    v19 = a1[609];
  }
  BYTE1(v99) = v20;
  *(_QWORD *)&v97 = v19;
  LOBYTE(v99) = a1[607] != 0;
  if (!a2[3])
    goto LABEL_120;
  v21 = 0;
  v22 = v90;
  v23 = 84;
  do
  {
    v24 = ((uint64_t (*)(_QWORD, _QWORD *, uint64_t))a2[3])(*a2, v22, v23);
    if (v24 < 1)
    {
      if ((v24 & 0x8000000000000000) == 0)
        goto LABEL_15;
      goto LABEL_120;
    }
    v22 = (_QWORD *)((char *)v22 + v24);
    v21 += v24;
    v23 -= v24;
  }
  while (v23);
  if (v21 < 0)
    goto LABEL_120;
LABEL_15:
  if (!a2[3])
    goto LABEL_120;
  v25 = v91;
  if (!v91)
    goto LABEL_24;
  v26 = 0;
  while (2)
  {
    v27 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v10, v25);
    if (v27 < 1)
    {
      if ((v27 & 0x8000000000000000) == 0)
        goto LABEL_23;
      goto LABEL_120;
    }
    v10 += v27;
    v26 += v27;
    v25 -= v27;
    if (v25)
      continue;
    break;
  }
  if (v26 < 0)
    goto LABEL_120;
LABEL_23:
  if (!a2[3])
  {
LABEL_120:
    v71 = "write state";
    v72 = 747;
    goto LABEL_121;
  }
LABEL_24:
  v28 = v92;
  if (v92)
  {
    v29 = 0;
    while (1)
    {
      v30 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v11, v28);
      if (v30 < 1)
        break;
      v11 += v30;
      v29 += v30;
      v28 -= v30;
      if (!v28)
        goto LABEL_30;
    }
    v29 = v30;
LABEL_30:
    if (v29 < 0)
      goto LABEL_120;
  }
  if (!a2[3])
    goto LABEL_120;
  v31 = v93;
  if (v93)
  {
    v32 = 0;
    while (1)
    {
      v33 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v12, v31);
      if (v33 < 1)
        break;
      v12 += v33;
      v32 += v33;
      v31 -= v33;
      if (!v31)
        goto LABEL_38;
    }
    v32 = v33;
LABEL_38:
    if (v32 < 0)
      goto LABEL_120;
  }
  v34 = (AAHeader_impl *)a1[596];
  if (!v34)
    goto LABEL_48;
  EncodedData = AAHeaderGetEncodedData(v34);
  if (!a2[3])
    goto LABEL_120;
  v36 = v94;
  if (!v94)
    goto LABEL_49;
  v37 = EncodedData;
  v38 = 0;
  while (1)
  {
    v39 = ((uint64_t (*)(_QWORD, const uint8_t *, uint64_t))a2[3])(*a2, v37, v36);
    if (v39 < 1)
      break;
    v37 += v39;
    v38 += v39;
    v36 -= v39;
    if (!v36)
      goto LABEL_47;
  }
  v38 = v39;
LABEL_47:
  if (v38 < 0)
    goto LABEL_120;
LABEL_48:
  if (!a2[3])
    goto LABEL_120;
LABEL_49:
  v40 = *((_QWORD *)&v97 + 1);
  if (*((_QWORD *)&v97 + 1))
  {
    v41 = 0;
    v42 = a1[600];
    while (1)
    {
      v43 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v42, v40);
      if (v43 < 1)
        break;
      v42 += v43;
      v41 += v43;
      v40 -= v43;
      if (!v40)
        goto LABEL_55;
    }
    v41 = v43;
LABEL_55:
    if (v41 < 0)
      goto LABEL_120;
  }
  if (!a2[3])
    goto LABEL_120;
  v44 = v98;
  if ((_QWORD)v98)
  {
    v45 = 0;
    v46 = a1[603];
    while (1)
    {
      v47 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v46, v44);
      if (v47 < 1)
        break;
      v46 += v47;
      v45 += v47;
      v44 -= v47;
      if (!v44)
        goto LABEL_63;
    }
    v45 = v47;
LABEL_63:
    if (v45 < 0 || !a2[3])
      goto LABEL_120;
  }
  v48 = *((_QWORD *)&v98 + 1);
  if (*((_QWORD *)&v98 + 1))
  {
    v49 = 0;
    v50 = a1[606];
    while (1)
    {
      v51 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v50, v48);
      if (v51 < 1)
        break;
      v50 += v51;
      v49 += v51;
      v48 -= v51;
      if (!v48)
        goto LABEL_71;
    }
    v49 = v51;
LABEL_71:
    if (v49 < 0)
      goto LABEL_120;
  }
  if (!a1[608])
  {
    if (a2[3])
    {
      v77 = v97;
      if (!(_QWORD)v97)
        goto LABEL_133;
      v78 = 0;
      v79 = a1[611];
      while (1)
      {
        v80 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v79, v77);
        if (v80 < 1)
          break;
        v79 += v80;
        v78 += v80;
        v77 -= v80;
        if (!v77)
          goto LABEL_132;
      }
      v78 = v80;
LABEL_132:
      if ((v78 & 0x8000000000000000) == 0)
        goto LABEL_133;
    }
    v71 = "write state";
    v72 = 769;
    goto LABEL_121;
  }
  v52 = v97;
  if (!(_QWORD)v97)
    goto LABEL_133;
  v85 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  while (2)
  {
    __s = 0;
    v56 = v52 - v55;
    if (v56 >= 0x40000)
      v57 = 0x40000;
    else
      v57 = v56;
    if (!v57)
    {
LABEL_142:
      v52 = v97;
      break;
    }
    v58 = 0;
    v59 = 0;
    s = (AAByteStream_impl *)a1[608];
    v84 = v55;
    v60 = v55;
    while (2)
    {
      if (v58 == v54)
      {
        v61 = v54 + 0x40000;
        if ((uint64_t)(v54 + 0x40000) < 0)
          goto LABEL_147;
        if (v54 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v54)
            {
              v54 = 0x4000;
              v63 = 0x4000;
              if (v61 <= 0x4000)
                goto LABEL_93;
            }
            v62 = v54 >> 1;
            if ((v54 & (v54 >> 1)) != 0)
              v62 = v54 & (v54 >> 1);
            v54 += v62;
          }
          while (v54 < v61);
          v63 = v54;
          if (v54 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_146;
          }
LABEL_93:
          v64 = (char *)realloc(v53, v63);
          if (v64)
          {
            v88 = v63;
            v89 = v64;
            v85 = v64;
            v58 = __s;
            goto LABEL_95;
          }
          free(v53);
LABEL_146:
          __s = 0;
          v88 = 0;
          v89 = 0;
          goto LABEL_147;
        }
        v58 = v54;
      }
      v63 = v54;
      v64 = v53;
LABEL_95:
      if (v63 - v58 >= v57)
        v65 = v57;
      else
        v65 = v63 - v58;
      v53 = v64;
      v66 = AAByteStreamPRead(s, &v64[v58], v65, v60);
      if (v66 < 0)
        goto LABEL_147;
      if (v66)
      {
        v58 = __s + v66;
        if (__CFADD__(__s, v66))
          goto LABEL_147;
        v54 = v88;
        if (v58 > v88)
          goto LABEL_147;
        __s += v66;
        v59 += v66;
        v60 += v66;
        v57 -= v66;
        if (!v57)
          goto LABEL_105;
        continue;
      }
      break;
    }
    v54 = v63;
LABEL_105:
    if (v59 < 0)
    {
LABEL_147:
      v71 = "reading DAT file";
      v72 = 759;
      goto LABEL_121;
    }
    v55 = v84;
    if (!v59)
      goto LABEL_142;
    if (a2[3])
    {
      v67 = __s;
      if (__s)
      {
        v68 = 0;
        v69 = v85;
        while (1)
        {
          v70 = ((uint64_t (*)(_QWORD, char *, unint64_t))a2[3])(*a2, v69, v67);
          if (v70 < 1)
            break;
          v69 += v70;
          v68 += v70;
          v67 -= v70;
          if (!v67)
          {
            v53 = v85;
            goto LABEL_116;
          }
        }
        v53 = v85;
        v68 = v70;
LABEL_116:
        v55 = v84;
      }
      else
      {
        v68 = 0;
        v53 = v85;
      }
    }
    else
    {
      v68 = -1;
    }
    if (v68 != v59)
    {
      v71 = "write state";
      v72 = 762;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"closeWithStateProc", v72, 133, 0, v71, v13, v14, v84);
      v4 = 0xFFFFFFFFLL;
      v73 = a1 + 604;
      goto LABEL_122;
    }
    v55 += v59;
    v52 = v97;
    if (v55 < (unint64_t)v97)
      continue;
    break;
  }
  if (v55 != v52)
  {
    v71 = "truncated DAT file";
    v72 = 765;
    goto LABEL_121;
  }
LABEL_133:
  v81 = (uint64_t (**)(void))a1[607];
  if (!v81)
  {
    v73 = a1 + 604;
    goto LABEL_138;
  }
  v73 = a1 + 604;
  if ((AAByteStreamCloseWithState(v81) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"closeWithStateProc", 775, 133, 0, "write state", v82, v83, v84);
    a1[607] = 0;
    v4 = 0xFFFFFFFFLL;
LABEL_122:
    v75 = a1 + 598;
    v74 = a1 + 601;
    goto LABEL_123;
  }
  a1[607] = 0;
LABEL_138:
  v75 = a1 + 598;
  v74 = a1 + 601;
  v4 = 0;
  if (a3)
    *a3 = -1;
LABEL_123:
  free(v89);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy((AAHeader)a1[596]);
  free((void *)a1[600]);
  memset_s(v75, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[603]);
  memset_s(v74, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[606]);
  memset_s(v73, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[611]);
  memset_s(a1 + 609, 0x18uLL, 0, 0x18uLL);
  AAByteStreamClose((AAByteStream)a1[608]);
  AAByteStreamClose((AAByteStream)a1[607]);
  free(a1);
  return v4;
}

uint64_t writeHeaderProc(uint64_t a1, AAHeader header)
{
  unsigned int *v2;
  AAFieldKey v7;
  uint32_t KeyIndex;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  AAFieldKey v13;
  uint32_t v14;
  unsigned int FieldString;
  int v16;
  uint64_t (*v17)(_QWORD, uint64_t, char *, _QWORD);
  int v18;
  const char *v19;
  __int16 v20;
  AAFieldKey v22;
  uint32_t v23;
  unsigned int FieldUInt;
  int v25;
  AAFieldKey v26;
  uint32_t v27;
  uint64_t *v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t (*v42)(_QWORD, uint64_t, uint64_t, uint64_t *);
  int v43;
  AAFieldKey v44;
  int v45;
  uint32_t v46;
  size_t v47;
  AAFieldKey v48;
  char v49;
  size_t length;
  uint64_t value;
  uint64_t v52[128];
  char __s1[200];
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v2 = (unsigned int *)(a1 + 8);
  if (!atomic_load((unsigned int *)(a1 + 8)))
  {
    length = 0;
    value = 0;
    v7.ikey = 5265748;
    KeyIndex = AAHeaderGetKeyIndex(header, v7);
    if ((KeyIndex & 0x80000000) != 0
      || ((v11 = AAHeaderGetFieldUInt(header, KeyIndex, &value), v11 <= 1) ? (v12 = 1) : (v12 = v11), v12 <= 0))
    {
      v19 = "missing TYP";
      v20 = 569;
    }
    else
    {
      v13.ikey = 4997708;
      v14 = AAHeaderGetKeyIndex(header, v13);
      if ((v14 & 0x80000000) == 0)
      {
        FieldString = AAHeaderGetFieldString(header, v14, 0xC8uLL, __s1, &length);
        v16 = FieldString <= 1 ? 1 : FieldString;
        if (v16 >= 1)
        {
          if (strcmp(__s1, (const char *)(a1 + 4540)))
          {
            __strlcpy_chk();
            *(_DWORD *)(a1 + 4740) = 0;
            v17 = *(uint64_t (**)(_QWORD, uint64_t, char *, _QWORD))(a1 + 1048);
            if (v17)
            {
              v18 = v17(*(_QWORD *)(a1 + 1040), 90, __s1, 0);
              if (v18 < 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"updateLabel", 205, 133, 0, "Caller cancelled", v9, v10, v49);
                v19 = "updating label";
                v20 = 571;
                goto LABEL_22;
              }
              if (v18)
                *(_DWORD *)(a1 + 4740) = 1;
            }
          }
        }
      }
      if (*(_DWORD *)(a1 + 4740))
        return 0;
      if (value != 77)
        goto LABEL_85;
      v52[0] = 0;
      v22.ikey = 5263193;
      v23 = AAHeaderGetKeyIndex(header, v22);
      if ((v23 & 0x80000000) != 0)
        goto LABEL_85;
      FieldUInt = AAHeaderGetFieldUInt(header, v23, v52);
      v25 = FieldUInt <= 1 ? 1 : FieldUInt;
      if (v25 < 1)
        goto LABEL_85;
      if (v52[0] == 93)
      {
        *(_QWORD *)(a1 + 4760) = 0;
        return 0;
      }
      if (v52[0] == 91)
      {
        v26.ikey = 5328729;
        v27 = AAHeaderGetKeyIndex(header, v26);
        if ((v27 & 0x80000000) == 0)
        {
          v28 = (uint64_t *)(a1 + 4760);
          v29 = AAHeaderGetFieldUInt(header, v27, v28);
          v30 = v29 <= 1 ? 1 : v29;
          if (v30 >= 1 && *v28)
            return 0;
        }
        v19 = "expected valid YOQ field";
        v20 = 584;
      }
      else
      {
LABEL_85:
        if (*(_QWORD *)(a1 + 4864)
          || *(_QWORD *)(a1 + 4856)
          || *(_QWORD *)(a1 + 4768)
          || *(_QWORD *)(a1 + 4872)
          || *(_QWORD *)(a1 + 4784)
          || *(_QWORD *)(a1 + 4808)
          || *(_QWORD *)(a1 + 4832))
        {
          v19 = "invalid extractor state (blobs)";
          v20 = 603;
        }
        else
        {
          *(_QWORD *)(a1 + 4768) = AAHeaderClone(header);
          *(_QWORD *)(a1 + 4776) = AAHeaderGetPayloadSize(header);
          if ((updateFromHeader((_BYTE *)a1) & 0x80000000) != 0)
          {
            v19 = "extract entry attributes from header";
            v20 = 610;
          }
          else
          {
            if (*(_QWORD *)(a1 + 2096) == 77)
            {
              v36 = (_DWORD *)(a1 + 1056);
            }
            else
            {
              if (!*(_DWORD *)(a1 + 4744))
              {
                v19 = "invalid AssetArchive stream (missing manifest)";
                v20 = 616;
                goto LABEL_22;
              }
              v36 = (_DWORD *)(a1 + 1056);
              if (*(_DWORD *)(a1 + 1056))
              {
                v42 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *))(a1 + 1048);
                if (v42)
                {
                  LOBYTE(v52[0]) = 0;
                  v43 = v42(*(_QWORD *)(a1 + 1040), 91, a1 + 1064, v52);
                  if (v43 < 0)
                  {
                    v19 = "Caller cancelled";
                    v20 = 626;
                    goto LABEL_22;
                  }
                  if (v43)
                  {
                    __strlcpy_chk();
                    v44.ikey = 5521744;
                    v45 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 4768), v44);
                    if (v45 < 0)
                    {
                      v19 = "no PAT field in header";
                      v20 = 632;
                      goto LABEL_22;
                    }
                    v46 = v45;
                    v47 = strlen((const char *)(a1 + 1064));
                    v48.ikey = 5521744;
                    if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 4768), v46, v48, (const char *)(a1 + 1064), v47) < 0)
                    {
                      v19 = "set PAT";
                      v20 = 633;
                      goto LABEL_22;
                    }
                  }
                }
              }
            }
            if (*(_QWORD *)(a1 + 2088) == 70 && *(_QWORD *)(a1 + 2096) == 69)
            {
              if (!*v36)
              {
                v19 = "missing PAT";
                v20 = 640;
                goto LABEL_22;
              }
              if ((concatExtractPath((char *)v52, 0x400uLL, (char *)(a1 + 3516), (const char *)(a1 + 1064)) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeHeaderProc", 641, 133, 0, "invalid PAT: %s", v37, v38, a1 + 40);
LABEL_23:
                while (!__ldaxr(v2))
                {
                  if (!__stlxr(1u, v2))
                    return 0xFFFFFFFFLL;
                }
                __clrex();
                return 0xFFFFFFFFLL;
              }
              v39 = strlen((const char *)v52);
              makePath((const char *)v52, v39);
              v40 = aaArchiveFileOutputStreamOpenAt(-1, (const char *)v52, *(_QWORD *)(a1 + 2104), *(_DWORD *)(a1 + 2488), 0, *(_DWORD *)(a1 + 2472), *(_QWORD *)(a1 + 2480));
              *(_QWORD *)(a1 + 4856) = v40;
              if (!v40)
              {
                v19 = "file stream";
                v20 = 647;
                goto LABEL_22;
              }
            }
            if (!*(_DWORD *)(a1 + 1060)
              || *(_QWORD *)(a1 + 4856)
              || *(_QWORD *)(a1 + 2104) < *(_QWORD *)(a1 + 4752)
              || (v41 = AATempFileStreamOpenWithDirectory((const char *)(a1 + 12)), (*(_QWORD *)(a1 + 4864) = v41) != 0))
            {
              if (*(_QWORD *)(a1 + 4776)
                || (processEntry_0((_BYTE *)a1, v31, v32, v33, v34, v35, v9, v10) & 0x80000000) == 0)
              {
                return 0;
              }
              v19 = "entry processing";
              v20 = 658;
            }
            else
            {
              v19 = "temp stream";
              v20 = 654;
            }
          }
        }
      }
    }
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeHeaderProc", v20, 133, 0, v19, v9, v10, v49);
    goto LABEL_23;
  }
  return 0xFFFFFFFFLL;
}

uint64_t writeBlobProc(uint64_t a1, size_t a2, uint64_t __src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  _QWORD *v20;
  size_t v21;
  size_t v22;
  void **v23;
  _QWORD *v24;
  uint64_t v25;
  rsize_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  size_t v31;
  uint64_t v32;
  unint64_t v33;
  size_t v34;
  size_t v35;
  uint64_t v36;
  rsize_t v37;
  uint64_t v38;
  unint64_t v39;
  size_t v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  void *v45;
  rsize_t v46;
  void *v48;
  void *v49;
  size_t v50;
  void *v51;
  char v52;

  v8 = (unsigned int *)(a1 + 8);
  if (atomic_load((unsigned int *)(a1 + 8)))
    return 0xFFFFFFFFLL;
  result = 0;
  if (!__smax || *(_DWORD *)(a1 + 4740))
    return result;
  if (*(_QWORD *)(a1 + 4776) < __smax)
  {
    v13 = "blob size mismatch";
    v14 = 672;
    goto LABEL_93;
  }
  if (!*(_QWORD *)(a1 + 4768))
  {
    v13 = "invalid state";
    v14 = 673;
    goto LABEL_93;
  }
  v15 = (char *)__src;
  result = 0;
  v16 = a2 & 0xFFFFFF;
  if ((a2 & 0xFFFFFF) > 0x544143)
  {
    if (v16 == 5521752)
    {
      v32 = *(_QWORD *)(a1 + 4808);
      v18 = __CFADD__(v32, __smax);
      v33 = v32 + __smax;
      if (!v18 && (v33 & 0x8000000000000000) == 0)
      {
        v20 = (_QWORD *)(a1 + 4808);
        v34 = *(_QWORD *)(a1 + 4816);
        if (v34 < v33)
        {
          do
          {
            while (!v34)
            {
              v34 = 0x4000;
              if (v33 <= 0x4000)
              {
                v23 = (void **)(a1 + 4824);
                v34 = 0x4000;
                goto LABEL_84;
              }
            }
            v35 = v34 >> 1;
            if ((v34 & (v34 >> 1)) != 0)
              v35 = v34 & (v34 >> 1);
            v34 += v35;
          }
          while (v34 < v33);
          v23 = (void **)(a1 + 4824);
          if (v34 >= 0x2000000001)
          {
LABEL_83:
            *__error() = 12;
            goto LABEL_100;
          }
LABEL_84:
          v41 = *v23;
          v45 = realloc(*v23, v34);
          if (!v45)
            goto LABEL_98;
          *(_QWORD *)(a1 + 4824) = v45;
          *(_QWORD *)(a1 + 4816) = v34;
        }
        v43 = *(_QWORD *)(a1 + 4824);
        if (!v15)
          goto LABEL_80;
        goto LABEL_87;
      }
    }
    else
    {
      if (v16 != 5521732)
        return result;
      v24 = *(_QWORD **)(a1 + 4856);
      if (v24)
      {
        if (!v24[3])
          goto LABEL_68;
        v25 = 0;
        v26 = __smax;
        while (1)
        {
          v27 = ((uint64_t (*)(_QWORD, char *, rsize_t))v24[3])(*v24, v15, v26);
          if (v27 < 1)
            break;
          v15 += v27;
          v25 += v27;
          v26 -= v27;
          if (!v26)
            goto LABEL_69;
        }
LABEL_57:
        v25 = v27;
LABEL_69:
        if (v25 == __smax)
          goto LABEL_89;
        v13 = "store blob";
        v14 = 688;
LABEL_93:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeBlobProc", v14, 133, 0, v13, a7, a8, v52);
        while (!__ldaxr(v8))
        {
          if (!__stlxr(1u, v8))
            return 0xFFFFFFFFLL;
        }
        __clrex();
        return 0xFFFFFFFFLL;
      }
      v36 = *(_QWORD *)(a1 + 4864);
      if (!v36)
      {
        v38 = *(_QWORD *)(a1 + 4872);
        v18 = __CFADD__(v38, __smax);
        v39 = v38 + __smax;
        if (!v18 && (v39 & 0x8000000000000000) == 0)
        {
          v20 = (_QWORD *)(a1 + 4872);
          a2 = *(_QWORD *)(a1 + 4880);
          if (a2 < v39)
          {
            do
            {
              while (!a2)
              {
                a2 = 0x4000;
                if (v39 <= 0x4000)
                {
                  v23 = (void **)(a1 + 4888);
                  a2 = 0x4000;
                  goto LABEL_102;
                }
              }
              v40 = a2 >> 1;
              if ((a2 & (a2 >> 1)) != 0)
                v40 = a2 & (a2 >> 1);
              a2 += v40;
            }
            while (a2 < v39);
            v23 = (void **)(a1 + 4888);
            if (a2 >= 0x2000000001)
              goto LABEL_83;
LABEL_102:
            v49 = *v23;
            v50 = a2;
            v51 = realloc(*v23, a2);
            if (!v51)
            {
              v48 = v49;
LABEL_99:
              free(v48);
LABEL_100:
              *v23 = 0;
              v25 = -1;
              *v20 = 0;
              v20[1] = 0;
              goto LABEL_69;
            }
            *(_QWORD *)(a1 + 4888) = v51;
            *(_QWORD *)(a1 + 4880) = v50;
          }
          v43 = *(_QWORD *)(a1 + 4888);
          if (!v15)
          {
LABEL_80:
            if (v43)
              memset_s((void *)(v43 + *v20), __smax, 0, __smax);
            goto LABEL_88;
          }
LABEL_87:
          memcpy((void *)(v43 + *v20), v15, __smax);
LABEL_88:
          *v20 += __smax;
LABEL_89:
          v46 = *(_QWORD *)(a1 + 4776) - __smax;
          *(_QWORD *)(a1 + 4776) = v46;
          if (v46 || (processEntry_0((_BYTE *)a1, a2, __src, __smax, a5, a6, a7, a8) & 0x80000000) == 0)
            return 0;
          v13 = "entry processing";
          v14 = 693;
          goto LABEL_93;
        }
        goto LABEL_68;
      }
      if (*(_QWORD *)(v36 + 24))
      {
        v25 = 0;
        v37 = __smax;
        while (1)
        {
          v27 = (*(uint64_t (**)(_QWORD, char *, rsize_t))(v36 + 24))(*(_QWORD *)v36, v15, v37);
          if (v27 < 1)
            goto LABEL_57;
          v15 += v27;
          v25 += v27;
          v37 -= v27;
          if (!v37)
            goto LABEL_69;
        }
      }
    }
LABEL_68:
    v25 = -1;
    goto LABEL_69;
  }
  if (v16 == 4408665)
  {
    v28 = *(_QWORD *)(a1 + 4784);
    v18 = __CFADD__(v28, __smax);
    v29 = v28 + __smax;
    if (!v18 && (v29 & 0x8000000000000000) == 0)
    {
      v20 = (_QWORD *)(a1 + 4784);
      v30 = *(_QWORD *)(a1 + 4792);
      if (v30 >= v29)
        goto LABEL_79;
      do
      {
        while (!v30)
        {
          v30 = 0x4000;
          if (v29 <= 0x4000)
          {
            v23 = (void **)(a1 + 4800);
            v30 = 0x4000;
            goto LABEL_77;
          }
        }
        v31 = v30 >> 1;
        if ((v30 & (v30 >> 1)) != 0)
          v31 = v30 & (v30 >> 1);
        v30 += v31;
      }
      while (v30 < v29);
      v23 = (void **)(a1 + 4800);
      if (v30 >= 0x2000000001)
        goto LABEL_83;
LABEL_77:
      v41 = *v23;
      v44 = realloc(*v23, v30);
      if (v44)
      {
        *(_QWORD *)(a1 + 4800) = v44;
        *(_QWORD *)(a1 + 4792) = v30;
LABEL_79:
        v43 = *(_QWORD *)(a1 + 4800);
        if (!v15)
          goto LABEL_80;
        goto LABEL_87;
      }
LABEL_98:
      v48 = v41;
      goto LABEL_99;
    }
    goto LABEL_68;
  }
  if (v16 == 4997953)
  {
    v17 = *(_QWORD *)(a1 + 4832);
    v18 = __CFADD__(v17, __smax);
    v19 = v17 + __smax;
    if (!v18 && (v19 & 0x8000000000000000) == 0)
    {
      v20 = (_QWORD *)(a1 + 4832);
      v21 = *(_QWORD *)(a1 + 4840);
      if (v21 >= v19)
        goto LABEL_74;
      do
      {
        while (!v21)
        {
          v21 = 0x4000;
          if (v19 <= 0x4000)
          {
            v23 = (void **)(a1 + 4848);
            v21 = 0x4000;
            goto LABEL_72;
          }
        }
        v22 = v21 >> 1;
        if ((v21 & (v21 >> 1)) != 0)
          v22 = v21 & (v21 >> 1);
        v21 += v22;
      }
      while (v21 < v19);
      v23 = (void **)(a1 + 4848);
      if (v21 >= 0x2000000001)
        goto LABEL_83;
LABEL_72:
      v41 = *v23;
      v42 = realloc(*v23, v21);
      if (v42)
      {
        *(_QWORD *)(a1 + 4848) = v42;
        *(_QWORD *)(a1 + 4840) = v21;
LABEL_74:
        v43 = *(_QWORD *)(a1 + 4848);
        if (!v15)
          goto LABEL_80;
        goto LABEL_87;
      }
      goto LABEL_98;
    }
    goto LABEL_68;
  }
  return result;
}

uint64_t cancelProc_1(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 8);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

uint64_t processEntry_0(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  char *v10;
  int v11;
  _BOOL4 v12;
  uint64_t v13;
  char *v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  _QWORD *v26;
  AAByteStream_impl *v27;
  int v28;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint32_t FieldCount;
  uint64_t v39;
  uint64_t v40;
  uint32_t v41;
  uint32_t v42;
  uint64_t v43;
  AAFieldKey FieldKey;
  BOOL v47;
  int v48;
  char *v49;
  size_t v50;
  uint32_t v51;
  char v52;
  char v53;
  char v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int **v62;
  int FD;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t DataSize;
  AAHeader_impl *v69;
  AAFieldKey v70;
  uint32_t KeyIndex;
  unsigned int FieldString;
  int v73;
  uint64_t v74;
  uint64_t v75;
  AAByteStream_impl *v76;
  const char *v77;
  __int16 v78;
  size_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  __int16 v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  __int16 v96;
  _QWORD *v97;
  char *v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  AAHashFunction hash_function;
  stat v106;
  size_t length;
  uint8_t value[16];
  __int128 v109;
  __int128 v110;
  __int128 v111;
  char __s[16];
  _OWORD v113[63];
  char v114[16];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;

  v127 = *MEMORY[0x24BDAC8D0];
  length = 0;
  memset(&v106, 0, sizeof(v106));
  hash_function = 0;
  v110 = 0u;
  v111 = 0u;
  *(_OWORD *)value = 0u;
  v109 = 0u;
  v9 = *(_QWORD *)a1;
  v10 = a1 + 2492;
  v11 = a1[2492];
  if (a1[2492])
    v12 = strcmp(a1 + 2492, a1 + 3516) == 0;
  else
    v12 = 0;
  if ((v9 & 2) != 0)
    v13 = 0x20000000000001;
  else
    v13 = 0x20000000000000;
  v14 = a1 + 2416;
  v15 = a1[2416];
  if ((v15 & 1) != 0)
  {
    if (*((_QWORD *)a1 + 304) != *((_QWORD *)a1 + 598))
    {
      v24 = "blob size mismatch";
      v25 = 235;
      goto LABEL_31;
    }
    *((_QWORD *)a1 + 303) = *((_QWORD *)a1 + 600);
  }
  if ((v15 & 2) != 0)
  {
    if (*((_QWORD *)a1 + 306) != *((_QWORD *)a1 + 601))
    {
      v24 = "blob size mismatch";
      v25 = 240;
      goto LABEL_31;
    }
    *((_QWORD *)a1 + 305) = *((_QWORD *)a1 + 603);
  }
  if ((v15 & 4) != 0)
  {
    if (*((_QWORD *)a1 + 308) != *((_QWORD *)a1 + 604))
    {
      v24 = "blob size mismatch";
      v25 = 245;
      goto LABEL_31;
    }
    *((_QWORD *)a1 + 307) = *((_QWORD *)a1 + 606);
  }
  v16 = *((_QWORD *)a1 + 262);
  v17 = v9 >> 62;
  switch(v16)
  {
    case 'C':
      if (!*((_DWORD *)a1 + 264))
      {
        v24 = "missing PAT";
        v25 = 398;
        break;
      }
      if (!v11)
      {
        v24 = "no input dir";
        v25 = 399;
        break;
      }
      if (v17 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Copy %c %s\n", (char)a1[2088], a1 + 1064);
      if (v12)
        goto LABEL_39;
      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 402, 133, 0, "invalid PAT: %s", v18, v19, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 403, 133, 0, "invalid PAT: %s", v20, v21, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if ((aaCopyFile(v114, __s, v13) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 404, 133, 0, "copy file: %s", v22, v23, (char)__s);
        goto LABEL_32;
      }
      if (*((_QWORD *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        v24 = "apply YEC (copy)";
        v25 = 406;
        break;
      }
      goto LABEL_39;
    case 'E':
      if (!*((_DWORD *)a1 + 264))
      {
        v24 = "missing PAT";
        v25 = 262;
        break;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 263, 133, 0, "invalid PAT: %s", v30, v31, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if (v17 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Extract %c %s\n", (char)a1[2088], a1 + 1064);
      v32 = strlen(__s);
      makePath(__s, v32);
      v33 = *((_QWORD *)a1 + 261);
      switch(v33)
      {
        case 'L':
          v69 = (AAHeader_impl *)*((_QWORD *)a1 + 596);
          v70.ikey = 4935244;
          KeyIndex = AAHeaderGetKeyIndex(v69, v70);
          if ((KeyIndex & 0x80000000) != 0
            || ((FieldString = AAHeaderGetFieldString(v69, KeyIndex, 0x400uLL, v114, &length), FieldString <= 1)
              ? (v73 = 1)
              : (v73 = FieldString),
                v73 <= 0))
          {
            v24 = "missing LNK";
            v25 = 279;
            goto LABEL_31;
          }
          unlink(__s);
          if ((symlink(v114, __s) & 0x80000000) == 0)
            goto LABEL_39;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 281, 133, 0, "creating symlink: %s", v74, v75, (char)__s);
          goto LABEL_32;
        case 'F':
          v76 = (AAByteStream_impl *)*((_QWORD *)a1 + 607);
          if (!v76)
          {
            v24 = "no file stream";
            v25 = 286;
            goto LABEL_31;
          }
          AAByteStreamClose(v76);
          *((_QWORD *)a1 + 607) = 0;
          if (*((_QWORD *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
          {
            v24 = "apply YEC (extract)";
            v25 = 288;
            goto LABEL_31;
          }
          break;
        case 'D':
          unlink(__s);
          if (mkdir(__s, 0x1EDu) < 0 && (*__error() != 17 || stat(__s, &v106) || (v106.st_mode & 0xF000) != 0x4000))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 274, 133, 0, "creating dir: %s", v34, v35, (char)__s);
            goto LABEL_32;
          }
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 292, 133, 0, "Unsupported entry type (extract): %c\n", a7, a8, v33);
          goto LABEL_32;
      }
      goto LABEL_39;
    case 'I':
      if (!*((_DWORD *)a1 + 264))
      {
        v24 = "missing PAT";
        v25 = 425;
        break;
      }
      if (!v11)
      {
        v24 = "no input dir";
        v25 = 426;
        break;
      }
      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 427, 133, 0, "invalid PAT: %s", v36, v37, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if (v17 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Src check %c %s\n", (char)a1[2088], a1 + 1064);
      FieldCount = AAHeaderGetFieldCount(*((AAHeader *)a1 + 596));
      *(_OWORD *)__s = 0u;
      memset(v113, 0, 156);
      if (!FieldCount)
        goto LABEL_183;
      v41 = FieldCount;
      v42 = 0;
      v43 = 0;
      do
      {
        if (AAHeaderGetFieldType(*((AAHeader *)a1 + 596), v42) != 3)
        {
          v48 = 0;
          goto LABEL_96;
        }
        FieldKey = AAHeaderGetFieldKey(*((AAHeader *)a1 + 596), v42);
        if (!v43)
        {
          v51 = FieldKey.ikey & 0xFFFFFF;
          if ((FieldKey.ikey & 0xFFFFFF) == 0x324853)
          {
            v43 = 0x2000;
          }
          else if (v51 == 3491923)
          {
            v43 = 0x8000;
          }
          else
          {
            if (v51 != 3360851)
            {
              v48 = 0;
              v43 = 0;
              goto LABEL_96;
            }
            v43 = 0x4000;
          }
        }
        if (!*(_DWORD *)__s && (aaEntryHashesInitWithPath(__s, v43, v10, a1 + 1064) & 0x80000000) != 0)
        {
          v98 = v114;
          v77 = "computing file digest: %s";
          v78 = 454;
          goto LABEL_206;
        }
        if (AAHeaderGetFieldHash(*((AAHeader *)a1 + 596), v42, 0x40uLL, &hash_function, value) < 0)
        {
          v77 = "retrieving digest from header";
          v78 = 458;
LABEL_206:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v78, 133, 0, v77, v39, v40, (char)v98);
          goto LABEL_207;
        }
        if ((__s[0] & 4) != 0 && hash_function == 3)
        {
          v47 = *(_QWORD *)((char *)v113 + 12) == *(_QWORD *)value
             && *(_QWORD *)((char *)&v113[1] + 4) == *(_QWORD *)&value[8]
             && *(_QWORD *)((char *)&v113[1] + 12) == (_QWORD)v109
             && *(_QWORD *)((char *)&v113[2] + 4) == *((_QWORD *)&v109 + 1);
          goto LABEL_93;
        }
        if ((__s[0] & 8) != 0 && hash_function == 4)
        {
          v49 = (char *)&v113[2] + 12;
          v50 = 48;
          goto LABEL_92;
        }
        v48 = 0;
        if ((__s[0] & 0x10) != 0 && hash_function == 5)
        {
          v49 = (char *)&v113[5] + 12;
          v50 = 64;
LABEL_92:
          v47 = memcmp(v49, value, v50) == 0;
LABEL_93:
          v48 = v47;
        }
LABEL_96:
        ++v42;
      }
      while (v42 < v41 && !v48);
      if ((v48 & 1) != 0)
      {
LABEL_128:
        v28 = 1;
        goto LABEL_208;
      }
LABEL_183:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 465, 133, 0, "patch doesn't match source file: %s", v39, v40, (char)v114);
LABEL_207:
      v28 = 0;
LABEL_208:
      v26 = 0;
LABEL_209:
      v27 = 0;
LABEL_34:
      AAHeaderDestroy(*((AAHeader *)a1 + 596));
      *((_QWORD *)a1 + 596) = 0;
      AAByteStreamClose(*((AAByteStream *)a1 + 608));
      *((_QWORD *)a1 + 608) = 0;
      AAByteStreamClose(*((AAByteStream *)a1 + 607));
      *((_QWORD *)a1 + 607) = 0;
      *((_QWORD *)a1 + 609) = 0;
      *((_QWORD *)a1 + 598) = 0;
      *((_QWORD *)a1 + 601) = 0;
      *((_QWORD *)a1 + 604) = 0;
      memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
      memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
      memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
      memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
      AAByteStreamClose(v27);
      MappedBufferDestroy(v26);
      if (v28)
        return 0;
      else
        return 0xFFFFFFFFLL;
    case 'M':
      v26 = 0;
      v27 = 0;
      v28 = 1;
      *((_DWORD *)a1 + 1186) = 1;
      goto LABEL_34;
    case 'O':
      if (!*((_DWORD *)a1 + 264))
      {
        v24 = "missing PAT";
        v25 = 472;
        break;
      }
      if (v17 < 2)
        goto LABEL_127;
      v126 = 0;
      v125 = 0u;
      v124 = 0u;
      v123 = 0u;
      v122 = 0u;
      v121 = 0u;
      v120 = 0u;
      v119 = 0u;
      v118 = 0u;
      v117 = 0u;
      v116 = 0u;
      v115 = 0u;
      *(_OWORD *)v114 = 0u;
      v52 = a1[2112];
      if ((v52 & 1) != 0)
      {
        __strlcat_chk();
        v52 = a1[2112];
        if ((v52 & 2) == 0)
        {
LABEL_107:
          if ((v52 & 8) == 0)
            goto LABEL_108;
          goto LABEL_150;
        }
      }
      else if ((a1[2112] & 2) == 0)
      {
        goto LABEL_107;
      }
      __strlcat_chk();
      v52 = a1[2112];
      if ((v52 & 8) == 0)
      {
LABEL_108:
        if ((v52 & 4) == 0)
          goto LABEL_109;
        goto LABEL_151;
      }
LABEL_150:
      __strlcat_chk();
      v52 = a1[2112];
      if ((v52 & 4) == 0)
      {
LABEL_109:
        if ((v52 & 0x40) == 0)
          goto LABEL_110;
        goto LABEL_152;
      }
LABEL_151:
      __strlcat_chk();
      v52 = a1[2112];
      if ((v52 & 0x40) == 0)
      {
LABEL_110:
        if ((v52 & 0x10) == 0)
          goto LABEL_111;
        goto LABEL_153;
      }
LABEL_152:
      __strlcat_chk();
      v52 = a1[2112];
      if ((v52 & 0x10) == 0)
      {
LABEL_111:
        if ((v52 & 0x20) == 0)
          goto LABEL_113;
        goto LABEL_112;
      }
LABEL_153:
      __strlcat_chk();
      if ((a1[2112] & 0x20) != 0)
LABEL_112:
        __strlcat_chk();
LABEL_113:
      v53 = a1[2184];
      if ((v53 & 2) != 0)
      {
        __strlcat_chk();
        v53 = a1[2184];
        if ((v53 & 1) == 0)
        {
LABEL_115:
          if ((v53 & 8) == 0)
            goto LABEL_116;
          goto LABEL_157;
        }
      }
      else if ((a1[2184] & 1) == 0)
      {
        goto LABEL_115;
      }
      __strlcat_chk();
      v53 = a1[2184];
      if ((v53 & 8) == 0)
      {
LABEL_116:
        if ((v53 & 4) == 0)
          goto LABEL_118;
        goto LABEL_117;
      }
LABEL_157:
      __strlcat_chk();
      if ((a1[2184] & 4) == 0)
      {
LABEL_118:
        v54 = a1[2240];
        if ((v54 & 4) != 0)
        {
          __strlcat_chk();
          v54 = a1[2240];
          if ((v54 & 8) == 0)
          {
LABEL_120:
            if ((v54 & 0x10) == 0)
              goto LABEL_122;
            goto LABEL_121;
          }
        }
        else if ((a1[2240] & 8) == 0)
        {
          goto LABEL_120;
        }
        __strlcat_chk();
        if ((a1[2240] & 0x10) == 0)
        {
LABEL_122:
          v55 = *v14;
          if ((*v14 & 1) != 0)
          {
            __strlcat_chk();
            v55 = *v14;
            if ((*v14 & 2) == 0)
            {
LABEL_124:
              if ((v55 & 4) == 0)
                goto LABEL_126;
              goto LABEL_125;
            }
          }
          else if ((*v14 & 2) == 0)
          {
            goto LABEL_124;
          }
          __strlcat_chk();
          if ((*v14 & 4) == 0)
          {
LABEL_126:
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Dst fixup %c%s %s\n", (char)a1[2088], v114, a1 + 1064);
LABEL_127:
            *(_QWORD *)v114 = 0;
            if ((aaCheckAndFixWithPath(a1 + 2112, a1 + 2184, a1 + 2240, a1 + 2416, -1, (unsigned int *)v114, a1 + 3516, a1 + 1064, v13) & 0x80000000) == 0)goto LABEL_128;
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 503, 133, 0, "fixup failed: %s", v56, v57, (char)__s);
            goto LABEL_207;
          }
LABEL_125:
          __strlcat_chk();
          goto LABEL_126;
        }
LABEL_121:
        __strlcat_chk();
        goto LABEL_122;
      }
LABEL_117:
      __strlcat_chk();
      goto LABEL_118;
    case 'P':
      if (!*((_DWORD *)a1 + 264))
      {
        v24 = "missing PAT";
        v25 = 301;
        break;
      }
      if (v17 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Patch %s\n", a1 + 1064);
      if (!v11)
      {
        v24 = "no input dir";
        v25 = 303;
        break;
      }
      if (*((_QWORD *)a1 + 607))
      {
        v24 = "file stream already opened";
        v25 = 304;
        break;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 305, 133, 0, "invalid PAT: %s", v60, v61, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      v103 = 0;
      v104 = 0;
      v62 = (unsigned int **)*((_QWORD *)a1 + 608);
      if (v62)
      {
        FD = aaFileStreamGetFD(v62);
        v64 = MappedBufferCreateWithFD(FD, 0, 0xFFFFFFFFFFFFFFFFLL);
        v26 = v64;
        if (!v64)
        {
          v89 = "mapping patch file";
          v90 = 316;
          goto LABEL_230;
        }
        v67 = (_QWORD *)BXDiffMatchesOBuf((uint64_t)v64);
        DataSize = MappedBufferGetDataSize((uint64_t)v26);
      }
      else
      {
        v26 = 0;
        v67 = (_QWORD *)*((_QWORD *)a1 + 611);
        DataSize = *((_QWORD *)a1 + 609);
      }
      v79 = strlen(__s);
      makePath(__s, v79);
      if (DataSize < 9 || *v67 != 0x3031464649444952)
      {
        if ((BXDiff5GetPatchInfo((uint64_t)v67, DataSize, (uint64_t)&v103) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          v89 = "invalid patch: %s";
          v90 = 353;
        }
        else if ((_DWORD)v104)
        {
          v86 = aaArchiveFileOutputStreamOpenAt(-1, __s, v103, *((_DWORD *)a1 + 622), 0, *((_DWORD *)a1 + 618), *((_QWORD *)a1 + 310));
          *((_QWORD *)a1 + 607) = v86;
          if (v86)
          {
            if ((BXPatch5StreamWithFlags(0, 0, 0, (uint64_t)v67, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc, (uint64_t)v86, 2) & 0x80000000) == 0)
            {
LABEL_198:
              AAByteStreamClose(*((AAByteStream *)a1 + 607));
              *((_QWORD *)a1 + 607) = 0;
              goto LABEL_199;
            }
            v98 = __s;
            v89 = "patching failed: %s";
            v90 = 364;
          }
          else
          {
            v89 = "file stream";
            v90 = 359;
          }
        }
        else if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          v89 = "invalid PAT: %s";
          v90 = 371;
        }
        else if (v12)
        {
          if (HIDWORD(v104))
          {
            if ((BXPatch5InPlace(__s, (uint64_t)v67, DataSize, 0, v91, v92, v65, v66) & 0x80000000) == 0)
            {
LABEL_199:
              MappedBufferDestroy(v26);
              if (!*((_QWORD *)a1 + 598) || (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) == 0)
              {
                v26 = 0;
                v28 = 1;
                goto LABEL_209;
              }
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 392, 133, 0, "apply YEC (patch)", v87, v88, (char)v98);
              v26 = 0;
              goto LABEL_232;
            }
            v89 = "in-place patching failed";
            v90 = 376;
          }
          else
          {
            v89 = "patch doesn't allow in-place";
            v90 = 375;
          }
        }
        else
        {
          v97 = aaArchiveFileOutputStreamOpenAt(-1, __s, v103, *((_DWORD *)a1 + 622), 0, *((_DWORD *)a1 + 618), *((_QWORD *)a1 + 310));
          *((_QWORD *)a1 + 607) = v97;
          if (!v97)
          {
            v89 = "file stream";
            v90 = 381;
            goto LABEL_231;
          }
          if ((BXPatch5FileWithFlags(v114, (uint64_t)v67, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc, (uint64_t)v97, 2) & 0x80000000) == 0)goto LABEL_198;
          v98 = __s;
          v89 = "patching failed: %s";
          v90 = 386;
        }
LABEL_230:
        LODWORD(v97) = 0;
LABEL_231:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v90, 133, (int)v97, v89, v65, v66, (char)v98);
LABEL_232:
        v28 = 0;
        goto LABEL_209;
      }
      v102 = 0;
      v100 = 0u;
      v101 = 0u;
      v99 = 0u;
      v27 = (AAByteStream_impl *)AAMemoryInputStreamOpen((uint64_t)v67, DataSize, v80, v81, v82, v83, v84, v85);
      if (v27)
      {
        if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          v95 = "invalid PAT: %s";
          v96 = 339;
        }
        else
        {
          *(_QWORD *)&v100 = v114;
          *((_QWORD *)&v100 + 1) = __s;
          v28 = 1;
          DWORD2(v101) = 1;
          LODWORD(v102) = 1;
          if ((RawImagePatchInternal((uint64_t)&v99, v27) & 0x80000000) == 0)
            goto LABEL_34;
          v95 = "RawImagePatchInternal";
          v96 = 348;
        }
      }
      else
      {
        v95 = "AAMemoryInputStreamOpen";
        v96 = 336;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v96, 133, 0, v95, v93, v94, (char)v98);
      goto LABEL_33;
    case 'R':
      if (*((_DWORD *)a1 + 264))
      {
        if (v11)
        {
          if (v17 >= 2)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Remove %c %s\n", (char)a1[2088], a1 + 1064);
          if (!v12)
            goto LABEL_39;
          if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) == 0)
          {
            unlink(__s);
LABEL_39:
            v26 = 0;
            v27 = 0;
            v28 = 1;
            goto LABEL_34;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 417, 133, 0, "invalid PAT: %s", v58, v59, (_BYTE)a1 + 40);
LABEL_32:
          v26 = 0;
          v27 = 0;
LABEL_33:
          v28 = 0;
          goto LABEL_34;
        }
        v24 = "no input dir";
        v25 = 413;
      }
      else
      {
        v24 = "missing PAT";
        v25 = 412;
      }
      break;
    default:
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "TODO(%c) %c %s\n", (char)v16, (char)a1[2088], a1 + 1064);
      goto LABEL_39;
  }
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v25, 133, 0, v24, a7, a8, (char)v98);
  goto LABEL_32;
}

uint64_t applyYEC(uint64_t *a1, char *a2, const char *a3)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  _OWORD v14[3];
  uint64_t v15;
  char v16[64];
  uint64_t v17;
  unsigned __int8 v18[184];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v3 = *a1;
  if (!*a1)
    return 0;
  v4 = (char)a3;
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v18, 0, 172);
  v13 = 0;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  LOBYTE(v10) = 1;
  *((_QWORD *)&v10 + 1) = a1[2];
  *(_QWORD *)&v11 = v3;
  v9 = 0;
  v7 = aaCheckAndFixWithPath(v16, (unsigned __int8 *)v14, v18, (unsigned __int8 *)&v10, -1, (unsigned int *)&v9, a2, a3, 0x20000000000000);
  if (v7 < 0)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"applyYEC", 113, 133, 0, "ECC failed: %s", v5, v6, v4);
  return (v7 >> 31);
}

_WORD *enterThreadErrorContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey;
  _WORD *result;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;

  ErrorContextKey = getErrorContextKey();
  result = pthread_getspecific(ErrorContextKey);
  if (result)
  {
    ++result[2];
  }
  else
  {
    v11 = calloc(1uLL, 0x2000uLL);
    if (v11)
    {
      v11[2] = 1;
      *((_DWORD *)v11 + 18) = 531890176;
      return (_WORD *)setThreadErrorContext(v11, v12, v13, v14, v15, v16, v17, v18, a9);
    }
    else
    {
      v19 = __error();
      return (_WORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThreadErrorContext", 76, 5, *v19, "malloc", v20, v21, a9);
    }
  }
  return result;
}

size_t setThreadErrorContext(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey;
  size_t result;
  int *v12;
  uint64_t v13;
  uint64_t v14;

  ErrorContextKey = getErrorContextKey();
  result = pthread_setspecific(ErrorContextKey, a1);
  if ((_DWORD)result)
  {
    v12 = __error();
    return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"setThreadErrorContext", 65, 5, *v12, "pthread_setspecific", v13, v14, a9);
  }
  return result;
}

uint64_t leaveThreadErrorContext(__CFError **a1, const __CFString **a2, int a3)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  char *v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  size_t v29;
  char *v30;
  const __CFAllocator *v31;
  CFStringRef v32;
  CFStringRef v33;
  __CFError *v34;
  unint64_t v35;
  size_t v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  CFIndex v41;
  char *v42;
  char *v43;
  const void *v44;
  CFIndex v45;
  char *v46;
  char *v47;
  char v49;
  void *userInfoKeys[128];
  void *userInfoValues[2];

  userInfoValues[1] = *(void **)MEMORY[0x24BDAC8D0];
  ErrorContextKey = getErrorContextKey();
  v7 = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (v7)
  {
    v15 = v7;
    v16 = v7[2] - 1;
    v7[2] = v16;
    if (!v16)
    {
      v18 = v7[36];
      v17 = *(unsigned int *)v7;
      if (!v7[36] && (v17 & 0x80000000) == 0)
      {
        if (!v7[3] || !a2 && !a3)
          goto LABEL_46;
        bzero(userInfoKeys, 0x400uLL);
        v35 = 0;
        do
        {
          v36 = strlen((const char *)userInfoKeys);
          if (v36 + 20 > 0x3FF)
            break;
          if (v36)
            snprintf((char *)userInfoKeys + v36, 1024 - v36, ",0x%08x");
          else
            snprintf((char *)userInfoKeys, 0x400uLL, "Warnings:0x%08x");
          ++v35;
        }
        while (v35 < v15[3]);
        v37 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)userInfoKeys, 0x600u);
        if (!v37)
          goto LABEL_46;
        v38 = v37;
        if (a2)
        {
          *a2 = v37;
          goto LABEL_46;
        }
        v45 = CFStringGetLength(v37) + 1;
        v46 = (char *)calloc(1uLL, v45);
        if (v46)
        {
          v47 = v46;
          CFStringGetCString(v38, v46, v45, 0x600u);
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", v47);
          free(v47);
        }
        v44 = v38;
LABEL_45:
        CFRelease(v44);
        goto LABEL_46;
      }
      if (!a1 && !a3)
        goto LABEL_46;
      v19 = v18 + 32;
      v20 = (char *)calloc(v18 + 32, 1uLL);
      if (!v20)
        goto LABEL_46;
      v21 = v20;
      v22 = v20;
      if ((v17 & 0x80000000) != 0)
      {
        snprintf(v20, v19, "Error 0x%08x\n", v17);
        v22 = &v21[strlen(v21)];
      }
      v23 = v15[36];
      if (v15[36])
      {
        v24 = 0;
        do
        {
          v25 = (unsigned __int16 *)((char *)v15 + v24 + 76);
          v26 = *v25;
          v27 = v26 + v24;
          if (v26 < 4 || v27 > v23)
            break;
          v29 = v26 - 3;
          memcpy(v22, v25 + 1, v29);
          v30 = &v22[v29];
          *v30 = 10;
          v22 = v30 + 1;
          v24 = (unsigned __int16)v27;
          v23 = v15[36];
        }
        while (v23 > (unsigned __int16)v27);
      }
      if (v22 > v21)
        *(v22 - 1) = 0;
      v31 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      v32 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v21, 0x600u);
      if (!v32)
      {
        free(v21);
        goto LABEL_46;
      }
      v33 = v32;
      userInfoKeys[0] = *(void **)MEMORY[0x24BDBD3A0];
      userInfoValues[0] = (void *)v32;
      v34 = CFErrorCreateWithUserInfoKeysAndValues(v31, CFSTR("com.apple.ParallelCompression"), 1, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
      CFRelease(v33);
      free(v21);
      if (v34)
      {
        if (!a1)
        {
          v39 = CFErrorCopyDescription(v34);
          if (v39)
          {
            v40 = v39;
            v41 = CFStringGetLength(v39) + 1;
            v42 = (char *)calloc(1uLL, v41);
            if (v42)
            {
              v43 = v42;
              CFStringGetCString(v40, v42, v41, 0x600u);
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", v43);
              free(v43);
            }
            CFRelease(v40);
          }
          v44 = v34;
          goto LABEL_45;
        }
        *a1 = v34;
      }
LABEL_46:
      setThreadErrorContext(0, v8, v9, v10, v11, v12, v13, v14, v49);
      free(v15);
      return v17;
    }
  }
  return 0;
}

size_t appendThreadErrorContextString(size_t result)
{
  const void *v1;
  size_t v2;
  pthread_key_t ErrorContextKey;
  size_t v4;
  __int16 v5;
  uint64_t v6;
  size_t v7;
  size_t v8;

  if (result)
  {
    v1 = (const void *)result;
    result = strlen((const char *)result);
    if (result - 8193 >= 0xFFFFFFFFFFFFE000)
    {
      v2 = result;
      ErrorContextKey = getErrorContextKey();
      result = (size_t)pthread_getspecific(ErrorContextKey);
      if (result)
      {
        v4 = result;
        v5 = v2 + 3;
        v6 = *(unsigned __int16 *)(result + 72);
        if (v6 + (unsigned __int16)(v2 + 3) <= *(unsigned __int16 *)(result + 74))
        {
          v7 = result + v6;
          *(_WORD *)(v7 + 76) = v5;
          v8 = v7 + 78;
          result = (size_t)memcpy((void *)(v7 + 78), v1, v2);
          *(_BYTE *)(v8 + v2) = 0;
          *(_WORD *)(v4 + 72) += v5;
        }
      }
    }
  }
  return result;
}

_WORD *updateThreadErrorContextErrorCode(_WORD *result)
{
  int v1;
  pthread_key_t ErrorContextKey;

  if ((result & 0x80000000) != 0)
  {
    v1 = (int)result;
    ErrorContextKey = getErrorContextKey();
    result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*(_DWORD *)result & 0x80000000) == 0)
      {
        *(_DWORD *)result = v1;
        result[3] = 0;
      }
    }
  }
  return result;
}

_DWORD *updateThreadErrorContextWarningCode(_DWORD *result)
{
  int v1;
  pthread_key_t ErrorContextKey;
  uint64_t v3;

  if ((result & 0x80000000) != 0)
  {
    v1 = (int)result;
    ErrorContextKey = getErrorContextKey();
    result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*result & 0x80000000) == 0)
      {
        v3 = *((unsigned __int16 *)result + 3);
        if (v3 <= 0xF)
        {
          result[v3 + 2] = v1;
          *((_WORD *)result + 3) = v3 + 1;
        }
      }
    }
  }
  return result;
}

unsigned __int16 *saveThreadErrorContext(void *a1)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *result;
  unsigned __int16 *v4;
  uint64_t v5;
  size_t v6;

  ErrorContextKey = getErrorContextKey();
  result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    v4 = result;
    bzero(a1, 0x2000uLL);
    v5 = v4[36];
    if (v5 <= 0x1FB4)
      v6 = v5 + 76;
    else
      v6 = 0;
    return (unsigned __int16 *)memcpy(a1, v4, v6);
  }
  return result;
}

unsigned __int16 *restoreThreadErrorContext(__int128 *a1)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *result;
  __int128 v4;
  __int128 v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[28];

  ErrorContextKey = getErrorContextKey();
  result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    v4 = a1[1];
    v13 = *a1;
    v14 = v4;
    v5 = a1[3];
    v15 = a1[2];
    *(_OWORD *)v16 = v5;
    *(_OWORD *)&v16[12] = *(__int128 *)((char *)a1 + 60);
    if ((v13 & 0x80000000) == 0)
    {
      v6 = WORD3(v13);
      if ((*(_DWORD *)result & 0x80000000) != 0 && WORD3(v13) <= 0xFu)
      {
        v6 = WORD3(v13) + 1;
        *((_DWORD *)&v13 + WORD3(v13) + 2) = *(_DWORD *)result;
      }
      v7 = result[3];
      if (result[3] && v6 <= 0xF)
      {
        v8 = 0;
        do
        {
          v9 = *(_DWORD *)&result[2 * v8 + 4];
          if (v8 >= v6 || *((_DWORD *)&v13 + v8 + 2) != v9)
          {
            v10 = v6++;
            *((_DWORD *)&v13 + v10 + 2) = v9;
          }
          ++v8;
        }
        while (v8 < v7 && v6 < 0x10);
      }
      WORD3(v13) = v6;
    }
    v11 = *(_OWORD *)v16;
    *((_OWORD *)result + 2) = v15;
    *((_OWORD *)result + 3) = v11;
    *(_OWORD *)(result + 30) = *(_OWORD *)&v16[12];
    v12 = v14;
    *(_OWORD *)result = v13;
    *((_OWORD *)result + 1) = v12;
    if (*(unsigned __int16 *)&v16[24] <= 0x1FB4uLL)
      return (unsigned __int16 *)memcpy(result + 38, (char *)a1 + 76, *(unsigned __int16 *)&v16[24]);
  }
  return result;
}

uint64_t createThread(pthread_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  pthread_attr_t *v10;
  pthread_attr_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  const void *v26;
  uint64_t v28;
  _opaque_pthread_t *v29;
  uint64_t qos_class_np;
  uint64_t v31;
  dispatch_block_t v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[5];
  int __relative_priority[2];

  *(_QWORD *)__relative_priority = 0;
  v8 = calloc(1uLL, 0x2000uLL);
  if (!v8)
  {
    v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 552, 5, *v19, "malloc", v20, v21, v36[0]);
    return -*__error();
  }
  v9 = v8;
  v10 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v10)
  {
    v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 555, 5, *v22, "malloc", v23, v24, v36[0]);
    v25 = __error();
    v13 = -*v25;
    if (!*v25)
      return v13;
    goto LABEL_10;
  }
  v11 = v10;
  v12 = pthread_attr_init(v10);
  if ((_DWORD)v12)
  {
    v13 = v12;
    v14 = *__error();
    v17 = "pthread_attr_init";
    v18 = 558;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", v18, 5, v14, v17, v15, v16, v36[0]);
    goto LABEL_6;
  }
  if (a4)
  {
    v28 = pthread_attr_setstacksize(v11, a4);
    if ((_DWORD)v28)
    {
      v13 = v28;
      v14 = *__error();
      v17 = "pthread_attr_setstacksize";
      v18 = 564;
      goto LABEL_5;
    }
  }
  v29 = pthread_self();
  qos_class_np = pthread_get_qos_class_np(v29, (qos_class_t *)&__relative_priority[1], __relative_priority);
  if ((_DWORD)qos_class_np)
  {
    v13 = qos_class_np;
    v14 = *__error();
    v17 = "pthread_get_qos_class_np";
    v18 = 570;
    goto LABEL_5;
  }
  v31 = pthread_attr_set_qos_class_np(v11, (qos_class_t)__relative_priority[1], __relative_priority[0]);
  if ((_DWORD)v31)
  {
    v13 = v31;
    v14 = *__error();
    v17 = "pthread_attr_set_qos_class_np";
    v18 = 572;
    goto LABEL_5;
  }
  v36[0] = MEMORY[0x24BDAC760];
  v36[1] = 0x40000000;
  v36[2] = __createThread_block_invoke;
  v36[3] = &__block_descriptor_tmp;
  v36[4] = v9;
  v32 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v36);
  v9[2] = v32;
  if (v32)
  {
    *v9 = a2;
    v9[1] = a3;
    *((_DWORD *)v9 + 7) = 1;
    *((_DWORD *)v9 + 24) = 530317312;
    v13 = pthread_create(a1, v11, (void *(__cdecl *)(void *))threadWrapperProc, v9);
    if ((_DWORD)v13)
    {
      v14 = *__error();
      v17 = "pthread_create";
      v18 = 591;
      goto LABEL_5;
    }
  }
  else
  {
    v33 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 578, 5, *v33, "dispatch_block_create", v34, v35, v36[0]);
    v13 = -*__error();
  }
LABEL_6:
  pthread_attr_destroy(v11);
  free(v11);
  if (!(_DWORD)v13)
    return v13;
LABEL_10:
  v26 = (const void *)v9[2];
  if (v26)
    _Block_release(v26);
  free(v9);
  return v13;
}

uint64_t __createThread_block_invoke(uint64_t a1)
{
  return (**(uint64_t (***)(_QWORD))(a1 + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t threadWrapperProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v17;
  char v18;

  setThreadErrorContext((const void *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8, v17);
  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  setThreadErrorContext(0, v9, v10, v11, v12, v13, v14, v15, v18);
  return a1;
}

uint64_t joinThread(_opaque_pthread_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  pthread_key_t ErrorContextKey;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  _WORD *v16;
  unsigned __int16 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  const void *v24;
  char v26;
  void *v27;

  v27 = 0;
  v1 = pthread_join(a1, &v27);
  if ((_DWORD)v1)
  {
    v4 = v1;
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 623, 5, *v5, "pthread_join", v6, v7, v26);
    v8 = 0;
    goto LABEL_26;
  }
  v8 = v27;
  if (*((_WORD *)v27 + 14) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 627, 5, 0, "expected ref_count=1 for terminating thread", v2, v3, v26);
    v4 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  ErrorContextKey = getErrorContextKey();
  v10 = pthread_getspecific(ErrorContextKey);
  if (!v10)
    goto LABEL_25;
  v11 = v10;
  v12 = *v10;
  if ((*v10 & 0x80000000) == 0)
  {
    v13 = v8[6];
    if (v13 < 0)
    {
      *v10 = v13;
      v12 = v13;
    }
  }
  v14 = *((unsigned __int16 *)v8 + 48);
  if (!*((_WORD *)v8 + 48))
  {
LABEL_15:
    if (v12)
    {
      v4 = 0;
      *((_WORD *)v11 + 3) = 0;
      goto LABEL_26;
    }
    if (*((_WORD *)v8 + 15))
    {
      v19 = 0;
      v20 = *((unsigned __int16 *)v11 + 3);
      LODWORD(v21) = 16 - v20;
      if (v20 <= 0x10)
        v21 = v21;
      else
        v21 = 0;
      v22 = (uint64_t)&v11[v20 + 2];
      v23 = v20 + 1;
      do
      {
        if (v21 == v19)
          break;
        *(_DWORD *)(v22 + 4 * v19) = v8[v19 + 8];
        *((_WORD *)v11 + 3) = v23 + v19++;
      }
      while (v19 < *((unsigned __int16 *)v8 + 15));
    }
LABEL_25:
    v4 = 0;
    goto LABEL_26;
  }
  v15 = 0;
  while (1)
  {
    v16 = (_WORD *)((char *)v8 + v15 + 100);
    v4 = (unsigned __int16)*v16;
    if (!*v16)
      break;
    v17 = v15 + v4;
    if (v15 + v4 > v14)
      goto LABEL_25;
    v18 = *((unsigned __int16 *)v11 + 36);
    if ((int)v18 + (int)v4 <= *((unsigned __int16 *)v11 + 37))
    {
      memcpy((char *)v11 + v18 + 76, v16, (unsigned __int16)*v16);
      *((_WORD *)v11 + 36) += v4;
      v15 = v17;
      v14 = *((unsigned __int16 *)v8 + 48);
      if (v14 > v17)
        continue;
    }
    v12 = *v11;
    goto LABEL_15;
  }
LABEL_26:
  v24 = (const void *)*((_QWORD *)v8 + 2);
  if (v24)
    _Block_release(v24);
  free(v8);
  return v4;
}

size_t ParallelCompressionUpdateError(_WORD *a1, size_t a2)
{
  updateThreadErrorContextErrorCode(a1);
  return appendThreadErrorContextString(a2);
}

uint64_t getErrorContextKey()
{
  int *v0;

  if (pthread_once(&getErrorContextKey_errorContextOnce, (void (*)(void))createErrorContextKey))
  {
    v0 = __error();
    pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "getErrorContextKey", 53, 5, *v0, "pthread_once");
  }
  return gErrorContextKey;
}

uint64_t createErrorContextKey()
{
  uint64_t result;
  int *v1;

  result = pthread_key_create((pthread_key_t *)&gErrorContextKey, 0);
  if ((_DWORD)result)
  {
    v1 = __error();
    return pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "createErrorContextKey", 42, 5, *v1, "pthread_key_create");
  }
  return result;
}

AAArchiveStream AAConvertArchiveOutputStreamOpen(AAArchiveStream stream, AAFieldKeySet insert_key_set, AAFieldKeySet remove_key_set, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  AAArchiveStream **v13;
  AAArchiveStream **v14;
  AAArchiveStream *v15;
  AAArchiveStream *v16;
  AAFieldKeySet v17;
  uint64_t v18;
  uint64_t v19;
  AAArchiveStream_impl *v20;
  int v21;
  const char *v22;
  __int16 v23;
  char v25;

  v13 = (AAArchiveStream **)malloc(0x38uLL);
  v14 = v13;
  if (v13)
    memset_s(v13, 0x38uLL, 0, 0x38uLL);
  v15 = (AAArchiveStream *)malloc(0x310uLL);
  v16 = v15;
  if (!v15 || (memset_s(v15, 0x310uLL, 0, 0x310uLL), !v14))
  {
    v21 = *__error();
    v22 = "malloc";
    v23 = 507;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"AAConvertArchiveOutputStreamOpen", v23, 111, v21, v22, v18, v19, v25);
    free(v14);
    convertStreamClose((uint64_t)v16);
    return 0;
  }
  *v16 = stream;
  v16[1] = AAFieldKeySetClone(insert_key_set);
  v17 = AAFieldKeySetClone(remove_key_set);
  v16[2] = v17;
  if (!v16[1] || !v17)
  {
    v22 = "copy key set";
    v23 = 512;
    v21 = 0;
    goto LABEL_11;
  }
  v16[3] = (AAArchiveStream)flags;
  v16[4] = (AAArchiveStream)msg_data;
  v16[5] = (AAArchiveStream)msg_proc;
  v16[12] = (AAArchiveStream)0x10000;
  v20 = (AAArchiveStream_impl *)malloc(0x10000uLL);
  v16[13] = v20;
  if (!v20)
  {
    v21 = *__error();
    v22 = "malloc";
    v23 = 518;
    goto LABEL_11;
  }
  v14[3] = (AAArchiveStream *)convertStreamWriteHeader;
  v14[4] = (AAArchiveStream *)convertStreamWriteBlob;
  *v14 = v16;
  v14[1] = (AAArchiveStream *)convertStreamClose;
  v14[2] = (AAArchiveStream *)convertStreamAbort;
  return (AAArchiveStream)v14;
}

uint64_t convertStreamClose(uint64_t a1)
{
  if (a1)
  {
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 8));
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 16));
    AAHeaderDestroy(*(AAHeader *)(a1 + 56));
    OECCStreamDestroy(*(void ***)(a1 + 776));
    free(*(void **)(a1 + 128));
    memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 104));
    free(*(void **)(a1 + 88));
    memset_s((void *)(a1 + 80), 0x10uLL, 0, 0x10uLL);
    free((void *)a1);
  }
  return 0;
}

uint64_t convertStreamWriteHeader(uint64_t a1, AAHeader header)
{
  uint64_t result;
  AAFieldKey v6;
  uint32_t KeyIndex;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  AAFieldKey v11;
  uint32_t v12;
  unsigned int FieldString;
  int v14;
  const char *v15;
  __int16 v16;
  uint64_t (*v17)(_QWORD, uint64_t, char *, AAHeader);
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  AAHeader v22;
  uint32_t FieldCount;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint32_t v29;
  uint32_t v30;
  AAFieldKey FieldKey;
  AAFieldKey v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  AAFieldKey v36;
  AAFieldKey v37;
  AAFieldKey v38;
  AAFieldKey v39;
  AAFieldKey v40;
  AAFieldKey v41;
  AAFieldKey v42;
  AAFieldKey v43;
  AAFieldKey v44;
  AAFieldKey v45;
  AAFieldKey v46;
  AAFieldKey v47;
  AAFieldKey v48;
  AAFieldKey v49;
  AAFieldKey v50;
  AAFieldKey v51;
  AAFieldKey v52;
  AAFieldKey v53;
  AAFieldKey v54;
  AAFieldKey v55;
  AAFieldKey v56;
  AAFieldKey v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  int FieldType;
  AAFieldKey v62;
  size_t v63;
  AAFieldKey v64;
  AAFieldKey v65;
  AAFieldKey v66;
  AAFieldKey v67;
  AAFieldKey v68;
  AAFieldKey v69;
  const char *v70;
  __int16 v71;
  uint64_t v72;
  int v73;
  timespec size;
  AAHashFunction hash_function;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t offset;
  uint64_t value;
  uint8_t v81[16];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  _BYTE v85[1024];
  char __s[1024];
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 48))
    return 0;
  value = 0;
  *(_OWORD *)v81 = 0u;
  v82 = 0u;
  v83 = 0u;
  v84 = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v6.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(header, v6);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    v15 = "Invalid entry missing TYP field (skipped)";
    v16 = 237;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteHeader", v16, 111, v15, v8, v9, v10, v72);
LABEL_11:
    result = 0;
    *(_DWORD *)(a1 + 52) = 1;
    return result;
  }
  v11.ikey = 5521744;
  v12 = AAHeaderGetKeyIndex(header, v11);
  if ((v12 & 0x80000000) != 0)
  {
    v14 = 0;
  }
  else
  {
    FieldString = AAHeaderGetFieldString(header, v12, 0x400uLL, __s, 0);
    if (FieldString <= 1)
      v14 = 1;
    else
      v14 = FieldString;
  }
  if (v14 <= 0 && value != 77)
  {
    v15 = "Invalid non metadata entry missing PAT field (skipped)";
    v16 = 244;
    goto LABEL_10;
  }
  if (v14 >= 1)
  {
    v17 = *(uint64_t (**)(_QWORD, uint64_t, char *, AAHeader))(a1 + 40);
    if (v17)
    {
      v18 = v17(*(_QWORD *)(a1 + 32), 40, __s, header);
      if (v18 < 0)
        goto LABEL_103;
      if (v18)
        goto LABEL_11;
      v19 = (*(uint64_t (**)(_QWORD, uint64_t, char *, _BYTE *))(a1 + 40))(*(_QWORD *)(a1 + 32), 41, __s, v85);
      if (v19 < 0)
      {
LABEL_103:
        *(_DWORD *)(a1 + 48) = 1;
        return 0xFFFFFFFFLL;
      }
      if (v19)
        __strlcpy_chk();
    }
  }
  if (value == 77 && (*(_BYTE *)(a1 + 25) & 2) != 0)
    goto LABEL_11;
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 80, header) & 0x80000000) != 0)
  {
    v70 = "capturing non-empty blobs";
    v71 = 262;
    goto LABEL_132;
  }
  v22 = AAHeaderCreate();
  *(_QWORD *)(a1 + 56) = v22;
  if (!v22)
  {
    v70 = "create new header";
    v71 = 266;
LABEL_132:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteHeader", v71, 111, 0, v70, v20, v21, v72);
    if (!*(_DWORD *)(a1 + 48))
    {
      *(_DWORD *)(a1 + 48) = 1;
      AAArchiveStreamCancel(*(AAArchiveStream *)a1);
    }
    return 0xFFFFFFFFLL;
  }
  FieldCount = AAHeaderGetFieldCount(header);
  if (!FieldCount)
    goto LABEL_108;
  v29 = FieldCount;
  v73 = 0;
  v30 = 0;
  v72 = a1 + 144;
  do
  {
    FieldKey = AAHeaderGetFieldKey(header, v30);
    v32 = FieldKey;
    v33 = AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 16), v32);
    v34 = *(_QWORD *)FieldKey.skey & 0xFFFFFFLL;
    if ((*(_QWORD *)FieldKey.skey & 0xFFFFFFLL) == 0x544144)
    {
      size.tv_sec = 0;
      offset = 0;
      if (AAHeaderGetFieldBlob(header, v30, (uint64_t *)&size, &offset) < 0)
      {
        v70 = "getting header blob field";
        v71 = 290;
        goto LABEL_132;
      }
      if (!v33
        || ((*(_QWORD *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (v35 = 5521744) : (v35 = 5265748), v34 == v35))
      {
        v36 = FieldKey;
        if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v36, size.tv_sec) < 0)
        {
          v70 = "inserting header field";
          v71 = 295;
          goto LABEL_132;
        }
        v73 = 1;
      }
      v37.ikey = 3229779;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v37))
      {
        v38.ikey = 3229779;
        if (AAHeaderGetKeyIndex(header, v38) < 0)
        {
          v39.ikey = 3229779;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v39, 2u, v81) < 0)
          {
            v70 = "inserting header field";
            v71 = 300;
            goto LABEL_132;
          }
          *(_BYTE *)(a1 + 136) |= 2u;
          CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)(a1 + 160));
        }
      }
      v40.ikey = 3295315;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v40))
      {
        v41.ikey = 3295315;
        if (AAHeaderGetKeyIndex(header, v41) < 0)
        {
          v42.ikey = 3295315;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v42, 3u, v81) < 0)
          {
            v70 = "inserting header field";
            v71 = 306;
            goto LABEL_132;
          }
          *(_BYTE *)(a1 + 136) |= 4u;
          CC_SHA256_Init((CC_SHA256_CTX *)(a1 + 256));
        }
      }
      v43.ikey = 3360851;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v43))
      {
        v44.ikey = 3360851;
        if (AAHeaderGetKeyIndex(header, v44) < 0)
        {
          v45.ikey = 3360851;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v45, 4u, v81) < 0)
          {
            v70 = "inserting header field";
            v71 = 312;
            goto LABEL_132;
          }
          *(_BYTE *)(a1 + 136) |= 8u;
          CC_SHA384_Init((CC_SHA512_CTX *)(a1 + 360));
        }
      }
      v46.ikey = 3491923;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v46))
      {
        v47.ikey = 3491923;
        if (AAHeaderGetKeyIndex(header, v47) < 0)
        {
          v48.ikey = 3491923;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v48, 5u, v81) < 0)
          {
            v70 = "inserting header field";
            v71 = 318;
            goto LABEL_132;
          }
          *(_BYTE *)(a1 + 136) |= 0x10u;
          CC_SHA512_Init((CC_SHA512_CTX *)(a1 + 568));
        }
      }
      v49.ikey = 5458755;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v49))
      {
        v50.ikey = 5458755;
        if (AAHeaderGetKeyIndex(header, v50) < 0)
        {
          v51.ikey = 5458755;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v51, 1u, v81) < 0)
          {
            v70 = "inserting header field";
            v71 = 324;
            goto LABEL_132;
          }
          *(_BYTE *)(a1 + 136) |= 1u;
          CC_CKSUM_Init(v72);
        }
      }
      v52.ikey = 5917011;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v52))
      {
        v53.ikey = 5917011;
        if (AAHeaderGetKeyIndex(header, v53) < 0)
        {
          v54.ikey = 5917011;
          if (AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v54, size.tv_sec) < 0)
          {
            v70 = "inserting header field";
            v71 = 330;
            goto LABEL_132;
          }
        }
      }
      v55.ikey = 4408665;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v55))
      {
        v56.ikey = 4408665;
        if (AAHeaderGetKeyIndex(header, v56) < 0)
        {
          if (size.tv_sec)
          {
            v57.ikey = 4408665;
            if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v57, 0) < 0)
            {
              v70 = "inserting header field";
              v71 = 334;
              goto LABEL_132;
            }
            *(_BYTE *)(a1 + 136) |= 0x20u;
            v58 = OECCStreamCreate(1, 0x4000u, size.tv_sec);
            *(_QWORD *)(a1 + 776) = v58;
            if (!v58)
            {
              v70 = "creating YEC context";
              v71 = 337;
              goto LABEL_132;
            }
          }
        }
      }
      if (!v33
        || ((*(_QWORD *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (v59 = 5521744) : (v59 = 5265748), v34 == v59))
      {
        if (*(_DWORD *)(a1 + 136))
        {
          v70 = "can't generate a field from DAT, and keep DAT at the same time";
          v71 = 342;
          goto LABEL_132;
        }
      }
    }
    if (v33)
    {
      if ((*(_QWORD *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F)
      {
        if (v34 == 5521744)
        {
LABEL_85:
          v63 = strlen(__s);
          v64 = FieldKey;
          if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v64, __s, v63) < 0)
          {
            v70 = "inserting header field";
            v71 = 350;
            goto LABEL_132;
          }
          goto LABEL_86;
        }
        v60 = 5653828;
        goto LABEL_80;
      }
      if (v34 != 4935244)
      {
        v60 = 5265748;
LABEL_80:
        if (v34 != v60)
          goto LABEL_86;
      }
    }
    else if (v34 == 5521744)
    {
      goto LABEL_85;
    }
    if (v34 != 5521732)
    {
      FieldType = AAHeaderGetFieldType(header, v30);
      v78 = 0;
      offset = 0;
      v76 = 0;
      v77 = 0;
      hash_function = 0;
      size.tv_sec = 0;
      size.tv_nsec = 0;
      switch(FieldType)
      {
        case 0:
          v62 = FieldKey;
          if ((AAHeaderSetFieldFlag(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v62) & 0x80000000) == 0)
            goto LABEL_86;
          v70 = "inserting header field";
          v71 = 375;
          goto LABEL_132;
        case 1:
          if (AAHeaderGetFieldUInt(header, v30, &v76) < 0)
          {
            v70 = "Invalid input header";
            v71 = 367;
            goto LABEL_132;
          }
          v65 = FieldKey;
          if ((AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v65, v76) & 0x80000000) == 0)
            goto LABEL_86;
          v70 = "inserting header field";
          v71 = 368;
          break;
        case 2:
          if (AAHeaderGetFieldString(header, v30, *(_QWORD *)(a1 + 96), *(char **)(a1 + 104), &offset) < 0)
          {
            v70 = "Invalid input header";
            v71 = 371;
            goto LABEL_132;
          }
          v66 = FieldKey;
          if ((AAHeaderSetFieldString(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v66, *(const char **)(a1 + 104), offset) & 0x80000000) == 0)
            goto LABEL_86;
          v70 = "inserting header field";
          v71 = 372;
          goto LABEL_132;
        case 3:
          if (AAHeaderGetFieldHash(header, v30, *(_QWORD *)(a1 + 96), &hash_function, *(uint8_t **)(a1 + 104)) < 0)
          {
            v70 = "Invalid input header";
            v71 = 378;
            goto LABEL_132;
          }
          v67 = FieldKey;
          if ((AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v67, hash_function, *(const uint8_t **)(a1 + 104)) & 0x80000000) == 0)goto LABEL_86;
          v70 = "inserting header field";
          v71 = 379;
          goto LABEL_132;
        case 4:
          if (AAHeaderGetFieldTimespec(header, v30, &size) < 0)
          {
            v70 = "Invalid input header";
            v71 = 382;
            goto LABEL_132;
          }
          v68 = FieldKey;
          if ((AAHeaderSetFieldTimespec(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v68, &size) & 0x80000000) == 0)
            goto LABEL_86;
          v70 = "inserting header field";
          v71 = 383;
          goto LABEL_132;
        case 5:
          if (AAHeaderGetFieldBlob(header, v30, &v78, &v77) < 0)
          {
            v70 = "Invalid input header";
            v71 = 363;
            goto LABEL_132;
          }
          v69 = FieldKey;
          if ((AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v69, v78) & 0x80000000) == 0)
            goto LABEL_86;
          v70 = "inserting header field";
          v71 = 364;
          goto LABEL_132;
        default:
          v70 = "Invalid header field type";
          v71 = 385;
          goto LABEL_132;
      }
      goto LABEL_132;
    }
LABEL_86:
    ++v30;
  }
  while (v29 != v30);
  if (v73 && (sendHeader(a1) & 0x80000000) != 0)
  {
    v70 = "sending header";
    v71 = 392;
    goto LABEL_132;
  }
LABEL_108:
  *(_DWORD *)(a1 + 76) = 0;
  if ((convertStreamToNextNonEmptyBlob(a1, v24, v25, v26, v27, v28, v20, v21) & 0x80000000) != 0)
  {
    v70 = "iterating to next blob";
    v71 = 396;
    goto LABEL_132;
  }
  if (*(_DWORD *)(a1 + 76) >= *(_DWORD *)(a1 + 80) && (convertStreamEndEntry(a1) & 0x80000000) != 0)
  {
    v70 = "finishing entry";
    v71 = 399;
    goto LABEL_132;
  }
  return 0;
}

uint64_t convertStreamWriteBlob(uint64_t a1, uint64_t a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  AAFieldKey v17;
  char v18;
  AAFieldKey v19;
  uint64_t v20;
  rsize_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  BOOL v29;
  unint64_t v30;
  size_t v31;
  size_t v32;
  void **v33;
  void *v34;
  void *v35;
  uint64_t v36;
  char v37;

  if (*(_DWORD *)(a1 + 48))
    return 0;
  result = 0;
  if (__smax && !*(_DWORD *)(a1 + 52))
  {
    v11 = *(_DWORD *)(a1 + 76);
    if (v11 >= *(_DWORD *)(a1 + 80))
    {
      v14 = "invalid state";
      v15 = 414;
      goto LABEL_9;
    }
    v12 = *(_QWORD *)(a1 + 88);
    v13 = *(_DWORD *)(v12 + 24 * v11);
    if (((v13 ^ a2) & 0xFFFFFF) != 0)
    {
      v14 = "invalid state";
      v15 = 416;
      goto LABEL_9;
    }
    v17.ikey = a2;
    if (!*(_DWORD *)(a1 + 68))
    {
      if ((convertStreamBeginBlob(a1, (AAFieldKey)a2, *(_QWORD *)(v12 + 24 * v11 + 8)) & 0x80000000) != 0)
      {
        v14 = "starting blob";
        v15 = 422;
        goto LABEL_9;
      }
      *(_DWORD *)(a1 + 68) = 1;
    }
    if ((*(_QWORD *)&v13 & 0xFFFFFFLL) != 0x544144)
      goto LABEL_30;
    v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 2) != 0)
    {
      CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 160), __src, __smax);
      v18 = *(_BYTE *)(a1 + 136);
      if ((v18 & 4) == 0)
      {
LABEL_19:
        if ((v18 & 8) == 0)
          goto LABEL_20;
        goto LABEL_26;
      }
    }
    else if ((*(_BYTE *)(a1 + 136) & 4) == 0)
    {
      goto LABEL_19;
    }
    CC_SHA256_Update((CC_SHA256_CTX *)(a1 + 256), __src, __smax);
    v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 8) == 0)
    {
LABEL_20:
      if ((v18 & 0x10) == 0)
        goto LABEL_21;
      goto LABEL_27;
    }
LABEL_26:
    CC_SHA384_Update((CC_SHA512_CTX *)(a1 + 360), __src, __smax);
    v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 0x10) == 0)
    {
LABEL_21:
      if ((v18 & 1) == 0)
        goto LABEL_22;
      goto LABEL_28;
    }
LABEL_27:
    CC_SHA512_Update((CC_SHA512_CTX *)(a1 + 568), __src, __smax);
    v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 1) == 0)
    {
LABEL_22:
      if ((v18 & 0x20) == 0)
        goto LABEL_30;
      goto LABEL_29;
    }
LABEL_28:
    CC_CKSUM_Update(a1 + 144, (unsigned __int8 *)__src, __smax);
    if ((*(_BYTE *)(a1 + 136) & 0x20) == 0)
    {
LABEL_30:
      if (*(_DWORD *)(a1 + 72))
      {
        if (*(_DWORD *)(a1 + 64))
        {
          v19 = v17;
          if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v19, __src, __smax) < 0)
          {
            v14 = "sending blob data";
            v15 = 449;
            goto LABEL_9;
          }
          goto LABEL_33;
        }
        v28 = (_QWORD *)(a1 + 112);
        v27 = *(_QWORD *)(a1 + 112);
        v29 = __CFADD__(v27, __smax);
        v30 = v27 + __smax;
        if (v29 || (v30 & 0x8000000000000000) != 0)
          goto LABEL_66;
        v31 = *(_QWORD *)(a1 + 120);
        if (v31 < v30)
        {
          do
          {
            while (!v31)
            {
              v31 = 0x4000;
              if (v30 <= 0x4000)
              {
                v33 = (void **)(a1 + 128);
                v31 = 0x4000;
                goto LABEL_56;
              }
            }
            v32 = v31 >> 1;
            if ((v31 & (v31 >> 1)) != 0)
              v32 = v31 & (v31 >> 1);
            v31 += v32;
          }
          while (v31 < v30);
          v33 = (void **)(a1 + 128);
          if (v31 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_65;
          }
LABEL_56:
          v34 = *v33;
          v35 = realloc(*v33, v31);
          if (v35)
          {
            *(_QWORD *)(a1 + 120) = v31;
            *(_QWORD *)(a1 + 128) = v35;
            goto LABEL_58;
          }
          free(v34);
LABEL_65:
          *v33 = 0;
          *v28 = 0;
          *(_QWORD *)(a1 + 120) = 0;
          goto LABEL_66;
        }
LABEL_58:
        v36 = *(_QWORD *)(a1 + 128);
        if (__src)
        {
          memcpy((void *)(v36 + *v28), __src, __smax);
        }
        else if (v36)
        {
          memset_s((void *)(v36 + *v28), __smax, 0, __smax);
        }
        *v28 += __smax;
        if ((__smax & 0x8000000000000000) != 0)
        {
LABEL_66:
          v14 = "accumulating blob data";
          v15 = 445;
          goto LABEL_9;
        }
      }
LABEL_33:
      v20 = v12 + 24 * v11;
      v21 = *(_QWORD *)(v20 + 8) - __smax;
      *(_QWORD *)(v20 + 8) = v21;
      if (v21)
        return 0;
      if ((convertStreamEndBlob(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        v14 = "finishing blob";
        v15 = 457;
        goto LABEL_9;
      }
      *(_DWORD *)(a1 + 68) = 0;
      ++*(_DWORD *)(a1 + 76);
      if ((convertStreamToNextNonEmptyBlob(a1, v22, v23, v24, v25, v26, a7, a8) & 0x80000000) != 0)
      {
        v14 = "iterating to next blob";
        v15 = 461;
        goto LABEL_9;
      }
      if (*(_DWORD *)(a1 + 76) < *(_DWORD *)(a1 + 80) || (convertStreamEndEntry(a1) & 0x80000000) == 0)
        return 0;
      v14 = "finishing entry";
      v15 = 465;
LABEL_9:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteBlob", v15, 111, 0, v14, a7, a8, v37);
      if (!*(_DWORD *)(a1 + 48))
      {
        *(_DWORD *)(a1 + 48) = 1;
        AAArchiveStreamCancel(*(AAArchiveStream *)a1);
      }
      return 0xFFFFFFFFLL;
    }
LABEL_29:
    if (OECCStreamWrite(*(_QWORD *)(a1 + 776), (char *)__src, __smax, __smax, a5, a6, a7, a8) != __smax)
    {
      v14 = "updating YEC field";
      v15 = 436;
      goto LABEL_9;
    }
    goto LABEL_30;
  }
  return result;
}

void convertStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAArchiveStreamCancel(*(AAArchiveStream *)a1);
  }
}

uint64_t sendHeader(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  AAFieldKey *v9;
  size_t v10;
  AAFieldKey v11;
  const char *v12;
  __int16 v13;
  char v14;

  if (*(_DWORD *)(a1 + 48))
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a1 + 64))
  {
    if (AAArchiveStreamWriteHeader(*(AAArchiveStream *)a1, *(AAHeader *)(a1 + 56)) < 0)
    {
      v12 = "Encoding failed";
      v13 = 56;
    }
    else
    {
      v5 = 0;
      *(_DWORD *)(a1 + 64) = 1;
      v6 = *(_QWORD *)(a1 + 112);
      v7 = *(_QWORD *)(a1 + 128);
      while (1)
      {
        if (v5 >= v6)
        {
          result = 0;
          *(_QWORD *)(a1 + 112) = 0;
          return result;
        }
        v8 = v5 + 24;
        if (v5 + 24 > v6)
        {
          v12 = "Invalid payload";
          v13 = 66;
          goto LABEL_16;
        }
        v9 = (AAFieldKey *)(v7 + v5);
        v10 = *(_QWORD *)(v7 + v5 + 8);
        v5 = v10 + v8;
        if (v10 + v8 > v6)
          break;
        v11 = *v9;
        if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v11, (const void *)(v7 + v8), v10) < 0)
        {
          v12 = "Blob encoding failed";
          v13 = 70;
          goto LABEL_16;
        }
      }
      v12 = "Invalid payload";
      v13 = 69;
    }
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"sendHeader", v13, 111, 0, v12, v3, v4, v14);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t convertStreamToNextNonEmptyBlob(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v10;
  uint64_t v11;
  AAFieldKey v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  char v23;

  v8 = *(_DWORD *)(a1 + 76);
  if (v8 >= *(_DWORD *)(a1 + 80))
    return 0;
  v10 = 1;
  do
  {
    v11 = *(_QWORD *)(a1 + 88);
    if (*(_QWORD *)(v11 + 24 * v8 + 8))
      break;
    v12 = *(AAFieldKey *)(v11 + 24 * v8);
    v13 = convertStreamBeginBlob(a1, v12, 0);
    if ((int)(convertStreamEndBlob(a1, v14, v15, v16, v17, v18, v19, v20) | v13) < 0)
      v10 = 0;
    v21 = *(_DWORD *)(a1 + 80);
    v8 = *(_DWORD *)(a1 + 76) + 1;
    *(_DWORD *)(a1 + 76) = v8;
  }
  while (v8 < v21);
  if (v10)
    return 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamToNextNonEmptyBlob", 204, 111, 0, "iterating to next non-empty blob", a7, a8, v23);
  return 0xFFFFFFFFLL;
}

uint64_t convertStreamEndEntry(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  char v6;

  v4 = sendHeader(a1);
  if (v4 < 0)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamEndEntry", 182, 111, 0, "send header", v2, v3, v6);
  AAHeaderDestroy(*(AAHeader *)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  OECCStreamDestroy(*(void ***)(a1 + 776));
  *(_QWORD *)(a1 + 776) = 0;
  free(*(void **)(a1 + 128));
  memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
  return (v4 >> 31);
}

uint64_t convertStreamBeginBlob(uint64_t a1, AAFieldKey a2, uint64_t a3)
{
  int KeyIndex;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  size_t v13;
  size_t v14;
  void **v15;
  void *v16;
  void *v17;
  unint64_t v18;
  size_t v19;
  void **v20;
  const char *v21;
  __int16 v22;
  char *v23;
  void *v24;
  char *v25;
  char v27;

  KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), a2);
  *(_DWORD *)(a1 + 72) = KeyIndex >= 0;
  if (KeyIndex < 0 || *(_DWORD *)(a1 + 64))
  {
LABEL_3:
    v9 = 1;
    goto LABEL_40;
  }
  v11 = (_QWORD *)(a1 + 112);
  v10 = *(_QWORD *)(a1 + 112);
  v12 = a3 + v10 + 24;
  if ((v12 & 0x8000000000000000) != 0)
    goto LABEL_29;
  v13 = *(_QWORD *)(a1 + 120);
  if (v13 < v12)
  {
    do
    {
      while (!v13)
      {
        v13 = 0x4000;
        if (v12 <= 0x4000)
        {
          v15 = (void **)(a1 + 128);
          v13 = 0x4000;
          goto LABEL_15;
        }
      }
      v14 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0)
        v14 = v13 & (v13 >> 1);
      v13 += v14;
    }
    while (v13 < v12);
    v15 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_28;
    }
LABEL_15:
    v16 = *v15;
    v17 = realloc(*v15, v13);
    if (v17)
    {
      *(_QWORD *)(a1 + 120) = v13;
      *(_QWORD *)(a1 + 128) = v17;
      v10 = *(_QWORD *)(a1 + 112);
      goto LABEL_17;
    }
    free(v16);
LABEL_28:
    *v15 = 0;
    *v11 = 0;
    *(_QWORD *)(a1 + 120) = 0;
LABEL_29:
    v21 = "allocating blob buffer";
    v22 = 87;
    goto LABEL_39;
  }
LABEL_17:
  v18 = v10 + 24;
  if (v10 < 0xFFFFFFFFFFFFFFE8 && (v18 & 0x8000000000000000) == 0)
  {
    if (v13 >= v18)
    {
      v23 = *(char **)(a1 + 128);
LABEL_35:
      v25 = &v23[v10];
      *(AAFieldKey *)v25 = a2;
      *((_DWORD *)v25 + 1) = 0;
      *((_QWORD *)v25 + 1) = a3;
      *((_QWORD *)v25 + 2) = 0;
      *v11 += 24;
      goto LABEL_3;
    }
    do
    {
      while (!v13)
      {
        v13 = 0x4000;
        if (v18 <= 0x4000)
        {
          v20 = (void **)(a1 + 128);
          v13 = 0x4000;
          goto LABEL_33;
        }
      }
      v19 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0)
        v19 = v13 & (v13 >> 1);
      v13 += v19;
    }
    while (v13 < v18);
    v20 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_37;
    }
LABEL_33:
    v24 = *v20;
    v23 = (char *)realloc(*v20, v13);
    if (v23)
    {
      *(_QWORD *)(a1 + 120) = v13;
      *(_QWORD *)(a1 + 128) = v23;
      v10 = *(_QWORD *)(a1 + 112);
      goto LABEL_35;
    }
    free(v24);
LABEL_37:
    *v20 = 0;
    *v11 = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  v21 = "accumulating blob data";
  v22 = 91;
LABEL_39:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamBeginBlob", v22, 111, 0, v21, v7, v8, v27);
  v9 = 0;
LABEL_40:
  if (v9)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t convertStreamEndBlob(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  const char *v10;
  __int16 v11;
  AAFieldKey v12;
  uint32_t KeyIndex;
  AAFieldKey v14;
  AAFieldKey v15;
  uint32_t v16;
  AAFieldKey v17;
  AAFieldKey v18;
  uint32_t v19;
  AAFieldKey v20;
  AAFieldKey v21;
  uint32_t v22;
  AAFieldKey v23;
  AAFieldKey v24;
  uint32_t v25;
  AAFieldKey v26;
  uint64_t v27;
  AAFieldKey v28;
  uint32_t v29;
  AAFieldKey v30;
  size_t DataSize;
  const void *DataPtr;
  AAFieldKey v33;
  int v34;
  char v36;
  unsigned int md[16];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 88) + 24 * *(unsigned int *)(a1 + 76)) & 0xFFFFFF) != 0x544144)
    goto LABEL_31;
  v9 = *(_DWORD *)(a1 + 136);
  if (!v9)
  {
LABEL_28:
    if ((sendHeader(a1) & 0x80000000) != 0)
    {
      v10 = "send header";
      v11 = 162;
      goto LABEL_46;
    }
    if ((*(_BYTE *)(a1 + 136) & 0x20) != 0)
    {
      DataSize = OECCStreamGetDataSize(*(_QWORD *)(a1 + 776));
      DataPtr = (const void *)OECCStreamGetDataPtr(*(_QWORD *)(a1 + 776));
      v33.ikey = 4408665;
      if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v33, DataPtr, DataSize) < 0)
      {
        v10 = "sending blob data";
        v11 = 169;
        goto LABEL_46;
      }
    }
LABEL_31:
    v34 = 1;
    goto LABEL_47;
  }
  if (!*(_DWORD *)(a1 + 64))
  {
    if ((v9 & 2) != 0)
    {
      CC_SHA1_Deprecated_Final((unsigned __int8 *)md, (CC_SHA1_CTX *)(a1 + 160));
      v12.ikey = 3229779;
      KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v12);
      if ((KeyIndex & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 117;
        goto LABEL_46;
      }
      v14.ikey = 3229779;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), KeyIndex, v14, 2u, (const uint8_t *)md) < 0)
      {
        v10 = "updating new header field";
        v11 = 118;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }
    if ((v9 & 4) != 0)
    {
      CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(a1 + 256));
      v15.ikey = 3295315;
      v16 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v15);
      if ((v16 & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 125;
        goto LABEL_46;
      }
      v17.ikey = 3295315;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v16, v17, 3u, (const uint8_t *)md) < 0)
      {
        v10 = "updating new header field";
        v11 = 126;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }
    if ((v9 & 8) != 0)
    {
      CC_SHA384_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 360));
      v18.ikey = 3360851;
      v19 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v18);
      if ((v19 & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 133;
        goto LABEL_46;
      }
      v20.ikey = 3360851;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v19, v20, 4u, (const uint8_t *)md) < 0)
      {
        v10 = "updating new header field";
        v11 = 134;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }
    if ((v9 & 0x10) != 0)
    {
      CC_SHA512_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 568));
      v21.ikey = 3491923;
      v22 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v21);
      if ((v22 & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 141;
        goto LABEL_46;
      }
      v23.ikey = 3491923;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v22, v23, 5u, (const uint8_t *)md) < 0)
      {
        v10 = "updating new header field";
        v11 = 142;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }
    if ((v9 & 1) != 0)
    {
      CC_CKSUM_Final(md, a1 + 144);
      v24.ikey = 5458755;
      v25 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v24);
      if ((v25 & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 149;
        goto LABEL_46;
      }
      v26.ikey = 5458755;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v25, v26, 1u, (const uint8_t *)md) < 0)
      {
        v10 = "updating new header field";
        v11 = 150;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }
    if ((v9 & 0x20) != 0)
    {
      v27 = OECCStreamGetDataSize(*(_QWORD *)(a1 + 776));
      v28.ikey = 4408665;
      v29 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v28);
      if ((v29 & 0x80000000) != 0)
      {
        v10 = "Missing field in new header";
        v11 = 157;
        goto LABEL_46;
      }
      v30.ikey = 4408665;
      if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), v29, v30, v27) < 0)
      {
        v10 = "updating new header field";
        v11 = 158;
        goto LABEL_46;
      }
    }
    goto LABEL_28;
  }
  v10 = "Header has already been sent";
  v11 = 111;
LABEL_46:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamEndBlob", v11, 111, 0, v10, a7, a8, v36);
  v34 = 0;
LABEL_47:
  if (v34)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void *aaInPlaceStreamOpen(AAByteStream_impl *a1)
{
  void *v2;
  pthread_mutex_t *v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  const char *v7;
  __int16 v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t i;
  char v19;

  v2 = calloc(1uLL, 0x68uLL);
  v3 = (pthread_mutex_t *)calloc(1uLL, 0x80uLL);
  v6 = v3;
  if (!v3 || !v2)
  {
    v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamOpen", 237, 126, *v9, "malloc", v10, v11, v19);
    free(v2);
    if (!v6)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (!*((_QWORD *)a1 + 4) || !*((_QWORD *)a1 + 5) || !*((_QWORD *)a1 + 6) || !*((_QWORD *)a1 + 8))
  {
    v7 = "stream not in-place compatible\n";
    v8 = 243;
    goto LABEL_12;
  }
  if (pthread_mutex_init(v3, 0))
  {
    v7 = "mutex failed";
    v8 = 246;
LABEL_12:
    v12 = 0;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamOpen", v8, 126, v12, v7, v4, v5, v19);
    free(v2);
LABEL_14:
    pthread_mutex_destroy(v6);
    free(*(void **)&v6[1].__opaque[32]);
LABEL_15:
    free(v6);
    return 0;
  }
  v6[1].__sig = (uint64_t)a1;
  *(_QWORD *)v6[1].__opaque = 0;
  *(_QWORD *)&v6[1].__opaque[16] = 0;
  v14 = AAByteStreamSeek(a1, 0, 2);
  *(_QWORD *)&v6[1].__opaque[8] = v14;
  *(_QWORD *)&v6[1].__opaque[24] = 0;
  if ((v14 & 0x8000000000000000) != 0)
  {
    v7 = "bad input size";
    v8 = 252;
    goto LABEL_12;
  }
  *(_QWORD *)&v6[1].__opaque[40] = (v14 + 0xFFFFF) >> 20;
  if (v14 >= 0x20000000000001)
  {
    *__error() = 12;
    *(_QWORD *)&v6[1].__opaque[32] = 0;
LABEL_26:
    v12 = *__error();
    v7 = "malloc";
    v8 = 257;
    goto LABEL_13;
  }
  v15 = (char *)calloc((v14 + 0xFFFFF) >> 20, 0x10uLL);
  *(_QWORD *)&v6[1].__opaque[32] = v15;
  if (!v15)
    goto LABEL_26;
  v16 = *(_QWORD *)&v6[1].__opaque[40];
  if (v16)
  {
    v17 = v15 + 8;
    for (i = v16 - 1; ; --i)
    {
      *(v17 - 1) = 0;
      if (!i)
        break;
      *v17 = 0x100000;
      v17 += 2;
    }
    *v17 = ((*(_DWORD *)&v6[1].__opaque[8] - 1) & 0xFFFFF) + 1;
  }
  AACustomByteStreamSetData((AAByteStream)v2, v6);
  AACustomByteStreamSetPReadProc((AAByteStream)v2, (AAByteStreamPReadProc)aaInPlaceStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v2, (AAByteStreamPWriteProc)aaInPlaceStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v2, (AAByteStreamReadProc)aaInPlaceStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v2, (AAByteStreamWriteProc)aaInPlaceStreamWrite);
  AACustomByteStreamSetSeekProc((AAByteStream)v2, (AAByteStreamSeekProc)aaInPlaceStreamSeek);
  AACustomByteStreamSetCloseProc((AAByteStream)v2, (AAByteStreamCloseProc)aaInPlaceStreamClose);
  AACustomByteStreamSetCancelProc((AAByteStream)v2, (AAByteStreamCancelProc)aaInPlaceStreamCancel);
  return v2;
}

uint64_t aaInPlaceStreamPRead(uint64_t a1, void *a2, size_t a3, uint64_t a4)
{
  return blockReader(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamPWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  return blockWriter(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return blockReader(a1, a2, a3, 0, 1);
}

uint64_t aaInPlaceStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  return blockWriter(a1, a2, a3, 0, 1);
}

uint64_t aaInPlaceStreamSeek(uint64_t a1, off_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  off_t v8;
  off_t v10;
  char v11;

  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamSeek", 176, 126, 0, "MutexLock", v6, v7, v11);
    *(_DWORD *)(a1 + 120) = 1;
    return -1;
  }
  if (*(_DWORD *)(a1 + 120))
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return -1;
  }
  v10 = AAByteStreamSeek(*(AAByteStream *)(a1 + 64), a2, a3);
  v8 = v10;
  if ((v10 & 0x8000000000000000) == 0)
  {
    *(_QWORD *)(a1 + 88) = v10;
    *(_QWORD *)(a1 + 72) = v10;
  }
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v8;
}

uint64_t aaInPlaceStreamClose(pthread_mutex_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v10;

  if (!a1)
    return 0;
  if (!*(_DWORD *)&a1[1].__opaque[48]
    && *(_QWORD *)&a1[1].__opaque[24] < *(_QWORD *)&a1[1].__opaque[8]
    && (AAByteStreamTruncate((_QWORD *)a1[1].__sig) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamClose", 210, 126, 0, "truncate failed", v2, v3, v10);
    v4 = 0xFFFFFFFFLL;
  }
  else
  {
    v4 = 0;
  }
  pthread_mutex_destroy(a1);
  v5 = *(char **)&a1[1].__opaque[32];
  if (v5)
  {
    if (*(_QWORD *)&a1[1].__opaque[40])
    {
      v6 = 0;
      v7 = 0;
      do
      {
        free(*(void **)&v5[v6]);
        v5 = *(char **)&a1[1].__opaque[32];
        v8 = *(_QWORD *)&a1[1].__opaque[40];
        *(_QWORD *)&v5[v6] = 0;
        ++v7;
        v6 += 16;
      }
      while (v7 < v8);
    }
    free(v5);
  }
  free(a1);
  return v4;
}

uint64_t aaInPlaceStreamCancel(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  if (pthread_mutex_lock((pthread_mutex_t *)a1))
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamCancel", 191, 126, 0, "MutexLock", v2, v3, v5);
  if (!*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 1;
    AAByteStreamCancel(*(AAByteStream *)(a1 + 64));
  }
  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

uint64_t blockReader(uint64_t a1, void *a2, size_t a3, uint64_t a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  char **v13;
  uint64_t v14;
  uint64_t v15;
  char **v16;
  unint64_t v17;
  size_t v18;
  char v19;

  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1;
    }
    if (a5)
    {
      a4 = *(_QWORD *)(a1 + 72);
      if (!a3)
        goto LABEL_24;
    }
    else
    {
      *(_QWORD *)(a1 + 72) = a4;
      if (!a3)
        goto LABEL_24;
    }
    if (*(_QWORD *)(a1 + 80) <= a4)
    {
      a3 = 0;
    }
    else
    {
      v13 = blockGetFromCache(a1, a4);
      if (v13)
      {
        v16 = v13;
        v17 = (unint64_t)v13[1];
        if (v17)
        {
          if (0x100000 - (a4 & 0xFFFFFuLL) < v17)
            v17 = 0x100000 - (a4 & 0xFFFFF);
          if (v17 < a3)
            a3 = v17;
          memcpy(a2, &(*v13)[a4 & 0xFFFFF], a3);
          v18 = (size_t)&v16[1][-a3];
          v16[1] = (char *)v18;
          if (!v18)
          {
            free(*v16);
            *v16 = 0;
          }
          *(_QWORD *)(a1 + 72) += a3;
          goto LABEL_24;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockPRead", 72, 126, 0, "block already consumed", v14, v15, v19);
      }
      *(_DWORD *)(a1 + 120) = 1;
      a3 = -1;
    }
LABEL_24:
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return a3;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockReader", 111, 126, 0, "MutexLock", v10, v11, v19);
  *(_DWORD *)(a1 + 120) = 1;
  return -1;
}

char **blockGetFromCache(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  char **v3;
  size_t v4;
  size_t *v5;
  size_t v6;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  const char *v18;
  __int16 v19;
  char v21;

  v2 = (_QWORD *)(*(_QWORD *)(a1 + 104) + 16 * (a2 >> 20));
  v3 = (char **)v2;
  if (!*v2)
  {
    v6 = v2[1];
    v5 = v2 + 1;
    v4 = v6;
    if (v6)
    {
      if (v4 >= 0x2000000001)
      {
        *__error() = 12;
        *v3 = 0;
LABEL_12:
        v17 = *__error();
        v18 = "malloc";
        v19 = 52;
LABEL_13:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockGetFromCache", v19, 126, v17, v18, v10, v11, v21);
        return 0;
      }
      v9 = (char *)malloc(v4);
      *v3 = v9;
      if (!v9)
        goto LABEL_12;
      v12 = *(_QWORD *)(a1 + 64);
      if (*(_QWORD *)(v12 + 32))
      {
        v13 = v9;
        v14 = 0;
        v15 = a2 & 0xFFFFFFFFFFF00000;
        while (1)
        {
          v16 = (*(uint64_t (**)(_QWORD, char *, size_t, unint64_t))(v12 + 32))(*(_QWORD *)v12, v13, v4, v15);
          if (v16 < 0)
            break;
          if (v16)
          {
            v13 += v16;
            v14 += v16;
            v15 += v16;
            v4 -= v16;
            if (v4)
              continue;
          }
          goto LABEL_17;
        }
        v14 = v16;
LABEL_17:
        v4 = *v5;
      }
      else
      {
        v14 = -1;
      }
      if (v14 != v4)
      {
        v18 = "stream read error";
        v19 = 58;
        v17 = 0;
        goto LABEL_13;
      }
    }
  }
  return v3;
}

uint64_t blockWriter(uint64_t a1, const void *a2, size_t a3, uint64_t a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  ssize_t v14;
  ssize_t v15;
  ssize_t v16;
  char v17;

  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1;
    }
    if (a5)
    {
      a4 = *(_QWORD *)(a1 + 88);
      if (a3)
        goto LABEL_9;
    }
    else
    {
      *(_QWORD *)(a1 + 88) = a4;
      if (a3)
      {
LABEL_9:
        if (*(_QWORD *)(a1 + 80) > a4)
        {
          if (!blockGetFromCache(a1, a4))
          {
            v12 = -1;
LABEL_20:
            *(_DWORD *)(a1 + 120) = 1;
            goto LABEL_21;
          }
          if (0x100000 - (a4 & 0xFFFFFuLL) < a3)
            a3 = 0x100000 - (a4 & 0xFFFFF);
        }
        v14 = AAByteStreamPWrite(*(AAByteStream *)(a1 + 64), a2, a3, a4);
        v12 = v14;
        if ((v14 & 0x8000000000000000) == 0)
        {
          if (v14)
          {
            v15 = *(_QWORD *)(a1 + 96);
            v16 = *(_QWORD *)(a1 + 88) + v14;
            *(_QWORD *)(a1 + 88) = v16;
            if (v15 < v16)
              *(_QWORD *)(a1 + 96) = v16;
          }
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
    v12 = 0;
LABEL_21:
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return v12;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockWriter", 131, 126, 0, "MutexLock", v10, v11, v17);
  *(_DWORD *)(a1 + 120) = 1;
  return -1;
}

uint64_t io_hint_static_content(unsigned int **a1)
{
  int FD;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  char v8;

  FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    v6 = "file not open";
    v7 = 63;
  }
  else
  {
    v8 = 1;
    if (fcntl(FD, 68) != -1)
      return 0;
    v6 = "static content hint failed";
    v7 = 64;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_hint_static_content", v7, 137, v6, v2, v3, v4, v8);
  return 0xFFFFFFFFLL;
}

uint64_t io_preallocate(unsigned int **a1, unint64_t a2)
{
  int FD;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;
  char v22;
  _QWORD v23[3];
  uint64_t v24;
  stat v25;

  getRealTime();
  FD = aaFileStreamGetFD(a1);
  memset(&v25, 0, sizeof(v25));
  if (FD < 0)
  {
    v15 = "file not open";
    v16 = 84;
LABEL_12:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", v16, 137, v15, v5, v6, v7, v21);
    LOBYTE(v10) = 0;
    goto LABEL_13;
  }
  v8 = FD;
  if (fstat(FD, &v25) || v25.st_size)
  {
    v15 = "file not empty";
    v16 = 85;
    goto LABEL_12;
  }
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 88, 137, "preallocating %llu B", v5, v6, v7, a2);
  if (!a2)
  {
    v14 = 0;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v23[0] = 0x300000002;
    v23[1] = 0;
    v23[2] = a2 - v10;
    v24 = 0;
    if (fcntl(v8, 42, v23) == -1 || v24 <= 0)
      break;
    v10 += v24;
    ++v9;
    if (v10 >= a2)
    {
      v14 = 0;
      goto LABEL_14;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 99, 137, "preallocation failed", v11, v12, v13, v22);
LABEL_13:
  v14 = 0xFFFFFFFFLL;
LABEL_14:
  getRealTime();
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 110, 137, "preallocation %llu/%llu B took %0.2f seconds (# of calls=%i)", v17, v18, v19, v10);
  return v14;
}

uint64_t io_set_nocache(unsigned int **a1)
{
  int FD;
  uint64_t v2;
  uint64_t v3;
  const char *v5;
  __int16 v6;
  int v7;
  char v8;

  FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    v5 = "aaFileStreamGetFD";
    v6 = 126;
    v7 = 0;
  }
  else
  {
    v8 = 1;
    if (fcntl(FD, 48) != -1)
      return 0;
    v7 = *__error();
    v5 = "fcntl";
    v6 = 127;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_set_nocache", v6, 137, v7, v5, v2, v3, v8);
  return 0xFFFFFFFFLL;
}

uint64_t **aaSegmentStreamOpen(_QWORD *a1, _QWORD *a2)
{
  uint64_t **v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  __int16 v38;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  char v44;

  v3 = (uint64_t **)SegmentStreamCreate(a1, (uint64_t)a2);
  v4 = v3;
  if (v3)
  {
    v5 = *v3;
    v12 = pc_array_indirect_sort(a2[267], compare_extents_by_position);
    if (v12)
    {
      v13 = 0;
      v14 = 0;
      v15 = a2[269];
      do
      {
        if (v13 >= v15)
        {
          v17 = 0;
          v16 = a2 + 265;
        }
        else
        {
          v16 = (unint64_t *)v12[v13];
          v17 = v16[1];
        }
        v18 = *v16;
        v19 = *v16 >= v14;
        v20 = *v16 - v14;
        if (v20 != 0 && v19)
        {
          v40 = v5[397];
          v41 = v20;
          v42 = v14;
          v43 = 0;
          v44 = 0;
          v5[397] = v40 + v20;
          v21 = pc_array_append(v5[395], &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v21;
          if (!v21)
          {
            v37 = "segment_add";
            v38 = 476;
            goto LABEL_28;
          }
          v15 = a2[269];
        }
        v14 = v18 + v17;
        ++v13;
      }
      while (v13 <= v15);
      v22 = v5[397];
      a2[258] = v22;
      v23 = a2[270];
      if (v23)
      {
        v24 = 0;
        while (1)
        {
          v25 = a2[267];
          v26 = a2[268] + 440 * v24;
          *(_QWORD *)(v26 + 32) = 0;
          v27 = (_QWORD *)(v26 + 32);
          v27[1] = v5[397];
          if (v27[49])
            break;
LABEL_19:
          if (++v24 >= v23)
          {
            v22 = v5[397];
            goto LABEL_21;
          }
        }
        v28 = 0;
        v29 = (_QWORD *)v5[395];
        v30 = (uint64_t *)(v25 + 16 * v27[48] + 8);
        while (1)
        {
          v32 = *(v30 - 1);
          v31 = *v30;
          v40 = v5[397];
          v41 = v31;
          v42 = v32;
          v43 = 0;
          v44 = 0;
          v5[397] = v40 + v31;
          v29 = pc_array_append((uint64_t)v29, &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v29;
          if (!v29)
            break;
          v33 = *v30;
          v30 += 2;
          *v27 += v33;
          if ((unint64_t)++v28 >= v27[49])
          {
            v23 = a2[270];
            goto LABEL_19;
          }
        }
        v37 = "segment_add";
        v38 = 500;
      }
      else
      {
LABEL_21:
        v5[396] = *(_QWORD *)(v5[395] - 64);
        if (v22 == a2[265])
        {
          free(v12);
          return v4;
        }
        v37 = "bad image";
        v38 = 507;
      }
    }
    else
    {
      v37 = "pc_array_indirect_sort";
      v38 = 465;
    }
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", v38, 137, 0, v37, v10, v11, v40);
  }
  else
  {
    v34 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", 457, 137, *v34, "aaSegmentStreamOpen", v35, v36, v40);
    v12 = 0;
    v5 = 0;
  }
  free(v12);
  free(v4);
  SegmentStreamClose((uint64_t)v5);
  return 0;
}

_QWORD *SegmentStreamCreate(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int v9;
  const char *v10;
  __int16 v11;
  char v13;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = calloc(1uLL, 0xC78uLL);
  v8 = v5;
  if (!v4 || !v5)
  {
    v9 = *__error();
    v10 = "malloc";
    v11 = 416;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamCreate", v11, 137, v9, v10, v6, v7, v13);
    free(v4);
    SegmentStreamClose((uint64_t)v8);
    return 0;
  }
  if (!a1[4] || !a1[5])
  {
    v10 = "stream not compatible";
    v11 = 417;
    v9 = 0;
    goto LABEL_9;
  }
  *v5 = a1;
  v5[1] = a2;
  v5[395] = pc_array_init(29);
  AACustomByteStreamSetData((AAByteStream)v4, v8);
  AACustomByteStreamSetPReadProc((AAByteStream)v4, (AAByteStreamPReadProc)SegmentStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v4, (AAByteStreamPWriteProc)SegmentStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v4, (AAByteStreamCancelProc)SegmentStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v4, (AAByteStreamCloseProc)SegmentStreamClose);
  if (a1[11])
    v4[11] = SegmentStreamSimulate;
  return v4;
}

uint64_t SegmentStreamClose(uint64_t a1)
{
  uint64_t i;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 3152))
    {
      for (i = 16; i != 3088; i += 24)
        free(*(void **)(a1 + i));
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3088));
    }
    pc_array_free(*(_QWORD *)(a1 + 3160));
    free((void *)a1);
  }
  return 0;
}

uint64_t *aaForkInputStreamOpen(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  _QWORD *v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  int v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  char *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  _QWORD *v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  const char *v56;
  __int16 v57;
  char v58;
  uint64_t *v59;
  int v60;
  _QWORD *v61;
  char v62;
  char v63;
  char v64;
  uint64_t v65;
  uint64_t __src;
  __int128 v67;
  int v68;
  char v69;

  if ((*(_BYTE *)(a2 + 2128) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 538, 137, 0, "no chunk info", a7, a8, v58);
    v8 = 0;
LABEL_13:
    v13 = 0;
    goto LABEL_16;
  }
  v10 = (_QWORD *)a2;
  v12 = SegmentStreamCreate(a1, a2);
  v8 = v12;
  if (!v12)
  {
    v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 542, 137, *v26, "SegmentStreamCreate", v27, v28, v58);
    goto LABEL_13;
  }
  v13 = *v12;
  if (a1[11])
    *(_DWORD *)(v13 + 3184) = 1;
  v14 = 0;
  *(_QWORD *)(v13 + 3152) = 1;
  do
  {
    v15 = malloc(0x10000uLL);
    v16 = v13 + v14;
    *(_QWORD *)(v16 + 16) = v15;
    *(_QWORD *)(v16 + 24) = -1;
    if (!v15)
    {
      v25 = *__error();
      v23 = "malloc";
      v24 = 554;
      goto LABEL_15;
    }
    v14 += 24;
  }
  while (v14 != 3072);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 3088), 0))
  {
    v23 = "MutexInit";
    v24 = 556;
    goto LABEL_11;
  }
  v59 = v8;
  v63 = 0;
  v61 = v10;
  v62 = 1;
  v60 = a3;
  while (!v10[270])
  {
LABEL_36:
    v8 = v59;
    if ((v62 & 1) == 0)
    {
      *(_QWORD *)(v13 + 3168) = *(_QWORD *)(*(_QWORD *)(v13 + 3160) - 64);
      v10[260] = *(_QWORD *)(v13 + 3176);
      return v8;
    }
    v53 = *(_QWORD *)(v13 + 3176);
    v10[257] = v53;
    v54 = v10[258];
    if (v54)
    {
      __src = v53;
      v67 = v54;
      v68 = 0;
      v69 = 0;
      *(_QWORD *)(v13 + 3176) = v54 + v53;
      v55 = pc_array_append(*(_QWORD *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(_QWORD *)(v13 + 3160) = v55;
      if (!v55)
      {
        v23 = "segment_add";
        v24 = 607;
LABEL_11:
        v25 = 0;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v24, 137, v25, v23, v21, v22, v58);
        goto LABEL_16;
      }
      v53 = *(_QWORD *)(v13 + 3176);
    }
    v62 = 0;
    v10[259] = v53;
    v63 = 1;
  }
  v30 = 0;
  while (1)
  {
    v65 = v10[268];
    if (a3)
      LOBYTE(v31) = 1;
    else
      v31 = *(_QWORD *)(v10[268] + 440 * v30 + 408);
    v64 = v31;
    if (!(v63 & 1 | ((v31 & 1) == 0)))
      break;
LABEL_33:
    if (!(v62 & 1 | ((v64 & 2) == 0)))
    {
      v49 = *(_QWORD *)(v13 + 3176);
      v50 = v65 + 440 * v30;
      *(_QWORD *)(v50 + 48) = v49;
      v51 = *(_OWORD *)(v50 + 32);
      __src = v49;
      v67 = v51;
      v68 = 0;
      v69 = 0;
      *(_QWORD *)(v13 + 3176) = v51 + v49;
      v52 = pc_array_append(*(_QWORD *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(_QWORD *)(v13 + 3160) = v52;
      if (!v52)
      {
        v56 = "segment_add";
        v57 = 597;
        goto LABEL_42;
      }
    }
LABEL_35:
    ++v30;
    v10 = v61;
    a3 = v60;
    if (v30 >= v61[270])
      goto LABEL_36;
  }
  v32 = v65 + 440 * v30;
  if (!*(_QWORD *)(v32 + 384))
  {
    v56 = "no chunks found";
    v57 = 572;
    goto LABEL_42;
  }
  v33 = v65 + 440 * v30;
  v35 = *(_QWORD *)(v33 + 56);
  v34 = (unint64_t *)(v33 + 56);
  *(v34 - 1) = *(_QWORD *)(v13 + 3176);
  if (!v35)
    goto LABEL_35;
  v36 = 0;
  v37 = 0;
  v38 = (_QWORD *)(v32 + 384);
  v39 = v65 + 440 * v30;
  v40 = *(_QWORD *)(v39 + 392);
  v41 = (_QWORD *)(v39 + 40);
  v42 = (char *)(v39 + 432);
  v43 = *(_QWORD **)(v13 + 3160);
  while (1)
  {
    v44 = *v38 + v36;
    v45 = v40 >= 0x10000 ? 0x10000 : v40;
    v46 = *(_QWORD *)v44 + *v41;
    v47 = *(_DWORD *)(v44 + 8);
    v48 = *v42;
    __src = *(_QWORD *)(v13 + 3176);
    *(_QWORD *)&v67 = v45;
    *((_QWORD *)&v67 + 1) = v46;
    v68 = v47;
    v69 = v48;
    *(_QWORD *)(v13 + 3176) = __src + v45;
    v43 = pc_array_append((uint64_t)v43, &__src, v17, v18, v19, v20, v21, v22);
    *(_QWORD *)(v13 + 3160) = v43;
    if (!v43)
      break;
    v40 -= v45;
    ++v37;
    v36 += 12;
    if (v37 >= *v34)
      goto LABEL_33;
  }
  v56 = "segment_add";
  v57 = 584;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v57, 137, 0, v56, v21, v22, v58);
  v8 = v59;
LABEL_16:
  free(v8);
  SegmentStreamClose(v13);
  return 0;
}

AAByteStream_impl *aaIntervalInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AAByteStream_impl *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  __int16 v12;
  int v13;
  char v15;

  v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  v7 = calloc(1uLL, 0x20uLL);
  v10 = v7;
  if (v6 && v7)
  {
    if (a3 >= a2)
    {
      *v7 = a1;
      v7[1] = a2;
      v7[2] = a3 - a2;
      v7[3] = 0;
      AACustomByteStreamSetData(v6, v7);
      AACustomByteStreamSetReadProc(v6, (AAByteStreamReadProc)IntervalStreamRead);
      AACustomByteStreamSetPReadProc(v6, (AAByteStreamPReadProc)IntervalStreamPRead);
      AACustomByteStreamSetSeekProc(v6, (AAByteStreamSeekProc)IntervalStreamSeek);
      AACustomByteStreamSetCancelProc(v6, (AAByteStreamCancelProc)IntervalStreamCancel);
      AACustomByteStreamSetCloseProc(v6, (AAByteStreamCloseProc)IntervalStreamClose);
      return v6;
    }
    v11 = "bad interval";
    v12 = 703;
    v13 = 0;
  }
  else
  {
    v13 = *__error();
    v11 = "malloc";
    v12 = 702;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaIntervalInputStreamOpen", v12, 137, v13, v11, v8, v9, v15);
  free(v6);
  free(v10);
  return 0;
}

ssize_t IntervalStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return IntervalStreamPRead(a1, a2, a3, *(_QWORD *)(a1 + 24));
}

ssize_t IntervalStreamPRead(uint64_t a1, void *a2, size_t a3, int64_t a4)
{
  int64_t v5;
  ssize_t result;

  if (!a3)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 == a4)
    return 0;
  if (v5 < a4)
    return -1;
  if ((uint64_t)(a4 + a3) > v5)
    a3 = v5 - a4;
  result = AAByteStreamPRead(*(AAByteStream *)a1, a2, a3, *(_QWORD *)(a1 + 8) + a4);
  if (result < 0)
    return -1;
  *(_QWORD *)(a1 + 24) += result;
  return result;
}

uint64_t IntervalStreamSeek(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v3;

  if (a3)
  {
    v3 = (_QWORD *)(a1 + 24);
    if (a3 != 1)
    {
      if (a3 != 2)
        return -1;
      v3 = (_QWORD *)(a1 + 16);
    }
    a2 += *v3;
  }
  if ((a2 & 0x8000000000000000) == 0 && a2 <= *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 24) = a2;
    return a2;
  }
  return -1;
}

void IntervalStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t IntervalStreamClose(void *a1)
{
  free(a1);
  return 0;
}

uint64_t SegmentStreamPRead(_QWORD **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t v7;
  pthread_mutex_t *v8;
  _QWORD **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD **v39;
  uint64_t *v40;
  uint8_t *v41;
  uint64_t v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint8_t *v49;
  uint64_t v50;
  BOOL v51;
  size_t v52;
  uint8_t *v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  size_t v58;
  uint64_t v59;
  const char *v60;
  __int16 v61;
  int v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  char v68;
  uint64_t v69;
  uint64_t *v70;
  _QWORD *v71;
  void **v72;
  unint64_t *v73;
  uint8_t *src_buffer;
  pthread_mutex_t *v75;
  size_t __n;
  size_t __na;
  unint64_t v80;
  uint64_t v81;
  _QWORD *v82;

  if (!a3)
    return 0;
  v5 = a3;
  v7 = 0;
  v8 = (pthread_mutex_t *)(a1 + 386);
  v9 = a1 + 2;
  v73 = (unint64_t *)(a1 + 4);
  v75 = (pthread_mutex_t *)(a1 + 386);
  while (1)
  {
    v10 = segment_find(a1, a4);
    if (!v10)
    {
      v63 = "no segment found";
      v64 = 321;
      goto LABEL_74;
    }
    v13 = v10;
    v14 = a4 - *(_QWORD *)v10;
    if (v5 - v7 >= *(_QWORD *)(v10 + 8) - v14)
      v15 = *(_QWORD *)(v10 + 8) - v14;
    else
      v15 = v5 - v7;
    if (!*(_DWORD *)(v10 + 24))
    {
      v22 = (uint64_t)*a1;
      if ((*a1)[4])
      {
        if (!v15)
          goto LABEL_41;
        v23 = 0;
        v24 = a2 + v7;
        v25 = v15;
        v26 = *(_QWORD *)(v10 + 16) + a4 - *(_QWORD *)v10;
        __n = v25;
        while (1)
        {
          v27 = (*(uint64_t (**)(_QWORD, uint64_t, size_t, unint64_t))(v22 + 32))(*(_QWORD *)v22, v24, v25, v26);
          if (v27 < 0)
            break;
          if (v27)
          {
            v24 += v27;
            v23 += v27;
            v26 += v27;
            v25 -= v27;
            if (v25)
              continue;
          }
          goto LABEL_39;
        }
        v23 = v27;
      }
      else
      {
        __n = v15;
        v23 = -1;
      }
LABEL_39:
      v15 = __n;
      v51 = __n == v23;
      v8 = v75;
      v5 = a3;
      if (!v51)
      {
        v63 = "aaSegmentStreamProcess";
        v64 = 337;
        goto LABEL_74;
      }
LABEL_41:
      if (*((_DWORD *)a1 + 796) && v15 != aaByteStreamSimulate(*a1))
      {
        v63 = "aaByteStreamSimulate";
        v64 = 340;
        goto LABEL_74;
      }
      goto LABEL_57;
    }
    v81 = *(unsigned __int8 *)(v10 + 28);
    v82 = a1[1];
    if (pthread_mutex_lock(v8))
    {
      v60 = "MutexLock";
      v61 = 169;
LABEL_62:
      v62 = 0;
      goto LABEL_68;
    }
    v18 = *(_QWORD *)(v13 + 16);
    v19 = ((unint64_t)(0x317E428CA9 * v18) >> 32) & 0x7F;
    v20 = &v9[3 * v19];
    if (v20[1] != v18)
      break;
    v21 = (uint64_t)a1[394] + 1;
    a1[394] = (_QWORD *)v21;
    v9[3 * v19 + 2] = (_QWORD *)v21;
LABEL_26:
    memcpy((void *)(a2 + v7), (const void *)(*v20 + v14), v15);
    v41 = 0;
LABEL_53:
    if (pthread_mutex_unlock(v8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", 208, 137, 0, "MutexUnlock", v56, v57, v68);
      goto LABEL_73;
    }
    free(v41);
    if (*((_DWORD *)a1 + 796))
    {
      v58 = v15;
      v59 = *(unsigned int *)(v13 + 24);
      v51 = aaByteStreamSimulate(*a1) == v59;
      v15 = v58;
      if (!v51)
      {
        v63 = "aaByteStreamSimulate";
        v64 = 333;
        goto LABEL_74;
      }
    }
LABEL_57:
    a4 += v15;
    v7 += v15;
    if (v7 >= v5)
      return v7;
  }
  v28 = 0;
  v29 = 0;
  v30 = v73;
  while (*(v30 - 1) != v18)
  {
    v31 = *v30;
    v30 += 3;
    if (v31 < (unint64_t)v9[3 * v29 + 2])
      v29 = v28;
    if (++v28 == 128)
      goto LABEL_25;
  }
  v29 = v28;
LABEL_25:
  v32 = (_QWORD *)v20[2];
  v33 = *(_OWORD *)v20;
  v34 = &v9[3 * v29];
  v35 = v34[2];
  *(_OWORD *)v20 = *(_OWORD *)v34;
  v20[2] = v35;
  *(_OWORD *)v34 = v33;
  v34[2] = v32;
  v36 = v20[1];
  v37 = *(_QWORD *)(v13 + 16);
  v38 = (uint64_t)a1[394] + 1;
  a1[394] = (_QWORD *)v38;
  v39 = &v9[3 * v19];
  v39[2] = (_QWORD *)v38;
  v40 = (uint64_t *)(v39 + 2);
  if (v36 == v37)
    goto LABEL_26;
  v70 = v40;
  v71 = v20 + 1;
  v72 = (void **)v20;
  if (pthread_mutex_unlock(v8))
  {
    v60 = "MutexUnlock";
    v61 = 175;
    goto LABEL_62;
  }
  v42 = *(unsigned int *)(v13 + 24);
  v43 = *(_QWORD *)(v13 + 8) + v42;
  if (v43 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_67:
    v62 = *__error();
    v60 = "aaMalloc";
    v61 = 179;
LABEL_68:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v61, 137, v62, v60, v16, v17, v68);
    v41 = 0;
    goto LABEL_73;
  }
  src_buffer = (uint8_t *)malloc(v43);
  if (!src_buffer)
    goto LABEL_67;
  v46 = (uint64_t)*a1;
  if ((*a1)[4])
  {
    __na = v15;
    v80 = v14;
    v69 = v42;
    v47 = 0;
    if ((_DWORD)v42)
    {
      v48 = *(_QWORD *)(v13 + 16);
      v49 = src_buffer;
      while (1)
      {
        v50 = (*(uint64_t (**)(_QWORD, uint8_t *, uint64_t, uint64_t))(v46 + 32))(*(_QWORD *)v46, v49, v42, v48);
        if (v50 < 0)
          break;
        if (v50)
        {
          v49 += v50;
          v47 += v50;
          v48 += v50;
          v42 -= v50;
          if (v42)
            continue;
        }
        goto LABEL_45;
      }
      v47 = v50;
    }
LABEL_45:
    v51 = v47 == v69;
    v8 = v75;
    v5 = a3;
    if (v51)
    {
      v52 = *(_QWORD *)(v13 + 8);
      if (*src_buffer == BYTE4(v82[v81]))
      {
        if (v52 + 1 != *(_DWORD *)(v13 + 24))
        {
          v65 = "chunk error";
          v66 = 189;
          goto LABEL_72;
        }
        v53 = src_buffer + 1;
      }
      else
      {
        v54 = *(unsigned int *)(v13 + 24);
        v53 = &src_buffer[v54];
        if (compression_decode_buffer(&src_buffer[v54], v52, src_buffer, v54, 0, (compression_algorithm)LODWORD(v82[v81])) != *(_QWORD *)(v13 + 8))
        {
          v65 = "compression_decode_buffer";
          v66 = 195;
          goto LABEL_72;
        }
      }
      memcpy((void *)(a2 + v7), &v53[v80], __na);
      if (pthread_mutex_lock(v75))
      {
        v65 = "MutexLock";
        v66 = 202;
        goto LABEL_72;
      }
      memcpy(*v72, v53, *(_QWORD *)(v13 + 8));
      *v71 = *(_QWORD *)(v13 + 16);
      v55 = (uint64_t)a1[394] + 1;
      a1[394] = (_QWORD *)v55;
      *v70 = v55;
      v15 = __na;
      v41 = src_buffer;
      goto LABEL_53;
    }
  }
  v65 = "aaByteStreamPReadExpected";
  v66 = 183;
LABEL_72:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v66, 137, 0, v65, v44, v45, v68);
  v41 = src_buffer;
LABEL_73:
  free(v41);
  v63 = "segment_decode_to_buffer";
  v64 = 330;
LABEL_74:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPRead", v64, 137, 0, v63, v11, v12, v68);
  return -1;
}

uint64_t SegmentStreamPWrite(_QWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  char v22;

  if (!a3)
    return 0;
  v7 = 0;
  while (1)
  {
    v8 = segment_find(a1, a4);
    if (!v8)
    {
      v19 = "no segment found";
      v20 = 363;
      goto LABEL_23;
    }
    v11 = a4 - *(_QWORD *)v8;
    if (a3 - v7 >= *(_QWORD *)(v8 + 8) - v11)
      v12 = *(_QWORD *)(v8 + 8) - v11;
    else
      v12 = a3 - v7;
    if (*(_DWORD *)(v8 + 24))
    {
      v19 = "compressed content";
      v20 = 370;
      goto LABEL_23;
    }
    v13 = *a1;
    if (!*(_QWORD *)(*a1 + 40))
    {
      v14 = -1;
      goto LABEL_16;
    }
    if (v12)
      break;
LABEL_17:
    a4 += v12;
    v7 += v12;
    if (v7 >= a3)
      return v7;
  }
  v14 = 0;
  v15 = a2 + v7;
  v16 = *(_QWORD *)(v8 + 16) + v11;
  v17 = v12;
  while (1)
  {
    v18 = (*(uint64_t (**)(_QWORD, uint64_t, unint64_t, unint64_t))(v13 + 40))(*(_QWORD *)v13, v15, v17, v16);
    if (v18 < 1)
      break;
    v15 += v18;
    v14 += v18;
    v16 += v18;
    v17 -= v18;
    if (!v17)
      goto LABEL_16;
  }
  v14 = v18;
LABEL_16:
  if (v12 == v14)
    goto LABEL_17;
  v19 = "aaByteStreamPWriteExpected";
  v20 = 374;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPWrite", v20, 137, 0, v19, v9, v10, v22);
  return -1;
}

void SegmentStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t SegmentStreamSimulate(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  __int16 v15;
  char v17;

  v8 = 0;
  while (a4 > v8)
  {
    v9 = segment_find(a1, a5);
    if (!v9)
    {
      v14 = "no segment found";
      v15 = 276;
      goto LABEL_12;
    }
    v12 = *(_QWORD *)(v9 + 8) - (a5 - *(_QWORD *)v9);
    if (a4 - v8 < v12)
      v12 = a4 - v8;
    a5 += v12;
    v8 += v12;
    if (*(_DWORD *)(v9 + 24))
      v13 = *(unsigned int *)(v9 + 24);
    else
      v13 = v12;
    if (v13 != aaByteStreamSimulate((_QWORD *)*a1))
    {
      v14 = "aaByteStreamSimulate";
      v15 = 303;
LABEL_12:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamSimulate", v15, 137, 0, v14, v10, v11, v17);
      return -1;
    }
  }
  return v8;
}

uint64_t segment_find(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (a1[397] <= a2)
    return 0;
  v2 = a1[396];
  v3 = a1[395];
  if (v2 < 2)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      if (*(_QWORD *)(v3 + 29 * ((v2 + v4) >> 1)) > a2)
        v2 = (v2 + v4) >> 1;
      else
        v4 = (v2 + v4) >> 1;
    }
    while (v4 + 1 < v2);
  }
  return v3 + 29 * v4;
}

uint64_t load_variants(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  const char **v6;
  FILE **v7;
  const char **v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  BOOL v20;
  const char *v22;
  __int16 v23;
  char v25;

  v4 = 0;
  v5 = 0;
  v6 = (const char **)(a2 + 16);
  v7 = (FILE **)MEMORY[0x24BDAC8D8];
  while (1)
  {
    v8 = v6;
    if (v4)
      v8 = (const char **)(*(_QWORD *)(a2 + 8) + 8 * v4 - 8);
    v9 = rawimg_create_with_path(*v8);
    *(_QWORD *)(a1 + 8 * v4) = v9;
    if (!v9)
    {
      v22 = "rawimg_create_with_file";
      v23 = 37;
      goto LABEL_26;
    }
    if ((rawimg_get_digests((uint64_t)v9, *(_DWORD *)(a2 + 36), 0, 0) & 0x80000000) != 0)
      break;
    v12 = *(uint64_t **)(a1 + 8 * v4);
    if (v4 < 2)
    {
LABEL_19:
      *(_QWORD *)(a1 + 8 * v5++) = v12;
    }
    else
    {
      v13 = 1;
      while (1)
      {
        v14 = *(_QWORD **)(a1 + 8 * v13);
        v15 = v14[261];
        v16 = v14[262];
        v17 = v14[263];
        v18 = v14[264];
        v19 = v12[261] == v15 && v12[262] == v16;
        v20 = v19 && v12[263] == v17;
        if (v20 && v12[264] == v18)
          break;
        if (v4 == ++v13)
          goto LABEL_19;
      }
      rawimg_destroy(v12);
      if (*(_DWORD *)(a2 + 40))
        fprintf(*v7, "ImageDiff: Removed non-unique input variant <%s>.\n", *(const char **)(*(_QWORD *)(a1 + 8 * v4) + 2048));
    }
    if (++v4 > *(_QWORD *)a2)
      return v5;
  }
  v22 = "rawimg_get_digests";
  v23 = 38;
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"load_variants", v23, 134, 0, v22, v10, v11, v25);
  return 0;
}

uint64_t patch_write_controls(AAByteStream_impl *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  off_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  AAFlagSet v12;
  AAByteStream v13;
  uint64_t v14;
  uint64_t v15;
  AAByteStream_impl *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  v8 = AAByteStreamSeek(a1, 0, 1);
  *(_QWORD *)(a3 + 38) = v8;
  if (v8 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 331, 134, 0, "AAByteStreamSeek", v9, v10, v33);
    v20 = 0;
    v16 = 0;
  }
  else
  {
    v11 = *(unsigned int *)(a4 + 40);
    if (v11 <= 3)
      v12 = v11 << 62;
    else
      v12 = 0xC000000000000000;
    v13 = AACompressionOutputStreamOpen(a1, 0x306u, 0x100000uLL, v12, *(_DWORD *)(a4 + 36));
    v16 = v13;
    if (v13)
    {
      v17 = a2[2];
      if (v17 < 2)
      {
        v21 = a2[3];
        v18 = (uint64_t *)(v21 + 56);
        v19 = (uint64_t *)(v21 + 40);
      }
      else
      {
        v18 = (uint64_t *)(a2 + 11);
        v19 = (uint64_t *)(a2 + 9);
      }
      v22 = *v18;
      *(_QWORD *)(a3 + 18) = v22;
      v20 = *v19;
      if (*((_QWORD *)v13 + 3))
      {
        v23 = 8 * v17 + 16;
        v24 = v23 * v22;
        if (!(v23 * v22))
          goto LABEL_19;
        v25 = 0;
        v26 = *v19;
        v27 = v23 * v22;
        while (1)
        {
          v28 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))v16 + 3))(*(_QWORD *)v16, v26, v27);
          if (v28 < 1)
            break;
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (!v27)
            goto LABEL_18;
        }
        v25 = v28;
LABEL_18:
        if (v24 == v25)
        {
LABEL_19:
          v29 = 0;
          goto LABEL_22;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 350, 134, 0, "aaByteStreamWriteExpected", v14, v15, v33);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 335, 134, 0, "AACompressionOutputStreamOpen", v14, v15, v33);
      v20 = 0;
    }
  }
  v29 = 1;
LABEL_22:
  if (AAByteStreamClose(v16) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 353, 134, 0, "AAByteStreamClose", v30, v31, v33);
  }
  else if (!v29)
  {
    return v20;
  }
  return 0;
}

uint64_t RawImageDiff(uint64_t a1)
{
  FILE **v2;
  unint64_t v3;
  unint64_t v4;
  const char *v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  unint64_t variants;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void **v22;
  unint64_t v23;
  char *v24;
  char *v25;
  _DWORD *v26;
  AAByteStream v27;
  uint64_t v28;
  uint64_t v29;
  AAByteStream_impl *v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  AAByteStream_impl *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  AAByteStream v49;
  uint64_t v50;
  uint64_t v51;
  AAByteStream_impl *v52;
  uint64_t **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  AAByteStream_impl *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  AAByteStream_impl *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  size_t v67;
  void *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  BOOL v90;
  BOOL v91;
  BOOL v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  int64x2_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  const char *v105;
  __int16 v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  __int16 v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unint64_t v119;
  unint64_t v120;
  int v122;
  char *v123;
  uint64_t v124;
  int v125;
  AAByteStream_impl *v126;
  uint64_t v127;
  uint64_t v128;
  AAByteStream_impl *v129;
  uint64_t v130;
  AAFlagSet v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  AAByteStream_impl *v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  off_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  AAByteStream v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t **v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  __int16 v160;
  const char *v161;
  AAByteStream_impl *v162;
  int v163;
  uint64_t v164;
  AAByteStream v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t **v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  _BYTE *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  BOOL v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  uint64_t v193;
  _BYTE *v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  _BYTE *v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t v201;
  unint64_t v202;
  _BYTE *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  unint64_t v213;
  uint64_t v214;
  uint64_t v215;
  _BYTE *v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  int *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  __int16 v227;
  const char *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  off_t v243;
  uint64_t v244;
  uint64_t v245;
  const char *v246;
  int *v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  uint64_t v251;
  const char *v252;
  __int16 v253;
  const char *v254;
  __int16 v255;
  const char *v256;
  __int16 v257;
  const char *v258;
  __int16 v259;
  const char *v260;
  __int16 v261;
  int v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  const char *v269;
  __int16 v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t v275;
  int *v276;
  uint64_t v277;
  uint64_t v278;
  int v279;
  uint64_t v280;
  uint64_t v281;
  char v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t *v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  uint64_t v298;
  off_t *v299;
  uint64_t v300;
  AAByteStream_impl *s;
  AAByteStream_impl *v302;
  int64x2_t v303;
  AAByteStream_impl *v304;
  int v305;
  AAByteStream_impl *v306;
  AAByteStream v307;
  AAByteStream_impl *v308;
  unint64_t v309;
  uint64_t v310;
  AAByteStream_impl *v311;
  _BYTE *v312;
  _BYTE *v313;
  _BYTE *v314;
  AAByteStream v315;
  AAByteStream_impl *v316;
  unint64_t v317;
  uint64_t *v318;
  __int128 v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  uint64_t v326;

  v326 = *MEMORY[0x24BDAC8D0];
  v324 = 0u;
  v325 = 0u;
  v322 = 0u;
  v323 = 0u;
  v320 = 0u;
  v321 = 0u;
  v319 = 0u;
  if (!*(_DWORD *)(a1 + 36))
    *(_DWORD *)(a1 + 36) = getDefaultNThreads();
  if (*(_DWORD *)(a1 + 40))
  {
    v2 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("ImageDiff\n", 0xAuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v3 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      v4 = 0;
      do
      {
        v5 = *(const char **)(*(_QWORD *)(a1 + 8) + 8 * v4);
        if (v5)
        {
          fprintf(*v2, "  Input %zu: %s\n", v4, v5);
          v3 = *(_QWORD *)a1;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    if (*(_QWORD *)(a1 + 16))
      fprintf(*v2, "  Output: %s\n", *(const char **)(a1 + 16));
    if (*(_QWORD *)(a1 + 24))
      fprintf(*v2, "  Patch: %s\n", *(const char **)(a1 + 24));
    if ((*(_DWORD *)(a1 + 32) & 1) != 0)
      v6 = "yes";
    else
      v6 = "no";
    fprintf(*v2, "  In-place: %s\n", v6);
  }
  v7 = *(_QWORD *)a1 + 1;
  if (v7 > 0x400000000)
  {
    *__error() = 12;
LABEL_95:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", 592, 134, 0, "aaCalloc", v8, v9, v282);
    v104 = 0xFFFFFFFFLL;
    goto LABEL_117;
  }
  v10 = (uint64_t *)calloc(v7, 8uLL);
  if (!v10)
    goto LABEL_95;
  v11 = v10;
  variants = load_variants((uint64_t)v10, a1);
  if (!variants)
  {
    v105 = "load_variants";
    v106 = 596;
    goto LABEL_113;
  }
  *(_QWORD *)a1 = variants - 1;
  if ((rawimg_set_fork_types((uint64_t)v11, variants, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    v105 = "rawimg_set_fork_types";
    v106 = 600;
    goto LABEL_113;
  }
  v19 = *(_QWORD *)a1;
  if ((*(_QWORD *)a1 & 0x80000000) == 0)
  {
    v20 = *(_QWORD *)a1;
    do
    {
      rawimg_show(v11[v20], v20 == 0, *(_DWORD *)(a1 + 40));
      --v20;
    }
    while (v20 != -1);
    v19 = *(_QWORD *)a1;
  }
  v21 = *v11;
  v22 = (void **)(*(_QWORD *)(*v11 + 2120) / 0x64uLL + 0x2000000);
  v319 = 0u;
  v320 = 0u;
  v321 = 0u;
  v322 = 0u;
  v323 = 0u;
  v324 = 0u;
  v325 = 0u;
  *(int32x2_t *)((char *)&v319 + 4) = vrev64_s32(*(int32x2_t *)(a1 + 36));
  *(_QWORD *)&v320 = v19;
  if (v19 <= 1)
    v23 = 1;
  else
    v23 = v19;
  if (!is_mul_ok(v23, 0x50uLL) || 80 * v23 >= 0x2000000001)
  {
    *__error() = 12;
    *((_QWORD *)&v320 + 1) = 0;
    goto LABEL_99;
  }
  v24 = (char *)calloc(v23, 0x50uLL);
  *((_QWORD *)&v320 + 1) = v24;
  if (!v24)
  {
LABEL_99:
    v107 = *__error();
    v110 = 205;
LABEL_100:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v110, 134, v107, "aaCalloc", v108, v109, v282);
    v45 = 0;
    v37 = 0;
    v30 = 0;
LABEL_101:
    v63 = 0;
    v59 = 0;
    v52 = 0;
    goto LABEL_102;
  }
  v25 = v24;
  if (v19)
  {
    v26 = v24 + 36;
    do
    {
      *v26 = 1;
      v26 += 20;
      --v19;
    }
    while (v19);
  }
  if (!*(_QWORD *)a1)
  {
    v250 = calloc(1uLL, 0x18uLL);
    *((_QWORD *)v25 + 5) = v250;
    if (v250)
    {
      v45 = 0;
      v30 = 0;
      v63 = 0;
      v59 = 0;
      v52 = 0;
      v251 = *(_QWORD *)(v21 + 2080);
      if (v251 < 0)
        v251 = 0x8000000000000000 - v251;
      v250[1] = v251;
      v111 = 1;
      *((_QWORD *)v25 + 7) = 1;
      v37 = 0;
      goto LABEL_103;
    }
    v107 = *__error();
    v110 = 213;
    goto LABEL_100;
  }
  v27 = AAFileStreamOpenWithPath(*(const char **)(v21 + 2048), 0, 0);
  v30 = v27;
  if (!v27)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 223, 134, 0, "AAFileStreamOpenWithPath", v28, v29, v282);
    v45 = 0;
    v37 = 0;
    goto LABEL_101;
  }
  v31 = aaSegmentStreamOpen(v27, (_QWORD *)v21);
  v37 = (AAByteStream_impl *)v31;
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 225, 134, 0, "aaSegmentStreamOpen", v35, v36, v282);
    v45 = 0;
    goto LABEL_101;
  }
  v45 = aaForkInputStreamOpen(v31, v21, 0, v32, v33, v34, v35, v36);
  if (!v45)
  {
    v252 = "aaForkInputStreamOpen";
    v253 = 227;
LABEL_290:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v253, 134, 0, v252, v43, v44, v282);
    goto LABEL_101;
  }
  v46 = 0;
  v303 = vdupq_n_s64(0x8000000000000000);
  v311 = v37;
  v315 = (AAByteStream)v22;
  while (1)
  {
    if (v46 >= (unint64_t)v320)
    {
      if ((unint64_t)v320 < 2)
      {
        v63 = 0;
        v59 = 0;
        v52 = 0;
        v111 = 1;
      }
      else
      {
        if (bxdiff5CreateComboControls((uint64_t)&v319, v38, v39, v40, v41, v42, v43, v44))
        {
          v252 = "bxdiff5CreateComboControls";
          v253 = 270;
          goto LABEL_290;
        }
        if ((controls_combo_enforce_copy_fork_boundary(*v11, &v319, v265, v266, v267, v268, v43, v44) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 272, 134, 0, "controls_combo_enforce_copy_fork_boundary", v280, v281, v282);
          v63 = 0;
          v59 = 0;
          v52 = 0;
          v111 = 0;
        }
        else
        {
          if (*(_DWORD *)(a1 + 40))
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImageDiff: Constructed %zd combo controls.\n", *((size_t *)&v324 + 1));
          v63 = 0;
          v59 = 0;
          v52 = 0;
          v111 = 1;
        }
        v37 = v311;
      }
      goto LABEL_103;
    }
    v22 = (void **)v30;
    v317 = v46;
    v47 = v46 + 1;
    v48 = v11[v46 + 1];
    v49 = AAFileStreamOpenWithPath(*(const char **)(v48 + 2048), 0, 0);
    v52 = v49;
    if (!v49)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 236, 134, 0, "AAFileStreamOpenWithPath", v50, v51, v282);
      v63 = 0;
      v59 = 0;
LABEL_318:
      v111 = 0;
      v30 = (AAByteStream_impl *)v22;
      LODWORD(v22) = (_DWORD)v315;
      goto LABEL_103;
    }
    v53 = aaSegmentStreamOpen(v49, (_QWORD *)v48);
    v59 = (AAByteStream_impl *)v53;
    if (!v53)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 238, 134, 0, "aaSegmentStreamOpen", v57, v58, v282);
      v63 = 0;
      goto LABEL_318;
    }
    v309 = v47;
    v60 = aaForkInputStreamOpen(v53, v48, 0, v54, v55, v56, v57, v58);
    v63 = (AAByteStream_impl *)v60;
    if (!v60)
    {
      v269 = "aaForkInputStreamOpen";
      v270 = 240;
LABEL_317:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v270, 134, 0, v269, v61, v62, v282);
      goto LABEL_318;
    }
    v313 = (_BYTE *)v48;
    if ((GetLargeFileControlsWithStreams((uint64_t)v60, *(_QWORD *)(v48 + 2072), (unint64_t)v45, *(_QWORD *)(v21 + 2072), (void **)(*((_QWORD *)&v320 + 1) + 80 * v317 + 40), (uint64_t *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 56), (uint64_t *)&v319) & 0x80000000) != 0)
    {
      v269 = "GetLargeFileControlsWithStreams";
      v270 = 246;
      goto LABEL_317;
    }
    v64 = *(_QWORD *)(v21 + 2160);
    v30 = (AAByteStream_impl *)v22;
    v22 = (void **)v315;
    if (v64)
    {
      v65 = *((_QWORD *)&v320 + 1) + 80 * v317;
      v307 = (AAByteStream)(v65 + 56);
      v66 = *(_QWORD *)(v65 + 56);
      if (!v66)
      {
        v256 = "empty controls";
        v257 = 124;
LABEL_293:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", v257, 134, 0, v256, v61, v62, v282);
        goto LABEL_294;
      }
      if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0 || (v313[2128] & 0x10) == 0)
      {
        v256 = "no digests found";
        v257 = 126;
        goto LABEL_293;
      }
      v22 = (void **)(v65 + 40);
      v67 = 24 * (v66 + v64);
      if (v67 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_332;
      }
      v305 = *(_DWORD *)(a1 + 40);
      v68 = *v22;
      v69 = (uint64_t *)realloc(*v22, v67);
      if (!v69)
      {
        free(v68);
        v37 = v311;
LABEL_332:
        *v22 = 0;
        v276 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", 130, 134, *v276, "aaReallocf", v277, v278, v282);
        LODWORD(v22) = (_DWORD)v315;
LABEL_294:
        v258 = "controls_append_copy_forks";
        v259 = 250;
LABEL_295:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v259, 134, 0, v258, v99, v100, v282);
        goto LABEL_102;
      }
      *v22 = v69;
      v70 = *(_QWORD *)v307;
      if (*(_QWORD *)v307)
      {
        v71 = 0;
        v72 = v69 + 2;
        v73 = *(_QWORD *)v307;
        v22 = (void **)v315;
        v37 = v311;
        do
        {
          v74 = *(v72 - 2);
          if (v74 < 0)
            v74 = 0x8000000000000000 - v74;
          v76 = *v72;
          v72 += 3;
          v75 = v76;
          v77 = 0x8000000000000000 - v76;
          if (v76 < 0)
            v75 = v77;
          v71 += v74 + v75;
          --v73;
        }
        while (v73);
      }
      else
      {
        v71 = 0;
        v22 = (void **)v315;
        v37 = v311;
      }
      v78 = *(_QWORD *)(v21 + 2160);
      if (v78)
      {
        v79 = 0;
        v80 = *(_QWORD *)(v21 + 2144);
        v81 = (char *)(v69 - 1);
        do
        {
          v82 = v80 + 440 * v79;
          if ((*(_BYTE *)(v82 + 408) & 2) != 0)
          {
            v83 = *((_QWORD *)v313 + 270);
            if (!v83)
              goto LABEL_292;
            v84 = *((_QWORD *)v313 + 268);
            v85 = (_QWORD *)(v80 + 440 * v79);
            v86 = v85 + 49;
            v87 = v85 + 50;
            v88 = v85 + 4;
            while (1)
            {
              if ((*(_BYTE *)(v84 + 408) & 2) != 0 && *(_QWORD *)(v84 + 392) == *v86 && *(_QWORD *)(v84 + 400) == *v87)
              {
                v89 = *(_QWORD *)(v84 + 32);
                if (v89 == *v88)
                {
                  v61 = *(_QWORD *)(v82 + 8);
                  v62 = *(_QWORD *)(v84 + 16);
                  v90 = *(_QWORD *)v84 == *(_QWORD *)v82 && *(_QWORD *)(v84 + 8) == v61;
                  v91 = v90 && v62 == *(_QWORD *)(v82 + 16);
                  v22 = (void **)v315;
                  v92 = v91 && *(_QWORD *)(v84 + 24) == *(_QWORD *)(v82 + 24);
                  v37 = v311;
                  if (v92)
                    break;
                }
              }
              v84 += 440;
              if (!--v83)
                goto LABEL_292;
            }
            v93 = *(_QWORD *)(v84 + 48);
            if (v93 < 0)
            {
LABEL_292:
              v256 = "copy fork not found";
              v257 = 161;
              goto LABEL_293;
            }
            v94 = 3 * v70++;
            *(_QWORD *)v307 = v70;
            v95 = (char *)&v69[v94];
            v96 = 8 * v94;
            *((_QWORD *)v95 + 1) = 0;
            *((_QWORD *)v95 + 2) = 0;
            v97 = *(_QWORD *)&v81[8 * v94];
            if (v97 < 0)
              v97 = 0x8000000000000000 - v97;
            v98.i64[0] = v97 + v93 - v71;
            v98.i64[1] = v89;
            *(int8x16_t *)&v81[v96] = vbslq_s8((int8x16_t)vcltzq_s64(v98), (int8x16_t)vsubq_s64(v303, v98), (int8x16_t)v98);
            v71 = v93 + v89;
            v78 = *(_QWORD *)(v21 + 2160);
          }
          ++v79;
        }
        while (v79 < v78);
      }
      if (v305 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImageDiff: Processed copy forks: %zd controls\n", v70);
    }
    if ((*(_BYTE *)(a1 + 32) & 1) != 0
      && (rawimg_force_in_place((_QWORD *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 40), (unint64_t *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 56), v313, v21, (uint64_t)v22, *(_DWORD *)(a1 + 40)) & 0x80000000) != 0)
    {
      v258 = "rawimg_force_in_place";
      v259 = 258;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v63) < 0)
    {
      v258 = "AAByteStreamClose";
      v259 = 262;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v59) < 0)
      break;
    v103 = AAByteStreamClose(v52);
    v46 = v309;
    if (v103 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 264, 134, 0, "AAByteStreamClose", v43, v44, v282);
      v63 = 0;
      v59 = 0;
      goto LABEL_102;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 263, 134, 0, "AAByteStreamClose", v101, v102, v282);
  v63 = 0;
LABEL_102:
  v111 = 0;
LABEL_103:
  if (AAByteStreamClose((AAByteStream)v45) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 280, 134, 0, "AAByteStreamClose", v112, v113, v282);
    v111 = 0;
  }
  if (AAByteStreamClose(v37) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 281, 134, 0, "AAByteStreamClose", v114, v115, v282);
    if ((AAByteStreamClose(v30) & 0x80000000) == 0)
      goto LABEL_112;
LABEL_111:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 282, 134, 0, "AAByteStreamClose", v116, v117, v282);
    goto LABEL_112;
  }
  if (AAByteStreamClose(v30) < 0)
    goto LABEL_111;
  if (!v111)
  {
LABEL_112:
    AAByteStreamClose(v63);
    AAByteStreamClose(v59);
    AAByteStreamClose(v52);
    BXDiff5Data_free((uint64_t)&v319);
    v105 = "controls_create_with_variants";
    v106 = 612;
    goto LABEL_113;
  }
  v118 = (int)v22;
  v119 = 8 * *(_QWORD *)a1 + 62;
  if (v119 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_281;
  }
  v122 = *(_DWORD *)(a1 + 32);
  v123 = (char *)calloc(1uLL, 8 * *(_QWORD *)a1 + 62);
  if (!v123)
  {
LABEL_281:
    v247 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 515, 134, *v247, "aaCalloc", v248, v249, v282);
    v124 = 0;
    v129 = 0;
LABEL_303:
    v262 = 1;
    goto LABEL_304;
  }
  v124 = (uint64_t)v123;
  *(_QWORD *)v123 = 0x3031464649444952;
  *((_WORD *)v123 + 4) = *(_WORD *)a1 + 1;
  *(_QWORD *)(v123 + 10) = v122 & 1;
  if ((v122 & 1) != 0)
    v125 = v118;
  else
    v125 = 0;
  *(_DWORD *)(v123 + 26) = v125;
  *(_QWORD *)(v123 + 30) = v119;
  v126 = AAFileStreamOpenWithPath(*(const char **)(a1 + 24), 1537, 0x1A4u);
  v129 = v126;
  if (!v126)
  {
    v254 = "AAFileStreamOpenWithPath";
    v255 = 526;
LABEL_302:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", v255, 134, 0, v254, v127, v128, v282);
    goto LABEL_303;
  }
  if (AAByteStreamSeek(v126, v119, 0) < 0)
  {
    v254 = "AAByteStreamSeek";
    v255 = 527;
    goto LABEL_302;
  }
  v130 = *(unsigned int *)(a1 + 40);
  if (v130 <= 3)
    v131 = v130 << 62;
  else
    v131 = 0xC000000000000000;
  v137 = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v131, *(_DWORD *)(a1 + 36));
  if (!v137)
  {
    v260 = "AACompressionOutputStreamOpen";
    v261 = 305;
    goto LABEL_299;
  }
  v138 = 0;
  do
  {
    if ((rawimg_save_to_stream(v137, v11[v138], v138 == 0, v132, v133, v134, v135, v136) & 0x80000000) != 0)
    {
      v260 = "rawimg_save_to_stream";
      v261 = 311;
LABEL_299:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", v261, 134, 0, v260, v135, v136, v282);
      if ((AAByteStreamClose(v137) & 0x80000000) == 0)
      {
LABEL_301:
        v254 = "patch_write_metadata";
        v255 = 530;
        goto LABEL_302;
      }
LABEL_300:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", 315, 134, 0, "AAByteStreamClose", v127, v128, v282);
      goto LABEL_301;
    }
    ++v138;
  }
  while (v138 <= *(_QWORD *)a1);
  if (AAByteStreamClose(v137) < 0)
    goto LABEL_300;
  v139 = patch_write_controls(v129, (unint64_t *)&v319, v124, a1);
  if (!v139)
  {
    v254 = "patch_write_controls";
    v255 = 534;
    goto LABEL_302;
  }
  v292 = v139;
  v140 = 0;
  do
  {
    v141 = v11[v140];
    v300 = *v11;
    v142 = AAByteStreamSeek(v129, 0, 1);
    v299 = (off_t *)(v124 + 46 + 8 * v140);
    *v299 = v142;
    v310 = v140;
    if (v142 < 0)
    {
      v160 = 383;
      v161 = "AAByteStreamSeek";
LABEL_147:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v160, 134, 0, v161, v143, v144, v282);
      v312 = 0;
      v314 = 0;
      v318 = 0;
      v302 = 0;
      v304 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
      goto LABEL_148;
    }
    LODWORD(v145) = *(_DWORD *)(a1 + 40);
    if (v145 >= 3)
      v145 = 3;
    else
      v145 = v145;
    s = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v145 << 62, *(_DWORD *)(a1 + 36));
    if (!s)
    {
      v160 = 387;
      v161 = "AACompressionOutputStreamOpen";
      goto LABEL_147;
    }
    if (v140)
    {
      v146 = AAFileStreamOpenWithPath(*(const char **)(v141 + 2048), 0, 0);
      if (!v146)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 394, 134, 0, "AAFileStreamOpenWithPath", v147, v148, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        v308 = 0;
        goto LABEL_254;
      }
      v308 = v146;
      v149 = aaSegmentStreamOpen(v146, (_QWORD *)v141);
      if (!v149)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 396, 134, 0, "aaSegmentStreamOpen", v153, v154, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        goto LABEL_254;
      }
      v306 = (AAByteStream_impl *)v149;
      v316 = (AAByteStream_impl *)aaForkInputStreamOpen(v149, v141, 0, v150, v151, v152, v153, v154);
      if (!v316)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 398, 134, 0, "aaForkInputStreamOpen", v155, v156, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        goto LABEL_254;
      }
      v312 = malloc(0x10000uLL);
      if (!v312)
      {
        v157 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 400, 134, *v157, "aaMalloc", v158, v159, v282);
        v312 = 0;
        v314 = 0;
        goto LABEL_235;
      }
    }
    else
    {
      v312 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
    }
    v164 = v300;
    v165 = AAFileStreamOpenWithPath(*(const char **)(v300 + 2048), 0, 0);
    if (!v165)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 405, 134, 0, "AAFileStreamOpenWithPath", v166, v167, v282);
      v314 = 0;
LABEL_235:
      v318 = 0;
      v302 = 0;
      v304 = 0;
LABEL_254:
      v163 = 0;
      v162 = s;
      goto LABEL_255;
    }
    v304 = v165;
    v168 = aaSegmentStreamOpen(v165, (_QWORD *)v300);
    if (!v168)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 407, 134, 0, "aaSegmentStreamOpen", v172, v173, v282);
      v314 = 0;
      v318 = 0;
      v302 = 0;
      goto LABEL_254;
    }
    v302 = (AAByteStream_impl *)v168;
    v318 = aaForkInputStreamOpen(v168, v300, 0, v169, v170, v171, v172, v173);
    if (!v318)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 409, 134, 0, "aaForkInputStreamOpen", v174, v175, v282);
      v314 = 0;
      v318 = 0;
      goto LABEL_254;
    }
    v176 = malloc(0x10000uLL);
    if (!v176)
    {
      v221 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 411, 134, *v221, "aaMalloc", v222, v223, v282);
      v314 = 0;
      goto LABEL_254;
    }
    v314 = v176;
    v179 = v292;
    if (*(_QWORD *)(v124 + 18))
    {
      v180 = 0;
      v181 = 0;
      v182 = 0;
      v183 = 0;
      v283 = v140 + 1;
      while (1)
      {
        v289 = v183;
        v288 = (unint64_t *)(v179 + 8 * (v183 + v183 * *(unsigned __int16 *)(v124 + 8)));
        v184 = v288[1];
        v185 = 0x8000000000000000 - *v288;
        if ((*v288 & 0x8000000000000000) == 0)
          v185 = *v288;
        v186 = 0x8000000000000000 - v184;
        if (v184 >= 0)
          v186 = v288[1];
        if (v140)
        {
          v286 = v186;
          v187 = *(_QWORD *)(v164 + 2072);
          if (v181 < v187 && v185 + v181 > v187)
          {
            v227 = 427;
            goto LABEL_246;
          }
          v188 = v181 >= v187;
          if (v181 >= v187)
            v189 = v185 + v181;
          else
            v189 = v181;
          if (v181 >= v187)
            v190 = v185;
          else
            v190 = 0;
          v293 = v189;
          v295 = v190 + v180;
          v284 = v182;
          if (!v188 && v185)
          {
            v191 = v185;
            v290 = v185;
            while (1)
            {
              v291 = v191;
              if (v191 >= 0x10000)
                v192 = 0x10000;
              else
                v192 = v191;
              if (!*((_QWORD *)v316 + 4))
                goto LABEL_248;
              v193 = 0;
              v194 = v312;
              v195 = v295;
              v297 = v192;
              while (1)
              {
                v196 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, uint64_t))v316 + 4))(*(_QWORD *)v316, v194, v192, v195);
                if (v196 < 0)
                  break;
                if (v196)
                {
                  v194 += v196;
                  v193 += v196;
                  v195 += v196;
                  v192 -= v196;
                  if (v192)
                    continue;
                }
                goto LABEL_183;
              }
              v193 = v196;
LABEL_183:
              v197 = v297;
              if (v297 != v193)
              {
LABEL_248:
                v227 = 442;
                goto LABEL_251;
              }
              v198 = v314;
              if (!v318[4])
                goto LABEL_250;
              v199 = 0;
              v200 = v293;
              while (1)
              {
                v201 = ((uint64_t (*)(uint64_t, _BYTE *, unint64_t, unint64_t))v318[4])(*v318, v198, v197, v200);
                if (v201 < 0)
                  break;
                if (v201)
                {
                  v198 += v201;
                  v199 += v201;
                  v200 += v201;
                  v197 -= v201;
                  if (v197)
                    continue;
                }
                goto LABEL_191;
              }
              v199 = v201;
LABEL_191:
              v202 = v297;
              v203 = v314;
              if (v297 != v199)
              {
LABEL_250:
                v227 = 443;
                goto LABEL_251;
              }
              v204 = 0;
              v205 = v297 <= 1 ? 1 : v297;
              do
              {
                v314[v204] -= v312[v204];
                ++v204;
              }
              while (v205 != v204);
              if (!*((_QWORD *)s + 3))
                break;
              v206 = 0;
              while (1)
              {
                v207 = (*((uint64_t (**)(_QWORD, _BYTE *, unint64_t))s + 3))(*(_QWORD *)s, v203, v202);
                if (v207 < 1)
                  break;
                v203 += v207;
                v206 += v207;
                v202 -= v207;
                if (!v202)
                  goto LABEL_202;
              }
              v206 = v207;
LABEL_202:
              v176 = v314;
              if (v297 != v206)
                break;
              v295 += v297;
              v293 += v297;
              v191 = v291 - v297;
              v185 = v290;
              if (v291 == v297)
                goto LABEL_204;
            }
            v227 = 447;
            v228 = "aaByteStreamWriteExpected";
            goto LABEL_253;
          }
LABEL_204:
          v182 = v284;
          v208 = v288[v283];
          if (v208 < 0)
            v208 = 0x8000000000000000 - v208;
          v180 = v208 + v295;
          v181 = v293 + v286;
          v164 = v300;
        }
        else
        {
          v181 += v185;
          if (v186)
          {
            v294 = v180;
            v285 = v182;
            v287 = v186;
            v209 = v186;
            while (1)
            {
              v210 = v209 >= 0x10000 ? 0x10000 : v209;
              if (!v318[4])
                break;
              v211 = 0;
              v212 = v176;
              v296 = v181;
              v298 = v210;
              v213 = v181;
              while (1)
              {
                v214 = ((uint64_t (*)(uint64_t, char *, uint64_t, unint64_t))v318[4])(*v318, v212, v210, v213);
                if (v214 < 0)
                  break;
                if (v214)
                {
                  v212 += v214;
                  v211 += v214;
                  v213 += v214;
                  v210 -= v214;
                  if (v210)
                    continue;
                }
                goto LABEL_219;
              }
              v211 = v214;
LABEL_219:
              v215 = v298;
              v216 = v314;
              if (v298 != v211)
                break;
              v217 = v209;
              v162 = s;
              if (!*((_QWORD *)s + 3))
                goto LABEL_249;
              v218 = 0;
              while (1)
              {
                v219 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t))s + 3))(*(_QWORD *)s, v216, v215);
                if (v219 < 1)
                  break;
                v216 += v219;
                v218 += v219;
                v215 -= v219;
                if (!v215)
                  goto LABEL_226;
              }
              v218 = v219;
LABEL_226:
              v176 = v314;
              if (v298 != v218)
              {
LABEL_249:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 467, 134, 0, "aaByteStreamWriteExpected", v177, v178, v282);
                goto LABEL_149;
              }
              v181 = v298 + v296;
              v209 = v217 - v298;
              if (v217 == v298)
              {
                v182 = v285;
                v185 = v287;
                v140 = v310;
                v164 = v300;
                v220 = v289;
                v180 = v294;
                goto LABEL_231;
              }
            }
            v227 = 466;
LABEL_251:
            v228 = "aaByteStreamPReadExpected";
            goto LABEL_253;
          }
          v185 = 0;
        }
        v220 = v289;
LABEL_231:
        v182 += v185;
        v183 = v220 + 1;
        v179 = v292;
        if (v183 >= *(_QWORD *)(v124 + 18))
          goto LABEL_242;
      }
    }
    v182 = 0;
    v181 = 0;
LABEL_242:
    if (v181 != *(_QWORD *)(v164 + 2080))
    {
      v227 = 472;
LABEL_246:
      v228 = "bad controls";
LABEL_253:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v227, 134, 0, v228, v177, v178, v282);
      goto LABEL_254;
    }
    v224 = v182;
    if (AAByteStreamClose(s) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 475, 134, 0, "AAByteStreamClose", v225, v226, v282);
      v163 = 0;
    }
    else
    {
      v163 = 1;
    }
    v243 = AAByteStreamSeek(v129, 0, 1);
    v299[1] = v243;
    if ((v243 & 0x8000000000000000) == 0)
    {
      if (*(int *)(a1 + 40) >= 2)
      {
        v246 = "Diff";
        if (!v310)
          v246 = "Literal";
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s stream: %llu bytes -> %llu bytes\n", v246, v224, v243 - *v299);
      }
      v162 = 0;
      goto LABEL_255;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 480, 134, 0, "AAByteStreamSeek", v244, v245, v282);
LABEL_148:
    v162 = 0;
LABEL_149:
    v163 = 0;
LABEL_255:
    if (AAByteStreamClose(v162) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 489, 134, 0, "AAByteStreamClose", v229, v230, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v316) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 490, 134, 0, "AAByteStreamClose", v231, v232, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v306) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 491, 134, 0, "AAByteStreamClose", v233, v234, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v308) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 492, 134, 0, "AAByteStreamClose", v235, v236, v282);
      v163 = 0;
    }
    if (AAByteStreamClose((AAByteStream)v318) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 493, 134, 0, "AAByteStreamClose", v237, v238, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v302) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 494, 134, 0, "AAByteStreamClose", v239, v240, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v304) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 495, 134, 0, "AAByteStreamClose", v241, v242, v282);
      v163 = 0;
    }
    free(v312);
    free(v314);
    if (!v163)
    {
      v254 = "patch_write_stream";
      v255 = 539;
      goto LABEL_302;
    }
    v140 = v310 + 1;
  }
  while ((unint64_t)(v310 + 1) <= *(_QWORD *)a1);
  if (!*((_QWORD *)v129 + 5))
    goto LABEL_341;
  v271 = 0;
  v272 = 0;
  v273 = v124;
  v274 = v119;
  while (1)
  {
    v275 = (*((uint64_t (**)(_QWORD, uint64_t, unint64_t, uint64_t))v129 + 5))(*(_QWORD *)v129, v273, v274, v272);
    if (v275 < 1)
      break;
    v273 += v275;
    v271 += v275;
    v272 += v275;
    v274 -= v275;
    if (!v274)
      goto LABEL_335;
  }
  v271 = v275;
LABEL_335:
  if (v119 != v271)
  {
LABEL_341:
    v254 = "aaByteStreamPWriteExpected";
    v255 = 543;
    goto LABEL_302;
  }
  v279 = *(_DWORD *)(a1 + 40);
  if (v279 > 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  Metadata: %llu bytes\n  Controls: %llu bytes\n", *(_QWORD *)(v124 + 38) - *(_QWORD *)(v124 + 30), *(_QWORD *)(v124 + 46) - *(_QWORD *)(v124 + 38));
    v279 = *(_DWORD *)(a1 + 40);
  }
  if (v279 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu final patch size\n", *(_QWORD *)(v124 + 8 * *(unsigned __int16 *)(v124 + 8) + 46));
  v262 = 0;
LABEL_304:
  if (AAByteStreamClose(v129) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 562, 134, 0, "AAByteStreamClose", v263, v264, v282);
    free((void *)v124);
  }
  else
  {
    free((void *)v124);
    if (!v262)
    {
      v104 = 0;
      goto LABEL_114;
    }
  }
  v105 = "patch_write";
  v106 = 615;
LABEL_113:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", v106, 134, 0, v105, v17, v18, v282);
  v104 = 0xFFFFFFFFLL;
LABEL_114:
  v120 = 0;
  do
    rawimg_destroy((uint64_t *)v11[v120++]);
  while (v120 <= *(_QWORD *)a1);
  free(v11);
LABEL_117:
  BXDiff5Data_free((uint64_t)&v319);
  return v104;
}

double BXDiff5Data_free(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  double result;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v3 = 0;
      v4 = 40;
      do
      {
        free(*(void **)(*(_QWORD *)(a1 + 24) + v4));
        ++v3;
        v4 += 80;
      }
      while (v3 < *(_QWORD *)(a1 + 16));
      v2 = *(void **)(a1 + 24);
    }
    free(v2);
  }
  free(*(void **)(a1 + 72));
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t controls_combo_enforce_copy_fork_boundary(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t *v27;
  unint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  const char *v32;
  __int16 v33;
  char v34;
  uint64_t v35;
  unint64_t v36;

  v8 = a1;
  v9 = a2[11];
  if (v9)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v36 = a2[2];
    v14 = v36 + 2;
    v15 = 8 * (v36 + 2);
    if (v36 == 0 || v36 >= 0xFFFFFFFFFFFFFFFELL)
      v14 = 2;
    v35 = 8 * v14 - 8;
    v16 = -1;
    while (1)
    {
      v17 = (char *)a2[9];
      v18 = *(_QWORD *)&v17[v11];
      if (v18 >= 0)
        v19 = *(_QWORD *)&v17[v11];
      else
        v19 = 0x8000000000000000 - v18;
      v20 = *(_QWORD *)(v8 + 2072);
      v21 = v19 + v13;
      v22 = v20 - v13;
      if (v20 > v13 && v21 > v20)
      {
        v25 = v9 + 1;
        a2[11] = v25;
        if (v15 * v25 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_32;
        }
        v26 = (char *)realloc(v17, v15 * v25);
        if (!v26)
        {
          free(v17);
LABEL_32:
          a2[9] = 0;
          v32 = "aaReallocf";
          v33 = 88;
LABEL_33:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_combo_enforce_copy_fork_boundary", v33, 134, 0, v32, a7, a8, v34);
          return 0xFFFFFFFFLL;
        }
        a2[9] = v26;
        v27 = (uint64_t *)&v26[v11];
        v28 = (unint64_t *)&v26[v11 + v15];
        memmove(v28, &v26[v11], v15 * (v16 + a2[11]));
        v29 = 0x8000000000000000 - v22;
        if (v22 >= 0)
          v29 = v22;
        *v27 = v29;
        if (v36 <= 0xFFFFFFFFFFFFFFFDLL)
          bzero(v27 + 1, v35);
        v30 = v19 - v22;
        if ((uint64_t)(v19 - v22) < 0)
          v30 = 0x8000000000000000 - (v19 - v22);
        *v28 = v30;
        v9 = a2[11];
        v13 = v20;
        v8 = a1;
      }
      else
      {
        v24 = *(_QWORD *)&v17[v11 + 8];
        if (v24 < 0)
          v24 = 0x8000000000000000 - v24;
        v13 = v21 + v24;
      }
      ++v12;
      v11 += v15;
      --v16;
      if (v12 >= v9)
        goto LABEL_27;
    }
  }
  v13 = 0;
LABEL_27:
  if (v13 != *(_QWORD *)(v8 + 2080))
  {
    v32 = "SIZE MISMATCH";
    v33 = 108;
    goto LABEL_33;
  }
  return 0;
}

uint64_t *AEADecryptToFileAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v25;
  int v26;
  _QWORD *v27;
  char v28;
  stat v29;
  char v30[16];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  strcpy(v30, ".tmp_decrypt");
  memset(&v29, 0, sizeof(v29));
  v12 = malloc(0x898uLL);
  v13 = (uint64_t)v12;
  if (v12)
  {
    memset_s(v12, 0x898uLL, 0, 0x898uLL);
    v14 = (uint64_t *)malloc(0x38uLL);
    v15 = v14;
    if (v14)
    {
      memset_s(v14, 0x38uLL, 0, 0x38uLL);
      *(_QWORD *)(v13 + 8) = a2;
      *(_QWORD *)(v13 + 16) = a3;
      *(_QWORD *)(v13 + 24) = a4;
      *(_QWORD *)(v13 + 2084) = -1;
      *(_DWORD *)(v13 + 2080) = a5 >> 62;
      if (pthread_mutex_init((pthread_mutex_t *)(v13 + 2136), 0))
      {
        v18 = "MutexInit";
        v19 = 290;
      }
      else if (strlen(a1) - 1012 > 0xFFFFFFFFFFFFFBFELL)
      {
        __strlcpy_chk();
        __strlcpy_chk();
        __strlcat_chk();
        v25 = stat((const char *)(v13 + 32), &v29);
        if (v25 || (v29.st_mode & 0xF000) == 0x8000)
        {
          v26 = stat((const char *)(v13 + 1056), &v29);
          if (v26 || (v29.st_mode & 0xF000) == 0x8000)
          {
            if (v26 | v25)
            {
              v27 = AEADecryptAsyncStreamOpen(v13, (uint64_t)setupContext, (uint64_t)verifySegment, (uint64_t)processSegment_0, a5, a6);
              *(_QWORD *)v13 = v27;
              if (v27)
              {
                *v15 = v13;
                v15[1] = (uint64_t)decryptToFileAsyncClose;
                v15[2] = (uint64_t)decryptToFileAsyncGetRange;
                v15[3] = (uint64_t)decryptToFileAsyncProcess;
                v15[4] = (uint64_t)decryptToFileAsyncCancel;
                return v15;
              }
              v18 = "creating DecryptAsyncStream";
              v19 = 313;
            }
            else
            {
              v28 = v13 + 32;
              v18 = "Both file and temp file exist: %s";
              v19 = 309;
            }
          }
          else
          {
            v28 = v13 + 32;
            v18 = "Temp file exists but is not a regular file: %s";
            v19 = 306;
          }
        }
        else
        {
          v28 = v13 + 32;
          v18 = "File exists but is not a regular file: %s";
          v19 = 301;
        }
      }
      else
      {
        v28 = (char)a1;
        v18 = "Filename is too long: %s";
        v19 = 293;
      }
      v23 = 0;
    }
    else
    {
      v23 = *__error();
      v18 = "malloc";
      v19 = 281;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileAsyncStreamOpen", v19, 98, v23, v18, v16, v17, v28);
  }
  else
  {
    v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileAsyncStreamOpen", 279, 98, *v20, "malloc", v21, v22, v28);
    v15 = 0;
  }
  decryptToFileAsyncClose(v13);
  free(v15);
  return 0;
}

uint64_t setupContext(uint64_t a1, AEAContext context, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t (*v10)(_QWORD, AEAContext);
  const char *v11;
  __int16 v12;
  uint64_t result;
  int v14;
  std::error_code *v15;
  int v16;
  int v17;
  int v18;
  char v19;
  stat v20;

  memset(&v20, 0, sizeof(v20));
  v10 = *(uint64_t (**)(_QWORD, AEAContext))(a1 + 16);
  if (v10 && (v10(*(_QWORD *)(a1 + 8), context) & 0x80000000) != 0)
  {
    v11 = "Client context callback returned an error";
    v12 = 58;
    goto LABEL_9;
  }
  if (!*(_DWORD *)(a1 + 2096))
  {
    result = 0;
    *(_DWORD *)(a1 + 2096) = 1;
    return result;
  }
  if ((*(_DWORD *)(a1 + 2084) & 0x80000000) == 0 || (*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
    v11 = "Invalid state, file already open";
    v12 = 64;
LABEL_9:
    v14 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"setupContext", v12, 98, v14, v11, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 2104) = AEAContextGetFieldUInt(context, 0xDu);
  *(_QWORD *)(a1 + 2112) = AEAContextGetFieldUInt(context, 4u);
  if (!stat((const char *)(a1 + 32), &v20) && (v20.st_mode & 0xF000) == 0x8000)
  {
    if (v20.st_size && v20.st_size != *(_QWORD *)(a1 + 2104))
    {
      v19 = a1 + 32;
      v11 = "Destination file exists and size doesn't match: %s";
      v12 = 77;
      goto LABEL_9;
    }
    rename((const std::__fs::filesystem::path *)(a1 + 32), (const std::__fs::filesystem::path *)(a1 + 1056), v15);
    if (v16)
    {
      v14 = *__error();
      v19 = a1 + 32;
      v11 = "rename: %s";
      v12 = 82;
      goto LABEL_10;
    }
    if (*(_DWORD *)(a1 + 2080))
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Verifying file: %s\n", (const char *)(a1 + 32));
  }
  if (stat((const char *)(a1 + 1056), &v20) || (v20.st_mode & 0xF000) != 0x8000)
  {
    *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 1537, 420);
    *(_DWORD *)(a1 + 2092) = 1;
    v17 = *(_DWORD *)(a1 + 2084);
  }
  else
  {
    v17 = open((const char *)(a1 + 1056), 0);
    *(_DWORD *)(a1 + 2084) = v17;
  }
  v18 = *(_DWORD *)(a1 + 2088);
  if (v17 < 0)
  {
    if (v18 < 0)
    {
      v14 = *__error();
      v19 = a1 + 32;
      v11 = "open: %s";
      v12 = 98;
      goto LABEL_10;
    }
  }
  else if (v18 < 0)
  {
    return 0;
  }
  result = ftruncate(v18, *(_QWORD *)(a1 + 2104));
  if ((_DWORD)result)
  {
    v14 = *__error();
    v19 = a1 + 32;
    v11 = "truncate to final size: %s";
    v12 = 101;
    goto LABEL_10;
  }
  return result;
}

uint64_t verifySegment(uint64_t a1, unint64_t a2, uint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  size_t v11;
  _QWORD *v12;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  ssize_t v22;
  int v23;
  int v24;
  __n128 v25;
  unint64_t *v27;
  unint64_t v28;
  uint64_t (*v29)(_QWORD, __n128);
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  _OWORD v34[16];
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a1 + 2092))
  {
    v11 = *(_QWORD *)(a1 + 2112);
    if (v11 < a2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"verifySegment", 117, 98, 0, "Invalid segment size", a7, a8, v33);
      return 0xFFFFFFFFLL;
    }
    v35 = 0;
    memset(v34, 0, sizeof(v34));
    if (v11 < 0x2000000001)
    {
      v12 = malloc(v11);
      if (v12)
      {
        v21 = 0;
        while (a2 > v21)
        {
          v22 = pread(*(_DWORD *)(a1 + 2084), (char *)v12 + v21, a2 - v21, v21 + a3);
          if (v22)
            v23 = 0;
          else
            v23 = 5;
          v21 += v22 & ~(v22 >> 63);
          if (v22 < 0)
            v23 = 4;
          if (v23)
          {
            if (v23 == 4)
              goto LABEL_21;
            break;
          }
        }
        if (v21 == a2)
        {
          v24 = aeaChecksum((uint64_t)v34, a4, v12, a2, v17, v18, v19, v20);
          v8 = 0;
          if (v24 < 0 || LODWORD(v34[0]) != a6)
            goto LABEL_22;
          if (!memcmp((char *)v34 + 4, a5, a6))
          {
            v27 = (unint64_t *)(a1 + 2128);
            do
              v28 = __ldxr(v27);
            while (__stxr(v28 + a2, v27));
            v29 = *(uint64_t (**)(_QWORD, __n128))(a1 + 24);
            if (v29
              && ((v30 = *(_QWORD *)(a1 + 2104)) == 0
                ? (v25.n128_u32[0] = 0)
                : (v25.n128_f32[0] = (float)((float)*v27 * 100.0) / (float)v30),
                  (v29(*(_QWORD *)(a1 + 8), v25) & 0x80000000) != 0))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"verifySegment", 144, 98, 0, "Client progress callback reported an error", v31, v32, v33);
              v8 = 0xFFFFFFFFLL;
            }
            else
            {
              if (*(_DWORD *)(a1 + 2080) >= 3u)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment verified: offset=%llu size=%zu\n", a3, a2);
              v8 = 1;
            }
            goto LABEL_22;
          }
        }
      }
LABEL_21:
      v8 = 0;
    }
    else
    {
      v12 = 0;
      v8 = 0;
      *__error() = 12;
    }
LABEL_22:
    free(v12);
    return v8;
  }
  return 0;
}

uint64_t processSegment_0(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, __n128 a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v13;
  unint64_t v14;
  ssize_t v15;
  unint64_t *v16;
  unint64_t v17;
  const char *v18;
  __int16 v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t (*v22)(_QWORD, __n128);
  unint64_t v23;
  char v25;

  if ((*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
LABEL_2:
    v13 = 0;
    do
    {
      v14 = v13;
      if (a2 <= v13)
        break;
      v15 = pwrite(*(_DWORD *)(a1 + 2088), (const void *)(a4 + v13), a2 - v13, v13 + a3);
      v13 = v15 + v14;
    }
    while (v15 > 0);
    if (a2 == v14)
    {
      v16 = (unint64_t *)(a1 + 2128);
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + a2, v16));
      if (*(_DWORD *)(a1 + 2080) >= 3u)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment processed: offset=%llu size=%zu\n", a3, a2);
    }
    else
    {
      v20 = (unint64_t *)(a1 + 2120);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + a2, v20));
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", 181, 98, 0, "Segment write failed: offset=%llu size=%zu\n", a8, a9, a3);
    }
    v22 = *(uint64_t (**)(_QWORD, __n128))(a1 + 24);
    if (!v22)
      return 0;
    v23 = *(_QWORD *)(a1 + 2104);
    if (v23)
      a5.n128_f32[0] = (float)((float)*(unint64_t *)(a1 + 2128) * 100.0) / (float)v23;
    else
      a5.n128_u32[0] = 0;
    if ((v22(*(_QWORD *)(a1 + 8), a5) & 0x80000000) == 0)
      return 0;
    v18 = "Client progress callback reported an error";
    v19 = 190;
    goto LABEL_26;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2136)))
  {
    v18 = "MutexInit";
    v19 = 165;
  }
  else
  {
    if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0)
      *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 2);
    if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2136)))
    {
      if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", 168, 98, 0, "Can't reopen %s for writing", a8, a9, a1 + 32);
        return 0xFFFFFFFFLL;
      }
      goto LABEL_2;
    }
    v18 = "MutexUnlock";
    v19 = 167;
  }
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", v19, 98, 0, v18, a8, a9, v25);
  return 0xFFFFFFFFLL;
}

uint64_t decryptToFileAsyncClose(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v10;
  std::error_code *v11;
  int v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  if (a1)
  {
    v4 = AAAsyncByteStreamClose(*(uint64_t (***)(void))a1);
    if ((v4 & 0x80000000) != 0)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 207, 98, 0, "Async stream reported errors", v2, v3, v18);
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 2136));
    v7 = atomic_load((unint64_t *)(a1 + 2128));
    v8 = atomic_load((unint64_t *)(a1 + 2120));
    if (!(_DWORD)v4)
    {
      if (v7 == *(_QWORD *)(a1 + 2104) && v8 == 0)
      {
        v4 = 0;
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 216, 98, 0, "Some segments failed to process", v5, v6, v18);
        v4 = 0xFFFFFFFFLL;
      }
    }
    v10 = *(_DWORD *)(a1 + 2084);
    if (v10 < 0)
    {
      v12 = *(_DWORD *)(a1 + 2088);
      if (v12 < 0)
      {
        if ((_DWORD)v4)
          goto LABEL_24;
        goto LABEL_21;
      }
    }
    else
    {
      close(v10);
      v12 = *(_DWORD *)(a1 + 2088);
      if (v12 < 0)
      {
        if (!(_DWORD)v4)
        {
LABEL_18:
          rename((const std::__fs::filesystem::path *)(a1 + 1056), (const std::__fs::filesystem::path *)(a1 + 32), v11);
          if (v13)
          {
            v14 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 227, 98, *v14, "rename: %s", v15, v16, a1 + 32);
            v4 = 0xFFFFFFFFLL;
            goto LABEL_24;
          }
LABEL_21:
          if (*(_DWORD *)(a1 + 2080) >= 2u)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Decrypted file: %s\n", (const char *)(a1 + 32));
          v4 = 0;
        }
LABEL_24:
        free((void *)a1);
        return v4;
      }
    }
    close(v12);
    if (!(_DWORD)v4)
      goto LABEL_18;
    goto LABEL_24;
  }
  return 0;
}

_QWORD *decryptToFileAsyncCancel(_QWORD **a1)
{
  return AAAsyncByteStreamCancel(*a1);
}

uint64_t decryptToFileAsyncGetRange(_QWORD **a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*a1, a2, a3);
}

uint64_t decryptToFileAsyncProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*a1, a2, a3, a4);
}

uint64_t AEADecryptToFileChunkAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, unsigned int a8)
{
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  v12 = AEADecryptToFileAsyncStreamOpen(a1, a2, a3, a4, a7 | 0x200000000000000, a8);
  if (v12)
    return aaCompositeChunkAsyncStreamOpen((uint64_t)v12, a5, a6, a7, a8);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileChunkAsyncStreamOpen", 349, 98, 0, "AEADecryptToFileAsyncStreamOpen", v13, v14, v16);
  return 0;
}

_QWORD *AATempStreamOpen(unint64_t a1)
{
  return AATempStreamOpenWithDirectory(a1, 0);
}

_QWORD *AATempStreamOpenWithDirectory(unint64_t a1, const char *a2)
{
  _QWORD *v4;
  char *v5;
  char *v6;
  size_t v7;
  size_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  void *v15;
  uint64_t v16;
  char v18;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = (char *)malloc(0x88uLL);
  v6 = v5;
  if (v5 && (memset_s(v5, 0x88uLL, 0, 0x88uLL), v4))
  {
    if (a2)
    {
      v7 = strlen(a2);
      v8 = v7 + 1;
      if (v7 + 1 < 0x2000000001)
      {
        v15 = malloc(v7 + 1);
        v9 = v15;
        if (v15)
          memcpy(v15, a2, v8);
      }
      else
      {
        v9 = 0;
        *__error() = 12;
      }
    }
    else
    {
      v9 = 0;
    }
    *((_QWORD *)v6 + 13) = v9;
    v16 = a1 >> 20;
    if (a1 == -1)
      v16 = -1;
    *((_QWORD *)v6 + 1) = 0x100000;
    *((_QWORD *)v6 + 2) = v16;
    if ((pthread_mutex_init((pthread_mutex_t *)(v6 + 40), 0) & 0x80000000) == 0)
    {
      *v4 = v6;
      v4[1] = tempStreamClose;
      v4[6] = tempStreamSeek;
      v4[7] = tempStreamCancel;
      v4[2] = tempStreamRead;
      v4[3] = tempStreamWrite;
      v4[4] = tempStreamPRead;
      v4[5] = tempStreamPWrite;
      v4[8] = tempStreamTruncate;
      return v4;
    }
    v10 = *__error();
    v13 = "mutex init";
    v14 = 326;
  }
  else
  {
    v10 = *__error();
    v13 = "malloc";
    v14 = 320;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"AATempStreamOpenWithDirectory", v14, 50, v10, v13, v11, v12, v18);
  free(v6);
  free(v4);
  return 0;
}

uint64_t tempStreamClose(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  void *v3;
  unint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 128));
    AAByteStreamClose(*(AAByteStream *)(result + 112));
    v3 = *(void **)(v1 + 32);
    if (v3)
    {
      if (*(_QWORD *)(v1 + 24))
      {
        v4 = 0;
        do
          free(*(void **)(*(_QWORD *)(v1 + 32) + 8 * v4++));
        while (v4 < *(_QWORD *)(v1 + 24));
        v3 = *(void **)(v1 + 32);
      }
      free(v3);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
    free(*(void **)(v1 + 104));
    free((void *)v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t tempStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 128);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

ssize_t tempStreamRead(uint64_t a1, void *a2, size_t a3)
{
  unint64_t *v5;
  off_t v6;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (*(_QWORD *)(a1 + 112))
    return AAByteStreamRead(*(AAByteStream *)(a1 + 112), a2, a3);
  v5 = (unint64_t *)(a1 + 120);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPRead(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPRead(uint64_t a1, char *buf, size_t a3, off_t offset)
{
  unsigned int *v4;
  uint64_t v6;
  unint64_t v8;
  char *v9;
  AAByteStream_impl *v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v29;

  v4 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  v8 = offset;
  v9 = buf;
  v11 = *(AAByteStream_impl **)(a1 + 112);
  if (!v11)
  {
    if (((offset | a3) & 0x8000000000000000) == 0)
    {
      v12 = offset + a3;
      if (!__OFADD__(offset, a3))
      {
        if (*(_QWORD *)a1 <= offset)
          return 0;
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
        {
          v21 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", 120, 50, *v21, "mutex lock", v22, v23, v29);
          v6 = -1;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4))
              return v6;
          }
        }
        else
        {
          if (v12 >= *(_QWORD *)a1)
            v13 = *(_QWORD *)a1;
          else
            v13 = v12;
          if (v13 <= v8)
          {
            v6 = 0;
          }
          else
          {
            v6 = 0;
            v14 = *(_QWORD *)(a1 + 8);
            v15 = v8 / v14;
            v16 = v8 / v14 * v14;
            v17 = v16 + v14;
            do
            {
              if (v17 >= v13)
                v18 = v13;
              else
                v18 = v17;
              memcpy(v9, (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v15) + v8 - v16), v18 - v8);
              v9 += v18 - v8;
              v6 += v18 - v8;
              ++v15;
              v19 = *(_QWORD *)(a1 + 8);
              v16 += v19;
              v8 = v18;
              v20 = v13 > v17;
              v17 += v19;
            }
            while (v20);
          }
          if ((pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) & 0x80000000) == 0)
            return v6;
          v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", 148, 50, *v25, "mutex unlock", v26, v27, (char)v4);
          v6 = -1;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4))
              return v6;
          }
        }
        __clrex();
      }
    }
    return -1;
  }
  return AAByteStreamPRead(v11, buf, a3, offset);
}

off_t tempStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (!*(_QWORD *)(a1 + 112))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        v5 = (unint64_t *)(a1 + 120);
        do
        {
          v6 = __ldaxr(v5);
          v7 = v6 + a2;
        }
        while (__stlxr(v7, v5));
        return v7;
      }
      if (a3 != 2)
        return -1;
      a2 += *(_QWORD *)a1;
    }
    atomic_store(a2, (unint64_t *)(a1 + 120));
    return a2;
  }
  return AAByteStreamSeek(*(AAByteStream *)(a1 + 112), a2, a3);
}

ssize_t tempStreamWrite(uint64_t a1, void *a2, size_t a3)
{
  unint64_t *v5;
  unint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (*(_QWORD *)(a1 + 112))
    return AAByteStreamWrite(*(AAByteStream *)(a1 + 112), a2, a3);
  v5 = (unint64_t *)(a1 + 120);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPWrite(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPWrite(uint64_t a1, char *buf, size_t nbyte, unint64_t offset)
{
  unsigned int *v4;
  uint64_t v6;
  unint64_t v8;
  char *v10;
  AAByteStream_impl *v12;
  int64_t v13;
  pthread_mutex_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  AAByteStream_impl *v24;
  ssize_t v25;
  int v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v31;
  __int16 v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  char v45;
  unint64_t v46;

  v4 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  v8 = offset;
  v10 = buf;
  v12 = *(AAByteStream_impl **)(a1 + 112);
  if (!v12)
  {
    if (((offset | nbyte) & 0x8000000000000000) != 0)
      return -1;
    v13 = offset + nbyte;
    if (__OFADD__(offset, nbyte))
      return -1;
    v14 = (pthread_mutex_t *)(a1 + 40);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
    {
      v27 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", 164, 50, *v27, "mutex lock", v28, v29, v45);
      v6 = -1;
      while (!__ldaxr(v4))
      {
        if (!__stlxr(1u, v4))
          return v6;
      }
LABEL_42:
      __clrex();
      return -1;
    }
    if (v13 <= *(_QWORD *)a1)
      v21 = *(_QWORD *)a1;
    else
      v21 = v8 + nbyte;
    if ((resizeStream(a1, v21, v15, v16, v17, v18, v19, v20) & 0x80000000) != 0)
    {
      v31 = "resizing stream";
      v32 = 170;
    }
    else
    {
      v24 = *(AAByteStream_impl **)(a1 + 112);
      if (!v24)
      {
        v45 = a1 + 40;
        if (v13 <= v8)
        {
          v6 = 0;
        }
        else
        {
          v6 = 0;
          v33 = *(_QWORD *)(a1 + 8);
          v34 = v8 / v33;
          v35 = v8 / v33 * v33;
          v36 = v35 + v33;
          v46 = v13;
          do
          {
            if (v36 >= v13)
              v37 = v46;
            else
              v37 = v36;
            memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v34) + v8 - v35), v10, v37 - v8);
            v10 += v37 - v8;
            v6 += v37 - v8;
            ++v34;
            v38 = *(_QWORD *)(a1 + 8);
            v35 += v38;
            v8 = v37;
            v13 = v46;
            v39 = v46 > v36;
            v36 += v38;
          }
          while (v39);
        }
        v26 = 0;
        v40 = *(_QWORD *)a1;
        if (v13 > *(_QWORD *)a1)
          v40 = v13;
        *(_QWORD *)a1 = v40;
        v14 = (pthread_mutex_t *)(a1 + 40);
        goto LABEL_34;
      }
      v25 = AAByteStreamPWrite(v24, v10, nbyte, v8);
      if ((v25 & 0x8000000000000000) == 0)
      {
        v6 = v25;
        v26 = 0;
LABEL_34:
        if (pthread_mutex_unlock(v14) < 0)
        {
          v41 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", 209, 50, *v41, "mutex unlock", v42, v43, v45);
        }
        else if (!v26)
        {
          return v6;
        }
        v6 = -1;
        while (!__ldaxr(v4))
        {
          if (!__stlxr(1u, v4))
            return v6;
        }
        goto LABEL_42;
      }
      v31 = "temp file write";
      v32 = 176;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v32, 50, 0, v31, v22, v23, v45);
    v6 = 0;
    v26 = 1;
    goto LABEL_34;
  }
  return AAByteStreamPWrite(v12, buf, nbyte, offset);
}

uint64_t tempStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  char v31;

  v8 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return 0xFFFFFFFFLL;
  v13 = *(_QWORD **)(a1 + 112);
  if (v13)
    return AAByteStreamTruncate(v13);
  if (a2 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 271, 50, 0, "invalid length", a7, a8, v31);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 272, 50, *v23, "mutex lock", v24, v25, v31);
    result = 0xFFFFFFFFLL;
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
        return result;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  if ((resizeStream(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 274, 50, 0, "resize stream", v20, v21, v31);
    v22 = 0;
  }
  else
  {
    v22 = 1;
  }
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    v27 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 276, 50, *v27, "mutex lock", v28, v29, v31);
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
      {
        v22 = 0;
        goto LABEL_22;
      }
    }
    v22 = 0;
    __clrex();
  }
LABEL_22:
  if (v22)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t resizeStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  AAByteStream_impl *v29;
  off_t v30;
  off_t v31;
  unint64_t v32;
  void *v33;
  char *v34;
  uint64_t v35;
  rsize_t v36;
  void *v37;
  void *v38;
  const char *v40;
  __int16 v41;
  char v42;

  if (*(_QWORD *)(a1 + 112))
  {
    v8 = "invalid state";
    v9 = 64;
LABEL_3:
    v10 = 0;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"resizeStream", v9, 50, v10, v8, a7, a8, v42);
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)a1 >= a2)
    goto LABEL_51;
  v14 = *(_QWORD *)(a1 + 8);
  if (__OFADD__(a2, v14))
  {
    v42 = a2;
    v8 = "new size out of range: %zu";
    v9 = 70;
    goto LABEL_3;
  }
  v15 = (a2 + v14 - 1) / v14;
  if (v15 <= *(_QWORD *)(a1 + 16))
  {
    v32 = *(_QWORD *)(a1 + 24);
    while (v32 < v15)
    {
      if (v32)
        v32 *= 2;
      else
        v32 = 32;
    }
    if (8 * v32 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_55:
      *(_QWORD *)(a1 + 32) = 0;
      v10 = *__error();
      v8 = "malloc";
      v9 = 89;
      goto LABEL_4;
    }
    v33 = *(void **)(a1 + 32);
    v34 = (char *)realloc(v33, 8 * v32);
    if (!v34)
    {
      free(v33);
      goto LABEL_55;
    }
    *(_QWORD *)(a1 + 32) = v34;
    memset_s(&v34[8 * *(_QWORD *)(a1 + 24)], 8 * (v32 - *(_QWORD *)(a1 + 24)), 0, 8 * (v32 - *(_QWORD *)(a1 + 24)));
    *(_QWORD *)(a1 + 24) = v32;
    v35 = v15 - 1;
    while (v35 != -1 && !*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35))
    {
      v36 = *(_QWORD *)(a1 + 8);
      if (v36 < 0x2000000001)
      {
        v38 = malloc(*(_QWORD *)(a1 + 8));
        v37 = v38;
        if (v38)
          memset_s(v38, v36, 0, v36);
      }
      else
      {
        v37 = 0;
        *__error() = 12;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35) = v37;
      if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35--))
      {
        v10 = *__error();
        v8 = "malloc";
        v9 = 99;
        goto LABEL_4;
      }
    }
LABEL_51:
    result = 0;
    *(_QWORD *)a1 = a2;
    return result;
  }
  v16 = AATempFileStreamOpenWithDirectory(*(const char **)(a1 + 104));
  *(_QWORD *)(a1 + 112) = v16;
  if (!v16)
  {
    v40 = "AATempFileStreamOpen";
    v41 = 36;
LABEL_57:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"offloadToFile", v41, 50, 0, v40, v17, v18, v42);
    v8 = "offload to file";
    v9 = 76;
    goto LABEL_3;
  }
  v19 = (_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 24))
  {
    v20 = 0;
    v21 = 0;
    while (*(_QWORD *)a1 > v21)
    {
      if (*(_QWORD *)(a1 + 8) >= *(_QWORD *)a1 - v21)
        v22 = *(_QWORD *)a1 - v21;
      else
        v22 = *(_QWORD *)(a1 + 8);
      v23 = *(_QWORD *)(a1 + 112);
      if (*(_QWORD *)(v23 + 24))
      {
        v24 = 0;
        if (v22)
        {
          v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v20);
          v26 = v22;
          while (1)
          {
            v27 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v23 + 24))(*(_QWORD *)v23, v25, v26);
            if (v27 < 1)
              break;
            v25 += v27;
            v24 += v27;
            v26 -= v27;
            if (!v26)
              goto LABEL_26;
          }
          v24 = v27;
        }
      }
      else
      {
        v24 = -1;
      }
LABEL_26:
      if (v24 != v22)
      {
        v40 = "writing data to temp file";
        v41 = 43;
        goto LABEL_57;
      }
      v21 += v22;
      if ((unint64_t)++v20 >= *v19)
      {
        if (!*v19)
          goto LABEL_31;
        break;
      }
    }
    v28 = 0;
    do
      free(*(void **)(*(_QWORD *)(a1 + 32) + 8 * v28++));
    while (v28 < *(_QWORD *)(a1 + 24));
  }
LABEL_31:
  free(*(void **)(a1 + 32));
  *v19 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  if ((AAByteStreamTruncate(*(_QWORD **)(a1 + 112)) & 0x80000000) != 0)
  {
    v8 = "truncate temp file";
    v9 = 78;
    goto LABEL_3;
  }
  v29 = *(AAByteStream_impl **)(a1 + 112);
  v30 = atomic_load((unint64_t *)(a1 + 120));
  v31 = AAByteStreamSeek(v29, v30, 0);
  result = 0;
  if (v31 < 0)
  {
    v8 = "seek temp file";
    v9 = 80;
    goto LABEL_3;
  }
  return result;
}

uint64_t bxdiff5Alloc(size_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;

  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_QWORD *)(a3 + 16) = a1;
  v3 = *a2;
  *(_DWORD *)(a3 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a3 = v3;
  if (a1)
    *(_QWORD *)(a3 + 24) = calloc(a1, 0x50uLL);
  return 0;
}

uint64_t bxdiff5Free(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t result;
  char v14;

  if (*(_QWORD *)(a1 + 16))
  {
    v9 = 0;
    v10 = 0;
    v11 = 1;
    do
    {
      v12 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v12 + v9))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 40, 54, 0, "in[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
        v12 = *(_QWORD *)(a1 + 24);
      }
      if (*(_QWORD *)(v12 + v9 + 64))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 41, 54, 0, "inPatch[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
        v12 = *(_QWORD *)(a1 + 24);
      }
      if (*(_QWORD *)(v12 + v9 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 42, 54, 0, "inControls[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
      }
      ++v10;
      v9 += 80;
    }
    while (v10 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    v11 = 1;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 44, 54, 0, "out is not NULL", a7, a8, v14);
    v11 = 0;
  }
  if (*(_QWORD *)(a1 + 72))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 45, 54, 0, "comboControls is not NULL", a7, a8, v14);
    v11 = 0;
  }
  if (*(_QWORD *)(a1 + 96))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 46, 54, 0, "comboPatch is not NULL", a7, a8, v14);
    v11 = 0;
  }
  free(*(void **)(a1 + 24));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  if (v11)
    result = 0;
  else
    result = 0xFFFFFFFFLL;
  *(_OWORD *)a1 = 0uLL;
  return result;
}

uint64_t bxdiff5Dump(uint64_t a1, FILE *a2)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t j;
  unint64_t v20;
  unint64_t v21;

  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = (int *)(*(_QWORD *)(a1 + 24) + 36);
    v6 = *(_QWORD *)(a1 + 16);
    do
    {
      v7 = *v5;
      v5 += 20;
      if (v7)
        ++v4;
      --v6;
    }
    while (v6);
  }
  else
  {
    v4 = 0;
  }
  fprintf(a2, "BXDiff5Data: n=%zu, nUnique=%zu\n", *(_QWORD *)(a1 + 16), v4);
  if (*(_QWORD *)(a1 + 16))
  {
    v8 = 0;
    v9 = 0;
    v10 = 16;
    do
    {
      fprintf(a2, "- input %zu\n", v9);
      v11 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v11 + 80 * v9))
      {
        fprintf(a2, "    in set, inSize=%zu, inSHA1=", *(_QWORD *)(v11 + 80 * v9 + 8));
        for (i = 0; i != 20; ++i)
          fprintf(a2, "%02x", *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v10 + i));
        v13 = "unique";
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 24) + 80 * v9 + 36))
          v13 = "non unique";
        fprintf(a2, ", %s", v13);
        fputc(10, a2);
      }
      else
      {
        fwrite("    in is NULL\n", 0xFuLL, 1uLL, a2);
      }
      v14 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v14 + 80 * v9 + 40))
      {
        v15 = v14 + 80 * v9;
        v16 = 3 * *(_QWORD *)(v15 + 56);
        fprintf(a2, "    inControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(_QWORD *)(v15 + 56), *(_DWORD *)(v15 + 48), (v16 >> 17) & 0xFFFFFFFFFFFLL);
        v8 += 8 * v16;
      }
      else
      {
        fwrite("    inControls is NULL\n", 0x17uLL, 1uLL, a2);
      }
      v17 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v17 + 80 * v9 + 64))
      {
        v18 = *(_QWORD *)(v17 + 80 * v9 + 72);
        fprintf(a2, "    inPatch set, inPatchSize=%zu (%zu MB)\n", v18, v18 >> 20);
        v8 += v18;
      }
      else
      {
        fwrite("    inPatch is NULL\n", 0x14uLL, 1uLL, a2);
      }
      ++v9;
      v10 += 80;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    v8 = 0;
  }
  fwrite("- output\n", 9uLL, 1uLL, a2);
  if (*(_QWORD *)(a1 + 32))
  {
    fprintf(a2, "    out set, outSize=%zu, outSHA1=", *(_QWORD *)(a1 + 40));
    for (j = 0; j != 20; ++j)
      fprintf(a2, "%02x", *(unsigned __int8 *)(a1 + 48 + j));
    fputc(10, a2);
  }
  else
  {
    fwrite("    out is NULL\n", 0x10uLL, 1uLL, a2);
  }
  if (*(_QWORD *)(a1 + 72))
  {
    v20 = (8 * v4 + 16) * *(_QWORD *)(a1 + 88);
    fprintf(a2, "    comboControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(_QWORD *)(a1 + 88), *(_DWORD *)(a1 + 80), v20 >> 20);
    v8 += v20;
  }
  else
  {
    fwrite("    comboControls is NULL\n", 0x1AuLL, 1uLL, a2);
  }
  if (*(_QWORD *)(a1 + 96))
  {
    v21 = *(_QWORD *)(a1 + 104);
    fprintf(a2, "    comboPatch set, comboPatchSize=%zu (%zu MB)\n", v21, v21 >> 20);
    v8 += v21;
  }
  else
  {
    fwrite("    comboPatch is NULL\n", 0x17uLL, 1uLL, a2);
  }
  fprintf(a2, "Total size %zu MB\n", v8 >> 20);
  return 0;
}

uint64_t bxdiff5SetIn(_QWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t result;
  char v19;

  if (a1[2] <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", 122, 54, 0, "invalid I=%zu", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  if (!a3 || !a4)
  {
    v16 = "invalid in,inSize";
    v17 = 123;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", v17, 54, 0, v16, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  if (!a1[4])
  {
    v16 = "missing out";
    v17 = 124;
    goto LABEL_16;
  }
  v10 = a1[3] + 80 * a2;
  *(_QWORD *)v10 = a3;
  *(_QWORD *)(v10 + 8) = a4;
  getBufferSHA1Digest(a3, a4, (unsigned __int8 *)(v10 + 16));
  v11 = a1[2];
  v12 = a1[3];
  *(_DWORD *)(v12 + 80 * a2 + 36) = 1;
  if (v11)
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      if (a2 != v14)
      {
        v15 = a1[3];
        if (*(_QWORD *)(v15 + v13))
        {
          if (!sha1cmp(v15 + 80 * a2 + 16, v15 + v13 + 16))
          {
            v12 = a1[3];
            *(_DWORD *)(v12 + 80 * a2 + 36) = 0;
            break;
          }
          v11 = a1[2];
        }
      }
      ++v14;
      v13 += 80;
      if (v14 >= v11)
      {
        v12 = a1[3];
        break;
      }
    }
  }
  result = sha1cmp(v12 + 80 * a2 + 16, (uint64_t)(a1 + 6));
  if ((_DWORD)result)
    return 0;
  *(_DWORD *)(a1[3] + 80 * a2 + 36) = 0;
  return result;
}

uint64_t bxdiff5SetOut(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (a2 && a3)
  {
    *(_QWORD *)(a1 + 32) = a2;
    *(_QWORD *)(a1 + 40) = a3;
    getBufferSHA1Digest(a2, a3, (unsigned __int8 *)(a1 + 48));
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetOut", 155, 54, 0, "invalid out,outSize", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInControls(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  int8x16_t **v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t result;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  int LargeFileControls;
  char v25;

  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    v14 = "invalid input index";
    v15 = 247;
    goto LABEL_5;
  }
  v10 = *(_QWORD *)(a1 + 24);
  v11 = v10 + 80 * a2;
  v13 = *(_QWORD *)(v11 + 40);
  v12 = (int8x16_t **)(v11 + 40);
  if (v13)
  {
    v14 = "input controls already present";
    v15 = 248;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateInControls", v15, 54, 0, v14, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  v17 = *(_QWORD *)(v10 + 80 * a2);
  if (!v17 || (v18 = *(_QWORD *)(v10 + 80 * a2 + 8)) == 0)
  {
    v14 = "input is missing or invalid";
    v15 = 249;
    goto LABEL_5;
  }
  if (!*(_DWORD *)(v10 + 80 * a2 + 36))
    return 0;
  v20 = *(_QWORD *)(a1 + 32);
  v21 = *(_QWORD *)(a1 + 40);
  v22 = (uint64_t *)(v10 + 80 * a2 + 56);
  if (!(v18 >> 28) || v21 >> 28 == 0)
  {
    if ((getBXDiffControls(v17, v18, v20, v21, v12, (uint64_t)v22, (int *)a1, a8) & 0x80000000) != 0)
    {
      v14 = "generic controls";
      v15 = 270;
      goto LABEL_5;
    }
  }
  else
  {
    LargeFileControls = GetLargeFileControls(v17, v18, v20, v21, (void **)v12, v22, (uint64_t *)a1, a8);
    if (LargeFileControls < 0)
    {
      v14 = "largefile controls";
      v15 = 262;
      goto LABEL_5;
    }
  }
  if (!a3)
    return 0;
  if ((forceInPlaceControls(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 56), *(_DWORD *)(a1 + 4)) & 0x80000000) != 0)
  {
    v14 = "forceInPlaceControls";
    v15 = 278;
    goto LABEL_5;
  }
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 48) = 1;
  return result;
}

uint64_t bxdiff5CreateComboControls(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  unint64_t v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;

  v8 = *(_QWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_7;
  v10 = 0;
  v11 = (int *)(*(_QWORD *)(a1 + 24) + 36);
  v12 = *(_QWORD *)(a1 + 16);
  do
  {
    v13 = *v11;
    v11 += 20;
    if (v13)
      ++v10;
    --v12;
  }
  while (v12);
  if (v10 > 1)
  {
    *(_DWORD *)(a1 + 80) = 1;
    v15 = (uint64_t *)calloc(v8, 0x18uLL);
    if (v15)
    {
      v16 = v15;
      v17 = v15;
      v18 = v8;
      do
      {
        initDiffSegmentVector(v17);
        v17 += 3;
        --v18;
      }
      while (v18);
      v25 = 0;
      v26 = 0;
      v27 = *(_QWORD *)(a1 + 24);
      do
      {
        if (*(_DWORD *)(v27 + v25 + 36))
        {
          v28 = *(_QWORD *)(v27 + v25 + 40);
          if (!v28)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 309, 54, 0, "missing controls for input %zu", v23, v24, v18);
            goto LABEL_28;
          }
          if ((pushControls((unint64_t *)&v16[3 * v26], v28, *(_QWORD *)(v27 + v25 + 56), 0, 0) & 0x80000000) != 0)
          {
            v33 = "pushControls";
            v34 = 312;
            goto LABEL_27;
          }
          v27 = *(_QWORD *)(a1 + 24);
          if (!*(_DWORD *)(v27 + v25 + 48))
            *(_DWORD *)(a1 + 80) = 0;
          ++v26;
        }
        ++v18;
        v25 += 80;
      }
      while (v8 != v18);
      if ((mergeDiffSegmentVectors(v26, v16, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        v33 = "mergeDiffSegmentVectors";
        v34 = 321;
      }
      else
      {
        if ((getComboControlsFromMergedDiffSegmentVectors((char *)v26, v16, (_QWORD *)(a1 + 72), (uint64_t *)(a1 + 88)) & 0x80000000) == 0)
        {
          v29 = 1;
          goto LABEL_29;
        }
        v33 = "getComboControlsFromMergedDiffSegmentVectors";
        v34 = 324;
      }
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", v34, 54, 0, v33, v23, v24, v37);
LABEL_28:
      v29 = 0;
LABEL_29:
      if (v8 <= 1)
        v35 = 1;
      else
        v35 = v8;
      v36 = (uint64_t)v16;
      do
      {
        BlobBufferFree(v36);
        v36 += 24;
        --v35;
      }
      while (v35);
      free(v16);
    }
    else
    {
      v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 300, 54, *v30, "malloc", v31, v32, v37);
      v29 = 0;
    }
    if (v29)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 289, 54, 0, "creating combo controls requires 2 or more unique inputs", a7, a8, v37);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInPatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24) + 80 * a2;
  return bxdiff5CreatePatchBackend(1, v2, v2 + 8, v2 + 16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a1 + 48, *(_QWORD *)(v2 + 40), *(_QWORD *)(v2 + 56), (_QWORD *)(v2 + 64), (size_t *)(v2 + 72), *(_DWORD *)(v2 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
}

uint64_t bxdiff5CreatePatchBackend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t __size, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10, size_t *a11, int a12, int a13, unsigned int a14)
{
  size_t *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  int64x2_t v24;
  int64x2_t v25;
  int64x2_t *v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  size_t v32;
  _OWORD *v33;
  _QWORD *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int64_t *v49;
  uint64_t v50;
  int64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  _BYTE *v58;
  int64_t v59;
  char v60;
  char v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  size_t v68;
  uint64_t v69;
  int *v71;
  uint64_t v72;
  uint64_t v73;
  size_t v74;
  size_t *v75;
  uint64_t v76;
  uint64_t v77;
  size_t v78;
  size_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  FILE **v85;
  char v86;
  char *v87;
  uint64_t v88;
  void *__dsta[2];
  char *__dst;

  v19 = a10;
  v18 = a11;
  v22 = (char *)malloc(__size);
  if (!v22)
  {
    v28 = *__error();
    v29 = "malloc";
    v30 = 447;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", v30, 54, v28, v29, v20, v21, v86);
    v34 = 0;
LABEL_49:
    free(v22);
    free(v34);
    v67 = 0;
    v68 = 0;
    v69 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  v23 = a9;
  if (a9)
  {
    v24 = 0uLL;
    v25 = vdupq_n_s64(0x8000000000000000);
    v26 = (int64x2_t *)a8;
    v27 = a9;
    do
    {
      v24 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v26), (int8x16_t)vsubq_s64(v25, *v26), *(int8x16_t *)v26), v24);
      v26 = (int64x2_t *)((char *)v26 + 8 * a1 + 16);
      --v27;
    }
    while (v27);
  }
  else
  {
    v24 = 0uLL;
  }
  v88 = a1 + 2;
  if (a13 > 1)
  {
    *(int64x2_t *)__dsta = v24;
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 backend, out: %zu B, diff: %zu B, lit: %zu B, ctrl: %zu B\n", __size, v24.u64[0], v24.u64[1], 8 * (a1 + 2) * a9);
    v24 = *(int64x2_t *)__dsta;
  }
  if (vaddvq_s64(v24) != __size)
  {
    v29 = "size inconsistency: diff + archive != out";
    v30 = 458;
    v28 = 0;
    goto LABEL_48;
  }
  __dst = v22;
  v31 = 28 * a1 + lzma_stream_buffer_bound() * a1;
  v32 = v31 + lzma_stream_buffer_bound() + 60;
  if (a13 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch allocated: %zu B\n", v32);
  v33 = malloc(v32);
  v34 = v33;
  if (!v33)
  {
    v71 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 469, 54, *v71, "malloc", v72, v73, v86);
LABEL_52:
    v19 = a10;
    v22 = __dst;
    goto LABEL_49;
  }
  *(_OWORD *)((char *)v33 + 44) = 0u;
  v33[1] = 0u;
  v33[2] = 0u;
  *v33 = 0u;
  v87 = (char *)v33 + 60;
  bzero((char *)v33 + 60, 28 * a1);
  *v34 = 0x3035464649445842;
  v34[2] = __size;
  *(_OWORD *)(v34 + 5) = *(_OWORD *)a7;
  *((_DWORD *)v34 + 14) = *(_DWORD *)(a7 + 16);
  *((_DWORD *)v34 + 2) = a1;
  *((_DWORD *)v34 + 3) = a12 != 0;
  if (a1)
  {
    v35 = (char *)v34 + 68;
    v36 = a1;
    do
    {
      *(_OWORD *)v35 = *(_OWORD *)a4;
      *((_DWORD *)v35 + 4) = *(_DWORD *)(a4 + 16);
      a4 += 20;
      v35 += 28;
      --v36;
    }
    while (v36);
  }
  v37 = (char *)v34 + v32;
  v38 = (uint64_t)&v87[28 * a1];
  if (a13 > 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch headers: %zu B\n", v38 - (_QWORD)v34);
  v19 = a10;
  v39 = plzmaEncodeBuffer(v38, (uint64_t)&v37[-v38], a8, 8 * (a1 + 2) * a9, a14);
  if (v39 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 499, 54, 0, "Payload compression", v40, v41, v86);
    v22 = __dst;
    goto LABEL_49;
  }
  v42 = v38 + v39;
  v34[3] = v39;
  if (a13 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch control payload: %zu B\n", v39);
  v22 = __dst;
  if (a1)
  {
    v43 = 0;
    v44 = a5;
    while (!a9)
    {
      v48 = v22;
LABEL_42:
      v63 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)v22, v48 - v22, a14);
      if (v63 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 530, 54, 0, "Payload compression", v64, v65, v86);
        goto LABEL_52;
      }
      v66 = v63;
      *(_QWORD *)&v87[28 * v43] = v63;
      if (a13 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch diff[%zu] payload: %zu B\n", v43, v63);
      v42 += v66;
      ++v43;
      v22 = __dst;
      v44 = a5;
      if (v43 == a1)
        goto LABEL_56;
    }
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = v22;
    while (1)
    {
      v49 = (int64_t *)(a8 + 8 * v45 * v88);
      v50 = v49[1];
      v51 = 0x8000000000000000 - *v49;
      if (*v49 >= 0)
        v51 = *v49;
      v52 = 0x8000000000000000 - v50;
      if (v50 >= 0)
        v52 = v49[1];
      v53 = v49[v43 + 2];
      if (v53 < 0)
        v53 = 0x8000000000000000 - v53;
      if (v46 < 0)
        break;
      v54 = v51 + v46;
      if (v51 + v46 > __size)
        break;
      if (v47 < 0 || (v55 = v51 + v47, v51 + v47 > *(_QWORD *)(a3 + 8 * v43)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 519, 54, 0, "in[%zu] access out of range", a2, v88, v43);
        goto LABEL_69;
      }
      if (v51 >= 1)
      {
        v56 = (char *)(*(_QWORD *)(a2 + 8 * v43) + v47);
        v57 = (char *)(v44 + v46);
        v58 = v48;
        v59 = v51;
        do
        {
          v61 = *v57++;
          v60 = v61;
          v62 = *v56++;
          *v58++ = v60 - v62;
          --v59;
        }
        while (v59);
      }
      v48 += v51;
      v46 = v54 + v52;
      v47 = v55 + v53;
      if (++v45 == a9)
        goto LABEL_42;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 518, 54, 0, "out access out of range", a2, v88, v86);
    goto LABEL_69;
  }
  v44 = a5;
LABEL_56:
  if (a9)
  {
    v74 = 0;
    v75 = (size_t *)(a8 + 8);
    v76 = 8 * a1 + 16;
    v22 = __dst;
    do
    {
      v77 = *(v75 - 1);
      if (v77 < 0)
        v77 = 0x8000000000000000 - v77;
      if ((*v75 & 0x8000000000000000) == 0)
        v78 = *v75;
      else
        v78 = 0x8000000000000000 - *v75;
      v79 = v77 + v74;
      memcpy(v22, (const void *)(v44 + v77 + v74), v78);
      v44 = a5;
      v22 += v78;
      v74 = v79 + v78;
      v75 = (size_t *)((char *)v75 + v76);
      --v23;
    }
    while (v23);
  }
  v80 = v22 - __dst;
  v22 = __dst;
  v81 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)__dst, v80, a14);
  if (v81 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 554, 54, 0, "Payload compression", v82, v83, v86);
    v18 = a11;
LABEL_69:
    v19 = a10;
    goto LABEL_49;
  }
  v84 = v42 + v81;
  v34[4] = v81;
  if (a13 <= 1)
  {
    v68 = v84 - (_QWORD)v34;
  }
  else
  {
    v85 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch archive payload: %zu B\n", v81);
    v68 = v84 - (_QWORD)v34;
    fprintf(*v85, "BXDiff5 patch total size: %zu B\n", v84 - (_QWORD)v34);
  }
  v18 = a11;
  v19 = a10;
  free(__dst);
  v67 = reallocToFit(v34, v68);
  v69 = 0;
LABEL_50:
  *v19 = v67;
  *v18 = v68;
  return v69;
}

uint64_t bxdiff5CreateComboPatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  size_t v10;
  int *v11;
  int v12;
  uint64_t PatchBackend;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  void *v17;
  BOOL v18;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  char v32;

  if (*(_QWORD *)(a1 + 72))
  {
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = 0;
      v11 = (int *)(*(_QWORD *)(a1 + 24) + 36);
      do
      {
        v12 = *v11;
        v11 += 20;
        if (v12)
          ++v10;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
    }
    v14 = calloc(v10, 8uLL);
    v15 = calloc(v10, 8uLL);
    v16 = (char *)calloc(v10, 0x14uLL);
    v17 = v16;
    if (v14)
      v18 = v15 == 0;
    else
      v18 = 1;
    if (v18 || v16 == 0)
    {
      v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 609, 54, *v20, "malloc", v21, v22, v32);
      PatchBackend = 0xFFFFFFFFLL;
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 16);
      if (v23)
      {
        v24 = 0;
        v25 = 0;
        v26 = 0;
        do
        {
          v27 = *(_QWORD *)(a1 + 24);
          if (*(_DWORD *)(v27 + v24 + 36))
          {
            v14[v26] = *(_QWORD *)(v27 + v24);
            v28 = *(_QWORD *)(a1 + 24) + v24;
            v15[v26] = *(_QWORD *)(v28 + 8);
            v29 = &v16[20 * v26];
            v30 = *(_OWORD *)(v28 + 16);
            *((_DWORD *)v29 + 4) = *(_DWORD *)(v28 + 32);
            *(_OWORD *)v29 = v30;
            ++v26;
            v23 = *(_QWORD *)(a1 + 16);
          }
          ++v25;
          v24 += 80;
        }
        while (v25 < v23);
      }
      PatchBackend = bxdiff5CreatePatchBackend(v10, (uint64_t)v14, (uint64_t)v15, (uint64_t)v16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a1 + 48, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 88), (_QWORD *)(a1 + 96), (size_t *)(a1 + 104), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
    }
    free(v14);
    free(v15);
    free(v17);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 600, 54, 0, "missing combo controls", a7, a8, v32);
    return 0xFFFFFFFFLL;
  }
  return PatchBackend;
}

uint64_t BXDiff5(uint64_t a1, void **a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BXDiff5WithIndividualPatches(a1, a2, a3, 0, 0, a6, a7, a8);
}

uint64_t BXDiff5WithIndividualPatches(uint64_t a1, void **a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  int v14;
  size_t v15;
  int v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  int v49;
  uint64_t v50;
  int *v51;
  int v52;
  uint64_t v53;
  int *v54;
  int v55;
  __int128 v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  size_t v60;
  char *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char v67;
  int v68;
  unint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  const char *v75;
  __int16 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  char v93;
  char v94;
  char v95;
  void **v96;
  _QWORD *v97;
  int v98;
  int v99;
  uint64_t v100;
  int v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  void *v106[2];
  __int128 v107;
  __int128 v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  if (HIDWORD(*(_QWORD *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 645, 54, 0, "Invalid number of inputs: %zu", a7, a8, *(_QWORD *)a1);
    return 0xFFFFFFFFLL;
  }
  v9 = (_QWORD *)a5;
  v10 = (_QWORD *)a4;
  v14 = *(_DWORD *)(a1 + 48);
  enterThreadErrorContext(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v93);
  v15 = *(_QWORD *)a1;
  v16 = *(_DWORD *)(a1 + 52);
  if (v10)
    v17 = v9 == 0;
  else
    v17 = 1;
  v18 = !v17;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  *(_OWORD *)v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v102 = 0u;
  v19 = *(_DWORD *)(a1 + 44);
  v99 = v18;
  LODWORD(v100) = *(_DWORD *)(a1 + 40);
  HIDWORD(v100) = v16;
  v101 = v19;
  bxdiff5Alloc(v15, &v100, (uint64_t)&v102);
  *a2 = 0;
  *a3 = 0;
  if (v10 && v15)
    bzero(v10, 8 * v15);
  if (v9 && v15)
    bzero(v9, 8 * v15);
  if (bxdiff5SetOut((uint64_t)&v102, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), v20, v21, v22, v23, v24))
  {
    v32 = "bxdiff5SetOut";
    v33 = 672;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", v33, 54, 0, v32, v30, v31, v94);
    LODWORD(v34) = 0;
    goto LABEL_18;
  }
  if (v15)
  {
    v45 = 0;
    while (!bxdiff5SetIn(&v102, v45, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v45), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v45), v28, v29, v30, v31))
    {
      if (v15 == ++v45)
        goto LABEL_28;
    }
    v32 = "bxdiff5SetIn";
    v33 = 675;
    goto LABEL_17;
  }
LABEL_28:
  v46 = v103;
  if ((_QWORD)v103)
  {
    v47 = 0;
    v48 = (int *)(*((_QWORD *)&v103 + 1) + 36);
    do
    {
      v49 = *v48;
      v48 += 20;
      if (v49)
        ++v47;
      --v46;
    }
    while (v46);
    if (!v47)
      *(_DWORD *)(*((_QWORD *)&v103 + 1) + 36) = 1;
  }
  if (v16 >= 2)
    bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (v15)
  {
    v50 = v103;
    v96 = a2;
    if ((_QWORD)v103)
    {
      v34 = 0;
      v51 = (int *)(*((_QWORD *)&v103 + 1) + 36);
      do
      {
        v52 = *v51;
        v51 += 20;
        if (v52)
          ++v34;
        --v50;
      }
      while (v50);
      if (v34 == 1)
      {
        v53 = 0;
        v54 = (int *)(*((_QWORD *)&v103 + 1) + 36);
        while (1)
        {
          v55 = *v54;
          v54 += 20;
          if (v55)
            break;
          if (v15 == ++v53)
          {
            v32 = "could not find unique input";
            v33 = 699;
            goto LABEL_17;
          }
        }
        v67 = v14;
        v98 = v16;
        v99 = 0;
        v97 = a3;
        v68 = 1;
        v34 = 1;
LABEL_59:
        v69 = 0;
        v70 = v67 & 2;
        if (v15 <= 1)
          v71 = 1;
        else
          v71 = v15;
        v72 = 36;
        do
        {
          if (*(_DWORD *)(*((_QWORD *)&v103 + 1) + v72))
          {
            if (bxdiff5CreateInControls((uint64_t)&v102, v69, v70, v27, v28, v29, v30, v31))
            {
              v32 = "bxdiff5CreateInControls";
              v33 = 710;
              goto LABEL_17;
            }
            v73 = v53 == v69 ? v68 : 0;
            if ((v99 || v73) && bxdiff5CreateInPatch((uint64_t)&v102, v69))
            {
              v32 = "bxdiff5CreateInPatch";
              v33 = 718;
              goto LABEL_17;
            }
          }
          ++v69;
          v72 += 80;
        }
        while (v71 != v69);
        if (v98 >= 2)
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
        if (v34 >= 2)
        {
          if (bxdiff5CreateComboControls((uint64_t)&v102, v25, v26, v27, v28, v29, v30, v31))
          {
            v32 = "bxdiff5CreateComboControls";
            v33 = 730;
            goto LABEL_17;
          }
          v79 = 0;
          v80 = *((_QWORD *)&v103 + 1);
          v81 = v71;
          do
          {
            free(*(void **)(v80 + v79 + 40));
            v80 = *((_QWORD *)&v103 + 1);
            v89 = *((_QWORD *)&v103 + 1) + v79;
            *(_QWORD *)(v89 + 40) = 0;
            *(_QWORD *)(v89 + 56) = 0;
            v79 += 80;
            --v81;
          }
          while (v81);
          if (v98 > 1)
            bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
          if (bxdiff5CreateComboPatch((uint64_t)&v102, v82, v83, v84, v85, v86, v87, v88))
          {
            v32 = "bxdiff5CreateComboPatch";
            v33 = 747;
            goto LABEL_17;
          }
        }
        if (v98 >= 2)
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
        if (v34 >= 2)
        {
          v90 = *((_QWORD *)&v108 + 1);
          *v96 = (void *)v108;
          *v97 = v90;
          v108 = 0uLL;
          if (!v99)
            goto LABEL_97;
          v91 = (_QWORD *)(*((_QWORD *)&v103 + 1) + 64);
          do
          {
            *v10++ = *v91;
            *v9++ = v91[1];
            *v91 = 0;
            v91[1] = 0;
            v91 += 10;
            --v71;
          }
          while (v71);
        }
        if (v34 == 1)
        {
          v92 = *((_QWORD *)&v103 + 1) + 80 * v53;
          *v96 = *(void **)(v92 + 64);
          *v97 = *(_QWORD *)(v92 + 72);
          *(_QWORD *)(v92 + 64) = 0;
          *(_QWORD *)(v92 + 72) = 0;
          goto LABEL_18;
        }
LABEL_97:
        LODWORD(v34) = 1;
LABEL_18:
        if (v15)
        {
          v35 = 0;
          v36 = *((_QWORD *)&v103 + 1);
          do
          {
            v37 = v36 + v35;
            *(_QWORD *)v37 = 0;
            free(*(void **)(v37 + 40));
            v36 = *((_QWORD *)&v103 + 1);
            *(_QWORD *)(*((_QWORD *)&v103 + 1) + v35 + 40) = 0;
            v35 += 80;
            --v15;
          }
          while (v15);
        }
        goto LABEL_21;
      }
      v67 = v14;
      v98 = v16;
      v97 = a3;
      v68 = 0;
    }
    else
    {
      v67 = v14;
      v98 = v16;
      v97 = a3;
      v68 = 0;
      v34 = 0;
    }
    v53 = -1;
    goto LABEL_59;
  }
  v56 = v104;
  v57 = DWORD1(v102);
  v58 = DWORD2(v102);
  v59 = lzma_stream_buffer_bound();
  v60 = v59 + 60;
  if (v57 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch capacity: %zu B\n", v60);
  v61 = (char *)malloc(v60);
  v62 = v61;
  if (v61)
  {
    *(_OWORD *)v61 = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *(_OWORD *)(v61 + 44) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(_QWORD *)v61 = 0x3035464649445842;
    *((_QWORD *)v61 + 1) = 0;
    *((_QWORD *)v61 + 2) = *((_QWORD *)&v56 + 1);
    *(_OWORD *)(v61 + 40) = v105;
    *((_DWORD *)v61 + 14) = v106[0];
    v63 = plzmaEncodeBuffer((uint64_t)(v61 + 60), v59, v56, *((uint64_t *)&v56 + 1), v58);
    if ((v63 & 0x8000000000000000) == 0)
    {
      v66 = (char *)v62 + v63 + 60;
      v62[4] = v63;
      if (v57 >= 1)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch archive payload size: %zu B\n", v63);
      *a2 = reallocToFit(v62, v66 - (char *)v62);
      *a3 = v66 - (char *)v62;
      LODWORD(v34) = 1;
      goto LABEL_21;
    }
    v75 = "Payload compression";
    v76 = 406;
    v74 = 0;
  }
  else
  {
    v74 = *__error();
    v75 = "malloc patch";
    v76 = 386;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateFullReplacementBackend", v76, 54, v74, v75, v64, v65, v94);
  free(v62);
  *a2 = 0;
  *a3 = 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 689, 54, 0, "bxdiff5CreateFullReplacementBackend", v77, v78, v95);
  LODWORD(v34) = 0;
LABEL_21:
  *(_QWORD *)&v104 = 0;
  free(v106[1]);
  v106[1] = 0;
  bxdiff5Free((uint64_t)&v102, v38, v39, v40, v41, v42, v43, v44);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return (v34 - 1);
  else
    return result;
}

uint64_t plzmaEncodeBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _QWORD *v29;

  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v10 = IMemStreamCreate(a3, a4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", 348, 54, 0, "is", v8, v9, v25);
    v19 = 0;
LABEL_8:
    v22 = 1;
    goto LABEL_9;
  }
  v11 = OMemStreamCreate(a1, a2);
  v19 = v11;
  if (!v11)
  {
    v20 = "os";
    v21 = 349;
    goto LABEL_7;
  }
  *(_QWORD *)((char *)&v25 + 4) = a5 | 0x100000000;
  LODWORD(v25) = 0;
  *(_QWORD *)&v26 = 0x100000;
  *((_QWORD *)&v26 + 1) = IMemStreamRead;
  *((_QWORD *)&v27 + 1) = v10;
  *(_QWORD *)&v28 = OMemStreamWrite;
  v29 = v11;
  if (ParallelCompressionEncode((uint64_t)&v25, v12, v13, v14, v15, v16, v17, v18))
  {
    v20 = "encode";
    v21 = 358;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", v21, 54, 0, v20, v17, v18, v25);
    goto LABEL_8;
  }
  v22 = 0;
LABEL_9:
  v23 = BXDiffMatchesOBuf((uint64_t)v19);
  OMemStreamDestroy(v10);
  OMemStreamDestroy(v19);
  if (v22)
    return -1;
  else
    return v23;
}

_QWORD *aaInSituStreamOpen(_QWORD *a1, uint64_t a2, int a3, int a4, int a5)
{
  _QWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  void *v17;
  __int128 v18;
  int v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  v10 = calloc(1uLL, 0x68uLL);
  v11 = calloc(1uLL, 0x140uLL);
  v14 = (uint64_t)v11;
  if (!v10 || !v11)
  {
    v23 = "aaCalloc";
    v24 = 336;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"aaInSituStreamOpen", v24, 140, 0, v23, v12, v13, v33);
    free(v10);
    InSituStreamClose(v14, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  *(_QWORD *)v11 = a1;
  v11[78] = a5;
  v15 = (unint64_t)(a2 + 0x3FFF) >> 14;
  v11[72] = v15;
  LODWORD(v15) = v15 + ((a3 + 0x3FFF) >> 14) + ((int)v15 >> 2);
  v11[79] = a4;
  v16 = (v15 + 256);
  *(_DWORD *)(v14 + 292) = v16;
  if ((int)v15 + 256 < 0)
  {
    *__error() = 12;
    *(_QWORD *)(v14 + 8) = 0;
    goto LABEL_14;
  }
  v17 = calloc(v16, 0xDuLL);
  *(_QWORD *)(v14 + 8) = v17;
  if (!v17)
  {
LABEL_14:
    v23 = "aaCalloc";
    v24 = 347;
    goto LABEL_16;
  }
  *(_QWORD *)&v18 = -1;
  *((_QWORD *)&v18 + 1) = -1;
  *(_OWORD *)(v14 + 240) = v18;
  *(_OWORD *)(v14 + 256) = v18;
  *(_OWORD *)(v14 + 208) = v18;
  *(_OWORD *)(v14 + 224) = v18;
  *(_OWORD *)(v14 + 176) = v18;
  *(_OWORD *)(v14 + 192) = v18;
  *(_OWORD *)(v14 + 144) = v18;
  *(_OWORD *)(v14 + 160) = v18;
  *(_OWORD *)(v14 + 112) = v18;
  *(_OWORD *)(v14 + 128) = v18;
  *(_OWORD *)(v14 + 80) = v18;
  *(_OWORD *)(v14 + 96) = v18;
  *(_OWORD *)(v14 + 48) = v18;
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 16) = v18;
  *(_OWORD *)(v14 + 32) = v18;
  v19 = *(_DWORD *)(v14 + 292);
  if (v19 >= 1)
  {
    v20 = 0;
    for (i = 0; i < v19; ++i)
    {
      v22 = *(_QWORD *)(v14 + 8) + v20;
      *(_DWORD *)(v22 + 1) = i;
      *(_QWORD *)(v22 + 5) = 0xFFFFFFFF00000000;
      if (i < *(int *)(v14 + 288))
      {
        free_page(v14, i);
        v19 = *(_DWORD *)(v14 + 292);
      }
      v20 += 13;
    }
  }
  if ((AAByteStreamTruncate(a1) & 0x80000000) != 0)
  {
    v23 = "AAByteStreamTruncate";
    v24 = 362;
    goto LABEL_16;
  }
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)InSituStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)InSituStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)InSituStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  v10[8] = InSituTruncate;
  v10[11] = InSituStreamSimulate;
  return v10;
}

uint64_t free_page(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t i;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;

  v3 = result;
  for (i = *(_QWORD *)(result + 8); ; a2 = *(_DWORD *)(i + 13 * a2 + 1))
  {
    v5 = (_BYTE *)(i + 13 * a2);
    v6 = *v5;
    if (v6 != 2)
      break;
  }
  if (v6 == 1)
  {
    *v5 = 0;
    *(_DWORD *)(i + 13 * a2 + 5) = 0;
  }
  ++*(_DWORD *)(result + 296);
  v7 = i + 13 * a2;
  v9 = *(_DWORD *)(v7 + 9);
  v8 = (_DWORD *)(v7 + 9);
  if (v9 < 0)
  {
    v10 = *(_DWORD *)(result + 276);
    *(_DWORD *)(result + 276) = v10 - 1;
    if (v10 >= 2)
    {
      v11 = *(_DWORD *)(result + 272);
    }
    else
    {
      *(_DWORD *)(result + 276) = 32;
      result = rand();
      v11 = result & 0x3F;
      *(_DWORD *)(v3 + 272) = v11;
    }
    v12 = v3 + 4 * v11;
    *v8 = *(_DWORD *)(v12 + 16);
    *(_DWORD *)(v12 + 16) = a2;
  }
  return result;
}

uint64_t InSituStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (result)
  {
    v8 = result;
    v9 = *(unsigned int *)(result + 292);
    if ((int)v9 < 1)
      goto LABEL_7;
    v10 = 0;
    v11 = (int *)(*(_QWORD *)(result + 8) + 5);
    do
    {
      v12 = *v11;
      v11 = (int *)((char *)v11 + 13);
      v10 += v12;
      --v9;
    }
    while (v9);
    if (v10)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 298, 140, 0, "%i dangling reads", a7, a8, v10);
      v13 = 0;
    }
    else
    {
LABEL_7:
      v13 = 1;
    }
    v14 = *(_DWORD *)(v8 + 288);
    v15 = *(_DWORD *)(v8 + 308);
    if (*(_DWORD *)(v8 + 300) + v14 != *(_DWORD *)(v8 + 296) + v15)
    {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 301, 140, "file + excess != written + free", a6, a7, a8, v18);
      v14 = *(_DWORD *)(v8 + 288);
      v15 = *(_DWORD *)(v8 + 308);
    }
    if (v14 < v15)
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 302, 140, "file < written", a6, a7, a8, v18);
    if (*(_DWORD *)(v8 + 316))
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "InSituStream: pages: %i file, %i written, %i remapped, %i free, %i excess (%iK)\n", *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 308), *(_DWORD *)(v8 + 304), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), 16 * *(_DWORD *)(v8 + 300));
    free(*(void **)(v8 + 8));
    if (*(_DWORD *)(v8 + 312) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 319, 140, 0, "AAByteStreamClose", v16, v17, v18);
      v13 = 0;
    }
    free((void *)v8);
    if (v13)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t InSituStreamPRead(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;

  if (!a3)
    return 0;
  v11 = 0;
  while (1)
  {
    v12 = a1[1];
    v13 = (v11 + a4) & 0x3FFF;
    v14 = a3 - v11 >= 0x4000 - v13 ? 0x4000 - v13 : a3 - v11;
    if (!*(_DWORD *)(v12 + 13 * (int)((v11 + a4) >> 14) + 5))
      break;
    v15 = *a1;
    if (!*(_QWORD *)(*a1 + 32))
      goto LABEL_19;
    if (v14)
    {
      v16 = 0;
      v17 = v13 | ((uint64_t)*(int *)(v12 + 13 * (int)((uint64_t)(v11 + a4) >> 14) + 1) << 14);
      v18 = a2 + v11;
      v19 = v14;
      while (1)
      {
        v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v15 + 32))(*(_QWORD *)v15, v18, v19, v17);
        if (v20 < 0)
          break;
        if (v20)
        {
          v18 += v20;
          v16 += v20;
          v17 += v20;
          v19 -= v20;
          if (v19)
            continue;
        }
        goto LABEL_15;
      }
      v16 = v20;
LABEL_15:
      if (v14 != v16)
      {
LABEL_19:
        v21 = "aaByteStreamPReadExpected";
        v22 = 238;
        goto LABEL_21;
      }
    }
    v11 += v14;
    if (v11 >= a3)
      return v11;
  }
  v21 = "data not locked";
  v22 = 235;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPRead", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

uint64_t InSituStreamPWrite(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;

  if (!a3)
    return 0;
  v11 = 0;
  while (1)
  {
    v12 = v11 + a4;
    v13 = (v11 + a4) >> 14;
    v14 = (_BYTE *)(a1[1] + 13 * (int)v13);
    if (a3 - v11 >= 0x4000 - ((v11 + a4) & 0x3FFF))
      v15 = 0x4000 - ((v11 + a4) & 0x3FFF);
    else
      v15 = a3 - v11;
    if (*v14 == 2)
      goto LABEL_9;
    if ((remap_page(a1, v13) & 0x80000000) != 0)
      break;
    *v14 = 2;
    --*((_DWORD *)a1 + 74);
    ++*((_DWORD *)a1 + 77);
LABEL_9:
    v16 = *a1;
    if (!*(_QWORD *)(*a1 + 40))
      goto LABEL_20;
    if (v15)
    {
      v17 = 0;
      v18 = a2 + v11;
      v19 = v15;
      while (1)
      {
        v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v16 + 40))(*(_QWORD *)v16, v18, v19, v12);
        if (v20 < 1)
          break;
        v18 += v20;
        v17 += v20;
        v12 += v20;
        v19 -= v20;
        if (!v19)
          goto LABEL_16;
      }
      v17 = v20;
LABEL_16:
      if (v15 != v17)
      {
LABEL_20:
        v21 = "aaByteStreamPWriteExpected";
        v22 = 268;
        goto LABEL_22;
      }
    }
    v11 += v15;
    if (v11 >= a3)
      return v11;
  }
  v21 = "remap_page";
  v22 = 261;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPWrite", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

void InSituStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t InSituTruncate(_QWORD **a1)
{
  return AAByteStreamTruncate(*a1);
}

uint64_t InSituStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  int64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  __int16 v24;
  char v26;

  v8 = a5;
  v9 = a4;
  if (a2 == 3)
  {
    v11 = *(_QWORD *)a1;
    if (!*(_QWORD *)(*(_QWORD *)a1 + 32))
      return -1;
    if (!a4)
      return 0;
    v13 = 0;
    while (1)
    {
      v14 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, unint64_t))(v11 + 32))(*(_QWORD *)v11, a3, v9, v8);
      if (v14 < 0)
        break;
      if (v14)
      {
        a3 += v14;
        v13 += v14;
        v8 += v14;
        v9 -= v14;
        if (v9)
          continue;
      }
      return v13;
    }
    return v14;
  }
  if (a4 < 1)
    return v9;
  if (a2 > 1)
  {
    v23 = "not implemented";
    v24 = 197;
    goto LABEL_24;
  }
  v16 = a5 + a4;
  while (1)
  {
    v17 = *(_QWORD *)(a1 + 8) + 13 * (int)(v8 >> 14);
    v20 = *(_DWORD *)(v17 + 5);
    v18 = (int *)(v17 + 5);
    v19 = v20;
    if (!a2)
      break;
    if (v19 <= 0)
    {
      v23 = "data not locked";
      v24 = 209;
      goto LABEL_24;
    }
    v21 = v19 - 1;
    *v18 = v21;
    if (!v21)
      free_page(a1, v8 >> 14);
LABEL_18:
    v8 = (v8 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if ((uint64_t)v8 >= v16)
      return v9;
  }
  *v18 = v19 + 1;
  if (v19)
    goto LABEL_18;
  v22 = *(_DWORD *)(a1 + 296);
  *(_DWORD *)(a1 + 296) = v22 - 1;
  if (v22)
    goto LABEL_18;
  v23 = "no free pages";
  v24 = 204;
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamSimulate", v24, 140, 0, v23, a7, a8, v26);
  return -1;
}

uint64_t remap_page(_DWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  int v5;
  uint64_t result;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  unsigned int *v18;
  unsigned int v19;
  int v20;
  BOOL v21;
  int v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char v42;

  v2 = *((_QWORD *)a1 + 1);
  v3 = v2 + 13 * a2;
  v5 = *(_DWORD *)(v3 + 5);
  v4 = (_DWORD *)(v3 + 5);
  if (v5)
  {
    if (*(_BYTE *)(v2 + 13 * a2) == 1)
    {
      result = remap_page(a1, *(unsigned int *)(v2 + 13 * a2 + 1));
      *v4 = 0;
      return result;
    }
    v11 = (char *)malloc(0x4000uLL);
    v14 = v11;
    if (v11)
    {
      v15 = a1[74];
      if (v15 <= 0)
      {
        v26 = a1[72];
        v27 = a1[75];
        a1[75] = v27 + 1;
        v19 = v27 + v26;
        if (v27 + v26 >= a1[73])
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"allocate_page", 97, 140, 0, "too many excess pages", v12, v13, v42);
        }
        else if ((v19 & 0x80000000) == 0)
        {
LABEL_20:
          v28 = *(_QWORD *)a1;
          if (*(_QWORD *)(*(_QWORD *)a1 + 32))
          {
            v29 = 0;
            v30 = (unsigned int *)(v2 + 13 * a2 + 1);
            v31 = (uint64_t)(int)*v30 << 14;
            v32 = 0x4000;
            v33 = v11;
            while (1)
            {
              v34 = (*(uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))(v28 + 32))(*(_QWORD *)v28, v33, v32, v31);
              if (v34 < 0)
                break;
              if (v34)
              {
                v33 += v34;
                v29 += v34;
                v31 += v34;
                v32 -= v34;
                if (v32)
                  continue;
              }
              if (v29 != 0x4000)
                break;
              v35 = *(_QWORD *)a1;
              if (*(_QWORD *)(*(_QWORD *)a1 + 40))
              {
                v36 = 0;
                v37 = (unint64_t)v19 << 14;
                v38 = 0x4000;
                v39 = v14;
                while (1)
                {
                  v40 = (*(uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))(v35 + 40))(*(_QWORD *)v35, v39, v38, v37);
                  if (v40 < 1)
                    break;
                  v39 += v40;
                  v36 += v40;
                  v37 += v40;
                  v38 -= v40;
                  if (!v38)
                  {
                    if (v36 != 0x4000)
                      break;
                    v10 = 0;
                    *v30 = v19;
                    v41 = *((_QWORD *)a1 + 1) + 13 * v19;
                    *(_BYTE *)v41 = 1;
                    *(_DWORD *)(v41 + 1) = a2;
                    *(_DWORD *)(v41 + 5) = 0x7FFFFFFF;
                    ++a1[76];
                    ++a1[74];
                    goto LABEL_35;
                  }
                }
              }
              v24 = "aaByteStreamPWriteExpected";
              v25 = 158;
              goto LABEL_34;
            }
          }
          v24 = "aaByteStreamPReadExpected";
          v25 = 157;
          goto LABEL_34;
        }
      }
      else
      {
        v16 = a1[70];
        a1[74] = v15 - 1;
        v17 = a1[73];
        if (v17)
        {
          v18 = &a1[(v16 & 0x3F) + 4];
          do
          {
            v19 = *v18;
            if ((*v18 & 0x80000000) != 0
              || (v20 = a1[71], v21 = __OFSUB__(v20, 1), --v20, a1[71] = v20, (v20 < 0) ^ v21 | (v20 == 0)))
            {
              a1[71] = 32;
              v22 = a1[70] + 1;
              a1[70] = v22;
              v18 = &a1[(v22 & 0x3F) + 4];
            }
            else
            {
              v23 = v2 + 13 * v19;
              *v18 = *(_DWORD *)(v23 + 9);
              *(_DWORD *)(v23 + 9) = -1;
              if (!*(_DWORD *)(v23 + 5) && !*(_BYTE *)(v2 + 13 * v19))
                goto LABEL_20;
            }
            --v17;
          }
          while (v17);
        }
      }
      v24 = "allocate_page";
      v25 = 153;
    }
    else
    {
      v24 = "aaMalloc";
      v25 = 149;
    }
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"remap_page", v25, 140, 0, v24, v12, v13, v42);
    v10 = 0xFFFFFFFFLL;
LABEL_35:
    free(v14);
    return v10;
  }
  return 0;
}

uint64_t aeaContextUnlock(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5, int a6)
{
  int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  size_t v29;
  size_t v30;
  size_t v31;
  char *v32;
  char *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  char v58;
  _DWORD *v59;
  _OWORD v60[3];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  _OWORD v65[2];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _OWORD v77[16];
  int v78;
  _OWORD v79[16];
  int v80;
  _OWORD v81[16];
  int v82;
  _OWORD v83[16];
  int v84;
  _OWORD v85[16];
  int v86;
  _OWORD v87[16];
  int v88;
  _OWORD v89[16];
  int v90;
  size_t __n[2];
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  int v107;
  size_t v108[2];
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  int v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  _OWORD v128[16];
  int v129;
  _OWORD v130[16];
  int v131;
  _OWORD __s[17];
  _BYTE v133[260];
  uint64_t v134;

  v134 = *MEMORY[0x24BDAC8D0];
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v66 = 0u;
  memset(v65, 0, sizeof(v65));
  v64 = 0;
  v62 = 0u;
  v63 = 0u;
  v61 = 0u;
  memset(v60, 0, sizeof(v60));
  v127 = 0u;
  v126 = 0u;
  v125 = 0u;
  v124 = 0;
  v123 = 0u;
  v122 = 0u;
  v121 = 0u;
  v120 = 0u;
  v119 = 0u;
  v118 = 0u;
  v117 = 0u;
  v116 = 0u;
  v115 = 0u;
  v114 = 0u;
  v113 = 0u;
  v112 = 0u;
  v111 = 0u;
  v110 = 0u;
  v109 = 0u;
  *(_OWORD *)v108 = 0u;
  v107 = 0;
  v106 = 0u;
  v105 = 0u;
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  v100 = 0u;
  v99 = 0u;
  v98 = 0u;
  v97 = 0u;
  v96 = 0u;
  v95 = 0u;
  v94 = 0u;
  v93 = 0u;
  v92 = 0u;
  *(_OWORD *)__n = 0u;
  v90 = 0;
  memset(v89, 0, sizeof(v89));
  v88 = 0;
  memset(v87, 0, sizeof(v87));
  v86 = 0;
  memset(v85, 0, sizeof(v85));
  v84 = 0;
  memset(v83, 0, sizeof(v83));
  v82 = 0;
  memset(v81, 0, sizeof(v81));
  v80 = 0;
  memset(v79, 0, sizeof(v79));
  v78 = 0;
  memset(v77, 0, sizeof(v77));
  v12 = *(_DWORD *)(a1 + 1372);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  v13 = *(_OWORD *)(a1 + 16);
  v14 = *(_OWORD *)(a1 + 32);
  v15 = *(_OWORD *)(a1 + 48);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 32) = v14;
  *(_OWORD *)(a2 + 48) = v15;
  *(_OWORD *)(a2 + 16) = v13;
  if ((aeaCryptoInit((char *)v65, (unsigned int *)a2) & 0x80000000) != 0)
  {
    v22 = "initializing crypto params";
    v23 = 33;
    goto LABEL_74;
  }
  if ((aeaContainerOffsetsInit((uint64_t)v60, (unsigned int *)a2, (unsigned int *)v65) & 0x80000000) != 0)
  {
    v22 = "deriving container offsets";
    v23 = 34;
    goto LABEL_74;
  }
  v18 = DWORD2(v65[0]);
  if (DWORD2(v65[0]) >= 0x101)
    goto LABEL_78;
  v59 = a4;
  __memcpy_chk();
  LODWORD(v108[0]) = v18;
  memset_s((char *)v108 + v18 + 4, 256 - v18, 0, 256 - v18);
  v19 = v67;
  if (v67 >= 0x101)
    goto LABEL_78;
  __memcpy_chk();
  LODWORD(v87[0]) = v19;
  memset_s((char *)v87 + v19 + 4, 256 - v19, 0, 256 - v19);
  if (*(_DWORD *)a2 <= 4u && ((1 << *(_DWORD *)a2) & 0x15) != 0)
  {
    v20 = *(unsigned int *)(a1 + 332);
    if ((_DWORD)v20)
    {
      if (v20 >= 0x101)
        goto LABEL_78;
      __memcpy_chk();
      LODWORD(v89[0]) = v20;
      memset_s((char *)v89 + v20 + 4, 256 - v20, 0, 256 - v20);
    }
    else if (*(_DWORD *)(a1 + 592))
    {
      if (!*((_QWORD *)&v74 + 1)
        || (v46 = (*((uint64_t (**)(_OWORD *, uint64_t))&v74 + 1))(v89, a1 + 592),
            LODWORD(v89[0]) != (_DWORD)v66)
        || v46 < 0)
      {
        v22 = "deriving signing public key";
        v23 = 47;
        goto LABEL_74;
      }
    }
  }
  if (!a6 || !v12)
  {
    if ((aeaDeriveMainKeyExisting((unsigned int *)v65, (_DWORD *)a2, __n, (_DWORD *)(a1 + 72), (_DWORD *)(a1 + 2152), (unsigned int *)v87, (unsigned int *)v89, (unsigned int *)(a1 + 852), (_DWORD *)(a1 + 1112), v108, *(uint64_t (**)(uint64_t, _QWORD, char *, __int128 *, unsigned int *, _QWORD))(a1 + 2432), *(_QWORD *)(a1 + 2440)) & 0x80000000) == 0)goto LABEL_17;
    v22 = "Main key derivation";
    v23 = 70;
LABEL_74:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", v23, 57, 0, v22, v16, v17, v58);
    v33 = 0;
    goto LABEL_75;
  }
  v21 = *(unsigned int *)(a1 + 1372);
  if (v21 >= 0x101)
    goto LABEL_78;
  __memcpy_chk();
  LODWORD(__n[0]) = v21;
  memset_s((char *)__n + v21 + 4, 256 - v21, 0, 256 - v21);
LABEL_17:
  if (!a5)
    goto LABEL_20;
  if (*(_DWORD *)a2 > 5u)
  {
    v22 = "Unsupported signature mode";
    v23 = 102;
    goto LABEL_74;
  }
  v24 = 1 << *(_DWORD *)a2;
  if ((v24 & 0x2A) != 0)
    goto LABEL_20;
  if ((v24 & 0x14) == 0)
  {
    v55 = *(unsigned int *)(a1 + 2448);
    if (v55 >= 0x101)
      goto LABEL_78;
    __memcpy_chk();
    LODWORD(v83[0]) = v55;
    memset_s((char *)v83 + v55 + 4, 256 - v55, 0, 256 - v55);
    goto LABEL_63;
  }
  memset(&v133[8], 0, 252);
  memset(__s, 0, 260);
  *(_DWORD *)&v133[7] = 1262834527;
  *(_QWORD *)v133 = 0x5F41454100000007;
  memset_s(&v133[11], 0xF9uLL, 0, 0xF9uLL);
  if (!*((_QWORD *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(v133, 0x104uLL, 0, 0x104uLL);
    goto LABEL_70;
  }
  v47 = (*((uint64_t (**)(_OWORD *, _QWORD, size_t *, _BYTE *, _OWORD *))&v68 + 1))(v85, LODWORD(v65[0]), __n, v133, __s);
  memset_s(v133, 0x104uLL, 0, 0x104uLL);
  if (v47 < 0)
  {
LABEL_70:
    v22 = "deriving signature encryption key";
    v23 = 89;
    goto LABEL_74;
  }
  if (!*((_QWORD *)&v73 + 1))
  {
LABEL_73:
    v22 = "decrypting signature";
    v23 = 90;
    goto LABEL_74;
  }
  memset(__s, 0, 260);
  v131 = 0;
  memset(v130, 0, sizeof(v130));
  v129 = 0;
  memset(v128, 0, sizeof(v128));
  if (*(_DWORD *)(a1 + 2448) != HIDWORD(v66))
    goto LABEL_72;
  if (LODWORD(v85[0]) != LODWORD(v65[0]))
    goto LABEL_72;
  *(_QWORD *)((char *)v130 + 4) = 0x324B45535F414541;
  LODWORD(v130[0]) = 8;
  memset_s((void *)((unint64_t)v130 | 0xC), 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((_QWORD *)&v68 + 1)
    || !LODWORD(v85[0])
    || ((*((uint64_t (**)(_OWORD *, _QWORD, _OWORD *, _OWORD *, _BYTE *))&v68 + 1))(__s, DWORD1(v65[0]), v85, v130, v133) & 0x80000000) != 0)
  {
    goto LABEL_72;
  }
  v48 = DWORD2(v66);
  if (DWORD2(v66) >= 0x101)
    goto LABEL_78;
  __memcpy_chk();
  LODWORD(v83[0]) = v48;
  memset_s((char *)v83 + v48 + 4, 256 - v48, 0, 256 - v48);
  v49 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101)
    goto LABEL_78;
  __memcpy_chk();
  LODWORD(v128[0]) = v49;
  memset_s((char *)v128 + v49 + 4, 256 - v49, 0, 256 - v49);
  if (((*((uint64_t (**)(char *, _QWORD, _OWORD *, _OWORD *, _QWORD, _QWORD))&v73 + 1))((char *)v83 + 4, LODWORD(v83[0]), v128, __s, 0, 0) & 0x80000000) != 0)
  {
LABEL_72:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    goto LABEL_73;
  }
  v50 = v83[0];
  v51 = DWORD2(v66);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v128, 0x104uLL, 0, 0x104uLL);
  memset_s(v130, 0x104uLL, 0, 0x104uLL);
  if (v50 != v51)
    goto LABEL_73;
LABEL_63:
  if (!*((_QWORD *)&v71 + 1)
    || (v56 = (*((uint64_t (**)(_OWORD *, _QWORD, _QWORD))&v71 + 1))(v81, *(_QWORD *)(a1 + 2720), *(_QWORD *)(a1 + 2728)), LODWORD(v81[0]) != DWORD1(v66))|| v56 < 0)
  {
    v22 = "digesting prologue";
    v23 = 94;
    goto LABEL_74;
  }
  if (!*((_QWORD *)&v72 + 1)
    || ((*((uint64_t (**)(_OWORD *, _OWORD *, _OWORD *))&v72 + 1))(v83, v89, v81) & 0x80000000) != 0)
  {
    v22 = "verifying signature";
    v23 = 97;
    goto LABEL_74;
  }
LABEL_20:
  v25 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101)
    goto LABEL_78;
  __memcpy_chk();
  LODWORD(v79[0]) = v25;
  memset_s((char *)v79 + v25 + 4, 256 - v25, 0, 256 - v25);
  v26 = *(_QWORD *)(a1 + 2720);
  v28 = *(_OWORD *)(v26 + v61 + 16);
  v27 = *(_OWORD *)(v26 + v61 + 32);
  v125 = *(_OWORD *)(v26 + v61);
  v126 = v28;
  v127 = v27;
  v29 = HIDWORD(v65[0]);
  v30 = *(unsigned int *)(a2 + 4);
  v31 = (v30 + HIDWORD(v65[0]));
  v32 = (char *)malloc(v31);
  v33 = v32;
  if (!v32)
  {
    v52 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", 113, 57, *v52, "malloc", v53, v54, v58);
LABEL_75:
    v43 = 0xFFFFFFFFLL;
    goto LABEL_76;
  }
  memcpy(v32, (const void *)(v26 + *((_QWORD *)&v61 + 1)), v29);
  memcpy(&v33[v29], (const void *)(v26 + *((_QWORD *)&v60[0] + 1)), v30);
  memset((char *)__s + 12, 0, 248);
  *(_QWORD *)((char *)__s + 4) = 0x4B4548525F414541;
  LODWORD(__s[0]) = 8;
  memset_s((char *)__s + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((_QWORD *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_58:
    v43 = 0xFFFFFFFFLL;
    goto LABEL_59;
  }
  v34 = (*((uint64_t (**)(_OWORD *, _QWORD, size_t *, _OWORD *, _BYTE *))&v68 + 1))(v77, DWORD1(v65[0]), __n, __s, v133);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v34 < 0
    || !(_QWORD)v70
    || LODWORD(v79[0]) != HIDWORD(v65[0])
    || (((uint64_t (*)(__int128 *, uint64_t, _OWORD *, _OWORD *, char *, size_t))v70)(&v125, 48, v79, v77, v33, v31) & 0x80000000) != 0)
  {
    goto LABEL_58;
  }
  if ((aeaContainerParamsInitWithRootHeader(a2, (uint64_t)&v125, v35, v36, v37, v38, v39, v40) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", 126, 57, 0, "Invalid root header", v41, v42, v58);
    goto LABEL_58;
  }
  v43 = (uint64_t)v59;
  if (a3)
  {
    v44 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101)
      goto LABEL_78;
    memcpy(a3 + 1, (char *)__n + 4, LODWORD(__n[0]));
    *a3 = v44;
    memset_s((char *)a3 + v44 + 4, 256 - v44, 0, 256 - v44);
  }
  if (v59)
  {
    v45 = LODWORD(v108[0]);
    if (LODWORD(v108[0]) < 0x101)
    {
      memcpy(v59 + 1, (char *)v108 + 4, LODWORD(v108[0]));
      *v59 = v45;
      memset_s((char *)v59 + v45 + 4, 256 - v45, 0, 256 - v45);
      v43 = 0;
      goto LABEL_59;
    }
LABEL_78:
    __break(1u);
  }
LABEL_59:
  memset_s(v33, v31, 0, v31);
LABEL_76:
  free(v33);
  memset_s(v65, 0xD0uLL, 0, 0xD0uLL);
  memset_s(v60, 0x68uLL, 0, 0x68uLL);
  memset_s(&v125, 0x30uLL, 0, 0x30uLL);
  memset_s(v87, 0x104uLL, 0, 0x104uLL);
  memset_s(v85, 0x104uLL, 0, 0x104uLL);
  memset_s(v83, 0x104uLL, 0, 0x104uLL);
  memset_s(v81, 0x104uLL, 0, 0x104uLL);
  memset_s(v108, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v79, 0x104uLL, 0, 0x104uLL);
  memset_s(v77, 0x104uLL, 0, 0x104uLL);
  memset_s(v89, 0x104uLL, 0, 0x104uLL);
  return v43;
}

uint64_t aeaContextCreateWithPrologue(_DWORD *a1, size_t a2)
{
  AEAContext_impl *v4;
  AEAContext_impl *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t result;
  char *v16;
  char *v17;
  size_t v18;
  void *v19;
  rsize_t v20;
  uint64_t v21;
  void *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  _OWORD __s[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v31 = 0u;
  memset(__s, 0, sizeof(__s));
  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v4 = (AEAContext_impl *)malloc(0xAB8uLL);
  v5 = v4;
  if (!v4)
  {
    v14 = *__error();
    v12 = "malloc";
    v13 = 161;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextCreateWithPrologue", v13, 57, v14, v12, v10, v11, v23);
    AEAContextDestroy(v5);
    return 0;
  }
  memset_s(v4, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v5 + 684) = 1;
  if (a2 <= 0xB)
  {
    v12 = "Invalid prologue";
    v13 = 167;
LABEL_15:
    v14 = 0;
    goto LABEL_16;
  }
  if ((aeaContainerParamsInitWithMagic((int *)v5, a1, v6, v7, v8, v9, v10, v11) & 0x80000000) != 0)
  {
    v12 = "Invalid magic";
    v13 = 168;
    goto LABEL_15;
  }
  if ((aeaCryptoInit((char *)__s, (unsigned int *)v5) & 0x80000000) != 0)
  {
    v12 = "Invalid container";
    v13 = 169;
    goto LABEL_15;
  }
  if ((aeaContainerOffsetsInit((uint64_t)&v23, (unsigned int *)v5, (unsigned int *)__s) & 0x80000000) != 0)
  {
    v12 = "deriving container offsets";
    v13 = 170;
    goto LABEL_15;
  }
  if ((_QWORD)v27 != a2)
  {
    v12 = "Prologue size mismatch";
    v13 = 171;
    goto LABEL_15;
  }
  *((_QWORD *)v5 + 341) = a2;
  if (a2 >= 0x2000000001)
  {
    *__error() = 12;
    *((_QWORD *)v5 + 340) = 0;
LABEL_28:
    v14 = *__error();
    v12 = "malloc";
    v13 = 176;
    goto LABEL_16;
  }
  v16 = (char *)malloc(a2);
  *((_QWORD *)v5 + 340) = v16;
  if (!v16)
    goto LABEL_28;
  v17 = v16;
  memcpy(v16, a1, a2);
  v18 = *((unsigned int *)v5 + 1);
  if ((_DWORD)v18)
  {
    v19 = malloc(*((unsigned int *)v5 + 1));
    *((_QWORD *)v5 + 339) = v19;
    if (!v19)
    {
      v14 = *__error();
      v12 = "malloc";
      v13 = 184;
      goto LABEL_16;
    }
    memcpy(v19, &v17[*((_QWORD *)&v23 + 1)], v18);
  }
  if (!*((_QWORD *)&v41 + 1)
    || (result = (*((uint64_t (**)(uint64_t, char *, size_t))&v41 + 1))((uint64_t)v5 + 1892, v17, a2),
        *((_DWORD *)v5 + 473) != DWORD1(v32))
    || (result & 0x80000000) != 0)
  {
    v12 = "digesting prologue";
    v13 = 189;
    goto LABEL_15;
  }
  v20 = HIDWORD(v31);
  if (HIDWORD(v31) < 0x101)
  {
    v21 = *((_QWORD *)v5 + 340);
    v22 = (void *)(v21 + v24);
    __memcpy_chk();
    *((_DWORD *)v5 + 612) = v20;
    memset_s((char *)v5 + v20 + 2452, 256 - v20, 0, 256 - v20);
    if (v21)
      memset_s(v22, v20, 0, v20);
    return (uint64_t)v5;
  }
  __break(1u);
  return result;
}

void AEAContextDestroy(AEAContext context)
{
  void *v2;
  void *v3;

  if (context)
  {
    v2 = (void *)*((_QWORD *)context + 339);
    if (v2)
      memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
    free(v2);
    v3 = (void *)*((_QWORD *)context + 340);
    if (v3)
      memset_s(*((void **)context + 340), *((_QWORD *)context + 341), 0, *((_QWORD *)context + 341));
    free(v3);
    memset_s(context, 0xAB8uLL, 0, 0xAB8uLL);
    free(context);
  }
}

AEAContext AEAContextCreateWithProfile(AEAProfile profile)
{
  AEAContext_impl *v2;
  AEAContext_impl *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  v2 = (AEAContext_impl *)malloc(0xAB8uLL);
  v3 = v2;
  if (!v2)
  {
    v12 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithProfile", 237, 57, v12, "malloc", v13, v14, v16);
    goto LABEL_5;
  }
  memset_s(v2, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v3 + 684) = 0;
  if ((aeaContainerParamsInitWithProfile((uint64_t)v3, profile, v4, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithProfile", 243, 57, 0, "Invalid profile: %u", v10, v11, profile);
LABEL_5:
    AEAContextDestroy(v3);
    return 0;
  }
  return v3;
}

AEAContext AEAContextCreateWithEncryptedStream(AAByteStream encrypted_stream)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  const char *v13;
  __int16 v14;
  int v15;
  _DWORD *v16;
  AEAContext_impl *v17;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  int v30;
  _OWORD v31[4];
  size_t __size[2];
  __int128 v33;
  uint64_t v34;
  _OWORD v35[4];
  uint64_t v36;
  _OWORD __s[13];

  memset(__s, 0, sizeof(__s));
  v36 = 0;
  memset(v35, 0, sizeof(v35));
  v34 = 0;
  *(_OWORD *)__size = 0u;
  v33 = 0u;
  memset(v31, 0, sizeof(v31));
  v30 = 0;
  v29 = 0;
  if (*((_QWORD *)encrypted_stream + 2))
  {
    v4 = 0;
    v5 = &v29;
    v6 = 12;
    do
    {
      v7 = (*((uint64_t (**)(_QWORD, uint64_t *, uint64_t))encrypted_stream + 2))(*(_QWORD *)encrypted_stream, v5, v6);
      if (v7 < 0)
        goto LABEL_12;
      if (!v7)
        break;
      v5 = (uint64_t *)((char *)v5 + v7);
      v4 += v7;
      v6 -= v7;
    }
    while (v6);
    if (v4 != 12)
      goto LABEL_12;
    if ((aeaContainerParamsInitWithMagic((int *)v35, &v29, v8, v9, v10, v11, v1, v2) & 0x80000000) != 0)
    {
      v13 = "Invalid magic";
      v14 = 264;
      goto LABEL_13;
    }
    if ((aeaCryptoInit((char *)__s, (unsigned int *)v35) & 0x80000000) != 0)
    {
      v13 = "Invalid container";
      v14 = 265;
      goto LABEL_13;
    }
    if ((aeaContainerOffsetsInit((uint64_t)v31, (unsigned int *)v35, (unsigned int *)__s) & 0x80000000) != 0)
    {
      v13 = "deriving container offsets";
      v14 = 266;
      goto LABEL_13;
    }
    v12 = __size[0];
    if (__size[0] >= 0x2000000001)
    {
      *__error() = 12;
LABEL_28:
      v15 = *__error();
      v13 = "malloc";
      v14 = 271;
      goto LABEL_14;
    }
    v19 = malloc(__size[0]);
    if (!v19)
      goto LABEL_28;
    v16 = v19;
    *(_QWORD *)v19 = v29;
    v19[2] = v30;
    if (*((_QWORD *)encrypted_stream + 2))
    {
      v22 = 0;
      if (v12 != 12)
      {
        v23 = (char *)(v19 + 3);
        v24 = v12 - 12;
        while (1)
        {
          v25 = (*((uint64_t (**)(_QWORD, char *, size_t))encrypted_stream + 2))(*(_QWORD *)encrypted_stream, v23, v24);
          if (v25 < 0)
            break;
          if (v25)
          {
            v23 += v25;
            v22 += v25;
            v24 -= v25;
            if (v24)
              continue;
          }
          goto LABEL_31;
        }
        v22 = v25;
      }
    }
    else
    {
      v22 = -1;
    }
LABEL_31:
    if (v22 == v12 - 12)
    {
      v26 = aeaContextCreateWithPrologue(v16, v12);
      if (v26)
      {
        v17 = (AEAContext_impl *)v26;
        free(v16);
        return v17;
      }
      v27 = "Context creation";
      v28 = 280;
    }
    else
    {
      v27 = "reading prologue";
      v28 = 276;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithEncryptedStream", v28, 57, 0, v27, v20, v21, v29);
  }
  else
  {
LABEL_12:
    v13 = "reading magic";
    v14 = 263;
LABEL_13:
    v15 = 0;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithEncryptedStream", v14, 57, v15, v13, v1, v2, v29);
    v16 = 0;
  }
  free(v16);
  AEAContextDestroy(0);
  return 0;
}

uint64_t AEAContextGetFieldUInt(AEAContext context, AEAContextField field)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  char vars0;

  switch(field)
  {
    case 0u:
      result = *(unsigned int *)context;
      break;
    case 1u:
      result = *((_QWORD *)context + 7);
      break;
    case 2u:
      result = *((unsigned int *)context + 3);
      break;
    case 3u:
      result = *((unsigned int *)context + 6);
      break;
    case 4u:
      result = *((unsigned int *)context + 4);
      break;
    case 0xDu:
      result = *((_QWORD *)context + 4);
      break;
    case 0xEu:
      result = *((_QWORD *)context + 5);
      break;
    case 0x11u:
      result = *((unsigned int *)context + 5);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetFieldUInt", 314, 57, 0, "Invalid field", v2, v3, vars0);
      result = -1;
      break;
  }
  return result;
}

int AEAContextGetFieldBlob(AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, size_t buf_capacity, uint8_t *buf, size_t *buf_size)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  size_t v10;
  unsigned int *v11;
  int result;
  char vars0;

  if (field > 0x13)
    goto LABEL_14;
  if (((1 << field) & 0xC1260) != 0)
  {
    if (representation)
    {
      v8 = "Invalid representation";
      v9 = 337;
LABEL_23:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetFieldBlob", v9, 57, 0, v8, v6, v7, vars0);
      return -1;
    }
    goto LABEL_7;
  }
  if (((1 << field) & 0xD80) == 0)
  {
LABEL_14:
    v8 = "Invalid field";
    v9 = 346;
    goto LABEL_23;
  }
  if (representation != 1)
  {
    v8 = "Invalid representation";
    v9 = 343;
    goto LABEL_23;
  }
LABEL_7:
  switch(field)
  {
    case 5u:
      if (buf_size)
        *buf_size = *((unsigned int *)context + 1);
      if (!buf_capacity)
        goto LABEL_28;
      v10 = *((unsigned int *)context + 1);
      if (v10 > buf_capacity)
      {
        v8 = "buf_capacity is too small";
        v9 = 358;
        goto LABEL_23;
      }
      memcpy(buf, *((const void **)context + 339), v10);
LABEL_28:
      result = 0;
      break;
    case 6u:
      v11 = (unsigned int *)((char *)context + 1372);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 7u:
      v11 = (unsigned int *)((char *)context + 332);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 8u:
      v11 = (unsigned int *)((char *)context + 592);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 9u:
      v11 = (unsigned int *)((char *)context + 72);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xAu:
      v11 = (unsigned int *)((char *)context + 852);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xBu:
      v11 = (unsigned int *)((char *)context + 1112);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xCu:
      v11 = (unsigned int *)((char *)context + 1632);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0x12u:
      v11 = (unsigned int *)((char *)context + 1892);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0x13u:
      v11 = (unsigned int *)((char *)context + 2152);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    default:
      v8 = "Invalid field";
      v9 = 375;
      goto LABEL_23;
  }
  return result;
}

uint64_t getFieldBlob(unsigned int *a1, size_t a2, void *__dst, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  char vars0;

  if (a4)
    *a4 = *a1;
  if (a2)
  {
    v8 = *a1;
    if (v8 > a2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"getFieldBlob", 212, 57, 0, "buf_capacity is too small", a7, a8, vars0);
      return 0xFFFFFFFFLL;
    }
    memcpy(__dst, a1 + 1, v8);
  }
  return 0;
}

int AEAContextSetFieldUInt(AEAContext context, AEAContextField field, uint64_t value)
{
  uint64_t v3;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  int result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char v12;

  if (field == 1 || !*((_DWORD *)context + 684))
  {
    switch(field)
    {
      case 1u:
        if (value - 16 >= 0xFFFFFFFFFFFFFFF2)
        {
          v6 = "Invalid padding size";
          v7 = 415;
          goto LABEL_4;
        }
        result = 0;
        *((_QWORD *)context + 7) = value;
        return result;
      case 2u:
        if (value > 2)
        {
          v6 = "Invalid checksum mode";
          v7 = 429;
          goto LABEL_4;
        }
        *((_DWORD *)context + 3) = value;
        v10 = aeaChecksumSize(value);
        result = 0;
        *((_DWORD *)context + 12) = v10;
        return result;
      case 3u:
        if ((uint64_t)value <= 1284)
        {
          if (value && value != 256 && value != 774)
            goto LABEL_36;
        }
        else if ((uint64_t)value > 2048)
        {
          if (value != 2304 && value != 2049)
            goto LABEL_36;
        }
        else if (value != 1285 && value != 1794)
        {
LABEL_36:
          v6 = "Invalid compression algorithm";
          v7 = 398;
          goto LABEL_4;
        }
        result = 0;
        *((_DWORD *)context + 6) = value;
        return result;
      case 4u:
        result = 0;
        v11 = 0x4000;
        if (value > 0x4000)
          v11 = value;
        if (v11 >= 0x10000000)
          LODWORD(v11) = 0x10000000;
        *((_DWORD *)context + 4) = v11;
        return result;
      default:
        if (field != 17)
        {
          v6 = "Invalid field";
          v7 = 439;
          goto LABEL_4;
        }
        result = 0;
        v9 = 32;
        if (value > 0x20)
          v9 = value;
        if (v9 >= 0x40000)
          LODWORD(v9) = 0x40000;
        *((_DWORD *)context + 5) = v9;
        return result;
    }
  }
  v6 = "Context can't be modified";
  v7 = 384;
LABEL_4:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldUInt", v7, 57, 0, v6, v3, v4, v12);
  return -1;
}

int AEAContextSetFieldBlob(AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, const uint8_t *buf, size_t buf_size)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v11;
  __int16 v12;
  char *v13;
  int v14;
  int result;
  void *v16;
  void *v17;
  char v18;

  if (field > 0x13)
    goto LABEL_14;
  if (((1 << field) & 0x81260) == 0)
  {
    if (((1 << field) & 0xD80) != 0)
    {
      if (representation != 1)
      {
        v11 = "Invalid representation";
        v12 = 464;
        goto LABEL_23;
      }
      goto LABEL_7;
    }
LABEL_14:
    v11 = "Invalid field";
    v12 = 467;
LABEL_23:
    v14 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldBlob", v12, 57, v14, v11, v6, v7, v18);
    return -1;
  }
  if (representation)
  {
    v11 = "Invalid representation";
    v12 = 458;
    goto LABEL_23;
  }
  if (field == 19 && buf_size <= 0x13)
  {
    v11 = "Password is too short";
    v12 = 471;
    goto LABEL_23;
  }
LABEL_7:
  switch(field)
  {
    case 5u:
      if (*((_DWORD *)context + 684))
      {
        v11 = "Context can't be modified";
        v12 = 477;
        goto LABEL_23;
      }
      v16 = (void *)*((_QWORD *)context + 339);
      if (v16)
        memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
      free(v16);
      *((_QWORD *)context + 339) = 0;
      *((_DWORD *)context + 1) = 0;
      if (!buf_size)
        goto LABEL_34;
      if (buf_size >= 0x4000001)
      {
        v18 = buf_size;
        v11 = "Invalid auth data size: %zu";
        v12 = 483;
        goto LABEL_23;
      }
      v17 = malloc(buf_size);
      *((_QWORD *)context + 339) = v17;
      if (!v17)
      {
        v14 = *__error();
        v11 = "malloc";
        v12 = 486;
        goto LABEL_24;
      }
      *((_DWORD *)context + 1) = buf_size;
      memcpy(v17, buf, buf_size);
LABEL_34:
      result = 0;
      break;
    case 6u:
      v13 = (char *)context + 1372;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 7u:
      v13 = (char *)context + 332;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 8u:
      v13 = (char *)context + 592;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 9u:
      v13 = (char *)context + 72;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xAu:
      v13 = (char *)context + 852;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xBu:
      v13 = (char *)context + 1112;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xCu:
      v13 = (char *)context + 1632;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0x13u:
      v13 = (char *)context + 2152;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    default:
      v11 = "Invalid field";
      v12 = 502;
      goto LABEL_23;
  }
  return result;
}

uint64_t setFieldBlob(_DWORD *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v11;
  char v12;

  if (a3 < 0x101)
  {
    v11 = a1 + 1;
    memcpy(a1 + 1, a2, a3);
    *a1 = a3;
    memset_s((char *)v11 + a3, 256 - a3, 0, 256 - a3);
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"setFieldBlob", 223, 57, 0, "Invalid field size", a7, a8, v12);
    return 0xFFFFFFFFLL;
  }
}

int AEAContextGenerateFieldBlob(AEAContext context, AEAContextField field)
{
  uint64_t v2;
  uint64_t v3;
  char *v5;
  int result;
  unint64_t v7;
  const char *v8;
  __int16 v9;
  char v10;
  unint64_t v11;

  v11 = 0;
  if (field == 19)
  {
    v5 = (char *)context + 2156;
    result = AEAKeychainGenerateItem(0, 0x63uLL, 0x100uLL, (char *)context + 2156, &v11, 0, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 538) = v11;
        goto LABEL_9;
      }
      goto LABEL_15;
    }
    v8 = "generate random field";
    v9 = 527;
  }
  else if (field == 9)
  {
    v5 = (char *)context + 76;
    result = AEAKeychainGenerateItem(1, 0x100uLL, 0x100uLL, (char *)context + 76, &v11, 0, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 18) = v11;
LABEL_9:
        memset_s(&v5[v7], 256 - v7, 0, 256 - v7);
        return 0;
      }
LABEL_15:
      __break(1u);
      return result;
    }
    v8 = "generate random field";
    v9 = 520;
  }
  else
  {
    v8 = "Invalid field";
    v9 = 532;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGenerateFieldBlob", v9, 57, 0, v8, v2, v3, v10);
  return -1;
}

uint64_t AEAContextSetFieldCallback(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char vars0;

  if (a2 == 16)
  {
    result = 0;
    a1[305] = a3;
    a1[304] = a4;
  }
  else if (a2 == 15)
  {
    result = 0;
    a1[303] = a3;
    a1[302] = a4;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldCallback", 555, 57, 0, "Invalid field", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t AEAContextGetContainerSizeUpperBound(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  unint64_t result;
  _OWORD v16[4];
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _OWORD __s[13];

  memset(__s, 0, sizeof(__s));
  v19 = 0;
  v17 = 0u;
  v18 = 0u;
  memset(v16, 0, sizeof(v16));
  if ((aeaCryptoInit((char *)__s, (unsigned int *)a1) & 0x80000000) != 0)
  {
    v13 = "Invalid context";
    v14 = 569;
    goto LABEL_13;
  }
  if ((aeaContainerOffsetsInit((uint64_t)v16, (unsigned int *)a1, (unsigned int *)__s) & 0x80000000) != 0)
  {
    v13 = "deriving container offsets";
    v14 = 572;
    goto LABEL_13;
  }
  v10 = v19
      * (((a2 + (unint64_t)*(unsigned int *)(a1 + 16) - 1) / *(unsigned int *)(a1 + 16)
        + *(unsigned int *)(a1 + 20)
        - 1)
       / *(unsigned int *)(a1 + 20));
  v11 = __CFADD__((_QWORD)v17, v10);
  v12 = v17 + v10;
  if (v11)
  {
    v13 = "invalid sizes";
    v14 = 580;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetContainerSizeUpperBound", v14, 57, 0, v13, v4, v5, v16[0]);
    return -1;
  }
  if (__CFADD__(v12, a2))
  {
    v13 = "invalid sizes";
    v14 = 581;
    goto LABEL_13;
  }
  result = aeaPaddedContainerSize(v12 + a2, *(_QWORD *)(a1 + 56), v6, v7, v8, v9, v4, v5);
  if (result == -1)
  {
    v13 = "Container size is too large to allow padding";
    v14 = 585;
    goto LABEL_13;
  }
  return result;
}

uint64_t LargeFileWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v10;
  unsigned __int8 *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  size_t v17;
  size_t v18;
  _QWORD *v19;
  size_t v20;
  int v21;
  char *v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  size_t v31;
  uint64_t v32;
  int v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  unsigned int v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  char *v54;
  size_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  unsigned int *v70;
  char v72;
  uint64_t v73;
  unint64_t *v74;
  int v75;
  unint64_t v76;
  uint64_t v77;
  size_t v78;
  char *__base;
  void *v80;
  _DWORD __b[4096];
  uint64_t v82;

  v8 = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v82 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(v8 + 8) = 0;
  if (atomic_load((unsigned int *)(*(_QWORD *)v8 + 104)))
    return 0;
  v10 = (_QWORD *)v8;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = *(_QWORD *)v8;
  v15 = *(unsigned int *)(v8 + 32);
  v16 = (unint64_t *)(v8 + 16);
  v80 = 0;
  if ((unint64_t)(*(_QWORD *)(v14 + 56) - (v15 << 21)) >= 0x200000)
    v17 = 0x200000;
  else
    v17 = *(_QWORD *)(v14 + 56) - (v15 << 21);
  v18 = v17 - 17;
  if (v17 >= 0x11)
  {
    v12 = malloc(0x1000000uLL);
    v11 = (unsigned __int8 *)malloc(v17);
    v22 = (char *)malloc(0x40000uLL);
    v13 = v22;
    if (!v12 || (v11 ? (v23 = v22 == 0) : (v23 = 1), v23))
    {
      v33 = *__error();
      v34 = "aaMalloc";
      v35 = 496;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", v35, 112, v33, v34, v24, v25, v72);
      v21 = 0;
      goto LABEL_73;
    }
    v74 = v16;
    memset(__b, 255, sizeof(__b));
    v26 = *(_QWORD **)(v14 + 24);
    if (!v26[4])
      goto LABEL_70;
    __base = v13;
    v27 = 0;
    v28 = v17;
    v29 = v15 << 21;
    v30 = v11;
    v75 = v15;
    v76 = v28;
    v31 = v28;
    while (1)
    {
      v32 = ((uint64_t (*)(_QWORD, unsigned __int8 *, size_t, uint64_t))v26[4])(*v26, v30, v31, v29);
      if (v32 < 0)
        break;
      if (v32)
      {
        v30 += v32;
        v27 += v32;
        v29 += v32;
        v31 -= v32;
        if (v31)
          continue;
      }
      goto LABEL_25;
    }
    v27 = v32;
LABEL_25:
    LODWORD(v15) = v75;
    v17 = v76;
    v23 = v76 == v27;
    v13 = __base;
    if (v23)
    {
      v36 = 0;
      v37 = 0;
      do
        v37 = -1640531535 * (v37 + v11[v36++]);
      while (v36 != 16);
      v77 = (uint64_t)v12;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v42 = *(_DWORD *)(v14 + 76);
      v43 = 16;
      do
      {
        if (v40 >= v38 || (*(_DWORD *)(v14 + 68) & ~v37) == 0)
        {
          v38 = v40 + (2 * *(_DWORD *)(v14 + 72));
          if (v40 >= v39)
          {
            v44 = *(unsigned int *)(*(_QWORD *)(v14 + 40) + 4 * (v37 >> -*(_BYTE *)(v14 + 64)));
            if ((_DWORD)v44 != -1)
            {
              v45 = __ROR8__(__ROR8__(2654435761 * *(_QWORD *)&v11[v40], 41) + 2654435761 * *(_QWORD *)&v11[v40 + 8], 41);
              v46 = HIDWORD(v45) ^ v45;
              v47 = *(_QWORD *)(v14 + 32);
              while (1)
              {
                v48 = v47 + 16 * v44;
                if (*(_DWORD *)(v48 + 8) == v46)
                  break;
                v44 = *(unsigned int *)(v48 + 12);
                if ((_DWORD)v44 == -1)
                  goto LABEL_46;
              }
              v49 = *(_QWORD *)(v47 + 16 * v44);
              v50 = v49 >> 20;
              v51 = v49 & 0xFFFFFFFFFFF00000;
              v52 = __b[v50];
              if (v52 == -1)
              {
LABEL_42:
                if (v41 != 0x4000)
                {
                  v54 = &__base[16 * v41];
                  *(_QWORD *)v54 = v51;
                  *((_DWORD *)v54 + 2) = v52;
                  *((_DWORD *)v54 + 3) = 1;
                  __b[v50] = v41++;
                }
              }
              else
              {
                v53 = __b[v50];
                while (*(_QWORD *)&__base[16 * v53] != v51)
                {
                  v53 = *(unsigned int *)&__base[16 * v53 + 8];
                  if ((_DWORD)v53 == -1)
                    goto LABEL_42;
                }
                ++*(_DWORD *)&__base[16 * v53 + 12];
              }
              v39 = v43;
            }
          }
        }
LABEL_46:
        v37 = -1640531535 * (v37 + v11[v43]) - v42 * v11[v40];
        v43 = v40 + 17;
        v23 = v40++ == v18;
      }
      while (!v23);
      if (!v41)
      {
        v16 = v74;
        goto LABEL_6;
      }
      v73 = (uint64_t)v11;
      qsort(__base, v41, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_rating);
      if (v41 >= 0x10)
        v55 = 16;
      else
        v55 = v41;
      v78 = v55;
      qsort(__base, v55, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_position);
      v58 = 0;
      LODWORD(v17) = 0;
      do
      {
        v59 = *(_QWORD *)&v13[16 * v58];
        if ((unint64_t)(*(_QWORD *)(v14 + 48) - v59) >= 0x100000)
          v60 = 0x100000;
        else
          v60 = *(_QWORD *)(v14 + 48) - v59;
        v61 = *(_QWORD **)(v14 + 16);
        if (!v61[4])
          goto LABEL_85;
        if (v60)
        {
          v62 = 0;
          v63 = v77 + v17;
          v64 = v60;
          while (1)
          {
            v65 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v61[4])(*v61, v63, v64, v59);
            if (v65 < 0)
              break;
            if (v65)
            {
              v63 += v65;
              v62 += v65;
              v59 += v65;
              v64 -= v65;
              if (v64)
                continue;
            }
            goto LABEL_64;
          }
          v62 = v65;
LABEL_64:
          v23 = v60 == v62;
          v13 = __base;
          if (!v23)
          {
LABEL_85:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", 546, 112, 0, "aaByteStreamPReadExpected", v56, v57, v72);
            v21 = 0;
            v12 = (void *)v77;
            v11 = (unsigned __int8 *)v73;
            goto LABEL_73;
          }
        }
        v17 = (v17 + v60);
        ++v58;
      }
      while (v58 != v78);
      v12 = (void *)v77;
      v11 = (unsigned __int8 *)v73;
      v16 = v74;
      if ((getBXDiffControls(v77, v17, v73, v76, (int8x16_t **)&v80, (uint64_t)v74, (int *)v14, v57) & 0x80000000) != 0)
      {
        v34 = "generic controls";
        v35 = 550;
      }
      else
      {
        v80 = convert_block_controls(v74, v80, *v74, (uint64_t)v13, v66, v67, v24, v25);
        if (v80)
        {
          LODWORD(v15) = v75;
          goto LABEL_8;
        }
        v34 = "convert_block_controls";
        v35 = 552;
      }
    }
    else
    {
LABEL_70:
      v34 = "aaByteStreamPReadExpected";
      v35 = 501;
    }
    v33 = 0;
    goto LABEL_72;
  }
LABEL_6:
  v19 = malloc(0x18uLL);
  v80 = v19;
  if (!v19)
  {
    v33 = *__error();
    v34 = "aaMalloc";
    v35 = 534;
    goto LABEL_72;
  }
  v20 = v17;
  LODWORD(v17) = 0;
  *v19 = 0;
  v19[1] = v20;
  v19[2] = 0;
  *v16 = 1;
LABEL_8:
  if (*(int *)(v14 + 4) >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], " LargeFile: Block = %5u, %5u K cache, %6zu controls\n", v15, v17 >> 10, *v16);
  v21 = 1;
LABEL_73:
  free(v12);
  free(v11);
  free(v13);
  if ((v21 & 1) == 0)
    free(v80);
  v68 = v80;
  if (!v21)
    v68 = 0;
  v10[1] = v68;
  if (v68)
    return 0;
  v70 = (unsigned int *)(*v10 + 104);
  while (!__ldaxr(v70))
  {
    if (!__stlxr(1u, v70))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t LargeFileConsumer(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int *v15;

  if (atomic_load((unsigned int *)(*a2 + 104)))
    return 0;
  result = a2[1];
  if (result)
  {
    if (a2[2])
    {
      v12 = 0;
      v13 = 0;
      v14 = *(char **)a1;
      do
      {
        v14 = add_control(v14, (unint64_t *)(a1 + 8), (unint64_t *)(a1 + 16), *(_QWORD *)(a2[1] + v12), *(_QWORD *)(a2[1] + v12 + 8), *(_QWORD *)(a2[1] + v12 + 16), a7, a8);
        *(_QWORD *)a1 = v14;
        if (!v14)
          break;
        ++v13;
        v12 += 24;
      }
      while (v13 < a2[2]);
      result = a2[1];
    }
    free((void *)result);
    if (*(_QWORD *)a1)
      return 0;
    v15 = (unsigned int *)(*a2 + 104);
    while (!__ldaxr(v15))
    {
      if (!__stlxr(1u, v15))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t GetLargeFileControlsWithStreams(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7)
{
  double RealTime;
  unsigned int DefaultNThreads;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  uint64_t v40;
  char *v41;
  _QWORD *Worker;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  const char *v50;
  __int16 v51;
  int v52;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  FILE *v65;
  unint64_t v66;
  void **v67;
  uint64_t v68;
  unint64_t v69;
  double v70;
  uint64_t i;
  _QWORD *v72;
  unsigned int *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  FILE *v89;
  uint64_t v90;
  double v91;
  uint64_t v92;
  const char *v93;
  __int16 v94;
  char v95;
  uint64_t v96;
  uint64_t *v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  _DWORD v101[2];
  uint64_t v102;
  uint64_t v103;
  __int128 v104;
  void *v105[2];
  __int128 v106;
  __int128 v107;
  void *v108[2];
  unsigned int v109[4];

  RealTime = getRealTime();
  DefaultNThreads = *((_DWORD *)a7 + 2);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  *(_QWORD *)v109 = 0;
  v107 = 0u;
  *(_OWORD *)v108 = 0u;
  *(_OWORD *)v105 = 0u;
  v106 = 0u;
  v102 = 0;
  v98 = 0;
  v99 = 0;
  v103 = a1;
  v104 = a3;
  v16 = *a7;
  v17 = 16;
  v100 = 0;
  v101[1] = HIDWORD(v16);
  v101[0] = 21;
  v18 = __clz((a2 + 15) >> 4);
  LODWORD(v102) = 1;
  v105[1] = (void *)a2;
  *(_QWORD *)&v106 = a4;
  if (1 << ~(_BYTE)v18 >= (a2 + 15) >> 4)
    v19 = 63 - v18;
  else
    v19 = 64 - v18;
  LODWORD(v107) = 16;
  if (v19 >= 0x1E)
  {
    do
    {
      --v19;
      v17 *= 2;
    }
    while (v19 > 0x1D);
    LODWORD(v107) = v17;
    v19 = 29;
  }
  DWORD2(v106) = v19;
  HIDWORD(v106) = v17 - 1;
  DWORD1(v107) = 840293553;
  if (DefaultNThreads < 0xCCCCCCCD)
  {
    v20 = calloc(DefaultNThreads, 0x28uLL);
  }
  else
  {
    v20 = 0;
    *__error() = 12;
  }
  v108[0] = v20;
  v21 = calloc(DefaultNThreads, 8uLL);
  v108[1] = v21;
  if (!v20 || !v21)
  {
    v49 = *__error();
    v50 = "aaCalloc";
    v51 = 672;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v51, 112, v49, v50, v22, v23, v95);
    goto LABEL_36;
  }
  *((_QWORD *)&v104 + 1) = pc_array_init(16, (5 * (a2 / v107)) >> 2);
  if (!*((_QWORD *)&v104 + 1))
  {
    v50 = "pc_array_init";
    v51 = 678;
LABEL_34:
    v49 = 0;
    goto LABEL_35;
  }
  v24 = malloc(4 << SBYTE8(v106));
  v105[0] = v24;
  if (!v24)
  {
    v49 = *__error();
    v50 = "malloc";
    v51 = 683;
    goto LABEL_35;
  }
  memset(v24, 255, 4 << SBYTE8(v106));
  v25 = calloc(DefaultNThreads, 0x20uLL);
  v26 = calloc(DefaultNThreads, 8uLL);
  v27 = v26;
  if (!v25 || !v26)
  {
    v54 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 433, 112, *v54, "aaCalloc", v55, v56, v95);
    v39 = 0;
LABEL_49:
    v48 = 0;
    goto LABEL_50;
  }
  if (DefaultNThreads)
  {
    v28 = v25;
    v29 = v26;
    v30 = DefaultNThreads;
    v31 = v25;
    do
    {
      *v31 = v101;
      v31 += 4;
      *v29++ = v28;
      v28 = v31;
      --v30;
    }
    while (v30);
  }
  v39 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v26, (uint64_t)fingerprint_worker, (uint64_t)v101, (uint64_t)fingerprint_consumer, 0);
  if (!v39)
  {
    v57 = "ThreadPipelineCreate";
    v58 = 444;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v58, 112, 0, v57, v37, v38, v95);
    goto LABEL_49;
  }
  v97 = a6;
  if (!v105[1])
  {
LABEL_29:
    a6 = v97;
    if ((ThreadPipelineFlush((uint64_t)v39) & 0x80000000) != 0)
    {
      v57 = "ThreadPipelineFlush";
      v58 = 461;
    }
    else
    {
      *((_QWORD *)&v104 + 1) = pc_array_compact(*((uint64_t *)&v104 + 1));
      if (*((_QWORD *)&v104 + 1))
      {
        v48 = 1;
        goto LABEL_50;
      }
      v57 = "pc_array_compact";
      v58 = 465;
    }
    goto LABEL_48;
  }
  v40 = 0;
  v41 = 0;
  while (1)
  {
    Worker = (_QWORD *)ThreadPipelineGetWorker((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
    if (!Worker)
    {
      v59 = "ThreadPipelineGetWorker";
      v60 = 451;
      goto LABEL_45;
    }
    Worker[1] = 0;
    Worker[2] = v41;
    v47 = (uint64_t)v105[1] + v40;
    if ((unint64_t)v105[1] + v40 >= 0x200000)
      v47 = 0x200000;
    Worker[3] = v47;
    if ((ThreadPipelineRunWorker((uint64_t)v39, (uint64_t)Worker, v43, v44, v45, v46, v37, v38) & 0x80000000) != 0)
      break;
    v41 += 0x200000;
    v40 -= 0x200000;
    if (v41 >= v105[1])
      goto LABEL_29;
  }
  v59 = "ThreadPipelineRunWorker";
  v60 = 457;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v60, 112, 0, v59, v37, v38, v95);
  v48 = 0;
  a6 = v97;
LABEL_50:
  if ((ThreadPipelineDestroy((uint64_t)v39) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 468, 112, 0, "ThreadPipelineDestroy", v61, v62, v95);
    v48 = 0;
  }
  free(v25);
  free(v27);
  if (!v48)
    goto LABEL_36;
  if (*((int *)a7 + 1) >= 3)
  {
    v65 = (FILE *)*MEMORY[0x24BDAC8D8];
    v66 = (unint64_t)(4 << SBYTE8(v106)) >> 20;
    v67 = a5;
    v68 = (*(_QWORD *)(*((_QWORD *)&v104 + 1) - 64) >> 16) & 0xFFFFFFFFFFFLL;
    v69 = (unint64_t)v105[1] >> 20;
    v70 = getRealTime();
    v96 = v68;
    a5 = v67;
    fprintf(v65, " LargeFile: Using %zu M for hashing.\n LargeFile: Using %zu M for fingerprints.\n LargeFile: Parsed %zu M in %0.2f (s). Added %zu/%zu fingerprints.\n", v66, v96, v69, v70 - RealTime, *(_QWORD *)(*((_QWORD *)&v104 + 1) - 64), (unint64_t)v105[1] / v107);
  }
  v98 = add_control(0, (unint64_t *)&v99, &v100, 0, 0, 0, v63, v64);
  if (!v98)
    goto LABEL_36;
  if (DefaultNThreads)
  {
    for (i = 0; i != DefaultNThreads; *((_QWORD *)v108[1] + i++) = v72)
    {
      v72 = (char *)v108[0] + 40 * i;
      *v72 = v101;
    }
  }
  v73 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v108[1], (uint64_t)LargeFileWorker, (uint64_t)&v98, (uint64_t)LargeFileConsumer, 0);
  *((_QWORD *)&v107 + 1) = v73;
  if (!v73)
  {
    v50 = "creating pipeline";
    v51 = 711;
    goto LABEL_34;
  }
  if (!a4)
  {
LABEL_67:
    if ((ThreadPipelineDestroy((uint64_t)v73) & 0x80000000) == 0)
    {
      *((_QWORD *)&v107 + 1) = 0;
      v99 = sanitize_internal_controls(v98, v99);
      convert_internal_controls((uint64_t)&v98);
      if (*((int *)a7 + 1) >= 2)
      {
        v89 = (FILE *)*MEMORY[0x24BDAC8D8];
        v90 = v99;
        v91 = getRealTime();
        fprintf(v89, "LargeFile: Constructed %zu controls in %0.2f (s).\n", v90, v91 - RealTime);
      }
      v52 = 0;
      v92 = v99;
      *a5 = v98;
      *a6 = v92;
      goto LABEL_37;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", 725, 112, 0, "ThreadPipelineDestroy failed", v87, v88, v95);
    *((_QWORD *)&v107 + 1) = 0;
LABEL_36:
    v52 = 1;
    goto LABEL_37;
  }
  v79 = 1;
  while (1)
  {
    v80 = ThreadPipelineGetWorker(*((uint64_t *)&v107 + 1), v74, v75, v76, v77, v78, v22, v23);
    if (!v80)
      break;
    *(_DWORD *)(v80 + 32) = v79 - 1;
    if ((ThreadPipelineRunWorker(*((uint64_t *)&v107 + 1), v80, v81, v82, v83, v84, v22, v23) & 0x80000000) != 0
      || (v85 = atomic_load(v109)) != 0)
    {
      v93 = "RunWorker";
      v94 = 723;
      goto LABEL_75;
    }
    v86 = v79++;
    if (a4 <= v86 << 21)
    {
      v73 = (unsigned int *)*((_QWORD *)&v107 + 1);
      goto LABEL_67;
    }
  }
  v93 = "getting worker from pipeline";
  v94 = 718;
LABEL_75:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v94, 112, 0, v93, v22, v23, v95);
  v52 = 1;
LABEL_37:
  ThreadPipelineDestroy(*((uint64_t *)&v107 + 1));
  free(v108[0]);
  free(v108[1]);
  free(v105[0]);
  pc_array_free(*((uint64_t *)&v104 + 1));
  if (v52)
  {
    free(v98);
    *a5 = 0;
    *a6 = 0;
  }
  return (v52 << 31 >> 31);
}

char *add_control(char *__ptr, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v12 = __ptr;
  v13 = *a2;
  if (*a2 < *a3)
    goto LABEL_2;
  v15 = v13 + (v13 >> 1) + 1;
  *a3 = v15;
  if (*a2 >= v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 213, 112, 0, "too many controls", a7, a8, v21);
    free(v12);
    return 0;
  }
  if (24 * v15 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_10:
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 215, 112, *v17, "aaReallocf", v18, v19, v21);
    return 0;
  }
  v16 = (char *)realloc(__ptr, 24 * v15);
  if (!v16)
  {
    free(v12);
    goto LABEL_10;
  }
  v13 = *a2;
  v12 = v16;
LABEL_2:
  *a2 = v13 + 1;
  v14 = &v12[24 * v13];
  *(_QWORD *)v14 = a4;
  *((_QWORD *)v14 + 1) = a5;
  *((_QWORD *)v14 + 2) = a6;
  return v12;
}

uint64_t sanitize_internal_controls(_QWORD *a1, uint64_t a2)
{
  char *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  v2 = (char *)a1;
  if (a2 >= 2)
  {
    v3 = (unint64_t)&a1[3 * a2];
    v4 = a1 + 3;
    v5 = a1;
    v6 = (char *)a1;
    do
    {
      v7 = v5;
      while (1)
      {
        v5 = v4;
        v8 = *v4;
        if (!v8)
        {
          v9 = *((_QWORD *)v6 + 1) + v7[4];
          goto LABEL_9;
        }
        if (*((_QWORD *)v6 + 1) || *(_QWORD *)v6 + *((_QWORD *)v6 + 2) != v7[5])
          break;
        *(_QWORD *)v6 += v8;
        v9 = v7[4];
LABEL_9:
        *((_QWORD *)v6 + 1) = v9;
        v4 = v5 + 3;
        v7 = v5;
        if ((unint64_t)(v5 + 3) >= v3)
        {
          v2 = v6;
          return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
        }
      }
      v2 = v6 + 24;
      v10 = *(_OWORD *)v5;
      *((_QWORD *)v6 + 5) = v5[2];
      *(_OWORD *)(v6 + 24) = v10;
      v4 = v5 + 3;
      v6 += 24;
    }
    while ((unint64_t)(v5 + 3) < v3);
  }
  return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
}

uint64_t convert_internal_controls(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t *v3;
  int64x2_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int64x2_t v8;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = 0;
    v3 = *(uint64_t **)result;
    v4 = vdupq_n_s64(0x8000000000000000);
    do
    {
      v5 = *v3;
      v6 = v3[2] + *v3;
      ++v2;
      v7 = v6;
      if (v2 < v1)
        v7 = v3[5];
      if (v5 < 0)
        v5 = 0x8000000000000000 - v5;
      *v3 = v5;
      v8.i64[0] = v3[1];
      v8.i64[1] = v7 - v6;
      *(int8x16_t *)(v3 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(v8), (int8x16_t)vsubq_s64(v4, v8), (int8x16_t)v8);
      v3 += 3;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t GetLargeFileControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  AAByteStream_impl *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  AAByteStream_impl *v21;
  uint64_t v22;
  uint64_t v23;
  AAByteStream_impl *v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  char v29;

  v14 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  v21 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a3, a4, v15, v16, v17, v18, v19, v20);
  v24 = v21;
  if (!v14 || !v21)
  {
    v26 = "AAMemoryInputStreamOpen";
    v27 = 758;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControls", v27, 112, 0, v26, v22, v23, v29);
    v25 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if ((GetLargeFileControlsWithStreams((uint64_t)v14, a2, (unint64_t)v21, a4, a5, a6, a7) & 0x80000000) != 0)
  {
    v26 = "GetLargeFileControlsWithStreams";
    v27 = 761;
    goto LABEL_7;
  }
  v25 = 0;
LABEL_8:
  AAByteStreamClose(v14);
  AAByteStreamClose(v24);
  return v25;
}

uint64_t chunk_compare_by_rating(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12));
}

uint64_t chunk_compare_by_position(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

char *convert_block_controls(unint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  __int16 v23;
  unint64_t v26;

  v26 = 0;
  *a1 = 0;
  if (a3)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    do
    {
      v14 = a2[3 * v11];
      if (v14 >= 0)
        v15 = a2[3 * v11];
      else
        v15 = 0x8000000000000000 - v14;
      while (1)
      {
        v16 = v12 & 0xFFFFF;
        v17 = 0x100000 - (v12 & 0xFFFFF);
        if (v17 >= v15)
          break;
        v18 = add_control(v13, a1, &v26, 0x100000 - (v12 & 0xFFFFF), 0, *(_QWORD *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
        if (!v18)
        {
          v23 = 251;
LABEL_18:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"convert_block_controls", v23, 112, 0, "add_control", a7, a8, a3);
          goto LABEL_19;
        }
        v13 = v18;
        v15 -= v17;
        v12 += v17;
      }
      v19 = a2[3 * v11 + 1];
      if (v19 >= 0)
        v20 = a2[3 * v11 + 1];
      else
        v20 = 0x8000000000000000 - v19;
      v21 = add_control(v13, a1, &v26, v15, v20, *(_QWORD *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
      if (!v21)
      {
        v23 = 255;
        goto LABEL_18;
      }
      v13 = v21;
      v22 = a2[3 * v11 + 2];
      if (v22 < 0)
        v22 = 0x8000000000000000 - v22;
      v12 += v15 + v22;
      ++v11;
    }
    while (v11 != a3);
  }
  else
  {
LABEL_19:
    v13 = 0;
  }
  free(a2);
  return v13;
}

uint64_t fingerprint_worker(uint64_t *a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v40;
  int v41;
  unsigned int v42;

  v2 = a1[3];
  if (v2 < 0x11)
    return 0;
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", 325, 112, 0, "aaMalloc", v4, v5, v40);
    v8 = 0;
    v15 = 0;
    goto LABEL_32;
  }
  v6 = *a1;
  v7 = (unsigned __int8 *)malloc(v2);
  if (!v7)
    goto LABEL_14;
  v8 = v7;
  v15 = pc_array_init(16);
  if (!v15)
  {
    v23 = "pc_array_init";
    v24 = 329;
    goto LABEL_31;
  }
  v16 = a1[3];
  v17 = *(_QWORD **)(v6 + 16);
  if (!v17[4])
  {
    v18 = -1;
LABEL_18:
    if (v16 != v18)
    {
      v23 = "aaByteStreamPReadExpected";
      v24 = 333;
      goto LABEL_31;
    }
    goto LABEL_19;
  }
  if (v16)
  {
    v18 = 0;
    v19 = a1[2];
    v20 = v8;
    v21 = a1[3];
    while (1)
    {
      v22 = ((uint64_t (*)(_QWORD, unsigned __int8 *, uint64_t, uint64_t))v17[4])(*v17, v20, v21, v19);
      if (v22 < 0)
        break;
      if (v22)
      {
        v20 += v22;
        v18 += v22;
        v19 += v22;
        v21 -= v22;
        if (v21)
          continue;
      }
      goto LABEL_18;
    }
    v18 = v22;
    goto LABEL_18;
  }
LABEL_19:
  v25 = 0;
  v26 = 0;
  do
    v26 = -1640531535 * (v26 + v8[v25++]);
  while (v25 != 16);
  v27 = a1[3];
  if (v27 < 0x11)
  {
LABEL_29:
    v3 = 0;
    a1[1] = (uint64_t)v15;
    v15 = 0;
    goto LABEL_33;
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = *(_DWORD *)(v6 + 72) << 8;
  while (1)
  {
    if (v31 < v30 || v31 < v29 && (*(_DWORD *)(v6 + 68) & ~v26) != 0)
      goto LABEL_28;
    v33 = *(unsigned int *)(v6 + 72);
    v40 = v31 + a1[2];
    v34 = __ROR8__(__ROR8__(2654435761 * *(_QWORD *)&v8[v31], 41) + 2654435761 * *(_QWORD *)&v8[v31 + 8], 41);
    v35 = v26 >> -*(_BYTE *)(v6 + 64);
    v41 = HIDWORD(v34) ^ v34;
    v42 = v35;
    v15 = pc_array_append((uint64_t)v15, &v40, v9, v10, v11, v12, v13, v14);
    if (!v15)
      break;
    v29 = v31 + (2 * v33);
    v36 = v28 + (v32 >> 8);
    v37 = v32 + v31;
    v32 = v31 + v32 - v36;
    v30 = v31 + v33 - ((unint64_t)(v37 - v36) >> 8);
    v27 = a1[3];
    v28 = v31;
LABEL_28:
    v26 = -1640531535 * (v26 + v8[v31 + 16]) - *(_DWORD *)(v6 + 76) * v8[v31];
    v38 = v31 + 17;
    ++v31;
    if (v38 >= v27)
      goto LABEL_29;
  }
  v23 = "pc_array_append";
  v24 = 361;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", v24, 112, 0, v23, v13, v14, v40);
LABEL_32:
  v3 = 0xFFFFFFFFLL;
LABEL_33:
  free(v8);
  pc_array_free((uint64_t)v15);
  return v3;
}

uint64_t fingerprint_consumer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  char v22;

  v8 = *(_QWORD *)(a2 + 8);
  if (!v8)
    return 0;
  v9 = *(_QWORD *)(v8 - 64);
  if (!v9)
  {
LABEL_13:
    v12 = 0;
    goto LABEL_16;
  }
  v11 = 0;
  v12 = 1;
  while (1)
  {
    v13 = (_DWORD *)(v8 + 16 * v11);
    v14 = *(_QWORD *)(a1 + 40);
    v15 = v13[3];
    v16 = *(_DWORD *)(v14 + 4 * v15);
    if (v16 != -1)
    {
      v17 = *(unsigned int *)(v14 + 4 * v15);
      while (1)
      {
        v18 = *(_QWORD *)(a1 + 32) + 16 * v17;
        if (v13[2] == *(_DWORD *)(v18 + 8))
          break;
        v17 = *(unsigned int *)(v18 + 12);
        if ((_DWORD)v17 == -1)
          goto LABEL_8;
      }
      if (*(_QWORD *)v18 < *(_QWORD *)v13)
        *(_QWORD *)v18 = *(_QWORD *)v13;
      goto LABEL_9;
    }
LABEL_8:
    v13[3] = v16;
    v19 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)(v14 + 4 * v15) = *(_QWORD *)(v19 - 64);
    v20 = pc_array_append(v19, v13, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 32) = v20;
    if (!v20)
      break;
LABEL_9:
    v12 = ++v11 < v9;
    if (v11 == v9)
      goto LABEL_13;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_consumer", 413, 112, 0, "pc_array_append", a7, a8, v22);
LABEL_16:
  pc_array_free(v8);
  return (v12 << 31 >> 31);
}

size_t pc_log_error(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  _WORD *v13;
  char *v14;
  size_t v15;
  char __str[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  v13 = (_WORD *)(((a3 & 0x3FFF) << 10) | (a4 << 24) | a5 & 0x3FF | 0x80000000);
  if (a5 >= 1)
  {
    v14 = strerror(a5);
    snprintf(__str, 0x400uLL, "%s: ", v14);
  }
  v15 = strlen(__str);
  vsnprintf(&__str[v15], 1024 - v15, a6, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    pc_log_error_cold_1((uint64_t)__str, (int)v13);
  return ParallelCompressionUpdateError(v13, (size_t)__str);
}

uint64_t pc_log_warning(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12;
  size_t v13;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  char *v18;
  char __s[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x400uLL);
  v12 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
  v13 = strlen(__s);
  vsnprintf(&__s[v13], 1024 - v13, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    v16 = v12;
    v17 = 2080;
    v18 = __s;
    _os_log_impl(&dword_20A376000, MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO, "[0x%08x](warning) %s", buf, 0x12u);
  }
  return ParallelCompressionUpdateWarning(v12, __s);
}

void pc_log_info(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v12;
  uint8_t buf[4];
  unsigned int v14;
  __int16 v15;
  char *v16;
  char __s[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x400uLL);
  v12 = strlen(__s);
  vsnprintf(&__s[v12], 1024 - v12, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    v14 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
    v15 = 2080;
    v16 = __s;
    _os_log_impl(&dword_20A376000, MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO, "[0x%08x] %s", buf, 0x12u);
  }
}

_QWORD *AAChunkOutputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int DefaultNThreads;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char v28;

  DefaultNThreads = a4;
  if (!a4)
    DefaultNThreads = getDefaultNThreads();
  v8 = calloc(1uLL, 0x68uLL);
  v9 = malloc(0x108uLL);
  v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x108uLL, 0, 0x108uLL), !v8))
  {
    v19 = *__error();
    v22 = "malloc";
    v23 = 425;
    goto LABEL_15;
  }
  *(_QWORD *)v10 = a1;
  *(_QWORD *)(v10 + 8) = a2;
  *(_QWORD *)(v10 + 16) = a3;
  *(_QWORD *)(v10 + 24) = DefaultNThreads;
  if (!is_mul_ok(DefaultNThreads, 0x98uLL) || (unint64_t)(152 * DefaultNThreads) >= 0x2000000001)
  {
    *__error() = 12;
    *(_QWORD *)(v10 + 32) = 0;
    goto LABEL_14;
  }
  v11 = calloc(DefaultNThreads, 0x98uLL);
  *(_QWORD *)(v10 + 32) = v11;
  if (!v11)
  {
LABEL_14:
    v19 = *__error();
    v22 = "malloc";
    v23 = 433;
    goto LABEL_15;
  }
  if ((pthread_mutex_init((pthread_mutex_t *)(v10 + 176), 0) & 0x80000000) == 0)
  {
    v12 = *(_QWORD *)(v10 + 24);
    *(_DWORD *)(v10 + 40) = 0;
    *(_DWORD *)(v10 + 44) = v12;
    v13 = calloc(v12, 4uLL);
    *(_QWORD *)(v10 + 48) = v13;
    if (v13)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v10 + 56), 0))
      {
        v17 = "SharedArrayInit: pthread_mutex_init failed\n";
        v18 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v10 + 120), 0))
        {
          if (!*(_QWORD *)(v10 + 24))
          {
LABEL_29:
            *v8 = v10;
            v8[1] = streamClose_0;
            v8[7] = streamAbort_0;
            v8[5] = streamPWrite;
            return v8;
          }
          v25 = 0;
          v26 = 0;
          while (1)
          {
            v27 = *(_QWORD *)(v10 + 32);
            *(_DWORD *)(v27 + v25 + 32) = 0;
            if (pthread_mutex_init((pthread_mutex_t *)(v27 + v25 + 40), 0)
              || pthread_cond_init((pthread_cond_t *)(v27 + v25 + 104), 0))
            {
              v22 = "SemInit";
              v23 = 441;
              goto LABEL_22;
            }
            *(_QWORD *)(v27 + v25 + 8) = v10;
            if ((createThread((pthread_t *)(v27 + v25), (uint64_t)writerProc, v27 + v25, 0) & 0x80000000) != 0)
              break;
            ++v26;
            v25 += 152;
            if (v26 >= *(_QWORD *)(v10 + 24))
              goto LABEL_29;
          }
          v22 = "createThread";
          v23 = 443;
          goto LABEL_22;
        }
        v17 = "SharedArrayInit: pthread_cond_init failed\n";
        v18 = 57;
      }
    }
    else
    {
      v17 = "SharedArrayInit: malloc failed\n";
      v18 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v18, 0, v17, v14, v15, v16, v28);
    v22 = "SharedArrayInit";
    v23 = 435;
LABEL_22:
    v19 = 0;
    goto LABEL_15;
  }
  v19 = *__error();
  v22 = "pthread_mutex_init";
  v23 = 434;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"AAChunkOutputStreamOpen", v23, 59, v19, v22, v20, v21, v28);
  free(v8);
  streamClose_0(v10);
  return 0;
}

uint64_t writerProc(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  pthread_cond_t *v5;
  unsigned int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  pthread_mutex_t *v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  __int16 v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v31;
  pthread_cond_t *v33;
  char v34;
  char v35;
  int v36;

  v2 = *(_QWORD *)(a1 + 8);
  v36 = 678152731 * ((unint64_t)(a1 - *(_QWORD *)(v2 + 32)) >> 3);
  v3 = (pthread_mutex_t *)(v2 + 56);
  v33 = (pthread_cond_t *)(v2 + 120);
  v4 = (pthread_mutex_t *)(a1 + 40);
  v5 = (pthread_cond_t *)(a1 + 104);
  v6 = (unsigned int *)(v2 + 168);
  v7 = 1;
  while (1)
  {
LABEL_2:
    if (!pthread_mutex_lock(v3))
    {
      v15 = v3;
      v16 = *(unsigned int *)(v2 + 40);
      v17 = *(_DWORD *)(v2 + 44);
      v18 = v16;
      if (v16 < v17)
      {
        *(_DWORD *)(*(_QWORD *)(v2 + 48) + 4 * v16) = v36;
        v18 = *(_DWORD *)(v2 + 40);
      }
      *(_DWORD *)(v2 + 40) = v18 + 1;
      if (v18 || !pthread_cond_broadcast(v33))
      {
        if (!pthread_mutex_unlock(v15))
        {
          v31 = v16 >= v17;
          v3 = v15;
          if (!v31)
            goto LABEL_14;
          v11 = 125;
          v12 = "SharedArrayPush: stack is full\n";
          goto LABEL_4;
        }
        v19 = 124;
        v20 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      }
      else
      {
        v19 = 122;
        v20 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      }
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v19, 0, v20, v8, v9, v10, (char)v33);
      v3 = v15;
      goto LABEL_13;
    }
    v11 = 117;
    v12 = "SharedArrayPush: pthread_mutex_lock failed\n";
LABEL_4:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v11, 0, v12, v8, v9, v10, (char)v33);
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 210, 59, 0, "SharedArrayPush", v13, v14, v34);
    v7 = 0;
LABEL_14:
    if (pthread_mutex_lock(v4))
      goto LABEL_19;
    while (1)
    {
      v23 = *(_DWORD *)(a1 + 32);
      if (v23 > 0)
        break;
      if (pthread_cond_wait(v5, v4))
        goto LABEL_19;
    }
    *(_DWORD *)(a1 + 32) = v23 - 1;
    if (pthread_mutex_unlock(v4))
    {
LABEL_19:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 212, 59, 0, "SemAcquire", v21, v22, (char)v33);
      v7 = 0;
    }
    v24 = *(_QWORD *)(a1 + 16);
    if (!v24)
      return a1;
    if (!atomic_load((unsigned int *)(v24 + 48)))
    {
      v26 = 186;
      v27 = "Invalid state";
      goto LABEL_29;
    }
    if (*(_QWORD *)(v24 + 32))
    {
      v26 = 187;
      v27 = "Chunk still has holes";
LABEL_29:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkWriteToStream", v26, 59, 0, v27, v21, v22, (char)v33);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 214, 59, 0, "Write to stream", v28, v29, v35);
      goto LABEL_30;
    }
    if (AAByteStreamPWrite(*(AAByteStream *)v2, *(const void **)v24, *(_QWORD *)(v24 + 16), *(_QWORD *)(a1 + 24)) != *(_QWORD *)(v24 + 16))
    {
      v26 = 189;
      v27 = "Chunk write failed";
      goto LABEL_29;
    }
    free(*(void **)v24);
    *(_QWORD *)v24 = 0;
    *(_QWORD *)(v24 + 8) = 0;
    *(_QWORD *)(v24 + 16) = 0;
    free(*(void **)(v24 + 40));
    *(_QWORD *)(v24 + 24) = 0;
    *(_QWORD *)(v24 + 32) = 0;
    *(_QWORD *)(v24 + 40) = 0;
    if (!v7)
    {
LABEL_30:
      while (!__ldaxr(v6))
      {
        if (!__stlxr(1u, v6))
        {
          AAByteStreamCancel(*(AAByteStream *)v2);
          v7 = 0;
          goto LABEL_2;
        }
      }
      v7 = 0;
      __clrex();
    }
  }
}

uint64_t streamClose_0(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 248);
    if (v2)
    {
      v3 = 0;
      v4 = 1;
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)(v1 + 256) + 8 * v3);
        v6 = *(_QWORD *)(v1 + 8);
        v7 = (unsigned int *)(v5 + 48);
        do
        {
          if (__ldaxr(v7))
          {
            __clrex();
            goto LABEL_10;
          }
        }
        while (__stlxr(1u, v7));
        if ((streamEnqueueWriteChunkToStream(v1, v5, v6 * v3) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 336, 59, 0, "enqueue chunk write", v9, v10, v38);
          v4 = 0;
        }
LABEL_10:
        ++v3;
        v2 = *(_QWORD *)(v1 + 248);
      }
      while (v3 < v2);
    }
    else
    {
      v4 = 1;
    }
    v11 = *(_QWORD *)(v1 + 24);
    if (v11)
    {
      v12 = 0;
      v13 = *(uint64_t **)(v1 + 32);
      do
      {
        v14 = *v13;
        v13 += 19;
        if (v14)
          ++v12;
        --v11;
      }
      while (v11);
      if (v12)
      {
        v15 = 0;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 56)))
          {
            v19 = 91;
            v20 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_25:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v19, 0, v20, v16, v17, v18, v38);
            v24 = -1;
          }
          else
          {
            while (1)
            {
              v21 = *(_DWORD *)(v1 + 40);
              if (v21)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 120), (pthread_mutex_t *)(v1 + 56)))
              {
                v19 = 94;
                v20 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_25;
              }
            }
            v31 = v21 - 1;
            *(_DWORD *)(v1 + 40) = v31;
            v24 = *(_DWORD *)(*(_QWORD *)(v1 + 48) + 4 * v31);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 56)))
              goto LABEL_27;
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v32, v33, v34, v38);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 346, 59, 0, "SharedArrayPop", v22, v23, v39);
          v4 = 0;
LABEL_27:
          v25 = *(_QWORD *)(v1 + 32);
          v26 = v25 + 152 * v24;
          *(_QWORD *)(v26 + 16) = 0;
          *(_QWORD *)(v26 + 24) = 0;
          if (pthread_mutex_lock((pthread_mutex_t *)(v26 + 40))
            || (v29 = v25 + 152 * v24, v30 = *(_DWORD *)(v29 + 32), *(_DWORD *)(v29 + 32) = v30 + 1, !v30)
            && pthread_cond_broadcast((pthread_cond_t *)(v25 + 152 * v24 + 104))
            || pthread_mutex_unlock((pthread_mutex_t *)(v26 + 40)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 350, 59, 0, "SemRelease", v27, v28, v38);
            v4 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v26) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 351, 59, 0, "joinThread", v35, v36, v38);
            v4 = 0;
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v26 + 40)))
            pthread_cond_destroy((pthread_cond_t *)(v25 + 152 * v24 + 104));
          if (++v15 == v12)
          {
            v2 = *(_QWORD *)(v1 + 248);
            break;
          }
        }
      }
    }
    if (v2)
    {
      v37 = 0;
      do
        chunkDestroy(*(void ***)(*(_QWORD *)(v1 + 256) + 8 * v37++));
      while (v37 < *(_QWORD *)(v1 + 248));
    }
    free(*(void **)(v1 + 256));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 176));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 120)))
      free(*(void **)(v1 + 48));
    free(*(void **)(v1 + 32));
    free((void *)v1);
    if (v4)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

void streamAbort_0(AAByteStream *a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 21);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }
  __clrex();
}

uint64_t streamPWrite(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  unint64_t v7;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  void *v24;
  void *v25;
  unint64_t v26;
  size_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void **v32;
  void **v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  BOOL v41;
  uint64_t v42;
  unint64_t v43;
  __int16 v45;
  const char *v46;
  char v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  __int16 v52;
  int *v53;
  uint64_t v54;
  uint64_t v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  size_t v65;
  unint64_t v66;
  size_t v67;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  size_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int *v78;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  __int16 v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  const char *v91;
  __int16 v92;
  int v94;
  uint64_t v95;
  uint64_t v96;
  char v97;
  unsigned int *v98;
  unint64_t v100;
  unint64_t v101;
  char *__src;
  unint64_t *v103;
  size_t __n;
  pthread_mutex_t *v105;

  if (atomic_load((unsigned int *)(a1 + 168)))
    return -1;
  if (!a3)
    return 0;
  v7 = a4;
  v9 = a4 + a3;
  if (a4 + a3 <= a4)
  {
    v11 = -1;
    goto LABEL_86;
  }
  v97 = a1 - 88;
  v105 = (pthread_mutex_t *)(a1 + 176);
  v103 = (unint64_t *)(a1 + 240);
  v100 = a4 + a3;
  v101 = *(_QWORD *)(a1 + 8);
  v11 = -1;
  do
  {
    v12 = v7 / v101;
    v13 = v7 / v101 * v101;
    if (v13 <= v7)
      v14 = v7;
    else
      v14 = v7 / v101 * v101;
    if (v9 >= v13 + v101)
      v15 = v13 + v101;
    else
      v15 = v9;
    if (pthread_mutex_lock(v105) < 0)
    {
      v88 = *__error();
      v91 = "pthread_mutex_lock";
      v92 = 262;
      goto LABEL_103;
    }
    __n = v15 - v14;
    v22 = *v103;
    if (*v103 <= v12)
    {
      do
      {
        if (v22)
          v22 *= 2;
        else
          v22 = 16;
      }
      while (v22 <= v12);
      *(_QWORD *)(a1 + 240) = v22;
      if (8 * v22 >= 0x2000000001)
      {
        *__error() = 12;
LABEL_44:
        *(_QWORD *)(a1 + 256) = 0;
        v48 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", 272, 59, *v48, "malloc", v49, v50, v97);
        v47 = 0;
        v43 = v15 - v14;
        *v103 = 0;
        v103[1] = 0;
        goto LABEL_68;
      }
      v23 = a2;
      v24 = *(void **)(a1 + 256);
      v25 = realloc(v24, 8 * v22);
      if (!v25)
      {
        free(v24);
        a2 = v23;
        goto LABEL_44;
      }
      *(_QWORD *)(a1 + 256) = v25;
      a2 = v23;
    }
    __src = a2;
    v26 = *(_QWORD *)(a1 + 248);
    while (1)
    {
      if (v26 > v12)
      {
        v38 = v14 - v13;
        v39 = *(_QWORD *)(*(_QWORD *)(a1 + 256) + 8 * v12);
        v40 = *(_QWORD *)(v39 + 16);
        v42 = v14 - v13 - v40;
        v41 = v14 - v13 > v40;
        a2 = __src;
        v43 = v15 - v14;
        if (v41)
        {
          if ((chunkAppendHole(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 8 * v12), v42, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            v58 = 301;
            v59 = "Hole append";
LABEL_67:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v58, 59, 0, v59, v20, v21, v97);
            v47 = 0;
            goto LABEL_68;
          }
          v40 = *(_QWORD *)(v39 + 16);
        }
        if (v40 == v38)
        {
          if (v15 != v14)
          {
            if (atomic_load((unsigned int *)(v39 + 48)))
            {
              v45 = 104;
              v46 = "Chunk has already been written";
LABEL_55:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendData", v45, 59, 0, v46, v20, v21, v97);
              v58 = 308;
              v59 = "Data append";
              goto LABEL_67;
            }
            v60 = *(_QWORD *)(v39 + 16);
            if (v60 + __n > *(_QWORD *)(v39 + 8))
            {
              v45 = 105;
              v46 = "Invalid data size";
              goto LABEL_55;
            }
            memcpy((void *)(*(_QWORD *)v39 + v60), __src, __n);
            *(_QWORD *)(v39 + 16) += __n;
          }
LABEL_42:
          v47 = 1;
          goto LABEL_68;
        }
        if (v15 == v14)
          goto LABEL_42;
        if (atomic_load((unsigned int *)(v39 + 48)))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkWriteData", 152, 59, 0, "Chunk has already been written", v20, v21, v97);
        }
        else
        {
          v61 = *(_QWORD *)(v39 + 32);
          if (v61)
          {
            v62 = 0;
            v63 = 0;
            v64 = *(_QWORD *)(v39 + 40);
            v65 = __n + v38;
            while (1)
            {
              v66 = *(_QWORD *)(v64 + v62 + 8);
              if (v66 <= v38)
              {
                v67 = *(_QWORD *)(v64 + v62) + v66;
                if (v65 <= v67 && (v66 == v38 || v65 == v67))
                  break;
              }
              ++v63;
              v62 += 16;
              if (v61 == v63)
                goto LABEL_65;
            }
            if (v63 < v61)
            {
              memcpy((void *)(*(_QWORD *)v39 + v38), __src, __n);
              v71 = *(_QWORD *)(v39 + 40);
              if (*(_QWORD *)(v71 + v62 + 8) == v38)
                *(_QWORD *)(v71 + v62 + 8) = v65;
              v72 = *(_QWORD *)(v71 + v62) - __n;
              *(_QWORD *)(v71 + v62) = v72;
              if (v72)
              {
                v47 = 1;
                a2 = __src;
                goto LABEL_68;
              }
              v73 = *(_QWORD *)(v39 + 32) - 1;
              *(_QWORD *)(v39 + 32) = v73;
              a2 = __src;
              if (v63 < v73)
              {
                do
                {
                  ++v63;
                  *(_OWORD *)(*(_QWORD *)(v39 + 40) + v62) = *(_OWORD *)(*(_QWORD *)(v39 + 40) + v62 + 16);
                  v62 += 16;
                  v47 = 1;
                }
                while (v63 < *(_QWORD *)(v39 + 32));
                goto LABEL_68;
              }
              goto LABEL_42;
            }
          }
LABEL_65:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkWriteData", 163, 59, 0, "Invalid data write, no matching hole", v20, v21, v97);
          a2 = __src;
        }
        v58 = 313;
        v59 = "Hole fill";
        goto LABEL_67;
      }
      v27 = *(_QWORD *)(a1 + 8);
      if (v26)
      {
        v28 = *(_QWORD *)(*(_QWORD *)(a1 + 256) + 8 * v26 - 8);
        v29 = *(_QWORD *)(v28 + 16);
        if (v27 > v29)
        {
          if ((chunkAppendHole(v28, v27 - v29, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            v56 = 284;
            v57 = "Hole creation";
            goto LABEL_51;
          }
          v27 = *(_QWORD *)(a1 + 8);
        }
      }
      v32 = (void **)malloc(0x38uLL);
      v33 = v32;
      if (!v32)
      {
        v52 = 89;
        goto LABEL_50;
      }
      memset_s(v32, 0x38uLL, 0, 0x38uLL);
      if (v27 >= 0x2000000001)
        break;
      v34 = malloc(v27);
      if (!v34)
        goto LABEL_49;
      v35 = v34;
      memset_s(v34, v27, 0, v27);
      *v33 = v35;
      v33[1] = (void *)v27;
      v33[2] = 0;
      v37 = *(_QWORD *)(a1 + 248);
      v36 = *(_QWORD *)(a1 + 256);
      v26 = v37 + 1;
      *(_QWORD *)(a1 + 248) = v37 + 1;
      *(_QWORD *)(v36 + 8 * v37) = v33;
    }
    *__error() = 12;
LABEL_49:
    *v33 = 0;
    v52 = 91;
LABEL_50:
    v53 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkCreate", v52, 59, *v53, "malloc", v54, v55, v97);
    chunkDestroy(v33);
    v56 = 289;
    v57 = "Chunk creation";
LABEL_51:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v56, 59, 0, v57, v30, v31, v97);
    v47 = 0;
    a2 = __src;
    v43 = v15 - v14;
LABEL_68:
    if (pthread_mutex_unlock(v105) < 0)
    {
      v88 = *__error();
      v91 = "pthread_mutex_unlock";
      v92 = 316;
LABEL_103:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v92, 59, v88, v91, v89, v90, v97);
LABEL_104:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamPWrite", 393, 59, 0, "Writing chunk data failed", v69, v70, v97);
      while (!__ldaxr(v98))
      {
        if (!__stlxr(1u, v98))
        {
          AAByteStreamCancel(*(AAByteStream *)a1);
          return -1;
        }
      }
      __clrex();
      return -1;
    }
    if ((v47 & 1) == 0)
      goto LABEL_104;
    if (v12 < v11)
      v11 = v7 / v101;
    v7 += v43;
    a2 += v43;
    v9 = v100;
  }
  while (v7 < v100);
LABEL_86:
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) < 0)
  {
    v83 = *__error();
    v86 = "pthread_mutex_lock";
    v87 = 239;
LABEL_99:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamCheckAndWriteChunksToStream", v87, 59, v83, v86, v84, v85, v97);
LABEL_100:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamPWrite", 404, 59, 0, "flushing chunks to stream", v95, v96, v97);
    return -1;
  }
  v74 = v11 + 1;
  if (v11 + 1 < *(_QWORD *)(a1 + 248))
  {
    while (1)
    {
      v75 = v11;
      v11 = v74;
      v76 = *(_QWORD *)(*(_QWORD *)(a1 + 256) + 8 * v75);
      if (!*(_QWORD *)(v76 + 40))
        break;
LABEL_95:
      v74 = v11 + 1;
      if (v11 + 1 >= *(_QWORD *)(a1 + 248))
        goto LABEL_96;
    }
    v77 = *(_QWORD *)(a1 + 8) * v75;
    v78 = (unsigned int *)(v76 + 48);
    do
    {
      if (__ldaxr(v78))
      {
        __clrex();
        goto LABEL_95;
      }
    }
    while (__stlxr(1u, v78));
    if ((streamEnqueueWriteChunkToStream(a1, v76, v77) & 0x80000000) == 0)
      goto LABEL_95;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamCheckAndWriteChunksToStream", 249, 59, 0, "enqueue chunk write", v80, v81, v97);
    v94 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
    if (v94 < 0)
    {
LABEL_97:
      v83 = *__error();
      v86 = "pthread_mutex_unlock";
      v87 = 254;
      goto LABEL_99;
    }
    goto LABEL_100;
  }
LABEL_96:
  v82 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
  v5 = a3;
  if (v82 < 0)
    goto LABEL_97;
  return v5;
}

uint64_t streamEnqueueWriteChunkToStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  __int16 v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  pthread_mutex_t *v22;
  uint64_t v23;
  int v24;
  char v25;

  v6 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    v10 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v11 = 91;
LABEL_8:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v10, v7, v8, v9, v25);
    v17 = "SharedArrayPop";
    v18 = 226;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamEnqueueWriteChunkToStream", v18, 59, 0, v17, v15, v16, v25);
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    v12 = *(_DWORD *)(a1 + 40);
    if (v12)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v6))
    {
      v10 = "SharedArrayPop: pthread_cond_wait failed\n";
      v11 = 94;
      goto LABEL_8;
    }
  }
  v13 = v12 - 1;
  *(_DWORD *)(a1 + 40) = v13;
  v14 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v13);
  if (pthread_mutex_unlock(v6))
  {
    v10 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v11 = 98;
    goto LABEL_8;
  }
  v20 = *(_QWORD *)(a1 + 32);
  v21 = v20 + 152 * v14;
  *(_QWORD *)(v21 + 16) = a2;
  *(_QWORD *)(v21 + 24) = a3;
  v22 = (pthread_mutex_t *)(v21 + 40);
  if (pthread_mutex_lock((pthread_mutex_t *)(v21 + 40))
    || (v23 = v20 + 152 * v14, v24 = *(_DWORD *)(v23 + 32), *(_DWORD *)(v23 + 32) = v24 + 1, !v24)
    && pthread_cond_broadcast((pthread_cond_t *)(v20 + 152 * v14 + 104))
    || (result = pthread_mutex_unlock(v22), (_DWORD)result))
  {
    v17 = "SemRelease";
    v18 = 230;
    goto LABEL_9;
  }
  return result;
}

void chunkDestroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1[5]);
    free(a1);
  }
}

uint64_t chunkAppendHole(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  __int16 v11;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  char *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  void *v27;
  char *v28;
  char *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  char v33;

  if (!a2)
    return 0;
  if (atomic_load((unsigned int *)(a1 + 48)))
  {
    v10 = "Chunk has already been written";
    v11 = 115;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendHole", v11, 59, 0, v10, a7, a8, v33);
    return 0xFFFFFFFFLL;
  }
  v14 = *(_QWORD *)(a1 + 16);
  v15 = v14 + a2;
  if ((unint64_t)(v14 + a2) > *(_QWORD *)(a1 + 8))
  {
    v10 = "Invalid hole size";
    v11 = 116;
    goto LABEL_7;
  }
  v16 = *(_QWORD *)(a1 + 32);
  if (!v16
    || (v17 = *(_QWORD *)(a1 + 40) + 16 * v16,
        v19 = *(_QWORD *)(v17 - 16),
        v20 = *(_QWORD *)(v17 - 8),
        v18 = (_QWORD *)(v17 - 16),
        v19 + v20 != v14))
  {
    v22 = (_QWORD *)(a1 + 24);
    v21 = *(_QWORD *)(a1 + 24);
    if (v16 < v21)
    {
      v23 = *(char **)(a1 + 40);
LABEL_20:
      result = 0;
      *(_QWORD *)(a1 + 32) = v16 + 1;
      v29 = &v23[16 * v16];
      *(_QWORD *)v29 = a2;
      *((_QWORD *)v29 + 1) = v14;
      goto LABEL_21;
    }
    v24 = 2 * v21;
    v25 = v21 == 0;
    v26 = 8;
    if (!v25)
      v26 = v24;
    *(_QWORD *)(a1 + 24) = v26;
    if ((unint64_t)(16 * v26) < 0x2000000001)
    {
      v27 = *(void **)(a1 + 40);
      v28 = (char *)realloc(v27, 16 * v26);
      if (v28)
      {
        v23 = v28;
        *(_QWORD *)(a1 + 40) = v28;
        v16 = *(_QWORD *)(a1 + 32);
        v14 = *(_QWORD *)(a1 + 16);
        v15 = v14 + a2;
        goto LABEL_20;
      }
      free(v27);
    }
    else
    {
      *__error() = 12;
    }
    *(_QWORD *)(a1 + 40) = 0;
    v30 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendHole", 135, 59, *v30, "malloc", v31, v32, v33);
    *v22 = 0;
    *(_QWORD *)(a1 + 32) = 0;
    return 0xFFFFFFFFLL;
  }
  result = 0;
  *v18 = v19 + a2;
LABEL_21:
  *(_QWORD *)(a1 + 16) = v15;
  return result;
}

uint64_t loadAndDecodeHeader_Cpio(uint64_t *a1, unint64_t *a2)
{
  int *v4;
  int v5;
  int v6;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  size_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  int v32;
  char v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  unint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  int v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  char v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  AAFieldKey v77;
  AAFieldKey v78;
  AAFieldKey v79;
  AAFieldKey v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t result;
  uint64_t v97;
  int v98;
  char v99;
  AAFieldKey v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  char v114;
  AAFieldKey v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  char *v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  unint64_t v123;
  char *v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  char v130;
  __darwin_time_t v131;
  int v132;
  char v133;
  AAFieldKey v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  char v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  AAFieldKey v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  char v165;
  AAFieldKey v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  unint64_t v173;
  uint64_t v174;
  unint64_t v175;
  AAFieldKey v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  AAFieldKey v180;
  _BOOL4 v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  char v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  char v189;
  AAFieldKey v190;
  AAFieldKey v191;
  unint64_t v192;
  uint64_t v193;
  int v194;
  timespec value;

  v4 = (int *)a1[8];
  v5 = *v4;
  v6 = *((unsigned __int16 *)v4 + 2);
  v8 = v5 != 925906736 || v6 != 12592;
  value.tv_sec = 0;
  value.tv_nsec = 0;
  v9 = *a1;
  if (AAHeaderClear((AAHeader)a1[11]) < 0)
  {
    v29 = "clear header";
    v30 = 67;
LABEL_116:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStreamCPIO.c", (uint64_t)"loadAndDecodeHeader_Cpio", v30, 113, 0, v29, v14, v15, v193);
    return 0xFFFFFFFFLL;
  }
  if (v8)
    v16 = 76;
  else
    v16 = 110;
  if ((decodeStreamLoadHeader(a1, v16, v10, v11, v12, v13, v14, v15) & 0x80000000) != 0)
  {
    v29 = "truncated stream";
    v30 = 73;
    goto LABEL_116;
  }
  v17 = a1[8];
  if (v8)
  {
    v18 = 0;
    v19 = v17 + 65;
    v20 = v17 + 63;
    v21 = 4;
    v22 = v17 + 59;
    do
    {
      v23 = 0;
      v24 = 0;
      v25 = v20;
      v26 = v21;
      do
      {
        v27 = *(_BYTE *)(v22 + v23++) & 7 | (8 * v24);
        v24 = v27;
      }
      while (v23 != 4);
      v18 = v27 + (v18 << 12);
      v20 = v25 + 4;
      v21 += 4;
      v22 += 4;
    }
    while (v25 + 4 <= v19);
    if (v25 >= v19)
    {
      v28 = v18;
    }
    else
    {
      do
      {
        v28 = *(_BYTE *)(v17 + 59 + v26++) & 7 | (8 * v18);
        v18 = v28;
      }
      while (v26 != 6);
    }
  }
  else
  {
    v31 = 0;
    v28 = 0;
    do
    {
      v32 = *(char *)(v17 + 94 + v31);
      v28 *= 16;
      v33 = v32 - 48;
      if ((v32 - 48) <= 0x36)
      {
        if (((1 << v33) & 0x3FF) != 0)
        {
          v28 = v28 + *(char *)(v17 + 94 + v31) - 48;
        }
        else if (((1 << v33) & 0x7E0000) != 0)
        {
          v28 = v28 + *(char *)(v17 + 94 + v31) - 55;
        }
        else if (((1 << v33) & 0x7E000000000000) != 0)
        {
          v28 = v28 + *(char *)(v17 + 94 + v31) - 87;
        }
      }
      ++v31;
    }
    while (v31 != 8);
  }
  v34 = 0;
  if (v8)
  {
    v35 = v17 + 65;
    v36 = v17 + 76;
    v37 = (char *)(v17 + 73);
    do
    {
      v38 = 0;
      v39 = 0;
      v40 = v37;
      do
      {
        v41 = *(_BYTE *)(v35 + v38++) & 7 | (8 * v39);
        v39 = v41;
      }
      while (v38 != 8);
      v34 = v41 + (v34 << 24);
      v37 = v40 + 8;
      v35 += 8;
    }
    while ((unint64_t)(v40 + 8) <= v36);
    v42 = v40 + 4;
    if ((unint64_t)(v40 + 4) <= v36)
    {
      do
      {
        v44 = 0;
        v45 = 0;
        do
        {
          v46 = v40[v44++] & 7 | (8 * v45);
          v45 = v46;
        }
        while (v44 != 4);
        v34 = v46 + (v34 << 12);
        v43 = v42;
        v40 += 4;
        v42 += 4;
      }
      while ((unint64_t)v42 <= v36);
    }
    else
    {
      v43 = v40;
    }
    if ((unint64_t)v43 >= v36)
    {
      v49 = v34;
    }
    else
    {
      v47 = v17 - (_QWORD)v43 + 76;
      do
      {
        v48 = *v43++;
        v49 = v48 & 7 | (8 * v34);
        v34 = v49;
        --v47;
      }
      while (v47);
    }
  }
  else
  {
    v49 = 0;
    do
    {
      v50 = *(char *)(v17 + 54 + v34);
      v49 *= 16;
      v51 = v50 - 48;
      if ((v50 - 48) <= 0x36)
      {
        if (((1 << v51) & 0x3FF) != 0)
        {
          v49 = v49 + *(char *)(v17 + 54 + v34) - 48;
        }
        else if (((1 << v51) & 0x7E0000) != 0)
        {
          v49 = v49 + *(char *)(v17 + 54 + v34) - 55;
        }
        else if (((1 << v51) & 0x7E000000000000) != 0)
        {
          v49 = v49 + *(char *)(v17 + 54 + v34) - 87;
        }
      }
      ++v34;
    }
    while (v34 != 8);
  }
  v52 = 0;
  if (v8)
  {
    v53 = v17 + 24;
    v54 = v17 + 22;
    v55 = v17 + 18;
    v56 = 4;
    v57 = v55;
    do
    {
      v58 = 0;
      v59 = 0;
      v60 = v54;
      v61 = v56;
      do
      {
        v62 = *(_BYTE *)(v57 + v58++) & 7 | (8 * v59);
        v59 = v62;
      }
      while (v58 != 4);
      v52 = v62 + (v52 << 12);
      v54 = v60 + 4;
      v56 += 4;
      v57 += 4;
    }
    while (v60 + 4 <= v53);
    if (v60 >= v53)
    {
      LOWORD(v63) = v52;
    }
    else
    {
      do
      {
        v63 = *(_BYTE *)(v55 + v61++) & 7 | (8 * v52);
        v52 = v63;
      }
      while (v61 != 6);
    }
  }
  else
  {
    v63 = 0;
    v64 = v17 + 14;
    do
    {
      v65 = *(char *)(v64 + v52);
      v63 *= 16;
      v66 = v65 - 48;
      if ((v65 - 48) <= 0x36)
      {
        if (((1 << v66) & 0x3FF) != 0)
        {
          v63 = v63 + *(char *)(v64 + v52) - 48;
        }
        else if (((1 << v66) & 0x7E0000) != 0)
        {
          v63 = v63 + *(char *)(v64 + v52) - 55;
        }
        else if (((1 << v66) & 0x7E000000000000) != 0)
        {
          v63 = v63 + *(char *)(v64 + v52) - 87;
        }
      }
      ++v52;
    }
    while (v52 != 8);
  }
  v67 = aaEntryTypeFromMode(v63);
  if (v28 >= 0x10000)
  {
    v29 = "invalid c_namesize";
    v30 = 82;
    goto LABEL_116;
  }
  v72 = v67;
  if (v8)
    v73 = v28 + v16;
  else
    v73 = (v28 + v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v74 = v73;
  if (v67 == 76)
  {
    if (v49 >= 0x10000)
    {
      v29 = "invalid c_filesize";
      v30 = 89;
      goto LABEL_116;
    }
    if (v8)
      v74 = v49 + v73;
    else
      v74 = (v49 + v73 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  }
  if ((decodeStreamLoadHeader(a1, v74, v68, v69, v70, v71, v14, v15) & 0x80000000) != 0)
  {
    v29 = "truncated stream";
    v30 = 95;
    goto LABEL_116;
  }
  if (v72)
    v75 = 0;
  else
    v75 = v49 == 0;
  if (v75 && v28 == 11)
  {
    v92 = (uint64_t *)(a1[8] + v16);
    v93 = *v92;
    v94 = *(uint64_t *)((char *)v92 + 3);
    if (v93 == 0x2152454C49415254 && v94 == 0x21212152454C49)
      return 1;
LABEL_115:
    v29 = "invalid cpio header";
    v30 = 101;
    goto LABEL_116;
  }
  if (!v72)
    goto LABEL_115;
  v193 = a1[8];
  v77.ikey = 5265748;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v77, v72) < 0)
  {
    v29 = "creating header";
    v30 = 106;
    goto LABEL_116;
  }
  v78.ikey = 5521744;
  if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v78, (const char *)(a1[8] + v16), v28) < 0)
  {
    v29 = "creating header";
    v30 = 109;
    goto LABEL_116;
  }
  if (v72 == 76)
  {
    v79.ikey = 4935244;
    if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v79, (const char *)(a1[8] + v73), v49) < 0)
    {
      v29 = "creating header";
      v30 = 114;
      goto LABEL_116;
    }
  }
  v80.ikey = 4476749;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v80, v63 & 0xFFF) < 0)
  {
    v29 = "creating header";
    v30 = 118;
    goto LABEL_116;
  }
  if (v8)
  {
    v81 = 0;
    v82 = v193 + 30;
    v83 = v193 + 28;
    v84 = 4;
    v85 = v193 + 24;
    do
    {
      v86 = 0;
      v87 = 0;
      v88 = v83;
      v89 = v84;
      do
      {
        v90 = *(_BYTE *)(v85 + v86++) & 7 | (8 * v87);
        v87 = v90;
      }
      while (v86 != 4);
      v81 = v90 + (v81 << 12);
      v83 = v88 + 4;
      v84 += 4;
      v85 += 4;
    }
    while (v88 + 4 <= v82);
    if (v88 >= v82)
    {
      v91 = v81;
    }
    else
    {
      do
      {
        v91 = *(_BYTE *)(v193 + 24 + v89++) & 7 | (8 * v81);
        v81 = v91;
      }
      while (v89 != 6);
    }
  }
  else
  {
    v97 = 0;
    v91 = 0;
    do
    {
      v98 = *(char *)(v193 + 22 + v97);
      v91 *= 16;
      v99 = v98 - 48;
      if ((v98 - 48) <= 0x36)
      {
        if (((1 << v99) & 0x3FF) != 0)
        {
          v91 = v91 + *(char *)(v193 + 22 + v97) - 48;
        }
        else if (((1 << v99) & 0x7E0000) != 0)
        {
          v91 = v91 + *(char *)(v193 + 22 + v97) - 55;
        }
        else if (((1 << v99) & 0x7E000000000000) != 0)
        {
          v91 = v91 + *(char *)(v193 + 22 + v97) - 87;
        }
      }
      ++v97;
    }
    while (v97 != 8);
  }
  v100.ikey = 4475221;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v100, v91) < 0)
  {
    v29 = "creating header";
    v30 = 122;
    goto LABEL_116;
  }
  if (v8)
  {
    v101 = 0;
    v102 = v193 + 36;
    v103 = v193 + 34;
    v104 = 4;
    v105 = v193 + 30;
    do
    {
      v106 = 0;
      v107 = 0;
      v108 = v103;
      v109 = v104;
      do
      {
        v110 = *(_BYTE *)(v105 + v106++) & 7 | (8 * v107);
        v107 = v110;
      }
      while (v106 != 4);
      v101 = v110 + (v101 << 12);
      v103 = v108 + 4;
      v104 += 4;
      v105 += 4;
    }
    while (v108 + 4 <= v102);
    if (v108 >= v102)
    {
      v111 = v101;
    }
    else
    {
      do
      {
        v111 = *(_BYTE *)(v193 + 30 + v109++) & 7 | (8 * v101);
        v101 = v111;
      }
      while (v109 != 6);
    }
  }
  else
  {
    v112 = 0;
    v111 = 0;
    do
    {
      v113 = *(char *)(v193 + 30 + v112);
      v111 *= 16;
      v114 = v113 - 48;
      if ((v113 - 48) <= 0x36)
      {
        if (((1 << v114) & 0x3FF) != 0)
        {
          v111 = v111 + *(char *)(v193 + 30 + v112) - 48;
        }
        else if (((1 << v114) & 0x7E0000) != 0)
        {
          v111 = v111 + *(char *)(v193 + 30 + v112) - 55;
        }
        else if (((1 << v114) & 0x7E000000000000) != 0)
        {
          v111 = v111 + *(char *)(v193 + 30 + v112) - 87;
        }
      }
      ++v112;
    }
    while (v112 != 8);
  }
  v115.ikey = 4475207;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v115, v111) < 0)
  {
    v29 = "creating header";
    v30 = 126;
    goto LABEL_116;
  }
  v116 = 0;
  if (v8)
  {
    v117 = v193 + 48;
    v118 = v193 + 59;
    v119 = (char *)(v193 + 56);
    do
    {
      v120 = 0;
      v121 = 0;
      v122 = v119;
      do
      {
        v123 = *(_BYTE *)(v117 + v120++) & 7 | (8 * v121);
        v121 = v123;
      }
      while (v120 != 8);
      v116 = v123 + (v116 << 24);
      v119 = v122 + 8;
      v117 += 8;
    }
    while ((unint64_t)(v122 + 8) <= v118);
    v124 = v122 + 4;
    if ((unint64_t)(v122 + 4) <= v118)
    {
      do
      {
        v126 = 0;
        v127 = 0;
        do
        {
          v128 = v122[v126++] & 7 | (8 * v127);
          v127 = v128;
        }
        while (v126 != 4);
        v116 = v128 + (v116 << 12);
        v125 = v124;
        v122 += 4;
        v124 += 4;
      }
      while ((unint64_t)v124 <= v118);
    }
    else
    {
      v125 = v122;
    }
    if ((unint64_t)v125 >= v118)
    {
      v131 = v116;
    }
    else
    {
      v129 = v193 - (_QWORD)v125 + 59;
      do
      {
        v130 = *v125++;
        v131 = v130 & 7 | (8 * v116);
        v116 = v131;
        --v129;
      }
      while (v129);
    }
  }
  else
  {
    v131 = 0;
    do
    {
      v132 = *(char *)(v193 + 46 + v116);
      v131 *= 16;
      v133 = v132 - 48;
      if ((v132 - 48) <= 0x36)
      {
        if (((1 << v133) & 0x3FF) != 0)
        {
          v131 = v131 + *(char *)(v193 + 46 + v116) - 48;
        }
        else if (((1 << v133) & 0x7E0000) != 0)
        {
          v131 = v131 + *(char *)(v193 + 46 + v116) - 55;
        }
        else if (((1 << v133) & 0x7E000000000000) != 0)
        {
          v131 = v131 + *(char *)(v193 + 46 + v116) - 87;
        }
      }
      ++v116;
    }
    while (v116 != 8);
  }
  value.tv_sec = v131;
  value.tv_nsec = 0;
  v134.ikey = 5067853;
  if (AAHeaderSetFieldTimespec((AAHeader)a1[11], 0xFFFFFFFF, v134, &value) < 0)
  {
    v29 = "creating header";
    v30 = 131;
    goto LABEL_116;
  }
  if (v8)
  {
    v135 = 0;
    v136 = v193;
    v137 = v193 + 18;
    v138 = v193 + 16;
    v139 = 4;
    v140 = v193 + 12;
    do
    {
      v141 = 0;
      v142 = 0;
      v143 = v138;
      v144 = v139;
      do
      {
        v145 = *(_BYTE *)(v140 + v141++) & 7 | (8 * v142);
        v142 = v145;
      }
      while (v141 != 4);
      v135 = v145 + (v135 << 12);
      v138 = v143 + 4;
      v139 += 4;
      v140 += 4;
    }
    while (v143 + 4 <= v137);
    if (v143 >= v137)
    {
      v146 = v135;
    }
    else
    {
      do
      {
        v146 = *(_BYTE *)(v193 + 12 + v144++) & 7 | (8 * v135);
        v135 = v146;
      }
      while (v144 != 6);
    }
  }
  else
  {
    v147 = 0;
    v146 = 0;
    v136 = v193;
    do
    {
      v148 = *(char *)(v193 + 6 + v147);
      v146 *= 16;
      v149 = v148 - 48;
      if ((v148 - 48) <= 0x36)
      {
        if (((1 << v149) & 0x3FF) != 0)
        {
          v146 = v146 + *(char *)(v193 + 6 + v147) - 48;
        }
        else if (((1 << v149) & 0x7E0000) != 0)
        {
          v146 = v146 + *(char *)(v193 + 6 + v147) - 55;
        }
        else if (((1 << v149) & 0x7E000000000000) != 0)
        {
          v146 = v146 + *(char *)(v193 + 6 + v147) - 87;
        }
      }
      ++v147;
    }
    while (v147 != 8);
  }
  if (v8)
  {
    v150 = 0;
    v151 = v136 + 12;
    v152 = v136 + 10;
    v153 = 4;
    v154 = v136 + 6;
    do
    {
      v155 = 0;
      v156 = 0;
      v157 = v152;
      v158 = v153;
      do
      {
        v159 = *(_BYTE *)(v154 + v155++) & 7 | (8 * v156);
        v156 = v159;
      }
      while (v155 != 4);
      v150 = v159 + (v150 << 12);
      v152 = v157 + 4;
      v153 += 4;
      v154 += 4;
    }
    while (v157 + 4 <= v151);
    if (v157 >= v151)
    {
      v160 = v150;
    }
    else
    {
      do
      {
        v160 = *(_BYTE *)(v136 + 6 + v158++) & 7 | (8 * v150);
        v150 = v160;
      }
      while (v158 != 6);
    }
    v146 |= v160 << 18;
    v166.ikey = 5197385;
    if ((AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v166, v146) & 0x80000000) == 0)
    {
      v163 = 0;
      v167 = v193 + 42;
      v168 = v193 + 40;
      v169 = 4;
      v170 = v193 + 36;
      do
      {
        v171 = 0;
        v172 = 0;
        v173 = v168;
        v174 = v169;
        do
        {
          v175 = *(_BYTE *)(v170 + v171++) & 7 | (8 * v172);
          v172 = v175;
        }
        while (v171 != 4);
        v163 = v175 + (v163 << 12);
        v168 = v173 + 4;
        v169 += 4;
        v170 += 4;
      }
      while (v173 + 4 <= v167);
      if (v173 < v167)
      {
        do
          v163 = *(_BYTE *)(v193 + 36 + v174++) & 7 | (8 * v163);
        while (v174 != 6);
      }
      goto LABEL_229;
    }
LABEL_239:
    v29 = "creating header";
    v30 = 145;
    goto LABEL_116;
  }
  v161.ikey = 5197385;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v161, v146) < 0)
    goto LABEL_239;
  v162 = 0;
  v163 = 0;
  do
  {
    v164 = *(char *)(v193 + 38 + v162);
    v163 *= 16;
    v165 = v164 - 48;
    if ((v164 - 48) <= 0x36)
    {
      if (((1 << v165) & 0x3FF) != 0)
      {
        v163 = v163 + *(char *)(v193 + 38 + v162) - 48;
      }
      else if (((1 << v165) & 0x7E0000) != 0)
      {
        v163 = v163 + *(char *)(v193 + 38 + v162) - 55;
      }
      else if (((1 << v165) & 0x7E000000000000) != 0)
      {
        v163 = v163 + *(char *)(v193 + 38 + v162) - 87;
      }
    }
    ++v162;
  }
  while (v162 != 8);
LABEL_229:
  v176.ikey = 4934734;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v176, v163) < 0)
  {
    v29 = "creating header";
    v30 = 149;
    goto LABEL_116;
  }
  if ((v9 & 0x8000000000000) != 0 || v163 < 2 || v72 != 70)
  {
    v181 = 0;
    if (v8 || (v72 & 0xFFFFFFFE) != 0x42)
      goto LABEL_263;
    v182 = 0;
    v183 = 0;
    do
    {
      v184 = *(char *)(v193 + 78 + v182);
      v183 *= 16;
      v185 = v184 - 48;
      if ((v184 - 48) <= 0x36)
      {
        if (((1 << v185) & 0x3FF) != 0)
        {
          v183 = v183 + *(char *)(v193 + 78 + v182) - 48;
        }
        else if (((1 << v185) & 0x7E0000) != 0)
        {
          v183 = v183 + *(char *)(v193 + 78 + v182) - 55;
        }
        else if (((1 << v185) & 0x7E000000000000) != 0)
        {
          v183 = v183 + *(char *)(v193 + 78 + v182) - 87;
        }
      }
      ++v182;
    }
    while (v182 != 8);
    v186 = 0;
    v187 = 0;
    do
    {
      v188 = *(char *)(v193 + 86 + v186);
      v187 *= 16;
      v189 = v188 - 48;
      if ((v188 - 48) <= 0x36)
      {
        if (((1 << v189) & 0x3FF) != 0)
        {
          v187 = v187 + *(char *)(v193 + 86 + v186) - 48;
        }
        else if (((1 << v189) & 0x7E0000) != 0)
        {
          v187 = v187 + *(char *)(v193 + 86 + v186) - 55;
        }
        else if (((1 << v189) & 0x7E000000000000) != 0)
        {
          v187 = v187 + *(char *)(v193 + 86 + v186) - 87;
        }
      }
      ++v186;
    }
    while (v186 != 8);
    v190.ikey = 5653828;
    if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v190, v187 + (v183 << 24)) < 0)
    {
      v29 = "creating header";
      v30 = 173;
      goto LABEL_116;
    }
LABEL_262:
    v181 = 0;
    goto LABEL_263;
  }
  v194 = 0;
  v179 = decodeStreamHLCFromINO(a1, v146, v163, &v194, v177, v178, v14, v15);
  if (v179 == -1)
  {
    v29 = "too many hard links or inconsistent nlink/ino data in archive";
    v30 = 156;
    goto LABEL_116;
  }
  v180.ikey = 4410440;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v180, v179) < 0)
  {
    v29 = "creating header";
    v30 = 157;
    goto LABEL_116;
  }
  if (v8)
    goto LABEL_262;
  if (!v194 && v49)
  {
    v29 = "invalid newc encoding for hard links";
    v30 = 162;
    goto LABEL_116;
  }
  v181 = v194 == 0;
LABEL_263:
  if (v72 != 70 || v181)
  {
    if (v72 != 70)
    {
      result = 0;
      *a2 = 0;
      return result;
    }
  }
  else
  {
    v191.ikey = 5521732;
    if (AAHeaderSetFieldBlob((AAHeader)a1[11], 0xFFFFFFFF, v191, v49) < 0)
    {
      v29 = "creating header";
      v30 = 179;
      goto LABEL_116;
    }
  }
  result = 0;
  v192 = (v49 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v8)
    v192 = v49;
  *a2 = v192;
  return result;
}

uint64_t getBXDiffControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int8x16_t **a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v10;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int8x16_t *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t BestMatch;
  uint64_t v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  unsigned __int8 v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unsigned __int8 v53;
  int v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  unsigned __int8 v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  unint64_t v67;
  char v68;
  char v69;
  char v70;
  unsigned __int8 v71;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int64x2_t v90;
  int8x16_t *v91;
  uint64_t v92;
  int8x16_t *v93;
  const char *v94;
  __int16 v95;
  int8x16_t *v96;
  unint64_t v97;
  int *v98;
  uint64_t v99;
  uint64_t v100;
  int64x2_t v101;
  uint64_t v102;
  uint64_t v103;
  char v105;
  _QWORD *v106;
  int8x16_t **v107;
  int v108;
  int64x2_t v109;
  int8x16_t *__ptr;
  BOOL v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v8 = 0xFFFFFFFFLL;
  if (!a2 || !a4)
    return v8;
  v10 = (_QWORD *)a6;
  if (a2 >= a4)
    v13 = a4;
  else
    v13 = a2;
  if (v13 >= 0x10000)
  {
    v14 = a2 - a4;
    if (a2 < a4)
      v14 = a4 - a2;
    v15 = (unsigned __int8 *)a1;
    v16 = (unsigned __int8 *)a3;
    do
    {
      v18 = *v15++;
      v17 = v18;
      v19 = *v16++;
      if (v17 != v19)
        ++v14;
      --v13;
    }
    while (v13);
    if (v14 <= a4 / 0x64)
    {
      v96 = (int8x16_t *)calloc(1uLL, 0x18uLL);
      if (v96)
      {
        *a5 = v96;
        *v10 = 1;
        if (a2 <= a4)
        {
          v8 = 0;
          v101.i64[0] = a2;
          v101.i64[1] = a4 - a2;
          *v96 = vbslq_s8((int8x16_t)vcltzq_s64(v101), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), v101), (int8x16_t)v101);
          v96[1].i64[0] = 0;
        }
        else
        {
          v8 = 0;
          v97 = 0x8000000000000000 - a4;
          v96->i64[1] = 0;
          v96[1].i64[0] = 0;
          if ((a4 & 0x8000000000000000) == 0)
            v97 = a4;
          v96->i64[0] = v97;
        }
        return v8;
      }
      v98 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffFastPathControls", 101, 24, *v98, "calloc", v99, v100, v105);
      v94 = "building fast path controls";
      v95 = 311;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", v95, 24, 0, v94, v21, v22, v105);
      return 0xFFFFFFFFLL;
    }
  }
  v20 = BXDiffMatchesCreate(a1, a2, a3, a4, a7, a6, (uint64_t)a7, a8);
  if (!v20)
  {
    v94 = "creating diff match lookup object";
    v95 = 319;
    goto LABEL_121;
  }
  v23 = (void **)v20;
  v24 = BXDiffMatchesIBuf(v20);
  v25 = BXDiffMatchesISize((uint64_t)v23);
  v26 = BXDiffMatchesOBuf((uint64_t)v23);
  v27 = BXDiffMatchesOSize((uint64_t)v23);
  v28 = 0;
  v117 = 0;
  if (!v25 || !v27)
    goto LABEL_126;
  if (v27 < 1)
  {
    v30 = 0;
    v93 = 0;
    goto LABEL_123;
  }
  v115 = (uint64_t)v23;
  v106 = v10;
  v107 = a5;
  __ptr = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v113 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = v27;
  v108 = 1;
  v109 = vdupq_n_s64(0x8000000000000000);
  v116 = v27;
  do
  {
    v112 = v30;
    v34 += v33;
    v111 = v34 < v27;
    v114 = v29;
    v36 = 0;
    if (v34 >= v27)
    {
LABEL_46:
      if (v33 == v36)
      {
        v30 = v112;
        if (v34 != v27)
          continue;
        goto LABEL_50;
      }
    }
    else
    {
      v37 = v34;
      do
      {
        BestMatch = BXDiffMatchesGetBestMatch(v115, v37, &v117);
        v39 = BestMatch + v37;
        if (BestMatch + v37 <= v35)
          v33 = BestMatch;
        else
          v33 = v35 - v37;
        if (v34 >= v33 + v37)
        {
          v27 = v116;
        }
        else
        {
          if (v39 >= v35)
            v39 = v35;
          v40 = (unsigned __int8 *)(v26 + v34);
          v41 = v39 - v34;
          v42 = v31 + v34;
          v27 = v116;
          do
          {
            if (v42 < v25 && *(unsigned __int8 *)(v24 + v42) == *v40)
              ++v36;
            ++v40;
            ++v42;
            --v41;
          }
          while (v41);
          v34 = v39;
        }
        v43 = v33 != v36 || v33 == 0;
        if (!v43 || v33 > v36 + 8)
        {
          v34 = v37;
          v29 = v114;
          goto LABEL_46;
        }
        if (v37 + v31 < v25)
          v36 -= *(unsigned __int8 *)(v24 + v37 + v31) == *(unsigned __int8 *)(v26 + v37);
        ++v37;
      }
      while (v37 < v27);
      v111 = 0;
      v34 = v27;
    }
    v30 = v112;
LABEL_50:
    v45 = v34 - v32;
    v46 = v25 - v113;
    if (v34 - v32 < v25 - v113)
      v46 = v34 - v32;
    if (v46 < 1)
    {
      v51 = 0;
    }
    else
    {
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      do
      {
        v52 = v49 | (v50 << 8);
        v53 = *(_BYTE *)(v24 + v47 + v113) - *(_BYTE *)(v26 + v47 + v32);
        if ((v50 & 0xFF000000FF0000) != 0 || (unsigned __int16)v52 == 0)
          v55 = 3;
        else
          v55 = 4;
        v56 = __OFADD__(v55, v48);
        v57 = v55 + v48;
        if ((v57 < 0) ^ v56 | (v57 == 0))
          v58 = v51;
        else
          v58 = v47 + 1;
        v59 = v57 & (v57 >> 31);
        v48 -= 4;
        ++v47;
        if (!v53)
        {
          v51 = v58;
          v48 = v59;
        }
        v50 = v52;
        v49 = v53;
      }
      while (v47 != v46);
    }
    if (!v111)
      goto LABEL_86;
    if (v45 >= v117)
      v45 = v117;
    if (v45 >= 1)
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v64 = 0;
      v65 = (char *)(v26 - 1 + v34);
      v66 = (char *)(v24 - 1 + v117);
      do
      {
        ++v60;
        v67 = v62 | (v63 << 8);
        v43 = (v63 & 0xFF000000FF0000) == 0;
        v69 = *v66--;
        v68 = v69;
        v70 = *v65--;
        v71 = v68 - v70;
        if (!v43 || (unsigned __int16)v67 == 0)
          v73 = 3;
        else
          v73 = 4;
        v56 = __OFADD__(v73, v61);
        v74 = v73 + v61;
        if ((v74 < 0) ^ v56 | (v74 == 0))
          v75 = v64;
        else
          v75 = v60;
        v76 = v74 & (v74 >> 31);
        v61 -= 4;
        if (!v71)
        {
          v64 = v75;
          v61 = v76;
        }
        v63 = v67;
        v62 = v71;
      }
      while (v45 != v60);
    }
    else
    {
LABEL_86:
      v64 = 0;
    }
    v77 = v51 + v32 - (v34 - v64);
    if (v51 + v32 > v34 - v64)
    {
      if (v77 < 1)
      {
        v80 = 0;
      }
      else
      {
        v78 = 0;
        v79 = 0;
        v80 = 0;
        do
        {
          v81 = *(unsigned __int8 *)(v26 + v79 + v34 - v64);
          v78 -= v81 == *(unsigned __int8 *)(v24 + v117 - v64 + v79);
          v82 = *(unsigned __int8 *)(v24 + v113 - (v32 - (v34 - v64)) + v79);
          if (v78 >= 0)
            v83 = v79 + 1;
          else
            v83 = v80;
          if (v78 < 0)
            v84 = v78 + 1;
          else
            v84 = 0;
          ++v79;
          if (v81 == v82)
          {
            v80 = v83;
            v78 = v84;
          }
        }
        while (v79 < v77);
      }
      v51 = v34 - v64 - v32 + v80;
      v64 -= v80;
    }
    v85 = v114;
    if (v30 >= v114)
    {
      v114 += 0x40000;
      __ptr = (int8x16_t *)reallocf(__ptr, 24 * (v85 + 0x40000));
      if (!__ptr)
      {
        v86 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffControlsWithMatches", 255, 24, *v86, "malloc", v87, v88, v105);
        __ptr = 0;
        v108 = 0;
      }
      v27 = v116;
    }
    v89 = v51 + v32;
    v32 = v34 - v64;
    v90.i64[0] = v51;
    v90.i64[1] = v34 - v64 - v89;
    v91 = (int8x16_t *)((char *)__ptr + 24 * v30);
    *v91 = vbslq_s8((int8x16_t)vcltzq_s64(v90), (int8x16_t)vsubq_s64(v109, v90), (int8x16_t)v90);
    v92 = v117 - (v51 + v113 + v64);
    if (v92 < 0)
      v92 = 0x8000000000000000 - v92;
    v91[1].i64[0] = v92;
    ++v30;
    v113 = v117 - v64;
    v31 = v117 - v34;
    v29 = v114;
  }
  while (v34 < v27);
  v10 = v106;
  a5 = v107;
  if (!v108)
  {
    v23 = (void **)v115;
    v28 = __ptr;
LABEL_126:
    free(v28);
    *a5 = 0;
    *v10 = 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", 324, 24, 0, "building diff controls", v102, v103, v105);
    goto LABEL_127;
  }
  v93 = __ptr;
  if (__ptr)
    v93 = (int8x16_t *)reallocToFit(__ptr, 24 * v30);
  v23 = (void **)v115;
LABEL_123:
  *a5 = v93;
  *v10 = v30;
LABEL_127:
  BXDiffMatchesDestroy(v23);
  if (*a5)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aaEntryYFPBlobInitWithPath(_QWORD *a1, char *a2, const char *a3)
{
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  ssize_t v11;
  ssize_t v12;
  unint64_t v13;
  size_t v14;
  unsigned int v15;
  unint64_t v16;
  void *v17;
  uint64_t i;
  uint64_t v19;
  BOOL v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  ssize_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  void *v29;
  uint64_t v30;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  size_t v47;
  size_t v48;
  uint64_t v49;
  void *v50;
  void *v51;
  char v52;
  int v53;
  unsigned __int8 *v54;
  _QWORD v55[2];
  char v56[2048];
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v55[0] = 0;
  v55[1] = 0;
  v6 = (unsigned __int8 *)malloc(0x40000uLL);
  if (!v6)
  {
    v26 = *__error();
    v27 = "malloc";
    v28 = 43;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", v28, 124, v26, v27, v7, v8, v52);
    v29 = 0;
    v10 = -1;
LABEL_29:
    v30 = 0xFFFFFFFFLL;
    goto LABEL_30;
  }
  if ((concatPath(v56, 0x800uLL, a2, a3) & 0x80000000) != 0)
  {
    v52 = (char)a2;
    v27 = "invalid path %s/%s";
    v28 = 46;
    v26 = 0;
    goto LABEL_28;
  }
  v9 = open(v56, 0x200000);
  v10 = v9;
  if (v9 < 0)
  {
    v32 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 50, 124, *v32, "open: %s", v33, v34, (char)v56);
    v29 = 0;
    goto LABEL_29;
  }
  v11 = read(v9, v6, 0x40000uLL);
  if (v11 < 0)
  {
    v17 = 0;
LABEL_35:
    v29 = v17;
    v35 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 56, 124, *v35, "read: %s", v36, v37, (char)v56);
    goto LABEL_29;
  }
  v12 = v11;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v54 = v6;
  v53 = v10;
  while (2)
  {
    if (v12)
    {
      for (i = 0; i != v12; ++i)
      {
        v19 = v6[i];
        v16 = v19 + 0x202000202008008DLL * v16 + 0x516929CF586FB3BFLL * *((unsigned __int8 *)v55 + v15);
        *((_BYTE *)v55 + v15) = v19;
        if (v15 == 15)
          v15 = 0;
        else
          ++v15;
        if (v16 >> 52)
          v20 = 1;
        else
          v20 = (_DWORD)v16 == 0;
        if (!v20)
        {
          if (v14 >= v13)
          {
            if (v13)
              v13 *= 2;
            else
              v13 = 256;
            if (4 * v13 >= 0x2000000001)
            {
              *__error() = 12;
LABEL_38:
              v38 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 79, 124, *v38, "malloc", v39, v40, v52);
              v29 = 0;
              v30 = 0xFFFFFFFFLL;
              v10 = v53;
              goto LABEL_30;
            }
            v21 = v17;
            v22 = realloc(v17, 4 * v13);
            if (!v22)
            {
              free(v21);
              v6 = v54;
              goto LABEL_38;
            }
            v17 = v22;
            v6 = v54;
          }
          *((_DWORD *)v17 + v14++) = v16;
        }
      }
      v10 = v53;
      v23 = v6;
      v24 = v17;
      v25 = read(v53, v23, 0x40000uLL);
      v17 = v24;
      v6 = v54;
      v12 = v25;
      if ((v25 & 0x8000000000000000) == 0)
        continue;
      goto LABEL_35;
    }
    break;
  }
  v41 = v17;
  qsort(v17, v14, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_markers);
  if (v14)
  {
    v44 = 0;
    v45 = 0;
    v29 = v41;
    do
    {
      v46 = *((_DWORD *)v41 + v44);
      if (!v45 || v46 != *((_DWORD *)v41 + v45 - 1))
        *((_DWORD *)v41 + v45++) = v46;
      ++v44;
    }
    while (v14 != v44);
    v14 = 4 * v45;
    *a1 = 0;
    if (4 * v45 < 0)
    {
LABEL_66:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 98, 124, 0, "malloc", v42, v43, v52);
      v30 = 0xFFFFFFFFLL;
      goto LABEL_67;
    }
    v47 = a1[1];
    if (v47 < v14)
    {
      do
      {
        while (!v47)
        {
          v47 = 0x4000;
          if (v14 <= 0x4000)
          {
            v47 = 0x4000;
            goto LABEL_62;
          }
        }
        v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0)
          v48 = v47 & (v47 >> 1);
        v47 += v48;
      }
      while (v47 < v14);
      if (v47 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_65;
      }
LABEL_62:
      v50 = (void *)a1[2];
      v51 = realloc(v50, v47);
      if (v51)
      {
        a1[1] = v47;
        a1[2] = v51;
        goto LABEL_55;
      }
      free(v50);
LABEL_65:
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      v29 = v41;
      goto LABEL_66;
    }
  }
  else
  {
    *a1 = 0;
LABEL_55:
    v29 = v41;
    if (!v41)
    {
      v49 = a1[2];
      if (v49)
        memset_s((void *)(v49 + *a1), v14, 0, v14);
      goto LABEL_57;
    }
  }
  memcpy((void *)(a1[2] + *a1), v29, v14);
LABEL_57:
  v30 = 0;
  *a1 += v14;
  v29 = v41;
LABEL_67:
  v6 = v54;
LABEL_30:
  free(v6);
  free(v29);
  if ((v10 & 0x80000000) == 0)
    close(v10);
  return v30;
}

uint64_t cmp_markers(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a2 < *a1;
}

off_t AAByteStreamProcess(AAByteStream istream, AAByteStream ostream)
{
  char *v4;
  char *v5;
  ssize_t v6;
  unint64_t v7;
  off_t v8;
  unint64_t v9;
  ssize_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  char v19;

  v4 = (char *)malloc(0x40000uLL);
  if (v4)
  {
    v5 = v4;
    v6 = AAByteStreamRead(istream, v4, 0x40000uLL);
    if ((v6 & 0x8000000000000000) == 0)
    {
      v7 = v6;
      v8 = 0;
      while (2)
      {
        if (!v7)
        {
          free(v5);
          return v8;
        }
        v9 = 0;
        v8 += v7;
        do
        {
          v10 = AAByteStreamWrite(ostream, &v5[v9], v7 - v9);
          if (v10 < 0)
          {
            AAByteStreamCancel(istream);
            v13 = "byte stream write error";
            v14 = 40;
            goto LABEL_14;
          }
          if (!v10)
          {
            v13 = "byte stream truncated write";
            v14 = 42;
            goto LABEL_14;
          }
          v9 += v10;
        }
        while (v9 < v7);
        v7 = AAByteStreamRead(istream, v5, 0x40000uLL);
        if ((v7 & 0x8000000000000000) == 0)
          continue;
        break;
      }
    }
    AAByteStreamCancel(ostream);
    v13 = "byte stream read error";
    v14 = 26;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c", (uint64_t)"AAByteStreamProcess", v14, 58, 0, v13, v11, v12, v19);
    free(v5);
  }
  else
  {
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c", (uint64_t)"AAByteStreamProcess", 18, 58, *v15, "malloc", v16, v17, v19);
  }
  return -1;
}

_QWORD *aaAssetDecryptionStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  __int16 v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  char v15;

  v6 = malloc(0x518uLL);
  v7 = v6;
  if (!v6)
  {
    v10 = 439;
LABEL_6:
    v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"aaAssetDecryptionStreamOpen", v10, 108, *v11, "malloc", v12, v13, v15);
    closeProc_2((uint64_t)v7);
    return 0;
  }
  memset_s(v6, 0x518uLL, 0, 0x518uLL);
  *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  v8 = malloc(0x38uLL);
  if (!v8)
  {
    v10 = 446;
    goto LABEL_6;
  }
  v9 = v8;
  memset_s(v8, 0x38uLL, 0, 0x38uLL);
  *v9 = v7;
  v9[1] = closeProc_2;
  v9[6] = closeWithStateProc_2;
  v9[2] = cancelProc_2;
  v9[3] = writeProc_1;
  return v9;
}

uint64_t closeProc_2(uint64_t result)
{
  void **v1;
  unsigned int v2;
  void *v3;

  if (result)
  {
    v1 = (void **)result;
    v2 = atomic_load((unsigned int *)(result + 24));
    v3 = (void *)(result + 1200);
    free(*(void **)(result + 1216));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[155]);
    memset_s(v1 + 153, 0x18uLL, 0, 0x18uLL);
    free(v1[158]);
    memset_s(v1 + 156, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x518uLL, 0, 0x518uLL);
    free(v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t closeWithStateProc_2(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  unsigned int v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _OWORD v45[5];
  __int128 v46;
  _OWORD v47[2];
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v5 = result;
    v6 = atomic_load((unsigned int *)(result + 24));
    v7 = v6 == 0;
    memset(v47, 0, sizeof(v47));
    v46 = 0u;
    memset(v45, 0, sizeof(v45));
    v8 = result + 240;
    aeaMagicInit(v45, (_DWORD *)(result + 240));
    aeaRootHeaderInit((unint64_t)v45 | 0xC, v8, v9, v10, v11, v12, v13, v14);
    *(_QWORD *)((char *)&v45[3] + 12) = *(_QWORD *)(v5 + 676);
    DWORD1(v45[4]) = *(_DWORD *)(v5 + 940);
    v17 = (uint64_t *)(v5 + 1200);
    v18 = (uint64_t *)(v5 + 1224);
    v19 = *(_QWORD *)(v5 + 1224);
    *((_QWORD *)&v45[4] + 1) = *(_QWORD *)(v5 + 1200);
    *(_QWORD *)&v46 = v19;
    v20 = (uint64_t *)(v5 + 1248);
    *((_QWORD *)&v46 + 1) = *(_QWORD *)(v5 + 1248);
    *(_QWORD *)&v47[0] = *(_QWORD *)(v5 + 1272);
    *(_OWORD *)((char *)v47 + 8) = *(_OWORD *)(v5 + 1280);
    *((_QWORD *)&v47[1] + 1) = *(_QWORD *)(v5 + 1296);
    if (!a2[3])
      goto LABEL_51;
    v21 = 0;
    v22 = v45;
    v23 = 128;
    while (1)
    {
      v24 = ((uint64_t (*)(_QWORD, _OWORD *, uint64_t))a2[3])(*a2, v22, v23);
      if (v24 < 1)
        break;
      v22 = (_OWORD *)((char *)v22 + v24);
      v21 += v24;
      v23 -= v24;
      if (!v23)
      {
        if (v21 < 0)
          goto LABEL_51;
        goto LABEL_9;
      }
    }
    if (v24 < 0)
      goto LABEL_51;
LABEL_9:
    if (!a2[3])
      goto LABEL_51;
    v25 = *(unsigned int *)(v5 + 680);
    if ((_DWORD)v25)
    {
      v26 = 0;
      v27 = v5 + 684;
      while (1)
      {
        v28 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v27, v25);
        if (v28 < 1)
          break;
        v27 += v28;
        v26 += v28;
        v25 -= v28;
        if (!v25)
        {
          if (v26 < 0)
            goto LABEL_51;
          goto LABEL_17;
        }
      }
      if (v28 < 0)
        goto LABEL_51;
LABEL_17:
      if (!a2[3])
        goto LABEL_51;
    }
    v29 = *(unsigned int *)(v5 + 940);
    if ((_DWORD)v29)
    {
      v30 = 0;
      v31 = v5 + 944;
      while (1)
      {
        v32 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v31, v29);
        if (v32 < 1)
          break;
        v31 += v32;
        v30 += v32;
        v29 -= v32;
        if (!v29)
        {
          if ((v30 & 0x8000000000000000) == 0)
            goto LABEL_25;
          goto LABEL_51;
        }
      }
      if (v32 < 0)
        goto LABEL_51;
    }
LABEL_25:
    if (!a2[3])
      goto LABEL_51;
    v33 = *v17;
    if (*v17)
    {
      v34 = 0;
      v35 = *(_QWORD *)(v5 + 1216);
      while (1)
      {
        v36 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v35, v33);
        if (v36 < 1)
          break;
        v35 += v36;
        v34 += v36;
        v33 -= v36;
        if (!v33)
          goto LABEL_32;
      }
      v34 = v36;
LABEL_32:
      if (v34 < 0 || !a2[3])
        goto LABEL_51;
    }
    v37 = *v18;
    if (*v18)
    {
      v38 = 0;
      v39 = *(_QWORD *)(v5 + 1240);
      while (1)
      {
        v40 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v39, v37);
        if (v40 < 1)
          break;
        v39 += v40;
        v38 += v40;
        v37 -= v40;
        if (!v37)
          goto LABEL_40;
      }
      v38 = v40;
LABEL_40:
      if (v38 < 0)
        goto LABEL_51;
    }
    if (!a2[3])
      goto LABEL_51;
    v41 = *v20;
    if (!*v20)
      goto LABEL_49;
    v42 = 0;
    v43 = *(_QWORD *)(v5 + 1264);
    while (1)
    {
      v44 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a2[3])(*a2, v43, v41);
      if (v44 < 1)
        break;
      v43 += v44;
      v42 += v44;
      v41 -= v44;
      if (!v41)
        goto LABEL_48;
    }
    v42 = v44;
LABEL_48:
    if (v42 < 0)
    {
LABEL_51:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"closeWithStateProc", 411, 108, 0, "write state", v15, v16, v45[0]);
      v7 = 0;
    }
    else
    {
LABEL_49:
      if (a3)
        *a3 = *(_QWORD *)(v5 + 1296);
    }
    free(*(void **)(v5 + 1216));
    memset_s((void *)(v5 + 1200), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1240));
    memset_s((void *)(v5 + 1224), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1264));
    memset_s((void *)(v5 + 1248), 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v5, 0x518uLL, 0, 0x518uLL);
    free((void *)v5);
    return (v7 - 1);
  }
  return result;
}

uint64_t writeProc_1(uint64_t result, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  int v13;
  uint64_t v14;
  size_t v15;
  size_t *v17;
  size_t v18;
  size_t v19;
  size_t v20;
  _DWORD *v21;
  uint64_t (*v22)(_QWORD, uint64_t);
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t (*v26)(_QWORD, uint64_t);
  uint64_t v27;
  char *v28;
  size_t v29;
  char *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t (*v34)(_DWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *);
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *);
  int v39;
  uint64_t (*v40)(char *, uint64_t, uint64_t, _OWORD *, char *, size_t);
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unsigned int *v48;
  unint64_t v49;
  BOOL v50;
  unsigned int v51;
  _BOOL4 v52;
  BOOL v53;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  size_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  size_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t (*v69)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *);
  int v70;
  uint64_t (*v71)(uint8_t *, size_t, _OWORD *, _OWORD *, _QWORD, _QWORD);
  uint64_t v72;
  uint64_t v73;
  size_t *v74;
  size_t v75;
  size_t v76;
  size_t v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  uint8_t *v81;
  void *v82;
  uint8_t *v83;
  uint64_t v84;
  int64_t v85;
  uint64_t v86;
  compression_algorithm v87;
  unint64_t v88;
  size_t v89;
  int v90;
  unint64_t v91;
  uint64_t (*v92)(_QWORD, size_t, unint64_t);
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t (*v96)(_OWORD *, _QWORD);
  char *v97;
  uint64_t v98;
  _OWORD *v99;
  const char *v100;
  __int16 v101;
  uint64_t (*v102)(uint64_t, uint64_t, size_t);
  _BOOL4 v103;
  void (*v105)(_QWORD);
  const char *v106;
  __int16 v107;
  const char *v108;
  __int16 v109;
  uint64_t (*v110)(uint64_t, _OWORD *);
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char v114;
  uint8_t *src_buffer;
  uint64_t v116;
  size_t *v117;
  size_t v118;
  _QWORD *v119;
  char *__dst;
  uint64_t v121;
  _DWORD *v122;
  uint64_t v123;
  _DWORD *v124;
  uint64_t v125;
  unsigned int *v126;
  size_t *v127;
  _OWORD v128[16];
  int v129;
  _OWORD v130[16];
  int v131;
  size_t __n[2];
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  int v148;
  _OWORD v149[16];
  int v150;
  _OWORD v151[16];
  int v152;
  _OWORD v153[16];
  int v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  int v171;
  _OWORD v172[17];
  _OWORD __s[17];
  uint64_t v174;

  v174 = *MEMORY[0x24BDAC8D0];
  v8 = (unsigned int *)(result + 24);
  if (atomic_load((unsigned int *)(result + 24)))
    return -1;
  v11 = result;
  v154 = 0;
  v12 = 0uLL;
  memset(v153, 0, sizeof(v153));
  v152 = 0;
  memset(v151, 0, sizeof(v151));
  v150 = 0;
  memset(v149, 0, sizeof(v149));
  v148 = 0;
  v146 = 0u;
  v147 = 0u;
  v144 = 0u;
  v145 = 0u;
  v142 = 0u;
  v143 = 0u;
  v140 = 0u;
  v141 = 0u;
  v138 = 0u;
  v139 = 0u;
  v136 = 0u;
  v137 = 0u;
  v134 = 0u;
  v135 = 0u;
  *(_OWORD *)__n = 0u;
  v133 = 0u;
  v131 = 0;
  memset(v130, 0, sizeof(v130));
  v129 = 0;
  memset(v128, 0, sizeof(v128));
  v13 = *(_DWORD *)(result + 676);
  if (v13 == 5)
  {
    v14 = 0;
    v10 = 0;
    goto LABEL_188;
  }
  v15 = a3;
  v10 = 0;
  v14 = 0;
  v17 = (size_t *)(result + 1200);
  v126 = (unsigned int *)(result + 32);
  v122 = (_DWORD *)(result + 680);
  v116 = result + 940;
  __dst = (char *)(result + 944);
  v119 = (_QWORD *)(result + 1248);
  v124 = (_DWORD *)(result + 416);
  v117 = (size_t *)(result + 1224);
  v121 = result + 312;
  v123 = result + 240;
  v127 = (size_t *)(result + 1200);
  while (2)
  {
    v18 = *v17;
    switch(v13)
    {
      case 0:
        if (v18 <= 0xB)
        {
          v19 = 12 - v18;
          goto LABEL_68;
        }
        DWORD2(__s[0]) = 0;
        *(_QWORD *)&__s[0] = 0;
        v64 = *(_QWORD *)(v11 + 1216);
        v65 = *(_DWORD *)(v64 + 8);
        *(_QWORD *)&__s[0] = *(_QWORD *)v64;
        DWORD2(__s[0]) = v65;
        if ((aeaContainerParamsInitWithMagic((int *)v123, __s, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0
          && (aeaCryptoInit((char *)v126, (unsigned int *)v123) & 0x80000000) == 0)
        {
          result = aeaContainerOffsetsInit(v121, (unsigned int *)v123, v126);
          if ((result & 0x80000000) == 0)
          {
            v13 = 1;
            *(_DWORD *)(v11 + 676) = 1;
            v12 = 0uLL;
            goto LABEL_125;
          }
        }
        v106 = "invalid AEA stream";
        v107 = 125;
        goto LABEL_186;
      case 1:
        v20 = *(_QWORD *)(v11 + 376);
        if (v18 < v20)
          goto LABEL_63;
        if (v18 != v20)
        {
          v106 = "invalid state";
          v107 = 138;
          goto LABEL_186;
        }
        v21 = *(_DWORD **)(v11 + 1216);
        v14 = aeaContextCreateWithPrologue(v21, *v17);
        if (!v14)
        {
          v106 = "invalid AEA prologue";
          v107 = 140;
          goto LABEL_186;
        }
        v22 = *(uint64_t (**)(_QWORD, uint64_t))(v11 + 16);
        if (v22 && (v22(*(_QWORD *)(v11 + 8), v14) & 0x80000000) != 0)
        {
          v106 = "user callback returned an error";
          v107 = 145;
          goto LABEL_186;
        }
        if ((aeaContextUnlock(v14, v123, v122, v153, 1, 0) & 0x80000000) != 0
          || (aeaCryptoInit((char *)v126, (unsigned int *)v123) & 0x80000000) != 0
          || (result = aeaContainerOffsetsInit(v121, (unsigned int *)v123, v126), (result & 0x80000000) != 0))
        {
          v106 = "unlocking AEA";
          v107 = 151;
          goto LABEL_186;
        }
        *(_OWORD *)v14 = *(_OWORD *)v123;
        v23 = *(_OWORD *)(v123 + 16);
        v24 = *(_OWORD *)(v123 + 32);
        v25 = *(_OWORD *)(v123 + 48);
        *(_QWORD *)(v14 + 64) = *(_QWORD *)(v123 + 64);
        *(_OWORD *)(v14 + 32) = v24;
        *(_OWORD *)(v14 + 48) = v25;
        *(_OWORD *)(v14 + 16) = v23;
        v26 = *(uint64_t (**)(_QWORD, uint64_t))(v11 + 16);
        if (v26)
        {
          result = v26(*(_QWORD *)(v11 + 8), v14);
          if ((result & 0x80000000) != 0)
          {
            v106 = "user callback returned an error";
            v107 = 156;
            goto LABEL_186;
          }
        }
        v27 = *(unsigned int *)(v11 + 44);
        if (v27 >= 0x101)
          goto LABEL_224;
        memcpy(__dst, (char *)v21 + *(_QWORD *)(v11 + 368), *(unsigned int *)(v11 + 44));
        *(_DWORD *)(v11 + 940) = v27;
        result = memset_s(&__dst[v27], 256 - v27, 0, 256 - v27);
        *(_QWORD *)(v11 + 1288) = (*(_QWORD *)(v11 + 272) + (unint64_t)*(unsigned int *)(v11 + 256) - 1)
                                / *(unsigned int *)(v11 + 256);
        *(_QWORD *)(v11 + 1280) = 0;
        *(_QWORD *)(v11 + 1200) = 0;
        *(_DWORD *)(v11 + 1272) = 0;
        v13 = 2;
LABEL_124:
        *(_DWORD *)(v11 + 676) = v13;
        v12 = 0uLL;
        v17 = v127;
        goto LABEL_125;
      case 2:
        v20 = *(_QWORD *)(v11 + 408);
        if (v18 < v20)
          goto LABEL_63;
        if (v18 != v20)
        {
          v106 = "invalid state";
          v107 = 177;
          goto LABEL_186;
        }
        v125 = v14;
        v28 = __src;
        v29 = v15;
        v30 = *(char **)(v11 + 1216);
        v31 = *(_QWORD *)(v11 + 392);
        v32 = *(_DWORD *)(v11 + 1272);
        *(_OWORD *)((char *)&__s[15] + 4) = v12;
        *(_OWORD *)((char *)&__s[13] + 8) = v12;
        *(_OWORD *)((char *)&__s[14] + 8) = v12;
        *(_OWORD *)((char *)&__s[11] + 8) = v12;
        *(_OWORD *)((char *)&__s[12] + 8) = v12;
        *(_OWORD *)((char *)&__s[9] + 8) = v12;
        *(_OWORD *)((char *)&__s[10] + 8) = v12;
        *(_OWORD *)((char *)&__s[7] + 8) = v12;
        *(_OWORD *)((char *)&__s[8] + 8) = v12;
        *(_OWORD *)((char *)&__s[5] + 8) = v12;
        *(_OWORD *)((char *)&__s[6] + 8) = v12;
        *(_OWORD *)((char *)&__s[3] + 8) = v12;
        *(_OWORD *)((char *)&__s[4] + 8) = v12;
        *(_OWORD *)((char *)&__s[1] + 8) = v12;
        *(_OWORD *)((char *)&__s[2] + 8) = v12;
        *(_OWORD *)((char *)__s + 8) = v12;
        LODWORD(v172[16]) = 0;
        v172[15] = v12;
        v172[14] = v12;
        v172[13] = v12;
        v172[12] = v12;
        v172[11] = v12;
        v172[10] = v12;
        v172[9] = v12;
        v172[8] = v12;
        v172[7] = v12;
        v172[6] = v12;
        v172[5] = v12;
        v172[4] = v12;
        v172[3] = v12;
        v172[2] = v12;
        v172[1] = v12;
        v172[0] = v12;
        WORD4(__s[0]) = 19267;
        *(_QWORD *)&__s[0] = 0x5F41454100000006;
        result = memset_s((char *)__s + 10, 0xFAuLL, 0, 0xFAuLL);
        v33 = LODWORD(__s[0]);
        if (LODWORD(__s[0]) >= 0xFD)
          goto LABEL_224;
        *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v32;
        LODWORD(__s[0]) = v33 + 4;
        memset_s((char *)__s + v33 + 8, 252 - v33, 0, 252 - v33);
        v34 = *(uint64_t (**)(_DWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        if (!v34 || !*v122)
        {
          v99 = __s;
LABEL_172:
          memset_s(v99, 0x104uLL, 0, 0x104uLL);
LABEL_173:
          v100 = "decrypting cluster header";
          v101 = 195;
LABEL_174:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", v101, 108, 0, v100, v36, v37, v114);
          v10 = -1;
          v14 = v125;
          goto LABEL_188;
        }
        v35 = v34(v124, *v126, v122, __s, v172);
        memset_s(__s, 0x104uLL, 0, 0x104uLL);
        if (v35 < 0)
          goto LABEL_173;
        memset((char *)v172 + 12, 0, 248);
        *(_QWORD *)((char *)v172 + 4) = 0x4B4548435F414541;
        LODWORD(v172[0]) = 8;
        memset_s((char *)v172 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(__s, 0, 260);
        v38 = *(uint64_t (**)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        if (!v38 || !*v124)
        {
          v99 = v172;
          goto LABEL_172;
        }
        v39 = v38(v151, *(unsigned int *)(v11 + 36), v124, v172, __s);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v39 < 0)
          goto LABEL_173;
        v40 = *(uint64_t (**)(char *, uint64_t, uint64_t, _OWORD *, char *, size_t))(v11 + 128);
        if (!v40)
          goto LABEL_173;
        if (*(_DWORD *)(v11 + 940) != *(_DWORD *)(v11 + 44))
          goto LABEL_173;
        result = v40(v30, v31, v116, v151, &v30[v31], v18 - v31);
        if ((result & 0x80000000) != 0)
          goto LABEL_173;
        *v119 = 0;
        if ((v18 & 0x8000000000000000) != 0)
          goto LABEL_217;
        v41 = *(_QWORD *)(v11 + 1256);
        v15 = v29;
        __src = v28;
        if (v41 >= v18)
          goto LABEL_118;
        do
        {
          while (!v41)
          {
            v41 = 0x4000;
            v43 = 0x4000;
            if (v18 <= 0x4000)
              goto LABEL_116;
          }
          v42 = v41 >> 1;
          if ((v41 & (v41 >> 1)) != 0)
            v42 = v41 & (v41 >> 1);
          v41 += v42;
        }
        while (v41 < v18);
        v43 = v41;
        if (v41 >= 0x2000000001)
        {
          *__error() = 12;
LABEL_216:
          *v119 = 0;
          v119[1] = 0;
          v119[2] = 0;
LABEL_217:
          v100 = "copy cluster header";
          v101 = 198;
          goto LABEL_174;
        }
LABEL_116:
        v78 = *(void **)(v11 + 1264);
        result = (uint64_t)realloc(v78, v43);
        if (!result)
        {
          free(v78);
          goto LABEL_216;
        }
        *(_QWORD *)(v11 + 1264) = result;
        *(_QWORD *)(v11 + 1256) = v43;
LABEL_118:
        v79 = *(_QWORD *)(v11 + 1264);
        if (v30)
        {
          result = (uint64_t)memcpy((void *)(v79 + *v119), v30, v18);
          v14 = v125;
        }
        else
        {
          v14 = v125;
          if (v79)
            result = memset_s((void *)(v79 + *v119), v18, 0, v18);
        }
        *(_QWORD *)(v11 + 1248) += v18;
        v80 = *(unsigned int *)(v11 + 44);
        if (v80 > 0x100)
        {
LABEL_224:
          __break(1u);
          return result;
        }
        memcpy(__dst, &v30[*(_QWORD *)(v11 + 392)], *(unsigned int *)(v11 + 44));
        *(_DWORD *)(v11 + 940) = v80;
        result = memset_s(&__dst[v80], 256 - v80, 0, 256 - v80);
        *(_QWORD *)(v11 + 1200) = 0;
        *(_DWORD *)(v11 + 1276) = 0;
        v13 = 3;
        goto LABEL_124;
      case 3:
        if (*(_QWORD *)(v11 + 1248) != *(_QWORD *)(v11 + 408))
        {
          v106 = "invalid state";
          v107 = 213;
          goto LABEL_186;
        }
        v118 = v15;
        v44 = *(_DWORD *)(v11 + 1276);
        if (v44 >= *(_DWORD *)(v11 + 260) || (v45 = *(_QWORD *)(v11 + 1280), v46 = *(_QWORD *)(v11 + 1288), v45 >= v46))
        {
          v106 = "invalid state";
          v107 = 218;
          goto LABEL_186;
        }
        v47 = *(unsigned int *)(v11 + 288);
        v48 = (unsigned int *)(*(_QWORD *)(v11 + 1264) + *(_QWORD *)(v11 + 384) + ((_DWORD)v47 + 8) * v44);
        v49 = *v48;
        v20 = v48[1];
        if ((_DWORD)v49)
          v50 = v20 > v49;
        else
          v50 = 1;
        if (v50
          || v20 < v49 && !*(_DWORD *)(v11 + 264)
          || ((v51 = *(_DWORD *)(v11 + 256), v45 + 1 != v46) ? (v52 = v49 != v51) : (v52 = 0),
              v49 <= v51 ? (v53 = !v52) : (v53 = 0),
              !v53))
        {
          v108 = "invalid segment sizes";
          v109 = 229;
          goto LABEL_158;
        }
        if (v18 < v20)
        {
          v15 = v118;
          v17 = v127;
LABEL_63:
          v19 = v20 - v18;
          if (v20 == v18)
            goto LABEL_125;
LABEL_68:
          if (!v15)
            goto LABEL_188;
          if (v19 >= v15)
            v57 = v15;
          else
            v57 = v19;
          v58 = v18 + v57;
          if (__CFADD__(v18, v57) || (v58 & 0x8000000000000000) != 0)
            goto LABEL_185;
          v59 = *(_QWORD *)(v11 + 1208);
          if (v59 < v58)
          {
            do
            {
              while (!v59)
              {
                v59 = 0x4000;
                v61 = 0x4000;
                if (v58 <= 0x4000)
                  goto LABEL_83;
              }
              v60 = v59 >> 1;
              if ((v59 & (v59 >> 1)) != 0)
                v60 = v59 & (v59 >> 1);
              v59 += v60;
            }
            while (v59 < v58);
            v61 = v59;
            if (v59 >= 0x2000000001)
            {
              *__error() = 12;
            }
            else
            {
LABEL_83:
              v62 = *(void **)(v11 + 1216);
              result = (uint64_t)realloc(v62, v61);
              if (result)
              {
                *(_QWORD *)(v11 + 1216) = result;
                *(_QWORD *)(v11 + 1208) = v61;
                v17 = v127;
                goto LABEL_85;
              }
              free(v62);
            }
            *v127 = 0;
            v127[1] = 0;
            v127[2] = 0;
LABEL_185:
            v106 = "malloc";
            v107 = 356;
            goto LABEL_186;
          }
LABEL_85:
          v63 = *(_QWORD *)(v11 + 1216);
          if (__src)
          {
            result = (uint64_t)memcpy((void *)(v63 + *v17), __src, v57);
          }
          else if (v63)
          {
            result = memset_s((void *)(v63 + *v17), v57, 0, v57);
          }
          *v17 += v57;
          v12 = 0uLL;
          if ((v57 & 0x8000000000000000) != 0)
            goto LABEL_185;
          v15 -= v57;
          __src += v57;
          v10 += v57;
          *(_QWORD *)(v11 + 1296) += v57;
          v13 = *(_DWORD *)(v11 + 676);
LABEL_125:
          if (v13 == 5)
            goto LABEL_188;
          continue;
        }
        if (v18 != v20)
        {
          v108 = "invalid state";
          v109 = 234;
LABEL_158:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", v109, 108, 0, v108, a7, a8, v114);
          v10 = -1;
          goto LABEL_188;
        }
        if (v47 >= 0x101)
          goto LABEL_224;
        src_buffer = *(uint8_t **)(v11 + 1216);
        __memcpy_chk();
        LODWORD(v149[0]) = v47;
        result = memset_s((char *)v149 + v47 + 4, 256 - v47, 0, 256 - v47);
        v66 = *(unsigned int *)(v11 + 44);
        if (v66 >= 0x101)
          goto LABEL_224;
        __memcpy_chk();
        LODWORD(v130[0]) = v66;
        memset_s((char *)v130 + v66 + 4, 256 - v66, 0, 256 - v66);
        v67 = *(_DWORD *)(v11 + 1276);
        memset((char *)v172 + 8, 0, 252);
        WORD4(v172[0]) = 19283;
        *(_QWORD *)&v172[0] = 0x5F41454100000006;
        result = memset_s((char *)v172 + 10, 0xFAuLL, 0, 0xFAuLL);
        v68 = LODWORD(v172[0]);
        if (LODWORD(v172[0]) >= 0xFD)
          goto LABEL_224;
        *(_DWORD *)((char *)v172 + LODWORD(v172[0]) + 4) = v67;
        LODWORD(v172[0]) = v68 + 4;
        memset_s((char *)v172 + v68 + 8, 252 - v68, 0, 252 - v68);
        memset(__s, 0, 260);
        v69 = *(uint64_t (**)(_OWORD *, _QWORD, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        v15 = v118;
        if (!v69 || !*v124)
        {
          memset_s(v172, 0x104uLL, 0, 0x104uLL);
LABEL_176:
          v106 = "decrypting segment";
          v107 = 248;
          goto LABEL_186;
        }
        v70 = v69(v151, *(unsigned int *)(v11 + 36), v124, v172, __s);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v70 < 0)
          goto LABEL_176;
        v71 = *(uint64_t (**)(uint8_t *, size_t, _OWORD *, _OWORD *, _QWORD, _QWORD))(v11 + 128);
        if (!v71
          || LODWORD(v130[0]) != *(_DWORD *)(v11 + 44)
          || (v71(src_buffer, v18, v130, v151, 0, 0) & 0x80000000) != 0)
        {
          goto LABEL_176;
        }
        v74 = v127;
        if (v20 < v49)
        {
          v75 = *(_QWORD *)(v11 + 1232);
          if (v75 >= v49)
          {
            v81 = *(uint8_t **)(v11 + 1240);
            goto LABEL_131;
          }
          do
          {
            while (!v75)
            {
              v75 = 0x4000;
              v77 = 0x4000;
              if (v49 <= 0x4000)
                goto LABEL_129;
            }
            v76 = v75 >> 1;
            if ((v75 & (v75 >> 1)) != 0)
              v76 = v75 & (v75 >> 1);
            v75 += v76;
          }
          while (v75 < v49);
          v77 = v75;
          if (v75 >= 0x2000000001)
          {
            *__error() = 12;
          }
          else
          {
LABEL_129:
            v82 = *(void **)(v11 + 1240);
            v83 = (uint8_t *)realloc(v82, v77);
            if (v83)
            {
              v81 = v83;
              *(_QWORD *)(v11 + 1240) = v83;
              *(_QWORD *)(v11 + 1232) = v77;
              v75 = v77;
              v15 = v118;
LABEL_131:
              *v117 = 0;
              if (v81)
              {
                v84 = *(unsigned int *)(v11 + 264);
                if ((_DWORD)v84 == 774)
                {
                  v85 = PCompressLZMADecode(v81, v75, src_buffer, v18);
                  v86 = v85 & ~(v85 >> 63);
                }
                else
                {
                  v87 = aeaEffectiveCompressionAlgorithm(v84);
                  LODWORD(v86) = compression_decode_buffer(v81, v75, src_buffer, v18, 0, v87);
                }
                if ((_DWORD)v86)
                {
                  v88 = *v117 + v86;
                  if (!__CFADD__(*v117, v86) && v88 <= *(_QWORD *)(v11 + 1232))
                    *v117 = v88;
                }
                v74 = v117;
                if ((_DWORD)v49 == (_DWORD)v86)
                  goto LABEL_140;
                v106 = "invalid compressed buffer";
                v107 = 271;
              }
              else
              {
                v106 = "invalid buffer";
                v107 = 258;
              }
LABEL_186:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", v107, 108, 0, v106, a7, a8, v114);
LABEL_187:
              v10 = -1;
              goto LABEL_188;
            }
            free(v82);
          }
          *v117 = 0;
          v117[1] = 0;
          v117[2] = 0;
          v106 = "malloc";
          v107 = 254;
          goto LABEL_186;
        }
LABEL_140:
        if (*v74 != v49)
        {
          v106 = "invalid raw size";
          v107 = 281;
          goto LABEL_186;
        }
        v89 = v74[2];
        v90 = *(_DWORD *)(v11 + 252);
        if (v90
          && ((aeaChecksum((uint64_t)__n, v90, (_QWORD *)v74[2], v49, v72, v73, a7, a8) & 0x80000000) != 0
           || LODWORD(__n[0]) != LODWORD(v149[0])
           || memcmp((char *)__n + 4, (char *)v149 + 4, LODWORD(__n[0]))))
        {
          v106 = "segment checksum verification";
          v107 = 287;
          goto LABEL_186;
        }
        v91 = 0;
        do
        {
          v92 = *(uint64_t (**)(_QWORD, size_t, unint64_t))(*(_QWORD *)v11 + 24);
          if (!v92 || (result = v92(**(_QWORD **)v11, v89 + v91, v49 - v91), v12 = 0uLL, result <= 0))
          {
            v106 = "invalid raw stream";
            v107 = 294;
            goto LABEL_186;
          }
          v91 += result;
        }
        while (v91 < v49);
        *(_QWORD *)(v11 + 1200) = 0;
        *(_QWORD *)(v11 + 1224) = 0;
        v93 = *(_DWORD *)(v11 + 1276) + 1;
        *(_DWORD *)(v11 + 1276) = v93;
        v94 = *(_QWORD *)(v11 + 1280) + 1;
        *(_QWORD *)(v11 + 1280) = v94;
        *(_DWORD *)(v11 + 676) = 3;
        if (v94 != *(_QWORD *)(v11 + 1288))
        {
          v17 = v127;
          if (v93 == *(_DWORD *)(v11 + 260))
          {
            ++*(_DWORD *)(v11 + 1272);
            v13 = 2;
LABEL_154:
            *(_DWORD *)(v11 + 676) = v13;
          }
          else
          {
            v13 = 3;
          }
          goto LABEL_125;
        }
        v17 = v127;
        if (*(_QWORD *)(v11 + 1296) != *(_QWORD *)(v11 + 280))
        {
          v13 = 4;
          goto LABEL_154;
        }
LABEL_223:
        *(_DWORD *)(v11 + 676) = 5;
LABEL_188:
        memset_s(v153, 0x104uLL, 0, 0x104uLL);
        memset_s(v151, 0x104uLL, 0, 0x104uLL);
        memset_s(v149, 0x104uLL, 0, 0x104uLL);
        memset_s(__n, 0x104uLL, 0, 0x104uLL);
        memset_s(v130, 0x104uLL, 0, 0x104uLL);
        memset_s(v128, 0x104uLL, 0, 0x104uLL);
        AEAContextDestroy((AEAContext)v14);
        if (v10 < 0)
        {
          do
          {
            if (__ldaxr(v8))
            {
              __clrex();
              return v10;
            }
          }
          while (__stlxr(1u, v8));
          v105 = *(void (**)(_QWORD))(*(_QWORD *)v11 + 16);
          if (v105)
            v105(**(_QWORD **)v11);
        }
        return v10;
      case 4:
        v54 = *(_QWORD *)(v11 + 1296);
        v55 = *(_QWORD *)(v11 + 280);
        v56 = v55 >= v54;
        v19 = v55 - v54;
        if (!v56)
        {
          v106 = "invalid padding state";
          v107 = 321;
          goto LABEL_186;
        }
        if (v19)
          goto LABEL_68;
        v95 = *(_QWORD *)(v11 + 1216);
        memset(__s, 0, 260);
        memset(v172, 0, 260);
        v171 = 0;
        v170 = 0u;
        v169 = 0u;
        v168 = 0u;
        v167 = 0u;
        v166 = 0u;
        v165 = 0u;
        v164 = 0u;
        v163 = 0u;
        v162 = 0u;
        v161 = 0u;
        v160 = 0u;
        v159 = 0u;
        v158 = 0u;
        v157 = 0u;
        v156 = 0u;
        v155 = 0u;
        if (*(_QWORD *)(v11 + 208)
          && (*(_DWORD *)((char *)v172 + 7) = 1262571615,
              *(_QWORD *)&v172[0] = 0x5F41454100000007,
              memset_s((char *)v172 + 11, 0xF9uLL, 0, 0xF9uLL),
              (v96 = *(uint64_t (**)(_OWORD *, _QWORD))(v11 + 104)) != 0)
          && *v122)
        {
          v97 = __dst;
          if ((v96(__s, *v126) & 0x80000000) == 0)
          {
            v98 = (*(uint64_t (**)(_OWORD *))(v11 + 208))(__s);
            goto LABEL_179;
          }
        }
        else
        {
          v97 = __dst;
        }
        v98 = 0;
LABEL_179:
        memset_s(__s, 0x104uLL, 0, 0x104uLL);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v98)
        {
          v102 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(v11 + 216);
          v103 = !v102 || (v102(v98, v95, v18) & 0x80000000) != 0;
          memset(__s, 0, 260);
          v110 = *(uint64_t (**)(uint64_t, _OWORD *))(v11 + 224);
          if (!v110)
            goto LABEL_206;
          if (*(_DWORD *)(v11 + 940) != *(_DWORD *)(v11 + 44))
            goto LABEL_206;
          if ((v110(v98, __s) & 0x80000000) != 0)
            goto LABEL_206;
          if (LODWORD(__s[0]) != *(_DWORD *)(v11 + 44))
            goto LABEL_206;
          if (LODWORD(__s[0]) < 8)
            goto LABEL_221;
          v111 = 0;
          v112 = 0;
          do
          {
            v112 |= *(_QWORD *)((char *)__s + v111 + 4) ^ *(_QWORD *)&v97[v111];
            v113 = v111 + 16;
            v111 += 8;
          }
          while (v113 <= LODWORD(__s[0]));
          if (!v112)
          {
LABEL_221:
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
            if (!v103)
            {
              *(_QWORD *)(v11 + 1200) = 0;
              goto LABEL_223;
            }
          }
          else
          {
LABEL_206:
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
          }
          v106 = "corrupted padding";
          v107 = 337;
        }
        else
        {
          v106 = "creating padding hash state";
          v107 = 334;
        }
        goto LABEL_186;
      default:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", 346, 108, 0, "invalid state %d", a7, a8, v13);
        goto LABEL_187;
    }
  }
}

_QWORD **cancelProc_2(_QWORD **result)
{
  unsigned int *v1;
  uint64_t (*v3)(_QWORD);

  v1 = (unsigned int *)(result + 3);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v1));
  v3 = (uint64_t (*)(_QWORD))(*result)[2];
  if (v3)
    return (_QWORD **)v3(**result);
  return result;
}

void (**aaAssetDecryptionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, _QWORD *a3))(void)
{
  void (**v5)(void);
  uint64_t v6;
  uint64_t v7;
  void (**v8)(void);
  void (*v9)(void);
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  const char *v30;
  __int16 v31;
  void (**result)(void);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  void *v48;
  void *v49;
  size_t v50;
  ssize_t v51;
  size_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  size_t v58;
  void *v59;
  size_t v60;
  ssize_t v61;
  size_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  size_t v68;
  void *v69;
  size_t v70;
  ssize_t v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t (*v75)(char *, _QWORD);
  int v76;
  _OWORD v77[3];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _OWORD v81[18];
  int v82;
  _QWORD __s[35];

  *(_QWORD *)((char *)&__s[32] + 4) = *MEMORY[0x24BDAC8D0];
  v5 = (void (**)(void))aaAssetDecryptionStreamOpen(a1, 0, 0);
  v8 = v5;
  if (!v5)
    return v8;
  v9 = *v5;
  memset(v81, 0, 32);
  v79 = 0u;
  v80 = 0u;
  v78 = 0u;
  memset(v77, 0, sizeof(v77));
  if (!*((_QWORD *)a2 + 2))
    goto LABEL_25;
  v10 = 0;
  v11 = v77;
  v12 = 128;
  do
  {
    v13 = (*((uint64_t (**)(_QWORD, _OWORD *, uint64_t))a2 + 2))(*(_QWORD *)a2, v11, v12);
    if (v13 < 0)
      goto LABEL_25;
    if (!v13)
      break;
    v11 = (_OWORD *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }
  while (v12);
  if (v10 != 128)
  {
LABEL_25:
    v30 = "truncated state";
    v31 = 480;
    goto LABEL_26;
  }
  *((_DWORD *)v9 + 169) = HIDWORD(v78);
  *((_QWORD *)v9 + 159) = *(_QWORD *)&v81[0];
  *((_OWORD *)v9 + 80) = *(_OWORD *)((char *)v81 + 8);
  *((_QWORD *)v9 + 162) = *((_QWORD *)&v81[1] + 1);
  if ((aeaContainerParamsInitWithMagic((int *)v9 + 60, v77, v14, v15, v16, v17, v6, v7) & 0x80000000) != 0
    || (aeaContainerParamsInitWithRootHeader((uint64_t)v9 + 240, (unint64_t)v77 | 0xC, v18, v19, v20, v21, v6, v7) & 0x80000000) != 0
    || (v22 = (_DWORD *)((char *)v9 + 32), (aeaCryptoInit((char *)v9 + 32, (unsigned int *)v9 + 60) & 0x80000000) != 0)
    || (aeaContainerOffsetsInit((uint64_t)v9 + 312, (unsigned int *)v9 + 60, (unsigned int *)v9 + 8) & 0x80000000) != 0)
  {
    v30 = "invalid state";
    v31 = 493;
    goto LABEL_26;
  }
  if (*((_DWORD *)v9 + 169) >= 6u)
  {
    v30 = "invalid state";
    v31 = 505;
    goto LABEL_26;
  }
  v23 = *((_QWORD *)v9 + 160);
  if (v23 > *((_QWORD *)v9 + 161)
    || (v24 = *((unsigned int *)v9 + 319), v25 = *((_DWORD *)v9 + 65), v24 > v25)
    || v24 + *((unsigned int *)v9 + 318) * (unint64_t)v25 != v23
    || (v26 = v79, v79 > *v22)
    || DWORD1(v79) > *((_DWORD *)v9 + 11)
    || ((v27 = *((unsigned int *)v9 + 64), v28 = *((_QWORD *)v9 + 51), v28 <= v27)
      ? (v29 = *((unsigned int *)v9 + 64))
      : (v29 = *((_QWORD *)v9 + 51)),
        *((_QWORD *)&v79 + 1) > v29 || (unint64_t)v80 > v27 || *((_QWORD *)&v80 + 1) > v28))
  {
    v30 = "invalid state";
    v31 = 515;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"aaAssetDecryptionStreamOpenWithState", v31, 108, 0, v30, v6, v7, v77[0]);
    if (*v8)
      v8[1]();
    free(v8);
    return 0;
  }
  if (!*((_QWORD *)a2 + 2))
    goto LABEL_135;
  if ((_DWORD)v79)
  {
    v33 = 0;
    v34 = (uint64_t)v9 + 684;
    do
    {
      v35 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v34, v26);
      if (v35 < 0)
        goto LABEL_135;
      if (!v35)
        break;
      v34 += v35;
      v33 += v35;
      v26 -= v35;
    }
    while (v26);
    if (v33 < 0 || !*((_QWORD *)a2 + 2))
      goto LABEL_135;
  }
  v36 = DWORD1(v79);
  if (DWORD1(v79))
  {
    v37 = 0;
    v38 = (uint64_t)v9 + 944;
    do
    {
      v39 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))a2 + 2))(*(_QWORD *)a2, v38, v36);
      if (v39 < 0)
        goto LABEL_135;
      if (!v39)
        break;
      v38 += v39;
      v37 += v39;
      v36 -= v39;
    }
    while (v36);
    if (v37 < 0)
    {
LABEL_135:
      v30 = "invalid state";
      v31 = 523;
      goto LABEL_26;
    }
  }
  v40 = *((_QWORD *)&v79 + 1);
  if (!*((_QWORD *)&v79 + 1))
    goto LABEL_72;
  v41 = 0;
  v42 = (unint64_t *)((char *)v9 + 1200);
  v43 = *((_QWORD *)v9 + 150);
  v44 = *((_QWORD *)v9 + 151);
  do
  {
    if (v43 == v44)
    {
      v45 = v44 + 0x40000;
      if ((uint64_t)(v44 + 0x40000) < 0)
        goto LABEL_135;
      if (v44 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v44)
          {
            v44 = 0x4000;
            v47 = 0x4000;
            if (v45 <= 0x4000)
              goto LABEL_61;
          }
          v46 = v44 >> 1;
          if ((v44 & (v44 >> 1)) != 0)
            v46 = v44 & (v44 >> 1);
          v44 += v46;
        }
        while (v44 < v45);
        v47 = v44;
        if (v44 >= 0x2000000001)
        {
LABEL_133:
          *__error() = 12;
        }
        else
        {
LABEL_61:
          v48 = (void *)*((_QWORD *)v9 + 152);
          v49 = realloc(v48, v47);
          if (v49)
          {
            *((_QWORD *)v9 + 152) = v49;
            *((_QWORD *)v9 + 151) = v47;
            v43 = *((_QWORD *)v9 + 150);
            goto LABEL_63;
          }
LABEL_132:
          free(v48);
        }
        *v42 = 0;
        v42[1] = 0;
        v42[2] = 0;
        goto LABEL_135;
      }
      v43 = v44;
    }
    v47 = v44;
LABEL_63:
    if (v47 - v43 >= v40)
      v50 = v40;
    else
      v50 = v47 - v43;
    v51 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 152) + v43), v50);
    if (v51 < 0)
      goto LABEL_135;
    if (!v51)
      break;
    v43 = *v42 + v51;
    if (__CFADD__(*v42, v51))
      goto LABEL_135;
    v44 = *((_QWORD *)v9 + 151);
    if (v43 > v44)
      goto LABEL_135;
    *v42 = v43;
    v41 += v51;
    v40 -= v51;
  }
  while (v40);
  if (v41 < 0)
    goto LABEL_135;
LABEL_72:
  v52 = v80;
  if (!(_QWORD)v80)
    goto LABEL_98;
  v53 = 0;
  v42 = (unint64_t *)((char *)v9 + 1224);
  v54 = *((_QWORD *)v9 + 153);
  v55 = *((_QWORD *)v9 + 154);
  while (2)
  {
    if (v54 != v55)
      goto LABEL_85;
    v56 = v55 + 0x40000;
    if ((uint64_t)(v55 + 0x40000) < 0)
      goto LABEL_135;
    if (v55 > 0xFFFFFFFFFFFBFFFFLL)
    {
      v54 = v55;
LABEL_85:
      v58 = v55;
      goto LABEL_89;
    }
    do
    {
      while (!v55)
      {
        v55 = 0x4000;
        v58 = 0x4000;
        if (v56 <= 0x4000)
          goto LABEL_87;
      }
      v57 = v55 >> 1;
      if ((v55 & (v55 >> 1)) != 0)
        v57 = v55 & (v55 >> 1);
      v55 += v57;
    }
    while (v55 < v56);
    v58 = v55;
    if (v55 >= 0x2000000001)
      goto LABEL_133;
LABEL_87:
    v48 = (void *)*((_QWORD *)v9 + 155);
    v59 = realloc(v48, v58);
    if (!v59)
      goto LABEL_132;
    *((_QWORD *)v9 + 155) = v59;
    *((_QWORD *)v9 + 154) = v58;
    v54 = *((_QWORD *)v9 + 153);
LABEL_89:
    if (v58 - v54 >= v52)
      v60 = v52;
    else
      v60 = v58 - v54;
    v61 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 155) + v54), v60);
    if (v61 < 0)
      goto LABEL_135;
    if (!v61)
      break;
    v54 = *v42 + v61;
    if (__CFADD__(*v42, v61))
      goto LABEL_135;
    v55 = *((_QWORD *)v9 + 154);
    if (v54 > v55)
      goto LABEL_135;
    *v42 = v54;
    v53 += v61;
    v52 -= v61;
    if (v52)
      continue;
    break;
  }
  if (v53 < 0)
    goto LABEL_135;
LABEL_98:
  v62 = *((_QWORD *)&v80 + 1);
  if (!*((_QWORD *)&v80 + 1))
    goto LABEL_124;
  v63 = 0;
  v42 = (unint64_t *)((char *)v9 + 1248);
  v64 = *((_QWORD *)v9 + 156);
  v65 = *((_QWORD *)v9 + 157);
  while (2)
  {
    if (v64 != v65)
    {
LABEL_111:
      v68 = v65;
      goto LABEL_115;
    }
    v66 = v65 + 0x40000;
    if ((uint64_t)(v65 + 0x40000) < 0)
      goto LABEL_135;
    if (v65 > 0xFFFFFFFFFFFBFFFFLL)
    {
      v64 = v65;
      goto LABEL_111;
    }
    do
    {
      while (!v65)
      {
        v65 = 0x4000;
        v68 = 0x4000;
        if (v66 <= 0x4000)
          goto LABEL_113;
      }
      v67 = v65 >> 1;
      if ((v65 & (v65 >> 1)) != 0)
        v67 = v65 & (v65 >> 1);
      v65 += v67;
    }
    while (v65 < v66);
    v68 = v65;
    if (v65 >= 0x2000000001)
      goto LABEL_133;
LABEL_113:
    v48 = (void *)*((_QWORD *)v9 + 158);
    v69 = realloc(v48, v68);
    if (!v69)
      goto LABEL_132;
    *((_QWORD *)v9 + 158) = v69;
    *((_QWORD *)v9 + 157) = v68;
    v64 = *((_QWORD *)v9 + 156);
LABEL_115:
    if (v68 - v64 >= v62)
      v70 = v62;
    else
      v70 = v68 - v64;
    v71 = AAByteStreamRead(a2, (void *)(*((_QWORD *)v9 + 158) + v64), v70);
    if (v71 < 0)
      goto LABEL_135;
    if (v71)
    {
      v64 = *v42 + v71;
      if (__CFADD__(*v42, v71))
        goto LABEL_135;
      v65 = *((_QWORD *)v9 + 157);
      if (v64 > v65)
        goto LABEL_135;
      *v42 = v64;
      v63 += v71;
      v62 -= v71;
      if (v62)
        continue;
    }
    break;
  }
  if (v63 < 0)
    goto LABEL_135;
LABEL_124:
  v72 = DWORD1(v79);
  *((_DWORD *)v9 + 170) = v79;
  *((_DWORD *)v9 + 235) = v72;
  v73 = *((_DWORD *)v9 + 318);
  memset(&__s[1], 0, 252);
  v82 = 0;
  LOWORD(__s[1]) = 19267;
  __s[0] = 0x5F41454100000006;
  memset(&v81[2], 0, 256);
  result = (void (**)(void))memset_s((char *)&__s[1] + 2, 0xFAuLL, 0, 0xFAuLL);
  v74 = LODWORD(__s[0]);
  if (LODWORD(__s[0]) >= 0xFD)
  {
    __break(1u);
    return result;
  }
  *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v73;
  LODWORD(__s[0]) = v74 + 4;
  memset_s((char *)&__s[1] + v74, 252 - v74, 0, 252 - v74);
  v75 = (uint64_t (*)(char *, _QWORD))*((_QWORD *)v9 + 13);
  if (!v75 || !*((_DWORD *)v9 + 170))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    goto LABEL_131;
  }
  v76 = v75((char *)v9 + 416, *v22);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v76 < 0)
  {
LABEL_131:
    v30 = "invalid state";
    v31 = 533;
    goto LABEL_26;
  }
  if (a3)
    *a3 = *((_QWORD *)v9 + 162);
  return v8;
}

uint64_t *AEADecryptAndExtractAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8)
{
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  const char *v25;
  __int16 v26;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  AAArchiveStream v32;
  char v33;
  stat v34;

  memset(&v34, 0, sizeof(v34));
  if (stat(a1, &v34) || (v34.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", 804, 115, 0, "Invalid/missing directory: %s", v16, v17, (char)a1);
    v21 = 0;
    v19 = 0;
  }
  else
  {
    v18 = malloc(0x9C8uLL);
    v19 = (uint64_t)v18;
    if (v18)
    {
      memset_s(v18, 0x9C8uLL, 0, 0x9C8uLL);
      v20 = (uint64_t *)malloc(0x38uLL);
      v21 = v20;
      if (v20)
      {
        memset_s(v20, 0x38uLL, 0, 0x38uLL);
        *(_QWORD *)v19 = a3;
        *(_QWORD *)(v19 + 8) = a4;
        *(_QWORD *)(v19 + 16) = a6;
        *(_QWORD *)(v19 + 24) = a5;
        *(_QWORD *)(v19 + 2128) = a7;
        *(_DWORD *)(v19 + 2136) = a8;
        *(_DWORD *)(v19 + 2120) = a7 >> 62;
        if (a2)
          *(_QWORD *)(v19 + 2296) = AAByteRangeClone(a2);
        if (realpath_DARWIN_EXTSN(a1, (char *)(v19 + 72)))
        {
          if ((concatPath((char *)(v19 + 1096), 0x400uLL, (char *)(v19 + 72), ".tmp_decrypt") & 0x80000000) != 0)
          {
            v33 = v19 + 72;
            v25 = "Path too long: %s";
            v26 = 822;
          }
          else if (stat((const char *)(v19 + 1096), &v34) || (v34.st_mode & 0xF000) == 0x4000)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2320), 0))
            {
              v24 = *__error();
              v25 = "pthread_mutex_init";
              v26 = 824;
LABEL_24:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", v26, 115, v24, v25, v22, v23, v33);
              goto LABEL_14;
            }
            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2408), 0))
            {
              v24 = *__error();
              v25 = "pthread_mutex_init";
              v26 = 825;
              goto LABEL_24;
            }
            v31 = AEADecryptAsyncStreamOpen(v19, (uint64_t)setupContext_0, (uint64_t)verifySegment_0, (uint64_t)processSegment_1, a7, a8);
            *(_QWORD *)(v19 + 48) = v31;
            if (v31)
            {
              v32 = AAExtractArchiveOutputStreamOpen(a1, (void *)v19, (AAEntryMessageProc)entryMessage, a7, a8);
              *(_QWORD *)(v19 + 64) = v32;
              if (v32)
              {
                *v21 = v19;
                v21[1] = (uint64_t)extractToDirAsyncClose;
                v21[2] = (uint64_t)extractToDirAsyncGetRange;
                v21[3] = (uint64_t)extractToDirAsyncProcess;
                v21[4] = (uint64_t)extractToDirAsyncCancel;
                return v21;
              }
              v25 = "creating extract stream";
              v26 = 832;
            }
            else
            {
              v25 = "creating decrypt stream";
              v26 = 830;
            }
          }
          else
          {
            v33 = v19 + 72;
            v25 = "Invalid tmp dir: %s";
            v26 = 823;
          }
        }
        else
        {
          v33 = (char)a1;
          v25 = "Invalid directory: %s";
          v26 = 821;
        }
        v24 = 0;
        goto LABEL_24;
      }
      v24 = *__error();
      v25 = "malloc";
      v26 = 810;
      goto LABEL_24;
    }
    v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", 808, 115, *v28, "malloc", v29, v30, v33);
    v21 = 0;
  }
LABEL_14:
  extractToDirAsyncClose(v19);
  free(v21);
  return 0;
}

uint64_t setupContext_0(uint64_t a1, AEAContext context)
{
  uint64_t (*v4)(_QWORD, AEAContext);
  uint64_t v5;
  uint64_t v6;
  uint64_t FieldUInt;
  size_t v8;
  const char *v9;
  __int16 v10;
  void **v11;
  uint64_t v12;
  void *v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  int v21;
  AAArchiveStream v23;
  uint64_t v24;
  uint64_t v25;
  void **RemainingRange;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  ssize_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  off_t st_size;
  int v74;
  int v75;
  FILE **v76;
  char *v77;
  uint64_t v78;
  int v79;
  size_t buf_size;
  stat v81;
  _BYTE __s2[128];
  stat buf;
  char __str[8];
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  memset(&v81, 0, sizeof(v81));
  v4 = *(uint64_t (**)(_QWORD, AEAContext))(a1 + 8);
  if (v4 && (v4(*(_QWORD *)a1, context) & 0x80000000) != 0)
  {
    v9 = "Client context callback returned an error";
    v10 = 459;
    goto LABEL_18;
  }
  if (*(_DWORD *)(a1 + 2140))
  {
    *(_QWORD *)(a1 + 2144) = AEAContextGetFieldUInt(context, 0xDu);
    FieldUInt = AEAContextGetFieldUInt(context, 4u);
    *(_QWORD *)(a1 + 2152) = FieldUInt;
    v8 = (FieldUInt + *(_QWORD *)(a1 + 2144) - 1) / FieldUInt;
    if (v8 >= 0xFFFFFFFF)
    {
      v9 = "Too many segments";
      v10 = 470;
LABEL_18:
      v21 = 0;
      goto LABEL_19;
    }
    *(_DWORD *)(a1 + 2384) = v8;
    if ((_DWORD)v8)
    {
      v13 = calloc(v8, 0x10uLL);
      *(_QWORD *)(a1 + 2392) = v13;
      if (!v13)
      {
        v21 = *__error();
        v9 = "malloc";
        v10 = 476;
LABEL_19:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"setupContext", v10, 115, v21, v9, v5, v6, (char)v77);
        v11 = 0;
LABEL_20:
        v12 = 0xFFFFFFFFLL;
        goto LABEL_21;
      }
      v14 = (*(_DWORD *)(a1 + 2384) + 1);
      *(_DWORD *)(a1 + 2160) = 0;
      *(_DWORD *)(a1 + 2164) = v14;
      v15 = calloc(v14, 4uLL);
      *(_QWORD *)(a1 + 2168) = v15;
      if (!v15)
      {
        v19 = "SharedArrayInit: malloc failed\n";
        v20 = 55;
        goto LABEL_17;
      }
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 2176), 0))
      {
        v19 = "SharedArrayInit: pthread_mutex_init failed\n";
        v20 = 56;
LABEL_17:
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v20, 0, v19, v16, v17, v18, (char)v77);
        v9 = "SharedArrayInit";
        v10 = 479;
        goto LABEL_18;
      }
      if (pthread_cond_init((pthread_cond_t *)(a1 + 2240), 0))
      {
        v19 = "SharedArrayInit: pthread_cond_init failed\n";
        v20 = 57;
        goto LABEL_17;
      }
      if (AASharedBufferPipeOpen((AAByteStream *)(a1 + 32), (AAByteStream *)(a1 + 40), *(_QWORD *)(a1 + 2152)) < 0)
      {
        v9 = "AASharedBufferPipeOpen";
        v10 = 482;
        goto LABEL_18;
      }
      v23 = AADecodeArchiveInputStreamOpen(*(AAByteStream *)(a1 + 40), 0, 0, *(_QWORD *)(a1 + 2128) | 0x100, *(_DWORD *)(a1 + 2136));
      *(_QWORD *)(a1 + 56) = v23;
      if (!v23)
      {
        v9 = "open decoder stream";
        v10 = 486;
        goto LABEL_18;
      }
      if ((createThread((pthread_t *)(a1 + 2488), (uint64_t)loadThread, a1, 0) & 0x80000000) != 0)
      {
        v9 = "createThread";
        v10 = 489;
        goto LABEL_18;
      }
      if ((createThread((pthread_t *)(a1 + 2496), (uint64_t)extractThread, a1, 0) & 0x80000000) != 0)
      {
        v9 = "createThread";
        v10 = 490;
        goto LABEL_18;
      }
    }
    if (stat((const char *)(a1 + 1096), &v81))
    {
      if (mkdir((const char *)(a1 + 1096), 0x1C0u))
      {
        v21 = *__error();
        LOBYTE(v77) = a1 + 72;
        v9 = "mkdir: %s";
        v10 = 500;
        goto LABEL_19;
      }
    }
    else if ((v81.st_mode & 0xF000) != 0x4000)
    {
      LOBYTE(v77) = a1 + 72;
      v9 = "Not a directory: %s";
      v10 = 496;
      goto LABEL_18;
    }
    buf_size = 0;
    memset(&buf, 0, 128);
    memset(__s2, 0, sizeof(__s2));
    if (AEAContextGetFieldBlob(context, 0x12u, 0, 0x80uLL, (uint8_t *)&buf, &buf_size) < 0)
    {
      v9 = "getting archive identifier";
      v10 = 511;
      goto LABEL_18;
    }
    if ((concatPath(__str, 0x400uLL, (char *)(a1 + 1096), "archive_id") & 0x80000000) != 0)
    {
      LOBYTE(v77) = a1 + 72;
      v9 = "Name too long: %s";
      v10 = 513;
      goto LABEL_18;
    }
    if (stat(__str, &v81))
    {
      if ((storeFileContents(__str, (uint64_t)&buf, buf_size) & 0x80000000) != 0)
      {
        v77 = __str;
        v9 = "storing archive id: %s";
        v10 = 529;
        goto LABEL_18;
      }
    }
    else
    {
      if ((v81.st_mode & 0xF000) != 0x8000 || v81.st_size != buf_size)
      {
        v9 = "Archive identifier size mismatch when resuming";
        v10 = 517;
        goto LABEL_18;
      }
      v36 = open(__str, 0);
      if (v36 < 0)
      {
        v21 = *__error();
        v77 = __str;
        v9 = "open: %s";
        v10 = 519;
        goto LABEL_19;
      }
      v37 = v36;
      v38 = read(v36, __s2, buf_size);
      close(v37);
      if (v38 != buf_size || memcmp(&buf, __s2, v38))
      {
        v9 = "Archive identifier value mismatch when resuming";
        v10 = 523;
        goto LABEL_18;
      }
    }
    v24 = *(_QWORD *)(a1 + 2296);
    if (!v24)
    {
      v39 = AAByteRangeCreate();
      *(_QWORD *)(a1 + 2296) = v39;
      if (!v39)
      {
        v9 = "AAByteRangeCreate";
        v10 = 537;
        goto LABEL_18;
      }
      if ((AAByteRangeAdd((uint64_t)v39, 0, *(_QWORD *)(a1 + 2144), v40, v41, v42, v5, v6) & 0x80000000) != 0)
      {
        v9 = "AAByteRangeAdd";
        v10 = 538;
        goto LABEL_18;
      }
      v24 = *(_QWORD *)(a1 + 2296);
    }
    v25 = AAByteRangeSizeAtOffset(v24, 0x7FFFFFFFFFFFFFFFLL);
    *(_QWORD *)(a1 + 2304) = v25 - AAByteRangeSizeAtOffset(v24, 0x8000000000000000);
    RemainingRange = loadRemainingRange(a1);
    if (RemainingRange)
    {
      v11 = RemainingRange;
      *(_QWORD *)__str = 0;
      *(_QWORD *)&buf.st_dev = 0;
      v27 = AAByteRangeFirst((uint64_t)RemainingRange, 0, __str, &buf);
      if ((v27 & 0x8000000000000000) == 0)
      {
        v30 = v27;
        while (1)
        {
          v31 = *(_QWORD *)__str;
          v32 = *(_QWORD *)&buf.st_dev;
          if (*(uint64_t *)__str <= *(uint64_t *)&buf.st_dev)
          {
            v34 = *(_QWORD *)(a1 + 2296);
            v35 = AAByteRangeSizeAtOffset(v34, *(uint64_t *)&buf.st_dev);
            v33 = v35 - AAByteRangeSizeAtOffset(v34, v31);
            v32 = *(_QWORD *)&buf.st_dev;
            v31 = *(_QWORD *)__str;
          }
          else
          {
            v33 = -1;
          }
          if (v33 < v32 - v31)
            break;
          v30 = AAByteRangeNext((uint64_t)v11, v30, __str, &buf);
          if (v30 < 0)
            goto LABEL_43;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"setupContext", 553, 115, 0, "Stored remaining range is not a subset of initial range", v28, v29, (char)v77);
        goto LABEL_20;
      }
LABEL_43:
      AAByteRangeDestroy(*(void ***)(a1 + 2296));
      *(_QWORD *)(a1 + 2296) = v11;
    }
    else
    {
      v11 = *(void ***)(a1 + 2296);
    }
    v43 = AAByteRangeClone((uint64_t)v11);
    *(_QWORD *)(a1 + 2472) = v43;
    if (!v43)
    {
      v9 = "AAByteRangeClone";
      v10 = 564;
      goto LABEL_18;
    }
    *(_DWORD *)(a1 + 2400) = -1;
    if (!*(_DWORD *)(a1 + 2384))
    {
      v12 = 0;
      if (!*(_DWORD *)(a1 + 2120))
      {
        v11 = 0;
        goto LABEL_21;
      }
      v62 = 0;
      v61 = 0;
      v60 = 0;
      v75 = 0;
      LODWORD(v58) = 0;
      goto LABEL_107;
    }
    v47 = 0;
    v48 = 0;
    while (1)
    {
      v49 = *(_QWORD *)(a1 + 2152);
      v50 = v49 * v48;
      v51 = v49 * v48 + v49;
      v52 = v51 >= *(_QWORD *)(a1 + 2144) ? *(_QWORD *)(a1 + 2144) : v51;
      if (v50 > v52)
        break;
      v54 = *(_QWORD *)(a1 + 2296);
      v55 = AAByteRangeSizeAtOffset(v54, v52);
      v56 = AAByteRangeSizeAtOffset(v54, v50);
      v53 = *(_QWORD *)(a1 + 2392);
      if (v55 != v56)
        goto LABEL_71;
      *(_DWORD *)(v53 + v47) = 3;
      unlinkTempSegment(a1, v48, v57, v44, v45, v46, v5, v6);
LABEL_73:
      ++v48;
      v58 = *(unsigned int *)(a1 + 2384);
      v47 += 16;
      if (v48 >= v58)
      {
        if (*(_DWORD *)(a1 + 2120))
        {
          if ((_DWORD)v58)
          {
            v59 = 0;
            v60 = 0;
            v61 = 0;
            v79 = 0;
            LODWORD(v12) = 0;
            v62 = 0;
            while (1)
            {
              v63 = *(_QWORD *)(a1 + 2152);
              v64 = v63 * v59;
              v65 = v63 * v59 + v63;
              v66 = v65 >= *(_QWORD *)(a1 + 2144) ? *(_QWORD *)(a1 + 2144) : v65;
              if (v64 > v66)
                break;
              v78 = v62;
              v68 = v61;
              v69 = v60;
              v70 = *(_QWORD *)(a1 + 2296);
              v71 = AAByteRangeSizeAtOffset(v70, v66);
              v72 = AAByteRangeSizeAtOffset(v70, v64);
              v67 = v71 - v72;
              if (v71 != v72)
              {
                v60 = v69;
                v61 = v68;
                v62 = v78;
LABEL_84:
                memset(&buf, 0, sizeof(buf));
                if (getTempSegmentFilename(a1, v59, __str, v44, v45, v46, v5, v6) || stat(__str, &buf))
                {
                  st_size = 0;
                }
                else if ((buf.st_mode & 0xF000) == 0x8000)
                {
                  st_size = buf.st_size;
                }
                else
                {
                  st_size = 0;
                }
                v62 += v67;
                LODWORD(v12) = v12 + 1;
                v61 = v61 - v64 + v66;
                if (st_size)
                  v74 = v79 + 1;
                else
                  v74 = v79;
                v79 = v74;
                v60 += st_size;
                goto LABEL_91;
              }
              v60 = v69;
              v61 = v68;
              v62 = v78;
LABEL_91:
              ++v59;
              v58 = *(unsigned int *)(a1 + 2384);
              if (v59 >= v58)
              {
                v75 = v79;
                goto LABEL_107;
              }
            }
            v67 = -1;
            goto LABEL_84;
          }
          v62 = 0;
          LODWORD(v12) = 0;
          v75 = 0;
          v61 = 0;
          v60 = 0;
LABEL_107:
          v76 = (FILE **)MEMORY[0x24BDAC8D8];
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u segments in archive\n", v58);
          fprintf(*v76, "%12u segments to process\n", v12);
          fprintf(*v76, "%12u segments in cache\n", v75);
          fprintf(*v76, "%12u segments to download\n", v12 - v75);
          fprintf(*v76, "%12llu bytes in archive\n", *(_QWORD *)(a1 + 2144));
          fprintf(*v76, "%12llu bytes to process\n", v62);
          fprintf(*v76, "%12llu segment bytes in cache\n", v60);
          fprintf(*v76, "%12llu segment bytes to download\n", v61 - v60);
        }
        v11 = 0;
        v12 = 0;
        goto LABEL_21;
      }
    }
    v53 = *(_QWORD *)(a1 + 2392);
LABEL_71:
    *(_DWORD *)(v53 + v47) = 0;
    if (*(_DWORD *)(a1 + 2400) == -1)
      *(_DWORD *)(a1 + 2400) = v48;
    goto LABEL_73;
  }
  v11 = 0;
  v12 = 0;
  *(_DWORD *)(a1 + 2140) = 1;
LABEL_21:
  AAByteRangeDestroy(v11);
  return v12;
}

uint64_t verifySegment_0(uint64_t a1, size_t __size, unint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  _QWORD *v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  int v16;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  _OWORD v37[16];
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v38 = 0;
  memset(v37, 0, sizeof(v37));
  v9 = *(_QWORD *)(a1 + 2152);
  v10 = a3 / v9;
  if (a3 / v9 * v9 != a3 || v10 >= *(unsigned int *)(a1 + 2384))
  {
    v36 = a3;
    v14 = "Invalid segment offset: %llu, size: %zu";
    v15 = 639;
    v16 = 0;
    goto LABEL_9;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 2392) + 16 * (a3 / v9)) != 3)
  {
    if (__size < 0x2000000001)
    {
      v21 = malloc(__size);
      if (v21)
      {
        v12 = v21;
        if ((int)loadTempSegment(a1, v10, (uint64_t)v21, __size, v22, v23, v24, v25) < 1
          || aeaChecksum((uint64_t)v37, a4, v12, __size, v28, v29, v30, v31)
          || LODWORD(v37[0]) != a6
          || memcmp((char *)v37 + 4, a5, a6))
        {
          unlinkTempSegment(a1, v10, v26, v27, v28, v29, v30, v31);
          v13 = 0;
          goto LABEL_11;
        }
        v32 = (unsigned int *)(a1 + 2288);
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 + 1, v32));
        if (*(_DWORD *)(a1 + 2120) >= 2u)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u: cached\n", v10);
        if ((notifySegmentAvailable(a1, v10, __size) & 0x80000000) == 0)
          goto LABEL_7;
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"verifySegment", 664, 115, 0, "pushSegmentData failed", v34, v35, v36);
LABEL_10:
        v13 = 0xFFFFFFFFLL;
        goto LABEL_11;
      }
    }
    else
    {
      *__error() = 12;
    }
    v16 = *__error();
    v14 = "malloc";
    v15 = 652;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"verifySegment", v15, 115, v16, v14, a7, a8, v36);
    v12 = 0;
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 2120) >= 2u)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u: not needed\n", v10);
  v12 = 0;
LABEL_7:
  v13 = 1;
LABEL_11:
  free(v12);
  return v13;
}

uint64_t processSegment_1(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  ssize_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v26;
  __int16 v27;
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  const char *v32;
  __int16 v33;
  char v34;
  stat v35;
  char __str[1024];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 2152);
  v10 = a3 / v9;
  if (a3 / v9 * v9 == a3 && v10 < *(unsigned int *)(a1 + 2384))
  {
    memset(&v35, 0, sizeof(v35));
    if ((getTempSegmentFilename(a1, v10, __str, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      v26 = "getSegmentFile";
      v27 = 127;
    }
    else
    {
      if (stat(__str, &v35))
      {
        v34 = 0x80;
        v15 = open(__str, 1537);
        if ((v15 & 0x80000000) == 0)
        {
          v16 = v15;
          if (!a2)
          {
LABEL_11:
            close(v16);
            v21 = (unsigned int *)(a1 + 2288);
            do
              v22 = __ldaxr(v21);
            while (__stlxr(v22 + 1, v21));
            if (*(_DWORD *)(a1 + 2120) >= 2u)
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u: stored in cache\n", v10);
            if ((notifySegmentAvailable(a1, v10, a2) & 0x80000000) == 0)
              return 0;
            v29 = "pushSegmentData";
            v30 = 695;
            goto LABEL_23;
          }
          v17 = 0;
          while (1)
          {
            v18 = write(v16, (const void *)(a4 + v17), a2 - v17);
            if (v18 < 0)
            {
              v31 = *__error();
              v32 = "write";
              v33 = 135;
              goto LABEL_30;
            }
            if (!v18)
              break;
            v17 += v18;
            if (v17 >= a2)
              goto LABEL_11;
          }
          v32 = "write returned 0";
          v33 = 136;
          v31 = 0;
LABEL_30:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeTempSegment", v33, 115, v31, v32, v19, v20, 128);
          close(v16);
LABEL_22:
          v29 = "storeTempSegment";
          v30 = 690;
LABEL_23:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"processSegment", v30, 115, 0, v29, v23, v24, v34);
          return 0xFFFFFFFFLL;
        }
        v28 = *__error();
        v26 = "tmp";
        v27 = 130;
LABEL_21:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeTempSegment", v27, 115, v28, v26, v13, v14, v34);
        goto LABEL_22;
      }
      v26 = "segment already in cache";
      v27 = 128;
    }
    v28 = 0;
    goto LABEL_21;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"processSegment", 686, 115, 0, "Invalid segment offset: %llu, size: %zu", a7, a8, a3);
  return 0xFFFFFFFFLL;
}

uint64_t entryMessage(_QWORD *a1, uint64_t a2, uint64_t a3, AAHeader header, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  int v10;
  uint64_t (*v12)(_QWORD, uint64_t, uint64_t, AAHeader);
  uint64_t v13;
  uint64_t v14;
  AAFieldKey v15;
  uint32_t KeyIndex;
  unsigned int FieldUInt;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  AAFieldKey v26;
  uint32_t v27;
  unsigned int v28;
  int v29;
  AAFieldKey v30;
  uint32_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t value;

  v9 = a3;
  v10 = a2;
  v12 = (uint64_t (*)(_QWORD, uint64_t, uint64_t, AAHeader))a1[3];
  if (!v12 || (v13 = v12(*a1, a2, a3, header), !(_DWORD)v13))
  {
    switch(v10)
    {
      case 20:
        v39 = -1;
        value = -1;
        v38 = -1;
        v15.ikey = 5265748;
        KeyIndex = AAHeaderGetKeyIndex(header, v15);
        v19 = 0;
        if ((KeyIndex & 0x80000000) == 0)
        {
          FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, &value);
          v18 = FieldUInt <= 1 ? 1 : FieldUInt;
          if (v18 > 0)
            v19 = 1;
        }
        v26.ikey = 5784649;
        v27 = AAHeaderGetKeyIndex(header, v26);
        if ((v27 & 0x80000000) != 0
          || ((v28 = AAHeaderGetFieldUInt(header, v27, &v39), v28 <= 1) ? (v29 = 1) : (v29 = v28), v29 <= 0))
        {
          v19 = 0;
        }
        v30.ikey = 5915721;
        v31 = AAHeaderGetKeyIndex(header, v30);
        if ((v31 & 0x80000000) != 0
          || ((v32 = AAHeaderGetFieldUInt(header, v31, &v38), v32 <= 1) ? (v33 = 1) : (v33 = v32), !v19 || v33 <= 0))
        {
          v24 = "Missing IDX,IDZ from archive decoder";
          v25 = 419;
        }
        else
        {
          v34 = AAByteRangeOffsetAtSize(a1[287], v39);
          v35 = AAByteRangeOffsetAtSize(a1[287], v38 + v39);
          if (value != 68 || (retireEntryRange((uint64_t)a1, v34, v35) & 0x80000000) == 0)
            return 0;
          v24 = "retire segment";
          v25 = 428;
        }
        break;
      case 21:
        if (header)
        {
          v20 = *(_QWORD *)header;
          v21 = *((_QWORD *)header + 1);
          v22 = AAByteRangeOffsetAtSize(a1[287], *(_QWORD *)header);
          v23 = AAByteRangeOffsetAtSize(a1[287], v21 + v20);
          if ((retireEntryRange((uint64_t)a1, v22, v23) & 0x80000000) == 0)
            return 0;
          v24 = "retire segment";
          v25 = 441;
        }
        else
        {
          v24 = "data not expected to be NULL";
          v25 = 432;
        }
        break;
      case 22:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"entryMessage", 407, 115, 0, "Extraction failed: %s", a7, a8, v9);
LABEL_37:
        v14 = 0xFFFFFFFFLL;
LABEL_38:
        cancelStreams(a1);
        return v14;
      default:
        return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"entryMessage", v25, 115, 0, v24, a7, a8, v37);
    goto LABEL_37;
  }
  v14 = v13;
  if ((v13 & 0x80000000) != 0)
    goto LABEL_38;
  return v14;
}

uint64_t extractToDirAsyncClose(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  _BOOL4 v3;
  _opaque_pthread_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  stat v11;

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 2292));
    v3 = v2 == 0;
    if (*(_QWORD *)(result + 2488))
    {
      SharedArrayEnqueue((unsigned int *)(result + 2160), -1);
      joinThread(*(_opaque_pthread_t **)(v1 + 2488));
    }
    AAByteStreamClose(*(AAByteStream *)(v1 + 32));
    v4 = *(_opaque_pthread_t **)(v1 + 2496);
    if (v4)
      joinThread(v4);
    AAByteStreamClose(*(AAByteStream *)(v1 + 40));
    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 64)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 725, 115, 0, "extract stream reported errors", v5, v6, v11.st_dev);
      v3 = 0;
    }
    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 56)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 726, 115, 0, "decode stream reported errors", v7, v8, v11.st_dev);
      v3 = 0;
    }
    if ((AAAsyncByteStreamClose(*(uint64_t (***)(void))(v1 + 48)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 727, 115, 0, "decrypt stream reported errors", v9, v10, v11.st_dev);
      v3 = 0;
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2320));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2408));
    free(*(void **)(v1 + 2392));
    if (*(_DWORD *)(v1 + 2384)
      && !pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2176))
      && !pthread_cond_destroy((pthread_cond_t *)(v1 + 2240)))
    {
      free(*(void **)(v1 + 2168));
    }
    AAByteRangeDestroy(*(void ***)(v1 + 2296));
    AAByteRangeDestroy(*(void ***)(v1 + 2472));
    if (v3)
    {
      memset(&v11, 0, sizeof(v11));
      if (!stat((const char *)(v1 + 1096), &v11) && (v11.st_mode & 0xF000) == 0x4000)
        removeTree((char *)(v1 + 1096));
    }
    free((void *)v1);
    if (v3)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t extractToDirAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  unsigned int *v6;
  uint64_t result;

  v6 = (unsigned int *)(a1 + 2312);
  if (atomic_load((unsigned int *)(a1 + 2312)))
  {
LABEL_2:
    while (!__ldaxr(v6))
    {
      if (!__stlxr(1u, v6))
        goto LABEL_6;
    }
    __clrex();
LABEL_6:
    if (*(_DWORD *)(a1 + 2400) < *(_DWORD *)(a1 + 2384))
      return 0;
    *a2 = 0;
    *a3 = 0;
    return 1;
  }
  result = AAAsyncByteStreamGetRange(*(_QWORD **)(a1 + 48), a2, a3);
  if ((int)result >= 1)
  {
    if ((_DWORD)result != 1 || !*a2)
      goto LABEL_2;
    return 1;
  }
  return result;
}

uint64_t extractToDirAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(_QWORD *)(a1 + 48), a2, a3, a4);
}

uint64_t AEADecryptAndExtractChunkAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, unint64_t a9, unsigned int a10)
{
  uint64_t *AsyncStreamOpen;
  uint64_t v13;
  uint64_t v14;
  char v16;

  AsyncStreamOpen = AEADecryptAndExtractAsyncStreamOpen(a1, a2, a3, a4, a5, a6, a9 | 0x200000000000000, a10);
  if (AsyncStreamOpen)
    return aaCompositeChunkAsyncStreamOpen((uint64_t)AsyncStreamOpen, a7, a8, a9, a10);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractChunkAsyncStreamOpen", 868, 115, 0, "AEADecryptAndExtractAsyncStreamOpen", v13, v14, v16);
  return 0;
}

uint64_t loadThread(uint64_t a1)
{
  size_t v2;
  char *v3;
  char *v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  ssize_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  char v43;
  char v44;
  int v45;
  unint64_t v46;
  unint64_t v47;

  v2 = *(_QWORD *)(a1 + 2152);
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_7:
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 331, 115, *v13, "malloc", v14, v15, v43);
    v4 = 0;
    goto LABEL_8;
  }
  v3 = (char *)malloc(v2);
  if (!v3)
    goto LABEL_7;
  v4 = v3;
  v5 = (pthread_mutex_t *)(a1 + 2176);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2176)))
  {
LABEL_5:
    v9 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v10 = 91;
LABEL_6:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v9, v6, v7, v8, v43);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 336, 115, 0, "SharedArrayDequeue", v11, v12, v44);
  }
  else
  {
    v17 = (unsigned int *)(a1 + 2288);
    while (1)
    {
      while (1)
      {
        v18 = *(_DWORD *)(a1 + 2160);
        if (v18)
          break;
        if (pthread_cond_wait((pthread_cond_t *)(a1 + 2240), v5))
        {
          v9 = "SharedArrayPop: pthread_cond_wait failed\n";
          v10 = 94;
          goto LABEL_6;
        }
      }
      v19 = v18 - 1;
      *(_DWORD *)(a1 + 2160) = v19;
      v20 = *(unsigned int *)(*(_QWORD *)(a1 + 2168) + 4 * v19);
      if (pthread_mutex_unlock(v5))
      {
        v9 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        v10 = 98;
        goto LABEL_6;
      }
      if ((_DWORD)v20 == -1)
        goto LABEL_9;
      if (v20 >= *(_DWORD *)(a1 + 2384))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 338, 115, 0, "Invalid segment index: %u", v7, v8, v20);
        goto LABEL_8;
      }
      if (*(_DWORD *)(a1 + 2120) >= 2u)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u: dequeue\n", v20);
      v22 = *(_QWORD *)(*(_QWORD *)(a1 + 2392) + 16 * v20 + 8);
      if ((int)loadTempSegment(a1, v20, (uint64_t)v4, v22, v21, v6, v7, v8) <= 0)
        break;
      v25 = *(_QWORD *)(a1 + 2152) * v20;
      v46 = 0;
      v47 = 0;
      v26 = AAByteRangeFirst(*(_QWORD *)(a1 + 2296), v25, &v47, &v46);
      if (v26 < 0)
      {
        v34 = 0;
      }
      else
      {
        v33 = v26;
        v45 = v20;
        v34 = 0;
        v35 = v25 + v22;
        v36 = 1;
        do
        {
          if (v47 <= v25)
            v37 = v25;
          else
            v37 = v47;
          if (v35 >= v46)
            v38 = v46;
          else
            v38 = v35;
          if (v37 >= v38)
            break;
          while (1)
          {
            v39 = AAByteStreamWrite(*(AAByteStream *)(a1 + 32), &v4[v37 - v25], v38 - v37);
            if (v39 < 0)
              break;
            v37 += v39;
            v34 += v39;
            if (v37 >= v38)
              goto LABEL_31;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 364, 115, 0, "SharedBufferWrite", v40, v41, v43);
          v36 = 0;
LABEL_31:
          v33 = AAByteRangeNext(*(_QWORD *)(a1 + 2296), v33, &v47, &v46);
        }
        while ((v33 & 0x8000000000000000) == 0);
        v5 = (pthread_mutex_t *)(a1 + 2176);
        LODWORD(v20) = v45;
        if (!v36)
          goto LABEL_8;
      }
      if (*(_DWORD *)(a1 + 2120) >= 2u)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Segment %u: %zu B processed\n", v20, v34);
      unlinkTempSegment(a1, v20, v27, v28, v29, v30, v31, v32);
      do
        v42 = __ldaxr(v17);
      while (__stlxr(v42 - 1, v17));
      if (pthread_mutex_lock(v5))
        goto LABEL_5;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 344, 115, 0, "loading segment: %u", v23, v24, v20);
  }
LABEL_8:
  cancelStreams((_QWORD *)a1);
LABEL_9:
  free(v4);
  return a1;
}

uint64_t extractThread(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  if (AAArchiveStreamProcess(*(AAArchiveStream *)(a1 + 56), *(AAArchiveStream *)(a1 + 64), 0, 0, *(_QWORD *)(a1 + 2128), *(_DWORD *)(a1 + 2136)) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractThread", 389, 115, 0, "AAByteStreamProcess reported an error", v2, v3, v5);
    cancelStreams((_QWORD *)a1);
  }
  return a1;
}

void **loadRemainingRange(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  void **v8;
  ssize_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  int v15;
  char v17;
  uint64_t v18[2];
  char v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  bzero(v19, 0x400uLL);
  if ((concatPath(v19, 0x400uLL, (char *)(a1 + 1096), "remaining") & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadRemainingRange", 254, 115, 0, "Name too long", v2, v3, v17);
    goto LABEL_9;
  }
  v4 = open(v19, 0);
  if (v4 < 0)
  {
LABEL_9:
    v8 = 0;
    goto LABEL_17;
  }
  v5 = v4;
  v8 = (void **)AAByteRangeCreate();
  if (v8)
  {
    while (1)
    {
      v9 = read(v5, v18, 0x10uLL);
      if (v9 < 0)
      {
        v15 = *__error();
        v13 = "read";
        v14 = 264;
        goto LABEL_16;
      }
      if (v9 != 16)
        break;
      if ((AAByteRangeAdd((uint64_t)v8, v18[0], v18[1], v10, v11, v12, v6, v7) & 0x80000000) != 0)
      {
        v13 = "AAByteRangeAdd";
        v14 = 267;
        goto LABEL_15;
      }
    }
    if (!v9)
    {
      close(v5);
      return v8;
    }
    v13 = "truncated remaining range file";
    v14 = 266;
  }
  else
  {
    v13 = "AAByteRangeCreate";
    v14 = 259;
  }
LABEL_15:
  v15 = 0;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadRemainingRange", v14, 115, v15, v13, v6, v7, v17);
  close(v5);
LABEL_17:
  AAByteRangeDestroy(v8);
  return 0;
}

uint64_t unlinkTempSegment(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char __str[1024];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  result = getTempSegmentFilename(a1, a2, __str, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
    return unlink(__str);
  return result;
}

uint64_t loadTempSegment(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  ssize_t v14;
  int v15;
  stat v17;
  char __str[1024];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  memset(&v17, 0, sizeof(v17));
  if ((getTempSegmentFilename(a1, a2, __str, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v10 = open(__str, 0, *(_OWORD *)&v17.st_dev, *(_OWORD *)&v17.st_uid, *(_OWORD *)&v17.st_atimespec, *(_OWORD *)&v17.st_mtimespec, *(_OWORD *)&v17.st_ctimespec, *(_OWORD *)&v17.st_birthtimespec);
  if (v10 < 0)
    return 0;
  v11 = v10;
  if (fstat(v10, &v17))
  {
    v12 = 0;
  }
  else if (v17.st_size == a4)
  {
    LODWORD(v12) = 0;
    v13 = 0;
    while (a4 > v13)
    {
      v14 = read(v11, (void *)(a3 + v13), a4 - v13);
      if (v14)
        v15 = 0;
      else
        v15 = 3;
      if (v14 < 0)
        v12 = 0xFFFFFFFFLL;
      else
        v12 = v12;
      v13 += v14 & ~(v14 >> 63);
      if (v14 < 0)
        v15 = 2;
      if (v15)
      {
        if (v15 == 2)
          goto LABEL_24;
        break;
      }
    }
    if (v13 == a4)
      v12 = 1;
    else
      v12 = 0xFFFFFFFFLL;
  }
  else
  {
    v12 = 0xFFFFFFFFLL;
  }
LABEL_24:
  close(v11);
  return v12;
}

void cancelStreams(_QWORD *a1)
{
  unsigned int *v2;
  AAArchiveStream_impl *v4;
  AAArchiveStream_impl *v5;
  _QWORD *v6;
  AAByteStream_impl *v7;
  AAByteStream_impl *v8;

  v2 = (unsigned int *)a1 + 573;
  do
  {
    if (__ldaxr(v2))
    {
      __clrex();
      return;
    }
  }
  while (__stlxr(1u, v2));
  v4 = (AAArchiveStream_impl *)a1[7];
  if (v4)
    AAArchiveStreamCancel(v4);
  v5 = (AAArchiveStream_impl *)a1[8];
  if (v5)
    AAArchiveStreamCancel(v5);
  v6 = (_QWORD *)a1[6];
  if (v6)
    AAAsyncByteStreamCancel(v6);
  v7 = (AAByteStream_impl *)a1[4];
  if (v7)
    AAByteStreamCancel(v7);
  v8 = (AAByteStream_impl *)a1[5];
  if (v8)
    AAByteStreamCancel(v8);
}

uint64_t getTempSegmentFilename(uint64_t a1, unsigned int a2, char *__str, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  char v11;

  if (*(_DWORD *)(a1 + 2384) <= a2)
  {
    v11 = a2;
    v8 = "Invalid segment index: %u";
    v9 = 113;
    goto LABEL_5;
  }
  if (snprintf(__str, 0x400uLL, "%s/%08x", (const char *)(a1 + 1096), a2) >= 0x400)
  {
    v8 = "Segment file name too long";
    v9 = 115;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"getTempSegmentFilename", v9, 115, 0, v8, a7, a8, v11);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t notifySegmentAvailable(uint64_t a1, unsigned int a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  FILE **v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;

  v6 = (pthread_mutex_t *)(a1 + 2320);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2320)))
  {
    v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 88, 115, *v9, "pthread_mutex_lock", v10, v11, v24);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 2392);
    if (*(_DWORD *)(v13 + 16 * a2))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 90, 115, 0, "Invalid segment state", v7, v8, v24);
      v14 = 0;
      v13 = *(_QWORD *)(a1 + 2392);
    }
    else
    {
      v14 = 1;
    }
    v15 = v13 + 16 * a2;
    *(_DWORD *)v15 = 1;
    *(_QWORD *)(v15 + 8) = a3;
    v16 = *(_DWORD *)(a1 + 2400);
    if (v16 < *(_DWORD *)(a1 + 2384))
    {
      v17 = (FILE **)MEMORY[0x24BDAC8D8];
      do
      {
        v18 = *(_DWORD *)(*(_QWORD *)(a1 + 2392) + 16 * v16);
        if (v18 == 1)
        {
          if (*(_DWORD *)(a1 + 2120) >= 2u)
          {
            fprintf(*v17, "Segment %u: in queue for processing\n", v16);
            v16 = *(_DWORD *)(a1 + 2400);
          }
          if ((SharedArrayEnqueue((unsigned int *)(a1 + 2160), v16) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 101, 115, 0, "SharedArrayEnqueue", v19, v20, v24);
            v14 = 0;
          }
        }
        else if (!v18)
        {
          break;
        }
        v16 = *(_DWORD *)(a1 + 2400) + 1;
        *(_DWORD *)(a1 + 2400) = v16;
      }
      while (v16 < *(_DWORD *)(a1 + 2384));
    }
    if (pthread_mutex_unlock(v6))
    {
      v21 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 106, 115, *v21, "pthread_mutex_unlock", v22, v23, v24);
      v14 = 0;
    }
    if (v14)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
}

uint64_t retireEntryRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  int v18;
  double RealTime;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  std::error_code *v32;
  int v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  const char *v51;
  __int16 v52;
  int *v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  std::__fs::filesystem::path __to;
  std::__fs::filesystem::path __from;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v6 = (pthread_mutex_t *)(a1 + 2408);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2408)))
  {
    v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 290, 115, *v12, "pthread_mutex_lock", v13, v14, v56);
    return 0xFFFFFFFFLL;
  }
  if ((AAByteRangeSub(*(unint64_t **)(a1 + 2472), a2, a3, v7, v8, v9, v10, v11) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 293, 115, 0, "AAByteRangeSub", v16, v17, v56);
    v18 = 0;
  }
  else
  {
    v18 = 1;
  }
  RealTime = getRealTime();
  if (RealTime <= *(double *)(a1 + 2480) + 1.0)
    goto LABEL_34;
  v57 = 0;
  v58 = 0;
  bzero(&__from, 0x400uLL);
  bzero(&__to, 0x400uLL);
  if ((concatPath((char *)&__from, 0x400uLL, (char *)(a1 + 1096), "remaining.tmp") & 0x80000000) != 0)
  {
    v35 = 203;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", v35, 115, 0, "Name too long", v20, v21, v56);
LABEL_24:
    v24 = 0;
    goto LABEL_25;
  }
  if ((concatPath((char *)&__to, 0x400uLL, (char *)(a1 + 1096), "remaining") & 0x80000000) != 0)
  {
    v35 = 204;
    goto LABEL_23;
  }
  v56 = 0x80;
  v22 = open((const char *)&__from, 1537);
  if (v22 < 0)
  {
    v47 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", 207, 115, v47, "open: %s", v48, v49, (char)&__to);
    goto LABEL_24;
  }
  v23 = v22;
  v24 = (char *)calloc(0x4000uLL, 8uLL);
  if (!v24)
  {
    v50 = *__error();
    v51 = "malloc";
    v52 = 210;
LABEL_45:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", v52, 115, v50, v51, v30, v31, 128);
    close(v23);
    goto LABEL_25;
  }
  v25 = AAByteRangeFirst(*(_QWORD *)(a1 + 2472), 0, &v58, &v57);
  if (v25 < 0)
    goto LABEL_19;
  v26 = v25;
  v27 = 0;
  do
  {
    v28 = v57;
    v29 = &v24[8 * v27];
    v27 += 2;
    *(_QWORD *)v29 = v58;
    *((_QWORD *)v29 + 1) = v28;
    if (v27 == 0x4000)
    {
      if (write(v23, v24, 0x20000uLL) != 0x20000)
      {
        v51 = "truncated write";
        v52 = 220;
LABEL_44:
        v50 = 0;
        goto LABEL_45;
      }
      v27 = 0;
    }
    v26 = AAByteRangeNext(*(_QWORD *)(a1 + 2472), v26, &v58, &v57);
  }
  while ((v26 & 0x8000000000000000) == 0);
  if (v27 && write(v23, v24, 8 * v27) != 8 * v27)
  {
    v51 = "truncated write";
    v52 = 229;
    goto LABEL_44;
  }
LABEL_19:
  close(v23);
  rename(&__from, &__to, v32);
  if ((v33 & 0x80000000) == 0)
  {
    v34 = 0;
    goto LABEL_26;
  }
  v53 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", 235, 115, *v53, "rename: %s", v54, v55, (char)&__to);
LABEL_25:
  v34 = 1;
LABEL_26:
  if (__from.__pn_.__r_.__value_.__s.__data_[0])
    unlink((const char *)&__from);
  free(v24);
  if (v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 300, 115, 0, "store remaining range", v36, v37, v56);
    v18 = 0;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    v38 = *(_QWORD *)(a1 + 2304);
    v39 = *(_QWORD *)(a1 + 2472);
    v40 = AAByteRangeSizeAtOffset(v39, 0x7FFFFFFFFFFFFFFFLL);
    v41 = AAByteRangeSizeAtOffset(v39, 0x8000000000000000);
    if (((*(uint64_t (**)(_QWORD, float))(a1 + 16))(*(_QWORD *)a1, (float)((float)(v38 - v40 + v41) * 100.0) / (float)v38) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 301, 115, 0, "User cancelled operation", v42, v43, v56);
      v18 = 0;
    }
  }
  *(double *)(a1 + 2480) = RealTime;
LABEL_34:
  if (pthread_mutex_unlock(v6))
  {
    v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 305, 115, *v44, "pthread_mutex_unlock", v45, v46, v56);
    v18 = 0;
  }
  if (v18)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aaEntryHashesInitWithFD(_BYTE *a1, unsigned int a2, int a3)
{
  void *v6;
  __int16 v7;
  char v8;
  ssize_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  CC_SHA512_CTX v16;
  CC_SHA512_CTX v17;
  CC_SHA256_CTX v18;
  CC_SHA1_CTX c;
  _QWORD v20[2];

  v6 = malloc(0x40000uLL);
  if (a1)
    memset_s(a1, 0xACuLL, 0, 0xACuLL);
  v20[0] = 0;
  v20[1] = 0;
  memset(&c, 0, sizeof(c));
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  memset(&v16, 0, sizeof(v16));
  v7 = *a1 & 0xE0 | ((unsigned __int16)a2 >> 11);
  *a1 = *a1 & 0xE0 | ((unsigned __int16)a2 >> 11);
  if (((a2 >> 11) & 1) != 0)
  {
    CC_CKSUM_Init((uint64_t)v20);
    LOBYTE(v7) = *a1;
    if ((*a1 & 2) == 0)
    {
LABEL_5:
      if ((v7 & 4) == 0)
        goto LABEL_6;
      goto LABEL_11;
    }
  }
  else if ((v7 & 2) == 0)
  {
    goto LABEL_5;
  }
  CC_SHA1_Deprecated_Init(&c);
  LOBYTE(v7) = *a1;
  if ((*a1 & 4) == 0)
  {
LABEL_6:
    if ((v7 & 8) == 0)
      goto LABEL_7;
LABEL_12:
    CC_SHA384_Init(&v17);
    if ((*a1 & 0x10) == 0)
      goto LABEL_26;
    goto LABEL_13;
  }
LABEL_11:
  CC_SHA256_Init(&v18);
  LOBYTE(v7) = *a1;
  if ((*a1 & 8) != 0)
    goto LABEL_12;
LABEL_7:
  if ((v7 & 0x10) == 0)
    goto LABEL_26;
LABEL_13:
  CC_SHA512_Init(&v16);
  while (1)
  {
LABEL_26:
    v9 = read(a3, v6, 0x40000uLL);
    v10 = v9;
    if (v9 < 0)
    {
      v11 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithFD", 36, 102, *v11, "read", v12, v13, v16.count[0]);
      goto LABEL_35;
    }
    if (!v9)
      break;
    v8 = *a1;
    if ((*a1 & 1) != 0)
    {
      CC_CKSUM_Update((uint64_t)v20, (unsigned __int8 *)v6, v9);
      v8 = *a1;
      if ((*a1 & 2) != 0)
        goto LABEL_22;
LABEL_17:
      if ((v8 & 4) == 0)
        goto LABEL_18;
LABEL_23:
      CC_SHA256_Update(&v18, v6, v10);
      v8 = *a1;
      if ((*a1 & 8) == 0)
        goto LABEL_19;
LABEL_24:
      CC_SHA384_Update(&v17, v6, v10);
      if ((*a1 & 0x10) != 0)
        goto LABEL_25;
    }
    else
    {
      if ((*a1 & 2) == 0)
        goto LABEL_17;
LABEL_22:
      CC_SHA1_Deprecated_Update(&c, v6, v10);
      v8 = *a1;
      if ((*a1 & 4) != 0)
        goto LABEL_23;
LABEL_18:
      if ((v8 & 8) != 0)
        goto LABEL_24;
LABEL_19:
      if ((v8 & 0x10) != 0)
LABEL_25:
        CC_SHA512_Update(&v16, v6, v10);
    }
  }
  v14 = *a1;
  if ((*a1 & 1) == 0)
  {
    if ((*a1 & 2) == 0)
      goto LABEL_30;
LABEL_37:
    CC_SHA1_Deprecated_Final(a1 + 8, &c);
    v14 = *a1;
    if ((*a1 & 4) != 0)
      goto LABEL_38;
LABEL_31:
    if ((v14 & 8) == 0)
      goto LABEL_32;
LABEL_39:
    CC_SHA384_Final(a1 + 60, &v17);
    if ((*a1 & 0x10) == 0)
      goto LABEL_34;
LABEL_33:
    CC_SHA512_Final(a1 + 108, &v16);
    goto LABEL_34;
  }
  CC_CKSUM_Final((unsigned int *)a1 + 1, (uint64_t)v20);
  v14 = *a1;
  if ((*a1 & 2) != 0)
    goto LABEL_37;
LABEL_30:
  if ((v14 & 4) == 0)
    goto LABEL_31;
LABEL_38:
  CC_SHA256_Final(a1 + 28, &v18);
  v14 = *a1;
  if ((*a1 & 8) != 0)
    goto LABEL_39;
LABEL_32:
  if ((v14 & 0x10) != 0)
    goto LABEL_33;
LABEL_34:
  v10 = 0;
LABEL_35:
  free(v6);
  return v10 >> 63;
}

uint64_t aaEntryHashesInitWithPath(_BYTE *a1, unsigned int a2, char *a3, const char *a4)
{
  char v4;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  int v16;
  char *v18;
  char v19[1024];
  uint64_t v20;

  v4 = (char)a4;
  v20 = *MEMORY[0x24BDAC8D0];
  if ((concatPath(v19, 0x400uLL, a3, a4) & 0x80000000) != 0)
  {
    v14 = "invalid path";
    v15 = 65;
    v16 = 0;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithPath", v15, 102, v16, v14, v7, v8, (char)v18);
    return 0xFFFFFFFFLL;
  }
  v9 = open(v19, 0);
  if (v9 < 0)
  {
    v16 = *__error();
    v18 = v19;
    v14 = "%s";
    v15 = 69;
    goto LABEL_7;
  }
  v10 = v9;
  if ((aaEntryHashesInitWithFD(a1, a2, v9) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithPath", 71, 102, 0, "computing hashes: %s", v11, v12, v4);
    v13 = 0xFFFFFFFFLL;
  }
  else
  {
    v13 = 0;
  }
  close(v10);
  return v13;
}

uint64_t aaEntryTypeFromMode(__int16 a1)
{
  unsigned int v1;

  v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6)
    return 0;
  else
    return dword_20A40C06C[v1 >> 12];
}

uint64_t aaEntryAttributesInitWithHeader(char *__s, char *a2, char *a3, AAHeader header)
{
  uint32_t FieldCount;
  uint32_t v9;
  uint32_t v10;
  AAFieldKey FieldKey;
  uint32_t v12;
  char v13;
  uint32_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint32_t v19;
  char v20;
  int v21;
  AAHashFunction hash_function;
  uint64_t v24;
  uint8_t v25[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (__s)
    memset_s(__s, 0x48uLL, 0, 0x48uLL);
  if (a2)
    memset_s(a2, 0x38uLL, 0, 0x38uLL);
  if (a3)
    memset_s(a3, 0xACuLL, 0, 0xACuLL);
  FieldCount = AAHeaderGetFieldCount(header);
  if (FieldCount)
  {
    v9 = FieldCount;
    v10 = 0;
    v24 = 0;
    hash_function = 0;
    do
    {
      FieldKey = AAHeaderGetFieldKey(header, v10);
      if (__s)
      {
        v12 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) <= 0x474C45)
        {
          if (v12 == 4475207)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 2u;
              *((_DWORD *)__s + 2) = v24;
            }
          }
          else if (v12 == 4475221)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 1u;
              *((_DWORD *)__s + 1) = v24;
            }
          }
          else if (v12 == 4476749 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            *__s |= 8u;
            *((_DWORD *)__s + 4) = v24;
          }
          goto LABEL_34;
        }
        if ((FieldKey.ikey & 0xFFFFFF) > 0x4D5442)
        {
          if (v12 != 5067843)
          {
            if (v12 != 5067853 || AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 56)) < 0)
              goto LABEL_34;
            v13 = *__s | 0x40;
            goto LABEL_31;
          }
          if ((AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 40)) & 0x80000000) == 0)
          {
            v13 = *__s | 0x20;
            goto LABEL_31;
          }
        }
        else
        {
          if (v12 == 4672582)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 4u;
              *((_DWORD *)__s + 3) = v24;
            }
            goto LABEL_34;
          }
          if (v12 == 5067842 && (AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 24)) & 0x80000000) == 0)
          {
            v13 = *__s | 0x10;
LABEL_31:
            *__s = v13;
          }
        }
      }
LABEL_34:
      if (a3)
      {
        v14 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) <= 0x334852)
        {
          if (v14 == 3229779)
          {
            if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
              && hash_function == 2)
            {
              *a3 |= 2u;
              *(_OWORD *)(a3 + 8) = *(_OWORD *)v25;
              *((_DWORD *)a3 + 6) = v26;
            }
          }
          else if (v14 == 3295315
                 && (AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
                 && hash_function == 3)
          {
            *a3 |= 4u;
            v15 = v26;
            *(_OWORD *)(a3 + 28) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 44) = v15;
          }
        }
        else if (v14 == 3360851)
        {
          if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 4)
          {
            *a3 |= 8u;
            v16 = v26;
            *(_OWORD *)(a3 + 60) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 76) = v16;
            *(_OWORD *)(a3 + 92) = v27;
          }
        }
        else if (v14 == 3491923)
        {
          if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 5)
          {
            *a3 |= 0x10u;
            v17 = v26;
            *(_OWORD *)(a3 + 108) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 124) = v17;
            v18 = v28;
            *(_OWORD *)(a3 + 140) = v27;
            *(_OWORD *)(a3 + 156) = v18;
          }
        }
        else if (v14 == 5458755
               && (AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
               && hash_function == 1)
        {
          *a3 |= 1u;
          *((_DWORD *)a3 + 1) = *(_DWORD *)v25;
        }
      }
      if (a2)
      {
        v19 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) > 0x524640)
        {
          if (v19 == 5391937)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *a2 |= 2u;
              *((_DWORD *)a2 + 3) = v24;
            }
          }
          else if (v19 == 5523009 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            *a2 |= 1u;
            *((_DWORD *)a2 + 2) = v24;
          }
        }
        else if (v19 == 4411984)
        {
          if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            v20 = *a2;
            *a2 |= 8u;
            switch(v24)
            {
              case 'A':
                v21 = 1;
                goto LABEL_77;
              case 'B':
                v21 = 2;
                goto LABEL_77;
              case 'C':
                v21 = 3;
                goto LABEL_77;
              case 'D':
                v21 = 4;
                goto LABEL_77;
              case 'E':
                v21 = 5;
                goto LABEL_77;
              case 'F':
                v21 = 6;
LABEL_77:
                *((_DWORD *)a2 + 1) = v21;
                break;
              default:
                *a2 = v20 & 0xF7;
                break;
            }
          }
        }
        else if (v19 == 4803654 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
        {
          *a2 |= 4u;
          *((_QWORD *)a2 + 2) = v24;
        }
      }
      ++v10;
    }
    while (v9 != v10);
  }
  return 0;
}

uint64_t aaEntryAttributesInitWithFD(char *a1, _BYTE *a2, _BYTE *a3, unsigned int a4, int a5)
{
  char v10;
  mode_t st_mode;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v17;
  const char *v18;
  __int16 v19;
  char v20;
  int v21;
  _QWORD v22[3];
  stat v23;
  _OWORD v24[4];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  memset(&v23, 0, sizeof(v23));
  if ((fstat(a5, &v23) & 0x80000000) == 0)
  {
    if (!a1)
      goto LABEL_15;
    memset_s(a1, 0x48uLL, 0, 0x48uLL);
    v10 = *a1 & 0x80 | a4 & 0x7F;
    *a1 = v10;
    if ((a4 & 1) != 0)
    {
      *((_DWORD *)a1 + 1) = v23.st_uid;
      if ((a4 & 2) == 0)
      {
LABEL_5:
        if ((a4 & 8) == 0)
          goto LABEL_6;
        goto LABEL_35;
      }
    }
    else if ((a4 & 2) == 0)
    {
      goto LABEL_5;
    }
    *((_DWORD *)a1 + 2) = v23.st_gid;
    if ((a4 & 8) == 0)
    {
LABEL_6:
      if ((a4 & 4) == 0)
      {
LABEL_8:
        if ((a4 & 0x30) != 0)
        {
          v22[1] = 0;
          v22[2] = 0;
          memset(v24, 0, sizeof(v24));
          v22[0] = 0x220000000005;
          if (!fgetattrlist(a5, v22, v24, 0x40uLL, 1u) && LODWORD(v24[0]) == 36)
          {
            *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)v24 + 4);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)&v24[1] + 4);
          }
          v10 = *a1;
        }
        if ((v10 & 0x40) != 0)
          *(timespec *)(a1 + 56) = v23.st_mtimespec;
LABEL_15:
        if (!a2)
        {
LABEL_28:
          if (!a3 || (v23.st_mode & 0xF000) != 0x8000 || (aaEntryHashesInitWithFD(a3, a4, a5) & 0x80000000) == 0)
            return 0;
          v18 = "computing file digests";
          v19 = 282;
          goto LABEL_39;
        }
        memset_s(a2, 0x38uLL, 0, 0x38uLL);
        *a2 = (a4 >> 7) & 0xF | *a2 & 0xF0;
        st_mode = v23.st_mode;
        v12 = v23.st_mode & 0xF000;
        if (v12 == 0x8000)
        {
          if (((a4 >> 7) & 2) == 0 && ((char)a4 & 0x80000000) == 0)
            goto LABEL_23;
          *(_QWORD *)&v24[0] = 0;
          v21 = 0;
          LODWORD(v22[0]) = 0;
          if ((ParallelCompressionAFSCGetMetadataFD(a5, (off_t *)v24, (unsigned int *)v22, &v21) & 0x80000000) != 0)
          {
            v18 = "querying AFSC metadata";
            v19 = 269;
LABEL_39:
            v17 = 0;
            goto LABEL_40;
          }
          v15 = v21;
          *((_DWORD *)a2 + 2) = v22[0];
          *((_DWORD *)a2 + 3) = v15;
          st_mode = v23.st_mode;
          v12 = v23.st_mode & 0xF000;
        }
        if (v12 != 0x8000 && v12 != 0x4000)
        {
LABEL_25:
          if ((st_mode & 0xF000) == 0x8000 && (*a2 & 8) != 0)
            *((_DWORD *)a2 + 1) = getFileProtectionClassFD(a5);
          goto LABEL_28;
        }
LABEL_23:
        if ((*a2 & 4) != 0)
        {
          *((_QWORD *)a2 + 2) = getFileAPFSInternalFlagsFD();
          st_mode = v23.st_mode;
        }
        goto LABEL_25;
      }
LABEL_7:
      *((_DWORD *)a1 + 3) = v23.st_flags;
      goto LABEL_8;
    }
LABEL_35:
    *((_DWORD *)a1 + 4) = v23.st_mode & 0xFFF;
    if ((a4 & 4) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v17 = *__error();
  v18 = "fstat";
  v19 = 209;
LABEL_40:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithFD", v19, 102, v17, v18, v13, v14, v20);
  return 0xFFFFFFFFLL;
}

uint64_t aaEntryAttributesInitWithPath(char *a1, _BYTE *a2, _BYTE *a3, unsigned int a4, char *__s, const char *a6)
{
  uint64_t v10;
  uint64_t v11;
  char v12;
  mode_t st_mode;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  const char *v21;
  __int16 v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  int v28;
  _QWORD v29[3];
  stat v30;
  _OWORD v31[4];
  char v32[2048];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  memset(&v30, 0, sizeof(v30));
  if ((concatPath(v32, 0x800uLL, __s, a6) & 0x80000000) != 0)
  {
    v21 = "invalid path";
    v22 = 301;
LABEL_36:
    v23 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", v22, 102, v23, v21, v10, v11, (char)v27);
    return 0xFFFFFFFFLL;
  }
  if (lstat(v32, &v30) < 0)
  {
    v23 = *__error();
    v27 = v32;
    v21 = "lstat: %s";
    v22 = 302;
    goto LABEL_38;
  }
  if (a1)
  {
    memset_s(a1, 0x48uLL, 0, 0x48uLL);
    v12 = *a1 & 0x80 | a4 & 0x7F;
    *a1 = v12;
    if ((a4 & 1) != 0)
    {
      *((_DWORD *)a1 + 1) = v30.st_uid;
      if ((a4 & 2) == 0)
      {
LABEL_6:
        if ((a4 & 8) == 0)
          goto LABEL_7;
        goto LABEL_42;
      }
    }
    else if ((a4 & 2) == 0)
    {
      goto LABEL_6;
    }
    *((_DWORD *)a1 + 2) = v30.st_gid;
    if ((a4 & 8) == 0)
    {
LABEL_7:
      if ((a4 & 4) == 0)
      {
LABEL_9:
        if ((a4 & 0x30) != 0)
        {
          v29[1] = 0;
          v29[2] = 0;
          memset(v31, 0, sizeof(v31));
          v29[0] = 0x220000000005;
          if (!getattrlist(v32, v29, v31, 0x40uLL, 1u) && LODWORD(v31[0]) == 36)
          {
            *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)v31 + 4);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)&v31[1] + 4);
          }
          v12 = *a1;
        }
        if ((v12 & 0x40) != 0)
          *(timespec *)(a1 + 56) = v30.st_mtimespec;
        goto LABEL_16;
      }
LABEL_8:
      *((_DWORD *)a1 + 3) = v30.st_flags;
      goto LABEL_9;
    }
LABEL_42:
    *((_DWORD *)a1 + 4) = v30.st_mode & 0xFFF;
    if ((a4 & 4) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
LABEL_16:
  if (!a2)
    goto LABEL_29;
  memset_s(a2, 0x38uLL, 0, 0x38uLL);
  *a2 = (a4 >> 7) & 0xF | *a2 & 0xF0;
  st_mode = v30.st_mode;
  v14 = v30.st_mode & 0xF000;
  if (v14 == 0x8000)
  {
    if (((a4 >> 7) & 2) == 0 && ((char)a4 & 0x80000000) == 0)
    {
LABEL_24:
      if ((*a2 & 4) != 0)
      {
        *((_QWORD *)a2 + 2) = getFileAPFSInternalFlagsFD();
        st_mode = v30.st_mode;
      }
      goto LABEL_26;
    }
    *(_QWORD *)&v31[0] = 0;
    v28 = 0;
    LODWORD(v29[0]) = 0;
    if ((ParallelCompressionAFSCGetMetadata(v32, (off_t *)v31, (unsigned int *)v29, &v28) & 0x80000000) == 0)
    {
      v15 = v28;
      *((_DWORD *)a2 + 2) = v29[0];
      *((_DWORD *)a2 + 3) = v15;
      st_mode = v30.st_mode;
      v14 = v30.st_mode & 0xF000;
      goto LABEL_22;
    }
    v27 = v32;
    v21 = "querying AFSC metadata: %s";
    v22 = 362;
    goto LABEL_36;
  }
LABEL_22:
  if (v14 == 0x8000 || v14 == 0x4000)
    goto LABEL_24;
LABEL_26:
  if ((st_mode & 0xF000) == 0x8000 && (*a2 & 8) != 0)
    *((_DWORD *)a2 + 1) = getFileProtectionClass(v32);
LABEL_29:
  if (!a3 || (v30.st_mode & 0xF000) != 0x8000)
    return 0;
  v16 = open(v32, 0);
  if (v16 < 0)
  {
    v24 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", 376, 102, v24, "open: %s", v25, v26, (char)v32);
  }
  else
  {
    v17 = v16;
    if ((aaEntryHashesInitWithFD(a3, a4, v16) & 0x80000000) == 0)
    {
      close(v17);
      return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", 377, 102, 0, "computing file digests: %s", v18, v19, (char)v32);
    close(v17);
  }
  return 0xFFFFFFFFLL;
}

uint64_t aaEntryAttributesApplyToPath(char *a1, char *__s, const char *a3, char a4)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int128 v14;
  uid_t v15;
  gid_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int *v21;
  int *v22;
  int *v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  __uint32_t v37;
  int *v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int *v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  int *v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  __uint32_t v54;
  int *v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  stat v60;
  _QWORD v61[3];
  _OWORD v62[8];
  char v63[2048];
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  if ((concatPath(v63, 0x800uLL, __s, a3) & 0x80000000) != 0)
  {
    v11 = "invalid path";
    v12 = 391;
    v13 = 0;
LABEL_33:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", v12, 102, v13, v11, v6, v7, (char)v59);
    return 0xFFFFFFFFLL;
  }
  v61[1] = 0;
  v61[2] = 0;
  v61[0] = 5;
  memset(v62, 0, sizeof(v62));
  v8 = *a1;
  if ((*a1 & 0x20) != 0)
  {
    v62[0] = *(_OWORD *)(a1 + 40);
    v9 = 512;
    HIDWORD(v61[0]) = 512;
    v10 = 16;
    if ((v8 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v9 = 0;
  v10 = 0;
  if ((*a1 & 0x40) != 0)
  {
LABEL_7:
    v14 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v62 + v10) = v14;
    *(_OWORD *)((char *)&v62[1] + v10) = v14;
    v10 |= 0x20u;
    v9 |= 0x1400u;
    HIDWORD(v61[0]) = v9;
  }
LABEL_8:
  if ((v8 & 0x10) == 0)
  {
    if ((v8 & 1) == 0)
      goto LABEL_10;
LABEL_13:
    v15 = *((_DWORD *)a1 + 1);
    if ((v8 & 2) != 0)
      goto LABEL_11;
    goto LABEL_14;
  }
  *(_OWORD *)((char *)v62 + v10) = *(_OWORD *)(a1 + 24);
  v10 += 16;
  HIDWORD(v61[0]) = v9 | 0x2000;
  if ((v8 & 1) != 0)
    goto LABEL_13;
LABEL_10:
  v15 = -1;
  if ((v8 & 2) != 0)
  {
LABEL_11:
    v16 = *((_DWORD *)a1 + 2);
    goto LABEL_15;
  }
LABEL_14:
  v16 = -1;
LABEL_15:
  memset(&v60, 0, sizeof(v60));
  if (lstat(v63, &v60) < 0)
  {
    v22 = __error();
    if ((a4 & 1) != 0 && *v22 == 13)
      return 0;
    v13 = *__error();
    v59 = v63;
    v11 = "%s";
    v12 = 443;
    goto LABEL_33;
  }
  v17 = v60.st_mode & 0xF000;
  if (v17 != 0x4000 && v17 != 40960 && v17 != 0x8000)
  {
    if ((*a1 & 1) != 0 && v15 != v60.st_uid || (v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
    {
      if (!lchown(v63, v15, v16) || (v24 = __error(), (a4 & 1) != 0) && *v24 == 1)
      {
        v20 = 1;
      }
      else
      {
        v42 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 494, 102, *v42, "%s", v43, v44, (char)v63);
        v20 = 0;
      }
    }
    if ((*a1 & 8) != 0)
    {
      v45 = *((_DWORD *)a1 + 4) & 0xFFF;
      if (v45 != (v60.st_mode & 0xFFF))
      {
        if (lchmod(v63, v45))
        {
          v46 = __error();
          if ((a4 & 1) == 0 || *v46 != 1)
          {
            v47 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 499, 102, *v47, "%s", v48, v49, (char)v63);
            v20 = 0;
          }
        }
      }
    }
    if (HIDWORD(v61[0]))
    {
      if (setattrlist(v63, v61, v62, v10, 1u))
      {
        v50 = __error();
        if ((a4 & 1) == 0 || *v50 != 1)
        {
          v51 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 512, 102, *v51, "%s", v52, v53, (char)v63);
          v20 = 0;
        }
      }
    }
    if ((*a1 & 4) != 0)
    {
      v54 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
      if (v60.st_flags != v54)
      {
        if (lchflags(v63, v54))
        {
          v55 = __error();
          if ((a4 & 1) == 0 || *v55 != 1)
          {
            v56 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 526, 102, *v56, "%s", v57, v58, (char)v63);
            v20 = 0;
          }
        }
      }
    }
    goto LABEL_61;
  }
  v18 = open(v63, 0x200000);
  if (v18 < 0)
  {
    v13 = *__error();
    v59 = v63;
    v11 = "%s";
    v12 = 456;
    goto LABEL_33;
  }
  v19 = v18;
  if ((*a1 & 1) != 0 && v15 != v60.st_uid || (v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
  {
    if (!fchown(v18, v15, v16) || (v21 = __error(), (a4 & 1) != 0) && *v21 == 1)
    {
      v20 = 1;
    }
    else
    {
      v25 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 460, 102, *v25, "%s", v26, v27, (char)v63);
      v20 = 0;
    }
  }
  if ((*a1 & 8) != 0)
  {
    v28 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v28 != (v60.st_mode & 0xFFF))
    {
      if (fchmod(v19, v28))
      {
        v29 = __error();
        if ((a4 & 1) == 0 || *v29 != 1)
        {
          v30 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 464, 102, *v30, "%s", v31, v32, (char)v63);
          v20 = 0;
        }
      }
    }
  }
  if (HIDWORD(v61[0]))
  {
    if (fsetattrlist(v19, v61, v62, v10, 1u))
    {
      v33 = __error();
      if ((a4 & 1) == 0 || *v33 != 1)
      {
        v34 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 469, 102, *v34, "%s", v35, v36, (char)v63);
        v20 = 0;
      }
    }
  }
  if ((*a1 & 4) != 0)
  {
    v37 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
    if (v60.st_flags != v37)
    {
      if (fchflags(v19, v37))
      {
        v38 = __error();
        if ((a4 & 1) == 0 || *v38 != 1)
        {
          v39 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 483, 102, *v39, "%s", v40, v41, (char)v63);
          v20 = 0;
        }
      }
    }
  }
  close(v19);
LABEL_61:
  if (v20)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aaEntryAttributesApplyToFD(char *a1, int a2, char a3)
{
  char v6;
  int v7;
  unsigned int v8;
  int *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  __int128 v14;
  unsigned int v15;
  __int128 v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int *v23;
  int *v24;
  uid_t v25;
  gid_t v26;
  int v27;
  int *v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int *v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  __uint32_t v43;
  int *v44;
  int *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[3];
  _QWORD v49[3];
  stat v50;
  timeval v51;
  __darwin_time_t v52;
  int v53;
  _OWORD v54[16];
  _OWORD v55[16];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  memset(&v50, 0, sizeof(v50));
  if (fstat(a2, &v50) < 0)
  {
    v9 = __error();
    if ((a3 & 1) == 0 || *v9 != 13)
    {
      v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 545, 102, *v10, "fstat", v11, v12, v48[0]);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  v49[1] = 0;
  v49[2] = 0;
  v49[0] = 5;
  memset(v55, 0, sizeof(v55));
  v48[1] = 0;
  v48[2] = 0;
  v48[0] = 5;
  memset(v54, 0, sizeof(v54));
  v6 = *a1;
  if ((*a1 & 0x20) != 0)
  {
    v55[0] = *(_OWORD *)(a1 + 40);
    v7 = 512;
    HIDWORD(v49[0]) = 512;
    v54[0] = v55[0];
    HIDWORD(v48[0]) = 512;
    v8 = 16;
    if ((v6 & 0x40) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  v7 = 0;
  v8 = 0;
  if ((*a1 & 0x40) != 0)
  {
LABEL_9:
    v14 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v55 + v8) = v14;
    v15 = v8 + 16;
    *(_OWORD *)((char *)v55 + v15) = v14;
    *(_OWORD *)((char *)v54 + v8) = v14;
    v8 |= 0x20u;
    v7 |= 0x1400u;
    HIDWORD(v49[0]) = v7;
    *(_OWORD *)((char *)v54 + v15) = v14;
    HIDWORD(v48[0]) = v7;
  }
LABEL_10:
  if ((v6 & 0x10) != 0)
  {
    v16 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)((char *)v55 + v8) = v16;
    *(_OWORD *)((char *)v54 + v8) = v16;
    v8 += 16;
    v7 |= 0x2000u;
    HIDWORD(v49[0]) = v7;
    HIDWORD(v48[0]) = v7;
  }
  v17 = v7;
  v18 = v8;
  if ((v6 & 1) != 0)
  {
    v19 = *((_DWORD *)a1 + 1);
    v17 = v7;
    v18 = v8;
    if (v19 != v50.st_uid)
    {
      *(_DWORD *)((char *)v55 + v8) = v19;
      v18 = v8 + 4;
      v17 = v7 | 0x8000;
      HIDWORD(v49[0]) = v7 | 0x8000;
    }
  }
  if ((v6 & 2) != 0)
  {
    v20 = *((_DWORD *)a1 + 2);
    if (v20 != v50.st_gid)
    {
      *(_DWORD *)((char *)v55 + v18) = v20;
      v18 += 4;
      v17 |= 0x10000u;
      HIDWORD(v49[0]) = v17;
    }
  }
  if ((v6 & 8) != 0)
  {
    v21 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v21 != (v50.st_mode & 0xFFF))
    {
      *(_DWORD *)((char *)v55 + v18) = v21;
      v18 += 4;
      v17 |= 0x20000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v21;
      v8 += 4;
      v7 |= 0x20000u;
      HIDWORD(v48[0]) = v7;
    }
  }
  if ((v6 & 4) != 0)
  {
    v22 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
    if (v22 != v50.st_flags)
    {
      *(_DWORD *)((char *)v55 + v18) = v22;
      v18 += 4;
      v17 |= 0x40000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v22;
      v8 += 4;
      HIDWORD(v48[0]) = v7 | 0x40000;
    }
  }
  if (!v17)
    return 0;
  result = fsetattrlist(a2, v49, v55, v18, 1u);
  if ((_DWORD)result)
  {
    v23 = __error();
    if ((a3 & 1) == 0 || *v23 != 1 || (result = fsetattrlist(a2, v48, v54, v8, 1u), (_DWORD)result))
    {
      v24 = __error();
      if ((a3 & 1) != 0 && *v24 == 1)
        return 0;
      if ((*a1 & 1) != 0)
      {
        v25 = *((_DWORD *)a1 + 1);
        if ((*a1 & 2) != 0)
        {
LABEL_35:
          v26 = *((_DWORD *)a1 + 2);
          if ((*a1 & 1) == 0)
            goto LABEL_40;
          goto LABEL_39;
        }
      }
      else
      {
        v25 = -1;
        if ((*a1 & 2) != 0)
          goto LABEL_35;
      }
      v26 = -1;
      if ((*a1 & 1) == 0)
      {
LABEL_40:
        v27 = 1;
        if ((*a1 & 2) == 0 || v26 == v50.st_gid)
        {
LABEL_47:
          if ((*a1 & 8) != 0)
          {
            v32 = *((_DWORD *)a1 + 4) & 0xFFF;
            if (v32 != (v50.st_mode & 0xFFF))
            {
              if (fchmod(a2, v32))
              {
                v33 = __error();
                if ((a3 & 1) == 0 || *v33 != 1)
                {
                  v34 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 659, 102, *v34, "fchmod", v35, v36, v48[0]);
                  v27 = 0;
                }
              }
            }
          }
          v37 = *a1;
          if ((*a1 & 0x40) != 0)
          {
            v38 = *((_QWORD *)a1 + 8);
            v52 = *((_QWORD *)a1 + 7);
            v51.tv_sec = v52;
            v53 = (int)v38 / 1000;
            v51.tv_usec = (int)v38 / 1000;
            if (futimes(a2, &v51))
            {
              v39 = __error();
              if ((a3 & 1) == 0 || *v39 != 1)
              {
                v40 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 667, 102, *v40, "futimes", v41, v42, v48[0]);
                v27 = 0;
              }
            }
            v37 = *a1;
          }
          if ((v37 & 4) != 0)
          {
            v43 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
            if (v50.st_flags != v43)
            {
              if (fchflags(a2, v43))
              {
                v44 = __error();
                if ((a3 & 1) == 0 || *v44 != 1)
                {
                  v45 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 681, 102, *v45, "fchflags", v46, v47, v48[0]);
                  v27 = 0;
                }
              }
            }
          }
          if (v27)
            return 0;
          else
            return 0xFFFFFFFFLL;
        }
LABEL_42:
        if (!fchown(a2, v25, v26) || (v28 = __error(), (a3 & 1) != 0) && *v28 == 1)
        {
          v27 = 1;
        }
        else
        {
          v29 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 655, 102, *v29, "fchown", v30, v31, v48[0]);
          v27 = 0;
        }
        goto LABEL_47;
      }
LABEL_39:
      if (v25 != v50.st_uid)
        goto LABEL_42;
      goto LABEL_40;
    }
  }
  return result;
}

uint64_t aaEntryAttributesCmp(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((a3 & 1) != 0 && (*(_BYTE *)a1 & 1) != 0)
  {
    v3 = *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4);
    if ((a3 & 2) == 0)
      goto LABEL_9;
  }
  else
  {
    v3 = 0;
    if ((a3 & 2) == 0)
      goto LABEL_9;
  }
  if ((*(_BYTE *)a1 & 2) != 0 && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    v3 |= 2u;
LABEL_9:
  if ((a3 & 8) != 0 && (*(_BYTE *)a1 & 8) != 0 && *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
    v3 |= 8u;
  if ((a3 & 4) != 0 && (*(_BYTE *)a1 & 4) != 0 && *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12))
    v3 |= 4u;
  if ((a3 & 0x40) != 0 && (*(_BYTE *)a1 & 0x40) != 0)
  {
    v4 = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a2 + 56);
    if ((unint64_t)(v4 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(_QWORD *)(a1 + 64) + 1000000000 * v4 - *(_QWORD *)(a2 + 64) + 2000) >= 0xFA1)
    {
      v3 |= 0x40u;
    }
  }
  if ((a3 & 0x10) != 0 && (*(_BYTE *)a1 & 0x10) != 0)
  {
    v5 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a2 + 24);
    if ((unint64_t)(v5 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(_QWORD *)(a1 + 32) + 1000000000 * v5 - *(_QWORD *)(a2 + 32) + 2000) >= 0xFA1)
    {
      v3 |= 0x10u;
    }
  }
  if ((a3 & 0x20) != 0 && (*(_BYTE *)a1 & 0x20) != 0)
  {
    v6 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a2 + 40);
    if ((unint64_t)(v6 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(_QWORD *)(a1 + 48) + 1000000000 * v6 - *(_QWORD *)(a2 + 48) + 2000) >= 0xFA1)
    {
      v3 |= 0x20u;
    }
  }
  return v3;
}

uint64_t aaEntryInternalAttributesCmp(uint64_t a1, uint64_t a2, __int16 a3)
{
  unsigned int v3;

  if ((a3 & 0x100) != 0 && (*(_BYTE *)a1 & 2) != 0)
  {
    v3 = (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)) << 8;
    if ((a3 & 0x80) == 0)
      goto LABEL_9;
  }
  else
  {
    v3 = 0;
    if ((a3 & 0x80) == 0)
      goto LABEL_9;
  }
  if ((*(_BYTE *)a1 & 1) != 0 && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    v3 |= 0x80u;
LABEL_9:
  if ((a3 & 0x200) != 0 && (*(_BYTE *)a1 & 4) != 0 && *(_QWORD *)(a1 + 16) != *(_QWORD *)(a2 + 16))
    v3 |= 0x200u;
  if ((a3 & 0x400) != 0 && (*(_BYTE *)a1 & 8) != 0 && *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
    v3 |= 0x400u;
  return v3;
}

uint64_t aaEntryHashesCmp(uint64_t a1, uint64_t a2, __int16 a3)
{
  unsigned int v6;

  if ((a3 & 0x800) != 0 && (*(_BYTE *)a1 & 1) != 0)
  {
    v6 = (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) << 11;
    if ((a3 & 0x1000) == 0)
      goto LABEL_9;
  }
  else
  {
    v6 = 0;
    if ((a3 & 0x1000) == 0)
      goto LABEL_9;
  }
  if ((*(_BYTE *)a1 & 2) != 0
    && *(_QWORD *)(a1 + 8) ^ *(_QWORD *)(a2 + 8) | *(_QWORD *)(a1 + 16) ^ *(_QWORD *)(a2 + 16) | (*(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a2 + 24)))
  {
    v6 |= 0x1000u;
  }
LABEL_9:
  if ((a3 & 0x2000) != 0
    && (*(_BYTE *)a1 & 4) != 0
    && *(_QWORD *)(a1 + 28) ^ *(_QWORD *)(a2 + 28) | *(_QWORD *)(a1 + 36) ^ *(_QWORD *)(a2 + 36) | *(_QWORD *)(a1 + 44) ^ *(_QWORD *)(a2 + 44) | *(_QWORD *)(a1 + 52) ^ *(_QWORD *)(a2 + 52))
  {
    v6 |= 0x2000u;
  }
  if ((a3 & 0x4000) != 0
    && (*(_BYTE *)a1 & 8) != 0
    && memcmp((const void *)(a1 + 60), (const void *)(a2 + 60), 0x30uLL))
  {
    v6 |= 0x4000u;
  }
  if (a3 < 0 && (*(_BYTE *)a1 & 0x10) != 0 && memcmp((const void *)(a1 + 108), (const void *)(a2 + 108), 0x40uLL))
    v6 |= 0x8000u;
  return v6;
}

uint64_t AAThreadErrorContextLeave(unint64_t a1)
{
  return ParallelCompressionLeaveThreadErrorContext(0, 0, HIWORD(a1) & 1);
}

uint64_t aaCheckAndFixWithPath(char *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, unsigned int *a6, char *__s, const char *a8, uint64_t a9)
{
  uint64_t v17;
  uint64_t v18;
  char v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  AAEntryXATBlob v23;
  AAEntryACLBlob v24;
  unsigned int v25;
  uint32x4_t v26;
  int8x16_t v27;
  int8x16_t v28;
  uint64x2_t v29;
  int8x16_t v30;
  unint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  AAEntryXATBlob_impl *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const uint8_t *EncodedData;
  int v50;
  const uint8_t *v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  BOOL v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  unsigned int v69;
  AAEntryACLBlob_impl *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  __int16 v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  __int16 v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  char v90;
  unsigned int *v91;
  uint64_t flags;
  unsigned __int8 *v93;
  uint64_t v94;
  AAEntryXATBlob_impl *v95;
  unsigned __int8 *v96;
  AAEntryACLBlob_impl *acl;
  uint64_t v98;
  _QWORD v99[3];
  unsigned int v100;
  unsigned int v101;
  off_t v102;
  stat v103;
  _BYTE v104[48];
  uint64_t v105;
  char v106[64];
  uint64_t v107;
  std::__fs::filesystem::path v108[85];
  _BYTE v109[184];
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  v107 = 0;
  memset(v106, 0, sizeof(v106));
  v105 = 0;
  memset(v104, 0, sizeof(v104));
  memset(v109, 0, 172);
  if ((concatPath((char *)v108, 0x800uLL, __s, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 773, 102, 0, "invalid path: %s", v17, v18, (char)a8);
    v25 = 0;
    v70 = 0;
    v35 = 0;
    v73 = 0xFFFFFFFFLL;
    goto LABEL_101;
  }
  v91 = a6;
  v98 = (uint64_t)a1;
  v19 = *a1;
  v96 = a2;
  v20 = *a2;
  v93 = a3;
  v21 = *a3;
  v22 = *a4;
  v23 = AAEntryXATBlobCreate();
  v24 = AAEntryACLBlobCreate();
  v95 = v23;
  if (!v23 || !v24)
  {
    v70 = v24;
    v74 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 800, 102, *v74, "malloc", v75, v76, v90);
    v25 = 0;
    v73 = 0xFFFFFFFFLL;
    a6 = v91;
    v35 = v95;
    goto LABEL_101;
  }
  acl = v24;
  v25 = 0;
  v26 = vmovl_u16((uint16x4_t)(*(_QWORD *)&vshl_u16((uint16x4_t)vdup_n_s16(v21), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01));
  v27.i64[0] = v26.u32[0];
  v27.i64[1] = v26.u32[1];
  v28.i64[0] = 255;
  v28.i64[1] = 255;
  v29 = (uint64x2_t)vandq_s8(v27, v28);
  v27.i64[0] = v26.u32[2];
  v27.i64[1] = v26.u32[3];
  v30 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)xmmword_20A40C0C0), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v27, v28), (uint64x2_t)xmmword_20A40C0B0));
  v31 = (*(_QWORD *)&vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)) | ((unint64_t)(v21 & 1) << 11) | ((unint64_t)((v20 >> 2) & 1) << 9) | ((unint64_t)((v20 >> 1) & 1) << 8) | ((unint64_t)(v22 & 1) << 16) | ((unint64_t)((v20 >> 3) & 1) << 10) | ((unint64_t)((v22 >> 2) & 1) << 18) | ((unint64_t)((v22 >> 1) & 1) << 17) | a5 & 0x80000 | v19 & 0x7F | ((unint64_t)(v20 & 1) << 7)) & a5;
  if (v31 >= 0x80000)
    v32 = v31;
  else
    v32 = v31 & 0xFFFE07FF;
  flags = a9 | 8;
  v33 = 1;
  v35 = v95;
  v34 = (uint64_t)v96;
  v36 = (uint64_t)v93;
  if ((v32 & 0x20000) != 0)
  {
LABEL_8:
    if ((aaEntryXATBlobInitWithPath(v35, __s, a8) & 0x80000000) == 0)
      goto LABEL_9;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 805, 102, 0, "loading file XAT: %s", v37, v38, (char)a8);
    goto LABEL_99;
  }
  while (1)
  {
LABEL_9:
    if ((v32 & 0x40000) != 0 && (aaEntryACLBlobInitWithPath(acl, __s, a8, a9) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 806, 102, 0, "loading file ACL: %s", v39, v40, (char)a8);
      goto LABEL_99;
    }
    if ((aaEntryAttributesInitWithPath(v106, v104, v109, v32, __s, a8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 807, 102, 0, "loading file attributes: %s", v41, v42, (char)a8);
      goto LABEL_99;
    }
    v94 = aaEntryAttributesCmp((uint64_t)v106, v98, v32);
    v43 = aaEntryInternalAttributesCmp((uint64_t)v104, v34, v32) | v94;
    v25 = aaEntryHashesCmp((uint64_t)v109, v36, v32) ? v43 | 0x80000 : v43;
    if ((v32 & 0x20000) != 0)
    {
      if (*((_QWORD *)a4 + 4))
      {
        if (AAEntryXATBlobGetEncodedSize(v35) == *((_QWORD *)a4 + 4)
          && (EncodedData = AAEntryXATBlobGetEncodedData(v35),
              !memcmp(EncodedData, *((const void **)a4 + 3), *((_QWORD *)a4 + 4))))
        {
          v50 = 0;
        }
        else
        {
          v50 = 0x20000;
        }
        v25 = v50 | v25 & 0xFFFDFFFF;
        if ((v32 & 0x40000) == 0)
        {
LABEL_17:
          if ((v32 & 0x10000) == 0)
            goto LABEL_37;
          goto LABEL_33;
        }
      }
      else
      {
        v25 = v25 & 0xFFFDFFFF | ((AAEntryXATBlobGetEntryCount(v35) != 0) << 17);
        if ((v32 & 0x40000) == 0)
          goto LABEL_17;
      }
    }
    else if ((v32 & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    if (*((_QWORD *)a4 + 6))
    {
      if (AAEntryACLBlobGetEncodedSize(acl) == *((_QWORD *)a4 + 6)
        && (v51 = AAEntryACLBlobGetEncodedData(acl), !memcmp(v51, *((const void **)a4 + 5), *((_QWORD *)a4 + 6))))
      {
        v52 = 0;
      }
      else
      {
        v52 = 0x40000;
      }
      v25 = v52 | v25 & 0xFFFBFFFF;
      if ((v32 & 0x10000) == 0)
        goto LABEL_37;
    }
    else
    {
      v25 = v25 & 0xFFFBFFFF | ((AAEntryACLBlobGetEntryCount(acl) != 0) << 18);
      if ((v32 & 0x10000) == 0)
        goto LABEL_37;
    }
LABEL_33:
    memset(&v103, 0, sizeof(v103));
    v53 = open((const char *)v108, 0);
    if (v53 < 0)
    {
      v77 = *__error();
      v80 = 830;
LABEL_90:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", v80, 102, v77, "open: %s", v78, v79, (char)v108);
      goto LABEL_98;
    }
    v54 = v53;
    if (fstat(v53, &v103) < 0)
    {
      v81 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 831, 102, v81, "fstat: %s", v82, v83, (char)v108);
      goto LABEL_97;
    }
    v58 = ParallelArchiveECCVerifyFileSegment(v54, 0, v103.st_size, *((__int128 **)a4 + 1), *((_QWORD *)a4 + 2), v55, v56, v57);
    close(v54);
    if (v58 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 834, 102, 0, "verifying data: %s", v47, v48, (char)v108);
      goto LABEL_98;
    }
    v35 = v95;
    if (!v58)
    {
      v25 |= 0x80000u;
      goto LABEL_38;
    }
LABEL_37:
    if (!v25)
      goto LABEL_81;
LABEL_38:
    v60 = (a9 & 0x20000000000000) == 0 && v33 == 1;
    if (!v33 || v60)
    {
LABEL_81:
      v73 = 0;
      goto LABEL_100;
    }
    v34 = (uint64_t)v96;
    if ((v32 & 0x10000) != 0 && (v25 & 0x80000) != 0)
      break;
LABEL_54:
    if ((v25 & 0x184) != 0)
    {
      if ((*(_BYTE *)v98 & 4) != 0)
        v68 = ((*(_DWORD *)(v98 + 12) >> 5) & 1) - 1;
      else
        v68 = -1;
      if ((*(_BYTE *)v34 & 1) != 0)
        v68 = *(_DWORD *)(v34 + 8);
      if ((*(_BYTE *)v34 & 2) != 0)
        v69 = *(_DWORD *)(v34 + 12);
      else
        v69 = 0;
      ParallelCompressionAFSCFixupMetadata(v108, v68, v69);
    }
    if ((v25 & 0x200) != 0)
      setFileAPFSInternalFlags((uint64_t)v108, *(_QWORD *)(v34 + 16));
    if ((v25 & 0x20000) != 0)
    {
      if ((aaEntryXATBlobInitWithEncodedData((unint64_t *)v35, *((char **)a4 + 3), *((_QWORD *)a4 + 4), v44, v45, v46, v47, v48) & 0x80000000) != 0)
      {
        v84 = "invalid XAT blob in manifest";
        v85 = 894;
        goto LABEL_93;
      }
      AAEntryXATBlobApplyToPath(v35, __s, a8, flags);
    }
    if ((v25 & 0x40000) != 0)
    {
      v70 = acl;
      if ((aaEntryACLBlobInitWithEncodedData(acl, *((char **)a4 + 5), *((_QWORD *)a4 + 6), v44, v45, v46, v47, v48) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 901, 102, 0, "invalid ACL blob in manifest", v71, v72, v90);
        v73 = 0xFFFFFFFFLL;
        a6 = v91;
        goto LABEL_101;
      }
      AAEntryACLBlobApplyToPath(acl, __s, a8, flags);
      v36 = (uint64_t)v93;
    }
    if (v94)
      aaEntryAttributesApplyToPath((char *)v98, __s, a8, a9);
    --v33;
    if ((v32 & 0x20000) != 0)
      goto LABEL_8;
  }
  v102 = 0;
  v100 = 0;
  v101 = -1;
  if ((ParallelCompressionAFSCGetMetadata((const char *)v108, &v102, &v101, &v100) & 0x80000000) != 0)
  {
    v84 = "get AFSC attributes";
    v85 = 853;
LABEL_93:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", v85, 102, 0, v84, v61, v62, v90);
    goto LABEL_99;
  }
  memset(&v103, 0, sizeof(v103));
  v63 = open((const char *)v108, 2);
  if (v63 < 0)
  {
    v77 = *__error();
    v80 = 858;
    goto LABEL_90;
  }
  v54 = v63;
  if ((fstat(v63, &v103) & 0x80000000) == 0)
  {
    memset(v99, 0, sizeof(v99));
    v64 = ParallelArchiveECCFixFileSegment(v54, 0, v103.st_size, *((__int128 **)a4 + 1), *((_QWORD *)a4 + 2), (uint64_t)v99);
    close(v54);
    if (v64 >= 1)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 863, 102, "Fixed data using ECC: %s", v65, v66, v67, (char)a8);
    ParallelCompressionAFSCFixupMetadata(v108, v101, v100);
    v35 = v95;
    v34 = (uint64_t)v96;
    goto LABEL_54;
  }
  v86 = *__error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 859, 102, v86, "fstat: %s", v87, v88, (char)v108);
LABEL_97:
  close(v54);
LABEL_98:
  v35 = v95;
LABEL_99:
  v73 = 0xFFFFFFFFLL;
LABEL_100:
  a6 = v91;
  v70 = acl;
LABEL_101:
  *a6 = v25;
  a6[1] = 0;
  AAEntryXATBlobDestroy(v35);
  AAEntryACLBlobDestroy(v70);
  return v73;
}

uint64_t aaCopyFile(const char *a1, const char *a2, char a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  AAEntryXATBlob_impl *v12;
  uint64_t v13;
  uint64_t v14;
  AAEntryXATBlob_impl *v15;
  AAEntryACLBlob_impl *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  void *v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  const char *v38;
  __int16 v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  const char *v48;
  __int16 v49;
  int v50;
  off_t st_size;
  size_t v52;
  ssize_t v53;
  ssize_t v54;
  int v55;
  ssize_t v56;
  unint64_t v57;
  unint64_t v58;
  size_t v59;
  ssize_t v60;
  char v61;
  char v62;
  stat v63;
  int v64[4];
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  _OWORD v68[4];
  uint64_t v69;

  v69 = 0;
  memset(v68, 0, sizeof(v68));
  v67 = 0;
  v65 = 0u;
  v66 = 0u;
  *(_OWORD *)v64 = 0u;
  memset(&v63, 0, sizeof(v63));
  v6 = open(a1, 0);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = v6;
    if (fstat(v6, &v63) < 0)
    {
      v33 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 940, 102, v33, "stat: %s", v34, v35, (char)a1);
    }
    else if ((v63.st_mode & 0xF000) == 0x8000)
    {
      if ((aaEntryAttributesInitWithFD((char *)v68, v64, 0, 0xFFFFFFFF, v7) & 0x80000000) == 0)
      {
        v12 = AAEntryXATBlobCreate();
        v15 = v12;
        if (v12 && (aaEntryXATBlobInitWithFD(v12, v7) & 0x80000000) == 0)
        {
          v16 = AAEntryACLBlobCreate();
          v19 = (unint64_t *)v16;
          if (!v16 || (aaEntryACLBlobInitWithFD(v16, v7, 0) & 0x80000000) != 0)
          {
            v38 = "get ACL";
            v39 = 946;
            v40 = 0;
          }
          else if (clonefile(a1, a2, 0))
          {
            if ((v64[0] & 8) != 0
              && v64[1] >= 1
              && (v62 = -92, v20 = open_dprotected_np(a2, 1537, v64[1], 0), (v20 & 0x80000000) == 0)
              || (v20 = open(a2, 1537, 420), (v20 & 0x80000000) == 0))
            {
              if (v63.st_size)
              {
                v21 = malloc(0x40000uLL);
                if (!v21)
                {
                  v22 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 972, 102, *v22, "malloc", v23, v24, v62);
                }
                if (statIsCompressed(v63.st_flags))
                {
                  v25 = fgetxattr(v7, "com.apple.decmpfs", v21, 0x40000uLL, 0, 32);
                  if ((v25 & 0x8000000000000000) != 0)
                  {
                    v28 = "Missing decmpfs xattr";
                    v29 = 980;
                    goto LABEL_64;
                  }
                  if (v25 > 0x40000)
                  {
                    v28 = "invalid decmpfs xattr size";
                    v29 = 981;
LABEL_64:
                    v55 = 0;
LABEL_65:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v29, 102, v55, v28, v26, v27, v62);
                    close(v7);
                    close(v20);
LABEL_66:
                    unlink(a2);
                    goto LABEL_29;
                  }
                  if (fsetxattr(v20, "com.apple.decmpfs", v21, v25, 0, 0) < 0)
                  {
                    v55 = *__error();
                    v28 = "fsetxattr decmpfs";
                    v29 = 982;
                    goto LABEL_65;
                  }
                  v56 = fgetxattr(v7, "com.apple.ResourceFork", 0, 0, 0, 32);
                  if (v56 >= 1)
                  {
                    v57 = v56;
                    v58 = 0;
                    while (1)
                    {
                      if (v57 - v58 >= 0x40000)
                        v59 = 0x40000;
                      else
                        v59 = v57 - v58;
                      v60 = fgetxattr(v7, "com.apple.ResourceFork", v21, v59, v58, 32);
                      if (v60 < 0)
                      {
                        v48 = "read resource fork";
                        v49 = 992;
                        goto LABEL_46;
                      }
                      if (v60 != v59)
                      {
                        v48 = "truncated read resource fork";
                        v49 = 993;
                        goto LABEL_46;
                      }
                      if (fsetxattr(v20, "com.apple.ResourceFork", v21, v59, v58, 0) < 0)
                        break;
                      v58 += v59;
                      if (v58 >= v57)
                        goto LABEL_77;
                    }
                    v50 = *__error();
                    v48 = "write resource fork";
                    v49 = 994;
                    goto LABEL_47;
                  }
LABEL_77:
                  if (fchflags(v20, 0x20u) < 0)
                  {
                    v48 = "set UF_COMPRESSED";
                    v49 = 1000;
                    goto LABEL_46;
                  }
                }
                else
                {
                  st_size = v63.st_size;
                  if (v63.st_size >= 1)
                  {
                    while (1)
                    {
                      if ((unint64_t)st_size >= 0x40000)
                        v52 = 0x40000;
                      else
                        v52 = st_size;
                      v53 = read(v7, v21, v52);
                      if (v53 < 0)
                      {
                        v50 = *__error();
                        v48 = "read";
                        v49 = 1026;
                        goto LABEL_47;
                      }
                      if (v53 != v52)
                      {
                        v48 = "truncated read";
                        v49 = 1027;
                        goto LABEL_46;
                      }
                      v54 = write(v20, v21, v52);
                      if (v54 < 0)
                      {
                        v50 = *__error();
                        v48 = "write";
                        v49 = 1029;
                        goto LABEL_47;
                      }
                      if (v54 != v52)
                        break;
                      st_size -= v52;
                      if (st_size < 1)
                        goto LABEL_38;
                    }
                    v48 = "truncated write";
                    v49 = 1030;
                    goto LABEL_46;
                  }
                }
LABEL_38:
                if ((aaEntryAttributesApplyToFD((char *)v68, v20, a3) & 0x80000000) == 0
                  && (aaEntryXATBlobApplyToFD(v15, v20, a3, v42, v43, v44, v45, v46) & 0x80000000) == 0
                  && (aaEntryACLBlobApplyToFD(v19, v20, a3) & 0x80000000) == 0)
                {
                  v47 = 0;
                  v36 = 1;
                  if ((v64[0] & 4) != 0 && (_QWORD)v65)
                  {
                    if ((setFileAPFSInternalFlags(v20, v65) & 0x80000000) != 0)
                    {
                      v48 = "setting internal attributes";
                      v49 = 1047;
                      goto LABEL_46;
                    }
                    v47 = 0;
                  }
LABEL_48:
                  close(v7);
                  if ((v20 & 0x80000000) != 0)
                    goto LABEL_30;
                  close(v20);
                  if (!v47)
                    goto LABEL_30;
                  goto LABEL_66;
                }
                v48 = "setting attributes";
                v49 = 1042;
LABEL_46:
                v50 = 0;
LABEL_47:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v49, 102, v50, v48, v45, v46, v62);
                v36 = 0;
                v47 = 1;
                goto LABEL_48;
              }
LABEL_37:
              v21 = 0;
              goto LABEL_38;
            }
            v40 = *__error();
            v61 = (char)a2;
            v38 = "open: %s";
            v39 = 964;
          }
          else
          {
            v62 = -92;
            v41 = open(a2, 0);
            if ((v41 & 0x80000000) == 0)
            {
              v20 = v41;
              goto LABEL_37;
            }
            v40 = *__error();
            v61 = (char)a2;
            v38 = "open: %s";
            v39 = 953;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v39, 102, v40, v38, v17, v18, v61);
          goto LABEL_28;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 944, 102, 0, "get XAT", v13, v14, v61);
LABEL_27:
        v19 = 0;
LABEL_28:
        close(v7);
        v21 = 0;
        goto LABEL_29;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 942, 102, 0, "get attributes", v10, v11, v61);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 941, 102, 0, "not a regular file: %s", v8, v9, (char)a1);
    }
    v15 = 0;
    goto LABEL_27;
  }
  v30 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 939, 102, *v30, "open: %s", v31, v32, (char)a1);
  v21 = 0;
  v19 = 0;
  v15 = 0;
LABEL_29:
  v36 = 0;
LABEL_30:
  AAEntryXATBlobDestroy(v15);
  AAEntryACLBlobDestroy((AAEntryACLBlob)v19);
  free(v21);
  if (v36)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t AARandomAccessDecodeAndExtract(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, int DefaultNThreads)
{
  void *v14;
  uint64_t v15;
  uint64_t VolumeCapabilities;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  __int16 v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int *v44;
  FILE **v45;
  const char *v46;
  const char *v47;
  int v48;
  double RealTime;
  int Header;
  uint64_t v51;
  uint64_t v52;
  AAHeader_impl *v53;
  AAFieldKey v54;
  uint32_t KeyIndex;
  unsigned int FieldUInt;
  int v57;
  AAHeader_impl *v58;
  AAFieldKey v59;
  uint32_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  double v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t *v70;
  unint64_t *v71;
  unint64_t *v72;
  unint64_t *v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v78;
  BOOL v79;
  unint64_t v80;
  size_t v81;
  unint64_t v82;
  void *v83;
  const char *v84;
  __int16 v85;
  double v86;
  unsigned __int16 *v87;
  uint64_t v88;
  uint64_t v89;
  AAHeader_impl *v90;
  _QWORD *v91;
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  unsigned __int16 *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int64_t v100;
  int64_t v101;
  unsigned __int16 *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t PayloadSize;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *EntryData;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  const char *v118;
  __int16 v119;
  int *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  const char *v125;
  __int16 v126;
  const char *v127;
  __int16 v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  FILE **v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  double v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  uint64_t Worker;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  char v159;
  const char *v160;
  __int16 v161;
  double v162;
  FILE **v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  double v171;
  unint64_t v172;
  unint64_t v173;
  uint64_t *v174;
  uint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  char v188;
  const char *v189;
  __int16 v190;
  double v191;
  double v192;
  unint64_t v193;
  FILE **v194;
  int v195;
  uint64_t v196;
  unsigned int v197;
  unsigned __int16 *v198;
  unsigned int v199;
  unsigned int v200;
  double v201;
  const char *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  double v210;
  unint64_t v211;
  unint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  unint64_t v218;
  unsigned int v219;
  double v220;
  FILE **v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  double v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t v238;
  double v239;
  FILE *v241;
  unint64_t v242;
  const char *v243;
  __int16 v244;
  const char *v245;
  __int16 v246;
  char v247;
  char v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t value;
  stat v252;
  uint64_t v253;

  v253 = *MEMORY[0x24BDAC8D0];
  memset(&v252, 0, sizeof(v252));
  v14 = malloc(0x520uLL);
  if (!v14)
  {
    v39 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreate", 812, 120, *v39, "malloc", v40, v41, v247);
    goto LABEL_28;
  }
  v15 = (uint64_t)v14;
  memset_s(v14, 0x520uLL, 0, 0x520uLL);
  *(_QWORD *)v15 = a1;
  *(_QWORD *)(v15 + 8) = a2;
  if (!realpath_DARWIN_EXTSN(a3, (char *)(v15 + 16))
    || lstat((const char *)(v15 + 16), &v252) < 0
    || (v252.st_mode & 0xF000) != 0x4000)
  {
    v34 = *__error();
    v247 = (char)a3;
    v35 = "invalid directory: %s";
    v36 = 819;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreate", v36, 120, v34, v35, v22, v23, v247);
    stateDestroy(v15);
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"AARandomAccessDecodeAndExtract", 1352, 120, 0, "creating state", v37, v38, v248);
    v15 = 0;
    goto LABEL_29;
  }
  *(_QWORD *)(v15 + 1056) = a6;
  *(_QWORD *)(v15 + 1040) = a4;
  *(_QWORD *)(v15 + 1048) = a5;
  *(_DWORD *)(v15 + 1080) = a6 >> 62;
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  *(_DWORD *)(v15 + 1152) = DefaultNThreads;
  *(_DWORD *)(v15 + 1064) = isDirEmpty((const char *)(v15 + 16)) == 0;
  *(_QWORD *)(v15 + 1068) = (a6 >> 54) & 1;
  VolumeCapabilities = getVolumeCapabilities((const char *)(v15 + 16));
  v17 = VolumeCapabilities & ~(VolumeCapabilities >> 63);
  v18 = 268;
  if ((v17 & 8) == 0)
    v18 = 264;
  v19 = v18 & 0xFFFFFFFFFFFFFFDFLL | (32 * (v17 & 1));
  if ((a6 & 0x20) == 0 && (v17 & 2) != 0)
    v20 = v19 | 0x40;
  else
    v20 = v19;
  *(_QWORD *)(v15 + 1088) = v20;
  v21 = StringTableCreate();
  *(_QWORD *)(v15 + 1096) = v21;
  if (!v21)
  {
    v35 = "string table creation";
    v36 = 842;
    goto LABEL_49;
  }
  v24 = calloc(*(unsigned int *)(v15 + 1152), 8uLL);
  *(_QWORD *)(v15 + 1160) = v24;
  if (!v24)
  {
    v34 = *__error();
    v35 = "malloc";
    v36 = 845;
    goto LABEL_26;
  }
  if (*(_DWORD *)(v15 + 1152))
  {
    v25 = 0;
    while (1)
    {
      v26 = malloc(0x858uLL);
      v27 = (uint64_t)v26;
      if (v26)
      {
        memset_s(v26, 0x858uLL, 0, 0x858uLL);
        *(_QWORD *)(v27 + 40) = 0x40000;
        v28 = malloc(0x40000uLL);
        *(_QWORD *)(v27 + 32) = v28;
        if (v28)
        {
          *(_DWORD *)(v27 + 2104) = -1;
          goto LABEL_22;
        }
        v29 = 120;
      }
      else
      {
        v29 = 116;
      }
      v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreate", v29, 120, *v30, "malloc", v31, v32, v247);
      workerDestroy_0(v27);
      v27 = 0;
LABEL_22:
      *(_QWORD *)(*(_QWORD *)(v15 + 1160) + 8 * v25) = v27;
      v33 = *(_QWORD *)(v15 + 1160);
      if (!*(_QWORD *)(v33 + 8 * v25))
      {
        v35 = "creating new worker";
        v36 = 849;
        goto LABEL_49;
      }
      ++v25;
      v24 = (void *)*(unsigned int *)(v15 + 1152);
      if (v25 >= (unint64_t)v24)
        goto LABEL_34;
    }
  }
  v33 = (uint64_t)v24;
  LODWORD(v24) = 0;
LABEL_34:
  v44 = ThreadPoolCreate(v24, v33, (uint64_t)workerProc_3);
  *(_QWORD *)(v15 + 1168) = v44;
  if (!v44)
  {
    v35 = "ThreadPoolCreate";
    v36 = 854;
LABEL_49:
    v34 = 0;
    goto LABEL_26;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v15 + 1176), 0) < 0)
  {
    v35 = "pthread_mutex_init";
    v36 = 857;
    goto LABEL_49;
  }
  if (*(_DWORD *)(v15 + 1080))
  {
    v45 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("DecodeAndExtract\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    fprintf(*v45, "  target directory: %s\n", a3);
    if (a2)
      v46 = "yes";
    else
      v46 = "no";
    fprintf(*v45, "  manifest: %s\n", v46);
    if ((a6 & 0x40000000000000) != 0)
      v47 = "no";
    else
      v47 = "yes";
    fprintf(*v45, "  path checking: %s\n", v47);
    v48 = *(_DWORD *)(v15 + 1080);
    if (!*(_QWORD *)(v15 + 8))
    {
LABEL_97:
      if (v48)
        fwrite("Scanning archive\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      goto LABEL_99;
    }
    *(_QWORD *)&v252.st_dev = 0;
    if (v48)
      fwrite("Scanning manifest\n", 0x12uLL, 1uLL, *v45);
LABEL_52:
    RealTime = getRealTime();
    v250 = 0;
    value = 0;
    Header = AAArchiveStreamReadHeader(*(AAArchiveStream *)(v15 + 8), (AAHeader *)&v252);
    if (Header)
    {
      while (1)
      {
        if (Header < 0)
        {
          v84 = "manifest read";
          v85 = 1041;
          goto LABEL_145;
        }
        v53 = *(AAHeader_impl **)&v252.st_dev;
        v54.ikey = 5784649;
        KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)&v252.st_dev, v54);
        if ((KeyIndex & 0x80000000) != 0)
          break;
        FieldUInt = AAHeaderGetFieldUInt(v53, KeyIndex, &value);
        v57 = FieldUInt <= 1 ? 1 : FieldUInt;
        if (v57 <= 0)
          break;
        v58 = *(AAHeader_impl **)&v252.st_dev;
        v59.ikey = 5915721;
        v60 = AAHeaderGetKeyIndex(*(AAHeader *)&v252.st_dev, v59);
        if ((v60 & 0x80000000) != 0
          || ((v61 = AAHeaderGetFieldUInt(v58, v60, &v250), v61 <= 1) ? (v62 = 1) : (v62 = v61), v62 <= 0))
        {
          v84 = "missing IDZ field";
          v85 = 1045;
          goto LABEL_145;
        }
        if ((stateAppendEntry(v15, *(AAHeader *)&v252.st_dev, value, v250, 0) & 0x80000000) != 0)
        {
          v84 = "adding entry";
          v85 = 1048;
          goto LABEL_145;
        }
        v250 = 0;
        value = 0;
        Header = AAArchiveStreamReadHeader(*(AAArchiveStream *)(v15 + 8), (AAHeader *)&v252);
        if (!Header)
          goto LABEL_66;
      }
      v84 = "missing IDX field";
      v85 = 1044;
LABEL_145:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanManifest", v85, 120, 0, v84, v51, v52, v247);
      AAHeaderDestroy(*(AAHeader *)&v252.st_dev);
      v125 = "scanning manifest";
      v126 = 1363;
      goto LABEL_277;
    }
LABEL_66:
    AAHeaderDestroy(*(AAHeader *)&v252.st_dev);
    v65 = getRealTime();
    if (*(_DWORD *)(v15 + 1080))
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12.2f time (s)\n", v65 - RealTime);
    if (*(_QWORD *)(v15 + 8))
      goto LABEL_69;
    v48 = *(_DWORD *)(v15 + 1080);
    goto LABEL_97;
  }
  if (*(_QWORD *)(v15 + 8))
  {
    *(_QWORD *)&v252.st_dev = 0;
    goto LABEL_52;
  }
LABEL_99:
  v86 = getRealTime();
  v87 = (unsigned __int16 *)malloc(0x10000uLL);
  if (!v87)
  {
    v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanArchive", 1074, 120, *v120, "malloc", v121, v122, v247);
    v90 = 0;
    goto LABEL_142;
  }
  v90 = AAHeaderCreate();
  if (!v90)
  {
    v118 = "AAHeaderCreate";
    v119 = 1076;
    goto LABEL_141;
  }
  v91 = *(_QWORD **)v15;
  v92 = (_QWORD *)(*(_QWORD *)v15 + 32);
  if (!*v92)
  {
LABEL_138:
    v118 = "read";
    v119 = 1083;
    goto LABEL_141;
  }
  v93 = 0;
  while (1)
  {
    v94 = 0;
    v95 = v87;
    v96 = v93;
    v97 = 6;
    do
    {
      v98 = ((uint64_t (*)(_QWORD, unsigned __int16 *, uint64_t, uint64_t))*v92)(*v91, v95, v97, v96);
      if (v98 < 0)
        goto LABEL_138;
      if (!v98)
        break;
      v95 = (unsigned __int16 *)((char *)v95 + v98);
      v94 += v98;
      v96 += v98;
      v97 -= v98;
    }
    while (v97);
    if (!v94)
      break;
    if ((v94 & 0x8000000000000000) != 0)
      goto LABEL_138;
    if (v94 <= 5)
    {
      v118 = "truncated archive";
      v119 = 1084;
      goto LABEL_141;
    }
    if (*(_DWORD *)v87 != 825246017 && *(_DWORD *)v87 != 826360153)
    {
      v118 = "invalid header magic";
      v119 = 1085;
      goto LABEL_141;
    }
    v99 = *(_QWORD *)v15;
    if (!*(_QWORD *)(*(_QWORD *)v15 + 32))
      goto LABEL_191;
    v100 = v87[2];
    if (v87[2])
    {
      v101 = 0;
      v102 = v87;
      v103 = v93;
      v104 = v87[2];
      do
      {
        v105 = (*(uint64_t (**)(_QWORD, unsigned __int16 *, uint64_t, uint64_t))(v99 + 32))(*(_QWORD *)v99, v102, v104, v103);
        if (v105 < 0)
          goto LABEL_191;
        if (!v105)
          break;
        v102 = (unsigned __int16 *)((char *)v102 + v105);
        v101 += v105;
        v103 += v105;
        v104 -= v105;
      }
      while (v104);
      if (v101 < 0)
      {
LABEL_191:
        v118 = "read";
        v119 = 1091;
        goto LABEL_141;
      }
    }
    else
    {
      v101 = 0;
    }
    if (v101 < v100)
    {
      v118 = "truncated archive";
      v119 = 1092;
      goto LABEL_141;
    }
    if ((aaHeaderInitWithEncodedData((uint64_t)v90, v87, v100) & 0x80000000) != 0)
    {
      v118 = "invalid archive";
      v119 = 1093;
      goto LABEL_141;
    }
    PayloadSize = AAHeaderGetPayloadSize(v90);
    if (__CFADD__(v100, PayloadSize))
    {
      v118 = "invalid payload size";
      v119 = 1096;
      goto LABEL_141;
    }
    v107 = PayloadSize;
    *(_QWORD *)&v252.st_dev = 0;
    if ((stateAppendEntry(v15, v90, v93, v100 + PayloadSize, (char **)&v252) & 0x80000000) != 0)
    {
      v118 = "adding entry";
      v119 = 1100;
      goto LABEL_141;
    }
    if (*(_QWORD *)&v252.st_dev && !*(_DWORD *)(v15 + 1072) && *(_DWORD *)(*(_QWORD *)&v252.st_dev + 60) == 68)
    {
      if (v107 == -1)
      {
        v118 = "invalid payload size";
        v119 = 1108;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanArchive", v119, 120, 0, v118, v88, v89, v247);
LABEL_142:
        free(v87);
        AAHeaderDestroy(v90);
        v125 = "scanning archive";
        v126 = 1364;
        goto LABEL_277;
      }
      EntryData = (char *)stateGetEntryData(v15, *(uint64_t *)&v252.st_dev, v108, v109, v110, v111, v88, v89);
      memcpy(EntryData, v87, v100);
      if (v107)
      {
        v249 = *(_QWORD *)v15;
        if (!*(_QWORD *)(*(_QWORD *)v15 + 32))
          goto LABEL_283;
        v113 = 0;
        v114 = v93 + v100;
        v115 = &EntryData[v100];
        v116 = v107;
        do
        {
          v117 = (*(uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))(v249 + 32))(*(_QWORD *)v249, v115, v116, v114);
          if (v117 < 0)
            goto LABEL_283;
          if (!v117)
            break;
          v115 += v117;
          v113 += v117;
          v114 += v117;
          v116 -= v117;
        }
        while (v116);
        if (v113 < 0 || v113 != v107)
        {
LABEL_283:
          v118 = "loading DIR entry";
          v119 = 1115;
          goto LABEL_141;
        }
      }
    }
    v93 += v100 + v107;
    v91 = *(_QWORD **)v15;
    v92 = (_QWORD *)(*(_QWORD *)v15 + 32);
    if (!*v92)
      goto LABEL_138;
  }
  *(_DWORD *)(v15 + 1072) = 1;
  free(v87);
  AAHeaderDestroy(v90);
  v201 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12.2f time (s)\n", v201 - v86);
LABEL_69:
  memset(&v252, 255, 24);
  v66 = *(_QWORD *)(v15 + 1136);
  if (!v66)
    goto LABEL_86;
  v67 = 0;
  v68 = *(_QWORD *)(v15 + 1144);
  do
  {
    v69 = 0;
    v70 = (unint64_t *)(v68 + 72 * v67);
    v71 = v70 + 4;
    v72 = v70 + 3;
    v73 = v70 + 2;
    do
    {
      v74 = v73;
      if ((_DWORD)v69)
      {
        if ((_DWORD)v69 == 2)
        {
          v74 = v71;
        }
        else
        {
          v74 = v72;
          if ((_DWORD)v69 != 1)
            goto LABEL_84;
        }
      }
      v75 = *v74;
      if (v75 != -1)
      {
        v76 = *((_QWORD *)&v252.st_dev + v69);
        if (v75 <= v76 && v76 != -1)
          v75 = *((_QWORD *)&v252.st_dev + v69);
        *((_QWORD *)&v252.st_dev + v69) = v75;
      }
LABEL_84:
      ++v69;
    }
    while (v69 != 3);
    ++v67;
  }
  while (v67 != v66);
LABEL_86:
  v78 = 0;
  v79 = 1;
  while (1)
  {
    v80 = *((_QWORD *)&v252.st_dev + v78);
    if (v80 == -1)
      goto LABEL_92;
    if (v80 == -2)
    {
      v127 = "too many cluster entries";
      v128 = 1164;
      v129 = 0;
      goto LABEL_149;
    }
    v81 = v80 + 1;
    v82 = v15 + 8 * v78;
    *(_QWORD *)(v82 + 1240) = v80 + 1;
    if (v80 >> 34)
      break;
    v83 = calloc(v81, 8uLL);
    *(_QWORD *)(v82 + 1264) = v83;
    if (!v83)
      goto LABEL_148;
    memset(v83, 255, 8 * v81);
LABEL_92:
    v79 = v78++ < 2;
    if (v78 == 3)
      goto LABEL_151;
  }
  *__error() = 12;
  *(_QWORD *)(v82 + 1264) = 0;
LABEL_148:
  v129 = *__error();
  v127 = "malloc";
  v128 = 1168;
LABEL_149:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAllocClusters", v128, 120, v129, v127, v63, v64, v247);
  if (v79)
  {
    v125 = "allocating clusters";
    v126 = 1367;
    goto LABEL_277;
  }
LABEL_151:
  if (*(_DWORD *)(v15 + 1080))
  {
    if (*(_QWORD *)(v15 + 1136))
    {
      v130 = 0;
      v131 = 0;
      v132 = 0;
      v133 = 0;
      v134 = 0;
      v135 = 0;
      v136 = 0;
      v137 = 0;
      v138 = *(_QWORD *)(v15 + 1144) + 32;
      v139 = *(_QWORD *)(v15 + 1136);
      do
      {
        v140 = *(_DWORD *)(v138 + 28);
        switch(v140)
        {
          case 'L':
            ++v132;
            break;
          case 'F':
            ++v131;
            if (*(_QWORD *)(v138 - 16) != -1)
              ++v135;
            if (*(_QWORD *)(v138 - 8) != -1)
              ++v134;
            if (*(_QWORD *)v138 != -1)
              ++v133;
            break;
          case 'D':
            ++v130;
            break;
          default:
            ++v137;
            break;
        }
        v136 += *(_QWORD *)(v138 - 24);
        v138 += 72;
        --v139;
      }
      while (v139);
    }
    else
    {
      v137 = 0;
      v136 = 0;
      v135 = 0;
      v134 = 0;
      v133 = 0;
      v132 = 0;
      v131 = 0;
      v130 = 0;
    }
    v141 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu entries selected\n", *(_QWORD *)(v15 + 1136));
    fprintf(*v141, "%12llu archive bytes\n", v136);
    fprintf(*v141, "%12zu regular files\n", v131);
    fprintf(*v141, "%12zu directories\n", v130);
    fprintf(*v141, "%12zu symbolic links\n", v132);
    if (v137)
      fprintf(*v141, "%12zu other entries\n", v137);
    fprintf(*v141, "%12zu bytes allocated in DIR blob\n", *(_QWORD *)(v15 + 1112));
    if (v135)
      fprintf(*v141, "%12zu regular files in hard link clusters\n", v135);
    if (v134)
      fprintf(*v141, "%12zu regular files in clone clusters\n", v134);
    if (v133)
      fprintf(*v141, "%12zu regular files in same content clusters\n", v133);
    if (*(_DWORD *)(v15 + 1080))
      fwrite("Creating directories\n", 0x15uLL, 1uLL, *v141);
  }
  v149 = getRealTime();
  v150 = *(_QWORD *)(v15 + 1136);
  if (v150 / (4 * *(_DWORD *)(v15 + 1152)) <= 0x64)
    v151 = 100;
  else
    v151 = v150 / (4 * *(_DWORD *)(v15 + 1152));
  if (v150)
  {
    v152 = 0;
    while (1)
    {
      Worker = ThreadPoolGetWorker(*(_QWORD *)(v15 + 1168), v142, v143, v144, v145, v146, v147, v148);
      if (!Worker)
      {
        v160 = "ThreadPoolGetWorker";
        v161 = 1190;
        goto LABEL_193;
      }
      *(_DWORD *)Worker = 0;
      *(_QWORD *)(Worker + 16) = v152;
      v152 += v151;
      v158 = *(_QWORD *)(v15 + 1136);
      if (v152 < v158)
        v158 = v152;
      *(_QWORD *)(Worker + 24) = v158;
      *(_QWORD *)(Worker + 8) = v15;
      if ((ThreadPoolRunWorker(*(_QWORD *)(v15 + 1168), Worker, v154, v155, v156, v157, v147, v148) & 0x80000000) != 0)
        break;
      if (v152 >= *(_QWORD *)(v15 + 1136))
        goto LABEL_189;
    }
    v160 = "ThreadPoolRunWorker";
    v161 = 1195;
LABEL_193:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateDirs", v161, 120, 0, v160, v147, v148, v247);
    v159 = 1;
  }
  else
  {
LABEL_189:
    v159 = 0;
  }
  if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateDirs", 1199, 120, 0, "ThreadPoolSync", v123, v124, v247);
    goto LABEL_215;
  }
  if ((v159 & 1) != 0)
  {
LABEL_215:
    v125 = "creating directories";
    v126 = 1410;
    goto LABEL_277;
  }
  v162 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    v163 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12.2f time (s)\n", v162 - v149);
    if (*(_DWORD *)(v15 + 1080))
      fprintf(*v163, "Creating files (flags=0x%08x)\n", *(_QWORD *)(v15 + 1088));
  }
  v171 = getRealTime();
  v172 = *(_QWORD *)(v15 + 1136);
  if (!v172)
  {
LABEL_213:
    v188 = 0;
    goto LABEL_219;
  }
  v173 = 0;
  v174 = (uint64_t *)(*(_QWORD *)(v15 + 1144) + 8);
  v175 = *(_QWORD *)(v15 + 1136);
  do
  {
    v176 = *v174;
    v174 += 9;
    v173 += v176;
    --v175;
  }
  while (v175);
  v177 = 0;
  v178 = 0;
  if (v173 / (6 * *(_DWORD *)(v15 + 1152)) >= 0x400)
    v179 = v173 / (6 * *(_DWORD *)(v15 + 1152));
  else
    v179 = v173;
  v180 = 8;
  v181 = 1;
  while (2)
  {
    if (v181 < v172)
    {
      v177 += *(_QWORD *)(*(_QWORD *)(v15 + 1144) + v180);
      if (v177 < v179)
      {
LABEL_211:
        v180 += 72;
        if (v181++ >= v172)
          goto LABEL_213;
        continue;
      }
    }
    break;
  }
  v182 = ThreadPoolGetWorker(*(_QWORD *)(v15 + 1168), v164, v165, v166, v167, v168, v169, v170);
  if (!v182)
  {
    v189 = "ThreadPoolGetWorker";
    v190 = 1308;
    goto LABEL_218;
  }
  *(_DWORD *)v182 = 1;
  *(_QWORD *)(v182 + 16) = v178;
  *(_QWORD *)(v182 + 24) = v181;
  *(_QWORD *)(v182 + 8) = v15;
  if ((ThreadPoolRunWorker(*(_QWORD *)(v15 + 1168), v182, v183, v184, v185, v186, v169, v170) & 0x80000000) == 0)
  {
    v177 = 0;
    v172 = *(_QWORD *)(v15 + 1136);
    v178 = v181;
    goto LABEL_211;
  }
  v189 = "ThreadPoolRunWorker";
  v190 = 1313;
LABEL_218:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateEntries", v190, 120, 0, v189, v169, v170, v247);
  v188 = 1;
LABEL_219:
  if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateEntries", 1321, 120, 0, "ThreadPoolSync", v123, v124, v247);
    *(_DWORD *)(v15 + 1072) = 1;
    goto LABEL_231;
  }
  *(_DWORD *)(v15 + 1072) = 1;
  if ((v188 & 1) != 0)
  {
LABEL_231:
    v125 = "creating entries";
    v126 = 1413;
    goto LABEL_277;
  }
  v191 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    v192 = v191 - v171;
    v193 = atomic_load((unint64_t *)(v15 + 1304));
    v194 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu data bytes written\n", v193);
    fprintf(*v194, "%12.2f MB/s\n", (double)v193 / v192 * 0.000000953674316);
    fprintf(*v194, "%12.2f time (s)\n", v192);
  }
  v195 = *(_DWORD *)(v15 + 1076);
  if (v195)
  {
    v196 = *(_QWORD *)(v15 + 1136);
    if (v196)
    {
      v197 = 0;
      v198 = (unsigned __int16 *)(*(_QWORD *)(v15 + 1144) + 68);
      do
      {
        v200 = *v198;
        v198 += 36;
        v199 = v200;
        if (v200 > v197)
          v197 = v199;
        --v196;
      }
      while (v196);
    }
    else
    {
      v197 = 0;
    }
  }
  else
  {
    v197 = -1;
  }
  if (*(_DWORD *)(v15 + 1080))
  {
    if (v195)
      v202 = "depth loop";
    else
      v202 = "single pass";
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Setting directories attributes (%s)\n", v202);
  }
  v210 = getRealTime();
  if (*(_QWORD *)(v15 + 1136) / (unint64_t)(4 * *(_DWORD *)(v15 + 1152)) <= 0x64)
    v211 = 100;
  else
    v211 = *(_QWORD *)(v15 + 1136) / (unint64_t)(4 * *(_DWORD *)(v15 + 1152));
  while (2)
  {
    if (*(_QWORD *)(v15 + 1136))
    {
      v212 = 0;
      while (1)
      {
        v213 = ThreadPoolGetWorker(*(_QWORD *)(v15 + 1168), v203, v204, v205, v206, v207, v208, v209);
        if (!v213)
        {
          v243 = "ThreadPoolGetWorker";
          v244 = 1232;
          goto LABEL_276;
        }
        *(_DWORD *)v213 = 3;
        *(_QWORD *)(v213 + 16) = v212;
        v212 += v211;
        v218 = *(_QWORD *)(v15 + 1136);
        if (v212 < v218)
          v218 = v212;
        *(_QWORD *)(v213 + 24) = v218;
        *(_QWORD *)(v213 + 8) = v15;
        *(_DWORD *)(v213 + 2108) = v197;
        if ((ThreadPoolRunWorker(*(_QWORD *)(v15 + 1168), v213, v214, v215, v216, v217, v208, v209) & 0x80000000) != 0)
          break;
        if (v212 >= *(_QWORD *)(v15 + 1136))
          goto LABEL_252;
      }
      v243 = "ThreadPoolRunWorker";
      v244 = 1238;
      goto LABEL_276;
    }
LABEL_252:
    if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
    {
      v243 = "ThreadPoolSync";
      v244 = 1240;
LABEL_276:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateSetDirsAttributes", v244, 120, 0, v243, v208, v209, v247);
      v125 = "setting directories attributes";
      v126 = 1416;
      goto LABEL_277;
    }
    v219 = v197-- + 1;
    if (v219 > 1)
      continue;
    break;
  }
  v220 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    v221 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12.2f time (s)\n", v220 - v210);
    if (*(_DWORD *)(v15 + 1080))
      fwrite("Creating hard links / clones\n", 0x1DuLL, 1uLL, *v221);
  }
  v229 = getRealTime();
  v230 = *(_QWORD *)(v15 + 1136);
  if (v230 / (4 * *(_DWORD *)(v15 + 1152)) <= 0x64)
    v231 = 100;
  else
    v231 = v230 / (4 * *(_DWORD *)(v15 + 1152));
  if (v230)
  {
    v232 = 0;
    while (1)
    {
      v233 = ThreadPoolGetWorker(*(_QWORD *)(v15 + 1168), v222, v223, v224, v225, v226, v227, v228);
      if (!v233)
      {
        v245 = "ThreadPoolGetWorker";
        v246 = 1266;
        goto LABEL_289;
      }
      *(_DWORD *)v233 = 2;
      *(_QWORD *)(v233 + 16) = v232;
      v232 += v231;
      v238 = *(_QWORD *)(v15 + 1136);
      if (v232 < v238)
        v238 = v232;
      *(_QWORD *)(v233 + 24) = v238;
      *(_QWORD *)(v233 + 8) = v15;
      if ((ThreadPoolRunWorker(*(_QWORD *)(v15 + 1168), v233, v234, v235, v236, v237, v227, v228) & 0x80000000) != 0)
        break;
      if (v232 >= *(_QWORD *)(v15 + 1136))
        goto LABEL_267;
    }
    v245 = "ThreadPoolRunWorker";
    v246 = 1271;
LABEL_289:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateClusters", v246, 120, 0, v245, v227, v228, v247);
    v125 = "creating hard links, clones";
    v126 = 1419;
LABEL_277:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"AARandomAccessDecodeAndExtract", v126, 120, 0, v125, v123, v124, v247);
LABEL_29:
    v42 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_267:
    if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
    {
      v245 = "ThreadPoolSync";
      v246 = 1273;
      goto LABEL_289;
    }
    v239 = getRealTime();
    if (*(_DWORD *)(v15 + 1080))
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12.2f time (s)\n", v239 - v229);
    if (atomic_load((unint64_t *)(v15 + 1296)))
    {
      if (*(_DWORD *)(v15 + 1080))
      {
        v241 = (FILE *)*MEMORY[0x24BDAC8D8];
        v242 = atomic_load((unint64_t *)(v15 + 1296));
        fprintf(v241, "%12llu errors reported\n", v242);
      }
      v125 = "errors reported";
      v126 = 1424;
      goto LABEL_277;
    }
    v42 = 0;
  }
  stateDestroy(v15);
  return v42;
}

void stateDestroy(uint64_t a1)
{
  void *v2;
  unint64_t v3;

  if (a1)
  {
    StringTableDestroy(*(void ***)(a1 + 1096));
    ThreadPoolDestroy(*(_QWORD *)(a1 + 1168));
    free(*(void **)(a1 + 1120));
    memset_s((void *)(a1 + 1104), 0x18uLL, 0, 0x18uLL);
    v2 = *(void **)(a1 + 1160);
    if (v2)
    {
      if (*(_DWORD *)(a1 + 1152))
      {
        v3 = 0;
        do
          workerDestroy_0(*(_QWORD *)(*(_QWORD *)(a1 + 1160) + 8 * v3++));
        while (v3 < *(unsigned int *)(a1 + 1152));
        v2 = *(void **)(a1 + 1160);
      }
      free(v2);
    }
    free(*(void **)(a1 + 1144));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1176));
    free((void *)a1);
  }
}

uint64_t workerProc_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  AAHeader_impl *v32;
  AAHeader_impl *v33;
  uint64_t v34;
  AAHeader v35;
  uint64_t v36;
  uint64_t v37;
  AAHeader_impl *v38;
  unint64_t v39;
  unint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  uint64_t v45;
  unint64_t *v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;
  unsigned __int16 *v62;
  unint64_t v63;
  const char *v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t (*v68)(_QWORD, uint64_t, const char *, AAHeader_impl *);
  int v69;
  uint64_t v70;
  uint64_t v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  AAFieldKey v75;
  uint32_t v76;
  unsigned int v77;
  int v78;
  AAFieldKey v79;
  uint32_t v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int *v99;
  uint64_t v100;
  uint64_t v101;
  __int16 v102;
  const char *v103;
  uint64_t v104;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t *v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  const char *v114;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  const char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unsigned __int16 *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t *v131;
  unint64_t v132;
  __int16 v133;
  uint64_t v134;
  uint64_t v135;
  __int16 v136;
  const char *v137;
  unsigned __int16 *v138;
  unint64_t v139;
  const char *v140;
  unint64_t v141;
  AAFieldKey v142;
  uint32_t v143;
  unsigned int v144;
  int v145;
  AAFieldKey v146;
  uint32_t v147;
  unsigned int v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  BOOL v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  int *v161;
  uint64_t v162;
  uint64_t v163;
  __int16 v164;
  const char *v165;
  AAHeader v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  unint64_t *v174;
  uint64_t v175;
  int *v176;
  uint64_t v177;
  uint64_t EntryData;
  _QWORD *v179;
  uint64_t v180;
  _QWORD *v181;
  uint64_t v182;
  uint64_t v183;
  _DWORD *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  AAByteStream_impl *v189;
  uint64_t v190;
  uint64_t v191;
  char *v192;
  uint64_t v193;
  uint64_t v194;
  char *v195;
  const char *v196;
  uint64_t v197;
  uint64_t v198;
  _QWORD *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  __int16 v211;
  const char *v212;
  __int16 v213;
  const char *v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t (*v219)(_QWORD, uint64_t, const char *, AAHeader_impl *);
  uint64_t v220;
  uint64_t v221;
  int v222;
  AAFieldKey v223;
  uint32_t KeyIndex;
  uint64_t v225;
  uint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  AAFieldKey v230;
  uint32_t v231;
  unsigned int FieldString;
  int v233;
  AAFieldKey v234;
  uint32_t v235;
  unsigned int FieldBlob;
  int v237;
  AAFieldKey v238;
  uint32_t v239;
  unsigned int v240;
  int v241;
  unint64_t v242;
  char v243;
  unsigned int v244;
  __int16 v245;
  const char *v246;
  AAHeader_impl *v247;
  AAFieldKey v248;
  uint32_t v249;
  uint64_t v250;
  uint64_t v251;
  size_t v252;
  uint64_t PayloadSize;
  __int16 v254;
  const char *v255;
  int v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  size_t v266;
  size_t v267;
  ssize_t v268;
  ssize_t v269;
  uint64_t (*v270)(_QWORD, uint64_t, const char *, uint64_t *);
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  size_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  size_t v284;
  uint64_t v285;
  __int16 v286;
  const char *v287;
  size_t v288;
  int v289;
  void *v290;
  const uint8_t *EncodedData;
  uint32_t v292;
  int FieldType;
  uint32_t v294;
  BOOL v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  size_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  uint64_t *v304;
  const void *v305;
  size_t v306;
  size_t v307;
  void **v308;
  int v309;
  __int16 v310;
  const char *v311;
  __int16 v312;
  const char *v313;
  __int16 v314;
  const char *v315;
  size_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  size_t v323;
  uint64_t v324;
  __int16 v325;
  const char *v326;
  void *v327;
  void *v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  unsigned int *v336;
  char v340;
  char v341;
  uint32_t FieldCount;
  size_t __n;
  size_t EncodedSize;
  int key;
  unint64_t v346;
  _QWORD *v347;
  unint64_t *v348;
  char *v349;
  unsigned int *v350;
  AAHeader_impl *v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  AAHeader_impl *header;
  AAHeader headera;
  const char *v357;
  int v358;
  AAHeader_impl *v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t data_size[2];
  __int128 v367;
  __int128 v368;
  uint64_t v369;
  __int128 v370;
  __int128 v371;
  __int128 v372;
  __int128 v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t length;
  uint64_t offset;
  uint64_t size[2];
  stat v379;
  char __s[2048];
  uint64_t v381;

  v8 = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v381 = *MEMORY[0x24BDAC8D0];
  v9 = v8;
  v360 = v8;
  switch(*(_DWORD *)v8)
  {
    case 0:
      v10 = *(_QWORD *)(v8 + 8);
      bzero(__s, 0x800uLL);
      memset(&v379, 0, sizeof(v379));
      v11 = atomic_load((unsigned int *)(v10 + 1288));
      if (v11)
        goto LABEL_19;
      v12 = *(_QWORD *)(v360 + 16);
      if (v12 >= *(_QWORD *)(v360 + 24))
        goto LABEL_19;
      v13 = (unint64_t *)(v10 + 1296);
      do
      {
        v14 = *(_QWORD *)(v10 + 1144);
        if (*(_DWORD *)(v14 + 72 * v12 + 60) != 68)
          goto LABEL_18;
        v15 = (const char *)(*(_QWORD *)(*(_QWORD *)(v10 + 1096) + 32)
                           + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 1096) + 8)
                                       + 16 * *(unsigned int *)(v14 + 72 * v12 + 64)));
        if ((stateConcatPath(v10, __s, v15) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 352, 120, 0, "invalid path", v16, v17, v340);
LABEL_16:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 370, 120, 0, "create dir failed: %s", v22, v23, (char)v15);
          do
            v24 = __ldxr(v13);
          while (__stxr(v24 + 1, v13));
          goto LABEL_18;
        }
        if (mkdir(__s, 0x1EDu))
        {
          if (!*(_DWORD *)(v10 + 1068)
            || *__error() != 2
            || (v18 = strlen(__s), makePath(__s, v18), mkdir(__s, 0x1EDu)))
          {
            if (*__error() != 17 || lstat(__s, &v379) || (v379.st_mode & 0xF000) != 0x4000)
            {
              v19 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 366, 120, v19, "creating directory: %s", v20, v21, (char)__s);
              goto LABEL_16;
            }
          }
        }
LABEL_18:
        ++v12;
      }
      while (v12 < *(_QWORD *)(v360 + 24));
LABEL_19:
      if (v11)
        return 0xFFFFFFFFLL;
      else
        return 0;
    case 1:
      v26 = *(_QWORD *)(v8 + 8);
      bzero(__s, 0x800uLL);
      bzero(&v379, 0x400uLL);
      v375 = 0;
      length = 0;
      v364 = 0;
      v365 = 0;
      v362 = 0;
      v363 = 0;
      v361 = 0;
      v374 = 0;
      v372 = 0u;
      v373 = 0u;
      v370 = 0u;
      v371 = 0u;
      v369 = 0;
      v367 = 0u;
      v368 = 0u;
      *(_OWORD *)data_size = 0u;
      if (atomic_load((unsigned int *)(v26 + 1288)))
        goto LABEL_29;
      v30 = *(unsigned int *)(v26 + 1152);
      if (!(_DWORD)v30)
        goto LABEL_28;
      v31 = 0;
      while (*(_QWORD *)(*(_QWORD *)(v26 + 1160) + 8 * v31) != v9)
      {
        if (v30 == ++v31)
        {
LABEL_28:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 489, 120, 0, "couldn't determine worker_id", v27, v28, v340);
LABEL_29:
          v32 = 0;
          goto LABEL_30;
        }
      }
      v166 = AAHeaderCreate();
      v32 = v166;
      if (!v166)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 492, 120, 0, "AAHeaderCreate", v171, v172, v340);
LABEL_30:
        v25 = 0xFFFFFFFFLL;
        goto LABEL_31;
      }
      v173 = *(_QWORD *)(v9 + 16);
      if (v173 >= *(_QWORD *)(v9 + 24))
      {
LABEL_431:
        v25 = 0;
        goto LABEL_31;
      }
      v349 = (char *)(v26 + 16);
      v350 = (unsigned int *)(v26 + 1288);
      v348 = (unint64_t *)(v26 + 1304);
      v174 = (unint64_t *)(v26 + 1296);
      v351 = v166;
      v352 = v26;
      while (1)
      {
        v175 = *(_QWORD *)(v26 + 1144);
        v364 = 0;
        v362 = 0;
        v375 = 0;
        headera = (AAHeader)(v175 + 72 * v173);
        v176 = (int *)((char *)headera + 60);
        if (*((_DWORD *)headera + 15) == 68)
        {
          if (*(_DWORD *)(v26 + 1072))
            goto LABEL_236;
          v177 = v175;
          EntryData = stateGetEntryData(v26, (uint64_t)headera, v167, v168, v169, v170, v171, v172);
          if (!EntryData)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 512, 120, 0, "invalid entry data", v171, v172, v340);
            goto LABEL_431;
          }
          v179 = *(_QWORD **)v26;
          v354 = v173;
          v180 = v177 + 72 * v173;
          v183 = *(_QWORD *)(v180 + 8);
          v181 = (_QWORD *)(v180 + 8);
          v182 = v183;
          if (!v179[4])
          {
            if (v182 != -1)
              goto LABEL_432;
LABEL_203:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 520, 120, 0, "invalid dir entry", v171, v172, v340);
            v189 = 0;
            v32 = v351;
            v26 = v352;
LABEL_204:
            v173 = v354;
            goto LABEL_230;
          }
          if (!v182)
            goto LABEL_203;
          v184 = (_DWORD *)EntryData;
          v185 = 0;
          v186 = *(_QWORD *)headera;
          v187 = EntryData;
          while (1)
          {
            v188 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v179[4])(*v179, v187, v182, v186);
            if (v188 < 0)
              break;
            if (v188)
            {
              v187 += v188;
              v185 += v188;
              v186 += v188;
              v182 -= v188;
              if (v182)
                continue;
            }
            goto LABEL_199;
          }
          v185 = v188;
LABEL_199:
          if (v185 != *v181)
          {
LABEL_432:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 516, 120, 0, "loading dir entry", v171, v172, v340);
            goto LABEL_433;
          }
          if (v185 < 4 || *v184 != 825246017 && *v184 != 826360153)
            goto LABEL_203;
          v26 = v352;
          v9 = v360;
          v32 = v351;
          v173 = v354;
          v175 = v177;
          v176 = (int *)((char *)headera + 60);
          if (*((_DWORD *)headera + 15) == 68)
            goto LABEL_236;
        }
        v353 = v175;
        v357 = (const char *)(*(_QWORD *)(*(_QWORD *)(v26 + 1096) + 32)
                            + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v26 + 1096) + 8)
                                        + 16 * *(unsigned int *)(v175 + 72 * v173 + 64)));
        if ((stateConcatPath(v26, __s, v357) & 0x80000000) != 0)
        {
          v211 = 528;
          v212 = "invalid path";
          goto LABEL_223;
        }
        v192 = strrchr(__s, 47);
        if (!v192)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 532, 120, 0, "invalid path", v193, v194, v340);
          v189 = 0;
          goto LABEL_230;
        }
        v195 = v192;
        v354 = v173;
        *v192 = 0;
        v196 = v192 + 1;
        if ((workerUpdateDir(v9, __s) & 0x80000000) != 0)
        {
          v213 = 535;
          v214 = "opening parent directory";
          goto LABEL_228;
        }
        *v195 = 47;
        v199 = *(_QWORD **)v26;
        if (!v199[4])
          goto LABEL_225;
        v200 = 0;
        v201 = *(_QWORD *)headera;
        v202 = *(_QWORD *)(v360 + 32);
        v203 = 6;
        do
        {
          v204 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v199[4])(*v199, v202, v203, v201);
          if (v204 < 0)
            goto LABEL_225;
          if (!v204)
            break;
          v202 += v204;
          v200 += v204;
          v201 += v204;
          v203 -= v204;
        }
        while (v203);
        if (v200 != 6)
        {
LABEL_225:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 541, 120, 0, "invalid entry", v197, v198, v340);
          v189 = 0;
          goto LABEL_226;
        }
        v26 = v352;
        v205 = *(_QWORD *)v352;
        if (!*(_QWORD *)(*(_QWORD *)v352 + 32))
          goto LABEL_279;
        v206 = *(_QWORD *)(v360 + 32);
        v207 = *(unsigned __int16 *)(v206 + 4);
        v346 = v207;
        v208 = 0;
        if (*(_WORD *)(v206 + 4))
        {
          v209 = *(_QWORD *)headera;
          while (1)
          {
            v210 = (*(uint64_t (**)(_QWORD, uint64_t, unint64_t, uint64_t))(v205 + 32))(*(_QWORD *)v205, v206, v207, v209);
            if (v210 < 0)
              break;
            if (v210)
            {
              v206 += v210;
              v208 += v210;
              v209 += v210;
              v207 -= v210;
              if (v207)
                continue;
            }
            goto LABEL_239;
          }
          v208 = v210;
        }
LABEL_239:
        v72 = v208 == v346;
        v26 = v352;
        if (!v72)
        {
LABEL_279:
          v213 = 544;
          v214 = "invalid entry";
LABEL_228:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v213, 120, 0, v214, v197, v198, v340);
          v189 = 0;
          goto LABEL_229;
        }
        v9 = v360;
        if ((aaHeaderInitWithEncodedData((uint64_t)v32, *(unsigned __int16 **)(v360 + 32), v346) & 0x80000000) != 0)
        {
          v245 = 545;
          v246 = "invalid header";
LABEL_294:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v245, 120, 0, v246, v220, v221, v340);
          v189 = 0;
          goto LABEL_204;
        }
        v222 = *v176;
        if (*v176 == 70)
        {
          v223.ikey = 5521732;
          KeyIndex = AAHeaderGetKeyIndex(v32, v223);
          if ((KeyIndex & 0x80000000) != 0)
          {
            v173 = v354;
            if (*(_QWORD *)(v353 + 72 * v354 + 16) != -1
              || *(_QWORD *)(v353 + 72 * v354 + 24) != -1
              || *(_QWORD *)(v353 + 72 * v354 + 32) != -1)
            {
              goto LABEL_359;
            }
            v211 = 553;
            v212 = "DAT field is required";
LABEL_223:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v211, 120, 0, v212, v190, v191, v340);
            v189 = 0;
LABEL_230:
            AAByteStreamClose(v189);
            goto LABEL_231;
          }
          if (AAHeaderGetFieldBlob(v32, KeyIndex, &v375, &v365) < 0)
          {
            v245 = 549;
            v246 = "getting DAT field";
            goto LABEL_294;
          }
          v227 = *(_QWORD *)(v353 + 72 * v354 + 16);
          if (v227 != -1
            && !stateShouldCreateFileInCluster(v352, 0, v227, v354, v225, v226, v220, v221)
            || (v228 = *(_QWORD *)(v353 + 72 * v354 + 24), v228 != -1)
            && !stateShouldCreateFileInCluster(v352, 1u, v228, v354, v225, v226, v220, v221)
            || (v229 = *(_QWORD *)(v353 + 72 * v354 + 32), v229 != -1)
            && !stateShouldCreateFileInCluster(v352, 2u, v229, v354, v225, v226, v220, v221))
          {
            AAByteStreamClose(0);
            v347 = *(_QWORD **)(*(_QWORD *)(v352 + 1160) + 8 * v31);
            EncodedSize = AAHeaderGetEncodedSize(v32);
            v247 = AAHeaderClone(v32);
            v248.ikey = 5521732;
            v249 = AAHeaderGetKeyIndex(v247, v248);
            if ((v249 & 0x80000000) == 0 && AAHeaderRemoveField(v247, v249) < 0)
            {
              v254 = 293;
              v255 = "removing DAT field";
              goto LABEL_415;
            }
            key = v249;
            v252 = AAHeaderGetEncodedSize(v247);
            PayloadSize = AAHeaderGetPayloadSize(v247);
            __n = v252 + PayloadSize;
            if (__CFADD__(v252, PayloadSize))
            {
              v254 = 298;
              v255 = "entry too large to defer";
              goto LABEL_415;
            }
            v288 = v252;
            v289 = workerReserve((uint64_t)v347, __n);
            if (v289 < 0)
            {
              v254 = 301;
              v255 = "allocating worker buf";
              goto LABEL_415;
            }
            v290 = (void *)v347[4];
            EncodedData = AAHeaderGetEncodedData(v247);
            memcpy(v290, EncodedData, v252);
            FieldCount = AAHeaderGetFieldCount(v351);
            if (FieldCount)
            {
              v292 = 0;
              do
              {
                FieldType = AAHeaderGetFieldType(v351, v292);
                v294 = v292;
                v295 = v292 != key || key <= -1;
                if (v295 && FieldType == 5)
                {
                  offset = 0;
                  size[0] = 0;
                  if (AAHeaderGetFieldBlob(v351, v292, size, &offset) < 0)
                  {
                    v254 = 313;
                    v255 = "getting blob field";
                    goto LABEL_415;
                  }
                  v296 = size[0];
                  v297 = *(_QWORD *)headera + EncodedSize + offset;
                  offset = v297;
                  if (size[0] + v288 > v347[5])
                  {
                    v254 = 315;
                    v255 = "invalid blob size";
                    goto LABEL_415;
                  }
                  v298 = *(_QWORD *)v352;
                  if (!*(_QWORD *)(*(_QWORD *)v352 + 32))
                    goto LABEL_368;
                  v299 = 0;
                  if (size[0])
                  {
                    v300 = v347[4] + v288;
                    do
                    {
                      v301 = (*(uint64_t (**)(_QWORD, size_t, uint64_t, uint64_t))(v298 + 32))(*(_QWORD *)v298, v300, v296, v297);
                      if (v301 < 0)
                        goto LABEL_368;
                      if (!v301)
                        break;
                      v300 += v301;
                      v299 += v301;
                      v297 += v301;
                      v296 -= v301;
                    }
                    while (v296);
                    if (v299 < 0 || v299 != size[0])
                    {
LABEL_368:
                      v254 = 319;
                      v255 = "reading blob";
                      goto LABEL_415;
                    }
                  }
                  v288 += v299;
                }
                v292 = v294 + 1;
              }
              while (v294 + 1 != FieldCount);
            }
            if (v288 != __n)
            {
              v254 = 322;
              v255 = "entry size mismatch";
              goto LABEL_415;
            }
            v302 = v347[264];
            v152 = __CFADD__(v302, __n);
            v303 = v302 + __n;
            if (!v152 && (v303 & 0x8000000000000000) == 0)
            {
              v304 = v347 + 264;
              v305 = (const void *)v347[4];
              v306 = v347[265];
              if (v306 >= v303)
              {
LABEL_396:
                v329 = v347[266];
                if (v305)
                {
                  memcpy((void *)(v329 + *v304), v305, __n);
                }
                else if (v329)
                {
                  memset_s((void *)(v329 + *v304), __n, 0, __n);
                }
                v332 = v353 + 72 * v354;
                v333 = *v304;
                *(_QWORD *)(v332 + 40) = *v304;
                *(_QWORD *)(v332 + 48) = __n;
                *v304 = v333 + __n;
                if ((__n & 0x8000000000000000) == 0)
                {
                  v173 = v354;
                  *(_DWORD *)(v353 + 72 * v354 + 56) = v31;
                  AAHeaderDestroy(v247);
                  v9 = v360;
                  v32 = v351;
                  v26 = v352;
                  goto LABEL_236;
                }
              }
              else
              {
                do
                {
                  while (!v306)
                  {
                    v306 = 0x4000;
                    if (v303 <= 0x4000)
                    {
                      v308 = (void **)(v347 + 266);
                      v306 = 0x4000;
                      goto LABEL_394;
                    }
                  }
                  v307 = v306 >> 1;
                  if ((v306 & (v306 >> 1)) != 0)
                    v307 = v306 & (v306 >> 1);
                  v306 += v307;
                }
                while (v306 < v303);
                v308 = (void **)(v347 + 266);
                if (v306 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_413;
                }
LABEL_394:
                v327 = *v308;
                v328 = realloc(*v308, v306);
                if (v328)
                {
                  v347[266] = v328;
                  v347[265] = v306;
                  goto LABEL_396;
                }
                free(v327);
LABEL_413:
                *v308 = 0;
                *v304 = 0;
                v347[265] = 0;
              }
            }
            v254 = 325;
            v255 = "storing entry in worker blob";
LABEL_415:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDeferEntry", v254, 120, 0, v255, v250, v251, v340);
            AAHeaderDestroy(v247);
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 651, 120, 0, "storing deferred entry", v334, v335, v341);
            v32 = v351;
            v26 = v352;
            v173 = v354;
            goto LABEL_231;
          }
          v222 = *v176;
        }
        if (v222 == 76)
        {
          v230.ikey = 4935244;
          v231 = AAHeaderGetKeyIndex(v32, v230);
          if ((v231 & 0x80000000) != 0
            || ((FieldString = AAHeaderGetFieldString(v32, v231, 0x400uLL, (char *)&v379, &length), FieldString <= 1)
              ? (v233 = 1)
              : (v233 = FieldString),
                v233 <= 0))
          {
            v245 = 563;
            v246 = "missing LNK field";
            goto LABEL_294;
          }
        }
        v234.ikey = 5521752;
        v235 = AAHeaderGetKeyIndex(v32, v234);
        if ((v235 & 0x80000000) != 0
          || ((FieldBlob = AAHeaderGetFieldBlob(v32, v235, &v364, &v363), FieldBlob <= 1)
            ? (v237 = 1)
            : (v237 = FieldBlob),
              v237 <= 0))
        {
          v364 = 0;
        }
        v238.ikey = 4997953;
        v239 = AAHeaderGetKeyIndex(v32, v238);
        if ((v239 & 0x80000000) != 0
          || ((v240 = AAHeaderGetFieldBlob(v32, v239, &v362, &v361), v240 <= 1) ? (v241 = 1) : (v241 = v240), v241 <= 0))
        {
          v362 = 0;
        }
        v242 = *(_QWORD *)headera + v346;
        v365 += v242;
        v363 += v242;
        v361 += v242;
        if ((aaEntryAttributesInitWithHeader((char *)&v370, (char *)data_size, 0, v32) & 0x80000000) != 0)
        {
          v245 = 571;
          v246 = "setting attributes from header";
          goto LABEL_294;
        }
        if (*(_DWORD *)(v352 + 1064))
          unlinkat(*(_DWORD *)(v360 + 2104), v196, 0);
        if (*v176 != 70)
        {
          if (*v176 != 76)
          {
            v245 = 584;
            v246 = "unsupported entry type";
            goto LABEL_294;
          }
          if (symlinkat((const char *)&v379, *(_DWORD *)(v360 + 2104), v196) < 0)
          {
            v309 = *__error();
            v310 = 581;
            v311 = "symlink";
            goto LABEL_363;
          }
          v9 = v360;
          v32 = v351;
          v26 = v352;
          if (*v176 != 70)
          {
            v173 = v354;
            if ((aaEntryAttributesApplyToPath((char *)&v370, v349, v357, *(_QWORD *)(v352 + 1056)) & 0x80000000) == 0)
              goto LABEL_359;
            v211 = 591;
            v212 = "setting attributes";
            goto LABEL_223;
          }
        }
        if ((v370 & 4) != 0)
        {
          v243 = data_size[0];
          v244 = -1;
          if ((BYTE12(v370) & 0x20) != 0 && v375)
            v244 = (LOBYTE(data_size[0]) << 31 >> 31) & data_size[1];
        }
        else
        {
          v243 = data_size[0];
          v244 = -1;
        }
        if ((v243 & 8) != 0)
        {
          if ((*(_BYTE *)(v352 + 1062) & 2) != 0)
            v256 = HIDWORD(data_size[0]);
          else
            v256 = -1;
        }
        else
        {
          v256 = -1;
        }
        v189 = (AAByteStream_impl *)aaArchiveFileOutputStreamOpenAt(*(_DWORD *)(v360 + 2104), v196, v375, v244, 0, v256, *(_QWORD *)(v352 + 1088));
        if (!v189)
        {
          v286 = 610;
          v287 = "creating file stream";
          goto LABEL_366;
        }
        v264 = v375;
        if (v375)
        {
          v265 = 0;
          while (1)
          {
            v266 = v264 - v265;
            if (*(_QWORD *)(v360 + 40) >= v266)
              v267 = v266;
            else
              v267 = *(_QWORD *)(v360 + 40);
            v268 = AAByteStreamPRead(*(AAByteStream *)v352, *(void **)(v360 + 32), v267, v365 + v265);
            if (v268 < 0)
            {
              v286 = 617;
              v287 = "read failed";
              goto LABEL_366;
            }
            v269 = v268;
            if (AAByteStreamWrite(v189, *(const void **)(v360 + 32), v268) != v268)
              break;
            v265 += v269;
            v270 = *(uint64_t (**)(_QWORD, uint64_t, const char *, uint64_t *))(v352 + 1048);
            if (v270)
            {
              size[0] = v375;
              size[1] = v265;
              if ((v270(*(_QWORD *)(v352 + 1040), 60, v357, size) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 629, 120, 0, "callback cancel", v262, v263, v340);
                while (!__ldaxr(v350))
                {
                  if (!__stlxr(1u, v350))
                    goto LABEL_433;
                }
                __clrex();
LABEL_433:
                v25 = 0xFFFFFFFFLL;
                v32 = v351;
LABEL_31:
                v33 = v32;
                goto LABEL_120;
              }
            }
            v264 = v375;
            if (v265 >= v375)
              goto LABEL_314;
          }
          v286 = 619;
          v287 = "write failed";
LABEL_366:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v286, 120, 0, v287, v262, v263, v340);
          goto LABEL_367;
        }
LABEL_314:
        v271 = aaArchiveFileOutputStreamCloseAndReturnFD((uint64_t (**)(uint64_t))v189, v257, v258, v259, v260, v261, v262, v263);
        if ((v271 & 0x80000000) != 0)
        {
          v310 = 636;
          v309 = 0;
          v311 = "invalid fd";
LABEL_363:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v310, 120, v309, v311, v272, v273, v340);
          v189 = 0;
LABEL_367:
          v32 = v351;
LABEL_226:
          v26 = v352;
LABEL_229:
          v173 = v354;
          goto LABEL_230;
        }
        v274 = v271;
        if ((workerApplyAttr(v360, (uint64_t)headera, v271, (char *)&v370) & 0x80000000) != 0)
        {
          v312 = 637;
          v313 = "setting attributes";
        }
        else
        {
          v277 = v364;
          if (!v364)
            goto LABEL_379;
          v278 = v363;
          if ((workerReserve(v360, v364) & 0x80000000) != 0)
          {
            v314 = 248;
            v315 = "allocating worker buf";
          }
          else
          {
            v281 = **(_QWORD **)(v360 + 8);
            if (*(_QWORD *)(v281 + 32))
            {
              v282 = 0;
              v283 = *(_QWORD *)(v360 + 32);
              v284 = v277;
              while (1)
              {
                v285 = (*(uint64_t (**)(_QWORD, uint64_t, size_t, uint64_t))(v281 + 32))(*(_QWORD *)v281, v283, v284, v278);
                if (v285 < 0)
                  break;
                if (v285)
                {
                  v283 += v285;
                  v282 += v285;
                  v278 += v285;
                  v284 -= v285;
                  if (v284)
                    continue;
                }
                goto LABEL_377;
              }
              v282 = v285;
            }
            else
            {
              v282 = -1;
            }
LABEL_377:
            if (v282 == v277)
            {
              if ((workerDecodeAndApplyXAT(v360, (uint64_t)headera, v274, *(uint8_t **)(v360 + 32), v277) & 0x80000000) == 0)
              {
LABEL_379:
                v316 = v362;
                if (!v362)
                  goto LABEL_401;
                v317 = v361;
                if ((workerReserve(v360, v362) & 0x80000000) != 0)
                {
                  v325 = 269;
                  v326 = "allocating worker buf";
                }
                else
                {
                  v320 = **(_QWORD **)(v360 + 8);
                  if (*(_QWORD *)(v320 + 32))
                  {
                    v321 = 0;
                    v322 = *(_QWORD *)(v360 + 32);
                    v323 = v316;
                    while (1)
                    {
                      v324 = (*(uint64_t (**)(_QWORD, uint64_t, size_t, uint64_t))(v320 + 32))(*(_QWORD *)v320, v322, v323, v317);
                      if (v324 < 0)
                        break;
                      if (v324)
                      {
                        v322 += v324;
                        v321 += v324;
                        v317 += v324;
                        v323 -= v324;
                        if (v323)
                          continue;
                      }
                      goto LABEL_399;
                    }
                    v321 = v324;
                  }
                  else
                  {
                    v321 = -1;
                  }
LABEL_399:
                  if (v321 == v316)
                  {
                    if ((workerDecodeAndApplyACL(v360, (uint64_t)headera, v274, *(uint8_t **)(v360 + 32), v316) & 0x80000000) == 0)
                    {
LABEL_401:
                      v330 = v375;
                      do
                        v331 = __ldxr(v348);
                      while (__stxr(v331 + v330, v348));
                      close(v274);
                      v9 = v360;
                      v32 = v351;
                      v26 = v352;
                      v173 = v354;
LABEL_359:
                      AAByteStreamClose(0);
                      v218 = 21;
                      goto LABEL_234;
                    }
                    v325 = 276;
                    v326 = "applying ACL";
                  }
                  else
                  {
                    v325 = 273;
                    v326 = "loading ACL blob";
                  }
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerLoadAndApplyACL", v325, 120, 0, v326, v318, v319, v340);
                v312 = 639;
                v313 = "loading and applying ACL";
                goto LABEL_407;
              }
              v314 = 255;
              v315 = "applying XAT";
            }
            else
            {
              v314 = 252;
              v315 = "loading XAT blob";
            }
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerLoadAndApplyXAT", v314, 120, 0, v315, v279, v280, v340);
          v312 = 638;
          v313 = "loading and applying XAT";
        }
LABEL_407:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v312, 120, 0, v313, v275, v276, v340);
        close(v274);
        AAByteStreamClose(0);
        v32 = v351;
        v26 = v352;
        v173 = v354;
LABEL_231:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 656, 120, 0, "extract entry failed: %s", v215, v216, (char)v357);
        v9 = v360;
        do
          v217 = __ldxr(v174);
        while (__stxr(v217 + 1, v174));
        v218 = 22;
LABEL_234:
        v219 = *(uint64_t (**)(_QWORD, uint64_t, const char *, AAHeader_impl *))(v26 + 1048);
        if (v219 && (v219(*(_QWORD *)(v26 + 1040), v218, v357, v32) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 663, 120, 0, "Caller cancelled", v171, v172, v340);
          v25 = 0xFFFFFFFFLL;
          while (!__ldaxr(v350))
          {
            if (!__stlxr(1u, v350))
              goto LABEL_31;
          }
          __clrex();
          goto LABEL_30;
        }
LABEL_236:
        if (++v173 >= *(_QWORD *)(v9 + 24))
          goto LABEL_431;
      }
    case 2:
      v34 = *(_QWORD *)(v8 + 8);
      bzero(__s, 0x800uLL);
      bzero(&v379, 0x800uLL);
      offset = 0;
      size[0] = 0;
      v375 = 0;
      length = 0;
      v374 = 0;
      v372 = 0u;
      v373 = 0u;
      v370 = 0u;
      v371 = 0u;
      v369 = 0;
      v367 = 0u;
      v368 = 0u;
      *(_OWORD *)data_size = 0u;
      v35 = AAHeaderCreate();
      v38 = v35;
      if (!v35)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 689, 120, 0, "AAHeaderCreate", v36, v37, v340);
        goto LABEL_118;
      }
      v39 = *(_QWORD *)(v9 + 16);
      if (v39 >= *(_QWORD *)(v9 + 24))
      {
LABEL_116:
        v25 = 0;
        goto LABEL_119;
      }
      v40 = (unint64_t *)(v34 + 1296);
      v358 = -1;
      header = v35;
      while (1)
      {
        v41 = *(_QWORD *)(v34 + 1144);
        v42 = v41 + 72 * v39;
        if (*(_DWORD *)(v42 + 60) != 70)
          goto LABEL_64;
        v44 = (unint64_t *)(v42 + 48);
        v43 = *(_QWORD *)(v42 + 48);
        v45 = v41 + 72 * v39;
        v47 = *(_QWORD *)(v45 + 16);
        v46 = (unint64_t *)(v45 + 16);
        if (v47 == -1 && *(_QWORD *)(v41 + 72 * v39 + 24) == -1)
        {
          v72 = *(_QWORD *)(v41 + 72 * v39 + 32) == -1 || v43 == 0;
          if (v72)
          {
LABEL_63:
            v9 = v360;
            goto LABEL_64;
          }
        }
        else if (!v43)
        {
          goto LABEL_63;
        }
        v48 = (const char *)(*(_QWORD *)(*(_QWORD *)(v34 + 1096) + 32)
                           + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 1096) + 8)
                                       + 16 * *(unsigned int *)(v41 + 72 * v39 + 64)));
        if ((stateConcatPath(v34, __s, v48) & 0x80000000) != 0)
          break;
        v55 = (unsigned __int16 *)stateGetEntryData(v34, v42, v49, v50, v51, v52, v53, v54);
        if (!v55)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 708, 120, 0, "invalid entry data", v56, v57, v340);
          v25 = 0;
          v38 = header;
          goto LABEL_119;
        }
        v58 = *v44;
        if (*v44 <= 5)
        {
          v59 = 710;
          goto LABEL_46;
        }
        v62 = v55;
        v63 = v55[2];
        if (v58 < v63)
        {
          v59 = 712;
LABEL_46:
          v64 = "invalid entry";
LABEL_47:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", v59, 120, 0, v64, v56, v57, v340);
LABEL_48:
          v38 = header;
          goto LABEL_49;
        }
        if ((aaHeaderInitWithEncodedData((uint64_t)header, v55, v63) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 713, 120, 0, "invalid header", v73, v74, v340);
          v38 = header;
LABEL_49:
          v65 = v358;
          if (v358 < 0)
            goto LABEL_51;
          goto LABEL_50;
        }
        v75.ikey = 5521752;
        v76 = AAHeaderGetKeyIndex(header, v75);
        if ((v76 & 0x80000000) != 0
          || ((v77 = AAHeaderGetFieldBlob(header, v76, size, &offset), v77 <= 1) ? (v78 = 1) : (v78 = v77), v78 <= 0))
        {
          size[0] = 0;
        }
        v79.ikey = 4997953;
        v80 = AAHeaderGetKeyIndex(header, v79);
        if ((v80 & 0x80000000) != 0
          || ((v81 = AAHeaderGetFieldBlob(header, v80, &length, &v375), v81 <= 1) ? (v82 = 1) : (v82 = v81), v82 <= 0))
        {
          length = 0;
        }
        v83 = offset + v63;
        offset += v63;
        v84 = v375 + v63;
        v375 += v63;
        if (size[0] && size[0] + v83 > v43 || length && length + v84 > v43)
        {
          v59 = 721;
          v64 = "invalid blob sizes";
          goto LABEL_47;
        }
        if ((aaEntryAttributesInitWithHeader((char *)&v370, (char *)data_size, 0, header) & 0x80000000) != 0)
        {
          v59 = 722;
          v64 = "setting attributes from header";
          goto LABEL_47;
        }
        v85 = *v46;
        v86 = *(_QWORD *)(v34 + 1240);
        v87 = (_QWORD *)(v34 + 1264);
        v88 = *v46;
        if (*v46 >= v86
          && (v88 = *(_QWORD *)(v41 + 72 * v39 + 24), v87 = (_QWORD *)(v34 + 1272), v88 >= *(_QWORD *)(v34 + 1248))
          && (v88 = *(_QWORD *)(v41 + 72 * v39 + 32), v87 = (_QWORD *)(v34 + 1280), v88 >= *(_QWORD *)(v34 + 1256))
          || (v89 = *(_QWORD *)(*v87 + 8 * v88), v89 == -1))
        {
          v59 = 730;
          v64 = "missing reference entry in cluster";
          goto LABEL_47;
        }
        if ((stateConcatPath(v34, (char *)&v379, (const char *)(*(_QWORD *)(*(_QWORD *)(v34 + 1096) + 32)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v34 + 1096) + 8)+ 16 * *(unsigned int *)(*(_QWORD *)(v34 + 1144) + 72 * v89 + 64)))) & 0x80000000) != 0)
        {
          v59 = 733;
          v64 = "invalid path";
          goto LABEL_47;
        }
        if (*(_DWORD *)(v34 + 1064))
          unlink(__s);
        if (v85 >= v86)
        {
          if (clonefile((const char *)&v379, __s, 0)
            && (copyFileSegment((const char *)&v379, 0, 0xFFFFFFFFFFFFFFFFLL, __s) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 745, 120, 0, "cloning file, falling back to copy, failed: %s", v93, v94, (char)__s);
            goto LABEL_48;
          }
        }
        else if (link((const char *)&v379, __s) < 0)
        {
          v90 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 754, 120, v90, "hard link: %s", v91, v92, (char)__s);
          goto LABEL_48;
        }
        v95 = open(__s, 0x200000);
        if ((v95 & 0x80000000) == 0)
        {
          v96 = v95;
          if ((workerApplyAttr(v360, v42, v95, (char *)&v370) & 0x80000000) != 0)
          {
            v102 = 760;
            v103 = "setting attributes";
          }
          else if (size[0]
                 && (workerDecodeAndApplyXAT(v360, v42, v96, (uint8_t *)v62 + offset, size[0]) & 0x80000000) != 0)
          {
            v102 = 761;
            v103 = "loading and applying XAT";
          }
          else
          {
            if (!length || (workerDecodeAndApplyACL(v360, v42, v96, (uint8_t *)v62 + v375, length) & 0x80000000) == 0)
            {
              close(v96);
              v67 = 21;
              v358 = -1;
              v38 = header;
              goto LABEL_54;
            }
            v102 = 762;
            v103 = "loading and applying ACL";
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", v102, 120, 0, v103, v97, v98, v340);
          v38 = header;
          v65 = v96;
LABEL_50:
          close(v65);
          v358 = -1;
          goto LABEL_51;
        }
        v358 = v95;
        v99 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 759, 120, *v99, "open: %s", v100, v101, (char)__s);
        v38 = header;
LABEL_51:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 766, 120, 0, "extract cluster entry failed: %s", v60, v61, (char)v48);
        do
          v66 = __ldxr(v40);
        while (__stxr(v66 + 1, v40));
        v67 = 22;
LABEL_54:
        v68 = *(uint64_t (**)(_QWORD, uint64_t, const char *, AAHeader_impl *))(v34 + 1048);
        if (v68)
        {
          v69 = v68(*(_QWORD *)(v34 + 1040), v67, v48, v38);
          v9 = v360;
          if (v69 < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 773, 120, 0, "Caller cancelled", v70, v71, v340);
            v336 = (unsigned int *)(v34 + 1288);
            v25 = 0xFFFFFFFFLL;
            while (!__ldaxr(v336))
            {
              if (!__stlxr(1u, v336))
                goto LABEL_119;
            }
            __clrex();
LABEL_118:
            v25 = 0xFFFFFFFFLL;
LABEL_119:
            v33 = v38;
LABEL_120:
            AAHeaderDestroy(v33);
            return v25;
          }
        }
        else
        {
          v9 = v360;
        }
LABEL_64:
        if (++v39 >= *(_QWORD *)(v9 + 24))
          goto LABEL_116;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 704, 120, 0, "invalid path", v53, v54, v340);
      goto LABEL_49;
    case 3:
      v104 = *(_QWORD *)(v8 + 8);
      bzero(__s, 0x800uLL);
      data_size[0] = 0;
      offset = 0;
      size[0] = 0;
      length = 0;
      memset(&v379, 0, 72);
      *(_QWORD *)&v373 = 0;
      v372 = 0u;
      v370 = 0u;
      v371 = 0u;
      if (atomic_load((unsigned int *)(v104 + 1288)))
        goto LABEL_115;
      v33 = AAHeaderCreate();
      if (!v33)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 398, 120, 0, "AAHeaderCreate", v107, v108, v340);
LABEL_115:
        v33 = 0;
        v25 = 0xFFFFFFFFLL;
        goto LABEL_120;
      }
      v109 = *(_QWORD *)(v9 + 16);
      if (v109 >= *(_QWORD *)(v9 + 24))
      {
        v25 = 0;
        goto LABEL_120;
      }
      v359 = v33;
      v110 = (unint64_t *)(v104 + 1296);
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while (1)
  {
    v111 = *(_QWORD *)(v104 + 1144);
    v112 = v111 + 72 * v109;
    data_size[0] = 0;
    offset = 0;
    if (*(_DWORD *)(v112 + 60) != 68)
      goto LABEL_144;
    v113 = *(_DWORD *)(v9 + 2108);
    if (v113 != -1 && v113 != *(unsigned __int16 *)(v111 + 72 * v109 + 68))
      goto LABEL_144;
    v114 = (const char *)(*(_QWORD *)(*(_QWORD *)(v104 + 1096) + 32)
                        + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v104 + 1096) + 8)
                                    + 16 * *(unsigned int *)(v111 + 72 * v109 + 64)));
    if ((stateConcatPath(v104, __s, v114) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 413, 120, 0, "invalid path", v115, v116, v340);
      goto LABEL_142;
    }
    v117 = strrchr(__s, 47);
    if (!v117)
      break;
    v120 = v117;
    *v117 = 0;
    v121 = v117 + 1;
    if ((workerUpdateDir(v9, __s) & 0x80000000) != 0)
    {
      v136 = 420;
      v137 = "opening parent directory";
      goto LABEL_137;
    }
    *v120 = 47;
    v126 = (unsigned __int16 *)stateGetEntryData(v104, v112, v122, v123, v124, v125, v118, v119);
    if (!v126)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 426, 120, 0, "invalid entry data", v127, v128, v340);
LABEL_424:
      v25 = 0;
      v33 = v359;
      goto LABEL_120;
    }
    v129 = v111 + 72 * v109;
    v132 = *(_QWORD *)(v129 + 48);
    v131 = (uint64_t *)(v129 + 48);
    v130 = v132;
    if (v132 <= 5)
    {
      v133 = 428;
      goto LABEL_140;
    }
    v138 = v126;
    v139 = v126[2];
    if (v130 < v139)
    {
      v133 = 430;
LABEL_140:
      v140 = "invalid entry";
LABEL_141:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v133, 120, 0, v140, v127, v128, v340);
      v9 = v360;
      goto LABEL_142;
    }
    if ((aaHeaderInitWithEncodedData((uint64_t)v359, v126, v139) & 0x80000000) != 0)
    {
      v133 = 431;
      v140 = "invalid header";
      goto LABEL_141;
    }
    v142.ikey = 5521752;
    v143 = AAHeaderGetKeyIndex(v359, v142);
    if ((v143 & 0x80000000) != 0
      || ((v144 = AAHeaderGetFieldBlob(v359, v143, data_size, size), v144 <= 1) ? (v145 = 1) : (v145 = v144), v145 <= 0))
    {
      data_size[0] = 0;
    }
    v146.ikey = 4997953;
    v147 = AAHeaderGetKeyIndex(v359, v146);
    if ((v147 & 0x80000000) != 0
      || ((v148 = AAHeaderGetFieldBlob(v359, v147, &offset, &length), v148 <= 1) ? (v149 = 1) : (v149 = v148), v149 <= 0))
    {
      offset = 0;
    }
    v150 = size[0] + v139;
    size[0] += v139;
    v151 = length + v139;
    length += v139;
    if (data_size[0])
    {
      v152 = __CFADD__(v150, data_size[0]);
      v153 = v150 + data_size[0];
      if (v152 || v153 > *v131)
      {
        v133 = 438;
        v140 = "invalid XAT blob size";
        goto LABEL_141;
      }
    }
    if (offset)
    {
      v152 = __CFADD__(v151, offset);
      v154 = v151 + offset;
      if (v152 || v154 > *v131)
      {
        v133 = 441;
        v140 = "invalid ACL blob size";
        goto LABEL_141;
      }
    }
    if ((aaEntryAttributesInitWithHeader((char *)&v379, (char *)&v370, 0, v359) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 442, 120, 0, "setting attributes from header", v155, v156, v340);
      v9 = v360;
      goto LABEL_142;
    }
    v157 = openat(*(_DWORD *)(v360 + 2104), v121, 0);
    if ((v157 & 0x80000000) != 0)
    {
      v161 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 446, 120, *v161, "open", v162, v163, v340);
      v9 = v360;
      goto LABEL_142;
    }
    v158 = v157;
    if ((workerApplyAttr(v360, v112, v157, (char *)&v379) & 0x80000000) != 0)
    {
      v164 = 447;
      v165 = "setting attributes";
      goto LABEL_181;
    }
    if (data_size[0]
      && (workerDecodeAndApplyXAT(v360, v112, v158, (uint8_t *)v138 + size[0], data_size[0]) & 0x80000000) != 0)
    {
      v164 = 449;
      v165 = "loading and applying XAT";
      goto LABEL_181;
    }
    if (offset && (workerDecodeAndApplyACL(v360, v112, v158, (uint8_t *)v138 + length, offset) & 0x80000000) != 0)
    {
      v164 = 450;
      v165 = "loading and applying ACL";
LABEL_181:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v164, 120, 0, v165, v159, v160, v340);
      close(v158);
      v9 = v360;
LABEL_142:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 454, 120, 0, "set dir attributes failed: %s", v134, v135, (char)v114);
      do
        v141 = __ldxr(v110);
      while (__stxr(v141 + 1, v110));
      goto LABEL_144;
    }
    close(v158);
    v9 = v360;
LABEL_144:
    if (++v109 >= *(_QWORD *)(v9 + 24))
      goto LABEL_424;
  }
  v136 = 417;
  v137 = "invalid path";
LABEL_137:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v136, 120, 0, v137, v118, v119, v340);
  goto LABEL_142;
}

void workerDestroy_0(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 2104);
    if ((v2 & 0x80000000) == 0)
      close(v2);
    free(*(void **)(a1 + 32));
    free(*(void **)(a1 + 2128));
    memset_s((void *)(a1 + 2112), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
}

uint64_t stateConcatPath(uint64_t a1, char *a2, const char *a3)
{
  char *v4;

  v4 = (char *)(a1 + 16);
  if (*(_DWORD *)(a1 + 1068))
    return concatPath(a2, 0x800uLL, v4, a3);
  else
    return concatExtractPath(a2, 0x800uLL, v4, a3);
}

uint64_t stateGetEntryData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char vars0;

  v8 = *(unsigned int *)(a2 + 56);
  if ((_DWORD)v8 == -1)
  {
    v15 = *(_QWORD *)(a2 + 40);
    v16 = *(_QWORD *)(a2 + 48);
    v11 = __CFADD__(v15, v16);
    v17 = v15 + v16;
    if (!v11 && v17 <= *(_QWORD *)(a1 + 1104))
      return *(_QWORD *)(a1 + 1120) + v15;
  }
  else if (v8 >= *(_DWORD *)(a1 + 1152))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateGetEntryData", 1008, 120, 0, "invalid worker index", a7, a8, vars0);
  }
  else
  {
    v9 = *(_QWORD *)(a2 + 40);
    v10 = *(_QWORD *)(a2 + 48);
    v11 = __CFADD__(v9, v10);
    v12 = v9 + v10;
    if (!v11)
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 1160) + 8 * v8);
      if (v12 <= *(_QWORD *)(v13 + 2112))
        return *(_QWORD *)(v13 + 2128) + v9;
    }
  }
  return 0;
}

uint64_t workerUpdateDir(uint64_t a1, char *__s)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  int v8;
  uint64_t result;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char v15;

  v4 = strlen(__s);
  v7 = v4;
  v8 = *(_DWORD *)(a1 + 2104);
  if ((v8 & 0x80000000) == 0)
  {
    if (v4 == *(_QWORD *)(a1 + 2096))
    {
      result = strcmp(__s, (const char *)(a1 + 48));
      if (!(_DWORD)result)
        return result;
    }
    close(v8);
    *(_DWORD *)(a1 + 2104) = -1;
  }
  if (v7 >= 0x800)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerUpdateDir", 150, 120, 0, "directory path too long", v5, v6, v15);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 2096) = v7;
  memcpy((void *)(a1 + 48), __s, v7);
  *(_BYTE *)(a1 + 48 + v7) = 0;
  v10 = open((const char *)(a1 + 48), 0);
  result = 0;
  *(_DWORD *)(a1 + 2104) = v10;
  if (v10 < 0)
  {
    makePath((const char *)(a1 + 48), *(_QWORD *)(a1 + 2096));
    mkdir((const char *)(a1 + 48), 0x1EDu);
    v11 = open((const char *)(a1 + 48), 0);
    result = 0;
    *(_DWORD *)(a1 + 2104) = v11;
    if (v11 < 0)
    {
      v12 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerUpdateDir", 164, 120, v12, "open: %s", v13, v14, a1 + 48);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t stateShouldCreateFileInCluster(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  pthread_mutex_t *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v16;
  __int16 v17;
  char v18;

  if (*(_QWORD *)(a1 + 8 * a2 + 1240) <= a3)
  {
    v16 = "invalid index in HLC/CLC/SLC cluster";
    v17 = 1019;
  }
  else
  {
    v12 = (pthread_mutex_t *)(a1 + 1176);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1176)) < 0)
    {
      v16 = "pthread_mutex_lock";
      v17 = 1020;
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 8 * a2 + 1264);
      v14 = *(_QWORD *)(v13 + 8 * a3);
      if (v14 == -1)
        *(_QWORD *)(v13 + 8 * a3) = a4;
      if ((pthread_mutex_unlock(v12) & 0x80000000) == 0)
        return v14 == -1;
      v16 = "pthread_mutex_lock";
      v17 = 1023;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateShouldCreateFileInCluster", v17, 120, 0, v16, a7, a8, v18);
  return 0xFFFFFFFFLL;
}

uint64_t workerApplyAttr(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  _QWORD *v6;
  uint64_t (*v7)(_QWORD, uint64_t, _QWORD, char *);
  uint64_t v8;
  uint64_t v9;
  const char *v11;
  __int16 v12;
  char v13;

  v6 = *(_QWORD **)(a1 + 8);
  v7 = (uint64_t (*)(_QWORD, uint64_t, _QWORD, char *))v6[131];
  if (v7
    && (v7(v6[130], 23, *(_QWORD *)(v6[137] + 32) + *(_QWORD *)(*(_QWORD *)(v6[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), a4) & 0x80000000) != 0)
  {
    v11 = "user error";
    v12 = 178;
  }
  else
  {
    if ((aaEntryAttributesApplyToFD(a4, a3, v6[132]) & 0x80000000) == 0)
      return 0;
    v11 = "setting attributes";
    v12 = 182;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerApplyAttr", v12, 120, 0, v11, v8, v9, v13);
  return 0xFFFFFFFFLL;
}

uint64_t workerReserve(uint64_t a1, size_t a2)
{
  uint64_t result;
  void *v4;
  void *v5;
  void *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (*(_QWORD *)(a1 + 40) >= a2)
    return 0;
  *(_QWORD *)(a1 + 40) = a2;
  if (a2 < 0x2000000001)
  {
    v4 = *(void **)(a1 + 32);
    v5 = realloc(v4, a2);
    if (v5)
    {
      v6 = v5;
      result = 0;
      *(_QWORD *)(a1 + 32) = v6;
      return result;
    }
    free(v4);
  }
  else
  {
    *__error() = 12;
  }
  *(_QWORD *)(a1 + 32) = 0;
  v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerReserve", 137, 120, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

uint64_t workerDecodeAndApplyXAT(uint64_t a1, uint64_t a2, int a3, uint8_t *data, size_t data_size)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  AAEntryXATBlob v13;
  uint64_t (*v14)(_QWORD, uint64_t, _QWORD, AAEntryXATBlob);
  uint64_t v15;
  const char *v16;
  __int16 v17;
  char v19;

  v7 = *(_QWORD **)(a1 + 8);
  v13 = AAEntryXATBlobCreateWithEncodedData(data, data_size);
  if (!v13)
  {
    v16 = "invalid XAT blob";
    v17 = 197;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDecodeAndApplyXAT", v17, 120, 0, v16, v11, v12, v19);
    v15 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  v14 = (uint64_t (*)(_QWORD, uint64_t, _QWORD, AAEntryXATBlob))v7[131];
  if (v14
    && (v14(v7[130], 24, *(_QWORD *)(v7[137] + 32) + *(_QWORD *)(*(_QWORD *)(v7[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), v13) & 0x80000000) != 0)
  {
    v16 = "user error";
    v17 = 203;
    goto LABEL_9;
  }
  if ((aaEntryXATBlobApplyToFD(v13, a3, v7[132], v8, v9, v10, v11, v12) & 0x80000000) != 0)
  {
    v16 = "applying XAT";
    v17 = 207;
    goto LABEL_9;
  }
  v15 = 0;
LABEL_10:
  AAEntryXATBlobDestroy(v13);
  return v15;
}

uint64_t workerDecodeAndApplyACL(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *data, size_t data_size)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t (*v11)(_QWORD, uint64_t, _QWORD, unint64_t *);
  uint64_t v12;
  const char *v13;
  __int16 v14;
  char v16;

  v7 = *(_QWORD **)(a1 + 8);
  v10 = (unint64_t *)AAEntryACLBlobCreateWithEncodedData(data, data_size);
  if (!v10)
  {
    v13 = "invalid ACL blob";
    v14 = 223;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDecodeAndApplyACL", v14, 120, 0, v13, v8, v9, v16);
    v12 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  v11 = (uint64_t (*)(_QWORD, uint64_t, _QWORD, unint64_t *))v7[131];
  if (v11
    && (v11(v7[130], 25, *(_QWORD *)(v7[137] + 32) + *(_QWORD *)(*(_QWORD *)(v7[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), v10) & 0x80000000) != 0)
  {
    v13 = "user error";
    v14 = 229;
    goto LABEL_9;
  }
  if ((aaEntryACLBlobApplyToFD(v10, a3, v7[132]) & 0x80000000) != 0)
  {
    v13 = "applying ACL";
    v14 = 233;
    goto LABEL_9;
  }
  v12 = 0;
LABEL_10:
  AAEntryACLBlobDestroy((AAEntryACLBlob)v10);
  return v12;
}

uint64_t stateAppendEntry(uint64_t a1, AAHeader header, uint64_t a3, rsize_t a4, char **a5)
{
  AAFieldKey v11;
  uint32_t KeyIndex;
  uint64_t v13;
  uint64_t v14;
  unsigned int FieldUInt;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t result;
  char *v20;
  AAFieldKey v21;
  uint32_t v22;
  unsigned int FieldString;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t (*v27)(_QWORD, uint64_t, char *, AAHeader);
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  AAFieldKey v33;
  uint32_t v34;
  unsigned int v35;
  int v36;
  AAFieldKey v37;
  uint32_t v38;
  unsigned int v39;
  int v40;
  AAFieldKey v41;
  uint32_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t *v47;
  size_t v48;
  size_t v49;
  void **v50;
  unsigned int *v51;
  rsize_t v53;
  __int16 v54;
  unint64_t v55;
  unint64_t v56;
  char *v57;
  AAFieldKey v58;
  AAFieldKey v59;
  uint32_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  unsigned int *v64;
  void *v66;
  char *v67;
  int *v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  int v72;
  unsigned __int8 *v73;
  int v74;
  char v75;
  size_t length;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t value;
  uint64_t v82[128];
  char v83;
  _BYTE v84[1031];

  *(_QWORD *)&v84[1023] = *MEMORY[0x24BDAC8D0];
  v80 = -1;
  value = 0;
  v78 = -1;
  v79 = -1;
  v77 = 0;
  length = 0;
  v11.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(header, v11);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, &value), FieldUInt <= 1) ? (v16 = 1) : (v16 = FieldUInt),
        v16 <= 0))
  {
    v17 = "invalid archive stream";
    v18 = 900;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", v18, 120, 0, v17, v13, v14, v75);
    return 0xFFFFFFFFLL;
  }
  if (value - 66 <= 0x15)
  {
    if (((1 << (value - 66)) & 0x274003) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 913, 120, 0, "unsupported entry type %c: %s", v13, v14, value);
      return 0xFFFFFFFFLL;
    }
    if (value == 77)
      goto LABEL_14;
  }
  v21.ikey = 5521744;
  v22 = AAHeaderGetKeyIndex(header, v21);
  if ((v22 & 0x80000000) != 0
    || ((FieldString = AAHeaderGetFieldString(header, v22, 0x400uLL, &v83, &length), FieldString <= 1)
      ? (v26 = 1)
      : (v26 = FieldString),
        v26 <= 0))
  {
    v17 = "missing PAT field";
    v18 = 920;
    goto LABEL_10;
  }
  v27 = *(uint64_t (**)(_QWORD, uint64_t, char *, AAHeader))(a1 + 1048);
  if (!v27)
    goto LABEL_28;
  v28 = v27(*(_QWORD *)(a1 + 1040), 20, &v83, header);
  if (v28 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 926, 120, 0, "Caller cancelled", v29, v30, v75);
    v51 = (unsigned int *)(a1 + 1288);
    result = 0xFFFFFFFFLL;
    while (!__ldaxr(v51))
    {
      if (!__stlxr(1u, v51))
        return result;
    }
    goto LABEL_88;
  }
  if (v28)
  {
LABEL_14:
    v20 = 0;
    goto LABEL_15;
  }
  LOBYTE(v82[0]) = 0;
  v31 = (*(uint64_t (**)(_QWORD, uint64_t, char *, uint64_t *))(a1 + 1048))(*(_QWORD *)(a1 + 1040), 27, &v83, v82);
  if (v31 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 932, 120, 0, "Caller cancelled", v13, v14, v75);
    v64 = (unsigned int *)(a1 + 1288);
    while (!__ldaxr(v64))
    {
      if (!__stlxr(1u, v64))
        return 0xFFFFFFFFLL;
    }
LABEL_88:
    __clrex();
    return 0xFFFFFFFFLL;
  }
  if (v31)
    __strlcpy_chk();
LABEL_28:
  v32 = value;
  if (value == 70)
  {
    v33.ikey = 4410440;
    v34 = AAHeaderGetKeyIndex(header, v33);
    if ((v34 & 0x80000000) != 0
      || ((v35 = AAHeaderGetFieldUInt(header, v34, &v80), v35 <= 1) ? (v36 = 1) : (v36 = v35), v36 <= 0))
    {
      v80 = -1;
    }
    v37.ikey = 4410435;
    v38 = AAHeaderGetKeyIndex(header, v37);
    if ((v38 & 0x80000000) != 0
      || ((v39 = AAHeaderGetFieldUInt(header, v38, &v79), v39 <= 1) ? (v40 = 1) : (v40 = v39), v40 <= 0))
    {
      v79 = -1;
    }
    v41.ikey = 4410451;
    v42 = AAHeaderGetKeyIndex(header, v41);
    if ((v42 & 0x80000000) != 0
      || ((v43 = AAHeaderGetFieldUInt(header, v42, &v78), v43 <= 1) ? (v44 = 1) : (v44 = v43), v44 <= 0))
    {
      v78 = -1;
    }
    v32 = value;
  }
  if (v32 == 68 && !*(_DWORD *)(a1 + 1076))
  {
    v82[0] = 0;
    v58.ikey = 5067853;
    if ((AAHeaderGetKeyIndex(header, v58) & 0x80000000) == 0)
      *(_DWORD *)(a1 + 1076) = 1;
    v59.ikey = 4672582;
    v60 = AAHeaderGetKeyIndex(header, v59);
    if ((v60 & 0x80000000) == 0)
    {
      v61 = AAHeaderGetFieldUInt(header, v60, v82);
      v62 = v61 <= 1 ? 1 : v61;
      if (v62 >= 1 && (v82[0] & 0x20002) != 0)
        *(_DWORD *)(a1 + 1076) = 1;
    }
  }
  if ((StringTableAppend(*(unsigned int **)(a1 + 1096), &v83, length, &v77, v24, v25, v13, v14) & 0x80000000) != 0)
  {
    v17 = "inserting path in table";
    v18 = 958;
    goto LABEL_10;
  }
  if (value == 68)
  {
    v45 = *(_QWORD *)(a1 + 1104);
    v46 = v45 + a4;
    if (__CFADD__(v45, a4) || (v46 & 0x8000000000000000) != 0)
      goto LABEL_112;
    v47 = (uint64_t *)(a1 + 1104);
    v48 = *(_QWORD *)(a1 + 1112);
    if (v48 < v46)
    {
      do
      {
        while (!v48)
        {
          v48 = 0x4000;
          if (v46 <= 0x4000)
          {
            v50 = (void **)(a1 + 1120);
            v48 = 0x4000;
            goto LABEL_98;
          }
        }
        v49 = v48 >> 1;
        if ((v48 & (v48 >> 1)) != 0)
          v49 = v48 & (v48 >> 1);
        v48 += v49;
      }
      while (v48 < v46);
      v50 = (void **)(a1 + 1120);
      if (v48 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_111;
      }
LABEL_98:
      v71 = *v50;
      v67 = (char *)realloc(*v50, v48);
      if (v67)
      {
        *(_QWORD *)(a1 + 1120) = v67;
        *(_QWORD *)(a1 + 1112) = v48;
        v45 = *(_QWORD *)(a1 + 1104);
        goto LABEL_100;
      }
      free(v71);
LABEL_111:
      *v50 = 0;
      *v47 = 0;
      *(_QWORD *)(a1 + 1112) = 0;
      goto LABEL_112;
    }
    v67 = *(char **)(a1 + 1120);
    if (v67)
    {
LABEL_100:
      memset_s(&v67[v45], a4, 0, a4);
      v45 = *v47;
    }
    *v47 = v45 + a4;
    if ((a4 & 0x8000000000000000) != 0)
    {
LABEL_112:
      v17 = "inserting blob placeholder";
      v18 = 964;
      goto LABEL_10;
    }
    v72 = v83;
    if (v83)
    {
      v54 = 0;
      v73 = v84;
      do
      {
        if (v72 == 47)
          ++v54;
        v74 = *v73++;
        v72 = v74;
      }
      while (v74);
    }
    else
    {
      v54 = 0;
    }
    v53 = a4;
  }
  else
  {
    v45 = 0;
    v53 = 0;
    v54 = 0;
  }
  v55 = *(_QWORD *)(a1 + 1136);
  v56 = *(_QWORD *)(a1 + 1128);
  if (v55 >= v56)
  {
    v63 = 2 * v56;
    if (!v56)
      v63 = 256;
    *(_QWORD *)(a1 + 1128) = v63;
    if ((unint64_t)(72 * v63) < 0x2000000001)
    {
      v66 = *(void **)(a1 + 1144);
      v57 = (char *)realloc(v66, 72 * v63);
      if (v57)
      {
        *(_QWORD *)(a1 + 1144) = v57;
        v55 = *(_QWORD *)(a1 + 1136);
        goto LABEL_91;
      }
      free(v66);
    }
    else
    {
      *__error() = 12;
    }
    *(_QWORD *)(a1 + 1144) = 0;
    v68 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 973, 120, *v68, "malloc", v69, v70, v75);
    *(_QWORD *)(a1 + 1128) = 0;
    *(_QWORD *)(a1 + 1136) = 0;
    return 0xFFFFFFFFLL;
  }
  v57 = *(char **)(a1 + 1144);
LABEL_91:
  *(_QWORD *)(a1 + 1136) = v55 + 1;
  v20 = &v57[72 * v55];
  *((_DWORD *)v20 + 15) = value;
  *((_DWORD *)v20 + 16) = v77;
  *(_QWORD *)v20 = a3;
  *((_QWORD *)v20 + 1) = a4;
  *((_QWORD *)v20 + 2) = v80;
  *((_QWORD *)v20 + 3) = v79;
  *((_QWORD *)v20 + 4) = v78;
  *((_QWORD *)v20 + 5) = v45;
  *((_QWORD *)v20 + 6) = v53;
  *((_WORD *)v20 + 34) = v54;
  *((_DWORD *)v20 + 14) = -1;
LABEL_15:
  result = 0;
  if (a5)
    *a5 = v20;
  return result;
}

AAFieldKeySet AAFieldKeySetCreate(void)
{
  AAFieldKeySet_impl *v0;
  AAFieldKeySet_impl *v1;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char v6;

  v0 = (AAFieldKeySet_impl *)malloc(0x10uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x10uLL, 0, 0x10uLL);
  }
  else
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreate", 63, 103, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

AAFieldKeySet AAFieldKeySetCreateWithString(const char *s)
{
  AAFieldKeySet v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  size_t v7;
  unsigned int v8;
  void *v9;
  _BYTE *v10;
  _BYTE *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  char v27;

  v2 = AAFieldKeySetCreate();
  if (!v2)
    goto LABEL_44;
  v3 = strlen(s);
  v6 = v3 + 1;
  if (((v3 + 1) & 3) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 73, 103, 0, "Invalid KeySet string length: %zu", v4, v5, v3 + 1);
    return 0;
  }
  if (v6 >> 34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 75, 103, 0, "String too long: %zu", v4, v5, v3 + 1);
    return 0;
  }
  v7 = v6 >> 2;
  if (((v6 >> 2) & 0x80000000) != 0)
  {
LABEL_43:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 77, 103, 0, "realloc_keys", v4, v5, v27);
LABEL_44:
    AAFieldKeySetDestroy(v2);
    return 0;
  }
  v8 = *((_DWORD *)v2 + 1);
  if (v8 < v7)
  {
    do
    {
      if (v8)
        v8 += v8 >> 1;
      else
        v8 = 16;
    }
    while (v8 < v7);
    v9 = (void *)*((_QWORD *)v2 + 1);
    v10 = realloc(v9, 4 * v8);
    if (v10)
    {
      v11 = v10;
      *((_QWORD *)v2 + 1) = v10;
      *((_DWORD *)v2 + 1) = v8;
      goto LABEL_15;
    }
    free(v9);
    *((_QWORD *)v2 + 1) = 0;
    v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v23, "malloc", v24, v25, v27);
    *(_QWORD *)v2 = 0;
    goto LABEL_43;
  }
  v11 = (_BYTE *)*((_QWORD *)v2 + 1);
LABEL_15:
  memcpy(v11, s, v6);
  if (v6)
  {
    v12 = v6;
    do
    {
      *v11 = __toupper((char)*v11);
      ++v11;
      --v12;
    }
    while (v12);
    *(_DWORD *)v2 = v7;
    if (v6 >= 4)
    {
      v15 = 0;
      if (v7 <= 1)
        v16 = 1;
      else
        v16 = v7;
      v17 = MEMORY[0x24BDAC740];
      while (1)
      {
        v18 = *((_QWORD *)v2 + 1) + v15;
        if (*(_BYTE *)(v18 + 3))
        {
          if (*(_BYTE *)(v18 + 3) != 44)
            break;
        }
        *(_BYTE *)(v18 + 3) = 0;
        v19 = *(_DWORD *)(*((_QWORD *)v2 + 1) + v15);
        if ((v19 & 0x80) != 0)
        {
          if (!__maskrune((char)v19, 0x500uLL))
            goto LABEL_47;
        }
        else if ((*(_DWORD *)(v17 + 4 * (char)v19 + 60) & 0x500) == 0)
        {
          goto LABEL_47;
        }
        v20 = (__int16)v19 >> 8;
        if (((v19 << 16) & 0x80000000) != 0)
        {
          if (!__maskrune(v20, 0x500uLL))
            goto LABEL_47;
        }
        else if ((*(_DWORD *)(v17 + 4 * v20 + 60) & 0x500) == 0)
        {
          goto LABEL_47;
        }
        v21 = (int)(v19 << 8) >> 24;
        if (((v19 << 8) & 0x80000000) != 0)
          v22 = __maskrune(v21, 0x500uLL);
        else
          v22 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x500;
        if (HIBYTE(v19) || !v22)
        {
LABEL_47:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 88, 103, 0, "invalid key set: %s", v13, v14, (char)s);
          goto LABEL_44;
        }
        v15 += 4;
        if (!--v16)
          goto LABEL_41;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 86, 103, 0, "invalid key set: %s", v13, v14, (char)s);
      goto LABEL_44;
    }
  }
  else
  {
    *(_DWORD *)v2 = v7;
  }
LABEL_41:
  qsort(*((void **)v2 + 1), v7, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_keys);
  return v2;
}

uint64_t cmp_keys(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

void AAFieldKeySetDestroy(AAFieldKeySet key_set)
{
  if (key_set)
  {
    free(*((void **)key_set + 1));
    free(key_set);
  }
}

AAFieldKeySet AAFieldKeySetClone(AAFieldKeySet key_set)
{
  AAFieldKeySet v2;
  uint64_t v3;
  uint64_t v4;
  AAFieldKeySet v5;
  uint64_t v6;
  unsigned int v7;
  void *v8;
  void *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v2 = AAFieldKeySetCreate();
  v5 = v2;
  if (!v2)
    goto LABEL_15;
  v6 = *(unsigned int *)key_set;
  if ((_DWORD)v6)
  {
    if ((v6 & 0x80000000) == 0)
    {
      v7 = *((_DWORD *)v2 + 1);
      if (v7 >= v6)
      {
        v9 = (void *)*((_QWORD *)v2 + 1);
        goto LABEL_12;
      }
      do
      {
        if (v7)
          v7 += v7 >> 1;
        else
          v7 = 16;
      }
      while (v7 < v6);
      v8 = (void *)*((_QWORD *)v2 + 1);
      v9 = realloc(v8, 4 * v7);
      if (v9)
      {
        *((_QWORD *)v5 + 1) = v9;
        *((_DWORD *)v5 + 1) = v7;
LABEL_12:
        *(_DWORD *)v5 = v6;
        memcpy(v9, *((const void **)key_set + 1), 4 * v6);
        return v5;
      }
      free(v8);
      *((_QWORD *)v5 + 1) = 0;
      v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v10, "malloc", v11, v12, v14);
      *(_QWORD *)v5 = 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetClone", 106, 103, 0, "realloc_keys", v3, v4, v14);
LABEL_15:
    AAFieldKeySetDestroy(v5);
    return 0;
  }
  return v5;
}

int AAFieldKeySetClear(AAFieldKeySet key_set)
{
  *(_DWORD *)key_set = 0;
  return 0;
}

int AAFieldKeySetContainsKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3;
  int v4;
  unsigned int *v5;
  int v6;
  unsigned int v7;
  int v8;
  AAFieldKey v10;
  unsigned int v11;

  v3 = 0;
  v10 = key;
  v11 = 0;
  do
  {
    *((_BYTE *)&v11 + v3) = __toupper(v10.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  v4 = *(_DWORD *)key_set;
  if (*(_DWORD *)key_set && (v5 = (unsigned int *)*((_QWORD *)key_set + 1), *v5 < v11))
  {
    v6 = v4 - 1;
    v7 = v5[v4 - 1];
    if (v7 < v11)
      return 0;
    if (v4 < 3)
      return v7 == v11;
    v8 = 0;
    do
    {
      if (v5[(v8 + v6) >> 1] >= v11)
        v6 = (v8 + v6) >> 1;
      else
        v8 = (v8 + v6) >> 1;
    }
    while (v6 - v8 > 1);
  }
  else
  {
    v6 = 0;
  }
  if (v6 < v4)
  {
    v7 = *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v6);
    return v7 == v11;
  }
  return 0;
}

int AAFieldKeySetInsertKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  void *v10;
  void *v11;
  unsigned int *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  int result;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char v21;
  AAFieldKey v22;
  unsigned int v23;

  v3 = 0;
  v22 = key;
  v23 = 0;
  do
  {
    *((_BYTE *)&v23 + v3) = __toupper(v22.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  v6 = *(_DWORD *)key_set;
  v7 = *(_DWORD *)key_set + 1;
  if (v7 < 0)
    goto LABEL_21;
  v8 = v23;
  v9 = *((_DWORD *)key_set + 1);
  if (v9 < v7)
  {
    do
    {
      if (v9)
        v9 += v9 >> 1;
      else
        v9 = 16;
    }
    while (v9 < v7);
    v10 = (void *)*((_QWORD *)key_set + 1);
    v11 = realloc(v10, 4 * v9);
    if (v11)
    {
      *((_QWORD *)key_set + 1) = v11;
      *((_DWORD *)key_set + 1) = v9;
      v6 = *(_DWORD *)key_set;
      goto LABEL_11;
    }
    free(v10);
    *((_QWORD *)key_set + 1) = 0;
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v17, "malloc", v18, v19, v21);
    *(_QWORD *)key_set = 0;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetInsertKey", 139, 103, 0, "realloc_keys failed", v4, v5, v21);
    return -1;
  }
LABEL_11:
  if (!v6 || (v12 = (unsigned int *)*((_QWORD *)key_set + 1), *v12 >= v8))
  {
    v13 = 0;
    goto LABEL_16;
  }
  v13 = v6 - 1;
  v14 = v12[v6 - 1];
  if (v14 >= v8)
  {
    if (v6 < 3)
    {
      v15 = v13;
      goto LABEL_18;
    }
    v20 = 0;
    do
    {
      if (v12[(v20 + v13) >> 1] >= v8)
        v13 = (v20 + v13) >> 1;
      else
        v20 = (v20 + v13) >> 1;
    }
    while (v13 - v20 > 1);
LABEL_16:
    if (v13 >= v6)
      goto LABEL_23;
    v12 = (unsigned int *)*((_QWORD *)key_set + 1);
    v15 = v13;
    v14 = v12[v13];
LABEL_18:
    if (v14 == v8)
      return 0;
    memmove(&v12[v13 + 1], &v12[v15], 4 * (v6 - v13));
    goto LABEL_23;
  }
  v13 = v6;
LABEL_23:
  result = 0;
  *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v13) = v8;
  ++*(_DWORD *)key_set;
  return result;
}

int AAFieldKeySetRemoveKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  AAFieldKey v14;
  unsigned int v15;

  v3 = 0;
  v14 = key;
  v15 = 0;
  do
  {
    *((_BYTE *)&v15 + v3) = __toupper(v14.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  v4 = *(int *)key_set;
  if (!(_DWORD)v4 || (v5 = (unsigned int *)*((_QWORD *)key_set + 1), *v5 >= v15))
  {
    v6 = 0;
LABEL_14:
    if (v6 == (_DWORD)v4)
      return 0;
    v5 = (unsigned int *)*((_QWORD *)key_set + 1);
    v9 = v6;
    v7 = v5[v6];
    goto LABEL_16;
  }
  v6 = v4 - 1;
  v7 = v5[v4 - 1];
  if (v7 < v15)
    return 0;
  if ((int)v4 >= 3)
  {
    v8 = 0;
    do
    {
      if (v5[(v8 + v6) >> 1] >= v15)
        v6 = (v8 + v6) >> 1;
      else
        v8 = (v8 + v6) >> 1;
    }
    while (v6 - v8 > 1);
    goto LABEL_14;
  }
  v9 = v4 - 1;
LABEL_16:
  if (v7 == v15)
  {
    v10 = v4 - 1;
    *(_DWORD *)key_set = v10;
    v11 = __OFSUB__(v10, v6);
    v12 = v10 - v6;
    if (!((v12 < 0) ^ v11 | (v12 == 0)))
      memmove(&v5[v9], &v5[v6 + 1], 4 * v12);
  }
  return 0;
}

int AAFieldKeySetInsertKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  char v30;

  v4 = *(unsigned int *)s;
  if ((_DWORD)v4)
  {
    v6 = *((_QWORD *)s + 1);
    v7 = *(unsigned int *)key_set;
    v8 = (_DWORD *)*((_QWORD *)key_set + 1);
    *(_QWORD *)key_set = 0;
    *((_QWORD *)key_set + 1) = 0;
    v9 = v7 + v4;
    if ((int)v7 + (int)v4 >= 0)
    {
      if (!v9)
      {
LABEL_11:
        if ((_DWORD)v7)
        {
          v12 = 0;
          v13 = 0;
          v14 = 0;
          while (1)
          {
            v15 = v8[v14];
            v16 = *(_DWORD *)(v6 + 4 * v13);
            if (v15 == v16)
            {
              *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v12) = v15;
              ++v14;
            }
            else
            {
              v17 = *((_QWORD *)key_set + 1);
              if (v15 < v16)
              {
                *(_DWORD *)(v17 + 4 * v12) = v15;
                ++v14;
                goto LABEL_19;
              }
              *(_DWORD *)(v17 + 4 * v12) = v16;
            }
            ++v13;
LABEL_19:
            ++v12;
            if (v14 >= v7 || v13 >= v4)
              goto LABEL_23;
          }
        }
        v14 = 0;
        v13 = 0;
        v12 = 0;
LABEL_23:
        if (v14 >= v7)
        {
          v20 = v12;
        }
        else
        {
          v18 = &v8[v14];
          v19 = v7 - v14;
          do
          {
            v20 = v12 + 1;
            v21 = *v18++;
            *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v12++) = v21;
            --v19;
          }
          while (v19);
        }
        if (v13 >= v4)
        {
          v24 = v20;
        }
        else
        {
          v22 = (int *)(v6 + 4 * v13);
          v23 = v4 - v13;
          do
          {
            v24 = v20 + 1;
            v25 = *v22++;
            *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v20++) = v25;
            --v23;
          }
          while (v23);
        }
        LODWORD(v4) = 0;
        *(_DWORD *)key_set = v24;
        goto LABEL_36;
      }
      v10 = 0;
      do
      {
        if (v10)
          v10 += v10 >> 1;
        else
          v10 = 16;
      }
      while (v10 < v9);
      v11 = malloc(4 * v10);
      if (v11)
      {
        *((_QWORD *)key_set + 1) = v11;
        *((_DWORD *)key_set + 1) = v10;
        goto LABEL_11;
      }
      *((_QWORD *)key_set + 1) = 0;
      v26 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v26, "malloc", v27, v28, v30);
      *(_QWORD *)key_set = 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetInsertKeySet", 178, 103, 0, "realloc_keys", v2, v3, v30);
    LODWORD(v4) = -1;
LABEL_36:
    free(v8);
  }
  return v4;
}

int AAFieldKeySetRemoveKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int *v11;
  unint64_t v12;
  unsigned int v13;
  int v14;

  v2 = *(unsigned int *)s;
  if ((_DWORD)v2)
  {
    v3 = *(unsigned int *)key_set;
    v4 = *((_QWORD *)key_set + 1);
    if ((_DWORD)v3)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = *((_QWORD *)s + 1);
      while (1)
      {
        v9 = *(_DWORD *)(v4 + 4 * v7);
        v10 = *(_DWORD *)(v8 + 4 * v6);
        if (v9 == v10)
        {
          ++v7;
        }
        else if (v9 < v10)
        {
          *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v5++) = v9;
          ++v7;
          goto LABEL_9;
        }
        ++v6;
LABEL_9:
        if (v7 >= v3 || v6 >= v2)
          goto LABEL_13;
      }
    }
    v7 = 0;
    v5 = 0;
LABEL_13:
    if (v7 >= v3)
    {
      v13 = v5;
    }
    else
    {
      v11 = (int *)(v4 + 4 * v7);
      v12 = v3 - v7;
      do
      {
        v13 = v5 + 1;
        v14 = *v11++;
        *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v5++) = v14;
        --v12;
      }
      while (v12);
    }
    *(_DWORD *)key_set = v13;
  }
  return 0;
}

int AAFieldKeySetSelectKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;

  v2 = *(unsigned int *)s;
  if ((_DWORD)v2 && (v3 = *(unsigned int *)key_set, (_DWORD)v3))
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = *((_QWORD *)s + 1);
    v8 = *((_QWORD *)key_set + 1);
    do
    {
      v9 = *(_DWORD *)(v8 + 4 * v6);
      v10 = *(_DWORD *)(v7 + 4 * v5);
      if (v9 == v10)
      {
        *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v4++) = v9;
        ++v6;
        ++v5;
      }
      else if (v9 >= v10)
      {
        ++v5;
      }
      else
      {
        ++v6;
      }
    }
    while (v6 < v3 && v5 < v2);
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)key_set = v4;
  return 0;
}

uint32_t AAFieldKeySetGetKeyCount(AAFieldKeySet key_set)
{
  return *(_DWORD *)key_set;
}

AAFieldKey AAFieldKeySetGetKey(AAFieldKeySet key_set, uint32_t i)
{
  return *(AAFieldKey *)(*((_QWORD *)key_set + 1) + 4 * i);
}

int AAFieldKeySetSerialize(AAFieldKeySet key_set, size_t capacity, char *s)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  int result;

  v3 = *(unsigned int *)key_set;
  if ((_DWORD)v3)
  {
    if (capacity >= 4 * v3)
    {
      if ((int)v3 >= 1)
      {
        v4 = 0;
        v5 = s;
        do
        {
          *(_DWORD *)v5 = *(_DWORD *)(*((_QWORD *)key_set + 1) + 4 * v4);
          if (v4)
            *(v5 - 1) = 44;
          ++v4;
          v5 += 4;
        }
        while (v4 < *(int *)key_set);
        LODWORD(v3) = *(_DWORD *)key_set;
      }
      s += (4 * v3 - 1);
      goto LABEL_11;
    }
  }
  else if (capacity)
  {
LABEL_11:
    result = 0;
    *s = 0;
    return result;
  }
  return -1;
}

uint64_t AAPathListCreate()
{
  uint64_t result;

  result = create();
  *(_DWORD *)(*(_QWORD *)(result + 8) + 16) = 1;
  return result;
}

uint64_t create()
{
  void *v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  char v14;
  unsigned int v15;

  v0 = malloc(0x20uLL);
  v1 = (uint64_t)v0;
  if (!v0)
  {
    v10 = *__error();
    v11 = "malloc";
    v12 = 444;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"create", v12, 60, v10, v11, v3, v4, v14);
    AAPathListDestroy((AAPathList)v1);
    return 0;
  }
  memset_s(v0, 0x20uLL, 0, 0x20uLL);
  v2 = StringTableCreate();
  *(_QWORD *)(v1 + 16) = v2;
  if (!v2)
  {
    v11 = "StringTableCreate";
    v12 = 447;
LABEL_10:
    v10 = 0;
    goto LABEL_11;
  }
  if ((increaseCapacity(v1, 0x100u) & 0x80000000) != 0)
  {
    v11 = "alloc";
    v12 = 450;
    goto LABEL_10;
  }
  v15 = -1;
  if ((StringTableAppend(*(unsigned int **)(v1 + 16), &unk_20A3FA2C1, 0, &v15, v5, v6, v3, v4) & 0x80000000) != 0)
  {
    v11 = "String table insert";
    v12 = 452;
    goto LABEL_10;
  }
  v7 = *(_QWORD *)(v1 + 8);
  v8 = (*(_DWORD *)v1)++;
  v9 = v7 + 24 * v8;
  *(_DWORD *)(v9 + 20) = -1;
  *(_DWORD *)(v9 + 8) = -1;
  *(_QWORD *)v9 = -1;
  *(_QWORD *)(v9 + 12) = v15;
  return v1;
}

void AAPathListDestroy(AAPathList path_list)
{
  if (path_list)
  {
    StringTableDestroy(*((void ***)path_list + 2));
    free(*((void **)path_list + 1));
    free(path_list);
  }
}

AAPathList AAPathListCreateWithDirectoryContents(const char *dir, const char *path, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int DefaultNThreads;
  unsigned int v9;
  unsigned int v10;
  uint64_t (*v11)(uint64_t, uint64_t, char *, _QWORD);
  uint64_t (*v12)(uint64_t, uint64_t, char *, _QWORD);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  size_t v18;
  _BOOL4 v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  int v26;
  unsigned int *v27;
  size_t v28;
  size_t v29;
  size_t v30;
  size_t v31;
  uint64_t v32;
  int v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  _DWORD *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  _QWORD *v47;
  unsigned int *v48;
  void *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  void ***v55;
  void **v56;
  int *v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  _BOOL4 v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  int *v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t Worker;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int16 v86;
  const char *v87;
  int v88;
  uint64_t i;
  char *v90;
  _DWORD *v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  unsigned int v95;
  int *v96;
  _DWORD *v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  __int16 v102;
  const char *v103;
  __int16 v104;
  int v105;
  char v106;
  char v107;
  unsigned int v108;
  _QWORD *v109;
  _BOOL4 v110;
  void *v111;
  int v112;
  signed int v113;
  int v114;
  stat v115;
  unsigned int v116;
  char __s[1025];
  char v118[2048];
  char v119[1024];
  char v120[1024];
  uint64_t v121;

  v6 = ((uint64_t (*)(const char *, const char *, void *, AAEntryMessageProc, AAFlagSet, _QWORD))MEMORY[0x24BDAC7A8])(dir, path, msg_data, msg_proc, flags, *(_QWORD *)&n_threads);
  DefaultNThreads = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  v17 = (const char *)v6;
  v121 = *MEMORY[0x24BDAC8D0];
  v116 = 0;
  bzero(v120, 0x400uLL);
  bzero(v119, 0x400uLL);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  if (!realpath_DARWIN_EXTSN(v17, v120))
  {
    v26 = *__error();
    v107 = (char)v17;
    v24 = "Invalid dir: %s";
    v25 = 508;
    goto LABEL_47;
  }
  v18 = strlen(v120);
  v20 = v18 != 1 || v120[0] != 47;
  if (v16)
  {
    v21 = v18;
    __strlcpy_chk();
    if ((normalizePath((uint64_t)v119) & 0x80000000) != 0)
    {
      v107 = (char)v17;
      v24 = "Invalid path (subpath normalization failed): %s/%s";
      v25 = 517;
LABEL_46:
      v26 = 0;
      goto LABEL_47;
    }
    if ((concatPath(v118, 0x800uLL, v120, v119) & 0x80000000) != 0)
    {
      v26 = *__error();
      v107 = (char)v17;
      v24 = "Path too long: %s/%s";
      v25 = 523;
    }
    else
    {
      if (realpath_DARWIN_EXTSN(v118, __s))
      {
        if (v20 && (strlen(__s) < v21 || memcmp(__s, v120, v21) || __s[v21] && __s[v21] != 47))
        {
          v107 = (char)v17;
          v24 = "Path resolving outside target dir: %s/%s";
          v25 = 531;
        }
        else
        {
          memset(&v115, 0, sizeof(v115));
          if (!lstat(__s, &v115) && (v115.st_mode & 0xF000) == 0x4000)
            goto LABEL_26;
          v107 = (char)v17;
          v24 = "Not a directory: %s/%s";
          v25 = 534;
        }
        goto LABEL_46;
      }
      v26 = *__error();
      v107 = (char)v17;
      v24 = "Invalid path, doesn't exist: %s/%s";
      v25 = 524;
    }
LABEL_47:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v25, 60, v26, v24, v22, v23, v107);
    v27 = 0;
LABEL_48:
    v48 = 0;
    v49 = 0;
    v47 = 0;
    v46 = 0;
LABEL_49:
    v50 = 0;
    goto LABEL_50;
  }
LABEL_26:
  v27 = (unsigned int *)create();
  if (!v27)
    return (AAPathList)v27;
  v113 = DefaultNThreads;
  v28 = strlen(v119);
  if (v28)
  {
    v29 = v28;
    v30 = 0;
    v31 = 0;
    v32 = *((_QWORD *)v27 + 1) + 24 * v27[7];
    *(_DWORD *)(v32 + 16) |= 1u;
    do
    {
      v33 = v119[v31];
      if (v33 == 47 || v33 == 0)
      {
        *(_DWORD *)v118 = -1;
        if ((increaseCapacity((uint64_t)v27, *v27 + 1) & 0x80000000) != 0)
        {
          v101 = "increase PathList capacity";
          v102 = 553;
LABEL_113:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v102, 60, 0, v101, v37, v38, v106);
          v48 = 0;
          v49 = 0;
          v47 = 0;
          v46 = 0;
          v50 = 0;
          DefaultNThreads = v113;
          goto LABEL_50;
        }
        if ((StringTableAppend(*((unsigned int **)v27 + 2), &v119[v30], v31 - v30, v118, v35, v36, v37, v38) & 0x80000000) != 0)
        {
          v101 = "inserting path component in table";
          v102 = 554;
          goto LABEL_113;
        }
        v39 = *v27;
        v40 = (_DWORD *)(*((_QWORD *)v27 + 1) + 24 * *v27);
        *v40 = *v27 - 1;
        v40[3] = *(_DWORD *)v118;
        v40[4] = v33 != 0;
        *v27 = v39 + 1;
        if (!v33)
          break;
        v30 = ++v31;
      }
      ++v31;
    }
    while (v31 <= v29);
  }
  DefaultNThreads = v113;
  if (!v12)
    goto LABEL_43;
  v41 = v12(v14, 11, v119, 0);
  if (v41 < 0)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 570, 60, "abort from callback", v42, v43, v44, v106);
    goto LABEL_48;
  }
  if (v41)
  {
    v45 = *((_QWORD *)v27 + 1) + 24 * (*v27 - 1);
    *(_DWORD *)(v45 + 16) |= 1u;
  }
LABEL_43:
  if (v113 < 0)
  {
    *__error() = 12;
    v46 = 0;
    v47 = 0;
    *__error() = 12;
  }
  else
  {
    v46 = (char *)calloc(v113, 0x28uLL);
    v47 = calloc(v113, 0x38uLL);
  }
  if ((unint64_t)(8 * v113) >= 0x2000000001)
  {
    v49 = 0;
    *__error() = 12;
LABEL_65:
    v58 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 578, 60, *v58, "malloc", v59, v60, v106);
    v48 = 0;
    goto LABEL_49;
  }
  v61 = malloc(8 * v113);
  v49 = v61;
  if (!v46 || !v47 || !v61)
    goto LABEL_65;
  if (v113 >= 1)
  {
    v62 = v47;
    v63 = v113;
    v64 = v61;
    do
    {
      v62[2] = v14;
      v62[3] = v12;
      v62[4] = &v116;
      *v62 = v27;
      v62[1] = v120;
      *((_DWORD *)v62 + 10) = (v10 >> 6) & 1;
      *v64++ = v62;
      v62 += 7;
      --v63;
    }
    while (v63);
  }
  v48 = ThreadPoolCreate(v113, (uint64_t)v61, (uint64_t)expandDirThreadProc);
  if (!v48)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 591, 60, 0, "ThreadPoolCreate", v70, v71, v106);
    goto LABEL_49;
  }
  v111 = v49;
  v109 = v47;
  v72 = *v27;
  if (!*v27)
    goto LABEL_108;
  v73 = 0;
  v74 = v72 - 1;
  v108 = v72 - 1;
  do
  {
    if ((DefaultNThreads + v72 + ~v74) / DefaultNThreads <= 0x64)
      v75 = 100;
    else
      v75 = (DefaultNThreads + v72 + ~v74) / DefaultNThreads;
    v110 = v73;
    v76 = 0;
    v114 = !v73;
    v112 = 1;
    v77 = v113;
    v78 = (int *)v46;
    do
    {
      v79 = v74 + v75 * v76;
      *v78 = v114;
      v78[1] = v79;
      v80 = v79 + v75;
      v78[2] = v79 + v75;
      if (v79 > v72)
      {
        v78[1] = v72;
        v79 = v72;
      }
      if (v80 > v72)
      {
        v78[2] = v72;
        v80 = v72;
      }
      if (v79 < v80)
      {
        Worker = ThreadPoolGetWorker((uint64_t)v48, v65, v66, v67, v68, v69, v70, v71);
        if (Worker)
        {
          *(_QWORD *)(Worker + 48) = v78;
          if ((ThreadPoolRunWorker((uint64_t)v48, Worker, v82, v83, v84, v85, v70, v71) & 0x80000000) == 0)
            goto LABEL_89;
          v86 = 618;
          v87 = "ThreadPoolRunWorker";
        }
        else
        {
          v86 = 616;
          v87 = "ThreadPoolGetWorker";
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v86, 60, 0, v87, v70, v71, v106);
        v112 = 0;
      }
LABEL_89:
      ++v76;
      v78 += 10;
      --v77;
    }
    while (v77);
    if ((ThreadPoolSync(v48) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 620, 60, 0, "ThreadPoolSync", v70, v71, v106);
      v105 = atomic_load(&v116);
      DefaultNThreads = v113;
      v49 = v111;
      if (v105 >= 1)
      {
LABEL_120:
        v103 = "Abort";
        v104 = 621;
LABEL_121:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v104, 60, 0, v103, v70, v71, v106);
      }
LABEL_122:
      v50 = 0;
      v47 = v109;
      goto LABEL_50;
    }
    v88 = atomic_load(&v116);
    DefaultNThreads = v113;
    v49 = v111;
    if (v88 > 0)
      goto LABEL_120;
    if (!v112)
      goto LABEL_122;
    if (v113)
    {
      for (i = 0; i != v113; ++i)
      {
        if (*(_DWORD *)&v46[40 * i + 4] < *(_DWORD *)&v46[40 * i + 8])
        {
          v90 = &v46[40 * i];
          v93 = *((_DWORD *)v90 + 4);
          v91 = v90 + 16;
          v92 = v93;
          if (v93)
          {
            *(_DWORD *)v118 = 0;
            if ((increaseCapacity((uint64_t)v27, *v27 + v92) & 0x80000000) != 0)
            {
              v103 = "alloc";
              v104 = 631;
              goto LABEL_121;
            }
            if ((StringTableAppendTable(*((_QWORD *)v27 + 2), *(unsigned int **)&v46[40 * i + 32], v118) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 632, 60, 0, "String table append", v70, v71, v106);
              v49 = v111;
              goto LABEL_122;
            }
            v94 = *((_QWORD *)v27 + 1);
            v95 = *v27;
            v96 = (int *)(*(_QWORD *)&v46[40 * i + 24] + 8);
            do
            {
              v97 = (_DWORD *)(v94 + 24 * v95++);
              *v27 = v95;
              *v97 = *(v96 - 2);
              v97[3] = *(_DWORD *)v118 + *(v96 - 1);
              v98 = *v96;
              v96 += 3;
              v97[4] = v98;
              --v92;
            }
            while (v92);
            *v91 = 0;
            v49 = v111;
          }
        }
      }
    }
    if (v110)
      break;
    v73 = v72 == *v27;
    v74 = v72 == *v27 ? v108 : v72;
    v72 = *v27;
  }
  while (v74 < *v27);
LABEL_108:
  v47 = v109;
  if ((normalize(v27) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 656, 60, 0, "Tree normalization", v99, v100, v106);
    v50 = 0;
  }
  else
  {
    v50 = 1;
  }
  v49 = v111;
LABEL_50:
  if ((ThreadPoolDestroy((uint64_t)v48) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 661, 60, 0, "ThreadPoolDestroy", v51, v52, v106);
    v50 = 0;
  }
  v53 = atomic_load(&v116);
  if (v53 >= 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 662, 60, 0, "threads reported errors", v51, v52, v106);
    v50 = 0;
  }
  if (v47)
  {
    if ((int)DefaultNThreads >= 1)
    {
      v54 = DefaultNThreads;
      v55 = (void ***)(v46 + 32);
      do
      {
        free(*(v55 - 1));
        v56 = *v55;
        v55 += 5;
        StringTableDestroy(v56);
        --v54;
      }
      while (v54);
    }
    free(v47);
    free(v49);
  }
  free(v46);
  if (!v50)
  {
    AAPathListDestroy((AAPathList)v27);
    return 0;
  }
  return (AAPathList)v27;
}

uint64_t increaseCapacity(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  void *v4;
  void *v5;
  void *v6;
  uint64_t result;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2)
    return 0;
  do
  {
    if (v2)
      v2 += v2 >> 1;
    else
      v2 = 256;
  }
  while (v2 < a2);
  *(_DWORD *)(a1 + 4) = v2;
  v4 = *(void **)(a1 + 8);
  v5 = realloc(v4, 24 * v2);
  if (v5)
  {
    v6 = v5;
    result = 0;
    *(_QWORD *)(a1 + 8) = v6;
  }
  else
  {
    free(v4);
    *(_QWORD *)(a1 + 8) = 0;
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"increaseCapacity", 270, 60, *v8, "malloc", v9, v10, v11);
    *(_QWORD *)a1 = 0;
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t expandDirThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  const char *v14;
  __int16 v15;
  size_t v16;
  char *v17;
  unsigned int v18;
  size_t v19;
  _DWORD *v20;
  __uint64_t d_ino;
  size_t v22;
  uint64_t v23;
  unsigned int (*v24)(_QWORD, uint64_t, _BYTE *, _QWORD);
  DIR *v25;
  DIR *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  size_t d_namlen;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  uint64_t (*v40)(_QWORD, uint64_t, void *, _QWORD);
  int v41;
  uint64_t (*v42)(_QWORD, uint64_t, void *, _QWORD);
  int v43;
  int v44;
  _BOOL4 v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  char *v50;
  unsigned int v51;
  char *v52;
  unsigned int *v53;
  int v54;
  __int16 v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int (*v59)(_QWORD, uint64_t, _BYTE *, _QWORD);
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  const char *v67;
  __int16 v68;
  int v69;
  unsigned int *v70;
  unsigned int v71;
  char *v73;
  int v74;
  char *v75;
  void *__dst;
  int v77;
  stat v78;
  dirent *v79;
  stat v80;
  dirent v81;
  char v82[2048];
  _BYTE __src[1024];
  uint64_t v84;

  v8 = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v84 = *MEMORY[0x24BDAC8D0];
  v9 = *(int **)(v8 + 48);
  bzero(__src, 0x400uLL);
  bzero(v82, 0x800uLL);
  v10 = (void *)*((_QWORD *)v9 + 4);
  if (!v10)
  {
    v10 = StringTableCreate();
    *((_QWORD *)v9 + 4) = v10;
    if (!v10)
    {
      v14 = "String table creation";
      v15 = 79;
      goto LABEL_101;
    }
  }
  StringTableClear((uint64_t)v10);
  v9[4] = 0;
  v13 = strlen(*(const char **)(v8 + 8));
  if (v13 >= 0x800)
  {
    v14 = "dir name too long";
    v15 = 88;
    goto LABEL_101;
  }
  v16 = v13;
  __memcpy_chk();
  v17 = &v82[v16];
  v82[v16] = 0;
  v18 = v9[1];
  if (v18 >= v9[2])
    return 0;
  v19 = v16 + 1;
  __dst = v17 + 1;
  while (1)
  {
    v20 = *(_DWORD **)v8;
    if (**(_DWORD **)v8 <= v18
      || (v81.d_ino = 0, (getPath((uint64_t)v20, v18, 0x400uLL, __src, &v81.d_ino) & 0x80000000) != 0))
    {
      v14 = "get node path";
      v15 = 96;
      goto LABEL_101;
    }
    d_ino = v81.d_ino;
    if (v81.d_ino >= 0x400)
    {
      v14 = "truncated node path";
      v15 = 97;
      goto LABEL_101;
    }
    if (v81.d_ino)
      v22 = v19 + v81.d_ino;
    else
      v22 = v16;
    if (v81.d_ino)
    {
      if (v19 + v81.d_ino >= 0x800)
      {
        v14 = "path too long";
        v15 = 103;
        goto LABEL_101;
      }
      *v17 = 47;
      memcpy(__dst, __src, d_ino);
    }
    v82[v22] = 0;
    memset(&v80, 0, sizeof(v80));
    if (lstat(v82, &v80) < 0)
    {
      v66 = *__error();
      v73 = v82;
      v14 = "lstat %s";
      v15 = 111;
      goto LABEL_102;
    }
    if (!statIsDataless(v80.st_flags))
      break;
    v24 = *(unsigned int (**)(_QWORD, uint64_t, _BYTE *, _QWORD))(v8 + 24);
    if (v24 && v24(*(_QWORD *)(v8 + 16), 12, __src, 0))
    {
      v73 = v82;
      v14 = "dataless dir error: %s";
      v15 = 118;
      goto LABEL_101;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 119, 60, "skip dataless dir: %s", v23, v11, v12, (char)v82);
LABEL_21:
    if (++v18 >= v9[2])
      return 0;
  }
  v25 = opendir(v82);
  if (!v25)
  {
    v59 = *(unsigned int (**)(_QWORD, uint64_t, _BYTE *, _QWORD))(v8 + 24);
    v19 = v16 + 1;
    if (v59 && v59(*(_QWORD *)(v8 + 16), 12, __src, 0))
    {
      v66 = *__error();
      v73 = v82;
      v14 = "opendir failed: %s";
      v15 = 130;
      goto LABEL_102;
    }
    v74 = *__error();
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 131, 60, "opendir failed with errno=%d: %s", v60, v61, v62, v74);
    goto LABEL_21;
  }
  v26 = v25;
  v75 = v17;
  memset(&v81, 0, 512);
  v27 = 1;
  v79 = 0;
  while (1)
  {
    if (!v27)
      goto LABEL_99;
    if (readdir_r(v26, &v81, &v79))
      break;
    if (!v79)
      goto LABEL_88;
    d_namlen = v81.d_namlen;
    if (v81.d_namlen == 1 && v81.d_name[0] == 46 || v81.d_namlen == 2 && v81.d_name[0] == 46 && v81.d_name[1] == 46)
      goto LABEL_36;
    v31 = v22 + 1 + v81.d_namlen;
    if (v31 >= 0x800)
    {
      v67 = "path too long";
      v68 = 162;
      v69 = 0;
      goto LABEL_98;
    }
    v82[v22] = 47;
    memcpy(&v82[v22 + 1], v81.d_name, d_namlen);
    v82[v31] = 0;
    memset(&v78, 0, sizeof(v78));
    if (lstat(v82, &v78))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 169, 60, "stat failed: %s", v33, v34, v35, (char)v82);
      goto LABEL_36;
    }
    if (v81.d_type == 4)
    {
      v37 = *v9;
      if (!*v9)
        goto LABEL_36;
LABEL_51:
      if (v78.st_dev != v80.st_dev && !*(_DWORD *)(v8 + 40))
        goto LABEL_36;
      if (v37)
      {
        v40 = *(uint64_t (**)(_QWORD, uint64_t, void *, _QWORD))(v8 + 24);
        if (!v40)
          goto LABEL_67;
        v41 = v40(*(_QWORD *)(v8 + 16), 10, __dst, 0);
        if (v41 < 0)
        {
          v55 = 182;
          goto LABEL_79;
        }
        v27 = 1;
        if (v41)
        {
          v36 = 26;
          goto LABEL_38;
        }
      }
      else
      {
        v27 = 1;
      }
      goto LABEL_60;
    }
    if (v81.d_type)
      v38 = 0;
    else
      v38 = (v78.st_mode & 0xF000) == 0x4000;
    v39 = v38;
    v37 = *v9;
    if ((((*v9 != 0) ^ v39) & 1) != 0)
      goto LABEL_36;
    if (v39)
      goto LABEL_51;
    v27 = 0;
LABEL_60:
    v42 = *(uint64_t (**)(_QWORD, uint64_t, void *, _QWORD))(v8 + 24);
    if (!v42)
    {
LABEL_67:
      v45 = 1;
      goto LABEL_68;
    }
    v43 = v42(*(_QWORD *)(v8 + 16), 11, __dst, 0);
    if (v43 < 0)
    {
      v55 = 189;
LABEL_79:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v55, 60, "abort from callback", v33, v34, v35, (char)v73);
      goto LABEL_80;
    }
    if (v43)
      v44 = v27;
    else
      v44 = 1;
    if (v44 == 1)
    {
      v45 = v43 == 0;
LABEL_68:
      v77 = -1;
      if ((StringTableAppend(*((unsigned int **)v9 + 4), v81.d_name, d_namlen, &v77, v32, v33, v34, v35) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 196, 60, 0, "String insertion failed", v46, v47, (char)v73);
LABEL_80:
        v27 = 0;
LABEL_81:
        v36 = 27;
        goto LABEL_38;
      }
      v48 = v9[3];
      v49 = v9[4];
      v50 = (char *)*((_QWORD *)v9 + 3);
      if (v49 >= v48)
      {
        if (v48)
          v51 = 2 * v48;
        else
          v51 = 256;
        v9[3] = v51;
        v52 = (char *)realloc(v50, 12 * v51);
        if (!v52)
        {
          free(v50);
          *((_QWORD *)v9 + 3) = 0;
          v56 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 201, 60, *v56, "malloc", v57, v58, (char)v73);
          v27 = 0;
          v9[3] = 0;
          v9[4] = 0;
          goto LABEL_81;
        }
        *((_QWORD *)v9 + 3) = v52;
        v49 = v9[4];
        v50 = v52;
      }
      v36 = 0;
      v9[4] = v49 + 1;
      v53 = (unsigned int *)&v50[12 * v49];
      v54 = v77;
      *v53 = v18;
      v53[1] = v54;
      v53[2] = !v45;
      goto LABEL_37;
    }
LABEL_36:
    v36 = 26;
LABEL_37:
    v27 = 1;
LABEL_38:
    if (v36 == 27)
    {
      closedir(v26);
      if (v27)
        goto LABEL_90;
LABEL_100:
      v14 = "Directory expansion";
      v15 = 211;
      goto LABEL_101;
    }
  }
  if (*__error() != 11)
  {
    v69 = *__error();
    v67 = "readdir_r";
    v68 = 144;
LABEL_98:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v68, 60, v69, v67, v28, v29, (char)v73);
LABEL_99:
    closedir(v26);
    goto LABEL_100;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 143, 60, "readdir on dataless directory: %s", v63, v64, v65, (char)v82);
LABEL_88:
  closedir(v26);
LABEL_90:
  if (!**(_DWORD **)(v8 + 32))
  {
    v17 = v75;
    v19 = v16 + 1;
    goto LABEL_21;
  }
  v14 = "Abort requested";
  v15 = 212;
LABEL_101:
  v66 = 0;
LABEL_102:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v15, 60, v66, v14, v11, v12, (char)v73);
  v70 = *(unsigned int **)(v8 + 32);
  do
    v71 = __ldaxr(v70);
  while (__stlxr(v71 + 1, v70));
  return 0;
}

uint64_t normalize(_DWORD *a1)
{
  unsigned int v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  char *v20;
  char v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  char *v29;
  int v30;
  char v32;
  void *v33;

  if (*a1)
  {
    v2 = StringTableSize(*((unsigned int **)a1 + 2));
    v33 = 0;
    v3 = *a1;
    if ((StringTableSort(*((unsigned int **)a1 + 2), &v33) & 0x80000000) != 0)
    {
      v27 = "String table sorting";
      v28 = 379;
LABEL_30:
      v30 = 0;
    }
    else
    {
      if ((_DWORD)v3)
      {
        v6 = v33;
        v7 = (_DWORD *)(*((_QWORD *)a1 + 1) + 12);
        v8 = v3;
        do
        {
          v9 = *v7;
          if (v9 >= v2)
          {
            v27 = "Name out of range";
            v28 = 386;
            goto LABEL_30;
          }
          *v7 = v6[v9];
          *((_QWORD *)v7 - 1) = -1;
          v7 += 6;
          --v8;
        }
        while (v8);
        v10 = 0;
        v11 = -1;
        a1[7] = -1;
        v12 = *((_QWORD *)a1 + 1);
        v13 = (_DWORD *)(v12 + 8);
        do
        {
          v14 = *(v13 - 2);
          if (v14 == -1)
          {
            if (v11 != -1)
            {
              v27 = "Multiple root nodes";
              v28 = 399;
              goto LABEL_30;
            }
            a1[7] = v10;
            v11 = v10;
          }
          else
          {
            v15 = v12 + 24 * v14;
            *v13 = *(_DWORD *)(v15 + 4);
            *(_DWORD *)(v15 + 4) = v10;
          }
          v13 += 6;
          ++v10;
        }
        while (v3 != v10);
        v16 = (char *)calloc(v3, 4uLL);
        if (!v16)
          goto LABEL_28;
        v17 = v16;
        v18 = 0;
        v19 = 0;
        v20 = (char *)(*((_QWORD *)a1 + 1) + 16);
        do
        {
          v21 = *v20;
          v20 += 24;
          if ((v21 & 1) == 0)
            *(_DWORD *)&v16[4 * v19++] = v18;
          ++v18;
        }
        while (v3 != v18);
        qsort_r(v16, v19, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))cmpNodesProc);
        v22 = a1 + 6;
        if (v19)
        {
          v23 = 0;
          v24 = *((_QWORD *)a1 + 1);
          do
          {
            v25 = *(_DWORD *)&v17[v23];
            *v22 = v25;
            v22 = (unsigned int *)(v24 + 24 * v25 + 20);
            v23 += 4;
          }
          while (4 * v19 != v23);
        }
        goto LABEL_26;
      }
      a1[7] = -1;
      v29 = (char *)calloc(v3, 4uLL);
      if (v29)
      {
        v17 = v29;
        qsort_r(v29, 0, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))cmpNodesProc);
        v22 = a1 + 6;
LABEL_26:
        v26 = 0;
        *v22 = -1;
LABEL_32:
        free(v33);
        free(v17);
        return v26;
      }
LABEL_28:
      v30 = *__error();
      v27 = "malloc";
      v28 = 410;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"normalize", v28, 60, v30, v27, v4, v5, v32);
    v17 = 0;
    v26 = 0xFFFFFFFFLL;
    goto LABEL_32;
  }
  return 0;
}

AAPathList AAPathListCreateWithPath(const char *dir, const char *path)
{
  const char *v2;
  size_t v3;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  int v10;
  unsigned int *v11;
  size_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  _DWORD *v25;
  const char *v26;
  __int16 v27;
  char v28;
  char v29;
  int v30;
  char __s[2048];
  char v32[2048];
  char v33[1024];
  char v34[1024];
  uint64_t v35;

  v2 = (const char *)((uint64_t (*)(const char *, const char *))MEMORY[0x24BDAC7A8])(dir, path);
  v35 = *MEMORY[0x24BDAC8D0];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(v2, v34))
  {
    v10 = *__error();
    v29 = (char)v2;
    v8 = "Invalid dir: %s";
    v9 = 693;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithPath", v9, 60, v10, v8, v6, v7, v29);
    v11 = 0;
    goto LABEL_21;
  }
  v3 = strlen(v34);
  v5 = v3 != 1 || v34[0] != 47;
  __strlcpy_chk();
  if ((normalizePath((uint64_t)v33) & 0x80000000) != 0)
  {
    v29 = (char)v2;
    v8 = "Invalid path (subpath normalization failed): %s/%s";
    v9 = 699;
    goto LABEL_17;
  }
  if ((concatPath(v32, 0x800uLL, v34, v33) & 0x80000000) != 0)
  {
    v10 = *__error();
    v29 = (char)v2;
    v8 = "Path too long: %s/%s";
    v9 = 705;
    goto LABEL_20;
  }
  if (!realpath_DARWIN_EXTSN(v32, __s))
  {
    v10 = *__error();
    v29 = (char)v2;
    v8 = "Invalid path, doesn't exist: %s/%s";
    v9 = 706;
    goto LABEL_20;
  }
  if (v5 && (strlen(__s) < v3 || memcmp(__s, v34, v3) || __s[v3] && __s[v3] != 47))
  {
    v29 = (char)v2;
    v8 = "Path resolving outside target dir: %s/%s";
    v9 = 713;
LABEL_17:
    v10 = 0;
    goto LABEL_20;
  }
  v11 = (unsigned int *)create();
  if (!v11)
    goto LABEL_21;
  v13 = strlen(v33);
  if (!v13)
  {
LABEL_38:
    if ((normalize(v11) & 0x80000000) != 0)
    {
      v26 = "Tree normalization";
      v27 = 745;
      goto LABEL_42;
    }
    return (AAPathList)v11;
  }
  v14 = v13;
  v15 = 0;
  v16 = 0;
  v17 = *((_QWORD *)v11 + 1) + 24 * v11[7];
  *(_DWORD *)(v17 + 16) |= 1u;
  while (1)
  {
    v18 = v33[v15];
    if (v18 == 47 || v18 == 0)
      break;
LABEL_37:
    if (++v15 > v14)
      goto LABEL_38;
  }
  v30 = -1;
  if ((increaseCapacity((uint64_t)v11, *v11 + 1) & 0x80000000) != 0)
  {
    v26 = "increase PathList capacity";
    v27 = 732;
    goto LABEL_42;
  }
  if ((StringTableAppend(*((unsigned int **)v11 + 2), &v33[v16], v15 - v16, &v30, v20, v21, v22, v23) & 0x80000000) == 0)
  {
    v24 = *v11;
    v25 = (_DWORD *)(*((_QWORD *)v11 + 1) + 24 * *v11);
    *v25 = *v11 - 1;
    v25[3] = v30;
    v25[4] = v18 != 0;
    *v11 = v24 + 1;
    if (!v18)
      goto LABEL_38;
    v16 = ++v15;
    goto LABEL_37;
  }
  v26 = "inserting path component in table";
  v27 = 733;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithPath", v27, 60, 0, v26, v22, v23, v28);
LABEL_21:
  AAPathListDestroy((AAPathList)v11);
  return 0;
}

int AAPathListNodeGetPath(AAPathList path_list, uint64_t node, size_t path_capacity, char *path, size_t *path_length)
{
  int result;
  size_t v7;

  if (node == -1)
  {
    if (path_capacity)
      *path = 0;
    result = 0;
    *path_length = 0;
  }
  else if (*(unsigned int *)path_list <= node)
  {
    return -1;
  }
  else
  {
    v7 = 0;
    result = getPath((uint64_t)path_list, node, path_capacity, path, &v7);
    if (path_length)
      *path_length = v7;
  }
  return result;
}

uint64_t getPath(uint64_t a1, unsigned int a2, size_t a3, _BYTE *a4, size_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  uint64_t v14;
  const void *v15;
  size_t v16;
  uint64_t result;

  if (a2 == -1)
  {
    v16 = 0;
    if (a3)
      *a4 = 0;
    goto LABEL_15;
  }
  if ((getPath() & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD *)(v10 + 8) + 16 * *(unsigned int *)(*(_QWORD *)(a1 + 8) + 24 * a2 + 12);
  v12 = *(unsigned int *)(v11 + 8);
  if (!(_DWORD)v12)
    return 0;
  v13 = *a5;
  v14 = *a5 + 1;
  if (v14 + v12 < a3)
  {
    v15 = (const void *)(*(_QWORD *)(v10 + 32) + *(_QWORD *)v11);
    if (v13)
      a4[v13] = 47;
    else
      v14 = 0;
    memcpy(&a4[v14], v15, v12);
    v16 = v14 + v12;
    a4[v14 + v12] = 0;
    goto LABEL_15;
  }
  if (a3)
    return 0xFFFFFFFFLL;
  v16 = v13 + (v12 + 1);
LABEL_15:
  result = 0;
  *a5 = v16;
  return result;
}

uint64_t AAPathListGetNode(uint64_t a1, char *__s)
{
  uint64_t v2;
  size_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  size_t v17;
  int v18;

  v2 = *(unsigned int *)(a1 + 28);
  if ((_DWORD)v2 != -1)
  {
    v6 = strlen(__s);
    if (!v6)
      return v2;
    v7 = 0;
    v17 = v6;
    while (1)
    {
      v8 = v6 <= v7 + 1 ? v7 + 1 : v6;
      v9 = v7;
      while (1)
      {
        v10 = __s[v9];
        if (v10 == 47)
          break;
        if (v8 == ++v9)
        {
          v10 = __s[v8];
          v9 = v8;
          break;
        }
      }
      v11 = v9 - v7;
      if (v9 == v7)
        break;
      v12 = *(_QWORD *)(a1 + 8);
      v2 = *(unsigned int *)(v12 + 24 * v2 + 4);
      if ((_DWORD)v2 == -1)
        break;
      v18 = v10;
      v13 = *(_QWORD *)(a1 + 16);
      v14 = *(_QWORD *)(v13 + 8);
      v15 = &__s[v7];
      while (1)
      {
        v16 = *(unsigned int *)(v12 + 24 * v2 + 12);
        if (v11 == *(_DWORD *)(v14 + 16 * v16 + 8)
          && !strncmp((const char *)(*(_QWORD *)(v13 + 32) + *(_QWORD *)(v14 + 16 * v16)), v15, v11))
        {
          break;
        }
        v2 = *(unsigned int *)(v12 + 24 * v2 + 8);
        if ((_DWORD)v2 == -1)
          return -1;
      }
      if (v18)
        v7 = v9 + 1;
      else
        v7 = v9;
      v6 = v17;
      if (v7 >= v17)
        return v2;
    }
  }
  return -1;
}

uint64_t AAPathListMerge(uint64_t a1, unsigned int *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  unint64_t v18;
  const char *v19;
  __int16 v20;
  char v21;
  int v22;

  result = 0;
  v22 = 0;
  if (*a2 != 1)
  {
    if ((StringTableAppendTable(*(_QWORD *)(a1 + 16), *((unsigned int **)a2 + 2), &v22) & 0x80000000) != 0)
    {
      v19 = "String table merge";
      v20 = 800;
    }
    else
    {
      v7 = *(_DWORD *)a1;
      if ((increaseCapacity(a1, *a2 + *(_DWORD *)a1) & 0x80000000) != 0)
      {
        v19 = "Capacity increase";
        v20 = 804;
      }
      else
      {
        if (*a2 >= 2)
        {
          v8 = 0;
          v9 = *(_QWORD *)(a1 + 8);
          v10 = *(_DWORD *)a1;
          v11 = (int *)(*((_QWORD *)a2 + 1) + 40);
          do
          {
            *(_DWORD *)a1 = v10 + v8 + 1;
            v12 = v9 + 24 * (v10 + v8);
            v13 = v22 + *(v11 - 1);
            v14 = *(v11 - 4);
            v15 = v14 == 0;
            v16 = v7 - 1 + v14;
            if (v15)
              v16 = 0;
            *(_DWORD *)v12 = v16;
            v17 = *v11;
            v11 += 6;
            *(_DWORD *)(v12 + 12) = v13;
            *(_DWORD *)(v12 + 16) = v17;
            *(_DWORD *)(v12 + 20) = -1;
            *(_QWORD *)(v12 + 4) = -1;
            v18 = v8 + 2;
            ++v8;
          }
          while (v18 < *a2);
        }
        if ((normalize((_DWORD *)a1) & 0x80000000) == 0)
          return 0;
        v19 = "Tree normalization";
        v20 = 816;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListMerge", v20, 60, 0, v19, v5, v6, v21);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t AAPathListNodeFirst(AAPathList path_list)
{
  if (*((_DWORD *)path_list + 6) == -1)
    return -1;
  else
    return *((unsigned int *)path_list + 6);
}

uint64_t AAPathListNodeNext(AAPathList path_list, uint64_t node)
{
  uint64_t v2;
  uint64_t v3;

  if (*(unsigned int *)path_list <= node)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListNodeNext", 826, 60, 0, "Invalid node: %llu", v2, v3, node);
    return -1;
  }
  else if (*(_DWORD *)(*((_QWORD *)path_list + 1) + 24 * node + 20) == -1)
  {
    return -1;
  }
  else
  {
    return *(unsigned int *)(*((_QWORD *)path_list + 1) + 24 * node + 20);
  }
}

uint64_t cmpNodesProc(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  size_t v10;
  char __s2[8];
  char __s1[1024];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = *a3;
  v5 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(v5 + 24 * v3) == *(_DWORD *)(v5 + 24 * *a3))
  {
    v6 = *(_DWORD *)(v5 + 24 * v3 + 12);
    v7 = *(_DWORD *)(v5 + 24 * v4 + 12);
    if (v6 < v7)
      return 0xFFFFFFFFLL;
    else
      return v7 < v6;
  }
  else
  {
    if (*(_DWORD *)a1 <= v3
      || (*(_QWORD *)__s2 = 0, (getPath(a1, v3, 0x400uLL, __s1, (size_t *)__s2) & 0x80000000) != 0)
      || *(_QWORD *)__s2 >= 0x400uLL)
    {
      __s1[0] = 0;
    }
    if (*(_DWORD *)a1 <= v4 || (v10 = 0, (getPath(a1, v4, 0x400uLL, __s2, &v10) & 0x80000000) != 0) || v10 >= 0x400)
      __s2[0] = 0;
    return strcmp(__s1, __s2);
  }
}

AAArchiveStream AAExtractArchiveOutputStreamOpen(const char *dir, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads;
  uint64_t *v10;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  int v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t VolumeCapabilities;
  char v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t i;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  stat v48;

  DefaultNThreads = n_threads;
  if (!n_threads)
    DefaultNThreads = getDefaultNThreads();
  v10 = (uint64_t *)malloc(0x38uLL);
  v11 = v10;
  if (v10)
    memset_s(v10, 0x38uLL, 0, 0x38uLL);
  memset(&v48, 0, sizeof(v48));
  v12 = malloc(0x690uLL);
  v13 = (uint64_t)v12;
  if (v12)
  {
    memset_s(v12, 0x690uLL, 0, 0x690uLL);
    if (v11)
    {
      if (!realpath_DARWIN_EXTSN(dir, (char *)v13))
      {
        v22 = *__error();
        v47 = (char)dir;
        v23 = "%s";
        v24 = 1611;
        goto LABEL_16;
      }
      if (stat((const char *)v13, &v48) || (v48.st_mode & 0xF000) != 0x4000)
      {
        v47 = (char)dir;
        v23 = "Invalid directory: %s";
        v24 = 1612;
      }
      else
      {
        *(_QWORD *)(v13 + 1024) = flags;
        *(_QWORD *)(v13 + 1032) = msg_data;
        *(_QWORD *)(v13 + 1040) = msg_proc;
        *(double *)(v13 + 1656) = getRealTime();
        *(_QWORD *)(v13 + 1640) = 0;
        *(_DWORD *)(v13 + 1056) = 1;
        *(_DWORD *)(v13 + 1072) = 0;
        *(_DWORD *)(v13 + 1076) = DefaultNThreads;
        v16 = calloc(DefaultNThreads, 4uLL);
        *(_QWORD *)(v13 + 1080) = v16;
        if (!v16)
        {
          v20 = "SharedArrayInit: malloc failed\n";
          v21 = 55;
          goto LABEL_22;
        }
        if (pthread_mutex_init((pthread_mutex_t *)(v13 + 1088), 0))
        {
          v20 = "SharedArrayInit: pthread_mutex_init failed\n";
          v21 = 56;
LABEL_22:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v21, 0, v20, v17, v18, v19, v47);
          v23 = "SharedArrayInit";
          v24 = 1619;
          goto LABEL_15;
        }
        if (pthread_cond_init((pthread_cond_t *)(v13 + 1152), 0))
        {
          v20 = "SharedArrayInit: pthread_cond_init failed\n";
          v21 = 57;
          goto LABEL_22;
        }
        VolumeCapabilities = getVolumeCapabilities((const char *)v13);
        v34 = -1;
        if (VolumeCapabilities < 0x7FFFFFFFFFFFFFFFLL)
          v34 = VolumeCapabilities;
        v35 = 268;
        if ((v34 & 8) == 0)
          v35 = 264;
        v36 = v35 & 0xFFFFFFFFFFFFFFDFLL | (32 * (v34 & 1));
        if ((flags & 0x20) == 0 && (v34 & 2) != 0)
          v37 = v36 | 0x40;
        else
          v37 = v36;
        *(_QWORD *)(v13 + 1048) = v37;
        if ((int)isDirEmpty((const char *)v13) >= 1)
          *(_DWORD *)(v13 + 1056) = 0;
        for (i = 0; i != 240; i += 80)
        {
          *(_OWORD *)(v13 + i + 1376) = 0u;
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + i + 1312), 0) < 0)
          {
            v39 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInit", 472, 72, *v39, "pthread_mutex_init", v40, v41, v47);
            v23 = "cluster init";
            v24 = 1638;
            goto LABEL_15;
          }
        }
        *(_QWORD *)(v13 + 1200) = v13;
        if (pthread_mutex_init((pthread_mutex_t *)(v13 + 1216), 0))
        {
          v22 = *__error();
          v23 = "pthread_mutex_init";
          v24 = 1643;
          goto LABEL_16;
        }
        if ((createThread((pthread_t *)(v13 + 1208), (uint64_t)retireThreadProc, v13 + 1200, 0) & 0x80000000) == 0)
        {
          *(_DWORD *)(v13 + 1060) = DefaultNThreads;
          if (DefaultNThreads < 0x2E8BA2E9)
          {
            v42 = calloc(DefaultNThreads, 0xB0uLL);
            *(_QWORD *)(v13 + 1064) = v42;
            if (v42)
            {
              if (!DefaultNThreads)
              {
LABEL_50:
                v11[3] = (uint64_t)extractStreamWriteHeader;
                v11[4] = (uint64_t)extractStreamWriteBlob;
                *v11 = v13;
                v11[1] = (uint64_t)extractStreamClose;
                v11[2] = (uint64_t)extractStreamAbort;
                return (AAArchiveStream)v11;
              }
              v43 = 0;
              while (1)
              {
                v44 = *(_QWORD *)(v13 + 1064);
                v45 = v44 + v43;
                *(_QWORD *)(v44 + v43) = v13;
                if (AASharedBufferPipeOpen((AAByteStream *)(v44 + v43 + 32), (AAByteStream *)(v44 + v43 + 40), 0x40000uLL) < 0)
                {
                  v23 = "creating shared data buffer";
                  v24 = 1654;
                  goto LABEL_15;
                }
                if (AASharedBufferPipeOpen((AAByteStream *)(v45 + 16), (AAByteStream *)(v45 + 24), 0x4000uLL) < 0)
                {
                  v23 = "creating shared command buffer";
                  v24 = 1655;
                  goto LABEL_15;
                }
                v46 = v44 + v43;
                if ((SemInit(v46 + 48) & 0x80000000) != 0)
                {
                  v23 = "SemInit failed";
                  v24 = 1656;
                  goto LABEL_15;
                }
                if ((createThread((pthread_t *)(v46 + 8), (uint64_t)extractThreadProc, v45, 0) & 0x80000000) != 0)
                  break;
                v43 += 176;
                if (176 * DefaultNThreads == v43)
                  goto LABEL_50;
              }
              v23 = "creating worker thread";
              v24 = 1657;
              goto LABEL_15;
            }
          }
          else
          {
            *__error() = 12;
            *(_QWORD *)(v13 + 1064) = 0;
          }
          v22 = *__error();
          v23 = "malloc";
          v24 = 1649;
          goto LABEL_16;
        }
        v23 = "creating retire thread";
        v24 = 1644;
      }
LABEL_15:
      v22 = 0;
      goto LABEL_16;
    }
  }
  v22 = *__error();
  v23 = "malloc";
  v24 = 1610;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"AAExtractArchiveOutputStreamOpen", v24, 72, v22, v23, v14, v15, v47);
  free(v11);
  extractStreamClose(v13, v25, v26, v27, v28, v29, v30, v31);
  return 0;
}

pthread_mutex_t *retireThreadProc(pthread_mutex_t *a1)
{
  pthread_mutex_t *v2;
  _QWORD *sig;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  void (*v19)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v20;
  unint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  _QWORD *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  const char *v41;
  void *v42;
  unsigned int *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  void *v49;
  unsigned int *v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(_QWORD, uint64_t, uint64_t, uint64_t);
  int *v65;
  uint64_t v66;
  uint64_t v67;
  char v69;

  v2 = (pthread_mutex_t *)&a1->__opaque[8];
  sig = (_QWORD *)a1->__sig;
  if (pthread_mutex_lock((pthread_mutex_t *)&a1->__opaque[8]))
    goto LABEL_71;
  v4 = sig + 164;
  while (1)
  {
    v5 = *(_QWORD *)&a1[1].__opaque[16];
    if (v5 >= *(_QWORD *)&a1[1].__opaque[24])
    {
      if (!pthread_mutex_unlock(v2))
        goto LABEL_70;
      v7 = 0;
    }
    else
    {
      v6 = *(_QWORD *)&a1[1].__opaque[32];
      *(_QWORD *)&a1[1].__opaque[16] = v5 + 1;
      v7 = *(_QWORD *)(v6 + 8 * v5);
      if (!pthread_mutex_unlock(v2))
      {
        if (!v7)
          return a1;
        goto LABEL_10;
      }
    }
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadDequeue", 643, 72, *v15, "pthread_mutex_unlock", v16, v17, v69);
    if (!v7)
      return a1;
LABEL_10:
    v18 = *(_DWORD *)(v7 + 2300);
    if (v18 == -1)
      goto LABEL_69;
    if (v18 == 2)
    {
      *(_DWORD *)(v7 + 2300) = 3;
      v19 = (void (*)(_QWORD, uint64_t, uint64_t, uint64_t))sig[130];
      if (v19)
        v19(sig[129], 21, v7, v7 + 2272);
    }
    v20 = *(_QWORD *)(v7 + 2048);
    if (v20 != 70)
    {
LABEL_32:
      if (v20 == 72)
      {
        v32 = sig[195];
        if (v32 == sig[194])
        {
          v33 = 2 * v32;
          v34 = v32 == 0;
          v35 = 32;
          if (!v34)
            v35 = v33;
          sig[194] = v35;
          if ((unint64_t)(8 * v35) >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_63;
          }
          v42 = (void *)sig[196];
          v36 = realloc(v42, 8 * v35);
          if (v36)
          {
            sig[196] = v36;
            v32 = sig[195];
            goto LABEL_42;
          }
          free(v42);
LABEL_63:
          sig[196] = 0;
          v54 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"hlinkInsertEntry", 455, 72, *v54, "malloc", v55, v56, v69);
          sig[194] = 0;
          sig[195] = 0;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 681, 72, 0, "hlinkInsertEntry failed: %s", v57, v58, v7);
LABEL_66:
          if (*(_DWORD *)(v7 + 2300) == -1)
            goto LABEL_69;
LABEL_67:
          *(_DWORD *)(v7 + 2300) = -1;
          v64 = (void (*)(_QWORD, uint64_t, uint64_t, uint64_t))sig[130];
          if (v64)
            v64(sig[129], 22, v7, v7 + 2272);
          goto LABEL_69;
        }
        v36 = (_QWORD *)sig[196];
LABEL_42:
        sig[195] = v32 + 1;
        v36[v32] = v7;
        v43 = (unsigned int *)(v7 + 2304);
        do
          v44 = __ldaxr(v43);
        while (__stlxr(v44 + 1, v43));
        v20 = *(_QWORD *)(v7 + 2048);
      }
      if (v20 != 68)
        goto LABEL_69;
      v45 = sig[198];
      if (v45 == sig[197])
      {
        v46 = 2 * v45;
        v34 = v45 == 0;
        v47 = 32;
        if (!v34)
          v47 = v46;
        sig[197] = v47;
        if ((unint64_t)(8 * v47) >= 0x2000000001)
        {
          *__error() = 12;
LABEL_65:
          sig[199] = 0;
          v59 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"dirInsertEntry", 433, 72, *v59, "malloc", v60, v61, v69);
          sig[197] = 0;
          sig[198] = 0;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 687, 72, 0, "dirInsertEntry failed: %s", v62, v63, v7);
          goto LABEL_66;
        }
        v49 = (void *)sig[199];
        v48 = realloc(v49, 8 * v47);
        if (!v48)
        {
          free(v49);
          goto LABEL_65;
        }
        sig[199] = v48;
        v45 = sig[198];
      }
      else
      {
        v48 = (_QWORD *)sig[199];
      }
      sig[198] = v45 + 1;
      v48[v45] = v7;
      v50 = (unsigned int *)(v7 + 2304);
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 + 1, v50));
      goto LABEL_69;
    }
    v21 = 0;
    v22 = (unsigned int *)(v7 + 2304);
    while (1)
    {
      v23 = *(_QWORD *)(v7 + 8 * v21 + 2312);
      if (v23 == -1)
        goto LABEL_30;
      if (pthread_mutex_lock((pthread_mutex_t *)&v4[10 * v21]) < 0)
      {
        v37 = *__error();
        v40 = 561;
        v41 = "pthread_mutex_lock";
        goto LABEL_59;
      }
      v26 = v4[10 * v21 + 9];
      if (!v21)
        break;
      v27 = *(_QWORD *)(v7 + 2312);
      if (v27 == -1)
        break;
      *(_QWORD *)(v26 + 32 * v23 + 16) = v27;
      if (v21 >= 2)
      {
        v28 = *(_QWORD *)(v7 + 2320);
        if (v28 != -1)
          goto LABEL_25;
      }
LABEL_29:
      if (pthread_mutex_unlock((pthread_mutex_t *)&v4[10 * v21]) < 0)
        goto LABEL_58;
LABEL_30:
      if (++v21 == 3)
      {
        v20 = *(_QWORD *)(v7 + 2048);
        goto LABEL_32;
      }
    }
    if (v21 >= 2)
    {
      v28 = *(_QWORD *)(v7 + 2320);
      if (v28 != -1)
      {
LABEL_25:
        *(_QWORD *)(v26 + 32 * v23 + 24) = v28;
        goto LABEL_29;
      }
    }
    v29 = v7 + 8 * v21;
    if (!*(_QWORD *)(v29 + 2336))
    {
      v30 = v26 + 32 * v23;
      *(_QWORD *)(v29 + 2336) = *(_QWORD *)(v30 + 8);
      *(_QWORD *)(v30 + 8) = v7;
      do
        v31 = __ldaxr(v22);
      while (__stlxr(v31 + 1, v22));
      goto LABEL_29;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInsertEntry", 574, 72, 0, "entry already linked", v24, v25, v69);
    if ((pthread_mutex_unlock((pthread_mutex_t *)&v4[10 * v21]) & 0x80000000) == 0)
      goto LABEL_60;
LABEL_58:
    v37 = *__error();
    v40 = 585;
    v41 = "pthread_mutex_unlock";
LABEL_59:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInsertEntry", v40, 72, v37, v41, v38, v39, v69);
LABEL_60:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 674, 72, 0, "clusterInsertEntry failed: %s", v52, v53, v7);
    if (*(_DWORD *)(v7 + 2300) != -1)
      goto LABEL_67;
LABEL_69:
    entryRelease(v7, v8, v9, v10, v11, v12, v13, v14);
LABEL_70:
    if (pthread_mutex_lock(v2))
    {
LABEL_71:
      v65 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadDequeue", 637, 72, *v65, "pthread_mutex_lock", v66, v67, v69);
      return a1;
    }
  }
}

uint64_t SemInit(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0))
    return 0xFFFFFFFFLL;
  if (pthread_cond_init((pthread_cond_t *)(a1 + 72), 0))
    return 0xFFFFFFFFLL;
  return 0;
}

uint64_t extractThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int v14;
  pthread_mutex_t *v15;
  pthread_mutex_t *v16;
  pthread_cond_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  ssize_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  unint64_t *v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  size_t v45;
  ssize_t v46;
  ssize_t v47;
  pthread_mutex_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  ssize_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t (**v58)(uint64_t);
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  ssize_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  size_t v70;
  ssize_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int16 v84;
  const char *v85;
  unint64_t v86;
  __int16 v87;
  const char *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  int v99;
  _QWORD *v100;
  uid_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  gid_t v113;
  int v114;
  const char *v115;
  __int16 v116;
  char v118;
  int v119;
  uint64_t v120;
  pthread_cond_t *v121;
  int v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  size_t buf[2];
  stat v127;
  char __s2[2048];
  char __s[2048];
  char v130[2048];
  char v131[2048];
  uint64_t v132;

  v8 = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v132 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)v8;
  v10 = *(_QWORD *)(*(_QWORD *)v8 + 1064);
  bzero(v130, 0x800uLL);
  bzero(__s, 0x800uLL);
  bzero(__s2, 0x800uLL);
  v13 = (char *)malloc(0x40000uLL);
  if (!v13)
  {
    v114 = *__error();
    v115 = "malloc";
    v116 = 756;
LABEL_197:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v116, 72, v114, v115, v11, v12, v118);
    free(v13);
    return v8;
  }
  if (*(_DWORD *)(v9 + 1060) <= -1171354717 * ((unint64_t)(v8 - v10) >> 4))
  {
    v118 = -93 * ((unint64_t)(v8 - v10) >> 4);
    v115 = "invalid thread ID %d";
    v116 = 757;
    v114 = 0;
    goto LABEL_197;
  }
  v123 = -1171354717 * ((unint64_t)(v8 - v10) >> 4);
  v14 = 0;
  v15 = (pthread_mutex_t *)(v9 + 1088);
  v16 = (pthread_mutex_t *)(v8 + 56);
  v17 = (pthread_cond_t *)(v8 + 120);
  v120 = v9 + 1200;
  v121 = (pthread_cond_t *)(v9 + 1152);
  v122 = -1;
  while (1)
  {
LABEL_4:
    if (v14)
      goto LABEL_20;
    if (pthread_mutex_lock(v15))
    {
      v21 = 117;
      v22 = "SharedArrayPush: pthread_mutex_lock failed\n";
LABEL_14:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v21, 0, v22, v18, v19, v20, v118);
      goto LABEL_15;
    }
    v23 = *(unsigned int *)(v9 + 1072);
    v24 = *(_DWORD *)(v9 + 1076);
    v25 = v23;
    if (v23 < v24)
    {
      *(_DWORD *)(*(_QWORD *)(v9 + 1080) + 4 * v23) = v123;
      v25 = *(_DWORD *)(v9 + 1072);
    }
    *(_DWORD *)(v9 + 1072) = v25 + 1;
    if (!v25 && pthread_cond_broadcast(v121))
    {
      v21 = 122;
      v22 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      goto LABEL_14;
    }
    if (pthread_mutex_unlock(v15))
    {
      v21 = 124;
      v22 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      goto LABEL_14;
    }
    if (v23 >= v24)
    {
      v21 = 125;
      v22 = "SharedArrayPush: stack is full\n";
      goto LABEL_14;
    }
LABEL_15:
    if (!pthread_mutex_lock(v16))
    {
      while (1)
      {
        v26 = *(_DWORD *)(v8 + 48);
        if (v26 > 0)
          break;
        if (pthread_cond_wait(v17, v16))
          goto LABEL_20;
      }
      *(_DWORD *)(v8 + 48) = v26 - 1;
      pthread_mutex_unlock(v16);
    }
LABEL_20:
    memset(buf, 0, 12);
    v27 = AAByteStreamRead(*(AAByteStream *)(v8 + 24), buf, 0xCuLL);
    if (v27 != 12)
      break;
    switch(LODWORD(buf[0]))
    {
      case 'A':
        goto LABEL_25;
      case 'B':
        if (*(_QWORD *)(v8 + 168))
          goto LABEL_74;
        v35 = 786;
        v36 = "no entry in thread";
        goto LABEL_83;
      case 'C':
        goto LABEL_67;
      case 'D':
        v42 = *(_QWORD *)(v8 + 168);
        if (!v42)
          goto LABEL_74;
        v43 = *(_QWORD *)(v42 + 2192);
        if (v43 == -1)
        {
          v35 = 847;
          v36 = "DAT size not received yet";
          goto LABEL_83;
        }
        if (*(_QWORD *)(v42 + 2288))
          goto LABEL_38;
        if ((*(_BYTE *)(v42 + 2056) & 4) == 0)
        {
          v76 = 0;
          v77 = -1;
          goto LABEL_99;
        }
        v76 = 0;
        v77 = -1;
        if (!v43 || (*(_DWORD *)(v42 + 2068) & 0x20) == 0)
          goto LABEL_99;
        if ((*(_BYTE *)(v42 + 2128) & 1) != 0)
        {
          v77 = *(_DWORD *)(v42 + 2136);
          if ((*(_BYTE *)(v42 + 2128) & 0x10) == 0)
          {
LABEL_159:
            v76 = 0;
            goto LABEL_99;
          }
        }
        else
        {
          v77 = 0;
          if ((*(_BYTE *)(v42 + 2128) & 0x10) == 0)
            goto LABEL_159;
        }
        v76 = *(unsigned int *)(v42 + 2156);
        v86 = *(unsigned int *)(v42 + 2152);
        if ((_DWORD)v86)
        {
          if (v43 <= v86)
          {
            v76 = v76 & 0xFFFFFFFC;
            v77 = 10;
          }
          else
          {
            v76 |= 3uLL;
          }
        }
LABEL_99:
        v125 = v77;
        if ((*(_BYTE *)(v42 + 2128) & 8) != 0 && (*(_BYTE *)(v9 + 1030) & 2) != 0)
          v78 = *(_DWORD *)(v42 + 2132);
        else
          v78 = -1;
        v119 = v78;
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, (const char *)v42) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 885, 72, 0, "invalid path: %s", v93, v94, v42);
          goto LABEL_84;
        }
        if (*(_DWORD *)(v9 + 1056))
          removeFile(v130);
        __strlcpy_chk();
        v95 = strrchr(__s, 47);
        if (!v95)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 890, 72, 0, "invalid path: %s", v96, v97, (char)v130);
          v65 = 1;
          v14 = 1;
          v16 = (pthread_mutex_t *)(v8 + 56);
          goto LABEL_86;
        }
        *v95 = 0;
        v98 = v95 + 1;
        if (v122 < 0)
          goto LABEL_154;
        if (!strcmp(__s, __s2))
        {
          v99 = v122;
        }
        else
        {
          close(v122);
LABEL_154:
          __strlcpy_chk();
          v99 = open(__s2, 0);
          if (v99 < 0)
          {
            v122 = v99;
            v100 = *(_QWORD **)(v42 + 2288);
            goto LABEL_170;
          }
        }
        v122 = v99;
        v100 = aaArchiveFileOutputStreamOpenAt(v99, v98, *(_QWORD *)(v42 + 2192), v125, v76, v119, *(_QWORD *)(v9 + 1048));
        *(_QWORD *)(v42 + 2288) = v100;
LABEL_170:
        v16 = (pthread_mutex_t *)(v8 + 56);
        if (!v100)
        {
          v108 = aaArchiveFileOutputStreamOpenAt(-1, v130, *(_QWORD *)(v42 + 2192), v125, v76, v119, *(_QWORD *)(v9 + 1048));
          *(_QWORD *)(v42 + 2288) = v108;
          if (!v108)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 904, 72, 0, "opening output file: %s", v109, v110, (char)v130);
LABEL_84:
            v65 = 1;
LABEL_85:
            v14 = 1;
            goto LABEL_86;
          }
        }
LABEL_38:
        v44 = *(size_t *)((char *)buf + 4);
        if (!*(size_t *)((char *)buf + 4))
        {
          v14 = 1;
          continue;
        }
        v124 = v42;
        while (1)
        {
          if (v44 >= 0x40000)
            v45 = 0x40000;
          else
            v45 = v44;
          v46 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v45);
          if (v46 < 0)
          {
            v35 = 912;
            goto LABEL_80;
          }
          v47 = v46;
          v48 = v15;
          v49 = v9;
          v50 = *(_QWORD *)(v124 + 2288);
          if (*(_QWORD *)(v50 + 24))
          {
            v51 = 0;
            if (v46)
            {
              v52 = v13;
              v53 = v46;
              while (1)
              {
                v54 = (*(uint64_t (**)(_QWORD, char *, ssize_t))(v50 + 24))(*(_QWORD *)v50, v52, v53);
                if (v54 < 1)
                  break;
                v52 += v54;
                v51 += v54;
                v53 -= v54;
                if (!v53)
                  goto LABEL_52;
              }
              v51 = v54;
            }
          }
          else
          {
            v51 = -1;
          }
LABEL_52:
          if (v51 != v47)
            break;
          v14 = 1;
          v44 = *(size_t *)((char *)buf + 4) - v47;
          v55 = *(size_t *)((char *)buf + 4) == v47;
          *(size_t *)((char *)buf + 4) -= v47;
          v9 = v49;
          v15 = v48;
          v16 = (pthread_mutex_t *)(v8 + 56);
          v17 = (pthread_cond_t *)(v8 + 120);
          if (v55)
            goto LABEL_4;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 914, 72, 0, "write failed %zd", v33, v34, v51);
        v65 = 1;
        v14 = 1;
        v9 = v49;
        v15 = v48;
        goto LABEL_183;
      case 'E':
        v56 = *(_QWORD *)(v8 + 168);
        if (!v56)
        {
          v65 = 0;
          v14 = 0;
LABEL_133:
          v17 = (pthread_cond_t *)(v8 + 120);
          goto LABEL_86;
        }
        v57 = *(_QWORD *)(v56 + 2048);
        if (v57 != 70)
          goto LABEL_104;
        v58 = *(uint64_t (***)(uint64_t))(v56 + 2288);
        if (v58)
          goto LABEL_59;
        if (*(_QWORD *)(v56 + 2192))
          goto LABEL_103;
        if ((*(_BYTE *)(v56 + 2128) & 8) != 0 && (*(_BYTE *)(v9 + 1030) & 2) != 0)
          v92 = *(_DWORD *)(v56 + 2132);
        else
          v92 = -1;
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, *(const char **)(v8 + 168)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 808, 72, 0, "invalid path: %s", v111, v112, v56);
        }
        else
        {
          if (*(_DWORD *)(v9 + 1056))
            removeFile(v130);
          v58 = (uint64_t (**)(uint64_t))aaArchiveFileOutputStreamOpenAt(-1, v130, *(_QWORD *)(v56 + 2192), 0xFFFFFFFF, 0, v92, *(_QWORD *)(v9 + 1048));
          *(_QWORD *)(v56 + 2288) = v58;
          if (v58)
          {
            v57 = *(_QWORD *)(v56 + 2048);
            v16 = (pthread_mutex_t *)(v8 + 56);
            if (v57 != 70)
              goto LABEL_104;
LABEL_59:
            *(_DWORD *)(v56 + 2296) = aaArchiveFileOutputStreamCloseAndReturnFD(v58, v28, v29, v30, v31, v32, v33, v34);
            *(_QWORD *)(v56 + 2288) = 0;
            v61 = applyEntryAttributes(v9, v56);
            v62 = *(_DWORD *)(v56 + 2296);
            if ((v62 & 0x80000000) == 0)
            {
              close(v62);
              *(_DWORD *)(v56 + 2296) = -1;
            }
            if (v61 < 0)
            {
              v118 = v56;
              v84 = 822;
              goto LABEL_121;
            }
            if (*(_DWORD *)(v56 + 2300) != 2)
              *(_DWORD *)(v56 + 2300) = 2;
LABEL_103:
            v57 = *(_QWORD *)(v56 + 2048);
LABEL_104:
            if (v57 == 70 || v57 == 72)
            {
LABEL_106:
              if ((retireThreadEnqueue(v120, *(_QWORD *)(v8 + 168)) & 0x80000000) == 0)
              {
                v65 = 0;
                v14 = 0;
                *(_QWORD *)(v8 + 168) = 0;
                goto LABEL_133;
              }
              v84 = 837;
              v85 = "sending entry to retire thread";
LABEL_132:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v84, 72, 0, v85, v59, v60, v118);
              v14 = 0;
              v65 = 1;
              goto LABEL_133;
            }
            if ((concatExtractPath(v131, 0x800uLL, (char *)v9, (const char *)v56) & 0x80000000) != 0)
            {
              v118 = v56;
              v87 = 274;
              v88 = "invalid path: %s";
            }
            else
            {
              v81 = *(_QWORD *)(v56 + 2048);
              if (v81 == 68)
              {
                memset(&v127, 0, sizeof(v127));
                if (*(_DWORD *)(v9 + 1056) && !lstat(v131, &v127))
                {
                  if ((v127.st_mode & 0xF000) != 0x4000)
                  {
                    removeFile(v131);
                    goto LABEL_114;
                  }
LABEL_190:
                  if (*(_DWORD *)(v56 + 2300) != 2)
                    *(_DWORD *)(v56 + 2300) = 2;
                  if (*(_QWORD *)(v56 + 2048) == 68 || (applyEntryAttributes(v9, v56) & 0x80000000) == 0)
                    goto LABEL_106;
                  v118 = v56;
                  v84 = 833;
LABEL_121:
                  v85 = "applyEntryAttributes failed: %s";
                  goto LABEL_132;
                }
LABEL_114:
                if (!mkdir(v131, 0x1EDu))
                {
                  if ((*(_BYTE *)(v56 + 2056) & 3) != 0)
                  {
                    if ((*(_BYTE *)(v56 + 2056) & 1) != 0)
                      v101 = *(_DWORD *)(v56 + 2060);
                    else
                      v101 = -1;
                    if ((*(_BYTE *)(v56 + 2056) & 2) != 0)
                      v113 = *(_DWORD *)(v56 + 2064);
                    else
                      v113 = -1;
                    chown(v131, v101, v113);
                  }
                  goto LABEL_190;
                }
                if (!lstat(v131, &v127) && (v127.st_mode & 0xF000) == 0x4000)
                  goto LABEL_190;
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 305, 72, 0, "mkdir failed: %s", v82, v83, v56);
LABEL_131:
                v118 = v56;
                v84 = 829;
                v85 = "creating fs object: %s";
                goto LABEL_132;
              }
              if (*(_DWORD *)(v9 + 1056))
              {
                removeFile(v131);
                v81 = *(_QWORD *)(v56 + 2048);
              }
              switch(v81)
              {
                case 'H':
                  if (!link((const char *)(v56 + 1024), v131))
                    goto LABEL_190;
                  v102 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 320, 72, v102, "link %s", v103, v104, v56);
                  goto LABEL_131;
                case 'P':
                  if (!mkfifo(v131, 0x1A4u))
                    goto LABEL_190;
                  v105 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 325, 72, v105, "mkfifo %s", v106, v107, v56);
                  goto LABEL_131;
                case 'L':
                  if (!symlink((const char *)(v56 + 1024), v131))
                    goto LABEL_190;
                  v89 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 315, 72, v89, "symlink %s", v90, v91, v56);
                  goto LABEL_131;
              }
              v87 = 330;
              v88 = "not implemented yet";
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", v87, 72, 0, v88, v79, v80, v118);
            goto LABEL_131;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 811, 72, 0, "opening output file: %s", v33, v34, (char)v130);
        }
        v14 = 0;
        v65 = 1;
LABEL_183:
        v16 = (pthread_mutex_t *)(v8 + 56);
        v17 = (pthread_cond_t *)(v8 + 120);
LABEL_86:
        v69 = *(size_t *)((char *)buf + 4);
        if (*(size_t *)((char *)buf + 4))
        {
          while (1)
          {
            v70 = v69 >= 0x40000 ? 0x40000 : v69;
            v71 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v70);
            if (v71 < 0)
              break;
            v69 = *(size_t *)((char *)buf + 4) - v71;
            *(size_t *)((char *)buf + 4) -= v71;
            if (!*(size_t *)((char *)buf + 4))
              goto LABEL_92;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 953, 72, 0, "reading payload", v72, v73, v118);
        }
        else
        {
LABEL_92:
          if (!v65)
            continue;
        }
        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0)
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 959, 72, 0, "retire failed entry", v74, v75, v118);
        break;
      case 'F':
        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 792, 72, 0, "retire failed entry", v63, v64, v118);
          v14 = 0;
          v65 = 1;
        }
        else
        {
          v65 = 0;
          v14 = 0;
        }
        goto LABEL_86;
      default:
        if ((LODWORD(buf[0]) - 88) >= 2)
        {
          if (LODWORD(buf[0]) == 42)
            goto LABEL_199;
LABEL_67:
          v35 = 942;
          v36 = "Invalid thread command";
        }
        else
        {
LABEL_25:
          v37 = *(unint64_t **)(v8 + 168);
          if (!v37)
            goto LABEL_74;
          v38 = v37 + 281;
          v39 = v37 + 275;
          v40 = v37 + 278;
          if (LODWORD(buf[0]) != 65)
            v40 = 0;
          if (LODWORD(buf[0]) == 88)
            v40 = v39;
          if (LODWORD(buf[0]) == 89)
            v41 = v38;
          else
            v41 = v40;
          if (*v41 + *(size_t *)((char *)buf + 4) <= v41[1])
          {
            v66 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), (void *)(v41[2] + *v41), *(size_t *)((char *)buf + 4));
            if (v66 < 0)
            {
              v35 = 933;
LABEL_80:
              v36 = "reading payload";
            }
            else
            {
              v67 = *(size_t *)((char *)buf + 4);
              *(size_t *)((char *)buf + 4) -= v66;
              if (v66)
              {
                v68 = *v41 + v66;
                if (!__CFADD__(*v41, v66) && v68 <= v41[1])
                  *v41 = v68;
              }
              if (v67 == v66)
              {
LABEL_74:
                v65 = 0;
                goto LABEL_85;
              }
              v35 = 936;
              v36 = "truncated read";
            }
          }
          else
          {
            v35 = 931;
            v36 = "too many blob bytes received";
          }
        }
LABEL_83:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v35, 72, 0, v36, v33, v34, v118);
        goto LABEL_84;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 775, 72, 0, "reading thread command, %zd", v33, v34, v27);
LABEL_199:
  free(v13);
  if ((v122 & 0x80000000) == 0)
    close(v122);
  return v8;
}

uint64_t extractStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  AAByteStream_impl *v22;
  int i;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  pthread_mutex_t *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  BOOL v59;
  char v60;
  int v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int Path;
  int v70;
  char v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  int v78;
  void (*v79)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void (*v83)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  __int16 v99;
  const char *v100;
  int v101;
  int v102;
  void (*v103)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  __int16 v117;
  const char *v118;
  uint64_t v119;
  unsigned int v120;
  FILE **v121;
  char v122;
  _BOOL4 v123;
  double v124;
  uint64_t j;
  uint64_t v126;
  unint64_t *v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t *v130;
  uint64_t v131;
  const char *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  char v139;
  unint64_t v140;
  int v141;
  int v142;
  uint64_t v143;
  char v144;
  uint64_t v145;
  char v146;
  unsigned int v147;
  int v148;
  _QWORD *v149;
  _QWORD *v150;
  char v151[1797];
  int buf;
  uint64_t v153;
  uint64_t v154;

  result = MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5, a6, a7, a8);
  v154 = *MEMORY[0x24BDAC8D0];
  if (!result)
    return result;
  v11 = result;
  v140 = *(_QWORD *)(result + 1024);
  if (atomic_load((unsigned int *)(result + 1600)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1486, 72, 0, "stream cancelled", v9, v10, v139);
    v13 = 0;
  }
  else
  {
    v13 = 1;
  }
  if (*(_QWORD *)(v11 + 1632) || *(_QWORD *)(v11 + 1640))
  {
    extractStreamStateFail(v11);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1492, 72, 0, "invalid state on destroy", v14, v15, v139);
    v13 = 0;
  }
  if (*(_QWORD *)(v11 + 1064))
  {
    v141 = v13;
    v16 = *(unsigned int *)(v11 + 1060);
    if ((_DWORD)v16)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = *(_QWORD *)(v11 + 1064);
        if (v20)
        {
          v21 = v20 + v17;
          if (*(_QWORD *)(v21 + 8))
            ++v19;
          if (!v141)
          {
            v22 = *(AAByteStream_impl **)(v21 + 32);
            if (v22)
            {
              AAByteStreamCancel(v22);
              v16 = *(unsigned int *)(v11 + 1060);
            }
          }
        }
        ++v18;
        v17 += 176;
      }
      while (v18 < v16);
      if (v19)
      {
        for (i = 0; i != v19; ++i)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1088)))
          {
            v27 = 91;
            v28 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_25:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v27, 0, v28, v24, v25, v26, v139);
          }
          else
          {
            while (1)
            {
              v29 = *(_DWORD *)(v11 + 1072);
              if (v29)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(v11 + 1152), (pthread_mutex_t *)(v11 + 1088)))
              {
                v27 = 94;
                v28 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_25;
              }
            }
            v30 = v29 - 1;
            *(_DWORD *)(v11 + 1072) = v30;
            v31 = *(_DWORD *)(*(_QWORD *)(v11 + 1080) + 4 * v30);
            if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1088)))
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v32, v33, v34, v139);
            if (v31 != -1)
            {
              v35 = *(_QWORD *)(v11 + 1064);
              v36 = (pthread_mutex_t *)(v35 + 176 * v31 + 56);
              if (!pthread_mutex_lock(v36))
              {
                v37 = v35 + 176 * v31;
                v38 = *(_DWORD *)(v37 + 48);
                *(_DWORD *)(v37 + 48) = v38 + 1;
                if (v38 || !pthread_cond_broadcast((pthread_cond_t *)(v35 + 176 * v31 + 120)))
                  pthread_mutex_unlock(v36);
              }
              v153 = 0;
              buf = 42;
              v39 = v35 + 176 * v31;
              AAByteStreamWrite(*(AAByteStream *)(v39 + 16), &buf, 0xCuLL);
              joinThread(*(_opaque_pthread_t **)(v39 + 8));
              AAByteStreamClose(*(AAByteStream *)(v39 + 16));
              AAByteStreamClose(*(AAByteStream *)(v39 + 24));
              AAByteStreamClose(*(AAByteStream *)(v39 + 32));
              AAByteStreamClose(*(AAByteStream *)(v39 + 40));
              if (!pthread_mutex_destroy(v36))
                pthread_cond_destroy((pthread_cond_t *)(v35 + 176 * v31 + 120));
            }
          }
        }
      }
    }
    free(*(void **)(v11 + 1064));
    v13 = v141;
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v11 + 1088)) && !pthread_cond_destroy((pthread_cond_t *)(v11 + 1152)))
    free(*(void **)(v11 + 1080));
  if (*(_QWORD *)(v11 + 1208))
  {
    retireThreadEnqueue(v11 + 1200, 0);
    joinThread(*(_opaque_pthread_t **)(v11 + 1208));
    pthread_mutex_destroy((pthread_mutex_t *)(v11 + 1216));
  }
  if (*(_QWORD *)(v11 + 1632))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1541, 72, 0, "entry found in extract stream", v45, v46, v139);
    entryRelease(*(_QWORD *)(v11 + 1632), v47, v48, v49, v50, v51, v52, v53);
    v13 = 0;
  }
  v142 = v13;
  v54 = 0;
  v55 = *(_QWORD *)(v11 + 1024);
  v147 = v55 & 1;
  v56 = v11 + 1312;
  v57 = (_QWORD *)(v11 + 1384);
  v144 = v55;
  v145 = v11 + 1312;
  v143 = (v55 >> 7) & 1;
  do
  {
    v150 = (_QWORD *)(v56 + 80 * v54 + 64);
    if (*v150)
    {
      v58 = 0;
      v149 = (_QWORD *)(v145 + 80 * v54 + 72);
      v59 = (v144 & 0x10) == 0 && v54 == 2;
      v60 = v59;
      if (v59)
        v61 = v143;
      else
        v61 = 0;
      v148 = v61;
      v146 = v60 ^ 1 | v143;
      while (1)
      {
        v62 = (uint64_t *)(*v149 + 32 * v58);
        v63 = v62 + 1;
        if (!v62[1])
          goto LABEL_103;
        v64 = v62[2];
        v65 = v57;
        if (v64 != -1 || (v64 = *(_QWORD *)(*v149 + 32 * v58 + 24), v65 = (_QWORD *)(v11 + 1464), v64 != -1))
          v62 = (uint64_t *)(*v65 + 32 * v64);
        v66 = *v62;
        if (*v62)
        {
          if (*(_DWORD *)(v66 + 2300) == 3)
            break;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1049, 72, 0, "no valid DAT entry for cluster %d/%llu", v45, v46, v54);
        while (1)
        {
          v82 = *v63;
          if (!*v63)
            break;
          *v63 = *(_QWORD *)(v82 + 8 * v54 + 2336);
          if (*(_DWORD *)(v82 + 2300) != -1)
          {
            *(_DWORD *)(v82 + 2300) = -1;
            v83 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v11 + 1040);
            if (v83)
              v83(*(_QWORD *)(v11 + 1032), 22, v82, v82 + 2272);
          }
          entryRelease(v82, v40, v41, v42, v43, v44, v45, v46);
        }
LABEL_103:
        if ((unint64_t)++v58 >= *v150)
          goto LABEL_111;
      }
      if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, (const char *)v66) & 0x80000000) != 0)
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1071, 72, 0, "invalid DAT path", v45, v46, v139);
      while (1)
      {
        v81 = *v63;
        if (!*v63)
        {
          v57 = (_QWORD *)(v11 + 1384);
          goto LABEL_103;
        }
        *v63 = *(_QWORD *)(v81 + 8 * v54 + 2336);
        if (v81 == v66)
        {
          v72 = v66;
          goto LABEL_100;
        }
        Path = concatExtractPath(v151, 0x800uLL, (char *)v11, (const char *)v81);
        if (Path < 0)
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1082, 72, 0, "invalid path: %s", v67, v68, v81);
        unlink(v151);
        if (!(_DWORD)v54)
          break;
        if ((_DWORD)v54 == 1)
          goto LABEL_71;
        if (v148)
          break;
        if ((v146 & 1) == 0)
        {
LABEL_71:
          v70 = clonefile((const char *)&buf, v151, 0);
          v71 = 0;
          if ((v70 & 0x80000000) == 0)
            goto LABEL_80;
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1116, 72, "failed to create clone: %s", v44, v45, v46, v81);
        }
        v76 = copyFileWithAttributes((const char *)&buf, v151, 0, v147, 0);
        v71 = 0;
        if (v76 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1123, 72, 0, "create copy: %s", v45, v46, v81);
          v77 = 0;
LABEL_88:
          if ((applyEntryAttributes(v11, v81) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1129, 72, 0, "setting entry attributes: %s", v45, v46, v81);
            goto LABEL_92;
          }
          goto LABEL_89;
        }
LABEL_80:
        if (Path < 0)
        {
          v77 = 0;
          if ((v71 & 1) == 0)
            goto LABEL_88;
        }
        else
        {
          if (*(_DWORD *)(v81 + 2300) != 2)
            *(_DWORD *)(v81 + 2300) = 2;
          v77 = 1;
          if ((v71 & 1) == 0)
            goto LABEL_88;
        }
LABEL_89:
        if (v77)
        {
          v78 = 3;
          goto LABEL_93;
        }
LABEL_92:
        v78 = -1;
LABEL_93:
        if (*(_DWORD *)(v81 + 2300) != v78)
        {
          *(_DWORD *)(v81 + 2300) = v78;
          v79 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v11 + 1040);
          if (v79)
          {
            if (v78 == -1)
              v80 = 22;
            else
              v80 = 21;
            v79(*(_QWORD *)(v11 + 1032), v80, v81, v81 + 2272);
          }
        }
        v72 = v81;
LABEL_100:
        entryRelease(v72, v40, v41, v42, v43, v44, v45, v46);
      }
      if (link((const char *)&buf, v151) < 0)
      {
        v73 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1108, 72, v73, "failed to create hard link: %s", v74, v75, v81);
        goto LABEL_92;
      }
      v71 = 1;
      goto LABEL_80;
    }
LABEL_111:
    ++v54;
    v56 = v11 + 1312;
  }
  while (v54 != 3);
  if (!*(_QWORD *)(v11 + 1560))
  {
    *(_QWORD *)(v11 + 1560) = 0;
    goto LABEL_135;
  }
  v84 = 0;
  v85 = 1;
  while (2)
  {
    v86 = *(_QWORD *)(*(_QWORD *)(v11 + 1568) + 8 * v84);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, (const char *)v86) & 0x80000000) != 0)
    {
      v99 = 1007;
      v100 = "invalid 'H' PAT";
      goto LABEL_122;
    }
    if ((concatExtractPath(v151, 0x800uLL, (char *)v11, (const char *)(v86 + 1024)) & 0x80000000) != 0)
    {
      v99 = 1008;
      v100 = "invalid 'H' LNK";
LABEL_122:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessHLinks", v99, 72, 0, v100, v87, v88, v139);
LABEL_123:
      v101 = 0;
      v102 = -1;
      goto LABEL_124;
    }
    if (*(_DWORD *)(v11 + 1056))
      removeFile((const char *)&buf);
    if (link(v151, (const char *)&buf))
    {
      v96 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessHLinks", 1010, 72, v96, "link %s ->%s", v97, v98, (char)&buf);
      goto LABEL_123;
    }
    v101 = 1;
    v102 = 3;
LABEL_124:
    if (*(_DWORD *)(v86 + 2300) != v102)
    {
      *(_DWORD *)(v86 + 2300) = v102;
      v103 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v11 + 1040);
      if (v103)
      {
        if (v102 == -1)
          v104 = 22;
        else
          v104 = 21;
        v103(*(_QWORD *)(v11 + 1032), v104, v86, v86 + 2272);
      }
    }
    entryRelease(v86, v89, v90, v91, v92, v93, v94, v95);
    *(_QWORD *)(*(_QWORD *)(v11 + 1568) + 8 * v84) = 0;
    v85 &= v101;
    if ((unint64_t)++v84 < *(_QWORD *)(v11 + 1560))
      continue;
    break;
  }
  *(_QWORD *)(v11 + 1560) = 0;
  if (!v85)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1550, 72, 0, "process hlinks", v45, v46, v139);
    v142 = 0;
  }
LABEL_135:
  v105 = *(_QWORD *)(v11 + 1584);
  if (!v105)
  {
    *(_QWORD *)(v11 + 1584) = 0;
    v119 = v11 + 1312;
    goto LABEL_147;
  }
  v106 = v105 - 1;
  v107 = 1;
  while (2)
  {
    v108 = *(const char **)(*(_QWORD *)(v11 + 1592) + 8 * v106);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, v108) & 0x80000000) != 0)
    {
      v117 = 983;
      v118 = "invalid 'D' PAT";
    }
    else
    {
      if ((applyEntryAttributes(v11, (uint64_t)v108) & 0x80000000) == 0)
      {
        v116 = 1;
        goto LABEL_143;
      }
      v117 = 984;
      v118 = "applyEntryAttributes failed";
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessDirs", v117, 72, 0, v118, v109, v110, v139);
    v116 = 0;
LABEL_143:
    entryRelease((uint64_t)v108, v111, v112, v113, v114, v115, v109, v110);
    *(_QWORD *)(*(_QWORD *)(v11 + 1592) + 8 * v106) = 0;
    v107 &= v116;
    if (--v106 != -1)
      continue;
    break;
  }
  *(_QWORD *)(v11 + 1584) = 0;
  v119 = v11 + 1312;
  if (!v107)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1553, 72, 0, "process dirs", v45, v46, v139);
    v142 = 0;
  }
LABEL_147:
  v120 = atomic_load((unsigned int *)(v11 + 1604));
  v121 = (FILE **)MEMORY[0x24BDAC8D8];
  if (v120)
  {
    v122 = atomic_load((unsigned int *)(v11 + 1604));
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1556, 72, 0, "%u entries failed to extract", v45, v46, v122);
    v123 = 0;
  }
  else
  {
    v123 = v142 != 0;
    if (v142 && v140 >> 62)
    {
      v124 = getRealTime() - *(double *)(v11 + 1656);
      v123 = 1;
      fwrite("Extract archive\n", 0x10uLL, 1uLL, *v121);
      fprintf(*v121, "%12u worker threads\n", *(_DWORD *)(v11 + 1060));
      fprintf(*v121, "%12u directories\n", *(_DWORD *)(v11 + 1672));
      fprintf(*v121, "%12u regular files\n", *(_DWORD *)(v11 + 1668));
      fprintf(*v121, "%12u symbolic links\n", *(_DWORD *)(v11 + 1676));
      fprintf(*v121, "%12u entries\n", *(_DWORD *)(v11 + 1664));
      fprintf(*v121, "%12.2f time (s)\n", v124);
    }
  }
  for (j = 0; j != 3; ++j)
  {
    v126 = v119 + 80 * j;
    v128 = *(_QWORD *)(v126 + 64);
    v127 = (unint64_t *)(v126 + 64);
    if (v128)
    {
      v129 = 0;
      v130 = (uint64_t *)(v145 + 80 * j + 72);
      do
      {
        v131 = *v130;
        v132 = *(const char **)(*v130 + 32 * v129 + 8);
        if (v132)
        {
          do
          {
            fprintf(*v121, "pending %s\n", v132);
            v132 = *(const char **)&v132[8 * j + 2336];
          }
          while (v132);
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterFree", 485, 72, 0, "cluster has pending entries %d/%llu", v133, v134, j);
          while (1)
          {
            v131 = *v130;
            v135 = *v130 + 32 * v129;
            v138 = *(_QWORD *)(v135 + 8);
            v137 = (_QWORD *)(v135 + 8);
            v136 = v138;
            if (!v138)
              break;
            *v137 = *(_QWORD *)(v136 + 8 * v129 + 2336);
            entryRelease(v136, v40, v41, v42, v43, v44, v45, v46);
          }
        }
        entryRelease(*(_QWORD *)(v131 + 32 * v129++), v40, v41, v42, v43, v44, v45, v46);
      }
      while (v129 < *v127);
    }
    v119 = v11 + 1312;
    pthread_mutex_destroy((pthread_mutex_t *)(v145 + 80 * j));
    free(*(void **)(v145 + 80 * j + 72));
  }
  free(*(void **)(v11 + 1568));
  free(*(void **)(v11 + 1624));
  memset_s((void *)(v11 + 1616), 0x10uLL, 0, 0x10uLL);
  free(*(void **)(v11 + 1304));
  free(*(void **)(v11 + 1592));
  free((void *)v11);
  return (v123 - 1);
}

uint64_t extractStreamWriteHeader(uint64_t a1, AAHeader header, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  const char *v10;
  __int16 v11;
  uint64_t result;
  AAFieldKey v15;
  uint32_t KeyIndex;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  AAFieldKey v21;
  uint32_t v22;
  uint64_t (*v23)(_QWORD, uint64_t, char *, AAHeader);
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  int v31;
  const char *v32;
  __int16 v33;
  char *v34;
  char *v35;
  uint64_t (*v36)(_QWORD, uint64_t, char *, char *);
  uint64_t (*v37)(_QWORD, uint64_t, char *, char *);
  AAFieldKey v38;
  uint32_t v39;
  size_t v40;
  size_t v41;
  void **v42;
  void *v43;
  void *v44;
  AAFieldKey v45;
  uint32_t v46;
  size_t v47;
  size_t v48;
  void **v49;
  void *v50;
  void *v51;
  AAFieldKey v52;
  uint32_t v53;
  size_t v54;
  size_t v55;
  void **v56;
  void *v57;
  void *v58;
  AAFieldKey v59;
  uint32_t v60;
  unsigned int FieldUInt;
  int v62;
  AAFieldKey v63;
  uint32_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  int v71;
  AAFieldKey v72;
  uint32_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  AAFieldKey v78;
  AAFieldKey v79;
  uint32_t v80;
  uint64_t v81;
  uint64_t v82;
  int updated;
  BOOL v84;
  AAFieldKey v85;
  uint32_t v86;
  AAFieldKey v87;
  uint32_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t offset;
  uint64_t size;
  uint64_t value;
  size_t length[128];
  char __s[1024];
  uint64_t v104;

  v104 = *MEMORY[0x24BDAC8D0];
  size = 0;
  value = -1;
  offset = 0;
  v9 = *(_QWORD *)(a1 + 1024);
  *(_DWORD *)(a1 + 1608) = 0;
  if (*(_QWORD *)(a1 + 1632) || *(_QWORD *)(a1 + 1640))
  {
    v10 = "invalid extract state";
    v11 = 1245;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", v11, 72, 0, v10, a7, a8, v95);
LABEL_5:
    extractStreamStateFail(a1);
    return 0xFFFFFFFFLL;
  }
  v15.ikey = 5265748;
  KeyIndex = AAHeaderGetKeyIndex(header, v15);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    v32 = "AA entry missing TYP field";
    v33 = 1249;
LABEL_24:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", v33, 72, v32, v17, v18, v19, v95);
    goto LABEL_25;
  }
  if (value - 66 > 0x11 || ((1 << (value - 66)) & 0x24457) == 0)
  {
    result = 0;
    *(_DWORD *)(a1 + 1608) = 1;
    return result;
  }
  length[0] = 0;
  v21.ikey = 5521744;
  v22 = AAHeaderGetKeyIndex(header, v21);
  if ((v22 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v22, 0x400uLL, __s, length) >= 2)
  {
    v32 = "YAA entry missing/invalid PAT field";
    v33 = 1274;
    goto LABEL_24;
  }
  v23 = *(uint64_t (**)(_QWORD, uint64_t, char *, AAHeader))(a1 + 1040);
  if (v23)
  {
    v24 = v23(*(_QWORD *)(a1 + 1032), 20, __s, header);
    if (v24 < 0)
    {
      v10 = "user cancelled";
      v11 = 1284;
      goto LABEL_4;
    }
    if (!v24)
    {
      v25 = (*(uint64_t (**)(_QWORD, uint64_t, char *, size_t *))(a1 + 1040))(*(_QWORD *)(a1 + 1032), 27, __s, length);
      if (v25 < 0)
      {
        v10 = "user cancelled";
        v11 = 1289;
        goto LABEL_4;
      }
      if (v25)
        __strlcpy_chk();
      goto LABEL_20;
    }
LABEL_25:
    result = 0;
    *(_DWORD *)(a1 + 1608) = 1;
    return result;
  }
LABEL_20:
  v26 = value;
  if (strlen(__s) >= 0x400)
  {
    v29 = "path too long";
    v30 = 198;
    v31 = 0;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryCreate", v30, 72, v31, v29, v27, v28, v95);
    *(_QWORD *)(a1 + 1632) = 0;
    v10 = "entry creation";
    v11 = 1295;
    goto LABEL_4;
  }
  v34 = (char *)malloc(0x938uLL);
  if (!v34)
  {
    v31 = *__error();
    v29 = "malloc";
    v30 = 200;
    goto LABEL_34;
  }
  v35 = v34;
  memset_s(v34, 0x938uLL, 0, 0x938uLL);
  __memcpy_chk();
  *((_QWORD *)v35 + 256) = v26;
  *((_DWORD *)v35 + 574) = -1;
  *((_QWORD *)v35 + 289) = -1;
  *((_QWORD *)v35 + 290) = -1;
  *((_QWORD *)v35 + 291) = -1;
  *((_QWORD *)v35 + 273) = -1;
  *((_QWORD *)v35 + 274) = -1;
  atomic_store(1u, (unsigned int *)v35 + 576);
  *(_QWORD *)(a1 + 1632) = v35;
  ++*(_DWORD *)(a1 + 1664);
  switch(value)
  {
    case 'L':
      ++*(_DWORD *)(a1 + 1676);
      break;
    case 'F':
      ++*(_DWORD *)(a1 + 1668);
      break;
    case 'D':
      ++*(_DWORD *)(a1 + 1672);
      break;
  }
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 1616, header) & 0x80000000) != 0)
  {
    v10 = "Eerror getting blobs from header";
    v11 = 1307;
    goto LABEL_4;
  }
  if ((aaEntryAttributesInitWithHeader(v35 + 2056, v35 + 2128, 0, header) & 0x80000000) != 0)
  {
    v10 = "getting attributes from header";
    v11 = 1310;
    goto LABEL_4;
  }
  v36 = *(uint64_t (**)(_QWORD, uint64_t, char *, char *))(a1 + 1040);
  if (v36)
  {
    if ((v36(*(_QWORD *)(a1 + 1032), 23, v35, v35 + 2056) & 0x80000000) != 0)
    {
      v10 = "message callback cancelled operations";
      v11 = 1314;
      goto LABEL_4;
    }
    v37 = *(uint64_t (**)(_QWORD, uint64_t, char *, char *))(a1 + 1040);
    if (v37
      && (*(_BYTE *)(a1 + 1030) & 0x10) != 0
      && (v37(*(_QWORD *)(a1 + 1032), 26, v35, v35 + 2128) & 0x80000000) != 0)
    {
      v10 = "message callback cancelled operations";
      v11 = 1320;
      goto LABEL_4;
    }
  }
  if ((v35[2056] & 4) != 0 && (v35[2068] & 0x20) != 0 && (v35[2128] & 1) != 0 && *((_DWORD *)v35 + 534) == -1)
  {
    v10 = "disable AFSC by clearing UF_COMPRESSED";
    v11 = 1325;
    goto LABEL_4;
  }
  v38.ikey = 4997953;
  v39 = AAHeaderGetKeyIndex(header, v38);
  if ((v39 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v39, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_166:
      v10 = "ACL blob allocation";
      v11 = 1331;
      goto LABEL_4;
    }
    v40 = *((_QWORD *)v35 + 279);
    if (v40 < size)
    {
      do
      {
        while (!v40)
        {
          v40 = 0x4000;
          if (size <= 0x4000)
          {
            v42 = (void **)(v35 + 2240);
            v40 = 0x4000;
            goto LABEL_66;
          }
        }
        v41 = v40 >> 1;
        if ((v40 & (v40 >> 1)) != 0)
          v41 = v40 & (v40 >> 1);
        v40 += v41;
      }
      while (v40 < size);
      v42 = (void **)(v35 + 2240);
      if (v40 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_165;
      }
LABEL_66:
      v43 = *v42;
      v44 = realloc(*v42, v40);
      if (v44)
      {
        *((_QWORD *)v35 + 280) = v44;
        *((_QWORD *)v35 + 279) = v40;
        goto LABEL_68;
      }
      free(v43);
LABEL_165:
      *v42 = 0;
      *((_QWORD *)v35 + 278) = 0;
      *((_QWORD *)v35 + 279) = 0;
      goto LABEL_166;
    }
  }
LABEL_68:
  v45.ikey = 5521752;
  v46 = AAHeaderGetKeyIndex(header, v45);
  if ((v46 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v46, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_169:
      v10 = "XAT blob allocation";
      v11 = 1335;
      goto LABEL_4;
    }
    v47 = *((_QWORD *)v35 + 276);
    if (v47 < size)
    {
      do
      {
        while (!v47)
        {
          v47 = 0x4000;
          if (size <= 0x4000)
          {
            v49 = (void **)(v35 + 2216);
            v47 = 0x4000;
            goto LABEL_81;
          }
        }
        v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0)
          v48 = v47 & (v47 >> 1);
        v47 += v48;
      }
      while (v47 < size);
      v49 = (void **)(v35 + 2216);
      if (v47 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_168;
      }
LABEL_81:
      v50 = *v49;
      v51 = realloc(*v49, v47);
      if (v51)
      {
        *((_QWORD *)v35 + 277) = v51;
        *((_QWORD *)v35 + 276) = v47;
        goto LABEL_83;
      }
      free(v50);
LABEL_168:
      *v49 = 0;
      *((_QWORD *)v35 + 275) = 0;
      *((_QWORD *)v35 + 276) = 0;
      goto LABEL_169;
    }
  }
LABEL_83:
  v52.ikey = 4408665;
  v53 = AAHeaderGetKeyIndex(header, v52);
  if ((v53 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v53, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_172:
      v10 = "YEC blob allocation";
      v11 = 1339;
      goto LABEL_4;
    }
    v54 = *((_QWORD *)v35 + 282);
    if (v54 < size)
    {
      do
      {
        while (!v54)
        {
          v54 = 0x4000;
          if (size <= 0x4000)
          {
            v56 = (void **)(v35 + 2264);
            v54 = 0x4000;
            goto LABEL_97;
          }
        }
        v55 = v54 >> 1;
        if ((v54 & (v54 >> 1)) != 0)
          v55 = v54 & (v54 >> 1);
        v54 += v55;
      }
      while (v54 < size);
      v56 = (void **)(v35 + 2264);
      if (v54 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_171;
      }
LABEL_97:
      v57 = *v56;
      v58 = realloc(*v56, v54);
      if (v58)
      {
        *((_QWORD *)v35 + 283) = v58;
        *((_QWORD *)v35 + 282) = v54;
        goto LABEL_99;
      }
      free(v57);
LABEL_171:
      *v56 = 0;
      *((_QWORD *)v35 + 281) = 0;
      *((_QWORD *)v35 + 282) = 0;
      goto LABEL_172;
    }
  }
LABEL_99:
  v98 = 0;
  *((_QWORD *)v35 + 284) = -1;
  *((_QWORD *)v35 + 285) = -1;
  v59.ikey = 5784649;
  v60 = AAHeaderGetKeyIndex(header, v59);
  if ((v60 & 0x80000000) == 0)
  {
    FieldUInt = AAHeaderGetFieldUInt(header, v60, &v98);
    v62 = FieldUInt <= 1 ? 1 : FieldUInt;
    if (v62 >= 1)
      *((_QWORD *)v35 + 284) = v98;
  }
  v63.ikey = 5915721;
  v64 = AAHeaderGetKeyIndex(header, v63);
  if ((v64 & 0x80000000) == 0)
  {
    v70 = AAHeaderGetFieldUInt(header, v64, &v98);
    v71 = v70 <= 1 ? 1 : v70;
    if (v71 >= 1)
      *((_QWORD *)v35 + 285) = v98;
  }
  if (value == 70)
  {
    *((_QWORD *)v35 + 274) = -1;
    v72.ikey = 5521732;
    v73 = AAHeaderGetKeyIndex(header, v72);
    if ((v73 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v73, &size, &offset) <= 1)
      *((_QWORD *)v35 + 274) = size;
    v74 = 0;
    v75 = 0;
    v76 = v9 & 0x10;
    v77 = 0;
    do
    {
      if (v74 == 2 && v76)
        break;
      v78.ikey = 4410451;
      if (v74 != 2)
        v78.ikey = 4144959;
      if ((_DWORD)v74 == 1)
        v78.ikey = 4410435;
      if ((_DWORD)v74)
        v79 = v78;
      else
        v79.ikey = 4410440;
      v97 = -1;
      v80 = AAHeaderGetKeyIndex(header, v79);
      if ((v80 & 0x80000000) == 0 && AAHeaderGetFieldUInt(header, v80, &v97) <= 1)
      {
        v81 = v97;
        *(_QWORD *)&v35[8 * v74 + 2312] = v97;
        v96 = 0;
        if (*((_QWORD *)v35 + 274) == -1)
          v82 = 0;
        else
          v82 = (uint64_t)v35;
        updated = clusterEntryUpdateDAT(a1, v74, v81, v82, &v96);
        if (updated < 0)
        {
          v10 = "cluster entry query";
          v11 = 1371;
          goto LABEL_4;
        }
        if (updated)
          v77 = 1;
        if (v96)
          v84 = updated == 0;
        else
          v84 = 0;
        if (v84)
          v75 = 1;
      }
      ++v74;
    }
    while (v74 != 3);
    if (!v77 && v75 && *((_QWORD *)v35 + 274) != -1)
      *((_QWORD *)v35 + 274) = -1;
  }
  else if ((value & 0xFFFFFFFFFFFFFFFBLL) == 0x48)
  {
    v97 = 0;
    v85.ikey = 4935244;
    v86 = AAHeaderGetKeyIndex(header, v85);
    if ((v86 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v86, 0x400uLL, v35 + 1024, &v97) > 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", 1389, 72, 0, "YAA link entry has no LNK field: %s", a7, a8, (char)__s);
      goto LABEL_5;
    }
  }
  else if ((value & 0xFFFFFFFFFFFFFFFELL) == 0x42)
  {
    v87.ikey = 5653828;
    v88 = AAHeaderGetKeyIndex(header, v87);
    if ((v88 & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, v88, (uint64_t *)v35 + 273) >= 2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", 1394, 72, 0, "YAA device entry has no DEV field: %s", a7, a8, (char)__s);
      goto LABEL_5;
    }
  }
  *(_DWORD *)(a1 + 1648) = 0;
  v89 = *(unsigned int *)(a1 + 1616);
  if ((_DWORD)v89 && (v90 = *(_QWORD *)(a1 + 1624), !*(_QWORD *)(v90 + 8)))
  {
    v92 = (uint64_t *)(v90 + 32);
    v93 = 1;
    do
    {
      v91 = v93;
      if (v89 == v93)
        break;
      v94 = *v92;
      v92 += 3;
      ++v93;
    }
    while (!v94);
    *(_DWORD *)(a1 + 1648) = v91;
  }
  else
  {
    v91 = 0;
  }
  if (v91 >= v89 && (extractStreamEntryEnd(a1, v65, v66, v67, v68, v69, a7, a8) & 0x80000000) != 0)
  {
    v10 = "end entry";
    v11 = 1404;
    goto LABEL_4;
  }
  return 0;
}

uint64_t extractStreamWriteBlob(uint64_t a1, size_t a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD *v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  _QWORD *v22;
  rsize_t v23;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _QWORD *v29;
  size_t v30;
  void **v31;
  uint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  size_t v35;
  void **v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  size_t v40;
  void **v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  void *v48;
  void *v49;
  uint64_t v50;
  BOOL v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  size_t v60;
  void **v61;
  void **v62;
  void **v63;

  if (atomic_load((unsigned int *)(a1 + 1600)))
    return 0xFFFFFFFFLL;
  result = 0;
  if (__smax && !*(_DWORD *)(a1 + 1608))
  {
    v12 = *(_QWORD **)(a1 + 1632);
    v13 = *(_QWORD *)(a1 + 1640);
    if (*(_OWORD *)(a1 + 1632) == 0)
    {
      v14 = "no active entry or active thread";
      v15 = 1423;
LABEL_8:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteBlob", v15, 72, 0, v14, a7, a8, v60);
      extractStreamStateFail(a1);
      return 0xFFFFFFFFLL;
    }
    v16 = *(_DWORD *)(a1 + 1648);
    if (v16 >= *(_DWORD *)(a1 + 1616))
    {
      v19 = "invalid blob reference";
      v20 = 1424;
      goto LABEL_13;
    }
    v17 = *(_QWORD *)(a1 + 1624);
    v18 = *(_DWORD *)(v17 + 24 * v16);
    if (((v18 ^ a2) & 0xFFFFFF) != 0)
    {
      v19 = "inconsistent blob key";
      v20 = 1428;
LABEL_13:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteBlob", v20, 72, 0, v19, a7, a8, v60);
      return 0xFFFFFFFFLL;
    }
    v21 = v17 + 24 * v16;
    v23 = *(_QWORD *)(v21 + 8);
    v22 = (_QWORD *)(v21 + 8);
    if (v23 < __smax)
    {
      v19 = "too many blob bytes received";
      v20 = 1429;
      goto LABEL_13;
    }
    v25 = *(_QWORD *)&v18 & 0xFFFFFFLL;
    if ((*(_QWORD *)&v18 & 0xFFFFFFuLL) <= 0x544143)
    {
      if (v25 != 4408665)
      {
        if (v25 == 4997953)
        {
          if (v12)
          {
            v26 = v12[278];
            v27 = __CFADD__(v26, __smax);
            v28 = v26 + __smax;
            if (v27 || (v28 & 0x8000000000000000) != 0)
              goto LABEL_112;
            v29 = v12 + 278;
            a2 = v12[279];
            if (a2 < v28)
            {
              do
              {
                while (!a2)
                {
                  a2 = 0x4000;
                  if (v28 <= 0x4000)
                  {
                    v31 = (void **)(v12 + 280);
                    a2 = 0x4000;
                    goto LABEL_68;
                  }
                }
                v30 = a2 >> 1;
                if ((a2 & (a2 >> 1)) != 0)
                  v30 = a2 & (a2 >> 1);
                a2 += v30;
              }
              while (a2 < v28);
              v31 = (void **)(v12 + 280);
              if (a2 >= 0x2000000001)
              {
                v61 = (void **)(v12 + 280);
                *__error() = 12;
                goto LABEL_111;
              }
LABEL_68:
              v60 = a2;
              v61 = v31;
              v42 = *v31;
              v43 = realloc(*v31, a2);
              if (v43)
              {
                v12[280] = v43;
                v12[279] = v60;
                goto LABEL_70;
              }
              free(v42);
LABEL_111:
              *v61 = 0;
              *v29 = 0;
              v12[279] = 0;
              goto LABEL_112;
            }
LABEL_70:
            v44 = v12[280];
            if (__src)
            {
              memcpy((void *)(v44 + *v29), __src, __smax);
            }
            else if (v44)
            {
              memset_s((void *)(v44 + *v29), __smax, 0, __smax);
            }
            *v29 += __smax;
            if ((__smax & 0x8000000000000000) != 0)
            {
LABEL_112:
              v14 = "too many blob bytes received";
              v15 = 1438;
              goto LABEL_8;
            }
          }
          if (v13 && (extractThreadSendCommand(v13, 65, __smax, __src) & 0x80000000) != 0)
          {
            v14 = "sending blob";
            v15 = 1439;
            goto LABEL_8;
          }
        }
        goto LABEL_97;
      }
      if (!v12)
        goto LABEL_96;
      v37 = v12[281];
      v27 = __CFADD__(v37, __smax);
      v38 = v37 + __smax;
      if (!v27 && (v38 & 0x8000000000000000) == 0)
      {
        v39 = v12 + 281;
        a2 = v12[282];
        if (a2 < v38)
        {
          do
          {
            while (!a2)
            {
              a2 = 0x4000;
              if (v38 <= 0x4000)
              {
                v41 = (void **)(v12 + 283);
                a2 = 0x4000;
                goto LABEL_76;
              }
            }
            v40 = a2 >> 1;
            if ((a2 & (a2 >> 1)) != 0)
              v40 = a2 & (a2 >> 1);
            a2 += v40;
          }
          while (a2 < v38);
          v41 = (void **)(v12 + 283);
          if (a2 >= 0x2000000001)
          {
            v63 = (void **)(v12 + 283);
            *__error() = 12;
            goto LABEL_117;
          }
LABEL_76:
          v60 = a2;
          v63 = v41;
          v48 = *v41;
          v49 = realloc(*v41, a2);
          if (v49)
          {
            v12[283] = v49;
            v12[282] = v60;
            goto LABEL_78;
          }
          free(v48);
LABEL_117:
          *v63 = 0;
          *v39 = 0;
          v12[282] = 0;
          goto LABEL_118;
        }
LABEL_78:
        v50 = v12[283];
        if (__src)
        {
          memcpy((void *)(v50 + *v39), __src, __smax);
        }
        else if (v50)
        {
          memset_s((void *)(v50 + *v39), __smax, 0, __smax);
        }
        *v39 += __smax;
        if ((__smax & 0x8000000000000000) == 0)
        {
LABEL_96:
          if (v13 && (extractThreadSendCommand(v13, 89, __smax, __src) & 0x80000000) != 0)
          {
            v14 = "sending blob";
            v15 = 1444;
            goto LABEL_8;
          }
          goto LABEL_97;
        }
      }
LABEL_118:
      v14 = "too many blob bytes received";
      v15 = 1443;
      goto LABEL_8;
    }
    if (v25 == 5521732)
    {
      if (!v12 || v12[274] != -1)
      {
        if (!v13)
        {
          if ((extractStreamSendEntryToExtractThread(a1) & 0x80000000) != 0)
          {
            v14 = "send entry to thread";
            v15 = 1453;
            goto LABEL_8;
          }
          v13 = *(_QWORD *)(a1 + 1640);
        }
        if ((extractThreadSendCommand(v13, 68, __smax, __src) & 0x80000000) != 0)
        {
          v14 = "sending DAT blob";
          v15 = 1457;
          goto LABEL_8;
        }
      }
      goto LABEL_97;
    }
    if (v25 != 5521752)
    {
LABEL_97:
      v51 = *v22 == __smax;
      *v22 -= __smax;
      if (!v51)
        return 0;
      v52 = *(_DWORD *)(a1 + 1648);
      v53 = (v52 + 1);
      *(_DWORD *)(a1 + 1648) = v53;
      v54 = *(unsigned int *)(a1 + 1616);
      if (v53 < v54)
      {
        v55 = *(_QWORD *)(a1 + 1624);
        if (!*(_QWORD *)(v55 + 24 * v53 + 8))
        {
          v56 = (uint64_t *)(v55 + 24 * v53 + 32);
          v57 = ~v53 + v54;
          v58 = v52 + 2;
          do
          {
            LODWORD(v53) = v58;
            if (!v57)
              break;
            v59 = *v56;
            v56 += 3;
            --v57;
            ++v58;
          }
          while (!v59);
          *(_DWORD *)(a1 + 1648) = v53;
        }
      }
      if (v53 < v54
        || (extractStreamEntryEnd(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) == 0)
      {
        return 0;
      }
      v19 = "end entry failed";
      v20 = 1472;
      goto LABEL_13;
    }
    if (!v12)
      goto LABEL_90;
    v32 = v12[275];
    v27 = __CFADD__(v32, __smax);
    v33 = v32 + __smax;
    if (!v27 && (v33 & 0x8000000000000000) == 0)
    {
      v34 = v12 + 275;
      a2 = v12[276];
      if (a2 < v33)
      {
        do
        {
          while (!a2)
          {
            a2 = 0x4000;
            if (v33 <= 0x4000)
            {
              v36 = (void **)(v12 + 277);
              a2 = 0x4000;
              goto LABEL_72;
            }
          }
          v35 = a2 >> 1;
          if ((a2 & (a2 >> 1)) != 0)
            v35 = a2 & (a2 >> 1);
          a2 += v35;
        }
        while (a2 < v33);
        v36 = (void **)(v12 + 277);
        if (a2 >= 0x2000000001)
        {
          v62 = (void **)(v12 + 277);
          *__error() = 12;
          goto LABEL_114;
        }
LABEL_72:
        v60 = a2;
        v62 = v36;
        v45 = *v36;
        v46 = realloc(*v36, a2);
        if (v46)
        {
          v12[277] = v46;
          v12[276] = v60;
          goto LABEL_74;
        }
        free(v45);
LABEL_114:
        *v62 = 0;
        *v34 = 0;
        v12[276] = 0;
        goto LABEL_115;
      }
LABEL_74:
      v47 = v12[277];
      if (__src)
      {
        memcpy((void *)(v47 + *v34), __src, __smax);
      }
      else if (v47)
      {
        memset_s((void *)(v47 + *v34), __smax, 0, __smax);
      }
      *v34 += __smax;
      if ((__smax & 0x8000000000000000) == 0)
      {
LABEL_90:
        if (v13 && (extractThreadSendCommand(v13, 88, __smax, __src) & 0x80000000) != 0)
        {
          v14 = "sending blob";
          v15 = 1434;
          goto LABEL_8;
        }
        goto LABEL_97;
      }
    }
LABEL_115:
    v14 = "too many blob bytes received";
    v15 = 1433;
    goto LABEL_8;
  }
  return result;
}

void extractStreamAbort(uint64_t a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 1600);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      extractStreamStateFail(a1);
      return;
    }
  }
  __clrex();
}

void entryRelease(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  char v15;
  char v16;

  if (a1)
  {
    v9 = (unsigned int *)(a1 + 2304);
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
    {
      v12 = *(_DWORD *)(a1 + 2300);
      if (v12 != -1 && v12 != 3)
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 223, 72, 0, "invalid entry final state %d: %s", a7, a8, *(_DWORD *)(a1 + 2300));
      if (atomic_load(v9))
      {
        v15 = atomic_load((unsigned int *)(a1 + 2304));
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 224, 72, 0, "invalid entry final ref count %u: %s", a7, a8, v15);
      }
      if ((*(_DWORD *)(a1 + 2296) & 0x80000000) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 226, 72, 0, "invalid entry final fd", a7, a8, v16);
        close(*(_DWORD *)(a1 + 2296));
      }
      AAByteStreamClose(*(AAByteStream *)(a1 + 2288));
      free(*(void **)(a1 + 2216));
      memset_s((void *)(a1 + 2200), 0x18uLL, 0, 0x18uLL);
      free(*(void **)(a1 + 2240));
      memset_s((void *)(a1 + 2224), 0x18uLL, 0, 0x18uLL);
      free(*(void **)(a1 + 2264));
      memset_s((void *)(a1 + 2248), 0x18uLL, 0, 0x18uLL);
      free((void *)a1);
    }
  }
}

uint64_t extractThreadFailEntry(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  void (*v4)(_QWORD, uint64_t, uint64_t, uint64_t);
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v1 = a1[21];
  if (!v1)
    return 0;
  a1[21] = 0;
  v3 = *a1;
  if (*(_DWORD *)(v1 + 2300) != -1)
  {
    *(_DWORD *)(v1 + 2300) = -1;
    v4 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v3 + 1040);
    if (v4)
    {
      v4(*(_QWORD *)(v3 + 1032), 22, v1, v1 + 2272);
      v3 = *a1;
    }
  }
  v5 = (unsigned int *)(v3 + 1604);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  AAByteStreamClose(*(AAByteStream *)(v1 + 2288));
  *(_QWORD *)(v1 + 2288) = 0;
  if ((retireThreadEnqueue(*a1 + 1200, v1) & 0x80000000) == 0)
    return 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadFailEntry", 736, 72, 0, "sending entry to retire thread", v7, v8, v10);
  return 0xFFFFFFFFLL;
}

uint64_t applyEntryAttributes(uint64_t a1, uint64_t a2)
{
  AAEntryACLBlob v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  rsize_t v11;
  rsize_t v12;
  rsize_t v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  void (*v21)(_QWORD, uint64_t, uint64_t, unint64_t *);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  char v40[4];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v4 = AAEntryACLBlobCreate();
  v10 = (unint64_t *)AAEntryXATBlobCreate();
  v11 = *(_QWORD *)(a2 + 2224);
  if (v11 && (aaEntryACLBlobInitWithEncodedData(v4, *(char **)(a2 + 2240), v11, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    v19 = "invalid ACL blob";
    v20 = 354;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", v20, 72, 0, v19, v8, v9, v39);
    v30 = 0;
    v16 = 0;
    goto LABEL_32;
  }
  v12 = *(_QWORD *)(a2 + 2200);
  if (v12 && (aaEntryXATBlobInitWithEncodedData(v10, *(char **)(a2 + 2216), v12, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    v19 = "invalid XAT blob";
    v20 = 357;
    goto LABEL_22;
  }
  v13 = *(_QWORD *)(a2 + 2248);
  if (v13)
  {
    v16 = AAEntryYECBlobCreateWithEncodedData(*(void **)(a2 + 2264), v13);
    if (!v16)
    {
      v17 = "invalid YEC blob";
      v18 = 361;
LABEL_25:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", v18, 72, 0, v17, v14, v15, v39);
LABEL_26:
      v30 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    v16 = 0;
  }
  v21 = *(void (**)(_QWORD, uint64_t, uint64_t, unint64_t *))(a1 + 1040);
  if (v21)
  {
    v21(*(_QWORD *)(a1 + 1032), 24, a2, v10);
    (*(void (**)(_QWORD, uint64_t, uint64_t, AAEntryACLBlob))(a1 + 1040))(*(_QWORD *)(a1 + 1032), 25, a2, v4);
  }
  if (v16)
  {
    *(_DWORD *)v40 = 0;
    if ((AAEntryYECBlobApplyToPath((uint64_t)v16, (char *)a1, (const char *)a2, (int *)v40, *(_QWORD *)(a1 + 1024), *(_DWORD *)(a1 + 1060)) & 0x80000000) != 0)
    {
      v39 = v40[0];
      v17 = "corrupted file data, ECC failed 0x%08x: %s";
      v18 = 377;
      goto LABEL_25;
    }
    if (*(_DWORD *)v40)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 378, 72, "ECC applied 0x%08x: %s", v22, v14, v15, v40[0]);
  }
  if ((concatExtractPath(v40, 0x800uLL, (char *)a1, (const char *)a2) & 0x80000000) != 0)
  {
    v39 = a1;
    v17 = "invalid path: %s/%s";
    v18 = 391;
    goto LABEL_25;
  }
  v26 = *(unsigned int *)(a2 + 2296);
  v27 = v26;
  if ((v26 & 0x80000000) != 0)
  {
    v27 = open(v40, 0x200000);
    if ((v27 & 0x80000000) != 0)
    {
      v36 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 400, 72, v36, "open: %s", v37, v38, (char)v40);
      goto LABEL_26;
    }
  }
  if ((aaEntryXATBlobApplyToFD(v10, v27, *(_QWORD *)(a1 + 1024), v23, v24, v25, v14, v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 405, 72, 0, "applying XAT: %s", v28, v29, a2);
    v30 = 0;
  }
  else
  {
    v30 = 1;
  }
  if ((aaEntryACLBlobApplyToFD((unint64_t *)v4, v27, *(_QWORD *)(a1 + 1024)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 406, 72, 0, "applying ACL: %s", v31, v32, a2);
    v30 = 0;
  }
  if ((aaEntryAttributesApplyToFD((char *)(a2 + 2056), v27, *(_QWORD *)(a1 + 1024)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 407, 72, 0, "applying ATTR: %s", v33, v34, a2);
    v30 = 0;
    if ((v26 & 0x80000000) == 0)
      goto LABEL_32;
  }
  else if ((v26 & 0x80000000) == 0)
  {
    goto LABEL_32;
  }
  close(v27);
LABEL_32:
  AAEntryXATBlobDestroy((AAEntryXATBlob)v10);
  AAEntryACLBlobDestroy(v4);
  AAEntryYECBlobDestroy(v16);
  if (v30)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t retireThreadEnqueue(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  int v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  v4 = (pthread_mutex_t *)(a1 + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadEnqueue", 597, 72, *v5, "pthread_mutex_lock", v6, v7, v21);
    return 0xFFFFFFFFLL;
  }
  v10 = *(_QWORD *)(a1 + 88);
  v9 = *(_QWORD *)(a1 + 96);
  v11 = v9 - v10;
  if (v9 == v10)
  {
    v9 = 0;
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 96) = 0;
  }
  else if (v10 >= 0x40)
  {
    memmove(*(void **)(a1 + 104), (const void *)(*(_QWORD *)(a1 + 104) + 8 * v10), 8 * v11);
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 96) = v11;
    v9 = v11;
  }
  v12 = *(_QWORD *)(a1 + 80);
  if (v9 < v12)
    goto LABEL_14;
  v13 = 2 * v12;
  if (!v12)
    v13 = 256;
  *(_QWORD *)(a1 + 80) = v13;
  if ((unint64_t)(8 * v13) < 0x2000000001)
  {
    v14 = *(void **)(a1 + 104);
    v15 = realloc(v14, 8 * v13);
    if (!v15)
    {
      free(v14);
      goto LABEL_18;
    }
    *(_QWORD *)(a1 + 104) = v15;
    v9 = *(_QWORD *)(a1 + 96);
    v12 = *(_QWORD *)(a1 + 80);
LABEL_14:
    if (v9 < v12)
    {
      v16 = *(_QWORD *)(a1 + 104);
      *(_QWORD *)(a1 + 96) = v9 + 1;
      *(_QWORD *)(v16 + 8 * v9) = a2;
    }
    v17 = 1;
    goto LABEL_19;
  }
  *__error() = 12;
LABEL_18:
  v17 = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
LABEL_19:
  if (pthread_mutex_unlock(v4))
  {
    v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadEnqueue", 623, 72, *v18, "pthread_mutex_unlock", v19, v20, v21);
    v17 = 0;
  }
  if (v17)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void extractStreamStateFail(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  char v18;

  v2 = (_QWORD *)(a1 + 1632);
  v3 = *(_QWORD *)(a1 + 1632);
  if (v3)
  {
    v4 = *(_QWORD *)(a1 + 1632);
    if (*(_DWORD *)(v3 + 2300) != -1)
    {
      *(_DWORD *)(v3 + 2300) = -1;
      v5 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(a1 + 1040);
      v4 = v3;
      if (v5)
      {
        v5(*(_QWORD *)(a1 + 1032), 22, v3, v3 + 2272);
        v4 = *(_QWORD *)(a1 + 1632);
      }
    }
    if ((retireThreadEnqueue(a1 + 1200, v4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamSendEntryToRetireThread", 1163, 72, 0, "retireThreadEnqueue failed", v6, v7, v18);
      entryRelease(v3, v8, v9, v10, v11, v12, v13, v14);
    }
    v15 = (unsigned int *)(a1 + 1604);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  else
  {
    v17 = *(_QWORD *)(a1 + 1640);
    if (v17)
      extractThreadSendCommand(v17, 70, 0, 0);
  }
  *(_DWORD *)(a1 + 1608) = 1;
  *v2 = 0;
  v2[1] = 0;
}

uint64_t extractThreadSendCommand(uint64_t a1, int a2, size_t a3, const void *a4)
{
  uint64_t v7;
  uint64_t v8;
  const char *v10;
  __int16 v11;
  char v12;
  int buf;
  size_t v14;

  buf = a2;
  v14 = a3;
  if (AAByteStreamWrite(*(AAByteStream *)(a1 + 16), &buf, 0xCuLL) == 12)
  {
    if (!a3 || AAByteStreamWrite(*(AAByteStream *)(a1 + 32), a4, a3) == a3)
      return 0;
    v10 = "sending command payload";
    v11 = 713;
  }
  else
  {
    v10 = "sending command";
    v11 = 708;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadSendCommand", v11, 72, 0, v10, v7, v8, v12);
  return 0xFFFFFFFFLL;
}

uint64_t clusterEntryUpdateDAT(uint64_t a1, int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v9;
  pthread_mutex_t *v10;
  int v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  _QWORD *v30;
  void *v31;
  unint64_t v32;
  char *v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  char v38;

  *a5 = 0;
  if (a3 == -1)
    return 0;
  v9 = a1 + 1312;
  v10 = (pthread_mutex_t *)(a1 + 1312 + 80 * a2);
  if (pthread_mutex_lock(v10) < 0)
  {
    v22 = *__error();
    v25 = "pthread_mutex_lock";
    v26 = 514;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterEntryUpdateDAT", v26, 72, v22, v25, v23, v24, v38);
    return 0xFFFFFFFFLL;
  }
  v11 = a2;
  v12 = v9 + 80 * a2;
  v15 = *(_QWORD *)(v12 + 64);
  v13 = (unint64_t *)(v12 + 64);
  v14 = v15;
  if (v15 <= a3)
  {
    v27 = v14;
    do
    {
      if (v27)
        v27 *= 2;
      else
        v27 = 32;
    }
    while (v27 <= a3);
    *v13 = v27;
    v28 = v9 + 80 * a2;
    v31 = *(void **)(v28 + 72);
    v30 = (_QWORD *)(v28 + 72);
    v29 = v31;
    if (32 * v27 < 0x2000000001)
    {
      v16 = (char *)realloc(v29, 32 * v27);
      if (v16)
      {
        *v30 = v16;
        v32 = *v13 - v14;
        if (*v13 > v14)
        {
          v33 = &v16[32 * v14 + 16];
          do
          {
            *((_QWORD *)v33 - 2) = 0;
            *((_QWORD *)v33 - 1) = 0;
            *(_QWORD *)v33 = -1;
            *((_QWORD *)v33 + 1) = -1;
            v33 += 32;
            --v32;
          }
          while (v32);
        }
        goto LABEL_5;
      }
      free(v29);
    }
    else
    {
      *__error() = 12;
    }
    *v30 = 0;
    v34 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterEntryUpdateDAT", 523, 72, *v34, "malloc", v35, v36, v38);
    *v13 = 0;
    v17 = 0xFFFFFFFFLL;
    goto LABEL_27;
  }
  v16 = *(char **)(v9 + 80 * a2 + 72);
LABEL_5:
  v17 = 0;
  v18 = &v16[32 * a3];
  v19 = *(_QWORD *)v18;
  if (a4 && !v19)
  {
    *(_QWORD *)v18 = a4;
    v20 = (unsigned int *)(a4 + 2304);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 + 1, v20));
    v19 = *(_QWORD *)(*(_QWORD *)(v9 + 80 * v11 + 72) + 32 * a3);
    v17 = 1;
  }
  *a5 = v19;
LABEL_27:
  if (pthread_mutex_unlock(v10) < 0)
  {
    v22 = *__error();
    v25 = "pthread_mutex_unlock";
    v26 = 547;
    goto LABEL_29;
  }
  return v17;
}

uint64_t extractStreamEntryEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  _QWORD *v15;
  char v16;

  if (atomic_load((unsigned int *)(a1 + 1600)))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 1608))
    return 0;
  v11 = *(_QWORD *)(a1 + 1632);
  v12 = *(_QWORD *)(a1 + 1640);
  if (*(_OWORD *)(a1 + 1632) == 0)
  {
    v13 = "no active entry or active thread";
    v14 = 1202;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamEntryEnd", v14, 72, 0, v13, a7, a8, v16);
    extractStreamStateFail(a1);
    return 0xFFFFFFFFLL;
  }
  if (v11)
  {
    if ((extractStreamSendEntryToExtractThread(a1) & 0x80000000) != 0)
    {
      v13 = "send entry to thread";
      v14 = 1207;
      goto LABEL_14;
    }
    v12 = *(_QWORD *)(a1 + 1640);
  }
  v15 = (_QWORD *)(a1 + 1632);
  if (v12)
    extractThreadSendCommand(v12, 69, 0, 0);
  result = 0;
  *v15 = 0;
  v15[1] = 0;
  return result;
}

uint64_t extractStreamSendEntryToExtractThread(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v20;

  v2 = (pthread_mutex_t *)(a1 + 1088);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1088)))
  {
    v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v7 = 91;
LABEL_8:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, v20);
    v13 = "SharedArrayPop failed";
    v14 = 1145;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamSendEntryToExtractThread", v14, 72, 0, v13, v11, v12, v20);
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    v8 = *(_DWORD *)(a1 + 1072);
    if (v8)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 1152), v2))
    {
      v6 = "SharedArrayPop: pthread_cond_wait failed\n";
      v7 = 94;
      goto LABEL_8;
    }
  }
  v9 = v8 - 1;
  *(_DWORD *)(a1 + 1072) = v9;
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 1080) + 4 * v9);
  if (pthread_mutex_unlock(v2))
  {
    v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v7 = 98;
    goto LABEL_8;
  }
  v16 = *(_QWORD *)(a1 + 1064);
  v17 = v16 + 176 * v10;
  *(_QWORD *)(a1 + 1640) = v17;
  *(_QWORD *)(v17 + 168) = *(_QWORD *)(a1 + 1632);
  *(_QWORD *)(a1 + 1632) = 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 56))
    || (v18 = v16 + 176 * v10, v19 = *(_DWORD *)(v18 + 48), *(_DWORD *)(v18 + 48) = v19 + 1, !v19)
    && pthread_cond_broadcast((pthread_cond_t *)(v16 + 176 * v10 + 120))
    || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 56)))
  {
    v13 = "SemRelease failed";
    v14 = 1150;
    goto LABEL_9;
  }
  if ((extractThreadSendCommand(v16 + 176 * v10, 66, 0, 0) & 0x80000000) != 0)
  {
    v13 = "extract thread BEGIN failed";
    v14 = 1153;
    goto LABEL_9;
  }
  return 0;
}

uint64_t aaHeaderInitWithEncodedData(uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  _QWORD *v10;
  size_t v11;
  size_t v12;
  void **v13;
  uint64_t v14;
  char *v15;
  void *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  int v23;
  int v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  size_t v29;
  size_t *v30;
  uint64_t v31;
  uint64_t result;
  char v33;
  size_t v34;

  init_blob_with_magic(a1);
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 40) = 0;
  if (a3 <= 5)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 113, 101, 0, "invalid header size: %llu", v6, v7, a3);
    goto LABEL_63;
  }
  if (*(_DWORD *)a2 != 826360153 && *(_DWORD *)a2 != 825246017)
  {
    v8 = "invalid header magic";
    v9 = 114;
    goto LABEL_62;
  }
  if (a2[2] != a3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 116, 101, 0, "header size mismatch: stored %u, got %llu", v6, v7, a2[2]);
    goto LABEL_63;
  }
  *(_QWORD *)(a1 + 16) = 0;
  v10 = (_QWORD *)(a1 + 16);
  if ((a3 & 0x8000000000000000) != 0)
    goto LABEL_61;
  v11 = *(_QWORD *)(a1 + 24);
  if (v11 >= a3)
  {
    v14 = 0;
    v15 = *(char **)(a1 + 32);
LABEL_22:
    memcpy(&v15[v14], a2, a3);
    goto LABEL_23;
  }
  do
  {
    while (!v11)
    {
      v11 = 0x4000;
      if (a3 <= 0x4000)
      {
        v13 = (void **)(a1 + 32);
        v11 = 0x4000;
        goto LABEL_20;
      }
    }
    v12 = v11 >> 1;
    if ((v11 & (v11 >> 1)) != 0)
      v12 = v11 & (v11 >> 1);
    v11 += v12;
  }
  while (v11 < a3);
  v13 = (void **)(a1 + 32);
  if (v11 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_60;
  }
LABEL_20:
  v16 = *v13;
  v15 = (char *)realloc(*v13, v11);
  if (!v15)
  {
    free(v16);
LABEL_60:
    *v13 = 0;
    *v10 = 0;
    *(_QWORD *)(a1 + 24) = 0;
LABEL_61:
    v8 = "realloc blob";
    v9 = 121;
    goto LABEL_62;
  }
  *(_QWORD *)(a1 + 24) = v11;
  *(_QWORD *)(a1 + 32) = v15;
  v14 = *(_QWORD *)(a1 + 16);
  if (a2)
    goto LABEL_22;
  memset_s(&v15[v14], a3, 0, a3);
LABEL_23:
  v17 = *v10 + a3;
  *v10 = v17;
  if (v17 < 4)
    goto LABEL_61;
  **(_DWORD **)(a1 + 32) = 825246017;
  if (a3 < 7)
    return 0;
  v34 = 0;
  v18 = 6;
  while (2)
  {
    if ((realloc_fields(a1, *(_DWORD *)a1 + 1) & 0x80000000) != 0)
    {
      v8 = "realloc_fields";
      v9 = 127;
      goto LABEL_62;
    }
    v19 = *(_QWORD *)(a1 + 8);
    v20 = (*(_DWORD *)a1)++;
    if (v18 + 4 > a3)
    {
      v8 = "truncated header";
      v9 = 130;
      goto LABEL_62;
    }
    v21 = v19 + 48 * v20;
    v22 = (char *)a2 + v18;
    *(_DWORD *)v21 = *(_DWORD *)((char *)a2 + v18);
    v23 = *(char *)(v21 + 3);
    *(_DWORD *)(v21 + 8) = v23;
    *(_BYTE *)(v21 + 3) = 0;
    switch(v23)
    {
      case '1':
        v24 = 1;
        v25 = 1;
        goto LABEL_50;
      case '2':
        v24 = 1;
        goto LABEL_36;
      case '3':
      case '5':
      case '6':
      case '7':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'D':
      case 'E':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'Q':
      case 'R':
        goto LABEL_68;
      case '4':
        v24 = 1;
        goto LABEL_40;
      case '8':
        v24 = 1;
        goto LABEL_48;
      case 'A':
        v24 = 5;
LABEL_36:
        v25 = 2;
        goto LABEL_50;
      case 'B':
        v24 = 5;
        goto LABEL_40;
      case 'C':
        v24 = 5;
        goto LABEL_48;
      case 'F':
        v24 = 3;
LABEL_40:
        v25 = 4;
        goto LABEL_50;
      case 'G':
        v24 = 3;
        v25 = 20;
        goto LABEL_50;
      case 'H':
        v24 = 3;
        v25 = 32;
        goto LABEL_50;
      case 'I':
        v24 = 3;
        v25 = 48;
        goto LABEL_50;
      case 'J':
        v24 = 3;
        v25 = 64;
        goto LABEL_50;
      case 'P':
        if (v18 + 6 <= a3)
        {
          v34 = *((unsigned __int16 *)v22 + 2);
          v25 = v34 + 2;
          v24 = 2;
LABEL_50:
          *(_DWORD *)(v19 + 48 * v20 + 4) = v24;
          if (v18 + 4 + v25 > a3)
          {
            v8 = "truncated header";
            v9 = 161;
            goto LABEL_62;
          }
          v26 = 0;
          v27 = v19 + 48 * v20;
          *(_QWORD *)(v27 + 24) = 0;
          v28 = (_QWORD *)(v27 + 24);
          v29 = v25 + 4;
          *((_DWORD *)v28 - 3) = v18;
          *((_DWORD *)v28 - 2) = v25 + 4;
          v28[2] = 0;
          v30 = v28 + 2;
          v28[1] = 0;
          switch(v24)
          {
            case 1:
              memcpy(v30, v22 + 4, v25);
              v26 = 0;
              break;
            case 2:
              v26 = 0;
              *v30 = v34;
              break;
            case 3:
              v26 = 0;
              *v30 = v25;
              break;
            case 5:
              v31 = v19 + 48 * v20;
              memcpy((void *)(v31 + 32), v22 + 4, v25);
              *v28 = *(_QWORD *)(a1 + 40);
              v26 = *(_QWORD *)(v31 + 32);
              break;
            default:
              break;
          }
          result = 0;
          *(_QWORD *)(a1 + 40) += v26;
          v18 += v29;
          if (v18 >= a3)
            return result;
          continue;
        }
        v8 = "truncated header";
        v9 = 153;
LABEL_62:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", v9, 101, 0, v8, v6, v7, v33);
LABEL_63:
        *(_DWORD *)a1 = 0;
        *(_QWORD *)(a1 + 16) = 0;
        result = 0xFFFFFFFFLL;
        *(_QWORD *)(a1 + 40) = 0;
        return result;
      case 'S':
        v24 = 4;
LABEL_48:
        v25 = 8;
        goto LABEL_50;
      case 'T':
        v24 = 4;
        v25 = 12;
        goto LABEL_50;
      default:
        if (v23 != 42)
        {
LABEL_68:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 159, 101, 0, "invalid field subtype: %d", v6, v7, v23);
          goto LABEL_63;
        }
        v24 = 0;
        v25 = 0;
        goto LABEL_50;
    }
  }
}

uint64_t init_blob_with_magic(uint64_t a1)
{
  _QWORD *v2;
  size_t v3;
  size_t v4;
  void *v5;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  void *v16;
  char *v17;
  char v18;

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 <= 5)
  {
    while (v3)
    {
      v4 = v3 >> 1;
      if ((v3 & (v3 >> 1)) != 0)
        v4 = v3 & (v3 >> 1);
      v3 += v4;
      if (v3 >= 6)
        goto LABEL_8;
    }
    v3 = 0x4000;
LABEL_8:
    v5 = *(void **)(a1 + 32);
    v6 = realloc(v5, v3);
    if (!v6)
    {
      free(v5);
      *(_DWORD *)a1 = 0;
      v2[1] = 0;
      v2[2] = 0;
      *v2 = 0;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"init_blob_with_magic", 61, 101, 0, "realloc_blob failed", v13, v14, v18);
      return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 24) = v3;
    *(_QWORD *)(a1 + 32) = v6;
  }
  *(_QWORD *)(a1 + 16) = 0;
  **(_DWORD **)(a1 + 32) = 825246017;
  v7 = *(_QWORD *)(a1 + 16) + 4;
  *(_QWORD *)(a1 + 16) = v7;
  v8 = v7 + 2;
  if (v7 >= 0xFFFFFFFFFFFFFFFELL || (v8 & 0x8000000000000000) != 0)
    return 0;
  v9 = *(_QWORD *)(a1 + 24);
  if (v9 >= v8)
  {
    v15 = *(char **)(a1 + 32);
LABEL_28:
    result = 0;
    *(_WORD *)&v15[v7] = 6;
    *v2 += 2;
  }
  else
  {
    v10 = 0x4000;
    do
    {
      while (!v9)
      {
        v9 = 0x4000;
        if (v8 <= 0x4000)
          goto LABEL_26;
      }
      v11 = v9 >> 1;
      if ((v9 & (v9 >> 1)) != 0)
        v11 = v9 & (v9 >> 1);
      v9 += v11;
    }
    while (v9 < v8);
    v10 = v9;
    if (v9 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_30;
    }
LABEL_26:
    v16 = *(void **)(a1 + 32);
    v17 = (char *)realloc(v16, v10);
    if (v17)
    {
      v15 = v17;
      *(_QWORD *)(a1 + 24) = v10;
      *(_QWORD *)(a1 + 32) = v17;
      v7 = *(_QWORD *)(a1 + 16);
      goto LABEL_28;
    }
    free(v16);
LABEL_30:
    result = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *v2 = 0;
    v2[1] = 0;
  }
  return result;
}

uint64_t realloc_fields(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t result;
  void *v6;
  void *v7;
  void *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  if ((a2 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD *)(a1 + 4);
  if (v3 >= a2)
    return 0;
  v4 = *(_DWORD *)(a1 + 4);
  do
  {
    if (v4)
      v4 += v4 >> 1;
    else
      v4 = 16;
  }
  while (v4 < a2);
  if (v3 >= v4)
    return 0;
  if (v4 < 0xAAAAAAAB)
  {
    v6 = *(void **)(a1 + 8);
    v7 = realloc(v6, 48 * v4);
    if (v7)
    {
      v8 = v7;
      result = 0;
      *(_QWORD *)(a1 + 8) = v8;
      *(_DWORD *)(a1 + 4) = v4;
      return result;
    }
    free(v6);
  }
  else
  {
    *__error() = 12;
  }
  *(_QWORD *)(a1 + 8) = 0;
  v9 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"realloc_fields", 35, 101, *v9, "malloc", v10, v11, v12);
  *(_QWORD *)a1 = 0;
  result = 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t aaHeaderInitWithPath(AAHeader_impl *a1, AAFieldKeySet_impl *a2, char *a3, const char *a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  uint64_t result;
  unsigned int v14;
  AAFieldKey v15;
  size_t v16;
  AAFieldKey v17;
  int v18;
  ssize_t v19;
  AAFieldKey v20;
  AAFieldKey v21;
  AAFieldKey v22;
  AAFieldKey v23;
  AAFieldKey v24;
  AAFieldKey v25;
  AAFieldKey v26;
  AAFieldKey v27;
  AAFieldKey v28;
  AAFieldKey v29;
  AAFieldKey v30;
  AAFieldKey v31;
  AAFieldKey v32;
  AAFieldKey v33;
  AAFieldKey v34;
  AAFieldKey v35;
  AAFieldKey v36;
  AAFieldKey v37;
  AAFieldKey v38;
  AAFieldKey v39;
  AAFieldKey v40;
  AAFieldKey v41;
  int v42;
  AAFieldKey v43;
  uint64_t FileAPFSInternalFlagsFD;
  AAFieldKey v45;
  AAFieldKey v46;
  uint64_t v47;
  AAFieldKey v48;
  AAFieldKey v49;
  AAFieldKey v50;
  AAFieldKey v51;
  AAFieldKey v52;
  AAFieldKey v53;
  AAFieldKey v54;
  int v55;
  AAFieldKey v56;
  unsigned int FilesystemBlockSize;
  uint64_t FileDiskUsageBlocks2;
  AAFieldKey v59;
  AAFieldKey v60;
  char v61;
  AAFieldKey v62;
  char v63;
  AAFieldKey v64;
  char v65;
  AAFieldKey v66;
  char v67;
  AAFieldKey v68;
  char v69;
  unsigned int v70;
  AAFieldKey v71;
  AAFieldKey v72;
  AAFieldKey v73;
  AAFieldKey v74;
  AAFieldKey v75;
  char *v76;
  timespec v77;
  uint64_t v78[3];
  stat v79;
  char value[1032];
  char v81[2048];
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  memset(&v79, 0, sizeof(v79));
  init_blob_with_magic((uint64_t)a1);
  *(_DWORD *)a1 = 0;
  *((_QWORD *)a1 + 5) = 0;
  if ((concatPath(v81, 0x800uLL, a3, a4) & 0x80000000) != 0)
  {
    LOBYTE(v76) = (_BYTE)a3;
    v11 = "invalid path %s/%s";
    v12 = 196;
LABEL_7:
    v10 = 0;
    goto LABEL_8;
  }
  if ((init_blob_with_magic((uint64_t)a1) & 0x80000000) != 0)
  {
    v11 = "init_blob_with_magic";
    v12 = 199;
    goto LABEL_7;
  }
  *(_DWORD *)a1 = 0;
  *((_QWORD *)a1 + 5) = 0;
  if (lstat(v81, &v79))
  {
    v10 = *__error();
    v76 = v81;
    v11 = "lstat %s";
    v12 = 204;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithPath", v12, 101, v10, v11, v8, v9, (char)v76);
    *(_DWORD *)a1 = 0;
    *((_QWORD *)a1 + 2) = 0;
    result = 0xFFFFFFFFLL;
    *((_QWORD *)a1 + 5) = 0;
    return result;
  }
  v14 = aaEntryTypeFromMode(v79.st_mode);
  if (!v14)
  {
    v76 = v81;
    v11 = "could not determine entry type: %s";
    v12 = 210;
    goto LABEL_7;
  }
  v15.ikey = 5265748;
  if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v15, v14) < 0)
  {
    v76 = v81;
    v11 = "inserting TYP: %s";
    v12 = 211;
    goto LABEL_7;
  }
  v16 = strlen(a4);
  v17.ikey = 5521744;
  if (AAHeaderSetFieldString(a1, 0xFFFFFFFF, v17, a4, v16) < 0)
  {
    v76 = v81;
    v11 = "inserting PAT: %s";
    v12 = 217;
    goto LABEL_7;
  }
  v18 = v79.st_mode & 0xF000;
  if (v18 == 40960)
  {
    v19 = readlink(v81, value, 0x3FFuLL);
    if (v19 < 0)
    {
      v10 = *__error();
      v76 = v81;
      v11 = "readlink: %s";
      v12 = 225;
      goto LABEL_8;
    }
    value[v19] = 0;
    v20.ikey = 4935244;
    if (AAHeaderSetFieldString(a1, 0xFFFFFFFF, v20, value, v19) < 0)
    {
      v76 = v81;
      v11 = "inserting LNK: %s";
      v12 = 227;
      goto LABEL_7;
    }
    v18 = v79.st_mode & 0xF000;
  }
  if ((v18 | 0x4000) == 0x6000)
  {
    v21.ikey = 5653828;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v21, v79.st_rdev) < 0)
    {
      v76 = v81;
      v11 = "inserting DEV: %s";
      v12 = 233;
      goto LABEL_7;
    }
  }
  v22.ikey = 4475221;
  if (AAFieldKeySetContainsKey(a2, v22))
  {
    v23.ikey = 4475221;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v23, v79.st_uid) < 0)
    {
      v76 = v81;
      v11 = "inserting UID: %s";
      v12 = 239;
      goto LABEL_7;
    }
  }
  v24.ikey = 4475207;
  if (AAFieldKeySetContainsKey(a2, v24))
  {
    v25.ikey = 4475207;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v25, v79.st_gid) < 0)
    {
      v76 = v81;
      v11 = "inserting GID: %s";
      v12 = 245;
      goto LABEL_7;
    }
  }
  v26.ikey = 4476749;
  if (AAFieldKeySetContainsKey(a2, v26))
  {
    v27.ikey = 4476749;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v27, v79.st_mode & 0xFFF) < 0)
    {
      v76 = v81;
      v11 = "inserting MOD: %s";
      v12 = 251;
      goto LABEL_7;
    }
  }
  v28.ikey = 4672582;
  if (AAFieldKeySetContainsKey(a2, v28))
  {
    v29.ikey = 4672582;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v29, v79.st_flags) < 0)
    {
      v76 = v81;
      v11 = "inserting FLG: %s";
      v12 = 259;
      goto LABEL_7;
    }
  }
  v30.ikey = 5067843;
  if (AAFieldKeySetContainsKey(a2, v30) || (v31.ikey = 5067842, AAFieldKeySetContainsKey(a2, v31)))
  {
    v78[1] = 0;
    v78[2] = 0;
    memset(value, 0, 64);
    v78[0] = 0x220000000005;
    if (!getattrlist(v81, v78, value, 0x40uLL, 1u) && *(_DWORD *)value == 36)
    {
      v77 = *(timespec *)&value[4];
      v32.ikey = 5067843;
      if (AAFieldKeySetContainsKey(a2, v32))
      {
        if (v77.tv_sec)
        {
          v33.ikey = 5067843;
          if (AAHeaderSetFieldTimespec(a1, 0xFFFFFFFF, v33, &v77) < 0)
          {
            v76 = v81;
            v11 = "inserting CTM: %s";
            v12 = 277;
            goto LABEL_7;
          }
        }
      }
      v77 = *(timespec *)&value[20];
      v34.ikey = 5067842;
      if (AAFieldKeySetContainsKey(a2, v34))
      {
        if (v77.tv_sec)
        {
          v35.ikey = 5067842;
          if (AAHeaderSetFieldTimespec(a1, 0xFFFFFFFF, v35, &v77) < 0)
          {
            v76 = v81;
            v11 = "inserting BTM: %s";
            v12 = 283;
            goto LABEL_7;
          }
        }
      }
    }
  }
  v36.ikey = 5067853;
  if (AAFieldKeySetContainsKey(a2, v36))
  {
    v37.ikey = 5067853;
    if (AAHeaderSetFieldTimespec(a1, 0xFFFFFFFF, v37, &v79.st_mtimespec) < 0)
    {
      v76 = v81;
      v11 = "inserting MTM: %s";
      v12 = 291;
      goto LABEL_7;
    }
  }
  if ((v79.st_mode & 0xF000) != 0x8000)
    goto LABEL_46;
  v38.ikey = 5523009;
  if (AAFieldKeySetContainsKey(a2, v38) <= 0)
  {
    v39.ikey = 5391937;
    if (AAFieldKeySetContainsKey(a2, v39) < 1)
      goto LABEL_46;
  }
  *(_QWORD *)value = 0;
  LODWORD(v78[0]) = 0;
  LODWORD(v77.tv_sec) = 0;
  if ((ParallelCompressionAFSCGetMetadata(v81, (off_t *)value, (unsigned int *)v78, &v77) & 0x80000000) != 0)
  {
    v11 = "querying AFSC metadata";
    v12 = 306;
    goto LABEL_7;
  }
  if (LODWORD(v78[0]) != -1)
  {
    v40.ikey = 5523009;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v40, SLODWORD(v78[0])) < 0)
    {
      v76 = v81;
      v11 = "inserting AFT: %s";
      v12 = 309;
      goto LABEL_7;
    }
    v41.ikey = 5391937;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v41, LODWORD(v77.tv_sec)) < 0)
    {
      v76 = v81;
      v11 = "inserting AFR: %s";
      v12 = 310;
      goto LABEL_7;
    }
  }
LABEL_46:
  v42 = v79.st_mode & 0xF000;
  if (v42 == 0x8000 || v42 == 0x4000)
  {
    v43.ikey = 4803654;
    if (AAFieldKeySetContainsKey(a2, v43) >= 1)
    {
      FileAPFSInternalFlagsFD = getFileAPFSInternalFlagsFD();
      if (FileAPFSInternalFlagsFD)
      {
        v45.ikey = 4803654;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v45, FileAPFSInternalFlagsFD) < 0)
        {
          v76 = v81;
          v11 = "inserting FLI: %s";
          v12 = 322;
          goto LABEL_7;
        }
      }
    }
  }
  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    v46.ikey = 4411984;
    if (AAFieldKeySetContainsKey(a2, v46) >= 1)
    {
      v47 = getFileProtectionClass(v81) - 1;
      if (v47 <= 5)
      {
        v48.ikey = 4411984;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v48, v47 + 65) < 0)
        {
          v76 = v81;
          v11 = "inserting PRC: %s";
          v12 = 342;
          goto LABEL_7;
        }
      }
    }
  }
  v49.ikey = 5197385;
  if (AAFieldKeySetContainsKey(a2, v49))
  {
    v50.ikey = 5197385;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v50, v79.st_ino) < 0)
    {
      v76 = v81;
      v11 = "inserting INO: %s";
      v12 = 359;
      goto LABEL_7;
    }
  }
  v51.ikey = 4934734;
  if (AAFieldKeySetContainsKey(a2, v51))
  {
    v52.ikey = 4934734;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v52, v79.st_nlink) < 0)
    {
      v76 = v81;
      v11 = "inserting LNK: %s";
      v12 = 365;
      goto LABEL_7;
    }
  }
  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    v53.ikey = 5917011;
    if (AAFieldKeySetContainsKey(a2, v53))
    {
      v54.ikey = 5917011;
      if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v54, v79.st_size) < 0)
      {
        v76 = v81;
        v11 = "inserting SIZ: %s";
        v12 = 371;
        goto LABEL_7;
      }
    }
  }
  v55 = v79.st_mode & 0xF000;
  if (v55 == 0x4000 || v55 == 40960 || v55 == 0x8000)
  {
    v56.ikey = 5920068;
    if (AAFieldKeySetContainsKey(a2, v56))
    {
      FilesystemBlockSize = getFilesystemBlockSize(a3);
      FileDiskUsageBlocks2 = getFileDiskUsageBlocks2(a3, a4, FilesystemBlockSize);
      if ((FileDiskUsageBlocks2 & 0x8000000000000000) == 0)
      {
        v59.ikey = 5920068;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v59, FileDiskUsageBlocks2) < 0)
        {
          v76 = v81;
          v11 = "inserting DUZ: %s";
          v12 = 381;
          goto LABEL_7;
        }
      }
    }
  }
  v60.ikey = 5458755;
  v61 = AAFieldKeySetContainsKey(a2, v60);
  v62.ikey = 3229779;
  v63 = AAFieldKeySetContainsKey(a2, v62);
  v64.ikey = 3295315;
  v65 = AAFieldKeySetContainsKey(a2, v64);
  v66.ikey = 3360851;
  v67 = AAFieldKeySetContainsKey(a2, v66);
  v68.ikey = 3491923;
  v69 = AAFieldKeySetContainsKey(a2, v68);
  result = 0;
  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    v70 = ((v61 & 1) << 11) & 0xFFF | ((v63 & 1) << 12) & 0x1FFF | ((v65 & 1) << 13) & 0x3FFF | ((v67 & 1) << 14) & 0x7FFF | ((v69 & 1) << 15);
    if (v70)
    {
      memset(value, 0, 172);
      if ((aaEntryHashesInitWithPath(value, v70, a3, a4) & 0x80000000) != 0)
      {
        v76 = v81;
        v11 = "computing file hashes: %s";
        v12 = 395;
      }
      else if ((v61 & 1) != 0
             && (v71.ikey = 5458755, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v71, 1u, (const uint8_t *)&value[4]) < 0))
      {
        v76 = v81;
        v11 = "inserting CKS: %s";
        v12 = 397;
      }
      else if ((v63 & 1) != 0
             && (v72.ikey = 3229779, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v72, 2u, (const uint8_t *)&value[8]) < 0))
      {
        v76 = v81;
        v11 = "inserting SH1: %s";
        v12 = 399;
      }
      else if ((v65 & 1) != 0
             && (v73.ikey = 3295315, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v73, 3u, (const uint8_t *)&value[28]) < 0))
      {
        v76 = v81;
        v11 = "inserting SH2: %s";
        v12 = 401;
      }
      else if ((v67 & 1) != 0
             && (v74.ikey = 3360851, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v74, 4u, (const uint8_t *)&value[60]) < 0))
      {
        v76 = v81;
        v11 = "inserting SH3: %s";
        v12 = 403;
      }
      else
      {
        if ((v69 & 1) == 0)
          return 0;
        v75.ikey = 3491923;
        if ((AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v75, 5u, (const uint8_t *)&value[108]) & 0x80000000) == 0)
          return 0;
        v76 = v81;
        v11 = "inserting SH5: %s";
        v12 = 405;
      }
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t getFileDiskUsageBlocks2(char *a1, const char *a2, unsigned int a3)
{
  uint64_t result;
  char v7[2048];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  bzero(v7, 0x800uLL);
  if (concatPath(v7, 0x800uLL, a1, a2))
    return -1;
  result = getFileDiskUsage(v7);
  if (result >= 0)
    return (result + a3 - 1) & -(uint64_t)a3;
  return result;
}

uint64_t aaHeaderAppendEntryAttributes(AAHeader header, char *a2, char *a3)
{
  char v6;
  AAFieldKey v7;
  uint64_t v8;
  uint64_t v9;
  AAFieldKey v10;
  AAFieldKey v11;
  AAFieldKey v12;
  AAFieldKey v13;
  AAFieldKey v14;
  AAFieldKey v15;
  char v16;
  AAFieldKey v17;
  AAFieldKey v18;
  AAFieldKey v19;
  AAFieldKey v20;
  const char *v22;
  __int16 v23;
  char v24;

  v6 = *a2;
  if ((*a2 & 1) != 0)
  {
    v7.ikey = 4475221;
    if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v7, *((unsigned int *)a2 + 1)) < 0)
    {
      v22 = "append UID";
      v23 = 416;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 2) != 0)
  {
    v10.ikey = 4475207;
    if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v10, *((unsigned int *)a2 + 2)) < 0)
    {
      v22 = "append GID";
      v23 = 417;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 8) != 0)
  {
    v11.ikey = 4476749;
    if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v11, *((unsigned int *)a2 + 4)) < 0)
    {
      v22 = "append MOD";
      v23 = 418;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 4) != 0)
  {
    v12.ikey = 4672582;
    if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v12, *((unsigned int *)a2 + 3)) < 0)
    {
      v22 = "append FLG";
      v23 = 419;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 0x40) != 0)
  {
    v13.ikey = 5067853;
    if (AAHeaderSetFieldTimespec(header, 0xFFFFFFFF, v13, (const timespec *)(a2 + 56)) < 0)
    {
      v22 = "append MTM";
      v23 = 420;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 0x20) != 0)
  {
    v14.ikey = 5067843;
    if (AAHeaderSetFieldTimespec(header, 0xFFFFFFFF, v14, (const timespec *)(a2 + 40)) < 0)
    {
      v22 = "append CTM";
      v23 = 421;
      goto LABEL_44;
    }
    v6 = *a2;
  }
  if ((v6 & 0x10) != 0
    && (v15.ikey = 5067842, AAHeaderSetFieldTimespec(header, 0xFFFFFFFF, v15, (const timespec *)(a2 + 24)) < 0))
  {
    v22 = "append BTM";
    v23 = 422;
  }
  else
  {
    v16 = *a3;
    if ((*a3 & 1) != 0)
    {
      v17.ikey = 5523009;
      if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v17, *((int *)a3 + 2)) < 0)
      {
        v22 = "append AFT";
        v23 = 423;
        goto LABEL_44;
      }
      v16 = *a3;
    }
    if ((v16 & 2) != 0)
    {
      v18.ikey = 5391937;
      if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v18, *((unsigned int *)a3 + 3)) < 0)
      {
        v22 = "append AFR";
        v23 = 424;
        goto LABEL_44;
      }
      v16 = *a3;
    }
    if ((v16 & 4) != 0)
    {
      v19.ikey = 4803654;
      if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v19, *((_QWORD *)a3 + 2)) < 0)
      {
        v22 = "append FLI";
        v23 = 425;
        goto LABEL_44;
      }
      v16 = *a3;
    }
    if ((v16 & 8) == 0)
      return 0;
    v20.ikey = 4411984;
    if ((AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v20, *((int *)a3 + 1)) & 0x80000000) == 0)
      return 0;
    v22 = "append PRC";
    v23 = 426;
  }
LABEL_44:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderAppendEntryAttributes", v23, 101, 0, v22, v8, v9, v24);
  return 0xFFFFFFFFLL;
}

uint64_t aaHeaderBlobArrayInitWithHeader(uint64_t a1, AAHeader_impl *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  uint32_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t size;

  *(_DWORD *)a1 = 0;
  v4 = *(unsigned int *)a2;
  if (v4 <= *(_DWORD *)(a1 + 4))
  {
    if (!(_DWORD)v4)
    {
      v8 = 0;
LABEL_13:
      result = 0;
      *(_DWORD *)a1 = v8;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4) = v4;
    v5 = *(void **)(a1 + 8);
    v6 = realloc(v5, 24 * v4);
    if (!v6)
    {
      free(v5);
      *(_QWORD *)(a1 + 8) = 0;
      v12 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderBlobArrayInitWithHeader", 441, 101, *v12, "malloc", v13, v14, v16);
      *(_QWORD *)a1 = 0;
      return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  v7 = 0;
  v8 = 0;
  while (AAHeaderGetFieldType(a2, v7) != 5)
  {
LABEL_9:
    if ((_DWORD)v4 == ++v7)
      goto LABEL_13;
  }
  size = 0;
  if ((AAHeaderGetFieldBlob(a2, v7, &size, &v16) & 0x80000000) == 0)
  {
    v11 = *(_QWORD *)(a1 + 8);
    *(AAFieldKey *)(v11 + 24 * v8) = AAHeaderGetFieldKey(a2, v7);
    *(int64x2_t *)(*(_QWORD *)(a1 + 8) + 24 * v8++ + 8) = vdupq_lane_s64(size, 0);
    goto LABEL_9;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderBlobArrayInitWithHeader", 448, 101, 0, "get field blob failed", v9, v10, v16);
  return 0xFFFFFFFFLL;
}

uint32_t AAHeaderGetFieldCount(AAHeader header)
{
  return *(_DWORD *)header;
}

int AAHeaderGetFieldType(AAHeader header, uint32_t i)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_DWORD *)header > i)
    return *(_DWORD *)(*((_QWORD *)header + 1) + 48 * i + 4);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldType", 580, 101, 0, "invalid field index %u", v2, v3, i);
  return -1;
}

int AAHeaderGetFieldBlob(AAHeader header, uint32_t i, uint64_t *size, uint64_t *offset)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int result;
  uint64_t v8;

  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldBlob", 658, 101, 0, "invalid field index %u", v4, v5, i);
  }
  else
  {
    v6 = *((_QWORD *)header + 1);
    if (*(_DWORD *)(v6 + 48 * i + 4) == 5)
    {
      result = 0;
      v8 = v6 + 48 * i;
      *size = *(_QWORD *)(v8 + 32);
      *offset = *(_QWORD *)(v8 + 24);
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldBlob", 660, 101, 0, "invalid type %d, expected BLOB", v4, v5, *(_DWORD *)(v6 + 48 * i + 4));
  }
  return -1;
}

AAFieldKey AAHeaderGetFieldKey(AAHeader header, uint32_t i)
{
  uint64_t v2;
  uint64_t v3;

  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldKey", 586, 101, 0, "invalid field index %u", v2, v3, i);
    return (AAFieldKey)0;
  }
  else
  {
    return *(AAFieldKey *)(*((_QWORD *)header + 1) + 48 * i);
  }
}

uint64_t aaHeaderBlobArrayPayloadSize(unsigned int *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t *v4;
  uint64_t v5;

  v1 = *a1;
  if (!(_DWORD)v1)
    return 0;
  result = 0;
  v4 = (uint64_t *)(*((_QWORD *)a1 + 1) + 8);
  do
  {
    v5 = *v4;
    v4 += 3;
    result += v5;
    --v1;
  }
  while (v1);
  return result;
}

AAHeader AAHeaderCreate(void)
{
  AAHeader_impl *v0;
  AAHeader_impl *v1;
  uint64_t v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v0 = (AAHeader_impl *)malloc(0x30uLL);
  v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
    if ((init_blob_with_magic((uint64_t)v1) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderCreate", 473, 101, 0, "init_blob_with_magic", v2, v3, v8);
      AAHeaderDestroy(v1);
      return 0;
    }
  }
  else
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderCreate", 470, 101, *v4, "malloc", v5, v6, v8);
  }
  return v1;
}

void AAHeaderDestroy(AAHeader header)
{
  if (header)
  {
    free(*((void **)header + 1));
    free(*((void **)header + 4));
    memset_s((char *)header + 16, 0x18uLL, 0, 0x18uLL);
    free(header);
  }
}

AAHeader AAHeaderClone(AAHeader header)
{
  AAHeader_impl *v2;
  AAHeader_impl *v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v2 = (AAHeader_impl *)malloc(0x30uLL);
  v3 = v2;
  if (v2)
  {
    memset_s(v2, 0x30uLL, 0, 0x30uLL);
    if (AAHeaderAssign(v3, header) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderClone", 495, 101, 0, "header copy", v4, v5, v10);
      AAHeaderDestroy(v3);
      return 0;
    }
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderClone", 492, 101, *v6, "malloc", v7, v8, v10);
  }
  return v3;
}

int AAHeaderAssign(AAHeader header, AAHeader from_header)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  size_t v10;
  void **v11;
  const char *v12;
  __int16 v13;
  void *v14;
  void *v15;
  uint64_t v16;
  unint64_t v17;
  int result;
  char v19;

  if ((realloc_fields((uint64_t)header, *(_DWORD *)from_header) & 0x80000000) != 0)
  {
    v12 = "realloc_fields";
    v13 = 507;
  }
  else
  {
    memcpy(*((void **)header + 1), *((const void **)from_header + 1), 48 * *(unsigned int *)from_header);
    *(_DWORD *)header = *(_DWORD *)from_header;
    *((_QWORD *)header + 2) = 0;
    v6 = (unint64_t *)((char *)header + 16);
    v7 = *((_QWORD *)from_header + 2);
    if ((v7 & 0x8000000000000000) == 0)
    {
      v8 = (const void *)*((_QWORD *)from_header + 4);
      v9 = *((_QWORD *)header + 3);
      if (v9 >= v7)
      {
LABEL_16:
        v16 = *((_QWORD *)header + 4);
        if (v8)
        {
          memcpy((void *)(v16 + *v6), v8, v7);
        }
        else if (v16)
        {
          memset_s((void *)(v16 + *v6), v7, 0, v7);
        }
        v17 = *v6 + v7;
        *v6 = v17;
        if (v17 > 3)
        {
          result = 0;
          **((_DWORD **)header + 4) = 825246017;
          *((_QWORD *)header + 5) = *((_QWORD *)from_header + 5);
          return result;
        }
      }
      else
      {
        do
        {
          while (!v9)
          {
            v9 = 0x4000;
            if (v7 <= 0x4000)
            {
              v11 = (void **)((char *)header + 32);
              v9 = 0x4000;
              goto LABEL_14;
            }
          }
          v10 = v9 >> 1;
          if ((v9 & (v9 >> 1)) != 0)
            v10 = v9 & (v9 >> 1);
          v9 += v10;
        }
        while (v9 < v7);
        v11 = (void **)((char *)header + 32);
        if (v9 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_23;
        }
LABEL_14:
        v14 = *v11;
        v15 = realloc(*v11, v9);
        if (v15)
        {
          *((_QWORD *)header + 3) = v9;
          *((_QWORD *)header + 4) = v15;
          goto LABEL_16;
        }
        free(v14);
LABEL_23:
        *v11 = 0;
        *v6 = 0;
        *((_QWORD *)header + 3) = 0;
      }
    }
    v12 = "realloc blob";
    v13 = 514;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderAssign", v13, 101, 0, v12, v4, v5, v19);
  return -1;
}

AAHeader AAHeaderCreateWithEncodedData(size_t data_size, const uint8_t *data)
{
  AAHeader v4;
  AAHeader_impl *v5;

  v4 = AAHeaderCreate();
  v5 = v4;
  if (v4 && (aaHeaderInitWithEncodedData((uint64_t)v4, (unsigned __int16 *)data, data_size) & 0x80000000) != 0)
  {
    AAHeaderDestroy(v5);
    return 0;
  }
  return v5;
}

AAHeader AAHeaderCreateWithPath(AAFieldKeySet key_set, const char *dir, const char *path, AAFlagSet flags)
{
  AAHeader_impl *v7;
  AAHeader_impl *v8;

  v7 = AAHeaderCreate();
  v8 = v7;
  if (v7 && (aaHeaderInitWithPath(v7, key_set, (char *)dir, path) & 0x80000000) != 0)
  {
    AAHeaderDestroy(v8);
    return 0;
  }
  return v8;
}

int AAHeaderRemoveField(AAHeader header, uint32_t i)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int result;
  char v12;

  if ((update_field_sizes((uint64_t)header, i, 0, 0, v2, v3, v4, v5) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderRemoveField", 546, 101, 0, "update_field_sizes failed", v8, v9, v12);
    return -1;
  }
  else
  {
    v10 = *(_DWORD *)header;
    if (*(_DWORD *)header + ~i)
    {
      memmove((void *)(*((_QWORD *)header + 1) + 48 * i), (const void *)(*((_QWORD *)header + 1) + 48 * (i + 1)), 48 * (*(_DWORD *)header + ~i));
      v10 = *(_DWORD *)header;
    }
    result = 0;
    *(_DWORD *)header = v10 - 1;
  }
  return result;
}

uint64_t update_field_sizes(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unint64_t v18;
  size_t v19;
  const char *v20;
  __int16 v21;
  uint64_t v24;
  unint64_t v25;
  size_t v26;
  size_t v27;
  void **v28;
  uint64_t v29;
  void **v30;
  void *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  void **v41;
  void *v42;
  uint64_t v43;
  size_t v44;

  if (*(_DWORD *)a1 <= a2)
  {
    v20 = "invalid field index";
    v21 = 74;
    goto LABEL_5;
  }
  v9 = a2;
  v12 = (unint64_t *)(a1 + 16);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)(a1 + 8);
  v14 = v13 + 48 * a2;
  v17 = *(_DWORD *)(v14 + 16);
  v16 = (unsigned int *)(v14 + 16);
  v15 = v17;
  v18 = *(v16 - 1) + (unint64_t)v17;
  v19 = v11 - v18;
  if (v11 < v18)
  {
LABEL_3:
    v20 = "realloc blob";
    v21 = 78;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"update_field_sizes", v21, 101, 0, v20, a7, a8, (char)v41);
    return 0xFFFFFFFFLL;
  }
  if (v15 >= a3)
  {
    if (v15 <= a3)
      goto LABEL_29;
    v29 = v15 - a3;
    if (v11 != v18)
    {
      memmove((void *)(*(_QWORD *)(a1 + 32) + v18 - v29), (const void *)(*(_QWORD *)(a1 + 32) + v18), v19);
      v18 = *(_QWORD *)(a1 + 16);
    }
    v11 = v18 - v29;
  }
  else
  {
    v24 = a3 - v15;
    v25 = v11 + v24;
    if ((uint64_t)(v11 + v24) < 0)
      goto LABEL_3;
    v26 = *(_QWORD *)(a1 + 24);
    if (v26 < v25)
    {
      do
      {
        while (!v26)
        {
          v26 = 0x4000;
          if (v25 <= 0x4000)
          {
            v43 = v24;
            v44 = v11 - v18;
            v28 = (void **)(a1 + 32);
            v26 = 0x4000;
            goto LABEL_23;
          }
        }
        v27 = v26 >> 1;
        if ((v26 & (v26 >> 1)) != 0)
          v27 = v26 & (v26 >> 1);
        v26 += v27;
      }
      while (v26 < v25);
      v28 = (void **)(a1 + 32);
      if (v26 >= 0x2000000001)
      {
        v30 = (void **)(a1 + 32);
        *__error() = 12;
        goto LABEL_36;
      }
      v43 = v24;
      v44 = v11 - v18;
LABEL_23:
      v41 = v28;
      v42 = *v28;
      v31 = realloc(*v28, v26);
      if (v31)
      {
        *(_QWORD *)(a1 + 24) = v26;
        *(_QWORD *)(a1 + 32) = v31;
        v24 = v43;
        v19 = v44;
        goto LABEL_25;
      }
      v30 = v41;
      free(v42);
LABEL_36:
      *v30 = 0;
      *v12 = 0;
      v12[1] = 0;
      goto LABEL_3;
    }
LABEL_25:
    if (v11 != v18)
    {
      v32 = (char *)(*(_QWORD *)(a1 + 32) + v18);
      v33 = v24;
      memmove(&v32[v24], v32, v19);
      v24 = v33;
    }
    v11 = *v12 + v24;
  }
  *v12 = v11;
LABEL_29:
  v34 = v13 + 48 * v9;
  v36 = *(_QWORD *)(v34 + 32);
  v35 = (_QWORD *)(v34 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 40) + a4 - v36;
  if (v11 <= 5)
  {
    v20 = "copy header size";
    v21 = 85;
    goto LABEL_5;
  }
  *(_WORD *)(*(_QWORD *)(a1 + 32) + 4) = v11;
  *v16 = a3;
  *v35 = a4;
  if (v9 + 1 < *(_DWORD *)a1)
  {
    v37 = *(_QWORD *)(a1 + 8);
    v38 = v37 + 48 * (v9 + 1) + 12;
    v39 = *(_DWORD *)a1 - 1;
    do
    {
      v40 = v37 + 48 * v9;
      *(_DWORD *)v38 = *(_DWORD *)(v40 + 16) + *(_DWORD *)(v40 + 12);
      *(_QWORD *)(v38 + 12) = *(_QWORD *)(v40 + 32) + *(_QWORD *)(v40 + 24);
      ++v9;
      v38 += 48;
    }
    while (v39 != v9);
  }
  return 0;
}

int AAHeaderClear(AAHeader header)
{
  init_blob_with_magic((uint64_t)header);
  *(_DWORD *)header = 0;
  *((_QWORD *)header + 5) = 0;
  return 0;
}

int AAHeaderGetKeyIndex(AAHeader header, AAFieldKey key)
{
  uint64_t v2;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned int *)header;
  if ((_DWORD)v2)
  {
    v4 = 0;
    v5 = (int *)*((_QWORD *)header + 1);
    while (1)
    {
      v6 = *v5;
      v5 += 12;
      if (((v6 ^ key.ikey) & 0xFFFFFF) == 0)
        break;
      if (v2 == ++v4)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    LODWORD(v4) = -1;
  }
  return v4;
}

int AAHeaderGetFieldUInt(AAHeader header, uint32_t i, uint64_t *value)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int result;

  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldUInt", 592, 101, 0, "invalid field index %u", v3, v4, i);
  }
  else
  {
    v5 = *((_QWORD *)header + 1);
    if (*(_DWORD *)(v5 + 48 * i + 4) == 1)
    {
      result = 0;
      *value = *(_QWORD *)(v5 + 48 * i + 40);
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldUInt", 594, 101, 0, "invalid type %d, expected UINT", v3, v4, *(_DWORD *)(v5 + 48 * i + 4));
  }
  return -1;
}

int AAHeaderGetFieldString(AAHeader header, uint32_t i, size_t capacity, char *value, size_t *length)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  int result;
  int v14;

  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldString", 602, 101, 0, "invalid field index %u", v5, v6, i);
    return -1;
  }
  v7 = *((_QWORD *)header + 1);
  if (*(_DWORD *)(v7 + 48 * i + 4) != 2)
  {
    v14 = *(_DWORD *)(v7 + 48 * i + 4);
    v11 = "invalid type %d, expected STRING";
    v12 = 604;
    goto LABEL_11;
  }
  v9 = *(unsigned int *)(v7 + 48 * i + 40);
  if (length)
    *length = v9;
  if (!capacity)
    return 0;
  if (v9 >= capacity)
    return -1;
  v10 = (*(_DWORD *)(v7 + 48 * i + 12) + 6);
  if (v9 + v10 > *((_QWORD *)header + 2))
  {
    v11 = "invalid blob segment";
    v12 = 612;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldString", v12, 101, 0, v11, v5, v6, v14);
    return -1;
  }
  memcpy(value, (const void *)(*((_QWORD *)header + 4) + v10), v9);
  result = 0;
  value[v9] = 0;
  return result;
}

int AAHeaderGetFieldHash(AAHeader header, uint32_t i, size_t capacity, AAHashFunction *hash_function, uint8_t *value)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v10;
  const char *v11;
  __int16 v12;
  int result;
  uint64_t v14;
  int v16;
  unsigned int v17;
  AAHashFunction v18;
  int v19;

  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldHash", 622, 101, 0, "invalid field index %u", v5, v6, i);
    return -1;
  }
  v7 = *((_QWORD *)header + 1);
  if (*(_DWORD *)(v7 + 48 * i + 4) != 3)
  {
    v19 = *(_DWORD *)(v7 + 48 * i + 4);
    v11 = "invalid type %d, expected HASH";
    v12 = 624;
    goto LABEL_7;
  }
  v10 = *(unsigned int *)(v7 + 48 * i + 40);
  if (v10 > capacity)
  {
    v11 = "not enough capacity to store HASH";
    v12 = 627;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldHash", v12, 101, 0, v11, v5, v6, v19);
    return -1;
  }
  v14 = (*(_DWORD *)(v7 + 48 * i + 12) + 4);
  if (v10 + v14 > *((_QWORD *)header + 2))
  {
    v11 = "invalid blob segment";
    v12 = 628;
    goto LABEL_7;
  }
  memcpy(value, (const void *)(*((_QWORD *)header + 4) + v14), v10);
  result = 0;
  if (hash_function)
  {
    v16 = *(_DWORD *)(v7 + 48 * i + 8);
    v17 = v16 - 70;
    v18 = v16 - 69;
    if (v17 >= 5)
      v18 = -1;
    *hash_function = v18;
  }
  return result;
}

int AAHeaderGetFieldTimespec(AAHeader header, uint32_t i, timespec *value)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  int result;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v16;
  __darwin_time_t v17;
  uint64_t v18;
  int v19;

  if (*(_DWORD *)header > i)
  {
    v5 = *((_QWORD *)header + 1);
    if (*(_DWORD *)(v5 + 48 * i + 4) == 4)
    {
      v6 = *(_DWORD *)(v5 + 48 * i + 8);
      if (v6 == 84)
      {
        v11 = *(_DWORD *)(v5 + 48 * i + 12);
        v12 = (v11 + 4);
        v13 = *((_QWORD *)header + 2);
        v14 = (v11 + 12);
        if (v12 + 8 > v13 || v14 + 4 > v13)
        {
          v8 = "invalid blob segment";
          v9 = 649;
          goto LABEL_9;
        }
        v16 = *((_QWORD *)header + 4);
        v17 = *(_QWORD *)(v16 + v12);
        v18 = *(unsigned int *)(v16 + v14);
      }
      else if (v6 == 83)
      {
        v7 = (*(_DWORD *)(v5 + 48 * i + 12) + 4);
        if ((unint64_t)(v7 + 8) > *((_QWORD *)header + 2))
        {
          v8 = "invalid blob segment";
          v9 = 643;
LABEL_9:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldTimespec", v9, 101, 0, v8, v3, v4, v19);
          return -1;
        }
        v18 = 0;
        v17 = *(_QWORD *)(*((_QWORD *)header + 4) + v7);
      }
      else
      {
        v17 = 0;
        v18 = 0;
      }
      result = 0;
      value->tv_sec = v17;
      value->tv_nsec = v18;
      return result;
    }
    v19 = *(_DWORD *)(v5 + 48 * i + 4);
    v8 = "invalid type %d, expected TIMESPEC";
    v9 = 637;
    goto LABEL_9;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldTimespec", 635, 101, 0, "invalid field index %u", v3, v4, i);
  return -1;
}

int AAHeaderSetFieldFlag(AAHeader header, uint32_t i, AAFieldKey key)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  char v21;
  AAFieldKey __src;
  uint64_t v23;
  uint64_t v24;

  v10 = MEMORY[0x24BDAC740];
  if (key.skey[0] < 0)
  {
    if (!__maskrune(key.skey[0], 0x500uLL))
      goto LABEL_19;
  }
  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * key.skey[0] + 60) & 0x500) == 0)
  {
    goto LABEL_19;
  }
  v11 = *(__int16 *)key.skey >> 8;
  if (((key.ikey << 16) & 0x80000000) != 0)
  {
    if (__maskrune(v11, 0x500uLL))
      goto LABEL_9;
LABEL_19:
    v18 = "invalid key";
    v19 = 669;
    goto LABEL_20;
  }
  if ((*(_DWORD *)(v10 + 4 * v11 + 60) & 0x500) == 0)
    goto LABEL_19;
LABEL_9:
  v12 = (int)(key.ikey << 8) >> 24;
  if (((key.ikey << 8) & 0x80000000) != 0)
    v13 = __maskrune(v12, 0x500uLL);
  else
    v13 = *(_DWORD *)(v10 + 4 * v12 + 60) & 0x500;
  if ((key.ikey & 0xFF000000) != 0 || !v13)
    goto LABEL_19;
  if (i == -1)
    i = append_field((unsigned int *)header);
  if ((update_field_sizes((uint64_t)header, i, 4u, 0, v3, v4, v5, v6) & 0x80000000) != 0)
  {
    v18 = "update_field_sizes failed";
    v19 = 673;
  }
  else
  {
    v14 = *((_QWORD *)header + 1) + 48 * i;
    *(AAFieldKey *)v14 = key;
    *(_QWORD *)(v14 + 4) = 0x2A00000000;
    *(_QWORD *)(v14 + 40) = 0;
    v23 = 0;
    v24 = 0;
    __src = key;
    __src.skey[3] = 42;
    v17 = v14 + 12;
    v16 = *(unsigned int *)(v14 + 12);
    v15 = *(unsigned int *)(v17 + 4);
    if (v16 + v15 <= *((_QWORD *)header + 2))
    {
      memcpy((void *)(*((_QWORD *)header + 4) + v16), &__src, v15);
      return 0;
    }
    v18 = "invalid blob segment";
    v19 = 684;
  }
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldFlag", v19, 101, 0, v18, v5, v6, v21);
  return -1;
}

uint64_t append_field(unsigned int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v2 = *a1;
  if ((realloc_fields((uint64_t)a1, (int)v2 + 1) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"append_field", 46, 101, 0, "realloc_fields failed", v3, v4, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    ++*a1;
    v5 = *((_QWORD *)a1 + 1);
    if (v5)
      memset_s((void *)(v5 + 48 * v2), 0x30uLL, 0, 0x30uLL);
    v6 = v5 + 48 * v2;
    *(_DWORD *)(v6 + 12) = *((_QWORD *)a1 + 2);
    *(_QWORD *)(v6 + 24) = *((_QWORD *)a1 + 5);
  }
  return v2;
}

int AAHeaderSetFieldUInt(AAHeader header, uint32_t i, AAFieldKey key, uint64_t value)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  const char *v18;
  __int16 v19;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  AAFieldKey __src;
  uint64_t v27;
  uint64_t v28;

  v12 = MEMORY[0x24BDAC740];
  if (key.skey[0] < 0)
  {
    if (!__maskrune(key.skey[0], 0x500uLL))
      goto LABEL_16;
  }
  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * key.skey[0] + 60) & 0x500) == 0)
  {
    goto LABEL_16;
  }
  v13 = *(__int16 *)key.skey >> 8;
  if (((key.ikey << 16) & 0x80000000) != 0)
  {
    if (__maskrune(v13, 0x500uLL))
      goto LABEL_9;
LABEL_16:
    v18 = "invalid key";
    v19 = 691;
    goto LABEL_17;
  }
  if ((*(_DWORD *)(v12 + 4 * v13 + 60) & 0x500) == 0)
    goto LABEL_16;
LABEL_9:
  v14 = (int)(key.ikey << 8) >> 24;
  if (((key.ikey << 8) & 0x80000000) != 0)
    v15 = __maskrune(v14, 0x500uLL);
  else
    v15 = *(_DWORD *)(v12 + 4 * v14 + 60) & 0x500;
  if ((key.ikey & 0xFF000000) != 0 || !v15)
    goto LABEL_16;
  if (value >= 0x100)
  {
    if (value >= 0x10000)
    {
      if (HIDWORD(value))
        v17 = 12;
      else
        v17 = 8;
      if (HIDWORD(value))
        v16 = 56;
      else
        v16 = 52;
    }
    else
    {
      v16 = 50;
      v17 = 6;
    }
  }
  else
  {
    v16 = 49;
    v17 = 5;
  }
  if (i == -1)
    i = append_field((unsigned int *)header);
  if ((update_field_sizes((uint64_t)header, i, v17, 0, v4, v5, v6, v7) & 0x80000000) != 0)
  {
    v18 = "update_field_sizes failed";
    v19 = 701;
  }
  else
  {
    v21 = *((_QWORD *)header + 1) + 48 * i;
    *(AAFieldKey *)v21 = key;
    *(_DWORD *)(v21 + 4) = 1;
    *(_DWORD *)(v21 + 8) = v16;
    *(_QWORD *)(v21 + 40) = value;
    v27 = value;
    v28 = 0;
    __src = key;
    __src.skey[3] = v16;
    v24 = v21 + 12;
    v23 = *(unsigned int *)(v21 + 12);
    v22 = *(unsigned int *)(v24 + 4);
    if (v23 + v22 <= *((_QWORD *)header + 2))
    {
      memcpy((void *)(*((_QWORD *)header + 4) + v23), &__src, v22);
      return 0;
    }
    v18 = "invalid blob segment";
    v19 = 713;
  }
LABEL_17:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldUInt", v19, 101, 0, v18, v6, v7, v25);
  return -1;
}

int AAHeaderSetFieldString(AAHeader header, uint32_t i, AAFieldKey key, const char *value, size_t length)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;

  v13 = MEMORY[0x24BDAC740];
  if (key.skey[0] < 0)
  {
    if (!__maskrune(key.skey[0], 0x500uLL))
      goto LABEL_16;
  }
  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * key.skey[0] + 60) & 0x500) == 0)
  {
    goto LABEL_16;
  }
  v14 = *(__int16 *)key.skey >> 8;
  if (((key.ikey << 16) & 0x80000000) != 0)
  {
    if (__maskrune(v14, 0x500uLL))
      goto LABEL_9;
LABEL_16:
    v17 = "invalid key";
    v18 = 720;
    goto LABEL_17;
  }
  if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x500) == 0)
    goto LABEL_16;
LABEL_9:
  v15 = (int)(key.ikey << 8) >> 24;
  if (((key.ikey << 8) & 0x80000000) != 0)
    v16 = __maskrune(v15, 0x500uLL);
  else
    v16 = *(_DWORD *)(v13 + 4 * v15 + 60) & 0x500;
  if ((key.ikey & 0xFF000000) != 0 || !v16)
    goto LABEL_16;
  if (length >= 0x10000)
  {
    v17 = "string too long";
    v18 = 721;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldString", v18, 101, 0, v17, v6, v7, v27);
    return -1;
  }
  if (i == -1)
    i = append_field((unsigned int *)header);
  if ((update_field_sizes((uint64_t)header, i, (int)length + 6, 0, length, v5, v6, v7) & 0x80000000) != 0)
  {
    v17 = "update_field_sizes failed";
    v18 = 725;
    goto LABEL_17;
  }
  v20 = *((_QWORD *)header + 1) + 48 * i;
  *(AAFieldKey *)v20 = key;
  *(_QWORD *)(v20 + 4) = 0x5000000002;
  *(_QWORD *)(v20 + 40) = length;
  v23 = *(_DWORD *)(v20 + 12);
  v21 = (_DWORD *)(v20 + 12);
  v22 = v23;
  if ((unint64_t)v23 + 6 > *((_QWORD *)header + 2)
    || (v24 = *((_QWORD *)header + 4) + v22,
        *(_DWORD *)v24 = key.ikey & 0xFFFFFF | 0x50000000,
        *(_WORD *)(v24 + 4) = length,
        v25 = (*v21 + 6),
        v25 + length > *((_QWORD *)header + 2)))
  {
    v17 = "invalid blob segment";
    v18 = 738;
    goto LABEL_17;
  }
  v26 = *((_QWORD *)header + 4);
  if (value)
  {
    memcpy((void *)(v26 + v25), value, length);
  }
  else if (v26)
  {
    memset_s((void *)(v26 + v25), length, 0, length);
  }
  return 0;
}

int AAHeaderSetFieldHash(AAHeader header, uint32_t i, AAFieldKey key, AAHashFunction hash_function, const uint8_t *value)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  size_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v27;
  char v28;

  v13 = MEMORY[0x24BDAC740];
  if (key.skey[0] < 0)
  {
    if (!__maskrune(key.skey[0], 0x500uLL))
      goto LABEL_21;
  }
  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * key.skey[0] + 60) & 0x500) == 0)
  {
    goto LABEL_21;
  }
  v14 = *(__int16 *)key.skey >> 8;
  if (((key.ikey << 16) & 0x80000000) != 0)
  {
    if (__maskrune(v14, 0x500uLL))
      goto LABEL_9;
LABEL_21:
    v23 = "invalid key";
    v24 = 745;
    goto LABEL_22;
  }
  if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x500) == 0)
    goto LABEL_21;
LABEL_9:
  v15 = (int)(key.ikey << 8) >> 24;
  if (((key.ikey << 8) & 0x80000000) != 0)
    v16 = __maskrune(v15, 0x500uLL);
  else
    v16 = *(_DWORD *)(v13 + 4 * v15 + 60) & 0x500;
  if ((key.ikey & 0xFF000000) != 0 || !v16)
    goto LABEL_21;
  if (hash_function - 1 >= 5)
  {
    v25 = -1;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldHash", 748, 101, 0, "invalid HASH subtype: %d", v6, v7, -1);
    return v25;
  }
  v17 = dword_20A40C10C[hash_function - 1];
  if (i == -1)
    i = append_field((unsigned int *)header);
  if ((update_field_sizes((uint64_t)header, i, (int)v17 + 4, 0, (uint64_t)value, v5, v6, v7) & 0x80000000) != 0)
  {
    v23 = "update_field_sizes failed";
    v24 = 752;
    goto LABEL_22;
  }
  v18 = *((_QWORD *)header + 1) + 48 * i;
  *(AAFieldKey *)v18 = key;
  *(_DWORD *)(v18 + 4) = 3;
  *(_DWORD *)(v18 + 8) = hash_function + 69;
  *(_QWORD *)(v18 + 40) = v17;
  v21 = *(_DWORD *)(v18 + 12);
  v19 = (_DWORD *)(v18 + 12);
  v20 = v21;
  if ((unint64_t)v21 + 4 > *((_QWORD *)header + 2)
    || (*(_DWORD *)(*((_QWORD *)header + 4) + v20) = key.ikey & 0xFFFFFF | ((hash_function + 69) << 24),
        v22 = (*v19 + 4),
        v22 + v17 > *((_QWORD *)header + 2)))
  {
    v23 = "invalid blob segment";
    v24 = 764;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldHash", v24, 101, 0, v23, v6, v7, v28);
    return -1;
  }
  v27 = *((_QWORD *)header + 4);
  if (value)
  {
    memcpy((void *)(v27 + v22), value, v17);
  }
  else if (v27)
  {
    memset_s((void *)(v27 + v22), v17, 0, v17);
  }
  return 0;
}

int AAHeaderSetFieldTimespec(AAHeader header, uint32_t i, AAFieldKey key, const timespec *value)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t tv_nsec;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  char v26;
  AAFieldKey __src;
  __darwin_time_t tv_sec;
  int v29;
  int v30;

  v12 = MEMORY[0x24BDAC740];
  if (key.skey[0] < 0)
  {
    if (!__maskrune(key.skey[0], 0x500uLL))
      goto LABEL_25;
  }
  else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * key.skey[0] + 60) & 0x500) == 0)
  {
    goto LABEL_25;
  }
  v13 = *(__int16 *)key.skey >> 8;
  if (((key.ikey << 16) & 0x80000000) != 0)
  {
    if (__maskrune(v13, 0x500uLL))
      goto LABEL_9;
LABEL_25:
    v23 = "invalid key";
    v24 = 771;
    goto LABEL_26;
  }
  if ((*(_DWORD *)(v12 + 4 * v13 + 60) & 0x500) == 0)
    goto LABEL_25;
LABEL_9:
  v14 = (int)(key.ikey << 8) >> 24;
  if (((key.ikey << 8) & 0x80000000) != 0)
    v15 = __maskrune(v14, 0x500uLL);
  else
    v15 = *(_DWORD *)(v12 + 4 * v14 + 60) & 0x500;
  if ((key.ikey & 0xFF000000) != 0 || !v15)
    goto LABEL_25;
  if (value->tv_nsec)
    v16 = 16;
  else
    v16 = 12;
  if (value->tv_nsec)
    v17 = 84;
  else
    v17 = 83;
  if (i == -1)
    i = append_field((unsigned int *)header);
  if ((update_field_sizes((uint64_t)header, i, v16, 0, v4, v5, v6, v7) & 0x80000000) != 0)
  {
    v23 = "update_field_sizes failed";
    v24 = 779;
  }
  else
  {
    v18 = *((_QWORD *)header + 1) + 48 * i;
    *(AAFieldKey *)v18 = key;
    *(_DWORD *)(v18 + 4) = 4;
    *(_DWORD *)(v18 + 8) = v17;
    *(_QWORD *)(v18 + 40) = 0;
    __src = key;
    __src.skey[3] = v17;
    tv_nsec = value->tv_nsec;
    tv_sec = value->tv_sec;
    v29 = tv_nsec;
    v30 = 0;
    v22 = v18 + 12;
    v21 = *(unsigned int *)(v18 + 12);
    v20 = *(unsigned int *)(v22 + 4);
    if (v21 + v20 <= *((_QWORD *)header + 2))
    {
      memcpy((void *)(*((_QWORD *)header + 4) + v21), &__src, v20);
      return 0;
    }
    v23 = "invalid blob segment";
    v24 = 792;
  }
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderSetFieldTimespec", v24, 101, 0, v23, v6, v7, v26);
  return -1;
}

