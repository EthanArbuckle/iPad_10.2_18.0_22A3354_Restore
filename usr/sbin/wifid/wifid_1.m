BOOL sub_1000A14B8(uint64_t a1, uint64_t a2)
{
  void *v4;
  _BOOL8 v5;

  v4 = objc_autoreleasePoolPush();
  v5 = 0;
  if (a1 && a2)
  {
    if (objc_msgSend(*(id *)(a1 + 1696), "isAuthorized"))
      v5 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", a2, 0, 3600.0) != 0;
    else
      v5 = 0;
  }
  objc_autoreleasePoolPop(v4);
  return v5;
}

id sub_1000A1538(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;
  void *v7;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerCopyGeoTagsForNetwork");
    goto LABEL_9;
  }
  if (!a2)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is NULL", "WiFiManagerCopyGeoTagsForNetwork");
LABEL_9:
    objc_autoreleasePoolPop(v7);
    v5 = 0;
    goto LABEL_4;
  }
  v5 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyGeoTagsForNetworkAtLocation:location:", a2, objc_msgSend(*(id *)(a1 + 1696), "latestLocation"));
LABEL_4:
  objc_autoreleasePoolPop(v4);
  return v5;
}

void sub_1000A1624(uint64_t a1, const void *a2, double a3, double a4)
{
  void *v8;
  id v9;
  void *v10;

  v8 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerSetGeoTagForNetwork");
    goto LABEL_17;
  }
  if (!a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is NULL", "WiFiManagerSetGeoTagForNetwork");
    goto LABEL_17;
  }
  if (a3 < -90.0 || a3 > 90.0)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid latitude value", "WiFiManagerSetGeoTagForNetwork");
    goto LABEL_17;
  }
  if (a4 < -180.0 || a4 > 180.0)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid longitude value", "WiFiManagerSetGeoTagForNetwork");
LABEL_17:
    objc_autoreleasePoolPop(v10);
    goto LABEL_8;
  }
  v9 = objc_msgSend(objc_alloc((Class)CLLocation), "initWithLatitude:longitude:", a3, a4);
  sub_10005E1F8(a2, v9);

LABEL_8:
  objc_autoreleasePoolPop(v8);
}

id sub_1000A17B4(uint64_t a1, int a2, double a3, double a4)
{
  void *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  void *v14;

  v8 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerCopyNetworksAtLocation");
    goto LABEL_17;
  }
  if (a3 < -90.0 || a3 > 90.0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid latitude value", "WiFiManagerCopyNetworksAtLocation");
    goto LABEL_17;
  }
  if (a4 < -180.0 || a4 > 180.0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid longitude value", "WiFiManagerCopyNetworksAtLocation");
LABEL_17:
    objc_autoreleasePoolPop(v14);
    v12 = 0;
    goto LABEL_10;
  }
  v9 = objc_msgSend(objc_alloc((Class)CLLocation), "initWithLatitude:longitude:", a3, a4);
  v10 = +[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager");
  if (a2)
    v11 = objc_msgSend(v10, "copyScoreSortedNetworksAvailableAtLocation:", v9);
  else
    v11 = objc_msgSend(v10, "copyNetworksAvailableAtLocation:", v9);
  v12 = v11;

LABEL_10:
  objc_autoreleasePoolPop(v8);
  return v12;
}

id sub_1000A1934(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;
  void *v7;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerCopyScoreForNetwork");
    goto LABEL_9;
  }
  if (!a2)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is NULL", "WiFiManagerCopyScoreForNetwork");
LABEL_9:
    objc_autoreleasePoolPop(v7);
    v5 = 0;
    goto LABEL_4;
  }
  v5 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyPreferenceScoreDictionaryForNetwork:", a2);
LABEL_4:
  objc_autoreleasePoolPop(v4);
  return v5;
}

id sub_1000A1A0C(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  id v5;
  NSNumber *v6;
  double v7;
  NSNumber *v8;
  double v9;
  NSNumber *v10;
  double v11;
  id v12;
  void *v14;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerCopyLeechedLocation");
    goto LABEL_9;
  }
  v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1696), "latestLocation"), "copy");
  if (!v3)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: location is NULL", "WiFiManagerCopyLeechedLocation");
LABEL_9:
    objc_autoreleasePoolPop(v14);
    v12 = 0;
    goto LABEL_4;
  }
  v4 = v3;
  v5 = objc_alloc((Class)NSDictionary);
  objc_msgSend(v4, "coordinate");
  v6 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  objc_msgSend(v4, "coordinate");
  v8 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v7);
  objc_msgSend(v4, "horizontalAccuracy");
  v10 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (int)v9);
  objc_msgSend(objc_msgSend(v4, "timestamp"), "timeIntervalSinceNow");
  v12 = objc_msgSend(v5, "initWithObjectsAndKeys:", v6, CFSTR("latitude"), v8, CFSTR("longitude"), v10, CFSTR("accuracy"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (int)v11), CFSTR("staleness"), 0);

LABEL_4:
  objc_autoreleasePoolPop(v2);
  return v12;
}

void sub_1000A1BAC(uint64_t a1, double a2)
{
  void *v3;
  uint64_t v4;

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerRemoveUnusedNetworkGeotags", v4);
    goto LABEL_8;
  }
  if (a2 <= 0.0)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid geoTagsUnusedRetentionPeriodInSeconds %f", "WiFiManagerRemoveUnusedNetworkGeotags", *(_QWORD *)&a2);
LABEL_8:
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000A1C64(uint64_t a1, uint64_t a2, double a3)
{
  void *v4;
  uint64_t v5;

  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerScheduleUnusedNetworkGeotagsRemovalTest", v5);
    goto LABEL_11;
  }
  if (a3 <= 0.0)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid geoTagsUnusedRetentionPeriodInSeconds %f", "WiFiManagerScheduleUnusedNetworkGeotagsRemovalTest", *(_QWORD *)&a3);
    goto LABEL_11;
  }
  if (!a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid intervalMinutes %lu", "WiFiManagerScheduleUnusedNetworkGeotagsRemovalTest", 0);
LABEL_11:
    objc_autoreleasePoolPop(v4);
  }
}

void sub_1000A1D50(uint64_t a1)
{
  void *v1;

  if (!a1)
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerUnScheduleUnusedNetworkGeotagsRemovalTest");
    objc_autoreleasePoolPop(v1);
  }
}

__CFDictionary *sub_1000A1DB0(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v3;
  char *v4;
  char *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  void *v26;
  void *v27;

  if (!*(_QWORD *)(a1 + 1728))
    return 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Failed to allocate dictionary for SoftError Counters", "WiFiManagerCopySoftErrorCounters");
    objc_autoreleasePoolPop(v27);
    return 0;
  }
  v3 = Mutable;
  v4 = (char *)sub_10003C39C(*(void **)(a1 + 1728));
  if (!v4)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: errorCountersRef recived from softErrorManager is NULL! ", "WiFiManagerCopySoftErrorCounters");
    goto LABEL_17;
  }
  v5 = v4;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v4);
  if (!v6)
    goto LABEL_15;
  v7 = v6;
  CFDictionaryAddValue(v3, CFSTR("WiFiToggleErrorCounter"), v6);
  CFRelease(v7);
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 28);
  if (!v8)
    goto LABEL_15;
  v9 = v8;
  CFDictionaryAddValue(v3, CFSTR("WiFiToggleErrorUserConfirmCounter"), v8);
  CFRelease(v9);
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 4);
  if (!v10)
    goto LABEL_15;
  v11 = v10;
  CFDictionaryAddValue(v3, CFSTR("WiFiNoNetworksFoundErrorCounter"), v10);
  CFRelease(v11);
  v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 32);
  if (!v12)
    goto LABEL_15;
  v13 = v12;
  CFDictionaryAddValue(v3, CFSTR("WiFiNoNetworksFoundErrorUserConfirmCounter"), v12);
  CFRelease(v13);
  v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 8);
  if (!v14)
    goto LABEL_15;
  v15 = v14;
  CFDictionaryAddValue(v3, CFSTR("WiFiSlowAutoJoinErrorCounter"), v14);
  CFRelease(v15);
  v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 36);
  if (!v16)
    goto LABEL_15;
  v17 = v16;
  CFDictionaryAddValue(v3, CFSTR("WiFiSlowAutoJoinErrorUserConfirmCounter"), v16);
  CFRelease(v17);
  v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 12);
  if (!v18)
    goto LABEL_15;
  v19 = v18;
  CFDictionaryAddValue(v3, CFSTR("WiFiTxDataStallErrorCounter"), v18);
  CFRelease(v19);
  v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 40);
  if (!v20)
    goto LABEL_15;
  v21 = v20;
  CFDictionaryAddValue(v3, CFSTR("WiFiTxDataStallErrorUserConfirmCounter"), v20);
  CFRelease(v21);
  v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 16);
  if (!v22
    || (v23 = v22,
        CFDictionaryAddValue(v3, CFSTR("WiFiRxDataStallErrorCounter"), v22),
        CFRelease(v23),
        (v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v5 + 44)) == 0))
  {
LABEL_15:
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: numRef create failed!", "WiFiManagerCopySoftErrorCounters");
LABEL_17:
    objc_autoreleasePoolPop(v26);
    return v3;
  }
  v25 = v24;
  CFDictionaryAddValue(v3, CFSTR("WiFiRxDataStallErrorUserConfirmCounter"), v24);
  CFRelease(v25);
  return v3;
}

id sub_1000A20E4(uint64_t a1)
{
  void *v1;
  void *v3;

  if (a1)
  {
    v1 = *(void **)(a1 + 1728);
    if (v1)
      return sub_10003C39C(v1);
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softError manager is NULL!", "WiFiManagerGetSoftErrorCounters");
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "WiFiManagerGetSoftErrorCounters");
  }
  objc_autoreleasePoolPop(v3);
  return 0;
}

uint64_t sub_1000A2190(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t result;
  void *v5;

  if (a1)
  {
    if (a2 && a3)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 1408);
      *a3 = *(_QWORD *)(a1 + 1416);
      return result;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Params Null", "WiFiManagerGetMotionState");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerGetMotionState");
  }
  objc_autoreleasePoolPop(v5);
  return 4294963396;
}

_WORD *sub_1000A2248(const __CFArray *a1)
{
  void *v2;
  uint64_t v3;
  CFDictionaryRef v4;
  _WORD *v5;
  void *v6;
  void *v7;
  void *v9;

  if (a1)
  {
    v2 = sub_10009FEE0(a1);
    v3 = *((_QWORD *)a1 + 207);
    if (v3)
    {
      v4 = sub_1000173C0(v3);
      v5 = sub_10002B314((uint64_t)kCFAllocatorDefault, v4);
      if (v2 && CFEqual(v2, v5))
        sub_10002B290((uint64_t)v5, (uint64_t)v2);
      if (v4)
        CFRelease(v4);
      if (!v2)
        return v5;
LABEL_18:
      CFRelease(v2);
      return v5;
    }
    if (v2 && sub_1000CEDAC((uint64_t)v2))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: session based network is an accessory = '%@'", "WiFiManagerCopyCurrentSessionBasedNetwork", v2);
      objc_autoreleasePoolPop(v6);
      CFRetain(v2);
      v5 = v2;
      goto LABEL_18;
    }
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: session based network is NULL", "WiFiManagerCopyCurrentSessionBasedNetwork");
    objc_autoreleasePoolPop(v7);
    v5 = 0;
    if (v2)
      goto LABEL_18;
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerCopyCurrentSessionBasedNetwork");
    objc_autoreleasePoolPop(v9);
    return 0;
  }
  return v5;
}

uint64_t sub_1000A23CC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 200);
}

void sub_1000A23D4(uint64_t a1)
{
  void *v1;
  _QWORD context[4];

  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000046;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifiManagerRef is NULL!", "WiFiManagerSubmitWoWBlacklistingHistory");
    objc_autoreleasePoolPop(v1);
  }
}

BOOL sub_1000A246C(const __CFArray *a1)
{
  void *v1;
  void *v2;

  v1 = sub_10009FEE0(a1);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2 != 0;
}

uint64_t sub_1000A24A0(const __CFArray *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  int v6;
  const void *ValueAtIndex;
  uint64_t v8;
  void *v10;

  if (!a1)
  {
LABEL_14:
    LOBYTE(v6) = 0;
    return v6;
  }
  v1 = sub_10000B29C(a1);
  if (!v1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "WiFiManagerIsAnyWiFiInterfacePrimary");
    objc_autoreleasePoolPop(v10);
    goto LABEL_14;
  }
  v2 = v1;
  Count = CFArrayGetCount(v1);
  if (Count < 1)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    v4 = Count;
    v5 = 0;
    v6 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, v5);
      v8 = sub_1000161D4((uint64_t)ValueAtIndex);
      if (v8 && sub_100029860(v8))
        v6 |= sub_1001234DC((uint64_t)ValueAtIndex);
      ++v5;
    }
    while (v4 != v5);
  }
  CFRelease(v2);
  return v6;
}

CFTypeRef sub_1000A258C(uint64_t a1, const void *a2, const void *a3)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *NetworkServiceEntity;
  const __CFString *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  CFTypeRef v11;

  v4 = (const __CFString *)sub_1000A2660(a1, a2, a3);
  if (!v4)
    return 0;
  v5 = v4;
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, v4, kSCEntNetIPv4);
  if (!NetworkServiceEntity)
  {
    v11 = 0;
    v9 = (const __CFDictionary *)v5;
LABEL_7:
    CFRelease(v9);
    return v11;
  }
  v7 = NetworkServiceEntity;
  v8 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 72), NetworkServiceEntity);
  v9 = v8;
  if (v8 && (Value = CFDictionaryGetValue(v8, kSCPropNetIPv4ConfigMethod)) != 0)
    v11 = CFRetain(Value);
  else
    v11 = 0;
  CFRelease(v5);
  CFRelease(v7);
  if (v9)
    goto LABEL_7;
  return v11;
}

CFTypeRef sub_1000A2660(uint64_t a1, const void *a2, const void *a3)
{
  const __CFDictionary *v5;
  const void *v6;
  const void *Value;
  CFArrayRef v8;
  const __CFArray *v9;
  CFIndex v10;
  const __SCNetworkSet *v11;
  const __SCNetworkSet *ValueAtIndex;
  const __SCNetworkSet *v13;
  CFStringRef Name;
  CFStringRef SetID;
  CFArrayRef v16;
  const __CFArray *v17;
  const __CFArray *ServiceOrder;
  const __CFArray *v19;
  CFIndex v20;
  CFStringRef v21;
  CFIndex v22;
  int Enabled;
  const __SCNetworkService *v24;
  const __SCNetworkService *v25;
  CFStringRef ServiceID;
  CFStringRef v27;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v29;
  CFStringRef BSDName;
  CFTypeRef v31;
  const __CFArray *v33;

  v5 = *(const __CFDictionary **)(a1 + 208);
  if (v5)
  {
    v6 = sub_10002B088(a3);
    Value = CFDictionaryGetValue(v5, v6);
  }
  else
  {
    Value = 0;
  }
  v8 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 1064));
  if (!v8)
    return 0;
  v9 = v8;
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 1064));
  if (CFArrayGetCount(v9) < 1)
    goto LABEL_40;
  v10 = 0;
  v11 = 0;
  do
  {
    ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v9, v10);
    if (ValueAtIndex)
    {
      v13 = ValueAtIndex;
      Name = SCNetworkSetGetName(ValueAtIndex);
      SetID = SCNetworkSetGetSetID(v13);
      if (SetID && Value && CFEqual(SetID, Value))
        goto LABEL_16;
      if (Name && CFEqual(Name, CFSTR("Automatic")))
        v11 = v13;
    }
    ++v10;
  }
  while (v10 < CFArrayGetCount(v9));
  v13 = v11;
  if (!v11)
    goto LABEL_40;
LABEL_16:
  v16 = SCNetworkSetCopyServices(v13);
  if (v16)
  {
    v17 = v16;
    ServiceOrder = SCNetworkSetGetServiceOrder(v13);
    if (!ServiceOrder)
      goto LABEL_38;
    v19 = ServiceOrder;
    if (CFArrayGetCount(ServiceOrder) < 1)
      goto LABEL_38;
    v20 = 0;
    v21 = 0;
    v33 = v9;
    do
    {
      if (CFArrayGetValueAtIndex(v19, v20) && CFArrayGetCount(v17) >= 1)
      {
        v22 = 0;
        Enabled = 0;
        do
        {
          v24 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v17, v22);
          if (v24)
          {
            v25 = v24;
            ServiceID = SCNetworkServiceGetServiceID(v24);
            if (ServiceID)
            {
              v27 = ServiceID;
              Interface = SCNetworkServiceGetInterface(v25);
              if (Interface)
              {
                do
                {
                  v29 = Interface;
                  Interface = SCNetworkInterfaceGetInterface(Interface);
                }
                while (Interface);
                BSDName = SCNetworkInterfaceGetBSDName(v29);
                if (BSDName)
                {
                  if (CFEqual(BSDName, a2))
                  {
                    Enabled = SCNetworkServiceGetEnabled(v25);
                    if (Enabled)
                      v21 = v27;
                  }
                }
              }
            }
          }
          ++v22;
        }
        while (CFArrayGetCount(v17) > v22);
      }
      else
      {
        Enabled = 0;
      }
      ++v20;
      v9 = v33;
    }
    while (CFArrayGetCount(v19) > v20 && !Enabled);
    if (v21)
      v31 = CFRetain(v21);
    else
LABEL_38:
      v31 = 0;
    CFRelease(v17);
  }
  else
  {
LABEL_40:
    v31 = 0;
  }
  CFRelease(v9);
  return v31;
}

CFTypeRef sub_1000A28AC(uint64_t a1, const void *a2, const void *a3)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *NetworkServiceEntity;
  const __CFString *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  CFTypeRef v11;

  v4 = (const __CFString *)sub_1000A2660(a1, a2, a3);
  if (!v4)
    return 0;
  v5 = v4;
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, v4, kSCEntNetIPv6);
  if (!NetworkServiceEntity)
  {
    v11 = 0;
    v9 = (const __CFDictionary *)v5;
LABEL_7:
    CFRelease(v9);
    return v11;
  }
  v7 = NetworkServiceEntity;
  v8 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 72), NetworkServiceEntity);
  v9 = v8;
  if (v8 && (Value = CFDictionaryGetValue(v8, kSCPropNetIPv6ConfigMethod)) != 0)
    v11 = CFRetain(Value);
  else
    v11 = 0;
  CFRelease(v5);
  CFRelease(v7);
  if (v9)
    goto LABEL_7;
  return v11;
}

uint64_t sub_1000A2980(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 1064);
  return result;
}

void sub_1000A298C(uint64_t a1)
{
  const __CFDictionary *v2;
  __CFArray *Mutable;
  void *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __SCNetworkSet *v7;
  const __CFString *Name;
  CFIndex v9;
  __CFArray *v10;
  const __SCNetworkSet *ValueAtIndex;
  const __SCNetworkSet *v12;
  const __CFString *v13;
  CFStringRef SetID;
  CFStringRef v15;
  void *v16;
  void *v17;
  const __SCPreferences *v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex v21;
  const __SCNetworkSet *v22;
  const __SCNetworkSet *v23;
  CFStringRef v24;
  void *v25;
  _BOOL4 v26;
  unsigned int v27;
  void *v28;
  NSObject *v29;
  int v30;
  const char *v31;
  void *v32;
  void *v33;
  const char *v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  __CFArray *v39;
  void *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  const __SCNetworkSet *cf;
  int v45;
  __CFArray *v46;
  _QWORD block[5];

  v2 = *(const __CFDictionary **)(a1 + 208);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiManagerRemoveOrphanedSCNetworkSets");
  objc_autoreleasePoolPop(v4);
  v5 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 1064));
  v6 = v5;
  if (!v5 || !CFArrayGetCount(v5))
  {
    v39 = Mutable;
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid scSets", "WiFiManagerRemoveOrphanedSCNetworkSets");
    objc_autoreleasePoolPop(v40);
    Mutable = v39;
    if (v6)
      goto LABEL_61;
    goto LABEL_62;
  }
  v7 = SCNetworkSetCopyCurrent(*(SCPreferencesRef *)(a1 + 1064));
  cf = v7;
  if (v7)
    Name = SCNetworkSetGetName(v7);
  else
    Name = 0;
  if (CFArrayGetCount(v6) < 1)
  {
    v10 = 0;
    goto LABEL_56;
  }
  v43 = a1;
  v46 = Mutable;
  v9 = 0;
  v45 = 0;
  v10 = 0;
  do
  {
    ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v6, v9);
    if (!ValueAtIndex)
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid set", "WiFiManagerRemoveOrphanedSCNetworkSets", v41);
      goto LABEL_21;
    }
    v12 = ValueAtIndex;
    v13 = SCNetworkSetGetName(ValueAtIndex);
    if (v13)
    {
      if (CFStringCompare(CFSTR("Automatic"), v13, 0) == kCFCompareEqualTo)
      {
        sub_1000A2FD0(Mutable, v12);
        v45 = 1;
        goto LABEL_28;
      }
      if (Name && CFStringCompare(Name, v13, 0) == kCFCompareEqualTo)
      {
        sub_1000A2FD0(Mutable, v12);
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set <%@> currently in use, skip", "WiFiManagerRemoveOrphanedSCNetworkSets", v13);
LABEL_21:
        objc_autoreleasePoolPop(v16);
        goto LABEL_28;
      }
    }
    SetID = SCNetworkSetGetSetID(v12);
    if (SetID)
    {
      v15 = SetID;
      if (v2 && CFDictionaryContainsValue(v2, SetID))
      {
        sub_1000A2FD0(Mutable, v12);
      }
      else
      {
        if (!v10)
          v10 = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks);
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: adding to purge list %@<%@>", "WiFiManagerRemoveOrphanedSCNetworkSets", v15, v13);
        objc_autoreleasePoolPop(v17);
        CFArrayAppendValue(v10, v12);
      }
    }
LABEL_28:
    ++v9;
  }
  while (CFArrayGetCount(v6) > v9);
  if (!v45)
    goto LABEL_56;
  v18 = *(const __SCPreferences **)(v43 + 1064);
  if (!v18)
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null prefs ref", "__WiFiManagerRemoveSCNetworkSets", v41);
    goto LABEL_74;
  }
  if (!v10 || (Count = CFArrayGetCount(v10), Count < 1))
  {
LABEL_54:
    v29 = *(NSObject **)(v43 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000BACF0;
    block[3] = &unk_10022EA38;
    block[4] = v43;
    dispatch_async(v29, block);
    goto LABEL_56;
  }
  v20 = Count;
  v21 = 0;
  while (2)
  {
    v22 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v10, v21);
    if (!v22)
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid set", "__WiFiManagerRemoveSCNetworkSets", v41);
LABEL_53:
      objc_autoreleasePoolPop(v25);
      if (v20 == ++v21)
        goto LABEL_54;
      continue;
    }
    break;
  }
  v23 = v22;
  if (SCNetworkSetGetName(v22))
  {
    v24 = SCNetworkSetGetName(v23);
    if (CFEqual(v24, CFSTR("Automatic")))
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping automatic set from removal! automatic/custom network set ID: %@", "__WiFiManagerRemoveSCNetworkSets", SCNetworkSetGetSetID(v23));
      goto LABEL_53;
    }
  }
  v26 = sub_1000BAB18(v23, Mutable);
  v27 = SCNetworkSetRemove(v23);
  v28 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set removal status for %@: %d", "__WiFiManagerRemoveSCNetworkSets", SCNetworkSetGetSetID(v23), v27);
  objc_autoreleasePoolPop(v28);
  if (!(v26 | v27))
  {
    v25 = objc_autoreleasePoolPush();
    Mutable = v46;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no change", "__WiFiManagerRemoveSCNetworkSets", v41);
    goto LABEL_53;
  }
  Mutable = v46;
  if (!SCPreferencesCommitChanges(v18))
  {
    v30 = SCError();
    v31 = SCErrorString(v30);
    v32 = objc_autoreleasePoolPush();
    v33 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_74;
    v34 = "SCError Unavailable";
    if (v31)
      v34 = v31;
    v42 = v34;
    v35 = "%s: failed to commit changes %s";
    goto LABEL_73;
  }
  if (SCPreferencesApplyChanges(v18))
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: processed set(%@) and its associated services", "__WiFiManagerRemoveSCNetworkSets", SCNetworkSetGetSetID(v23));
    goto LABEL_53;
  }
  v36 = SCError();
  v37 = SCErrorString(v36);
  v32 = objc_autoreleasePoolPush();
  v33 = (void *)qword_10026DD20;
  if (!qword_10026DD20)
    goto LABEL_74;
  v38 = "SCError Unavailable";
  if (v37)
    v38 = v37;
  v42 = v38;
  v35 = "%s: failed to apply changes %s";
LABEL_73:
  objc_msgSend(v33, "WFLog:message:", 4, v35, "__WiFiManagerRemoveSCNetworkSets", v42);
LABEL_74:
  objc_autoreleasePoolPop(v32);
  Mutable = v46;
LABEL_56:
  if (cf)
    CFRelease(cf);
  if (v10)
    CFRelease(v10);
  if (v6)
LABEL_61:
    CFRelease(v6);
LABEL_62:
  if (Mutable)
    CFRelease(Mutable);
}

void sub_1000A2FD0(__CFArray *a1, const __SCNetworkSet *a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  void *v6;
  id v7;
  CFRange v8;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null list.", "__WiFiManagerHelperAddNetworkServicesFromSetToList");
    goto LABEL_12;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null set.", "__WiFiManagerHelperAddNetworkServicesFromSetToList");
LABEL_12:
    objc_autoreleasePoolPop(v6);
    return;
  }
  v7 = (id)sub_10001E1C8((uint64_t)"__WiFiManagerHelperAddNetworkServicesFromSetToList");
  v4 = SCNetworkSetCopyServices(a2);
  if (v4)
  {
    v5 = v4;
    if (CFArrayGetCount(v4))
    {
      v8.length = CFArrayGetCount(v5);
      v8.location = 0;
      CFArrayAppendArray(a1, v5, v8);
    }

    CFRelease(v5);
  }
  else
  {

  }
}

void sub_1000A30DC(_QWORD *a1)
{
  void *v2;
  void *v3;
  NSMutableArray *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  uint64_t v9;
  double v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *j;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  _BYTE v25[128];

  v2 = objc_autoreleasePoolPush();
  v3 = (void *)a1[202];
  v4 = objc_opt_new(NSMutableArray);
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v20, v25, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v21;
    do
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(_QWORD *)v21 != v7)
          objc_enumerationMutation(v3);
        v9 = *(_QWORD *)(*((_QWORD *)&v20 + 1) + 8 * (_QWORD)i);
        objc_msgSend(objc_msgSend(objc_msgSend(v3, "objectForKeyedSubscript:", v9), "objectForKeyedSubscript:", CFSTR("timestamp")), "timeIntervalSinceNow");
        if (v10 < -21600.0)
          -[NSMutableArray addObject:](v4, "addObject:", v9);
      }
      v6 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v20, v25, 16);
    }
    while (v6);
  }
  if (-[NSMutableArray count](v4, "count"))
  {
    v11 = objc_msgSend(v3, "mutableCopy");
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v19 = 0u;
    v12 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v4, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
    if (v12)
    {
      v13 = v12;
      v14 = *(_QWORD *)v17;
      do
      {
        for (j = 0; j != v13; j = (char *)j + 1)
        {
          if (*(_QWORD *)v17 != v14)
            objc_enumerationMutation(v4);
          objc_msgSend(v11, "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)j));
        }
        v13 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v4, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
      }
      while (v13);
    }
    sub_100087488(a1, CFSTR("SessionBasedNetworkList"), v11, 0);
    sub_1000A3300((uint64_t)a1, v11);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000A3300(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  const void *v5;
  void *v6;

  if (a1)
  {
    if (!cf || (v4 = *(const void **)(a1 + 1616)) == 0 || !CFEqual(cf, v4))
    {
      v5 = *(const void **)(a1 + 1616);
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(a1 + 1616) = 0;
      }
      if (cf)
        *(_QWORD *)(a1 + 1616) = CFRetain(cf);
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "__WiFiManagerSetSessionBasedNetworkList");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_1000A33AC(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  uint64_t v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  _UNKNOWN **v17;
  double v18;
  void *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *j;
  void *v26;
  uint64_t v27;
  void *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[128];
  _BYTE v38[128];

  if (a1)
  {
    v2 = *(void **)(a1 + 2192);
    if (v2)
    {
      if (objc_msgSend(*(id *)(a1 + 2192), "count"))
      {
        v3 = objc_autoreleasePoolPush();
        v33 = 0u;
        v34 = 0u;
        v35 = 0u;
        v36 = 0u;
        v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v33, v38, 16);
        if (!v4)
          goto LABEL_34;
        v5 = v4;
        v26 = v3;
        v27 = a1;
        v28 = 0;
        v6 = *(_QWORD *)v34;
        do
        {
          for (i = 0; i != v5; i = (char *)i + 1)
          {
            if (*(_QWORD *)v34 != v6)
              objc_enumerationMutation(v2);
            v8 = *(_QWORD *)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)i);
            v9 = objc_msgSend(v2, "objectForKey:", v8);
            v10 = objc_msgSend(v9, "objectForKey:", CFSTR("type"));
            if (v10)
            {
              v11 = v10;
              v12 = objc_msgSend(v9, "objectForKey:", CFSTR("notificationType"));
              if (v12)
              {
                v13 = v12;
                v14 = objc_msgSend(v11, "unsignedIntValue");
                v15 = objc_msgSend(v13, "unsignedIntValue");
                v16 = objc_msgSend(v9, "objectForKey:", CFSTR("timestamp"));
                v17 = (_UNKNOWN **)objc_msgSend(v9, "objectForKey:", CFSTR("count"));
                if (v16)
                {
                  if (!v17)
                    v17 = &off_100252D20;
                  if (+[WiFiUserNotificationManager canRepromptForNotificationType:blacklistType:atDate:count:](WiFiUserNotificationManager, "canRepromptForNotificationType:blacklistType:atDate:count:", v15, v14, v16, objc_msgSend(v17, "integerValue")))
                  {
                    objc_msgSend(v16, "timeIntervalSinceDate:", +[NSDate date](NSDate, "date"));
                    if (v18 > 2592000.0)
                    {
                      v19 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing ssid: %@ timestamp: %@ notificationType: %d", "WiFiManagerRemoveOldUserBlackListEntries", v8, v16, v15);
                      objc_autoreleasePoolPop(v19);
                      v20 = v28;
                      if (!v28)
                        v20 = objc_alloc_init((Class)NSMutableArray);
                      v28 = v20;
                      objc_msgSend(v20, "addObject:", v8);
                    }
                  }
                }
              }
            }
          }
          v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v33, v38, 16);
        }
        while (v5);
        v3 = v26;
        if (v28)
        {
          v21 = objc_msgSend(v2, "mutableCopy");
          v29 = 0u;
          v30 = 0u;
          v31 = 0u;
          v32 = 0u;
          v22 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v29, v37, 16);
          if (v22)
          {
            v23 = v22;
            v24 = *(_QWORD *)v30;
            do
            {
              for (j = 0; j != v23; j = (char *)j + 1)
              {
                if (*(_QWORD *)v30 != v24)
                  objc_enumerationMutation(v28);
                objc_msgSend(v21, "removeObjectForKey:", *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)j));
              }
              v23 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v29, v37, 16);
            }
            while (v23);
          }
          -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v21, CFSTR("UserNotificationBlacklist"));
          sub_1000A371C(v27, v21);
          if (v21)
            CFRelease(v21);
          objc_autoreleasePoolPop(v26);
          CFRelease(v28);
        }
        else
        {
LABEL_34:
          objc_autoreleasePoolPop(v3);
        }
      }
    }
  }
}

void sub_1000A371C(uint64_t a1, CFTypeRef cf)
{
  void *v4;
  const void *v5;
  void *v6;
  uint64_t v7;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "__WiFiManagerSetUserNotificationBlacklist", v7);
    goto LABEL_14;
  }
  v4 = *(void **)(a1 + 2192);
  if (!cf || !v4)
  {
    if (!cf)
    {
      if (v4)
      {
        CFRelease(v4);
        v4 = 0;
      }
      goto LABEL_12;
    }
LABEL_11:
    v4 = (void *)CFRetain(cf);
LABEL_12:
    *(_QWORD *)(a1 + 2192) = v4;
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updating blacklist: %@", "__WiFiManagerSetUserNotificationBlacklist", cf);
LABEL_14:
    objc_autoreleasePoolPop(v6);
    return;
  }
  if ((objc_msgSend(v4, "isEqualToDictionary:", cf) & 1) == 0)
  {
    v5 = *(const void **)(a1 + 2192);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 2192) = 0;
    }
    goto LABEL_11;
  }
}

void sub_1000A380C(uint64_t a1)
{
  uint64_t v1;
  NSString *const **v2;
  double v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  double v8;
  const __SCPreferences *v9;
  const __SCPreferences *v10;
  void *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFPropertyListRef Value;
  int v15;
  uint64_t v16;
  int v17;
  void *v18;
  void *v19;
  double v20;
  double v21;
  double v22;
  void *v23;
  const __CFArray *v24;
  __CFArray *v25;
  const __CFArray *v26;
  id v27;
  CFIndex v28;
  CFDictionaryRef *ValueAtIndex;
  void *v30;
  void *v31;
  NSDate *v32;
  id v33;
  id v34;
  NSString *v35;
  void *v36;
  void *v37;
  double v38;
  double v39;
  double v40;
  id v41;
  id v42;
  id v43;
  id v44;
  uint64_t v45;
  void *i;
  uint64_t v47;
  id v48;
  id v49;
  void *v50;
  void *v51;
  void *v52;
  double v53;
  double v54;
  double v55;
  id v56;
  id v57;
  id v58;
  id v59;
  uint64_t v60;
  void *j;
  uint64_t v62;
  id v63;
  CFDictionaryRef *v64;
  CFDictionaryRef *v65;
  void *v66;
  void *v67;
  void *v68;
  id v69;
  void *v70;
  void *v71;
  void *v72;
  double v73;
  void *v74;
  void *v75;
  double v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *context;
  void *v83;
  void *v84;
  void *v85;
  uint64_t v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  _BYTE v95[128];
  _BYTE v96[128];
  CFRange v97;

  if (a1)
  {
    v1 = a1;
    v2 = &ACAccountStoreDidChangeNotification_ptr;
    +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
    v4 = v3;
    v5 = (uint64_t)-[__SCPreferences integerValue](sub_10001D90C((_QWORD *)v1, CFSTR("Version")), "integerValue");
    v6 = v5;
    v86 = v1;
    if (v5 > 11)
    {
      if ((unint64_t)v5 > 0xD)
      {
LABEL_44:
        if (v6 <= 14)
        {
          v84 = (void *)v6;
          context = objc_autoreleasePoolPush();
          objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
          v40 = v39;
          v41 = objc_msgSend(*(id *)(v1 + 1104), "dictionaryRepresentation");
          v91 = 0u;
          v92 = 0u;
          v93 = 0u;
          v94 = 0u;
          v42 = objc_msgSend(v41, "allKeys");
          v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v91, v96, 16);
          if (v43)
          {
            v44 = v43;
            v45 = *(_QWORD *)v92;
            do
            {
              for (i = 0; i != v44; i = (char *)i + 1)
              {
                if (*(_QWORD *)v92 != v45)
                  objc_enumerationMutation(v42);
                v47 = *(_QWORD *)(*((_QWORD *)&v91 + 1) + 8 * (_QWORD)i);
                v48 = objc_msgSend(v41, "objectForKeyedSubscript:", v47);
                v49 = objc_msgSend(objc_alloc((Class)CWFNetworkProfile), "initWithExternalForm:", v48);
                if (v49)
                {
                  v50 = v49;
                  objc_msgSend(*(id *)(v86 + 1104), "setObject:forKey:", 0, v47);
                  objc_msgSend(*(id *)(v86 + 1104), "setObject:forKey:", v48, objc_msgSend(v50, "identifier"));
                }
              }
              v44 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v91, v96, 16);
            }
            while (v44);
          }
          v1 = v86;
          objc_msgSend(*(id *)(v86 + 1104), "synchronize");
          v51 = objc_autoreleasePoolPush();
          v52 = (void *)qword_10026DD20;
          v2 = &ACAccountStoreDidChangeNotification_ptr;
          if (qword_10026DD20)
          {
            +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
            objc_msgSend(v52, "WFLog:message:", 3, "%s: Remove duplicate PNL entries took %fs", "WiFiManagerMigratePNL", v53 - v40);
          }
          objc_autoreleasePoolPop(v51);
          objc_autoreleasePoolPop(context);
          v6 = (uint64_t)v84;
        }
        if (v6 <= 22)
        {
          v85 = objc_autoreleasePoolPush();
          objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
          v55 = v54;
          v56 = objc_msgSend(*(id *)(v1 + 1104), "dictionaryRepresentation");
          v87 = 0u;
          v88 = 0u;
          v89 = 0u;
          v90 = 0u;
          v57 = objc_msgSend(v56, "allKeys");
          v58 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v87, v95, 16);
          if (v58)
          {
            v59 = v58;
            v60 = *(_QWORD *)v88;
            do
            {
              for (j = 0; j != v59; j = (char *)j + 1)
              {
                if (*(_QWORD *)v88 != v60)
                  objc_enumerationMutation(v57);
                v62 = *(_QWORD *)(*((_QWORD *)&v87 + 1) + 8 * (_QWORD)j);
                v63 = objc_msgSend(objc_alloc((Class)CWFNetworkProfile), "initWithExternalForm:", objc_msgSend(v56, "objectForKeyedSubscript:", v62));
                if (v63)
                {
                  v64 = (CFDictionaryRef *)sub_1000CCB10(v63, 0);
                  if (v64)
                  {
                    v65 = v64;
                    v66 = sub_100026664(v64);
                    if (v66)
                    {
                      v67 = v66;
                      objc_msgSend(*(id *)(v1 + 1104), "setObject:forKey:", 0, v62);
                      v68 = *(void **)(v86 + 1104);
                      v69 = objc_msgSend(v67, "externalForm");
                      v70 = v68;
                      v1 = v86;
                      objc_msgSend(v70, "setObject:forKey:", v69, v62);

                    }
                    CFRelease(v65);
                  }
                }
              }
              v59 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v87, v95, 16);
            }
            while (v59);
          }
          objc_msgSend(*(id *)(v1 + 1104), "synchronize");
          v71 = objc_autoreleasePoolPush();
          v72 = (void *)qword_10026DD20;
          v2 = &ACAccountStoreDidChangeNotification_ptr;
          if (qword_10026DD20)
          {
            +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
            objc_msgSend(v72, "WFLog:message:", 3, "%s: Migrate OS-specific attributes to CWFNetworkProfile took %fs", "WiFiManagerMigratePNL", v73 - v55);
          }
          objc_autoreleasePoolPop(v71);
          objc_autoreleasePoolPop(v85);
        }
        v74 = objc_autoreleasePoolPush();
        v75 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
          objc_msgSend(v75, "WFLog:message:", 3, "%s: Entire PNL update took %fs", "WiFiManagerMigratePNL", v76 - v4);
        }
        objc_autoreleasePoolPop(v74);
        return;
      }
LABEL_22:
      objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
      v22 = v21;
      v23 = objc_autoreleasePoolPush();
      if (sub_10001D90C((_QWORD *)v1, CFSTR("isWiFiPNLMigrationComplete")) == kCFBooleanTrue)
      {
        SCPreferencesSynchronize(*(SCPreferencesRef *)(v1 + 1080));
        v24 = sub_10001D90C((_QWORD *)v1, CFSTR("List of known networks"));
        if (v24)
        {
          v25 = sub_100064608(v24);
          if (v25)
          {
            v26 = v25;
            v27 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
            if (CFArrayGetCount(v26) >= 1)
            {
              v28 = 0;
              do
              {
                ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v26, v28);
                if (ValueAtIndex)
                {
                  v30 = sub_100026664(ValueAtIndex);
                  if (v30)
                  {
                    v31 = v30;
                    if (!objc_msgSend(v30, "addedAt") && !objc_msgSend(v31, "lastJoinedByUserAt"))
                    {
                      v32 = (NSDate *)objc_msgSend(v31, "updatedAt");
                      if (!v32)
                      {
                        v32 = (NSDate *)objc_msgSend(v31, "lastJoinedBySystemAt");
                        if (!v32)
                          v32 = +[NSDate date](NSDate, "date");
                      }
                      objc_msgSend(v31, "setAddedAt:", v32);
                    }
                    v33 = objc_msgSend(v31, "identifier");
                    v34 = objc_msgSend(v31, "externalForm");
                    if (v33 && v34)
                      objc_msgSend(v27, "setObject:forKeyedSubscript:", v34, v33);

                  }
                }
                ++v28;
              }
              while (CFArrayGetCount(v26) > v28);
            }
            objc_msgSend(*(id *)(v1 + 1104), "addEntriesFromDictionary:", v27);
            objc_msgSend(*(id *)(v1 + 1104), "synchronize");
            CFRelease(v26);
            v2 = &ACAccountStoreDidChangeNotification_ptr;
          }
        }
      }
      objc_autoreleasePoolPop(v23);
      v35 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("/Library/Preferences/SystemConfiguration/%@"), CFSTR("com.apple.wifi-networks.plist"));
      -[NSFileManager copyItemAtPath:toPath:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "copyItemAtPath:toPath:error:", v35, -[NSString stringByAppendingPathExtension:](v35, "stringByAppendingPathExtension:", CFSTR("backup")), 0);
      sub_100087488((_QWORD *)v1, CFSTR("List of known networks"), 0, 0);
      v36 = objc_autoreleasePoolPush();
      v37 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
        objc_msgSend(v37, "WFLog:message:", 3, "%s: PNL migration to unified KVS took %fs", "WiFiManagerMigratePNL", v38 - v22);
      }
      objc_autoreleasePoolPop(v36);
      goto LABEL_44;
    }
    +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
    v8 = v7;
    v9 = *(const __SCPreferences **)(v1 + 1072);
    v10 = *(const __SCPreferences **)(v1 + 1080);
    v11 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerMigratePNLToStandaloneClassC");
    if (!sub_100007620(v9))
    {
      v78 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not acquire lock oldPrefs", "__WiFiManagerMigratePNLToStandaloneClassC");
      objc_autoreleasePoolPop(v78);
      v2 = &ACAccountStoreDidChangeNotification_ptr;
      goto LABEL_19;
    }
    SCPreferencesSynchronize(v9);
    v12 = SCPreferencesCopyKeyList(v9);
    v13 = v12;
    v83 = v11;
    if (v12)
    {
      v97.length = CFArrayGetCount(v12);
      v97.location = 0;
      if (!CFArrayContainsValue(v13, v97, CFSTR("List of known networks")))
      {
        v16 = v6;
        v15 = 0;
        v17 = 1;
        goto LABEL_15;
      }
      Value = SCPreferencesGetValue(v9, CFSTR("List of known networks"));
      if (!Value)
        goto LABEL_9;
      if (sub_100007620(v10))
      {
        if (!SCPreferencesSetValue(v10, CFSTR("List of known networks"), Value))
        {
          v16 = v6;
          v81 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not set records", "__WiFiManagerMigratePNLToStandaloneClassC");
          objc_autoreleasePoolPop(v81);
          v17 = 0;
          v15 = 0;
          goto LABEL_11;
        }
LABEL_9:
        v15 = SCPreferencesRemoveValue(v9, CFSTR("List of known networks"));
        v16 = v6;
        if (v15)
        {
          v17 = 1;
          if (!Value)
          {
LABEL_15:
            v1 = v86;
            if ((sub_1000076D4(v9, v15) & v17) != 0)
              sub_100093FA0((_QWORD *)v86, CFSTR("isWiFiPNLMigrationComplete"), kCFBooleanTrue);
            v2 = &ACAccountStoreDidChangeNotification_ptr;
            v6 = v16;
            v11 = v83;
            if (v13)
              CFRelease(v13);
LABEL_19:

            v18 = objc_autoreleasePoolPush();
            v19 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              objc_msgSend((id)v2[415], "timeIntervalSinceReferenceDate");
              objc_msgSend(v19, "WFLog:message:", 3, "%s: PNL migration to class C standalone plist took %fs", "WiFiManagerMigratePNL", v20 - v8);
            }
            objc_autoreleasePoolPop(v18);
            goto LABEL_22;
          }
        }
        else
        {
          v80 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not remove value", "__WiFiManagerMigratePNLToStandaloneClassC");
          objc_autoreleasePoolPop(v80);
          v17 = 0;
          if (!Value)
            goto LABEL_15;
        }
LABEL_11:
        v17 &= sub_1000076D4(v10, v15);
        goto LABEL_15;
      }
      v16 = v6;
      v79 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not acquire lock newPrefs", "__WiFiManagerMigratePNLToStandaloneClassC");
    }
    else
    {
      v16 = v6;
      v79 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not fetch keyList", "__WiFiManagerMigratePNLToStandaloneClassC");
    }
    objc_autoreleasePoolPop(v79);
    v17 = 0;
    v15 = 0;
    goto LABEL_15;
  }
  v77 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:manager is null", "WiFiManagerMigratePNL");
  objc_autoreleasePoolPop(v77);
}

uint64_t sub_1000A4174(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 2064);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerIsConnectionQualityLocalCollectionEnabled");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000A41E0(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 2064) != (_DWORD)a2)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting connection quality local collection to %d", "WiFiManagerSetConnectionQualityLocalCollectionEnabled", a2);
      objc_autoreleasePoolPop(v4);
      *(_BYTE *)(a1 + 2064) = a2;
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerSetConnectionQualityLocalCollectionEnabled");
    objc_autoreleasePoolPop(v5);
  }
}

uint64_t sub_1000A42AC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 2048);
}

void sub_1000A42B4(const __CFArray *a1, void *a2, uint64_t a3, const __CFDictionary *a4)
{
  void *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  uint64_t *ValueAtIndex;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  CFAllocatorRef v14;
  int v15;
  uint64_t v16;
  const __CFString *Value;
  void *v18;
  uint64_t v19;
  uint64_t v20;

  if (byte_10026DD61 && ((_DWORD)a3 == 5 || !(_DWORD)a3))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Lockdown Mode is enabled, ignoring type %@(%d)", "WiFiManagerSimulateNotification", sub_100064E5C(a3), a3);
LABEL_6:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v8 = sub_10000B29C(a1);
  if (!v8)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "WiFiManagerSimulateNotification", v19, v20);
    goto LABEL_6;
  }
  v9 = v8;
  if (CFArrayGetCount(v8))
  {
    ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(v9, 0);
    if (ValueAtIndex)
    {
      v11 = ValueAtIndex;
      v12 = sub_1000161D4((uint64_t)ValueAtIndex);
      if (v12)
      {
        switch((int)a3)
        {
          case 2:
            sub_1001198D4((uint64_t)v11, a2);
            break;
          case 5:
            if (!a2)
            {
              v18 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "WiFiManagerSimulateNotification");
              goto LABEL_29;
            }
            sub_10002C478((uint64_t)a2, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"), 0);
            sub_10011914C((uint64_t)v11, (uint64_t)a2);
            break;
          case 7:
            v13 = sub_100029860(v12);
            v14 = kCFAllocatorDefault;
            v15 = 7;
            v16 = 2;
            goto LABEL_17;
          case 8:
            sub_100119488((uint64_t)v11, a2);
            break;
          case 10:
            sub_100119518((uint64_t)v11, a2);
            break;
          case 13:
            Value = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("SSID_STR"));
            sub_10012219C(v11, Value);
            break;
          case 14:
            sub_100122730((uint64_t)v11, a2);
            break;
          default:
            v13 = sub_100029860(v12);
            v14 = kCFAllocatorDefault;
            v15 = a3;
            v16 = 0;
LABEL_17:
            sub_1000D7154((uint64_t)v14, v15, v16, v11, v13, (CFDictionaryRef *)a2, 0);
            break;
        }
        goto LABEL_22;
      }
    }
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device manager is null", "WiFiManagerSimulateNotification");
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device managers array is empty", "WiFiManagerSimulateNotification");
  }
LABEL_29:
  objc_autoreleasePoolPop(v18);
LABEL_22:
  CFRelease(v9);
}

uint64_t sub_1000A4578(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(_QWORD *)(a1 + 224);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerGetKnownNetworks");
  objc_autoreleasePoolPop(v2);
  return 0;
}

uint64_t sub_1000A45E4(uint64_t a1)
{
  uint64_t result;

  result = sub_10001E1C8((uint64_t)"WiFiManagerGetKnownNetworksCache_block_invoke");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_1000A4618(uint64_t a1)
{
  void *v2;

  if (CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 224)) < 401)
  {

  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s PNL greater than theshold (%d), won't end xpc_transaction", "WiFiManagerGetKnownNetworksCache_block_invoke_2", 400);
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000A46A8(uint64_t a1, const __CFArray *a2)
{
  void *v4;
  uint64_t v5;
  const void *v6;
  void *v7;
  void *v8;
  const __CFArray *v9;
  CFIndex Count;
  const void *v11;
  void *v12;
  void *v14;
  _QWORD context[4];

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    v5 = 0;
    if (a2 && *(_BYTE *)(a1 + 1328))
    {
      v6 = *(const void **)(a1 + 352);
      if (!v6 || !CFEqual(a2, v6))
      {
        v7 = objc_autoreleasePoolPush();
        v8 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v9 = *(const __CFArray **)(a1 + 352);
          if (v9)
            Count = CFArrayGetCount(v9);
          else
            Count = 0;
          objc_msgSend(v8, "WFLog:message:", 3, "%s: Switching cached list from %ld to %ld private mac networks", "WiFiManagerSetPrivateMacNetworksCache", Count, CFArrayGetCount(a2));
        }
        objc_autoreleasePoolPop(v7);
        v11 = *(const void **)(a1 + 352);
        if (v11)
        {
          CFRelease(v11);
          *(_QWORD *)(a1 + 352) = 0;
        }
        *(_QWORD *)(a1 + 352) = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      }
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updated %ld private mac networks in the cache", "WiFiManagerSetPrivateMacNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 352)));
      objc_autoreleasePoolPop(v12);
      context[0] = a1;
      context[1] = 0xAAAAAAAA0000006ELL;
      v5 = 1;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerSetPrivateMacNetworksCache");
    objc_autoreleasePoolPop(v14);
    v5 = 0;
  }
  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t sub_1000A485C(uint64_t a1, int a2, int a3)
{
  void *v6;
  const __CFArray *v7;
  CFIndex Count;
  __CFArray *v9;
  __CFArray *v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  const void *v14;
  void *v15;
  void *v17;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerFlushPrivateMacNetworksCache");
    objc_autoreleasePoolPop(v17);
    goto LABEL_20;
  }
  if (!*(_BYTE *)(a1 + 1328)
    || (v7 = *(const __CFArray **)(a1 + 352)) == 0
    || (Count = CFArrayGetCount(v7), (v9 = sub_1000172FC(*(const __CFArray **)(a1 + 352), a2)) == 0))
  {
LABEL_20:
    v11 = 0;
    goto LABEL_16;
  }
  v10 = v9;
  v11 = sub_100087488((_QWORD *)a1, CFSTR("List of scanned networks with private mac"), v9, a3);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v13 = "Successfully flushed";
    if (!(_DWORD)v11)
      v13 = "Failed to flush";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " WFMacRandomisation : %s: %s %ld privateMac networks to the plist", "WiFiManagerFlushPrivateMacNetworksCache", v13, Count);
  }
  objc_autoreleasePoolPop(v12);
  if (!Count)
  {
    v14 = *(const void **)(a1 + 352);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(a1 + 352) = 0;
    }
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Cleared private mac networks cache", "WiFiManagerFlushPrivateMacNetworksCache");
    objc_autoreleasePoolPop(v15);
  }
  CFRelease(v10);
LABEL_16:
  objc_autoreleasePoolPop(v6);
  return v11;
}

void sub_1000A49EC(uint64_t a1)
{
  _QWORD v1[4];

  v1[0] = a1;
  v1[1] = 0xAAAAAAAA0000004ALL;
  v1[2] = 0;
  v1[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v1);
}

uint64_t sub_1000A4A30(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 2065);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerArePrivacyRestrictionsForWiFiConnectionQualityDisabled");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000A4A9C(uint64_t a1, uint64_t a2)
{
  void *v4;
  const void **v5;
  void *v6;
  _QWORD context[4];

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 2065) != (_DWORD)a2)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: arePrivacyRestrictionsForWiFiConnectionQualityDisabled now set to %d", "WiFiManagerSetPrivacyRestrictionsForWiFiConnectionQualityDisabled", a2);
      objc_autoreleasePoolPop(v4);
      v5 = (const void **)&kCFBooleanTrue;
      if (!(_DWORD)a2)
        v5 = (const void **)&kCFBooleanFalse;
      sub_100087488((_QWORD *)a1, CFSTR("ConnectionQualityPrivacyRestrictionsDisabled"), *v5, 0);
      *(_BYTE *)(a1 + 2065) = a2;
      context[0] = a1;
      context[1] = 0xAAAAAAAA0000002DLL;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerSetPrivacyRestrictionsForWiFiConnectionQualityDisabled");
    objc_autoreleasePoolPop(v6);
  }
}

BOOL sub_1000A4BC4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 1328) != 0;
}

void sub_1000A4BD4(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  objc_msgSend(*(id *)(a1 + 1432), "checkForWiFiPasswordChange");
  objc_msgSend(*(id *)(a1 + 1432), "syncKnownWiFiNetworks:", 0);
  objc_autoreleasePoolPop(v2);
}

CFStringRef sub_1000A4C10(uint64_t a1)
{
  id v2;
  void *v3;
  double v4;
  id v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  void *i;
  const void *v12;
  uint64_t v13;
  NSMutableArray *v14;
  NSMutableArray *v15;
  id v16;
  id v17;
  uint64_t v18;
  void *j;
  id v20;
  void *v21;
  id v22;
  id v23;
  const __CFAllocator *Default;
  const __CFString *v25;
  CFStringRef Copy;
  void *v27;
  void *v28;
  void *v29;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE v43[128];
  _BYTE v44[128];
  CFRange v45;

  v34 = objc_autoreleasePoolPush();
  v2 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1696), "latestLocation"), "copy");
  v3 = v2;
  if (!v2)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s won't determine known network SSID for location as there's no location available (are Location Services enabled?)", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation", v32);
    goto LABEL_41;
  }
  objc_msgSend(v2, "horizontalAccuracy");
  if (v4 >= 100.1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s won't determine known network SSID for location as location accuracy is greater than threshold (%f)", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation", 0x4059066666666666);
LABEL_41:
    objc_autoreleasePoolPop(v28);
    v6 = 0;
    goto LABEL_46;
  }
  v5 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyNetworksAvailableAtLocation:", v3);
  v6 = v5;
  if (!v5 || !objc_msgSend(v5, "count"))
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s copyNetworksAvailableAtLocation returned null or empty array, likely no known networks at this location. Returning NULL", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
    goto LABEL_45;
  }
  if (objc_msgSend(v6, "count") == (id)1)
  {
    v20 = objc_msgSend(v6, "firstObject");
    if (v20)
      goto LABEL_33;
    goto LABEL_43;
  }
  v7 = +[NSMutableArray array](NSMutableArray, "array");
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v42 = 0u;
  v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v39, v44, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v40;
    do
    {
      for (i = 0; i != v9; i = (char *)i + 1)
      {
        if (*(_QWORD *)v40 != v10)
          objc_enumerationMutation(v6);
        v12 = *(const void **)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)i);
        if (sub_10002B088(v12))
          objc_msgSend(v7, "addObject:", sub_10002B088(v12));
      }
      v9 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v39, v44, 16);
    }
    while (v9);
  }
  if (!objc_msgSend(v7, "count"))
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Multiple matches for current location, but couldn't determine the SSIDs of *any* of them, this is likely a serious bug but possibly a rare setup", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
    goto LABEL_45;
  }
  v13 = sub_10008674C(a1);
  if (!v13)
  {
    v31 = objc_autoreleasePoolPush();
    v29 = v34;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Couldn't get known networks cache, bail", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
    goto LABEL_57;
  }
  v14 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", v13);
  if (!v14 || (v15 = v14, !-[NSMutableArray count](v14, "count")))
  {
LABEL_46:
    Copy = 0;
    goto LABEL_47;
  }
  v45.length = (CFIndex)-[NSMutableArray count](v15, "count");
  v45.location = 0;
  CFArraySortValues((CFMutableArrayRef)v15, v45, (CFComparatorFunction)sub_1000C88A0, 0);
  if (!-[NSMutableArray count](v15, "count"))
  {
    v31 = objc_autoreleasePoolPush();
    v29 = v34;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Sorted network list empty, this shouldn't happen.", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
    goto LABEL_57;
  }
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v35, v43, 16);
  if (!v16)
    goto LABEL_43;
  v17 = v16;
  v33 = v3;
  v18 = *(_QWORD *)v36;
  do
  {
    for (j = 0; j != v17; j = (char *)j + 1)
    {
      if (*(_QWORD *)v36 != v18)
        objc_enumerationMutation(v15);
      v20 = *(id *)(*((_QWORD *)&v35 + 1) + 8 * (_QWORD)j);
      v21 = objc_autoreleasePoolPush();
      v22 = objc_msgSend(v7, "filteredArrayUsingPredicate:", +[NSPredicate predicateWithFormat:](NSPredicate, "predicateWithFormat:", CFSTR("SELF MATCHES %@"), sub_10002B088(v20)));
      if (v22)
      {
        v23 = objc_msgSend(v22, "count");
        objc_autoreleasePoolPop(v21);
        if (v23)
          goto LABEL_32;
      }
      else
      {
        objc_autoreleasePoolPop(v21);
      }
    }
    v17 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v35, v43, 16);
  }
  while (v17);
  v20 = 0;
LABEL_32:
  v3 = v33;
  if (!v20)
  {
LABEL_43:
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Logic error, determination process finished without detecting a handleable error and didn't finish with a determination. This is a bug.", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
LABEL_45:
    objc_autoreleasePoolPop(v27);
    goto LABEL_46;
  }
LABEL_33:
  if (!sub_10002B088(v20))
  {
    v31 = objc_autoreleasePoolPush();
    v29 = v34;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Couldn't determine the SSID of the known network that was determined to be the most used at the current device location. Bail ", "WiFiManagerCopySSIDRepresentingMostUsedNetworkGeoTaggedToCurrentDeviceLocation");
LABEL_57:
    objc_autoreleasePoolPop(v31);
    Copy = 0;
    goto LABEL_48;
  }
  Default = CFAllocatorGetDefault();
  v25 = (const __CFString *)sub_10002B088(v20);
  Copy = CFStringCreateCopy(Default, v25);
LABEL_47:
  v29 = v34;
LABEL_48:

  objc_autoreleasePoolPop(v29);
  return Copy;
}

uint64_t sub_1000A5114(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000054;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_1000A5158(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000055;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_1000A519C(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000056;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_1000A51E0(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000058;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

void sub_1000A5224(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, int a4)
{
  __CFString *v8;
  CFStringRef v9;
  __CFString *v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  __CFDictionary *v17;
  __CFDictionary *v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  int v25;
  const __CFDictionary *v26;
  const __CFDictionary *Value;
  const __CFDictionary *v28;
  __CFDictionary *v29;
  __CFDictionary *v30;
  CFNumberRef v31;
  CFNumberRef v32;
  __CFString *v33;
  __CFDictionary *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  int valuePtr;

  valuePtr = a4;
  v8 = (__CFString *)sub_1000161D4(a2);
  v39 = 0;
  v40 = 0;
  if ((_DWORD)a3 == 14 && (LODWORD(v39) = 5, !a4))
  {
    sub_100005F98(a1, a2);
  }
  else
  {
    v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d"), a3, v39, v40);
    if (v9)
    {
      v10 = (__CFString *)v9;
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v12 = Mutable;
        v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
        if (v13)
        {
          v14 = v13;
          CFDictionaryAddValue(v12, CFSTR("EventRateClientIntervalKey"), v13);
          CFRelease(v14);
          v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v40);
          if (v15)
          {
            v16 = v15;
            CFDictionaryAddValue(v12, CFSTR("EventRateClientPrevDispatchTimestampKey"), v15);
            CFRelease(v16);
            v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v17)
            {
              v18 = v17;
              CFDictionarySetValue(v17, v8, v12);
              v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v39);
              if (!v19)
              {
                v38 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number 3", "WiFiManagerEventSetRateLimit");
                goto LABEL_44;
              }
              v20 = v19;
              CFDictionaryAddValue(v18, CFSTR("EventRateDefaultIntervalKey"), v19);
              CFRelease(v20);
              v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v40);
              if (!v21)
              {
                v38 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number 4", "WiFiManagerEventSetRateLimit");
                goto LABEL_44;
              }
              v22 = v21;
              CFDictionaryAddValue(v18, CFSTR("EventRatePrevDispatchTimestampKey"), v21);
              CFRelease(v22);
              v23 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)&v39 + 4);
              if (!v23)
              {
                v38 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number 5", "WiFiManagerEventSetRateLimit");
                goto LABEL_44;
              }
              v24 = v23;
              CFDictionaryAddValue(v18, CFSTR("EventRateRateDispachedCount"), v23);
              CFRelease(v24);
              v25 = CFDictionaryContainsKey(a1[266], v10);
              v26 = a1[266];
              if (v25)
              {
                Value = (const __CFDictionary *)CFDictionaryGetValue(v26, v10);
                if (Value)
                {
                  v28 = Value;
                  v29 = (__CFDictionary *)CFDictionaryGetValue(Value, v8);
                  if (v29)
                  {
                    v30 = v29;
                    v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                    if (v31)
                    {
                      v32 = v31;
                      CFDictionarySetValue(v30, CFSTR("EventRateClientIntervalKey"), v31);
                      CFRelease(v32);
LABEL_19:
                      CFRelease(v10);
LABEL_20:
                      CFRelease(v18);
                      CFRelease(v12);
                      return;
                    }
                    v38 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number 6", "WiFiManagerEventSetRateLimit");
LABEL_44:
                    objc_autoreleasePoolPop(v38);
                    goto LABEL_19;
                  }
                  v26 = v28;
                  v33 = v8;
                  v34 = v12;
LABEL_18:
                  CFDictionarySetValue(v26, v33, v34);
                  goto LABEL_19;
                }
                v26 = a1[266];
              }
              v33 = v10;
              v34 = v18;
              goto LABEL_18;
            }
            v37 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null eventDict", "WiFiManagerEventSetRateLimit");
          }
          else
          {
            v37 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number 2", "WiFiManagerEventSetRateLimit");
          }
        }
        else
        {
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null number", "WiFiManagerEventSetRateLimit");
        }
        objc_autoreleasePoolPop(v37);
        v18 = (__CFDictionary *)v10;
        goto LABEL_20;
      }
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null clientDict", "WiFiManagerEventSetRateLimit");
      objc_autoreleasePoolPop(v36);
      CFRelease(v10);
    }
    else
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null eventKey", "WiFiManagerEventSetRateLimit");
      objc_autoreleasePoolPop(v35);
    }
  }
}

uint64_t sub_1000A5708(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v5;
  CFStringRef v6;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  const void *v9;
  const __CFDictionary *v10;
  const __CFNumber *v11;
  void *v12;
  void *v14;
  unsigned int valuePtr;

  valuePtr = 0;
  v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d"), a3);
  if (v5)
  {
    v6 = v5;
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2128), v5);
    if (Value)
    {
      v8 = Value;
      v9 = (const void *)sub_1000161D4(a2);
      v10 = (const __CFDictionary *)CFDictionaryGetValue(v8, v9);
      if (v10)
      {
        v11 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("EventRateClientIntervalKey"));
        if (!CFNumberGetValue(v11, kCFNumberIntType, &valuePtr))
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to get value", "WiFiManagerEventGetRateLimit");
          objc_autoreleasePoolPop(v12);
        }
      }
    }
    else
    {
      valuePtr = 0;
    }
    CFRelease(v6);
    return valuePtr;
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null eventKey", "WiFiManagerEventGetRateLimit");
    objc_autoreleasePoolPop(v14);
    return 0;
  }
}

BOOL sub_1000A5840(uint64_t a1, char a2)
{
  return (a2 & 2) != 0 && *(_BYTE *)(a1 + 2176) != 0;
}

uint64_t sub_1000A585C(uint64_t a1, uint64_t a2)
{
  int v3;
  _BOOL8 v4;
  BOOL v6;
  void *v7;

  v3 = *(unsigned __int8 *)(a1 + 2177);
  if (*(_BYTE *)(a1 + 2176))
  {
    if ((v3 & a2) != 0)
      return 1;
    v4 = 1;
    switch(*(_BYTE *)(a1 + 2177))
    {
      case 0:
        break;
      case 1:
      case 8:
        v6 = (((_DWORD)a2 - 2) & 0xFFFFFFFD) == 0;
        goto LABEL_15;
      case 2:
        v6 = (_DWORD)a2 == 4 || (_DWORD)a2 == 1;
LABEL_15:
        v4 = v6;
        break;
      case 4:
        v4 = (a2 - 1) < 2;
        break;
      default:
        v4 = 0;
        break;
    }
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: OpMode current state:%d  requested %d status %d", "WiFiManagerIsOpModeAllowed", *(unsigned __int8 *)(a1 + 2177), a2, v4);
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    v4 = v3 == 0;
    if ((_DWORD)a2 == 1)
    {
      if (v3 != 2)
        return v4;
      return 1;
    }
    if ((_DWORD)a2 == 2 && v3 == 1)
      return 1;
  }
  return v4;
}

_DWORD *sub_1000A5978(_DWORD *result, int a2, int a3)
{
  const __CFString *v4;
  const __CFString *v5;

  if (result[83] != a2)
  {
    result[83] = a2;
    v4 = CFSTR("Never");
    if (a2 == 1)
      v4 = CFSTR("Ask to Join");
    if (a2 == 2)
      v5 = CFSTR("Automatic");
    else
      v5 = v4;
    sub_100087488(result, CFSTR("AutoInstantHotspot"), v5, a3);
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendAutoHotspotModeDidChangeEvent");
    return objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendUserSettingsDidChangeEvent");
  }
  return result;
}

uint64_t sub_1000A5A04(uint64_t result, int a2, int a3)
{
  const __CFString *v4;
  const __CFString *v5;

  if (*(_DWORD *)(result + 340) != a2)
  {
    *(_DWORD *)(result + 340) = a2;
    v4 = CFSTR("Never");
    if (a2 == 1)
      v4 = CFSTR("Ask for Approval");
    if (a2 == 2)
      v5 = CFSTR("Automatic");
    else
      v5 = v4;
    return sub_100087488((_QWORD *)result, CFSTR("ShareMyPersonalHotspot"), v5, a3);
  }
  return result;
}

uint64_t sub_1000A5A54(uint64_t a1)
{
  const __SCPreferences *v2;
  const __SCPreferences *v3;
  uint64_t v4;

  v2 = sub_10001D90C((_QWORD *)a1, CFSTR("AutoInstantHotspot"));
  if (v2)
  {
    v3 = v2;
    if (CFEqual(CFSTR("Never"), v2))
    {
      v4 = 0;
    }
    else
    {
      v4 = 1;
      if (!CFEqual(CFSTR("Ask to Join"), v3))
      {
        if (CFEqual(CFSTR("Automatic"), v3))
          v4 = 2;
        else
          v4 = 1;
      }
    }
  }
  else
  {
    v4 = 1;
  }
  *(_DWORD *)(a1 + 332) = v4;
  return v4;
}

uint64_t sub_1000A5AEC(uint64_t a1)
{
  const __SCPreferences *v2;
  const __SCPreferences *v3;
  uint64_t v4;

  v2 = sub_10001D90C((_QWORD *)a1, CFSTR("ShareMyPersonalHotspot"));
  if (v2)
  {
    v3 = v2;
    if (CFEqual(CFSTR("Never"), v2))
    {
      v4 = 0;
    }
    else
    {
      v4 = 1;
      if (!CFEqual(CFSTR("Ask for Approval"), v3))
      {
        if (CFEqual(CFSTR("Automatic"), v3))
          v4 = 2;
        else
          v4 = 1;
      }
    }
  }
  else
  {
    v4 = 1;
  }
  *(_DWORD *)(a1 + 340) = v4;
  return v4;
}

void sub_1000A5B84(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 2168) != a2)
  {
    *(double *)(a1 + 2168) = a2;
    sub_1000932C4((_QWORD *)a1, CFSTR("AutoInstantHotspotTriggerInterval"), a2);
  }
}

void sub_1000A5BA8(uint64_t a1, int a2)
{
  _QWORD context[4];
  int v3;

  v3 = a2;
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000005ALL;
  context[2] = &v3;
  context[3] = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
}

void sub_1000A5BF0(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = objc_autoreleasePoolPush();
  if (sub_10008C218(a1))
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: purging local store if it size exceeds %lu bytes", "WiFiManagerPrune3BarsNetworks", a2);
    objc_autoreleasePoolPop(v5);
    objc_msgSend(+[WiFi3BarsObserver sharedWiFi3BarsObserver](WiFi3BarsObserver, "sharedWiFi3BarsObserver"), "prune3BarsNetworks:", a2);
  }
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_1000A5C88(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(_QWORD *)(a1 + 2184);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "WiFiManagerGet3BarsSource");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000A5CF4(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  __CTServerConnection *v5;
  void *v6;

  if (*(_BYTE *)(a1 + 128))
  {
    v5 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
    if (v5)
    {
      _CTServerConnectionCopyPacketContextInterfaceNameByServiceType(v5, kCTDataConnectionServiceTypeInternet, a2);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s called by %s: cellular interface name: %@", "WiFiManagerCopyCellularInterfaceName", a3, *a2);
      objc_autoreleasePoolPop(v6);
    }
  }
}

_QWORD *sub_1000A5DA8(_QWORD *a1)
{
  if (a1)
    return sub_1000A5DB4(a1);
  return a1;
}

CFArrayRef sub_1000A5DB4(_QWORD *a1)
{
  NSUserDefaults *v2;
  const __CFArray *v3;
  const __SCPreferences *v5;

  v2 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  v3 = -[NSUserDefaults arrayForKey:](v2, "arrayForKey:", CFSTR("FamilyHotspotPreferences"));
  if (v3)
    return CFArrayCreateCopy(kCFAllocatorDefault, v3);
  v5 = sub_10001D90C(a1, CFSTR("FamilyHotspotPreferences"));
  if (v5
    && (sub_1000A6014(a1, (uint64_t)v5),
        sub_100087488(a1, CFSTR("FamilyHotspotPreferences"), 0, 0),
        (v3 = -[NSUserDefaults arrayForKey:](v2, "arrayForKey:", CFSTR("FamilyHotspotPreferences"))) != 0))
  {
    return CFArrayCreateCopy(kCFAllocatorDefault, v3);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000A5E68(_QWORD *a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  id v4;
  void *v5;
  id v6;
  uint64_t v7;
  void *v8;

  v2 = sub_1000A5F44(a1);
  if (!v2)
  {
    v4 = 0;
    goto LABEL_10;
  }
  v3 = v2;
  v4 = -[__CFDictionary mutableCopy](v2, "mutableCopy");

  if (!v4)
  {
LABEL_10:
    v7 = 0;
    goto LABEL_11;
  }
  v5 = (void *)a1[315];
  if (!v5 || (v6 = objc_msgSend(v5, "cellularICCID")) == 0)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to retrieve ICCID", "WiFiManagerResetHotspotDataUsage");
    objc_autoreleasePoolPop(v8);
    goto LABEL_10;
  }
  objc_msgSend(v4, "removeObjectForKey:", v6);
  -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v4, CFSTR("InterfaceDataUsageV1"));
  v7 = 1;
LABEL_11:

  return v7;
}

CFDictionaryRef sub_1000A5F44(_QWORD *a1)
{
  NSUserDefaults *v2;
  const __CFDictionary *v3;
  const __SCPreferences *v5;

  v2 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  v3 = -[NSUserDefaults dictionaryForKey:](v2, "dictionaryForKey:", CFSTR("InterfaceDataUsageV1"));
  if (v3)
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v3);
  v5 = sub_10001D90C(a1, CFSTR("InterfaceDataUsageV1"));
  if (v5
    && (-[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v5, CFSTR("InterfaceDataUsageV1")), sub_100087488(a1, CFSTR("InterfaceDataUsageV1"), 0, 0), (v3 = -[NSUserDefaults dictionaryForKey:](v2, "dictionaryForKey:", CFSTR("InterfaceDataUsageV1"))) != 0))
  {
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v3);
  }
  else
  {
    return 0;
  }
}

void sub_1000A6014(_QWORD *a1, uint64_t a2)
{
  void *v3;
  CFAbsoluteTime Current;
  CFDateRef v5;
  CFDateRef v6;

  -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", a2, CFSTR("FamilyHotspotPreferences"));
  v3 = objc_autoreleasePoolPush();
  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(kCFAllocatorDefault, Current);
  if (v5)
  {
    v6 = v5;
    sub_100087488(a1, CFSTR("FamilyHotspotPreferencesUpdateTimestamp"), v5, 0);
    CFRelease(v6);
  }
  objc_autoreleasePoolPop(v3);
}

uint64_t sub_1000A60AC(_QWORD *a1)
{
  -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", 0, CFSTR("UserNotificationBlacklist"));
  return sub_100087488(a1, CFSTR("UserNotificationBlacklist"), 0, 0);
}

CFDictionaryRef sub_1000A60FC(_QWORD *a1)
{
  return sub_10009DA68(a1, 0);
}

id sub_1000A6104(uint64_t a1, uint64_t a2)
{
  return -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", a2, CFSTR("Custom network settings"));
}

uint64_t sub_1000A613C(_QWORD *a1)
{
  void *v2;
  CFDictionaryRef v3;
  id v4;
  NSObject *v5;
  NSObject *global_queue;
  dispatch_time_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  _QWORD block[10];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  void (*v21)(uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  void (*v27)(uint64_t);
  uint64_t v28;

  v2 = objc_autoreleasePoolPush();
  v23 = 0;
  v24 = &v23;
  v25 = 0x3052000000;
  v26 = sub_10002FA68;
  v27 = sub_10002F978;
  v28 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x3052000000;
  v20 = sub_10002FA68;
  v21 = sub_10002F978;
  v22 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v3 = sub_1000A5F44(a1);
  if (v3)
  {
    v4 = objc_alloc_init((Class)NSMutableDictionary);
    v18[5] = (uint64_t)v4;
    if (v4)
    {
      v5 = dispatch_semaphore_create(0);
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000A6374;
      block[3] = &unk_1002308C8;
      block[6] = &v17;
      block[7] = &v13;
      block[8] = &v23;
      block[9] = a1;
      block[4] = v3;
      block[5] = v5;
      dispatch_async(global_queue, block);
      v7 = dispatch_time(0, 1000000000);
      if (dispatch_semaphore_wait(v5, v7))
      {
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timed out waiting for data usage.", "WiFiManagerCopyHotspotDataUsage");
        objc_autoreleasePoolPop(v8);
        *((_BYTE *)v14 + 24) = 1;
      }
      dispatch_release(v5);
    }
  }

  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: returning data usage info %@", "WiFiManagerCopyHotspotDataUsage", v24[5]);
  objc_autoreleasePoolPop(v9);
  v10 = v24[5];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v23, 8);
  objc_autoreleasePoolPop(v2);
  return v10;
}

void sub_1000A6344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1000A6374(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v15;
  _QWORD v16[6];
  uint64_t v17;

  v2 = *(void **)(*(_QWORD *)(a1 + 72) + 2520);
  if (!v2 || (v3 = objc_msgSend(v2, "cellularICCID")) == 0)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to retrieve ICCID", "WiFiManagerCopyHotspotDataUsage_block_invoke", v15);
    goto LABEL_13;
  }
  v4 = v3;
  v5 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:", v3);
  if (!v5)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: empty usage record for ICCID %@", "WiFiManagerCopyHotspotDataUsage_block_invoke", v4);
LABEL_13:
    objc_autoreleasePoolPop(v12);
    goto LABEL_14;
  }
  v6 = v5;
  v7 = objc_alloc_init((Class)CoreTelephonyClient);
  if (!v7)
    goto LABEL_10;
  v8 = v7;
  v17 = 0;
  v9 = objc_msgSend(v7, "billingCycleEndDatesForLastPeriods:error:", 2, &v17);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %@, billing periods %@", "WiFiManagerCopyHotspotDataUsage_block_invoke", v17, v9);
  objc_autoreleasePoolPop(v10);

  if (v9 && objc_msgSend(v9, "count"))
  {
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_1000A6CEC;
    v16[3] = &unk_1002308A0;
    v11 = *(_QWORD *)(a1 + 48);
    v16[4] = v6;
    v16[5] = v11;
    objc_msgSend(v9, "enumerateObjectsWithOptions:usingBlock:", 2, v16);
  }
  else
  {
LABEL_10:
    sub_1000A655C(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v6, 0, 0);
  }
LABEL_14:
  v13 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))

  else
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40) = v13;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void sub_1000A655C(void *a1, void *a2, NSDate *a3, uint64_t a4)
{
  void *v5;
  id v6;
  const __CFString *v7;
  const __CFString *v8;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  const __CFString *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  void *v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  id v30;
  id v31;
  id v32;
  const __CFString *v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  id v38;
  id v39;
  char *v40;
  id v41;
  char *v42;
  void *v43;
  id v44;
  id v45;
  void *v46;
  void *context;
  id obj;
  uint64_t v52;
  id v53;
  uint64_t v54;
  uint64_t v55;
  id v56;
  id v57;
  id v58;
  void *v59;
  void *v60;
  void *v61;
  char *v62;
  id v63;
  uint64_t v64;
  id v65;
  id v66;
  id v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  _BYTE v84[128];
  _BYTE v85[128];
  _BYTE v86[128];
  _BYTE v87[128];

  if (a1 && a2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: records %@", "__populateHotspotDataUsageFromRecord", a2);
    objc_autoreleasePoolPop(v5);
    context = objc_autoreleasePoolPush();
    if (!a3)
      a3 = +[NSDate date](NSDate, "date");
    v6 = +[NSMutableArray array](NSMutableArray, "array");
    v80 = 0u;
    v81 = 0u;
    v82 = 0u;
    v83 = 0u;
    obj = a2;
    v53 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v80, v87, 16);
    if (v53)
    {
      v52 = *(_QWORD *)v81;
      v7 = CFSTR("DataUsageInterfaceName");
      v8 = CFSTR("DataUsageInterfacePeerDisplayName");
      do
      {
        v9 = 0;
        do
        {
          if (*(_QWORD *)v81 != v52)
            objc_enumerationMutation(obj);
          v54 = v9;
          v10 = *(void **)(*((_QWORD *)&v80 + 1) + 8 * v9);
          v11 = objc_msgSend(v10, "objectForKey:", CFSTR("DataUsageDate"));
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: record date %@", "__populateHotspotDataUsageFromRecord", v11);
          objc_autoreleasePoolPop(v12);
          if (v11 && -[NSDate compare:](a3, "compare:", v11) != NSOrderedAscending)
          {
            v13 = objc_msgSend(v10, "objectForKey:", v7);
            v14 = objc_msgSend(v10, "objectForKey:", CFSTR("DataUsageInterfacePeerList"));
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: interfaceName %@", "__populateHotspotDataUsageFromRecord", v13);
            objc_autoreleasePoolPop(v15);
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: peerRecords %@", "__populateHotspotDataUsageFromRecord", v14);
            objc_autoreleasePoolPop(v16);
            v78 = 0u;
            v79 = 0u;
            v76 = 0u;
            v77 = 0u;
            v57 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v76, v86, 16);
            if (v57)
            {
              v55 = *(_QWORD *)v77;
              v56 = v14;
              v63 = v13;
              do
              {
                v17 = 0;
                do
                {
                  if (*(_QWORD *)v77 != v55)
                    objc_enumerationMutation(v14);
                  v62 = (char *)v17;
                  v18 = *(void **)(*((_QWORD *)&v76 + 1) + 8 * (_QWORD)v17);
                  v19 = v8;
                  v20 = objc_msgSend(v18, "objectForKey:", v8);
                  v21 = objc_msgSend(v18, "objectForKey:", CFSTR("DataUsageInterfacePeerAddr"));
                  v22 = objc_msgSend(v18, "objectForKey:", CFSTR("DataUsageInterfacePeerLastBytes"));
                  v59 = v18;
                  v23 = objc_msgSend(v18, "objectForKey:", CFSTR("DataUsageInterfacePeerTotalBytes"));
                  v24 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: record %@/%@/%@/%@", "__populateHotspotDataUsageFromRecord", v20, v21, v22, v23);
                  v60 = v22;
                  v61 = v23;
                  objc_autoreleasePoolPop(v24);
                  v74 = 0u;
                  v75 = 0u;
                  v72 = 0u;
                  v73 = 0u;
                  v67 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v72, v85, 16);
                  if (v67)
                  {
                    v58 = v20;
                    v25 = 0;
                    v26 = 0;
                    v27 = *(_QWORD *)v73;
                    v64 = *(_QWORD *)v73;
LABEL_29:
                    v28 = 0;
                    while (1)
                    {
                      if (*(_QWORD *)v73 != v27)
                        objc_enumerationMutation(v6);
                      v29 = *(void **)(*((_QWORD *)&v72 + 1) + 8 * v28);
                      if (objc_msgSend(v13, "isEqualToString:", objc_msgSend(v29, "objectForKey:", v7)))
                      {
                        if (v25)

                        v25 = v29;
                        v30 = objc_msgSend(v29, "objectForKey:", CFSTR("DataUsageInterfacePeerList"));
                        if (v30)
                        {
                          if (v26)

                          v26 = v30;
                        }
                        v70 = 0u;
                        v71 = 0u;
                        v68 = 0u;
                        v69 = 0u;
                        v31 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v68, v84, 16);
                        if (v31)
                        {
                          v32 = v31;
                          v65 = v25;
                          v66 = v26;
                          v33 = v7;
                          v34 = v6;
                          v35 = *(_QWORD *)v69;
LABEL_41:
                          v36 = 0;
                          while (1)
                          {
                            if (*(_QWORD *)v69 != v35)
                              objc_enumerationMutation(v30);
                            v37 = *(void **)(*((_QWORD *)&v68 + 1) + 8 * v36);
                            if ((objc_msgSend(objc_msgSend(v37, "objectForKey:", CFSTR("DataUsageInterfacePeerAddr")), "isEqualToString:", v21) & 1) != 0)break;
                            if (v32 == (id)++v36)
                            {
                              v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v68, v84, 16);
                              if (v32)
                                goto LABEL_41;
                              goto LABEL_49;
                            }
                          }
                          v38 = v37;
                          if (!v38)
                          {
LABEL_49:
                            v6 = v34;
                            v7 = v33;
                            v13 = v63;
                            v25 = v65;
                            v26 = v66;
                            goto LABEL_50;
                          }
                          v39 = v38;
                          v41 = objc_msgSend(v38, "objectForKey:", CFSTR("DataUsageInterfacePeerLastBytes"));
                          v42 = (char *)objc_msgSend(objc_msgSend(v39, "objectForKey:", CFSTR("DataUsageInterfacePeerTotalBytes")), "unsignedIntegerValue");
                          v6 = v34;
                          v7 = v33;
                          v13 = v63;
                          if (v41)
                            v42 = &v42[(_QWORD)objc_msgSend(v41, "unsignedIntegerValue")];
                          v8 = CFSTR("DataUsageInterfacePeerDisplayName");
                          if (v60)
                            v42 = &v42[(_QWORD)objc_msgSend(v60, "unsignedIntegerValue")];
                          if (v61)
                            v42 = &v42[(_QWORD)objc_msgSend(v61, "unsignedIntegerValue")];
                          objc_msgSend(v39, "setObject:forKey:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v42), CFSTR("DataUsageInterfacePeerTotalBytes"));
                          if (v58)
                            objc_msgSend(v39, "setObject:forKey:", v58, CFSTR("DataUsageInterfacePeerDisplayName"));
                          objc_msgSend(v39, "removeObjectForKey:", CFSTR("DataUsageInterfacePeerLastBytes"));
                          v14 = v56;
                          v40 = v62;
                          if (v66)
                            goto LABEL_67;
                          goto LABEL_66;
                        }
LABEL_50:
                        v27 = v64;
                      }
                      if ((id)++v28 == v67)
                      {
                        v67 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v72, v85, 16);
                        if (v67)
                          goto LABEL_29;
                        v65 = v25;
                        v39 = objc_msgSend(v59, "mutableCopy");
                        v14 = v56;
                        v40 = v62;
                        if (v26)
                        {
                          v66 = v26;
                          objc_msgSend(v26, "addObject:", v39);
                          v8 = CFSTR("DataUsageInterfacePeerDisplayName");
                          goto LABEL_67;
                        }
                        v8 = CFSTR("DataUsageInterfacePeerDisplayName");
                        goto LABEL_66;
                      }
                    }
                  }
                  v39 = objc_msgSend(v59, "mutableCopy");
                  v65 = 0;
                  v14 = v56;
                  v40 = v62;
                  v8 = v19;
LABEL_66:
                  v66 = objc_alloc_init((Class)NSMutableArray);
                  objc_msgSend(v66, "addObject:", v39);
LABEL_67:
                  v43 = v65;
                  if (!v65)
                  {
                    v44 = objc_alloc_init((Class)NSMutableDictionary);
                    v43 = v44;
                    if (v13)
                      objc_msgSend(v44, "setObject:forKey:", v13, v7);
                    objc_msgSend(v43, "setObject:forKey:", v66, CFSTR("DataUsageInterfacePeerList"));
                    objc_msgSend(v6, "addObject:", v43);
                  }

                  v17 = v40 + 1;
                }
                while (v17 != v57);
                v45 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v76, v86, 16);
                v57 = v45;
              }
              while (v45);
            }
          }
          v9 = v54 + 1;
        }
        while ((id)(v54 + 1) != v53);
        v53 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v80, v87, 16);
      }
      while (v53);
    }
    if (objc_msgSend(v6, "count"))
    {
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: adding interface usage %@", "__populateHotspotDataUsageFromRecord", v6);
      objc_autoreleasePoolPop(v46);
      objc_msgSend(a1, "setObject:forKey:", v6, -[NSNumber stringValue](+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", a4), "stringValue"));
    }
    objc_autoreleasePoolPop(context);
  }
}

void sub_1000A6CEC(uint64_t a1, NSDate *a2, uint64_t a3)
{
  sub_1000A655C(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(void **)(a1 + 32), a2, a3);
}

void sub_1000A6D04(uint64_t a1, int a2)
{
  const void **v2;
  void *v3;

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 2201) != a2)
    {
      *(_BYTE *)(a1 + 2201) = a2;
      v2 = (const void **)&kCFBooleanTrue;
      if (!a2)
        v2 = (const void **)&kCFBooleanFalse;
      sub_100087488((_QWORD *)a1, CFSTR("isWiFiPowerModificationDisabled"), *v2, 0);
    }
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "WiFiManagerDisablePowerModification");
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_1000A6DC0(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 344);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "WiFiManagerIsPersonalHotspotModificationDisabled");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000A6E2C(uint64_t a1, int a2)
{
  const void **v2;
  void *v3;

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 344) != a2)
    {
      *(_BYTE *)(a1 + 344) = a2;
      v2 = (const void **)&kCFBooleanTrue;
      if (!a2)
        v2 = (const void **)&kCFBooleanFalse;
      sub_100087488((_QWORD *)a1, CFSTR("isPersonalHotspotModificationDisabled"), *v2, 0);
    }
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "WiFiManagerDisablePersonalHotspotModification");
    objc_autoreleasePoolPop(v3);
  }
}

CFDictionaryRef sub_1000A6EE8(CFDictionaryRef result)
{
  if (result)
    return sub_1000A6EF8(result, 0);
  return result;
}

CFDictionaryRef sub_1000A6EF8(_QWORD *a1, int a2)
{
  NSUserDefaults *v4;
  const __CFDictionary *v5;
  const __SCPreferences *v7;

  v4 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  v5 = -[NSUserDefaults dictionaryForKey:](v4, "dictionaryForKey:", CFSTR("UserNotificationBlacklist"));
  if (v5)
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v5);
  v7 = sub_10001D90C(a1, CFSTR("UserNotificationBlacklist"));
  if (v7
    && (-[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v7, CFSTR("UserNotificationBlacklist")), sub_100087488(a1, CFSTR("UserNotificationBlacklist"), 0, a2), (v5 = -[NSUserDefaults dictionaryForKey:](v4, "dictionaryForKey:", CFSTR("UserNotificationBlacklist"))) != 0))
  {
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v5);
  }
  else
  {
    return 0;
  }
}

void sub_1000A6FC8(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  void *v5;
  const void **v6;
  _QWORD context[4];

  if (a1)
  {
    v4 = (unsigned __int8 *)(a1 + 376);
    if (*(unsigned __int8 *)(a1 + 376) != (_DWORD)a2)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation: Mac Randomisation internal UI toggled. Current State : %d,new state : %d", "WiFiManagerSetMacRandomisationPreference", *v4, a2);
      objc_autoreleasePoolPop(v5);
      v6 = (const void **)&kCFBooleanFalse;
      if ((_DWORD)a2)
        v6 = (const void **)&kCFBooleanTrue;
      sub_100087488((_QWORD *)a1, CFSTR("WiFiMacRandomizationInternalUI"), *v6, 0);
    }
    *(_BYTE *)(a1 + 376) = a2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000006FLL;
    context[2] = v4;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_1000A70B4(uint64_t a1, const __CFArray *a2)
{
  void *v4;
  void *v5;
  _QWORD context[4];

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (a2 && *(_BYTE *)(a1 + 1328))
    {
      *(_QWORD *)(a1 + 800) = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      context[0] = a1;
      context[1] = 0xAAAAAAAA0000007ELL;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerSetAmbiguousSSIDs");
    objc_autoreleasePoolPop(v5);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_1000A718C(_DWORD *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  CFAbsoluteTime Current;
  CFDateRef v6;
  const __CFNumber *Value;
  unsigned int v8;
  unsigned int v9;
  _BOOL4 v10;
  uint64_t v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFString *v18;
  int v19;
  int v20;
  int v21;
  NSObject *v22;
  int v24;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  dispatch_time_t v29;
  CFIndex v30;
  BOOL v31;
  const __CFBoolean *v32;
  int v33;
  const void *ValueAtIndex;
  const void *v35;
  CFTypeID v36;
  const __CFBoolean *v37;
  const __CFBoolean *v38;
  const void *v39;
  const void *v40;
  CFTypeID TypeID;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v43;
  const __CFBoolean *v44;
  const __CFBoolean *v45;
  CFNumberRef v46;
  CFNumberRef v47;
  CFNumberRef v48;
  void *v49;
  const __CFString *v50;
  const __CFDate *v51;
  __CFDictionary *Mutable;
  const __CFData *v53;
  const __CFData *v54;
  const __CFData *v55;
  const __CFString *v56;
  CFDataRef v57;
  CFNumberRef v58;
  const __CFString *v59;
  const __CFBoolean *v60;
  const __CFDictionary *v61;
  const __CFDictionary *v62;
  __CFDictionary *v63;
  const __CFNumber *v64;
  void *v65;
  void *v66;
  const __CFArray *v67;
  void *v68;
  const void *v69;
  void *v70;
  void *v71;
  CFNumberRef otherNumber;
  _BOOL4 v73;
  uint64_t v74;
  const __CFString *theString2;
  int v76;
  CFIndex Count;
  const __CFString *v78;
  const __CFArray *v79;
  _QWORD v80[2];

  v4 = kCFAllocatorDefault;
  Current = CFAbsoluteTimeGetCurrent();
  v6 = CFDateCreate(kCFAllocatorDefault, Current);
  v80[0] = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("enabled"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, (char *)v80 + 4);
      v8 = HIDWORD(v80[0]);
      if (HIDWORD(v80[0]))
      {
        v9 = 1;
      }
      else
      {
        v9 = 0;
        *((_QWORD *)a1 + 55) = 0x4008000000000000;
        *((_QWORD *)a1 + 57) = 0x1400000002;
        a1[116] = 2;
        *(_OWORD *)(a1 + 95) = xmmword_1001BB5C0;
        a1[99] = 1209600;
        a1[100] = 86400;
      }
      if (v8 > 1)
        v11 = 1;
      else
        v11 = v9;
      v10 = v8 != *((unsigned __int8 *)a1 + 376);
      sub_1000A6FC8((uint64_t)a1, v11);
    }
    else
    {
      v10 = 0;
    }
    theString2 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("privateMacNetwork"));
    otherNumber = (CFNumberRef)CFDictionaryGetValue(a2, CFSTR("setSwitchState"));
    v12 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("scanTimeout"));
    if (v12)
      CFNumberGetValue(v12, kCFNumberIntType, a1 + 95);
    v13 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("migrationInterval"));
    if (v13)
      CFNumberGetValue(v13, kCFNumberIntType, a1 + 96);
    v14 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("migrationAttempts"));
    if (v14)
      CFNumberGetValue(v14, kCFNumberIntType, v80);
    v15 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("keyRotationInterval"));
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberIntType, a1 + 98);
      sub_100087488(a1, CFSTR("RotationKeyDateMacRandomisation"), v6, 0);
    }
    v16 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("inactiveNetworkInterval"));
    if (v16)
      CFNumberGetValue(v16, kCFNumberIntType, a1 + 99);
    v17 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("nonTrustworthyInactiveNetworkInterval"));
    if (v17)
      CFNumberGetValue(v17, kCFNumberIntType, a1 + 100);
    v18 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("makeMigratedNetwork"));
    v19 = a1[95];
    if (v19 <= 0)
    {
      v19 = 1800;
      a1[95] = 1800;
    }
    v20 = a1[96];
    if (!v20 || v20 < v19)
    {
      a1[96] = 86400;
      v20 = 86400;
    }
    if (LODWORD(v80[0]))
      a1[97] = v80[0];
    v21 = a1[98];
    if (v21 <= 0)
    {
      a1[98] = 86400;
      v21 = 86400;
    }
    if ((int)a1[99] <= 0)
      a1[99] = 1209600;
    if ((int)a1[100] <= 0)
      a1[100] = 86400;
    v22 = *((_QWORD *)a1 + 62);
    if (v22)
    {
      if (v21 > v20 || v21 > v19)
        v24 = v20;
      else
        v24 = v21;
      if (v19 > v20 || v19 > v21)
        v19 = v24;
      v26 = v19 - 1;
      v27 = v19 >> 1;
      if (v26 >= 0x3C)
        v27 = 60;
      v28 = 1000000000 * v27;
      v29 = dispatch_time(0, v28);
      dispatch_source_set_timer(v22, v29, v28, 0);
    }
    v78 = v18;
    if (v10 && !*((_BYTE *)a1 + 376))
      sub_1000A7CEC((uint64_t)a1);
    v79 = (const __CFArray *)sub_1000875B0((uint64_t)a1);
    if (v79)
    {
      Count = CFArrayGetCount(v79);
      if (Count >= 1)
      {
        v30 = 0;
        v74 = 0;
        if (theString2)
          v31 = otherNumber == 0;
        else
          v31 = 1;
        v32 = kCFBooleanFalse;
        v33 = !v31;
        v76 = v33;
        v73 = v10;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v79, v30);
          if (!ValueAtIndex || (v35 = ValueAtIndex, v36 = CFGetTypeID(ValueAtIndex), v36 != sub_1000C312C()))
          {
            v71 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : knownNetwork is invalid", "WiFiManagerSetMacRandomisationParams");
            objc_autoreleasePoolPop(v71);
            goto LABEL_133;
          }
          v37 = (const __CFBoolean *)sub_10002BE64((uint64_t)v35, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
          if (v37 && v37 == kCFBooleanTrue)
          {
            sub_10002B698((uint64_t)v35, CFSTR("PrivateMacClassifyInterval"), (int)a1[96]);
            sub_10002B698((uint64_t)v35, CFSTR("MacAddressRandomisationClassificationAttempts"), SLODWORD(v80[0]));
            if (sub_10002BE64((uint64_t)v35, CFSTR("PrivateMacJoinDateAfterUpgrade")))
            {
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacJoinDateAfterUpgrade"), v6);
              if (!v10)
                goto LABEL_99;
              goto LABEL_74;
            }
          }
          else
          {
            v38 = (const __CFBoolean *)sub_10002BE64((uint64_t)v35, CFSTR("PresentInKnownNetworks"));
            v32 = v38;
            if (v38 && v38 == kCFBooleanTrue)
            {
              sub_10002C478((uint64_t)v35, CFSTR("FirstJoinWithNewMacTimestamp"), v6);
              v32 = kCFBooleanTrue;
              if (!v10)
                goto LABEL_99;
              goto LABEL_74;
            }
          }
          if (!v10)
            goto LABEL_99;
LABEL_74:
          v39 = sub_10002BE64((uint64_t)v35, CFSTR("PRIVATE_MAC_ADDRESS"));
          if (!v39)
            goto LABEL_99;
          v40 = v39;
          TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v40))
            goto LABEL_99;
          MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, (CFDictionaryRef)v40);
          if (!MutableCopy)
            goto LABEL_133;
          v43 = MutableCopy;
          v44 = (const __CFBoolean *)sub_10002BE64((uint64_t)v35, CFSTR("isProfileBasedNetwork"));
          if (*((_BYTE *)a1 + 376))
          {
            if (!v44)
              goto LABEL_99;
            if (v44 != kCFBooleanTrue)
              goto LABEL_99;
            v45 = (const __CFBoolean *)sub_10002BE64((uint64_t)v35, CFSTR("PrivateMacProfileDefaultInitialValue"));
            if (!v45)
              goto LABEL_99;
            if (v45 == kCFBooleanTrue)
            {
              v48 = sub_100064FE0(1);
              CFDictionarySetValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v48);
              CFDictionarySetValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *((const void **)a1 + 61));
              CFDictionaryRemoveValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
              if (v48)
                CFRelease(v48);
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacDefaultToOFF"), kCFBooleanTrue);
              sub_10002C478((uint64_t)v35, CFSTR("privateMacSuccessfulAssocAtleastOnce"), 0);
              v49 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Profile Based private MAC disable key reinforced for network <%@>", "WiFiManagerSetMacRandomisationParams", sub_10002B088(v35));
              objc_autoreleasePoolPop(v49);
            }
            else
            {
              v46 = sub_100064FE0(2);
              CFDictionarySetValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v46);
              CFDictionaryRemoveValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacDefaultToOFF"), kCFBooleanFalse);
              sub_10002C478((uint64_t)v35, CFSTR("RotationKeyMacRandomisation"), 0);
              if (v46)
                CFRelease(v46);
            }
            sub_10002C478((uint64_t)v35, CFSTR("PRIVATE_MAC_ADDRESS"), v43);
            v4 = kCFAllocatorDefault;
          }
          else
          {
            if (v44 && v44 == kCFBooleanTrue)
              goto LABEL_99;
            if (!v32)
              goto LABEL_99;
            if (v32 != kCFBooleanTrue)
              goto LABEL_99;
            v47 = sub_100064FE0(1);
            CFDictionarySetValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v47);
            CFDictionarySetValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *((const void **)a1 + 61));
            CFDictionaryRemoveValue(v43, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
            v43 = v47;
            if (!v47)
              goto LABEL_99;
          }
          CFRelease(v43);
LABEL_99:
          if (v78)
          {
            v50 = (const __CFString *)sub_10002B088(v35);
            if (CFStringCompare(v50, v78, 0) == kCFCompareEqualTo)
            {
              v51 = v6;
              Mutable = CFDictionaryCreateMutable(v4, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              v54 = (const __CFData *)*((_QWORD *)a1 + 51);
              v53 = (const __CFData *)*((_QWORD *)a1 + 52);
              v55 = (const __CFData *)*((_QWORD *)a1 + 61);
              v56 = (const __CFString *)sub_10002B088(v35);
              v57 = sub_1000CE52C(v53, v54, v55, v56);
              v58 = sub_100064FE0(2);
              CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v58);
              CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v57);
              if (v57)
                CFRelease(v57);
              if (v58)
                CFRelease(v58);
              sub_10002C478((uint64_t)v35, CFSTR("MacAddressRandomisationTagMigratedNetwork"), kCFBooleanTrue);
              sub_10002B698((uint64_t)v35, CFSTR("MacAddressRandomisationClassificationAttempts"), (int)a1[97]);
              sub_10002B698((uint64_t)v35, CFSTR("PrivateMacClassifyInterval"), (int)a1[96]);
              sub_10002C478((uint64_t)v35, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable);
              sub_10002C478((uint64_t)v35, CFSTR("RotationKeyUsed"), *((const void **)a1 + 51));
              sub_10002C478((uint64_t)v35, CFSTR("PresentInKnownNetworks"), kCFBooleanTrue);
              sub_10002C478((uint64_t)v35, CFSTR("BlockRotation"), kCFBooleanTrue);
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacFutureMacAddress"), 0);
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacPrefChanged"), 0);
              sub_10002C478((uint64_t)v35, CFSTR("PrivateMacPrefChangedTimestamp"), 0);
              sub_10002C478((uint64_t)v35, CFSTR("ResetCaptiveProbe"), 0);
              sub_10002C478((uint64_t)v35, CFSTR("ExperiencedFallback"), 0);
              sub_10002C478((uint64_t)v35, CFSTR("privateMacSuccessfulAssocAtleastOnce"), 0);
              v6 = v51;
              if (Mutable)
                CFRelease(Mutable);
              sub_10008A2B8((uint64_t)a1, "WiFiManagerSetMacRandomisationParams", 27815);
              v74 = (uint64_t)v35;
              v4 = kCFAllocatorDefault;
              v10 = v73;
            }
          }
          if (v76)
          {
            v59 = (const __CFString *)sub_10002B088(v35);
            if (CFStringCompare(v59, theString2, 0) == kCFCompareEqualTo)
            {
              v60 = (const __CFBoolean *)sub_10002BE64((uint64_t)v35, CFSTR("PrivateMacControlledDevice"));
              if (!v60 || v60 == kCFBooleanFalse)
              {
                v61 = (const __CFDictionary *)sub_10002BE64((uint64_t)v35, CFSTR("PRIVATE_MAC_ADDRESS"));
                if (v61)
                  v62 = CFDictionaryCreateMutableCopy(v4, 0, v61);
                else
                  v62 = CFDictionaryCreateMutable(v4, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                v63 = v62;
                v64 = (const __CFNumber *)CFDictionaryGetValue(v62, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
                if (!v64 || CFNumberCompare(v64, otherNumber, 0))
                {
                  v65 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : switch toggled using mobilewifitool", "WiFiManagerSetMacRandomisationParams");
                  objc_autoreleasePoolPop(v65);
                  CFDictionarySetValue(v63, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), otherNumber);
                }
                sub_10002C478((uint64_t)v35, CFSTR("PRIVATE_MAC_ADDRESS"), v63);
                if (v63)
                  CFRelease(v63);
              }
            }
          }
          if (Count == ++v30)
            goto LABEL_125;
        }
      }
      v74 = 0;
LABEL_125:
      if (sub_1000A46A8((uint64_t)a1, v79) && !sub_1000A485C((uint64_t)a1, 1, 0))
      {
        v66 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Updated privateMac Params and wrote to flash", "WiFiManagerSetMacRandomisationParams");
        objc_autoreleasePoolPop(v66);
      }
      if (v78)
      {
        v67 = (const __CFArray *)sub_10008674C((uint64_t)a1);
        v68 = (void *)sub_1000A7E60(v67, v74);
        sub_1000A7EE0((uint64_t)a1, v68, 4);
        v69 = sub_10002B634(v79, (const __CFDictionary **)v68);
        if (v69)
          sub_10002C478((uint64_t)v69, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
      }
    }
  }
LABEL_133:
  v70 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Updated Private Mac Params from mobilewifitool at <%@>. scanTimeout = <%d>, keyRotationInterval = <%d>, migrationInterval = <%d>, migrationAttempts = <%d>, inactiveNetworkInterval = <%d> , nonTrustworthyInactiveNetworkInterval = <%d>", "WiFiManagerSetMacRandomisationParams", v6, a1[95], a1[98], a1[96], a1[97], a1[99], a1[100]);
  objc_autoreleasePoolPop(v70);
  if (v6)
    CFRelease(v6);
}

void sub_1000A7CEC(uint64_t a1)
{
  const __CFArray *v2;
  const __CFArray *Copy;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  void *ValueAtIndex;
  void *v9;
  const __CFBoolean *v10;
  void *v11;

  if (a1)
  {
    v2 = *(const __CFArray **)(a1 + 352);
    if (v2 && CFArrayGetCount(v2))
    {
      Copy = CFArrayCreateCopy(kCFAllocatorDefault, *(CFArrayRef *)(a1 + 352));
      v4 = Copy;
      if (Copy)
      {
        Count = CFArrayGetCount(Copy);
        if (Count >= 1)
        {
          v6 = Count;
          for (i = 0; i != v6; ++i)
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(v4, i);
            if (ValueAtIndex)
            {
              v9 = ValueAtIndex;
              v10 = (const __CFBoolean *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PresentInKnownNetworks"));
              if (!v10 || v10 != kCFBooleanTrue)
              {
                v11 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Removing scan record <%@>", "__WiFiManagerPrivateMacRemoveAllScannedNetworks", sub_10002B088(v9));
                objc_autoreleasePoolPop(v11);
                sub_1000AAD20(a1, (const __CFDictionary **)v9);
              }
            }
          }
        }
      }
    }
    else
    {
      v4 = 0;
    }
    sub_1000A46A8(a1, *(const __CFArray **)(a1 + 352));
    sub_1000A485C(a1, 1, 0);
    if (v4)
      CFRelease(v4);
  }
}

const void *sub_1000A7E60(const __CFArray *a1, uint64_t a2)
{
  const void *ValueAtIndex;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;

  ValueAtIndex = 0;
  if (a1 && a2)
  {
    Count = CFArrayGetCount(a1);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (sub_1000C6060((uint64_t)ValueAtIndex, a2))
          break;
        if (v6 == ++v7)
          return 0;
      }
    }
  }
  return ValueAtIndex;
}

uint64_t sub_1000A7EE0(uint64_t a1, void *a2, uint64_t a3)
{
  void *v6;
  const __CFAllocator *v7;
  CFAbsoluteTime Current;
  CFDateRef v9;
  int v10;
  uint64_t v11;
  const __CFArray *v12;
  int v13;
  void *v14;
  const char *v15;
  const void **v16;
  const void **v17;
  void *v18;
  const void **v19;
  void *v20;
  void *v21;
  const void *v22;
  _WORD *v23;
  uint64_t v24;
  void *v25;
  _WORD *v26;
  void *v27;
  const void *v28;
  const void *v29;
  CFTypeID TypeID;
  const void *v31;
  void *v32;
  const void *v33;
  const void *v34;
  CFTypeID v35;
  const void *v36;
  const void *v37;
  const void *v38;
  void *v39;
  _BOOL4 v40;
  CFAbsoluteTime v41;
  const __CFDate *v42;
  const void *v43;
  double v44;
  uint64_t v45;
  const __CFDictionary *v46;
  _BOOL4 v47;
  const __CFDate *v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  void *v52;
  void *v53;
  void *v54;
  const void *v55;
  const __CFBoolean *v56;
  const __SCPreferences *v57;
  const __CFBoolean *v58;
  const void *v59;
  const void *v60;
  CFBooleanRef v61;
  const __CFDictionary *v62;
  const __CFBoolean *v63;
  CFTypeID v64;
  const __CFData *v65;
  unsigned int v66;
  CFMutableDictionaryRef MutableCopy;
  _WORD *v68;
  _BOOL4 v69;
  _BOOL4 v70;
  _BOOL4 v71;
  CFBooleanRef v72;
  CFMutableDictionaryRef v73;
  __CFDictionary *v74;
  int v75;
  void *v76;
  CFBooleanRef v77;
  const __CFBoolean *v78;
  CFBooleanRef v79;
  CFBooleanRef v80;
  const __CFBoolean *v81;
  const __CFDictionary *v82;
  const __CFDictionary *v83;
  const __CFDictionary *v84;
  void *v85;
  const __CFBoolean *v86;
  const __CFBoolean *v87;
  __CFDictionary *v88;
  const __CFData *v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  CFNumberRef v93;
  void *v94;
  const __CFBoolean *v95;
  const __CFBoolean *v96;
  unint64_t v97;
  const __CFDate *v98;
  const __CFDate *v99;
  const void *v100;
  __CFString *v101;
  const void *v102;
  void *v103;
  void *v104;
  void *v105;
  CFBooleanRef v106;
  BOOL v107;
  char v108;
  const __CFBoolean *v109;
  const __CFData *v110;
  const __CFBoolean *v111;
  __CFDictionary *v112;
  const __CFData *v113;
  const __CFString *v114;
  const __CFData *v115;
  CFDataRef v116;
  __CFDictionary *v117;
  void *v118;
  const void *v119;
  const void *v120;
  CFTypeID v121;
  void *v122;
  const __CFData *v123;
  const __CFData *v124;
  const __CFData *v125;
  const __CFString *v126;
  CFDataRef v127;
  CFNumberRef v128;
  void *v129;
  void *v130;
  int v131;
  void *v132;
  const __CFArray *v133;
  const __CFArray *v134;
  const void *ValueAtIndex;
  CFNumberRef v136;
  unsigned __int8 v137;
  void *v138;
  const __CFData *v139;
  const __CFData *v140;
  const __CFData *v141;
  const __CFString *v142;
  const __CFData *v143;
  CFDataRef v144;
  const __CFDictionary *v145;
  const __CFDictionary *v146;
  CFTypeID v147;
  const __CFNumber *v148;
  __CFDictionary *v149;
  CFNumberRef v150;
  void *v151;
  uint64_t v152;
  __CFDictionary *v153;
  const void **v154;
  CFNumberRef v155;
  CFNumberRef v156;
  const __CFArray *v157;
  uint64_t v158;
  void *v159;
  const void *v160;
  void *v161;
  const void *v162;
  _BOOL4 v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  __CFDictionary *Mutable;
  void *v169;
  CFNumberRef v170;
  void *v171;
  __CFDictionary *v172;
  const __CFBoolean *v173;
  const __CFBoolean *v174;
  void *v175;
  void *v176;
  CFNumberRef v177;
  const __CFData *v178;
  const __CFData *v179;
  const __CFData *v180;
  const __CFString *v181;
  void *v182;
  const __CFData *v183;
  const __CFData *v184;
  const __CFData *v185;
  const __CFString *v186;
  CFDataRef v187;
  const __CFString *v188;
  void *v189;
  void *v190;
  void *v191;
  void *v192;
  void *v193;
  void *v194;
  void *v196;
  const void *v197;
  const void *v198;
  void *v199;
  uint64_t v200;
  uint64_t v201;
  const __CFDate *otherDate;
  char v203;
  _BOOL4 v204;
  const __CFAllocator *v205;
  const __CFBoolean *v206;
  unsigned int cf;
  char cfa;
  CFNumberRef cfb;
  const __CFString *value;
  _WORD *v211;
  _WORD *v212;
  int v213;
  void *v214;
  CFMutableDictionaryRef theDict;
  const __CFDate *v216;
  uint64_t v217;
  CFIndex v218;
  unsigned int valuePtr;
  CFIndex context[5];

  valuePtr = a3;
  v6 = objc_autoreleasePoolPush();
  v218 = -1;
  v217 = 0;
  v7 = kCFAllocatorDefault;
  Current = CFAbsoluteTimeGetCurrent();
  v9 = CFDateCreate(kCFAllocatorDefault, Current);
  v10 = _os_feature_enabled_impl("WiFiManager", "PrivateMacRotation");
  theDict = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!theDict)
  {
    v193 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: networkRecord create fail", "WiFiManagerAddPrivateMacNetwork");
    objc_autoreleasePoolPop(v193);
LABEL_358:
    v158 = 0;
    if (!v9)
      goto LABEL_353;
    goto LABEL_352;
  }
  if (!a1)
  {
    v194 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerAddPrivateMacNetwork");
    goto LABEL_344;
  }
  if (!a2)
  {
    v194 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerAddPrivateMacNetwork");
LABEL_344:
    objc_autoreleasePoolPop(v194);
    goto LABEL_357;
  }
  v11 = sub_1000875B0(a1);
  if (!v11)
  {
LABEL_357:
    CFRelease(theDict);
    goto LABEL_358;
  }
  v12 = (const __CFArray *)v11;
  value = (const __CFString *)sub_10002B088(a2);
  v213 = sub_1000CEBA4((uint64_t)a2);
  if (sub_1000C5378((uint64_t)a2) && (_DWORD)a3 == 7)
  {
    *(_BYTE *)(a1 + 529) = 1;
    sub_10002C478((uint64_t)a2, CFSTR("NetworkAddedByProfile"), kCFBooleanTrue);
    if (sub_1000C3BC4((_BOOL8)a2))
    {
      sub_1000AADDC(v12, a2, &v218, &v217);
      if (v218 != -1)
      {
        v13 = sub_100096B7C(a1, a2, CFSTR("PresentInKnownNetworks"), kCFBooleanFalse);
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (v13)
            v15 = "%s: HS20 provisioning already exists. Removing existing provisioning and matched networks. provisionin"
                  "g profile : <%@>";
          else
            v15 = "%s: Unable to remove existing HS20 account <%@>";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v15, "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
        }
        objc_autoreleasePoolPop(v14);
      }
      v16 = (const void **)sub_10009FEE0((const __CFArray *)a1);
      if (v16)
      {
        v17 = v16;
        if (sub_1000CE080(v16, (const __CFDictionary **)a2))
        {
          v18 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Disassociating because a HS2.0 profile is being added while being associated to the provisioned network <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v17));
          objc_autoreleasePoolPop(v18);
          sub_10008A2B8(a1, "WiFiManagerAddPrivateMacNetwork", 28318);
        }
      }
    }
    else
    {
      v19 = (const void **)sub_10009FEE0((const __CFArray *)a1);
      sub_1000AAD20(a1, (const __CFDictionary **)a2);
      if (v19)
      {
        if (sub_1000CE080(v19, (const __CFDictionary **)a2))
        {
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Disassociating because a profile based network (with private MAC key) is being added while we are associated to that network <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
          objc_autoreleasePoolPop(v20);
          sub_10008A2B8(a1, "WiFiManagerAddPrivateMacNetwork", 28296);
        }
        CFRelease(v19);
      }
      context[0] = a1;
      context[1] = 0xAAAAAAAA0000006ELL;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
      sub_1000A485C(a1, 1, 0);
    }
  }
  v21 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Checking if network already present : Retrieving private mac cache version of the network <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
  objc_autoreleasePoolPop(v21);
  v22 = sub_1000AAF20(a1, (const __CFDictionary **)a2);
  v214 = v6;
  v216 = v9;
  if (!v22)
    goto LABEL_38;
  v23 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v22);
  if (sub_10002DA5C((_BOOL8)a2) && (_DWORD)a3 != 7)
  {
    v24 = (uint64_t)v23;
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : HS2.0 network <%@> add reason :<%u>. Merge HS20 records", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2), a3);
    objc_autoreleasePoolPop(v25);
    v23 = (_WORD *)v24;
    sub_10002B290(v24, (uint64_t)a2);
    v7 = kCFAllocatorDefault;
  }
  if (!v23)
  {
LABEL_38:
    if (sub_10002DA5C((_BOOL8)a2) && (_DWORD)a3 == 7)
    {
      v26 = sub_10002B2DC((uint64_t)v7, (uint64_t)a2);
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : HS2.0 provisioning being added by profile addition. Storing the entire record: <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
      objc_autoreleasePoolPop(v27);
    }
    else
    {
      if (value)
        CFDictionarySetValue(theDict, CFSTR("SSID_STR"), value);
      v26 = sub_10002B314((uint64_t)v7, theDict);
    }
    if (v26)
    {
      v23 = 0;
      v211 = v26;
      goto LABEL_47;
    }
    v196 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: new Network create fail", "WiFiManagerAddPrivateMacNetwork");
    objc_autoreleasePoolPop(v196);
    v9 = v216;
    goto LABEL_357;
  }
  v211 = 0;
  v26 = v23;
LABEL_47:
  sub_1000AAFDC((uint64_t)v26, (uint64_t)a2);
  v212 = v23;
  switch(valuePtr)
  {
    case 2u:
      sub_10002C478((uint64_t)v26, CFSTR("MacGenerationTimeStamp"), v216);
      sub_10002C478((uint64_t)v26, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
      sub_10002C478((uint64_t)v26, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
      v28 = sub_10002BE64((uint64_t)a2, CFSTR("PRIVATE_MAC_ADDRESS"));
      if (!v28)
        goto LABEL_60;
      v29 = v28;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(v29))
        goto LABEL_60;
      sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v29);
      v31 = *(const void **)(a1 + 408);
      goto LABEL_59;
    case 3u:
      sub_10002C478((uint64_t)v26, CFSTR("MacGenerationTimeStamp"), v216);
      sub_10002C478((uint64_t)v26, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
      v33 = sub_10002BE64((uint64_t)a2, CFSTR("PRIVATE_MAC_ADDRESS"));
      if (v33)
      {
        v34 = v33;
        v35 = CFDictionaryGetTypeID();
        if (v35 == CFGetTypeID(v34))
          sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v34);
      }
      v36 = sub_10002BE64((uint64_t)a2, CFSTR("RotationKeyUsed"));
      if (v36)
      {
        v31 = v36;
LABEL_59:
        sub_10002C478((uint64_t)v26, CFSTR("RotationKeyUsed"), v31);
      }
LABEL_60:
      sub_10002B698((uint64_t)v26, CFSTR("FailureCountThresholdCurrent"), *(unsigned int *)(a1 + 456));
      goto LABEL_246;
    case 4u:
      sub_10002C478((uint64_t)v26, CFSTR("preSwUpdateNetwork"), kCFBooleanTrue);
      sub_10002C478((uint64_t)v26, CFSTR("FeatureOffBySystemForHome"), 0);
      if (!sub_1000AB400((_BOOL8)v26) && sub_1000AB400((_BOOL8)a2))
      {
        v37 = sub_10002BE64((uint64_t)a2, CFSTR("NetworkOfInterestHomeState"));
        v38 = sub_10002BE64((uint64_t)a2, CFSTR("NetworkAtLocationOfInterestType"));
        sub_10002C478((uint64_t)v26, CFSTR("NetworkOfInterestHomeState"), v37);
        sub_10002C478((uint64_t)v26, CFSTR("NetworkAtLocationOfInterestType"), v38);
      }
      goto LABEL_64;
    case 5u:
LABEL_64:
      v39 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Processing migrated network: <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
      objc_autoreleasePoolPop(v39);
      cf = sub_10000BE8C((uint64_t)a2);
      v40 = sub_1000AB400((_BOOL8)v26);
      v41 = CFAbsoluteTimeGetCurrent();
      v205 = v7;
      v42 = CFDateCreate(v7, v41);
      v43 = sub_10002B088(a2);
      v44 = sub_10002DFE4((uint64_t)a2);
      v45 = sub_1000C5104((uint64_t)a2);
      v46 = sub_1000C433C((const __CFDictionary *)a2);
      v47 = sub_10002DAB4((uint64_t)a2);
      v204 = v40;
      if (sub_1000AB400((_BOOL8)a2)
        || sub_1000CBE60((uint64_t)a2) == 1
        || sub_1000CC270((uint64_t)a2) == 3
        || (v48 = (const __CFDate *)sub_10002BE64((uint64_t)a2, CFSTR("addedAt")), v44 == 0.0))
      {
        v51 = 0;
        goto LABEL_76;
      }
      otherDate = v48;
      if (!v48)
      {
        v200 = 0;
        v201 = 0;
        v49 = 0;
LABEL_318:
        v203 = 1;
        goto LABEL_323;
      }
      v49 = (int)(CFDateGetTimeIntervalSinceDate(v42, v48) / 86400.0);
      if (!(_DWORD)v49)
        goto LABEL_317;
      v50 = v44 / (double)(int)v49;
      if ((int)v49 > 6)
      {
        if (v50 > 10800.0)
        {
          v203 = 0;
          v200 = 0;
          v201 = 1;
          goto LABEL_323;
        }
LABEL_317:
        v200 = 0;
        v201 = 0;
        goto LABEL_318;
      }
      if (v50 <= 14400.0)
      {
        v201 = 0;
        v203 = 1;
      }
      else
      {
        v203 = 0;
        v201 = 1;
      }
      v200 = 1;
LABEL_323:
      v189 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v199 = v189;
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : %s,  current Date : [%@], recentlyAdded [%hhu],  Timesinceadded :[%f], daysSinceAdded : [%d], FrequentlyUSed [%hhu]", "__WiFiManagerPrivateMacIsSpecialFrequentlyUsedNetwork", v42, v200, CFDateGetTimeIntervalSinceDate(v42, otherDate), v49, v201);
        v189 = v199;
      }
      objc_autoreleasePoolPop(v189);
      if ((v203 & 1) != 0)
      {
        v51 = 0;
        v40 = v204;
LABEL_76:
        v7 = v205;
        if (!v42)
          goto LABEL_78;
        goto LABEL_77;
      }
      v190 = objc_autoreleasePoolPush();
      v40 = v204;
      if (!(v45 | v46) || v47)
      {
        if (qword_10026DD20)
        {
          v198 = v43;
          v192 = v190;
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Frequently used network <%@>. suppoerts WPA2 : [%hhu], supports WPA3 : [%hhu], is EAP : [%hhu]", "__WiFiManagerPrivateMacIsSpecialFrequentlyUsedNetwork", v198, v45, v46, v47);
          v190 = v192;
        }
        v51 = 0;
      }
      else
      {
        if (qword_10026DD20)
        {
          v197 = v43;
          v191 = v190;
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : frequently used, secure and non enterprise network <%@> ", "__WiFiManagerPrivateMacIsSpecialFrequentlyUsedNetwork", v197);
          v190 = v191;
        }
        v51 = 1;
      }
      v7 = v205;
      objc_autoreleasePoolPop(v190);
      if (v42)
LABEL_77:
        CFRelease(v42);
LABEL_78:
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : migrated network type. isCarplay <%hhu>, isHome <%hhu>, isSpecialFrequentlyUsed <%hhu>", "WiFiManagerAddPrivateMacNetwork", cf, v40, v51);
      objc_autoreleasePoolPop(v52);
      v53 = objc_autoreleasePoolPush();
      v54 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v55 = sub_10002BE64((uint64_t)a2, CFSTR("NetworkOfInterestHomeState"));
        objc_msgSend(v54, "WFLog:message:", 3, "%s WFMacRandomisation : migrated network Home state: from known networks <%@>, From privateMac cache <%@>,", "WiFiManagerAddPrivateMacNetwork", v55, sub_10002BE64((uint64_t)v26, CFSTR("NetworkOfInterestHomeState")));
      }
      objc_autoreleasePoolPop(v53);
      v56 = sub_10001D90C((_QWORD *)a1, CFSTR("PrivateMacForceDisableForHome"));
      v57 = sub_10001D90C((_QWORD *)a1, CFSTR("PrivateMacTurnOffCarplayNetworks"));
      v206 = sub_10001D90C((_QWORD *)a1, CFSTR("ForceUseStaticMac"));
      v58 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("NetworkUsedForSWUpgrade"));
      v59 = sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacDefaultToOFF"));
      v60 = sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacProfileDefaultInitialValue"));
      if (v60)
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacProfileDefaultInitialValue"), v60);
      if (cf)
      {
        if (v57 && v57 == kCFBooleanTrue)
        {
          sub_1000AB448(a1, v26);
          sub_10002C478((uint64_t)v26, CFSTR("FeatureOffBySystemForCarplay"), v57);
        }
      }
      else if (v59)
      {
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacDefaultToOFF"), v59);
        v102 = sub_10002BE64((uint64_t)v26, CFSTR("PayloadUUID"));
        if (v102
          || (context[0] = -1, (v133 = (const __CFArray *)sub_10008674C(a1)) != 0)
          && (v134 = v133, sub_1000953B8(1, v133, a2, context, 0), context[0] != -1)
          && (ValueAtIndex = CFArrayGetValueAtIndex(v134, context[0])) != 0
          && (v102 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PayloadUUID"))) != 0)
        {
          v103 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Found payloadUUID for network %@", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
          objc_autoreleasePoolPop(v103);
          sub_10002C478((uint64_t)v26, CFSTR("PayloadUUID"), v102);
          v104 = objc_autoreleasePoolPush();
          v105 = *(void **)(a1 + 1480);
          if ((objc_msgSend(v105, "isWiFiNetworkMDMNetwork:", v26) & 1) != 0)
          {
            objc_autoreleasePoolPop(v104);
          }
          else
          {
            v137 = objc_msgSend(v105, "isSupervisedDevice");
            objc_autoreleasePoolPop(v104);
            if ((v137 & 1) == 0)
              goto LABEL_224;
          }
          v138 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> has/had profile based disable key ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
          objc_autoreleasePoolPop(v138);
          sub_1000AB448(a1, v26);
          *(_BYTE *)(a1 + 529) = 1;
        }
      }
      else if (v58 && v58 == kCFBooleanTrue)
      {
        v132 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> used during setup already. Skip data migration.", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
        objc_autoreleasePoolPop(v132);
      }
      else
      {
        v163 = sub_1000AB628(a1, (uint64_t)v26);
        if (!v163)
        {
          v164 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> evaluated eligible for classification as FALSE. ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
          objc_autoreleasePoolPop(v164);
        }
        if (v204 && v56 && v56 == kCFBooleanTrue)
        {
          v165 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Skipping home network disable", "WiFiManagerAddPrivateMacNetwork");
          objc_autoreleasePoolPop(v165);
        }
        if (v163)
        {
          v166 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated Network <%@> eligible for classification. Tagged. ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
          objc_autoreleasePoolPop(v166);
          v167 = sub_10009FEE0((const __CFArray *)a1);
          Mutable = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (valuePtr == 5)
          {
            v169 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Downgrading to physical MAC for setup network <%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
            objc_autoreleasePoolPop(v169);
            v170 = sub_100064FE0(1);
            CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v170);
            CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
            sub_10002C478((uint64_t)v26, CFSTR("NetworkUsedForSWUpgrade"), kCFBooleanTrue);
            v171 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Setup network detected <%@> and using physical MAC. Flag NetworkUsedForSWUpgrade", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
            objc_autoreleasePoolPop(v171);
          }
          else
          {
            v184 = *(const __CFData **)(a1 + 408);
            v183 = *(const __CFData **)(a1 + 416);
            v185 = *(const __CFData **)(a1 + 488);
            v186 = (const __CFString *)sub_10002B088(v26);
            v187 = sub_1000CE52C(v183, v184, v185, v186);
            v170 = sub_100064FE0(2);
            CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v170);
            CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v187);
            sub_10002C478((uint64_t)v26, CFSTR("RotationKeyUsed"), *(const void **)(a1 + 408));
            if (v187)
              CFRelease(v187);
          }
          if (v170)
            CFRelease(v170);
          sub_10002C478((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
          sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"), kCFBooleanTrue);
          sub_10002B698((uint64_t)v26, CFSTR("MacAddressRandomisationClassificationAttempts"), *(int *)(a1 + 388));
          sub_10002B698((uint64_t)v26, CFSTR("PrivateMacClassifyInterval"), *(int *)(a1 + 384));
          sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable);
          sub_10002C478((uint64_t)v26, CFSTR("PresentInKnownNetworks"), kCFBooleanTrue);
          sub_10002C478((uint64_t)v26, CFSTR("BlockRotation"), kCFBooleanTrue);
          sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), 0);
          sub_10002C478((uint64_t)v26, CFSTR("privateMacSuccessfulAssocAtleastOnce"), 0);
          if (v167)
          {
            v188 = (const __CFString *)sub_10002B088(v167);
            if (CFStringCompare(v188, value, 0) == kCFCompareEqualTo)
              sub_10002C478((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade"), v216);
          }
          if (Mutable)
            CFRelease(Mutable);
          if (v167)
            CFRelease(v167);
        }
      }
LABEL_224:
      if (v206 && v206 == kCFBooleanTrue)
      {
        v139 = (const __CFData *)sub_10002BE64((uint64_t)v26, CFSTR("RotationKeyUsed"));
        v140 = *(const __CFData **)(a1 + 416);
        v141 = *(const __CFData **)(a1 + 488);
        v142 = (const __CFString *)sub_10002B088(v26);
        if (v139)
          v143 = v139;
        else
          v143 = 0;
        v144 = sub_1000CE52C(v140, v143, v141, v142);
        v145 = (const __CFDictionary *)sub_10002BE64((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"));
        if (v145)
        {
          v146 = v145;
          v147 = CFDictionaryGetTypeID();
          if (v147 == CFGetTypeID(v146))
          {
            v148 = (const __CFNumber *)CFDictionaryGetValue(v146, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
            if (v148 && sub_100064F80(v148) == 3)
            {
              v149 = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              v150 = sub_100064FE0(3);
              CFDictionarySetValue(v149, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v150);
              CFDictionarySetValue(v149, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v144);
              sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v149);
              v151 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Force moved network <%@> to use static MAC", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
              objc_autoreleasePoolPop(v151);
              if (v149)
                CFRelease(v149);
              if (v150)
                CFRelease(v150);
            }
            if (sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress")))
              sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), v144);
          }
        }
        if (v144)
          CFRelease(v144);
      }
      v101 = CFSTR("TotalRotationsThisBuild");
      goto LABEL_244;
    case 6u:
      v61 = kCFBooleanTrue;
      sub_10002C478((uint64_t)v26, CFSTR("PresentInKnownNetworks"), kCFBooleanTrue);
      v62 = (const __CFDictionary *)sub_10002BE64((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"));
      v63 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("NetworkUsedForSWUpgrade"));
      if (v62 && (v64 = CFDictionaryGetTypeID(), v64 == CFGetTypeID(v62)))
      {
        v65 = (const __CFData *)CFDictionaryGetValue(v62, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
        v66 = sub_10002B75C(v65);
        MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, v62);
      }
      else
      {
        MutableCopy = 0;
        v66 = 0;
      }
      v106 = (CFBooleanRef)sub_10002BE64((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
      if (v106)
        v107 = v106 == kCFBooleanTrue;
      else
        v107 = 0;
      v108 = !v107;
      cfa = v108;
      sub_10002C478((uint64_t)v26, CFSTR("lastJoined"), v216);
      if (v66)
      {
        sub_10002C478((uint64_t)v26, CFSTR("BlockRotation"), 0);
        sub_10002C478((uint64_t)v26, CFSTR("LinkDownTimestamp"), 0);
        v109 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("NoAssociationWithNewMac"));
        sub_10002B698((uint64_t)v26, CFSTR("FailureCountThresholdCurrent"), *(unsigned int *)(a1 + 460));
        sub_10002C478((uint64_t)v26, CFSTR("privateMacSuccessfulAssocAtleastOnce"), kCFBooleanTrue);
        if (v109 && v109 == kCFBooleanTrue)
        {
          sub_10002C478((uint64_t)v26, CFSTR("NoAssociationWithNewMac"), kCFBooleanFalse);
          sub_10002C478((uint64_t)v26, CFSTR("FirstJoinWithNewMacTimestamp"), v216);
          sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), 0);
        }
        if (sub_10000BE8C((uint64_t)a2))
        {
          if (*(_BYTE *)(a1 + 377))
          {
            v110 = *(const __CFData **)(a1 + 416);
            v111 = v63;
            v112 = MutableCopy;
            v113 = *(const __CFData **)(a1 + 488);
            v114 = (const __CFString *)sub_10002B088(a2);
            v115 = v113;
            MutableCopy = v112;
            v63 = v111;
            v61 = kCFBooleanTrue;
            v116 = sub_1000CE7A0(v110, v115, v114);
            sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), v116);
            if (v116)
              CFRelease(v116);
          }
        }
        if ((cfa & 1) != 0)
        {
          if ((v10 & 1) == 0 || !v63 || v63 != v61)
          {
LABEL_206:
            if (MutableCopy)
              CFRelease(MutableCopy);
            goto LABEL_246;
          }
        }
        else
        {
          v130 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated network <%@> associated successfully with private Mac", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
          objc_autoreleasePoolPop(v130);
          sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
          sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
          sub_10002C478((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
          sub_10002C478((uint64_t)v26, CFSTR("NetworkUsedForSWUpgrade"), 0);
          if ((v10 & 1) == 0)
            goto LABEL_206;
        }
        if (sub_1000CEC50((CFDictionaryRef *)a2))
          v131 = 2;
        else
          v131 = 3;
        v128 = sub_100064FE0(v131);
        if (MutableCopy)
        {
          CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v128);
          sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
        }
        if (!v128)
          goto LABEL_206;
      }
      else
      {
        v119 = sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"));
        if (v119)
        {
          v120 = v119;
          v121 = CFDataGetTypeID();
          if (v121 == CFGetTypeID(v120))
          {
            if (MutableCopy)
            {
              CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v120);
              sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
            }
          }
        }
        if ((cfa & 1) != 0)
          goto LABEL_206;
        v122 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated network <%@> associated successfully with physical Mac", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
        objc_autoreleasePoolPop(v122);
        if (!sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade")))
          sub_10002C478((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade"), v216);
        if (!v63)
          goto LABEL_206;
        if (v63 != kCFBooleanTrue)
          goto LABEL_206;
        v124 = *(const __CFData **)(a1 + 408);
        v123 = *(const __CFData **)(a1 + 416);
        v125 = *(const __CFData **)(a1 + 488);
        v126 = (const __CFString *)sub_10002B088(v26);
        v127 = sub_1000CE52C(v123, v124, v125, v126);
        if (!v127)
          goto LABEL_206;
        v128 = v127;
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), v127);
        sub_10002C478((uint64_t)v26, CFSTR("MacGenerationTimeStamp"), v216);
        sub_10002C478((uint64_t)v26, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v26, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v26, CFSTR("RotationKeyUsed"), *(const void **)(a1 + 408));
        v129 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> used during setup marked to use private MAC next", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
        objc_autoreleasePoolPop(v129);
      }
      CFRelease(v128);
      goto LABEL_206;
    case 7u:
      sub_10002C478((uint64_t)v26, CFSTR("PresentInKnownNetworks"), kCFBooleanTrue);
      v68 = sub_10002B2DC((uint64_t)v7, (uint64_t)a2);
      v69 = sub_1000C5378((uint64_t)a2);
      v70 = sub_10002DA5C((_BOOL8)a2);
      v71 = sub_1000CB480((uint64_t)a2);
      v72 = (CFBooleanRef)sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacDefaultToOFF"));
      sub_10002C478((uint64_t)v68, CFSTR("PrivateMacDefaultToOFF"), v72);
      if (v68)
        CFRelease(v68);
      if (!v69 && !v70 && !v71)
        goto LABEL_246;
      v73 = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v73)
        goto LABEL_299;
      v74 = v73;
      if (!*(_BYTE *)(a1 + 376))
        goto LABEL_218;
      if (v72)
      {
        if (v72 == kCFBooleanTrue)
        {
LABEL_218:
          v136 = sub_100064FE0(1);
          CFDictionarySetValue(v74, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v136);
          CFDictionarySetValue(v74, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
          if (!v136)
            goto LABEL_298;
          goto LABEL_297;
        }
        v75 = 2;
      }
      else if (sub_1000CEC50((CFDictionaryRef *)a2))
      {
        v75 = 2;
      }
      else
      {
        v75 = 3;
      }
      v177 = sub_100064FE0(v75);
      CFDictionarySetValue(v74, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v177);
      if (v177)
        CFRelease(v177);
      v179 = *(const __CFData **)(a1 + 408);
      v178 = *(const __CFData **)(a1 + 416);
      v180 = *(const __CFData **)(a1 + 488);
      v181 = (const __CFString *)sub_10002B088(a2);
      v136 = sub_1000CE52C(v178, v179, v180, v181);
      v182 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Generated private mac address <%@> for profile network<%@> ", "WiFiManagerAddPrivateMacNetwork", v136, sub_10002B088(a2));
      objc_autoreleasePoolPop(v182);
      if (v136)
      {
        CFDictionarySetValue(v74, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v136);
        sub_10002C478((uint64_t)v26, CFSTR("MacGenerationTimeStamp"), v216);
        sub_10002C478((uint64_t)v26, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v26, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v26, CFSTR("RotationKeyUsed"), *(const void **)(a1 + 408));
LABEL_297:
        CFRelease(v136);
      }
LABEL_298:
      sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v74);
      sub_10002B698((uint64_t)v26, CFSTR("FailureCountThresholdCurrent"), *(unsigned int *)(a1 + 456));
      CFRelease(v74);
LABEL_299:
      if (v72)
      {
        sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
        sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
        v101 = CFSTR("PrivateMacFutureMacAddress");
LABEL_244:
        v152 = (uint64_t)v26;
        v153 = 0;
LABEL_245:
        sub_10002C478(v152, v101, v153);
      }
LABEL_246:
      v154 = (const void **)&kCFBooleanTrue;
      if (!v213)
        v154 = (const void **)&kCFBooleanFalse;
      sub_10002C478((uint64_t)v26, CFSTR("IsOpenNetwork"), *v154);
      v155 = CFNumberCreate(v7, kCFNumberIntType, &valuePtr);
      if (v155)
      {
        v156 = v155;
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacAddReason"), v155);
        CFRelease(v156);
      }
      v157 = (const __CFArray *)sub_1000875B0(a1);
      v158 = (uint64_t)v157;
      if (!v157)
      {
        v6 = v214;
        v9 = v216;
        v160 = v212;
LABEL_346:
        v162 = v211;
        goto LABEL_347;
      }
      sub_10002B7AC(v157, (const __CFDictionary **)a2, &v218, &v217);
      v159 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s:Adding network to private mac cache with reason <%u>  existingIndex %ld, insertIndex %ld", "WiFiManagerAddPrivateMacNetwork", valuePtr, v218, v217);
      objc_autoreleasePoolPop(v159);
      if (v218 == -1)
        CFArrayAppendValue((CFMutableArrayRef)v158, v26);
      else
        CFArraySetValueAtIndex((CFMutableArrayRef)v158, v218, v26);
      v160 = v212;
      v158 = sub_1000A46A8(a1, (const __CFArray *)v158);
      sub_1000A485C(a1, 1, 0);
      v6 = v214;
      v9 = v216;
      if (!(_DWORD)v158)
        goto LABEL_346;
      v161 = objc_autoreleasePoolPush();
      v162 = v211;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Added/replaced network <%@> to list of known private mac networks", value);
      objc_autoreleasePoolPop(v161);
      v158 = 1;
LABEL_347:
      CFRelease(theDict);
      if (v162)
        CFRelease(v162);
      if (v160)
        CFRelease(v160);
      if (v9)
LABEL_352:
        CFRelease(v9);
LABEL_353:
      objc_autoreleasePoolPop(v6);
      return v158;
    case 8u:
      v76 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : HS20 network <%@> being updated", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
      objc_autoreleasePoolPop(v76);
      v77 = (CFBooleanRef)sub_10002BE64((uint64_t)a2, CFSTR("PrivateMacDefaultToOFF"));
      v78 = (const __CFBoolean *)sub_10002BE64((uint64_t)a2, CFSTR("PrivateMacPrefChanged"));
      v79 = (CFBooleanRef)sub_10002BE64((uint64_t)a2, CFSTR("PrivateMacControlledDevice"));
      if (v78)
      {
        v80 = kCFBooleanTrue;
        if (v78 == kCFBooleanTrue || !v77)
          goto LABEL_246;
      }
      else
      {
        if (!v77)
          goto LABEL_246;
        v80 = kCFBooleanTrue;
      }
      if (v77 == v80)
      {
        v117 = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        cfb = sub_100064FE0(1);
        CFDictionarySetValue(v117, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), cfb);
        CFDictionarySetValue(v117, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
        v118 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : HS20 network <%@> default OFF provisioned", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(v26));
        objc_autoreleasePoolPop(v118);
        sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v117);
        if (v117)
          CFRelease(v117);
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFutureMacAddress"), 0);
        if (cfb)
          CFRelease(cfb);
      }
      if (v79 && v79 == v80)
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacControlledDevice"), v79);
      sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
      sub_10002C478((uint64_t)v26, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
      v101 = CFSTR("PrivateMacJoinDateAfterUpgrade");
      goto LABEL_244;
    case 9u:
      if (!v10)
        goto LABEL_246;
      v81 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
      if (v81)
      {
        if (v81 == kCFBooleanTrue)
          goto LABEL_246;
      }
      v82 = (const __CFDictionary *)sub_10002BE64((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"));
      if (v82)
        v83 = CFDictionaryCreateMutableCopy(v7, 0, v82);
      else
        v83 = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v172 = v83;
      v173 = (const __CFBoolean *)CFDictionaryGetValue(v83, CFSTR("PRIVATE_MAC_ADDRESS_VALID"));
      if (v173 && (v174 = v173, v173 == kCFBooleanFalse))
      {
        v175 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : rotation upgrade for network<%@>, maintain switch OFF with HW MAC ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
        objc_autoreleasePoolPop(v175);
        CFDictionarySetValue(v172, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), v174);
        CFDictionarySetValue(v172, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
      }
      else
      {
        if (sub_1000CEC50((CFDictionaryRef *)a2))
        {
          CFDictionarySetValue(v172, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), kCFBooleanTrue);
          v176 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : rotation upgrade for network<%@>, using rotating MAC with switch ON ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
        }
        else
        {
          CFDictionarySetValue(v172, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), kCFBooleanFalse);
          v176 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : rotation upgrade for network<%@>, using static MAC with switch OFF ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
        }
        objc_autoreleasePoolPop(v176);
      }
      v101 = CFSTR("PRIVATE_MAC_ADDRESS");
      v152 = (uint64_t)v26;
      v153 = v172;
      goto LABEL_245;
    case 0xAu:
      v84 = (const __CFDictionary *)sub_10002BE64((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"));
      v85 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Attempting to tri state upgrade for network<%@>", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2));
      objc_autoreleasePoolPop(v85);
      if (!v84)
        goto LABEL_246;
      v86 = (const __CFBoolean *)CFDictionaryGetValue(v84, CFSTR("PRIVATE_MAC_ADDRESS_VALID"));
      if (!v86)
        goto LABEL_246;
      v87 = v86;
      v88 = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v89 = (const __CFData *)CFDictionaryGetValue(v84, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
      if (!v89)
        v89 = (const __CFData *)CFDictionaryGetValue(v84, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
      v90 = sub_10002B75C(v89);
      if (v87 == kCFBooleanTrue)
        v91 = 2;
      else
        v91 = 3;
      if (v90)
        v92 = v91;
      else
        v92 = 1;
      v93 = sub_100064FE0(v92);
      CFDictionarySetValue(v88, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v93);
      if (v89)
        CFDictionarySetValue(v88, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v89);
      if (v93)
        CFRelease(v93);
      sub_10002C478((uint64_t)v26, CFSTR("PRIVATE_MAC_ADDRESS"), v88);
      if (v88)
        CFRelease(v88);
      v94 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : tri state upgrade for network<%@>, using switch state : %d ", "WiFiManagerAddPrivateMacNetwork", sub_10002B088(a2), v92);
      objc_autoreleasePoolPop(v94);
      v95 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedONtoOFF"));
      v96 = (const __CFBoolean *)sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedOFFtoON"));
      if (v95 && v95 == kCFBooleanTrue || v96 && v96 == kCFBooleanTrue)
      {
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacPrefChanged"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedONtoOFF"), 0);
        sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedOFFtoON"), 0);
      }
      v97 = (unint64_t)sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedONtoOFFTimestamp"));
      v98 = (const __CFDate *)sub_10002BE64((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedOFFtoONTimestamp"));
      if (!(v97 | (unint64_t)v98))
        goto LABEL_246;
      v99 = v98;
      if (CFDateCompare((CFDateRef)v97, v98, 0) == kCFCompareGreaterThan)
        v100 = (const void *)v97;
      else
        v100 = v99;
      sub_10002C478((uint64_t)v26, CFSTR("PrivateMacPrefChangedTimestamp"), v100);
      sub_10002C478((uint64_t)v26, CFSTR("PrivateMacFeatureTurnedONtoOFFTimestamp"), 0);
      v101 = CFSTR("PrivateMacFeatureTurnedOFFtoONTimestamp");
      goto LABEL_244;
    default:
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s:Invalid Add reason", "WiFiManagerAddPrivateMacNetwork");
      objc_autoreleasePoolPop(v32);
      goto LABEL_246;
  }
}

id sub_1000AA26C(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  if (a1 && (v3 = *(void **)(a1 + 2112)) != 0)
  {
    v4 = objc_msgSend(v3, "appInForeground");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null appStateManager", "__WiFiManagerIsAppInForeground");
    objc_autoreleasePoolPop(v6);
    v4 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v4;
}

const __CFNumber *sub_1000AA2FC(const __CFNumber *result, CFDictionaryRef theDict)
{
  void *v2;
  WiFiUserInteractionMonitor *v3;
  void *v4;
  uint64_t valuePtr;

  if (result)
  {
    if (theDict)
    {
      result = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("NetworkAppOverride"));
      if (result)
      {
        valuePtr = 0;
        CFNumberGetValue(result, kCFNumberLongLongType, &valuePtr);
        v2 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting user interaction override to networking application with mask=0x%llx", "WiFiManagerSetUserInteractionOverride", valuePtr);
        objc_autoreleasePoolPop(v2);
        v3 = +[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance");
        return (const __CFNumber *)-[WiFiUserInteractionMonitor setOverrideApplicationState:](v3, "setOverrideApplicationState:", valuePtr);
      }
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resetting user interaction overrides", "WiFiManagerSetUserInteractionOverride");
      objc_autoreleasePoolPop(v4);
      return (const __CFNumber *)-[WiFiUserInteractionMonitor resetOverrideStates](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "resetOverrideStates");
    }
  }
  return result;
}

const __CFNumber *sub_1000AA3FC(const __CFNumber *result, CFDictionaryRef theDict)
{
  const void *Value;
  void *v4;
  WiFiUserInteractionMonitor *v5;
  void *v6;
  uint64_t valuePtr;

  if (result)
  {
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, CFSTR("NetworkPropSsidOverride"));
      result = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("NetworkPropOverrideMask"));
      if (result)
      {
        valuePtr = 0;
        CFNumberGetValue(result, kCFNumberLongLongType, &valuePtr);
        v4 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting user interaction network override for ssid %@ with mask=0x%llx", "WiFiManagerSetUserInteractionNwOverride", Value, valuePtr);
        objc_autoreleasePoolPop(v4);
        v5 = +[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance");
        -[WiFiUserInteractionMonitor updateOverrideNetworkState:overrideValue:](v5, "updateOverrideNetworkState:overrideValue:", Value, valuePtr);
        return (const __CFNumber *)-[WiFiUserInteractionMonitor dumpOverrideNetworkState](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "dumpOverrideNetworkState");
      }
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resetting user interaction network overrides", "WiFiManagerSetUserInteractionNwOverride");
      objc_autoreleasePoolPop(v6);
      return (const __CFNumber *)-[WiFiUserInteractionMonitor resetOverrideNetworkStates](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "resetOverrideNetworkStates");
    }
  }
  return result;
}

uint64_t sub_1000AA528(uint64_t a1, const __CFString *a2, int a3, const void *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  CFTypeID TypeID;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  const void *ValueAtIndex;
  const void *v17;
  CFTypeID v18;
  const __CFString *v19;
  void *v20;
  int v21;
  void *v22;
  __CFDictionary *Mutable;
  __CFDictionary *v24;
  _WORD *v25;
  CFTypeID v26;
  void *v27;
  void *v28;
  void *v30;
  uint64_t v31;
  const void *v32;
  uint64_t v33;

  v5 = 0;
  v6 = 0;
  if (!a1)
  {
LABEL_35:
    v7 = v5;
    goto LABEL_38;
  }
  v7 = 0;
  if (!a2)
    goto LABEL_38;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  if (*(_BYTE *)(a1 + 376))
    LODWORD(v31) = a3;
  if (a4)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(a4))
      v32 = a4;
  }
  v11 = (const __CFArray *)sub_1000875B0(a1);
  v12 = v11;
  if (v11)
  {
    Count = CFArrayGetCount(v11);
    if (Count >= 1)
    {
      v14 = Count;
      v15 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v12, v15);
        if (!ValueAtIndex)
          break;
        v17 = ValueAtIndex;
        v18 = CFGetTypeID(ValueAtIndex);
        if (v18 != sub_1000C312C())
          break;
        v19 = (const __CFString *)sub_10002B088(v17);
        if (CFStringCompare(v19, a2, 0) == kCFCompareEqualTo)
        {
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : updating Network <%@> found in PrivateMacCache. Private mac pref is : <%d>", "WiFiManagerSetPrivateMacPrefForScanRecord", v19, v31);
          objc_autoreleasePoolPop(v20);
          if (sub_1000AA894(a1, v17, (uint64_t)&v31))
          {
            v21 = 0;
            goto LABEL_19;
          }
        }
        if (v14 == ++v15)
          goto LABEL_18;
      }
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : networkFromPrivateMacCache is invalid", "WiFiManagerSetPrivateMacPrefForScanRecord");
      objc_autoreleasePoolPop(v30);
LABEL_45:
      v5 = 0;
      v6 = 0;
      goto LABEL_37;
    }
  }
LABEL_18:
  v21 = 1;
LABEL_19:
  if (!sub_1000A46A8(a1, v12))
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Unable to Set private mac cache to device manager", "WiFiManagerSetPrivateMacPrefForScanRecord");
    objc_autoreleasePoolPop(v22);
  }
  v5 = 1;
  sub_1000A485C(a1, 1, 0);
  if (!v21)
  {
    v7 = 0;
    v6 = 1;
    goto LABEL_38;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    goto LABEL_45;
  v24 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("SSID_STR"), a2);
  v25 = sub_10002B314((uint64_t)kCFAllocatorDefault, v24);
  v6 = (uint64_t)v25;
  if (v25)
  {
    v26 = CFGetTypeID(v25);
    if (v26 == sub_1000C312C()
      && sub_1000AA894(a1, (const void *)v6, (uint64_t)&v31)
      && sub_1000A7EE0(a1, (void *)v6, 2))
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Adding new Network <%@> to PrivateMacCache. Private mac pref is : <%d>", "WiFiManagerSetPrivateMacPrefForScanRecord", a2, v31);
      objc_autoreleasePoolPop(v27);
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    CFRelease(v24);
    CFRelease((CFTypeRef)v6);
    v6 = 0;
    goto LABEL_35;
  }
  CFRelease(v24);
  v5 = 0;
LABEL_37:
  v7 = 0;
LABEL_38:
  v28 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Update private mac pref for network <%@> complete with status : <%d>. Found in private mac cache : <%d>, Added to private mac cache : <%d> ", "WiFiManagerSetPrivateMacPrefForScanRecord", a2, v5, v6, v7);
  objc_autoreleasePoolPop(v28);
  return v5;
}

uint64_t sub_1000AA894(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  CFAbsoluteTime Current;
  CFDateRef v7;
  uint64_t v8;
  const __CFNumber *v9;
  void *v10;
  const __CFDictionary *v11;
  const __CFBoolean *v12;
  CFTypeID TypeID;
  const __CFNumber *Value;
  __CFDictionary *MutableCopy;
  BOOL v16;
  void *v17;
  const __CFData *v18;
  unsigned int v19;
  unsigned int v20;
  CFTypeID v21;
  void *v22;

  v5 = objc_autoreleasePoolPush();
  Current = CFAbsoluteTimeGetCurrent();
  v7 = CFDateCreate(kCFAllocatorDefault, Current);
  v8 = 0;
  v9 = 0;
  if (!a2 || !a3)
    goto LABEL_30;
  v10 = v5;
  v11 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("PRIVATE_MAC_ADDRESS"));
  v12 = (const __CFBoolean *)sub_10002BE64((uint64_t)a2, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
  v9 = sub_100064FE0(*(_DWORD *)a3);
  if (v11 && (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v11)))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v11);
    v16 = 1;
    if (Value && v9)
      v16 = CFNumberCompare(Value, v9, 0) == kCFCompareEqualTo;
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v16 = 1;
  }
  if (MutableCopy)
  {
    if (!v16)
    {
      sub_10002C478((uint64_t)a2, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
      if (v12 && v12 == kCFBooleanTrue)
      {
        sub_10002C478((uint64_t)a2, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacClassifyInterval"), 0);
        sub_10002B698((uint64_t)a2, CFSTR("FailureCountThresholdCurrent"), *(unsigned int *)(a1 + 456));
        v12 = kCFBooleanFalse;
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migration keys removed for network <%@> because user toggled Private Mac preference", "__WiFiManagerUpdateNetworkWithPrivateMacInfo", sub_10002B088(a2));
        objc_autoreleasePoolPop(v17);
      }
      if (sub_10002BE64((uint64_t)a2, CFSTR("PrivateMacDefaultToOFF")))
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacDefaultToOFF"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("FeatureOffBySystemForHome"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("FeatureOffBySystemForCarplay"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("FeatureOFFBySystemForFrequentlyUsedNetworks"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("PrivateMacFeatureToggled"), kCFBooleanTrue);
      sub_10002C478((uint64_t)a2, CFSTR("BlockRotation"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("NetworkUsedForSWUpgrade"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("PrivateMacPrefChanged"), kCFBooleanTrue);
      sub_10002C478((uint64_t)a2, CFSTR("PrivateMacPrefChangedTimestamp"), v7);
    }
    v5 = v10;
    CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v9);
    v18 = (const __CFData *)CFDictionaryGetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
    v19 = sub_10002B75C(v18);
    if (*(_DWORD *)a3 == 1)
    {
      CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
    }
    else if (*(_QWORD *)(a3 + 8))
    {
      v20 = v19;
      v21 = CFDataGetTypeID();
      if (v21 == CFGetTypeID(*(CFTypeRef *)(a3 + 8)) && !v20 && (!v12 || v12 != kCFBooleanTrue))
      {
        CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a3 + 8));
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Accepted Private Mac Address from UI <%@> for network <%@>", "__WiFiManagerUpdateNetworkWithPrivateMacInfo", *(_QWORD *)(a3 + 8), sub_10002B088(a2));
        objc_autoreleasePoolPop(v22);
        sub_10002C478((uint64_t)a2, CFSTR("MacGenerationTimeStamp"), v7);
        sub_10002C478((uint64_t)a2, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
        sub_10002C478((uint64_t)a2, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
      }
    }
    sub_10002C478((uint64_t)a2, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
    CFRelease(MutableCopy);
    v8 = 1;
LABEL_30:
    if (!v7)
      goto LABEL_32;
    goto LABEL_31;
  }
  v8 = 0;
  if (v7)
LABEL_31:
    CFRelease(v7);
LABEL_32:
  if (v9)
    CFRelease(v9);
  objc_autoreleasePoolPop(v5);
  return v8;
}

void sub_1000AAD20(uint64_t a1, const __CFDictionary **a2)
{
  const __CFArray *v3;
  __CFArray *v4;
  void *v5;
  void *v6;
  const void *v7;
  uint64_t v8;
  CFIndex idx;

  v8 = 0;
  idx = -1;
  if (a1)
  {
    if (a2)
    {
      v3 = (const __CFArray *)sub_1000875B0(a1);
      if (v3)
      {
        v4 = v3;
        sub_10002B7AC(v3, a2, &idx, &v8);
        if (idx != -1)
        {
          v5 = objc_autoreleasePoolPush();
          v6 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v7 = sub_10002B088(a2);
            objc_msgSend(v6, "WFLog:message:", 3, "%s WFMacRandomisation : Removed a record : <%@>", "__WiFiManagerPrivateMacRemoveNetwork", v7, v8);
          }
          objc_autoreleasePoolPop(v5);
          CFArrayRemoveValueAtIndex(v4, idx);
        }
      }
    }
  }
}

void sub_1000AADDC(const __CFArray *a1, void *a2, CFIndex *a3, _QWORD *a4)
{
  CFIndex Count;
  uint64_t v9;
  CFTypeID v10;
  CFIndex v11;
  const void **ValueAtIndex;
  const __CFBoolean *v13;
  void *v14;

  if (!a1)
    goto LABEL_12;
  Count = CFArrayGetCount(a1);
  if (!Count)
    goto LABEL_12;
  if (!a2 || (v9 = Count, v10 = CFGetTypeID(a2), v10 != sub_1000C312C()))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid network ref", "__GetPrivateMacHS20ProvisionedNetworkMatch");
    objc_autoreleasePoolPop(v14);
    goto LABEL_12;
  }
  if (v9 < 1)
  {
LABEL_12:
    v11 = -1;
    goto LABEL_13;
  }
  v11 = 0;
  while (1)
  {
    ValueAtIndex = (const void **)CFArrayGetValueAtIndex(a1, v11);
    v13 = (const __CFBoolean *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("NetworkAddedByProfile"));
    if (sub_10002DA5C((_BOOL8)ValueAtIndex)
      && v13
      && v13 == kCFBooleanTrue
      && sub_1000CE080(ValueAtIndex, (const __CFDictionary **)a2))
    {
      break;
    }
    if (v9 == ++v11)
      goto LABEL_12;
  }
LABEL_13:
  if (a4)
    *a4 = 0;
  if (a3)
    *a3 = v11;
}

const void *sub_1000AAF20(uint64_t a1, const __CFDictionary **a2)
{
  const __CFArray *v3;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerRetrievePrivateMacNetworkVersionFromCache");
    goto LABEL_9;
  }
  if (!a2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "__WiFiManagerRetrievePrivateMacNetworkVersionFromCache");
LABEL_9:
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  v3 = (const __CFArray *)sub_1000875B0(a1);
  if (v3)
    return sub_10002B634(v3, a2);
  return 0;
}

void sub_1000AAFDC(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  const void *v7;
  void *v8;
  const void *v9;
  void *v10;
  const void *v11;
  _BOOL4 v12;
  _BOOL4 v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  CFBooleanRef v18;
  const void *v19;
  CFBooleanRef v20;
  const void *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  const __CFBoolean *v24;
  int v25;
  _BOOL4 v26;
  int v27;

  if (a1 && a2)
  {
    v4 = sub_10002BE64(a2, CFSTR("BSSID"));
    if (v4)
      sub_10002C478(a1, CFSTR("BSSID"), v4);
    v5 = sub_10002BE64(a2, CFSTR("addedAt"));
    if (v5)
      sub_10002C478(a1, CFSTR("addedAt"), v5);
    if (&_CNForgetSSID)
    {
      if (sub_10002BE64(a2, kCNSNetworkWasCaptiveProperty))
      {
        v6 = (void *)kCNSNetworkWasCaptiveProperty;
        v7 = sub_10002BE64(a2, kCNSNetworkWasCaptiveProperty);
        sub_10002C478(a1, v6, v7);
      }
      if (sub_10002BE64(a2, kCNSCaptiveNetworkProperty))
      {
        v8 = (void *)kCNSCaptiveNetworkProperty;
        v9 = sub_10002BE64(a2, kCNSCaptiveNetworkProperty);
        sub_10002C478(a1, v8, v9);
      }
      if (sub_10002BE64(a2, kCNSDisabledByCaptiveProperty) && !sub_10002BE64(a1, kCNSDisabledByCaptiveProperty))
      {
        v10 = (void *)kCNSDisabledByCaptiveProperty;
        v11 = sub_10002BE64(a2, kCNSDisabledByCaptiveProperty);
        sub_10002C478(a1, v10, v11);
      }
    }
    v12 = sub_10002DAB4(a2);
    v13 = sub_1000C5378(a2);
    v22 = sub_10002DA5C(a2);
    v23 = sub_1000CB480(a2);
    v24 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("PrivateMacDefaultToOFF"));
    v14 = sub_10002BE64(a2, CFSTR("DomainName"));
    v15 = sub_10002BE64(a2, CFSTR("DisplayedOperatorName"));
    v27 = sub_10000BE8C(a2);
    v16 = sub_10002BE64(a2, CFSTR("PayloadUUID"));
    v17 = sub_10002BE64(a2, CFSTR("PolicyUUID"));
    v25 = sub_100007828(a2);
    v26 = sub_1000CEDAC(a2);
    if (v16)
      sub_10002C478(a1, CFSTR("PayloadUUID"), v16);
    if (v17)
      sub_10002C478(a1, CFSTR("PolicyUUID"), v17);
    v18 = (CFBooleanRef)sub_10002BE64(a2, CFSTR("NetworkAddedByProfile"));
    if (v12)
      sub_10002C478(a1, CFSTR("IsEapNetwork"), kCFBooleanTrue);
    if (v18 && v18 == kCFBooleanTrue)
      sub_10002C478(a1, CFSTR("NetworkAddedByProfile"), v18);
    if (v13)
      sub_10002C478(a1, CFSTR("isProfileBasedNetwork"), kCFBooleanTrue);
    if (v22)
      sub_10002C478(a1, CFSTR("isHs20BasedNetwork"), kCFBooleanTrue);
    v19 = v15;
    if (v23)
      sub_10002C478(a1, CFSTR("isCarrierBundleBased"), kCFBooleanTrue);
    v20 = v24;
    if (!sub_10002BE64(a1, CFSTR("PrivateMacDefaultToOFF")) && v24)
    {
      if (v24 != kCFBooleanTrue)
        v20 = kCFBooleanFalse;
      sub_10002C478(a1, CFSTR("PrivateMacDefaultToOFF"), v20);
      sub_10002C478(a1, CFSTR("PrivateMacProfileDefaultInitialValue"), v20);
    }
    if (v14)
      sub_10002C478(a1, CFSTR("DomainName"), v14);
    if (v19)
      sub_10002C478(a1, CFSTR("DisplayedOperatorName"), v19);
    if (v27)
      sub_10002C478(a1, CFSTR("IsCarplayNetwork"), kCFBooleanTrue);
    if (v25)
      sub_10002C478(a1, CFSTR("PublicAirPlayNetwork"), kCFBooleanTrue);
    if (v26)
    {
      v21 = sub_10002BE64(a2, CFSTR("AccessoryIdentifier"));
      if (v21)
        sub_10002C478(a1, CFSTR("AccessoryIdentifier"), v21);
    }
  }
}

BOOL sub_1000AB400(_BOOL8 result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    return sub_1000C3F88(result) == 1 || sub_1000CC270(v1) == 2;
  }
  return result;
}

void sub_1000AB448(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v4;
  CFNumberRef v5;
  void *v6;

  if (a1)
  {
    if (a2)
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v4 = Mutable;
        v5 = sub_100064FE0(1);
        CFDictionarySetValue(v4, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v5);
        if (v5)
          CFRelease(v5);
        sub_10002C478((uint64_t)a2, CFSTR("PRIVATE_MAC_ADDRESS"), v4);
        sub_10002C478((uint64_t)a2, CFSTR("BlockRotation"), kCFBooleanTrue);
        CFRelease(v4);
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Force disabling private MAC for migrated Network : <%@>", "__WiFiManagerPrivateMacForceTurnOffMigratedNetwork", sub_10002B088(a2));
        objc_autoreleasePoolPop(v6);
        sub_10002C478((uint64_t)a2, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacFeatureTurnedONtoOFF"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacFeatureTurnedONtoOFFTimestamp"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacFeatureTurnedOFFtoON"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacFeatureTurnedOFFtoONTimestamp"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacPrefChanged"), 0);
        sub_10002C478((uint64_t)a2, CFSTR("PrivateMacPrefChangedTimestamp"), 0);
      }
    }
  }
}

BOOL sub_1000AB628(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  const __CFBoolean *v5;
  const __CFBoolean *v6;
  const __CFBoolean *v7;
  CFBooleanRef v8;
  const __CFBoolean *v9;
  const void *v10;
  const void *v11;
  BOOL v12;
  char v13;
  CFTypeID TypeID;
  CFTypeID v15;
  BOOL v16;

  result = 0;
  if (a1 && a2)
  {
    v5 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("PrivateMacFeatureTurnedONtoOFF"));
    v6 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("PrivateMacFeatureTurnedOFFtoON"));
    v7 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("PrivateMacPrefChanged"));
    sub_10002BE64(a2, CFSTR("IsOpenNetwork"));
    v8 = (CFBooleanRef)sub_10002BE64(a2, CFSTR("privateMacSuccessfulAssocAtleastOnce"));
    v9 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("PrivateMacDefaultToOFF"));
    v10 = sub_10002BE64(a2, CFSTR("PRIVATE_MAC_ADDRESS"));
    if (v10)
    {
      v11 = v10;
      if (v8)
        v12 = v8 == kCFBooleanTrue;
      else
        v12 = 0;
      v13 = v12;
      TypeID = CFDictionaryGetTypeID();
      v15 = CFGetTypeID(v11);
      v12 = TypeID == v15;
      result = TypeID != v15;
      if (v12 && (v13 & 1) == 0)
      {
        if (v6 && v6 == kCFBooleanTrue
          || v5 && v5 == kCFBooleanTrue
          || v7 && v7 == kCFBooleanTrue
          || v9 && v9 == kCFBooleanFalse
          || sub_10000BE8C(a2))
        {
          return 0;
        }
        else
        {
          if (v9)
            v16 = v9 == kCFBooleanTrue;
          else
            v16 = 0;
          return !v16;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000AB7A0(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2;
  const void **v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  const __CFArray *Copy;
  CFIndex v9;
  const __CFDictionary **ValueAtIndex;
  void *v11;

  v2 = 0;
  if (!a1 || !a2)
    return v2;
  v4 = (const void **)sub_10002B2DC((uint64_t)kCFAllocatorDefault, a2);
  v5 = (const __CFArray *)sub_1000875B0(a1);
  Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
    Copy = 0;
  }
  else
  {
    v7 = Count;
    Copy = CFArrayCreateCopy(kCFAllocatorDefault, *(CFArrayRef *)(a1 + 352));
    if (Copy)
    {
      v9 = 0;
      v2 = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary **)CFArrayGetValueAtIndex(Copy, v9);
        if (sub_1000CE080(v4, ValueAtIndex))
        {
          sub_1000AAD20(a1, ValueAtIndex);
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : %s removed a HS20 network/provisioning <%@>", "__WiFiManagerPrivateMacRemoveHS20Networks", sub_10002B088(ValueAtIndex));
          objc_autoreleasePoolPop(v11);
          v2 = 1;
        }
        ++v9;
      }
      while (v7 != v9);
      if (!v4)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  v2 = 0;
  if (v4)
LABEL_12:
    CFRelease(v4);
LABEL_13:
  if (Copy)
    CFRelease(Copy);
  return v2;
}

BOOL sub_1000AB8F4(uint64_t a1, const __CFDictionary **a2, const __CFDictionary **a3)
{
  const void *v5;
  const void *v6;
  _BOOL8 result;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFNumber *Value;
  const __CFNumber *v11;
  BOOL v12;

  v5 = sub_1000AAF20(a1, a2);
  v6 = sub_1000AAF20(a1, a3);
  result = 0;
  if (v5)
  {
    if (v6)
    {
      v8 = (const __CFDictionary *)sub_10002BE64((uint64_t)v5, CFSTR("PRIVATE_MAC_ADDRESS"));
      v9 = (const __CFDictionary *)sub_10002BE64((uint64_t)v6, CFSTR("PRIVATE_MAC_ADDRESS"));
      result = 0;
      if (v8)
      {
        if (v9)
        {
          Value = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
          v11 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
          if (Value)
            v12 = v11 == 0;
          else
            v12 = 1;
          return !v12 && CFNumberCompare(Value, v11, 0) == kCFCompareEqualTo;
        }
      }
    }
  }
  return result;
}

BOOL sub_1000AB9C8(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  BOOL v12;
  BOOL v13;
  _BOOL8 v14;

  v8 = (const __CFString *)sub_1000A258C(a1, a2, a3);
  v9 = (const __CFString *)sub_1000A258C(a1, a2, a4);
  v10 = (const __CFString *)sub_1000A28AC(a1, a2, a3);
  v11 = (const __CFString *)sub_1000A28AC(a1, a2, a4);
  if (v8)
  {
    if (CFStringCompare(v8, kSCValNetIPv4ConfigMethodDHCP, 0))
      v12 = 1;
    else
      v12 = v9 == 0;
    v14 = 0;
    if (!v12)
    {
      v13 = CFStringCompare(v9, kSCValNetIPv4ConfigMethodDHCP, 0) || v10 == 0;
      if (!v13
        && CFStringCompare(v10, kSCValNetIPv6ConfigMethodAutomatic, 0) == kCFCompareEqualTo
        && v11
        && CFStringCompare(v11, kSCValNetIPv6ConfigMethodAutomatic, 0) == kCFCompareEqualTo)
      {
        v14 = 1;
      }
    }
    CFRelease(v8);
    if (!v9)
      goto LABEL_17;
    goto LABEL_16;
  }
  v14 = 0;
  if (v9)
LABEL_16:
    CFRelease(v9);
LABEL_17:
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  return v14;
}

__CFDictionary *sub_1000ABB0C(unsigned int *a1)
{
  __CFDictionary *Mutable;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  void *v16;
  _BOOL4 valuePtr;

  if (!a1)
    return 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    valuePtr = *((_BYTE *)a1 + 376) != 0;
    v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(Mutable, CFSTR("enabled"), v3);
    if (v3)
      CFRelease(v3);
    v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 95);
    if (v4)
    {
      v5 = v4;
      CFDictionaryAddValue(Mutable, CFSTR("scanTimeout"), v4);
      CFRelease(v5);
    }
    v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 96);
    if (v6)
    {
      v7 = v6;
      CFDictionaryAddValue(Mutable, CFSTR("migrationInterval"), v6);
      CFRelease(v7);
    }
    v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 97);
    if (v8)
    {
      v9 = v8;
      CFDictionaryAddValue(Mutable, CFSTR("migrationAttempts"), v8);
      CFRelease(v9);
    }
    v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 98);
    if (v10)
    {
      v11 = v10;
      CFDictionaryAddValue(Mutable, CFSTR("keyRotationInterval"), v10);
      CFRelease(v11);
    }
    v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 99);
    if (v12)
    {
      v13 = v12;
      CFDictionaryAddValue(Mutable, CFSTR("inactiveNetworkInterval"), v12);
      CFRelease(v13);
    }
    v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 100);
    if (v14)
    {
      v15 = v14;
      CFDictionaryAddValue(Mutable, CFSTR("nonTrustworthyInactiveNetworkInterval"), v14);
      CFRelease(v15);
    }
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Returning parameters to client: enabled <%d>, scanTimeOut <%d>, keyRotationInterval <%d>, migrationClassificationInterval <%d>, inactiveNetworkInterval <%d>, nonTrustworthyInactiveNetworkInterval <%d>", *((unsigned __int8 *)a1 + 376), a1[95], a1[98], a1[96], a1[99], a1[100]);
    objc_autoreleasePoolPop(v16);
  }
  return Mutable;
}

const __CFNumber *sub_1000ABD48(uint64_t a1, const __CFString *a2)
{
  const __CFNumber *v2;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFNumber *Value;
  void *v13;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = (const __CFArray *)sub_1000875B0(a1);
    if (v4)
    {
      v5 = v4;
      Count = CFArrayGetCount(v4);
      if (Count < 1)
      {
        v2 = 0;
      }
      else
      {
        v7 = Count;
        v8 = 0;
        v2 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v5, v8);
          v10 = (const __CFString *)sub_10002B088(ValueAtIndex);
          if (CFStringCompare(v10, a2, 0) == kCFCompareEqualTo)
          {
            v11 = (const __CFDictionary *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PRIVATE_MAC_ADDRESS"));
            if (v11)
            {
              Value = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
              v2 = sub_100064F80(Value);
            }
          }
          ++v8;
        }
        while (v7 != v8);
      }
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Returning parameters to client for network [%@]: privateMacSwitchState <%d>", a2, v2);
      objc_autoreleasePoolPop(v13);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_1000ABE64(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    v2[0] = a1;
    v2[1] = 0xAAAAAAAA00000070;
    v2[2] = a2;
    v2[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  }
}

uint64_t sub_1000ABEAC(uint64_t a1, const void *a2)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  CFTypeID v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  if (!a1)
    goto LABEL_22;
  if (!a2)
    goto LABEL_22;
  v4 = (const __CFString *)sub_10002B088(a2);
  if (!v4)
    goto LABEL_22;
  v5 = v4;
  v6 = (const __CFString *)sub_10002BE64((uint64_t)a2, CFSTR("UpdateReason"));
  if (!v6)
    goto LABEL_22;
  v7 = v6;
  v8 = CFGetTypeID(v6);
  if (v8 != CFStringGetTypeID())
    goto LABEL_22;
  if (CFStringCompare(v7, CFSTR("UpdatePrivateMacReasonMigration"), 0) == kCFCompareEqualTo)
  {
    if (CFStringCompare(CFSTR("Apple Store"), v5, 0))
    {
      v9 = a1;
      v10 = (void *)a2;
      v11 = 4;
      goto LABEL_16;
    }
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Skipping migration for network <%@>", v5);
    goto LABEL_21;
  }
  if (CFStringCompare(v7, CFSTR("ProfileAddition"), 0) == kCFCompareEqualTo)
  {
    v9 = a1;
    v10 = (void *)a2;
    v11 = 7;
    goto LABEL_16;
  }
  if (CFStringCompare(v7, CFSTR("UpdatePrivateMacReasonMigrateToRotation"), 0) == kCFCompareEqualTo)
  {
    if (CFStringCompare(CFSTR("Apple Store"), v5, 0))
    {
      v9 = a1;
      v10 = (void *)a2;
      v11 = 9;
      goto LABEL_16;
    }
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Skipping rotation migration for network <%@>", v5);
LABEL_21:
    objc_autoreleasePoolPop(v13);
    goto LABEL_22;
  }
  if (CFStringCompare(v7, CFSTR("UpdatePrivateMacReasonMigrateToTriState"), 0))
  {
LABEL_22:
    v12 = 1;
    goto LABEL_23;
  }
  v9 = a1;
  v10 = (void *)a2;
  v11 = 10;
LABEL_16:
  v12 = sub_1000A7EE0(v9, v10, v11);
LABEL_23:
  sub_10002C478((uint64_t)a2, CFSTR("UpdateReason"), 0);
  return v12;
}

void sub_1000AC08C(uint64_t a1, int a2)
{
  void *v4;
  void *v5;
  void *v6;
  const void **v7;
  const __CFDate *v8;
  const __CFDate *v9;
  CFBooleanRef *v10;
  const void *v11;
  const void *v12;
  unsigned int v13;
  unint64_t v14;

  v4 = objc_autoreleasePoolPush();
  v5 = sub_10009FEE0((const __CFArray *)a1);
  v6 = v5;
  if (a1)
  {
    if (v5)
    {
      v7 = *(const void ***)(a1 + 472);
      if (v7)
      {
        if (sub_1000CE080(v7, (const __CFDictionary **)v6))
        {
          v8 = (const __CFDate *)sub_10002E000(v6);
          v9 = (const __CFDate *)sub_10002E000(*(const void **)(a1 + 472));
          if (!v8 || !v9 || CFDateGetTimeIntervalSinceDate(v8, v9) < 1.0)
          {
            v10 = (CFBooleanRef *)&kCFBooleanTrue;
            if (!a2)
              v10 = (CFBooleanRef *)&kCFBooleanFalse;
            sub_100096B7C(a1, *(void **)(a1 + 472), CFSTR("isBackhaulLinkUp"), *v10);
            v11 = sub_10002B634(*(const __CFArray **)(a1 + 352), (const __CFDictionary **)v6);
            if (!a2 && v11)
            {
              v14 = 0xAAAAAAAAAAAAAAAALL;
              v13 = 7;
              sub_100061728((uint64_t)v11, (uint64_t)&v13);
              sub_100061494(&v13);
            }
          }
        }
      }
    }
  }
  v12 = *(const void **)(a1 + 472);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 472) = 0;
  }
  if (v6)
    CFRelease(v6);
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_1000AC1B0(const __CFArray *a1, const void *a2)
{
  void *v4;
  void *v5;
  const void *v6;
  uint64_t v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFTypeID TypeID;
  const __CFData *Value;
  unsigned int v12;
  void *v13;
  void *v14;
  const void *v15;
  uint64_t v16;
  const __CFBoolean *v17;
  BOOL v18;
  uint64_t v20;

  v4 = sub_10009FEE0(a1);
  v5 = v4;
  if (!a1 || !a2 || !*((_BYTE *)a1 + 376) || !v4)
  {
    v16 = 0;
    if (!v4)
      return v16;
    goto LABEL_24;
  }
  if (!sub_1000C6060((uint64_t)a2, (uint64_t)v4))
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v15 = sub_10002B088(v5);
      objc_msgSend(v14, "WFLog:message:", 3, "%s: WFMacRandomisation : dont request quick probe check. This is a different network. Current Network <%@>, request for network <%@>", "WiFiManagerPrivateMacIsQuickProbeRequired", v15, sub_10002B088(a2));
    }
    goto LABEL_12;
  }
  v6 = sub_1000AAF20((uint64_t)a1, (const __CFDictionary **)v5);
  if (!v6)
    goto LABEL_23;
  v7 = (uint64_t)v6;
  v8 = (const __CFDictionary *)sub_10002BE64((uint64_t)v6, CFSTR("PRIVATE_MAC_ADDRESS"));
  if (v8 && (v9 = v8, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v9)))
  {
    Value = (const __CFData *)CFDictionaryGetValue(v9, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
    v12 = sub_10002B75C(Value);
  }
  else
  {
    v12 = 1;
  }
  v17 = (const __CFBoolean *)sub_10002BE64(v7, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
  if (!sub_1000C475C(v7))
  {
    v18 = sub_1000C47AC(v7);
    if (v17)
      goto LABEL_17;
LABEL_23:
    v16 = 0;
    goto LABEL_24;
  }
  v18 = 1;
  if (!v17)
    goto LABEL_23;
LABEL_17:
  v16 = 0;
  if (v17 != kCFBooleanTrue || !v12)
    goto LABEL_24;
  v13 = objc_autoreleasePoolPush();
  v16 = qword_10026DD20;
  if (!v18)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Requesting early expiry probe check for network <%@>", "WiFiManagerPrivateMacIsQuickProbeRequired", sub_10002B088(v5));
    v16 = 1;
    goto LABEL_13;
  }
  if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Not requesting early expiry probe check for network <%@> becuase it was a captive network", "WiFiManagerPrivateMacIsQuickProbeRequired", sub_10002B088(v5), v20);
LABEL_12:
    v16 = 0;
  }
LABEL_13:
  objc_autoreleasePoolPop(v13);
LABEL_24:
  CFRelease(v5);
  return v16;
}

void sub_1000AC3C0(const __CFArray *a1, const void *a2, unsigned int a3)
{
  void *v6;
  void *v7;
  _BOOL4 v8;
  void *v9;
  void *v10;
  const void *v11;
  void *v12;
  void *v13;
  const void *v14;
  uint64_t v15;
  const __CFBoolean *v16;
  unsigned int v17;
  unint64_t v18;

  v6 = sub_10009FEE0(a1);
  v7 = v6;
  if (a2 && a1 && v6)
  {
    v8 = sub_1000C6060((uint64_t)a2, (uint64_t)v6);
    v9 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (v8)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Early probe request for network <%@>. Result <%hhu>", "WiFiManagerPrivateMacProbeResult", sub_10002B088(v7), a3);
      objc_autoreleasePoolPop(v9);
      v11 = sub_1000AAF20((uint64_t)a1, (const __CFDictionary **)v7);
      if (!v11)
        goto LABEL_17;
      if (!a3)
      {
        v15 = (uint64_t)v11;
        v16 = (const __CFBoolean *)sub_10002BE64((uint64_t)v11, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
        if (v16 && v16 == kCFBooleanTrue)
        {
          sub_1000AC5A4((uint64_t)v16, (const __CFDictionary **)v7, (uint64_t)a1);
          sub_10008A2B8((uint64_t)a1, "WiFiManagerPrivateMacProbeResult", 30377);
          v18 = 0xAAAAAAAAAAAAAAAALL;
          v17 = 4;
          sub_100061728(v15, (uint64_t)&v17);
          sub_100061494(&v17);
        }
        goto LABEL_17;
      }
      if (sub_1000A7EE0((uint64_t)a1, v7, 6))
      {
LABEL_17:
        CFRelease(v7);
        return;
      }
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Unable to add assoc done network (%@) after probe to Private Mac network List", sub_10002B088(v7));
      v13 = v12;
    }
    else
    {
      if (qword_10026DD20)
      {
        v14 = sub_10002B088(v7);
        objc_msgSend(v10, "WFLog:message:", 3, "%s: WFMacRandomisation : Ignore early probe timeout. This is a different network. Current Network <%@>, probed network <%@>", "WiFiManagerPrivateMacProbeResult", v14, sub_10002B088(a2));
      }
      v13 = v9;
    }
    objc_autoreleasePoolPop(v13);
    goto LABEL_17;
  }
  if (v6)
    goto LABEL_17;
}

void sub_1000AC5A4(uint64_t a1, const __CFDictionary **a2, uint64_t a3)
{
  __CFDictionary *Mutable;
  const void *v6;
  uint64_t v7;
  BOOL v8;
  const __CFBoolean *v9;
  const __CFBoolean *v10;
  CFNumberRef v11;
  int v12;
  void *v13;
  const char *v14;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = sub_1000AAF20(a3, a2);
  if (a2 && a3 && ((v7 = (uint64_t)v6, Mutable) ? (v8 = v6 == 0) : (v8 = 1), !v8))
  {
    v9 = (const __CFBoolean *)sub_10002BE64((uint64_t)v6, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
    v10 = v9;
    if (v9 && v9 == kCFBooleanTrue)
    {
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), *(const void **)(a3 + 488));
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a3 + 488));
      sub_10002C478(v7, CFSTR("PrivateMacFutureMacAddress"), 0);
      sub_10002C478(v7, CFSTR("NetworkUsedForSWUpgrade"), 0);
      v11 = sub_100064FE0(1);
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v11);
      if (v11)
        CFRelease(v11);
      sub_10002C478(v7, CFSTR("ExperiencedFallback"), kCFBooleanTrue);
      sub_10002C478(v7, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
      sub_100096B7C(a3, a2, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable);
      v10 = kCFBooleanTrue;
    }
  }
  else
  {
    if (!Mutable)
      return;
    v10 = 0;
  }
  CFRelease(Mutable);
  if (v10 && v10 == kCFBooleanTrue)
  {
    v12 = sub_100096B7C(a3, a2, CFSTR("MacAddressRandomisationClassificationAttempts"), kCFBooleanTrue);
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (v12)
        v14 = "%s: WFMacRandomisation : Migrated Network <%@> falling back to physical Mac. Successfully written to cache.";
      else
        v14 = "%s: WFMacRandomisation : Migrated Network <%@> falling back to physical Mac. But Unable to write to cache";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v14, "__WiFiManagerMacAddressFallbackCallback", sub_10002B088(a2));
    }
    objc_autoreleasePoolPop(v13);
  }
}

void sub_1000AC7D0(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  id *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  int v9;
  void *ValueAtIndex;
  void *v11;
  const void *v12;
  int v13;
  void *v14;
  id *v15;
  id v16;
  void *v17;
  const void *v18;
  void *v19;
  const __CFDictionary *v20;
  const __CFAllocator *v21;
  CFMutableDictionaryRef v22;
  __CFDictionary *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex i;
  const void *v27;
  const void *Value;
  void *v29;
  void *v30;
  void *v31;
  CFAbsoluteTime Current;
  CFDateRef v33;
  const __CFArray *v34;
  const __CFArray *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex j;
  const void *v39;
  const void *v40;
  const __CFBoolean *v41;
  const __CFBoolean *v42;
  const __CFDictionary *v43;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v45;
  _QWORD *v46;
  CFNumberRef v47;
  const __CFData *v48;
  const __CFData *v49;
  const __CFData *v50;
  const __CFString *v51;
  CFNumberRef v52;
  void *v53;
  void *v54;
  void *v55;
  CFDateRef v56;
  const __CFArray *v57;
  uint64_t v58;
  __CFArray *Mutable;

  if (a1)
  {
    v1 = a1;
    v2 = objc_autoreleasePoolPush();
    v3 = (id *)&qword_10026DD20;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resetting network settings", "WiFiManagerResetNetworkSettings");
    objc_autoreleasePoolPop(v2);
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      v4 = sub_100090DA4(v1);
      v57 = v4;
      v58 = v1;
      if (!v4)
        goto LABEL_40;
      v5 = v4;
      Count = CFArrayGetCount(v4);
      if (Count < 1)
        goto LABEL_40;
      v7 = Count;
      v8 = 0;
      v9 = 0;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v5, v8);
        if (ValueAtIndex)
        {
          v11 = ValueAtIndex;
          if (sub_1000C5378((uint64_t)ValueAtIndex))
          {
            v12 = sub_10002B088(v11);
            if (v12)
              CFArrayAppendValue(Mutable, v12);
            v9 = 1;
          }
          else
          {
            sub_100098DBC(v1, v11, (const void *)0xD);
            v13 = sub_1000CA608((uint64_t)v11);
            v14 = objc_autoreleasePoolPush();
            v15 = v3;
            v16 = *v3;
            if (v13 == 2)
            {
              if (v16)
                objc_msgSend(v16, "WFLog:message:", 4, "%s: %@ is CarPlayUserConfigured, not removing password", "WiFiManagerResetNetworkSettings", sub_10002B088(v11));
              objc_autoreleasePoolPop(v14);
              v3 = v15;
            }
            else
            {
              if (v16)
                objc_msgSend(v16, "WFLog:message:", 4, "%s: Set password not syncable for %@", "WiFiManagerResetNetworkSettings", sub_10002B088(v11));
              objc_autoreleasePoolPop(v14);
              sub_1000C6754();
              v17 = objc_autoreleasePoolPush();
              v3 = v15;
              if (*v15)
                objc_msgSend(*v15, "WFLog:message:", 4, "%s: REMOVE password for %@", "WiFiManagerResetNetworkSettings", sub_10002B088(v11));
              objc_autoreleasePoolPop(v17);
              sub_1000C65D8(v11);
            }
            v5 = v57;
            v1 = v58;
            if (&_EAPTLSRemoveTrustExceptionsBindings && sub_10002DAB4((uint64_t)v11))
            {
              v18 = sub_10002B088(v11);
              EAPTLSRemoveTrustExceptionsBindings(CFSTR("WirelessSSID"), v18);
            }
          }
        }
        ++v8;
      }
      while (v7 != v8);
      if (v9)
      {
        v19 = objc_autoreleasePoolPush();
        if (*v3)
          objc_msgSend(*v3, "WFLog:message:", 3, "%s: device has profile based networks", "WiFiManagerResetNetworkSettings");
        objc_autoreleasePoolPop(v19);
        v20 = *(const __CFDictionary **)(v1 + 208);
        v21 = kCFAllocatorDefault;
        if (v20)
        {
          v22 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v22)
          {
            v23 = v22;
            v24 = CFArrayGetCount(Mutable);
            if (v24 >= 1)
            {
              v25 = v24;
              for (i = 0; i != v25; ++i)
              {
                v27 = CFArrayGetValueAtIndex(Mutable, i);
                Value = CFDictionaryGetValue(v20, v27);
                v29 = objc_autoreleasePoolPush();
                if (*v3)
                  objc_msgSend(*v3, "WFLog:message:", 3, "%s: preserving network set for %@ (%@)", "WiFiManagerResetNetworkSettings", v27, Value);
                objc_autoreleasePoolPop(v29);
                if (v27 && Value)
                  CFDictionarySetValue(v23, v27, Value);
              }
            }
            -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v23, CFSTR("Custom network settings"));
            CFRelease(v23);
            v1 = v58;
          }
        }
      }
      else
      {
LABEL_40:
        v30 = objc_autoreleasePoolPush();
        if (*v3)
          objc_msgSend(*v3, "WFLog:message:", 3, "%s: removing custom network settings", "WiFiManagerResetNetworkSettings");
        objc_autoreleasePoolPop(v30);
        -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", 0, CFSTR("Custom network settings"));
        v21 = kCFAllocatorDefault;
      }
      sub_100093FA0((_QWORD *)v1, CFSTR("AllowEnable"), 0);
      sub_100093FA0((_QWORD *)v1, CFSTR("DeviceUUID"), 0);
      sub_1000A5BF0(v1, 0);
      v31 = objc_autoreleasePoolPush();
      if (*v3)
        objc_msgSend(*v3, "WFLog:message:", 3, "%s: WFMacRandomisation : Special Handling for Private MAC Networks", "WiFiManagerResetNetworkSettings");
      objc_autoreleasePoolPop(v31);
      sub_1000A7CEC(v1);
      Current = CFAbsoluteTimeGetCurrent();
      v33 = CFDateCreate(v21, Current);
      v34 = (const __CFArray *)sub_1000875B0(v1);
      if (v34)
      {
        v35 = v34;
        v36 = CFArrayGetCount(v34);
        if (v36)
        {
          v37 = v36;
          v56 = v33;
          if (v36 >= 1)
          {
            for (j = 0; v37 != j; ++j)
            {
              v39 = CFArrayGetValueAtIndex(v35, j);
              if (!v39)
                continue;
              v40 = v39;
              v41 = (const __CFBoolean *)sub_10002BE64((uint64_t)v39, CFSTR("isProfileBasedNetwork"));
              if (!v41)
                continue;
              if (v41 != kCFBooleanTrue)
                continue;
              v42 = (const __CFBoolean *)sub_10002BE64((uint64_t)v40, CFSTR("PrivateMacProfileDefaultInitialValue"));
              v43 = (const __CFDictionary *)sub_10002BE64((uint64_t)v40, CFSTR("PRIVATE_MAC_ADDRESS"));
              MutableCopy = CFDictionaryCreateMutableCopy(v21, 0, v43);
              if (!MutableCopy)
                continue;
              v45 = MutableCopy;
              if (v42)
              {
                if (v42 == kCFBooleanTrue)
                {
                  v52 = sub_100064FE0(1);
                  CFDictionarySetValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v52);
                  CFDictionarySetValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(v1 + 488));
                  CFDictionaryRemoveValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
                  sub_10002C478((uint64_t)v40, CFSTR("PrivateMacDefaultToOFF"), kCFBooleanTrue);
                  sub_10002C478((uint64_t)v40, CFSTR("privateMacSuccessfulAssocAtleastOnce"), 0);
                  v54 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Profile Based private MAC disable key reinforced for network <%@>", "__WiFiManagerPrivateMacProcessProfileBasedNetworks", sub_10002B088(v40));
                  objc_autoreleasePoolPop(v54);
                  v21 = kCFAllocatorDefault;
                  if (!v52)
                    goto LABEL_65;
                }
                else
                {
                  v46 = (_QWORD *)v1;
                  v47 = sub_100064FE0(2);
                  CFDictionarySetValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v47);
                  CFDictionaryRemoveValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
                  CFDictionaryRemoveValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
                  sub_10002C478((uint64_t)v40, CFSTR("PrivateMacDefaultToOFF"), kCFBooleanFalse);
                  sub_10002C478((uint64_t)v40, CFSTR("RotationKeyMacRandomisation"), 0);
                  v49 = (const __CFData *)v46[51];
                  v48 = (const __CFData *)v46[52];
                  v50 = (const __CFData *)v46[61];
                  v51 = (const __CFString *)sub_10002B088(v40);
                  v52 = sub_1000CE52C(v48, v49, v50, v51);
                  v53 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Generated private mac address <%@> for profile network<%@> ", "__WiFiManagerPrivateMacProcessProfileBasedNetworks", v52, sub_10002B088(v40));
                  objc_autoreleasePoolPop(v53);
                  v21 = kCFAllocatorDefault;
                  if (v47)
                    CFRelease(v47);
                  v1 = v58;
                  if (!v52)
                    goto LABEL_65;
                  CFDictionarySetValue(v45, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v52);
                  sub_10002C478((uint64_t)v40, CFSTR("MacGenerationTimeStamp"), v56);
                  sub_10002C478((uint64_t)v40, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
                  sub_10002C478((uint64_t)v40, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
                  sub_10002C478((uint64_t)v40, CFSTR("RotationKeyUsed"), *(const void **)(v58 + 408));
                }
                CFRelease(v52);
              }
LABEL_65:
              sub_10002C478((uint64_t)v40, CFSTR("PRIVATE_MAC_ADDRESS"), v45);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacFeatureTurnedONtoOFF"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacFeatureTurnedONtoOFFTimestamp"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacFeatureTurnedOFFtoON"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacFeatureTurnedOFFtoONTimestamp"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
              sub_10002C478((uint64_t)v40, CFSTR("isBackhaulLinkUp"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("privateMacSuccessfulAssocAtleastOnce"), 0);
              sub_10002B698((uint64_t)v40, CFSTR("FailureCountThresholdCurrent"), *(unsigned int *)(v1 + 456));
              sub_10002B698((uint64_t)v40, CFSTR("FailureCountCurrent"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacPrefChanged"), 0);
              sub_10002C478((uint64_t)v40, CFSTR("PrivateMacPrefChangedTimestamp"), 0);
              CFRelease(v45);
            }
          }
          sub_1000A46A8(v1, v35);
          sub_1000A485C(v1, 1, 0);
          v3 = (id *)&qword_10026DD20;
          v33 = v56;
        }
      }
      if (v33)
        CFRelease(v33);
      sub_100093FA0((_QWORD *)v1, CFSTR("deviceSpecificKeyMacRandomisation"), 0);
      sub_100093FA0((_QWORD *)v1, CFSTR("RotationKeyMacRandomisation"), 0);
      v55 = objc_autoreleasePoolPush();
      if (*v3)
        objc_msgSend(*v3, "WFLog:message:", 3, "%s WFMacRandomisation : Device Specific Key Reset", "__WiFiManagerPrivateMacAdjustSettingsOnReset");
      objc_autoreleasePoolPop(v55);
      if (v57)
        CFRelease(v57);
      CFRelease(Mutable);
    }
  }
}

void sub_1000AD118(uint64_t a1)
{
  const __CFArray *v2;
  void *v3;
  _QWORD block[5];

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerPurgeExpiredKnownNetworks");
    goto LABEL_10;
  }
  v2 = *(const __CFArray **)(a1 + 216);
  if (!v2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager->networks", "WiFiManagerPurgeExpiredKnownNetworks");
LABEL_10:
    objc_autoreleasePoolPop(v3);
    return;
  }
  if (CFArrayGetCount(v2) >= 1)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000AD210;
    block[3] = &unk_10022EA38;
    block[4] = a1;
    dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  }
}

void sub_1000AD210(uint64_t a1)
{
  id v2;
  uint64_t v3;
  NSObject *v4;
  id v5;
  _QWORD block[7];

  v5 = objc_alloc_init((Class)WiFiWalletSource);
  v2 = objc_msgSend(objc_msgSend(v5, "expiredWalletIDs"), "copy");
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(NSObject **)(v3 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000AD2B0;
    block[3] = &unk_1002308F0;
    block[4] = v2;
    block[5] = v5;
    block[6] = v3;
    dispatch_async(v4, block);
  }
  else
  {

  }
}

void sub_1000AD2B0(uint64_t a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  void *ValueAtIndex;
  const void *v6;
  void *v7;

  Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 48) + 216));
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)(a1 + 48) + 216), i);
      v6 = sub_1000CC4F8(ValueAtIndex);
      if (v6 && objc_msgSend(*(id *)(a1 + 32), "containsObject:", v6))
      {
        sub_100098DBC(*(_QWORD *)(a1 + 48), ValueAtIndex, (const void *)0x14);
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Purging Known Network : [ %@ ]", "WiFiManagerPurgeExpiredKnownNetworks_block_invoke_2", sub_10002B088(ValueAtIndex));
        objc_autoreleasePoolPop(v7);
      }
    }
  }

}

void sub_1000AD3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  context[0] = a2;
  context[1] = a3;
  context[2] = a4;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000AD3E4, context);
}

void sub_1000AD3E4(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  if (a2 && *(_QWORD *)a2 && (v2 = *(void **)(a2 + 8)) != 0)
  {
    sub_100065FA0(a1, *(_QWORD *)a2, v2, *(const void **)(a2 + 16));
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchTdConfirmedEvent");
    objc_autoreleasePoolPop(v3);
  }
}

const __CFArray *sub_1000AD468(const __CFArray *a1)
{
  const __CFArray *result;
  const __CFArray *v2;
  const void *ValueAtIndex;
  id v4;

  result = sub_10000B29C(a1);
  if (result)
  {
    v2 = result;
    ValueAtIndex = CFArrayGetValueAtIndex(result, 0);
    v4 = sub_10011F71C((uint64_t)ValueAtIndex);
    CFRelease(v2);
    return (const __CFArray *)v4;
  }
  return result;
}

void sub_1000AD4A8(uint64_t a1, unsigned int a2)
{
  void *v4;
  const char *v5;
  void *v6;
  _QWORD context[4];

  if (a1)
  {
    if (*(_QWORD *)(a1 + 1600) != a2)
    {
      *(_QWORD *)(a1 + 1600) = a2;
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v5 = "enabled";
        if (!a2)
          v5 = "disabled";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Battery saver mode is now %s", "WiFiManagerSetBatterySaveMode", v5);
      }
      objc_autoreleasePoolPop(v4);
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000040;
      context[2] = a2;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
      objc_msgSend(*(id *)(a1 + 2416), "updateWowState:lpasState:lowPowerState:batterySaverState:", *(_BYTE *)(a1 + 1160) != 0, *(_BYTE *)(a1 + 1176) != 0, *(_BYTE *)(a1 + 1162) != 0, *(_QWORD *)(a1 + 1600) != 0);
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiManagerSetBatterySaveMode");
    objc_autoreleasePoolPop(v6);
  }
}

uint64_t sub_1000AD5F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1600);
}

void sub_1000AD5FC(const __CFArray *a1, const __CFBoolean *a2)
{
  NSUserDefaults *v4;
  NSUserDefaults *v5;
  CFTypeID TypeID;
  void *v7;
  const char *v8;

  v4 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  if (a2)
  {
    v5 = v4;
    TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      -[NSUserDefaults setBool:forKey:](v5, "setBool:forKey:", kCFBooleanTrue == a2, CFSTR("PerpetualWiFiScanEnabled"));
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v8 = "DISABLED";
        if (kCFBooleanTrue == a2)
          v8 = "ENABLED";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Setting perpetual WiFi scan mode %s", v8);
      }
      objc_autoreleasePoolPop(v7);
      if (kCFBooleanTrue == a2 && sub_1000A246C(a1))
        sub_10008A2B8((uint64_t)a1, "WiFiManagerSetPerpetualWiFiScanSettings", 31777);
    }
  }
}

void sub_1000AD704()
{
  void *v0;

  v0 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Stand-alone LPAS Test mode is not supported on this platform", "__WiFiManagerSetStandAloneLPASTestMode");
  objc_autoreleasePoolPop(v0);
}

void sub_1000AD75C(const __CFArray *a1, const void *a2)
{
  void *v4;
  const __CFNumber *v5;
  __CFDictionary *Mutable;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  int v11;
  int v12;
  int valuePtr;

  v11 = -1431655766;
  v12 = -1431655766;
  v4 = sub_10009FEE0(a1);
  v5 = (const __CFNumber *)sub_10002BE64((uint64_t)v4, CFSTR("CHANNEL_FLAGS"));
  if (v5 && (valuePtr = 0, CFNumberGetValue(v5, kCFNumberIntType, &valuePtr), (valuePtr & 0x2018) == 0x2000))
    v11 = 1;
  else
    v12 = 1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v12);
  if (v7)
  {
    v8 = v7;
    CFDictionarySetValue(Mutable, CFSTR("6E_NETWORK_TRANSITION"), v7);
    CFRelease(v8);
  }
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v11);
  if (v9)
  {
    v10 = v9;
    CFDictionarySetValue(Mutable, CFSTR("LEGACY_NETWORK_TRANSITION"), v9);
    CFRelease(v10);
  }
  if (a2)
    CFDictionarySetValue(Mutable, CFSTR("CHANNEL"), a2);
  sub_1000AD8A0((uint64_t)a1, (uint64_t)Mutable);
}

void sub_1000AD8A0(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    v2[0] = a1;
    v2[1] = 0xAAAAAAAA00000086;
    v2[2] = a2;
    v2[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  }
}

uint64_t sub_1000AD8E8(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000087;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

id sub_1000AD92C(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 2012))
      return objc_msgSend(*(id *)(a1 + 192), "getLocaleCountryCode");
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerGetLocaleCountryCode");
    objc_autoreleasePoolPop(v2);
  }
  return 0;
}

void sub_1000AD9AC(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a1)
  {
    objc_msgSend(*(id *)(a1 + 192), "determineAndSetLocale:", a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiManagerDetermineAndSetLocale");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000ADA20(uint64_t a1, const __CFArray *a2)
{
  uint64_t v2;
  const void *v4;
  _QWORD v6[3];
  uint64_t v7;

  v2 = 83;
  if (a1 && a2)
  {
    v4 = *(const void **)(a1 + 2504);
    *(_QWORD *)(a1 + 2504) = CFArrayCreateCopy(kCFAllocatorDefault, a2);
    v6[0] = a1;
    v6[1] = 0xAAAAAAAA00000005;
    v6[2] = 0;
    v7 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v6);
    v2 = v7;
    if ((_DWORD)v7)
    {
      CFRelease(*(CFTypeRef *)(a1 + 2504));
      *(_QWORD *)(a1 + 2504) = v4;
    }
    else
    {
      if (v4)
        CFRelease(v4);
      return 0;
    }
  }
  return v2;
}

NSError *sub_1000ADAC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;

  v3 = *(void **)(a1 + 1784);
  if (v3)
    return (NSError *)objc_msgSend(v3, "getServiceFor:withServiceKey:", a2, a3);
  else
    return +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CWFManagerErrorDomain, -3907, 0);
}

id sub_1000ADAF8(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    if (+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"))
      return -[WiFiSoftApUsageMonitor statsDictionary](+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"), "statsDictionary");
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerGetMISStats");
    objc_autoreleasePoolPop(v2);
  }
  return 0;
}

void sub_1000ADB84(uint64_t a1)
{
  void *v1;

  if (a1)
  {
    if (+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"))
      -[WiFiSoftApUsageMonitor resetStats](+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"), "resetStats");
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "WiFiManagerResetMISStats");
    objc_autoreleasePoolPop(v1);
  }
}

__CFArray *sub_1000ADC18(char *a1, uint64_t a2)
{
  __CFArray *Mutable;
  BOOL v5;
  CFNumberRef v6;
  CFNumberRef v7;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
    v5 = a2 < 1;
  else
    v5 = 1;
  if (!v5)
  {
    do
    {
      v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, a1);
      if (v6)
      {
        v7 = v6;
        CFArrayAppendValue(Mutable, v6);
        CFRelease(v7);
      }
      a1 += 8;
      --a2;
    }
    while (a2);
  }
  return Mutable;
}

void sub_1000ADCB4(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  io_object_t v13;
  io_object_t v14;
  io_object_t v15;
  io_object_t v16;
  io_object_t v17;
  io_object_t v18;
  void *v19;
  void *v20;
  IONotificationPort *v21;
  IONotificationPort *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  void *v49;
  const void *v50;
  const void *v51;
  NSObject *v52;
  void *v53;
  const void *v54;
  const void *v55;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  void *v64;
  void *v65;
  const void *v66;
  const void *v67;
  const void *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  const void *v76;
  const void *v77;
  const void *v78;
  const void *v79;

  v2 = objc_autoreleasePoolPush();
  sub_10008B698(a1, *(const void **)(a1 + 32));
  v3 = *(NSObject **)(a1 + 1576);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(a1 + 1576) = 0;
  }
  v4 = *(NSObject **)(a1 + 1536);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 1536) = 0;
  }
  v5 = *(NSObject **)(a1 + 1488);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(a1 + 1488) = 0;
  }
  v6 = *(NSObject **)(a1 + 1336);
  if (v6)
  {
    dispatch_release(v6);
    *(_QWORD *)(a1 + 1336) = 0;
  }
  v7 = *(NSObject **)(a1 + 1872);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(a1 + 1872) = 0;
  }
  v8 = *(NSObject **)(a1 + 920);
  if (v8)
  {
    dispatch_release(v8);
    *(_QWORD *)(a1 + 920) = 0;
  }
  sub_1000BD050(a1 + 1800);
  v9 = *(NSObject **)(a1 + 1360);
  if (v9)
  {
    dispatch_release(v9);
    *(_QWORD *)(a1 + 1360) = 0;
  }
  v10 = *(NSObject **)(a1 + 2352);
  if (v10)
  {
    dispatch_release(v10);
    *(_QWORD *)(a1 + 2352) = 0;
  }
  v11 = *(NSObject **)(a1 + 496);
  if (v11)
  {
    dispatch_release(v11);
    *(_QWORD *)(a1 + 496) = 0;
  }
  v12 = *(NSObject **)(a1 + 432);
  if (v12)
  {
    dispatch_release(v12);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v13 = *(_DWORD *)(a1 + 968);
  if (v13)
    IOObjectRelease(v13);
  v14 = *(_DWORD *)(a1 + 976);
  if (v14)
    IOObjectRelease(v14);
  v15 = *(_DWORD *)(a1 + 980);
  if (v15)
    IOObjectRelease(v15);
  v16 = *(_DWORD *)(a1 + 1000);
  if (v16)
    IOObjectRelease(v16);
  v17 = *(_DWORD *)(a1 + 1004);
  if (v17)
    IOObjectRelease(v17);
  v18 = *(_DWORD *)(a1 + 1008);
  if (v18)
    IOObjectRelease(v18);
  v19 = *(void **)(a1 + 2488);
  if (v19)
  {
    objc_msgSend(v19, "removeAllObjects");

  }
  v20 = *(void **)(a1 + 2496);
  if (v20)
  {
    objc_msgSend(v20, "removeAllObjects");

  }
  v21 = *(IONotificationPort **)(a1 + 960);
  if (v21)
    IONotificationPortDestroy(v21);
  v22 = *(IONotificationPort **)(a1 + 1016);
  if (v22)
    IONotificationPortDestroy(v22);
  v23 = *(const void **)(a1 + 1064);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a1 + 1064) = 0;
  }
  v24 = *(const void **)(a1 + 1072);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(a1 + 1072) = 0;
  }
  v25 = *(const void **)(a1 + 1080);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a1 + 1080) = 0;
  }
  v26 = *(const void **)(a1 + 1096);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 1096) = 0;
  }
  v27 = *(const void **)(a1 + 1088);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a1 + 1088) = 0;
  }

  *(_QWORD *)(a1 + 1104) = 0;
  *(_QWORD *)(a1 + 1120) = 0;
  v28 = *(const void **)(a1 + 208);
  if (v28)
  {
    CFRelease(v28);
    *(_QWORD *)(a1 + 208) = 0;
  }
  v29 = *(const void **)(a1 + 216);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v30 = *(const void **)(a1 + 224);
  if (v30)
  {
    CFRelease(v30);
    *(_QWORD *)(a1 + 224) = 0;
  }
  v31 = *(const void **)(a1 + 256);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(a1 + 256) = 0;
  }
  v32 = *(const void **)(a1 + 104);
  if (v32)
  {
    CFRelease(v32);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v33 = *(const void **)(a1 + 96);
  if (v33)
  {
    CFRelease(v33);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v34 = *(const void **)(a1 + 136);
  if (v34)
  {
    CFRelease(v34);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v35 = *(const void **)(a1 + 144);
  if (v35)
  {
    CFRelease(v35);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v36 = *(const void **)(a1 + 152);
  if (v36)
  {
    CFRelease(v36);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v37 = *(const void **)(a1 + 160);
  if (v37)
  {
    CFRelease(v37);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v38 = *(const void **)(a1 + 176);
  if (v38)
  {
    CFRelease(v38);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v39 = *(const void **)(a1 + 1168);
  if (v39)
  {
    CFRelease(v39);
    *(_QWORD *)(a1 + 1168) = 0;
  }
  v40 = *(const void **)(a1 + 1192);
  if (v40)
  {
    CFRelease(v40);
    *(_QWORD *)(a1 + 1192) = 0;
  }
  v41 = *(const void **)(a1 + 80);
  if (v41)
  {
    CFRelease(v41);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v42 = *(const void **)(a1 + 200);
  if (v42)
  {
    CFRelease(v42);
    *(_QWORD *)(a1 + 200) = 0;
  }

  *(_QWORD *)(a1 + 192) = 0;
  v43 = *(const void **)(a1 + 1240);
  if (v43)
  {
    CFRelease(v43);
    *(_QWORD *)(a1 + 1240) = 0;
  }
  v44 = *(const void **)(a1 + 1264);
  if (v44)
  {
    CFRelease(v44);
    *(_QWORD *)(a1 + 1264) = 0;
  }
  v45 = *(const void **)(a1 + 1368);
  if (v45)
  {
    CFRelease(v45);
    *(_QWORD *)(a1 + 1368) = 0;
  }
  v46 = *(const void **)(a1 + 1400);
  if (v46)
  {
    CFRelease(v46);
    *(_QWORD *)(a1 + 1400) = 0;
  }
  v47 = *(const void **)(a1 + 1688);
  if (v47)
  {
    CFRelease(v47);
    *(_QWORD *)(a1 + 1688) = 0;
  }
  sub_100176EFC(*(void **)(a1 + 1432));
  v48 = *(const void **)(a1 + 1448);
  if (v48)
  {
    CFRelease(v48);
    *(_QWORD *)(a1 + 1448) = 0;
  }
  v49 = *(void **)(a1 + 1936);
  if (v49)
  {
    objc_msgSend(v49, "setHandler:", 0);
    objc_msgSend(*(id *)(a1 + 1936), "invalidate");
    *(_QWORD *)(a1 + 1936) = 0;
  }
  v50 = *(const void **)(a1 + 1656);
  if (v50)
  {
    CFRelease(v50);
    *(_QWORD *)(a1 + 1656) = 0;
  }
  v51 = *(const void **)(a1 + 1664);
  if (v51)
  {
    CFRelease(v51);
    *(_QWORD *)(a1 + 1664) = 0;
  }
  v52 = *(NSObject **)(a1 + 1680);
  if (v52)
  {
    dispatch_release(v52);
    *(_QWORD *)(a1 + 1680) = 0;
  }
  v53 = *(void **)(a1 + 1944);
  if (v53)
  {
    objc_msgSend(v53, "invalidate");
    v54 = *(const void **)(a1 + 1944);
    if (v54)
    {
      CFRelease(v54);
      *(_QWORD *)(a1 + 1944) = 0;
    }
  }
  v55 = *(const void **)(a1 + 416);
  if (v55)
  {
    CFRelease(v55);
    *(_QWORD *)(a1 + 416) = 0;
  }
  v56 = *(const void **)(a1 + 408);
  if (v56)
  {
    CFRelease(v56);
    *(_QWORD *)(a1 + 408) = 0;
  }
  v57 = *(const void **)(a1 + 488);
  if (v57)
  {
    CFRelease(v57);
    *(_QWORD *)(a1 + 488) = 0;
  }
  v58 = *(const void **)(a1 + 352);
  if (v58)
  {
    CFRelease(v58);
    *(_QWORD *)(a1 + 352) = 0;
  }
  v59 = *(const void **)(a1 + 1608);
  if (v59)
  {
    CFRelease(v59);
    *(_QWORD *)(a1 + 1608) = 0;
  }
  v60 = *(const void **)(a1 + 1616);
  if (v60)
  {
    CFRelease(v60);
    *(_QWORD *)(a1 + 1616) = 0;
  }
  v61 = *(const void **)(a1 + 1960);
  if (v61)
  {
    CFRelease(v61);
    *(_QWORD *)(a1 + 1960) = 0;
  }
  v62 = *(const void **)(a1 + 1968);
  if (v62)
  {
    CFRelease(v62);
    *(_QWORD *)(a1 + 1968) = 0;
  }
  v63 = *(const void **)(a1 + 1976);
  if (v63)
  {
    CFRelease(v63);
    *(_QWORD *)(a1 + 1976) = 0;
  }

  *(_QWORD *)(a1 + 1624) = 0;
  *(_QWORD *)(a1 + 1728) = 0;

  *(_QWORD *)(a1 + 1736) = 0;
  *(_QWORD *)(a1 + 1744) = 0;

  *(_QWORD *)(a1 + 1760) = 0;
  *(_QWORD *)(a1 + 1768) = 0;

  *(_QWORD *)(a1 + 1840) = 0;
  *(_QWORD *)(a1 + 2544) = 0;

  *(_QWORD *)(a1 + 1776) = 0;
  v64 = *(void **)(a1 + 1784);
  if (v64)
  {

    *(_QWORD *)(a1 + 1784) = 0;
  }
  v65 = *(void **)(a1 + 1792);
  if (v65)
  {

    *(_QWORD *)(a1 + 1792) = 0;
  }
  qword_10026D680 = 0;
  v66 = *(const void **)(a1 + 2080);
  if (v66)
  {
    CFRelease(v66);
    *(_QWORD *)(a1 + 2080) = 0;
  }
  v67 = *(const void **)(a1 + 168);
  if (v67)
  {
    CFRelease(v67);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v68 = *(const void **)(a1 + 2128);
  if (v68)
  {
    CFRelease(v68);
    *(_QWORD *)(a1 + 2128) = 0;
  }
  v69 = *(const void **)(a1 + 320);
  if (v69)
  {
    CFRelease(v69);
    *(_QWORD *)(a1 + 320) = 0;
  }
  v70 = *(const void **)(a1 + 2264);
  if (v70)
  {
    CFRelease(v70);
    *(_QWORD *)(a1 + 2264) = 0;
  }
  if (&_ct_green_tea_logger_destroy)
    ct_green_tea_logger_destroy(*(_QWORD *)(a1 + 2056));
  *(_QWORD *)(a1 + 2056) = 0;
  v71 = *(const void **)(a1 + 2184);
  if (v71)
  {
    CFRelease(v71);
    *(_QWORD *)(a1 + 2184) = 0;
  }
  v72 = *(const void **)(a1 + 2032);
  if (v72)
  {
    CFRelease(v72);
    *(_QWORD *)(a1 + 2032) = 0;
  }
  v73 = *(const void **)(a1 + 2368);
  if (v73)
  {
    CFRelease(v73);
    *(_QWORD *)(a1 + 2368) = 0;
  }
  v74 = *(const void **)(a1 + 2376);
  if (v74)
  {
    CFRelease(v74);
    *(_QWORD *)(a1 + 2376) = 0;
  }
  v75 = *(const void **)(a1 + 2384);
  if (v75)
  {
    CFRelease(v75);
    *(_QWORD *)(a1 + 2384) = 0;
  }
  v76 = *(const void **)(a1 + 2424);
  if (v76)
  {
    CFRelease(v76);
    *(_QWORD *)(a1 + 2424) = 0;
  }
  v77 = *(const void **)(a1 + 2504);
  if (v77)
  {
    CFRelease(v77);
    *(_QWORD *)(a1 + 2504) = 0;
  }
  v78 = *(const void **)(a1 + 2512);
  if (v78)
  {
    CFRelease(v78);
    *(_QWORD *)(a1 + 2512) = 0;
  }
  v79 = *(const void **)(a1 + 2528);
  if (v79)
  {
    CFRelease(v79);
    *(_QWORD *)(a1 + 2528) = 0;
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000AE260(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  void *ValueAtIndex;
  unsigned int v9;
  id v10;
  id v11;
  uint64_t v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL4 v24;
  void *v25;
  void *v26;
  unsigned __int8 v27;
  int v28;
  void *v29;
  void *v30;
  void *v31;
  __CFDictionary *Mutable;
  const void *v33;
  __CFString *v34;
  const __CFString *v35;
  void *v36;
  id v37;
  id v38;
  __CFUserNotification *v39;
  __CFUserNotification *v40;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v42;
  __CFRunLoop *Main;
  void *v44;
  CFStringRef cf;
  _QWORD block[8];
  _QWORD v47[4];
  SInt32 error[2];
  uint64_t v49;
  uint64_t v50;
  void (*v51)(uint64_t, uint64_t);
  void (*v52)(uint64_t);
  id v53;

  if (a4)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 1688), 0);
    v9 = objc_msgSend(ValueAtIndex, "sessionBased");
    v10 = objc_msgSend(ValueAtIndex, "network");
    if (v10)
    {
      v11 = objc_msgSend(ValueAtIndex, "client");
      if (v11)
      {
        v12 = (uint64_t)v11;
        if (!(_DWORD)a2)
        {
          sub_1001055B4(a1, a3);
          if (!v9)
          {
LABEL_14:
            v19 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: request.bypassPrompt=%d assocResult=%d", "__WiFiDeviceManagerForcedAssociationCallback", objc_msgSend(ValueAtIndex, "bypassPrompt"), 0);
            objc_autoreleasePoolPop(v19);
            if (objc_msgSend(ValueAtIndex, "bypassPrompt"))
            {
              v20 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: showing app join notification for %@", "__WiFiDeviceManagerForcedAssociationCallback", v10);
              objc_autoreleasePoolPop(v20);
              sub_100122730(a1, v10);
              if (sub_1000CEBA4((uint64_t)v10))
              {
                v21 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: accessory network (%@) is unsecured", "__WiFiDeviceManagerForcedAssociationCallback", v10);
                objc_autoreleasePoolPop(v21);
                v22 = 3;
              }
              else
              {
                v22 = 1;
              }
              *(_QWORD *)error = 0;
              v49 = (uint64_t)error;
              v50 = 0x3052000000;
              v51 = sub_10002FA68;
              v52 = sub_10002F978;
              v53 = (id)0xAAAAAAAAAAAAAAAALL;
              v53 = objc_msgSend(ValueAtIndex, "bundleId");
              v47[0] = 0;
              v47[1] = v47;
              v47[2] = 0x2020000000;
              v47[3] = v10;
              CFRetain(v10);
              CFRetain(*(CFTypeRef *)(v49 + 40));
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_1000AEEE4;
              block[3] = &unk_100230978;
              block[6] = v10;
              block[7] = v22;
              block[4] = error;
              block[5] = v47;
              dispatch_async((dispatch_queue_t)qword_10026DD40, block);
              _Block_object_dispose(v47, 8);
              _Block_object_dispose(error, 8);
            }
            objc_msgSend(ValueAtIndex, "bypassPrompt");
            v23 = 0;
            v24 = 1;
LABEL_26:
            sub_100066564(v12, a4, (uint64_t)v10, v23);
LABEL_27:
            if (objc_msgSend(ValueAtIndex, "callback"))
              ((void (*)(uint64_t, id, uint64_t, id))objc_msgSend(ValueAtIndex, "callback"))(a4, v10, v23, objc_msgSend(ValueAtIndex, "context"));
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a4 + 1688), 0);
            if (v24)
              sub_100098854(a4);
            return;
          }
          v13 = objc_msgSend(ValueAtIndex, "bundleId");
          v14 = objc_autoreleasePoolPush();
          if (v13)
          {
            *(_QWORD *)(a4 + 1664) = v13;
            CFRetain(v13);
            *(_QWORD *)(a4 + 1656) = v10;
            CFRetain(v10);
            objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentSessionBasedNetworkRef:", v10);
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: start monitoring application state for %@", "__WiFiManagerStartMonitoringSessionBasedApplication", *(_QWORD *)(a4 + 1664));
            objc_autoreleasePoolPop(v15);
            v16 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", v13, 0);
            if (objc_opt_class(BKSApplicationStateMonitor))
            {
              v17 = objc_alloc((Class)BKSApplicationStateMonitor);
              v18 = objc_msgSend(v17, "initWithBundleIDs:states:", v16, BKSApplicationStateAll);
              *(_QWORD *)(a4 + 1944) = v18;
              if (v18)
              {
                *(_QWORD *)error = _NSConcreteStackBlock;
                v49 = 3221225472;
                v50 = (uint64_t)sub_1000AEF54;
                v51 = (void (*)(uint64_t, uint64_t))&unk_100230998;
                v52 = (void (*)(uint64_t))a4;
                objc_msgSend(v18, "setHandler:", error);
                if (!v16)
                {
LABEL_13:
                  objc_autoreleasePoolPop(v14);
                  goto LABEL_14;
                }
LABEL_12:
                CFRelease(v16);
                goto LABEL_13;
              }
              v31 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create app state monitor", "__WiFiManagerStartMonitoringSessionBasedApplication");
              objc_autoreleasePoolPop(v31);
            }
            CFRelease(v13);
          }
          else
          {
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bundle id is null", "__WiFiManagerStartMonitoringSessionBasedApplication");
            objc_autoreleasePoolPop(v30);
            v16 = 0;
          }
          CFRelease(v10);
          if (!v16)
            goto LABEL_13;
          goto LABEL_12;
        }
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to association error %d", "__WiFiDeviceManagerForcedAssociationCallback", a2);
        v23 = 7;
LABEL_43:
        objc_autoreleasePoolPop(v26);
        v27 = objc_msgSend(ValueAtIndex, "bypassPrompt");
        v24 = a2 == 0;
        if (!(_DWORD)a2 || (v27 & 1) != 0)
          goto LABEL_81;
        if (v9)
        {
          v28 = sub_100098780(a4, *(const void **)(a4 + 1656), 0);
          v29 = objc_autoreleasePoolPush();
          if (v28)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is existing network, leaving password", "__WiFiDeviceManagerForcedAssociationCallback", sub_10002B088(*(const void **)(a4 + 1656)));
            objc_autoreleasePoolPop(v29);
          }
          else
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: removing password for %@", "__WiFiDeviceManagerForcedAssociationCallback", sub_10002B088(*(const void **)(a4 + 1656)));
            objc_autoreleasePoolPop(v29);
            sub_1000C65D8(*(const void **)(a4 + 1656));
          }
        }
        error[0] = -1431655766;
        if (a3)
        {
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            if (sub_10015B920())
            {
              v33 = sub_10002B088(a3);
              cf = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%c%@%c"), 8, v33, 127);
              if (cf)
              {
                v34 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                if (v34)
                {
                  v35 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_FAILURE_TITLE"));
                  if (v35)
                  {
                    CFStringAppendFormat(v34, 0, v35, cf);
                    if ((int)sub_10001D3D8((const __CFNumber *)a3) <= -75)
                    {
                      v36 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: weak signal, adding message to alert", "__WiFiManagerDispatchForcedAssociationFailureNotification");
                      objc_autoreleasePoolPop(v36);
                      v37 = sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_FAILURE_BODY_WEAK_SIGNAL"));
                      if (v37)
                        CFDictionarySetValue(Mutable, kCFUserNotificationAlertMessageKey, v37);
                    }
                    CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, v34);
                    v38 = sub_10015B934((uint64_t)CFSTR("WIFI_FAILURE_OK"));
                    CFDictionarySetValue(Mutable, kCFUserNotificationDefaultButtonTitleKey, v38);
                    v39 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, error, Mutable);
                    if (v39)
                    {
                      v40 = v39;
                      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v39, (CFUserNotificationCallBack)sub_1000AF25C, 0);
                      if (RunLoopSource)
                      {
                        v42 = RunLoopSource;
                        *(_QWORD *)(a4 + 1640) = RunLoopSource;
                        *(_QWORD *)(a4 + 1648) = v40;
                        Main = CFRunLoopGetMain();
                        CFRunLoopAddSource(Main, v42, kCFRunLoopDefaultMode);
                      }
                      else
                      {
                        *(_QWORD *)(a4 + 1640) = 0;
                        *(_QWORD *)(a4 + 1648) = 0;
                        CFRelease(v40);
                        sub_100098854(a4);
                      }
LABEL_76:
                      CFRelease(cf);
LABEL_77:
                      if (v34)
                        CFRelease(v34);
                      if (Mutable)
                        CFRelease(Mutable);
LABEL_81:
                      if (!v12)
                        goto LABEL_27;
                      goto LABEL_26;
                    }
                  }
                }
LABEL_87:
                *(_OWORD *)(a4 + 1640) = 0u;
                sub_100098854(a4);
                if (!cf)
                  goto LABEL_77;
                goto LABEL_76;
              }
            }
          }
        }
        else
        {
          v44 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "__WiFiManagerDispatchForcedAssociationFailureNotification");
          objc_autoreleasePoolPop(v44);
          Mutable = 0;
        }
        cf = 0;
        v34 = 0;
        goto LABEL_87;
      }
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: client is null", "__WiFiDeviceManagerForcedAssociationCallback");
    }
    else
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: request network is null", "__WiFiDeviceManagerForcedAssociationCallback");
    }
    v12 = 0;
    v23 = 0x7FFFFFFFLL;
    goto LABEL_43;
  }
  v25 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiDeviceManagerForcedAssociationCallback");
  objc_autoreleasePoolPop(v25);
}

void sub_1000AEB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_1000AEB34(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5)
{
  void *ValueAtIndex;
  id v9;
  id v10;
  uint64_t v11;
  __CFArray *v12;
  uint64_t v13;
  const __CFString *v14;
  CFMutableArrayRef Mutable;
  CFIndex v16;
  const void *v17;
  const void *v18;
  const __CFString *v19;
  const __CFString *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  if (!a5)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiManagerAddNetworkScanCallback");
    objc_autoreleasePoolPop(v22);
    return;
  }
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a5 + 1688), 0);
  v9 = objc_msgSend(ValueAtIndex, "network");
  if (v9)
  {
    v10 = objc_msgSend(ValueAtIndex, "client");
    if (v10)
    {
      v11 = (uint64_t)v10;
      if ((_DWORD)a2 == 3)
      {
        v12 = 0;
        v13 = 6;
      }
      else
      {
        if ((_DWORD)a2)
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to scan error %d", "__WiFiManagerAddNetworkScanCallback", a2);
          v13 = 7;
        }
        else
        {
          if (objc_msgSend(ValueAtIndex, "usingPrefix"))
            v14 = (const __CFString *)sub_10002B088(v9);
          else
            v14 = 0;
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (Mutable)
          {
            v12 = Mutable;
            if (a3 && CFArrayGetCount(a3) >= 1)
            {
              v16 = 0;
              do
              {
                v17 = CFArrayGetValueAtIndex(a3, v16);
                if (v17)
                {
                  v18 = v17;
                  if (sub_10002B088(v17))
                  {
                    v19 = (const __CFString *)sub_10002B088(v18);
                    if (CFStringCompare(v19, v14, 0) == kCFCompareEqualTo)
                      goto LABEL_22;
                    v20 = (const __CFString *)sub_10002B088(v18);
                    if (CFStringHasPrefix(v20, v14))
                      CFArrayAppendValue(v12, v18);
                  }
                }
                ++v16;
              }
              while (v16 < CFArrayGetCount(a3));
            }
            if (CFArrayGetCount(v12))
            {
              v18 = CFArrayGetValueAtIndex(v12, 0);
              if (v18)
              {
LABEL_22:
                v21 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found network %@ matching prefix %@", "__WiFiManagerAddNetworkScanCallback", sub_10002B088(v18), v14);
                objc_autoreleasePoolPop(v21);
                objc_msgSend(ValueAtIndex, "setNetworkMatchingPrefix:", v18);
                sub_100098854(a5);
                goto LABEL_31;
              }
            }
            v13 = 9;
            goto LABEL_27;
          }
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null matchingResults", "__WiFiManagerAddNetworkScanCallback");
          v13 = 9;
        }
        objc_autoreleasePoolPop(v24);
        v12 = 0;
      }
LABEL_27:
      sub_100066564(v11, a5, (uint64_t)v9, v13);
      goto LABEL_28;
    }
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: client is null", "__WiFiManagerAddNetworkScanCallback");
  }
  else
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: request network is null", "__WiFiManagerAddNetworkScanCallback");
  }
  objc_autoreleasePoolPop(v23);
  v12 = 0;
  v13 = 9;
LABEL_28:
  if (objc_msgSend(ValueAtIndex, "callback"))
    ((void (*)(uint64_t, id, uint64_t, id))objc_msgSend(ValueAtIndex, "callback"))(a5, v9, v13, objc_msgSend(ValueAtIndex, "context"));
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a5 + 1688), 0);
  if (v12)
LABEL_31:
    CFRelease(v12);
}

void sub_1000AEEE4(uint64_t a1)
{
  const void *v2;
  const void *v3;

  sub_100038580(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(const void **)(a1 + 48), *(_QWORD *)(a1 + 56));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = 0;
  }
}

void sub_1000AEF54(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[6];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000AEFAC;
  v4[3] = &unk_1002306C8;
  v4[4] = a2;
  v4[5] = v2;
  dispatch_async(v3, v4);
}

void sub_1000AEFAC(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;
  void *v8;
  void *v9;
  const __CFString *v10;
  void *v11;
  void *v12;
  const char *v13;
  void *v14;
  void *v15;
  NSObject *v16;
  dispatch_time_t v17;

  v2 = objc_msgSend(*(id *)(a1 + 32), "objectForKey:", CFSTR("SBApplicationStateDisplayIDKey"));
  v5 = a1 + 32;
  v3 = *(void **)(a1 + 32);
  v4 = *(_QWORD *)(v5 + 8);
  v6 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (objc_msgSend(v3, "objectForKey:", CFSTR("SBApplicationStateKey")))
    {
      v7 = objc_msgSend(objc_msgSend(v3, "objectForKey:", CFSTR("SBApplicationStateKey")), "integerValue");
      goto LABEL_8;
    }
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: missing user info dictionary", "__BKApplicationStateFromUserInfo");
    objc_autoreleasePoolPop(v8);
  }
  v7 = 0;
LABEL_8:
  objc_autoreleasePoolPop(v6);
  if (!v4)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiManagerSessionBasedApplicationStateChange");
    goto LABEL_20;
  }
  v9 = objc_autoreleasePoolPush();
  if (!v2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bundle id is null", "__WiFiManagerSessionBasedApplicationStateChange");
    v14 = v9;
    goto LABEL_21;
  }
  if (qword_10026DD20)
  {
    if (v7 - 1 > 7)
      v10 = CFSTR("Unknown");
    else
      v10 = off_100230D80[v7 - 1];
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bundleId %@ state %@", "__WiFiManagerSessionBasedApplicationStateChange", v2, v10);
  }
  objc_autoreleasePoolPop(v9);
  if (v7 != 8 && *(_BYTE *)(v4 + 1672))
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_20:
      v14 = v11;
LABEL_21:
      objc_autoreleasePoolPop(v14);
      return;
    }
    v13 = "%s: state change ignored, timer running for disassociation";
LABEL_19:
    objc_msgSend(v12, "WFLog:message:", 3, v13, "__WiFiManagerSessionBasedApplicationStateChange");
    goto LABEL_20;
  }
  if (v7 == 8 && *(_BYTE *)(v4 + 1672))
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: application became active, cancelling disassociation timer", "__WiFiManagerSessionBasedApplicationStateChange");
    objc_autoreleasePoolPop(v15);
    dispatch_source_set_timer(*(dispatch_source_t *)(v4 + 1680), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(_BYTE *)(v4 + 1672) = 0;
  }
  else if (v7 != 8 && !*(_BYTE *)(v4 + 1672))
  {
    v16 = *(NSObject **)(v4 + 1680);
    v17 = dispatch_time(0, 15000000000);
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(_BYTE *)(v4 + 1672) = 1;
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_20;
    v13 = "%s: starting timer for disassociation";
    goto LABEL_19;
  }
}

void sub_1000AF25C()
{
  NSObject *v0;
  void *v1;
  _QWORD block[5];

  if (qword_10026D680)
  {
    v0 = *(NSObject **)(qword_10026D680 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000AF30C;
    block[3] = &unk_10022EA38;
    block[4] = qword_10026D680;
    dispatch_async(v0, block);
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to get manager", "__WiFiManagerForcedAssociationFailureUserNotificationCallback");
    objc_autoreleasePoolPop(v1);
  }
}

void sub_1000AF30C(uint64_t a1)
{
  __CFRunLoop *Main;
  uint64_t v3;

  Main = CFRunLoopGetMain();
  CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(*(_QWORD *)(a1 + 32) + 1640), kCFRunLoopDefaultMode);
  v3 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v3 + 1640))
  {
    CFRelease(*(CFTypeRef *)(v3 + 1640));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1640) = 0;
    v3 = *(_QWORD *)(a1 + 32);
  }
  if (*(_QWORD *)(v3 + 1648))
  {
    CFRelease(*(CFTypeRef *)(v3 + 1648));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1648) = 0;
    v3 = *(_QWORD *)(a1 + 32);
  }
  sub_100098854(v3);
}

void sub_1000AF380(const __SCDynamicStore *a1, uint64_t a2, const __CFArray *a3)
{
  void *v6;
  const char *v7;
  const __CFString *NetworkInterface;
  const __CFString *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFArray *Value;
  const __CFArray *v14;
  CFTypeID v15;
  CFMutableArrayRef Mutable;
  __CFArray *v17;
  CFIndex v18;
  const void *ValueAtIndex;
  void *v20;
  CFIndex v21;
  const __CFString *v22;
  const __CFString *v23;
  void *v24;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v7 = "DyamicStoreChange";
    if (!a2)
      v7 = "Initialization";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Callback reason=%s", v7);
  }
  objc_autoreleasePoolPop(v6);
  NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(kCFAllocatorDefault, kSCDynamicStoreDomainState);
  if (NetworkInterface)
  {
    v9 = NetworkInterface;
    v10 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkInterface);
    if (v10)
    {
      v11 = v10;
      v12 = CFGetTypeID(v10);
      if (v12 == CFDictionaryGetTypeID())
      {
        Value = (const __CFArray *)CFDictionaryGetValue(v11, kSCDynamicStorePropNetInterfaces);
        if (Value)
        {
          v14 = Value;
          v15 = CFGetTypeID(Value);
          if (v15 == CFArrayGetTypeID())
          {
            if (CFArrayGetCount(v14))
            {
              if (CFArrayGetCount(v14))
              {
                Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                if (Mutable)
                {
                  v17 = Mutable;
                  if (CFArrayGetCount(v14) >= 1)
                  {
                    v18 = 0;
                    do
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex(v14, v18);
                      if (sub_1000B0484((uint64_t)ValueAtIndex))
                        CFArrayAppendValue(v17, ValueAtIndex);
                      ++v18;
                    }
                    while (v18 < CFArrayGetCount(v14));
                  }
                  if (CFArrayGetCount(v17))
                  {
                    v20 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Discovered %ld airport Interfaces", CFArrayGetCount(v17));
                    objc_autoreleasePoolPop(v20);
                    if (CFArrayGetCount(v17) >= 1)
                    {
                      v21 = 0;
                      do
                      {
                        v22 = (const __CFString *)CFArrayGetValueAtIndex(v17, v21);
                        if (v22)
                        {
                          v23 = v22;
                          if (!sub_1000AF714(a3, v22))
                          {
                            v24 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Now attempting to add AirPort Interface with BSDName %@", v23);
                            objc_autoreleasePoolPop(v24);
                            sub_1000AF7B4((int)a3, v23);
                          }
                        }
                        ++v21;
                      }
                      while (v21 < CFArrayGetCount(v17));
                    }
                  }
                  CFRelease(v17);
                }
              }
            }
          }
        }
      }
      CFRelease(v11);
    }
    CFRelease(v9);
  }
}

void sub_1000AF618(uint64_t a1)
{
  CFStringRef NetworkInterface;
  CFStringRef v3;
  __CFArray *Mutable;
  const __CFArray *v5;

  NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(kCFAllocatorDefault, kSCDynamicStoreDomainState);
  if (NetworkInterface)
  {
    v3 = NetworkInterface;
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      v5 = Mutable;
      CFArrayAppendValue(Mutable, v3);
      if (CFArrayGetCount(v5))
        SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 72), v5, 0);
      CFRelease(v3);
    }
    else
    {
      v5 = (const __CFArray *)v3;
    }
    CFRelease(v5);
  }
}

void sub_1000AF6C4(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    sub_1000AF618(a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Cannot reconnect to the dynamic store - info is NULL");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000AF714(const __CFArray *a1, const void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  const void *ValueAtIndex;
  const void *v7;
  uint64_t v8;

  v3 = sub_100009CDC(a1);
  if (!v3)
    return 0;
  v4 = v3;
  if (CFArrayGetCount(v3) && CFArrayGetCount(v4) >= 1)
  {
    v5 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
      if (ValueAtIndex)
      {
        v7 = (const void *)sub_100029860((uint64_t)ValueAtIndex);
        if (CFEqual(v7, a2))
          break;
      }
      if (++v5 >= CFArrayGetCount(v4))
        goto LABEL_8;
    }
    v8 = 1;
  }
  else
  {
LABEL_8:
    v8 = 0;
  }
  CFRelease(v4);
  return v8;
}

void sub_1000AF7B4(uint64_t a1, CFStringRef theString)
{
  CFAllocatorRef v4;
  const __CFString *NetworkInterface;
  const __CFString *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  const __CFArray *Value;
  const __CFArray *v11;
  CFTypeID v12;
  __CFDictionary *Mutable;
  __CFDictionary *v14;
  __CFDictionary *v15;
  __CFDictionary *v16;
  int v17;
  uint64_t MatchingService;
  void *v19;
  const __CFString *v20;
  uint64_t v21;
  const __CFString *CFProperty;
  uint64_t v23;
  const void *v24;
  unsigned int v25;
  unsigned int v26;
  void *v27;
  const __SCNetworkInterface *v28;
  const __CFArray *v29;
  const __CFArray *v30;
  CFIndex Count;
  CFIndex v32;
  CFIndex v33;
  const __SCNetworkSet *ValueAtIndex;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  int i;
  int j;
  void *v42;
  void *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  const char *v49;
  int *v50;
  __CFDictionary *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  CFStringRef v56;
  const __CFString *v57;
  __CFDictionary *v58;
  int v59;
  uint64_t context;
  unint64_t v61;
  int *v62;
  uint64_t v63;
  char buffer[8];
  uint64_t v65;
  CFRange v66;

  *(_QWORD *)buffer = 0;
  v65 = 0;
  if (!a1)
    return;
  if (!theString)
    return;
  CFStringGetCString(theString, buffer, 16, 0);
  if (sub_1000AF714((const __CFArray *)a1, theString))
    return;
  if (!*(_QWORD *)(a1 + 72))
    goto LABEL_91;
  v4 = kCFAllocatorDefault;
  NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(kCFAllocatorDefault, kSCDynamicStoreDomainState);
  if (!NetworkInterface)
    goto LABEL_91;
  v6 = NetworkInterface;
  v7 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 72), NetworkInterface);
  if (!v7)
  {
    CFRelease(v6);
LABEL_91:
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ does not exist in dynamic store", theString);
    goto LABEL_95;
  }
  v8 = v7;
  v9 = CFGetTypeID(v7);
  if (v9 != CFDictionaryGetTypeID())
    goto LABEL_12;
  Value = (const __CFArray *)CFDictionaryGetValue(v8, kSCDynamicStorePropNetInterfaces);
  v11 = Value;
  if (!Value)
    goto LABEL_13;
  v12 = CFGetTypeID(Value);
  if (v12 == CFArrayGetTypeID() && CFArrayGetCount(v11))
  {
    v66.length = CFArrayGetCount(v11);
    v66.location = 0;
    LODWORD(v11) = CFArrayContainsValue(v11, v66, theString);
  }
  else
  {
LABEL_12:
    LODWORD(v11) = 0;
  }
LABEL_13:
  CFRelease(v6);
  CFRelease(v8);
  if (!(_DWORD)v11)
    goto LABEL_91;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ propertyDictionaryRef alloc failed", theString);
LABEL_95:
    objc_autoreleasePoolPop(v52);
    return;
  }
  v14 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("IOInterfaceName"), theString);
  v15 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v15)
  {
    v16 = v15;
    CFDictionarySetValue(v15, CFSTR("IOPropertyMatch"), v14);
    v17 = 32;
    while (1)
    {
      CFRetain(v16);
      MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v16);
      if ((_DWORD)MatchingService)
        break;
      usleep(0x2710u);
      if (!--v17)
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No Matching Service Found for interface %@", "__WiFiManagerDeviceAddedCallback", theString);
        objc_autoreleasePoolPop(v19);
        v20 = 0;
LABEL_86:
        CFRelease(v16);
        CFRelease(v14);
        if (v20)
        {
          v51 = (__CFDictionary *)v20;
          goto LABEL_88;
        }
        return;
      }
    }
    v21 = MatchingService;
    CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(MatchingService, CFSTR("IO80211InterfaceRole"), kCFAllocatorDefault, 0);
    v57 = CFProperty;
    v58 = v14;
    if (!CFProperty || CFStringCompare(CFProperty, CFSTR("Infrastructure"), 0))
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is a virtual IO80211 interface", "__WiFiManagerDeviceAddedCallback", theString);
      goto LABEL_84;
    }
    v56 = theString;
    -[WiFiUserInteractionMonitor startMonitoringInterface:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "startMonitoringInterface:", theString);
    v23 = sub_1000690B4(kCFAllocatorDefault, v21);
    if (!v23)
      goto LABEL_85;
    v24 = (const void *)v23;
    v25 = sub_100007620(*(const __SCPreferences **)(a1 + 1064));
    if (!v25)
    {
LABEL_45:
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 96), v24);
      v36 = sub_1000E7998((uint64_t)v4, v24, *(NSObject **)(a1 + 32));
      if (v36)
      {
        v37 = (void *)v36;
        CFRelease(v24);
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 104), v37);
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s() CATS Trace: Enter\n", "__WiFiManagerDeviceManagerInit");
        objc_autoreleasePoolPop(v38);
        context = a1;
        v61 = 0xAAAAAAAA00000000;
        v62 = (int *)(a1 + 20);
        v63 = 1;
        sub_1000FC88C((uint64_t)v37, (uint64_t)sub_1000B05F8, a1);
        sub_1000FC8A4((uint64_t)v37, (uint64_t)sub_1000B089C, a1);
        sub_1000FC898((uint64_t)v37, (uint64_t)sub_1000B08A4, a1);
        sub_1000FC8B0((uint64_t)v37, (uint64_t)sub_1000B0954, a1);
        sub_1000FC8BC((uint64_t)v37, (uint64_t)sub_1000B136C, a1);
        sub_1000FC8C8((uint64_t)v37, (uint64_t)sub_1000B172C, a1);
        sub_1000FC8D4((uint64_t)v37, (uint64_t)sub_1000B17C8, a1);
        sub_1000FC8E0((uint64_t)v37, (uint64_t)sub_1000B1950, a1);
        sub_1000FC8EC((uint64_t)v37, (uint64_t)sub_1000B19D0, a1);
        sub_1000FC904((uint64_t)v37, (uint64_t)sub_1000B1AB0, a1);
        sub_1000FC82C((uint64_t)v37, (uint64_t)sub_1000B1AE0, a1);
        sub_1000FC838((uint64_t)v37, (uint64_t)sub_1000B2A2C, a1);
        sub_1000FC850((uint64_t)v37, (uint64_t)sub_1000B2AA8, a1);
        sub_1000FC85C((uint64_t)v37, (uint64_t)sub_1000B2B8C, a1);
        sub_1000FC868((uint64_t)v37, (uint64_t)sub_1000B2EBC, a1);
        sub_1000FC874((uint64_t)v37, (uint64_t)sub_1000B301C, a1);
        sub_1000FC880((uint64_t)v37, (uint64_t)sub_1000B3204, a1);
        sub_1000FC8F8((uint64_t)v37, (uint64_t)sub_10000EDC4, a1);
        sub_1000FC928((uint64_t)v37, (uint64_t)sub_1000B33E0, a1);
        sub_1000FC934((uint64_t)v37, (uint64_t)sub_1000B33F8, a1);
        sub_1000FC940((uint64_t)v37, (uint64_t)sub_1000093F8, a1);
        sub_1000FC94C((uint64_t)v37, (uint64_t)sub_1000300A4, a1);
        sub_1000FC958((uint64_t)v37, (uint64_t)sub_1000B3430, a1);
        sub_100070844((uint64_t)v37, (uint64_t)sub_1000B346C, a1);
        sub_100070850((uint64_t)v37, (uint64_t)sub_1000B34A8, a1);
        sub_1000FC964((uint64_t)v37, (uint64_t)sub_1000B34E4, a1);
        sub_1000FC970((uint64_t)v37, (uint64_t)sub_10000CCC8, a1);
        sub_1000FC97C((uint64_t)v37, (uint64_t)sub_1000B3564, a1);
        sub_1000FC988((uint64_t)v37, (uint64_t)sub_1000B35A0, a1);
        sub_1000FC994((uint64_t)v37, (uint64_t)sub_1000B35E0, a1);
        sub_1000FC9A0((uint64_t)v37, (uint64_t)sub_1000B3628, a1);
        sub_1000FC9B8((uint64_t)v37, (uint64_t)sub_100018A1C, a1);
        sub_1000FCA0C((uint64_t)v37, (uint64_t)sub_1000B3668, a1);
        sub_1000FCA18((uint64_t)v37, (uint64_t)sub_1000B3764, a1);
        sub_1000FC844((uint64_t)v37, (uint64_t)sub_1000AC5A4, a1);
        sub_10007079C((uint64_t)v37, (uint64_t)sub_1000B3794, a1);
        sub_10007088C((uint64_t)v37, (uint64_t)sub_1000B3958, a1);
        sub_1000FC9E8((uint64_t)v37, (uint64_t)sub_1000B3B74, a1);
        sub_100110218((uint64_t)v37, (uint64_t)sub_1000B3BC0, a1);
        sub_100112030((uint64_t)v37, (uint64_t)sub_1000B3BF4, a1);
        sub_1000FC910((uint64_t)v37, (uint64_t)sub_1000B4214, a1);
        sub_1000FC91C((uint64_t)v37, (uint64_t)sub_1000B4244, a1);
        sub_1000FC9DC((uint64_t)v37, (uint64_t)sub_1000B4274, a1);
        sub_100110224((uint64_t)v37, (uint64_t)sub_1000B4514, a1);
        sub_1001153E4((uint64_t)v37, (uint64_t)sub_1000B4548, a1);
        sub_1000FC9F4((uint64_t)v37, (uint64_t)sub_1000B4554, a1);
        sub_1000FCA00((uint64_t)v37, (uint64_t)sub_1000B4588, a1);
        sub_100117C70((uint64_t)v37, (uint64_t)sub_1000B45A4, a1);
        sub_10011A558((uint64_t)v37, (uint64_t)sub_1000B46FC, a1);
        sub_1000FC9AC((uint64_t)v37, (uint64_t)sub_1000B4708, a1);
        sub_1000FC9D0((uint64_t)v37, (uint64_t)sub_1000B538C, a1);
        sub_1000FCA24((uint64_t)v37, (uint64_t)sub_1000B539C, a1);
        sub_1000FCA30((uint64_t)v37, (uint64_t)sub_1000B54D4, a1);
        sub_10011CE48((uint64_t)v37, (uint64_t)sub_1000B566C, a1);
        sub_1000FCA3C((uint64_t)v37, (uint64_t)sub_1000B5680, a1);
        sub_100117C7C((uint64_t)v37, (uint64_t)sub_1000B578C, a1);
        sub_100070874((uint64_t)v37, (uint64_t)sub_1000B590C, a1);
        sub_100070898((uint64_t)v37, (uint64_t)nullsub_5, a1);
        sub_1000708BC((uint64_t)v37, (uint64_t)sub_1000B613C, a1);
        sub_1000708C8((uint64_t)v37, (uint64_t)sub_1000B630C, a1);
        sub_10011E684((uint64_t)v37, a1);
        sub_1000708D4((uint64_t)v37, (uint64_t)sub_1000B63F8, a1);
        sub_10011E678((uint64_t)v37, (uint64_t)sub_100031ABC, a1);
        sub_10011E670((uint64_t)v37, a1);
        v39 = *(_QWORD *)(a1 + 2312);
        if (v39)
          sub_10011AD38((uint64_t)v37, v39);
        for (i = 23; i != 47; ++i)
        {
          LODWORD(v61) = i;
          v59 = 5;
          if (i != 34)
          {
            if (i == 33)
              v62 = &v59;
            sub_10002E0D4((CFMutableArrayRef *)v37, (int *)&context);
            v62 = (int *)(a1 + 20);
          }
        }
        for (j = 0; j != 14; ++j)
        {
          LODWORD(v61) = j;
          if (j == 8)
            v62 = 0;
          sub_10002E0D4((CFMutableArrayRef *)v37, (int *)&context);
          v62 = (int *)(a1 + 20);
        }
        sub_1001062AC((uint64_t)v37);
        sub_1000FB1F0((uint64_t)v37, *(_QWORD *)(a1 + 1432));
        sub_10011ADFC((uint64_t)v37, *(unsigned __int8 *)(a1 + 2120));
        sub_1001003D0((uint64_t)v37, *(CFTypeRef *)(a1 + 800));
        v42 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s() CATS Trace: Exit\n", "__WiFiManagerDeviceManagerInit");
        objc_autoreleasePoolPop(v42);
        CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B807C, v37);
        if (*(_BYTE *)(a1 + 88) == 1 && !*(_BYTE *)(a1 + 2408))
        {
          v43 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Making WiFi Manager available for all to see");
          objc_autoreleasePoolPop(v43);
          notify_post("com.apple.wifi.manager.available");
        }
        v44 = sub_10000AF8C(a1);
        sub_100118868((uint64_t)v37, v44, 0xFFFFFFFFLL, 0);
        v45 = sub_1000A5A54(a1);
        sub_10011B934((uint64_t)v37, v45);
        if (sub_10008C218(a1))
        {
          v46 = *(_QWORD *)(a1 + 2184);
          if (!v46)
          {
LABEL_72:
            v48 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              if (*(_BYTE *)(a1 + 26))
                v49 = "Enabling";
              else
                v49 = "Disabling";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device manager created. %s automatic association state", "__WiFiManagerDeviceAddedCallback", v49);
            }
            objc_autoreleasePoolPop(v48);
            if (*(_BYTE *)(a1 + 26))
              sub_1000FB2E0((uint64_t)v37);
            else
              sub_1000FB408((uint64_t)v37);
            CFRelease(v37);
            v50 = *(int **)(a1 + 1608);
            context = a1;
            v61 = 0xAAAAAAAA00000043;
            v62 = v50;
            v63 = 1;
            CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
            sub_10009F9BC(a1, *(unsigned int *)(a1 + 1552));
            sub_100012924(a1, v56, 0);
            if (*(_BYTE *)(a1 + 2408))
              *(_BYTE *)(a1 + 2408) = 0;
            v35 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Detected %ld wifi device(s)", CFSetGetCount(*(CFSetRef *)(a1 + 96)), v54);
LABEL_84:
            objc_autoreleasePoolPop(v35);
            goto LABEL_85;
          }
          v47 = (uint64_t)v37;
        }
        else
        {
          v47 = (uint64_t)v37;
          v46 = 0;
        }
        sub_10011BCC0(v47, v46);
        goto LABEL_72;
      }
LABEL_85:
      IOObjectRelease(v21);
      v20 = v57;
      v14 = v58;
      goto LABEL_86;
    }
    v26 = v25;
    v27 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerUpdateDeviceSystemConfiguration");
    v28 = (const __SCNetworkInterface *)_SCNetworkInterfaceCreateWithIONetworkInterfaceObject(v21);
    if (v28)
    {
      v29 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 1064));
      v30 = v29;
      if (!v29)
        goto LABEL_40;
      Count = CFArrayGetCount(v29);
      if (Count)
      {
        v32 = Count;
        if (Count >= 1)
        {
          v55 = v27;
          v33 = 0;
          v26 = 0;
          do
          {
            ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v30, v33);
            if (!SCNetworkSetContainsInterface(ValueAtIndex, v28))
            {
              v26 = SCNetworkSetEstablishDefaultInterfaceConfiguration(ValueAtIndex, v28);
              if (!v26)
              {
                if (SCError())
                  break;
              }
            }
            ++v33;
          }
          while (v32 != v33);
          v27 = v55;
          v4 = kCFAllocatorDefault;
LABEL_40:
          sub_1000076D4(*(SCPreferencesRef *)(a1 + 1064), v26);

          if (v26)
          {
            if (!v30)
              goto LABEL_43;
          }
          else
          {
            SCError();
            if (!v30)
            {
LABEL_43:
              if (v28)
                CFRelease(v28);
              goto LABEL_45;
            }
          }
          CFRelease(v30);
          goto LABEL_43;
        }
        v26 = 0;
      }
      v4 = kCFAllocatorDefault;
      goto LABEL_40;
    }
    v30 = 0;
    goto LABEL_40;
  }
  v53 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ matchingServiceDict alloc failed", theString);
  objc_autoreleasePoolPop(v53);
  v51 = v14;
LABEL_88:
  CFRelease(v51);
}

uint64_t sub_1000B0484(uint64_t a1)
{
  int v2;
  int v3;
  BOOL v4;
  void *v6;
  void *v7;
  char buffer[8];
  uint64_t v9;
  _OWORD v10[3];

  memset(v10, 0, 44);
  *(_QWORD *)buffer = 0;
  v9 = 0;
  v2 = socket(2, 2, 0);
  if (v2 == -1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Socket creation failed", "__WiFiManagerCheckAirPortInterface");
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  else
  {
    v3 = v2;
    if (a1)
    {
      CFStringGetCString((CFStringRef)a1, buffer, 16, 0);
      if (buffer[0])
      {
        __strlcpy_chk(v10, buffer, 16, 16);
        if (ioctl(v3, 0xC02C6938uLL, v10))
          v4 = 0;
        else
          v4 = (v10[1] & 0xE0) == 128;
        a1 = v4;
      }
      else
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, interfaceCName is zero length.", "__WiFiManagerCheckAirPortInterface");
        objc_autoreleasePoolPop(v7);
        a1 = 0;
      }
    }
    close(v3);
  }
  return a1;
}

void sub_1000B05F8(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const void *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  CFIndex v17;
  void *v18;
  void *v19;
  _QWORD block[5];

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s:%d\n", "__WiFiManagerDeviceRemovedCallback", 6968);
  objc_autoreleasePoolPop(v5);
  *(_BYTE *)(a3 + 2408) = 1;
  pthread_mutex_lock(&stru_10026CB48);
  pthread_mutex_lock(&stru_10026CB88);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a3 + 32));
  v6 = (const void *)sub_1000161D4((uint64_t)a1);
  v7 = sub_10000B29C((CFArrayRef)a3);
  v8 = v7;
  if (v7)
  {
    Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      v10 = Count;
      for (i = 0; i != v10; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v8, i);
        v13 = sub_1000161D4((uint64_t)ValueAtIndex);
        if (v13)
        {
          v14 = sub_100029860(v13);
          if (v14)
            objc_msgSend(*(id *)(a3 + 2416), "addFaultEvent:forInterface:", 24, v14);
        }
      }
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "__WiFiManagerSoftErrorDextCrashedEvent");
    objc_autoreleasePoolPop(v19);
  }
  *(_BYTE *)(a3 + 1808) = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B6480;
  block[3] = &unk_10022EA38;
  block[4] = a3;
  dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  if (v8)
    CFRelease(v8);
  sub_10011E9DC((uint64_t)a1);
  sub_1000FB44C((uint64_t)a1);
  sub_1000F6FE8((uint64_t)a1);
  sub_1000F8AF4((uint64_t)a1);
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B64B4, a1);
  CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 104), a1);
  CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 96), v6);
  v15 = objc_autoreleasePoolPush();
  v16 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v17 = CFSetGetCount(*(CFSetRef *)(a3 + 104));
    objc_msgSend(v16, "WFLog:message:", 3, "Finished Clean up %s:%d devm_count:%ld dev_count:%ld\n", "__WiFiManagerDeviceRemovedCallback", 6997, v17, CFSetGetCount(*(CFSetRef *)(a3 + 96)));
  }
  objc_autoreleasePoolPop(v15);
  pthread_mutex_unlock(&stru_10026CB88);
  pthread_mutex_unlock(&stru_10026CB48);
  sub_1000AF380(*(const __SCDynamicStore **)(a3 + 72), 0, (const __CFArray *)a3);
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Exit: %s:%d %ld\n", "__WiFiManagerDeviceRemovedCallback", 7004, CFSetGetCount(*(CFSetRef *)(a3 + 104)));
  objc_autoreleasePoolPop(v18);
}

uint64_t sub_1000B089C(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 2408);
}

void sub_1000B08A4(void *a1, uint64_t a2, uint64_t a3)
{
  int v5;
  _QWORD v6[3];
  uint64_t v7;

  v6[0] = a3;
  v6[1] = 0xAAAAAAAA0000002FLL;
  v6[2] = 0;
  v7 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, v6);
  v5 = v7;
  *(_DWORD *)(a3 + 316) = v7;
  if (v5 == 1)
  {
    sub_1000898A0(a3, 1, 1, 0);
    sub_100090934(a3, *(_DWORD *)(a3 + 2072), 0, 0);
    if (sub_10008D5F4(a3))
      sub_10008BB68(a3);
  }
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B64B8, a1);
}

void sub_1000B0954(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  const __CFAllocator *v7;
  CFAbsoluteTime Current;
  const __CFBoolean *v9;
  const void *v10;
  void *Value;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  const void *v16;
  uint64_t v17;
  const void *v18;
  const void *v19;
  CFTypeID TypeID;
  const __CFNumber *v21;
  const __CFData *v22;
  const __CFNumber *v23;
  void *v24;
  const __CFBoolean *v25;
  const __CFBoolean *v26;
  void *v27;
  void *v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  const __SCPreferences *v38;
  const __SCPreferences *v39;
  void *v40;
  const __CFArray *v41;
  const __CFArray *v42;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef *v44;
  unint64_t v45;
  const __CFDate *v46;
  double v47;
  double v48;
  double v49;
  void *v50;
  int v51;
  uint64_t v52;
  const __CFNumber *v53;
  BOOL v54;
  const void *v55;
  void *v56;
  void *v57;
  CFDictionaryRef v58;
  CFDictionaryRef v59;
  __CFDictionary *Mutable;
  const __CFBoolean *v61;
  uint64_t v62;
  int valuePtr;
  CFIndex context;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  CFIndex v68;

  v7 = kCFAllocatorDefault;
  Current = CFAbsoluteTimeGetCurrent();
  v9 = CFDateCreate(kCFAllocatorDefault, Current);
  v10 = *(const void **)(a3 + 2264);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a3 + 2264) = 0;
  }
  if (!a4)
  {
LABEL_95:
    if (!v9)
      return;
    goto LABEL_96;
  }
  Value = (void *)CFDictionaryGetValue(a4, CFSTR("LINK_CHANGED_NETWORK"));
  sub_1000B64BC(a3, Value);
  sub_100100160(a1, 0);
  if (Value)
  {
    *(_BYTE *)(a3 + 2200) = 1;
    if (*(_BYTE *)(a3 + 1504) || sub_10000BE8C((uint64_t)Value))
    {
      if (sub_1000CA53C((uint64_t)Value))
        sub_1000B6718(a3, a1, 1);
      *(_BYTE *)(a3 + 1504) = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1536), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      context = a3;
      v65 = 0xAAAAAA0000000042;
      v66 = 0xAAAAAAAA00000000;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
      sub_1000B6890(a3, 1);
      kdebug_trace(731381772, 0, 0, 0, 0);
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LINK_UP: so disabled the carplay mode ###STOP_CAAJ", "__WiFiManagerDeviceLinkCallback");
      objc_autoreleasePoolPop(v12);
    }
    if (*(_BYTE *)(a3 + 1560))
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1576), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      *(_BYTE *)(a3 + 1560) = 0;
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LINK_UP: so disabled the companion assisted mode ###STOP_CAAJ", "__WiFiManagerDeviceLinkCallback");
      objc_autoreleasePoolPop(v13);
      context = *(_QWORD *)(a3 + 1568);
      v65 = *(_QWORD *)(a3 + 1584);
      sub_1000618C4((uint64_t)&context, Value);
    }
    if (sub_10009B28C(a3, Value))
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is joined first time, so now enable it", "__WiFiManagerDeviceLinkCallback", sub_10002B088(Value));
      objc_autoreleasePoolPop(v14);
      sub_1000CADDC(Value, 0);
      sub_100099EA4(a3, Value, 1u);
    }
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Retrieving private mac cache version of the network <%@>", "__WiFiManagerDeviceLinkCallback", sub_10002B088(Value));
    objc_autoreleasePoolPop(v15);
    v16 = sub_1000AAF20(a3, (const __CFDictionary **)Value);
    if (v16
      && (v17 = (uint64_t)v16, (v18 = sub_10002BE64((uint64_t)v16, CFSTR("PRIVATE_MAC_ADDRESS"))) != 0)
      && (v19 = v18, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v19)))
    {
      sub_10002C478((uint64_t)Value, CFSTR("PRIVATE_MAC_ADDRESS"), v19);
      v21 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v19, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
      v22 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v19, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
      v23 = sub_100064F80(v21);
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Link UP. UI Status is <%d> and mac address is <%@> for network <%@> ", "__WiFiManagerDeviceLinkCallback", v23, v22, sub_10002B088(Value));
      objc_autoreleasePoolPop(v24);
      if (sub_10002B75C(v22))
      {
        sub_10002C478((uint64_t)Value, CFSTR("PrivateMacInfoDictionary"), 0);
        v25 = (const __CFBoolean *)sub_10002BE64(v17, CFSTR("FailureThresholdMet"));
        v7 = kCFAllocatorDefault;
        if (v25 && (v26 = v25, v25 == kCFBooleanTrue))
        {
          if (!sub_10002B704((uint64_t)Value))
          {
            v27 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Using random MAC and failure threshold met indication is sent in Link UP for network <%@>", "__WiFiManagerDeviceLinkCallback", sub_10002B088(Value));
            objc_autoreleasePoolPop(v27);
            sub_10002C478((uint64_t)Value, CFSTR("FailureThresholdMet"), v26);
            v7 = kCFAllocatorDefault;
          }
        }
        else
        {
          sub_10002C478((uint64_t)Value, CFSTR("FailureThresholdMet"), 0);
        }
      }
      else
      {
        v7 = kCFAllocatorDefault;
        if (!sub_10002B704((uint64_t)Value))
        {
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          sub_10002BAD4(v17, Mutable);
          sub_10002C478((uint64_t)Value, CFSTR("PrivateMacInfoDictionary"), Mutable);
          if (Mutable)
            CFRelease(Mutable);
        }
      }
    }
    else
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Unable to find  private Mac Info for link update for network <%@> ", "__WiFiManagerDeviceLinkCallback", sub_10002B088(Value));
      objc_autoreleasePoolPop(v28);
    }
    if (_os_feature_enabled_impl("WiFiManager", "LinkUpEventAfter4way"))
    {
      if (sub_10003145C((uint64_t)Value) || sub_1000C433C((const __CFDictionary *)Value))
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hold off dispatching client link up event until 4 way completes.", "__WiFiManagerDeviceLinkCallback");
        objc_autoreleasePoolPop(v29);
        v30 = 0;
      }
      else
      {
        v30 = 1;
      }
    }
    else
    {
      v30 = 1;
    }
    if (*(_BYTE *)(a3 + 2360))
    {
      LOBYTE(context) = 0;
      v53 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("LINK_DEBOUNCE_RESULT"));
      if (v53)
      {
        CFNumberGetValue(v53, kCFNumberSInt8Type, &context);
        v54 = (_BYTE)context != 0;
      }
      else
      {
        v54 = 0;
      }
      *(_BYTE *)(a3 + 2345) = v54;
    }
    v55 = *(const void **)(a3 + 1656);
    if (!v55 || CFEqual(v55, Value))
      goto LABEL_92;
  }
  else
  {
    *(_BYTE *)(a3 + 2200) = 0;
    context = a3;
    v65 = 0xAAAAAAAA00000082;
    v66 = 0;
    v67 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    if ((_BYTE)v67)
    {
      v31 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending link down status to Gizmo", "__WiFiManagerDeviceLinkCallback");
      objc_autoreleasePoolPop(v31);
      sub_100176C34(*(void **)(a3 + 1432), 0);
    }
    v32 = (void *)sub_100103560(a1);
    if (v32)
    {
      v33 = v32;
      sub_100096B7C(a3, v32, CFSTR("PrivateMacFeatureToggled"), kCFBooleanFalse);
      sub_100096B7C(a3, v33, CFSTR("LinkDownTimestamp"), v9);
      if (sub_1000C5BD8(v33))
      {
        v34 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: removing ONE TIME PASSWORD for network %@", "__WiFiManagerDeviceLinkCallback", sub_10002B088(v33));
        objc_autoreleasePoolPop(v34);
        sub_1000C65D8(v33);
      }
      if (sub_10000BE8C((uint64_t)v33))
        sub_1000B69B0(a3, a1, (uint64_t)v33);
      v35 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("LINKDOWN_REASON_CODE"));
      v36 = v35;
      valuePtr = 0;
      if (v35)
        CFNumberGetValue(v35, kCFNumberIntType, &valuePtr);
      v62 = a1;
      *(_BYTE *)(a3 + 2360) = 0;
      if (sub_10000BE8C((uint64_t)v33))
      {
        LOBYTE(context) = 0;
        v37 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("LINK_DEBOUNCE_STATE"));
        if (v37)
          CFNumberGetValue(v37, kCFNumberSInt8Type, &context);
        if ((_BYTE)context)
        {
          *(CFAbsoluteTime *)(a3 + 2320) = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)(a3 + 2336) = valuePtr;
          if (CFDictionaryGetValue(a4, CFSTR("LINKDOWN_SUBREASON_CODE")))
            CFNumberGetValue(v36, kCFNumberIntType, (void *)(a3 + 2340));
          *(_BYTE *)(a3 + 2360) = 1;
        }
      }
      context = -1;
      v68 = 0;
      v38 = (const __SCPreferences *)sub_10001D964((_QWORD *)a3, CFSTR("List of known networks"));
      if (v38)
      {
        v39 = v38;
        if (sub_100007620(v38))
        {
          v61 = v9;
          v40 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerUpdateNetworkUsageTime");
          v41 = (const __CFArray *)sub_10008674C(a3);
          if (v41
            && (v42 = v41, sub_1000953B8(*(_DWORD *)(a3 + 304), v41, v33, &context, &v68), context != -1)
            && (ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v42, context)) != 0
            && (v44 = ValueAtIndex, (v45 = sub_10002E000(ValueAtIndex)) != 0))
          {
            v46 = (const __CFDate *)v45;
            v47 = sub_10002DFE4((uint64_t)v44);
            v48 = CFAbsoluteTimeGetCurrent();
            v49 = v47 + v48 - CFDateGetAbsoluteTime(v46);
            sub_1000C6AD4((uint64_t)v44, v49);
            v50 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Total connection time to %@ %f", sub_10002B088(v33), *(_QWORD *)&v49);
            objc_autoreleasePoolPop(v50);
            v51 = sub_100095610(a3, v42);
            sub_100094200(a3, v44, 0);
          }
          else
          {
            v51 = 0;
          }
          sub_1000076D4(v39, v51);

          v9 = v61;
          if (v51)
            sub_10008488C(v52, 2, a3);
        }
      }
      a1 = v62;
      v7 = kCFAllocatorDefault;
    }
    if (!*(_QWORD *)(a3 + 1656))
      goto LABEL_94;
    v30 = 1;
  }
  if (*(_BYTE *)(a3 + 1672))
  {
    v56 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: cancelling session based disassociation timer", "__WiFiManagerDeviceLinkCallback");
    objc_autoreleasePoolPop(v56);
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1680), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(_BYTE *)(a3 + 1672) = 0;
  }
  v57 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no longer attached to session based network, stopping monitor", "__WiFiManagerDeviceLinkCallback");
  objc_autoreleasePoolPop(v57);
  sub_1000B6A48(a3);
  if (!Value)
  {
LABEL_98:
    if (v30)
      goto LABEL_94;
    goto LABEL_99;
  }
LABEL_92:
  v58 = sub_1000173C0((uint64_t)Value);
  if (!v58)
    goto LABEL_98;
  v59 = v58;
  CFDictionaryReplaceValue(a4, CFSTR("LINK_CHANGED_NETWORK"), v58);
  CFRelease(v59);
  if ((v30 & 1) != 0)
  {
LABEL_94:
    context = a3;
    v65 = a1;
    v66 = (unint64_t)a4;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B6EA8, &context);
    goto LABEL_95;
  }
LABEL_99:
  *(_QWORD *)(a3 + 2264) = CFDictionaryCreateCopy(v7, a4);
  if (v9)
LABEL_96:
    CFRelease(v9);
}

void sub_1000B136C(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, void *a5)
{
  const void *v10;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  void *v13;
  void *v14;
  const __CFString *v15;
  const __CFString *v16;
  void *v17;
  __CFDictionary *MutableCopy;
  CFDictionaryRef Copy;
  id v20;
  uint64_t v21;
  _QWORD block[5];
  void *value;
  _QWORD context[2];

  if (!a3 || !theDict)
    return;
  v10 = CFDictionaryGetValue(theDict, CFSTR("autoJoinNetwork"));
  if (v10)
  {
    v11 = sub_1000173C0((uint64_t)v10);
    if (v11)
    {
      v12 = v11;
      CFDictionaryReplaceValue(theDict, CFSTR("autoJoinNetwork"), v11);
      CFRelease(v12);
    }
  }
  value = 0;
  CFDictionaryGetValueIfPresent(theDict, CFSTR("autoJoinStatus"), (const void **)&value);
  if (value && CFStringCompare((CFStringRef)value, CFSTR("autoJoinAlreadyAssoicated"), 0) == kCFCompareEqualTo)
  {
    v14 = sub_10009FEE0((const __CFArray *)a3);
    v15 = (const __CFString *)sub_10002B088(v14);
    if (v15)
    {
      if (*(_BYTE *)(a3 + 1560))
      {
        v16 = *(const __CFString **)(a3 + 1568);
        if (v16)
        {
          if (CFStringCompare(v15, v16, 0) == kCFCompareEqualTo)
          {
            dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1576), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
            *(_BYTE *)(a3 + 1560) = 0;
            v17 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: already associated, so disabled the companion assisted mode ###STOP_CAAJ", "__WiFiManagerDeviceAutoJoinCallback");
            objc_autoreleasePoolPop(v17);
          }
        }
      }
    }
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    CFDictionarySetValue(MutableCopy, CFSTR("autoJoinStatus"), CFSTR("autoJoinSuccess"));
    Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, MutableCopy);
    if (MutableCopy)
      CFRelease(MutableCopy);
    if (v14)
      CFRelease(v14);
    if (Copy)
      CFRelease(Copy);
  }
  else
  {
    context[0] = a1;
    context[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B6EFC, context);
  }
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    if (objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinAssociating"))
      || (objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinWaiting")) & 1) != 0
      || objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinEAPNeedsUserFix")))
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinUpdatedWithState:interfaceName:", 3, a2);
    }
    else
    {
      if (objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinAssociationFailure"))
        || objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinNetworkNotFound"))
        || objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinAborted")))
      {
        v20 = +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager");
        v21 = 0;
      }
      else
      {
        if (!objc_msgSend(value, "isEqualToString:", CFSTR("autoJoinSuccess")))
          goto LABEL_14;
        v20 = +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager");
        v21 = 1;
      }
      objc_msgSend(v20, "autoJoinEndedWithResult:interfaceName:", v21, a2);
    }
  }
LABEL_14:
  if (&_WiFiCloudSyncEngineCreate
    && a5
    && *(_QWORD *)(a3 + 1304)
    && CWFIsAutoJoinRetryTrigger(objc_msgSend(objc_msgSend(a5, "autoJoinParameters"), "trigger"))
    && !objc_msgSend(a5, "error")
    && !*(_BYTE *)(a3 + 1296))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting cloud sync engine after AJ retry", "__WiFiManagerDeviceAutoJoinCallback");
    objc_autoreleasePoolPop(v13);
    *(_BYTE *)(a3 + 1296) = 1;
    WiFiCloudSyncEngineScheduleWithQueue(*(_QWORD *)(a3 + 1304), qword_10026DD48);
    CFRetain(*(CFTypeRef *)(a3 + 1304));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B6ECC;
    block[3] = &unk_10022EA38;
    block[4] = a3;
    dispatch_async((dispatch_queue_t)qword_10026DD48, block);
  }
}

void sub_1000B172C(uint64_t a1, int a2, uint64_t a3, CFDictionaryRef theDict)
{
  const void *Value;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  _QWORD v10[2];

  if (a3 && theDict)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("userJoinNetwork"));
    if (Value)
    {
      v8 = sub_1000173C0((uint64_t)Value);
      if (v8)
      {
        v9 = v8;
        CFDictionaryReplaceValue(theDict, CFSTR("userJoinNetwork"), v8);
        CFRelease(v9);
      }
    }
    v10[0] = a1;
    v10[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B6F18, v10);
  }
}

void sub_1000B17C8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  const __CFDictionary *v10;
  __CFDictionary *MutableCopy;
  void *v12;
  _QWORD context[3];

  if (a3)
  {
    if (a4)
    {
      v8 = sub_1000173C0((uint64_t)a4);
      if (v8)
      {
        v9 = v8;
        v10 = *(const __CFDictionary **)(a3 + 2264);
        if (v10 && (MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v10)) != 0
          || (MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) != 0)
        {
          CFDictionarySetValue(MutableCopy, CFSTR("LINK_CHANGED_IS_LINKDOWN"), kCFBooleanFalse);
          CFDictionarySetValue(MutableCopy, CFSTR("LINK_CHANGED_NETWORK"), v9);
          CFRelease(v9);
          sub_100099EA4(a3, a4, 1u);
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: outranking state overridden. Replaying link event to clients.", "__WiFiManagerUserOverridingCellularOutrankingCallback");
          objc_autoreleasePoolPop(v12);
          context[0] = a3;
          context[1] = a1;
          context[2] = MutableCopy;
          CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B6EA8, context);
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "replayLinkUpEventWithInterfaceName:", a2);
          CFRelease(MutableCopy);
        }
        else
        {
          CFRelease(v9);
        }
      }
    }
  }
}

void sub_1000B1950(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  const __CFBoolean *Value;
  BOOL v7;
  _QWORD v8[2];

  if (a2 && theDict)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("HostApEnabled"));
    v7 = Value && CFBooleanGetValue(Value);
    *(_BYTE *)(a2 + 1208) = v7;
    v8[0] = a1;
    v8[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a2 + 136), (CFSetApplierFunction)sub_1000B6F34, v8);
  }
}

void sub_1000B19D0(uint64_t a1, uint64_t a2, int a3)
{
  int v5;
  void *v6;
  const char *v7;
  const char *v8;

  v5 = *(unsigned __int8 *)(a2 + 1209);
  *(_BYTE *)(a2 + 1209) = a3;
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v7 = "disabled";
    if (*(_BYTE *)(a2 + 1211) == 1)
      v8 = "enabled";
    else
      v8 = "disabled";
    if (*(_BYTE *)(a2 + 1209) == 1)
      v7 = "enabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS Discovery Req state %s Current state %s", "__WiFiManagerDeviceMISDiscoverStateChangeCallback", v8, v7);
  }
  objc_autoreleasePoolPop(v6);
  if (v5 != a3)
  {
    if (objc_opt_class(CHSControlService))
      dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_1002309B8);
  }
}

void sub_1000B1AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B6FBC, v4);
}

void sub_1000B1AE0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v8;
  void *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFNumber *Value;
  CFBooleanRef v13;
  BOOL v14;
  int v15;
  __CFDictionary *MutableCopy;
  const void *v17;
  const __CFBoolean *v18;
  const __CFBoolean *v19;
  void *v20;
  void *v21;
  const char *v22;
  const void *v23;
  void *v24;
  const __CFArray *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  const __CFArray *v30;
  const void *v31;
  uint64_t v32;
  const __CFBoolean *v33;
  void *v34;
  const void *ValueAtIndex;
  void *v36;
  void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  CFBooleanRef v41;
  void *v42;
  void *v43;
  CFAbsoluteTime Current;
  CFDateRef v45;
  NSUserDefaults *v46;
  int v47;
  const __CFString *v48;
  void *v49;
  const void *v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  const __CFDictionary *v54;
  CFBooleanRef v55;
  const __CFBoolean *v56;
  const void *v57;
  const __CFBoolean *v58;
  __CFDictionary *v59;
  __CFDictionary *Mutable;
  int v61;
  CFNumberRef v62;
  const __CFData *v63;
  void *v64;
  void *v65;
  char v66;
  const void *v67;
  void *v68;
  CFNumberRef v69;
  void *v70;
  void *v71;
  CFTypeID TypeID;
  void *v73;
  void *v74;
  void *v75;
  char v76;
  void *v77;
  int v78;
  void *v79;
  const void *v80;
  const __CFString *v81;
  unsigned int v82;
  void *v83;
  __CFDictionary *v84;
  uint64_t v85;
  char v86;
  char v87;
  const __CFBoolean *v88;
  CFDateRef v89;
  const __CFString *v90;
  uint64_t v91;
  CFIndex idx[4];

  sub_1000B6FD8(a6, a3, a2);
  v8 = (void *)sub_1000AAF20(a6, (const __CFDictionary **)a3);
  v9 = v8;
  if (!v8)
  {
    v15 = 0;
    v11 = 0;
LABEL_11:
    Value = 0;
    goto LABEL_12;
  }
  v10 = (const __CFDictionary *)sub_10002BE64((uint64_t)v8, CFSTR("PRIVATE_MAC_ADDRESS"));
  v11 = v10;
  if (!v10)
  {
    v15 = 0;
    goto LABEL_11;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
  v13 = (CFBooleanRef)sub_10002BE64((uint64_t)v9, CFSTR("IsPrivateMacAddressCarriedOver"));
  if (v13)
    v14 = v13 == kCFBooleanTrue;
  else
    v14 = 0;
  v15 = v14;
LABEL_12:
  if (!sub_10002BE64((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
  {
    if (!Value || sub_100064F80(Value) == 1 || !v15)
      goto LABEL_28;
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v11);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
    CFDictionaryRemoveValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
    sub_100096B7C(a6, v9, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
    sub_100096B7C(a6, v9, CFSTR("IsPrivateMacAddressCarriedOver"), kCFBooleanFalse);
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v84 = MutableCopy;
    v22 = "clear carried over private mac address (%@)";
    goto LABEL_24;
  }
  if (!Value || sub_100064F80(Value) == 1)
    goto LABEL_28;
  MutableCopy = (__CFDictionary *)sub_10009FEE0((const __CFArray *)a6);
  v17 = sub_1000AAF20(a6, (const __CFDictionary **)MutableCopy);
  if (!v17)
    goto LABEL_26;
  v18 = (const __CFBoolean *)sub_10002BE64((uint64_t)v17, CFSTR("PRIVATE_MAC_ADDRESS"));
  if (!v18)
    goto LABEL_26;
  v19 = v18;
  sub_10002C478((uint64_t)a3, CFSTR("PRIVATE_MAC_ADDRESS"), v18);
  sub_100096B7C(a6, v9, CFSTR("PRIVATE_MAC_ADDRESS"), v19);
  sub_100096B7C(a6, v9, CFSTR("IsPrivateMacAddressCarriedOver"), kCFBooleanTrue);
  v20 = objc_autoreleasePoolPush();
  v21 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v22 = "carry over private mac address due to SSID transition";
LABEL_24:
    objc_msgSend(v21, "WFLog:message:", 3, v22, v84);
  }
LABEL_25:
  objc_autoreleasePoolPop(v20);
LABEL_26:
  if (MutableCopy)
    CFRelease(MutableCopy);
LABEL_28:
  if (!a3)
    return;
  v23 = sub_10002B088(a3);
  if (*(_BYTE *)(a6 + 529) && sub_1000B71C0(a6))
  {
    *(_BYTE *)(a6 + 529) = 0;
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Profiles Networks successfully checked for MDM or supervised.", "__WiFiManagerWillAssociateCallback");
    objc_autoreleasePoolPop(v24);
  }
  if ((!*(_BYTE *)(a6 + 528)
     || !-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))&& *(_BYTE *)(a6 + 376))
  {
    v25 = (const __CFArray *)sub_10008674C(a6);
    v26 = (void *)sub_1000A7E60(v25, (uint64_t)a3);
    if (v26)
      v27 = v26;
    else
      v27 = a3;
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation :  Associating to network <%@> while in Buddy. Upgrading it to MigratedNetwork Status and disabling private Mac", "__WiFiManagerWillAssociateCallback", v23);
    objc_autoreleasePoolPop(v28);
    if (!sub_1000A7EE0(a6, v27, 5))
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Unable to add new network (%@) to Private Mac network List", v23);
      objc_autoreleasePoolPop(v29);
    }
  }
  if (sub_10002DA5C((_BOOL8)a3))
  {
    v30 = (const __CFArray *)sub_1000875B0(a6);
    v31 = sub_10002B634(*(const __CFArray **)(a6 + 352), (const __CFDictionary **)a3);
    v91 = 0;
    idx[0] = -1;
    if (v31)
    {
      v32 = (uint64_t)v31;
      v33 = (const __CFBoolean *)sub_10002BE64((uint64_t)v31, CFSTR("PrivateMacPrefChanged"));
      if (v33 && v33 == kCFBooleanTrue || sub_10002BE64(v32, CFSTR("PrivateMacDefaultToOFF")))
        goto LABEL_69;
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : HS20 network <%@> Will check provisioning for private MAC default OFF property", "__WiFiManagerWillAssociateCallback", v23);
    }
    else
    {
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : New HS20 network <%@> Will check provisioning for private MAC default OFF property", "__WiFiManagerWillAssociateCallback", v23);
    }
    objc_autoreleasePoolPop(v34);
    sub_1000AADDC(v30, a3, idx, &v91);
    if (idx[0] != -1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v30, idx[0]);
      v36 = objc_autoreleasePoolPush();
      v37 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v38 = sub_10002B088(ValueAtIndex);
        objc_msgSend(v37, "WFLog:message:", 3, "%s: WFMacRandomisation : HS20 network <%@> found (provisioned). Profile from private Mac Cache : <%@>. Sanity check : is found earlier to be provisioned? <%hhu>", "__WiFiManagerWillAssociateCallback", v23, v38, sub_1000C993C((uint64_t)a3));
      }
      objc_autoreleasePoolPop(v36);
      if (ValueAtIndex)
      {
        v39 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PrivateMacDefaultToOFF"));
        if (v39)
        {
          v40 = v39;
          v41 = (CFBooleanRef)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PrivateMacControlledDevice"));
          sub_10002C478((uint64_t)a3, CFSTR("PrivateMacDefaultToOFF"), v40);
          if (v41 && v41 == kCFBooleanTrue)
            sub_10002C478((uint64_t)a3, CFSTR("PrivateMacControlledDevice"), v41);
          v42 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : kWiFiPrivateMacProfileDefaultFeatureToDisable in account profile. Copied over to network <%@>. Flag : <%@>", "__WiFiManagerWillAssociateCallback", v23, v40);
          objc_autoreleasePoolPop(v42);
          if (!sub_1000A7EE0(a6, a3, 8))
          {
            v43 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Unable to add new network (%@) to Private Mac network List", v23);
            objc_autoreleasePoolPop(v43);
          }
        }
      }
    }
  }
LABEL_69:
  Current = CFAbsoluteTimeGetCurrent();
  v45 = CFDateCreate(kCFAllocatorDefault, Current);
  v46 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  v47 = _os_feature_enabled_impl("WiFiManager", "PrivateMacRotation");
  v48 = (const __CFString *)sub_10002B088(a3);
  sub_1000CEBA4((uint64_t)a3);
  v49 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Retrieving private mac cache version of the network <%@>", "__WiFiManagerUpdatePrivateMac", v48);
  v90 = v48;
  objc_autoreleasePoolPop(v49);
  v50 = sub_1000AAF20(a6, (const __CFDictionary **)a3);
  v89 = v45;
  if (sub_100007828((uint64_t)a3) || sub_100007828((uint64_t)v50))
  {
    if ((_os_feature_enabled_impl("WiFiManager", "PrivateMacAirPlayNetwork") & 1) != 0)
      v51 = 1;
    else
      v51 = -[NSUserDefaults BOOLForKey:](v46, "BOOLForKey:", CFSTR("PrivateMACAirplayNetworkEnabled"));
  }
  else
  {
    v51 = 0;
  }
  if (sub_1000CEDAC((uint64_t)a3) || sub_1000CEDAC((uint64_t)v50))
  {
    sub_10002BE64((uint64_t)v50, CFSTR("NoAssociationWithNewMac"));
    v52 = 1;
  }
  else
  {
    v52 = 0;
  }
  if (v50 && (v53 = sub_1000C312C(), v53 == CFGetTypeID(v50)))
  {
    v54 = (const __CFDictionary *)sub_10002BE64((uint64_t)v50, CFSTR("PRIVATE_MAC_ADDRESS"));
    v55 = (CFBooleanRef)sub_10002BE64((uint64_t)v50, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
    v56 = (const __CFBoolean *)sub_10002BE64((uint64_t)v50, CFSTR("ResetCaptiveProbe"));
    v57 = sub_10002BE64((uint64_t)v50, CFSTR("PrivateMacFutureMacAddress"));
    v58 = (const __CFBoolean *)sub_10002BE64((uint64_t)v50, CFSTR("FailureThresholdMet"));
    if (!v54)
    {
      v88 = v56;
      Mutable = 0;
      v66 = 1;
      v86 = 1;
      v87 = 0;
      goto LABEL_121;
    }
    v59 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v54);
    Mutable = v59;
    if (v57)
    {
      CFDictionarySetValue(v59, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v57);
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), v57);
      v87 = 0;
    }
    else
    {
      v67 = CFDictionaryGetValue(v54, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
      if (v67)
        CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), v67);
      v87 = 0;
      v57 = 0;
    }
    v86 = 1;
  }
  else
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v47)
    {
      if (sub_1000CEC50((CFDictionaryRef *)a3))
        v61 = 2;
      else
        v61 = 3;
    }
    else
    {
      v61 = 3;
    }
    v62 = sub_100064FE0(v61);
    CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v62);
    if (v62)
      CFRelease(v62);
    v63 = *(const __CFData **)(a6 + 416);
    if (v51)
    {
      v57 = sub_1000CE7A0(v63, *(const __CFData **)(a6 + 488), v48);
      sub_10002C478((uint64_t)a3, CFSTR("RotationKeyUsed"), 0);
      v64 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Generated private mac address <%@> for airplay network <%@> ", "__WiFiManagerUpdatePrivateMac", v57, v48);
    }
    else if (v52)
    {
      v57 = sub_1000CE7A0(v63, *(const __CFData **)(a6 + 488), v48);
      sub_10002C478((uint64_t)a3, CFSTR("RotationKeyUsed"), 0);
      v64 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Generated private mac address <%@> for accessory network <%@> ", "__WiFiManagerUpdatePrivateMac", v57, v48);
    }
    else
    {
      v57 = sub_1000CE52C(v63, *(const __CFData **)(a6 + 408), *(const __CFData **)(a6 + 488), v48);
      v64 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Generated private mac address <%@> for network <%@> ", "__WiFiManagerUpdatePrivateMac", v57, v48);
    }
    objc_autoreleasePoolPop(v64);
    if (v57)
    {
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v57);
      CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), v57);
      sub_10002C478((uint64_t)a3, CFSTR("MacGenerationTimeStamp"), v89);
      sub_10002C478((uint64_t)a3, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
      sub_10002C478((uint64_t)a3, CFSTR("RotationKeyUsed"), *(const void **)(a6 + 408));
      CFRelease(v57);
      if (!sub_1000A7EE0(a6, a3, 3))
      {
        v65 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Updated join network <%@> with private mac but unable to set it to cache", v48);
        objc_autoreleasePoolPop(v65);
      }
      v86 = 0;
      v57 = 0;
    }
    else
    {
      v86 = 0;
    }
    v58 = 0;
    v87 = 1;
    v55 = kCFBooleanFalse;
    v56 = kCFBooleanFalse;
  }
  v88 = v56;
  if (Mutable)
  {
    sub_10002C478((uint64_t)a3, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable);
    if (!sub_100096B7C(a6, a3, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable))
    {
      v68 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Updated existing private cache network <%@> but unable to set it to cache", v90);
      objc_autoreleasePoolPop(v68);
    }
    v66 = 0;
  }
  else
  {
    v66 = 1;
  }
LABEL_121:
  if (sub_10000BE8C((uint64_t)a3))
  {
    sub_10002C478((uint64_t)a3, CFSTR("FeatureOffBySystemForCarplay"), kCFBooleanTrue);
    sub_100096B7C(a6, a3, CFSTR("FeatureOffBySystemForCarplay"), kCFBooleanTrue);
  }
  if ((v66 & 1) != 0)
    goto LABEL_163;
  if (!*(_BYTE *)(a6 + 376))
  {
    v69 = sub_100064FE0(1);
    CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v69);
    CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a6 + 488));
    CFDictionarySetValue(Mutable, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), *(const void **)(a6 + 488));
    sub_10002C478((uint64_t)a3, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable);
    v70 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Using HW Mac for Network <%@>. Feature is disabled", v90);
    objc_autoreleasePoolPop(v70);
    if (v69)
      CFRelease(v69);
    if (!sub_100096B7C(a6, a3, CFSTR("PRIVATE_MAC_ADDRESS"), Mutable))
    {
      v71 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Updated existing private cache network <%@> but unable to set it to cache", v90);
      objc_autoreleasePoolPop(v71);
    }
  }
  if (v55 && v55 == kCFBooleanTrue)
  {
    if (v57)
    {
      TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v57))
      {
        v73 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Attempting association for migrated network <%@> re-trying random MAC <%@>", "__WiFiManagerUpdatePrivateMac", v90, v57);
        objc_autoreleasePoolPop(v73);
      }
    }
    sub_10002C478((uint64_t)a3, CFSTR("MacAddressRandomisationTagMigratedNetwork"), v55);
  }
  if (v58 && v58 == kCFBooleanTrue)
  {
    v74 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Failure threshold met for network <%@> Resetting counters for new association", "__WiFiManagerUpdatePrivateMac", v90);
    objc_autoreleasePoolPop(v74);
    if (!sub_100096B7C(a6, a3, CFSTR("FailureThresholdMet"), kCFBooleanFalse))
    {
      v75 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Updated kWiFiPrivateMacFailureThresholdMet keys for network <%@> but unable to set it to cache", v90);
      objc_autoreleasePoolPop(v75);
    }
  }
  if (v88)
  {
    v76 = v87;
    if (v88 == kCFBooleanTrue)
      v76 = 1;
    if ((v76 & 1) == 0)
      goto LABEL_163;
    goto LABEL_155;
  }
  if ((v86 & 1) == 0)
  {
LABEL_155:
    idx[0] = a6;
    idx[1] = 0xAAAAAAAA00000071;
    idx[2] = (CFIndex)a3;
    idx[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a6 + 104), (CFSetApplierFunction)sub_10002E0D4, idx);
    v77 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : DHCP released for network <%@>", v90);
    objc_autoreleasePoolPop(v77);
    v78 = sub_100096B7C(a6, a3, CFSTR("ResetCaptiveProbe"), kCFBooleanFalse);
    v79 = objc_autoreleasePoolPush();
    if (v78)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Cleared the property kWiFiPrivateMacResetCaptiveProbe in private mac network record for <%@>", "__WiFiManagerUpdatePrivateMac", sub_10002B088(a3));
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Updated kWiFiPrivateMacResetCaptiveProbe keys for network <%@> but unable to set it to cache", v90, v85);
    }
    objc_autoreleasePoolPop(v79);
  }
LABEL_163:
  if (Mutable)
    CFRelease(Mutable);
  if (v89)
    CFRelease(v89);
  v80 = *(const void **)(a6 + 448);
  if (v80)
  {
    CFRelease(v80);
    *(_QWORD *)(a6 + 448) = 0;
  }
  v81 = (const __CFString *)sub_10002B088(a3);
  *(_QWORD *)(a6 + 448) = CFStringCreateCopy(kCFAllocatorDefault, v81);
  if (*(_BYTE *)(a6 + 1208))
  {
    if (!*(_BYTE *)(a6 + 2176) || (v82 = *(unsigned __int8 *)(a6 + 2177), v82 <= 0xE) && ((1 << v82) & 0x5440) != 0)
    {
      v83 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: MIS state is enabled. Force-disabling before association.", "__WiFiManagerWillAssociateCallback");
      objc_autoreleasePoolPop(v83);
      sub_1000921A4(a6, 0, 0);
    }
  }
}

void sub_1000B2A2C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v6;
  _QWORD v7[6];

  v6 = a3;
  if (*(_QWORD *)(a5 + 1776))
  {
    *(_BYTE *)(a5 + 1808) = 0;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1000B747C;
    v7[3] = &unk_1002306C8;
    v7[4] = v6;
    v7[5] = a5;
    dispatch_async((dispatch_queue_t)qword_10026DD40, v7);
  }
}

void sub_1000B2AA8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v10;

  if (a3 && a6)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@, requestedInformation %@ err %d", "__WiFiManagerDidAssociateCallback", sub_10002B088(a3), a4, a5);
    objc_autoreleasePoolPop(v10);
    sub_1000CC95C((uint64_t)a3);
    sub_100099EA4(a6, a3, 1u);
    sub_1000898A0(a6, 1, 2, 0);
    sub_1000300E0(a6, *(unsigned __int8 *)(a6 + 24), 1);
  }
}

void sub_1000B2B8C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v9;
  id v10;
  const void *v11;
  unsigned int v12;
  void *v13;
  void *v14;
  const char *v15;
  const void *v16;
  const __CFBoolean *v17;
  void *v18;
  _BOOL4 v19;
  const __CFNumber *v20;
  void *v21;
  void *v22;
  int valuePtr;
  _QWORD context[2];

  valuePtr = 0;
  sub_1000B6FD8(a6, a3, a2);
  if (a3
    && sub_10002BE64((uint64_t)a3, CFSTR("WPS_PROB_RESP_IE"))
    && objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"))
  {
    v9 = objc_autoreleasePoolPush();
    v10 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient");
    v11 = sub_10002BE64((uint64_t)a3, CFSTR("BSSID"));
    v12 = objc_msgSend(v10, "parsedBeaconInfoIsStored:ssid:", v11, sub_10002B088(a3));
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (v12)
        v15 = "does not need";
      else
        v15 = "needs";
      v16 = sub_10002B088(a3);
      objc_msgSend(v14, "WFLog:message:", 3, "%s: ParsedBeaconInfo %s submission for ssid:%@ bssid:%@ ", "__WiFiManagerBSSIDChangedCallback", v15, v16, sub_10002BE64((uint64_t)a3, CFSTR("BSSID")));
    }
    objc_autoreleasePoolPop(v13);
    if ((v12 & 1) == 0)
      sub_10005E4D8(a6, a3, 0);
    objc_autoreleasePoolPop(v9);
  }
  sub_100099EA4(a6, a3, 1u);
  v17 = (const __CFBoolean *)sub_10002BE64((uint64_t)a3, CFSTR("BSSID"));
  if (!sub_100096B7C(a6, a3, CFSTR("BSSID"), v17))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BSSID changed. Updating private mac networks for network : %@", "__WiFiManagerBSSIDChangedCallback", sub_10002B088(a3));
    objc_autoreleasePoolPop(v18);
  }
  sub_1000B64BC(a6, a3);
  context[0] = a3;
  context[1] = a1;
  CFSetApplyFunction(*(CFSetRef *)(a6 + 136), (CFSetApplierFunction)sub_1000B74B0, context);
  if (sub_10000BE8C((uint64_t)a3))
  {
    v19 = sub_1000CA53C((uint64_t)a3);
    sub_1000B6718(a6, a1, v19);
  }
  v20 = (const __CFNumber *)sub_1000316E0((uint64_t)a3);
  if (v20)
  {
    CFNumberGetValue(v20, kCFNumberIntType, &valuePtr);
    if (valuePtr >= 36)
    {
      if (CFAbsoluteTimeGetCurrent() - *(double *)(a6 + 2256) <= 600.0)
      {
        if (valuePtr >= 36)
        {
          v22 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Roamed to 5GHz band, ignoring frequent channel update to Gizmo %f", "__WiFiManagerBSSIDChangedCallback", CFAbsoluteTimeGetCurrent() - *(double *)(a6 + 2256));
          objc_autoreleasePoolPop(v22);
        }
      }
      else
      {
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Roamed to 5GHz band, send channel to Watch: %@", "__WiFiManagerBSSIDChangedCallback", sub_10002B088(a3));
        objc_autoreleasePoolPop(v21);
        sub_100176D68(*(void **)(a6 + 1432));
        *(CFAbsoluteTime *)(a6 + 2256) = CFAbsoluteTimeGetCurrent();
      }
    }
  }
}

void sub_1000B2EBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  _BYTE *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  NSObject *v11;
  dispatch_time_t v12;
  _QWORD context[3];

  if (a5)
  {
    if (!*(_BYTE *)(a6 + 2360))
      return;
    v7 = (_BYTE *)(a6 + 2360);
    goto LABEL_4;
  }
  v8 = *(_QWORD *)(a6 + 2264);
  if (v8)
  {
    context[0] = a6;
    context[1] = a1;
    context[2] = v8;
    CFSetApplyFunction(*(CFSetRef *)(a6 + 136), (CFSetApplierFunction)sub_1000B6EA8, context);
    kdebug_trace(731381836, 0, 0, 0, 0);
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Dispatching client link up event.", "__WiFiManagerJoinDoneCallback");
    objc_autoreleasePoolPop(v9);
  }
  if (*(_BYTE *)(a6 + 2360))
  {
    v7 = (_BYTE *)(a6 + 2360);
    if (*(_BYTE *)(a6 + 2345))
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Debounce succeeded.", "__WiFiManagerJoinDoneCallback");
      objc_autoreleasePoolPop(v10);
      *(CFAbsoluteTime *)(a6 + 2328) = CFAbsoluteTimeGetCurrent();
      if (*(_BYTE *)(a6 + 2346))
      {
        v11 = *(NSObject **)(a6 + 2352);
        v12 = dispatch_time(0, 3000000000);
        dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
      goto LABEL_5;
    }
LABEL_4:
    *(_WORD *)(a6 + 2345) = 0;
LABEL_5:
    if (!*(_BYTE *)(a6 + 2345) || !*(_BYTE *)(a6 + 2346))
      sub_1000B74BC(a6);
    *v7 = 0;
  }
}

const void *sub_1000B301C(const void *a1, int a2, uint64_t a3, uint64_t a4, CFDictionaryRef *a5, const __CFDictionary *a6, uint64_t a7)
{
  uint64_t v9;
  const void *v10;
  void *v11;
  const void *v12;
  void *v14;
  _QWORD context[2];

  byte_10026D6A8 = 0;
  if (*(_DWORD *)(a7 + 788) == 2)
    goto LABEL_5;
  if (!*(_QWORD *)(a7 + 848))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type %@(%d), display is off", "__WiFiManagerRequestCallback", sub_100064E5C(a3), a3);
    goto LABEL_22;
  }
  if (a3 > 4)
    goto LABEL_7;
  if ((*(_BYTE *)(a7 + 832) & 0x11) == 0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type %@(%d), no FG wifi app", "__WiFiManagerRequestCallback", sub_100064E5C(a3), a3);
LABEL_22:
    objc_autoreleasePoolPop(v14);
LABEL_13:
    v10 = 0;
    goto LABEL_15;
  }
LABEL_5:
  if (!(_DWORD)a3 && *(_QWORD *)(a7 + 880))
    goto LABEL_13;
LABEL_7:
  v9 = sub_1000D7154((uint64_t)kCFAllocatorDefault, a3, a4, a1, a2, a5, a6);
  v10 = (const void *)v9;
  if (v9)
  {
    sub_1000D7498(v9, (uint64_t)sub_1000B7620, a7);
    if (sub_1000D7214((uint64_t)v10))
    {
      context[0] = 0xAAAAAAAAFFFFF0C1;
      context[1] = v10;
      CFSetApplyFunction(*(CFSetRef *)(a7 + 136), (CFSetApplierFunction)sub_1000B78D0, context);
      if (LODWORD(context[0]) == -3903)
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Notification %d not supported", sub_1000D7204((uint64_t)v10));
        objc_autoreleasePoolPop(v11);
        CFRelease(v10);
        goto LABEL_13;
      }
      byte_10026D6A8 = 1;
    }
  }
LABEL_15:
  v12 = *(const void **)(a7 + 184);
  if (v12)
    CFRelease(v12);
  *(_QWORD *)(a7 + 184) = v10;
  return v10;
}

const void *sub_1000B3204(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, const __CFDictionary *a6, uint64_t a7)
{
  uint64_t v9;
  const void *v10;
  void *v11;
  const void *v12;
  void *v14;
  _QWORD context[2];

  byte_10026D6A8 = 0;
  if (*(_DWORD *)(a7 + 788) == 2)
    goto LABEL_5;
  if (!*(_QWORD *)(a7 + 848))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type %@(%d), display is off", "__WiFiManagerColocatedRequestCallback", sub_100064E5C(a3), a3);
    goto LABEL_22;
  }
  if (a3 > 4)
    goto LABEL_7;
  if ((*(_BYTE *)(a7 + 832) & 0x11) == 0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type %@(%d), no FG wifi app", "__WiFiManagerColocatedRequestCallback", sub_100064E5C(a3), a3);
LABEL_22:
    objc_autoreleasePoolPop(v14);
LABEL_13:
    v10 = 0;
    goto LABEL_15;
  }
LABEL_5:
  if (!(_DWORD)a3 && *(_QWORD *)(a7 + 880))
    goto LABEL_13;
LABEL_7:
  v9 = sub_1000D652C((uint64_t)kCFAllocatorDefault, a1, a2, a5, a6);
  v10 = (const void *)v9;
  if (v9)
  {
    sub_1000D7498(v9, (uint64_t)sub_1000B7620, a7);
    if (sub_1000D7214((uint64_t)v10))
    {
      context[0] = 0xAAAAAAAAFFFFF0C1;
      context[1] = v10;
      CFSetApplyFunction(*(CFSetRef *)(a7 + 136), (CFSetApplierFunction)sub_1000B78D0, context);
      if (LODWORD(context[0]) == -3903)
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Notification %d not supported", sub_1000D7204((uint64_t)v10));
        objc_autoreleasePoolPop(v11);
        CFRelease(v10);
        goto LABEL_13;
      }
      byte_10026D6A8 = 1;
    }
  }
LABEL_15:
  v12 = *(const void **)(a7 + 184);
  if (v12)
    CFRelease(v12);
  *(_QWORD *)(a7 + 184) = v10;
  return v10;
}

void sub_1000B33E0(void *context, uint64_t a2, uint64_t a3)
{
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B78FC, context);
}

void sub_1000B33F8(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  _QWORD v4[2];

  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  v4[1] = a1;
  LOBYTE(v4[0]) = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7900, v4);
}

void sub_1000B3430(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7910, context);
    }
  }
}

void sub_1000B346C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7934, context);
    }
  }
}

void sub_1000B34A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7958, context);
    }
  }
}

void sub_1000B34E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;

  if (a3 && *(_BYTE *)(a3 + 2360))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Debounce failed", "__WiFiManagerLinkDownDebounceFailedCallback");
    objc_autoreleasePoolPop(v4);
    *(_WORD *)(a3 + 2345) = 0;
    sub_1000B74BC(a3);
    *(_BYTE *)(a3 + 2360) = 0;
  }
}

void sub_1000B3564(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD context[2];
  int v5;
  int v6;

  context[1] = a1;
  v6 = -1431655766;
  context[0] = a3;
  v5 = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B797C, context);
}

void sub_1000B35A0(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  _QWORD context[2];
  unint64_t v5;

  *(_BYTE *)(a3 + 913) = a4;
  context[1] = a1;
  v5 = 0xAAAAAAAAAAAAAAAALL;
  context[0] = a3;
  LOBYTE(v5) = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B9270, context);
}

void sub_1000B35E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _QWORD context[2];
  int v5;
  int v6;

  v3 = *(_DWORD *)(a3 + 916) + 1;
  *(_DWORD *)(a3 + 916) = v3;
  context[1] = a1;
  v6 = -1431655766;
  context[0] = a3;
  v5 = v3;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7A00, context);
}

void sub_1000B3628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD context[3];

  *(_DWORD *)(a3 + 916) = 0;
  context[1] = a1;
  context[2] = 0xAAAAAAAA00000000;
  context[0] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7A00, context);
}

void sub_1000B3668(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;

  if (!a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "__WiFiManagerRecommendedNetworkAssociationCallback");
    goto LABEL_10;
  }
  v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is null", "__WiFiManagerRecommendedNetworkAssociationCallback");
LABEL_10:
    objc_autoreleasePoolPop(v5);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: association to recommened network %@", "__WiFiManagerRecommendedNetworkAssociationCallback", sub_10002B088(a2));
  objc_autoreleasePoolPop(v5);
  sub_100094420(a3, a2, 14);
}

void sub_1000B3764(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[2];

  v3[0] = a1;
  v3[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a2 + 136), (CFSetApplierFunction)sub_1000B7AA0, v3);
}

void sub_1000B3794(int a1, void *a2, CFStringRef theString1, const __CFBoolean *a4, uint64_t a5)
{
  void *v8;
  void *v9;

  if (a2 || !theString1)
  {
    if (theString1 && a2 && a4)
      sub_100096B7C(a5, a2, theString1, a4);
  }
  else if (CFStringCompare(theString1, CFSTR("ForcedDisassoc"), 1uLL))
  {
    if (CFStringCompare(theString1, CFSTR("PrivateMacCheckForMDMOrSupervised"), 1uLL) == kCFCompareEqualTo
      && *(_BYTE *)(a5 + 529)
      && sub_1000B71C0(a5))
    {
      *(_BYTE *)(a5 + 529) = 0;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Profiles Networks successfully checked for MDM or supervised.", "__WiFiManagerPrivateMacUpdateNetworkCallback");
      objc_autoreleasePoolPop(v8);
    }
  }
  else if (a4 && kCFBooleanTrue == a4 && *(_BYTE *)(a5 + 362))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : No associated network. Update Force Disassociate key", "__WiFiManagerPrivateMacUpdateNetworkCallback");
    objc_autoreleasePoolPop(v9);
    if (sub_100087488((_QWORD *)a5, CFSTR("PrivateMacForcedDisassocPending"), 0, 0))
    {
      *(_BYTE *)(a5 + 362) = 0;
      sub_1000875B0(a5);
      sub_100087FE4(a5);
      sub_1000A485C(a5, 1, 0);
      sub_10008A2B8(a5, "__WiFiManagerPrivateMacUpdateNetworkCallback", 29855);
    }
  }
}

void sub_1000B3958(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  __CFString *v6;
  __CFString *v7;
  const __CFString *v8;
  NSString *v9;
  _QWORD block[6];

  v3 = sub_100005AF0(a1);
  if (*(_DWORD *)(a2 + 2016) != (_DWORD)v3)
  {
    v4 = v3;
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiMC : band support changed. Before : %d, after : %d", "__WiFiManagerCountryCodeChangedCallback", *(unsigned int *)(a2 + 2016), v4);
    objc_autoreleasePoolPop(v5);
    *(_DWORD *)(a2 + 2016) = v4;
    sub_10009322C((_QWORD *)a2, CFSTR("WiFiCountryBandSupportKey"), v4, 1);
  }
  v6 = (__CFString *)objc_msgSend(objc_alloc((Class)NSMutableString), "initWithString:", &stru_100238178);
  if (sub_1000071A0((unsigned int *)a2, (uint64_t)v6))
  {
    if (!-[__CFString caseInsensitiveCompare:](v6, "caseInsensitiveCompare:", &stru_100238178)
      || !-[__CFString caseInsensitiveCompare:](v6, "caseInsensitiveCompare:", CFSTR("X0"))
      || !-[__CFString caseInsensitiveCompare:](v6, "caseInsensitiveCompare:", CFSTR("X2"))
      || !-[__CFString caseInsensitiveCompare:](v6, "caseInsensitiveCompare:", CFSTR("X3"))
      || !-[__CFString caseInsensitiveCompare:](v6, "caseInsensitiveCompare:", CFSTR("XZ")))
    {

      v6 = (__CFString *)objc_msgSend(objc_alloc((Class)NSMutableString), "initWithString:", &stru_100238178);
    }
    if ((-[__CFString isEqual:](v6, "isEqual:", *(_QWORD *)(a2 + 1768)) & 1) == 0)
    {
      v7 = *(__CFString **)(a2 + 1768);
      if (-[__CFString isEqual:](v7, "isEqual:", &stru_100238178))
        v7 = CFSTR("unknown");
      if (-[__CFString isEqual:](v6, "isEqual:", &stru_100238178))
        v8 = CFSTR("unknown");
      else
        v8 = v6;
      v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("WiFi country code changed from %@ to %@"), v7, v8);

      *(_QWORD *)(a2 + 1768) = -[__CFString copy](v6, "copy");
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000B7ABC;
      block[3] = &unk_1002306C8;
      block[4] = v9;
      block[5] = a2;
      dispatch_async((dispatch_queue_t)qword_10026DD40, block);
    }
  }

}

void sub_1000B3B74(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  void (__cdecl *v4)(const void *, void *);
  _QWORD v5[2];

  if (a3)
  {
    v5[0] = a1;
    v5[1] = a2;
    if (a4)
      v4 = (void (__cdecl *)(const void *, void *))sub_1000B7AEC;
    else
      v4 = (void (__cdecl *)(const void *, void *))sub_1000B7AF8;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), v4, v5);
  }
}

void sub_1000B3BC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  context[0] = a1;
  context[1] = a2;
  context[2] = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7B04, context);
}

void sub_1000B3BF4(const void *a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  const void *Value;
  const __CFString *v9;
  const void *v10;
  const __CFString *v11;
  void *v12;
  void *v13;
  const __CFString *v14;
  const __CFString *v15;
  void *v16;
  id v17;
  char v18;
  int v19;
  void *v20;
  const __CFString *v21;
  const __CFString *v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFNumber *v26;
  void *v27;
  void *v28;
  const __CFArray *v29;
  CFIndex Count;
  CFIndex v31;
  CFIndex v32;
  const void *ValueAtIndex;
  const __CFString *v34;
  BOOL v35;
  void *v36;
  const __CFDictionary *v37;
  const __CFDictionary *v38;
  CFTypeID TypeID;
  const __CFNumber *v40;
  const __CFData *v41;
  const __CFData *v43;
  const UInt8 *BytePtr;
  const UInt8 *v45;
  void *v47;
  const __CFData *theData;
  _QWORD block[5];
  uint64_t context;
  CFDictionaryRef v51;
  BOOL *v52;
  uint64_t v53;
  BOOL v54;

  Value = CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE"));
  v9 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_KEY_SUBREASON_STRING"));
  v10 = *(const void **)(a4 + 792);
  if (v10)
  {
    v11 = v9;
    if (CFEqual(Value, v10))
    {
      if (!v11 || CFStringCompare(CFSTR("Driver Booted"), v11, 1uLL))
      {
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: driver availability: %@ hasn't changed, bail out\n", "__WiFiManagerDispatchDeviceAvailable", Value);
        objc_autoreleasePoolPop(v12);
        return;
      }
    }
  }
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: driver availability: %@, previously: %@\n", "__WiFiManagerDispatchDeviceAvailable", Value, *(_QWORD *)(a4 + 792));
  objc_autoreleasePoolPop(v13);
  *(_QWORD *)(a4 + 792) = Value;
  if (!CFEqual(Value, kCFBooleanTrue))
  {
    v21 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
    if (CFStringCompare(CFSTR("Watchdog"), v21, 1uLL))
    {
      v22 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
      if (CFStringCompare(CFSTR("DextCrashed"), v22, 1uLL) == kCFCompareEqualTo && *(_BYTE *)(a4 + 2200) == 1)
      {
        v23 = sub_100103560((uint64_t)a1);
        if (v23)
        {
          v24 = v23;
          if (sub_10000BE8C(v23))
            sub_1000B69B0(a4, (uint64_t)a1, v24);
        }
      }
    }
    else
    {
      if (theDict)
      {
        v25 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("SSID_STR"));
        v26 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
        theData = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
      }
      else
      {
        v25 = 0;
        v26 = 0;
        theData = 0;
      }
      sub_1000875B0(a4);
      v29 = *(const __CFArray **)(a4 + 352);
      if (v29)
      {
        Count = CFArrayGetCount(v29);
        if (Count >= 1)
        {
          v31 = Count;
          v32 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 352), v32);
            v34 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("SSID_STR"));
            v35 = !v34 || v25 == 0;
            if (!v35 && CFStringCompare(v34, v25, 0) == kCFCompareEqualTo)
              break;
            if (v31 == ++v32)
              goto LABEL_49;
          }
          v37 = (const __CFDictionary *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PRIVATE_MAC_ADDRESS"));
          if (v37)
          {
            v38 = v37;
            TypeID = CFDictionaryGetTypeID();
            if (TypeID == CFGetTypeID(v38))
            {
              v40 = (const __CFNumber *)CFDictionaryGetValue(v38, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
              v41 = (const __CFData *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("PrivateMacFutureMacAddress"));
              if (v40 && v26 != 0)
              {
                v43 = v41;
                if (CFNumberCompare(v40, v26, 0) == kCFCompareEqualTo && v43 && theData)
                {
                  BytePtr = CFDataGetBytePtr(v43);
                  v45 = CFDataGetBytePtr(theData);
                  if (*(_DWORD *)BytePtr != *(_DWORD *)v45
                    || *((unsigned __int16 *)BytePtr + 2) != *((unsigned __int16 *)v45 + 2))
                  {
                    v47 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : WatchDog occurred. Preventing mac Address rotation. Will revert to Current Value. Current : <%@> Rotated : <%@>\n", "__WiFiManagerDispatchDeviceAvailable", theData, theData);
                    objc_autoreleasePoolPop(v47);
                    sub_10002C478((uint64_t)ValueAtIndex, CFSTR("PrivateMacFutureMacAddress"), 0);
                    sub_10002C478((uint64_t)ValueAtIndex, CFSTR("ResetCaptiveProbe"), kCFBooleanFalse);
                    sub_100087FE4(a4);
                    sub_1000A485C(a4, 1, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_49;
  }
  if (sub_10008D5F4(a4))
    sub_10008BB68(a4);
  v14 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
  if (CFStringCompare(CFSTR("Initializing"), v14, 1uLL) == kCFCompareEqualTo)
  {
    v54 = sub_10003036C((_QWORD *)a4, CFSTR("WiFiMacRandomizationInternalUI"), 1);
    context = a4;
    v51 = (CFDictionaryRef)0xAAAAAAAA0000006FLL;
    v52 = &v54;
    v53 = 1;
    CFSetApplyFunction(*(CFSetRef *)(a4 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    sub_1000875B0(a4);
    sub_100087FE4(a4);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B7C48;
  block[3] = &unk_10022EA38;
  block[4] = a4;
  dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  sub_10000E880((void *)a4, *(void **)(a4 + 1728), 10, a1);
  v15 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
  if (CFStringCompare(CFSTR("DextCrashed"), v15, 1uLL) == kCFCompareEqualTo)
  {
    v16 = *(void **)(a4 + 192);
    if (v16)
    {
      v17 = objc_msgSend(v16, "getLocaleCountryCode");
      v18 = objc_msgSend(*(id *)(a4 + 192), "getLocaleSource");
      if (*(_BYTE *)(a4 + 2012) && v17)
      {
        v19 = sub_10010883C((uint64_t)a1, v17, v18);
        v20 = objc_autoreleasePoolPush();
        if (v19)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Successfully Reapplied country : [%@] after DextCrashed", "__WiFiManagerDispatchDeviceAvailable", v17);
          objc_autoreleasePoolPop(v20);
          goto LABEL_49;
        }
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Could not apply : [%@] after DextCrashed. Determining locale...", "__WiFiManagerDispatchDeviceAvailable", v17);
        v28 = v20;
      }
      else
      {
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Dext Crashed. Locale not available. Determining fresh locale...", "__WiFiManagerDispatchDeviceAvailable");
        v28 = v27;
      }
      objc_autoreleasePoolPop(v28);
      objc_msgSend(*(id *)(a4 + 192), "determineAndSetLocale:", 0);
    }
  }
LABEL_49:
  context = (uint64_t)a1;
  v51 = theDict;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7C54, &context);
  v36 = *(void **)(a4 + 1792);
  if (v36)
    objc_msgSend(v36, "handleEvent:withData:interface:", 55, theDict, a2);
}

void sub_1000B4214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7C70, v4);
}

void sub_1000B4244(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[2];

  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7C8C, v4);
}

void sub_1000B4274(uint64_t a1, uint64_t a2, const __CFDictionary **a3, unsigned int a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8)
{
  void *v15;
  const __CFArray *v16;
  const __CFDictionary **v17;
  const __CFDictionary **v18;
  const __CFDictionary *v19;
  uint64_t v20;
  const __CFBoolean *v21;
  const __CFData *Value;
  int v23;
  void *v24;
  void *v25;
  unsigned int v26;
  unint64_t v27;

  if (a8)
  {
    kdebug_trace(731381776, 0, 0, 0, 0);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: <%@> [%@] isMainIf? %d, isIPV4Routable <%d>, is IPV6Routable <%d>", "__WiFiManagerIPv4Callback", a2, a3, a4, a5, a6);
    objc_autoreleasePoolPop(v15);
    if (a4)
    {
      if (a6 | a5)
      {
        if (!a3)
        {
          v18 = 0;
LABEL_33:
          v25 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending link up status to Gizmo", "__WiFiManagerIPv4Callback");
          objc_autoreleasePoolPop(v25);
          sub_100176C34(*(void **)(a8 + 1432), v18);
          return;
        }
        v16 = (const __CFArray *)sub_10008674C(a8);
        v17 = (const __CFDictionary **)sub_1000A7E60(v16, (uint64_t)a3);
        if (v17)
          v18 = v17;
        else
          v18 = a3;
        v19 = (const __CFDictionary *)sub_1000AAF20(a8, a3);
        v20 = (uint64_t)v19;
        if (v19)
        {
          v21 = (const __CFBoolean *)sub_10002BE64((uint64_t)v19, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
          v19 = (const __CFDictionary *)sub_10002BE64(v20, CFSTR("PRIVATE_MAC_ADDRESS"));
          if (v19)
          {
            Value = (const __CFData *)CFDictionaryGetValue(v19, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
            v19 = sub_10002B75C(Value);
            v23 = (int)v19;
            if (!a5)
              goto LABEL_29;
            goto LABEL_17;
          }
        }
        else
        {
          v21 = 0;
        }
        v23 = 0;
        if (!a5)
        {
LABEL_29:
          if (v21 && v21 == kCFBooleanTrue && v23)
          {
            sub_1000AC5A4((uint64_t)v19, a3, a8);
            sub_10008A2B8(a8, "__WiFiManagerIPv4Callback", 9335);
            v27 = 0xAAAAAAAAAAAAAAAALL;
            v26 = 3;
            sub_100061728(v20, (uint64_t)&v26);
            sub_100061494(&v26);
          }
          goto LABEL_33;
        }
LABEL_17:
        if (a7 || (v19 = (const __CFDictionary *)sub_10000BE8C((uint64_t)v18), (_DWORD)v19))
        {
          if (v20
            && (!v21 || v21 != kCFBooleanTrue || !v23 || sub_1000C475C((uint64_t)v18) || sub_1000C47AC((uint64_t)v18))
            && !sub_1000A7EE0(a8, v18, 6))
          {
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Unable to add assoc done network (%@) to Private Mac network List", sub_10002B088(a3));
            objc_autoreleasePoolPop(v24);
          }
          goto LABEL_33;
        }
        goto LABEL_29;
      }
    }
  }
}

void sub_1000B4514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  context[0] = a1;
  context[1] = a2;
  context[2] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7CA8, context);
}

void sub_1000B4548(int a1, int a2, _QWORD *a3, CFDictionaryRef theDict)
{
  sub_1000A01E4(a3, theDict);
}

uint64_t sub_1000B4554(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1000CC95C((uint64_t)a2);
  return sub_100099EA4(a3, a2, 1u);
}

uint64_t sub_1000B4588(uint64_t result, _DWORD *a2, _BYTE *a3, uint64_t a4)
{
  if (result)
  {
    if (a4)
    {
      *a2 = *(_DWORD *)(a4 + 984);
      *a3 = *(_BYTE *)(a4 + 314);
    }
  }
  return result;
}

void sub_1000B45A4(void *a1, uint64_t a2, const void *a3, uint64_t a4)
{
  int v7;
  void *v8;
  void *v9;
  void *v10;

  if (!a4)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiManagerSoftErrorManagerCallback");
    goto LABEL_18;
  }
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "__WiFiManagerSoftErrorManagerCallback");
    goto LABEL_18;
  }
  v7 = a2;
  switch((_DWORD)a2)
  {
    case 0x12:
      v8 = *(void **)(a4 + 1744);
LABEL_9:
      objc_msgSend(v8, "updateHUDWithMessage:", a3);
      return;
    case 0x11:
      v8 = *(void **)(a4 + 1736);
      goto LABEL_9;
    case 0x10:
      objc_msgSend(*(id *)(a4 + 1736), "incrementCount", a2, a3);
      objc_msgSend(*(id *)(a4 + 1736), "submitABCReportWithReason:", 0);
      objc_msgSend(*(id *)(a4 + 1736), "submitMetric");
      sub_10011BC48((uint64_t)a1, -1);
      return;
  }
  v9 = *(void **)(a4 + 1728);
  if (v9)
  {
    sub_10000E880(a1, v9, v7, a3);
    return;
  }
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManager is NULL!", "__WiFiManagerSoftErrorManagerCallback");
LABEL_18:
  objc_autoreleasePoolPop(v10);
}

void sub_1000B46FC(uint64_t a1, uint64_t a2)
{
  sub_100091914(a2, 0);
}

void sub_1000B4708(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  void *v8;
  void *v9;
  CFDictionaryRef *v10;
  CFDictionaryRef *v11;
  id v12;
  void *v13;
  _BOOL4 v14;
  const __CFString *v15;
  void *v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  WiFiUsageMonitor *v20;
  BOOL v21;
  uint64_t v22;
  void *v23;
  _BOOL8 v24;
  void *v25;
  void *v26;
  id v27;
  WiFiUsageMonitor *v28;
  BOOL v29;
  uint64_t v30;
  void *v31;
  void *v32;
  const void *v33;
  _WORD *v34;
  CFNumberRef v35;
  uint64_t v36;
  const __CFArray *v37;
  void *v38;
  int v39;
  void *v40;
  int v41;
  int v42;
  void *v43;
  const char *v44;
  void *v45;
  const __CFString *v46;
  const void *ValueAtIndex;
  void *v48;
  _WORD *v49;
  const void *v50;
  const void *v51;
  void *v52;
  void *v53;
  void *v54;
  const __CFNumber *v55;
  char v56;
  void *v57;
  void *v58;
  void *v59;
  uint64_t v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  id v70;
  const void *v71;
  const void *v72;
  _QWORD *v73;
  uint64_t v74;
  void *v75;
  _QWORD context[4];
  unsigned int v77;
  CFNumberRef v78;
  unsigned int v79;
  CFNumberRef number;
  unsigned int valuePtr;
  void *value;
  unsigned __int8 v83;
  uint64_t v84;
  void *v85;
  unsigned int v86;
  void *v87;
  CFIndex v88;
  void *v89;
  void *v90;

  v89 = 0;
  v90 = 0;
  v87 = 0;
  v88 = -1;
  v86 = 0;
  v84 = 0;
  v85 = 0;
  v83 = 0;
  value = 0;
  valuePtr = 0;
  number = 0;
  v79 = 0;
  v78 = 0;
  v77 = 0;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing __WiFiManagerBssSteerCallback for ifName:%@", "__WiFiManagerBssSteerCallback", a2);
  objc_autoreleasePoolPop(v8);
  if (CFDictionaryGetValueIfPresent(a4, CFSTR("P2P_BSS_STEERING_REQUEST_TYPE"), (const void **)&value))
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Steering Request type:%u!", "__WiFiManagerBssSteerCallback", valuePtr);
    objc_autoreleasePoolPop(v9);
  }
  if (value)
  {
    v10 = (CFDictionaryRef *)sub_1000169FC(a1, a2);
    v11 = v10;
    if (v10)
      v12 = sub_100027D10((uint64_t)v10);
    else
      v12 = 0;
    v69 = objc_msgSend(objc_msgSend(v12, "channel"), "band");
    if (!CFDictionaryGetValueIfPresent(a4, CFSTR("BSSID"), (const void **)&v89))
      v89 = 0;
    if (!CFDictionaryGetValueIfPresent(a4, CFSTR("SSID_STR"), (const void **)&v90))
      v90 = 0;
    v13 = sub_100026664(v11);
    v14 = 0;
    if (v11 && v90)
    {
      if (sub_10002B088(v11))
      {
        v15 = (const __CFString *)sub_10002B088(v11);
        v14 = CFStringCompare(v15, (CFStringRef)v90, 0) == kCFCompareEqualTo;
      }
      else
      {
        v14 = 0;
      }
    }
    if (CFDictionaryGetValueIfPresent(a4, CFSTR("CHANNEL_FLAGS"), (const void **)&v85))
    {
      if (v85)
        CFNumberGetValue((CFNumberRef)v85, kCFNumberIntType, (char *)&v84 + 4);
    }
    else
    {
      v85 = 0;
    }
    if (CFDictionaryGetValueIfPresent(a4, CFSTR("CHANNEL"), (const void **)&v87))
    {
      if (v87)
      {
        CFNumberGetValue((CFNumberRef)v87, kCFNumberSInt32Type, &v86);
        v16 = v87;
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      v16 = 0;
      v87 = 0;
    }
    v17 = (unint64_t)+[WiFiUsagePrivacyFilter bandFromFlags:OrChannel:](WiFiUsagePrivacyFilter, "bandFromFlags:OrChannel:", v85, v16);
    if (v85)
      v18 = HIDWORD(v84) == 0;
    else
      v18 = 1;
    v19 = v18;
    if (CFDictionaryGetValueIfPresent(a4, CFSTR("BAND_PREFERENCE"), (const void **)&number))
    {
      if (number)
      {
        CFNumberGetValue(number, kCFNumberSInt32Type, &v79);
        if (v79 - 1 >= 3)
          v17 = v17;
        else
          v17 = v79 - 1;
      }
    }
    else
    {
      number = 0;
    }
    if (CFDictionaryGetValueIfPresent(a4, CFSTR("ROAM_FLAGS"), (const void **)&v78))
    {
      if (v78)
        CFNumberGetValue(v78, kCFNumberSInt32Type, &v77);
    }
    else
    {
      v78 = 0;
    }
    if (valuePtr >= 2)
    {
      if (valuePtr == 2)
      {
        v72 = a2;
        v74 = a1;
        v26 = v13;
        v27 = v12;
        v28 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
        if (v86)
          v29 = v87 == 0;
        else
          v29 = 1;
        if (v29)
          v30 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v30 = v86;
        v31 = v90;
        if (v89)
        {
          if (CFStringCompare(CFSTR("ff:ff:ff:ff:ff:ff"), (CFStringRef)v89, 0))
            v32 = v89;
          else
            v32 = 0;
        }
        else
        {
          v32 = 0;
        }
        LOWORD(v67) = objc_msgSend(v26, "isStandalone6G");
        -[WiFiUsageMonitor setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:](v28, "setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:", 2, v30, v17, v31, !v14, v32, v67);
        v57 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Current Network ssid is :%@", "__WiFiManagerBssSteerCallback", sub_10002B088(v11));
        objc_autoreleasePoolPop(v57);
        v12 = v27;
        if (v11)
          sub_1000F7F48(v74, v72, 1017, "__WiFiManagerBssSteerCallback", 9065);
        v33 = 0;
        v34 = 0;
        v35 = 0;
        v13 = v26;
        if (!v12)
          goto LABEL_131;
LABEL_130:
        CFRelease(v12);
LABEL_131:
        if (v11)
          CFRelease(v11);
        if (v33)
          CFRelease(v33);
        if (v34)
          CFRelease(v34);
        if (v35)
          CFRelease(v35);
        if (v13)
          CFRelease(v13);
        return;
      }
      v33 = 0;
      v34 = 0;
      goto LABEL_68;
    }
    v71 = a2;
    v73 = (_QWORD *)a1;
    v75 = v13;
    v70 = v12;
    v20 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
    if (v86)
      v21 = v87 == 0;
    else
      v21 = 1;
    if (v21)
      v22 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v22 = v86;
    v23 = v90;
    v24 = !v14;
    if (v89)
    {
      if (CFStringCompare(CFSTR("ff:ff:ff:ff:ff:ff"), (CFStringRef)v89, 0))
        v25 = v89;
      else
        v25 = 0;
    }
    else
    {
      v25 = 0;
    }
    LOWORD(v67) = objc_msgSend(v75, "isStandalone6G");
    -[WiFiUsageMonitor setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:](v20, "setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:", v19, v22, v17, v23, v24, v25, v67);
    v36 = sub_10008674C(a3);
    if (!v36)
    {
      v62 = objc_autoreleasePoolPush();
      v12 = v70;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Known networks cache is Null!", "__WiFiManagerBssSteerCallback");
      objc_autoreleasePoolPop(v62);
      v33 = 0;
      v34 = 0;
      v35 = 0;
LABEL_110:
      v13 = v75;
      if (!v12)
        goto LABEL_131;
      goto LABEL_130;
    }
    v37 = (const __CFArray *)v36;
    if (v90)
    {
      v34 = sub_1000C323C((const __CFString *)v90);
      v38 = objc_autoreleasePoolPush();
      if (!v34)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed in creating the network!", "__WiFiManagerBssSteerCallback");
        objc_autoreleasePoolPop(v38);
        v33 = 0;
        v34 = 0;
        goto LABEL_109;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Current Network ssid is :%@", "__WiFiManagerBssSteerCallback", sub_10002B088(v11));
      objc_autoreleasePoolPop(v38);
      if (!v11)
      {
        v42 = 0;
        v41 = 0;
LABEL_86:
        v43 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v44 = "doFullJoin";
          if (v42)
            v44 = "doRoam";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d %s !\n", "__WiFiManagerBssSteerCallback", 8945, v44);
        }
        objc_autoreleasePoolPop(v43);
        if ((v42 & 1) != 0)
        {
          if (v41)
          {
            v45 = objc_autoreleasePoolPush();
            v12 = v70;
            v13 = v75;
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Try any Roam candidate", "__WiFiManagerBssSteerCallback");
            objc_autoreleasePoolPop(v45);
            v46 = 0;
            goto LABEL_113;
          }
          v46 = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("BSSID"));
          v12 = v70;
          v13 = v75;
          if (v46)
          {
LABEL_113:
            if (v87)
            {
              if (number)
              {
                v53 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Band Preference :%u!", "__WiFiManagerBssSteerCallback", v79);
                objc_autoreleasePoolPop(v53);
              }
              v54 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d Calling for Roam", "__WiFiManagerBssSteerCallback", 9006);
              objc_autoreleasePoolPop(v54);
              v85 = (void *)CFDictionaryGetValue(a4, CFSTR("CHANNEL_FLAGS"));
              v55 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("CHANNEL"));
              if (!v85)
              {
                v35 = 0;
                if (v55)
LABEL_151:
                  CFNumberGetValue(v55, kCFNumberSInt8Type, &v84);
LABEL_152:
                sub_10010A904(v73, (int)v71, v46, v84, SHIDWORD(v84), v79, v77);
                v59 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Cached steering request bssid (%@), channel (%u), band (%d),  channel flags(0x%x), roam flags(0x%x)", "__WiFiManagerBssSteerCallback", v46, v84, v79, HIDWORD(v84), v77);
                objc_autoreleasePoolPop(v59);
                v12 = v70;
                v13 = v75;
                if (_os_feature_enabled_impl("CoreWiFi", "SSIDTransition") && v69 == 3)
                {
                  if (v83 == 2)
                    v60 = 55;
                  else
                    v60 = 54;
                  sub_100007F68(a3, v60);
                }
                else
                {
                  sub_100117EC0((uint64_t)v73, v46, (unint64_t)v87, v35, number, v78);
                }
                v33 = 0;
                if (!v70)
                  goto LABEL_131;
                goto LABEL_130;
              }
              CFNumberGetValue((CFNumberRef)v85, kCFNumberIntType, (char *)&v84 + 4);
              if ((v84 & 0x800000000) != 0)
              {
                v56 = 1;
              }
              else
              {
                if ((v84 & 0x1000000000) == 0)
                  goto LABEL_146;
                v56 = 2;
              }
              v83 = v56;
LABEL_146:
              if ((v84 & 0x200000000000) != 0)
                v83 = 3;
              v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &v83);
              v58 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : Band for roam : %d", "__WiFiManagerBssSteerCallback", v83);
              objc_autoreleasePoolPop(v58);
              if (v55)
                goto LABEL_151;
              goto LABEL_152;
            }
            v66 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Channel not present", "__WiFiManagerBssSteerCallback");
            objc_autoreleasePoolPop(v66);
            v33 = 0;
LABEL_68:
            v35 = 0;
            if (!v12)
              goto LABEL_131;
            goto LABEL_130;
          }
          v63 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssid is not present in Steering Dictionary", "__WiFiManagerBssSteerCallback", v68);
        }
        else
        {
          sub_10009A914(v37, v34, &v88);
          if (v88 == -1)
          {
            v63 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ does not  exist", "__WiFiManagerBssSteerCallback", v90);
          }
          else
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v37, v88);
            v48 = objc_autoreleasePoolPush();
            if (!ValueAtIndex)
            {
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ does not  exist in the Known Network List", "__WiFiManagerBssSteerCallback", v90);
              v64 = v48;
              goto LABEL_191;
            }
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "known network ssid: %@: \n", sub_10002B088(ValueAtIndex));
            objc_autoreleasePoolPop(v48);
            if (v11)
              sub_1000F7F48((uint64_t)v73, v71, 1017, "__WiFiManagerBssSteerCallback", 8959);
            v49 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
            if (v49)
            {
              v33 = v49;
              v50 = CFDictionaryGetValue(a4, CFSTR("BSSID"));
              if (v50)
              {
                v51 = v50;
                if (v87)
                  sub_10002C478((uint64_t)v33, CFSTR("CHANNEL"), v87);
                sub_10002C478((uint64_t)v33, CFSTR("BSSID"), v51);
                sub_10002C478((uint64_t)v33, CFSTR("FORCE_BSSID"), kCFBooleanTrue);
                if (sub_10002BE64((uint64_t)v33, CFSTR("BSSID")))
                {
                  sub_1000C38BC((uint64_t)v33, (uint64_t)ValueAtIndex);
                  v52 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found matching network in scan results, proceeding with association", "__WiFiManagerBssSteerCallback");
                  objc_autoreleasePoolPop(v52);
                  context[0] = a3;
                  context[1] = 0xAAAAAAAA00000059;
                  context[2] = v33;
                  context[3] = 0;
                  CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
                }
              }
              else
              {
                v65 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssid is not present in Steering Dictionary", "__WiFiManagerBssSteerCallback");
                objc_autoreleasePoolPop(v65);
              }
              goto LABEL_109;
            }
            v63 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Unable to copy known network", "__WiFiManagerBssSteerCallback", v68);
          }
        }
        v64 = v63;
LABEL_191:
        objc_autoreleasePoolPop(v64);
        v33 = 0;
LABEL_109:
        v35 = 0;
        v12 = v70;
        goto LABEL_110;
      }
      v39 = sub_1000C5F98((uint64_t)v11, (uint64_t)v34);
      v40 = objc_autoreleasePoolPush();
      if (!v39)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Different network from current - attempting Roam !\n", "__WiFiManagerBssSteerCallback");
        v41 = 1;
        goto LABEL_84;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Same network as current - doing Roam !\n", "__WiFiManagerBssSteerCallback");
    }
    else
    {
      v40 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Ssid not present in the dictionary! - doing Roam\n", "__WiFiManagerBssSteerCallback");
      v34 = 0;
    }
    v41 = 0;
LABEL_84:
    objc_autoreleasePoolPop(v40);
    v42 = 1;
    goto LABEL_86;
  }
  v61 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to get steering request type\n", "__WiFiManagerBssSteerCallback");
  objc_autoreleasePoolPop(v61);
}

void sub_1000B538C(uint64_t a1, char a2, char a3, uint64_t a4)
{
  if (a4)
  {
    *(_BYTE *)(a4 + 2176) = a2;
    *(_BYTE *)(a4 + 2177) = a3;
  }
}

void sub_1000B539C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  void *v7;
  id v8;
  id context;

  if (a4)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type: %d network: %@", "__WiFiManagerUserNotificationPresentationCallback", a3, a2);
    objc_autoreleasePoolPop(v7);
    v8 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", sub_10002B088(a2), CFSTR("ssid"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a3), CFSTR("notificationType"), CFSTR("notification"), CFSTR("type"), CFSTR("presentation"), CFSTR("trigger"), 0);
    context = v8;
    CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_1000B7CB8, &context);
    if (v8)
      CFRelease(v8);
  }
}

void sub_1000B54D4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  void *v10;
  CFTypeRef v11;
  NSObject *v12;
  _QWORD block[6];
  int v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  if (a5)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type: %d response: %d network: %@", "__WiFiManagerUserNotificationResponseCallback", a3, a4, a2);
    objc_autoreleasePoolPop(v9);
    if ((_DWORD)a3 != 1)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no blacklisting for notification of type %d response %d", "__WiFiManagerUserNotificationResponseCallback", a3, a4);
      goto LABEL_8;
    }
    if ((_DWORD)a4 == 5)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not blacklisting system cancelled recommendation", "__WiFiManagerUserNotificationResponseCallback");
LABEL_8:
      objc_autoreleasePoolPop(v10);
      goto LABEL_12;
    }
    if (a2)
    {
      v11 = CFRetain(a2);
      v17[3] = (uint64_t)v11;
    }
    v12 = *(NSObject **)(a5 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B7CC0;
    block[3] = &unk_100230A08;
    block[4] = &v16;
    block[5] = a5;
    v14 = 1;
    v15 = a4;
    dispatch_async(v12, block);
  }
LABEL_12:
  _Block_object_dispose(&v16, 8);
}

void sub_1000B5654(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B566C(uint64_t a1, uint64_t a2)
{
  if (a2)
    return *(_QWORD *)(a2 + 2192);
  else
    return 0;
}

void sub_1000B5680(uint64_t a1, void *a2, const __CFString *a3, const __CFBoolean *a4, uint64_t a5)
{
  const void *v6;
  uint64_t v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFTypeID TypeID;
  const __CFData *Value;
  unsigned int v12;
  NSObject *v13;
  dispatch_time_t v14;

  if (a2 && a3 && a4)
  {
    sub_100096B7C(a5, a2, a3, a4);
  }
  else
  {
    v6 = sub_1000AAF20(a5, (const __CFDictionary **)a2);
    if (v6)
    {
      v7 = (uint64_t)v6;
      v8 = (const __CFDictionary *)sub_10002BE64((uint64_t)v6, CFSTR("PRIVATE_MAC_ADDRESS"));
      if (v8 && (v9 = v8, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v9)))
      {
        Value = (const __CFData *)CFDictionaryGetValue(v9, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
        v12 = sub_10002B75C(Value);
        if (!sub_10002BE64(v7, CFSTR("isBackhaulLinkUp")))
        {
          if (v12)
          {
            v13 = *(NSObject **)(a5 + 432);
            v14 = dispatch_time(0, (uint64_t)(*(double *)(a5 + 440) * 1000000000.0));
            dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);
          }
        }
      }
      else
      {
        sub_10002BE64(v7, CFSTR("isBackhaulLinkUp"));
      }
    }
  }
}

void sub_1000B578C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  void *v10;
  _QWORD context[3];

  if (!a3)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiManagerP2pThreadCoexEventCallback");
    goto LABEL_13;
  }
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "__WiFiManagerP2pThreadCoexEventCallback");
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return;
  }
  v8 = objc_autoreleasePoolPush();
  if (a4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoexEvent intf :%@", "__WiFiManagerP2pThreadCoexEventCallback", a2);
    objc_autoreleasePoolPop(v8);
    context[0] = a3;
    context[1] = a1;
    context[2] = a4;
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoexEvent deviceManager :%p", "__WiFiManagerDispatchClientP2pThreadCoexEvent", a1);
    objc_autoreleasePoolPop(v9);
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7E78, context);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoexEvent data is NULL!", "__WiFiManagerP2pThreadCoexEventCallback");
    objc_autoreleasePoolPop(v8);
  }
}

void sub_1000B590C(int a1, int a2, CFArrayRef theArray, uint64_t a4)
{
  CFIndex Count;
  CFIndex v7;
  const void *v8;
  CFMutableArrayRef Mutable;
  const __CFArray *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex v13;
  CFIndex v14;
  void *v15;
  CFIndex v16;
  const __CFDictionary *v17;
  const __CFString *Value;
  const __CFString *v19;
  CFIndex j;
  const void *v21;
  const __CFString *v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex i;
  const void *ValueAtIndex;
  void *v27;
  const __CFDictionary **v28;
  const __CFDictionary **v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  CFTypeID TypeID;
  const void *v33;
  void *v34;
  const void *v35;
  void *v36;
  const __CFArray *v37;
  const __CFArray *v38;
  CFIndex v39;
  CFIndex v40;
  void *v41;
  CFIndex v42;
  const void *v43;
  CFIndex v44;
  const __CFDictionary *v45;
  void *v46;
  int v47;
  unsigned int v48;
  void *v49;
  void *v50;
  void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const __CFDictionary *v55;
  void *v56;
  void *v57;
  CFTypeID v58;
  void *v59;
  void *v60;
  void *v61;
  const __CFArray *v62;
  uint64_t v63;
  void *v64;
  const void *v65;
  const __CFDictionary *v66;
  const __CFDictionary *v67;
  CFTypeID v68;
  void *v69;
  uint64_t v70;
  const void *v71;
  CFIndex v72;
  uint64_t v73;

  Count = CFArrayGetCount(theArray);
  if (!a4)
  {
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerColocatedCacheEventCallback");
    goto LABEL_78;
  }
  v7 = Count;
  v8 = *(const void **)(a4 + 2424);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a4 + 2424) = 0;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    *(_QWORD *)(a4 + 2424) = 0;
    *(_BYTE *)(a4 + 2432) = 0;
    return;
  }
  v10 = Mutable;
  v72 = v7;
  v11 = (const __CFArray *)sub_10008674C(a4);
  v73 = a4;
  if (v11)
  {
    v12 = v11;
    v13 = CFArrayGetCount(v11);
    v14 = CFArrayGetCount(theArray);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated Network Count = %ld ", "__WiFiManagerCreateColocatedNetworkGroup", v14);
    objc_autoreleasePoolPop(v15);
    if (v14 < 1)
    {
LABEL_19:
      v23 = CFArrayGetCount(v10);
      a4 = v73;
      if (v23 >= 1)
      {
        v24 = v23;
        for (i = 0; i != v24; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Colocated Network %@ ", ValueAtIndex);
          objc_autoreleasePoolPop(v27);
        }
      }
      goto LABEL_24;
    }
    v16 = 0;
    while (1)
    {
      v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v16);
      if (v17)
      {
        Value = (const __CFString *)CFDictionaryGetValue(v17, CFSTR("SSID_STR"));
        if (!Value)
        {
          v69 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID is NULL!", "__WiFiManagerCreateColocatedNetworkGroup");
          objc_autoreleasePoolPop(v69);
          a4 = v73;
          break;
        }
        if (v13 >= 1)
        {
          v19 = Value;
          for (j = 0; j != v13; ++j)
          {
            v21 = CFArrayGetValueAtIndex(v12, j);
            v22 = (const __CFString *)sub_10002BE64((uint64_t)v21, CFSTR("SSID_STR"));
            if (v22 && CFStringCompare(v22, v19, 0) == kCFCompareEqualTo)
              CFArrayAppendValue(v10, v21);
          }
        }
      }
      if (++v16 == v14)
        goto LABEL_19;
    }
  }
LABEL_24:
  *(_QWORD *)(a4 + 2424) = v10;
  v28 = (const __CFDictionary **)sub_10009FEE0((const __CFArray *)a4);
  v29 = v28;
  if (v28)
  {
    v30 = (const __CFDictionary *)sub_10002BE64((uint64_t)v28, CFSTR("PRIVATE_MAC_ADDRESS"));
    if (v30)
    {
      v31 = v30;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v31))
        CFDictionaryGetValue(v31, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
    }
    v33 = sub_10002BE64((uint64_t)v29, CFSTR("WiFiNetworkRouterMac"));
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Router MAC Address: %@", v33);
    objc_autoreleasePoolPop(v34);
    v35 = sub_10002BE64((uint64_t)v29, CFSTR("WiFiNetworkRouterIP"));
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Router IP Address: %@", v35);
    objc_autoreleasePoolPop(v36);
  }
  v37 = (const __CFArray *)sub_10008674C(a4);
  if (!v37)
    goto LABEL_76;
  v38 = v37;
  v39 = CFArrayGetCount(v37);
  v40 = CFArrayGetCount(v10);
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Run Colocated Networks against Private Filters. ColocatedNetwork Count = %ld ", "__WiFiManagerColocatedCachePrivacyFilters", v40);
  objc_autoreleasePoolPop(v41);
  if (!v40)
    goto LABEL_76;
  if (v40 < 1)
  {
    v43 = 0;
LABEL_80:
    v61 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ meets Colocated Privacy Guidelines", v43);
    objc_autoreleasePoolPop(v61);
    *(_BYTE *)(a4 + 2432) = 1;
    if (sub_10009FEE0((const __CFArray *)a4))
    {
      v62 = *(const __CFArray **)(a4 + 2424);
      v63 = a4;
    }
    else
    {
      if (v72)
        return;
      v64 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Invalidate Colocated Cache");
      objc_autoreleasePoolPop(v64);
      v65 = *(const void **)(a4 + 2424);
      if (v65)
      {
        CFRelease(v65);
        *(_QWORD *)(a4 + 2424) = 0;
      }
      *(_BYTE *)(a4 + 2432) = 0;
      *(_QWORD *)(a4 + 2440) = 0;
      v63 = a4;
      v62 = 0;
    }
    sub_1000B7F4C(v63, v62);
    return;
  }
  v42 = 0;
  while (1)
  {
    v43 = CFArrayGetValueAtIndex(v10, v42);
    if (!v43)
      goto LABEL_71;
    if (v39 < 1)
      goto LABEL_73;
    v44 = 0;
    while (1)
    {
      v45 = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, v44);
      if (sub_1000C6060((uint64_t)v43, (uint64_t)v45))
        break;
      if (v39 == ++v44)
        goto LABEL_73;
    }
    if (!v45)
    {
LABEL_73:
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ is not present in Known Network list", v43);
      goto LABEL_75;
    }
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ is present in Known Network list", v43);
    objc_autoreleasePoolPop(v46);
    v47 = sub_1000C5104((uint64_t)v45);
    v48 = v47 | sub_1000C433C(v45);
    v49 = objc_autoreleasePoolPush();
    if (!v48)
      break;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ is Secure", v43);
    objc_autoreleasePoolPop(v49);
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ has same Subnet", v43);
    objc_autoreleasePoolPop(v50);
    v51 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ has same Auto-Join Policy", v43);
    objc_autoreleasePoolPop(v51);
    v52 = sub_1000AAF20(v73, v29);
    if (v52)
      v53 = sub_10002BE64((uint64_t)v52, CFSTR("PRIVATE_MAC_ADDRESS"));
    else
      v53 = 0;
    v54 = sub_1000AAF20(v73, (const __CFDictionary **)v45);
    if (!v53 || !v54)
    {
      v66 = (const __CFDictionary *)sub_10002BE64((uint64_t)v54, CFSTR("PRIVATE_MAC_ADDRESS"));
      if (v66)
      {
        v67 = v66;
        v68 = CFDictionaryGetTypeID();
        if (v68 == CFGetTypeID(v67))
          CFDictionaryGetValue(v67, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
      }
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ has same Privacy Policy", v43);
      goto LABEL_75;
    }
    v71 = v53;
    v55 = (const __CFDictionary *)sub_10002BE64((uint64_t)v54, CFSTR("PRIVATE_MAC_ADDRESS"));
    v56 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Colocated Network Private Mac Dictionary %@", v55);
    objc_autoreleasePoolPop(v56);
    v57 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Current Network Private Mac Dictionary %@", v71);
    objc_autoreleasePoolPop(v57);
    if (v55)
    {
      v58 = CFDictionaryGetTypeID();
      if (v58 == CFGetTypeID(v55))
      {
        if (CFDictionaryGetValue(v55, CFSTR("PRIVATE_MAC_ADDRESS_TYPE")))
          sub_10002C478((uint64_t)v45, CFSTR("PRIVATE_MAC_ADDRESS"), v71);
      }
    }
    v59 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ has same Privacy Policy", v43);
    objc_autoreleasePoolPop(v59);
    a4 = v73;
LABEL_71:
    if (++v42 == v40)
      goto LABEL_80;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Network %@ is Not Secure", v43);
LABEL_75:
  objc_autoreleasePoolPop(v49);
  a4 = v73;
LABEL_76:
  *(_BYTE *)(a4 + 2432) = 0;
  v60 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Colocated Group is not valid", v70);
LABEL_78:
  objc_autoreleasePoolPop(v60);
}

void sub_1000B613C(uint64_t a1, uint64_t a2)
{
  CFMutableStringRef Mutable;
  BOOL v5;
  int v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (a2)
  {
    if (sub_10009C718(a2, Mutable))
      v5 = Mutable == 0;
    else
      v5 = 1;
    if (!v5)
    {
      if (CFStringCompare(Mutable, CFSTR("XZ"), 0)
        && CFStringCompare(Mutable, &stru_100238178, 0)
        && CFStringCompare(Mutable, CFSTR("X0"), 0)
        && CFStringCompare(Mutable, CFSTR("X2"), 0)
        && CFStringCompare(Mutable, CFSTR("X3"), 0))
      {
        v6 = sub_10010883C(a1, Mutable, 0);
        v7 = objc_autoreleasePoolPush();
        if (v6)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Successfully initilaized country to HW on boot : %@", "__WiFiManagerUpdateCountryOnInitCallback", Mutable);
        }
        else if (qword_10026DD20)
        {
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Unable to initialize country to HW on boot : %@", "__WiFiManagerUpdateCountryOnInitCallback", Mutable);
        }
      }
      else
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " WiFiCC : User Defaults does not have valid country code ", v9, v10);
      }
      objc_autoreleasePoolPop(v7);
      goto LABEL_20;
    }
    if (Mutable)
LABEL_20:
      CFRelease(Mutable);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerUpdateCountryOnInitCallback");
    objc_autoreleasePoolPop(v8);
    if (Mutable)
      goto LABEL_20;
  }
}

void sub_1000B630C(int a1, int a2, CFDictionaryRef theDict, uint64_t a4)
{
  const void *Value;
  const void *v6;
  void *v7;
  void *v8;
  void *v9;

  if (a4)
  {
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, CFSTR("P2P_CC_COUNTRY"));
      if (Value)
      {
        v6 = Value;
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Country from Peer : [%@]", v6);
        objc_autoreleasePoolPop(v7);
        v8 = *(void **)(a4 + 192);
        if (v8)
          objc_msgSend(v8, "updatePeerCountryCode:", v6);
      }
    }
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerPeerCountryEventCallback");
    objc_autoreleasePoolPop(v9);
  }
}

void sub_1000B63F8(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6)
{
  void *v6;
  NSNumber *v8;
  void *v9;
  uint64_t v10;

  if (a6)
  {
    v6 = *(void **)(a6 + 1792);
    if (v6)
    {
      if (a3 == 238)
      {
        v8 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *a2);
        v9 = v6;
        v10 = 238;
        goto LABEL_8;
      }
      if (a3 == 239)
      {
        v8 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a2, a5);
        v9 = v6;
        v10 = 239;
LABEL_8:
        objc_msgSend(v9, "handleEvent:withData:interface:", v10, v8, a4);
      }
    }
  }
}

BOOL sub_1000B6480(uint64_t a1)
{
  _BOOL8 result;

  result = sub_100167AF8(*(_QWORD *)(a1 + 32) + 1800, 0);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 1808) = result;
  return result;
}

void sub_1000B64BC(uint64_t a1, const void *a2)
{
  void *v4;
  void *v5;
  id v6;
  unsigned int v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL!", "__WiFiManagerGeoTagNetworkIfApplicable");
    goto LABEL_19;
  }
  if (a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network: %@, isWiFiNetworkWaitingToBeGeoTagged %d", "__WiFiManagerGeoTagNetworkIfApplicable", sub_10002B088(a2), *(unsigned __int8 *)(a1 + 1704));
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 1704) = 0;
    if (!sub_10000BE8C((uint64_t)a2) && !sub_10001395C((uint64_t)a2))
    {
      v5 = objc_autoreleasePoolPush();
      if (objc_msgSend(*(id *)(a1 + 1696), "isAuthorized"))
      {
        v6 = objc_msgSend(*(id *)(a1 + 1696), "latestLocation");
        sub_1000B6D14((const __CFArray *)a1, v6);
        +[WiFiLocationManager logLocation:addPrefixString:](WiFiLocationManager, "logLocation:addPrefixString:", v6, sub_10002B088(a2));
        v7 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v6, 1, 60.0);
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ - isValid %d", "__WiFiManagerGeoTagNetwork", sub_10002B088(a2), v7 != 0);
        objc_autoreleasePoolPop(v8);
        if (v7)
        {
          ++*(_QWORD *)(a1 + 1720);
        }
        else
        {
          ++*(_QWORD *)(a1 + 1712);
          *(_BYTE *)(a1 + 1704) = 1;
          objc_msgSend(*(id *)(a1 + 1696), "requestHighAccuracyLocationUpdate");
        }
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LEECHED_LOC_STAT_HIGH_ACCURACY_GEOTAG: GOOD %ld, BAD %ld", "__WiFiManagerGeoTagNetwork", *(_QWORD *)(a1 + 1720), *(_QWORD *)(a1 + 1712));
      }
      else
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not authorized to use location", "__WiFiManagerGeoTagNetwork", v10, v11);
      }
      objc_autoreleasePoolPop(v9);
LABEL_19:
      objc_autoreleasePoolPop(v5);
    }
  }
}

void sub_1000B6718(uint64_t a1, uint64_t a2, int a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v7;
  const void **v8;
  CFNumberRef v9;
  CFNumberRef v10;
  void *v11;
  void *v12;
  _QWORD context[3];
  int valuePtr;

  valuePtr = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v7 = Mutable;
    v8 = (const void **)&kCFBooleanTrue;
    if (!a3)
      v8 = (const void **)&kCFBooleanFalse;
    CFDictionarySetValue(Mutable, CFSTR("BT_SCAN_INTERVAL_RELAX_ENABLE"), *v8);
    v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    if (v9)
    {
      v10 = v9;
      CFDictionarySetValue(v7, CFSTR("BT_SCAN_INTERVAL_RELAX_REASON"), v9);
      CFRelease(v10);
      context[0] = a1;
      context[1] = a2;
      context[2] = v7;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B6E24, context);
      CFRelease(v7);
    }
    else
    {
      CFRelease(v7);
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Could not allocate reasonRef", "__WiFiManagerDispatchClientBTScanIntervalRelaxEvent");
      objc_autoreleasePoolPop(v12);
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Could not allocate BTScanIntervalRelax", "__WiFiManagerDispatchClientBTScanIntervalRelaxEvent");
    objc_autoreleasePoolPop(v11);
  }
}

void sub_1000B6890(uint64_t a1, int a2)
{
  const CFBooleanRef *v4;
  CFBooleanRef v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  if (*(unsigned __int8 *)(a1 + 1544) != a2)
  {
    v4 = &kCFBooleanTrue;
    if (!a2)
      v4 = &kCFBooleanFalse;
    keys[0] = CFSTR("appPolicyUUID");
    keys[1] = CFSTR("appPolicyState");
    v5 = *v4;
    values[0] = CFSTR("CARPLAY_UUID");
    values[1] = v5;
    v6 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v6)
    {
      v7 = v6;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000041;
      context[2] = v6;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
      CFRelease(v7);
    }
    *(_BYTE *)(a1 + 1544) = a2 != 0;
  }
}

void sub_1000B69B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;

  if (sub_1000CA53C(a3))
    sub_1000B6718(a1, a2, 0);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Lost link to Carplay network. Reset Carplay mode.", "__WiFiManagerResetCarPlayMode");
  objc_autoreleasePoolPop(v5);
  sub_10009FB18(a1, 0, 0);
  sub_1000B6890(a1, 0);
}

void sub_1000B6A48(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  const void *v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  int v12;
  void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  void *v18;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiManagerStopMonitoringSessionBasedApplication");
    v18 = v17;
    goto LABEL_36;
  }
  v3 = *(_QWORD *)(a1 + 1656);
  v4 = objc_autoreleasePoolPush();
  if (!v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: session based network is null", "__WiFiManagerStopMonitoringSessionBasedApplication");
    v18 = v4;
LABEL_36:
    objc_autoreleasePoolPop(v18);
    goto LABEL_29;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: stop monitoring application state for %@", "__WiFiManagerStopMonitoringSessionBasedApplication", *(_QWORD *)(a1 + 1664));
  objc_autoreleasePoolPop(v4);
  v5 = *(void **)(a1 + 1944);
  if (v5)
    objc_msgSend(v5, "invalidate");
  if (*(_QWORD *)(a1 + 1616))
  {
    v6 = *(const void **)(a1 + 1656);
    v7 = (void *)sub_10002B088(v6);
    v8 = objc_msgSend(v7, "stringByAppendingString:", sub_1000CB154((uint64_t)v6));
    v9 = objc_autoreleasePoolPush();
    if (objc_msgSend(*(id *)(a1 + 1616), "objectForKey:", v8))
    {
      v10 = objc_msgSend(*(id *)(a1 + 1616), "mutableCopy");
      objc_msgSend(v10, "removeObjectForKey:", v8);
      sub_100087488((_QWORD *)a1, CFSTR("SessionBasedNetworkList"), v10, 0);
      sub_1000A3300(a1, v10);
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sessionBasedNetworkList not found", "__WiFiManagerRemoveSessionBasedNetwork");
      objc_autoreleasePoolPop(v11);
    }
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sessionBasedNetworkList is NULL", "__WiFiManagerRemoveSessionBasedNetwork");
  }
  objc_autoreleasePoolPop(v9);
  v12 = sub_100098780(a1, *(const void **)(a1 + 1656), 0);
  v13 = objc_autoreleasePoolPush();
  if (v12)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is existing network, leaving password", "__WiFiManagerStopMonitoringSessionBasedApplication", sub_10002B088(*(const void **)(a1 + 1656)));
    objc_autoreleasePoolPop(v13);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: removing password for %@", "__WiFiManagerStopMonitoringSessionBasedApplication", sub_10002B088(*(const void **)(a1 + 1656)));
    objc_autoreleasePoolPop(v13);
    sub_1000C65D8(*(const void **)(a1 + 1656));
  }
  v14 = *(const void **)(a1 + 1944);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 1944) = 0;
  }
  v15 = *(const void **)(a1 + 1656);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 1656) = 0;
  }
  v16 = *(const void **)(a1 + 1664);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 1664) = 0;
  }
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentSessionBasedNetworkRef:", 0);
LABEL_29:
  objc_autoreleasePoolPop(v2);
}

void sub_1000B6D14(const __CFArray *a1, void *a2)
{
  void *v4;
  void *v5;
  int v6;
  double v7;
  CLLocationDegrees v8;
  double v9;
  CLLocationDegrees v10;
  double v11;
  double v12;
  id v13;

  v4 = objc_autoreleasePoolPush();
  v5 = sub_10009FEE0(a1);
  if (+[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", a2, 1, 60.0))*((_BYTE *)a1 + 1704) = 0;
  v6 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (a2 && v6 && v5)
  {
    objc_msgSend(a2, "coordinate");
    v8 = v7;
    objc_msgSend(a2, "coordinate");
    v10 = v9;
    objc_msgSend(a2, "horizontalAccuracy");
    v12 = v11;
    v13 = objc_msgSend(a2, "timestamp");
    sub_1000A10CC((int)v13, v5, v8, v10, v12, v13);
    sub_100099EA4((uint64_t)a1, v5, 1u);
    sub_10005E1F8(v5, a2);
LABEL_8:
    CFRelease(v5);
    goto LABEL_9;
  }
  sub_10005E1F8(v5, a2);
  if (v5)
    goto LABEL_8;
LABEL_9:
  objc_autoreleasePoolPop(v4);
}

void sub_1000B6E24(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    sub_1000663BC(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchBTScanIntervalRelaxEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000B6EA8(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_QWORD *)(a2 + 8))
  {
    if (*(_QWORD *)a2)
      sub_1000662CC(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
}

void sub_1000B6ECC(uint64_t a1)
{
  WiFiCloudSyncEngineCheckKeychainSyncState(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_1000B6EFC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_1000662D8(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B6F18(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_1000662E4(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B6F34(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_1000662F0(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B6F50(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Requesting PersonalHotspotControl extension to reload");
  objc_autoreleasePoolPop(v1);
  -[CHSControlService reloadControlsForExtension:kind:reason:](+[CHSControlService sharedInstance](CHSControlService, "sharedInstance"), "reloadControlsForExtension:kind:reason:", CFSTR("com.apple.WiFiKit.PersonalHotspotControl"), CFSTR("PersonalHotspotControl"), CFSTR("wifi manager set MIS state request PH widget to reload"));
}

void sub_1000B6FBC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_100066308(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B6FD8(uint64_t a1, const void *a2, uint64_t a3)
{
  const __CFDictionary *v4;
  const void *v7;
  const __CFString *Value;
  const __CFArray *v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const __SCNetworkSet *ValueAtIndex;
  const __SCNetworkSet *v15;
  CFStringRef Name;
  void *v17;
  CFStringRef SetID;
  const __CFString *v19;
  void *v20;
  int v21;
  void *v22;
  uint64_t v23;

  if (!a2)
    return;
  v4 = *(const __CFDictionary **)(a1 + 208);
  if (!v4)
    return;
  v7 = sub_10002B088(a2);
  Value = (const __CFString *)CFDictionaryGetValue(v4, v7);
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 1064));
  v9 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 1064));
  if (!v9)
    return;
  v10 = v9;
  v23 = a3;
  Count = CFArrayGetCount(v9);
  if (Count < 1)
    goto LABEL_21;
  v12 = Count;
  v13 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v10, v13);
    if (!ValueAtIndex)
      goto LABEL_15;
    v15 = ValueAtIndex;
    Name = SCNetworkSetGetName(ValueAtIndex);
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set for network %@: %@", "__WiFiManagerApplyNetworkSettings", sub_10002B088(a2), Name);
    objc_autoreleasePoolPop(v17);
    if (!Value)
      break;
    if (SCNetworkSetGetSetID(v15))
    {
      SetID = SCNetworkSetGetSetID(v15);
      v19 = Value;
      goto LABEL_14;
    }
LABEL_15:
    if (v12 == ++v13)
      goto LABEL_21;
  }
  if (!Name)
    goto LABEL_15;
  SetID = Name;
  v19 = CFSTR("Automatic");
LABEL_14:
  if (!CFEqual(SetID, v19))
    goto LABEL_15;
  sub_100007620(*(const __SCPreferences **)(a1 + 1064));
  v20 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerApplyNetworkSettings");
  v21 = SCNetworkSetSetCurrent(v15);
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set %@ is now active for interface %@", "__WiFiManagerApplyNetworkSettings", Name, v23);
  objc_autoreleasePoolPop(v22);
  sub_1000076D4(*(SCPreferencesRef *)(a1 + 1064), v21);

LABEL_21:
  CFRelease(v10);
}

uint64_t sub_1000B71C0(uint64_t a1)
{
  const __CFArray *v2;
  uint64_t v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;
  CFBooleanRef v8;
  BOOL v9;
  void *v10;
  unsigned int v11;
  void *v12;
  CFBooleanRef v13;
  void *v14;
  CFBooleanRef v15;
  void *v17;
  void *context;

  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerCheckProfileNetworksForMDMOrSupervised");
    goto LABEL_32;
  }
  if ((objc_msgSend(*(id *)(a1 + 1480), "isMCInitialized") & 1) == 0)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ManagedConfiguration not initialized", "__WiFiManagerCheckProfileNetworksForMDMOrSupervised");
LABEL_32:
    objc_autoreleasePoolPop(v17);
    return 0;
  }
  v2 = (const __CFArray *)sub_1000875B0(a1);
  v3 = (uint64_t)v2;
  if (!v2)
    return v3;
  Count = CFArrayGetCount(v2);
  if (!Count)
    return 0;
  v5 = Count;
  if (Count >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, i);
      v8 = (CFBooleanRef)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("isProfileBasedNetwork"));
      if (v8)
        v9 = v8 == kCFBooleanTrue;
      else
        v9 = 0;
      if (v9)
      {
        context = objc_autoreleasePoolPush();
        v10 = *(void **)(a1 + 1480);
        v11 = objc_msgSend(v10, "isWiFiNetworkMDMNetwork:", ValueAtIndex);
        if (v11)
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Network <%@> is subject to MDM.", "__WiFiManagerCheckProfileNetworksForMDMOrSupervised", sub_10002B088(ValueAtIndex));
          objc_autoreleasePoolPop(v12);
          v13 = kCFBooleanTrue;
        }
        else
        {
          v13 = 0;
        }
        sub_10002C478((uint64_t)ValueAtIndex, CFSTR("PrivateMacManagedNetwork"), v13);
        if (objc_msgSend(v10, "isSupervisedDevice"))
        {
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Device is subject to supervision. Store key for profile <%@>", "__WiFiManagerCheckProfileNetworksForMDMOrSupervised", sub_10002B088(ValueAtIndex));
          objc_autoreleasePoolPop(v14);
          sub_10002C478((uint64_t)ValueAtIndex, CFSTR("PrivateMacSupervisedDevice"), kCFBooleanTrue);
          objc_autoreleasePoolPop(context);
          v15 = kCFBooleanTrue;
        }
        else
        {
          sub_10002C478((uint64_t)ValueAtIndex, CFSTR("PrivateMacSupervisedDevice"), 0);
          objc_autoreleasePoolPop(context);
          if (v11)
            v15 = kCFBooleanTrue;
          else
            v15 = 0;
        }
        sub_10002C478((uint64_t)ValueAtIndex, CFSTR("PrivateMacControlledDevice"), v15);
      }
    }
  }
  sub_1000A46A8(a1, (const __CFArray *)v3);
  v3 = 1;
  sub_1000A485C(a1, 1, 0);
  return v3;
}

void sub_1000B747C(uint64_t a1)
{
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 1856) = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 1776), "WiFiDriverTriggeredTTRHandler:", *(_QWORD *)(a1 + 32));

}

void sub_1000B74B0(uint64_t a1, uint64_t a2)
{
  sub_1000662FC(a1, *(_QWORD *)(a2 + 8), *(const void **)a2);
}

void sub_1000B74BC(uint64_t a1)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  unsigned int v12[2];
  const __CFString *v13;
  int v14;
  char v15;
  char v16;
  char v17;
  char v18;
  const __CFString *v19;
  __int128 v20;

  v2 = *(unsigned __int8 *)(a1 + 2345);
  if (*(_BYTE *)(a1 + 2345))
    v3 = ((*(double *)(a1 + 2328) - *(double *)(a1 + 2320)) * 1000.0);
  else
    v3 = 0xFFFFFFFFLL;
  v4 = *(unsigned __int8 *)(a1 + 2344);
  v5 = *(unsigned __int8 *)(a1 + 2346);
  v6 = *(unsigned int *)(a1 + 2336);
  v7 = *(unsigned int *)(a1 + 2340);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (v5)
      v9 = "yes";
    else
      v9 = "no";
    if (v2)
      v10 = "yes";
    else
      v10 = "no";
    if (v4)
      v11 = "yes";
    else
      v11 = "no";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: duration %u ms, session up ? %s, debounce succeeded ? %s, debounce timed out ? %s, reason %@(%d), subReason %d", "__WiFiManagerSubmitCarPlayLinkDownSuppressionMetrics", v3, v9, v10, v11, sub_100064AA8(v6), v6, v7);
  }
  objc_autoreleasePoolPop(v8);
  v18 = -86;
  v12[1] = -1431655766;
  v12[0] = v3;
  v13 = sub_100064AA8(v6);
  v14 = v7;
  v15 = v4;
  v16 = v2;
  v17 = v5;
  v19 = CFSTR("Unknown");
  *(_QWORD *)&v20 = CFSTR("Unknown");
  *((_QWORD *)&v20 + 1) = CFSTR("Unknown");
  if (*(_QWORD *)(a1 + 2368))
  {
    v19 = *(const __CFString **)(a1 + 2368);
    v20 = *(_OWORD *)(a1 + 2376);
  }
  sub_100062C04(v12);
}

void sub_1000B7620(uint64_t a1, _QWORD *a2)
{
  int v4;
  int v5;
  int *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  void *v10;
  CFAbsoluteTime Current;
  CFDateRef v12;
  CFDateRef v13;
  void *v14;
  void *v15;
  const void *v16;
  _QWORD block[5];

  v4 = sub_1000D71EC(a1);
  if (v4 != 5)
  {
    if (v4)
      return;
    v5 = sub_1000D71FC(a1);
    if ((v5 & 0xFFFFFFFE) == 2 && (byte_10026D6A8 & 1) != 0)
    {
      v6 = &dword_10026D68C;
    }
    else
    {
      if (v5 != 1)
      {
LABEL_11:
        byte_10026D6A8 = 0;
        v8 = sub_1000D71FC(a1);
        if (v8 == 2)
        {
          a2[110] = 1;
        }
        else if (v8 == 1)
        {
          v9 = sub_1000C053C(a1);
          if (v9)
          {
            v10 = (void *)v9;
            Current = CFAbsoluteTimeGetCurrent();
            v12 = CFDateCreate(kCFAllocatorDefault, Current);
            if (v12)
            {
              v13 = v12;
              sub_1000C69F0(v10, 1, v12);
              CFRelease(v13);
            }
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting addition of %@.", sub_10002B088(v10));
            objc_autoreleasePoolPop(v14);
            sub_100094420((uint64_t)a2, v10, 6);
          }
          else
          {
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received Ask to join response accepted but network object is NULL");
            objc_autoreleasePoolPop(v15);
          }
        }
        v16 = (const void *)a2[23];
        if (v16)
        {
          CFRelease(v16);
          a2[23] = 0;
        }
        return;
      }
      v6 = &dword_10026D690;
    }
    ++*v6;
    goto LABEL_11;
  }
  if (sub_1000D71FC(a1) == 2)
  {
    v7 = a2[4];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B77FC;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v7, block);
  }
}

void sub_1000B77FC(uint64_t a1)
{
  CFAbsoluteTime Current;
  CFDateRef v3;
  NSDate *v4;
  void *v5;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(kCFAllocatorDefault, Current);
  v4 = sub_1000649A4((uint64_t)v3, 5, 0, 0);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user chose to mute join recommendation", "__WiFiManagerNotificationResponseFilterJoinRecommendation_block_invoke");
  objc_autoreleasePoolPop(v5);
  sub_100090934(*(_QWORD *)(a1 + 32), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 2072), v4, 0);
  if (v4)
    CFRelease(v4);
  if (v3)
    CFRelease(v3);
}

uint64_t sub_1000B78D0(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = sub_10006519C(a1, *(_QWORD *)(a2 + 8));
  if (!(_DWORD)result)
    *(_DWORD *)a2 = 0;
  return result;
}

void sub_1000B7900(uint64_t a1, unsigned __int8 *a2)
{
  sub_100066320(a1, *a2, *((_QWORD *)a2 + 1));
}

void sub_1000B7910(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 8))
      sub_100066398(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
}

void sub_1000B7934(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 8))
      sub_1000663A4(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
}

void sub_1000B7958(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 8))
      sub_1000663B0(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
}

void sub_1000B797C(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    sub_10006649C(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(a2 + 16));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchCarPlayNetworkTypeChangeEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000B7A00(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    sub_1000663EC(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(a2 + 16));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchM1M4Handshake24GHzCountEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000B7A84(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_10006654C(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B7AA0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_100066884(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

id sub_1000B7ABC(uint64_t a1)
{
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 1760), "incrementCount");
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 1760), "updateHUDWithMessage:", *(_QWORD *)(a1 + 32));
}

void sub_1000B7AEC(uint64_t a1, uint64_t a2)
{
  sub_100065B14(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
}

void sub_1000B7AF8(uint64_t a1, uint64_t a2)
{
  sub_100065BD8(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
}

void sub_1000B7B04(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v4;
  const void *Value;
  const void *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex v9;
  const void *ValueAtIndex;
  __CFArray *MutableCopy;
  const __CFArray *v12;

  if (a1)
  {
    v4 = *(const __CFDictionary **)(a2 + 16);
    if (v4)
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("WiFiHostApStateIdentifier"));
      if (!Value || !CFEqual(Value, kCFBooleanTrue))
      {
        v6 = CFDictionaryGetValue(v4, CFSTR("LINK_CHANGED_IS_LINKDOWN"));
        if (v6)
        {
          if (CFEqual(v6, kCFBooleanTrue))
          {
            v7 = (const __CFArray *)sub_100032320(a1);
            if (v7)
            {
              v8 = v7;
              if (CFArrayGetCount(v7) >= 1)
              {
                v9 = 0;
                while (1)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
                  if (ValueAtIndex)
                  {
                    if (sub_100017A54((uint64_t)ValueAtIndex, CFSTR("networkRole")) == (const __CFNumber *)4)
                      break;
                  }
                  if (++v9 >= CFArrayGetCount(v8))
                    goto LABEL_17;
                }
                MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v8);
                if (MutableCopy)
                {
                  v12 = MutableCopy;
                  CFArrayRemoveValueAtIndex(MutableCopy, v9);
                  sub_100065130(a1, v12);
                  CFRelease(v12);
                }
                else
                {
                  sub_100065130(a1, 0);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_17:
  sub_100066130(a1, *(_QWORD *)a2, *(void **)(a2 + 8), *(const void **)(a2 + 16));
}

void sub_1000B7C48(uint64_t a1)
{
  sub_1000BA668(*(_QWORD *)(a1 + 32), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 1592));
}

void sub_1000B7C54(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_100066558(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B7C70(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_10006660C(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B7C8C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)a2)
      sub_100066618(a1, *(_QWORD *)a2, *(const void **)(a2 + 8));
  }
}

void sub_1000B7CA8(uint64_t a1, uint64_t a2)
{
  sub_100065DD4(a1, *(_QWORD *)a2, *(void **)(a2 + 8), *(const void **)(a2 + 16));
}

void sub_1000B7CB8(uint64_t a1, const void **a2)
{
  sub_100066890(a1, *a2);
}

void sub_1000B7CC0(uint64_t a1)
{
  const void *v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFDictionaryRef v5;
  const void *v6;
  CFDictionaryRef v7;
  void *values[5];
  void *keys[5];

  v2 = sub_10002B088(*(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  sub_10009AB1C(*(_QWORD **)(a1 + 40), v2, 0, 0, *(unsigned int *)(a1 + 48));
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a1 + 48));
  v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a1 + 52));
  keys[0] = CFSTR("ssid");
  keys[1] = CFSTR("type");
  keys[2] = CFSTR("notificationType");
  keys[3] = CFSTR("response");
  keys[4] = CFSTR("trigger");
  values[0] = (void *)v2;
  values[1] = CFSTR("notification");
  values[2] = v3;
  values[3] = v4;
  values[4] = CFSTR("dismissal");
  v5 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 5, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = v5;
  CFSetApplyFunction(*(CFSetRef *)(*(_QWORD *)(a1 + 40) + 136), (CFSetApplierFunction)sub_1000B7CB8, &v7);
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
  if (v3)
    CFRelease(v3);
  v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_1000B7E78(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoexEvent client :%p", "__WiFiManagerDispatchP2pThreadCoexEvent", a1);
    objc_autoreleasePoolPop(v4);
    sub_10006692C(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchP2pThreadCoexEvent");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000B7F4C(uint64_t a1, const __CFArray *a2)
{
  id v4;
  NSNumber *v5;
  NSNumber *v6;
  NSNumber *v7;
  CFIndex Count;
  void *v9;
  _QWORD context[4];

  v4 = objc_alloc_init((Class)NSMutableDictionary);
  v5 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(unsigned __int8 *)(a1 + 2432));
  v6 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *(_QWORD *)(a1 + 2440));
  if (a2)
  {
    v7 = v6;
    Count = CFArrayGetCount(a2);
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated Network Count = %ld ", "__WiFiManagerSetColocatedNetworks", Count);
    objc_autoreleasePoolPop(v9);
    if (Count)
    {
      objc_msgSend(v4, "setObject:forKey:", a2, CFSTR("COLOCATED_NETWORK_GROUP"));
      objc_msgSend(v4, "setObject:forKey:", v5, CFSTR("COLOCATED_NETWORK_GROUP_STATUS"));
      objc_msgSend(v4, "setObject:forKey:", v7, CFSTR("COLOCATED_NETWORK_GROUP_SCOPE_ID"));
    }
  }
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000085;
  context[2] = v4;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);

}

id sub_1000B8080(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id result;

  result = objc_msgSend(a2, "isMemberOfClass:", objc_opt_class(WiFiUsageMonitor_UsbDevice));
  if (a2 && (_DWORD)result)
  {
    result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(_QWORD *)(a1 + 40));
    if ((_DWORD)result)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
      *a4 = 1;
    }
  }
  return result;
}

void sub_1000B80F8(uint64_t a1, io_registry_entry_t entry, uint64_t a3)
{
  int v6;
  uint64_t RegistryEntryID;
  CFTypeRef CFProperty;
  CFTypeRef v9;
  void *v10;
  CFTypeRef v11;
  unsigned int v12;
  unsigned int v13;
  CFTypeRef v14;
  unsigned int v15;
  CFTypeRef v16;
  void *v17;
  void *v18;
  BOOL v19;
  void *v20;
  unint64_t v21;
  id v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  void *v27;
  io_object_t v28;
  uint64_t v29;
  void *v30;
  _QWORD v31[6];
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t entryID;

  entryID = 0;
  v6 = *(_DWORD *)(a1 + 2460);
  RegistryEntryID = IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if ((_DWORD)RegistryEntryID)
  {
    v29 = RegistryEntryID;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification IORegistryEntryGetRegistryEntryID failed: %08x", v29);
    objc_autoreleasePoolPop(v30);
  }
  else
  {
    CFProperty = IORegistryEntryCreateCFProperty(entry, CFSTR("TransportDescription"), kCFAllocatorDefault, 0);
    v9 = (id)CFMakeCollectable(CFProperty);
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Usb Host Notification Transport message arrived! (messageType: 0x%08x, transportDescription: %@, registryEntryID: %llu)", a3, v9, entryID);
    objc_autoreleasePoolPop(v10);
    v11 = IORegistryEntryCreateCFProperty(entry, CFSTR("TransportType"), kCFAllocatorDefault, 0);
    v12 = objc_msgSend((id)(id)CFMakeCollectable(v11), "intValue");
    if ((_DWORD)a3 == -536870896)
    {
      v13 = v12;
      v14 = IORegistryEntryCreateCFProperty(entry, CFSTR("DataRole"), kCFAllocatorDefault, 0);
      v15 = objc_msgSend((id)(id)CFMakeCollectable(v14), "intValue");
      v16 = IORegistryEntryCreateCFProperty(entry, CFSTR("Vendor ID"), kCFAllocatorDefault, 0);
      v17 = (id)CFMakeCollectable(v16);
      if (v15 <= 1)
      {
        v18 = v17;
        --*(_DWORD *)(a1 + 2460);
        v19 = objc_msgSend(v17, "intValue") == 1452 || objc_msgSend(v18, "intValue") == 1452;
        *(_BYTE *)(a1 + 2464) = v19;
        if (objc_msgSend(*(id *)(a1 + 2488), "count"))
        {
          v32 = 0;
          v33 = &v32;
          v34 = 0x2020000000;
          v35 = -1;
          v20 = *(void **)(a1 + 2488);
          v31[0] = _NSConcreteStackBlock;
          v31[1] = 3221225472;
          v31[2] = sub_1000B8560;
          v31[3] = &unk_100230A58;
          v31[4] = v9;
          v31[5] = &v32;
          objc_msgSend(v20, "enumerateObjectsUsingBlock:", v31);
          v21 = v33[3];
          v22 = objc_msgSend(*(id *)(a1 + 2488), "count");
          v23 = objc_autoreleasePoolPush();
          if (v21 >= (unint64_t)v22)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Usb Host Notification for %@ -- unable to find in %@\n", "__WiFiManagerhandleNotificationForService", v9, *(_QWORD *)(a1 + 2488));
          }
          else
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Usb Host Notification for %@ -- Removing device at index %lu from %@\n", "__WiFiManagerhandleNotificationForService", v9, v33[3], *(_QWORD *)(a1 + 2488));
            objc_autoreleasePoolPop(v23);
            objc_msgSend(*(id *)(a1 + 2488), "removeObjectAtIndex:", v33[3]);
            v23 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Usb Host Notification for %@ seqNum %d managerTotal %d setTotal:%ld\n", "__WiFiManagerhandleNotificationForService", v9, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460), objc_msgSend(*(id *)(a1 + 2488), "count"));
          }
          objc_autoreleasePoolPop(v23);
          _Block_object_dispose(&v32, 8);
        }
        else
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Usb Host Notification for %@ seqNum %d Total %d\n", "__WiFiManagerhandleNotificationForService", v9, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460));
          objc_autoreleasePoolPop(v24);
        }
        if (v6 > *(_DWORD *)(a1 + 2460))
        {
          *(_DWORD *)(a1 + 2456) = 0;
          *(CFAbsoluteTime *)(a1 + 2480) = CFAbsoluteTimeGetCurrent();
          if (v13 == 2)
          {
            ++*(_DWORD *)(a1 + 2460);
          }
          else if (v13 == 3)
          {
            sub_10008BB68(a1);
          }
          v25 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Usb Host Notification metrics usbDevices removal count %lu %@ \n", objc_msgSend(*(id *)(a1 + 2488), "count"), *(_QWORD *)(a1 + 2488));
          objc_autoreleasePoolPop(v25);
          -[WiFiUsageMonitor setUsbStatus:currentDevices:currentNoiseDelta:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setUsbStatus:currentDevices:currentNoiseDelta:", 0, *(_QWORD *)(a1 + 2488), -1);
        }
      }
      v26 = objc_msgSend(*(id *)(a1 + 2496), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", entryID));
      if (v26)
      {
        v27 = v26;
        objc_msgSend(*(id *)(a1 + 2496), "removeObjectForKey:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", entryID));
        v28 = objc_msgSend(v27, "unsignedIntValue");
        if (v28)
          IOObjectRelease(v28);
      }
    }
  }
}

void sub_1000B8548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1000B8560(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id result;

  result = objc_msgSend(a2, "isMemberOfClass:", objc_opt_class(WiFiUsageMonitor_UsbDevice));
  if (a2 && (_DWORD)result)
  {
    result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(_QWORD *)(a1 + 32));
    if ((_DWORD)result)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a3;
      *a4 = 1;
    }
  }
  return result;
}

void sub_1000B85D8(uint64_t a1)
{
  uint64_t v2;
  __CTServerConnection *v3;
  CFTypeRef v4;
  NSObject *v5;
  _QWORD block[10];
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef v10;
  CFTypeRef v11;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32))
  {
    v10 = 0;
    v11 = 0;
    v8 = 0;
    v9 = 0;
    v7 = kCTRegistrationStatusUnknown;
    _CTServerConnectionCopyDataStatus(-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"), 0, &v11);
    _CTServerConnectionGetRegistrationStatus(-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"), &v7);
    _CTServerConnectionCopyProviderNameUsingCarrierBundle(-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"), &v10);
    _CTServerConnectionGetRadioAccessTechnology(-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"), &v8);
    v2 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v2 + 128))
    {
      v3 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
      _CTServerConnectionCopyPacketContextInterfaceNameByServiceType(v3, kCTDataConnectionServiceTypeInternet, &v9);
      v2 = *(_QWORD *)(a1 + 32);
      v4 = v9;
    }
    else
    {
      v4 = 0;
    }
    v5 = *(NSObject **)(v2 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B8734;
    block[3] = &unk_100230AB8;
    block[4] = v4;
    block[5] = v2;
    block[6] = v8;
    block[7] = v11;
    block[8] = v7;
    block[9] = v10;
    dispatch_sync(v5, block);
    if (v11)
    {
      CFRelease(v11);
      v11 = 0;
    }
    if (v10)
    {
      CFRelease(v10);
      v10 = 0;
    }
    if (v9)
      CFRelease(v9);
  }
}

void sub_1000B8734(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const __CFDictionary *v4;
  const __CFString *Value;
  const void *v6;
  int v7;
  const char *v8;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const __CFSet *v20;
  int v21;
  void *v22;
  int v23;
  void *v24;
  void *v25;
  void *v26;
  __CFSet *v27;
  int v28;
  void *v29;
  void *v30;
  int v31;
  void *v32;
  void *v33;
  void *v34;
  BOOL v35;
  char v36;
  char v37;
  uint64_t context;
  unint64_t v39;
  char *v40;
  uint64_t v41;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 1240))
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 40) + 1240));
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1240) = 0;
      v2 = *(const void **)(a1 + 32);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1240) = CFRetain(v2);
    if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 1240))
      -[WiFiUserInteractionMonitor setCellularInterfaceName:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "setCellularInterfaceName:", *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1240));
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 48), kCTRegistrationRadioAccessTechnologyNR, 0) == kCFCompareEqualTo)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (*(_BYTE *)(v3 + 1280) != 1)
    {
      *(_BYTE *)(v3 + 1280) = 1;
      context = v3;
      v39 = 0xAAAAAAAA00000076;
      v40 = 0;
      v41 = 1;
      CFSetApplyFunction(*(CFSetRef *)(v3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    }
  }
  v4 = *(const __CFDictionary **)(a1 + 56);
  if (v4)
  {
    Value = (const __CFString *)CFDictionaryGetValue(v4, kCTRegistrationDataIndicator);
    if (Value)
    {
      v6 = *(const void **)(*(_QWORD *)(a1 + 40) + 1288);
      if (v6)
      {
        CFRelease(v6);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1288) = 0;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1288) = CFStringCreateCopy(kCFAllocatorDefault, Value);
    }
    if (CFStringCompare(Value, kCTRegistrationDataIndicatorNone, 0)
      && CFStringCompare(Value, kCTRegistrationDataIndicator2G, 0)
      && CFStringCompare(Value, kCTRegistrationDataIndicator2_5G, 0))
    {
      v7 = 0;
      v8 = "High bw cellular data available, so WiFi would disconnect under low signal quality";
      v9 = 1;
    }
    else
    {
      v9 = 0;
      v7 = 1;
      v8 = "Low bw cellular data available, so WiFi would stay connected under low signal quality";
    }
    if (CFStringCompare(Value, kCTRegistrationDataIndicator3G, 0) == kCFCompareEqualTo
      || CFStringCompare(Value, kCTRegistrationDataIndicator3_5G, 0) == kCFCompareEqualTo
      || CFStringCompare(Value, kCTRegistrationDataIndicator3_75G, 0) == kCFCompareEqualTo)
    {
      v9 = 0;
    }
    v10 = CFStringCompare(Value, kCTRegistrationDataIndicator5G, 0) == kCFCompareEqualTo
       || CFStringCompare(Value, kCTRegistrationDataIndicator5G_Plus, 0) == kCFCompareEqualTo
       || CFStringCompare(Value, kCTRegistrationDataIndicator5G_Uwb, 0) == kCFCompareEqualTo;
    v11 = *(_QWORD *)(a1 + 40);
    if (*(unsigned __int8 *)(v11 + 1232) != v7)
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v8);
      objc_autoreleasePoolPop(v12);
      v13 = *(_QWORD *)(a1 + 40);
      *(_BYTE *)(v13 + 1232) = v7;
      context = v13;
      v39 = 0xAAAAAAAA00000027;
      v40 = 0;
      v41 = 1;
      CFSetApplyFunction(*(CFSetRef *)(v13 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
      v11 = *(_QWORD *)(a1 + 40);
    }
    objc_msgSend(*(id *)(v11 + 2416), "setCellularDataStatus:inAirplaneMode:", *(_QWORD *)(v11 + 1288), sub_1000B8F2C() != 0);
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v14 = *(_QWORD *)(a1 + 64);
  v15 = kCTRegistrationStatusRegisteredRoaming;
  if (v14 == kCTRegistrationStatusRegisteredRoaming)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: cellular in roaming mode.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
    objc_autoreleasePoolPop(v16);
  }
  v17 = *(const void **)(a1 + 72);
  if (v17)
  {
    v18 = *(const void **)(*(_QWORD *)(a1 + 40) + 1272);
    if (v18)
    {
      if (CFEqual(v18, v17))
        goto LABEL_44;
      v19 = *(const void **)(*(_QWORD *)(a1 + 40) + 1272);
      if (v19)
      {
        CFRelease(v19);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1272) = 0;
      }
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1272) = CFRetain(*(CFTypeRef *)(a1 + 72));
    context = *(_QWORD *)(a1 + 40);
    v39 = 0xAAAAAAAA00000066;
    v40 = 0;
    v41 = 1;
    CFSetApplyFunction(*(CFSetRef *)(context + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  }
LABEL_44:
  v20 = *(const __CFSet **)(*(_QWORD *)(a1 + 40) + 1264);
  if (!v20)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1264) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    if (!v9)
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Initialized with No LTE status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
      objc_autoreleasePoolPop(v24);
      CFSetAddValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatusNoLTE"));
    }
    if (v10)
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Initialized with 5G status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
      objc_autoreleasePoolPop(v25);
      CFSetAddValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatus5GAvailable"));
    }
    if (v14 != v15)
      goto LABEL_91;
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Initialized with roaming status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
    objc_autoreleasePoolPop(v26);
    v27 = *(__CFSet **)(*(_QWORD *)(a1 + 40) + 1264);
    goto LABEL_90;
  }
  v21 = CFSetContainsValue(v20, CFSTR("WiFiCellularDataStatusNoLTE"));
  if (v9)
  {
    if (v21)
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: gained LTE status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
      objc_autoreleasePoolPop(v22);
      CFSetRemoveValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatusNoLTE"));
LABEL_50:
      v23 = 1;
      goto LABEL_65;
    }
  }
  else if (!v21)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lost LTE status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
    objc_autoreleasePoolPop(v33);
    CFSetAddValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatusNoLTE"));
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_100014478(*(_QWORD *)(a1 + 40));
    goto LABEL_50;
  }
  v23 = 0;
LABEL_65:
  v28 = CFSetContainsValue(*(CFSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatus5GAvailable"));
  if (v10)
  {
    if (!v28)
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: gained Cellular 5G status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
      objc_autoreleasePoolPop(v29);
      CFSetAddValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatus5GAvailable"));
LABEL_74:
      v23 = 1;
    }
  }
  else if (v28)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lost Cellular 5G status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
    objc_autoreleasePoolPop(v30);
    CFSetRemoveValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatus5GAvailable"));
    goto LABEL_74;
  }
  v31 = CFSetContainsValue(*(CFSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatusRoaming"));
  if (v14 != v15)
  {
    if (v31)
    {
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lost roaming status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
      objc_autoreleasePoolPop(v32);
      CFSetRemoveValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 1264), CFSTR("WiFiCellularDataStatusRoaming"));
      goto LABEL_91;
    }
LABEL_81:
    if (!v23)
      return;
    goto LABEL_91;
  }
  if (v31)
    goto LABEL_81;
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: gained roaming status.", "__WiFiManagerCellularDataRegistrationCallback_block_invoke_2");
  objc_autoreleasePoolPop(v34);
  v27 = *(__CFSet **)(*(_QWORD *)(a1 + 40) + 1264);
LABEL_90:
  CFSetAddValue(v27, CFSTR("WiFiCellularDataStatusRoaming"));
LABEL_91:
  if (v10 | v9)
    v35 = *(_QWORD *)(a1 + 56) == 0;
  else
    v35 = 1;
  v36 = !v35;
  v37 = v36;
  -[WiFiUserInteractionMonitor setCellularDataStatusMap:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "setCellularDataStatusMap:", *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1264));
  context = *(_QWORD *)(a1 + 40);
  v39 = 0xAAAAAAAA0000008BLL;
  v40 = &v37;
  v41 = 1;
  CFSetApplyFunction(*(CFSetRef *)(context + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
}

uint64_t sub_1000B8F2C()
{
  CFPropertyListRef v0;
  const void *v1;
  CFTypeID v2;
  uint64_t v3;

  v0 = CFPreferencesCopyAppValue(CFSTR("AirplaneModeEnabled"), CFSTR("com.apple.preferences.network"));
  if (!v0)
    return 0;
  v1 = v0;
  v2 = CFGetTypeID(v0);
  if (v2 == CFBooleanGetTypeID())
    v3 = CFEqual(v1, kCFBooleanTrue);
  else
    v3 = 0;
  CFRelease(v1);
  return v3;
}

void sub_1000B8FA8(uint64_t a1, int a2)
{
  void *v2;
  _QWORD context[4];
  int v4;

  v4 = a2;
  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000003ALL;
    context[2] = &v4;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    if (v4 == -536870272)
      -[WiFiUserInteractionMonitor resetBackgroundApps](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "resetBackgroundApps");
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager ref", "__WiFiManagerSetSystemPMState");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000B906C(_QWORD *a1, int a2)
{
  _BOOL4 v4;
  CFBooleanRef v5;
  _BOOL8 v6;
  CFBooleanRef v7;
  const __CFString *v8[5];

  v4 = sub_10003036C(a1, CFSTR("LoggingFileEnabled"), byte_10026DD18);
  if (v4)
    v5 = kCFBooleanTrue;
  else
    v5 = kCFBooleanFalse;
  sub_100087488(a1, CFSTR("LoggingFileEnabled"), v5, a2);
  v6 = sub_10003036C(a1, CFSTR("LoggingFileClassC"), byte_10026DD19);
  if (v6)
    v7 = kCFBooleanTrue;
  else
    v7 = kCFBooleanFalse;
  sub_100087488(a1, CFSTR("LoggingFileClassC"), v7, a2);
  v8[0] = (const __CFString *)sub_10001D90C(a1, CFSTR("LoggingLoggerFile"));
  v8[1] = (const __CFString *)sub_10001D90C(a1, CFSTR("LoggingLoggerSize"));
  v8[2] = (const __CFString *)sub_10001D90C(a1, CFSTR("LoggingLoggerLevel"));
  v8[3] = (const __CFString *)sub_10001D90C(a1, CFSTR("LoggingLoggerLifeSpan"));
  v8[4] = (const __CFString *)sub_10001D90C(a1, CFSTR("LoggingLoggerPrivacy"));
  sub_100080500((uint64_t)a1, v4, v6, v8);
}

uint64_t sub_1000B91CC(_QWORD *a1, unsigned int a2)
{
  void *v4;
  const void **v5;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting airplane mode stickiness preference to %d", "__WiFiManagerSetAirplaneModeStickinessUserPreference", a2);
  objc_autoreleasePoolPop(v4);
  v5 = (const void **)&kCFBooleanTrue;
  if (!a2)
    v5 = (const void **)&kCFBooleanFalse;
  return sub_100087488(a1, CFSTR("KeepWiFiPoweredAirplaneMode"), *v5, 0);
}

uint64_t sub_1000B9268(uint64_t a1, unsigned __int8 *a2)
{
  return sub_1000653E0(a1, *a2);
}

void sub_1000B9270(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    sub_1000663C8(a1, *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 16));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatch24GHzNetworkInCriticalStateEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000B92F4(int a1, int a2, int a3, int a4, uint64_t a5, NSObject **cf)
{
  CFTypeID v10;
  uint64_t v11;
  NSObject *v12;
  void *v14;
  uint64_t v15;
  _QWORD block[5];
  int v17;
  int v18;
  int v19;
  int v20;

  if ((_DWORD)a5)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, result %d", "__WiFiManagerBluetoothServiceCallback", a5);
  }
  else if (cf)
  {
    v10 = CFGetTypeID(cf);
    v11 = qword_10026D658;
    if (!qword_10026D658)
    {
      pthread_once(&stru_10026C9C0, (void (*)(void))sub_1000830F0);
      v11 = qword_10026D658;
    }
    if (v10 == v11)
    {
      v12 = cf[4];
      if (v12)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000B9784;
        block[3] = &unk_100230AF0;
        v17 = a3;
        v18 = a4;
        block[4] = cf;
        v19 = a2;
        v20 = 0;
        dispatch_async(v12, block);
        return;
      }
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager queue null", "__WiFiManagerBluetoothServiceCallback", v15);
    }
    else
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, invalid userData type", "__WiFiManagerBluetoothServiceCallback", v15);
    }
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, null userData", "__WiFiManagerBluetoothServiceCallback", v15);
  }
  objc_autoreleasePoolPop(v14);
}

void sub_1000B94A0(uint64_t a1, int a2, uint64_t a3, NSObject **cf)
{
  CFTypeID v7;
  uint64_t v8;
  NSObject *v9;
  void *v11;
  uint64_t v12;
  _QWORD block[6];
  int v14;

  if ((_DWORD)a3)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, result %d", "__WiFiManagerBluetoothLocalDeviceCallback", a3);
  }
  else if (cf)
  {
    v7 = CFGetTypeID(cf);
    v8 = qword_10026D658;
    if (!qword_10026D658)
    {
      pthread_once(&stru_10026C9C0, (void (*)(void))sub_1000830F0);
      v8 = qword_10026D658;
    }
    if (v7 == v8)
    {
      v9 = cf[4];
      if (v9)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000B9868;
        block[3] = &unk_100230B30;
        v14 = a2;
        block[4] = cf;
        block[5] = a1;
        dispatch_async(v9, block);
        return;
      }
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager queue null", "__WiFiManagerBluetoothLocalDeviceCallback", v12);
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, invalid userData type", "__WiFiManagerBluetoothLocalDeviceCallback", v12);
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, null userData", "__WiFiManagerBluetoothLocalDeviceCallback", v12);
  }
  objc_autoreleasePoolPop(v11);
}

_QWORD *sub_1000B9644(_QWORD *result)
{
  *(_QWORD *)(result[4] + 1032) = result[5];
  *(_QWORD *)(result[4] + 1040) = result[6];
  *(_DWORD *)(result[4] + 1052) = 0;
  return result;
}

void sub_1000B9664(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t (*v6)(int, int, int, CFTypeRef);

  v2 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v2 + 1052) = 0;
  sub_1000B9720(v2, 102, 0);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1032) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1040) = 0;
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    v6 = sub_10008E708;
    v3 = BTSessionAttachWithQueue("com.apple.wifi.manager", &v6, *(_QWORD *)(a1 + 32), qword_10026DD40);
    if ((_DWORD)v3)
    {
      v4 = v3;
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to attach to Mobile Bluetooth result=0x%X", v4);
      objc_autoreleasePoolPop(v5);
    }
  }
}

void sub_1000B9720(uint64_t a1, int a2, int a3)
{
  _QWORD v3[4];

  if (*(_DWORD *)(a1 + 1060) != a2 || *(_DWORD *)(a1 + 1056) != a3)
  {
    *(_DWORD *)(a1 + 1060) = a2;
    *(_DWORD *)(a1 + 1056) = a3;
    v3[0] = a1;
    v3[1] = 0xAAAAAAAA0000000CLL;
    v3[2] = 0;
    v3[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v3);
  }
}

void sub_1000B9784(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  int v5;
  void *v6;

  if (!*(_DWORD *)(a1 + 40))
  {
    v2 = *(_DWORD *)(a1 + 44);
    if (v2 == 11)
    {
      if (*(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 48) != -1)
        return;
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Bluetooth Paging Stopped.");
      objc_autoreleasePoolPop(v6);
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(v4 + 1052) & 0xFFFFFFF7;
    }
    else
    {
      if (v2 || *(_DWORD *)(a1 + 48) != -1)
        return;
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Bluetooth Paging Started.");
      objc_autoreleasePoolPop(v3);
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(v4 + 1052) | 8;
    }
    *(_DWORD *)(v4 + 1052) = v5;
    sub_1000B9720(v4, 102, v5);
  }
}

void sub_1000B9868(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  int v5;
  uint64_t Power;
  uint64_t v7;
  void *v8;
  void *v9;
  int v10;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2)
  {
    if (v2 == 7)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Bluetooth Inquiry Stopped.");
      objc_autoreleasePoolPop(v9);
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(v4 + 1052) & 0xFFFFFFFB;
    }
    else
    {
      if (v2 != 6)
        return;
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Bluetooth Inquiry Started.");
      objc_autoreleasePoolPop(v3);
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(v4 + 1052) | 4;
    }
    *(_DWORD *)(v4 + 1052) = v5;
    sub_1000B9720(v4, 102, v5);
  }
  else
  {
    v10 = -1431655766;
    Power = BTLocalDeviceGetPower(*(_QWORD *)(a1 + 40), &v10);
    if ((_DWORD)Power)
    {
      v7 = Power;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to obtain Bluetooth Local Device power state.  result=0x%X", v7);
      objc_autoreleasePoolPop(v8);
    }
    else
    {
      sub_1000B9720(*(_QWORD *)(a1 + 32), 104, v10 != 0);
    }
  }
}

void sub_1000B99A4(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 184);
  if (v2)
  {
    if (sub_1000D71EC(v2) == 5)
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: pending notification is join recommendation stopping abort", "__WiFiManagerAbortNotifications");
      objc_autoreleasePoolPop(v3);
    }
    else
    {
      sub_1000D7238(*(_QWORD *)(a1 + 184));
      v4 = *(const void **)(a1 + 184);
      if (v4)
      {
        CFRelease(v4);
        *(_QWORD *)(a1 + 184) = 0;
      }
    }
  }
}

void sub_1000B9A3C(uint64_t a1, char a2)
{
  _QWORD context[4];
  char v3;

  v3 = a2;
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000005CLL;
  context[2] = &v3;
  context[3] = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
}

void sub_1000B9A84(uint64_t a1)
{
  sub_10008C888(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void sub_1000B9AB4(uint64_t a1)
{
  sub_100086528(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 0);
}

uint64_t sub_1000B9AC8(uint64_t a1, unsigned __int8 *a2)
{
  return sub_1000667D8(a1, *a2);
}

void sub_1000B9AD0(uint64_t a1)
{
  _BYTE *v2;
  void *v3;
  uint64_t v4;
  _QWORD block[5];

  v2 = *(_BYTE **)(a1 + 32);
  if (!v2[1296])
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting cloud sync engine after exceeding %ds waiting for auto-join attempt", "__WiFiManagerLockStateUpdate_block_invoke", 30);
    objc_autoreleasePoolPop(v3);
    v4 = *(_QWORD *)(a1 + 32);
    *(_BYTE *)(v4 + 1296) = 1;
    WiFiCloudSyncEngineScheduleWithQueue(*(_QWORD *)(v4 + 1304), qword_10026DD48);
    CFRetain(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B9BB4;
    block[3] = &unk_10022EA38;
    block[4] = *(_QWORD *)(a1 + 32);
    dispatch_async((dispatch_queue_t)qword_10026DD48, block);
    v2 = *(_BYTE **)(a1 + 32);
  }
  CFRelease(v2);
}

void sub_1000B9BB4(uint64_t a1)
{
  WiFiCloudSyncEngineCheckKeychainSyncState(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_1000B9BE4(id a1, BOOL a2)
{
  void *v2;

  if (a2)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s retrying to init deviceAnalyticsClient", "__WiFiManagerLockStateUpdate_block_invoke_3");
    objc_autoreleasePoolPop(v2);
    objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient");
  }
}

void sub_1000B9C54(CFArrayRef theArray, const void *a2, CFIndex *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  void *v10;

  if (a3)
  {
    *a3 = -1;
    if (theArray)
    {
      Count = CFArrayGetCount(theArray);
      if (Count)
      {
        v7 = Count;
        if (Count < 1)
        {
          v8 = 0;
        }
        else
        {
          v8 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
            if (sub_1000C5F98((uint64_t)a2, (uint64_t)ValueAtIndex))
              break;
            if (v7 == ++v8)
              goto LABEL_12;
          }
          *a3 = v8;
        }
        if (v8 == v7)
        {
LABEL_12:
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@ not found", "__GetNetworkWithSameSsid", sub_10002B088(a2));
          objc_autoreleasePoolPop(v10);
        }
      }
    }
  }
}

void sub_1000B9D58(uint64_t a1, const void **a2)
{
  sub_1000667E4(a1, *a2);
}

void sub_1000B9D60(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *(NSObject **)(qword_10026D680 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000B9F4C;
  v3[3] = &unk_10022EF88;
  v3[4] = a2;
  v3[5] = qword_10026D680;
  dispatch_async(v2, v3);
}

void sub_1000B9DBC(_QWORD *a1, const void *a2)
{
  void *v4;
  id v5;
  void *v6;
  NSMutableDictionary *v7;
  void *v8;
  void *v9;
  NSMutableDictionary *v10;
  NSMutableDictionary *v11;

  if (a1)
  {
    v4 = (void *)sub_10002B088(a2);
    v5 = objc_msgSend(v4, "stringByAppendingString:", sub_1000CB154((uint64_t)a2));
    v6 = objc_autoreleasePoolPush();
    v7 = objc_opt_new(NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", +[NSDate date](NSDate, "date"), CFSTR("timestamp"));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", sub_1000CB154((uint64_t)a2), CFSTR("bundleID"));
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Add item:%@ at sessionKey:%@", "__WiFiManagerAddSessionBasedNetwork", v7, v5);
    objc_autoreleasePoolPop(v8);
    v9 = (void *)a1[202];
    if (v9)
      v10 = (NSMutableDictionary *)objc_msgSend(v9, "mutableCopy");
    else
      v10 = objc_opt_new(NSMutableDictionary);
    v11 = v10;
    -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v7, v5);
    sub_100087488(a1, CFSTR("SessionBasedNetworkList"), v11, 0);
    sub_1000A3300((uint64_t)a1, v11);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "__WiFiManagerAddSessionBasedNetwork");
  }
  objc_autoreleasePoolPop(v6);
}

void sub_1000B9F4C(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *ValueAtIndex;
  void *v5;
  id v6;
  void *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  void *v12;
  void *v13;
  char v14;
  uint64_t v15;
  void *v16;
  unsigned int v17;
  _QWORD *v18;
  uint64_t v19;
  __CFRunLoop *Main;
  uint64_t v21;
  const void *v22;
  const void *v23;
  void *v24;
  _QWORD context[4];

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: response %lu", "__WiFiManagerAddNetworkAsyncUserNotificationCallback_block_invoke", *(_QWORD *)(a1 + 32));
  objc_autoreleasePoolPop(v2);
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 1688), 0);
    if (ValueAtIndex)
    {
      v5 = ValueAtIndex;
      v6 = objc_msgSend(ValueAtIndex, "network");
      if (v6)
      {
        v7 = v6;
        v8 = objc_msgSend(v5, "client");
        v9 = *(_QWORD *)(a1 + 32);
        if (v9 == 3)
        {
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System cancelled user notification.");
          objc_autoreleasePoolPop(v13);
          v14 = 0;
          v15 = 2;
        }
        else if (v9 == 1)
        {
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User did not give consent to add network.");
          objc_autoreleasePoolPop(v16);
          v14 = 0;
          v15 = 1;
        }
        else if (v9)
        {
          v14 = 0;
          v15 = 0x7FFFFFFFLL;
        }
        else
        {
          v10 = 25;
          if (objc_msgSend(v5, "originator") != 1)
          {
            if (objc_msgSend(v5, "originator") == 6)
              v10 = 25;
            else
              v10 = 8;
          }
          v11 = sub_1000CFC28((uint64_t)v7);
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User gave consent to add network (sessionBased=%d, isAccessory=%d)", objc_msgSend(v5, "sessionBased"), v11 != 0);
          objc_autoreleasePoolPop(v12);
          if (v11)
          {
            sub_100094420(*(_QWORD *)(a1 + 40), v7, v10);
            sub_1000B9DBC(*(_QWORD **)(a1 + 40), v7);
          }
          else
          {
            v17 = objc_msgSend(v5, "sessionBased");
            v18 = *(_QWORD **)(a1 + 40);
            if (v17)
            {
              sub_1000B9DBC(v18, v7);
              sub_100095360(v7);
            }
            else
            {
              sub_100094420((uint64_t)v18, v7, v10);
            }
          }
          if (sub_10002DA5C((_BOOL8)v7))
          {
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping association for HS20 network", "__WiFiManagerAddNetworkAsyncUserNotificationCallback_block_invoke");
            objc_autoreleasePoolPop(v24);
            v14 = 0;
            v15 = 0;
          }
          else
          {
            v19 = *(_QWORD *)(a1 + 40);
            if (!*(_DWORD *)(v19 + 316))
            {
              sub_100093358(v19, 1, 0);
              v19 = *(_QWORD *)(a1 + 40);
            }
            context[0] = v19;
            context[1] = 0xAAAAAAAA00000045;
            context[2] = v7;
            context[3] = 0;
            CFSetApplyFunction(*(CFSetRef *)(v19 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
            v15 = 0x7FFFFFFFLL;
            v14 = 1;
          }
        }
        if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 1640))
        {
          Main = CFRunLoopGetMain();
          CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(*(_QWORD *)(a1 + 40) + 1640), kCFRunLoopDefaultMode);
        }
        if ((v14 & 1) == 0)
        {
          if (v8)
            sub_100066564((uint64_t)v8, *(_QWORD *)(a1 + 40), (uint64_t)v7, v15);
          if (objc_msgSend(v5, "callback"))
            ((void (*)(_QWORD, id, uint64_t, id))objc_msgSend(v5, "callback"))(*(_QWORD *)(a1 + 40), objc_msgSend(v5, "network"), v15, objc_msgSend(v5, "context"));
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 1688), 0);
          sub_100098854(*(_QWORD *)(a1 + 40));
        }
      }
    }
    v21 = *(_QWORD *)(a1 + 40);
    if (v21)
    {
      v22 = *(const void **)(v21 + 1640);
      if (v22)
      {
        CFRelease(v22);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1640) = 0;
        v21 = *(_QWORD *)(a1 + 40);
      }
      v23 = *(const void **)(v21 + 1648);
      if (v23)
      {
        CFRelease(v23);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1648) = 0;
      }
    }
  }
}

void sub_1000BA2C8(uint64_t a1)
{
  const void *v2;

  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    CNForgetSSID();
    v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void sub_1000BA318(int a1, CFMutableStringRef theString)
{
  if ((a1 & 1) != 0)
  {
    CFStringAppend(theString, CFSTR(" Pwr"));
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 0x800000) == 0)
        goto LABEL_4;
      goto LABEL_24;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }
  CFStringAppend(theString, CFSTR(" Lnk"));
  if ((a1 & 0x800000) == 0)
  {
LABEL_4:
    if ((a1 & 4) == 0)
      goto LABEL_5;
    goto LABEL_25;
  }
LABEL_24:
  CFStringAppend(theString, CFSTR(" AuJo"));
  if ((a1 & 4) == 0)
  {
LABEL_5:
    if ((a1 & 8) == 0)
      goto LABEL_6;
    goto LABEL_26;
  }
LABEL_25:
  CFStringAppend(theString, CFSTR(" Att"));
  if ((a1 & 8) == 0)
  {
LABEL_6:
    if ((a1 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_27;
  }
LABEL_26:
  CFStringAppend(theString, CFSTR(" Rmv"));
  if ((a1 & 0x10) == 0)
  {
LABEL_7:
    if ((a1 & 0x20) == 0)
      goto LABEL_8;
    goto LABEL_28;
  }
LABEL_27:
  CFStringAppend(theString, CFSTR(" Prf"));
  if ((a1 & 0x20) == 0)
  {
LABEL_8:
    if ((a1 & 0x40) == 0)
      goto LABEL_9;
    goto LABEL_29;
  }
LABEL_28:
  CFStringAppend(theString, CFSTR(" Not"));
  if ((a1 & 0x40) == 0)
  {
LABEL_9:
    if ((a1 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_30;
  }
LABEL_29:
  CFStringAppend(theString, CFSTR(" ScCu"));
  if ((a1 & 0x80) == 0)
  {
LABEL_10:
    if ((a1 & 0x100) == 0)
      goto LABEL_11;
    goto LABEL_31;
  }
LABEL_30:
  CFStringAppend(theString, CFSTR(" ScUpFu"));
  if ((a1 & 0x100) == 0)
  {
LABEL_11:
    if ((a1 & 0x400) == 0)
      goto LABEL_12;
    goto LABEL_32;
  }
LABEL_31:
  CFStringAppend(theString, CFSTR(" ScUpTr"));
  if ((a1 & 0x400) == 0)
  {
LABEL_12:
    if ((a1 & 0x8000) == 0)
      goto LABEL_13;
    goto LABEL_33;
  }
LABEL_32:
  CFStringAppend(theString, CFSTR(" Bss"));
  if ((a1 & 0x8000) == 0)
  {
LABEL_13:
    if ((a1 & 0x800) == 0)
      goto LABEL_14;
    goto LABEL_34;
  }
LABEL_33:
  CFStringAppend(theString, CFSTR(" DiagSta"));
  if ((a1 & 0x800) == 0)
  {
LABEL_14:
    if ((a1 & 0x1000) == 0)
      goto LABEL_15;
    goto LABEL_35;
  }
LABEL_34:
  CFStringAppend(theString, CFSTR(" ResSc"));
  if ((a1 & 0x1000) == 0)
  {
LABEL_15:
    if ((a1 & 0x2000) == 0)
      goto LABEL_16;
    goto LABEL_36;
  }
LABEL_35:
  CFStringAppend(theString, CFSTR(" bgS"));
  if ((a1 & 0x2000) == 0)
  {
LABEL_16:
    if ((a1 & 0x4000) == 0)
      goto LABEL_17;
    goto LABEL_37;
  }
LABEL_36:
  CFStringAppend(theString, CFSTR(" WowEn"));
  if ((a1 & 0x4000) == 0)
  {
LABEL_17:
    if ((a1 & 0x80000000) == 0)
      goto LABEL_18;
    goto LABEL_38;
  }
LABEL_37:
  CFStringAppend(theString, CFSTR(" LQM"));
  if ((a1 & 0x80000000) == 0)
  {
LABEL_18:
    if ((a1 & 0x10000) == 0)
      goto LABEL_19;
    goto LABEL_39;
  }
LABEL_38:
  CFStringAppend(theString, CFSTR(" WeightAvgLQM"));
  if ((a1 & 0x10000) == 0)
  {
LABEL_19:
    if ((a1 & 0x20000) == 0)
      goto LABEL_20;
    goto LABEL_40;
  }
LABEL_39:
  CFStringAppend(theString, CFSTR(" Rst"));
  if ((a1 & 0x20000) == 0)
  {
LABEL_20:
    if ((a1 & 0x40000) == 0)
      return;
LABEL_41:
    CFStringAppend(theString, CFSTR(" VrtR"));
    return;
  }
LABEL_40:
  CFStringAppend(theString, CFSTR(" VrtA"));
  if ((a1 & 0x40000) != 0)
    goto LABEL_41;
}

intptr_t sub_1000BA51C(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Device Analytics Store File:%@", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse_block_invoke", a2);
    objc_autoreleasePoolPop(v4);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(objc_alloc((Class)NSString), "initWithString:", a2);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t sub_1000BA5B0(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (a2)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithDictionary:", a2);
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updated configuration with %s", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse_block_invoke_2", -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), a2), "UTF8String"));
    objc_autoreleasePoolPop(v4);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000BA668(uint64_t a1, uint64_t val)
{
  NSObject *v4;
  void *v5;
  void *v6;
  _QWORD block[6];
  uint64_t state64;

  state64 = 0;
  if (notify_is_valid_token(val))
  {
    notify_get_state(val, &state64);
    v4 = *(NSObject **)(a1 + 32);
    if (v4)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000BA778;
      block[3] = &unk_10022EF88;
      block[4] = a1;
      block[5] = state64;
      dispatch_async(v4, block);
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probably WiFiManager is in middle of closing.", "__WiFiManagerNotifyBatterySaverModeConfiguration");
      objc_autoreleasePoolPop(v5);
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid token %d", "__WiFiManagerNotifyBatterySaverModeConfiguration", val);
    objc_autoreleasePoolPop(v6);
  }
}

void sub_1000BA778(uint64_t a1)
{
  sub_1000AD4A8(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_1000BA788(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  unsigned int v7;
  void *v8;
  NSData *v9;
  void *v10;
  void *v11;
  unsigned int v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 1952))
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join disabled location update received", "__WiFiManagerLocationManagerCallback_block_invoke");
    objc_autoreleasePoolPop(v3);
    v4 = *(_QWORD *)(a1 + 32);
    v5 = objc_autoreleasePoolPush();
    if (v4)
    {
      if (*(_BYTE *)(v4 + 1952))
      {
        if (!sub_10000AF8C(v4))
        {
          v6 = objc_msgSend(objc_msgSend(*(id *)(v4 + 1696), "latestLocation"), "copy");
          v7 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v6, 1, 60.0);
          v8 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location update %@ isValid %d", "__WiFiManagerUserAutoJoinDisabledLocationUpdate", v6, v7 != 0);
          objc_autoreleasePoolPop(v8);
          if (v7)
          {
            v9 = +[NSKeyedArchiver archivedDataWithRootObject:](NSKeyedArchiver, "archivedDataWithRootObject:", v6);
            if (v9)
            {
              sub_100087488((_QWORD *)v4, CFSTR("UserAutoJoinDisabledLoc"), v9, 0);
            }
            else
            {
              v11 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create archive of location", "__WiFiManagerUserAutoJoinDisabledLocationUpdate");
              objc_autoreleasePoolPop(v11);
            }
            *(_QWORD *)(v4 + 1960) = v6;
            *(_WORD *)(v4 + 1952) = 0;
          }
          else
          {
            v10 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location update is not high accuracy", "__WiFiManagerUserAutoJoinDisabledLocationUpdate");
            objc_autoreleasePoolPop(v10);
            if (v6)
              CFRelease(v6);
            *(_BYTE *)(v4 + 1953) = 1;
          }
          goto LABEL_21;
        }
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join is not disabled, location update not required", "__WiFiManagerUserAutoJoinDisabledLocationUpdate");
      }
      else
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join is not waiting on a location update", "__WiFiManagerUserAutoJoinDisabledLocationUpdate");
      }
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "__WiFiManagerUserAutoJoinDisabledLocationUpdate");
    }
    objc_autoreleasePoolPop(v15);
LABEL_21:
    objc_autoreleasePoolPop(v5);
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (*(_BYTE *)(v2 + 1704))
  {
    v16 = objc_msgSend(objc_msgSend(*(id *)(v2 + 1696), "latestLocation"), "copy");
    v12 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v16, 1, 60.0);
    +[WiFiLocationManager logLocation:addPrefixString:](WiFiLocationManager, "logLocation:addPrefixString:", v16, CFSTR("__WiFiManagerLocationManagerCallback"));
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isValid %d", "__WiFiManagerLocationManagerCallback_block_invoke", v12 != 0);
    objc_autoreleasePoolPop(v13);
    sub_1000B6D14(*(const __CFArray **)(a1 + 32), v16);

  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no network waiting to be tagged", "__WiFiManagerLocationManagerCallback_block_invoke");
    objc_autoreleasePoolPop(v14);
  }
}

BOOL sub_1000BAAD4(uint64_t a1)
{
  _BOOL8 result;

  result = sub_100167AF8(*(_QWORD *)(a1 + 32) + 1800, 1);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 1808) = result;
  return result;
}

void sub_1000BAB08(uint64_t a1, const void **a2)
{
  sub_100066728(a1, *(unsigned __int8 *)a2, a2[1]);
}

BOOL sub_1000BAB18(const __SCNetworkSet *a1, const __CFArray *a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  BOOL v6;
  CFIndex v7;
  const __SCNetworkService *ValueAtIndex;
  const __SCNetworkService *v9;
  void *v10;
  const __SCNetworkInterface *Interface;
  CFStringRef InterfaceType;
  unsigned int v13;
  void *v14;
  uint64_t v16;
  CFRange v17;

  v4 = SCNetworkSetCopyServices(a1);
  if (v4)
  {
    v5 = v4;
    if (CFArrayGetCount(v4) >= 1)
    {
      v6 = 0;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v5, v7);
        if (ValueAtIndex)
        {
          v9 = ValueAtIndex;
          if (a2 && (v17.length = CFArrayGetCount(a2), v17.location = 0, CFArrayContainsValue(a2, v17, v9)))
          {
            v10 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: service ID %@ found in exclude list. Not removing it.", "__WiFiManagerRemoveMatchingServiceForSet", SCNetworkServiceGetServiceID(v9), v16);
          }
          else
          {
            Interface = SCNetworkServiceGetInterface(v9);
            if (!Interface)
              goto LABEL_15;
            InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
            if (!InterfaceType || !CFEqual(InterfaceType, kSCNetworkInterfaceTypeIEEE80211))
              goto LABEL_15;
            v13 = SCNetworkServiceRemove(v9);
            v6 = (v6 | v13) != 0;
            v10 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: service removal status for set %@: %d", "__WiFiManagerRemoveMatchingServiceForSet", SCNetworkSetGetSetID(a1), v13);
          }
          objc_autoreleasePoolPop(v10);
        }
LABEL_15:
        if (++v7 >= CFArrayGetCount(v5))
          goto LABEL_21;
      }
    }
    v6 = 0;
LABEL_21:
    CFRelease(v5);
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no services", "__WiFiManagerRemoveMatchingServiceForSet");
    objc_autoreleasePoolPop(v14);
    return 0;
  }
  return v6;
}

uint64_t sub_1000BACF0(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: sc prefs clean up done !!", "__WiFiManagerRemoveSCNetworkSets_block_invoke");
  objc_autoreleasePoolPop(v2);
  return sub_100093FA0(*(_QWORD **)(a1 + 32), CFSTR("IsOrphanedSCCleanUpRequired"), kCFBooleanFalse);
}

void sub_1000BAD6C(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  _QWORD v5[7];

  v2 = objc_alloc_init((Class)FAFetchFamilyCircleRequest);
  if (v2)
  {
    v3 = v2;
    objc_msgSend(v2, "setCachePolicy:", 0);
    v4 = *(_QWORD *)(a1 + 40);
    *(_BYTE *)(v4 + 2217) = 1;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1000BAE10;
    v5[3] = &unk_100230BE8;
    v5[5] = v3;
    v5[6] = v4;
    v5[4] = *(_QWORD *)(a1 + 32);
    objc_msgSend(v3, "startRequestWithCompletionHandler:", v5);
  }
  else
  {

  }
}

void sub_1000BAE10(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  void *v12;
  NSNumber *v13;
  void *v14;
  id v15;
  uint64_t v16;
  void *i;
  void *v18;
  NSNumber *v19;
  id v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  void *v24;
  uint64_t v25;
  id v26;
  uint64_t v27;
  id v28;
  _QWORD block[6];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  void (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t);
  uint64_t v43;
  _BYTE v44[128];
  _BYTE v45[128];

  v38 = 0;
  v39 = &v38;
  v40 = 0x3052000000;
  v41 = sub_10002FA68;
  v42 = sub_10002F978;
  v43 = 0;
  if (a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error loading family members: %@", "__WiFiManagerUpdateFamilyPreferences_block_invoke_2", a3);
    objc_autoreleasePoolPop(v5);
    if (objc_msgSend(a3, "code") != (id)-1004)
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + 2217) = 0;
  }
  else if (a2)
  {
    v7 = objc_alloc_init((Class)NSMutableArray);
    v39[5] = (uint64_t)v7;
    if ((unint64_t)objc_msgSend(objc_msgSend(a2, "members"), "count") >= 2)
      *(_DWORD *)(*(_QWORD *)(a1 + 48) + 340) = 2;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v8 = objc_msgSend(a2, "members");
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v34, v45, 16);
    if (v9)
    {
      v10 = *(_QWORD *)v35;
      v26 = v8;
      v27 = a1;
      v25 = *(_QWORD *)v35;
      do
      {
        v11 = 0;
        v28 = v9;
        do
        {
          if (*(_QWORD *)v35 != v10)
            objc_enumerationMutation(v8);
          v12 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)v11);
          if ((objc_msgSend(v12, "isMe") & 1) == 0)
          {
            v13 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 1);
            v32 = 0u;
            v33 = 0u;
            v30 = 0u;
            v31 = 0u;
            v14 = *(void **)(a1 + 32);
            v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v30, v44, 16);
            if (v15)
            {
              v16 = *(_QWORD *)v31;
              while (2)
              {
                for (i = 0; i != v15; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v31 != v16)
                    objc_enumerationMutation(v14);
                  v18 = *(void **)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)i);
                  if (objc_msgSend(objc_msgSend(v12, "altDSID"), "isEqual:", objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("FamilyHotspotIdentifier"))))
                  {
                    v19 = (NSNumber *)objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("FamilyHotspotSharingMode"));
                    v8 = v26;
                    a1 = v27;
                    v9 = v28;
                    v10 = v25;
                    v13 = v19;
                    if (-[NSNumber intValue](v19, "intValue") == 1)
                      *(_DWORD *)(*(_QWORD *)(v27 + 48) + 340) = 1;
                    goto LABEL_26;
                  }
                }
                v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v30, v44, 16);
                if (v15)
                  continue;
                break;
              }
              v8 = v26;
              a1 = v27;
              v9 = v28;
              v10 = v25;
            }
LABEL_26:
            v20 = objc_alloc_init((Class)NSMutableDictionary);
            objc_msgSend(v20, "setObject:forKey:", objc_msgSend(v12, "altDSID"), CFSTR("FamilyHotspotIdentifier"));
            objc_msgSend(v20, "setObject:forKey:", objc_msgSend(v12, "wifiDisplayName"), CFSTR("FamilyHotspotDisplayName"));
            objc_msgSend(v20, "setObject:forKey:", v13, CFSTR("FamilyHotspotSharingMode"));
            v21 = (void *)v39[5];
            if (v21)
              objc_msgSend(v21, "addObject:", v20);

          }
          v11 = (char *)v11 + 1;
        }
        while (v11 != v9);
        v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v34, v45, 16);
      }
      while (v9);
    }
    if (v39[5])
    {
      v22 = *(_QWORD *)(a1 + 48);
      v23 = *(NSObject **)(v22 + 32);
      if (v23)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000BB270;
        block[3] = &unk_10022F160;
        block[4] = &v38;
        block[5] = v22;
        dispatch_async(v23, block);
      }
      else
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null runloop.", "__WiFiManagerUpdateFamilyPreferences_block_invoke_2");
        objc_autoreleasePoolPop(v24);

      }
    }
  }

  _Block_object_dispose(&v38, 8);
}

void sub_1000BB230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Unwind_Resume(a1);
}

void sub_1000BB270(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting family hotspot preference %@", "__WiFiManagerUpdateFamilyPreferences_block_invoke_3", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  objc_autoreleasePoolPop(v2);
  sub_1000A6014(*(_QWORD **)(a1 + 40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));

}

void sub_1000BB2F8(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD block[6];

  if (a3)
  {
    v4 = objc_msgSend(a2, "length");
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (v4)
    {
      *(_BYTE *)(v5 + 24) = 1;
      goto LABEL_6;
    }
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  *(_BYTE *)(v5 + 24) = 0;
LABEL_6:
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Backhaul link status : %hhu", *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  objc_autoreleasePoolPop(v6);
  v8 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  v9 = *(NSObject **)(v7 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BB3CC;
  block[3] = &unk_10022F160;
  block[4] = v8;
  block[5] = v7;
  dispatch_async(v9, block);
}

void sub_1000BB3CC(uint64_t a1)
{
  sub_1000AC08C(*(_QWORD *)(a1 + 40), *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
}

BOOL sub_1000BB3E4(const __CFData *a1, const __CFData *a2)
{
  const UInt8 *BytePtr;
  const UInt8 *v4;
  _BOOL8 result;
  uint8x8_t v6;
  uint8x8_t v7;
  __int32 v8;
  BOOL v9;
  __int32 v11;
  __int16 v12;
  __int32 v13;
  __int16 v14;

  BytePtr = CFDataGetBytePtr(a1);
  v13 = *(_DWORD *)BytePtr;
  v14 = *((_WORD *)BytePtr + 2);
  v4 = CFDataGetBytePtr(a2);
  result = 0;
  v11 = *(_DWORD *)v4;
  v12 = *((_WORD *)v4 + 2);
  v6.i32[0] = v13;
  v7 = (uint8x8_t)vmovn_s16((int16x8_t)vmovl_u8(v6));
  v8 = v7.i32[0] | v14;
  v7.i32[0] = *(_DWORD *)v4;
  v9 = (vmovn_s16((int16x8_t)vmovl_u8(v7)).u32[0] | v12 | HIBYTE(v12)) == 0;
  if (v8 | HIBYTE(v14) && !v9)
    return v13 == v11 && v14 == v12;
  return result;
}

void sub_1000BB4B0(uint64_t a1)
{
  _QWORD v1[4];

  v1[0] = *(_QWORD *)(a1 + 32);
  v1[1] = 0xAAAAAAAA00000009;
  v1[2] = 0;
  v1[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(v1[0] + 104), (CFSetApplierFunction)sub_10002E0D4, v1);
}

const __CFString *sub_1000BBE04(int a1)
{
  if ((a1 - 2) > 3)
    return CFSTR("None");
  else
    return off_100230DC0[a1 - 2];
}

void sub_1000BBFD0(uint64_t a1, void *a2)
{
  uint64_t v4;
  void *v5;
  NSObject *v6;
  _QWORD block[5];

  if (a2 && objc_msgSend(a2, "confidence") == (id)2)
  {
    objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 5);
    if (objc_msgSend(a2, "automotive"))
      objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 4);
    if (objc_msgSend(a2, "stationary"))
    {
      if (objc_msgSend(a2, "automotive"))
        v4 = 6;
      else
        v4 = 1;
      objc_msgSend(*(id *)(a1 + 32), "setMotionState:", v4);
    }
    if (objc_msgSend(a2, "walking"))
      objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 2);
    if (objc_msgSend(a2, "running"))
      objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 3);
    if (objc_msgSend(*(id *)(a1 + 32), "motionState") == 4
      || objc_msgSend(*(id *)(a1 + 32), "motionState") == 6)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s [MOTION] MotionState: %@ - (%@)", "-[WiFiManagerMotionServices startMonitoringMotionState]_block_invoke", sub_100024674((int)objc_msgSend(*(id *)(a1 + 32), "motionState")), a2);
      objc_autoreleasePoolPop(v5);
    }
    objc_msgSend(objc_msgSend(a2, "startDate"), "timeIntervalSinceReferenceDate");
    objc_msgSend(*(id *)(a1 + 32), "setMotionStartTime:");
    v6 = objc_msgSend(*(id *)(a1 + 32), "queue");
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000BC15C;
    block[3] = &unk_10022EEE8;
    block[4] = *(_QWORD *)(a1 + 32);
    dispatch_async(v6, block);
  }
}

id sub_1000BC15C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchMotionCallback");
}

id sub_1000BC430(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  NSObject *v6;
  _QWORD block[5];

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: [MOTION] Walking Started alarm triggered, error %@", "-[WiFiManagerMotionServices setupWalkingStartedAlarm]_block_invoke", a3);
  objc_autoreleasePoolPop(v5);
  objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 2);
  v6 = objc_msgSend(*(id *)(a1 + 32), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BC4F4;
  block[3] = &unk_10022EEE8;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async(v6, block);
  return objc_msgSend(*(id *)(a1 + 32), "setupWalkingEndedAlarm");
}

id sub_1000BC4F4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchMotionCallback");
}

id sub_1000BC660(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  NSObject *v6;
  _QWORD block[5];

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: [MOTION] Walking Ended alarm triggered, error %@", "-[WiFiManagerMotionServices setupWalkingEndedAlarm]_block_invoke", a3);
  objc_autoreleasePoolPop(v5);
  objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 2);
  v6 = objc_msgSend(*(id *)(a1 + 32), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BC724;
  block[3] = &unk_10022EEE8;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async(v6, block);
  return objc_msgSend(*(id *)(a1 + 32), "setupWalkingStartedAlarm");
}

id sub_1000BC724(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchMotionCallback");
}

id sub_1000BC890(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  NSObject *v6;
  _QWORD block[5];

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: [MOTION] driving started alarm triggered........., error %@", "-[WiFiManagerMotionServices setupDrivingStartedAlarm]_block_invoke", a3);
  objc_autoreleasePoolPop(v5);
  objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 4);
  v6 = objc_msgSend(*(id *)(a1 + 32), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BC954;
  block[3] = &unk_10022EEE8;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async(v6, block);
  return objc_msgSend(*(id *)(a1 + 32), "setupDrivingEndedAlarm");
}

id sub_1000BC954(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchMotionCallback");
}

id sub_1000BCAC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  NSObject *v6;
  _QWORD block[5];

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: [MOTION] Driving ended alarm triggered..........., error %@", "-[WiFiManagerMotionServices setupDrivingEndedAlarm]_block_invoke", a3);
  objc_autoreleasePoolPop(v5);
  objc_msgSend(*(id *)(a1 + 32), "setMotionState:", 2);
  v6 = objc_msgSend(*(id *)(a1 + 32), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BCB84;
  block[3] = &unk_10022EEE8;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async(v6, block);
  return objc_msgSend(*(id *)(a1 + 32), "setupDrivingStartedAlarm");
}

id sub_1000BCB84(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchMotionCallback");
}

WiFiManagerMotionServices *sub_1000BCC6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  WiFiManagerMotionServices *v7;
  WiFiManagerMotionServices *v8;
  void *v10;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerMotionServicesInitialize");
    goto LABEL_12;
  }
  if (!a3)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null motionStateChangeCb", "WiFiManagerMotionServicesInitialize");
    goto LABEL_12;
  }
  v7 = objc_alloc_init(WiFiManagerMotionServices);
  if (!v7)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: motionServices is null", "WiFiManagerMotionServicesInitialize");
LABEL_12:
    objc_autoreleasePoolPop(v10);
    v8 = 0;
    goto LABEL_5;
  }
  v8 = v7;
  -[WiFiManagerMotionServices setManager:](v7, "setManager:", a1);
  -[WiFiManagerMotionServices setMotionStateChangeCb:](v8, "setMotionStateChangeCb:", a3);
  -[WiFiManagerMotionServices setQueue:](v8, "setQueue:", a2);
  -[WiFiManagerMotionServices startMonitoringMotionState](v8, "startMonitoringMotionState");
LABEL_5:
  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_1000BCDA4(void *a1)
{
  void *v2;
  void *v3;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    objc_msgSend(a1, "stopMonitoringMotionState");

  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null motionServices", "WiFiManagerMotionServicesEnd");
    objc_autoreleasePoolPop(v3);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000BCE24(_QWORD *a1, NSObject *a2)
{
  DIR *v4;
  NSObject *v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  void *v11;
  NSObject *v12;
  NSObject *v13;
  dispatch_time_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *((_BYTE *)a1 + 48) = 0;
  if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
    *((_BYTE *)a1 + 48) = 1;
  *((_BYTE *)a1 + 8) = 0;
  v4 = opendir("/private/var/dextcores");
  if (v4)
  {
    *a1 = "/private/var/dextcores";
    closedir(v4);
  }
  else
  {
    *a1 = "/private/var/cores";
  }
  a1[3] = a2;
  v5 = a2;
  v6 = sub_100167440();
  if (v6)
    v7 = v6;
  else
    v7 = 5;
  *((_DWORD *)a1 + 9) = v7;
  v8 = sub_1001673F8();
  if (v8)
    v9 = v8;
  else
    v9 = 360;
  *((_DWORD *)a1 + 8) = v9;
  v22 = 9221;
  v10 = fsctl((const char *)*a1, 0xC0084A44uLL, &v22, 0);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s fsctl for %s returns %d", "WiFiDextCrashMarkCoreFilesPurgable", *a1, v10);
  objc_autoreleasePoolPop(v11);
  if (*((int *)a1 + 8) > 1440)
    goto LABEL_17;
  v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
  a1[2] = v12;
  if (v12)
  {
    dispatch_set_context(v12, a1);
    dispatch_source_set_event_handler_f((dispatch_source_t)a1[2], (dispatch_function_t)sub_100167488);
    dispatch_activate((dispatch_object_t)a1[2]);
    v13 = a1[2];
    v14 = dispatch_time(0, 10000000000);
    dispatch_source_set_timer(v13, v14, 60000000000 * *((int *)a1 + 8), 0x8BB2C97000uLL);
LABEL_17:
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s  timer enabled:%d startTime:%d period:%d (min) leeway:%d (min) maxFiles:%d corefile_directory:%s", "WiFiDextCrashProcessInit", *((_DWORD *)a1 + 8) < 1441, 10, *((unsigned int *)a1 + 8), 10, *((unsigned int *)a1 + 9), *a1);
    goto LABEL_19;
  }
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create dextcrash handling timer", "WiFiDextCrashProcessInit", v16, v17, v18, v19, v20, v21);
LABEL_19:
  objc_autoreleasePoolPop(v15);
}

void sub_1000BD050(uint64_t a1)
{
  NSObject *v2;
  void *v3;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {

    *(_QWORD *)(a1 + 24) = 0;
  }
}

void sub_1000BDE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000BE774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000BE798(id a1, int64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to register for periodic RSSI updates from P2PD %d", a2);
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000BE7F4(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  const char *v9;
  id WeakRetained;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t, uint64_t, id, id, id, id, void *, int);
  id v23;

  v23 = a2;
  v3 = objc_autoreleasePoolPush();
  v4 = (void *)qword_10026DD20;
  if (!v23)
  {
    if (!qword_10026DD20)
      goto LABEL_12;
    v9 = "generateCurrentNetworkRecordForInternetSharingSession returns NULL Dictionary";
LABEL_11:
    objc_msgSend(v4, "WFLog:message:", 3, v9, v21);
    goto LABEL_12;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "generateCurrentNetworkRecordForInternetSharingSession returns non NULL dictionary");
  objc_autoreleasePoolPop(v3);
  v5 = objc_msgSend(v23, "copy");
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(void **)(v6 + 168);
  *(_QWORD *)(v6 + 168) = v5;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168);
  v3 = objc_autoreleasePoolPush();
  v4 = (void *)qword_10026DD20;
  if (!v8)
  {
    if (!qword_10026DD20)
      goto LABEL_12;
    v9 = "_curNetworkRecord is NULL ";
    goto LABEL_11;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dump Current NAN BSS Info Dictionary : %@ ", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168));
LABEL_12:
  objc_autoreleasePoolPop(v3);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (objc_msgSend(WeakRetained, "staDatapathEstablishedcallback"))
  {
    v22 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, id, id, id, id, void *, int))objc_msgSend(WeakRetained, "staDatapathEstablishedcallback");
    v11 = *(_QWORD **)(a1 + 32);
    v12 = v11[14];
    v13 = v11[18];
    v14 = v11[19];
    v15 = v11[20];
    v16 = objc_msgSend(WeakRetained, "establishedLinkNetwork");
    v17 = objc_msgSend(WeakRetained, "linkEstablishedCallbackContext");
    v18 = objc_msgSend(WeakRetained, "nanAssocData");
    v19 = objc_msgSend(WeakRetained, "isAutoJoined");
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "waDiscoveryResult"));
    v22(v13, v12, v14, v15, v16, v17, v18, v19, v20, 1);

  }
}

void sub_1000BF324(id a1, int64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Transaction %d abruptly ended because %d", 16, a2);
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000BF384(id a1, int64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Transaction %d abruptly ended because %d", 16, a2);
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000BF3E4(id a1, int64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Transaction %d abruptly ended because %d", 16, a2);
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000BF444(id a1, int64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Transaction %d abruptly ended because %d", 16, a2);
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_1000BF87C()
{
  uint64_t result;

  result = qword_10026D6B0;
  if (!qword_10026D6B0)
  {
    pthread_once(&stru_10026CAF8, (void (*)(void))sub_1000BF8B8);
    return qword_10026D6B0;
  }
  return result;
}

CFMutableDictionaryRef sub_1000BF8B8()
{
  CFMutableDictionaryRef result;

  qword_10026D6B0 = _CFRuntimeRegisterClass(&unk_100230F48);
  result = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  qword_10026D6B8 = (uint64_t)result;
  return result;
}

void sub_1000BF900(int a1, mach_msg_header_t *a2, int a3, CFIndex *cf)
{
  mach_msg_header_t *v6;
  mach_msg_header_t *v7;
  mach_port_t msgh_remote_port;
  mach_port_t *p_msgh_remote_port;
  void (*v10)(CFIndex *, CFIndex);
  NDR_record_t v11;
  void (*v12)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex);
  mach_msg_option_t v13;

  if (cf)
  {
    CFRetain(cf);
    v6 = (mach_msg_header_t *)CFAllocatorAllocate(0, cf[3], 0);
    if (!v6)
    {
LABEL_19:
      CFRelease(cf);
      return;
    }
    v7 = v6;
    msgh_remote_port = a2->msgh_remote_port;
    v6->msgh_bits = a2->msgh_bits & 0x1F;
    v6->msgh_size = 36;
    *(_QWORD *)&v6->msgh_remote_port = msgh_remote_port;
    v6->msgh_id = a2->msgh_id + 100;
    if (a2->msgh_id == 70)
    {
      v6->msgh_bits = 0;
      v6->msgh_remote_port = 0;
      v6[1].msgh_remote_port = 0;
      p_msgh_remote_port = &v6[1].msgh_remote_port;
      v10 = (void (*)(CFIndex *, CFIndex))cf[12];
      if (v10)
        v10(cf, cf[13]);
    }
    else
    {
      v11 = NDR_record;
      v6[1].msgh_remote_port = -303;
      p_msgh_remote_port = &v6[1].msgh_remote_port;
      *(NDR_record_t *)&v6[1].msgh_bits = v11;
      v12 = (void (*)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex))cf[10];
      if (v12)
        v12(cf, a2, v6, cf[11]);
    }
    if ((v7->msgh_bits & 0x80000000) == 0 && *p_msgh_remote_port)
    {
      if (*p_msgh_remote_port == -305)
        goto LABEL_18;
      a2->msgh_remote_port = 0;
      mach_msg_destroy(a2);
    }
    if (v7->msgh_remote_port)
    {
      if ((v7->msgh_bits & 0x1F) == 0x12)
        v13 = 1;
      else
        v13 = 17;
      if ((mach_msg(v7, v13, v7->msgh_size, 0, 0, 0, 0) - 268435459) > 1)
        goto LABEL_18;
    }
    else if ((v7->msgh_bits & 0x80000000) == 0)
    {
      goto LABEL_18;
    }
    mach_msg_destroy(v7);
LABEL_18:
    CFAllocatorDeallocate(0, v7);
    goto LABEL_19;
  }
}

void sub_1000BFA70(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  __CFRunLoopSource *RunLoopSource;

  *(_QWORD *)(a1 + 32) = rl;
  *(_QWORD *)(a1 + 40) = mode;
  RunLoopSource = *(__CFRunLoopSource **)(a1 + 48);
  if (RunLoopSource
    || (RunLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, *(CFMachPortRef *)(a1 + 56), 1),
        (*(_QWORD *)(a1 + 48) = RunLoopSource) != 0))
  {
    CFRunLoopAddSource(rl, RunLoopSource, mode);
  }
}

void sub_1000BFAE4(uint64_t a1, __CFRunLoop *cf1, const __CFString *a3)
{
  const void *v6;
  _QWORD *v7;
  __CFRunLoopSource *v8;
  const void *v9;

  if (cf1)
  {
    if (a3)
    {
      v7 = (_QWORD *)(a1 + 32);
      v6 = *(const void **)(a1 + 32);
      if (v6)
      {
        if (*(_QWORD *)(a1 + 40))
        {
          if (CFEqual(cf1, v6))
          {
            if (CFEqual(a3, *(CFTypeRef *)(a1 + 40)))
            {
              *v7 = 0;
              v7[1] = 0;
              v8 = *(__CFRunLoopSource **)(a1 + 48);
              if (v8)
              {
                CFRunLoopRemoveSource(cf1, v8, a3);
                v9 = *(const void **)(a1 + 48);
                if (v9)
                {
                  CFRelease(v9);
                  *(_QWORD *)(a1 + 48) = 0;
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_1000BFB70(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 80) = a2;
  *(_QWORD *)(result + 88) = a3;
  return result;
}

void sub_1000BFE54(id a1, id a2, unint64_t a3, BOOL *a4)
{
  if (a2)
    dispatch_source_cancel((dispatch_source_t)a2);
}

void sub_1000BFF08(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint8_t buf[4];
  const char *v6;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Received signal %d", *(unsigned int *)(a1 + 48));
  objc_autoreleasePoolPop(v2);
  if (*(_DWORD *)(a1 + 48) == 15)
  {
    v3 = (void *)MGCopyAnswerWithError(CFSTR("LowPowerExpressModesSupported"), 0, 0);
    v4 = v3;
    if (v3 && objc_msgSend(v3, "count"))
    {
      sub_10008F33C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 0, CFSTR("LPEM"));
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315138;
      v6 = "-[WiFiManagerLifeCycle handleSignal:onQueue:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: LPEM mode not supported. Not powering off on SIGTERM", buf, 0xCu);
    }

  }
  sub_100007FDC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 1, 1, 0);
  sub_1000A485C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 1, 0);
  objc_msgSend(*(id *)(a1 + 32), "stopOnQueue:", *(_QWORD *)(a1 + 40));
  exit(*(_DWORD *)(a1 + 48));
}

uint64_t start()
{
  void *v0;
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  const __CFLocale *v5;
  __CFDateFormatter *v6;
  int v7;
  void *v8;
  void *v9;
  _QWORD v11[5];
  _QWORD block[5];
  uint64_t v13;
  _QWORD v14[6];

  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x3052000000;
  v14[3] = sub_10002FA78;
  v14[4] = sub_10002F984;
  v14[5] = 0;
  v0 = objc_autoreleasePoolPush();
  if ((_set_user_dir_suffix("com.apple.wifi.manager") & 1) == 0
    && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    sub_1001870E8();
  }
  NSTemporaryDirectory();
  +[NSError _setFileNameLocalizationEnabled:](NSError, "_setFileNameLocalizationEnabled:", 0);
  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_10026DD50 = (uint64_t)dispatch_queue_create("com.apple.wifid.managerQueue", v1);
  if (!qword_10026DD50)
    goto LABEL_29;
  if (&_wd_endpoint_register)
  {
    wd_endpoint_register("com.apple.wifid.watchdog");
    v2 = wd_endpoint_add_queue(qword_10026DD50);
    wd_endpoint_activate(v2);
  }
  v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_10026DD40 = (uint64_t)dispatch_queue_create("com.apple.wifid.serialQueue", v3);
  if (qword_10026DD40
    && (v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM),
        (qword_10026DD48 = (uint64_t)dispatch_queue_create("com.apple.wifi.network-sync", v4)) != 0))
  {
    v5 = CFLocaleCopyCurrent();
    v6 = CFDateFormatterCreate(0, v5, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    qword_10026DD58 = (uint64_t)v6;
    if (v6)
      CFDateFormatterSetFormat(v6, CFSTR("MM/dd/yy HH:mm:ss.SSS"));
    if (v5)
      CFRelease(v5);
    pthread_mutex_init(&stru_10026CB48, 0);
    pthread_mutex_init(&stru_10026CB88, 0);
    byte_10026DD60 = os_variant_is_darwinos(0);
    if (objc_opt_class(LockdownModeManager))
      byte_10026DD61 = objc_msgSend(+[LockdownModeManager shared](LockdownModeManager, "shared"), "enabled");
    if (objc_opt_class(MSDKDemoState))
    {
      v13 = 0;
      byte_10026DD62 = -[MSDKDemoState isStoreDemoModeEnabled:](+[MSDKDemoState sharedInstance](MSDKDemoState, "sharedInstance"), "isStoreDemoModeEnabled:", &v13);
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000C0398;
    block[3] = &unk_100230858;
    block[4] = v14;
    dispatch_async((dispatch_queue_t)qword_10026DD50, block);
    v7 = 1;
  }
  else
  {
LABEL_29:
    v7 = 0;
  }
  objc_autoreleasePoolPop(v0);
  if (v7)
  {
    -[NSRunLoop run](+[NSRunLoop mainRunLoop](NSRunLoop, "mainRunLoop"), "run");
    v8 = objc_autoreleasePoolPush();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1000C03E0;
    v11[3] = &unk_100230858;
    v11[4] = v14;
    dispatch_async((dispatch_queue_t)qword_10026DD50, v11);
    objc_autoreleasePoolPop(v8);
  }
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD58)
  {
    CFRelease((CFTypeRef)qword_10026DD58);
    qword_10026DD58 = 0;
  }
  if (qword_10026DD40)
  {
    dispatch_release((dispatch_object_t)qword_10026DD40);
    qword_10026DD40 = 0;
  }
  if (qword_10026DD48)
  {
    dispatch_release((dispatch_object_t)qword_10026DD48);
    qword_10026DD48 = 0;
  }
  if (qword_10026DD50)
  {
    dispatch_release((dispatch_object_t)qword_10026DD50);
    qword_10026DD50 = 0;
  }
  objc_autoreleasePoolPop(v9);
  _Block_object_dispose(v14, 8);
  return 0;
}

void sub_1000C037C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1000C0398(uint64_t a1)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = objc_alloc_init(WiFiManagerLifeCycle);
  return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "startOnQueue:", qword_10026DD50);
}

void sub_1000C03E0(uint64_t a1)
{
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "stopOnQueue:", qword_10026DD50);

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = 0;
}

uint64_t sub_1000C0430(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  char *v7;
  void *v8;

  if (!qword_10026D6C0)
    pthread_once(&stru_10026CBC8, (void (*)(void))sub_1000C0838);
  Instance = _CFRuntimeCreateInstance(a1);
  *(_QWORD *)(Instance + 72) = 850045863;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_QWORD *)(Instance + 128) = 0;
  v7 = (char *)malloc_type_malloc(a3 * a2, 0x79B6E5A0uLL);
  *(_QWORD *)(Instance + 40) = v7;
  if (v7)
  {
    *(_QWORD *)(Instance + 56) = v7;
    *(_QWORD *)(Instance + 64) = v7;
    *(_QWORD *)(Instance + 48) = &v7[a3 * a2];
    *(_QWORD *)(Instance + 16) = a2;
    *(_QWORD *)(Instance + 24) = 0;
    *(_QWORD *)(Instance + 32) = a3;
    *(_BYTE *)(Instance + 136) = 0;
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s allocation error (likely OOM)", "WiFiCircularBufferCreate");
    objc_autoreleasePoolPop(v8);
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t sub_1000C053C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t sub_1000C0544(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  memcpy(*(void **)(a1 + 56), a2, *(_QWORD *)(a1 + 32));
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 56) + *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 56) = v6;
  if (v6 == v5)
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 24);
  if (v7 < *(_QWORD *)(a1 + 16))
    *(_QWORD *)(a1 + 24) = v7 + 1;
  return pthread_mutex_unlock(v4);
}

uint64_t sub_1000C05C0(uint64_t a1, void *a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  sub_1000C0604(a1, a2);
  return pthread_mutex_unlock(v4);
}

void *sub_1000C0604(uint64_t a1, void *__dst)
{
  void *result;
  uint64_t v4;
  void *v5;

  if (*(_QWORD *)(a1 + 24))
  {
    result = memcpy(__dst, *(const void **)(a1 + 64), *(_QWORD *)(a1 + 32));
    v4 = *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 64) = v4;
    if (v4 == *(_QWORD *)(a1 + 48))
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 40);
    --*(_QWORD *)(a1 + 24);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s when empty", "__WiFiCircularBufferGet");
    objc_autoreleasePoolPop(v5);
    return (void *)pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72));
  }
  return result;
}

void sub_1000C06C4(uint64_t a1, void *a2)
{
  void *v2;

  if (*(_BYTE *)(a1 + 136))
  {
    sub_1000C0604(a1, a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s write locked not locked", "WiFiCircularBufferWriteLockedGet");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000C0734(uint64_t a1)
{
  void *v1;

  if (*(_BYTE *)(a1 + 136))
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s write lock already locked", "WiFiCircularBufferTakeWriteLock");
    objc_autoreleasePoolPop(v1);
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
    *(_BYTE *)(a1 + 136) = 1;
  }
}

void sub_1000C07B8(uint64_t a1)
{
  void *v2;

  if (*(_BYTE *)(a1 + 136))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72));
    *(_BYTE *)(a1 + 136) = 0;
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s write lock not locked", "WiFiCircularBufferReleaseWriteLock");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000C0838()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100231010);
  qword_10026D6C0 = result;
  return result;
}

void sub_1000C085C(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  free(*(void **)(a1 + 40));
}

void sub_1000C11D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_1000C11F8(uint64_t a1)
{
  id WeakRetained;
  void *v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cachedBudget"));

  return v2;
}

void sub_1000C1440(uint64_t a1, void *a2)
{
  id v3;
  id *WeakRetained;
  id *v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  _QWORD block[4];
  id *v16;
  uint64_t *v17;
  const void *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  id v22;

  v3 = a2;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  v5 = WeakRetained;
  v6 = WeakRetained[1];
  if (v6)
  {
    objc_msgSend(WeakRetained[5], "acknowledgePowerBudget:forClientId:error:", v3, WeakRetained[18], 0);
    v19 = 0;
    v20 = &v19;
    v21 = 0x2020000000;
    v22 = (id)0xAAAAAAAAAAAAAAAALL;
    v22 = objc_msgSend(v5, "WiFiBatteryManagerHandleCpmsAllocatedBudgetReturnIndex:", v3);
    v7 = sub_1000161D4((uint64_t)v6);
    v8 = sub_10007526C(v7);
    v9 = v20[3];
    v10 = objc_autoreleasePoolPush();
    if (v9 == v8)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt :  Budget to be written is %lu, last was %lu : ignoring", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke", v20[3], v8);
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt :  Budget to be written is %lu (last was %lu) !", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke", v20[3], v8);
      objc_autoreleasePoolPop(v10);
      v11 = sub_10011AF9C((uint64_t)v6);
      v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      if (v12)
      {
        CFRetain(v6);
        v13 = sub_10011AF9C((uint64_t)v6);
        v14 = objc_claimAutoreleasedReturnValue(v13);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000C165C;
        block[3] = &unk_1002310A0;
        v17 = &v19;
        v18 = v6;
        v16 = v5;
        dispatch_async(v14, block);

LABEL_12:
        _Block_object_dispose(&v19, 8);
        goto LABEL_13;
      }
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke");
    }
    objc_autoreleasePoolPop(v10);
    goto LABEL_12;
  }
LABEL_13:

}

void sub_1000C1644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C165C(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  int v6;
  int v7;
  void *v8;

  v2 = sub_10011AF9C(*(_QWORD *)(a1 + 48));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt :  Async CPMS Handler ", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke_2");
    objc_autoreleasePoolPop(v4);
    v5 = sub_1000161D4(*(_QWORD *)(a1 + 48));
    v6 = sub_100074FA8(v5, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    if (!v6)
      goto LABEL_8;
    v7 = v6;
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : Unable to set the Async budget value to FW ", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke_2");
    objc_autoreleasePoolPop(v8);
    if (v7 != 82)
LABEL_8:
      objc_msgSend(*(id *)(a1 + 32), "WiFiBatteryManagerHandlePowerAdmissionResponse:", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke_2");
    objc_autoreleasePoolPop(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void sub_1000C1870(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  const void *v5;
  void *v6;
  void *v7;
  double v8;
  double v9;
  uint64_t v10;
  void *v11;
  const __CFDictionary *v12;
  const __CFNumber *Value;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  void *v19;
  _QWORD block[4];
  _QWORD *v21;
  uint64_t *v22;
  const void *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = (const void *)WeakRetained[1];
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "asyncPPMBudgetTimestamp"));
  objc_msgSend(v6, "timeIntervalSinceDate:", v7);
  v9 = v8;

  if (v5)
  {
    v10 = sub_10011AF9C((uint64_t)v5);
    v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

    if (v11)
    {
      if (v3)
      {
        v12 = (const __CFDictionary *)objc_msgSend(v3, "objectForKey:", CFSTR("CDResourceAvailabilityKeyRetryReason"));
        if (v12)
        {
          v24 = 0;
          v25 = &v24;
          v26 = 0x2020000000;
          v27 = 0xAAAAAAAAAAAAAAAALL;
          Value = (const __CFNumber *)CFDictionaryGetValue(v12, CFSTR("com.apple.duet.ppm-bgt.wifi"));
          if (Value && v9 >= 5.0)
          {
            objc_msgSend(WeakRetained, "setAsyncPPMBudgetTimestamp:", v6);
            CFNumberGetValue(Value, kCFNumberLongLongType, v25 + 3);
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFiBatteryMgmt called back received wifibudget is %llu", v25[3]);
            objc_autoreleasePoolPop(v14);
            v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cachedBudget"));
            v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", v25[3]));
            objc_msgSend(v15, "setObject:forKey:", v16, CFSTR("kCPMSPowerLegacyPPM"));

            CFRetain(v5);
            v17 = sub_10011AF9C((uint64_t)v5);
            v18 = objc_claimAutoreleasedReturnValue(v17);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_1000C1AEC;
            block[3] = &unk_1002310A0;
            v22 = &v24;
            v23 = v5;
            v21 = WeakRetained;
            dispatch_async(v18, block);

          }
          _Block_object_dispose(&v24, 8);
        }
      }
    }
    else
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke");
      objc_autoreleasePoolPop(v19);
    }
  }

}

void sub_1000C1AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C1AEC(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;

  v2 = sub_10011AF9C(*(_QWORD *)(a1 + 48));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt :  Async PPM Handler ", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_2");
    objc_autoreleasePoolPop(v4);
    v5 = sub_1000161D4(*(_QWORD *)(a1 + 48));
    sub_100074FA8(v5, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    objc_msgSend(*(id *)(a1 + 32), "WiFiBatteryManagerHandlePowerAdmissionResponse:", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_2");
    objc_autoreleasePoolPop(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void sub_1000C1BC4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t *WeakRetained;
  uint64_t *v7;
  const void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  void *v13;
  _QWORD block[4];
  uint64_t *v15;
  const void *v16;
  uint64_t v17;

  v5 = a3;
  WeakRetained = (uint64_t *)objc_loadWeakRetained((id *)(a1 + 32));
  v7 = WeakRetained;
  v8 = (const void *)WeakRetained[1];
  if (v8)
  {
    v9 = sub_10011AF9C(WeakRetained[1]);
    v10 = (void *)objc_claimAutoreleasedReturnValue(v9);

    if (v10)
    {
      if (a2 != 2)
      {
        CFRetain(v8);
        v11 = sub_10011AF9C((uint64_t)v8);
        v12 = objc_claimAutoreleasedReturnValue(v11);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000C1CEC;
        block[3] = &unk_1002310F0;
        v16 = v8;
        v15 = v7;
        v17 = a2;
        dispatch_async(v12, block);

      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_3");
      objc_autoreleasePoolPop(v13);
    }
  }

}

void sub_1000C1CEC(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;

  v2 = sub_10011AF9C(*(_QWORD *)(a1 + 40));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:WiFiBatteryMgmt : PPM Admission Handler", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_4");
    objc_autoreleasePoolPop(v4);
    if (*(_QWORD *)(a1 + 48) == 1)
      v5 = 100;
    else
      v5 = 0;
    objc_msgSend(*(id *)(a1 + 32), "WiFiBatteryManagerHandlePowerAdmissionResponse:", v5);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager queue.", "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_4");
    objc_autoreleasePoolPop(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t sub_1000C312C()
{
  uint64_t result;

  result = qword_10026D6C8;
  if (!qword_10026D6C8)
  {
    pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
    return qword_10026D6C8;
  }
  return result;
}

CFSetRef sub_1000C3168()
{
  CFSetRef result;
  _OWORD v1[2];
  void *values[2];
  __int128 v3;
  const __CFString *v4;

  qword_10026D6C8 = _CFRuntimeRegisterClass(&unk_100231138);
  *(_OWORD *)values = *(_OWORD *)&off_100231198;
  v3 = *(_OWORD *)&off_1002311A8;
  v4 = CFSTR("AcceptEAPTypes");
  qword_10026D6D0 = (uint64_t)CFArrayCreate(kCFAllocatorDefault, (const void **)values, 5, &kCFTypeArrayCallBacks);
  v1[0] = *(_OWORD *)&off_1002311C0;
  v1[1] = *(_OWORD *)&off_1002311D0;
  result = CFSetCreate(kCFAllocatorDefault, (const void **)v1, 4, &kCFTypeSetCallBacks);
  qword_10026D6D8 = (uint64_t)result;
  return result;
}

_WORD *sub_1000C323C(const __CFString *a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  CFDataRef ExternalRepresentation;
  CFDataRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  _WORD *v8;
  void *v10;
  __int16 valuePtr;

  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssid", "WiFiNetworkCreateWithSsid");
    goto LABEL_13;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networkRecord", "WiFiNetworkCreateWithSsid");
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return 0;
  }
  v3 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("SSID_STR"), a1);
  ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a1, 0x8000100u, 0);
  if (ExternalRepresentation)
  {
    v5 = ExternalRepresentation;
    CFDictionarySetValue(v3, CFSTR("SSID"), ExternalRepresentation);
    CFRelease(v5);
  }
  valuePtr = 2;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (v6)
  {
    v7 = v6;
    CFDictionarySetValue(v3, CFSTR("AP_MODE"), v6);
    CFRelease(v7);
  }
  v8 = sub_10002B314((uint64_t)kCFAllocatorDefault, v3);
  CFRelease(v3);
  return v8;
}

CFMutableDictionaryRef sub_1000C33B4(uint64_t a1)
{
  return CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *(CFDictionaryRef *)(a1 + 16));
}

const __CFDictionary *sub_1000C33D0(uint64_t a1)
{
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v2;
  const __CFDictionary *Value;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  __CFDictionary *v7;
  __CFDictionary *v8;

  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *(CFDictionaryRef *)(a1 + 16));
  v2 = MutableCopy;
  if (MutableCopy)
  {
    if (!CFDictionaryGetValue(MutableCopy, CFSTR("SSID_STR")))
    {
      v5 = v2;
      v2 = 0;
LABEL_10:
      CFRelease(v5);
      return v2;
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v2, CFSTR("EnterpriseProfile"));
    if (Value)
    {
      v4 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
      if (v4)
      {
        v5 = v4;
        v6 = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("EAPClientConfiguration"));
        if (v6)
        {
          v7 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v6);
          if (v7)
          {
            v8 = v7;
            CFDictionaryRemoveValue(v7, CFSTR("UserPassword"));
            CFDictionaryRemoveValue(v8, CFSTR("TLSSaveTrustExceptions"));
            CFDictionaryRemoveValue(v8, CFSTR("TLSUserTrustProceedCertificateChain"));
            CFDictionarySetValue(v5, CFSTR("EAPClientConfiguration"), v8);
            CFRelease(v8);
          }
        }
        CFDictionarySetValue(v2, CFSTR("EnterpriseProfile"), v5);
        goto LABEL_10;
      }
    }
  }
  return v2;
}

const __CFDictionary *sub_1000C34F4(CFDictionaryRef *a1, const void *a2)
{
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v6;
  const __CFDictionary *Value;
  __CFDictionary *v8;
  __CFDictionary *v9;
  CFStringRef v10;
  void *v11;
  const char *v12;
  void *v13;
  void *v14;

  v4 = (const __CFDictionary *)sub_10002BE64((uint64_t)a1, CFSTR("EnterpriseProfile"));
  if (!v4)
    return 0;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v4);
  v6 = MutableCopy;
  if (MutableCopy)
  {
    CFDictionarySetValue(MutableCopy, CFSTR("EnableUserInterface"), kCFBooleanFalse);
    Value = (const __CFDictionary *)CFDictionaryGetValue(v6, CFSTR("EAPClientConfiguration"));
    if (Value)
    {
      v8 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
      if (v8)
      {
        v9 = v8;
        if (a2)
        {
          CFDictionarySetValue(v8, CFSTR("UserPassword"), a2);
LABEL_23:
          CFDictionarySetValue(v6, CFSTR("EAPClientConfiguration"), v9);
          CFRelease(v9);
          return v6;
        }
        if (sub_10002DA5C((_BOOL8)a1))
        {
          v10 = sub_1000C3718((uint64_t)a1);
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v12 = "non-null";
            if (!v10)
              v12 = "null";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiNetworkCopyPasswordForAccount() returned a %s password", "WiFiNetworkCopyPreparedEAPProfile", v12);
          }
          objc_autoreleasePoolPop(v11);
          if (!v10)
          {
            v10 = sub_1000C37A0(a1);
            if (!v10)
            {
              v13 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Password for EAP profile NULL after fetch by account name and normal method, attempting password fetch by domain name ", "WiFiNetworkCopyPreparedEAPProfile");
              objc_autoreleasePoolPop(v13);
              v10 = sub_1000C3890((uint64_t)a1);
              if (!v10)
              {
                v14 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Password for EAP profile still NULL after attempted fetch by domain name", "WiFiNetworkCopyPreparedEAPProfile");
                objc_autoreleasePoolPop(v14);
                goto LABEL_23;
              }
            }
          }
        }
        else
        {
          v10 = sub_1000C37A0(a1);
          if (!v10)
            goto LABEL_23;
        }
        CFDictionarySetValue(v9, CFSTR("UserPassword"), v10);
        CFRelease(v10);
        goto LABEL_23;
      }
    }
  }
  return v6;
}

CFStringRef sub_1000C3718(uint64_t a1)
{
  __CFString *v1;
  void *v2;

  v1 = (__CFString *)sub_10002BE64(a1, CFSTR("HS20AccountName"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS 2.0 account name from WiFiNetworkGetProperty() is %@", "__WiFiNetworkCopyPasswordForAccount", v1);
  objc_autoreleasePoolPop(v2);
  if (v1)
    return sub_1000D7FC8(v1);
  else
    return 0;
}

CFStringRef sub_1000C37A0(CFDictionaryRef *a1)
{
  const __CFString *v2;
  CFStringRef result;
  __CFString *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const __CFString *v8;

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315394;
    v6 = "WiFiNetworkCopyPassword";
    v7 = 2112;
    v8 = sub_1000C3C04(a1);
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: Copy password for Network %@", (uint8_t *)&v5, 0x16u);
  }
  if (!a1
    || !CFDictionaryContainsKey(a1[2], CFSTR("PayloadUUID"))
    || (v2 = sub_1000C3C04(a1), (result = sub_1000D96B0(v2)) == 0))
  {
    v4 = (__CFString *)sub_1000C3C04(a1);
    return sub_1000D7FC8(v4);
  }
  return result;
}

__CFString *sub_1000C3890(uint64_t a1)
{
  __CFString *result;

  result = (__CFString *)sub_10002BE64(a1, CFSTR("DomainName"));
  if (result)
    return (__CFString *)sub_1000D7FC8(result);
  return result;
}

void sub_1000C38BC(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  void *v8;
  const void *v9;
  void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  void *v14;
  const void *v15;
  const void *v16;
  int v17;

  if (a1)
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("WEP")) == kCFBooleanTrue)
    {
      v4 = sub_10002BE64(a2, CFSTR("WEP_AUTH_Flags"));
      if (v4)
        sub_10002C478(a1, CFSTR("WEP_AUTH_Flags"), v4);
    }
  }
  if (sub_10002DAB4(a2))
  {
    v5 = sub_10002BE64(a2, CFSTR("EnterpriseProfile"));
    if (v5)
      sub_10002C478(a1, CFSTR("EnterpriseProfile"), v5);
  }
  if (a2 && CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("DomainName")) && sub_10002DA5C(a1))
  {
    v6 = sub_10002BE64(a2, CFSTR("DisplayedOperatorName"));
    if (v6)
      sub_10002C478(a1, CFSTR("HS2NetworkBadge"), v6);
    v7 = sub_10002BE64(a2, CFSTR("HS20AccountName"));
    if (v7 || (v7 = sub_10002B088((const void *)a2)) != 0)
    {
      sub_10002C478(a1, CFSTR("HS20AccountName"), v7);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting HS 2.0 account name to %@ for network %@", "WiFiNetworkMergeForAssociation", v7, sub_1000C3C04((const void *)a1));
      objc_autoreleasePoolPop(v8);
    }
  }
  v9 = sub_10002BE64(a2, CFSTR("TransitionDisabledFlags"));
  if (v9)
    sub_10002C478(a1, CFSTR("TransitionDisabledFlags"), v9);
  v10 = (void *)CWFCoreWiFiSpecificAttributesKey;
  v11 = sub_10002BE64(a2, CWFCoreWiFiSpecificAttributesKey);
  if (v11)
    sub_10002C478(a1, v10, v11);
  v12 = sub_10002BE64(a2, CFSTR("PolicyUUID"));
  if (v12)
    sub_10002C478(a1, CFSTR("PolicyUUID"), v12);
  v13 = sub_10002BE64(a2, CFSTR("PayloadUUID"));
  if (v13)
    sub_10002C478(a1, CFSTR("PayloadUUID"), v13);
  sub_1000C3C70((const void *)a1, a2);
  if (&_CNForgetSSID)
  {
    v14 = (void *)kCNSCaptiveNetworkProperty;
    v15 = sub_10002BE64(a2, kCNSCaptiveNetworkProperty);
    sub_10002C478(a1, v14, v15);
  }
  v16 = sub_10002BE64(a2, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"));
  sub_10002C478(a1, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"), v16);
  if (*(__int16 *)(a1 + 24) == -1)
  {
    v17 = *(unsigned __int16 *)(a2 + 24);
    if (v17 != 0xFFFF)
      *(_WORD *)(a1 + 24) = v17;
  }
}

BOOL sub_1000C3B8C(_BOOL8 result)
{
  if (result)
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), CFSTR("WEP")) == kCFBooleanTrue;
  return result;
}

BOOL sub_1000C3BC4(_BOOL8 result)
{
  if (result)
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), CFSTR("DomainName")) != 0;
  return result;
}

void sub_1000C3BF4(uint64_t a1, const void *a2)
{
  sub_10002C478(a1, CFSTR("HS2NetworkBadge"), a2);
}

const __CFString *sub_1000C3C04(const void *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  const void *v4;

  if (!a1)
    return 0;
  v2 = (const __CFString *)sub_10002B088(a1);
  v3 = v2;
  if ((!v2 || !CFStringGetLength(v2)) && sub_10002DA5C((_BOOL8)a1))
  {
    v4 = sub_10002BE64((uint64_t)a1, CFSTR("DomainName"));
    if (v4)
      return (const __CFString *)v4;
  }
  return v3;
}

void sub_1000C3C70(const void *a1, uint64_t a2)
{
  _BOOL4 v4;
  void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null destNetwork", "WiFiNetworkMergeAutoJoinProperties", v12, v13);
    goto LABEL_10;
  }
  if (!a2)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null srcNetwork", "WiFiNetworkMergeAutoJoinProperties", v12, v13);
    goto LABEL_10;
  }
  sub_1000CC95C((uint64_t)a1);
  v4 = sub_100007F24(a2);
  sub_1000C6770((uint64_t)a1, v4);
  if (!v4)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: preserving all AJ-disabled-related properties for network %@", "WiFiNetworkMergeAutoJoinProperties", sub_10002B088(a1));
    objc_autoreleasePoolPop(v5);
    v6 = sub_10002BE64(a2, CFSTR("networkDisabledClientName"));
    sub_10002C478((uint64_t)a1, CFSTR("networkDisabledClientName"), v6);
    v7 = sub_10002BE64(a2, CFSTR("networkDisabledReason"));
    sub_10002C478((uint64_t)a1, CFSTR("networkDisabledReason"), v7);
    v8 = sub_10002BE64(a2, CFSTR("networkDisabledTimestamp"));
    sub_10002C478((uint64_t)a1, CFSTR("networkDisabledTimestamp"), v8);
    v9 = sub_10002BE64(a2, CFSTR("WiFiNetworkDisabledUntilDate"));
    if (v9)
    {
      v10 = v9;
      sub_10002C478((uint64_t)a1, CFSTR("WiFiNetworkDisabledUntilDate"), v9);
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: preserved disabledUntil for %@ network with %@", "WiFiNetworkMergeAutoJoinProperties", sub_10002B088(a1), v10);
LABEL_10:
      objc_autoreleasePoolPop(v11);
    }
  }
}

CFDictionaryRef sub_1000C3E64(CFDictionaryRef result, CFDictionaryRef theDict)
{
  const __CFDictionary *v3;
  unsigned int Count;
  uint64_t v5;
  size_t v6;
  const void **v7;
  const void **v8;
  const __CFAllocator *Default;
  const __CFDictionary *MutableCopy;
  unint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  CFDictionaryRef Copy;
  const __CFAllocator *v15;

  if (result)
  {
    v3 = result;
    if (theDict && (Count = CFDictionaryGetCount(theDict), (v5 = Count) != 0))
    {
      v6 = 8 * Count;
      v7 = (const void **)malloc_type_malloc(v6, 0x6004044C4A2DFuLL);
      v8 = (const void **)malloc_type_malloc(v6, 0xC0040B8AA526DuLL);
      Default = CFAllocatorGetDefault();
      MutableCopy = CFDictionaryCreateMutableCopy(Default, 0, v3);
      CFDictionaryGetKeysAndValues(theDict, v7, v8);
      v11 = 0;
      v12 = 8 * v5;
      do
      {
        CFDictionaryGetValueIfPresent(MutableCopy, v7[v11 / 8], 0);
        CFDictionaryAddValue(MutableCopy, v7[v11 / 8], v8[v11 / 8]);
        v11 += 8;
      }
      while (v12 != v11);
      free(v8);
      free(v7);
      v13 = CFAllocatorGetDefault();
      Copy = CFDictionaryCreateCopy(v13, MutableCopy);
      CFRelease(MutableCopy);
      return Copy;
    }
    else
    {
      v15 = CFAllocatorGetDefault();
      return CFDictionaryCreateCopy(v15, v3);
    }
  }
  return result;
}

const __CFNumber *sub_1000C3F88(uint64_t a1)
{
  const __CFNumber *result;
  int Value;
  void *v4;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    result = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkOfInterestHomeState"));
    if (result)
    {
      Value = CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr - 3 >= 0xFFFFFFFE || Value == 0)
        return (const __CFNumber *)valuePtr;
      else
        return 0;
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetNetworkOfInterestHomeType");
    objc_autoreleasePoolPop(v4);
    return 0;
  }
  return result;
}

const __CFDictionary *sub_1000C4028(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  const __CFData *Value;
  const __CFData *v3;
  CFStringRef v4;

  if (result)
  {
    v1 = result;
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("SSID_STR"));
    if (!result)
    {
      Value = (const __CFData *)CFDictionaryGetValue(v1, CFSTR("SSID"));
      if (Value
        && ((v3 = Value, (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, Value, 0x8000100u)) != 0)
         || (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v3, 0)) != 0)
        || (v4 = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u)) != 0)
      {
        CFDictionarySetValue(v1, CFSTR("SSID_STR"), v4);
        CFRelease(v4);
      }
      return (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("SSID_STR"));
    }
  }
  return result;
}

CFDataRef sub_1000C4110(uint64_t a1)
{
  CFDataRef result;
  const __CFString *v2;
  CFTypeID v3;
  uint64_t v4;
  _QWORD v5[2];

  result = (CFDataRef)sub_10002BE64(a1, CFSTR("BSSID"));
  if (result)
  {
    v2 = (const __CFString *)result;
    v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID()
      && (v4 = 0, v5[0] = 0, *(_DWORD *)((char *)v5 + 7) = 0, CFStringGetCString(v2, (char *)&v4, 19, 0x8000100u)))
    {
      result = (CFDataRef)ether_aton((const char *)&v4);
      if (result)
        return CFDataCreate(kCFAllocatorDefault, (const UInt8 *)result, 6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFArray *sub_1000C41D4(const __CFArray *result)
{
  uint64_t v1;
  const __CFArray *v2;
  CFIndex Count;

  if (result)
  {
    v1 = (uint64_t)result;
    result = (const __CFArray *)sub_10002BE64((uint64_t)result, CFSTR("CHANNEL"));
    if (!result)
    {
      result = (const __CFArray *)sub_10002BE64(v1, CFSTR("networkKnownBSSListKey"));
      if (result)
      {
        v2 = result;
        result = (const __CFArray *)CFArrayGetCount(result);
        if (result)
        {
          Count = CFArrayGetCount(v2);
          result = (const __CFArray *)CFArrayGetValueAtIndex(v2, Count - 1);
          if (result)
            return (const __CFArray *)CFDictionaryGetValue(result, CFSTR("CHANNEL"));
        }
      }
    }
  }
  return result;
}

uint64_t sub_1000C4250(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  const __CFArray *v6;
  uint64_t v7;
  CFIndex i;
  const void *v9;
  CFTypeID TypeID;
  uint64_t v11;
  int valuePtr;

  *a3 = 0xFFFFFFFF80000000;
  *a2 = 37;
  result = (uint64_t)sub_10002BE64(a1, CFSTR("RATES"));
  if (result)
  {
    v6 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v7 = result;
      for (i = 0; i != v7; ++i)
      {
        result = (uint64_t)CFArrayGetValueAtIndex(v6, i);
        valuePtr = -1431655766;
        if (result)
        {
          v9 = (const void *)result;
          TypeID = CFNumberGetTypeID();
          result = CFGetTypeID(v9);
          if (TypeID == result)
          {
            result = CFNumberGetValue((CFNumberRef)v9, kCFNumberIntType, &valuePtr);
            v11 = valuePtr;
            if (*a3 < valuePtr)
              *a3 = valuePtr;
            if (*a2 > v11)
              *a2 = v11;
          }
        }
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1000C433C(const __CFDictionary *result)
{
  if (result)
    return sub_10002CFA8(*((const __CFDictionary **)result + 2));
  return result;
}

void sub_1000C434C(int a1, int a2, int a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  void *keys;
  uint64_t valuePtr;
  void *values;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    values = Mutable;
    if (Mutable)
    {
      v6 = Mutable;
      valuePtr = 8;
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
      if (v7)
      {
        v8 = v7;
        CFArrayAppendValue(v6, v7);
        CFRelease(v8);
      }
      if (a3)
      {
        valuePtr = 2;
        v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
        if (v9)
        {
          v10 = v9;
          CFArrayAppendValue(v6, v9);
          CFRelease(v10);
        }
      }
      else
      {
        sub_10002C478(a1, CFSTR("ALLOW_WPA2_PSK"));
      }
      keys = CFSTR("IE_KEY_RSN_AUTHSELS");
      v11 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v11)
      {
        v12 = v11;
        sub_10002C478(a1, CFSTR("RSN_IE"));
        CFRelease(v12);
      }
      CFRelease(values);
    }
  }
  else
  {
    sub_10002C478(a1, CFSTR("RSN_IE"));
  }
}

void sub_1000C44C4(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  const __CFString *v8;
  CFTypeRef cf;
  uint64_t valuePtr;
  void *values;

  v2 = a1;
  if (a2)
  {
    v3 = 2 * (sub_10002BE64(a1, CFSTR("EnterpriseProfile")) == 0);
    valuePtr = v3;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (cf)
      {
        v8 = CFSTR("IE_KEY_RSN_AUTHSELS");
        v4 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v8, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v4)
        {
          v5 = v4;
          sub_10002C478(v2, CFSTR("RSN_IE"));
          CFRelease(v5);
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
      if (values)
      {
        CFRelease(values);
        values = 0;
      }
    }
    valuePtr = v3;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (cf)
      {
        v8 = CFSTR("IE_KEY_WPA_AUTHSELS");
        v6 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v8, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v6)
        {
          v7 = v6;
          sub_10002C478(v2, CFSTR("WPA_IE"));
          CFRelease(v7);
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
      if (values)
        CFRelease(values);
    }
  }
  else
  {
    sub_10002C478(a1, CFSTR("RSN_IE"));
    sub_10002C478(v2, CFSTR("WPA_IE"));
  }
}

double sub_1000C46B4(uint64_t a1, void *a2)
{
  const void *v2;

  v2 = sub_10002BE64(a1, a2);
  return sub_10002DF80(v2);
}

BOOL sub_1000C46C8(uint64_t a1)
{
  CFBooleanRef v1;

  v1 = (CFBooleanRef)sub_10002BE64(a1, CFSTR("AmbiguousSSIDs"));
  return v1 && v1 == kCFBooleanTrue;
}

BOOL sub_1000C4700(const void *a1)
{
  const __CFString *v1;

  v1 = (const __CFString *)sub_10002B088(a1);
  return v1 && CFStringHasSuffix(v1, CFSTR("_nomap"));
}

void sub_1000C4734(uint64_t a1, int a2)
{
  const void **v2;

  v2 = (const void **)&kCFBooleanTrue;
  if (!a2)
    v2 = (const void **)&kCFBooleanFalse;
  sub_10002C478(a1, CFSTR("UserDirected"), *v2);
}

BOOL sub_1000C475C(uint64_t a1)
{
  return &_CNForgetSSID
      && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue;
}

BOOL sub_1000C47AC(uint64_t a1)
{
  return &_CNForgetSSID
      && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSNetworkWasCaptiveProperty) == kCFBooleanTrue;
}

const void *sub_1000C47FC(uint64_t a1)
{
  const __CFDictionary *v1;

  if (a1 && (v1 = *(const __CFDictionary **)(a1 + 16)) != 0)
    return CFDictionaryGetValue(v1, CFSTR("DiagnosticsBssEnv"));
  else
    return 0;
}

uint64_t sub_1000C4820(uint64_t a1)
{
  int ValueIfPresent;
  unsigned int v2;
  void *value;

  if (!&_CNForgetSSID)
    return 0;
  value = 0;
  ValueIfPresent = CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty, (const void **)&value);
  if (value == kCFBooleanTrue)
    v2 = 2;
  else
    v2 = 1;
  if (ValueIfPresent)
    return v2;
  else
    return 0;
}

BOOL sub_1000C488C(uint64_t a1)
{
  const void *v2;
  CFTypeID v3;
  const void *Value;
  const void *v5;
  CFTypeID v6;
  const UInt8 *BytePtr;
  const UInt8 *v8;
  CFIndex Length;
  uint64_t v10;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v17;

  if (!a1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNetworkIsWoWAllowed", v17);
    goto LABEL_26;
  }
  v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network record.", "WiFiNetworkIsWoWAllowed", v17);
    goto LABEL_26;
  }
  v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad record type %ld", "WiFiNetworkIsWoWAllowed", CFGetTypeID(*(CFTypeRef *)(a1 + 16)));
    v15 = v14;
    goto LABEL_27;
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (!Value)
    return 1;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID())
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad ieList type %ld", "__WiFiNetworkIsWoWAllowed", CFGetTypeID(v5));
LABEL_26:
    v15 = v13;
LABEL_27:
    objc_autoreleasePoolPop(v15);
    return 1;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)v5);
  if (!BytePtr)
    return 1;
  v8 = BytePtr;
  Length = CFDataGetLength((CFDataRef)v5);
  if (Length << 32 < 1)
    return 1;
  v10 = 0;
  while (*v8 != 221 || v8[1] != 10 || *(_DWORD *)(v8 + 2) != 116528896 || *(_DWORD *)(v8 + 5) != 50397446)
  {
    v12 = v8[1] + 2;
    v10 += v12;
    v8 += v12;
    if (v10 >= (int)Length)
      return 1;
  }
  return (v8[9] & 3) != 1;
}

const __CFData *sub_1000C4AA0(uint64_t a1)
{
  const void *v2;
  CFTypeID v3;
  const __CFData *result;
  const __CFData *v5;
  unsigned __int8 *v6;
  CFIndex Length;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  uint64_t v12;
  uint64_t v14;
  unsigned __int8 *v16;
  void *v17;
  void *v18;
  void *v19;

  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNetworkFoundNanIe");
    goto LABEL_29;
  }
  v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network record.", "WiFiNetworkFoundNanIe");
LABEL_29:
    v18 = v17;
LABEL_33:
    objc_autoreleasePoolPop(v18);
    return 0;
  }
  v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad record type %ld", "WiFiNetworkFoundNanIe", CFGetTypeID(*(CFTypeRef *)(a1 + 16)));
    v18 = v19;
    goto LABEL_33;
  }
  result = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (!result)
    return result;
  v5 = result;
  result = (const __CFData *)CFDataGetBytePtr(result);
  if (!result)
    return result;
  v6 = (unsigned __int8 *)result;
  Length = CFDataGetLength(v5);
  if (Length << 32 < 1)
    return 0;
  v8 = 0;
  v9 = (unint64_t)&v6[(int)Length];
  while (1)
  {
    v10 = v6 + 6;
    if (*v6 == 221
      && (unint64_t)v10 <= v9
      && *(_DWORD *)(v6 + 2) == 116528896
      && (unint64_t)(v6 + 9) <= v9)
    {
      break;
    }
LABEL_13:
    v12 = v6[1] + 2;
    v8 += v12;
    v6 += v12;
    if (v8 >= (int)Length)
      return 0;
  }
  while (1)
  {
    v14 = v10[2];
    if (*(_WORD *)v10 == 260 && (_DWORD)v14 == 18)
      return (const __CFData *)1;
    v16 = &v10[v14];
    v10 = v16 + 3;
    if ((unint64_t)(v16 + 6) > v9)
      goto LABEL_13;
  }
}

uint64_t sub_1000C4C88(uint64_t a1)
{
  uint64_t result;
  void *v3;

  if (a1)
  {
    result = sub_10001395C(a1);
    if ((_DWORD)result)
    {
      result = (uint64_t)sub_1000C4AA0(a1);
      if ((_DWORD)result)
        return sub_10002BE64(a1, CFSTR("WiFiNetworkNANServiceID")) != 0;
    }
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNetworkIsNanPH");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  return result;
}

const __CFData *sub_1000C4D24(uint64_t a1, unsigned __int8 *a2)
{
  const __CFData *result;
  const __CFData *v4;
  unsigned __int8 *v5;
  CFIndex Length;
  uint64_t v7;
  uint64_t v9;
  int v10;
  void *v11;

  result = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (result)
  {
    v4 = result;
    result = (const __CFData *)CFDataGetBytePtr(result);
    if (result)
    {
      v5 = (unsigned __int8 *)result;
      Length = CFDataGetLength(v4);
      if (Length << 32 < 1)
      {
        return 0;
      }
      else
      {
        v7 = 0;
        while (*v5 != 221 || v5[1] != 13 || *(_DWORD *)(v5 + 2) != 116528896 || *(_DWORD *)(v5 + 5) != 100729350)
        {
          v9 = v5[1] + 2;
          v7 += v9;
          v5 += v9;
          if (v7 >= (int)Length)
            return 0;
        }
        v10 = *(_DWORD *)(v5 + 9);
        *((_WORD *)a2 + 2) = *(_WORD *)(v5 + 13);
        *(_DWORD *)a2 = v10;
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BT MAC found in Apple IE %02X:%02X:%02X:%02X:%02X:%02X", "__WiFiNetworkGetBtMacFromIe", *a2, a2[1], a2[2], a2[3], a2[4], a2[5]);
        objc_autoreleasePoolPop(v11);
        return (const __CFData *)1;
      }
    }
  }
  return result;
}

const UInt8 *sub_1000C4E70(uint64_t a1)
{
  _BYTE *v2;
  const __CFData *Value;
  const __CFData *v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v7;
  unint64_t v8;
  unsigned __int16 *v9;
  uint64_t v11;
  uint64_t v13;
  char *v15;
  __int128 v16;

  v2 = malloc_type_malloc(0x11uLL, 0xC32A05B9uLL);
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (!Value)
    goto LABEL_23;
  v4 = Value;
  BytePtr = CFDataGetBytePtr(Value);
  if (!BytePtr)
    goto LABEL_24;
  Length = CFDataGetLength(v4);
  if (Length << 32 < 1)
  {
LABEL_23:
    BytePtr = 0;
    goto LABEL_24;
  }
  v7 = 0;
  v8 = (unint64_t)&BytePtr[(int)Length];
  while (1)
  {
    v9 = (unsigned __int16 *)(BytePtr + 6);
    if (*BytePtr == 221
      && (unint64_t)v9 <= v8
      && *(_DWORD *)(BytePtr + 2) == 116528896
      && (unint64_t)(BytePtr + 9) <= v8)
    {
      break;
    }
LABEL_10:
    v11 = BytePtr[1] + 2;
    v7 += v11;
    BytePtr += v11;
    if (v7 >= (int)Length)
      goto LABEL_23;
  }
  while (1)
  {
    v13 = *((unsigned __int8 *)v9 + 2);
    if (!(*v9 ^ 0x104 | v13 ^ 0x12) && (unint64_t)v9 + 21 <= v8)
      break;
    v15 = (char *)v9 + v13;
    v9 = (unsigned __int16 *)(v15 + 3);
    if ((unint64_t)(v15 + 6) > v8)
      goto LABEL_10;
  }
  v16 = *(_OWORD *)(v9 + 2);
  v2[16] = *((_BYTE *)v9 + 20);
  *(_OWORD *)v2 = v16;
  BytePtr = (const UInt8 *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s"), v2);
LABEL_24:
  free(v2);
  return BytePtr;
}

const UInt8 *sub_1000C4FE0(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  const __CFData *Value;
  const __CFData *v7;
  const UInt8 *result;
  const UInt8 *v9;
  CFIndex Length;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  __int16 v15;

  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (*a3 < 3u || Value == 0)
    return 0;
  v7 = Value;
  result = CFDataGetBytePtr(Value);
  if (!result)
    return result;
  v9 = result;
  Length = CFDataGetLength(v7);
  if (Length << 32 < 1)
    return 0;
  v11 = 0;
  while (1)
  {
    v12 = v9[1];
    if (*v9 == 7 && v12 >= 3)
      break;
    v14 = v12 + 2;
    v11 += v14;
    v9 += v14;
    if (v11 >= (int)Length)
      return 0;
  }
  v15 = *((_WORD *)v9 + 1);
  *(_BYTE *)(a2 + 2) = v9[4];
  *(_WORD *)a2 = v15;
  *a3 = 3;
  return (const UInt8 *)1;
}

BOOL sub_1000C50A0(_BOOL8 result)
{
  uint64_t v1;
  const __CFDictionary *v2;

  if (result)
  {
    v1 = result;
    v2 = *(const __CFDictionary **)(result + 16);
    return sub_10002CEF4(v2)
        || sub_10002CEB0(v2)
        || sub_10002CFA8(*(const __CFDictionary **)(v1 + 16)) != 0;
  }
  return result;
}

uint64_t sub_1000C50F4(uint64_t result)
{
  if (result)
    return sub_10002CEF4(*(const __CFDictionary **)(result + 16));
  return result;
}

uint64_t sub_1000C5104(uint64_t result)
{
  if (result)
    return sub_10002CEB0(*(const __CFDictionary **)(result + 16));
  return result;
}

const __CFDictionary *sub_1000C5114(const __CFDictionary *result)
{
  if (result)
    return sub_10002D1E0(*((const __CFDictionary **)result + 2));
  return result;
}

void *sub_1000C5124(void *result)
{
  const __CFDictionary *v1;
  const __CFDictionary *v2;
  int valuePtr;
  void *value;

  if (result)
  {
    v1 = (const __CFDictionary *)*((_QWORD *)result + 2);
    value = 0;
    valuePtr = 0;
    v2 = (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("EXT_CAPS"));
    result = 0;
    if (v2)
    {
      result = (void *)CFDictionaryGetValueIfPresent(v2, CFSTR("BEACON_PROTECTION"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = value;
        if (value)
        {
          CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
          return (void *)(valuePtr == 1);
        }
      }
    }
  }
  return result;
}

CFDictionaryRef *sub_1000C519C(CFDictionaryRef *result)
{
  if (result)
  {
    result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], CFSTR("RSN_IE"));
    if (result)
    {
      result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("IE_KEY_RSN_CAPS"));
      if (result)
      {
        result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("OCV"));
        if (result)
          return (CFDictionaryRef *)(CFBooleanGetValue((CFBooleanRef)result) == 1);
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1000C51F0(const __CFDictionary *result)
{
  if (result)
    return sub_10002CF48(*((const __CFDictionary **)result + 2));
  return result;
}

const __CFDictionary *sub_1000C5200(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  int valuePtr;
  void *value;

  if (result)
  {
    v1 = (const __CFDictionary *)*((_QWORD *)result + 2);
    value = 0;
    result = sub_10002CFA8(v1);
    if ((_DWORD)result)
    {
      result = sub_10002CF48(v1);
      if ((_DWORD)result)
      {
        result = (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("EXT_CAPS"));
        if (result)
        {
          valuePtr = -1431655766;
          result = (const __CFDictionary *)CFDictionaryGetValueIfPresent(result, CFSTR("SAE_PK_PASSWD_USED"), (const void **)&value);
          if ((_DWORD)result)
            return (const __CFDictionary *)(CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr)
                                         && valuePtr == 1);
        }
      }
    }
  }
  return result;
}

BOOL sub_1000C5294(_BOOL8 result)
{
  if (result)
    return (~sub_10002DB40(*(const __CFDictionary **)(result + 16)) & 7) == 0;
  return result;
}

BOOL sub_1000C52BC(_BOOL8 result)
{
  if (result)
    return (~sub_10002DB40(*(const __CFDictionary **)(result + 16)) & 0xB) == 0;
  return result;
}

const __CFDictionary *sub_1000C52E4(const __CFDictionary *result)
{
  if (result)
    return sub_10002CD50(*((const __CFDictionary **)result + 2));
  return result;
}

BOOL sub_1000C52F4(_BOOL8 result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    result = sub_10002DAB4(result);
    if (result)
      return sub_10002C798(v1, 17)
          || sub_10002C798(v1, 21)
          || sub_10002C798(v1, 25)
          || sub_10002C798(v1, 26)
          || sub_10002C798(v1, 43) != 0;
  }
  return result;
}

BOOL sub_1000C5378(uint64_t a1)
{
  return a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PayloadUUID"));
}

BOOL sub_1000C53B0(uint64_t a1)
{
  const __CFNumber *Value;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
    return 1;
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IsWiFiNetworkShareble"));
  if (!Value)
    return 1;
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  return valuePtr != 0;
}

BOOL sub_1000C5408(uint64_t a1)
{
  return a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("BundleIdentifier"));
}

void sub_1000C5440(uint64_t a1)
{
  if (sub_1000C5478(a1) != 0.0)
    CFAbsoluteTimeGetCurrent();
}

double sub_1000C5478(uint64_t a1)
{
  const __CFNumber *v1;
  void *v3;
  double valuePtr;

  valuePtr = 0.0;
  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetExpireDate");
    objc_autoreleasePoolPop(v3);
    return 0.0;
  }
  v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("WiFiNetworkExpirationDate"));
  if (!v1)
    return 0.0;
  CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
  return valuePtr;
}

void sub_1000C5508(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime;
  void *v4;

  if (a1)
  {
    if (theDate)
    {
      AbsoluteTime = CFDateGetAbsoluteTime(theDate);
      sub_1000179E8(a1, CFSTR("WiFiNetworkExpirationDate"), AbsoluteTime);
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null expire date, removing property", "WiFiNetworkSetExpireDate");
      objc_autoreleasePoolPop(v4);
      sub_10002C478(a1, CFSTR("WiFiNetworkExpirationDate"), 0);
    }
  }
}

BOOL sub_1000C55BC(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("WiFiNetworkExpirationDate")) != 0;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsExpirable");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000C563C(uint64_t a1, int a2)
{
  const void **v2;

  v2 = (const void **)&kCFBooleanTrue;
  if (!a2)
    v2 = (const void **)&kCFBooleanFalse;
  sub_10002C478(a1, CFSTR("WEP"), *v2);
}

void sub_1000C5664(uint64_t a1, int a2)
{
  CFMutableArrayRef Mutable;
  __CFArray *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  void *keys;
  uint64_t valuePtr;
  void *values;

  if (a2)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    values = Mutable;
    if (Mutable)
    {
      v4 = Mutable;
      valuePtr = 18;
      v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
      if (v5)
      {
        v6 = v5;
        CFArrayAppendValue(v4, v5);
        CFRelease(v6);
      }
      keys = CFSTR("IE_KEY_RSN_AUTHSELS");
      v7 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v7)
      {
        v8 = v7;
        sub_10002C478(a1, CFSTR("RSN_IE"), v7);
        CFRelease(v8);
      }
      CFRelease(values);
    }
  }
  else
  {
    sub_10002C478(a1, CFSTR("RSN_IE"), 0);
  }
}

void sub_1000C5774(uint64_t a1, int a2)
{
  CFDictionaryRef v3;
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  const __CFString *v7;
  CFTypeRef cf;
  uint64_t valuePtr;
  void *values;

  if (a2)
  {
    valuePtr = 1;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (cf)
      {
        v7 = CFSTR("IE_KEY_RSN_AUTHSELS");
        v3 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v7, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v3)
        {
          v4 = v3;
          sub_10002C478(a1, CFSTR("RSN_IE"), v3);
          CFRelease(v4);
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
      if (values)
      {
        CFRelease(values);
        values = 0;
      }
    }
    valuePtr = 1;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (cf)
      {
        v7 = CFSTR("IE_KEY_WPA_AUTHSELS");
        v5 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v7, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v5)
        {
          v6 = v5;
          sub_10002C478(a1, CFSTR("WPA_IE"), v5);
          CFRelease(v6);
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
      if (values)
        CFRelease(values);
    }
  }
  else
  {
    sub_10002C478(a1, CFSTR("RSN_IE"), 0);
    sub_10002C478(a1, CFSTR("WPA_IE"), 0);
    sub_10002C478(a1, CFSTR("EnterpriseProfile"), 0);
  }
}

BOOL sub_1000C5964(uint64_t a1)
{
  _BOOL8 result;

  if (!sub_10002DAB4(a1))
  {
    if (!sub_10003145C(a1))
    {
      if (a1)
      {
        if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("WEP")) != kCFBooleanTrue && !sub_10002DAF0(a1))
          return sub_10002CFA8(*(const __CFDictionary **)(a1 + 16)) != 0;
      }
      else
      {
        result = sub_10002DAF0(0);
        if (!result)
          return result;
      }
    }
    return 1;
  }
  return !sub_1000C5A2C(a1)
      && !sub_10002C798(a1, 18)
      && sub_10002C798(a1, 23) == 0;
}

const __CFArray *sub_1000C5A2C(uint64_t a1)
{
  const __CFArray *v2;
  CFNumberRef v3;
  CFNumberRef v4;
  int valuePtr;
  CFRange v7;

  if (!sub_10002DAB4(a1))
    return 0;
  v2 = (const __CFArray *)sub_10002BE64(a1, CFSTR("AcceptEAPTypes"));
  if (v2)
  {
    valuePtr = 13;
    v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v3)
    {
      v4 = v3;
      v7.length = CFArrayGetCount(v2);
      v7.location = 0;
      v2 = (const __CFArray *)(CFArrayGetFirstIndexOfValue(v2, v7, v4) != -1);
      CFRelease(v4);
      return v2;
    }
    return 0;
  }
  return v2;
}

BOOL sub_1000C5AD0(uint64_t a1)
{
  _BOOL8 result;
  const __CFArray *v3;
  const __CFArray *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFIndex FirstIndexOfValue;
  CFNumberRef v8;
  CFNumberRef v9;
  CFIndex v10;
  int v11;
  int valuePtr;
  CFRange v13;
  CFRange v14;

  v11 = 18;
  valuePtr = 13;
  result = sub_10002DAB4(a1);
  if (result)
  {
    v3 = (const __CFArray *)sub_10002BE64(a1, CFSTR("AcceptEAPTypes"));
    if (v3 && (v4 = v3, (v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr)) != 0))
    {
      v6 = v5;
      v13.length = CFArrayGetCount(v4);
      v13.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v13, v6);
      CFRelease(v6);
      v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v11);
      if (v8)
      {
        v9 = v8;
        v14.length = CFArrayGetCount(v4);
        v14.location = 0;
        v10 = CFArrayGetFirstIndexOfValue(v4, v14, v9);
        CFRelease(v9);
      }
      else
      {
        v10 = -1;
      }
      if (FirstIndexOfValue != -1)
        return 0;
    }
    else
    {
      v10 = -1;
    }
    return v10 == -1;
  }
  return result;
}

const void *sub_1000C5BD8(const void *result)
{
  if (result)
  {
    result = sub_10002BE64((uint64_t)result, CFSTR("OneTimeUserPassword"));
    if (result)
      return (const void *)(CFEqual(result, kCFBooleanTrue) != 0);
  }
  return result;
}

uint64_t sub_1000C5C14(uint64_t a1)
{
  return sub_10002CDC4(*(const __CFDictionary **)(a1 + 16));
}

uint64_t sub_1000C5C1C(unsigned int a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v8;

  if ((a1 & a2 & 4) == 0 || ((a2 ^ a1) & 8) != 0)
  {
    if (a1 >= a2)
      v8 = 0;
    else
      v8 = -1;
    if (a1 <= a2)
      return v8;
    else
      return 1;
  }
  else
  {
    v2 = a1 & 0xFFFFFFFB;
    v3 = a2 & 0xFFFFFFFB;
    if ((a1 & 0xFFFFFFFB) > (a2 & 0xFFFFFFFB))
      v4 = 1;
    else
      v4 = -1;
    if (v3)
      v5 = v4;
    else
      v5 = -1;
    if (v2)
      v6 = v5;
    else
      v6 = 1;
    if (v2 == v3)
      return 0;
    else
      return v6;
  }
}

uint64_t sub_1000C5C74(const __CFDictionary **cf, const __CFDictionary **a2)
{
  uint64_t result;
  CFTypeID v5;
  uint64_t v6;
  CFTypeID v7;
  uint64_t v8;
  int v9;
  int v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  int v13;
  CFBooleanRef Value;
  CFBooleanRef v15;
  CFBooleanRef v16;
  unint64_t v17;
  int v18;
  int v19;
  const __CFBoolean *v20;
  _BOOL4 v21;
  CFBooleanRef v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  _BOOL4 v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;

  result = 0;
  if (cf && a2)
  {
    v5 = CFGetTypeID(cf);
    v6 = qword_10026D6C8;
    if (!qword_10026D6C8)
    {
      pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
      v6 = qword_10026D6C8;
    }
    if (v5 != v6)
      return 0;
    v7 = CFGetTypeID(a2);
    v8 = qword_10026D6C8;
    if (!qword_10026D6C8)
    {
      pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
      v8 = qword_10026D6C8;
    }
    if (v7 != v8)
      return 0;
    v9 = sub_10002CDC4(cf[2]);
    v10 = sub_10002CDC4(a2[2]);
    v33 = sub_10002CFA8(cf[2])
       && (v11 = cf[2], !sub_10002CEF4(v11))
       && sub_10002CEB0(v11) == 0;
    v30 = v10;
    v13 = sub_10002CFA8(a2[2])
       && (v12 = a2[2], !sub_10002CEF4(v12))
       && sub_10002CEB0(v12) == 0;
    v31 = sub_10002CD50(cf[2]);
    v32 = sub_10002CD50(a2[2]);
    Value = (CFBooleanRef)CFDictionaryGetValue(cf[2], CFSTR("ALLOW_WPA2_PSK"));
    v15 = (CFBooleanRef)CFDictionaryGetValue(a2[2], CFSTR("ALLOW_WPA2_PSK"));
    v16 = (CFBooleanRef)CFDictionaryGetValue(cf[2], CFSTR("ALLOW_OWE_TSN"));
    v17 = (unint64_t)CFDictionaryGetValue(a2[2], CFSTR("ALLOW_OWE_TSN"));
    v18 = ((unint64_t)Value | (unint64_t)v16) == 0;
    v19 = ((unint64_t)v15 | v17) == 0;
    if (v18 != v19)
    {
      v20 = (const __CFBoolean *)v17;
      v29 = v9;
      if (v33)
      {
        v21 = sub_10003153C((uint64_t)cf) != 3;
        if ((v13 & 1) == 0)
        {
LABEL_20:
          v22 = kCFBooleanTrue;
LABEL_31:
          if (v15 == v22 && v21)
            return 0;
          v9 = v29;
          if ((v18 & v33) == 1 && sub_10003153C((uint64_t)cf) == 3)
            v9 = v29 | 2;
          if ((v19 & v13) == 1)
          {
            v25 = sub_10003153C((uint64_t)a2);
            v26 = v30;
            if (v25 == 3)
              v26 = v30 | 2;
            v30 = v26;
          }
          v27 = v31 && sub_10003153C((uint64_t)cf) != 3;
          if (v32)
          {
            v28 = sub_10003153C((uint64_t)a2);
            if (v16 == v22 && v28 != 3)
              return 0;
          }
          if (v20 == v22 && v27)
            return 0;
LABEL_23:
          if (!v9 || !v30 || (v30 & v9) != 0)
            return (v9 == 0) ^ (v30 != 0);
          return 0;
        }
      }
      else
      {
        v21 = 0;
        if ((v13 & 1) == 0)
          goto LABEL_20;
      }
      v23 = sub_10003153C((uint64_t)a2);
      v24 = Value == kCFBooleanTrue;
      v22 = kCFBooleanTrue;
      if (v24 && v23 != 3)
        return 0;
      goto LABEL_31;
    }
    result = 0;
    if (v33 == v13 && v31 == v32)
      goto LABEL_23;
  }
  return result;
}

uint64_t sub_1000C5F98(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1 && a2)
  {
    result = sub_10002D248(*(const void **)(a1 + 16), *(const __CFDictionary **)(a2 + 16));
    if ((_DWORD)result)
      return sub_10002D2A0(*(CFTypeRef *)(a1 + 16), *(const __CFDictionary **)(a1 + 16), CFSTR("AP_MODE")) != 0;
  }
  return result;
}

uint64_t sub_1000C5FEC(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return sub_1000C6000(a1, a2);
  else
    return 0;
}

uint64_t sub_1000C6000(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && sub_10002DA5C(a1) && sub_10002DA5C(a2))
    return sub_10002D2A0(*(CFTypeRef *)(a1 + 16), *(const __CFDictionary **)(a2 + 16), CFSTR("DomainName"));
  else
    return 0;
}

BOOL sub_1000C6060(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    if (a2)
      return sub_10002D2A0(*(CFTypeRef *)(a1 + 16), *(const __CFDictionary **)(a2 + 16), CFSTR("SSID_STR")) != 0;
  }
  return result;
}

uint64_t sub_1000C609C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  _BOOL4 v6;
  _BOOL4 v7;
  _BOOL4 v8;
  _BOOL4 v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  float v15;
  _BOOL4 v16;
  const __CFBoolean *v17;
  const __CFBoolean *v18;
  uint64_t valuePtr;

  if (a1 | a2)
    v3 = -1;
  else
    v3 = 0;
  if (a2)
    result = 1;
  else
    result = v3;
  if (!a1 || !a2)
    return result;
  v6 = sub_100013840(a1);
  v7 = sub_100013840(a2);
  v8 = sub_10002DA5C(a1);
  v9 = sub_10002DA5C(a2);
  if (v6 || v8 || v7 || v9)
  {
    v16 = !v6 && !v8;
    if (!v16 && !v7 && !v9)
      return 1;
    if (v16 && (v7 || v9))
      return -1;
    if (v6 && v9)
      return 1;
    if (v8 && v7)
      return -1;
    if (v8 && v9)
    {
      v17 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("HS20HomeOperatorNetwork"));
      v18 = (const __CFBoolean *)sub_10002BE64(a2, CFSTR("HS20HomeOperatorNetwork"));
      if (v17 == kCFBooleanTrue && v18 != kCFBooleanTrue)
        return -1;
      if (v17 != kCFBooleanTrue && v18 == kCFBooleanTrue)
        return 1;
    }
  }
  v10 = sub_10002CDC4(*(const __CFDictionary **)(a1 + 16));
  v11 = sub_10002CDC4(*(const __CFDictionary **)(a2 + 16));
  v12 = sub_1000C5C1C(v10, v11);
  if (v12 == 1)
    return -1;
  if (v12 == -1)
    return 1;
  valuePtr = 0;
  v13 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("Strength"));
  if (v13)
    CFNumberGetValue(v13, kCFNumberFloatType, (char *)&valuePtr + 4);
  v14 = (const __CFNumber *)sub_10002BE64(a2, CFSTR("Strength"));
  if (v14)
  {
    CFNumberGetValue(v14, kCFNumberFloatType, &valuePtr);
    v15 = *(float *)&valuePtr;
  }
  else
  {
    v15 = 0.0;
  }
  if (*((float *)&valuePtr + 1) <= v15)
    return *((float *)&valuePtr + 1) < v15;
  else
    return -1;
}

BOOL sub_1000C6274(uint64_t a1)
{
  return sub_10002BE64(a1, CFSTR("HS20HomeOperatorNetwork")) == kCFBooleanTrue;
}

__CFString *sub_1000C62A4(CFDictionaryRef *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  __CFString *v4;

  if (sub_100007E20((uint64_t)a1) < 2)
    return 0;
  v2 = sub_1000C37A0(a1);
  if (v2 && !sub_10002BE64((uint64_t)a1, CFSTR("RSN_IE")))
  {
    v3 = sub_10003149C(a1);
    v4 = sub_1000D9368(v2, (const __CFData *)v3);
    CFRelease(v2);
    return v4;
  }
  return (__CFString *)v2;
}

__CFString *sub_1000C6320(const void *a1, const __CFString *a2)
{
  const __CFString *v3;

  v3 = sub_10003149C(a1);
  return sub_1000D9368(a2, (const __CFData *)v3);
}

uint64_t sub_1000C6348(CFDictionaryRef *a1, BOOL *a2, double a3)
{
  const __CFString *v6;
  uint64_t result;
  const __CFString *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const __CFString *v12;

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 136315394;
    v10 = "WiFiNetworkCopyPasswordWithTimeout";
    v11 = 2112;
    v12 = sub_1000C3C04(a1);
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: Copy password for Network/account %@", (uint8_t *)&v9, 0x16u);
  }
  if (!a1
    || !CFDictionaryContainsKey(a1[2], CFSTR("PayloadUUID"))
    || (v6 = sub_1000C3C04(a1), (result = sub_1000D98C4(v6, a2, a3)) == 0))
  {
    v8 = sub_1000C3C04(a1);
    return sub_1000D7AA0(v8, a2, a3);
  }
  return result;
}

uint64_t sub_1000C6458(const void *a1, const __CFString *a2, BOOL *a3, double a4)
{
  const __CFString *v7;

  v7 = sub_1000C3C04(a1);
  return sub_1000D8680(v7, a2, a3, a4);
}

CFStringRef sub_1000C6494(const void *a1)
{
  const __CFString *v1;

  v1 = sub_1000C3C04(a1);
  return sub_1000D84EC(v1);
}

CFStringRef sub_1000C64A8(const void *a1)
{
  const __CFString *v1;

  v1 = sub_1000C3C04(a1);
  return sub_1000D96B0(v1);
}

uint64_t sub_1000C64BC(const void *a1, BOOL *a2, double a3)
{
  const __CFString *v5;

  v5 = sub_1000C3C04(a1);
  return sub_1000D98C4(v5, a2, a3);
}

BOOL sub_1000C64F0(const void *a1, const __CFString *a2)
{
  __CFString *v3;
  int v5;
  const char *v6;
  __int16 v7;
  __CFString *v8;

  v3 = (__CFString *)sub_1000C3C04(a1);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136315394;
    v6 = "WiFiNetworkSetPassword";
    v7 = 2112;
    v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: Set password for Network/account %@", (uint8_t *)&v5, 0x16u);
  }
  return sub_1000D8A4C(v3, a2);
}

BOOL sub_1000C65B4(const void *a1, const __CFString *a2)
{
  __CFString *v3;

  v3 = (__CFString *)sub_1000C3C04(a1);
  return sub_1000D8DE8(v3, a2);
}

uint64_t sub_1000C65D8(const void *a1)
{
  const __CFString *v2;
  int v4;
  const char *v5;
  __int16 v6;
  const __CFString *v7;

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315394;
    v5 = "WiFiNetworkRemovePassword";
    v6 = 2112;
    v7 = sub_1000C3C04(a1);
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: Remove password for Network/account %@", (uint8_t *)&v4, 0x16u);
  }
  v2 = sub_1000C3C04(a1);
  return sub_1000D8DF0(v2);
}

uint64_t sub_1000C669C(const void *a1)
{
  const __CFString *v1;

  v1 = sub_1000C3C04(a1);
  return sub_1000D8F80(v1);
}

CFStringRef sub_1000C66B0(CFDictionaryRef *a1)
{
  CFStringRef result;

  result = sub_1000C37A0(a1);
  if (result)
  {
    CFRelease(result);
    return (CFStringRef)1;
  }
  return result;
}

uint64_t sub_1000C66D0(void *a1)
{
  uint64_t result;
  const void *v3;
  const void *v4;

  if (!sub_1000C5964((uint64_t)a1))
    return 1;
  result = (uint64_t)sub_1000C3718((uint64_t)a1);
  if (result)
  {
LABEL_3:
    CFRelease((CFTypeRef)result);
    return 1;
  }
  v3 = sub_10002B088(a1);
  v4 = sub_10002BE64((uint64_t)a1, CFSTR("HS20AccountName"));
  if (!v3 || v4 && CFEqual(v3, v4))
    return 0;
  result = (uint64_t)sub_1000C37A0((CFDictionaryRef *)a1);
  if (result)
    goto LABEL_3;
  return result;
}

uint64_t sub_1000C6754()
{
  return 1;
}

uint64_t sub_1000C675C(const void *a1)
{
  const __CFString *v1;

  v1 = sub_1000C3C04(a1);
  return sub_1000D8F88(v1);
}

void sub_1000C6770(uint64_t a1, int a2)
{
  const void **v4;
  __CFDictionary *v5;
  __CFDictionary *v6;
  const __CFString *v7;

  if (a1)
  {
    v4 = (const void **)&kCFBooleanTrue;
    v5 = *(__CFDictionary **)(a1 + 16);
    if (!a2)
      v4 = (const void **)&kCFBooleanFalse;
    CFDictionarySetValue(v5, CFSTR("enabled"), *v4);
    if (a2)
    {
      sub_1000C682C(a1, 0);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledTimestamp"));
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledReason"));
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledClientName"));
      v6 = *(__CFDictionary **)(a1 + 16);
      v7 = CFSTR("prevJoined");
    }
    else
    {
      v6 = *(__CFDictionary **)(a1 + 16);
      v7 = CFSTR("WiFiNetworkUserAcceptedRecommendationAt");
    }
    CFDictionaryRemoveValue(v6, v7);
  }
}

void sub_1000C682C(uint64_t a1, const void *a2)
{
  const void *v2;
  const void *v3;
  void *v4;

  if (a1)
  {
    v2 = a2;
    v3 = (const void *)a1;
    if (!a2)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Clearing disable-until property for SSID '%@'", "WiFiNetworkSetDisabledUntilDate", sub_10002B088(v3));
      objc_autoreleasePoolPop(v4);
      a1 = (uint64_t)v3;
      v2 = 0;
    }
    sub_10002C478(a1, CFSTR("WiFiNetworkDisabledUntilDate"), v2);
  }
}

void sub_1000C68E8(CFMutableDictionaryRef *a1, int a2, const void *a3)
{
  CFTypeID TypeID;
  _BOOL4 v7;
  CFAbsoluteTime Current;
  CFDateRef v9;
  CFDateRef v10;

  if (a1)
  {
    if (a3)
    {
      TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          sub_10018712C(a1, a2, (uint64_t)a3);
        v7 = sub_100007F24((uint64_t)a1);
        if (!a2 && v7)
        {
          sub_10002C478((uint64_t)a1, CFSTR("networkDisabledReason"), a3);
          Current = CFAbsoluteTimeGetCurrent();
          v9 = CFDateCreate(kCFAllocatorDefault, Current);
          if (v9)
          {
            v10 = v9;
            CFDictionarySetValue(a1[2], CFSTR("networkDisabledTimestamp"), v9);
            CFRelease(v10);
          }
        }
      }
    }
  }
  sub_1000C6770((uint64_t)a1, a2);
}

BOOL sub_1000C69C8(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("enabled")) != 0;
}

void sub_1000C69F0(const void *a1, int a2, const void *a3)
{
  const void *v6;
  __CFString *v7;

  v6 = (const void *)sub_10002E000(a1);
  if (v6)
    sub_10002C478((uint64_t)a1, CFSTR("prevJoined"), v6);
  if (a2)
    v7 = CFSTR("lastJoined");
  else
    v7 = CFSTR("lastAutoJoined");
  sub_10002C478((uint64_t)a1, v7, a3);
}

const void *sub_1000C6A58(uint64_t a1, int a2)
{
  __CFString *v2;

  if (a2)
    v2 = CFSTR("lastJoined");
  else
    v2 = CFSTR("lastAutoJoined");
  return sub_10002BE64(a1, v2);
}

double sub_1000C6A74(const void *a1)
{
  const __CFDate *v2;
  const __CFDate *v3;
  double result;

  v2 = (const __CFDate *)sub_10002E000(a1);
  v3 = (const __CFDate *)sub_10002BE64((uint64_t)a1, CFSTR("prevJoined"));
  if (v2 && v3)
    return CFDateGetTimeIntervalSinceDate(v2, v3);
  result = -1.0;
  if (v2)
    return 0.0;
  return result;
}

void sub_1000C6AD4(uint64_t a1, double a2)
{
  sub_1000179E8(a1, CFSTR("networkUsage"), a2);
}

const void *sub_1000C6AE4(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("CHANNEL_FLAGS"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetChannelFlags");
  objc_autoreleasePoolPop(v2);
  return 0;
}

const __CFNumber *sub_1000C6B54(uint64_t a1)
{
  const __CFNumber *v1;

  v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("PHY_MODE"));
  return sub_10001F500(v1);
}

uint64_t sub_1000C6B74(int a1)
{
  uint64_t v2;

  if (a1 < 1)
    return 0;
  if (a1 < 0xF)
    return 1;
  v2 = 0;
  while (dword_10026CBD8[v2] != a1)
  {
    if (++v2 == 33)
      return 0;
  }
  return 2;
}

void sub_1000C6BC0(const void *a1)
{
  CFAbsoluteTime Current;
  CFDateRef v3;
  CFDateRef v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  const __CFDictionary *v11;
  CFIndex v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  const void *Value;
  __CFDictionary *MutableCopy;
  __CFDictionary *v17;
  const __CFNumber *v18;
  const __CFArray *v19;
  const __CFArray *v20;
  CFIndex v21;
  const __CFNumber *v22;
  const void *v23;
  const __CFNumber *v24;
  const void *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const void *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  const void *v31;
  void *v32;
  void *v33;
  const void *v34;
  const void *v35;
  const __CFDate *v36;
  __CFArray *theArray;
  CFTypeRef cf2;
  int v39;
  int valuePtr;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(kCFAllocatorDefault, Current);
  v4 = v3;
  if (!a1 || !v3)
    goto LABEL_47;
  v5 = sub_10002BE64((uint64_t)a1, CFSTR("CHANNEL"));
  if (v5)
  {
    v6 = v5;
    v7 = sub_10002BE64((uint64_t)a1, CFSTR("CHANNEL_FLAGS"));
    if (v7)
    {
      v8 = v7;
      cf2 = sub_10002BE64((uint64_t)a1, CFSTR("BSSID"));
      if (cf2)
      {
        theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (theArray)
        {
          v9 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
          if (!v9)
            goto LABEL_18;
          v10 = v9;
          if (CFArrayGetCount(v9) < 1)
            goto LABEL_18;
          v11 = 0;
          v12 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v12);
            if (ValueAtIndex)
            {
              v14 = ValueAtIndex;
              Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
              if (Value)
              {
                if (CFEqual(Value, cf2))
                  v11 = v14;
                else
                  CFArrayAppendValue(theArray, v14);
              }
            }
            ++v12;
          }
          while (v12 < CFArrayGetCount(v10));
          if (v11)
            MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v11);
          else
LABEL_18:
            MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v17 = MutableCopy;
          if (MutableCopy)
          {
            CFDictionarySetValue(MutableCopy, CFSTR("BSSID"), cf2);
            CFDictionarySetValue(v17, CFSTR("CHANNEL"), v6);
            CFDictionarySetValue(v17, CFSTR("CHANNEL_FLAGS"), v8);
            CFDictionarySetValue(v17, CFSTR("lastRoamed"), v4);
            v18 = (const __CFNumber *)sub_10002BE64((uint64_t)a1, CFSTR("CHANNEL_FLAGS"));
            if (v18)
            {
              valuePtr = 0;
              CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
              if ((valuePtr & 0x2000) != 0)
              {
                v19 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("ORIG_RNR_CHANNEL_LIST"));
                if (v19)
                {
                  v20 = v19;
                  if (CFArrayGetCount(v19) >= 1)
                  {
                    v34 = v6;
                    v35 = a1;
                    v36 = v4;
                    v21 = 0;
                    v22 = 0;
                    v23 = 0;
                    v24 = 0;
                    v25 = 0;
                    while (!v25 || !v23)
                    {
                      v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v21);
                      if (v26)
                      {
                        v27 = v26;
                        v28 = CFDictionaryGetValue(v26, CFSTR("CHANNEL"));
                        v29 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("CHANNEL_FLAGS"));
                        if (v28)
                        {
                          v30 = v29;
                          if (v29)
                          {
                            v39 = 0;
                            CFNumberGetValue(v29, kCFNumberSInt32Type, &v39);
                            if ((v39 & 8) != 0)
                            {
                              v25 = v28;
                              v24 = v30;
                            }
                            else if ((v39 & 0x10) != 0)
                            {
                              v23 = v28;
                              v22 = v30;
                            }
                          }
                        }
                      }
                      if (CFArrayGetCount(v20) <= ++v21)
                      {
                        if (!v23)
                          goto LABEL_37;
                        break;
                      }
                    }
                    CFDictionarySetValue(v17, CFSTR("colocated5GHzRNRChannel"), v23);
                    CFDictionarySetValue(v17, CFSTR("colocated5GHzRNRChannelFlags"), v22);
LABEL_37:
                    a1 = v35;
                    v4 = v36;
                    v6 = v34;
                    if (v25)
                    {
                      CFDictionarySetValue(v17, CFSTR("colocated2GHzRNRChannel"), v25);
                      CFDictionarySetValue(v17, CFSTR("colocated2GHzRNRChannelFlags"), v24);
                    }
                  }
                }
              }
            }
            v31 = sub_10002BE64((uint64_t)a1, CFSTR("LEAKY_AP_LEARNED_DATA"));
            if (v31)
            {
              CFDictionarySetValue(v17, CFSTR("LEAKY_AP_LEARNED_DATA"), v31);
              sub_10002C478((uint64_t)a1, CFSTR("LEAKY_AP_LEARNED_DATA"), 0);
              v32 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: moved leaky AP info to bss dictionary", "WiFiNetworkPrepareKnownBssList");
              objc_autoreleasePoolPop(v32);
            }
            CFArrayAppendValue(theArray, v17);
            sub_10002C478((uint64_t)a1, CFSTR("networkKnownBSSListKey"), theArray);
            v33 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: successfully prepared known BSS info for %@ (bssid: %@, channel: %@)", "WiFiNetworkPrepareKnownBssList", sub_10002B088(a1), cf2, v6);
            objc_autoreleasePoolPop(v33);
            CFRelease(theArray);
          }
          else
          {
            v17 = theArray;
          }
          CFRelease(v17);
LABEL_47:
          if (!v4)
            return;
        }
      }
    }
  }
  CFRelease(v4);
}

void sub_1000C7018(uint64_t a1, CFArrayRef theArray)
{
  const __CFArray *v4;
  const __CFArray *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  const void *Value;
  const void *v12;
  void *v13;
  void *v14;
  CFRange v15;

  if (a1)
  {
    if (theArray)
    {
      if (CFArrayGetCount(theArray) >= 1)
      {
        v4 = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
        if (v4)
        {
          v5 = v4;
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (Mutable)
          {
            v7 = Mutable;
            if (CFArrayGetCount(v5) >= 1)
            {
              v8 = 0;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v8);
                if (ValueAtIndex)
                {
                  v10 = ValueAtIndex;
                  Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
                  if (Value)
                  {
                    v12 = Value;
                    v15.length = CFArrayGetCount(theArray);
                    v15.location = 0;
                    if (CFArrayGetFirstIndexOfValue(theArray, v15, v12) == -1)
                    {
                      CFArrayAppendValue(v7, v10);
                    }
                    else
                    {
                      v13 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Removed known BSS from index %ld", "WiFiNetworkRemoveBssFromKnownList", v8);
                      objc_autoreleasePoolPop(v13);
                    }
                  }
                }
                ++v8;
              }
              while (v8 < CFArrayGetCount(v5));
            }
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updated known BSS list after removal - %@", "WiFiNetworkRemoveBssFromKnownList", v7);
            objc_autoreleasePoolPop(v14);
            sub_10002C478(a1, CFSTR("networkKnownBSSListKey"), v7);
            CFRelease(v7);
          }
        }
      }
    }
  }
}

void sub_1000C71DC(const void *a1, const void *a2)
{
  CFAbsoluteTime Current;
  CFDateRef v5;
  void *v6;
  void *v7;
  const void *v8;
  const void *v9;
  CFMutableArrayRef Mutable;
  __CFArray *v11;
  void *v12;
  const __CFArray *v13;
  const __CFArray *v14;
  const __CFDictionary *v15;
  CFIndex v16;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v18;
  const void *v19;
  __CFDictionary *MutableCopy;
  __CFDictionary *v21;
  void *v22;
  void *v23;
  void *v24;
  const void *v25;
  void *v26;
  const __CFDate *v27;
  void *v28;
  void *value;

  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(kCFAllocatorDefault, Current);
  if (!a1 || !a2)
    goto LABEL_30;
  v6 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("CHANNEL"));
  v7 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("CHANNEL_FLAGS"));
  v8 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
  if (v8)
  {
    v9 = v8;
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      v11 = Mutable;
      v28 = v7;
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BSS updated - current BSS: %@ (%@)", "WiFiNetworkSetKnownBssUsageData", v9, v6);
      value = v6;
      objc_autoreleasePoolPop(v12);
      v13 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
      if (!v13)
        goto LABEL_20;
      v14 = v13;
      v27 = v5;
      if (CFArrayGetCount(v13) < 1)
      {
        v15 = 0;
      }
      else
      {
        v15 = 0;
        v16 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, v16);
          if (ValueAtIndex)
          {
            v18 = ValueAtIndex;
            v19 = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
            if (v19)
            {
              if (CFEqual(v19, v9))
                v15 = v18;
              else
                CFArrayAppendValue(v11, v18);
            }
          }
          ++v16;
        }
        while (v16 < CFArrayGetCount(v14));
      }
      v5 = v27;
      if (v15)
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v15);
      else
LABEL_20:
        MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v21 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, CFSTR("BSSID"), v9);
        CFDictionarySetValue(v21, CFSTR("CHANNEL"), value);
        CFDictionarySetValue(v21, CFSTR("CHANNEL_FLAGS"), v28);
        CFDictionarySetValue(v21, CFSTR("lastRoamed"), v5);
        CFArrayAppendValue(v11, v21);
        if (CFArrayGetCount(v11) >= 21)
        {
          v22 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: known BSS list has grown beyond maximum. Removing %@", "WiFiNetworkSetKnownBssUsageData", CFArrayGetValueAtIndex(v11, 0));
          objc_autoreleasePoolPop(v22);
          CFArrayRemoveValueAtIndex(v11, 0);
        }
        v23 = objc_autoreleasePoolPush();
        v24 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v25 = sub_10002B088(a1);
          objc_msgSend(v24, "WFLog:message:", 2, "%s: known BSS stats for %@ - num. of BSS = %ld", "WiFiNetworkSetKnownBssUsageData", v25, CFArrayGetCount(v11));
        }
        objc_autoreleasePoolPop(v23);
        sub_10002C478((uint64_t)a2, CFSTR("networkKnownBSSListKey"), v11);
        sub_10002C478((uint64_t)a1, CFSTR("networkKnownBSSListKey"), v11);
        CFRelease(v21);
      }
      CFRelease(v11);
    }
LABEL_30:
    if (!v5)
      return;
    goto LABEL_31;
  }
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get BSSID from %@", "WiFiNetworkSetKnownBssUsageData", sub_10002B088(a2));
  objc_autoreleasePoolPop(v26);
  if (v5)
LABEL_31:
    CFRelease(v5);
}

void sub_1000C7578(const void *a1, const void *a2, double a3, double a4, double a5)
{
  const void *v10;
  const void *v11;
  CFMutableArrayRef Mutable;
  __CFArray *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  const __CFDictionary *v16;
  CFIndex v17;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v19;
  const void *Value;
  __CFDictionary *MutableCopy;
  __CFDictionary *v22;
  void *v23;

  if (a1 && a2)
  {
    v10 = sub_10002BE64((uint64_t)a1, CFSTR("BSSID"));
    if (v10)
    {
      v11 = v10;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        v13 = Mutable;
        v14 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
        if (v14)
        {
          v15 = v14;
          if (CFArrayGetCount(v14) >= 1)
          {
            v16 = 0;
            v17 = 0;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v17);
              if (ValueAtIndex)
              {
                v19 = ValueAtIndex;
                Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
                if (Value)
                {
                  if (CFEqual(Value, v11))
                    v16 = v19;
                  else
                    CFArrayAppendValue(v13, v19);
                }
              }
              ++v17;
            }
            while (v17 < CFArrayGetCount(v15));
            if (v16)
            {
              MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v16);
              if (MutableCopy)
              {
                v22 = MutableCopy;
                CFDictionarySetValue(MutableCopy, CFSTR("networkLocnLat"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a3));
                CFDictionarySetValue(v22, CFSTR("networkLocnLong"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a4));
                CFDictionarySetValue(v22, CFSTR("networkLocnAccuracy"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a5));
                CFDictionarySetValue(v22, CFSTR("networkLocnTimestamp"), a2);
                CFArrayAppendValue(v13, v22);
                sub_10002C478((uint64_t)a1, CFSTR("networkKnownBSSListKey"), v13);
                CFRelease(v22);
              }
            }
          }
        }
        CFRelease(v13);
      }
    }
    else
    {
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSLocation", sub_10002B088(a1));
      objc_autoreleasePoolPop(v23);
    }
  }
}

void sub_1000C7808(const void *a1, const __CFString *a2, uint64_t a3)
{
  const void *v6;
  CFMutableArrayRef Mutable;
  __CFArray *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  const __CFString *Value;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v16;
  const void *v17;
  void *v18;

  if (a1 && a3)
  {
    v6 = sub_10002B088(a1);
    if (a2)
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        v8 = Mutable;
        v9 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
        if (v9)
        {
          v10 = v9;
          if (CFArrayGetCount(v9) >= 1)
          {
            v11 = 0;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v11);
              if (ValueAtIndex)
              {
                v13 = ValueAtIndex;
                Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
                if (Value)
                {
                  if (CFStringCompare(Value, a2, 1uLL))
                  {
                    CFArrayAppendValue(v8, v13);
                  }
                  else
                  {
                    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v13);
                    if (MutableCopy)
                    {
                      v16 = MutableCopy;
                      (*(void (**)(uint64_t, CFMutableDictionaryRef))(a3 + 16))(a3, MutableCopy);
                      CFArrayAppendValue(v8, v16);
                      CFRelease(v16);
                    }
                  }
                }
              }
              ++v11;
            }
            while (v11 < CFArrayGetCount(v10));
          }
        }
        sub_10002C478((uint64_t)a1, CFSTR("networkKnownBSSListKey"), v8);
        CFRelease(v8);
      }
    }
    else
    {
      v17 = v6;
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSProperty", v17);
      objc_autoreleasePoolPop(v18);
    }
  }
}

void sub_1000C79E0(const void *a1, const void *a2)
{
  const void *v4;
  const void *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  void *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  const __CFDictionary *v11;
  CFIndex v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  const void *Value;
  __CFDictionary *MutableCopy;
  __CFDictionary *v17;
  void *v18;

  if (a1 && a2)
  {
    v4 = sub_10002BE64((uint64_t)a1, CFSTR("BSSID"));
    if (v4)
    {
      v5 = v4;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        v7 = Mutable;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BSS updated - current BSS: %@ (awdl=%@)", "WiFiNetworkSetBSSAWDLRealTimeModeTimestamp", v5, a2);
        objc_autoreleasePoolPop(v8);
        v9 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
        if (v9)
        {
          v10 = v9;
          if (CFArrayGetCount(v9) >= 1)
          {
            v11 = 0;
            v12 = 0;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v12);
              if (ValueAtIndex)
              {
                v14 = ValueAtIndex;
                Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
                if (Value)
                {
                  if (CFEqual(Value, v5))
                    v11 = v14;
                  else
                    CFArrayAppendValue(v7, v14);
                }
              }
              ++v12;
            }
            while (v12 < CFArrayGetCount(v10));
            if (v11)
            {
              MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v11);
              if (MutableCopy)
              {
                v17 = MutableCopy;
                CFDictionarySetValue(MutableCopy, CFSTR("AWDLRealTimeModeTimestamp"), a2);
                CFArrayAppendValue(v7, v17);
                sub_10002C478((uint64_t)a1, CFSTR("networkKnownBSSListKey"), v7);
                CFRelease(v17);
              }
            }
          }
        }
        CFRelease(v7);
      }
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSAWDLRealTimeModeTimestamp", sub_10002B088(a1));
      objc_autoreleasePoolPop(v18);
    }
  }
}

void sub_1000C7C1C(uint64_t a1, const void *a2, int a3, int a4)
{
  const void *v8;
  const void *v9;
  __CFArray *Mutable;
  void *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const __CFDictionary *v14;
  CFIndex v15;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v17;
  const void *Value;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  void *v23;
  const __CFDictionary *v24;
  __CFDictionary *v25;
  const __CFNumber *v26;
  CFNumberRef v27;
  CFNumberRef v28;
  const __CFNumber *v29;
  CFNumberRef v30;
  CFNumberRef v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  int v38;
  int v39;
  int valuePtr;
  int v41;
  int v42;

  v41 = a4;
  v42 = a3;
  if (a1 && a2)
  {
    v8 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    if (v8)
    {
      v9 = v8;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      v11 = objc_autoreleasePoolPush();
      if (Mutable)
      {
        v38 = a4;
        v39 = a3;
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BSS late roam data - %@ current BSS: %@", "WiFiNetworkSetBssLateRoamInfo", sub_10002B088(a2), v9);
        objc_autoreleasePoolPop(v11);
        v12 = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
        if (!v12)
          goto LABEL_46;
        v13 = v12;
        if (CFArrayGetCount(v12) < 1)
        {
          v14 = 0;
        }
        else
        {
          v14 = 0;
          v15 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v15);
            if (ValueAtIndex)
            {
              v17 = ValueAtIndex;
              Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
              if (Value)
              {
                if (CFEqual(Value, v9))
                  v14 = v17;
                else
                  CFArrayAppendValue(Mutable, v17);
              }
            }
            ++v15;
          }
          while (v15 < CFArrayGetCount(v13));
        }
        if (!v14)
          goto LABEL_46;
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v14);
        if (!MutableCopy)
        {
          v34 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create newBssDict", "WiFiNetworkSetBssLateRoamInfo");
          objc_autoreleasePoolPop(v34);
          goto LABEL_46;
        }
        v20 = MutableCopy;
        v21 = (const __CFDictionary *)CFDictionaryGetValue(v14, CFSTR("lateRoamInfo"));
        if (v21)
        {
          v22 = v21;
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Creating new Late Roam Info %@ - %@", "WiFiNetworkSetBssLateRoamInfo", sub_10002B088(a2), v9);
          objc_autoreleasePoolPop(v23);
          v24 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v22);
        }
        else
        {
          v24 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        }
        v25 = v24;
        if (!v24)
        {
          v35 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create newLateRoamInfoDict", "WiFiNetworkSetBssLateRoamInfo");
          objc_autoreleasePoolPop(v35);
          goto LABEL_45;
        }
        v26 = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("lateRoamMinDelta"));
        if (v26 && (valuePtr = 0, CFNumberGetValue(v26, kCFNumberIntType, &valuePtr)) && valuePtr <= v39)
        {
          v27 = 0;
        }
        else
        {
          v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v42);
          if (!v28)
          {
            v36 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create newMinDeltaRef", "WiFiNetworkSetBssLateRoamInfo");
            objc_autoreleasePoolPop(v36);
            goto LABEL_44;
          }
          v27 = v28;
          CFDictionarySetValue(v25, CFSTR("lateRoamMinDelta"), v28);
        }
        v29 = (const __CFNumber *)CFDictionaryGetValue(v25, CFSTR("lateRoamMaxDelta"));
        if (v29 && (valuePtr = 0, CFNumberGetValue(v29, kCFNumberIntType, &valuePtr)) && valuePtr >= v38)
        {
          v30 = 0;
        }
        else
        {
          v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v41);
          if (!v31)
          {
            v37 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create newMaxDeltaRef", "WiFiNetworkSetBssLateRoamInfo");
            objc_autoreleasePoolPop(v37);
            v30 = 0;
            if (!v27)
              goto LABEL_42;
LABEL_41:
            CFRelease(v27);
LABEL_42:
            if (v30)
              CFRelease(v30);
LABEL_44:
            CFRelease(v25);
LABEL_45:
            CFRelease(v20);
LABEL_46:
            CFRelease(Mutable);
            return;
          }
          v30 = v31;
          CFDictionarySetValue(v25, CFSTR("lateRoamMaxDelta"), v31);
        }
        CFDictionarySetValue(v20, CFSTR("lateRoamInfo"), v25);
        CFArrayAppendValue(Mutable, v20);
        v32 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updated BSS late roam data - %@ current BSS: %@", "WiFiNetworkSetBssLateRoamInfo", sub_10002B088(a2), v9);
        objc_autoreleasePoolPop(v32);
        sub_10002C478((uint64_t)a2, CFSTR("networkKnownBSSListKey"), Mutable);
        sub_10002C478(a1, CFSTR("networkKnownBSSListKey"), Mutable);
        if (!v27)
          goto LABEL_42;
        goto LABEL_41;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create newBssList", "WiFiNetworkSetBssLateRoamInfo");
      objc_autoreleasePoolPop(v11);
    }
    else
    {
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to get BSSID from %@", "WiFiNetworkSetBssLateRoamInfo", sub_10002B088(a2));
      objc_autoreleasePoolPop(v33);
    }
  }
}

void sub_1000C8160(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  double Current;
  int v7;
  CFAbsoluteTime v8;
  const __CFDate *v9;
  CFDateRef v10;
  double v11;
  int v12;
  void *v13;
  char v14;
  const __CFArray *v15;
  CFMutableArrayRef Mutable;
  __CFArray *v17;
  CFIndex v18;
  const __CFString *v19;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v21;
  const __CFString *Value;
  const __CFString *v23;
  const __CFNumber *v24;
  int v25;
  const __CFNumber *v26;
  int v27;
  int v28;
  uint64_t v29;
  const __CFString *v30;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  void *v37;
  uint64_t v38;
  CFDateRef cf;
  int v40;
  int v41;
  int v42;
  char v43;
  char v44;
  int valuePtr;
  int v46;
  int v47;

  Current = CFAbsoluteTimeGetCurrent();
  v47 = 0;
  valuePtr = 0;
  v46 = 0;
  if (!a1 || !a2)
    return;
  v7 = a3 - 3;
  if ((a3 - 3) >= 3)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Incorrect reason code, bailing out!");
    objc_autoreleasePoolPop(v13);
    return;
  }
  v8 = Current;
  v40 = dword_1001BBA74[v7];
  v41 = dword_1001BBA68[v7];
  v9 = (const __CFDate *)sub_10002BE64(a1, CFSTR("knownBSSUpdatedDate"));
  v10 = CFDateCreate(kCFAllocatorDefault, v8);
  if (!v9)
  {
    v12 = 1;
    goto LABEL_12;
  }
  v11 = v8 - CFDateGetAbsoluteTime(v9);
  if (v11 > 2592000.0)
  {
    v12 = 0;
    LOBYTE(v9) = 1;
LABEL_12:
    sub_10002C478(a1, CFSTR("knownBSSUpdatedDate"), v10);
    v14 = v12;
    v44 = (char)v9;
    goto LABEL_13;
  }
  LOBYTE(v9) = 0;
  v14 = 0;
  v12 = 1;
  v44 = 1;
  if (v11 > 1296000.0)
    goto LABEL_12;
LABEL_13:
  v42 = v12;
  v38 = a1;
  cf = v10;
  v15 = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    v17 = Mutable;
    if (v15 && CFArrayGetCount(v15) >= 1)
    {
      v18 = 0;
      v43 = v14 | v9;
      v19 = CFSTR("BSSID");
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v18);
        if (!ValueAtIndex)
          goto LABEL_46;
        v21 = ValueAtIndex;
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v19);
        if (!Value)
          goto LABEL_46;
        v23 = Value;
        if (CFStringCompare(Value, a2, 0))
        {
          v46 = 0;
          v47 = 0;
          if ((v43 & 1) == 0)
          {
            CFArrayAppendValue(v17, v21);
            goto LABEL_46;
          }
        }
        else
        {
          v47 = v41;
          v46 = v40;
        }
        v24 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("beaconLossCount"));
        if (v24)
        {
          CFNumberGetValue(v24, kCFNumberIntType, &valuePtr);
          if ((v44 & 1) != 0)
          {
            if (!v42)
              goto LABEL_29;
            v25 = valuePtr & 0xFF00 | (v47 + valuePtr);
          }
          else
          {
            v25 = v47 | (valuePtr << 8);
          }
          v47 = v25;
        }
LABEL_29:
        v26 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("trigDisconnectCount"));
        if (!v26)
          goto LABEL_35;
        CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
        if ((v44 & 1) != 0)
        {
          if (!v42)
            goto LABEL_35;
          v27 = valuePtr & 0xFF00 | (v46 + valuePtr);
        }
        else
        {
          v27 = v46 | (valuePtr << 8);
        }
        v46 = v27;
LABEL_35:
        v28 = CFEqual(v23, a2);
        v29 = a3;
        if ((_DWORD)a3 == 5 && v28)
        {
          v46 = 0;
          v47 = 0;
        }
        v30 = v19;
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v21);
        if (!MutableCopy)
          goto LABEL_48;
        v32 = MutableCopy;
        v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v47);
        if (v33)
        {
          v34 = v33;
          CFDictionarySetValue(v32, CFSTR("beaconLossCount"), v33);
          CFRelease(v34);
        }
        v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v46);
        if (v35)
        {
          v36 = v35;
          CFDictionarySetValue(v32, CFSTR("trigDisconnectCount"), v35);
          CFRelease(v36);
        }
        CFArrayInsertValueAtIndex(v17, v18, v32);
        CFRelease(v32);
        v37 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ - bcnloss:%d (%d %d) trgDisc:%d (%d %d)", "WiFiNetworkSetBssDisconnectReason", v23, BYTE1(v47) + v47, v47, BYTE1(v47), BYTE1(v46) + v46, v46, BYTE1(v46), v38);
        objc_autoreleasePoolPop(v37);
        v19 = v30;
        a3 = v29;
LABEL_46:
        ++v18;
      }
      while (v18 < CFArrayGetCount(v15));
    }
    sub_10002C478(v38, CFSTR("networkKnownBSSListKey"), v17);
LABEL_48:
    CFRelease(v17);
  }
  if (cf)
    CFRelease(cf);
}

__CFDictionary *sub_1000C85C4(uint64_t a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  __CFDictionary *Mutable;
  CFIndex v4;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v6;
  const void *Value;
  const void *v8;
  __CFString *v9;
  __CFString *v10;

  v1 = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
  if (!v1)
    return 0;
  v2 = v1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable && CFArrayGetCount(v2) >= 1)
  {
    v4 = 0;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v4);
      if (ValueAtIndex)
      {
        v6 = ValueAtIndex;
        Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL"));
        if (Value)
        {
          v8 = Value;
          v9 = CFStringCreateMutable(kCFAllocatorDefault, 0);
          if (v9)
          {
            v10 = v9;
            CFStringAppendFormat(v9, 0, CFSTR("%@"), v8);
            CFDictionarySetValue(Mutable, v10, v6);
            CFRelease(v10);
          }
        }
      }
      ++v4;
    }
    while (v4 < CFArrayGetCount(v2));
  }
  return Mutable;
}

uint64_t sub_1000C86EC(const void *a1, const void *a2)
{
  uint64_t v2;
  const __CFArray *v5;
  CFIndex v6;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  const void *Value;
  void *v10;
  void *v11;
  const void *v12;
  const char *v13;
  const __CFNumber *v15;
  const __CFNumber *v16;
  _BOOL4 v17;
  unsigned int v18;
  int valuePtr;

  v2 = 0;
  valuePtr = 0;
  v18 = 0;
  if (a1 && a2)
  {
    v5 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
    v2 = (uint64_t)v5;
    if (v5)
    {
      if (CFArrayGetCount(v5) < 1)
      {
LABEL_10:
        v2 = 0;
      }
      else
      {
        v6 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v2, v6);
          if (ValueAtIndex)
          {
            v8 = ValueAtIndex;
            Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
            if (Value)
            {
              if (CFEqual(Value, a2))
                break;
            }
          }
          if (++v6 >= CFArrayGetCount((CFArrayRef)v2))
            goto LABEL_10;
        }
        v15 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("beaconLossCount"));
        if (v15)
        {
          CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
          valuePtr = BYTE1(valuePtr) + valuePtr;
        }
        v16 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("trigDisconnectCount"));
        if (v16)
        {
          CFNumberGetValue(v16, kCFNumberIntType, &v18);
          v18 = BYTE1(v18) + v18;
          v17 = v18 > 2;
        }
        else
        {
          v17 = 0;
        }
        v2 = valuePtr > 5 || v17;
      }
    }
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v12 = sub_10002B088(a1);
      v13 = "yes";
      if (!(_DWORD)v2)
        v13 = "no";
      objc_msgSend(v11, "WFLog:message:", 3, "%s: %@ - %@ - %s - {bcnloss:%d trgDisc:%d}", "WiFiNetworkIsEdgeBss", v12, a2, v13, valuePtr, v18);
    }
    objc_autoreleasePoolPop(v10);
  }
  return v2;
}

uint64_t sub_1000C88A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  const void *v6;
  double v7;
  const void *v8;
  double v9;

  if (a1 | a2)
    v3 = -1;
  else
    v3 = 0;
  if (a2)
    result = 1;
  else
    result = v3;
  if (a1 && a2)
  {
    v6 = sub_10002BE64(a1, CFSTR("networkUsage"));
    v7 = sub_10002DF80(v6);
    v8 = sub_10002BE64(a2, CFSTR("networkUsage"));
    v9 = sub_10002DF80(v8);
    if (v7 >= v9)
    {
      if (v7 <= v9)
        return sub_1000C894C(a1, a2);
      else
        return -1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000C894C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  const __CFDate *v6;
  const __CFDate *v7;
  const __CFDate *v8;
  CFComparisonResult v9;
  const __CFDate *v10;
  const __CFDate *v11;
  const __CFDate *v12;
  const __CFDate *v13;
  CFComparisonResult v14;
  _BOOL4 v15;
  _BOOL4 v16;
  CFComparisonResult v17;

  if (a1 | a2)
    v3 = -1;
  else
    v3 = 0;
  if (a2)
    result = 1;
  else
    result = v3;
  if (a1 && a2)
  {
    v6 = (const __CFDate *)sub_10002BE64(a1, CFSTR("lastAutoJoined"));
    v7 = (const __CFDate *)sub_10002BE64(a1, CFSTR("lastJoined"));
    v8 = v7;
    if (v6 && v7)
    {
      v9 = CFDateCompare(v6, v7, 0);
      if (v9 == kCFCompareGreaterThan)
        v10 = v6;
      else
        v10 = 0;
      if (v9 == kCFCompareEqualTo)
        v10 = v8;
      if (v9 == kCFCompareLessThan)
        v6 = v8;
      else
        v6 = v10;
    }
    else if (!v6)
    {
      v6 = v7;
    }
    v11 = (const __CFDate *)sub_10002BE64(a2, CFSTR("lastAutoJoined"));
    v12 = (const __CFDate *)sub_10002BE64(a2, CFSTR("lastJoined"));
    v13 = v12;
    if (v11 && v12)
    {
      v14 = CFDateCompare(v11, v12, 0);
      if (v14 != kCFCompareLessThan)
      {
        if (v14)
        {
          v13 = v11;
          if (v14 != kCFCompareGreaterThan)
          {
            v15 = 0;
            v16 = v6 != 0;
LABEL_34:
            if (v16)
              return -1;
            else
              return v15;
          }
        }
      }
    }
    else if (v11)
    {
      v13 = v11;
    }
    v16 = v6 != 0;
    v15 = v13 != 0;
    if (!v6 || !v13)
      goto LABEL_34;
    v17 = CFDateCompare(v6, v13, 0);
    if (v17 == kCFCompareGreaterThan)
      return -1;
    else
      return v17 == kCFCompareLessThan;
  }
  return result;
}

BOOL sub_1000C8AAC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const __CFNumber *v4;
  const __CFNumber *v5;
  float v6;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1 | a2)
    v2 = -1;
  else
    v2 = 0;
  if (a2)
    v2 = 1;
  if (a1 && a2)
  {
    v4 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("Strength"));
    if (v4)
      CFNumberGetValue(v4, kCFNumberFloatType, (char *)&valuePtr + 4);
    v5 = (const __CFNumber *)sub_10002BE64(a2, CFSTR("Strength"));
    if (v5)
    {
      CFNumberGetValue(v5, kCFNumberFloatType, &valuePtr);
      v6 = *(float *)&valuePtr;
    }
    else
    {
      v6 = 0.0;
    }
    v2 = -1;
    if (*((float *)&valuePtr + 1) <= v6)
      return *((float *)&valuePtr + 1) < v6;
  }
  return v2;
}

const __CFArray *sub_1000C8B54(uint64_t a1)
{
  const __CFArray *result;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  const __CFNumber *Value;
  const __CFNumber *v12;
  const __CFNumber *v13;
  int valuePtr;
  unsigned int v17;

  valuePtr = 0;
  result = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
  if (result)
  {
    v2 = result;
    Count = CFArrayGetCount(result);
    if (Count >= 2)
    {
      v4 = Count;
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v17 = -1431655766;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v8);
        if (ValueAtIndex)
        {
          v10 = ValueAtIndex;
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL"));
          v12 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("CHANNEL_FLAGS"));
          if (Value)
          {
            v13 = v12;
            if (v12)
            {
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              CFNumberGetValue(v13, kCFNumberSInt32Type, &v17);
              if (valuePtr)
              {
                if (v17)
                {
                  if ((v17 & 8) != 0)
                  {
                    ++v7;
                  }
                  else if ((v17 & 0x10) != 0)
                  {
                    ++v6;
                  }
                  else
                  {
                    v5 += ((unint64_t)v17 >> 13) & 1;
                  }
                }
              }
            }
          }
        }
        ++v8;
      }
      while (v4 != v8);
      return (const __CFArray *)(v6 > 1 || v7 > 1 || v5 > 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000C8C90(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  int v6;
  void *v7;
  int v8;
  uint64_t result;
  int v10;
  _BOOL4 v11;
  unsigned int v12;
  void *v13;
  const __CFDate *v14;
  int v15;
  void *v16;
  void *v17;
  int v18;
  const __CFDate *v19;
  const __CFDate *v20;
  const __CFDate *v21;
  CFComparisonResult v22;
  void *v23;
  void *v24;
  const void *v25;
  const void *v26;
  uint64_t v27;
  const __CFDate *v28;
  const void *v29;
  const __CFDate *v30;
  CFComparisonResult v31;
  void *v32;
  void *v33;
  const void *v34;
  const void *v35;
  BOOL v36;
  uint64_t v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  BOOL v42;
  void *v43;
  const void *v44;
  void *v45;
  const void *v46;
  void *v47;
  const void *v48;
  void *v49;
  const void *v50;
  CFComparisonResult v51;
  void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  void *v56;
  const void *v57;
  void *v58;
  const void *v59;
  void *v60;
  const void *v61;
  void *v62;
  const void *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  uint64_t v67;
  uint64_t v68;
  const __CFDate *theDate;

  if (!(a1 | a2))
    return 0;
  if (a1)
  {
    v6 = sub_1000C9410(a1);
    if (v6 == 1)
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NOI (1) '%@' is forced-fix", sub_10002B088((const void *)a1));
      objc_autoreleasePoolPop(v7);
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    v12 = sub_1000C3F88(a1);
    if (v12 == 1)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NOI (1) '%@' has home-state", sub_10002B088((const void *)a1));
      objc_autoreleasePoolPop(v13);
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    v11 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PayloadUUID")) != 0;
    v14 = (const __CFDate *)sub_10002BE64(a1, CFSTR("addedAt"));
    if (!a2)
    {
      result = -1;
      if (v6 == 1)
        return result;
LABEL_45:
      if (v12 == 1)
        return result;
      return 0;
    }
    theDate = v14;
  }
  else
  {
    if (!a2)
      return 0;
    v10 = 0;
    v8 = 0;
    v11 = 0;
    theDate = 0;
  }
  v15 = sub_1000C9410(a2);
  if (v15 == 1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NOI (1) '%@' is forced-fix", sub_10002B088((const void *)a2));
    objc_autoreleasePoolPop(v16);
  }
  v12 = sub_1000C3F88(a2);
  if (v12 == 1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NOI (2) '%@' has home-state", sub_10002B088((const void *)a2));
    objc_autoreleasePoolPop(v17);
  }
  v18 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 16), CFSTR("PayloadUUID"));
  v19 = (const __CFDate *)sub_10002BE64(a2, CFSTR("addedAt"));
  if (!a1 || !a2)
  {
    if (v8)
      result = -1;
    else
      result = 1;
    if (v8 || v15 == 1)
      return result;
    result = v10 ? -1 : 1;
    if (v10)
      return result;
    goto LABEL_45;
  }
  if (v8 && v15 == 1)
  {
    v20 = (const __CFDate *)sub_1000C94E4(a1);
    v21 = (const __CFDate *)sub_1000C94E4(a2);
    v22 = CFDateCompare(v20, v21, 0);
    v23 = objc_autoreleasePoolPush();
    v24 = (void *)qword_10026DD20;
    if (v22 != kCFCompareLessThan)
    {
      if (qword_10026DD20)
      {
        v25 = sub_10002B088((const void *)a1);
        v26 = sub_10002B088((const void *)a2);
        objc_msgSend(v24, "WFLog:message:", 3, "Both (%@) and (%@) force fixed. Preferred (1), the most recently force fixed: %@", v25, v26, sub_10002B088((const void *)a1), v68);
      }
LABEL_33:
      objc_autoreleasePoolPop(v23);
      return -1;
    }
    if (qword_10026DD20)
    {
      v38 = sub_10002B088((const void *)a1);
      v39 = sub_10002B088((const void *)a2);
      objc_msgSend(v24, "WFLog:message:", 3, "Both (%@) and (%@) force fixed. Preferred (2), the most recently force fixed: %@", v38, v39, sub_10002B088((const void *)a2), v68);
    }
    goto LABEL_66;
  }
  if ((!v8 || !v18) && (!v11 || v15 != 1))
  {
    v42 = v15 == 1;
    if (!v8)
      v42 = 1;
    if (!v42)
    {
      v23 = objc_autoreleasePoolPush();
      v43 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v44 = sub_10002B088((const void *)a1);
        objc_msgSend(v43, "WFLog:message:", 3, "NOI (1) forced-fix: preferred (1) %@ over %@", v44, sub_10002B088((const void *)a2), v67, v68);
      }
      goto LABEL_33;
    }
    if (!v8 && v15 == 1)
    {
      v23 = objc_autoreleasePoolPush();
      v45 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v46 = sub_10002B088((const void *)a2);
        objc_msgSend(v45, "WFLog:message:", 3, "NOI (2) forced-fix: Preferred (2) %@ over %@", v46, sub_10002B088((const void *)a1), v67, v68);
      }
LABEL_66:
      objc_autoreleasePoolPop(v23);
      return 1;
    }
    if (v11 && !v18)
    {
      v23 = objc_autoreleasePoolPush();
      v47 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v48 = sub_10002B088((const void *)a1);
        objc_msgSend(v47, "WFLog:message:", 3, "NOI home-state: preferred (1) %@ (as it's profile based) over %@", v48, sub_10002B088((const void *)a2), v67, v68);
      }
      goto LABEL_33;
    }
    if (!v11 && v18)
    {
      v23 = objc_autoreleasePoolPush();
      v49 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v50 = sub_10002B088((const void *)a2);
        objc_msgSend(v49, "WFLog:message:", 3, "NOI home-state: preferred (2) %@ (as it's profile based) over %@", v50, sub_10002B088((const void *)a1), v67, v68);
      }
      goto LABEL_66;
    }
    if (v11 && v18)
    {
      if (theDate)
      {
        if (!v19)
        {
          v23 = objc_autoreleasePoolPush();
          v62 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v63 = sub_10002B088((const void *)a1);
            objc_msgSend(v62, "WFLog:message:", 3, "NOI home-state: preferred (1) %@ over %@ (which has no kWiFiPreferenceAddedAtKey)", v63, sub_10002B088((const void *)a2), v67, v68);
          }
          goto LABEL_33;
        }
        v51 = CFDateCompare(theDate, v19, 0);
        v23 = objc_autoreleasePoolPush();
        v52 = (void *)qword_10026DD20;
        if (v51 != kCFCompareLessThan)
        {
          if (qword_10026DD20)
          {
            v53 = sub_10002B088((const void *)a1);
            v54 = sub_10002B088((const void *)a2);
            v55 = sub_10002B088((const void *)a1);
            objc_msgSend(v52, "WFLog:message:", 3, "NOI home-state: preferred (1) %@ over %@. %@ was added after %@", v53, v54, v55, sub_10002B088((const void *)a2));
          }
          goto LABEL_33;
        }
        if (qword_10026DD20)
        {
          v64 = sub_10002B088((const void *)a2);
          v65 = sub_10002B088((const void *)a1);
          v66 = sub_10002B088((const void *)a2);
          objc_msgSend(v52, "WFLog:message:", 3, "NOI home-state: preferred (2) %@ over %@. %@ was added after %@", v64, v65, v66, sub_10002B088((const void *)a1));
        }
      }
      else
      {
        v23 = objc_autoreleasePoolPush();
        v60 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v61 = sub_10002B088((const void *)a2);
          objc_msgSend(v60, "WFLog:message:", 3, "NOI home-state: preferred (2) %@ over %@ (which has no kWiFiPreferenceAddedAtKey)", v61, sub_10002B088((const void *)a1), v67, v68);
        }
      }
      goto LABEL_66;
    }
    if (v10 && v12 != 1)
    {
      v23 = objc_autoreleasePoolPush();
      v56 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v57 = sub_10002B088((const void *)a1);
        objc_msgSend(v56, "WFLog:message:", 3, "NOI home-state: preferred (1) %@ over %@", v57, sub_10002B088((const void *)a2), v67, v68);
      }
      goto LABEL_33;
    }
    if (!v10 && v12 == 1)
    {
      v23 = objc_autoreleasePoolPush();
      v58 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v59 = sub_10002B088((const void *)a2);
        objc_msgSend(v58, "WFLog:message:", 3, "NOI home-state: Preferred (2) %@ over %@", v59, sub_10002B088((const void *)a1), v67, v68);
      }
      goto LABEL_66;
    }
    if (a3)
      *a3 = v10;
    return 0;
  }
  if (v8)
    v27 = a1;
  else
    v27 = a2;
  v28 = (const __CFDate *)sub_1000C94E4(v27);
  if (v11)
    v29 = (const void *)a1;
  else
    v29 = (const void *)a2;
  v30 = (const __CFDate *)sub_10002BE64((uint64_t)v29, CFSTR("addedAt"));
  v31 = CFDateCompare(v28, v30, 0);
  v32 = objc_autoreleasePoolPush();
  v33 = (void *)qword_10026DD20;
  if (v31 == kCFCompareLessThan)
  {
    if (qword_10026DD20)
    {
      v40 = sub_10002B088(v29);
      if (v11)
        v41 = (const void *)a2;
      else
        v41 = (const void *)a1;
      objc_msgSend(v33, "WFLog:message:", 3, "NOI: Profile based network (%@) was added AFTER network was force fixed  (%@), prefer profile based ", v40, sub_10002B088(v41));
    }
    objc_autoreleasePoolPop(v32);
    v36 = v8 == 0;
    v37 = -1;
  }
  else
  {
    if (qword_10026DD20)
    {
      v34 = sub_10002B088(v29);
      if (v11)
        v35 = (const void *)a2;
      else
        v35 = (const void *)a1;
      objc_msgSend(v33, "WFLog:message:", 3, "NOI: Profile based network (%@) was added BEFORE network was force fixed (%@), prefer force fixed network ", v34, sub_10002B088(v35));
    }
    objc_autoreleasePoolPop(v32);
    v36 = v8 == 0;
    v37 = 1;
  }
  if (v36)
    return v37;
  else
    return -v37;
}

uint64_t sub_1000C9410(uint64_t a1)
{
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetForcedHomeFix");
LABEL_9:
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  v1 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("NetworkForcedHomeFix"));
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == CFBooleanGetTypeID())
      return CFBooleanGetValue(v2);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid value type", "WiFiNetworkGetForcedHomeFix");
    goto LABEL_9;
  }
  return 0;
}

const void *sub_1000C94E4(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("kWiFiNetworkLastHomeForceFixDateKey"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetLastHomeForceFixDate");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000C9564(uint64_t a1, __CFString *a2)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  uint64_t v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex v14;
  uint64_t v15;
  CFIndex j;
  const __CFString *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  CFIndex v20;
  uint64_t v21;
  CFIndex k;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  void *value;

  value = kCFBooleanFalse;
  if (a2)
  {
    v4 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DomainName"));
    if (v4)
    {
      v5 = v4;
      CFStringAppend(a2, CFSTR("\nDomain name "));
      CFStringAppend(a2, v5);
    }
    v6 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("RoamingConsortiumOIs"));
    if (v6)
    {
      v7 = v6;
      Count = CFArrayGetCount(v6);
      if (Count)
      {
        v9 = Count;
        CFStringAppend(a2, CFSTR("\nRoaming Consortium OI "));
        if (v9 >= 1)
        {
          for (i = 0; i != v9; ++i)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, i);
            CFStringAppend(a2, ValueAtIndex);
            CFStringAppend(a2, CFSTR(" "));
          }
        }
      }
    }
    v12 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("NaiRealmName"));
    if (v12)
    {
      v13 = v12;
      v14 = CFArrayGetCount(v12);
      if (v14)
      {
        v15 = v14;
        CFStringAppend(a2, CFSTR("\nNAI Realm Name "));
        if (v15 >= 1)
        {
          for (j = 0; j != v15; ++j)
          {
            v17 = (const __CFString *)CFArrayGetValueAtIndex(v13, j);
            CFStringAppend(a2, v17);
            CFStringAppend(a2, CFSTR(" "));
          }
        }
      }
    }
    v18 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("MCCandMNC"));
    if (v18)
    {
      v19 = v18;
      v20 = CFArrayGetCount(v18);
      if (v20)
      {
        v21 = v20;
        CFStringAppend(a2, CFSTR("\n3GPP MCC&MNC "));
        if (v21 >= 1)
        {
          for (k = 0; k != v21; ++k)
          {
            v23 = (const __CFString *)CFArrayGetValueAtIndex(v19, k);
            CFStringAppend(a2, v23);
            CFStringAppend(a2, CFSTR(" "));
          }
        }
      }
    }
    v24 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DisplayedOperatorName"));
    if (v24)
    {
      v25 = v24;
      CFStringAppend(a2, CFSTR("\nFriendly Operator Name "));
      CFStringAppend(a2, v25);
    }
    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 16), CFSTR("SPRoaming"), (const void **)&value))
    {
      CFStringAppend(a2, CFSTR("\nRoaming set to: "));
      if (value)
        v26 = CFSTR("true");
      else
        v26 = CFSTR("false");
      CFStringAppend(a2, v26);
    }
  }
}

__CFDictionary *sub_1000C97E4(uint64_t a1)
{
  __CFDictionary *Mutable;
  const void *Value;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DomainName"));
    if (Value)
      CFDictionaryAddValue(Mutable, CFSTR("DomainName"), Value);
    v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DisplayedOperatorName"));
    if (v4)
      CFDictionaryAddValue(Mutable, CFSTR("DisplayedOperatorName"), v4);
    v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("RoamingConsortiumOIs"));
    if (v5)
      CFDictionaryAddValue(Mutable, CFSTR("RoamingConsortiumOIs"), v5);
    v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("NaiRealmName"));
    if (v6)
      CFDictionaryAddValue(Mutable, CFSTR("NaiRealmName"), v6);
    v7 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("MCCandMNC"));
    if (v7)
      CFDictionaryAddValue(Mutable, CFSTR("MCCandMNC"), v7);
  }
  return Mutable;
}

void sub_1000C9914(uint64_t a1, int a2)
{
  const void **v2;

  v2 = (const void **)&kCFBooleanTrue;
  if (!a2)
    v2 = (const void **)&kCFBooleanFalse;
  sub_10002C478(a1, CFSTR("HS20ProvisionedNetwork"), *v2);
}

BOOL sub_1000C993C(uint64_t a1)
{
  return sub_10002BE64(a1, CFSTR("HS20ProvisionedNetwork")) == kCFBooleanTrue;
}

void sub_1000C996C(uint64_t a1, int a2)
{
  const void **v2;

  v2 = (const void **)&kCFBooleanTrue;
  if (!a2)
    v2 = (const void **)&kCFBooleanFalse;
  sub_10002C478(a1, CFSTR("HS20HomeOperatorNetwork"), *v2);
}

const void *sub_1000C9994(uint64_t a1)
{
  const void *result;

  result = sub_10002BE64(a1, CFSTR("HS2NetworkBadge"));
  if (!result)
    return sub_1000C99D0(a1);
  return result;
}

const void *sub_1000C99D0(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFArray *Value;
  const __CFArray *v3;
  const __CFDictionary *ValueAtIndex;

  v1 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("HS20GasResponse"));
  if (v1
    && (Value = (const __CFArray *)CFDictionaryGetValue(v1, CFSTR("ANQP_OPERATOR_NAMES_LIST"))) != 0
    && (v3 = Value, CFArrayGetCount(Value) >= 1)
    && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, 0)) != 0)
  {
    return CFDictionaryGetValue(ValueAtIndex, CFSTR("ANQP_OPERATOR_NAME"));
  }
  else
  {
    return 0;
  }
}

const void *sub_1000C9A40(uint64_t a1)
{
  return sub_10002BE64(a1, CFSTR("HS20GasResponse"));
}

const void *sub_1000C9A4C(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFArray *Value;
  const __CFArray *v4;

  v2 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("HS20GasResponse"));
  if (!v2)
    return sub_10002BE64(a1, CFSTR("DomainName"));
  Value = (const __CFArray *)CFDictionaryGetValue(v2, CFSTR("ANQP_DOMAIN_NAME_LIST"));
  if (Value && (v4 = Value, CFArrayGetCount(Value) >= 1))
    return CFArrayGetValueAtIndex(v4, 0);
  else
    return 0;
}

void sub_1000C9ACC(uint64_t a1, const void *a2)
{
  if (sub_10002BE64(a1, CFSTR("HS20GasResponse")))
    sub_10002C478(a1, CFSTR("HS20GasResponse"), 0);
  sub_10002C478(a1, CFSTR("HS20GasResponse"), a2);
}

uint64_t sub_1000C9B20(const void *a1, const void *a2)
{
  uint64_t v2;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const void *v6;
  const __CFArray *Value;
  const __CFArray *v8;
  CFIndex v9;
  const void *ValueAtIndex;
  const void *v11;
  char v12;
  const __CFBoolean *v13;
  void *v14;
  const char *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  CFIndex Count;
  char v19;
  CFIndex v20;
  const void *v21;
  const void *v22;
  void *v23;
  const __CFArray *v24;
  const __CFArray *v25;
  void *v26;
  void *v27;
  void *v28;
  const void *v29;
  void *v30;
  const __CFArray *v31;
  const __CFArray *v32;
  CFIndex v33;
  CFIndex v34;
  void *v35;
  const __CFArray *v36;
  const __CFArray *v37;
  void *v38;
  CFIndex v39;
  const __CFDictionary *v40;
  const void *v41;
  const void *v42;
  int v43;
  CFIndex v44;
  void *v45;
  const __CFArray *v46;
  const __CFArray *v47;
  CFIndex v48;
  CFIndex v49;
  void *v50;
  const __CFArray *v51;
  const __CFArray *v52;
  void *v53;
  CFIndex v54;
  const __CFString *v55;
  int v56;
  CFIndex v57;
  void *v58;
  CFRange v61;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = (const __CFDictionary *)sub_10002BE64((uint64_t)a1, CFSTR("HS20GasResponse"));
    if (v4)
    {
      v5 = v4;
      v6 = sub_10002BE64((uint64_t)a2, CFSTR("DomainName"));
      Value = (const __CFArray *)CFDictionaryGetValue(v5, CFSTR("ANQP_DOMAIN_NAME_LIST"));
      if (Value && (v8 = Value, CFArrayGetCount(Value) >= 1))
      {
        v9 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
          if (ValueAtIndex)
          {
            if (v6)
            {
              v11 = ValueAtIndex;
              if (CFEqual(ValueAtIndex, v6))
                break;
            }
          }
          if (++v9 >= CFArrayGetCount(v8))
            goto LABEL_11;
        }
        v27 = objc_autoreleasePoolPush();
        v28 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          if (sub_10002DA5C((_BOOL8)a1))
            v29 = sub_1000C9A4C((uint64_t)a1);
          else
            v29 = sub_10002B088(a1);
          objc_msgSend(v28, "WFLog:message:", 3, "%s: found matching domain name %@ in GAS response from scannedNetwork, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v11, v29);
        }
        objc_autoreleasePoolPop(v27);
        v12 = 0;
        v2 = 1;
      }
      else
      {
LABEL_11:
        v2 = 0;
        v12 = 1;
      }
      v13 = (const __CFBoolean *)sub_10002BE64((uint64_t)a2, CFSTR("SPRoaming"));
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v13 == kCFBooleanFalse)
          v15 = "%s: roaming is disabled for account %@";
        else
          v15 = "%s: roaming is enabled for account %@";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v15, "WiFiNetworkIsScannedNetworkMatchingHS20Account", sub_10002B088(a2));
      }
      objc_autoreleasePoolPop(v14);
      v16 = (const __CFArray *)sub_10002BE64((uint64_t)a2, CFSTR("MCCandMNC"));
      if (v16)
      {
        v17 = v16;
        Count = CFArrayGetCount(v16);
        v19 = v12 ^ 1;
        if (Count < 1)
          v19 = 1;
        if ((v19 & 1) == 0)
        {
          v20 = 0;
          while (1)
          {
            v21 = CFArrayGetValueAtIndex(v17, v20);
            if (v21)
            {
              v22 = v21;
              v23 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found MCCMNC in account %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5621, v22);
              objc_autoreleasePoolPop(v23);
              v24 = (const __CFArray *)CFDictionaryGetValue(v5, CFSTR("ANQP_CELL_NETWORK_INFO"));
              if (v24)
              {
                v25 = v24;
                v26 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found cellInfoArray count %ld %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5625, CFArrayGetCount(v25), v25);
                objc_autoreleasePoolPop(v26);
                v61.length = CFArrayGetCount(v25);
                v61.location = 0;
                if (CFArrayContainsValue(v25, v61, v22))
                  break;
              }
            }
            if (++v20 >= CFArrayGetCount(v17))
            {
              v2 = 0;
              goto LABEL_37;
            }
          }
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found response from 3GPP %@, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v22, sub_10002B088(a1));
          objc_autoreleasePoolPop(v30);
          v2 = 1;
        }
      }
LABEL_37:
      v31 = (const __CFArray *)sub_10002BE64((uint64_t)a2, CFSTR("NaiRealmName"));
      if (v31)
      {
        v32 = v31;
        v33 = CFArrayGetCount(v31);
        if (!(_DWORD)v2 && v33 >= 1)
        {
          v34 = 0;
          while (1)
          {
            v2 = (uint64_t)CFArrayGetValueAtIndex(v32, v34);
            if (v2)
            {
              v35 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found NAI Realm in accounts %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5640, v2);
              objc_autoreleasePoolPop(v35);
              v36 = (const __CFArray *)CFDictionaryGetValue(v5, CFSTR("ANQP_NAI_REALM_LIST"));
              if (v36)
              {
                v37 = v36;
                v38 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found NaiRealmArray count %ld %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5644, CFArrayGetCount(v37), v37);
                objc_autoreleasePoolPop(v38);
                if (CFArrayGetCount(v37) >= 1)
                {
                  v39 = 0;
                  while (1)
                  {
                    v40 = (const __CFDictionary *)CFArrayGetValueAtIndex(v37, v39);
                    if (v40)
                    {
                      v41 = CFDictionaryGetValue(v40, CFSTR("ANQP_NAI_REALM_NAME"));
                      if (v41)
                      {
                        v42 = v41;
                        if (CFEqual(v41, (CFTypeRef)v2))
                          break;
                      }
                    }
                    if (++v39 >= CFArrayGetCount(v37))
                      goto LABEL_53;
                  }
                  v45 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found response from NAI Realm %@, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v42, sub_10002B088(a1));
                  objc_autoreleasePoolPop(v45);
                  v43 = 0;
                  v2 = 1;
                  goto LABEL_55;
                }
              }
LABEL_53:
              v2 = 0;
            }
            v43 = 1;
LABEL_55:
            v44 = CFArrayGetCount(v32);
            if (v43)
            {
              if (++v34 < v44)
                continue;
            }
            break;
          }
        }
      }
      v46 = (const __CFArray *)sub_10002BE64((uint64_t)a2, CFSTR("RoamingConsortiumOIs"));
      if (v46)
      {
        v47 = v46;
        v48 = CFArrayGetCount(v46);
        if (!(_DWORD)v2 && v48 >= 1)
        {
          v49 = 0;
          while (1)
          {
            v2 = (uint64_t)CFArrayGetValueAtIndex(v47, v49);
            if (v2)
            {
              v50 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found Roaming Consortium OI in accounts %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5665, v2);
              objc_autoreleasePoolPop(v50);
              v51 = (const __CFArray *)CFDictionaryGetValue(v5, CFSTR("ANQP_ROAMING_CONSORTIUM_OI_LIST"));
              if (v51)
              {
                v52 = v51;
                v53 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d found RoamingConsortiumArray count %ld %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5669, CFArrayGetCount(v52), v52);
                objc_autoreleasePoolPop(v53);
                if (CFArrayGetCount(v52) >= 1)
                {
                  v54 = 0;
                  while (1)
                  {
                    v55 = (const __CFString *)CFArrayGetValueAtIndex(v52, v54);
                    if (v55)
                    {
                      if (CFStringCompare(v55, (CFStringRef)v2, 1uLL) == kCFCompareEqualTo)
                        break;
                    }
                    if (++v54 >= CFArrayGetCount(v52))
                      goto LABEL_76;
                  }
                  v58 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found response from Roaming Consortium %@, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v2, sub_10002B088(a1));
                  objc_autoreleasePoolPop(v58);
                  v56 = 0;
                  v2 = 1;
                  goto LABEL_78;
                }
              }
LABEL_76:
              v2 = 0;
            }
            v56 = 1;
LABEL_78:
            v57 = CFArrayGetCount(v47);
            if (v56)
            {
              if (++v49 < v57)
                continue;
            }
            return v2;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFDictionaryRef *sub_1000CA1F0(CFDictionaryRef *result)
{
  CFDictionaryRef *v1;
  const __CFDictionary *v2;
  __int16 v3;
  __int16 valuePtr;

  valuePtr = 0;
  v3 = 0;
  if (result)
  {
    v1 = result;
    result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], CFSTR("EXT_CAPS"));
    if (result)
    {
      result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("BSS_TRANS_MGMT"));
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        if ((_BYTE)valuePtr)
        {
          result = (CFDictionaryRef *)CFDictionaryGetValue(v1[2], CFSTR("QBSS_LOAD_IE"));
          if (result)
          {
            v2 = (const __CFDictionary *)result;
            result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("QBSS_CHAN_UTIL"));
            if (result)
            {
              CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, (char *)&valuePtr + 1);
              result = (CFDictionaryRef *)CFDictionaryGetValue(v2, CFSTR("QBSS_STA_COUNT"));
              if (result)
              {
                CFNumberGetValue((CFNumberRef)result, kCFNumberSInt16Type, &v3);
                return (CFDictionaryRef *)(v3 == -1);
              }
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_1000CA2C0(const void *a1, const void *a2)
{
  const void *v4;
  void *v5;
  void *v6;
  void *v7;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetPasswordModificationDate");
    goto LABEL_11;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null modDate", "WiFiNetworkSetPasswordModificationDate");
LABEL_11:
    v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v4 = sub_10002B088(a1);
  v5 = objc_autoreleasePoolPush();
  if (!v4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssid", "WiFiNetworkSetPasswordModificationDate");
    v7 = v5;
    goto LABEL_15;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: for network <%@>,  modDate %@", "WiFiNetworkSetPasswordModificationDate", v4, a2);
  objc_autoreleasePoolPop(v5);
  sub_10002C478((uint64_t)a1, CFSTR("WiFiNetworkPasswordModificationDate"), a2);
}

const void *sub_1000CA3FC(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("WiFiNetworkPasswordModificationDate"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetPasswordModificationDate");
  objc_autoreleasePoolPop(v2);
  return 0;
}

CFTypeRef sub_1000CA47C(const void *a1)
{
  const __CFString *v1;
  void *v3;

  if (a1)
  {
    v1 = sub_1000C3C04(a1);
    return sub_1000D84F4(v1);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkCopyKeychainModDate");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
}

const __CFDictionary *sub_1000CA4F4(uint64_t a1)
{
  const __CFDictionary *result;
  CFBooleanRef Value;

  result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("APPLE_DEVICE_IE"));
  if (result)
  {
    Value = (CFBooleanRef)CFDictionaryGetValue(result, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_CARPLAY"));
    return (const __CFDictionary *)(Value && Value == kCFBooleanTrue);
  }
  return result;
}

BOOL sub_1000CA53C(uint64_t a1)
{
  const __CFNumber *v2;
  const __CFNumber *v3;
  void *v5;
  unsigned int valuePtr;
  unsigned int v7;

  v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("CHANNEL"));
  v7 = -1431655766;
  v3 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("CHANNEL_FLAGS"));
  if (v3)
  {
    valuePtr = 0;
    CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
    return (valuePtr >> 3) & 1;
  }
  else
  {
    CFNumberGetValue(v2, kCFNumberSInt32Type, &v7);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s : Current channel %d\n", "WiFiNetworkIs24GHzNetwork", v7);
    objc_autoreleasePoolPop(v5);
    return v7 - 1 < 0xE;
  }
}

uint64_t sub_1000CA608(uint64_t a1)
{
  const void *v2;
  unsigned int v3;

  v2 = sub_10002BE64(a1, CFSTR("CARPLAY_NETWORK"));
  if (v2 && CFEqual(v2, kCFBooleanTrue))
  {
    if (sub_10002BE64(a1, CFSTR("lastJoined"))
      || a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PayloadUUID")))
    {
      v3 = 2;
    }
    else
    {
      v3 = 1;
    }
  }
  else
  {
    v3 = 0;
  }
  if (sub_10002DA5C(a1))
    return 3;
  else
    return v3;
}

CFIndex sub_1000CA6A0(CFIndex result)
{
  const __CFArray *v1;
  CFIndex i;
  _QWORD *ValueAtIndex;
  _QWORD *v4;
  void *v5;

  if (result)
  {
    v1 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      for (i = 0; i < result; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v1, i);
        if (ValueAtIndex)
        {
          v4 = ValueAtIndex;
          v5 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", v4[2]);
          objc_autoreleasePoolPop(v5);
        }
        result = CFArrayGetCount(v1);
      }
    }
  }
  return result;
}

void sub_1000CA74C(uint64_t a1)
{
  sub_10002C478(a1, CFSTR("CARPLAY_NETWORK"), 0);
  sub_10002C478(a1, CFSTR("CARPLAY_UUID"), 0);
}

const void *sub_1000CA788(uint64_t a1, const __CFString *a2)
{
  const __CFString *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  const __CFString *Value;
  const void *result;
  void *v14;
  uint64_t v15;

  v15 = 0;
  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkCopyLeakyStatus");
    goto LABEL_28;
  }
  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null bssid", "WiFiNetworkCopyLeakyStatus");
    goto LABEL_28;
  }
  v4 = (const __CFString *)sub_10002BE64(a1, CFSTR("BSSID"));
  if (!v4)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null bssidFromNetwork", "WiFiNetworkCopyLeakyStatus");
    goto LABEL_28;
  }
  if (CFStringCompare(a2, v4, 0) == kCFCompareEqualTo)
  {
    result = sub_10002BE64(a1, CFSTR("LEAKY_AP_LEARNED_DATA"));
    if (!result)
      return result;
    goto LABEL_14;
  }
  v5 = (const __CFArray *)sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
  if (!v5)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null knownBssids", "WiFiNetworkCopyLeakyStatus");
    goto LABEL_28;
  }
  v6 = v5;
  Count = CFArrayGetCount(v5);
  if (!Count)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no knownBssids", "WiFiNetworkCopyLeakyStatus");
LABEL_28:
    objc_autoreleasePoolPop(v14);
    return 0;
  }
  v8 = Count;
  if (Count < 1)
    return 0;
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v9);
    if (ValueAtIndex)
    {
      v11 = ValueAtIndex;
      Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
      if (CFStringCompare(a2, Value, 0) == kCFCompareEqualTo)
        break;
    }
    if (v8 == ++v9)
      return 0;
  }
  result = CFDictionaryGetValue(v11, CFSTR("LEAKY_AP_LEARNED_DATA"));
  if (result)
  {
LABEL_14:
    Apple80211CopyLeakyAPStatus(result, &v15);
    return (const void *)v15;
  }
  return result;
}

BOOL sub_1000CA9A4(uint64_t a1, const __CFString *a2)
{
  const __CFNumber *v2;
  const __CFNumber *v3;
  _BOOL8 v4;
  void *v6;
  char valuePtr;

  v2 = (const __CFNumber *)sub_1000CA788(a1, a2);
  if (v2)
  {
    v3 = v2;
    valuePtr = -86;
    CFNumberGetValue(v2, kCFNumberSInt8Type, &valuePtr);
    v4 = valuePtr == 2;
    CFRelease(v3);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null leaky number", "WiFiNetworkIsAPLeaky");
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  return v4;
}

const __CFDictionary *sub_1000CAA40(uint64_t a1)
{
  const __CFDictionary *result;
  char valuePtr;

  result = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("11U_INTERWORKING_IE"));
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("INTERWORKING_ACCESS_NETWORK_TYPE"));
    if (result)
    {
      valuePtr = 0;
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      return (const __CFDictionary *)(valuePtr == 2);
    }
  }
  return result;
}

BOOL sub_1000CAA94(uint64_t a1)
{
  unsigned int v2;

  if (sub_10002DA5C(a1)
    || &_CNForgetSSID
    && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue)
  {
    v2 = sub_1000CAA40(a1);
  }
  else
  {
    v2 = 0;
  }
  return sub_10001395C(a1) || sub_10000BE8C(a1) || v2;
}

uint64_t sub_1000CAB28(uint64_t a1)
{
  const __CFNumber *v2;
  _BOOL8 v3;
  int valuePtr;

  valuePtr = 0;
  v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("SaveDataMode"));
  if (v2)
  {
    CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
    v3 = valuePtr == 1;
    if (valuePtr)
      return v3;
  }
  else
  {
    v3 = 0;
  }
  if (sub_10001395C(a1) || sub_1000C4AA0(a1) || sub_10000BE8C(a1))
    return 1;
  return v3;
}

double sub_1000CABB4(uint64_t a1)
{
  const __CFNumber *v1;
  void *v2;
  double valuePtr;

  valuePtr = 0.0;
  v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkQualityResponsiveness"));
  if (v1)
    CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: retrieved %.3f", "WiFiNetworkGetNetworkQualityResponsiveness", *(_QWORD *)&valuePtr);
  objc_autoreleasePoolPop(v2);
  return valuePtr;
}

const void *sub_1000CAC40(uint64_t a1)
{
  const void *v1;
  void *v2;

  v1 = sub_10002BE64(a1, CFSTR("NetworkQualityDate"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: retrieved %@", "WiFiNetworkGetNetworkQualityDate", v1);
  objc_autoreleasePoolPop(v2);
  return v1;
}

void sub_1000CACB4(const void *a1, const void *a2, double a3)
{
  void *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  void *v9;
  double valuePtr;

  valuePtr = a3;
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@, %.3f %@", "WiFiNetworkSetNetworkQuality", sub_10002B088(a1), *(_QWORD *)&a3, a2);
  objc_autoreleasePoolPop(v6);
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v7)
  {
    v8 = v7;
    sub_10002C478((uint64_t)a1, CFSTR("NetworkQualityResponsiveness"), v7);
    sub_10002C478((uint64_t)a1, CFSTR("NetworkQualityDate"), a2);
    CFRelease(v8);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s CFNumberCreate failed", "WiFiNetworkSetNetworkQuality");
    objc_autoreleasePoolPop(v9);
  }
}

void sub_1000CADDC(const void *a1, unsigned int a2)
{
  void *v4;
  const void **v5;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@, %d", "WiFiNetworkDisableAutoJoinUntilFirstUserJoin", sub_10002B088(a1), a2);
    objc_autoreleasePoolPop(v4);
    v5 = (const void **)&kCFBooleanTrue;
    if (!a2)
      v5 = (const void **)&kCFBooleanFalse;
    sub_10002C478((uint64_t)a1, CFSTR("DisableWiFiAutoJoinUntilFirstUserJoin"), *v5);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkDisableAutoJoinUntilFirstUserJoin");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_1000CAEC8(uint64_t a1)
{
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsAutoJoinDisabledUntilFirstUserJoin");
LABEL_9:
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  v1 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("DisableWiFiAutoJoinUntilFirstUserJoin"));
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == CFBooleanGetTypeID())
      return CFBooleanGetValue(v2);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid value type", "WiFiNetworkIsAutoJoinDisabledUntilFirstUserJoin");
    goto LABEL_9;
  }
  return 0;
}

const __CFBoolean *sub_1000CAF9C(const __CFDictionary **a1)
{
  const __CFBoolean *result;
  const __CFBoolean *v3;
  CFTypeID v4;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsInfrequentlyJoinedPublicNetwork");
    goto LABEL_12;
  }
  if (sub_10002CDC4(a1[2]))
    return 0;
  result = (const __CFBoolean *)sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsPublic"));
  if (!result)
    return result;
  v3 = result;
  v4 = CFGetTypeID(result);
  if (v4 != CFBooleanGetTypeID())
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid value type", "WiFiNetworkIsInfrequentlyJoinedPublicNetwork");
LABEL_12:
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  result = (const __CFBoolean *)CFBooleanGetValue(v3);
  if ((_DWORD)result)
    return (const __CFBoolean *)(sub_1000C6A74(a1) > 1209600.0);
  return result;
}

BOOL sub_1000CB0A0(uint64_t a1)
{
  CFBooleanRef v1;

  v1 = (CFBooleanRef)sub_10002BE64(a1, CFSTR("CaptiveBypass"));
  return v1 && v1 == kCFBooleanTrue;
}

void sub_1000CB0D8(uint64_t a1, const void *a2)
{
  void *v2;

  if (a1)
  {
    sub_10002C478(a1, CFSTR("BundleIdentifier"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkAddBundleIdentifier");
    objc_autoreleasePoolPop(v2);
  }
}

const void *sub_1000CB154(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("BundleIdentifier"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetBundleIdentifier");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000CB1D4(uint64_t a1, unsigned int a2)
{
  void *v2;

  if (a1)
  {
    sub_10002B698(a1, CFSTR("NetworkOriginator"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkAddOriginator");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000CB254(uint64_t a1, const void *a2)
{
  void *v2;

  if (a1)
  {
    sub_10002C478(a1, CFSTR("NetworkOriginatorName"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetOriginatorName");
    objc_autoreleasePoolPop(v2);
  }
}

const __CFNumber *sub_1000CB2D0(uint64_t a1)
{
  const __CFNumber *v1;
  void *v3;

  if (a1)
  {
    v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkOriginator"));
    return sub_10001F500(v1);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetOriginator");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
}

uint64_t sub_1000CB34C(uint64_t a1)
{
  uint64_t v1;
  const __CFNumber *v2;
  unsigned int valuePtr;

  v1 = 1;
  valuePtr = 1;
  v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("UserRole"));
  if (v2)
  {
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }
  return v1;
}

uint64_t sub_1000CB39C(const __CFArray *a1, uint64_t a2)
{
  CFIndex v2;
  CFTypeRef *ValueAtIndex;
  CFTypeRef *v6;
  CFTypeID v7;
  uint64_t v8;

  v2 = -1;
  if (a1 && a2 && CFArrayGetCount(a1) >= 1)
  {
    v2 = 0;
    while (1)
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(a1, v2);
      if (ValueAtIndex)
      {
        v6 = ValueAtIndex;
        v7 = CFGetTypeID(ValueAtIndex);
        v8 = qword_10026D6C8;
        if (!qword_10026D6C8)
        {
          pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
          v8 = qword_10026D6C8;
        }
        if (v7 == v8 && sub_10002D2A0(v6[2], *(const __CFDictionary **)(a2 + 16), CFSTR("SSID_STR")))
          break;
      }
      if (++v2 >= CFArrayGetCount(a1))
        return -1;
    }
  }
  return v2;
}

BOOL sub_1000CB480(uint64_t a1)
{
  const __CFNumber *v1;
  void *v3;

  if (a1)
  {
    v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkOriginator"));
    return sub_10001F500(v1) == 2;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsCarrierBundleBased");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
}

const void *sub_1000CB504(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("WiFiNetworkDisabledUntilDate"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetDisabledUntilDate");
  objc_autoreleasePoolPop(v2);
  return 0;
}

const __CFArray *sub_1000CB584(const void *a1)
{
  const __CFArray *result;
  const __CFDictionary *v3;
  const void *Value;
  CFTypeID v5;
  const __CFNumber *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkCanExposeIMSI");
    goto LABEL_17;
  }
  if (!sub_10002C798((uint64_t)a1, 18) && !sub_10002C798((uint64_t)a1, 23))
  {
    result = sub_10002C798((uint64_t)a1, 50);
    if (!(_DWORD)result)
      return result;
  }
  v3 = (const __CFDictionary *)sub_10002BE64((uint64_t)a1, CFSTR("EnterpriseProfile"));
  if (!v3)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no eapProfile for %@", "WiFiNetworkCanExposeIMSI", sub_10002B088(a1));
    v9 = v8;
    goto LABEL_18;
  }
  Value = CFDictionaryGetValue(v3, CFSTR("EAPClientConfiguration"));
  v5 = CFGetTypeID(Value);
  if (v5 != CFDictionaryGetTypeID())
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid EAP client configuration", "WiFiNetworkCanExposeIMSI");
LABEL_17:
    v9 = v7;
LABEL_18:
    objc_autoreleasePoolPop(v9);
    return 0;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)Value, CFSTR("EAPSIMAKAEncryptedIdentityEnabled")))
  {
    v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("EAPSIMAKAEncryptedIdentityEnabled"));
    return (const __CFArray *)(sub_10001F500(v6) == 0);
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: missing encrypted identity key", "WiFiNetworkCanExposeIMSI");
    objc_autoreleasePoolPop(v10);
    return (const __CFArray *)1;
  }
}

void sub_1000CB74C(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("enabled")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("enabled"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("lastAutoJoined")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("lastAutoJoined"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("lastJoined")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("lastJoined"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("prevJoined")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("prevJoined"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("lastRoamed")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("lastRoamed"));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkRemoveInternalProperties");
    objc_autoreleasePoolPop(v2);
  }
}

CFDictionaryRef *sub_1000CB87C(CFDictionaryRef *result)
{
  char valuePtr;

  valuePtr = -1;
  if (result)
  {
    result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], CFSTR("11U_INTERWORKING_IE"));
    if (result)
    {
      result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("INTERWORKING_ACCESS_VENTURE_GRP"));
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        return (CFDictionaryRef *)(valuePtr == 11);
      }
    }
  }
  return result;
}

CFDictionaryRef *sub_1000CB8DC(CFDictionaryRef *result)
{
  char valuePtr;

  valuePtr = -1;
  if (result)
  {
    result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], CFSTR("11U_INTERWORKING_IE"));
    if (result)
    {
      result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("INTERWORKING_ACCESS_VENTURE_GRP"));
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        return (CFDictionaryRef *)(valuePtr == 10);
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1000CB93C(uint64_t a1)
{
  const __CFDictionary *result;
  char v2;
  void *v3;
  char valuePtr;

  valuePtr = -1;
  result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("11U_INTERWORKING_IE"));
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("INTERWORKING_ACCESS_NETWORK_TYPE"));
    if (result)
    {
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      v2 = valuePtr + 1;
      if ((valuePtr + 1) < 0x13u && ((0x6007Fu >> v2) & 1) != 0)
      {
        return (const __CFDictionary *)dword_1001BBA80[v2];
      }
      else
      {
        v3 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s unhandled type trying to convert from apple8021_access_network_t -> WiFiAdvertisedNetworkType", "WiFiNetworkGetAdvertisedNetworkType");
        objc_autoreleasePoolPop(v3);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1000CBA0C(CFDictionaryRef *a1, void *a2)
{
  void *v4;
  id v5;
  CFDictionaryRef Copy;
  NSData *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v12;
  uint64_t v13;

  v13 = 0;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@ path %@", "WiFiNetworkArchiveToPath", sub_10002B088(a1), a2, v13);
  objc_autoreleasePoolPop(v4);
  v5 = objc_msgSend(a2, "stringByDeletingLastPathComponent");
  if (-[NSFileManager fileExistsAtPath:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:", v5)|| -[NSFileManager createDirectoryAtPath:withIntermediateDirectories:attributes:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v5, 0, 0, &v13))
  {
    Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, a1[2]);
    v7 = +[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", Copy, 200, 0, 0);
    if (v7)
    {
      if (-[NSFileManager createFileAtPath:contents:attributes:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "createFileAtPath:contents:attributes:", a2, v7, 0))
      {
        v8 = 1;
        if (!Copy)
          return v8;
        goto LABEL_17;
      }
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to archive network dictionary in %@", "WiFiNetworkArchiveToPath", a2);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to archive network dictionary", "WiFiNetworkArchiveToPath", v12);
    }
    objc_autoreleasePoolPop(v9);
    v8 = 0;
    if (Copy)
LABEL_17:
      CFRelease(Copy);
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to create directory at path %@", "WiFiNetworkArchiveToPath", v5);
    objc_autoreleasePoolPop(v10);
    return 0;
  }
  return v8;
}

_WORD *sub_1000CBBE8(uint64_t a1)
{
  NSData *v2;
  _WORD *result;
  void *v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;

  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_13;
    v6 = "%s: path is nil";
LABEL_9:
    v7 = 3;
LABEL_12:
    objc_msgSend(v5, "WFLog:message:", v7, v6, "WiFiNetworkCreateFromPath", v8);
    goto LABEL_13;
  }
  v2 = -[NSFileManager contentsAtPath:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "contentsAtPath:", a1);
  if (!v2)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_13;
    v8 = a1;
    v6 = "%s: data at path %@ is nil";
    goto LABEL_9;
  }
  result = sub_10002B314(0, +[NSPropertyListSerialization propertyListWithData:options:format:error:](NSPropertyListSerialization, "propertyListWithData:options:format:error:", v2, 0, 0, 0));
  if (!result)
  {
    v4 = objc_autoreleasePoolPush();
    v5 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v8 = a1;
      v6 = "%s: unable to create WiFiNetworkRef at path %@";
      v7 = 4;
      goto LABEL_12;
    }
LABEL_13:
    objc_autoreleasePoolPop(v4);
    return 0;
  }
  return result;
}

uint64_t sub_1000CBCFC(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 24) = a2;
  return result;
}

uint64_t sub_1000CBD04(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

void sub_1000CBD0C(const void *a1, int a2)
{
  void *v4;
  void *v5;
  const void *v6;
  const char *v7;
  CFNumberRef v8;
  void *v9;
  int valuePtr;

  valuePtr = a2;
  if (a1)
  {
    if ((a2 - 1) > 1)
    {
      valuePtr = 0;
      v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting NOI work-state for '%@' to 'Unknown'", "WiFiNetworkSetNetworkOfInterestWorkType", sub_10002B088(a1));
      objc_autoreleasePoolPop(v9);
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = sub_10002B088(a1);
        v7 = "NotWork";
        if (a2 == 1)
          v7 = "Work";
        objc_msgSend(v5, "WFLog:message:", 3, "%s: Setting NOI work-state for '%@' to '%s'", "WiFiNetworkSetNetworkOfInterestWorkType", v6, v7);
      }
      objc_autoreleasePoolPop(v4);
      v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }
    sub_10002C478((uint64_t)a1, CFSTR("NetworkOfInterestWorkState"), v8);
    if (v8)
      CFRelease(v8);
  }
}

const __CFNumber *sub_1000CBE60(uint64_t a1)
{
  const __CFNumber *result;
  int Value;
  void *v4;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    result = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkOfInterestWorkState"));
    if (result)
    {
      Value = CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr - 3 >= 0xFFFFFFFE || Value == 0)
        return (const __CFNumber *)valuePtr;
      else
        return 0;
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetNetworkOfInterestWorkType");
    objc_autoreleasePoolPop(v4);
    return 0;
  }
  return result;
}

void sub_1000CBF00(const void *a1, int a2)
{
  void *v4;
  void *v5;
  const void *v6;
  CFNumberRef v7;
  void *v8;
  int valuePtr;

  valuePtr = a2;
  if (a1)
  {
    if ((a2 - 1) > 1)
    {
      valuePtr = 0;
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting NOI home-state for '%@' to 'Unknown'", "WiFiNetworkSetNetworkOfInterestHomeType", sub_10002B088(a1));
      objc_autoreleasePoolPop(v8);
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = sub_10002B088(a1);
        objc_msgSend(v5, "WFLog:message:", 3, "%s: Setting NOI home-state for '%@' to '%@'", "WiFiNetworkSetNetworkOfInterestHomeType", v6, sub_100064D68(a2));
      }
      objc_autoreleasePoolPop(v4);
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }
    sub_10002C478((uint64_t)a1, CFSTR("NetworkOfInterestHomeState"), v7);
    if (v7)
      CFRelease(v7);
  }
}

void sub_1000CC050(const void *a1, int a2)
{
  const void **v4;
  CFAbsoluteTime Current;
  CFDateRef v6;
  void *v7;

  if (a1)
  {
    v4 = (const void **)&kCFBooleanFalse;
    if (a2)
      v4 = (const void **)&kCFBooleanTrue;
    sub_10002C478((uint64_t)a1, CFSTR("NetworkForcedHomeFix"), *v4);
    if (a2)
    {
      Current = CFAbsoluteTimeGetCurrent();
      v6 = CFDateCreate(kCFAllocatorDefault, Current);
      sub_1000CC134(a1, v6);
      if (v6)
        CFRelease(v6);
    }
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetForcedHomeFix");
    objc_autoreleasePoolPop(v7);
  }
}

void sub_1000CC134(const void *a1, const void *a2)
{
  const void *v4;
  void *v5;
  void *v6;
  void *v7;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetLastHomeForceFixDate");
    goto LABEL_11;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null modDate", "WiFiNetworkSetLastHomeForceFixDate");
LABEL_11:
    v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v4 = sub_10002B088(a1);
  v5 = objc_autoreleasePoolPush();
  if (!v4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssid", "WiFiNetworkSetLastHomeForceFixDate");
    v7 = v5;
    goto LABEL_15;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: for network <%@>,  modDate %@", "WiFiNetworkSetLastHomeForceFixDate", v4, a2);
  objc_autoreleasePoolPop(v5);
  sub_10002C478((uint64_t)a1, CFSTR("kWiFiNetworkLastHomeForceFixDateKey"), a2);
}

uint64_t sub_1000CC270(uint64_t a1)
{
  const __CFNumber *v1;
  void *v2;
  unsigned int valuePtr;

  valuePtr = 0;
  if (!a1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetLOIType");
    goto LABEL_6;
  }
  v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("NetworkAtLocationOfInterestType"));
  if (!v1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null stateRef", "WiFiNetworkGetLOIType");
    goto LABEL_6;
  }
  if (!CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr))
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to get kWiFiNetworkAtLocationOfInterestTypeKey", "WiFiNetworkGetLOIType");
LABEL_6:
    objc_autoreleasePoolPop(v2);
  }
  return valuePtr;
}

void sub_1000CC35C(const void *a1, unsigned int a2)
{
  CFNumberRef v3;
  void *v4;
  void *v5;
  const __CFString *v6;
  unsigned int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  v4 = objc_autoreleasePoolPush();
  v5 = (void *)qword_10026DD20;
  if (v3)
  {
    if (qword_10026DD20)
    {
      v6 = sub_100064DE4(valuePtr);
      objc_msgSend(v5, "WFLog:message:", 3, "%s: Setting NetworkLocationOfInterestType=%@(%d) for %@", "WiFiNetworkSetLOIType", v6, valuePtr, sub_10002B088(a1));
    }
    objc_autoreleasePoolPop(v4);
    sub_10002C478((uint64_t)a1, CFSTR("NetworkAtLocationOfInterestType"), v3);
    CFRelease(v3);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create CFNumber while setting NetworkAtLocationOfInterestType=%d", "WiFiNetworkSetLOIType", valuePtr);
    objc_autoreleasePoolPop(v4);
  }
}

BOOL sub_1000CC464(const void *a1)
{
  const void *v1;
  BOOL v2;

  v1 = sub_10002B088(a1);
  if (qword_10026D6D8)
    v2 = v1 == 0;
  else
    v2 = 1;
  return !v2 && CFSetContainsValue((CFSetRef)qword_10026D6D8, v1);
}

const __CFNumber *sub_1000CC4A4(const __CFNumber *result)
{
  const __CFNumber *v1;

  if (result)
  {
    if (*((_QWORD *)result + 2))
    {
      v1 = (const __CFNumber *)sub_10002BE64((uint64_t)result, CFSTR("ShareableStatus"));
      return sub_10001F500(v1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1000CC4DC(uint64_t a1, const void *a2)
{
  if (a1)
    sub_10002C478(a1, CFSTR("WalletIdentifier"), a2);
}

const void *sub_1000CC4F8(const void *result)
{
  if (result)
    return sub_10002BE64((uint64_t)result, CFSTR("WalletIdentifier"));
  return result;
}

void sub_1000CC510(uint64_t a1, uint64_t a2)
{
  CFArrayRef v3;
  CFArrayRef v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  CFMutableDictionaryRef v7;
  __CFDictionary *v8;
  const __CFArray *v9;
  __CFString *v10;
  void *v11;
  void *v12;
  const __CFDictionary *v13;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v15;
  const __CFArray *Value;
  void *v17;
  void *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  CFTypeID TypeID;
  CFMutableDictionaryRef v22;
  const __CFArray *v23;
  void *values;
  uint64_t valuePtr;

  valuePtr = a2;
  values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (values)
  {
    v3 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    if (!v3)
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: build array failed for mode (%d)", "WiFiNetworkUpdateWPARSNAuthType", valuePtr);
      objc_autoreleasePoolPop(v12);
      goto LABEL_40;
    }
    v4 = v3;
    if ((unint64_t)(valuePtr - 1) < 2)
    {
      v13 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("RSN_IE"));
      if (v13)
      {
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v13);
        if (MutableCopy)
        {
          v15 = MutableCopy;
          Value = (const __CFArray *)CFDictionaryGetValue(v13, CFSTR("IE_KEY_RSN_AUTHSELS"));
          if (!Value || CFArrayGetCount(Value) >= 2)
          {
            CFDictionaryReplaceValue(v15, CFSTR("IE_KEY_RSN_AUTHSELS"), v4);
            sub_10002C478(a1, CFSTR("RSN_IE"), v15);
          }
          CFRelease(v15);
        }
      }
      else
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s RSN auth type (%d) has no RSN IE", "WiFiNetworkUpdateWPARSNAuthType", valuePtr);
        objc_autoreleasePoolPop(v18);
      }
      v19 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("WPA_IE"));
      if (v19)
      {
        v20 = v19;
        TypeID = CFDictionaryGetTypeID();
        if (sub_1000648AC(TypeID, v20))
        {
          v22 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v20);
          if (v22)
          {
            v8 = v22;
            v23 = (const __CFArray *)CFDictionaryGetValue(v13, CFSTR("IE_KEY_WPA_AUTHSELS"));
            if (v23 && CFArrayGetCount(v23) < 2)
              goto LABEL_35;
            CFDictionaryReplaceValue(v8, CFSTR("IE_KEY_WPA_AUTHSELS"), v4);
            v10 = CFSTR("WPA_IE");
            goto LABEL_34;
          }
LABEL_39:
          CFRelease(v4);
LABEL_40:
          if (values)
            CFRelease(values);
          return;
        }
      }
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s WPA auth type (%d) has no WPA IE", "WiFiNetworkUpdateWPARSNAuthType", valuePtr);
    }
    else
    {
      if (valuePtr != 8 && valuePtr != 12)
        goto LABEL_39;
      v5 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("RSN_IE"));
      if (v5)
      {
        v6 = v5;
        v7 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v5);
        if (v7)
        {
          v8 = v7;
          v9 = (const __CFArray *)CFDictionaryGetValue(v6, CFSTR("IE_KEY_RSN_AUTHSELS"));
          if (v9 && CFArrayGetCount(v9) < 2)
            goto LABEL_35;
          CFDictionaryReplaceValue(v8, CFSTR("IE_KEY_RSN_AUTHSELS"), v4);
          v10 = CFSTR("RSN_IE");
LABEL_34:
          sub_10002C478(a1, v10, v8);
LABEL_35:
          CFRelease(v8);
          goto LABEL_39;
        }
        goto LABEL_39;
      }
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s RSN auth type (%d) has no RSN IE", "WiFiNetworkUpdateWPARSNAuthType", valuePtr);
    }
    objc_autoreleasePoolPop(v17);
    goto LABEL_39;
  }
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: build number failed for mode(%d)", "WiFiNetworkUpdateWPARSNAuthType", valuePtr);
  objc_autoreleasePoolPop(v11);
}

uint64_t sub_1000CC884(uint64_t a1)
{
  const __CFNumber *v2;
  uint64_t result;
  CFBooleanRef v4;
  void *v5;

  if (a1)
  {
    v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("kWiFiNetworkSSIDHarvestStatusKey"));
    result = (uint64_t)sub_10001F500(v2);
    if (!(_DWORD)result)
    {
      v4 = (CFBooleanRef)sub_10002BE64(a1, CFSTR("WiFiNetworkAttributeHighPopularity"));
      if (v4 == kCFBooleanTrue)
      {
        if (sub_10002BE64(a1, CFSTR("WiFiNetworkAttributeIsPublic")) == v4)
          return 3;
        else
          return 0;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetHarvestSSIDStatus");
    objc_autoreleasePoolPop(v5);
    return 1;
  }
  return result;
}

void sub_1000CC95C(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("enabled")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("enabled"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("WiFiNetworkDisabledUntilDate")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("WiFiNetworkDisabledUntilDate"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("networkDisabledClientName")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledClientName"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("networkDisabledReason")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledReason"));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("networkDisabledTimestamp")))
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("networkDisabledTimestamp"));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkRemoveAutoJoinProperties");
    objc_autoreleasePoolPop(v2);
  }
}

const void *sub_1000CCA90(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("PrivacyProxyBlockedReason"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetPrivacyProxyBlockedReason");
  objc_autoreleasePoolPop(v2);
  return 0;
}

_WORD *sub_1000CCB10(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  id v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unint64_t v14;
  uint64_t v15;
  id v16;
  NSNumber *v17;
  NSNumber *v18;
  const __CFString *v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  void *v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  _UNKNOWN **v36;
  _UNKNOWN **v37;
  id v38;
  _UNKNOWN **v39;
  _UNKNOWN **v40;
  char v41;
  _UNKNOWN **v42;
  const __CFString *v43;
  void *v44;
  _UNKNOWN **v45;
  id v46;
  NSDictionary *v47;
  id v48;
  id v49;
  void *v50;
  id v51;
  id v52;
  id v53;
  uint64_t v54;
  NSString *const **v55;
  void *i;
  void *v57;
  id v58;
  const char *v59;
  ether_addr *v60;
  char *v61;
  id v62;
  id v63;
  id v64;
  id v65;
  void *v66;
  id v67;
  void *v68;
  double v69;
  id v70;
  void *v71;
  id v72;
  void *v73;
  id v74;
  void *v75;
  id v76;
  void *v77;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  uint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE v89[128];
  const __CFString *v90;
  id v91;

  v4 = objc_autoreleasePoolPush();
  v5 = sub_100027B80();
  v6 = 0;
  if (a1 && v5)
  {
    v7 = sub_100027B80();
    v8 = objc_opt_class(v7);
    if ((objc_opt_isKindOfClass(a1, v8) & 1) == 0)
    {
      v6 = 0;
      goto LABEL_223;
    }
    v9 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    if (!a2 || objc_msgSend(a2, "containsObject:", &off_100252EB8))
    {
      objc_msgSend(v9, "addEntriesFromDictionary:", objc_msgSend(a1, "OSSpecificAttributes"));
      if (!objc_msgSend(v9, "objectForKey:", CFSTR("AP_MODE")))
        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_100252E70, CFSTR("AP_MODE"));
    }
    v10 = objc_msgSend(a1, "coreWiFiSpecificAttributes");
    v84 = CWFCoreWiFiSpecificAttributesKey;
    objc_msgSend(v9, "setObject:forKeyedSubscript:", v10);
    v82 = v4;
    if (a2)
    {
      if (objc_msgSend(a2, "containsObject:", &off_100252ED0))
      {
        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "SSID"), CFSTR("SSID"));
        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkName"), CFSTR("SSID_STR"));
      }
      if ((objc_msgSend(a2, "containsObject:", &off_100252EE8) & 1) == 0)
      {
LABEL_61:
        if (!objc_msgSend(a2, "containsObject:", &off_100252F60))
        {
LABEL_65:
          if (!objc_msgSend(a2, "containsObject:", &off_100252F78))
            goto LABEL_72;
LABEL_66:
          if (objc_msgSend(a1, "hiddenState") == (id)1)
          {
            v32 = &__kCFBooleanTrue;
          }
          else
          {
            if (objc_msgSend(a1, "hiddenState") != (id)2)
              goto LABEL_71;
            v32 = &__kCFBooleanFalse;
          }
          objc_msgSend(v9, "setObject:forKeyedSubscript:", v32, CFSTR("UserDirected"));
LABEL_71:
          if (!a2)
          {
LABEL_73:
            if (objc_msgSend(a1, "isPasswordSharingDisabled"))
              objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_100252E70, CFSTR("ShareMode"));
            if (!a2)
            {
              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "payloadUUID"), CFSTR("PayloadUUID"));
LABEL_81:
              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "bundleID"), CFSTR("BundleIdentifier"));
              if (!a2)
              {
                if (objc_msgSend(a1, "isAutoJoinDisabled"))
                  v34 = &__kCFBooleanFalse;
                else
                  v34 = &__kCFBooleanTrue;
                objc_msgSend(v9, "setObject:forKeyedSubscript:", v34, CFSTR("enabled"));
LABEL_93:
                v35 = objc_msgSend(a1, "lowDataMode");
                v36 = &off_100252DB0;
                if (v35 == (id)2)
                  v36 = &off_100252E70;
                if (v35 == (id)1)
                  v37 = &off_100252DC8;
                else
                  v37 = v36;
                objc_msgSend(v9, "setObject:forKeyedSubscript:", v37, CFSTR("SaveDataMode"));
                if (!a2)
                {
                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "lastJoinedByUserAt"), CFSTR("lastJoined"));
LABEL_104:
                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "lastJoinedBySystemAt"), CFSTR("lastAutoJoined"));
                  if (!a2)
                  {
LABEL_106:
                    v38 = objc_msgSend(a1, "addReason");
                    v39 = 0;
                    v40 = &off_100252E10;
                    v41 = 1;
                    v42 = &off_100252DC8;
                    switch((unint64_t)v38)
                    {
                      case 2uLL:
                      case 3uLL:
                      case 4uLL:
                      case 5uLL:
                        goto LABEL_107;
                      case 6uLL:
                        v42 = &off_100252EA0;
                        goto LABEL_107;
                      case 7uLL:
                        v39 = 0;
                        v40 = &off_100252DC8;
                        v42 = &off_100252E88;
                        goto LABEL_119;
                      case 8uLL:
                        v42 = &off_100252DE0;
                        goto LABEL_107;
                      case 9uLL:
                        v42 = &off_100253068;
                        goto LABEL_107;
                      case 0xAuLL:
                        v39 = 0;
                        v42 = &off_100252E70;
                        goto LABEL_119;
                      case 0xBuLL:
                        v42 = &off_100252F18;
                        goto LABEL_107;
                      case 0xCuLL:
                        v39 = 0;
                        v40 = &off_100252DC8;
                        v42 = &off_100252DF8;
                        goto LABEL_119;
                      case 0xDuLL:
                        v42 = &off_100252DF8;
LABEL_107:
                        v43 = CFSTR("WiFiManagerKnownNetworksEventType");
                        v44 = v9;
                        v45 = v42;
                        goto LABEL_121;
                      case 0xEuLL:
                        v39 = 0;
                        v42 = &off_100252DB0;
                        goto LABEL_119;
                      case 0xFuLL:
                        goto LABEL_119;
                      case 0x10uLL:
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_100253050, CFSTR("WiFiManagerKnownNetworksEventType"));
                        v39 = &off_100252EE8;
                        goto LABEL_120;
                      case 0x11uLL:
                        v41 = 0;
                        v39 = &off_100252ED0;
                        v40 = &off_100253050;
                        v42 = &off_100252DE0;
LABEL_119:
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", v40, CFSTR("WiFiManagerKnownNetworksEventType"));
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", v42, CFSTR("NetworkOriginator"));
                        if ((v41 & 1) == 0)
                        {
LABEL_120:
                          v43 = CFSTR("WiFiNetworkAttributeSource");
                          v44 = v9;
                          v45 = v39;
LABEL_121:
                          objc_msgSend(v44, "setObject:forKeyedSubscript:", v45, v43);
                        }
                        break;
                      default:
                        break;
                    }
                    if (!a2)
                    {
                      objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "addedAt", v40), CFSTR("addedAt"));
LABEL_128:
                      v46 = objc_msgSend(a1, "EAPProfile");
                      if (v46)
                      {
                        v90 = CFSTR("EAPClientConfiguration");
                        v91 = v46;
                        v47 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v91, &v90, 1);
                      }
                      else
                      {
                        v47 = 0;
                      }
                      objc_msgSend(v9, "setObject:forKeyedSubscript:", v47, CFSTR("EnterpriseProfile"));
                      if (!a2)
                      {
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "domainName"), CFSTR("DomainName"));
LABEL_137:
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "displayedOperatorName"), CFSTR("DisplayedOperatorName"));
                        if (!a2)
                        {
                          objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isServiceProviderRoamingEnabled")), CFSTR("SPRoaming"));
LABEL_143:
                          objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "cellularNetworkInfo"), CFSTR("MCCandMNC"));
                          if (!a2)
                          {
                            objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "NAIRealmNameList"), CFSTR("NaiRealmName"));
LABEL_149:
                            objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "roamingConsortiumList"), CFSTR("RoamingConsortiumOIs"));
                            if (!a2)
                            {
                              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "userPreferredNetworkNames"), CFSTR("userPreferredNetworkNames"));
LABEL_155:
                              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "userPreferredPasspointDomains"), CFSTR("userPreferredPasspointDomains"));
                              if (!a2)
                              {
                                objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkGroupID"), CFSTR("networkGroupID"));
LABEL_161:
                                objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkGroupPriority"), CFSTR("networkGroupPriority"));
                                if (!a2)
                                {
                                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "lastDiscoveredAt"), CFSTR("discoveredAt"));
LABEL_167:
                                  v48 = +[NSMutableSet set](NSMutableSet, "set");
                                  v49 = objc_msgSend(a1, "BSSList");
                                  if (v49)
                                  {
                                    v50 = v49;
                                    v79 = a2;
                                    v80 = v9;
                                    v81 = a1;
                                    v87 = 0u;
                                    v88 = 0u;
                                    v85 = 0u;
                                    v86 = 0u;
                                    v51 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
                                    if (v51)
                                    {
                                      v52 = v51;
                                      v53 = 0;
                                      v54 = *(_QWORD *)v86;
                                      v55 = &ACAccountStoreDidChangeNotification_ptr;
                                      v83 = v50;
                                      do
                                      {
                                        for (i = 0; i != v52; i = (char *)i + 1)
                                        {
                                          if (*(_QWORD *)v86 != v54)
                                            objc_enumerationMutation(v50);
                                          v57 = *(void **)(*((_QWORD *)&v85 + 1) + 8 * (_QWORD)i);
                                          v58 = objc_msgSend(v57, "BSSID");
                                          if (v58)
                                          {
                                            v59 = (const char *)objc_msgSend(v58, "UTF8String");
                                            if (v59)
                                            {
                                              v60 = ether_aton(v59);
                                              if (v60)
                                              {
                                                v61 = ether_ntoa(v60);
                                                if (v61)
                                                {
                                                  v62 = objc_msgSend((id)v55[449], "stringWithUTF8String:", v61);
                                                  if (v62)
                                                  {
                                                    v63 = v62;
                                                    if ((objc_msgSend(v48, "containsObject:", v62) & 1) == 0)
                                                    {
                                                      objc_msgSend(v48, "addObject:", v63);
                                                      v64 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
                                                      objc_msgSend(v64, "addEntriesFromDictionary:", objc_msgSend(v57, "OSSpecificAttributes"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", v63, CFSTR("BSSID"));
                                                      v65 = objc_msgSend(v57, "channel");
                                                      if (v65)
                                                      {
                                                        v66 = v65;
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v65, "channel")), CFSTR("CHANNEL"));
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v66, "flags")), CFSTR("CHANNEL_FLAGS"));
                                                      }
                                                      v67 = objc_msgSend(v57, "location");
                                                      if (v67)
                                                      {
                                                        v68 = v67;
                                                        objc_msgSend(v67, "coordinate");
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), CFSTR("networkLocnLat"));
                                                        objc_msgSend(v68, "coordinate");
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v69), CFSTR("networkLocnLong"));
                                                        objc_msgSend(v68, "horizontalAccuracy");
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), CFSTR("networkLocnAccuracy"));
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v68, "timestamp"), CFSTR("networkLocnTimestamp"));
                                                      }
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "lastAssociatedAt"), CFSTR("lastRoamed"));
                                                      v70 = objc_msgSend(v57, "colocated2GHzRNRChannel");
                                                      if (v70)
                                                      {
                                                        v71 = v70;
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v70, "channel")), CFSTR("colocated2GHzRNRChannel"));
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v71, "flags")), CFSTR("colocated2GHzRNRChannelFlags"));
                                                      }
                                                      v72 = objc_msgSend(v57, "colocated5GHzRNRChannel");
                                                      if (v72)
                                                      {
                                                        v73 = v72;
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v72, "channel")), CFSTR("colocated5GHzRNRChannel"));
                                                        objc_msgSend(v64, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v73, "flags")), CFSTR("colocated5GHzRNRChannelFlags"));
                                                      }
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "AWDLRealTimeModeTimestamp"), CFSTR("AWDLRealTimeModeTimestamp"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "IPv4NetworkSignature"), CFSTR("IPv4NetworkSignature"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "IPv6NetworkSignature"), CFSTR("IPv6NetworkSignature"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "DHCPServerID"), CFSTR("DHCPServerID"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "DHCPv6ServerID"), CFSTR("DHCPv6ServerID"));
                                                      objc_msgSend(v64, "setObject:forKeyedSubscript:", objc_msgSend(v57, "coreWiFiSpecificAttributes"), v84);
                                                      if (!v53)
                                                        v53 = +[NSMutableArray array](NSMutableArray, "array");
                                                      objc_msgSend(v53, "addObject:", v64);
                                                      v50 = v83;
                                                      v55 = &ACAccountStoreDidChangeNotification_ptr;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                        v52 = objc_msgSend(v50, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
                                      }
                                      while (v52);
                                    }
                                    else
                                    {
                                      v53 = 0;
                                    }
                                    v9 = v80;
                                    objc_msgSend(v80, "setObject:forKeyedSubscript:", v53, CFSTR("networkKnownBSSListKey"));
                                    a1 = v81;
                                    v4 = v82;
                                    a2 = v79;
                                  }
                                  if (!a2)
                                  {
                                    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isPrivacyProxyEnabled")), CFSTR("PrivacyProxyEnabled"));
                                    goto LABEL_201;
                                  }
LABEL_196:
                                  if (objc_msgSend(a2, "containsObject:", &off_1002531D0))
                                    objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isPrivacyProxyEnabled")), CFSTR("PrivacyProxyEnabled"));
                                  if ((objc_msgSend(a2, "containsObject:", &off_1002531E8) & 1) == 0)
                                  {
LABEL_202:
                                    if (!objc_msgSend(a2, "containsObject:", &off_100253200))
                                    {
LABEL_209:
                                      if (!objc_msgSend(a2, "containsObject:", &off_100253218))
                                        goto LABEL_216;
LABEL_210:
                                      v76 = objc_msgSend(a1, "publicAttribute");
                                      if (v76 == (id)1)
                                      {
                                        v77 = &__kCFBooleanTrue;
                                      }
                                      else
                                      {
                                        if (v76 != (id)2)
                                          goto LABEL_215;
                                        v77 = &__kCFBooleanFalse;
                                      }
                                      objc_msgSend(v9, "setObject:forKeyedSubscript:", v77, CFSTR("WiFiNetworkAttributeIsPublic"));
LABEL_215:
                                      if (!a2)
                                      {
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(a1, "transitionDisabledFlags")), CFSTR("TransitionDisabledFlags"));
LABEL_221:
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isStandalone6G")), CFSTR("Standalone"));
LABEL_222:
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "carplayUUID"), CFSTR("CARPLAY_UUID"));
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isPersonalHotspot")), CFSTR("IsPersonalHotspot"));
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "NANServiceID"), CFSTR("WiFiNetworkNANServiceID"));
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isPublicAirPlayNetwork")), CFSTR("PublicAirPlayNetwork"));
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isDNSHeuristicsFilteredNetwork")), CFSTR("FilteredNetwork"));
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "DNSHeuristicsFailureStateInfo"), CFSTR("DNSFailures"));
                                        v6 = sub_10002B314((uint64_t)kCFAllocatorDefault, v9);
                                        goto LABEL_223;
                                      }
LABEL_216:
                                      if (objc_msgSend(a2, "containsObject:", &off_100253230))
                                        objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(a1, "transitionDisabledFlags")), CFSTR("TransitionDisabledFlags"));
                                      if ((objc_msgSend(a2, "containsObject:", &off_100253248) & 1) == 0)
                                        goto LABEL_222;
                                      goto LABEL_221;
                                    }
LABEL_203:
                                    v74 = objc_msgSend(a1, "movingAttribute");
                                    if (v74 == (id)1)
                                    {
                                      v75 = &__kCFBooleanTrue;
                                    }
                                    else
                                    {
                                      if (v74 != (id)2)
                                        goto LABEL_208;
                                      v75 = &__kCFBooleanFalse;
                                    }
                                    objc_msgSend(v9, "setObject:forKeyedSubscript:", v75, CFSTR("WiFiNetworkAttributeIsMoving"));
LABEL_208:
                                    if (!a2)
                                      goto LABEL_210;
                                    goto LABEL_209;
                                  }
LABEL_201:
                                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "privacyProxyBlockedReason"), CFSTR("PrivacyProxyBlockedReason"));
                                  if (!a2)
                                    goto LABEL_203;
                                  goto LABEL_202;
                                }
LABEL_162:
                                if (objc_msgSend(a2, "containsObject:", &off_1002531A0))
                                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "lastDiscoveredAt"), CFSTR("discoveredAt"));
                                if ((objc_msgSend(a2, "containsObject:", &off_1002531B8) & 1) == 0)
                                  goto LABEL_196;
                                goto LABEL_167;
                              }
LABEL_156:
                              if (objc_msgSend(a2, "containsObject:", &off_100253170))
                                objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkGroupID"), CFSTR("networkGroupID"));
                              if ((objc_msgSend(a2, "containsObject:", &off_100253188) & 1) == 0)
                                goto LABEL_162;
                              goto LABEL_161;
                            }
LABEL_150:
                            if (objc_msgSend(a2, "containsObject:", &off_100253140))
                              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "userPreferredNetworkNames"), CFSTR("userPreferredNetworkNames"));
                            if ((objc_msgSend(a2, "containsObject:", &off_100253158) & 1) == 0)
                              goto LABEL_156;
                            goto LABEL_155;
                          }
LABEL_144:
                          if (objc_msgSend(a2, "containsObject:", &off_100253110))
                            objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "NAIRealmNameList"), CFSTR("NaiRealmName"));
                          if ((objc_msgSend(a2, "containsObject:", &off_100253128) & 1) == 0)
                            goto LABEL_150;
                          goto LABEL_149;
                        }
LABEL_138:
                        if (objc_msgSend(a2, "containsObject:", &off_1002530E0))
                          objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a1, "isServiceProviderRoamingEnabled")), CFSTR("SPRoaming"));
                        if ((objc_msgSend(a2, "containsObject:", &off_1002530F8) & 1) == 0)
                          goto LABEL_144;
                        goto LABEL_143;
                      }
LABEL_132:
                      if (objc_msgSend(a2, "containsObject:", &off_1002530B0))
                        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "domainName"), CFSTR("DomainName"));
                      if ((objc_msgSend(a2, "containsObject:", &off_1002530C8) & 1) == 0)
                        goto LABEL_138;
                      goto LABEL_137;
                    }
LABEL_123:
                    if (objc_msgSend(a2, "containsObject:", &off_100253080))
                      objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "addedAt"), CFSTR("addedAt"));
                    if ((objc_msgSend(a2, "containsObject:", &off_100253098) & 1) == 0)
                      goto LABEL_132;
                    goto LABEL_128;
                  }
LABEL_105:
                  if (!objc_msgSend(a2, "containsObject:", &off_100253038))
                    goto LABEL_123;
                  goto LABEL_106;
                }
LABEL_99:
                if (objc_msgSend(a2, "containsObject:", &off_100253008))
                  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "lastJoinedByUserAt"), CFSTR("lastJoined"));
                if ((objc_msgSend(a2, "containsObject:", &off_100253020) & 1) == 0)
                  goto LABEL_105;
                goto LABEL_104;
              }
LABEL_82:
              if (objc_msgSend(a2, "containsObject:", &off_100252FD8))
              {
                if (objc_msgSend(a1, "isAutoJoinDisabled"))
                  v33 = &__kCFBooleanFalse;
                else
                  v33 = &__kCFBooleanTrue;
                objc_msgSend(v9, "setObject:forKeyedSubscript:", v33, CFSTR("enabled"));
              }
              if ((objc_msgSend(a2, "containsObject:", &off_100252FF0) & 1) == 0)
                goto LABEL_99;
              goto LABEL_93;
            }
LABEL_76:
            if (objc_msgSend(a2, "containsObject:", &off_100252FA8))
              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "payloadUUID"), CFSTR("PayloadUUID"));
            if ((objc_msgSend(a2, "containsObject:", &off_100252FC0) & 1) == 0)
              goto LABEL_82;
            goto LABEL_81;
          }
LABEL_72:
          if (!objc_msgSend(a2, "containsObject:", &off_100252F90))
            goto LABEL_76;
          goto LABEL_73;
        }
LABEL_62:
        v31 = objc_msgSend(a1, "captiveProfile");
        if (v31)
          objc_msgSend(v9, "addEntriesFromDictionary:", v31);
        if (!a2)
          goto LABEL_66;
        goto LABEL_65;
      }
      v11 = (unsigned __int16)objc_msgSend(a1, "supportedSecurityTypes");
      v12 = v11;
      if ((v11 & 2) == 0)
      {
        if ((v11 & 1) == 0
          || (objc_msgSend(v9, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("WEP")),
              !objc_msgSend(a2, "containsObject:", &off_100252F48)))
        {
LABEL_31:
          if ((v12 & 0xC) != 0)
          {
            v20 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
            objc_msgSend(v20, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 1), CFSTR("IE_KEY_WPA_VERSION"));
            objc_msgSend(v20, "setObject:forKey:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 2), CFSTR("IE_KEY_WPA_MCIPHER"));
            v21 = +[NSMutableArray array](NSMutableArray, "array");
            objc_msgSend(v21, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 2));
            objc_msgSend(v20, "setObject:forKey:", v21, CFSTR("IE_KEY_WPA_UCIPHERS"));
            v22 = +[NSMutableArray array](NSMutableArray, "array");
            if ((v12 & 8) != 0)
              v23 = 1;
            else
              v23 = 2;
            objc_msgSend(v22, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v23));
            objc_msgSend(v20, "setObject:forKey:", v22, CFSTR("IE_KEY_WPA_AUTHSELS"));
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v20, CFSTR("WPA_IE"));
          }
          v24 = v12 & 0x300;
          if ((v12 & 0xF0) == 0 && v24 != 256)
          {
LABEL_52:
            if (v24 == 768)
              objc_msgSend(v9, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SCAN_RESULT_OWE_MULTI_SSID"));
            if (objc_msgSend(a1, "isWPA2"))
              v29 = &__kCFBooleanTrue;
            else
              v29 = &__kCFBooleanFalse;
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v29, CFSTR("ALLOW_WPA2_PSK"));
            if (objc_msgSend(a1, "isOpen"))
              v30 = &__kCFBooleanTrue;
            else
              v30 = &__kCFBooleanFalse;
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v30, CFSTR("ALLOW_OWE_TSN"));
            v4 = v82;
            if (!a2)
              goto LABEL_62;
            goto LABEL_61;
          }
          v25 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
          objc_msgSend(v25, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 1), CFSTR("IE_KEY_RSN_VERSION"));
          objc_msgSend(v25, "setObject:forKey:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 4), CFSTR("IE_KEY_RSN_MCIPHER"));
          v26 = +[NSMutableArray array](NSMutableArray, "array");
          objc_msgSend(v26, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 4));
          objc_msgSend(v25, "setObject:forKey:", v26, CFSTR("IE_KEY_RSN_UCIPHERS"));
          v27 = +[NSMutableArray array](NSMutableArray, "array");
          if ((v12 & 0x80) != 0)
          {
            objc_msgSend(v27, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 12));
            if ((v12 & 0x20) == 0)
            {
LABEL_40:
              if ((v12 & 0x40) == 0)
                goto LABEL_47;
              goto LABEL_44;
            }
          }
          else if ((v12 & 0x20) == 0)
          {
            goto LABEL_40;
          }
          objc_msgSend(v27, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 1));
          if ((v12 & 0x40) == 0)
          {
LABEL_47:
            if (v24 == 256)
              objc_msgSend(v27, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 18));
            if ((v12 & 0x10) != 0)
              objc_msgSend(v27, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 2));
            objc_msgSend(v25, "setObject:forKey:", v27, CFSTR("IE_KEY_RSN_AUTHSELS"));
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v25, CFSTR("RSN_IE"));
            goto LABEL_52;
          }
LABEL_44:
          objc_msgSend(v27, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 8));
          v28 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
          objc_msgSend(v28, "setObject:forKey:", &__kCFBooleanTrue, CFSTR("MFP_CAPABLE"));
          if ((v12 & 0x10) == 0)
            objc_msgSend(v28, "setObject:forKey:", &__kCFBooleanTrue, CFSTR("MFP_REQUIRED"));
          objc_msgSend(v25, "setObject:forKey:", v28, CFSTR("IE_KEY_RSN_CAPS"));
          goto LABEL_47;
        }
        goto LABEL_19;
      }
      if (!objc_msgSend(a2, "containsObject:", &off_100252F00))
        goto LABEL_31;
    }
    else
    {
      objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "SSID"), CFSTR("SSID"));
      objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkName"), CFSTR("SSID_STR"));
      v13 = (unsigned __int16)objc_msgSend(a1, "supportedSecurityTypes");
      v12 = v13;
      if ((v13 & 2) == 0)
      {
        if ((v13 & 1) == 0)
          goto LABEL_31;
        objc_msgSend(v9, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("WEP"));
LABEL_19:
        v14 = (unint64_t)objc_msgSend(a1, "WEPSubtype") - 1;
        if (v14 > 3)
          v15 = 0;
        else
          v15 = dword_1001BBAD0[v14];
        v18 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v15);
        v19 = CFSTR("WEP_AUTH_Flags");
LABEL_30:
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v18, v19);
        goto LABEL_31;
      }
    }
    v16 = objc_msgSend(a1, "WAPISubtype");
    v17 = (NSNumber *)&off_100252F30;
    if (v16 != (id)1)
      v17 = 0;
    if (v16 == (id)2)
      v18 = (NSNumber *)&off_100252F18;
    else
      v18 = v17;
    v19 = CFSTR("WAPI");
    goto LABEL_30;
  }
LABEL_223:
  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t sub_1000CE080(const void **a1, const __CFDictionary **a2)
{
  const void *v4;
  const void *v5;
  BOOL v6;
  uint64_t result;
  int v8;
  void *v9;
  void *v10;
  const void *v11;

  v4 = sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkNANServiceID"));
  v5 = sub_10002BE64((uint64_t)a2, CFSTR("WiFiNetworkNANServiceID"));
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (!v6 && CFEqual(v4, v5))
    return 1;
  result = 0;
  if (!a1 || !a2)
    return result;
  if (!sub_10002D248(a1[2], a2[2]))
  {
    if (!sub_1000CFFA4(a1, a2, 0))
    {
      v8 = sub_1000C6000((uint64_t)a1, (uint64_t)a2);
      return v8 != 0;
    }
    return 1;
  }
  if ((!sub_10002DA5C((_BOOL8)a1) || sub_10002DA5C((_BOOL8)a2))
    && (sub_10002DA5C((_BOOL8)a1) || !sub_10002DA5C((_BOOL8)a2)))
  {
    result = sub_10002D378((const __CFDictionary *)a1[2], a2[2]);
    if (!(_DWORD)result)
      return result;
    v8 = sub_10002D2A0(a1[2], a2[2], CFSTR("AP_MODE"));
    return v8 != 0;
  }
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v11 = sub_1000C9A4C((uint64_t)a1);
    objc_msgSend(v10, "WFLog:message:", 3, "%s: Same SSID HS20 networks - network1: %@ (domain='%@'), network2: %@ (domain='%@')", "__WiFiNetworkEqualIgnoreAuthType", a1, v11, a2, sub_1000C9A4C((uint64_t)a2));
  }
  objc_autoreleasePoolPop(v9);
  return 0;
}

void *sub_1000CE200(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  void *v7;
  _WORD *v8;
  const void *v9;
  id v10;
  CFDictionaryRef *v11;
  CFDictionaryRef *v12;
  CFDictionaryRef Copy;
  CFDictionaryRef v14;
  id v15;
  void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;

  v2 = objc_autoreleasePoolPush();
  v3 = sub_10002851C();
  if (a1
    && v3
    && (v4 = sub_10002851C(), v5 = objc_opt_class(v4), (objc_opt_isKindOfClass(a1, v5) & 1) != 0)
    && (v6 = objc_msgSend(objc_msgSend(a1, "scanRecord"), "mutableCopy")) != 0
    && (v7 = v6,
        objc_msgSend(v6, "addEntriesFromDictionary:", objc_msgSend(a1, "OSSpecificAttributes")),
        (v8 = sub_10002B314((uint64_t)kCFAllocatorDefault, v7)) != 0))
  {
    v9 = v8;
    v10 = objc_msgSend(a1, "matchingKnownNetworkProfile");
    if (v10)
    {
      v11 = (CFDictionaryRef *)sub_1000CCB10(v10, 0);
      v12 = v11;
      if (v11 && (Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v11[2])) != 0)
      {
        v14 = Copy;
        v15 = objc_msgSend(v7, "copy");
        objc_msgSend(v7, "setDictionary:", v14);
        objc_msgSend(v7, "addEntriesFromDictionary:", v15);
        v16 = sub_10002B314((uint64_t)kCFAllocatorDefault, v7);
        CFRelease(v14);
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      v16 = (void *)CFRetain(v9);
      v12 = 0;
    }
    v17 = sub_10002BE64((uint64_t)v12, CFSTR("WPA_IE"));
    v18 = sub_10002BE64((uint64_t)v9, CFSTR("WPA_IE"));
    v19 = sub_10002BE64((uint64_t)v12, CFSTR("RSN_IE"));
    v20 = sub_10002BE64((uint64_t)v9, CFSTR("RSN_IE"));
    if (v19 && v17 && v20 && !v18)
      sub_10002C478((uint64_t)v16, CFSTR("WPA_IE"), 0);
    if (!sub_10002BE64((uint64_t)v9, CFSTR("BSSID")))
      sub_10002C478((uint64_t)v16, CFSTR("BSSID"), 0);
    objc_autoreleasePoolPop(v2);
    if (v12)
      CFRelease(v12);
    CFRelease(v9);
  }
  else
  {
    objc_autoreleasePoolPop(v2);
    return 0;
  }
  return v16;
}

const __CFDictionary *sub_1000CE400(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  CFTypeID TypeID;

  if (result)
  {
    result = (const __CFDictionary *)sub_10002BE64((uint64_t)result, CFSTR("WPS_PROB_RESP_IE"));
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IE_KEY_WPS_MANUFACTURER"));
      if (result)
      {
        v1 = result;
        TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1))
          return v1;
        else
          return 0;
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1000CE458(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  CFTypeID TypeID;

  if (result)
  {
    result = (const __CFDictionary *)sub_10002BE64((uint64_t)result, CFSTR("WPS_PROB_RESP_IE"));
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IE_KEY_WPS_MODEL_NAME"));
      if (result)
      {
        v1 = result;
        TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1))
          return v1;
        else
          return 0;
      }
    }
  }
  return result;
}

const __CFDictionary *sub_1000CE4B0(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  CFTypeID TypeID;

  if (result)
  {
    result = (const __CFDictionary *)sub_10002BE64((uint64_t)result, CFSTR("WPS_PROB_RESP_IE"));
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IE_KEY_WPS_MODEL_NUM"));
      if (result)
      {
        v1 = result;
        TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1))
          return v1;
        else
          return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1000CE508(uint64_t a1)
{
  if (a1)
    sub_10002BE64(a1, CFSTR("WPS_PROB_RESP_IE"));
  return 0;
}

CFDataRef sub_1000CE52C(const __CFData *a1, const __CFData *a2, const __CFData *a3, CFStringRef theString)
{
  CFDataRef v4;
  __int128 v5;
  const __CFAllocator *v9;
  CFDataRef ExternalRepresentation;
  const __CFData *v11;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  const UInt8 *v14;
  const UInt8 *v15;
  const UInt8 *v16;
  CFIndex Length;
  CFIndex v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  UInt8 *MutableBytePtr;
  __int128 v23;
  CC_SHA256_CTX v25;
  _OWORD bytes[2];
  unsigned __int8 md[16];
  __int128 v28;

  v4 = 0;
  *(_OWORD *)md = 0u;
  v28 = 0u;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v5;
  bytes[1] = v5;
  if (a1 && a3)
  {
    if (theString)
    {
      v9 = kCFAllocatorDefault;
      ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
    }
    else
    {
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
        return 0;
      v9 = kCFAllocatorDefault;
      ExternalRepresentation = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)bytes, 32);
    }
    v11 = ExternalRepresentation;
    Mutable = CFDataCreateMutable(v9, 0);
    if (Mutable)
    {
      BytePtr = CFDataGetBytePtr(v11);
      v14 = CFDataGetBytePtr(a1);
      v15 = CFDataGetBytePtr(a3);
      if (a2)
        v16 = CFDataGetBytePtr(a2);
      else
        v16 = 0;
      Length = CFDataGetLength(a1);
      CFDataAppendBytes(Mutable, v14, Length);
      CFDataAppendBytes(Mutable, v15, 6);
      v18 = CFDataGetLength(v11);
      CFDataAppendBytes(Mutable, BytePtr, v18);
      if (a2 && v16)
      {
        v19 = CFDataGetLength(a2);
        CFDataAppendBytes(Mutable, v16, v19);
      }
      v20 = CFDataGetLength(a1);
      v21 = v20 + CFDataGetLength(v11) + 6;
      if (a2)
        LODWORD(v21) = CFDataGetLength(a2) + v21;
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      *(_QWORD *)&v25.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v25.wbuf[6] = v23;
      *(_OWORD *)&v25.wbuf[10] = v23;
      *(_OWORD *)&v25.hash[6] = v23;
      *(_OWORD *)&v25.wbuf[2] = v23;
      *(_OWORD *)v25.count = v23;
      *(_OWORD *)&v25.hash[2] = v23;
      CC_SHA256_Init(&v25);
      CC_SHA256_Update(&v25, MutableBytePtr, v21);
      CC_SHA256_Final(md, &v25);
    }
    v25.count[0] = *(_DWORD *)md;
    LOWORD(v25.count[1]) = *(_WORD *)&md[4];
    LOBYTE(v25.count[0]) = md[0] & 0xFC | 2;
    v4 = CFDataCreate(v9, (const UInt8 *)&v25, 6);
    if (Mutable)
      CFRelease(Mutable);
    if (v11)
      CFRelease(v11);
  }
  return v4;
}

CFDataRef sub_1000CE7A0(const __CFData *a1, const __CFData *a2, CFStringRef theString)
{
  CFDataRef v3;
  __int128 v4;
  const __CFAllocator *v7;
  const __CFData *ExternalRepresentation;
  const __SecRandom *v9;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  const UInt8 *v12;
  const UInt8 *v13;
  CFIndex Length;
  CFIndex v15;
  int v16;
  UInt8 *MutableBytePtr;
  __int128 v18;
  CC_SHA256_CTX v20;
  UInt8 v21[4];
  __int16 v22;
  UInt8 v23[16];
  __int128 v24;
  _OWORD bytes[2];
  unsigned __int8 md[16];
  __int128 v27;

  v3 = 0;
  v22 = 0;
  *(_DWORD *)v21 = 0;
  *(_OWORD *)md = 0u;
  v27 = 0u;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v4;
  bytes[1] = v4;
  *(_OWORD *)v23 = v4;
  v24 = v4;
  if (a1 && a2)
  {
    if (theString)
    {
      v7 = kCFAllocatorDefault;
      ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
      v9 = kSecRandomDefault;
    }
    else
    {
      v9 = kSecRandomDefault;
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, v23))
        return 0;
      v7 = kCFAllocatorDefault;
      ExternalRepresentation = CFDataCreate(kCFAllocatorDefault, v23, 32);
    }
    if (SecRandomCopyBytes(v9, 0x20uLL, bytes))
    {
      v3 = 0;
    }
    else
    {
      Mutable = CFDataCreateMutable(v7, 0);
      if (Mutable)
      {
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        v12 = CFDataGetBytePtr(a1);
        v13 = CFDataGetBytePtr(a2);
        Length = CFDataGetLength(a1);
        CFDataAppendBytes(Mutable, v12, Length);
        CFDataAppendBytes(Mutable, v13, 6);
        v15 = CFDataGetLength(ExternalRepresentation);
        CFDataAppendBytes(Mutable, BytePtr, v15);
        CFDataAppendBytes(Mutable, (const UInt8 *)bytes, 32);
        v16 = CFDataGetLength(a1);
        LODWORD(v13) = v16 + CFDataGetLength(ExternalRepresentation);
        MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
        *(_QWORD *)&v20.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v20.wbuf[6] = v18;
        *(_OWORD *)&v20.wbuf[10] = v18;
        *(_OWORD *)&v20.hash[6] = v18;
        *(_OWORD *)&v20.wbuf[2] = v18;
        *(_OWORD *)v20.count = v18;
        *(_OWORD *)&v20.hash[2] = v18;
        CC_SHA256_Init(&v20);
        CC_SHA256_Update(&v20, MutableBytePtr, (_DWORD)v13 + 38);
        CC_SHA256_Final(md, &v20);
      }
      *(_DWORD *)v21 = *(_DWORD *)md;
      v22 = *(_WORD *)&md[4];
      v21[0] = md[0] & 0xFC | 2;
      v3 = CFDataCreate(v7, v21, 6);
      if (Mutable)
        CFRelease(Mutable);
    }
    if (ExternalRepresentation)
      CFRelease(ExternalRepresentation);
  }
  return v3;
}

CFDataRef sub_1000CEA08(const __CFData *a1, const __CFString *a2)
{
  CFDataRef v2;
  __int128 v3;
  const __CFData *ExternalRepresentation;
  CFMutableDataRef Mutable;
  __CFData *v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  CFIndex Length;
  int v11;
  UInt8 *MutableBytePtr;
  __int128 v13;
  CC_SHA256_CTX v15;
  unsigned __int8 md[16];
  __int128 v17;
  UInt8 bytes[16];
  __int128 v19;

  v2 = 0;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v3;
  v19 = v3;
  *(_OWORD *)md = 0u;
  v17 = 0u;
  if (a1 && a2)
  {
    ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a2, 0x8000100u, 0);
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
    if (!Mutable)
    {
      *(_OWORD *)bytes = 0u;
      v19 = 0u;
      v2 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
      if (!ExternalRepresentation)
        return v2;
      goto LABEL_5;
    }
    v7 = Mutable;
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    v9 = CFDataGetBytePtr(a1);
    CFDataAppendBytes(v7, v9, 6);
    Length = CFDataGetLength(ExternalRepresentation);
    CFDataAppendBytes(v7, BytePtr, Length);
    v11 = CFDataGetLength(ExternalRepresentation);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    *(_QWORD *)&v15.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v15.wbuf[6] = v13;
    *(_OWORD *)&v15.wbuf[10] = v13;
    *(_OWORD *)&v15.hash[6] = v13;
    *(_OWORD *)&v15.wbuf[2] = v13;
    *(_OWORD *)v15.count = v13;
    *(_OWORD *)&v15.hash[2] = v13;
    CC_SHA256_Init(&v15);
    CC_SHA256_Update(&v15, MutableBytePtr, v11 + 6);
    CC_SHA256_Final(md, &v15);
    *(_OWORD *)bytes = *(_OWORD *)md;
    v19 = v17;
    v2 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
    CFRelease(v7);
    if (ExternalRepresentation)
LABEL_5:
      CFRelease(ExternalRepresentation);
  }
  return v2;
}

uint64_t sub_1000CEBA4(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    return !sub_10002DAB4(result)
        && CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 16), CFSTR("WEP")) != kCFBooleanTrue
        && !sub_10003145C(v1)
        && !sub_10002DAF0(v1)
        && !sub_10002CFA8(*(const __CFDictionary **)(v1 + 16))
        && sub_10002CD50(*(const __CFDictionary **)(v1 + 16)) == 0;
  }
  return result;
}

uint64_t sub_1000CEC2C(uint64_t a1)
{
  if (a1)
    return sub_100007828(a1) ^ 1;
  else
    return 1;
}

BOOL sub_1000CEC50(CFDictionaryRef *a1)
{
  void *v2;
  id v3;
  unsigned int v4;
  unsigned __int8 v5;
  BOOL v6;
  _BOOL8 result;
  char v8;

  v2 = sub_100026664(a1);
  v3 = sub_100027D10((uint64_t)a1);
  if (objc_msgSend(v2, "isAllowedInLockdownMode"))
    v4 = objc_msgSend(v3, "isAllowedInLockdownMode") ^ 1;
  else
    LOBYTE(v4) = 1;
  v5 = objc_msgSend(v2, "supportedSecurityTypes");
  if (v2)
    CFRelease(v2);
  if (v3)
    CFRelease(v3);
  v6 = sub_10000BE8C((uint64_t)a1) == 0;
  result = v6;
  if (v6)
    v8 = v4;
  else
    v8 = 1;
  if ((v8 & 1) == 0)
    return sub_100013840((uint64_t)a1)
        || sub_10002DA5C((_BOOL8)a1)
        || sub_1000137D8((uint64_t)a1)
        || sub_100013900((uint64_t)a1)
        || a1 && CFDictionaryGetValue(a1[2], CFSTR("DomainName"))
        || sub_1000CB154((uint64_t)a1)
        || sub_1000CB480((uint64_t)a1)
        || a1 && sub_10002BE64((uint64_t)a1, CFSTR("WalletIdentifier"))
        || sub_100007828((uint64_t)a1)
        || sub_10001395C((uint64_t)a1)
        || ((unint64_t)sub_1000CFC28((uint64_t)a1) | v5 & 4 | v5 & 8) != 0;
  return result;
}

BOOL sub_1000CEDAC(uint64_t a1)
{
  return sub_1000CFC28(a1) != 0;
}

uint64_t sub_1000CEDC8(uint64_t a1, __int32 *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  _BOOL4 v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int8x8_t v18;
  int8x8_t v19;
  int8x8_t v20;
  int8x8_t v21;
  int8x8_t v22;
  int8x8_t v23;
  int8x8_t v24;
  int8x8_t v25;
  int8x8_t v26;
  __int32 v27;
  int8x8_t v28;
  int8x8_t v29;
  int8x8_t v30;
  __int32 v31;
  uint64_t v32;
  unsigned int v34;
  int8x8_t v35;

  v4 = *(const __CFDictionary **)(a1 + 16);
  if (v4)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("RSN_IE"));
    v6 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("WPA_IE"));
    if (Value)
    {
      v7 = sub_10002D11C(Value, 2) != 0;
      v8 = sub_10002D11C(Value, 1);
      if (v8)
        v9 = (8 * v7) | 4;
      else
        v9 = 8 * v7;
      v35.i32[0] = v9;
      v35.i32[1] = v8 | (2 * v7);
      v34 = sub_10002D11C(Value, 3) == 0;
      v10 = sub_10002D11C(Value, 4) == 0;
      v11 = sub_10002D11C(Value, 5) == 0;
      v12 = sub_10002D11C(Value, 6) == 0;
      v13 = sub_10002D11C(Value, 8) == 0;
      v14 = sub_10002D11C(Value, 9) == 0;
      v15 = sub_10002D11C(Value, 24) == 0;
      v16 = sub_10002D11C(Value, 25) == 0;
      v17 = sub_10002D11C(Value, 12) == 0;
      v18 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v34), 0x1FuLL)), v35, vorr_s8(v35, (int8x8_t)0x400000080));
      v19 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v10), 0x1FuLL)), v18, vorr_s8(v18, (int8x8_t)0x800000010));
      v20 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v11), 0x1FuLL)), v19, vorr_s8(v19, (int8x8_t)0x1000000800));
      v21 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v12), 0x1FuLL)), v20, vorr_s8(v20, (int8x8_t)0x2000000400));
      v22 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v13), 0x1FuLL)), v21, vorr_s8(v21, (int8x8_t)0x8000001000));
      v23 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v14), 0x1FuLL)), v22, vorr_s8(v22, (int8x8_t)0x10000002000));
      v24 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v15), 0x1FuLL)), v23, vorr_s8(v23, (int8x8_t)0x80000000010000));
      v25 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v16), 0x1FuLL)), v24, vorr_s8(v24, (int8x8_t)0x100000000020000));
      v26 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v17), 0x1FuLL)), v25, vorr_s8(v25, (int8x8_t)0x80000004000));
      v27 = sub_10002D11C(Value, 13);
      v28.i32[0] = 0;
      v29.i32[0] = v27;
      v30 = vbsl_s8(vdup_lane_s8(vceq_s8(v29, v28), 0), v26, vorr_s8(v26, (int8x8_t)0x100000008000));
    }
    else
    {
      v30 = 0;
    }
    v32 = v30.u32[0];
    v31 = v30.i32[1];
    if (v6)
    {
      if (sub_10002D11C(v6, 2))
        LODWORD(v32) = v32 | 2;
      v32 = v32 | sub_10002D11C(v6, 1);
    }
  }
  else
  {
    v31 = 0;
    v32 = 0xFFFFLL;
  }
  if (a2)
    *a2 = v31;
  return v32;
}

uint64_t sub_1000CF0CC(const void *a1)
{
  unint64_t v2;
  char *v3;
  const __CFData *v4;
  const __CFData *v5;
  const void *v6;
  uint64_t v7;
  UInt8 buffer[8];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  const void *v13;
  __int16 v14;
  const __CFData *v15;
  CFRange v16;

  if (!a1)
    return 0;
  v2 = 0;
  v3 = &byte_1001BBA50;
  do
  {
    v4 = sub_1000C4110((uint64_t)a1);
    if (v4)
    {
      v5 = v4;
      memset(buffer, 170, 6);
      v16.location = 0;
      v16.length = 6;
      CFDataGetBytes(v4, v16, buffer);
      if (buffer[0] == *(v3 - 2)
        && buffer[1] == *(v3 - 1)
        && buffer[2] == *v3)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v6 = sub_10002B088(a1);
          *(_DWORD *)buf = 136315650;
          v11 = "WiFiNetworkIsProblematicForEncryptedDNS";
          v12 = 2112;
          v13 = v6;
          v14 = 2112;
          v15 = v5;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: network %@ (%@) is known to be problematic for DoT/DoH", buf, 0x20u);
        }
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
      CFRelease(v5);
    }
    else
    {
      v7 = 0;
    }
    if (v2 > 1)
      break;
    ++v2;
    v3 += 3;
  }
  while (!(_DWORD)v7);
  return v7;
}

void sub_1000CF264(uint64_t a1, const void *a2)
{
  const __CFArray *v4;
  const __CFArray *MutableCopy;
  void *v6;
  __CFArray *v7;
  CFRange v8;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkAddSIMIdentifier");
    goto LABEL_9;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null simId", "WiFiNetworkAddSIMIdentifier");
LABEL_9:
    objc_autoreleasePoolPop(v6);
    return;
  }
  v4 = (const __CFArray *)sub_10002BE64(a1, CFSTR("SIMIdentifiers"));
  if (v4)
    MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v4);
  else
    MutableCopy = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v7 = MutableCopy;
  v8.length = CFArrayGetCount(MutableCopy);
  v8.location = 0;
  if (CFArrayGetFirstIndexOfValue(v7, v8, a2) == -1)
    CFArrayAppendValue(v7, a2);
  sub_10002C478(a1, CFSTR("SIMIdentifiers"), v7);
  if (v7)
    CFRelease(v7);
}

void sub_1000CF3B8(uint64_t a1, const void *a2)
{
  const __CFArray *v4;
  const __CFArray *MutableCopy;
  void *v6;
  const __CFArray *v7;
  CFIndex FirstIndexOfValue;
  const __CFArray *v9;
  CFRange v10;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkRemoveSIMIdentifier");
    goto LABEL_9;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null simId", "WiFiNetworkRemoveSIMIdentifier");
LABEL_9:
    objc_autoreleasePoolPop(v6);
    return;
  }
  v4 = (const __CFArray *)sub_10002BE64(a1, CFSTR("SIMIdentifiers"));
  if (v4)
    MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v4);
  else
    MutableCopy = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v7 = MutableCopy;
  v10.length = CFArrayGetCount(MutableCopy);
  v10.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v7, v10, a2);
  if (FirstIndexOfValue != -1)
    CFArrayRemoveValueAtIndex(v7, FirstIndexOfValue);
  if (CFArrayGetCount(v7))
    v9 = v7;
  else
    v9 = 0;
  sub_10002C478(a1, CFSTR("SIMIdentifiers"), v9);
  if (v7)
    CFRelease(v7);
}

void sub_1000CF518(uint64_t a1, CFDictionaryRef *a2, const void *a3)
{
  const void *v6;
  const void *v7;
  const __CFDictionary *v8;
  __CFDictionary *v9;
  const void *v10;
  const void *v11;
  const __CFDictionary *v12;
  __CFDictionary *v13;
  const __CFDictionary *v14;
  CFIndex Count;
  __CFString *v16;
  uint64_t v17;
  const __CFDictionary *v18;
  CFIndex v19;

  if (a1 && a2)
  {
    if (CFDictionaryGetValue(a2[2], CFSTR("DomainName")))
    {
      v6 = sub_1000C9A4C((uint64_t)a2);
      if (v6)
      {
        v7 = v6;
        v8 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("userPreferredPasspointDomains"));
        v9 = v8
           ? CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v8)
           : CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v14 = v9;
        if (v9)
        {
          if (a3)
            CFDictionaryAddValue(v9, v7, a3);
          else
            CFDictionaryRemoveValue(v9, v7);
          Count = CFDictionaryGetCount(v14);
          v16 = CFSTR("userPreferredPasspointDomains");
          if (Count)
          {
LABEL_16:
            v17 = a1;
            v18 = v14;
LABEL_25:
            sub_10002C478(v17, v16, v18);
            CFRelease(v14);
            return;
          }
LABEL_24:
          v17 = a1;
          v18 = 0;
          goto LABEL_25;
        }
      }
    }
    else
    {
      v10 = sub_10002B088(a2);
      if (v10)
      {
        v11 = v10;
        v12 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("userPreferredNetworkNames"));
        v13 = v12
            ? CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v12)
            : CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v14 = v13;
        if (v13)
        {
          if (a3)
            CFDictionarySetValue(v13, v11, a3);
          else
            CFDictionaryRemoveValue(v13, v11);
          v19 = CFDictionaryGetCount(v14);
          v16 = CFSTR("userPreferredNetworkNames");
          if (v19)
            goto LABEL_16;
          goto LABEL_24;
        }
      }
    }
  }
}

const void *sub_1000CF6B0(uint64_t a1, CFDictionaryRef *a2)
{
  const void *v4;
  const void *v5;
  __CFString *v6;
  const void *v7;
  const __CFDictionary *v8;

  if (!a1 || !a2)
    return 0;
  if (CFDictionaryGetValue(a2[2], CFSTR("DomainName")))
  {
    v4 = sub_1000C9A4C((uint64_t)a2);
    if (!v4)
      return 0;
    v5 = v4;
    v6 = CFSTR("userPreferredPasspointDomains");
  }
  else
  {
    v7 = sub_10002B088(a2);
    if (!v7)
      return 0;
    v5 = v7;
    v6 = CFSTR("userPreferredNetworkNames");
  }
  v8 = (const __CFDictionary *)sub_10002BE64(a1, v6);
  if (v8)
    return CFDictionaryGetValue(v8, v5);
  return 0;
}

void sub_1000CF744(uint64_t a1, int a2)
{
  const void **v2;
  void *v3;

  if (a1)
  {
    v2 = (const void **)&kCFBooleanTrue;
    if (!a2)
      v2 = (const void **)&kCFBooleanFalse;
    sub_10002C478(a1, CFSTR("PrivacyProxyEnabled"), *v2);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetPrivacyProxyEnabled");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000CF7DC(uint64_t a1, const void *a2)
{
  void *v2;

  if (a1)
  {
    sub_10002C478(a1, CFSTR("PrivacyProxyBlockedReason"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetPrivacyProxyBlockedReason");
    objc_autoreleasePoolPop(v2);
  }
}

BOOL sub_1000CF858(uint64_t a1)
{
  CFAbsoluteTime Current;
  const __CFDate *v3;
  const __CFDate *v4;
  double TimeIntervalSinceDate;
  _BOOL8 v6;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(kCFAllocatorDefault, Current);
  v4 = (const __CFDate *)sub_10002BE64(a1, CFSTR("lastJoined"));
  TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v3, v4);
  if (sub_1000CBE60(a1) == 1
    || sub_1000C3F88(a1) == 1
    || (!&_CNForgetSSID
     || CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) != kCFBooleanTrue)
    && !sub_10002BE64(a1, CFSTR("WiFiNetworkAttributeIsPublic"))
    && !sub_1000CB480(a1))
  {
    v6 = 1;
    if (!v3)
      return v6;
LABEL_4:
    CFRelease(v3);
    return v6;
  }
  v6 = TimeIntervalSinceDate < 86400.0 && TimeIntervalSinceDate > -1.0;
  if (v3)
    goto LABEL_4;
  return v6;
}

BOOL sub_1000CF968(uint64_t a1)
{
  return !_os_feature_enabled_impl("WiFiManager", "SlowWiFiDPSTuning") || sub_1000CF858(a1);
}

uint64_t sub_1000CF9B0(CFDictionaryRef *a1)
{
  uint64_t result;

  if (sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsPublic")))
    return 1;
  result = (uint64_t)sub_1000CB87C(a1);
  if ((_DWORD)result)
    return 1;
  return result;
}

BOOL sub_1000CF9F0(uint64_t a1)
{
  return sub_10002BE64(a1, CFSTR("WiFiNetworkAttributeIsLowQuality")) != 0;
}

void sub_1000CFA18(uint64_t a1, int a2)
{
  const void **v2;
  void *v3;

  if (a1)
  {
    v2 = (const void **)&kCFBooleanTrue;
    if (!a2)
      v2 = (const void **)&kCFBooleanFalse;
    sub_10002C478(a1, CFSTR("PublicAirPlayNetwork"), *v2);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetPublicAirPlayNetwork");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000CFAB0(uint64_t a1, const void *a2)
{
  void *v2;

  if (a1)
  {
    sub_10002C478(a1, CFSTR("DisplayFriendlyName"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetDisplayFriendlyName");
    objc_autoreleasePoolPop(v2);
  }
}

const void *sub_1000CFB2C(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("DisplayFriendlyName"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetDisplayFriendlyName");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000CFBAC(uint64_t a1, const void *a2)
{
  void *v2;

  if (a1)
  {
    sub_10002C478(a1, CFSTR("AccessoryIdentifier"), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetAccessoryIdentifier");
    objc_autoreleasePoolPop(v2);
  }
}

const void *sub_1000CFC28(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("AccessoryIdentifier"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetAccessoryIdentifier");
  objc_autoreleasePoolPop(v2);
  return 0;
}

BOOL sub_1000CFCA8(uint64_t a1)
{
  return sub_1000CFC28(a1) == 0;
}

CFHashCode sub_1000CFCC4(const void *a1)
{
  const void *v1;

  if (a1 && (v1 = sub_10002B088(a1)) != 0)
    return CFHash(v1);
  else
    return 0;
}

CFStringRef sub_1000CFCE8(const __CFDictionary **cf)
{
  uint64_t v2;
  const __CFNumber *v3;
  const void *v4;
  const void *v5;
  unsigned int v6;
  const __CFString *v7;
  const __CFString *v8;
  unsigned int v9;
  const void *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _BOOL4 v15;
  const void *v17;
  const void *v18;
  uint64_t v19;
  const __CFNumber *v20;
  _BOOL8 v21;
  _BOOL8 v22;
  unsigned int v23;
  _BOOL4 v24;
  unsigned int v25;
  const void *v26;
  _DWORD valuePtr[3];

  valuePtr[0] = 0;
  if (!cf)
    return CFSTR("Invalid network ref");
  v2 = qword_10026D6C8;
  if (!qword_10026D6C8)
  {
    pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
    v2 = qword_10026D6C8;
  }
  if (v2 != CFGetTypeID(cf))
    return CFSTR("Invalid network ref");
  v3 = (const __CFNumber *)sub_1000316E0((uint64_t)cf);
  if (v3)
    CFNumberGetValue(v3, kCFNumberSInt32Type, valuePtr);
  v26 = sub_10002B088(cf);
  v25 = sub_100031670(cf);
  v24 = sub_10002DAB4((uint64_t)cf);
  v23 = sub_10002CFA8(cf[2]);
  v22 = sub_10003145C((uint64_t)cf) != 0;
  v21 = CFDictionaryGetValue(cf[2], CFSTR("WEP")) == kCFBooleanTrue;
  v20 = sub_10002DB40(cf[2]);
  v19 = sub_1000CA608((uint64_t)cf);
  v18 = sub_10002BE64((uint64_t)cf, CFSTR("enabled"));
  v17 = sub_10002BE64((uint64_t)cf, CFSTR("SaveDataMode"));
  v4 = sub_10002BE64((uint64_t)cf, CFSTR("NetworkQualityResponsiveness"));
  v5 = sub_10002BE64((uint64_t)cf, CFSTR("NetworkQualityDate"));
  v6 = sub_1000C3F88((uint64_t)cf);
  v7 = CFSTR("Unknown");
  if (v6 == 1)
    v7 = CFSTR("Home");
  if (v6 == 2)
    v8 = CFSTR("Not Home");
  else
    v8 = v7;
  v9 = sub_1000C9410((uint64_t)cf);
  v10 = sub_10002BE64((uint64_t)cf, CFSTR("TransitionDisabledFlags"));
  v11 = sub_1000C4AA0((uint64_t)cf);
  v12 = sub_10001395C((uint64_t)cf);
  v13 = sub_100007828((uint64_t)cf);
  v14 = sub_10002DB7C((uint64_t)cf);
  v15 = sub_10002DA5C((_BOOL8)cf);
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@: isHidden=%d, isEAP=%d, isSAE=%d, isWPA=%d, isWEP=%d, WAPI=%d, type=%d, enabled=%@, saveData=%@, responsiveness=%@ (%@) isHome=%@, isForceFixed=%d, transitionDisabledFlags=%@, foundNanIe=%d, isPH=%d, isPublicAirPlayNetwork=%d, is6EDisabled=%d, hs20=%d, Channel=%d"), v26, v25, v24, v23, v22, v21, v20, v19, v18, v17, v4, v5, v8, v9, v10, v11,
           v12,
           v13,
           v14,
           v15,
           valuePtr[0]);
}

uint64_t sub_1000CFFA4(const void *a1, const void *a2, unsigned int a3)
{
  uint64_t v3;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  uint64_t v16;

  v3 = 0;
  if (a1 && a2)
  {
    if (sub_10002DA5C((_BOOL8)a1) && sub_10002DA5C((_BOOL8)a2))
    {
      v7 = (const __CFString *)sub_10002B088(a1);
      v8 = (const __CFString *)sub_10002B088(a2);
      v9 = (const __CFString *)sub_10002BE64((uint64_t)a1, CFSTR("HS20AccountName"));
      v10 = (const __CFString *)sub_10002BE64((uint64_t)a2, CFSTR("HS20AccountName"));
      v11 = (const __CFString *)sub_1000C9A4C((uint64_t)a1);
      v12 = (const __CFString *)sub_1000C9A4C((uint64_t)a2);
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS20 - ssid1: %@, account1: %@, domain1: %@; ssid2: %@, account2: %@, domain2: %@, GAS check: %d",
          "__WiFiIsSameHS20Account",
          v7,
          v9,
          v11,
          v8,
          v10,
          v12,
          a3);
      objc_autoreleasePoolPop(v13);
      if (v7 && v10 && CFStringCompare(v7, v10, 0) == kCFCompareEqualTo
        || v8 && v9 && CFStringCompare(v8, v9, 0) == kCFCompareEqualTo)
      {
        return 1;
      }
      if (v9 && v10 && v11 && v12 && CFStringCompare(v11, v12, 0) == kCFCompareEqualTo)
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found matching domain %@ on two accounts. Accounts are %@ and %@", "__WiFiIsSameHS20Account", v11, v9, v10, v16);
        goto LABEL_23;
      }
      if (!a3)
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Skip GAS content check for domainName %@ and domainName %@", "__WiFiIsSameHS20Account", v11, v12);
        v3 = 0;
        goto LABEL_29;
      }
      if (sub_1000C9B20(a1, a2) || sub_1000C9B20(a2, a1))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS20 - found matching attribute in GAS response - ssid1: %@, account1 %@; ssid2: %@, account: %@",
            "__WiFiIsSameHS20Account",
            v7,
            v9,
            v8,
            v10);
LABEL_23:
        v3 = 1;
LABEL_29:
        objc_autoreleasePoolPop(v14);
        return v3;
      }
    }
    return 0;
  }
  return v3;
}

Class sub_1000D0204(uint64_t a1)
{
  Class result;

  sub_1000D0258();
  result = objc_getClass("CWFNetworkProfile");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    sub_1001872C4();
  qword_10026D6E0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t sub_1000D0258()
{
  uint64_t v0;
  void *v2;
  __int128 v3;
  uint64_t v4;

  v2 = 0;
  if (!qword_10026D6E8)
  {
    v3 = off_1002311E0;
    v4 = 0;
    qword_10026D6E8 = _sl_dlopen(&v3, &v2);
  }
  v0 = qword_10026D6E8;
  if (!qword_10026D6E8)
    sub_100187328(&v2);
  if (v2)
    free(v2);
  return v0;
}

Class sub_1000D0300(uint64_t a1)
{
  Class result;

  sub_1000D0258();
  result = objc_getClass("CWFBSS");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    sub_10018738C();
  qword_10026D6F0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class sub_1000D0354(uint64_t a1)
{
  Class result;

  sub_1000D0258();
  result = objc_getClass("CWFChannel");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    sub_1001873F0();
  qword_10026D6F8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class sub_1000D03A8(uint64_t a1)
{
  Class result;

  sub_1000D03FC();
  result = objc_getClass("CLLocation");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    sub_100187454();
  qword_10026D700 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t sub_1000D03FC()
{
  uint64_t v0;
  void *v2;
  __int128 v3;
  uint64_t v4;

  v2 = 0;
  if (!qword_10026D708)
  {
    v3 = off_1002311F8;
    v4 = 0;
    qword_10026D708 = _sl_dlopen(&v3, &v2);
  }
  v0 = qword_10026D708;
  if (!qword_10026D708)
    sub_1001874B8(&v2);
  if (v2)
    free(v2);
  return v0;
}

Class sub_1000D04A4(uint64_t a1)
{
  Class result;

  sub_1000D0258();
  result = objc_getClass("CWFScanResult");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    sub_10018751C();
  qword_10026D718 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void sub_1000D26E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000D26F8(uint64_t a1)
{
  id v2;
  NSObject *v3;
  uint64_t v4;
  id v5;
  _QWORD block[4];
  id v7;
  uint64_t v8;

  v2 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v3 = qword_10026D728;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D2788;
  block[3] = &unk_100231218;
  v4 = *(_QWORD *)(a1 + 32);
  v7 = v2;
  v8 = v4;
  v5 = v2;
  dispatch_sync(v3, block);

}

id sub_1000D2788(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_updateNetworkOnManagerQueue:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));
}

uint64_t sub_1000D4858(uint64_t a1)
{
  return ((uint64_t (*)(id, _QWORD))objc_msgSend(*(id *)(a1 + 32), "AVSystemMonitorCb"))(objc_msgSend(*(id *)(a1 + 32), "manager"), *(_QWORD *)(a1 + 40));
}

WiFiManagerAVSystemMonitor *sub_1000D4BD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  WiFiManagerAVSystemMonitor *v7;
  WiFiManagerAVSystemMonitor *v8;
  void *v9;
  _QWORD block[5];

  v6 = objc_autoreleasePoolPush();
  if (!objc_opt_class(AVSystemController))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AVSystemMonitor class is not valid.", "WiFiManagerAVSystemMonitorStart");
    goto LABEL_8;
  }
  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerAVSystemMonitorStart");
    goto LABEL_8;
  }
  if (!a3)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null AVSystemMonitorCb", "WiFiManagerAVSystemMonitorStart");
    goto LABEL_8;
  }
  v7 = objc_alloc_init(WiFiManagerAVSystemMonitor);
  if (!v7)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AVSystemMonitor allocation failed!", "WiFiManagerAVSystemMonitorStart");
LABEL_8:
    objc_autoreleasePoolPop(v9);
    v8 = 0;
    goto LABEL_9;
  }
  v8 = v7;
  -[WiFiManagerAVSystemMonitor setManager:](v7, "setManager:", a1);
  -[WiFiManagerAVSystemMonitor setAVSystemMonitorCb:](v8, "setAVSystemMonitorCb:", a3);
  -[WiFiManagerAVSystemMonitor setQueue:](v8, "setQueue:", a2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D4D84;
  block[3] = &unk_10022EEE8;
  block[4] = v8;
  dispatch_async((dispatch_queue_t)qword_10026DD40, block);
LABEL_9:
  objc_autoreleasePoolPop(v6);
  return v8;
}

id sub_1000D4D84(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "startMonitoringAVSystem");
}

void sub_1000D4D8C(void *a1)
{
  void *v2;
  void *v3;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    objc_msgSend(a1, "stopMonitoringAVSystem");

  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null AVSystemMonitor", "WiFiManagerAVSystemMonitorStop");
    objc_autoreleasePoolPop(v3);
  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1000D4E0C()
{
  uint64_t result;

  result = qword_10026D738;
  if (!qword_10026D738)
  {
    pthread_once(&stru_10026CC70, (void (*)(void))sub_1000D4E48);
    return qword_10026D738;
  }
  return result;
}

uint64_t sub_1000D4E48()
{
  qword_10026D738 = _CFRuntimeRegisterClass(&unk_100231240);
  qword_10026D740 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  return pthread_mutex_init(&stru_10026CC80, 0);
}

uint64_t sub_1000D4E9C(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  const __CFString *v6;
  const __CFString *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v12;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  if (sub_10015B920())
  {
    v6 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_ASK_TO_JOIN_TITLE"));
    v7 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_ASK_TO_JOIN_CANCEL_BUTTON"));
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateAskToJoin");
    objc_autoreleasePoolPop(v8);
    v7 = CFSTR("Cancel");
    v6 = CFSTR("Select a Wireless Network");
  }
  CFDictionarySetValue(v5, kCFUserNotificationAlertHeaderKey, v6);
  CFDictionarySetValue(v5, kCFUserNotificationDefaultButtonTitleKey, v7);
  CFDictionarySetValue(v5, SBUserNotificationExtensionIdentifierKey, CFSTR("com.apple.framework.WiFiKit.WiFiPickerExtension"));
  v9 = sub_1000D503C(a1, 0, 0, a2, v5, 0, 0);
  if (!v9)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification of type ask to join", "WiFiNotificationCreateAskToJoin");
    objc_autoreleasePoolPop(v12);
    return 0;
  }
  v10 = v9;
  CFRelease(v5);
  return v10;
}

uint64_t sub_1000D503C(uint64_t a1, int a2, int a3, const void *a4, __CFDictionary *a5, CFOptionFlags a6, const void *a7)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  __CFBundle *BundleWithIdentifier;
  CFURLRef v14;
  CFURLRef v15;
  void *v16;
  id v17;
  id v18;
  NSData *v19;
  void *v20;
  CFUserNotificationRef v21;
  CFUserNotificationRef v22;
  CFRunLoopSourceRef RunLoopSource;
  uint64_t v25;
  SInt32 error;
  id v27;

  if (!a5)
    return 0;
  do
  {
    v10 = __ldxr((unsigned int *)&unk_10026CCC0);
    v11 = v10 + 1;
  }
  while (__stxr(v11, (unsigned int *)&unk_10026CCC0));
  v12 = sub_1000D55B4(a1, a2, a3, a4, a7, v11);
  if (v12)
  {
    error = -1431655766;
    BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.wifi.manager"));
    if (BundleWithIdentifier)
    {
      v14 = CFBundleCopyBundleURL(BundleWithIdentifier);
      if (v14)
      {
        v15 = v14;
        CFDictionarySetValue(a5, kCFUserNotificationLocalizationURLKey, v14);
        CFRelease(v15);
      }
    }
    if (SBUserNotificationDismissOnLock)
    {
      CFDictionarySetValue(a5, SBUserNotificationDismissOnLock, kCFBooleanTrue);
      CFDictionarySetValue(a5, SBUserNotificationAlertMessageDelimiterKey, &stru_100238178);
    }
    if (a2)
      goto LABEL_19;
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: adding extensionItem for ask to join notification (id: %d)", "__WiFiNotificationCreateCFUN", v11);
    objc_autoreleasePoolPop(v16);
    v17 = objc_alloc_init((Class)NSExtensionItem);
    v18 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithObjectsAndKeys:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11), CFSTR("notificationId"), 0);
    objc_msgSend(v17, "setUserInfo:", v18);
    v25 = 0;
    v27 = v17;
    v19 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:](NSKeyedArchiver, "archivedDataWithRootObject:requiringSecureCoding:error:", +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v27, 1), 1, &v25);
    if (v25)
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error archiving extensionItem %@", "__WiFiNotificationCreateCFUN", v25);
      objc_autoreleasePoolPop(v20);
      if (!v17)
        goto LABEL_17;
    }
    else
    {
      CFDictionarySetValue(a5, SBUserNotificationExtensionItemsKey, v19);
      if (!v17)
      {
LABEL_17:
        if (v18)
          CFRelease(v18);
LABEL_19:
        v21 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, a6, &error, a5);
        *(_QWORD *)(v12 + 120) = v21;
        if (v21)
        {
          v22 = v21;
          pthread_mutex_lock(&stru_10026CC80);
          CFDictionarySetValue((CFMutableDictionaryRef)qword_10026D740, v22, (const void *)v12);
          pthread_mutex_unlock(&stru_10026CC80);
          RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, *(CFUserNotificationRef *)(v12 + 120), (CFUserNotificationCallBack)sub_1000D7728, 0);
          *(_QWORD *)(v12 + 56) = RunLoopSource;
          if (RunLoopSource)
            return v12;
        }
        CFRelease((CFTypeRef)v12);
        return 0;
      }
    }
    CFRelease(v17);
    goto LABEL_17;
  }
  return v12;
}

uint64_t sub_1000D5334(uint64_t a1, const void *a2, int a3, const void *a4, CFDictionaryRef theDict, int a6)
{
  uint64_t v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  const __CFString *v14;
  const void *v15;
  CFStringRef v16;
  id v17;
  id v18;
  id v19;
  unsigned int v20;
  void *v21;
  void *v23;

  v6 = 0;
  if (!a4 || !theDict)
    return v6;
  if (!CFDictionaryGetValue(theDict, CFSTR("TLSServerCertificateChain")))
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: server certificate chain is null", "WiFiNotificationCreateEAPTrust");
    objc_autoreleasePoolPop(v23);
    return 0;
  }
  if (a6 != 2)
  {
    do
      v20 = __ldxr((unsigned int *)&unk_10026CCC0);
    while (__stxr(v20 + 1, (unsigned int *)&unk_10026CCC0));
    v6 = sub_1000D55B4(a1, 2, a6, a2, theDict, v20 + 1);
    if (!v6)
      return v6;
    goto LABEL_12;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v13 = Mutable;
  v14 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_OPEN_SETTINGS_CERTIFICATE_TITLE"));
  v15 = sub_10002B088(a4);
  v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v14, v15);
  CFDictionarySetValue(v13, kCFUserNotificationAlertHeaderKey, v16);
  if (v16)
    CFRelease(v16);
  v17 = sub_10015B934((uint64_t)CFSTR("WIFI_OPEN_SETTINGS_CERTIFICATE_ACCEPT_BUTTON"));
  CFDictionarySetValue(v13, kCFUserNotificationDefaultButtonTitleKey, v17);
  v18 = sub_10015B934((uint64_t)CFSTR("WIFI_OPEN_SETTINGS_CERTIFICATE_VIEW_BUTTON"));
  CFDictionarySetValue(v13, kCFUserNotificationAlternateButtonTitleKey, v18);
  v19 = sub_10015B934((uint64_t)CFSTR("WIFI_CANCEL"));
  CFDictionarySetValue(v13, kCFUserNotificationOtherButtonTitleKey, v19);
  v6 = sub_1000D503C(a1, 2, 2, a2, v13, 0, 0);
  CFRelease(v13);
  if (v6)
  {
    *(_QWORD *)(v6 + 24) = CFRetain(a4);
    *(_QWORD *)(v6 + 112) = CFRetain(theDict);
LABEL_12:
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching EAP Trust panel(%d)", *(unsigned int *)(v6 + 40));
    objc_autoreleasePoolPop(v21);
    *(_QWORD *)(v6 + 24) = CFRetain(a4);
  }
  return v6;
}

uint64_t sub_1000D55B4(uint64_t a1, int a2, int a3, const void *a4, const void *a5, int a6)
{
  uint64_t Instance;
  uint64_t v13;

  if (!qword_10026D738)
    pthread_once(&stru_10026CC70, (void (*)(void))sub_1000D4E48);
  Instance = _CFRuntimeCreateInstance(a1);
  v13 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_DWORD *)(Instance + 32) = a2;
    *(_DWORD *)(Instance + 36) = a3;
    *(_DWORD *)(Instance + 40) = a6;
    if (a4)
      *(_QWORD *)(Instance + 16) = CFRetain(a4);
    if (a5)
      *(_QWORD *)(v13 + 112) = CFRetain(a5);
  }
  return v13;
}

uint64_t sub_1000D567C(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef *a4, int a5)
{
  CFStringRef v9;
  CFStringRef v10;
  void *v11;
  int v12;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v14;
  _BOOL4 v15;
  void *v16;
  int v17;
  unsigned int v18;
  const __CFString *v19;
  int v20;
  BOOL v21;
  const __CFString *v22;
  uint64_t v23;
  id v24;
  const __CFString *v25;
  int v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  _BOOL4 v31;
  const void *v32;
  CFStringRef v33;
  uint64_t v34;
  const __CFString *v35;
  const void *v36;
  CFStringRef v37;
  id v38;
  id v39;
  const void *v40;
  CFStringRef v41;
  CFStringRef v42;
  CFMutableArrayRef v43;
  __CFArray *v44;
  id v45;
  id v46;
  CFStringRef v47;
  const void *v48;
  uint64_t v49;
  _BOOL4 v50;
  __CFArray *v51;
  __CFArray *v52;
  id v53;
  const __CFString *v54;
  CFMutableArrayRef v55;
  __CFArray *v56;
  const __CFString *v57;
  const __CFString *v58;
  char v59;
  CFOptionFlags v60;
  __CFDictionary *v61;
  uint64_t v62;
  void *v63;
  const char *v64;
  int v66;
  const void *v67;

  if (!a4 || !sub_1000C5964((uint64_t)a4))
    return 0;
  v9 = sub_1000C37A0(a4);
  if (v9)
    goto LABEL_8;
  v10 = sub_1000C64A8(a4);
  if (v10)
  {
    v9 = v10;
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: found password with non-syncable attribute for network %@.", "WiFiNotificationCreatePassword", sub_10002B088(a4));
    objc_autoreleasePoolPop(v11);
LABEL_8:
    CFRelease(v9);
    v12 = 0;
    goto LABEL_9;
  }
  v12 = 1;
LABEL_9:
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v14 = Mutable;
  v15 = sub_10015B920();
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localizationAvailable=%d", "WiFiNotificationCreatePassword", v15);
  objc_autoreleasePoolPop(v16);
  if (!v15)
  {
    if (a5 == 2)
    {
      v31 = sub_1000C5AD0((uint64_t)a4);
      v32 = sub_10002B088(a4);
      if (v31)
        v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Incorrect Wi-Fi Credentials for “%@”"), v32);
      else
        v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Incorrect Wi-Fi Password for “%@”"), v32);
      v47 = v33;
      CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v33);
      if (v47)
        CFRelease(v47);
      if (sub_1000C5AD0((uint64_t)a4))
        v28 = CFSTR("Enter Credentials");
      else
        v28 = CFSTR("Enter Password");
    }
    else
    {
      if (a5 != 1)
      {
LABEL_58:
        CFDictionarySetValue(v14, kCFUserNotificationAlternateButtonTitleKey, CFSTR("Cancel"));
        v48 = sub_10002B088(a4);
        v44 = (__CFArray *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Enter the password for %@."), v48);
        v42 = 0;
        if (v44)
          goto LABEL_59;
        v62 = 0;
LABEL_82:
        CFRelease(v14);
        return v62;
      }
      if (sub_1000C5BD8(a4))
        v26 = 1;
      else
        v26 = v12;
      if (v26)
        v27 = CFSTR("Wi-Fi Password");
      else
        v27 = CFSTR("Incorrect Wi-Fi Password");
      CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v27);
      v28 = CFSTR("Join");
    }
    CFDictionarySetValue(v14, kCFUserNotificationDefaultButtonTitleKey, v28);
    goto LABEL_58;
  }
  v17 = sub_10011CE54(a2);
  if (a5 == 2)
  {
    if (sub_1000C5AD0((uint64_t)a4))
    {
      v29 = CFSTR("WIFI_OPEN_SETTINGS_CREDENTIALS_TITLE");
      v30 = CFSTR("WIFI_OPEN_SETTINGS_CREDENTIALS_TITLE_CH");
    }
    else
    {
      v29 = CFSTR("WIFI_OPEN_SETTINGS_PASSWORD_TITLE");
      v30 = CFSTR("WIFI_OPEN_SETTINGS_PASSWORD_TITLE_CH");
    }
    if (v17)
      v34 = (uint64_t)v30;
    else
      v34 = (uint64_t)v29;
    v35 = (const __CFString *)sub_10015B934(v34);
    v36 = sub_10002B088(a4);
    v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v35, v36);
    CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v37);
    if (v37)
      CFRelease(v37);
    if (sub_1000C5AD0((uint64_t)a4))
      v25 = CFSTR("WIFI_OPEN_SETTINGS_CREDENTIALS_BUTTON");
    else
      v25 = CFSTR("WIFI_OPEN_SETTINGS_PASSWORD_BUTTON");
  }
  else
  {
    if (a5 != 1)
      goto LABEL_48;
    v18 = sub_1000C5BD8(a4);
    v19 = CFSTR("WIFI_PASSWORD_TITLE");
    if (v18)
      v20 = 1;
    else
      v20 = v12;
    v21 = v20 == 0;
    v22 = CFSTR("WIFI_PASSWORD_TITLE_CH");
    if (!v21)
    {
      v19 = CFSTR("WIFI_OTP_PASSWORD_TITLE");
      v22 = CFSTR("WIFI_OTP_PASSWORD_TITLE_CH");
    }
    if (v17)
      v23 = (uint64_t)v22;
    else
      v23 = (uint64_t)v19;
    v24 = sub_10015B934(v23);
    CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v24);
    v25 = CFSTR("WIFI_JOIN");
  }
  v38 = sub_10015B934((uint64_t)v25);
  CFDictionarySetValue(v14, kCFUserNotificationDefaultButtonTitleKey, v38);
LABEL_48:
  v39 = sub_10015B934((uint64_t)CFSTR("WIFI_CANCEL"));
  CFDictionarySetValue(v14, kCFUserNotificationAlternateButtonTitleKey, v39);
  v40 = sub_10002B088(a4);
  v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%c%@%c"), 8, v40, 127);
  if (!v41)
  {
    v62 = 0;
    goto LABEL_82;
  }
  v42 = v41;
  v43 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v43)
  {
    v44 = v43;
    v45 = sub_10015B934((uint64_t)CFSTR("WIFI_PASSWORD_MESSAGE_PREFIX"));
    CFArrayAppendValue(v44, v45);
    CFArrayAppendValue(v44, v42);
    v46 = sub_10015B934((uint64_t)CFSTR("WIFI_PASSWORD_MESSAGE_SUFFIX"));
    CFArrayAppendValue(v44, v46);
LABEL_59:
    v66 = v12;
    v67 = (const void *)a2;
    v49 = a1;
    CFDictionarySetValue(v14, kCFUserNotificationAlertMessageKey, v44);
    CFRelease(v44);
    CFDictionarySetValue(v14, kCFUserNotificationTextFieldTitlesKey, &stru_100238178);
    v50 = sub_1000C5AD0((uint64_t)a4);
    if (a5 == 1 && v50)
    {
      v51 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      v52 = v51;
      if (!v51
        || (!v15
          ? (CFArrayAppendValue(v51, CFSTR("Username")), v54 = CFSTR("Password"))
          : (v53 = sub_10015B934((uint64_t)CFSTR("WIFI_USERNAME_TEXT_TITLE")),
             CFArrayAppendValue(v52, v53),
             v54 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_PASSWORD_TEXT_TITLE"))),
            CFArrayAppendValue(v52, v54),
            CFDictionarySetValue(v14, kCFUserNotificationTextFieldTitlesKey, v52),
            (v55 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) == 0))
      {
        v62 = 0;
        v61 = 0;
        goto LABEL_77;
      }
      v56 = v55;
      v57 = (const __CFString *)sub_10002BE64((uint64_t)a4, CFSTR("UserName"));
      if (v57)
        v58 = v57;
      else
        v58 = &stru_100238178;
      CFArrayAppendValue(v56, v58);
      CFArrayAppendValue(v56, &stru_100238178);
      CFDictionarySetValue(v14, kCFUserNotificationTextFieldValuesKey, v56);
      v59 = 1;
    }
    else
    {
      v56 = 0;
      v52 = 0;
      v59 = 0;
      v61 = 0;
      v60 = 0;
      if (a5 != 1)
      {
LABEL_71:
        v62 = sub_1000D503C(v49, 1, a5, v67, v14, v60, 0);
        if (v62)
        {
          v63 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v64 = "no";
            if (v66)
              v64 = "yes";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching password panel(%d), missing password=%s", *(unsigned int *)(v62 + 40), v64);
          }
          objc_autoreleasePoolPop(v63);
          *(_QWORD *)(v62 + 24) = CFRetain(a4);
        }
LABEL_77:
        CFRelease(v14);
        v14 = v61;
        if (!v42)
          goto LABEL_79;
        goto LABEL_78;
      }
    }
    v60 = 0x10000 << v59;
    v61 = v56;
    goto LABEL_71;
  }
  CFRelease(v14);
  v61 = 0;
  v52 = 0;
  v62 = 0;
LABEL_78:
  CFRelease(v42);
  v14 = v61;
LABEL_79:
  if (v52)
    CFRelease(v52);
  if (v14)
    goto LABEL_82;
  return v62;
}

uint64_t sub_1000D5D80(uint64_t a1, const void *a2, int a3, const void *a4, int a5)
{
  const void *v9;
  const void *v10;
  void *v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v17;
  const __CFString *v18;
  id v19;
  id v20;
  id v21;
  const __CFString *v22;
  const __CFString *v23;
  const void *v24;
  CFStringRef v25;
  CFStringRef v26;
  void *v27;
  void *v29;
  const void *v30;

  if (!a4)
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_6;
    v13 = "%s: null network.";
    goto LABEL_26;
  }
  v9 = sub_10002BE64((uint64_t)a4, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"));
  if (v9)
  {
    v10 = v9;
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_6:
      objc_autoreleasePoolPop(v11);
      return 0;
    }
    v30 = v10;
    v13 = "%s: user already accepted join recommendation for this network at %@. Suppressing alert.";
    v14 = 3;
LABEL_5:
    objc_msgSend(v12, "WFLog:message:", v14, v13, "WiFiNotificationCreateJoinRecommendation", v30);
    goto LABEL_6;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_6;
    v13 = "%s: null alert.";
LABEL_26:
    v14 = 4;
    goto LABEL_5;
  }
  v17 = Mutable;
  if (sub_10011CE54((uint64_t)a2))
    v18 = CFSTR("WIFI_ASK_TO_JOIN_NETWORK_AVAILABLE_TITLE_CH");
  else
    v18 = CFSTR("WIFI_ASK_TO_JOIN_NETWORK_AVAILABLE_TITLE");
  v19 = sub_10015B934((uint64_t)v18);
  CFDictionarySetValue(v17, kCFUserNotificationAlertHeaderKey, v19);
  v20 = sub_10015B934((uint64_t)CFSTR("WIFI_ASK_TO_JOIN_JOIN_BUTTON"));
  CFDictionarySetValue(v17, kCFUserNotificationDefaultButtonTitleKey, v20);
  v21 = sub_10015B934((uint64_t)CFSTR("WIFI_ASK_TO_JOIN_CANCEL_BUTTON"));
  CFDictionarySetValue(v17, kCFUserNotificationAlternateButtonTitleKey, v21);
  if (a5 == 12)
    v22 = CFSTR("WIFI_ASK_TO_JOIN_NETWORK_HOTSPOT_RECOMMENDED_BODY");
  else
    v22 = CFSTR("WIFI_ASK_TO_JOIN_NETWORK_AVAILABLE_BODY");
  v23 = (const __CFString *)sub_10015B934((uint64_t)v22);
  v24 = sub_10002B088(a4);
  v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v23, v24);
  if (!v25)
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null messageString.", "WiFiNotificationCreateJoinRecommendation");
    objc_autoreleasePoolPop(v29);
    CFRelease(v17);
    return 0;
  }
  v26 = v25;
  CFDictionarySetValue(v17, kCFUserNotificationAlertMessageKey, v25);
  v15 = sub_1000D503C(a1, a5, 0, a2, v17, 0, 0);
  if (v15)
  {
    *(_QWORD *)(v15 + 24) = CFRetain(a4);
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching Join Recommendation Notification(%d)", *(unsigned int *)(v15 + 40));
    objc_autoreleasePoolPop(v27);
  }
  CFRelease(v17);
  CFRelease(v26);
  return v15;
}

uint64_t sub_1000D6074(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  const __CFString *v9;
  const void *v10;
  CFStringRef v11;
  const __CFString *v12;
  void *v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v19;
  void *v20;

  if (!a4)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNotificationCreateJoinFailureCaptive");
    objc_autoreleasePoolPop(v19);
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v8 = Mutable;
  if (sub_10015B920())
  {
    v9 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_FAILURE_CAPTIVE_TITLE"));
    v10 = sub_10002B088(a4);
    v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v9, v10);
    v12 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_FAILURE_OK"));
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateJoinFailureCaptive");
    objc_autoreleasePoolPop(v13);
    v14 = sub_10002B088(a4);
    v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to join the network\n“%@”"), v14);
    v12 = CFSTR("OK");
  }
  CFDictionarySetValue(v8, kCFUserNotificationAlertHeaderKey, v11);
  if (v11)
    CFRelease(v11);
  CFDictionarySetValue(v8, kCFUserNotificationDefaultButtonTitleKey, v12);
  v15 = sub_1000D503C(a1, 6, 0, a2, v8, 0, 0);
  if (!v15)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification of type join failure captive", "WiFiNotificationCreateJoinFailureCaptive");
    objc_autoreleasePoolPop(v20);
    CFRelease(v8);
    return 0;
  }
  v16 = v15;
  CFRelease(v8);
  *(_QWORD *)(v16 + 24) = CFRetain(a4);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching Join Failure Captive Notification(%d)", *(unsigned int *)(v16 + 40));
  objc_autoreleasePoolPop(v17);
  return v16;
}

uint64_t sub_1000D62D0(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  const __CFString *v9;
  const void *v10;
  CFStringRef v11;
  const __CFString *v12;
  void *v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v19;
  void *v20;

  if (!a4)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNotificationCreateJoinFailure");
    objc_autoreleasePoolPop(v19);
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v8 = Mutable;
  if (sub_10015B920())
  {
    v9 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_FAILURE_TITLE"));
    v10 = sub_10002B088(a4);
    v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v9, v10);
    v12 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_FAILURE_OK"));
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateJoinFailure");
    objc_autoreleasePoolPop(v13);
    v14 = sub_10002B088(a4);
    v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to join the network\n“%@”"), v14);
    v12 = CFSTR("OK");
  }
  CFDictionarySetValue(v8, kCFUserNotificationAlertHeaderKey, v11);
  if (v11)
    CFRelease(v11);
  CFDictionarySetValue(v8, kCFUserNotificationDefaultButtonTitleKey, v12);
  v15 = sub_1000D503C(a1, 7, 0, a2, v8, 0, 0);
  if (!v15)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification of type join failure", "WiFiNotificationCreateJoinFailure");
    objc_autoreleasePoolPop(v20);
    CFRelease(v8);
    return 0;
  }
  v16 = v15;
  CFRelease(v8);
  *(_QWORD *)(v16 + 24) = CFRetain(a4);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching Join Failure Notification(%d)", *(unsigned int *)(v16 + 40));
  objc_autoreleasePoolPop(v17);
  return v16;
}

uint64_t sub_1000D652C(uint64_t a1, uint64_t a2, int a3, void *a4, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v10;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v12;
  _BOOL4 v13;
  const void *v14;
  int v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  const void *v22;
  const void *v23;
  const __CFString *v24;
  CFStringRef v25;
  const __CFString *v26;
  const __CFString *v27;
  void *v28;
  const __CFString *v29;
  CFStringRef v30;
  const __CFString *v31;
  const __CFString *v32;
  CFStringRef v33;
  const __CFString *v34;
  CFStringRef v35;
  CFStringRef v36;
  uint64_t v37;
  void *v38;
  CFStringRef v39;
  void *v40;
  _BOOL4 v41;
  const __CFString *v42;
  id v43;
  const __CFString *v44;
  id v45;
  id v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  void *v51;
  void *v52;
  void *v53;
  const void *v54;
  const void *v55;
  uint64_t v56;

  if (!a4)
  {
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: nil networks manager.", "WiFiNotificationCreateColocatedJoin");
    goto LABEL_62;
  }
  if (!theDict)
  {
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: additional inforation is null", "WiFiNotificationCreateColocatedJoin");
    goto LABEL_62;
  }
  Value = CFDictionaryGetValue(theDict, CFSTR("SSID_STR"));
  if (!Value)
  {
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network SSID string is null", "WiFiNotificationCreateColocatedJoin");
LABEL_62:
    objc_autoreleasePoolPop(v52);
    return 0;
  }
  v10 = Value;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v12 = Mutable;
  v56 = a1;
  v13 = sub_10015B920();
  v14 = (const void *)a2;
  v15 = sub_10011CE54(a2);
  v16 = objc_msgSend(a4, "numberOfCandidates");
  if (!v16)
  {
    v53 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No colocated candidates");
    v36 = 0;
LABEL_69:
    objc_autoreleasePoolPop(v53);
    CFRelease(v12);
    v48 = 0;
    if (!v36)
      return v48;
    goto LABEL_51;
  }
  v17 = v16;
  v18 = objc_msgSend(a4, "colocatedNetworks");
  v19 = v18;
  if (v17 == (id)1)
  {
    v28 = sub_1000CE200(objc_msgSend(v18, "objectAtIndex:", 0));
    v22 = sub_10002B088(v28);
    if (v13)
    {
      v29 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_TITLE"));
      v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v29, v22);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v30);
      if (v30)
        CFRelease(v30);
      if (v15)
        v31 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_BODY_CH");
      else
        v31 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_BODY");
      v27 = (const __CFString *)sub_10015B934((uint64_t)v31);
      goto LABEL_22;
    }
    CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, CFSTR("Related Wi-Fi Network Available"));
    v40 = objc_autoreleasePoolPush();
    v37 = a1;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateColocatedJoin");
    objc_autoreleasePoolPop(v40);
    v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("“%@” has a separate network name on this Wi-Fi network, which may affect some experiences. Do you want to also join “%@”?"), v10, v22);
  }
  else
  {
    if (v17 != (id)2)
    {
      if (!v13)
      {
        CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, CFSTR("Related Wi-Fi Networks Available"));
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateColocatedJoin");
        objc_autoreleasePoolPop(v51);
        v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("“%@” has separate network names on this Wi-Fi network, which may affect some experiences. Do you want to also join those networks?"), v10);
        goto LABEL_31;
      }
      v32 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_TITLE"));
      v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v32, 0);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v33);
      if (v33)
        CFRelease(v33);
      if (v15)
        v34 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_BODY_CH");
      else
        v34 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_BODY");
      v27 = (const __CFString *)sub_10015B934((uint64_t)v34);
LABEL_30:
      v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v27, v10, v54, v55);
LABEL_31:
      v36 = v35;
      v37 = v56;
      goto LABEL_39;
    }
    v20 = sub_1000CE200(objc_msgSend(v18, "objectAtIndex:", 0));
    v21 = sub_1000CE200(objc_msgSend(v19, "objectAtIndex:", 1));
    v22 = sub_10002B088(v20);
    v23 = sub_10002B088(v21);
    if (v13)
    {
      v24 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_TITLE"));
      v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v24, v22, v23);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v25);
      if (v25)
        CFRelease(v25);
      if (v15)
        v26 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_BODY_CH");
      else
        v26 = CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_BODY");
      v27 = (const __CFString *)sub_10015B934((uint64_t)v26);
      v55 = v23;
LABEL_22:
      v54 = v22;
      goto LABEL_30;
    }
    CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, CFSTR("Related Wi-Fi Networks Available"));
    v38 = objc_autoreleasePoolPush();
    v37 = v56;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: localization not available", "WiFiNotificationCreateColocatedJoin");
    objc_autoreleasePoolPop(v38);
    v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("“%@” has separate network names on this Wi-Fi network, which may affect some experiences. Do you want to also join “%@” & “%@”?"), v10, v22, v23);
  }
  v36 = v39;
LABEL_39:
  v41 = sub_10015B920();
  if (v41)
    v42 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_BUTTON_OK"));
  else
    v42 = CFSTR("Join");
  v43 = objc_msgSend(objc_alloc((Class)SBSMutableUserNotificationButtonDefinition), "initWithTitle:", v42);
  objc_msgSend(v43, "setIsPreferredButton:", 1);
  objc_msgSend(v43, "setPresentationStyle:", 0);
  if (v41)
    v44 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("WIFI_LIMITED_COMPATIBILITY_JOIN_BUTTON_CANCEL"));
  else
    v44 = CFSTR("Not Now");
  v45 = objc_msgSend(objc_alloc((Class)SBSMutableUserNotificationButtonDefinition), "initWithTitle:", v44);
  v46 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", objc_msgSend(v45, "build"), objc_msgSend(v43, "build"), 0);

  CFDictionarySetValue(v12, SBSUserNotificationButtonDefinitionsKey, v46);
  if (v46)
    CFRelease(v46);
  CFDictionarySetValue(v12, kCFUserNotificationAlertMessageKey, v36);
  v47 = sub_1000D503C(v37, 13, 0, v14, v12, 0, theDict);
  if (!v47)
  {
    v53 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification of limited compatibility assisted join", "WiFiNotificationCreateColocatedJoin");
    goto LABEL_69;
  }
  v48 = v47;
  CFRelease(v12);
  v49 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching colocated join Notification(%d)", *(unsigned int *)(v48 + 40));
  objc_autoreleasePoolPop(v49);
  if (v36)
LABEL_51:
    CFRelease(v36);
  return v48;
}

uint64_t sub_1000D6BCC(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  uint64_t v7;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  const __CFString *v11;
  const void *v12;
  CFStringRef v13;
  const __CFString *v14;
  CFStringRef v15;
  const __CFString *v16;
  id v17;
  uint64_t v18;
  void *v19;
  void *v21;
  void *v22;
  const void *v23;
  const void *v24;

  v7 = sub_10011BC40((uint64_t)a2);
  if (!a4)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNotificationCreateAutoHotspotError");
    goto LABEL_20;
  }
  v8 = v7;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null alert.", "WiFiNotificationCreateAutoHotspotError");
LABEL_20:
    objc_autoreleasePoolPop(v21);
    return 0;
  }
  v10 = Mutable;
  if ((_DWORD)v8 == 2)
  {
    v11 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_DECLINED_BODY"));
    v12 = sub_10002B088(a4);
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v11, v12);
  }
  else
  {
    if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
    {
      v14 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_START_FAILURE_BODY_INTERNAL"));
      v23 = sub_10002B088(a4);
      v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v14, v23, v8);
    }
    else
    {
      v16 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_START_FAILURE_BODY"));
      v24 = sub_10002B088(a4);
      v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v16, v24);
    }
    v13 = v15;
    v17 = sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_REMOTE_FAILURE_TITLE"));
    CFDictionarySetValue(v10, kCFUserNotificationAlertHeaderKey, v17);
  }
  if (!v13)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null messageString.", "WiFiNotificationCreateAutoHotspotError");
    objc_autoreleasePoolPop(v22);
    CFRelease(v10);
    return 0;
  }
  CFDictionarySetValue(v10, kCFUserNotificationDefaultButtonTitleKey, CFSTR("OK"));
  CFDictionarySetValue(v10, kCFUserNotificationAlertMessageKey, v13);
  v18 = sub_1000D503C(a1, 11, 0, a2, v10, 0, 0);
  if (v18)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching Auto Hotspot Join Failure Panel(%d)", *(unsigned int *)(v18 + 40));
    objc_autoreleasePoolPop(v19);
    *(_QWORD *)(v18 + 24) = CFRetain(a4);
  }
  CFRelease(v10);
  CFRelease(v13);
  return v18;
}

uint64_t sub_1000D6E94(uint64_t a1, const void *a2, int a3, const void *a4)
{
  const void *v7;
  const void *v8;
  void *v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v15;
  id v16;
  id v17;
  id v18;
  const __CFString *v19;
  const void *v20;
  CFStringRef v21;
  CFStringRef v22;
  void *v23;
  void *v25;
  const void *v26;

  if (!a4)
  {
    v9 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_6;
    v11 = "%s: null network.";
    goto LABEL_20;
  }
  v7 = sub_10002BE64((uint64_t)a4, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"));
  if (v7)
  {
    v8 = v7;
    v9 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_6:
      objc_autoreleasePoolPop(v9);
      return 0;
    }
    v26 = v8;
    v11 = "%s: user already accepted join recommendation for this network at %@. Suppressing alert.";
    v12 = 3;
LABEL_5:
    objc_msgSend(v10, "WFLog:message:", v12, v11, "WiFiNotificationCreateAskToJoinHotspot", v26);
    goto LABEL_6;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v9 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_6;
    v11 = "%s: null alert.";
LABEL_20:
    v12 = 4;
    goto LABEL_5;
  }
  v15 = Mutable;
  v16 = sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_NEARBY_TITLE"));
  CFDictionarySetValue(v15, kCFUserNotificationAlertHeaderKey, v16);
  v17 = sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_JOIN"));
  CFDictionarySetValue(v15, kCFUserNotificationDefaultButtonTitleKey, v17);
  v18 = sub_10015B934((uint64_t)CFSTR("WIFI_JOIN_NETWORK_CANCEL"));
  CFDictionarySetValue(v15, kCFUserNotificationAlternateButtonTitleKey, v18);
  v19 = (const __CFString *)sub_10015B934((uint64_t)CFSTR("PERSONAL_HOTSPOT_NEARBY_BODY"));
  v20 = sub_10002B088(a4);
  v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v19, v20);
  if (!v21)
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null messageString.", "WiFiNotificationCreateAskToJoinHotspot");
    objc_autoreleasePoolPop(v25);
    CFRelease(v15);
    return 0;
  }
  v22 = v21;
  CFDictionarySetValue(v15, kCFUserNotificationAlertMessageKey, v21);
  v13 = sub_1000D503C(a1, 10, 0, a2, v15, 0, 0);
  if (v13)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching Auto Hotspot Panel(%d)", *(unsigned int *)(v13 + 40));
    objc_autoreleasePoolPop(v23);
    *(_QWORD *)(v13 + 24) = CFRetain(a4);
  }
  CFRelease(v15);
  CFRelease(v22);
  return v13;
}

uint64_t sub_1000D7154(uint64_t a1, int a2, uint64_t a3, const void *a4, int a5, CFDictionaryRef *a6, CFDictionaryRef theDict)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
      result = sub_1000D4E9C(a1, a4);
      break;
    case 1:
    case 3:
      result = sub_1000D567C(a1, (uint64_t)a4, a3, a6, a3);
      break;
    case 2:
      result = sub_1000D5334(a1, a4, a3, a6, theDict, a3);
      break;
    case 5:
    case 12:
      result = sub_1000D5D80(a1, a4, a3, a6, a2);
      break;
    case 6:
      result = sub_1000D6074(a1, a4, a3, a6);
      break;
    case 7:
      result = sub_1000D62D0(a1, a4, a3, a6);
      break;
    case 10:
      result = sub_1000D6E94(a1, a4, a3, a6);
      break;
    case 11:
      result = sub_1000D6BCC(a1, a4, a3, a6);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t sub_1000D71EC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1000D71F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1000D71FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_1000D7204(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_1000D720C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

BOOL sub_1000D7214(uint64_t a1)
{
  unsigned int v1;
  BOOL v2;
  int v3;

  v1 = *(_DWORD *)(a1 + 32);
  v2 = v1 > 0xC;
  v3 = (1 << v1) & 0x1425;
  return !v2 && v3 != 0;
}

void sub_1000D7238(uint64_t a1)
{
  void *v2;
  void *v3;
  const char *v4;
  void *v5;

  if (!*(_DWORD *)(a1 + 96))
  {
    switch(*(_DWORD *)(a1 + 32))
    {
      case 0:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Ask To Join panel";
        break;
      case 1:
      case 3:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling pending password panel";
        break;
      case 2:
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Canceling EAP Trust panel");
        objc_autoreleasePoolPop(v5);
        goto LABEL_22;
      case 5:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Join Recommendation panel";
        break;
      case 7:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Join Failure panel";
        break;
      case 0xA:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Ask-To-Join Hotspot";
        break;
      case 0xB:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Auto Hotspot Failure";
        break;
      case 0xC:
        v2 = objc_autoreleasePoolPush();
        v3 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_21;
        v4 = "Canceling Auto Hotspot Join Recommendation";
        break;
      default:
        goto LABEL_22;
    }
    objc_msgSend(v3, "WFLog:message:", 3, v4);
LABEL_21:
    objc_autoreleasePoolPop(v2);
    CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 120));
LABEL_22:
    sub_1000D7524(a1, 3);
  }
}

void sub_1000D73D8(_QWORD *a1, int a2, CFTypeRef cf)
{
  sub_1000D74B0(a1, cf);
  sub_1000D7524((uint64_t)a1, a2);
}

void sub_1000D7408(uint64_t a1, uint64_t a2)
{
  __CFRunLoop *Main;

  *(_QWORD *)(a1 + 48) = a2;
  if (*(_QWORD *)(a1 + 56))
  {
    Main = CFRunLoopGetMain();
    CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(a1 + 56), kCFRunLoopDefaultMode);
  }
}

void sub_1000D7450(uint64_t a1)
{
  __CFRunLoop *Main;

  *(_QWORD *)(a1 + 48) = 0;
  if (*(_QWORD *)(a1 + 56))
  {
    Main = CFRunLoopGetMain();
    CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 56), kCFRunLoopDefaultMode);
  }
}

uint64_t sub_1000D7498(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 64) = a2;
  *(_QWORD *)(result + 72) = a3;
  return result;
}

const __CFDictionary *sub_1000D74A0(uint64_t a1, const void *a2)
{
  const __CFDictionary *result;

  result = *(const __CFDictionary **)(a1 + 104);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

_QWORD *sub_1000D74B0(_QWORD *result, CFTypeRef cf)
{
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;

  if (cf)
  {
    v3 = (uint64_t)result;
    v4 = (const void *)result[13];
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(v3 + 104) = 0;
    }
    result = CFRetain(cf);
    *(_QWORD *)(v3 + 104) = result;
    if (!*(_DWORD *)(v3 + 32))
    {
      v5 = result;
      v6 = *(const void **)(v3 + 24);
      if (v6)
      {
        CFRelease(v6);
        *(_QWORD *)(v3 + 24) = 0;
        v5 = *(const void **)(v3 + 104);
      }
      result = sub_10002B314((uint64_t)kCFAllocatorDefault, v5);
      *(_QWORD *)(v3 + 24) = result;
    }
  }
  return result;
}

void sub_1000D7524(uint64_t a1, int a2)
{
  void *v3;
  uint64_t v4;
  __CFString *v5;
  void (*v6)(uint64_t, _QWORD);
  void (*v7)(uint64_t, _QWORD);

  *(_DWORD *)(a1 + 96) = a2;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = *(int *)(a1 + 96);
    if (v4 > 5)
      v5 = 0;
    else
      v5 = off_1002312A0[v4];
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Notification response received. Type=%d (%@) ResponseType=%d.", *(unsigned int *)(a1 + 32), v5, v4);
  }
  objc_autoreleasePoolPop(v3);
  v6 = *(void (**)(uint64_t, _QWORD))(a1 + 64);
  if (v6)
    v6(a1, *(_QWORD *)(a1 + 72));
  v7 = *(void (**)(uint64_t, _QWORD))(a1 + 80);
  if (v7)
    v7(a1, *(_QWORD *)(a1 + 88));
}

__CFString *sub_1000D75DC(unsigned int a1)
{
  if (a1 > 5)
    return 0;
  else
    return off_1002312A0[a1];
}

void sub_1000D75FC(uint64_t a1)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D7720;
  block[3] = &unk_10022EA38;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)&_dispatch_main_q, block);
  v2 = *(_DWORD *)(a1 + 32);
  v3 = v2 > 0xD;
  v4 = (1 << v2) & 0x3CEB;
  if (!v3 && v4 != 0)
  {
    v6 = *(const void **)(a1 + 120);
    if (v6)
    {
      pthread_mutex_lock(&stru_10026CC80);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_10026D740, v6);
      pthread_mutex_unlock(&stru_10026CC80);
      CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 120));
      v7 = *(const void **)(a1 + 120);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a1 + 120) = 0;
      }
    }
  }
  v8 = *(const void **)(a1 + 16);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v9 = *(const void **)(a1 + 112);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v10 = *(const void **)(a1 + 24);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v11 = *(const void **)(a1 + 104);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v12 = *(const void **)(a1 + 56);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void sub_1000D7720(uint64_t a1)
{
  sub_1000D7450(*(_QWORD *)(a1 + 32));
}

void sub_1000D7728(const void *a1, uint64_t a2)
{
  _QWORD *Value;
  _QWORD *v5;
  CFTypeID v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD block[7];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  if (a1)
  {
    pthread_mutex_lock(&stru_10026CC80);
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_10026D740, a1);
    v5 = Value;
    if (Value)
      CFRetain(Value);
    pthread_mutex_unlock(&stru_10026CC80);
    v11[3] = (uint64_t)v5;
    if (v5)
    {
      if (v5[6])
      {
        v6 = CFGetTypeID(v5);
        v7 = qword_10026D738;
        if (!qword_10026D738)
        {
          pthread_once(&stru_10026CC70, (void (*)(void))sub_1000D4E48);
          v7 = qword_10026D738;
        }
        if (v6 == v7)
        {
          CFRetain(a1);
          v8 = *(NSObject **)(v11[3] + 48);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1000D7890;
          block[3] = &unk_100230A08;
          block[4] = &v10;
          block[5] = a2;
          block[6] = a1;
          dispatch_async(v8, block);
          goto LABEL_12;
        }
        v5 = (_QWORD *)v11[3];
        if (!v5)
          goto LABEL_12;
      }
      CFRelease(v5);
      v11[3] = 0;
    }
  }
LABEL_12:
  _Block_object_dispose(&v10, 8);
}

void sub_1000D7878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000D7890(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  _QWORD *v14;
  CFDictionaryRef ResponseDictionary;
  const void *v16;

  v2 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 36);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %lu type: %d inputType: %d", "__WiFiNotificationCFUNCallback_block_invoke", *(_QWORD *)(a1 + 40), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 32), v2);
  objc_autoreleasePoolPop(v3);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
  if ((_DWORD)v2 != 1)
  {
    v6 = *(_DWORD *)(v5 + 32);
    if (v6 != 13)
      goto LABEL_14;
  }
  v7 = *(const void **)(v5 + 104);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 104) = 0;
    v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 104) = CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(v5 + 120));
  v4 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
  v9 = *(const void **)(v8 + 104);
  if (v9)
  {
    CFRetain(v9);
    v4 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
  }
  v6 = *(_DWORD *)(v8 + 32);
  if (v6 != 13)
  {
LABEL_14:
    v12 = *(_QWORD *)(a1 + 40) & 3;
    if (v12 != 3)
    {
      if (v12 != 1)
      {
        if (v12)
        {
          v11 = 0;
          goto LABEL_30;
        }
        if (v6 == 2)
        {
          v11 = 1;
          goto LABEL_30;
        }
        if ((_DWORD)v2 != 2)
        {
          if (v6)
            v11 = 1;
          else
            v11 = 2;
          goto LABEL_30;
        }
        goto LABEL_26;
      }
      if ((_DWORD)v2 == 2 && v6 == 2)
      {
LABEL_26:
        v11 = 4;
        goto LABEL_30;
      }
    }
    v11 = 2;
    goto LABEL_30;
  }
  v10 = objc_msgSend(-[__CFDictionary objectForKey:](CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(v8 + 120)), "objectForKey:", SBSUserNotificationButtonDefinitionResponseIndexKey), "intValue");
  if (v10)
    v11 = v10 == 1;
  else
    v11 = 2;
  v4 = *(_QWORD *)(a1 + 32);
LABEL_30:
  v14 = *(_QWORD **)(*(_QWORD *)(v4 + 8) + 24);
  ResponseDictionary = CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(a1 + 48));
  sub_1000D74B0(v14, ResponseDictionary);
  CFRelease(*(CFTypeRef *)(a1 + 48));
  sub_1000D7524(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v11);
  v16 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

uint64_t sub_1000D7AA0(const void *a1, BOOL *a2, double a3)
{
  NSObject *v6;
  NSObject *global_queue;
  dispatch_time_t v8;
  BOOL v9;
  uint64_t *v10;
  void *v11;
  uint64_t v12;
  void *v14;
  _QWORD block[8];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  if (a1)
  {
    if (MKBGetDeviceLockState(0) == 1 && !MKBUserUnlockedSinceBoot(0))
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Cannot copy password for %@. Device wasn't unlocked yet", a1);
      objc_autoreleasePoolPop(v14);
    }
    else
    {
      v6 = dispatch_semaphore_create(0);
      v16 = 0;
      v17 = &v16;
      v18 = 0x2020000000;
      v19 = 0;
      CFRetain(a1);
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000D7C94;
      block[3] = &unk_1002312D8;
      block[6] = &v16;
      block[7] = a1;
      block[4] = v6;
      block[5] = &v20;
      dispatch_async(global_queue, block);
      v8 = dispatch_time(0, (uint64_t)(a3 * 1000000000.0));
      v9 = dispatch_semaphore_wait(v6, v8) != 0;
      v10 = v17;
      *((_BYTE *)v17 + 24) = v9;
      *a2 = v9;
      if (*((_BYTE *)v10 + 24))
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:SecItemCopyMatching timed out, timeout %f\n", "WiFiSecurityCopyPasswordWithTimeout", *(_QWORD *)&a3);
        objc_autoreleasePoolPop(v11);
      }
      dispatch_release(v6);
      _Block_object_dispose(&v16, 8);
    }
  }
  v12 = v21[3];
  _Block_object_dispose(&v20, 8);
  return v12;
}

void sub_1000D7C68(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1000D7C94(uint64_t a1)
{
  __CFDictionary *v2;
  __CFDictionary *v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  const void *v7;
  CFTypeRef result;

  result = 0;
  v2 = sub_1000D7DD4(*(const void **)(a1 + 56), 0, 0, 0, 0, 1);
  v3 = v2;
  if (v2)
  {
    v4 = SecItemCopyMatching(v2, &result);
    if ((_DWORD)v4)
      v5 = 1;
    else
      v5 = result == 0;
    if (!v5)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
      goto LABEL_11;
    }
  }
  else
  {
    v4 = 0;
  }
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "WiFiSecurityCopyPasswordWithTimeout_block_invoke", *(_QWORD *)(a1 + 56), v4);
  objc_autoreleasePoolPop(v6);
LABEL_11:
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (v3)
    CFRelease(v3);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
  {
    v7 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

__CFDictionary *sub_1000D7DD4(const void *a1, const void *a2, const void *a3, int a4, int a5, int a6)
{
  __CFDictionary *Mutable;
  __CFDictionary *v13;
  void *v15;
  uint64_t v16;

  if (!a1)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "__WiFiSecurityCreateQuery", v16);
    goto LABEL_18;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  if (!Mutable)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create query for %@", "__WiFiSecurityCreateQuery", a1);
LABEL_18:
    objc_autoreleasePoolPop(v15);
    return 0;
  }
  v13 = Mutable;
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v13, kSecAttrAccount, a1);
  CFDictionarySetValue(v13, kSecAttrService, CFSTR("AirPort"));
  CFDictionarySetValue(v13, kSecAttrSynchronizable, kSecAttrSynchronizableAny);
  if (a2)
    CFDictionarySetValue(v13, kSecAttrLabel, a2);
  if (a3)
    CFDictionarySetValue(v13, kSecAttrDescription, a3);
  if (a6)
    CFDictionarySetValue(v13, kSecUseSystemKeychain, kCFBooleanTrue);
  if (!a4)
    CFDictionarySetValue(v13, kSecReturnData, kCFBooleanTrue);
  if (a5)
    CFDictionarySetValue(v13, kSecReturnAttributes, kCFBooleanTrue);
  return v13;
}

CFStringRef sub_1000D7FC8(__CFString *a1)
{
  CFStringRef result;
  const char *v3;
  const char *v4;
  const char *v5;

  result = sub_1000D805C(a1, 1);
  if (!result)
  {
    v3 = getprogname();
    if (!strncmp("sharingd", v3, 8uLL))
      return sub_1000D81B4(a1);
    v4 = getprogname();
    if (!strncmp("HPSetup", v4, 7uLL))
      return sub_1000D81B4(a1);
    v5 = getprogname();
    if (!strncmp("HDSViewService", v5, 0xEuLL))
      return sub_1000D81B4(a1);
    else
      return 0;
  }
  return result;
}

CFStringRef sub_1000D805C(const __CFString *a1, int a2)
{
  CFStringRef v2;
  __CFDictionary *v4;
  __CFDictionary *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  CFTypeRef result;

  v2 = a1;
  if (!a1)
    return v2;
  if (MKBGetDeviceLockState(0) != 1 || MKBUserUnlockedSinceBoot(0))
  {
    v4 = sub_1000D7DD4(v2, 0, 0, 0, 0, a2);
    v5 = v4;
    result = 0;
    if (v4)
    {
      v6 = SecItemCopyMatching(v4, &result);
      if (!(_DWORD)v6 && result)
      {
        v2 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
LABEL_12:
        if (result)
        {
          CFRelease(result);
          result = 0;
        }
        if (v5)
          CFRelease(v5);
        return v2;
      }
    }
    else
    {
      v6 = 0;
    }
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "__WiFiSecurityCopyPassword", v2, v6);
    objc_autoreleasePoolPop(v7);
    v2 = 0;
    goto LABEL_12;
  }
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Cannot copy password for %@. Device wasn't unlocked yet", v2);
  objc_autoreleasePoolPop(v8);
  return 0;
}

CFStringRef sub_1000D81B4(void *a1)
{
  void *v2;
  id v3;
  void *v4;
  id v5;
  OSStatus v6;
  CFStringRef v7;
  const char *v8;
  uint32_t v9;
  const char *v11;
  CFTypeRef result;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  void *v16;
  __int16 v17;
  void *v18;

  v2 = objc_autoreleasePoolPush();
  result = 0;
  if (a1)
  {
    if (objc_msgSend(a1, "length"))
    {
      v3 = sub_1000D9C84(a1);
      v4 = v3;
      if (v3 && objc_msgSend(v3, "length"))
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
          v15 = 2112;
          v16 = a1;
          v17 = 2112;
          v18 = v4;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: ssid %@ (%@)", buf, 0x20u);
        }
        v5 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
        objc_msgSend(v5, "setObject:forKey:", kSecClassGenericPassword, kSecClass);
        objc_msgSend(v5, "setObject:forKey:", v4, kSecAttrAccount);
        objc_msgSend(v5, "setObject:forKey:", CFSTR("AirPort"), kSecAttrService);
        objc_msgSend(v5, "setObject:forKey:", &__kCFBooleanTrue, kSecReturnData);
        v6 = SecItemCopyMatching((CFDictionaryRef)v5, &result);
        if (!v6 && result)
        {
          v7 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
          goto LABEL_14;
        }
        if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_13;
        *(_DWORD *)buf = 136315650;
        v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
        v15 = 2112;
        v16 = v4;
        v17 = 1024;
        LODWORD(v18) = v6;
        v8 = "%s:[%@] error result %d \n";
        v9 = 28;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_13;
        *(_DWORD *)buf = 136315138;
        v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
        v8 = "%s: error: empty ssid hash";
        v9 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v8, buf, v9);
LABEL_13:
      v7 = 0;
      goto LABEL_14;
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
      v11 = "%s: error: empty ssid";
      goto LABEL_23;
    }
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
    v11 = "%s: null ssid";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v11, buf, 0xCu);
  }
  v7 = 0;
  v4 = 0;
LABEL_14:

  if (result)
    CFRelease(result);
  objc_autoreleasePoolPop(v2);
  return v7;
}

CFStringRef sub_1000D84EC(const __CFString *a1)
{
  return sub_1000D805C(a1, 0);
}

CFTypeRef sub_1000D84F4(const void *a1)
{
  __CFDictionary *v2;
  __CFDictionary *v3;
  uint64_t v4;
  const void *Value;
  CFTypeRef v6;
  void *v7;
  void *v9;
  uint64_t v10;
  CFTypeRef result;

  result = 0;
  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "WiFiSecurityCopyPasswordModificationDate", v10);
    goto LABEL_21;
  }
  if (MKBGetDeviceLockState(0) == 1 && !MKBUserUnlockedSinceBoot(0))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Cannot get keychain attributes for %@. Device wasn't unlocked yet", "WiFiSecurityCopyPasswordModificationDate", a1);
LABEL_21:
    objc_autoreleasePoolPop(v9);
    v6 = 0;
    v3 = 0;
    goto LABEL_12;
  }
  v2 = sub_1000D7DD4(a1, 0, 0, 0, 1, 1);
  v3 = v2;
  if (v2)
  {
    v4 = SecItemCopyMatching(v2, &result);
    if (!(_DWORD)v4 && result)
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)result, kSecAttrModificationDate);
      v6 = CFRetain(Value);
      goto LABEL_12;
    }
  }
  else
  {
    v4 = 0;
  }
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d", "WiFiSecurityCopyPasswordModificationDate", a1, v4);
  objc_autoreleasePoolPop(v7);
  v6 = 0;
LABEL_12:
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (v3)
    CFRelease(v3);
  return v6;
}

uint64_t sub_1000D8680(const void *a1, const __CFString *a2, BOOL *a3, double a4)
{
  void *v8;
  CFDataRef ExternalRepresentation;
  const __CFString *v10;
  const __CFString *v11;
  BOOL v12;
  const __CFDictionary *v13;
  uint64_t v14;
  __CFDictionary *v15;
  __CFDictionary *Mutable;
  __CFDictionary *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  CFTypeRef result;
  BOOL v27;

  v27 = 0;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: for account %@", "WiFiSecuritySetPasswordWithTimeout", a1);
  objc_autoreleasePoolPop(v8);
  if (!a1)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "WiFiSecuritySetPasswordWithTimeout", v25);
    goto LABEL_35;
  }
  if (!a2)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null password", "WiFiSecuritySetPasswordWithTimeout", v25);
    goto LABEL_35;
  }
  if (!CFStringGetLength(a2))
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Empty password for account %@", "WiFiSecuritySetPasswordWithTimeout", a1);
LABEL_35:
    objc_autoreleasePoolPop(v22);
    return 0;
  }
  ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a2, 0x8000100u, 0);
  v10 = (const __CFString *)sub_1000D7AA0(a1, &v27, a4);
  v11 = v10;
  v12 = v27;
  if (v27)
  {
    v13 = 0;
    *a3 = 1;
    v14 = 4294899568;
  }
  else
  {
    if (v10)
    {
      if (CFStringCompare(a2, v10, 0) == kCFCompareEqualTo)
      {
        *a3 = v12;
        v20 = 1;
        goto LABEL_25;
      }
      v15 = sub_1000D7DD4(a1, 0, 0, 1, 0, 1);
      if (!v15)
      {
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null query", "WiFiSecuritySetPasswordWithTimeout");
        objc_autoreleasePoolPop(v23);
        v20 = 0;
        goto LABEL_25;
      }
      v13 = v15;
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
      CFDictionarySetValue(Mutable, kSecValueData, ExternalRepresentation);
      CFDictionarySetValue(Mutable, kSecAttrLabel, a1);
      CFDictionarySetValue(Mutable, kSecAttrDescription, CFSTR("AirPort network password"));
      v14 = SecItemUpdate(v13, Mutable);
      if (Mutable)
        CFRelease(Mutable);
    }
    else
    {
      v17 = sub_1000D7DD4(a1, a1, CFSTR("AirPort network password"), 1, 0, 1);
      if (!v17)
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null query", "WiFiSecuritySetPasswordWithTimeout");
        objc_autoreleasePoolPop(v24);
        v20 = 0;
        if (ExternalRepresentation)
          goto LABEL_27;
        return v20;
      }
      v13 = v17;
      result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFDictionarySetValue(v17, kSecValueData, ExternalRepresentation);
      CFDictionarySetValue(v13, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
      CFDictionarySetValue(v13, kSecAttrSynchronizable, kCFBooleanTrue);
      v14 = SecItemAdd(v13, &result);
    }
    *a3 = v12;
    if (!(_DWORD)v14)
    {
      notify_post("com.apple.wifid.WiFiPasswordChanged");
      v19 = 1;
      goto LABEL_22;
    }
  }
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "WiFiSecuritySetPasswordWithTimeout", a1, v14);
  objc_autoreleasePoolPop(v18);
  v19 = 0;
  v20 = 0;
  if (!v13)
  {
    if (!v11)
      goto LABEL_26;
LABEL_25:
    CFRelease(v11);
    goto LABEL_26;
  }
LABEL_22:
  CFRelease(v13);
  v20 = v19;
  if (v11)
    goto LABEL_25;
LABEL_26:
  if (ExternalRepresentation)
LABEL_27:
    CFRelease(ExternalRepresentation);
  return v20;
}

BOOL sub_1000D8A4C(__CFString *a1, const __CFString *a2)
{
  return sub_1000D8A54(a1, a2, 1);
}

BOOL sub_1000D8A54(__CFString *a1, CFStringRef theString, int a3)
{
  CFDataRef ExternalRepresentation;
  CFStringRef v7;
  __CFDictionary *v8;
  const __CFDictionary *v9;
  __CFDictionary *Mutable;
  uint64_t v11;
  __CFDictionary *v12;
  _BOOL8 v13;
  void *v14;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  CFTypeRef result;

  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "__WiFiSecuritySetPassword", v19);
    goto LABEL_29;
  }
  if (!theString)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null password", "__WiFiSecuritySetPassword", v19);
    goto LABEL_29;
  }
  if (!CFStringGetLength(theString))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Empty password for account %@", "__WiFiSecuritySetPassword", a1);
LABEL_29:
    objc_autoreleasePoolPop(v16);
    return 0;
  }
  ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
  v7 = sub_1000D7FC8(a1);
  if (v7)
  {
    if (CFStringCompare(theString, v7, 0) == kCFCompareEqualTo)
    {
      v13 = 1;
LABEL_19:
      CFRelease(v7);
      goto LABEL_20;
    }
    v8 = sub_1000D7DD4(a1, 0, 0, 1, 0, a3);
    if (!v8)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null query", "__WiFiSecuritySetPassword");
      objc_autoreleasePoolPop(v17);
      v13 = 0;
      goto LABEL_19;
    }
    v9 = v8;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
    CFDictionarySetValue(Mutable, kSecValueData, ExternalRepresentation);
    CFDictionarySetValue(Mutable, kSecAttrLabel, a1);
    CFDictionarySetValue(Mutable, kSecAttrDescription, CFSTR("AirPort network password"));
    v11 = SecItemUpdate(v9, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    v12 = sub_1000D7DD4(a1, a1, CFSTR("AirPort network password"), 1, 0, a3);
    if (!v12)
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null query", "__WiFiSecuritySetPassword");
      objc_autoreleasePoolPop(v18);
      v13 = 0;
      if (ExternalRepresentation)
        goto LABEL_21;
      return v13;
    }
    v9 = v12;
    result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
    CFDictionarySetValue(v12, kSecValueData, ExternalRepresentation);
    CFDictionarySetValue(v9, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionarySetValue(v9, kSecAttrSynchronizable, kCFBooleanTrue);
    v11 = SecItemAdd(v9, &result);
  }
  v13 = (_DWORD)v11 == 0;
  if ((_DWORD)v11)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "__WiFiSecuritySetPassword", a1, v11);
    objc_autoreleasePoolPop(v14);
  }
  else
  {
    notify_post("com.apple.wifid.WiFiPasswordChanged");
  }
  CFRelease(v9);
  if (v7)
    goto LABEL_19;
LABEL_20:
  if (ExternalRepresentation)
LABEL_21:
    CFRelease(ExternalRepresentation);
  return v13;
}

BOOL sub_1000D8DE8(__CFString *a1, const __CFString *a2)
{
  return sub_1000D8A54(a1, a2, 0);
}

uint64_t sub_1000D8DF0(const void *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Removing password for %@", "WiFiSecurityRemovePassword", a1);
  objc_autoreleasePoolPop(v2);
  return sub_1000D8E58(a1, 1);
}

uint64_t sub_1000D8E58(const void *a1, int a2)
{
  __CFDictionary *v3;
  __CFDictionary *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v9;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "__WiFiSecurityRemovePassword");
    goto LABEL_13;
  }
  v3 = sub_1000D7DD4(a1, 0, 0, 0, 0, a2);
  if (!v3)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null query", "__WiFiSecurityRemovePassword");
LABEL_13:
    v7 = v9;
LABEL_7:
    objc_autoreleasePoolPop(v7);
    return 0;
  }
  v4 = v3;
  v5 = SecItemDelete(v3);
  CFRelease(v4);
  if ((_DWORD)v5)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "__WiFiSecurityRemovePassword", a1, v5);
    v7 = v6;
    goto LABEL_7;
  }
  notify_post("com.apple.wifid.WiFiPasswordChanged");
  return 1;
}

uint64_t sub_1000D8F80(const void *a1)
{
  return sub_1000D8E58(a1, 0);
}

uint64_t sub_1000D8F88(const void *a1)
{
  __CFDictionary *v2;
  __CFDictionary *v3;
  uint64_t v4;
  const __CFBoolean *Value;
  uint64_t v6;
  void *v7;
  void *v9;
  uint64_t v10;
  CFTypeRef result;

  result = 0;
  if (a1)
  {
    if (MKBGetDeviceLockState(0) != 1 || MKBUserUnlockedSinceBoot(0))
    {
      v2 = sub_1000D7DD4(a1, 0, 0, 0, 1, 1);
      v3 = v2;
      if (v2)
      {
        v4 = SecItemCopyMatching(v2, &result);
        if (!(_DWORD)v4 && result)
        {
          Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)result, kSecAttrSynchronizable);
          if (Value)
          {
            v6 = CFBooleanGetValue(Value);
            goto LABEL_14;
          }
          goto LABEL_13;
        }
      }
      else
      {
        v4 = 0;
      }
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "WiFiSecurityIsPasswordSyncing", a1, v4);
      objc_autoreleasePoolPop(v7);
LABEL_13:
      v6 = 0;
      goto LABEL_14;
    }
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Cannot get keychain attributes for %@. Device wasn't unlocked yet", "WiFiSecurityIsPasswordSyncing", a1);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null account", "WiFiSecurityIsPasswordSyncing", v10);
  }
  objc_autoreleasePoolPop(v9);
  v6 = 0;
  v3 = 0;
LABEL_14:
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (v3)
    CFRelease(v3);
  return v6;
}

BOOL sub_1000D9118(__CFString *a1, uint64_t a2)
{
  CFStringRef v4;
  CFStringRef v5;
  __CFDictionary *v6;
  __CFDictionary *v7;
  __CFDictionary *Mutable;
  const __CFDictionary *v9;
  const void **v10;
  uint64_t v11;
  _BOOL8 v12;
  uint64_t v13;
  void *v14;
  void *v16;
  void *v17;
  void *v18;

  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null account", "WiFiSecuritySetPasswordSyncable");
    goto LABEL_18;
  }
  v4 = sub_1000D7FC8(a1);
  if (!v4)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null existingPassword", "WiFiSecuritySetPasswordSyncable");
LABEL_18:
    objc_autoreleasePoolPop(v16);
    return 0;
  }
  v5 = v4;
  v6 = sub_1000D7DD4(a1, 0, 0, 0, 0, 1);
  if (!v6)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null query", "WiFiSecuritySetPasswordSyncable");
    objc_autoreleasePoolPop(v17);
    CFRelease(v5);
    return 0;
  }
  v7 = v6;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  if (Mutable)
  {
    v9 = Mutable;
    v10 = (const void **)&kCFBooleanFalse;
    if ((_DWORD)a2)
      v10 = (const void **)&kCFBooleanTrue;
    CFDictionarySetValue(Mutable, kSecAttrSynchronizable, *v10);
    CFDictionaryRemoveValue(v7, kSecReturnData);
    v11 = SecItemUpdate(v7, v9);
    v12 = (_DWORD)v11 == 0;
    if ((_DWORD)v11)
    {
      v13 = v11;
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@]%d Error result %d \n", "WiFiSecuritySetPasswordSyncable", a1, a2, v13);
      objc_autoreleasePoolPop(v14);
    }
    CFRelease(v9);
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null newVal", "WiFiSecuritySetPasswordSyncable");
    objc_autoreleasePoolPop(v18);
    v12 = 0;
  }
  CFRelease(v5);
  CFRelease(v7);
  return v12;
}

__CFString *sub_1000D9368(const __CFString *a1, const __CFData *a2)
{
  __CFString *Mutable;
  const char *CStringPtr;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFData *v7;
  const __CFData *v8;
  const UInt8 *v9;
  uint64_t i;
  UInt8 bytes[16];
  __int128 v13;

  Mutable = 0;
  if (a1 && a2)
  {
    *(_OWORD *)bytes = 0u;
    v13 = 0u;
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    if (Apple80211ParseWPAPassword(CStringPtr, bytes, 32, 0, BytePtr, Length))
      return 0;
    v7 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
    if (!v7)
    {
      return 0;
    }
    else
    {
      v8 = v7;
      v9 = CFDataGetBytePtr(v7);
      if (CFDataGetLength(v8) == 32)
      {
        Mutable = CFStringCreateMutable(kCFAllocatorDefault, 64);
        for (i = 0; i != 32; ++i)
          CFStringAppendFormat(Mutable, 0, CFSTR("%02x"), v9[i]);
      }
      else
      {
        Mutable = 0;
      }
      CFRelease(v8);
    }
  }
  return Mutable;
}

CFTypeRef sub_1000D94B8()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v6;
  CFTypeRef result;

  result = 0;
  if (MKBGetDeviceLockState(0) == 1 && !MKBUserUnlockedSinceBoot(0))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Cannot get all airport keychain attributes. Device wasn't unlocked yet", "WiFiSecurityCopyAttributesForAllAirPortEntries");
    goto LABEL_12;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  if (!Mutable)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create query", "__WiFiSecurityCreateWildcardAttributeQuery");
LABEL_12:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  v1 = Mutable;
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v1, kSecMatchLimit, kSecMatchLimitAll);
  CFDictionarySetValue(v1, kSecAttrService, CFSTR("AirPort"));
  CFDictionarySetValue(v1, kSecAttrSynchronizable, kSecAttrSynchronizableAny);
  CFDictionarySetValue(v1, kSecReturnAttributes, kCFBooleanTrue);
  CFDictionarySetValue(v1, kSecUseSystemKeychain, kCFBooleanTrue);
  v2 = SecItemCopyMatching(v1, &result);
  if ((_DWORD)v2 && result)
  {
    v3 = v2;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error result %d", "WiFiSecurityCopyAttributesForAllAirPortEntries", v3);
    objc_autoreleasePoolPop(v4);
  }
  CFRelease(v1);
  return result;
}

CFStringRef sub_1000D96B0(const __CFString *a1)
{
  CFStringRef v1;
  void *v2;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  void *v8;
  void *v9;
  CFTypeRef result;

  v1 = a1;
  result = 0;
  if (!a1)
    return v1;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Attempting to fetch non-syncable password for account %@", "WiFiSecurityCopyNonSyncablePassword", v1);
  objc_autoreleasePoolPop(v2);
  if (MKBGetDeviceLockState(0) == 1 && !MKBUserUnlockedSinceBoot(0))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Cannot copy password for %@. Device wasn't unlocked yet", v1);
    objc_autoreleasePoolPop(v9);
    v4 = 0;
    goto LABEL_18;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  v4 = Mutable;
  if (!Mutable)
  {
LABEL_18:
    v1 = 0;
    goto LABEL_19;
  }
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v4, kSecAttrAccount, v1);
  CFDictionarySetValue(v4, kSecAttrService, CFSTR("AirPort"));
  CFDictionarySetValue(v4, kSecUseSystemKeychain, kCFBooleanTrue);
  CFDictionarySetValue(v4, kSecReturnData, kCFBooleanTrue);
  v5 = SecItemCopyMatching(v4, &result);
  if ((_DWORD)v5)
    v6 = 1;
  else
    v6 = result == 0;
  if (v6)
  {
    v7 = v5;
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:[%@] Error result %d", "WiFiSecurityCopyNonSyncablePassword", v1, v7);
    objc_autoreleasePoolPop(v8);
    goto LABEL_18;
  }
  v1 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
LABEL_19:
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (v4)
    CFRelease(v4);
  return v1;
}

uint64_t sub_1000D98C4(const void *a1, BOOL *a2, double a3)
{
  NSObject *v6;
  NSObject *global_queue;
  dispatch_time_t v8;
  BOOL v9;
  uint64_t *v10;
  void *v11;
  uint64_t v12;
  void *v14;
  _QWORD block[8];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  if (a1)
  {
    if (MKBGetDeviceLockState(0) == 1 && !MKBUserUnlockedSinceBoot(0))
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Cannot copy password for %@. Device wasn't unlocked yet", a1);
      objc_autoreleasePoolPop(v14);
    }
    else
    {
      v6 = dispatch_semaphore_create(0);
      v16 = 0;
      v17 = &v16;
      v18 = 0x2020000000;
      v19 = 0;
      CFRetain(a1);
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000D9AB8;
      block[3] = &unk_1002312D8;
      block[6] = &v16;
      block[7] = a1;
      block[4] = v6;
      block[5] = &v20;
      dispatch_async(global_queue, block);
      v8 = dispatch_time(0, (uint64_t)(a3 * 1000000000.0));
      v9 = dispatch_semaphore_wait(v6, v8) != 0;
      v10 = v17;
      *((_BYTE *)v17 + 24) = v9;
      *a2 = v9;
      if (*((_BYTE *)v10 + 24))
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:SecItemCopyMatching timed out, timeout %f\n", "WiFiSecurityCopyNonSyncablePasswordWithTimeout", *(_QWORD *)&a3);
        objc_autoreleasePoolPop(v11);
      }
      dispatch_release(v6);
      _Block_object_dispose(&v16, 8);
    }
  }
  v12 = v21[3];
  _Block_object_dispose(&v20, 8);
  return v12;
}

void sub_1000D9A8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1000D9AB8(uint64_t a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  const void *v7;
  CFTypeRef result;

  result = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, 0, 0);
  v3 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
    CFDictionarySetValue(v3, kSecAttrAccount, *(const void **)(a1 + 56));
    CFDictionarySetValue(v3, kSecAttrService, CFSTR("AirPort"));
    CFDictionarySetValue(v3, kSecUseSystemKeychain, kCFBooleanTrue);
    CFDictionarySetValue(v3, kSecReturnData, kCFBooleanTrue);
    v4 = SecItemCopyMatching(v3, &result);
    if ((_DWORD)v4)
      v5 = 1;
    else
      v5 = result == 0;
    if (!v5)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
      goto LABEL_11;
    }
  }
  else
  {
    v4 = 0;
  }
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:[%@] Error result %d \n", "WiFiSecurityCopyNonSyncablePasswordWithTimeout_block_invoke", *(_QWORD *)(a1 + 56), v4);
  objc_autoreleasePoolPop(v6);
LABEL_11:
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (v3)
    CFRelease(v3);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
  {
    v7 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id sub_1000D9C84(void *a1)
{
  void *v2;
  __int128 v3;
  const char *v4;
  size_t v5;
  id v6;
  uint64_t i;
  _OWORD macOut[2];

  v2 = objc_autoreleasePoolPush();
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  macOut[0] = v3;
  macOut[1] = v3;
  v4 = (const char *)objc_msgSend(a1, "cStringUsingEncoding:", 4);
  v5 = strlen(v4);
  CCHmac(2u, "CURRENT_NETWORK", 0xFuLL, v4, v5, macOut);
  v6 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithCapacity:", 64);
  for (i = 0; i != 32; ++i)
    objc_msgSend(v6, "appendFormat:", CFSTR("%02x"), *((unsigned __int8 *)macOut + i));
  objc_autoreleasePoolPop(v2);
  return v6;
}

BOOL sub_1000D9D7C(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;
  dispatch_time_t v6;
  intptr_t v7;
  _BOOL4 v8;
  _BOOL8 v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  uint64_t v19;

  v4 = objc_autoreleasePoolPush();
  v5 = dispatch_semaphore_create(0);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000D9F54;
  v11[3] = &unk_100231300;
  v11[4] = a1;
  v11[5] = a2;
  v11[6] = v5;
  v11[7] = &v12;
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, v11);
  v6 = dispatch_time(0, 1000000000);
  v7 = dispatch_semaphore_wait(v5, v6);
  v8 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136315394;
      v17 = "WiFiSecuritySavePasswordForPasswordBackup";
      v18 = 2112;
      v19 = a1;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s:[%@] timed out\n", buf, 0x16u);
    }
    v9 = 0;
  }
  else
  {
    if (v8)
    {
      *(_DWORD *)buf = 136315394;
      v17 = "WiFiSecuritySavePasswordForPasswordBackup";
      v18 = 2112;
      v19 = a1;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s:[%@] completed\n", buf, 0x16u);
    }
    v9 = *((_DWORD *)v13 + 6) == 0;
  }
  dispatch_release(v5);
  _Block_object_dispose(&v12, 8);
  objc_autoreleasePoolPop(v4);
  return v9;
}

intptr_t sub_1000D9F54(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  int v8;
  const char *v9;
  uint32_t v10;
  const char *v12;
  uint32_t v13;
  void *v14;
  CFTypeRef result;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  void *v19;
  __int16 v20;
  void *v21;

  result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_28;
    *(_DWORD *)buf = 136315138;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v12 = "%s: null ssid";
LABEL_24:
    v13 = 12;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v12, buf, v13);
    goto LABEL_28;
  }
  if (!*(_QWORD *)(a1 + 40))
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_28;
    *(_DWORD *)buf = 136315138;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v12 = "%s: null password";
    goto LABEL_24;
  }
  if (!objc_msgSend(v2, "length"))
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_28;
    *(_DWORD *)buf = 136315138;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v12 = "%s: error: empty ssid";
    goto LABEL_24;
  }
  if (!objc_msgSend(*(id *)(a1 + 40), "length"))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 136315394;
      v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
      v18 = 2112;
      v19 = v14;
      v12 = "%s: error: empty password for ssid %@";
      v13 = 22;
      goto LABEL_27;
    }
LABEL_28:
    v4 = 0;
    goto LABEL_15;
  }
  v3 = sub_1000D9C84(*(void **)(a1 + 32));
  v4 = v3;
  if (!v3 || !objc_msgSend(v3, "length"))
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_15;
    *(_DWORD *)buf = 136315138;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v9 = "%s: error: empty ssid hash";
    v10 = 12;
    goto LABEL_14;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 136315650;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v18 = 2112;
    v19 = v5;
    v20 = 2112;
    v21 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: ssid %@ (%@)", buf, 0x20u);
  }
  v6 = objc_msgSend(*(id *)(a1 + 40), "dataUsingEncoding:", 4);
  v7 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  objc_msgSend(v7, "setObject:forKey:", kSecClassGenericPassword, kSecClass);
  objc_msgSend(v7, "setObject:forKey:", v4, kSecAttrAccount);
  objc_msgSend(v7, "setObject:forKey:", CFSTR("AirPort"), kSecAttrService);
  objc_msgSend(v7, "setObject:forKey:", v6, kSecValueData);
  objc_msgSend(v7, "setObject:forKey:", kSecAttrAccessibleAfterFirstUnlock, kSecAttrAccessible);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = SecItemAdd((CFDictionaryRef)v7, &result);
  v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  if (v8 == -25299)
  {
    sub_1000DA384(*(_QWORD *)(a1 + 32));
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = SecItemAdd((CFDictionaryRef)v7, &result);
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  }
  if (v8 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    v18 = 2112;
    v19 = v4;
    v20 = 1024;
    LODWORD(v21) = v8;
    v9 = "%s:[%@] error result %d \n";
    v10 = 28;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v9, buf, v10);
  }
LABEL_15:

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

BOOL sub_1000DA384(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  dispatch_time_t v4;
  intptr_t v5;
  _BOOL4 v6;
  _BOOL8 v7;
  _QWORD block[7];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  uint64_t v17;

  v2 = objc_autoreleasePoolPush();
  v3 = dispatch_semaphore_create(0);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000DA558;
  block[3] = &unk_100231328;
  block[5] = v3;
  block[6] = &v10;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  v4 = dispatch_time(0, 1000000000);
  v5 = dispatch_semaphore_wait(v3, v4);
  v6 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136315394;
      v15 = "WiFiSecurityRemovePasswordFromPasswordBackup";
      v16 = 2112;
      v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s:[%@] timed out\n", buf, 0x16u);
    }
    v7 = 0;
  }
  else
  {
    if (v6)
    {
      *(_DWORD *)buf = 136315394;
      v15 = "WiFiSecurityRemovePasswordFromPasswordBackup";
      v16 = 2112;
      v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s:[%@] completed\n", buf, 0x16u);
    }
    v7 = *((_DWORD *)v11 + 6) == 0;
  }
  dispatch_release(v3);
  _Block_object_dispose(&v10, 8);
  objc_autoreleasePoolPop(v2);
  return v7;
}

intptr_t sub_1000DA558(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  void *v5;
  id v6;
  int v7;
  const char *v8;
  uint32_t v9;
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  void *v15;
  __int16 v16;
  void *v17;

  v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136315138;
      v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
      v11 = "%s: null ssid";
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v12, 0xCu);
    }
LABEL_19:
    v4 = 0;
    goto LABEL_11;
  }
  if (!objc_msgSend(v2, "length"))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136315138;
      v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
      v11 = "%s: error: empty ssid";
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v3 = sub_1000D9C84(*(void **)(a1 + 32));
  v4 = v3;
  if (!v3 || !objc_msgSend(v3, "length"))
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    v12 = 136315138;
    v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
    v8 = "%s: error: empty ssid hash";
    v9 = 12;
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(void **)(a1 + 32);
    v12 = 136315650;
    v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
    v14 = 2112;
    v15 = v5;
    v16 = 2112;
    v17 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: ssid %@ (%@)", (uint8_t *)&v12, 0x20u);
  }
  v6 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  objc_msgSend(v6, "setObject:forKey:", kSecClassGenericPassword, kSecClass);
  objc_msgSend(v6, "setObject:forKey:", v4, kSecAttrAccount);
  objc_msgSend(v6, "setObject:forKey:", CFSTR("AirPort"), kSecAttrService);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = SecItemDelete((CFDictionaryRef)v6);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  if (v7 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136315650;
    v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
    v14 = 2112;
    v15 = v4;
    v16 = 1024;
    LODWORD(v17) = v7;
    v8 = "%s:[%@] error result %d \n";
    v9 = 28;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v12, v9);
  }
LABEL_11:

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

uint64_t sub_1000DA83C()
{
  uint64_t result;

  result = qword_10026D748;
  if (!qword_10026D748)
  {
    pthread_once(&stru_10026CCC8, (void (*)(void))sub_1000DA878);
    return qword_10026D748;
  }
  return result;
}

uint64_t sub_1000DA878()
{
  qword_10026D748 = _CFRuntimeRegisterClass(&unk_100231378);
  return notify_register_check("com.apple.wifi.manager.available", &dword_10026CCD8);
}

double sub_1000DA8AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  double result;

  if (a2 && a3)
  {
    if (!qword_10026D748)
      pthread_once(&stru_10026CCC8, (void (*)(void))sub_1000DA878);
    Instance = _CFRuntimeCreateInstance(a1);
    if (Instance)
    {
      result = 0.0;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_QWORD *)(Instance + 16) = a3;
      *(_QWORD *)(Instance + 40) = a2;
    }
  }
  return result;
}

uint64_t sub_1000DA92C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unsigned int v7;
  mach_port_t sp;

  *(_QWORD *)(a1 + 24) = a2;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v5 = 0;
  }
  else
  {
    sp = -1431655766;
    if (bootstrap_check_in(bootstrap_port, *(const char **)(a1 + 40), &sp))
      return 0;
    v6 = sub_100031C7C((uint64_t)kCFAllocatorDefault, 60, sp, 0);
    *(_QWORD *)(a1 + 32) = v6;
    if (!v6)
      return 0;
    v7 = sub_100005830((uint64_t)v6);
    sub_100005AA4(v7, (const void *)a1);
    v4 = *(_QWORD *)(a1 + 32);
    v5 = 1;
  }
  sub_100031C20(v4, a2);
  return v5;
}

uint64_t sub_1000DA9E0(uint64_t a1)
{
  return sub_100031C0C(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1000DA9E8(const __CFString *a1)
{
  if (CFStringCompare(a1, CFSTR("MWS_BT_COEX_ULOFDMA_DISABLE"), 0) == kCFCompareEqualTo)
    return 358;
  if (CFStringCompare(a1, CFSTR("MWS_RC1_COEX_ULOFDMA_DISABLE"), 0) == kCFCompareEqualTo)
    return 519;
  if (CFStringCompare(a1, CFSTR("MWS_RC2_COEX_ULOFDMA_DISABLE"), 0) == kCFCompareEqualTo)
    return 520;
  if (CFStringCompare(a1, CFSTR("MWS_LE_SCAN_PARAM_INFO"), 0) == kCFCompareEqualTo)
    return 521;
  if (CFStringCompare(a1, CFSTR("MWSType7BITMAPWiFiEnh"), 0) == kCFCompareEqualTo)
    return 540;
  if (CFStringCompare(a1, CFSTR("MWSCOEXBITMAPWiFiEnh"), 0) == kCFCompareEqualTo)
    return 541;
  if (CFStringCompare(a1, CFSTR("MWSOCLBITMAPWiFiEnh"), 0) == kCFCompareEqualTo)
    return 542;
  if (CFStringCompare(a1, CFSTR("MWS_RFEM_CONFIG_Enh"), 0) == kCFCompareEqualTo)
    return 543;
  if (CFStringCompare(a1, CFSTR("MWS_ASSOC_PROTECTION_BITMAP_Enh"), 0) == kCFCompareEqualTo)
    return 544;
  if (CFStringCompare(a1, CFSTR("MWS_SCAN_FREQ_Enh"), 0) == kCFCompareEqualTo)
    return 545;
  if (CFStringCompare(a1, CFSTR("MWS_SCAN_FREQ_MODE_Enh"), 0) == kCFCompareEqualTo)
    return 546;
  if (CFStringCompare(a1, CFSTR("MWS_CONDITION_ID_BITMAP_Enh"), 0) == kCFCompareEqualTo)
    return 547;
  if (CFStringCompare(a1, CFSTR("MWS_ANTENNA_SELECTION_Enh"), 0) == kCFCompareEqualTo)
    return 548;
  if (CFStringCompare(a1, CFSTR("MWS_TIME_SHARING_Enh"), 0))
    return 0;
  return 539;
}

uint64_t sub_1000DABC0(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  const __CFString *v12;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v11 = "ON";
          else
            v11 = "OFF";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Manager power %s requested by \"%@\"", v11, sub_1000161D4((uint64_t)v6));
        }
        objc_autoreleasePoolPop(v10);
        v12 = (const __CFString *)sub_1000161D4((uint64_t)v6);
        sub_100093358(v9, a2, v12);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_power(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DACF0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100031A6C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_power(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DADB0(unsigned int a1, unsigned int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  const void *v12;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v11 = "ON";
          else
            v11 = "OFF";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Manager power %s requested by \"%@\"", v11, sub_1000161D4((uint64_t)v6));
        }
        objc_autoreleasePoolPop(v10);
        v12 = (const void *)sub_1000161D4((uint64_t)v6);
        sub_10008F33C(v9, a2, v12);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_power_ext(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DAEE0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100090CA8(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_ask_to_join_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DAFA0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (!v8)
      {
LABEL_12:
        CFRelease(v6);
        return 0;
      }
      *a2 = sub_1000927C0(v8);
      v7 = objc_autoreleasePoolPush();
      v9 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v10 = sub_1000161D4((uint64_t)v6);
        if (*a2)
          v11 = "Associated";
        else
          v11 = "Unassociated";
        objc_msgSend(v9, "WFLog:message:", 3, "NAN Client Assoc state queried by \"%@\" is %s", v10, v11);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_nanclient_assoc_status(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    }
    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }
  return 0;
}

uint64_t sub_1000DB0B0(unsigned int a1, double a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested NAN Off Head Connection expiry of %f seconds ", sub_1000161D4((uint64_t)v6), *(_QWORD *)&a2);
        objc_autoreleasePoolPop(v10);
        sub_10009EFC4(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_nan_off_head_connection_expiry(mach_port_t, double)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DB1C0(unsigned int a1, _QWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  const __CFArray *v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = (const __CFArray *)sub_100016A7C((uint64_t)v6);
      if (!v8)
      {
LABEL_9:
        CFRelease(v6);
        return 0;
      }
      *(double *)a2 = sub_10009F064(v8);
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NAN Off Head Connection expiry queried by \"%@\" is %f", sub_1000161D4((uint64_t)v6), *a2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_nan_off_head_connection_expiry(mach_port_t, double *)", sub_1000161D4((uint64_t)v6));
    }
    objc_autoreleasePoolPop(v7);
    goto LABEL_9;
  }
  return 0;
}

uint64_t sub_1000DB2BC(unsigned int a1, int a2)
{
  uint64_t v4;
  const __CFString *v5;
  const __CFString *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;

  v4 = sub_1000167F8();
  v5 = (const __CFString *)sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v11 = "Enable";
          else
            v11 = "Disable";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s MIS set state requested by \"%@\"", v11, sub_1000161D4((uint64_t)v6));
        }
        objc_autoreleasePoolPop(v10);
        sub_1000921A4(v9, v6, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mis_state(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DB3E4(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (!v8)
      {
LABEL_12:
        CFRelease(v6);
        return 0;
      }
      *a2 = sub_1000923A8(v8);
      v7 = objc_autoreleasePoolPush();
      v9 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v10 = sub_1000161D4((uint64_t)v6);
        if (*a2)
          v11 = "Enable";
        else
          v11 = "Disable";
        objc_msgSend(v9, "WFLog:message:", 3, "MIS state queried by \"%@\" is %s", v10, v11);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mis_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    }
    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }
  return 0;
}

uint64_t sub_1000DB4F4(unsigned int a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, UInt8 *a6, unsigned int a7, UInt8 *a8, unsigned int a9, int a10)
{
  uint64_t v18;
  const __CFString *v19;
  const __CFString *v20;
  void *v21;
  CFPropertyListRef v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  void *v28;
  const char *v29;
  const __CFString *v30;
  int v31;
  _BOOL4 v33;
  CFIndex v35;
  UInt8 *v36;

  v18 = sub_1000167F8();
  v19 = (const __CFString *)sub_10001674C(a1, v18);
  if (v19)
  {
    v20 = v19;
    if ((sub_100016834((uint64_t)v19) & 1) == 0)
    {
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mis_discovery_state(mach_port_t, int, int, int, int, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v20));
      objc_autoreleasePoolPop(v21);
      goto LABEL_6;
    }
    v23 = sub_100016A7C((uint64_t)v20);
    if (!v23)
    {
LABEL_6:
      v22 = v20;
LABEL_28:
      CFRelease(v22);
      return 0;
    }
    v24 = v23;
    v36 = a8;
    v35 = a9;
    v25 = sub_1000161D4((uint64_t)v20);
    if (sub_10006668C(v20))
      v26 = a10 == 8;
    else
      v26 = 0;
    if (v26)
      v27 = 1;
    else
      v27 = a4;
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v29 = "Enable";
      if (!a2)
        v29 = "Disable";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s MIS Discoverability requested by \"%@\" with immediateDisable=%u hidden=%u Force2.4GHz Channel=%u\n", v29, v25, a3, v27, a5, a9, v36);
    }
    objc_autoreleasePoolPop(v28);
    sub_10009287C(v24, a2, v27, a3, v25);
    v30 = (const __CFString *)sub_10001D7D0(a6, a7);
    v22 = sub_10001D7D0(v36, v35);
    if (v30)
    {
      v31 = sub_1000716EC(v30);
      v33 = a10 == 8 || v31 != 0;
      sub_1000923EC(v24, v20, a2, a3, a5, v33);
      CFRelease(v20);
      v20 = v30;
    }
    else
    {
      sub_1000923EC(v24, v20, a2, a3, a5, a10 == 8);
    }
    CFRelease(v20);
    if (v22)
      goto LABEL_28;
  }
  return 0;
}

uint64_t sub_1000DB718(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092804(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mis_discovery_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DB7D8(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v11 = "Enable";
          else
            v11 = "Disable";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s WoW requested by \"%@\"", v11, sub_1000161D4((uint64_t)v6));
        }
        objc_autoreleasePoolPop(v10);
        sub_10000A77C(v9, v6, a2, 2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_wow_state(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DB904(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  __CFDictionary *v11;
  __CFDictionary *v12;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_100092918(v10);
        if (v11)
        {
          v12 = v11;
          sub_100016858(v11, a2, a3);
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_wow_state(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DB9E4(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  unsigned int *v10;
  __CFDictionary *v11;
  __CFDictionary *v12;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = (unsigned int *)sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000ABB0C(v10);
        if (v11)
        {
          v12 = v11;
          sub_100016858(v11, a2, a3);
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mac_randomisation_parameters(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DBAC4(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;

  v8 = sub_1000167F8();
  v9 = (const __CFString *)sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) == 0)
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_privatemac_network_switch_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
      goto LABEL_8;
    }
    v12 = sub_100016A7C((uint64_t)v10);
    if (!v12
      || (v13 = v12,
          v14 = (const __CFString *)sub_10001D7D0(a2, a3),
          *a4 = sub_1000ABD48(v13, v14),
          CFRelease(v10),
          (v10 = v14) != 0))
    {
LABEL_8:
      CFRelease(v10);
    }
  }
  return 0;
}

uint64_t sub_1000DBBBC(unsigned int a1, int a2, _DWORD *a3)
{
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;

  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = (void *)sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v13 = "quiescing";
          else
            v13 = "unquiescing";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi %s requested by \"%@\"", v13, sub_1000161D4((uint64_t)v8));
        }
        objc_autoreleasePoolPop(v12);
        *a3 = sub_100005838(v11, v8, a2);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_quiesce_state(mach_port_t, int, int *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DBCF8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092BEC(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_quiesce_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DBDB8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092DF4(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_wow_capability(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DBE78(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const void *v15;

  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = v12;
        v14 = (void *)sub_10001D7D0(a2, a3);
        if (v14)
        {
          v15 = v14;
          *a4 = sub_10009BBB4(v13, v14);
          CFRelease(v15);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_merge_known_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DBF7C(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092F04(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_tethering_supported(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DC03C(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  id v11;
  const void *v12;
  void *v13;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000ADAF8(v10);
        if (v11)
        {
          v12 = v11;
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:MIS Stats requested by \"%@\"", "_wifi_manager_copy_mis_stats", sub_1000161D4((uint64_t)v8));
          objc_autoreleasePoolPop(v13);
          sub_100016858(v12, a2, a3);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_mis_stats(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DC168(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  void *v5;
  uint64_t v6;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    if ((sub_100016834((uint64_t)v3) & 1) != 0)
    {
      v6 = sub_100016A7C((uint64_t)v4);
      if (!v6)
      {
LABEL_9:
        CFRelease(v4);
        return 0;
      }
      sub_1000ADB84(v6);
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:MIS Stats reset requested by \"%@\"", "_wifi_manager_reset_mis_stats", sub_1000161D4((uint64_t)v4));
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_reset_mis_stats(mach_port_t)", sub_1000161D4((uint64_t)v4));
    }
    objc_autoreleasePoolPop(v5);
    goto LABEL_9;
  }
  return 0;
}

uint64_t sub_1000DC258(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092F8C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_always_on_wifi_supported(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DC318(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  void *v9;
  uint64_t v10;
  __CFDictionary *v11;
  __CFDictionary *v12;
  uint64_t v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = (__CFDictionary *)sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (!v10)
        goto LABEL_9;
      v11 = sub_10009CCE8(v10);
      if (v11)
      {
        v12 = v11;
        sub_100016858(v11, a2, a3);
        CFRelease(v8);
        v8 = v12;
        goto LABEL_9;
      }
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Null localeStatsDict", "_wifi_manager_copy_locale_stats", v14);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_locale_stats(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
    }
    objc_autoreleasePoolPop(v9);
LABEL_9:
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DC42C(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  const __CFString *v15;
  void *v16;

  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = v12;
        v14 = (const __CFString *)sub_10001D7D0(a2, a3);
        if (v14)
        {
          v15 = v14;
          if (!sub_100092FD0(v13, v14))
          {
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set mis password");
            objc_autoreleasePoolPop(v16);
          }
          CFRelease(v15);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_mis_set_password(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
      *a4 = 1;
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DC568(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v14;
  uint64_t v15;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_mis_copy_password(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }
    v10 = sub_100016A7C((uint64_t)v8);
    if (v10)
    {
      v11 = sub_100093058(v10);
      if (!v11)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to copy mis password", v14, v15);
        goto LABEL_10;
      }
      v12 = v11;
      sub_100016858(v11, a2, a3);
      CFRelease(v12);
    }
LABEL_11:
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DC66C(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        sub_1000930C4(v8, a2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_retry_cap(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DC728(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_10009310C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_retry_cap(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DC7E8(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  const __CFString *v16;
  const __CFString *v17;
  CFTypeID v18;
  const __SCPreferences *v19;
  const void *v20;
  const void *v21;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      goto LABEL_17;
    }
    v14 = sub_100016A7C((uint64_t)v12);
    if (!v14 || (v15 = (_QWORD *)v14, (v16 = (const __CFString *)sub_10001D7D0(a2, a3)) == 0))
    {
LABEL_17:
      CFRelease(v12);
      goto LABEL_18;
    }
    v17 = v16;
    v18 = CFGetTypeID(v16);
    if (v18 != CFStringGetTypeID())
      goto LABEL_16;
    if (CFStringCompare(v17, CFSTR("carplayParameters"), 0))
    {
      if (CFStringCompare(v17, CFSTR("HotspotDataUsage"), 0))
      {
        if (CFStringCompare(v17, CFSTR("Custom network settings"), 0))
        {
          v19 = sub_100092D68(v15, v17);
          if (v19)
            sub_100016858(v19, a4, a5);
          goto LABEL_16;
        }
        v20 = sub_1000A60FC(v15);
        if (!v20)
        {
LABEL_16:
          CFRelease(v17);
          goto LABEL_17;
        }
      }
      else
      {
        v20 = (const void *)sub_1000A613C(v15);
        if (!v20)
          goto LABEL_16;
      }
    }
    else
    {
      v20 = sub_1000A0138((uint64_t)v15);
      if (!v20)
        goto LABEL_16;
    }
    v21 = v20;
    sub_100016858(v20, a4, a5);
    CFRelease(v21);
    goto LABEL_16;
  }
LABEL_18:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DC9B8(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  uint64_t v16;
  const __CFArray *v17;
  const __CFString *v18;
  CFPropertyListRef v19;
  void *v20;
  void *v21;
  void *v22;
  const char *v23;
  void *v24;

  *a6 = 0;
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if ((sub_100016834((uint64_t)v13) & 1) == 0)
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
      objc_autoreleasePoolPop(v15);
      *a6 = 1;
      goto LABEL_36;
    }
    v16 = sub_100016A7C((uint64_t)v14);
    if (!v16)
    {
LABEL_36:
      CFRelease(v14);
      goto LABEL_37;
    }
    v17 = (const __CFArray *)v16;
    v18 = (const __CFString *)sub_10001D7D0(a2, a3);
    v19 = sub_10001D7D0(a4, a5);
    if (!v18)
    {
LABEL_34:
      if (v19)
        CFRelease(v19);
      goto LABEL_36;
    }
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ManagerClient[\"%@\"] setProperty[\"%@\"] = %@", sub_1000161D4((uint64_t)v14), v18, v19);
    objc_autoreleasePoolPop(v20);
    if (CFStringCompare(v18, CFSTR("carplayParameters"), 0))
    {
      if (CFStringCompare(v18, CFSTR("HotspotDataUsage"), 0))
      {
        if (CFStringCompare(v18, CFSTR("FamilyHotspotPreferences"), 0) == kCFCompareEqualTo)
        {
          sub_1000A6014(v17, (uint64_t)v19);
          goto LABEL_27;
        }
        if (CFStringCompare(v18, CFSTR("Custom network settings"), 0) == kCFCompareEqualTo)
        {
          sub_1000A6104((uint64_t)v17, (uint64_t)v19);
          goto LABEL_27;
        }
        if (CFStringCompare(v18, CFSTR("PerpetualWiFiScanEnabled"), 0) == kCFCompareEqualTo)
        {
          sub_1000AD5FC(v17, (const __CFBoolean *)v19);
          goto LABEL_27;
        }
        if (!sub_100093FA0(v17, v18, v19))
        {
          v21 = objc_autoreleasePoolPush();
          v22 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v23 = "Unable to Set Property";
LABEL_22:
            objc_msgSend(v22, "WFLog:message:", 4, v23);
            goto LABEL_23;
          }
          goto LABEL_23;
        }
      }
      else if (!sub_1000A5E68(v17))
      {
        v21 = objc_autoreleasePoolPush();
        v22 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v23 = "Unable to Reset Hotspot Data Usage";
          goto LABEL_22;
        }
LABEL_23:
        objc_autoreleasePoolPop(v21);
      }
    }
    else
    {
      sub_10009FFC4((uint64_t)v17, (const __CFDictionary *)v19);
    }
LABEL_27:
    if (CFStringCompare(v18, CFSTR("IsNewInstall"), 0) == kCFCompareEqualTo)
      sub_100087390((uint64_t)v17);
    if (CFStringCompare(v18, CFSTR("SimulatedHardwareFailureStatus"), 0) == kCFCompareEqualTo)
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Posting hardware failure status in _wifi_manager_set_property");
      objc_autoreleasePoolPop(v24);
      sub_10008A3AC(v17);
    }
    CFRelease(v18);
    goto LABEL_34;
  }
LABEL_37:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000DCCF0(unsigned int a1, int a2, vm_offset_t *a3, mach_msg_type_number_t *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  const __CFArray *v13;
  const __CFArray *v14;
  __CFArray *v15;
  __CFArray *v16;

  *a3 = 0;
  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = a2 ? sub_100090EC4(v12) : sub_100090DA4(v12);
        v14 = v13;
        if (v13)
        {
          v15 = sub_1000173D8(v13);
          if (v15)
          {
            v16 = v15;
            sub_100016858(v15, a3, a4);
            CFRelease(v16);
          }
          CFRelease(v14);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_networks(mach_port_t, int, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  return 0;
}

uint64_t sub_1000DCE00(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;
  void *v13;
  void *v14;
  void *v15;
  const void *v16;
  const __CFString *v17;
  const __CFString *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = sub_1000DCFD4(a2, a3);
        if (v12)
        {
          v13 = v12;
          v14 = objc_autoreleasePoolPush();
          v15 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v16 = sub_10002B088(v13);
            objc_msgSend(v15, "WFLog:message:", 3, "Add network <%@>, requested by \"%@\"", v16, sub_1000161D4((uint64_t)v8));
          }
          objc_autoreleasePoolPop(v14);
          v17 = (const __CFString *)sub_1000161D4((uint64_t)v8);
          if (CFStringCompare(v17, CFSTR("profiled"), 0))
          {
            v18 = (const __CFString *)sub_1000161D4((uint64_t)v8);
            if (CFStringCompare(v18, CFSTR("mobilewifitool"), 0))
            {
              v19 = v11;
              v20 = v13;
              v21 = 1;
            }
            else
            {
              v19 = v11;
              v20 = v13;
              v21 = 23;
            }
            sub_100094420(v19, v20, v21);
          }
          else
          {
            sub_100094420(v11, v13, 17);
            sub_10002C478((uint64_t)v13, CFSTR("UpdateReason"), CFSTR("ProfileAddition"));
            sub_1000ABEAC(v11, v13);
          }
          CFRelease(v13);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

_WORD *sub_1000DCFD4(UInt8 *a1, CFIndex length)
{
  CFPropertyListRef v2;
  const void *v3;
  CFTypeID v4;
  _WORD *v5;

  v2 = sub_10001D7D0(a1, length);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = CFGetTypeID(v2);
  if (v4 == CFDictionaryGetTypeID())
    v5 = sub_10002B314((uint64_t)kCFAllocatorDefault, v3);
  else
    v5 = 0;
  CFRelease(v3);
  return v5;
}

uint64_t sub_1000DD044(unsigned int a1, UInt8 *a2, CFIndex a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  const void *v17;
  const __CFDictionary *v18;
  CFTypeID v19;

  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_100016A7C((uint64_t)v12);
      if (v14)
      {
        v15 = v14;
        v16 = sub_1000DCFD4(a2, a3);
        if (v16)
        {
          v17 = v16;
          v18 = 0;
          if (!a4
            || !a5
            || (v18 = (const __CFDictionary *)sub_10001D7D0(a4, a5),
                v19 = CFGetTypeID(v18),
                v19 == CFDictionaryGetTypeID()))
          {
            sub_100097414(v15, (uint64_t)v12, v17, v18, 0, 0);
          }
          CFRelease(v17);
          if (v18)
            CFRelease(v18);
        }
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_network_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000DD1AC(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;
  void *v13;
  const __CFString *v14;
  void *v15;
  void *v16;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = sub_1000DCFD4(a2, a3);
        if (v12)
        {
          v13 = v12;
          v14 = (const __CFString *)sub_1000161D4((uint64_t)v8);
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Update network <%@>, requested by \"%@\"", sub_10002B088(v13), v14);
          objc_autoreleasePoolPop(v15);
          if (CFStringCompare(v14, CFSTR("configd"), 0) == kCFCompareEqualTo)
          {
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing internal properties from network", "_wifi_manager_update_network");
            objc_autoreleasePoolPop(v16);
            sub_1000CB74C((uint64_t)v13);
          }
          sub_100099EA4(v11, v13, 1u);
          CFRelease(v13);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_update_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DD358(unsigned int a1, UInt8 *a2, CFIndex a3, const void *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  void *v15;
  void *v16;
  void *v17;
  const void *v18;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = v12;
        v14 = sub_1000DCFD4(a2, a3);
        if (v14)
        {
          v15 = v14;
          v16 = objc_autoreleasePoolPush();
          v17 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v18 = sub_10002B088(v15);
            objc_msgSend(v17, "WFLog:message:", 3, "Remove network <%@>, requested by \"%@\"", v18, sub_1000161D4((uint64_t)v10));
          }
          objc_autoreleasePoolPop(v16);
          sub_100098DBC(v13, v15, a4);
          CFRelease(v15);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DD4B4(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const __CFString *v7;
  const __CFString *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFString *v13;
  CFTypeID v14;

  v6 = sub_1000167F8();
  v7 = (const __CFString *)sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = (const __CFString *)sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          v14 = CFGetTypeID(v12);
          if (v14 == CFStringGetTypeID())
            sub_10009AF34(v11, v13);
          CFRelease(v8);
          v8 = v13;
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_networks_with_bundle_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DD5C4(unsigned int a1, UInt8 *a2, unsigned int a3, unsigned __int8 a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  const __CFString *v15;
  CFTypeID v16;
  __CFArray *v17;
  const __CFArray *v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex i;
  void *ValueAtIndex;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = v12;
        v14 = (const __CFString *)sub_10001D7D0(a2, a3);
        if (v14)
        {
          v15 = v14;
          v16 = CFGetTypeID(v14);
          if (v16 == CFStringGetTypeID())
          {
            v17 = sub_100090CB8(v13, v15);
            if (v17)
            {
              v18 = v17;
              Count = CFArrayGetCount(v17);
              if (Count >= 1)
              {
                v20 = Count;
                for (i = 0; i != v20; ++i)
                {
                  ValueAtIndex = (void *)CFArrayGetValueAtIndex(v18, i);
                  if (ValueAtIndex)
                    sub_10009B080(v13, ValueAtIndex, a4, 0);
                }
              }
              CFRelease(v18);
            }
          }
          CFRelease(v15);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_networks_state_with_bundle_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DD73C(unsigned int a1, UInt8 *a2, CFIndex a3, int a4, char a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  void *v17;
  void *v18;
  const char *v19;
  const void *v20;

  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_network_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      goto LABEL_17;
    }
    v14 = sub_100016A7C((uint64_t)v12);
    if (!v14 || (v15 = v14, (v16 = sub_1000DCFD4(a2, a3)) == 0))
    {
LABEL_17:
      CFRelease(v12);
      goto LABEL_18;
    }
    v17 = v16;
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (a4)
        v19 = "ENABLED";
      else
        v19 = "DISABLED";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Auto join %s by \"%@\" for %@", v19, sub_1000161D4((uint64_t)v12), v17);
    }
    objc_autoreleasePoolPop(v18);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100187580(a4, (uint64_t)v12, (uint64_t)v17);
      if (a4)
        goto LABEL_16;
    }
    else if (a4)
    {
LABEL_16:
      sub_10009B080(v15, v17, a4, a5);
      CFRelease(v17);
      goto LABEL_17;
    }
    v20 = (const void *)sub_1000161D4((uint64_t)v12);
    sub_10002C478((uint64_t)v17, CFSTR("networkDisabledClientName"), v20);
    goto LABEL_16;
  }
LABEL_18:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DD8FC(unsigned int a1, UInt8 *a2, CFIndex a3, _DWORD *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  const void *v15;

  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_100016A7C((uint64_t)v10);
      if (v12)
      {
        v13 = v12;
        v14 = sub_1000DCFD4(a2, a3);
        if (v14)
        {
          v15 = v14;
          *a4 = sub_10009B224(v13, v14);
          CFRelease(v15);
        }
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_network_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DDA00(unsigned int a1, uint64_t a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  CFPropertyListRef v16;
  const void *v17;
  CFTypeID v18;

  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_indicate_carplay_hid_event_received(mach_port_t, int, int, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      goto LABEL_12;
    }
    v14 = sub_100016A7C((uint64_t)v12);
    if (v14)
    {
      v15 = v14;
      v16 = sub_10001D7D0(a4, a5);
      if (v16)
      {
        v17 = v16;
        v18 = CFGetTypeID(v16);
        if (v18 == CFStringGetTypeID())
        {
          sub_1000940E8(v15, a2, a3, (uint64_t)v17);
          CFRelease(v17);
          goto LABEL_12;
        }
        CFRelease(v17);
      }
      sub_1000940E8(v15, a2, a3, 0);
    }
LABEL_12:
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000DDB44(unsigned int a1, uint64_t a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  CFPropertyListRef v16;
  const void *v17;
  CFTypeID v18;

  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_dispatch_notification_response(mach_port_t, int, int, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      goto LABEL_12;
    }
    v14 = sub_100016A7C((uint64_t)v12);
    if (v14)
    {
      v15 = v14;
      v16 = sub_10001D7D0(a4, a5);
      if (v16)
      {
        v17 = v16;
        v18 = CFGetTypeID(v16);
        if (v18 == CFDictionaryGetTypeID())
        {
          sub_100093FF8(v15, a2, a3, v17);
          CFRelease(v17);
          goto LABEL_12;
        }
        CFRelease(v17);
      }
      sub_100093FF8(v15, a2, a3, 0);
    }
LABEL_12:
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000DDC88(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (!v8)
      {
LABEL_17:
        CFRelease(v6);
        return 0;
      }
      v9 = v8;
      if (a2)
      {
        sub_1000066D8(v8, v6);
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          sub_100007F68(v9, 15);
        else
          sub_100090860(v9, 2);
      }
      else
      {
        sub_100093F3C(v8, v6);
      }
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (a2)
          v10 = "ENABLED";
        else
          v10 = "DISABLED";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto join %s by \"%@\"", v10, sub_1000161D4((uint64_t)v6));
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_enable_state(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
    }
    objc_autoreleasePoolPop(v7);
    goto LABEL_17;
  }
  return 0;
}

uint64_t sub_1000DDDE0(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested association mode %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_100091214(v9, a2, 0);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_association_mode(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DDEF0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 1;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100091C34(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_association_mode(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DDFB4(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested ask-to-join preference %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_100091C3C(v9, a2, 0);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_asktojoin_preference(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DE0C8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 1;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100091D64(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_asktojoin_preference(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DE18C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  CFPropertyListRef v12;
  void *v13;
  CFTypeID v14;
  __CFArray *v15;
  __CFArray *v16;
  __CFArray *v17;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = (void *)v12;
          v14 = CFGetTypeID(v12);
          if (v14 == CFArrayGetTypeID() && (v15 = sub_100064608((const __CFArray *)v13)) != 0)
          {
            v16 = v15;
            sub_100005B68(v11, v15);
            CFRelease(v13);
            v17 = v16;
          }
          else
          {
            v17 = (__CFArray *)v13;
          }
          CFRelease(v17);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_background_scan_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DE2B8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092E7C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_bgscancache_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DE378(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_10009CEC4(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_bgscan_cache_state(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DE470(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  const char *v13;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        v11 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v12 = sub_1000161D4((uint64_t)v6);
          v13 = "enabled";
          if (!a2)
            v13 = "disabled";
          objc_msgSend(v11, "WFLog:message:", 3, "%@ requested scan backoff reporting to be %s", v12, v13);
        }
        objc_autoreleasePoolPop(v10);
        sub_10009CF0C(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_scan_backoff_report(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000DE594(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_10009DBE4(v10, v12);
          CFRelease(v13);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_test_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DE68C(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  void *v13;
  id v14;
  const __CFDictionary *v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *v18;
  void *v19;
  void *v20;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = (const __CFDictionary *)sub_10001674C(a1, v10);
  if (!v11)
  {
    v14 = objc_msgSend(objc_alloc((Class)NSNumber), "initWithBool:", 0);
    if (!v14)
      goto LABEL_16;
    goto LABEL_15;
  }
  v12 = v11;
  if ((sub_100016834((uint64_t)v11) & 1) == 0)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_test_params(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
LABEL_5:
    objc_autoreleasePoolPop(v13);
    v14 = objc_msgSend(objc_alloc((Class)NSNumber), "initWithBool:", 0);
    v15 = v12;
LABEL_13:
    CFRelease(v15);
    goto LABEL_14;
  }
  v16 = sub_100016A7C((uint64_t)v12);
  if (!v16)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find manager for client %@", "_wifi_manager_copy_test_params", sub_1000161D4((uint64_t)v12));
    goto LABEL_5;
  }
  v17 = v16;
  v18 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling WiFiManagerSetTestParamsAndCopyResponse with request:%@", "_wifi_manager_copy_test_params", v18);
  objc_autoreleasePoolPop(v19);
  v20 = sub_10009DF50(v17, v18);
  v14 = v20;
  if (v20)
    sub_100016858(v20, a4, a5);
  CFRelease(v12);
  if (v18)
  {
    v15 = v18;
    goto LABEL_13;
  }
LABEL_14:
  if (v14)
LABEL_15:
    CFRelease(v14);
LABEL_16:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DE870(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFStringRef v10;
  CFStringRef v11;
  uint64_t v13;
  uint64_t v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_version_info(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }
    if (sub_100016A7C((uint64_t)v8))
    {
      v10 = sub_10009C990();
      if (!v10)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to copy client names", v13, v14);
        goto LABEL_10;
      }
      v11 = v10;
      sub_100016858(v10, a2, a3);
      CFRelease(v11);
    }
LABEL_11:
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DE974(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  CFMutableArrayRef v11;
  CFMutableArrayRef v12;
  uint64_t v14;
  uint64_t v15;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_client_names(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }
    v10 = sub_100016A7C((uint64_t)v8);
    if (v10)
    {
      v11 = sub_10009CA08(v10);
      if (!v11)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to copy client names", v14, v15);
        goto LABEL_10;
      }
      v12 = v11;
      sub_100016858(v11, a2, a3);
      CFRelease(v12);
    }
LABEL_11:
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000DEA78(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  CFPropertyListRef v19;
  CFPropertyListRef v20;
  const void *v21;
  uint64_t *v22;
  uint64_t *v23;
  void *v24;
  unsigned int v26;
  UInt8 *v27;

  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) == 0)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
LABEL_18:
      CFRelease(v16);
      goto LABEL_19;
    }
    v26 = a3;
    v27 = a2;
    v18 = sub_10001D7D0(a2, a3);
    v19 = sub_10001D7D0(a4, a5);
    v20 = sub_10001D7D0(a6, a7);
    v21 = v20;
    if (v18 && v19 && v20)
    {
      v22 = (uint64_t *)sub_10001683C((uint64_t)v16, v18);
      if (v22)
      {
        v23 = v22;
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DeviceClient[\"%@\"] setProperty[\"%@\"] = %@", sub_1000161D4((uint64_t)v16), v19, v21);
        objc_autoreleasePoolPop(v24);
        sub_1001234E8(v23, v18, v19, v21);
      }
    }
    else if (!v18)
    {
      goto LABEL_14;
    }
    CFRelease(v18);
LABEL_14:
    if (v21)
      CFRelease(v21);
    a2 = v27;
    a3 = v26;
    if (v19)
      CFRelease(v19);
    goto LABEL_18;
  }
LABEL_19:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  sub_10001D7AC((vm_address_t)a6, a7);
  return 0;
}

uint64_t sub_1000DEC70(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFPropertyListRef v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  void *v14;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_10001D7D0(a2, a3);
      if (v10)
      {
        v11 = v10;
        v12 = sub_10001683C((uint64_t)v8, v10);
        if (v12)
        {
          v13 = (uint64_t)v12;
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation requested by \"%@\"", sub_1000161D4((uint64_t)v8));
          objc_autoreleasePoolPop(v14);
          sub_1000F7F48(v13, v11, 1001, "_wifi_device_disassociate", 2902);
        }
        CFRelease(v11);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_disassociate(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DEDC4(unsigned int a1, UInt8 *a2, unsigned int a3, int a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;
  const void *v14;
  uint64_t v15;
  void *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_10001D7D0(a2, a3);
      if (v12)
      {
        v13 = v12;
        v14 = sub_10001683C((uint64_t)v10, v12);
        if (v14)
        {
          v15 = (uint64_t)v14;
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation requested by \"%@\"", sub_1000161D4((uint64_t)v10));
          objc_autoreleasePoolPop(v16);
          if (a4 == 2)
            v17 = 1015;
          else
            v17 = 1001;
          if (a4 == 1)
            v18 = 1011;
          else
            v18 = v17;
          sub_1000F7F48(v15, v13, v18, "_wifi_device_disassociate_with_reason", 2948);
        }
        CFRelease(v13);
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_disassociate_with_reason(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DEF34(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  CFPropertyListRef v16;
  CFPropertyListRef v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const __CFData *v21;
  const __CFData *v22;
  void *v23;
  int v24;
  int v25;
  const void *v26;
  const void *v27;
  _BOOL4 v28;
  WiFiFindAndJoinRequest *v29;
  WiFiFindAndJoinRequest *v30;
  uint64_t v31;
  void *v32;
  const __CFString *v33;
  void *v34;
  const __CFData *v35;
  const void *v37;
  const void *v38;
  _QWORD v39[8];

  *a6 = 0;
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if ((sub_100016834((uint64_t)v13) & 1) == 0)
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_assoc_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
      objc_autoreleasePoolPop(v15);
      *a6 = 1;
      goto LABEL_35;
    }
    v16 = sub_10001D7D0(a2, a3);
    v17 = sub_10001D7D0(a4, a5);
    v18 = v17;
    if (!v16 || !v17)
    {
      if (v16)
        CFRelease(v16);
      if (!v18)
        goto LABEL_35;
      goto LABEL_34;
    }
    v19 = sub_10001683C((uint64_t)v14, v16);
    if (!v19 || (v20 = v19, (v21 = (const __CFData *)sub_10002B314((uint64_t)kCFAllocatorDefault, v18)) == 0))
    {
      v35 = (const __CFData *)v16;
      goto LABEL_33;
    }
    v22 = v21;
    v38 = v18;
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Async association requested by \"%@\"", sub_1000161D4((uint64_t)v14));
    objc_autoreleasePoolPop(v23);
    v24 = sub_100016A8C((uint64_t)v14);
    if ((v24 & 2) != 0)
    {
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Already associating, will not queue request. ");
      objc_autoreleasePoolPop(v32);
      sub_1000653EC((uint64_t)v14, v20, (const __CFData *)v16, v22, 0, 37);
      goto LABEL_32;
    }
    v25 = v24;
    sub_100016A84((uint64_t)v14, v24 | 2);
    sub_1000FB44C((uint64_t)v20);
    sub_1000FB408((uint64_t)v20);
    if (sub_1000161D4((uint64_t)v14))
    {
      v26 = (const void *)sub_1000161D4((uint64_t)v14);
      if (CFEqual(v26, CFSTR("HPSetup"))
        || (v27 = (const void *)sub_1000161D4((uint64_t)v14), CFEqual(v27, CFSTR("sharingd"))))
      {
        v28 = 1;
      }
      else
      {
        v37 = (const void *)sub_1000161D4((uint64_t)v14);
        v28 = CFEqual(v37, CFSTR("mobilewifitool")) != 0;
      }
      if (_os_feature_enabled_impl("WiFiManager", "FindAndJoinNetworkAPI") && v28)
      {
        v29 = -[WiFiFindAndJoinRequest initWithNetworkName:]([WiFiFindAndJoinRequest alloc], "initWithNetworkName:", sub_10002B088(v22));
        if (!v29)
        {
          v31 = 4294963395;
          goto LABEL_29;
        }
        v30 = v29;
        -[WiFiFindAndJoinRequest setChannelNumber:](v29, "setChannelNumber:", sub_100017A54((uint64_t)v22, CFSTR("CHANNEL")));
        -[WiFiFindAndJoinRequest setTimeout:](v30, "setTimeout:", 60.0);
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 3221225472;
        v39[2] = sub_1000DF344;
        v39[3] = &unk_100231358;
        v39[4] = v30;
        v39[5] = v20;
        v39[6] = v16;
        v39[7] = v14;
        if (!-[WiFiFindAndJoinRequest runAsynchronouslyOnQueue:onInterface:withReply:](v30, "runAsynchronouslyOnQueue:onInterface:withReply:", sub_10011AF9C((uint64_t)v20), v16, v39))
        {
          v31 = 4294963396;
LABEL_29:
          v34 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error returned by Associate Async %d", v31);
          objc_autoreleasePoolPop(v34);
          sub_100016A84((uint64_t)v14, v25 & 0xFFFFFFFD);
          goto LABEL_32;
        }
LABEL_27:
        CFRetain(v14);
LABEL_32:
        v18 = v38;
        CFRelease(v16);
        v35 = v22;
LABEL_33:
        CFRelease(v35);
LABEL_34:
        CFRelease(v18);
LABEL_35:
        CFRelease(v14);
        goto LABEL_36;
      }
    }
    else
    {
      _os_feature_enabled_impl("WiFiManager", "FindAndJoinNetworkAPI");
    }
    v33 = (const __CFString *)sub_1000161D4((uint64_t)v14);
    v31 = sub_10010AD4C((uint64_t)v20, v16, v22, 0, v33, (uint64_t)sub_1000DF410, (uint64_t)v14, 1008);
    if ((_DWORD)v31)
      goto LABEL_29;
    goto LABEL_27;
  }
LABEL_36:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_1000DF344(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  const __CFData *v7;

  if (a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error returned by WiFiFindAndJoinRequest %@", a3);
    objc_autoreleasePoolPop(v5);
    v6 = 4294963353;
  }
  else
  {
    v6 = 0;
  }
  if (objc_msgSend(*(id *)(a1 + 32), "joinedNetwork"))
    v7 = (const __CFData *)sub_1000CE200(objc_msgSend(*(id *)(a1 + 32), "joinedNetwork"));
  else
    v7 = 0;
  sub_1000DF410(*(const void **)(a1 + 40), *(const __CFData **)(a1 + 48), v7, 0, v6, *(const void **)(a1 + 56));
  if (v7)
    CFRelease(v7);
}

void sub_1000DF410(const void *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, uint64_t a5, const void *a6)
{
  int v12;
  void *v13;

  v12 = sub_100016A8C((uint64_t)a6);
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Async association request completed for \"%@\" (%d)", sub_1000161D4((uint64_t)a6), a5);
  objc_autoreleasePoolPop(v13);
  sub_1000FB2E0((uint64_t)a1);
  sub_1000653EC((uint64_t)a6, a1, a2, a3, a4, a5);
  sub_100016A84((uint64_t)a6, v12 & 0xFFFFFFFD);
  if (a6)
  {
    if ((v12 & 2) != 0)
      CFRelease(a6);
  }
}

uint64_t sub_1000DF510(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFPropertyListRef v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;

  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_10001D7D0(a2, a3);
      if (v14)
      {
        v15 = v14;
        v16 = sub_10001683C((uint64_t)v12, v14);
        if (v16)
        {
          v17 = (uint64_t)v16;
          v18 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            if ((_DWORD)a4)
              v19 = "ON";
            else
              v19 = "OFF";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device power %s requested by \"%@\"", v19, sub_1000161D4((uint64_t)v12));
          }
          objc_autoreleasePoolPop(v18);
          v20 = sub_100108F0C(v17, v15, a4);
          if ((_DWORD)v20)
          {
            v21 = v20;
            v22 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set power state(%d) to %d. deviceManager=%p", v21, a4, v17);
            objc_autoreleasePoolPop(v22);
          }
        }
        CFRelease(v15);
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_power(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      *a5 = 1;
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000DF6C4(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, UInt8 *a5, unsigned int a6, _DWORD *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  const __CFString *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  void *v21;
  int v22;
  int v23;
  const __CFArray *v24;
  const __CFArray *v25;
  CFIndex v26;
  const void *ValueAtIndex;
  uint64_t v28;
  char *v29;
  void *v30;
  const void *v31;
  void *v32;
  void *v33;
  const __CFString *v34;
  CFComparisonResult v35;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v37;
  CFDictionaryRef Copy;
  void *v39;
  const void *v40;
  int v41;
  void *v42;
  void *v44;
  uint64_t v45;
  unsigned int v46;
  UInt8 *v47;
  const __CFDictionary *theDict;
  char *v49;

  *a7 = 0;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (!v15)
  {
    *a7 = 74;
    goto LABEL_53;
  }
  v16 = v15;
  if ((sub_100016834((uint64_t)v15) & 1) != 0)
  {
    v18 = (const __CFString *)sub_10001D7D0(a2, a3);
    v19 = (const __CFDictionary *)sub_10001D7D0(a5, a6);
    v20 = v19;
    if (!v18 || (_DWORD)a4 != 4 && !v19)
    {
      *a7 = 72;
      goto LABEL_48;
    }
    v49 = (char *)sub_10001683C((uint64_t)v16, v18);
    if (v49)
    {
      theDict = v20;
      if ((_DWORD)a4 == 4)
      {
        kdebug_trace(731381784, 0, 0, 0, 0);
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "\"%@\" starting AWDL", sub_1000161D4((uint64_t)v16), v45);
      }
      else
      {
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "\"%@\" starting network role (%d)", sub_1000161D4((uint64_t)v16), a4);
      }
      objc_autoreleasePoolPop(v21);
      v22 = sub_100016A8C((uint64_t)v16);
      if ((v22 & 8) == 0)
      {
        v23 = v22;
        v46 = a6;
        v47 = a5;
        v24 = (const __CFArray *)sub_100032320((uint64_t)v16);
        if (v24)
        {
          v25 = v24;
          if (CFArrayGetCount(v24))
          {
            if (CFArrayGetCount(v25) >= 1)
            {
              v26 = 0;
              while (1)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v25, v26);
                if (ValueAtIndex)
                {
                  v28 = (uint64_t)ValueAtIndex;
                  if (sub_100017A54((uint64_t)ValueAtIndex, CFSTR("networkRole")) == (const __CFNumber *)(int)a4)
                    break;
                }
                if (++v26 >= CFArrayGetCount(v25))
                  goto LABEL_23;
              }
              v44 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client %@ has already brought up network of role %ld", "_wifi_device_start_network", sub_1000161D4((uint64_t)v16), (int)a4);
              objc_autoreleasePoolPop(v44);
              sub_1000655D0((uint64_t)v16, (uint64_t)v49, v18, 37, v28, 0);
              a5 = v47;
              v20 = theDict;
              a6 = v46;
LABEL_48:
              if (!v18)
                goto LABEL_50;
              goto LABEL_49;
            }
          }
        }
LABEL_23:
        sub_100016A84((uint64_t)v16, v23 | 8);
        v29 = v49;
        if ((a4 & 0xFFFFFFFE) == 2)
        {
          v30 = sub_1000169FC((uint64_t)v49, v18);
          if (v30)
          {
            v31 = v30;
            if (!sub_100107828((uint64_t)v49, 4))
            {
              v32 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enabling SoftAP. Now disconnecting from %@", sub_10002B088(v31));
              objc_autoreleasePoolPop(v32);
              v29 = v49;
              sub_1000F7F48((uint64_t)v49, v18, 1007, "_wifi_device_start_network", 3555);
            }
            CFRelease(v31);
          }
          else
          {
            sub_1000FB44C((uint64_t)v49);
          }
        }
        v34 = (const __CFString *)sub_1000161D4((uint64_t)v16);
        if (v34)
        {
          v35 = CFStringCompare(v34, CFSTR("matd"), 1uLL);
          v20 = theDict;
          if (theDict && v35 == kCFCompareEqualTo)
          {
            MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
            if (!MutableCopy)
            {
LABEL_47:
              a5 = v47;
              a6 = v46;
              goto LABEL_48;
            }
            v37 = MutableCopy;
            CFRelease(theDict);
            CFDictionarySetValue(v37, CFSTR("AP_MODE_MOVETOIOS_MIGRATION"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1));
            Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v37);
            CFRelease(v37);
            v39 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION:%s Request  Dict : %@ ", "_wifi_device_start_network", Copy);
            objc_autoreleasePoolPop(v39);
            v20 = Copy;
            v29 = v49;
          }
        }
        else
        {
          v20 = theDict;
        }
        v40 = (const void *)sub_1000161D4((uint64_t)v16);
        v41 = sub_10010F0C0((uint64_t)v29, v18, a4, v20, (uint64_t)sub_1000DFC8C, (uint64_t)v16, v40);
        *a7 = v41;
        if (!v41 || (sub_100016A84((uint64_t)v16, v23 & 0xFFFFFFF7), !*a7))
        {
          if ((a4 & 0xFFFFFFFE) == 2)
          {
            v42 = (void *)sub_1000161D4((uint64_t)v16);
            sub_10010806C((uint64_t)v29, 1, 0, 0, v42);
            sub_1001074B0((uint64_t)v29, 1);
            sub_1000F9DAC(v29, 4, 1);
          }
          CFRetain(v16);
        }
        goto LABEL_47;
      }
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client %@ has already requested hosted network.", "_wifi_device_start_network", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v33);
      sub_1000655D0((uint64_t)v16, (uint64_t)v49, v18, 37, 0, 0);
    }
    else
    {
      *a7 = 74;
    }
LABEL_49:
    CFRelease(v18);
LABEL_50:
    if (v20)
      CFRelease(v20);
    goto LABEL_52;
  }
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_start_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v16));
  objc_autoreleasePoolPop(v17);
  *a7 = 1;
LABEL_52:
  CFRelease(v16);
LABEL_53:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a5, a6);
  return 0;
}

void sub_1000DFC8C(char *a1, const void *a2, uint64_t a3, const void *a4, const __CFData *a5, const void *a6)
{
  int v12;
  void *v13;
  void *v14;
  const __CFArray *v15;
  __CFArray *MutableCopy;
  const __CFArray *v17;

  if (a6)
    v12 = sub_100016A8C((uint64_t)a6) & 0xFFFFFFF7;
  else
    v12 = 0;
  v13 = objc_autoreleasePoolPush();
  if ((_DWORD)a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Failed to start network requested by \"%@\", %d", sub_1000161D4((uint64_t)a6), a3);
    objc_autoreleasePoolPop(v13);
    if (a4 && ((unint64_t)sub_100017A54((uint64_t)a4, CFSTR("networkRole")) & 0xFFFFFFFFFFFFFFFELL) == 2)
    {
      v14 = (void *)sub_1000161D4((uint64_t)a6);
      sub_10010806C((uint64_t)a1, 0, 0, 0, v14);
      sub_1001074B0((uint64_t)a1, 0);
      sub_1000F9DAC(a1, 4, 0);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Started network \"%@\" requested by %@\"", a4, sub_1000161D4((uint64_t)a6));
    objc_autoreleasePoolPop(v13);
    v15 = (const __CFArray *)sub_100032320((uint64_t)a6);
    if (v15)
    {
      MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v15);
      if (MutableCopy)
      {
        v17 = MutableCopy;
        CFArrayAppendValue(MutableCopy, a4);
        sub_100065130((uint64_t)a6, v17);
        CFRelease(v17);
      }
      else
      {
        sub_100065130((uint64_t)a6, 0);
      }
    }
  }
  sub_100016A84((uint64_t)a6, v12);
  sub_1000655D0((uint64_t)a6, (uint64_t)a1, a2, a3, (uint64_t)a4, a5);
  if (a6)
    CFRelease(a6);
}

uint64_t sub_1000DFE78(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, int *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  CFPropertyListRef v16;
  CFPropertyListRef v17;
  const void *v18;
  char *v19;
  char *v20;
  _WORD *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  const __CFArray *v26;
  const __CFArray *v27;
  CFIndex v28;
  const void *ValueAtIndex;
  const void *v30;
  const __CFNumber *v31;
  int v32;
  void *v33;
  void *v35;
  __CFArray *MutableCopy;
  const __CFArray *v37;
  int v38;
  const void *v39;
  void *v40;
  void *context;
  UInt8 *v42;
  UInt8 *v43;
  unsigned int v44;
  unsigned int v45;

  *a6 = 0;
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (!v13)
  {
    *a6 = 74;
    goto LABEL_30;
  }
  v14 = v13;
  if ((sub_100016834((uint64_t)v13) & 1) != 0)
  {
    v45 = a3;
    v16 = sub_10001D7D0(a2, a3);
    v17 = sub_10001D7D0(a4, a5);
    v18 = v17;
    if (!v16 || !v17)
    {
      v22 = 0;
      *a6 = 72;
      if (!v16)
        goto LABEL_25;
      goto LABEL_24;
    }
    v43 = a2;
    v44 = a5;
    v19 = (char *)sub_10001683C((uint64_t)v14, v16);
    if (v19)
    {
      v20 = v19;
      v21 = sub_10002B314((uint64_t)kCFAllocatorDefault, v18);
      if (v21)
      {
        v22 = v21;
        v42 = a4;
        v23 = objc_autoreleasePoolPush();
        v24 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v25 = sub_1000161D4((uint64_t)v14);
          objc_msgSend(v24, "WFLog:message:", 3, "\"%@\" stopping network \"%@\"", v25, sub_10002B088(v22));
        }
        objc_autoreleasePoolPop(v23);
        v26 = (const __CFArray *)sub_100032320((uint64_t)v14);
        if (v26 && (v27 = v26, CFArrayGetCount(v26) >= 1))
        {
          v28 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v27, v28);
            if (ValueAtIndex)
            {
              v30 = ValueAtIndex;
              if (CFEqual(ValueAtIndex, v22))
                break;
            }
            if (++v28 >= CFArrayGetCount(v27))
              goto LABEL_18;
          }
          v35 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v40 = (void *)qword_10026DD20;
            context = v35;
            v39 = sub_10002B088(v30);
            objc_msgSend(v40, "WFLog:message:", 3, "%s: removing network %@ for client %@ started network list.", "_wifi_device_stop_network", v39, sub_1000161D4((uint64_t)v14));
            v35 = context;
          }
          objc_autoreleasePoolPop(v35);
          v31 = sub_100017A54((uint64_t)v30, CFSTR("networkRole"));
          MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v27);
          if (MutableCopy)
          {
            v37 = MutableCopy;
            CFArrayRemoveValueAtIndex(MutableCopy, v28);
            sub_100065130((uint64_t)v14, v37);
            CFRelease(v37);
          }
          else
          {
            sub_100065130((uint64_t)v14, 0);
          }
        }
        else
        {
LABEL_18:
          v31 = 0;
        }
        v32 = sub_10010FABC((uint64_t)v20, v16, v22, (uint64_t)sub_1000E0220, (uint64_t)v14);
        *a6 = v32;
        a4 = v42;
        if (!v32)
        {
          if (((unint64_t)v31 & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            v33 = (void *)sub_1000161D4((uint64_t)v14);
            sub_10010806C((uint64_t)v20, 0, 0, 0, v33);
            sub_1001074B0((uint64_t)v20, 0);
            sub_1000F9DAC(v20, 4, 0);
          }
          CFRetain(v14);
        }
        a5 = v44;
        a2 = v43;
        goto LABEL_24;
      }
      v38 = 72;
    }
    else
    {
      v38 = 74;
    }
    v22 = 0;
    *a6 = v38;
    a2 = v43;
LABEL_24:
    CFRelease(v16);
LABEL_25:
    if (v22)
      CFRelease(v22);
    a3 = v45;
    if (v18)
      CFRelease(v18);
    goto LABEL_29;
  }
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_stop_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
  objc_autoreleasePoolPop(v15);
  *a6 = 1;
LABEL_29:
  CFRelease(v14);
LABEL_30:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_1000E0220(uint64_t a1, const void *a2, int a3, const __CFData *a4, const void *a5)
{
  sub_100065760((uint64_t)a5, a1, a2, a3, a4);
  if (a5)
    CFRelease(a5);
}

uint64_t sub_1000E0268(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, vm_offset_t *a5, mach_msg_type_number_t *a6, int *a7)
{
  uint64_t v13;
  const void *v14;
  const void *v15;
  void *v16;
  const __CFString *v17;
  const __CFString *v18;
  const void *v19;
  __CFDictionary *v20;
  __CFDictionary *v21;
  const __CFString *v22;
  int v24;

  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  v13 = sub_1000167F8();
  v14 = sub_10001674C(a1, v13);
  if (!v14)
  {
    *a7 = 74;
    goto LABEL_12;
  }
  v15 = v14;
  if ((sub_100016834((uint64_t)v14) & 1) == 0)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_interface_state_info(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_1000161D4((uint64_t)v15));
    objc_autoreleasePoolPop(v16);
    *a7 = 1;
    goto LABEL_11;
  }
  v17 = (const __CFString *)sub_10001D7D0(a2, a3);
  if (v17)
  {
    v18 = v17;
    v19 = sub_10001683C((uint64_t)v15, v17);
    if (v19)
    {
      v20 = sub_100109D00((uint64_t)v19, v18);
      if (v20)
      {
        v21 = v20;
        sub_100016858(v20, a5, a6);
        CFRelease(v18);
        v22 = (const __CFString *)v21;
LABEL_10:
        CFRelease(v22);
        goto LABEL_11;
      }
      v24 = 5;
    }
    else
    {
      v24 = 74;
    }
    *a7 = v24;
    v22 = v18;
    goto LABEL_10;
  }
LABEL_11:
  CFRelease(v15);
LABEL_12:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E03C4(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, vm_offset_t *a5, mach_msg_type_number_t *a6, int *a7)
{
  uint64_t v13;
  const void *v14;
  const void *v15;
  void *v16;
  __CFArray *v17;
  __CFArray *v18;
  const void *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v24;
  const __CFNumber *v25;
  _QWORD *v26;
  CFDictionaryRef v27;
  void *v28;
  __CFArray *v29;
  __CFArray *v30;
  int v32;
  uint64_t v33;
  mach_msg_type_number_t *v34;
  unsigned int v35;
  UInt8 *v36;

  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  v13 = sub_1000167F8();
  v14 = sub_10001674C(a1, v13);
  if (!v14)
  {
    *a7 = 74;
    goto LABEL_28;
  }
  v15 = v14;
  if ((sub_100016834((uint64_t)v14) & 1) == 0)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_1000161D4((uint64_t)v15));
    objc_autoreleasePoolPop(v16);
    *a7 = 1;
    goto LABEL_27;
  }
  v17 = (__CFArray *)sub_10001D7D0(a2, a3);
  if (v17)
  {
    v18 = v17;
    v19 = sub_10001683C((uint64_t)v15, v17);
    if (v19)
    {
      v20 = sub_100109C30((uint64_t)v19);
      v21 = v20;
      if (v20)
      {
        v34 = a6;
        v35 = a3;
        v36 = a2;
        if (CFArrayGetCount(v20) >= 1)
        {
          for (i = 0; i < CFArrayGetCount(v21); ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v21, i);
            if (ValueAtIndex)
            {
              v24 = ValueAtIndex;
              v25 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("networkRole"));
              if ((v25 & 0xFFFFFFFE) == 2)
              {
                v26 = (_QWORD *)sub_100016A7C((uint64_t)v15);
                v27 = sub_1000A6010(v26);
                v28 = objc_autoreleasePoolPush();
                if (v27)
                {
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: attaching interface data usage to %@", "_wifi_device_copy_networks", sub_10002B088(v24));
                  objc_autoreleasePoolPop(v28);
                  sub_10002C478((uint64_t)v24, CFSTR("InterfaceDataUsageV1"), v27);
                  CFRelease(v27);
                  continue;
                }
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no interface data usage for %@", "_wifi_device_copy_networks", sub_10002B088(v24), v33);
              }
              else
              {
                v28 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@ has invalid role (%d)", "_wifi_device_copy_networks", sub_10002B088(v24), v25);
              }
              objc_autoreleasePoolPop(v28);
            }
          }
        }
        v29 = sub_1000173D8(v21);
        if (v29)
        {
          v30 = v29;
          sub_100016858(v29, a5, v34);
          CFRelease(v18);
          v18 = v30;
          a2 = v36;
          a3 = v35;
          goto LABEL_25;
        }
        v32 = 5;
        a2 = v36;
        a3 = v35;
      }
      else
      {
        v32 = 5;
      }
    }
    else
    {
      v21 = 0;
      v32 = 74;
    }
    *a7 = v32;
LABEL_25:
    CFRelease(v18);
    if (v21)
      CFRelease(v21);
  }
LABEL_27:
  CFRelease(v15);
LABEL_28:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E06D0(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFPropertyListRef v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  unsigned int v20;
  void *v21;

  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_10001D7D0(a2, a3);
      if (v14)
      {
        v15 = v14;
        v16 = sub_10001683C((uint64_t)v12, v14);
        if (v16)
        {
          v17 = (uint64_t)v16;
          v18 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            if ((_DWORD)a4)
              v19 = "enabled";
            else
              v19 = "disabled";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi Direct Mode %s, requested by \"%@\"", v19, sub_1000161D4((uint64_t)v12));
          }
          objc_autoreleasePoolPop(v18);
          v20 = sub_100109B74(v17, (uint64_t)v15, a4);
          *a5 = v20;
          if (v20)
          {
            v21 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set WiFi Direct state to 0x%X, 0x%X. deviceManager=%p", a4, *a5, v17);
            objc_autoreleasePoolPop(v21);
          }
        }
        else
        {
          *a5 = 74;
        }
        CFRelease(v15);
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_wifi_direct_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      *a5 = 1;
    }
    CFRelease(v12);
  }
  else
  {
    *a5 = 74;
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E08A8(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  uint64_t v16;
  const void *v17;
  const void *v18;
  void *v19;
  CFPropertyListRef v20;
  const __CFDictionary *v21;
  CFPropertyListRef v22;
  const __CFArray *v23;
  const void *v24;
  uint64_t v25;
  __CFArray *v26;
  __CFDictionary *MutableCopy;
  __CFDictionary *v28;
  void *v29;
  int v30;
  int v31;
  int v32;
  void *v33;
  void *v35;
  UInt8 *v36;
  UInt8 *v37;
  const __CFDictionary *cf;
  CFTypeRef v39;
  unsigned int v40;

  *a8 = -3900;
  v16 = sub_1000167F8();
  v17 = sub_10001674C(a1, v16);
  if (v17)
  {
    v18 = v17;
    if ((sub_100016834((uint64_t)v17) & 1) == 0)
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_gas_start_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v18));
      objc_autoreleasePoolPop(v19);
LABEL_32:
      CFRelease(v18);
      goto LABEL_33;
    }
    v40 = a3;
    v20 = sub_10001D7D0(a2, a3);
    v21 = (const __CFDictionary *)sub_10001D7D0(a6, a7);
    v22 = sub_10001D7D0(a4, a5);
    cf = v21;
    v39 = v22;
    if (v20 && v21 && (v23 = (const __CFArray *)v22) != 0)
    {
      v37 = a2;
      v24 = sub_10001683C((uint64_t)v18, v20);
      if (v24)
      {
        v25 = (uint64_t)v24;
        v26 = sub_100064608(v23);
        if (v26)
        {
          MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v21);
          v28 = MutableCopy;
          if (MutableCopy)
          {
            v36 = a4;
            CFDictionaryAddValue(MutableCopy, CFSTR("GAS_NETWORKS"), v26);
            v29 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Async GAS query requested by \"%@\" on %@", sub_1000161D4((uint64_t)v18), v20);
            objc_autoreleasePoolPop(v29);
            *a8 = 0;
            v30 = sub_100016A8C((uint64_t)v18);
            if ((v30 & 4) != 0)
            {
              v33 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Already GAS querying, will not queue request. ");
              objc_autoreleasePoolPop(v33);
              sub_100065858((uint64_t)v18, v25, v20, 0, 37);
              a4 = v36;
            }
            else
            {
              v31 = v30;
              sub_100016A84((uint64_t)v18, v30 | 4);
              v32 = sub_100110470(v25, v20, v28, (uint64_t)sub_1000E0BF0, (uint64_t)v18);
              *a8 = v32;
              if (v32)
                sub_100016A84((uint64_t)v18, v31 & 0xFFFFFFFB);
              else
                CFRetain(v18);
              a4 = v36;
            }
          }
        }
        else
        {
          v28 = 0;
        }
      }
      else
      {
        v35 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_gas_start_async", v20);
        objc_autoreleasePoolPop(v35);
        v28 = 0;
        v26 = 0;
      }
      a2 = v37;
    }
    else
    {
      v28 = 0;
      v26 = 0;
      if (!v20)
        goto LABEL_24;
    }
    CFRelease(v20);
LABEL_24:
    if (cf)
      CFRelease(cf);
    a3 = v40;
    if (v28)
      CFRelease(v28);
    if (v39)
      CFRelease(v39);
    if (v26)
      CFRelease(v26);
    goto LABEL_32;
  }
LABEL_33:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a6, a7);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_1000E0BF0(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, const void *a5)
{
  int v10;
  void *v11;

  v10 = sub_100016A8C((uint64_t)a5);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Gas request completed for \"%@\" (%d)", sub_1000161D4((uint64_t)a5), a4);
  objc_autoreleasePoolPop(v11);
  sub_100065858((uint64_t)a5, a1, a2, a3, a4);
  sub_100016A84((uint64_t)a5, v10 & 0xFFFFFFFB);
  if (a5)
  {
    if ((v10 & 4) != 0)
      CFRelease(a5);
  }
}

uint64_t sub_1000E0CD4(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, UInt8 *a5, unsigned int a6, unsigned int *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  const void *v19;
  void *v20;
  BOOL v21;
  unsigned int v22;
  UInt8 *v23;
  unsigned int v24;
  UInt8 *v25;
  const char *v26;
  unsigned int v27;
  void *v28;
  const char *v30;
  uint64_t v31;
  const __CFArray *v32;
  const void *v33;

  *a7 = 0;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) != 0)
    {
      v18 = sub_10001D7D0(a2, a3);
      if (v18)
      {
        v19 = v18;
        v33 = sub_10001683C((uint64_t)v16, v18);
        if (v33)
        {
          v32 = (const __CFArray *)sub_10001D7D0(a5, a6);
          kdebug_trace(731381796, 0, 0, 0, 0);
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v21 = (_DWORD)a4 == 0;
            v31 = a4;
            v22 = a3;
            v23 = a2;
            v24 = a6;
            v25 = a5;
            if (v21)
              v26 = "OFF";
            else
              v26 = "ON";
            v30 = v26;
            a5 = v25;
            a6 = v24;
            a2 = v23;
            a3 = v22;
            a4 = v31;
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Set device rangeable %s requested by \"%@\"", v30, sub_1000161D4((uint64_t)v16));
          }
          objc_autoreleasePoolPop(v20);
          v27 = sub_100110780((uint64_t)v33, (uint64_t)v19, a4, v32);
          *a7 = v27;
          if (v27)
          {
            v28 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set rangeable state(%d) to %d. deviceManager=%p", *a7, a4, v33);
            objc_autoreleasePoolPop(v28);
          }
          if (v32)
            CFRelease(v32);
        }
        CFRelease(v19);
      }
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_rangeable(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
      *a7 = 1;
    }
    CFRelease(v16);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a5, a6);
  return 0;
}

uint64_t sub_1000E0F10(unsigned int a1, UInt8 *a2, unsigned int a3, int a4, UInt8 *a5, unsigned int a6, unsigned int *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  CFMutableDictionaryRef MutableCopy;
  unsigned int v25;
  void *v26;
  UInt8 *bytes;

  *a7 = 0;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) == 0)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_ranging_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
      *a7 = 1;
      goto LABEL_22;
    }
    v18 = sub_10001D7D0(a2, a3);
    if (!v18)
    {
LABEL_22:
      CFRelease(v16);
      goto LABEL_23;
    }
    v19 = v18;
    bytes = a5;
    v20 = sub_10001683C((uint64_t)v16, v18);
    if (v20)
    {
      v21 = (uint64_t)v20;
      if (!a4)
      {
        MutableCopy = 0;
        v23 = 0;
        goto LABEL_13;
      }
      v22 = (const __CFDictionary *)sub_10001D7D0(a5, a6);
      if (v22)
      {
        v23 = v22;
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v22);
        if (!MutableCopy)
        {
LABEL_20:
          CFRelease(v23);
          goto LABEL_21;
        }
LABEL_13:
        v25 = sub_100110790(v21, (uint64_t)v19, a4, (uint64_t)MutableCopy);
        *a7 = v25;
        if (v25)
        {
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set ranging identifier(%d). deviceManager=%p", *a7, v21);
          objc_autoreleasePoolPop(v26);
        }
        if (MutableCopy)
          CFRelease(MutableCopy);
        if (!v23)
          goto LABEL_21;
        goto LABEL_20;
      }
    }
LABEL_21:
    CFRelease(v19);
    a5 = bytes;
    goto LABEL_22;
  }
LABEL_23:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a5, a6);
  return 0;
}

uint64_t sub_1000E10F0(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  const __CFArray *v22;
  const __CFArray *v23;
  void *v24;
  int v25;
  int v26;
  int v27;
  void *v28;
  void *v30;
  UInt8 *v31;
  unsigned int v32;

  *a7 = -3900;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) != 0)
    {
      v18 = sub_10001D7D0(a2, a3);
      if (v18)
      {
        v19 = v18;
        v31 = a2;
        v20 = sub_10001683C((uint64_t)v16, v18);
        v32 = a5;
        if (v20)
        {
          v21 = (uint64_t)v20;
          v22 = (const __CFArray *)sub_10001D7D0(a4, a5);
          if (v22)
          {
            v23 = v22;
            kdebug_trace(731381800, 0, 0, 0, 0);
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Async ranging requested by \"%@\" on %@ timeout %d", sub_1000161D4((uint64_t)v16), v19, a6);
            objc_autoreleasePoolPop(v24);
            *a7 = 0;
            v25 = sub_100016A8C((uint64_t)v16);
            if ((v25 & 0x10) != 0)
            {
              v28 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Already ranging, will not queue request.");
              objc_autoreleasePoolPop(v28);
              sub_100065CB8((uint64_t)v16, v21, v19, 0, 37);
            }
            else
            {
              v26 = v25;
              sub_100016A84((uint64_t)v16, v25 | 0x10);
              v27 = sub_100110798(v21, v19, v23, (uint64_t)sub_1000E1390, (uint64_t)v16, (double)(int)a6);
              *a7 = v27;
              if (v27)
                sub_100016A84((uint64_t)v16, v26 & 0xFFFFFFEF);
              else
                CFRetain(v16);
            }
            CFRelease(v23);
          }
        }
        else
        {
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_ranging_start_async", v19);
          objc_autoreleasePoolPop(v30);
        }
        CFRelease(v19);
        a5 = v32;
        a2 = v31;
      }
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_ranging_start_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
    }
    CFRelease(v16);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_1000E1390(uint64_t a1, const void *a2, const void *a3, uint64_t a4, const void *a5)
{
  int v10;
  void *v11;

  v10 = sub_100016A8C((uint64_t)a5);
  kdebug_trace(731381812, 0, 0, 0, 0);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Ranging request completed for \"%@\" (%d)", sub_1000161D4((uint64_t)a5), a4);
  objc_autoreleasePoolPop(v11);
  sub_100065CB8((uint64_t)a5, a1, a2, a3, a4);
  sub_100016A84((uint64_t)a5, v10 & 0xFFFFFFEF);
  if (a5)
  {
    if ((v10 & 0x10) != 0)
      CFRelease(a5);
  }
}

uint64_t sub_1000E1490(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        sub_10009F9BC(v8, a2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_thermal_index(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E154C(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 100;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_10009F938(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_thermal_index(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E1610(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7, _DWORD *a8)
{
  uint64_t v16;
  const void *v17;
  const void *v18;
  void *v19;
  CFPropertyListRef v20;
  unsigned int v21;
  const void *v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  const void *v25;
  void *v26;
  UInt8 *v28;
  unsigned int v29;
  CFTypeRef cf;

  cf = 0;
  *a6 = 0;
  *a7 = 0;
  *a8 = -3900;
  v16 = sub_1000167F8();
  v17 = sub_10001674C(a1, v16);
  if (!v17)
    goto LABEL_18;
  v18 = v17;
  if ((sub_100016834((uint64_t)v17) & 1) != 0)
  {
    v20 = sub_10001D7D0(a2, a3);
    v21 = a5;
    v22 = v20;
    v29 = v21;
    v23 = (const __CFDictionary *)sub_10001D7D0(a4, v21);
    v24 = v23;
    if (v22 && v23)
    {
      v28 = a4;
      v25 = sub_10001683C((uint64_t)v18, v22);
      v26 = objc_autoreleasePoolPush();
      if (v25)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: received debug request: %@", "_wifi_device_debug_command", v24);
        objc_autoreleasePoolPop(v26);
        *a8 = sub_100110DCC((uint64_t)v25, (uint64_t)v22, v24, (CFMutableDictionaryRef *)&cf);
        a4 = v28;
        if (cf)
          sub_100016858(cf, a6, a7);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_debug_command", v22);
        objc_autoreleasePoolPop(v26);
        a4 = v28;
      }
    }
    else if (!v22)
    {
LABEL_14:
      a5 = v29;
      if (v24)
        CFRelease(v24);
      goto LABEL_16;
    }
    CFRelease(v22);
    goto LABEL_14;
  }
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_debug_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_1000161D4((uint64_t)v18));
  objc_autoreleasePoolPop(v19);
LABEL_16:
  CFRelease(v18);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
LABEL_18:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E1830(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFPropertyListRef v14;
  void *v15;
  const void *v16;
  __CFDictionary *v17;
  __CFDictionary *v18;
  __CFDictionary *v19;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_10001D7D0(a2, a3);
      if (v14)
      {
        v15 = (void *)v14;
        v16 = sub_10001683C((uint64_t)v12, v14);
        if (v16 && (v17 = sub_100109ACC((uint64_t)v16, v15)) != 0)
        {
          v18 = v17;
          sub_100016858(v17, a4, a5);
          CFRelease(v15);
          v19 = v18;
        }
        else
        {
          v19 = (__CFDictionary *)v15;
        }
        CFRelease(v19);
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_roam_stats(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E1960(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  CFPropertyListRef v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const void *v19;
  void *v21;

  *a6 = -3900;
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if ((sub_100016834((uint64_t)v13) & 1) == 0)
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_trgdisc_params(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
      objc_autoreleasePoolPop(v15);
LABEL_13:
      CFRelease(v14);
      goto LABEL_14;
    }
    v16 = sub_10001D7D0(a2, a3);
    v17 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
    v18 = v17;
    if (v16 && v17)
    {
      v19 = sub_10001683C((uint64_t)v14, v16);
      if (v19)
      {
        *a6 = sub_100112C84((uint64_t)v19, v18);
      }
      else
      {
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_set_trgdisc_params", v16);
        objc_autoreleasePoolPop(v21);
      }
    }
    else if (!v16)
    {
LABEL_11:
      if (v18)
        CFRelease(v18);
      goto LABEL_13;
    }
    CFRelease(v16);
    goto LABEL_11;
  }
LABEL_14:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E1AE8(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  CFPropertyListRef v12;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = sub_10001D7D0(a2, a3);
        sub_10009D354(v10);
        if (v12)
          CFRelease(v12);
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_dump_logs(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E1BE0(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  const __SCPreferences *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = (const __SCPreferences *)v10;
        v12 = sub_1000E1CD8(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_1000A07F8(v11, v12);
          CFRelease(v13);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_policy(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

const __CFDictionary *sub_1000E1CD8(UInt8 *a1, CFIndex length)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  CFTypeID v4;
  _QWORD *v5;

  v2 = (const __CFDictionary *)sub_10001D7D0(a1, length);
  v3 = v2;
  if (v2 && (v4 = CFGetTypeID(v2), v4 == CFDictionaryGetTypeID()))
  {
    v5 = sub_10003F310(kCFAllocatorDefault, v3);
    CFRelease(v3);
    v3 = 0;
  }
  else
  {
    v5 = 0;
  }
  if (v5)
    return (const __CFDictionary *)v5;
  else
    return v3;
}

uint64_t sub_1000E1D4C(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = sub_1000E1CD8(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_1000A0A10(v11, v12);
          CFRelease(v13);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_policy(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E1E44(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  const __CFArray *v11;
  const __CFArray *v12;
  __CFArray *v13;
  __CFArray *v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000A0C00(v10);
        if (v11)
        {
          v12 = v11;
          v13 = sub_10003F754(v11);
          if (v13)
          {
            v14 = v13;
            sub_100016858(v13, a2, a3);
            CFRelease(v14);
          }
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_policies(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E1F40(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_10009836C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_restriction_policy_active(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E2000(unsigned int a1, unsigned __int8 a2, UInt8 *a3, unsigned int a4)
{
  void *v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  CFPropertyListRef v15;
  void *v17;
  uint64_t v18;

  kdebug_trace(731381764, 0, 0, 0, 0);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s is called\n", "_wifi_manager_set_incar_state");
  objc_autoreleasePoolPop(v8);
  v9 = sub_1000167F8();
  v10 = sub_10001674C(a1, v9);
  if (v10)
  {
    v11 = v10;
    if ((sub_100016834((uint64_t)v10) & 1) != 0)
    {
      v13 = sub_100016A7C((uint64_t)v11);
      if (v13)
      {
        v14 = v13;
        v15 = sub_10001D7D0(a3, a4);
        sub_10009FA88(v14, a2, v15);
        if (v15)
          CFRelease(v15);
        goto LABEL_11;
      }
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid manager\n", "_wifi_manager_set_incar_state", v18);
    }
    else
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_incar_state(mach_port_t, int, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v11));
    }
    objc_autoreleasePoolPop(v12);
LABEL_11:
    CFRelease(v11);
    goto LABEL_12;
  }
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid client\n", "_wifi_manager_set_incar_state");
  objc_autoreleasePoolPop(v17);
LABEL_12:
  sub_10001D7AC((vm_address_t)a3, a4);
  return 0;
}

uint64_t sub_1000E21B0(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7, _DWORD *a8)
{
  uint64_t v15;
  __CFArray *v16;
  __CFArray *v17;
  void *v18;
  CFPropertyListRef v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  const __CFDictionary *v23;
  void *v24;
  __CFArray *v25;
  __CFArray *v26;
  void *v28;
  uint64_t v29;
  UInt8 *v30;

  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  v15 = sub_1000167F8();
  v16 = (__CFArray *)sub_10001674C(a1, v15);
  if (v16)
  {
    v17 = v16;
    if ((sub_100016834((uint64_t)v16) & 1) == 0)
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_wowblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_1000161D4((uint64_t)v17));
LABEL_5:
      objc_autoreleasePoolPop(v18);
LABEL_15:
      CFRelease(v17);
      goto LABEL_16;
    }
    v19 = sub_10001D7D0(a2, a3);
    if (!v19)
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:interface is NULL!", "_wifi_device_wowblacklist_command", v29);
      goto LABEL_5;
    }
    v20 = v19;
    v21 = sub_10001683C((uint64_t)v17, v19);
    v30 = a4;
    if (v21)
    {
      v22 = (uint64_t)v21;
      v23 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling WiFiDeviceManagerProcessWoWBlacklistCommands with request:%@", "_wifi_device_wowblacklist_command", v23);
      objc_autoreleasePoolPop(v24);
      v25 = sub_100101FC8(v22, v23);
      v26 = v25;
      if (v25)
        sub_100016858(v25, a6, a7);
    }
    else
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_wowblacklist_command", v20);
      objc_autoreleasePoolPop(v28);
      v23 = 0;
      v26 = 0;
    }
    CFRelease(v20);
    CFRelease(v17);
    if (v23)
      CFRelease(v23);
    v17 = v26;
    a4 = v30;
    if (v26)
      goto LABEL_15;
  }
LABEL_16:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E23E8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  id v11;
  const void *v12;
  void *v13;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000A1A0C(v10);
        if (v11)
        {
          v12 = v11;
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Leech location requested by \"%@\"", "_wifi_manager_copy_leeched_location", sub_1000161D4((uint64_t)v8));
          objc_autoreleasePoolPop(v13);
          sub_100016858(v12, a2, a3);
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_leeched_location(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E251C(unsigned int a1, UInt8 *a2, CFIndex a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  const void *v17;
  void *v18;
  void *v19;
  const void *v20;
  id v21;
  const void *v22;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_100016A7C((uint64_t)v12);
      if (v14)
      {
        v15 = v14;
        v16 = sub_1000DCFD4(a2, a3);
        if (v16)
        {
          v17 = v16;
          v18 = objc_autoreleasePoolPush();
          v19 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v20 = sub_10002B088(v17);
            objc_msgSend(v19, "WFLog:message:", 3, "%s:%@ requested by \"%@\"", "_wifi_manager_copy_geotags_for_network", v20, sub_1000161D4((uint64_t)v12));
          }
          objc_autoreleasePoolPop(v18);
          v21 = sub_1000A1538(v15, (uint64_t)v17);
          if (v21)
          {
            v22 = v21;
            sub_100016858(v21, a4, a5);
            CFRelease(v22);
          }
          CFRelease(v17);
        }
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_geotags_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E26A8(unsigned int a1, UInt8 *a2, CFIndex a3, double a4, double a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  const void *v17;
  void *v18;
  void *v19;
  const void *v20;
  void *v22;

  if (a4 < -90.0 || a4 > 90.0)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid latitude value", "_wifi_manager_set_geotag_for_network");
    goto LABEL_21;
  }
  if (a5 < -180.0 || a5 > 180.0)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid longitude value", "_wifi_manager_set_geotag_for_network");
LABEL_21:
    objc_autoreleasePoolPop(v22);
    goto LABEL_16;
  }
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_100016A7C((uint64_t)v12);
      if (v14)
      {
        v15 = v14;
        v16 = sub_1000DCFD4(a2, a3);
        if (v16)
        {
          v17 = v16;
          v18 = objc_autoreleasePoolPush();
          v19 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v20 = sub_10002B088(v17);
            objc_msgSend(v19, "WFLog:message:", 3, "%s:%@ requested by \"%@\"", "_wifi_manager_set_geotag_for_network", v20, sub_1000161D4((uint64_t)v12));
          }
          objc_autoreleasePoolPop(v18);
          sub_1000A1624(v15, v17, a4, a5);
          CFRelease(v17);
        }
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_geotag_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, double, double)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
LABEL_16:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E28C8(unsigned int a1, int a2, vm_offset_t *a3, mach_msg_type_number_t *a4, double a5, double a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  const __CFArray *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  __CFArray *v22;
  __CFArray *v23;
  void *v25;

  *a3 = 0;
  *a4 = 0;
  if (a5 < -90.0 || a5 > 90.0)
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid latitude value", "_wifi_manager_copy_networks_at_location");
    goto LABEL_24;
  }
  if (a6 < -180.0 || a6 > 180.0)
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid longitude value", "_wifi_manager_copy_networks_at_location");
LABEL_24:
    objc_autoreleasePoolPop(v25);
    return 0;
  }
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if ((sub_100016834((uint64_t)v13) & 1) != 0)
    {
      v17 = sub_100016A7C((uint64_t)v14);
      if (v17)
      {
        v18 = v17;
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:(%f,%f) requested by \"%@\"", "_wifi_manager_copy_networks_at_location", *(_QWORD *)&a5, *(_QWORD *)&a6, sub_1000161D4((uint64_t)v14));
        objc_autoreleasePoolPop(v19);
        v20 = (const __CFArray *)sub_1000A17B4(v18, a2 != 0, a5, a6);
        if (v20)
        {
          v21 = v20;
          v22 = sub_1000173D8(v20);
          if (v22)
          {
            v23 = v22;
            sub_100016858(v22, a3, a4);
            CFRelease(v23);
          }
          CFRelease(v14);
          v16 = v21;
          goto LABEL_18;
        }
      }
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_networks_at_location(mach_port_t, double, double, int, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v14));
      objc_autoreleasePoolPop(v15);
    }
    v16 = (const __CFArray *)v14;
LABEL_18:
    CFRelease(v16);
  }
  return 0;
}

uint64_t sub_1000E2AFC(unsigned int a1, UInt8 *a2, CFIndex a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  const void *v17;
  void *v18;
  void *v19;
  const void *v20;
  id v21;
  const void *v22;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_100016A7C((uint64_t)v12);
      if (v14)
      {
        v15 = v14;
        v16 = sub_1000DCFD4(a2, a3);
        if (v16)
        {
          v17 = v16;
          v18 = objc_autoreleasePoolPush();
          v19 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v20 = sub_10002B088(v17);
            objc_msgSend(v19, "WFLog:message:", 3, "%s:%@ requested by \"%@\"", "_wifi_manager_copy_score_for_network", v20, sub_1000161D4((uint64_t)v12));
          }
          objc_autoreleasePoolPop(v18);
          v21 = sub_1000A1934(v15, (uint64_t)v17);
          if (v21)
          {
            v22 = v21;
            sub_100016858(v21, a4, a5);
            CFRelease(v22);
          }
          CFRelease(v17);
        }
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_score_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E2C88(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  void *v15;
  const __CFDictionary *v16;
  CFPropertyListRef v17;
  const void *v18;
  const void *v19;
  uint64_t v20;
  const __CFDictionary *v21;
  void *v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  void *v27;
  uint64_t v28;
  unsigned int valuePtr;
  void *value;

  value = 0;
  valuePtr = 1024;
  *a6 = 0;
  v12 = sub_1000167F8();
  v13 = (const __CFDictionary *)sub_10001674C(a1, v12);
  if (!v13)
    goto LABEL_20;
  v14 = v13;
  if ((sub_100016834((uint64_t)v13) & 1) == 0)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_soft_error_notification(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
    objc_autoreleasePoolPop(v15);
    *a6 = 1;
    goto LABEL_6;
  }
  v17 = sub_10001D7D0(a2, a3);
  if (!v17)
  {
LABEL_6:
    v16 = v14;
LABEL_19:
    CFRelease(v16);
    goto LABEL_20;
  }
  v18 = v17;
  v19 = sub_10001683C((uint64_t)v14, v17);
  if (v19)
  {
    v20 = (uint64_t)v19;
    v21 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
    if (CFDictionaryGetValueIfPresent(v21, CFSTR("APPLE80211KEY_SOFT_ERROR_EVENT_TYPE"), (const void **)&value))
    {
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr < 0x13)
        {
          sub_100117C88(v20);
          goto LABEL_17;
        }
        v22 = objc_autoreleasePoolPush();
        v23 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_16;
        v28 = valuePtr;
        v24 = "%s: Invalid SoftError Event:%u";
      }
      else
      {
        v22 = objc_autoreleasePoolPush();
        v23 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_16;
        v24 = "%s: SoftErrorEventNum is Null!";
      }
      v25 = 3;
    }
    else
    {
      v22 = objc_autoreleasePoolPush();
      v23 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
      {
LABEL_16:
        objc_autoreleasePoolPop(v22);
        goto LABEL_17;
      }
      v24 = "%s: No APPLE80211KEY_SOFT_ERROR_EVENT_TYPE Key ";
      v25 = 4;
    }
    objc_msgSend(v23, "WFLog:message:", v25, v24, "_wifi_device_soft_error_notification", v28);
    goto LABEL_16;
  }
  v27 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_soft_error_notification", v18);
  objc_autoreleasePoolPop(v27);
  v21 = 0;
LABEL_17:
  CFRelease(v18);
  CFRelease(v14);
  if (v21)
  {
    v16 = v21;
    goto LABEL_19;
  }
LABEL_20:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E2EF8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  __CFDictionary *v11;
  __CFDictionary *v12;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000A1DB0(v10);
        if (v11)
        {
          v12 = v11;
          sub_100016858(v11, a2, a3);
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_softerror_counters(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E2FD8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  const __CFArray *v10;
  _WORD *v11;
  const void *v12;
  CFDictionaryRef v13;
  CFDictionaryRef v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = (const __CFArray *)sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000A2248(v10);
        if (v11)
        {
          v12 = v11;
          v13 = sub_1000173C0((uint64_t)v11);
          if (v13)
          {
            v14 = v13;
            sub_100016858(v13, a2, a3);
            CFRelease(v14);
          }
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_current_session_based_network(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E30D4(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Set user auto join enabled requested by \"%@\" enabled %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        v11 = sub_1000161D4((uint64_t)v6);
        sub_1000898A0(v9, a2, 0, v11);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_auto_join_state(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E31F0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (!v8)
      {
LABEL_12:
        CFRelease(v6);
        return 0;
      }
      *a2 = sub_10000AF8C(v8);
      v7 = objc_autoreleasePoolPush();
      v9 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v10 = sub_1000161D4((uint64_t)v6);
        if (*a2)
          v11 = "Enable";
        else
          v11 = "Disable";
        objc_msgSend(v9, "WFLog:message:", 3, "User auto join state queried by \"%@\" is %s", v10, v11);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_user_auto_join_state(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    }
    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }
  return 0;
}

uint64_t sub_1000E32FC(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    if ((sub_100016834((uint64_t)v3) & 1) != 0)
    {
      v6 = sub_100016A7C((uint64_t)v4);
      if (v6)
      {
        v7 = v6;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Orphaned SC sets removal requested by \"%@\"", sub_1000161D4((uint64_t)v4));
        objc_autoreleasePoolPop(v8);
        sub_1000A298C(v7);
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_orphaned_sc_network_sets(mach_port_t)", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v5);
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E33F8(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    if ((sub_100016834((uint64_t)v3) & 1) != 0)
    {
      v6 = sub_100016A7C((uint64_t)v4);
      if (v6)
      {
        v7 = v6;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Migration of wifi plist requested by \"%@\"", sub_1000161D4((uint64_t)v4));
        objc_autoreleasePoolPop(v8);
        sub_1000A380C(v7);
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_migrate_list(mach_port_t)", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v5);
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E34F4(unsigned int a1, double a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Unused geotags removal requested by \"%@\", with retention period %f secs", sub_1000161D4((uint64_t)v6), *(_QWORD *)&a2);
        objc_autoreleasePoolPop(v10);
        sub_1000A1BAC(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_unused_network_geotags(mach_port_t, double)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E3604(unsigned int a1, uint64_t a2, double a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Schedule unused geotags removal at interval %d mins requested by \"%@\", with retention period %f secs", a2, sub_1000161D4((uint64_t)v8), *(_QWORD *)&a3);
        objc_autoreleasePoolPop(v12);
        sub_1000A1C64(v11, (int)a2, a3);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_schedule_unused_network_geotags_removal_test(mach_port_t, double, int)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E3728(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    if ((sub_100016834((uint64_t)v3) & 1) != 0)
    {
      v6 = sub_100016A7C((uint64_t)v4);
      if (v6)
      {
        v7 = v6;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Unschedule unused network geotags removal test requested by \"%@\"", sub_1000161D4((uint64_t)v4));
        objc_autoreleasePoolPop(v8);
        sub_1000A1D50(v7);
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_unschedule_unused_network_geotags_removal_test(mach_port_t)", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v5);
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E3824(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  uint64_t v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  void *v17;
  CFPropertyListRef v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  const __CFDictionary *v22;
  void *v23;
  __CFDictionary *v24;
  const __CFDictionary *v25;
  const __CFArray *Value;
  __CFArray *v27;
  __CFArray *v28;
  void *v30;
  void *v31;
  uint64_t v32;
  UInt8 *v33;

  v14 = sub_1000167F8();
  v15 = (const __CFDictionary *)sub_10001674C(a1, v14);
  if (!v15)
    goto LABEL_19;
  v16 = v15;
  if ((sub_100016834((uint64_t)v15) & 1) == 0)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_autojoinblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v16));
LABEL_5:
    objc_autoreleasePoolPop(v17);
LABEL_18:
    CFRelease(v16);
    goto LABEL_19;
  }
  v18 = sub_10001D7D0(a2, a3);
  if (!v18)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:interface is NULL!", "_wifi_device_autojoinblacklist_command", v32);
    goto LABEL_5;
  }
  v19 = v18;
  v20 = sub_10001683C((uint64_t)v16, v18);
  v33 = a4;
  if (v20)
  {
    v21 = (uint64_t)v20;
    v22 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse with request:%@", "_wifi_device_autojoinblacklist_command", v22);
    objc_autoreleasePoolPop(v23);
    v24 = sub_1001199A8(v21, v22);
    v25 = v24;
    if (v24)
    {
      if (CFDictionaryContainsKey(v24, CFSTR("networks")))
      {
        if (CFDictionaryContainsKey(v25, CFSTR("reasons")))
        {
          Value = (const __CFArray *)CFDictionaryGetValue(v25, CFSTR("networks"));
          v27 = sub_1000173D8(Value);
          if (v27)
          {
            v28 = v27;
            CFDictionarySetValue(v25, CFSTR("networks"), v27);
            CFRelease(v28);
            sub_100016858(v25, a6, a7);
            goto LABEL_15;
          }
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - _WiFiCreateRecordsFromNetworks failed", "_wifi_device_autojoinblacklist_command");
        }
        else
        {
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklist reasons in response", "_wifi_device_autojoinblacklist_command");
        }
      }
      else
      {
        v31 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklisted WiFiNetworkRef (records) in response", "_wifi_device_autojoinblacklist_command");
      }
      objc_autoreleasePoolPop(v31);
    }
  }
  else
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_autojoinblacklist_command", v19);
    objc_autoreleasePoolPop(v30);
    v22 = 0;
    v25 = 0;
  }
LABEL_15:
  CFRelease(v19);
  CFRelease(v16);
  if (v22)
    CFRelease(v22);
  v16 = v25;
  a4 = v33;
  if (v25)
    goto LABEL_18;
LABEL_19:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E3B50(unsigned int a1, UInt8 *a2, CFIndex a3, uint64_t a4, UInt8 *a5, unsigned int a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  uint64_t v16;
  const __CFArray *v17;
  _WORD *v18;
  const __CFDictionary *v19;

  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if ((sub_100016834((uint64_t)v13) & 1) != 0)
    {
      v16 = sub_100016A7C((uint64_t)v14);
      if (v16)
      {
        v17 = (const __CFArray *)v16;
        if (a2)
          v18 = sub_1000DCFD4(a2, a3);
        else
          v18 = 0;
        v19 = (const __CFDictionary *)sub_10001D7D0(a5, a6);
        sub_1000A42B4(v17, v18, a4, v19);
        if (v19)
          CFRelease(v19);
        if (v18)
          CFRelease(v18);
      }
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_simulate_notification(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v14));
      objc_autoreleasePoolPop(v15);
    }
    CFRelease(v14);
  }
  sub_10001D7AC((vm_address_t)a5, a6);
  return 0;
}

uint64_t sub_1000E3C8C(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  CFPropertyListRef v11;
  const void *v12;
  void *v13;
  void *v14;
  const void *v15;
  void *v16;
  int v17;
  void *v18;
  void *v20;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    v11 = sub_10001D7D0(a2, a3);
    if (!v11)
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:interface is NULL!", "_wifi_device_destroy_eap_trust_current_network");
      objc_autoreleasePoolPop(v20);
      v12 = v10;
      goto LABEL_19;
    }
    v12 = v11;
    if ((sub_100016834((uint64_t)v10) & 1) != 0)
    {
      v15 = sub_10001683C((uint64_t)v10, v12);
      v16 = objc_autoreleasePoolPush();
      if (v15)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Destroy EAP trust exceptions sent by: \"%@\"", sub_1000161D4((uint64_t)v10));
        objc_autoreleasePoolPop(v16);
        v17 = sub_10011AC28((uint64_t)v15, v12);
        v18 = objc_autoreleasePoolPush();
        if (v17)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Did destroy EAP trust exceptions for the current network.", "_wifi_device_destroy_eap_trust_current_network");
          objc_autoreleasePoolPop(v18);
          *a4 = 0;
        }
        else
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s **Failed to destroy EAP trust exceptions for the current network.", "_wifi_device_destroy_eap_trust_current_network");
          objc_autoreleasePoolPop(v18);
          *a4 = -3900;
        }
        goto LABEL_18;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_destroy_eap_trust_current_network", v12);
      v14 = v16;
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_destroy_eap_trust_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      v14 = v13;
    }
    objc_autoreleasePoolPop(v14);
LABEL_18:
    CFRelease(v10);
LABEL_19:
    CFRelease(v12);
  }
  return 0;
}

uint64_t sub_1000E3EB0(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    if ((sub_100016834((uint64_t)v3) & 1) != 0)
    {
      v6 = sub_100016A7C((uint64_t)v4);
      if (v6)
      {
        v7 = v6;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Trigger gizmo/IDS sync engine to check for password changes \"%@\"", sub_1000161D4((uint64_t)v4));
        objc_autoreleasePoolPop(v8);
        sub_1000A4BD4(v7);
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_tigger_gizmo_sync_password_check(mach_port_t)", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v5);
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E3FAC(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  CFStringRef v11;
  CFStringRef v12;
  uint64_t v14;
  uint64_t v15;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_ssid_most_used_geo_tagged_to_current_location(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }
    v10 = sub_100016A7C((uint64_t)v8);
    if (v10)
    {
      v11 = sub_1000A4C10(v10);
      if (!v11)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to copy SSID representing most used network that's geo tagged to current device location", v14, v15);
        goto LABEL_10;
      }
      v12 = v11;
      sub_100016858(v11, a2, a3);
      CFRelease(v12);
    }
LABEL_11:
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E40B0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
    return 0;
  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (!v5)
    return 0;
  v6 = v5;
  if ((sub_100016834((uint64_t)v5) & 1) != 0)
  {
    v9 = sub_100016A7C((uint64_t)v6);
    v8 = 0;
    if (v9)
      *a2 = sub_1000A5114(v9);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_wpa3_personal_supported(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    objc_autoreleasePoolPop(v7);
    v8 = 2;
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_1000E418C(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
    return 0;
  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (!v5)
    return 0;
  v6 = v5;
  if ((sub_100016834((uint64_t)v5) & 1) != 0)
  {
    v9 = sub_100016A7C((uint64_t)v6);
    v8 = 0;
    if (v9)
      *a2 = sub_1000A519C(v9);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_hotspot_wpa3_personal_supported(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    objc_autoreleasePoolPop(v7);
    v8 = 2;
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_1000E4268(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
    return 0;
  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (!v5)
    return 0;
  v6 = v5;
  if ((sub_100016834((uint64_t)v5) & 1) != 0)
  {
    v9 = sub_100016A7C((uint64_t)v6);
    v8 = 0;
    if (v9)
      *a2 = sub_100093FF4(v9);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_managed_apple_id(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    objc_autoreleasePoolPop(v7);
    v8 = 2;
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_1000E4344(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
    return 0;
  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (!v5)
    return 0;
  v6 = v5;
  if ((sub_100016834((uint64_t)v5) & 1) != 0)
  {
    v9 = sub_100016A7C((uint64_t)v6);
    v8 = 0;
    if (v9)
      *a2 = sub_1000A5158(v9);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_wpa3_enterprise_supported(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    objc_autoreleasePoolPop(v7);
    v8 = 2;
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_1000E4420(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
    return 0;
  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (!v5)
    return 0;
  v6 = v5;
  if ((sub_100016834((uint64_t)v5) & 1) != 0)
  {
    v9 = sub_100016A7C((uint64_t)v6);
    v8 = 0;
    if (v9)
      *a2 = sub_1000A51E0(v9);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_mfp_capable_device(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
    objc_autoreleasePoolPop(v7);
    v8 = 2;
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_1000E44FC(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  _DWORD *v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = (_DWORD *)v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested auto instant hotspot mode %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_1000A5978(v9, a2, 0);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_mode(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E4610(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 1;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000A5A54(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_auto_instant_hotspot_mode(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E46D4(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested Set Share My Personal Hotspot mode %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_1000A5A04(v9, a2, 0);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_share_personal_hotspot_mode(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E47E4(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 1;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000A5AEC(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_share_personal_hotspot_mode(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E48A8(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested Set AutoInstant Hotspot Test Mode %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_1000A5BA8(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_test_mode(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E49B8(unsigned int a1, double a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested auto instant hotspot trigger interval %f seconds ", sub_1000161D4((uint64_t)v6), *(_QWORD *)&a2);
        objc_autoreleasePoolPop(v10);
        sub_1000A5B84(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_trigger_interval(mach_port_t, double)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E4AC8(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  CFPropertyListRef v16;
  const void *v17;

  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = sub_100016A7C((uint64_t)v12);
      if (v14)
      {
        v15 = v14;
        v16 = sub_10001D7D0(a2, a3);
        if (v16)
        {
          v17 = v16;
          if (sub_10001683C((uint64_t)v12, v16))
            *a5 = sub_1000A5708(v15, (uint64_t)v12, a4);
          CFRelease(v17);
        }
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_get_event_interval(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
    }
    CFRelease(v12);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E4BEC(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v11;
  const void *v12;
  const void *v13;
  void *v14;
  CFPropertyListRef v15;
  const void *v16;
  const void *v17;
  void *v18;

  *a6 = -3900;
  v11 = sub_1000167F8();
  v12 = sub_10001674C(a1, v11);
  if (v12)
  {
    v13 = v12;
    if ((sub_100016834((uint64_t)v12) & 1) != 0)
    {
      if (sub_100016A7C((uint64_t)v13))
      {
        v15 = sub_10001D7D0(a2, a3);
        if (v15)
        {
          v16 = v15;
          v17 = sub_10001683C((uint64_t)v13, v15);
          if (a4 != 14 && v17)
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s ERROR: Unhandled event %llu", "kern_return_t _wifi_device_set_event_interval(mach_port_t, vm_offset_t, mach_msg_type_number_t, uint64_t, int, int *)", a4);
            objc_autoreleasePoolPop(v18);
          }
          CFRelease(v16);
        }
      }
    }
    else
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_event_interval(mach_port_t, vm_offset_t, mach_msg_type_number_t, uint64_t, int, int *)", sub_1000161D4((uint64_t)v13));
      objc_autoreleasePoolPop(v14);
      *a6 = 1;
    }
    CFRelease(v13);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E4D40(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000A585C(v8, 1);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_infra_allowed(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E4E04(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000A5840(v8, 2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_p2p_allowed(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E4EC8(unsigned int a1, UInt8 *a2, CFIndex a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  uint64_t v16;
  const void *v17;
  const void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  void *v23;
  void *v24;
  CFPropertyListRef v25;
  void *v26;
  void *v27;
  unsigned int v29;
  UInt8 *v30;

  *a8 = 0;
  v16 = sub_1000167F8();
  v17 = sub_10001674C(a1, v16);
  if (v17)
  {
    v18 = v17;
    if ((sub_100016834((uint64_t)v17) & 1) != 0)
    {
      v20 = sub_100016A7C((uint64_t)v18);
      if (v20)
      {
        v21 = v20;
        v22 = sub_1000DCFD4(a2, a3);
        if (v22)
        {
          v23 = v22;
          v29 = a5;
          v30 = a4;
          v24 = (void *)sub_10001D7D0(a4, a5);
          v25 = sub_10001D7D0(a6, a7);
          if (v24)
          {
            v26 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ManagerClient[\"%@\"] setNetworkProperty[\"%@\"] = %@", sub_1000161D4((uint64_t)v18), v24, v25);
            objc_autoreleasePoolPop(v26);
            if (!sub_10009B9A4(v21, v23, v24, v25))
            {
              v27 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "unable to set property");
              objc_autoreleasePoolPop(v27);
            }
            CFRelease(v24);
          }
          if (v25)
            CFRelease(v25);
          CFRelease(v18);
          v18 = v23;
          a4 = v30;
          a5 = v29;
        }
      }
    }
    else
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_network_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v18));
      objc_autoreleasePoolPop(v19);
      *a8 = 1;
    }
    CFRelease(v18);
  }
  sub_10001D7AC((vm_address_t)a4, a5);
  sub_10001D7AC((vm_address_t)a6, a7);
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E50F4(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = (_QWORD *)sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_1000A5DA8(v10);
        if (v11)
        {
          v12 = v11;
          sub_100016858(v11, a2, a3);
          CFRelease(v8);
          v8 = v12;
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_family_hotspot_preferences(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E51D8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100093470(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_power_modification_disabled(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E5298(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ requested builtInReceiver %d", sub_1000161D4((uint64_t)v6), a2);
        objc_autoreleasePoolPop(v10);
        sub_10009EF00(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_built_in_receiver(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E53A4(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000A6DC0(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_personal_hotspot_modification_disabled(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E5464(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFPropertyListRef v14;
  const void *v15;
  const void *v16;
  id v17;
  id v18;

  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_network_recommendations(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
LABEL_11:
      CFRelease(v12);
      goto LABEL_12;
    }
    v14 = sub_10001D7D0(a2, a3);
    if (!v14)
      goto LABEL_11;
    v15 = v14;
    v16 = sub_10001683C((uint64_t)v12, v14);
    if (v16)
    {
      v17 = sub_10011C9A0((uint64_t)v16);
      v18 = v17;
      if (v17)
        sub_100016858(v17, a4, a5);
    }
    else
    {
      v18 = 0;
    }
    CFRelease(v15);
    CFRelease(v12);
    v12 = v18;
    if (v18)
      goto LABEL_11;
  }
LABEL_12:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E559C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFPropertyListRef v10;
  const void *v11;
  const void *v12;
  _QWORD *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_10001D7D0(a2, a3);
      if (v10)
      {
        v11 = v10;
        v12 = sub_10001683C((uint64_t)v8, v10);
        if (v12)
        {
          sub_10011CE5C((uint64_t)v12);
          v13 = (_QWORD *)sub_100016A7C((uint64_t)v8);
          if (v13)
            sub_1000A60AC(v13);
        }
        CFRelease(v11);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_reset_availability_engine(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E569C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  const __CFNumber *v11;
  const __CFDictionary *v12;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = (const __CFNumber *)v10;
        v12 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
        sub_1000AA2FC(v11, v12);
        if (v12)
          CFRelease(v12);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_interaction_override(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E5794(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  const __CFNumber *v11;
  const __CFDictionary *v12;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = (const __CFNumber *)v10;
        v12 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
        sub_1000AA3FC(v11, v12);
        if (v12)
          CFRelease(v12);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_interaction_nw_override(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E588C(unsigned int a1, UInt8 *a2, unsigned int a3, int a4, UInt8 *a5, unsigned int a6, _DWORD *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  const __CFString *v22;
  void *v23;

  *a7 = 0;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) == 0)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_private_mac_pref(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
      *a7 = 1;
      goto LABEL_6;
    }
    v19 = sub_100016A7C((uint64_t)v16);
    if (!v19 || (v20 = v19, (v21 = (const __CFString *)sub_10001D7D0(a2, a3)) == 0))
    {
LABEL_6:
      v18 = v16;
LABEL_14:
      CFRelease(v18);
      goto LABEL_15;
    }
    v22 = v21;
    v18 = sub_10001D7D0(a5, a6);
    if (!sub_1000AA528(v20, v22, a4, v18))
    {
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Unable to Set private mac preference");
      objc_autoreleasePoolPop(v23);
    }
    CFRelease(v22);
    CFRelease(v16);
    if (v18)
      goto LABEL_14;
  }
LABEL_15:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E5A0C(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  uint64_t v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  void *v17;
  CFPropertyListRef v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  const __CFDictionary *v22;
  void *v23;
  __CFDictionary *v24;
  const __CFDictionary *v25;
  const __CFArray *Value;
  __CFArray *v27;
  __CFArray *v28;
  void *v30;
  void *v31;
  uint64_t v32;
  UInt8 *v33;

  v14 = sub_1000167F8();
  v15 = (const __CFDictionary *)sub_10001674C(a1, v14);
  if (!v15)
    goto LABEL_21;
  v16 = v15;
  if ((sub_100016834((uint64_t)v15) & 1) == 0)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_bssblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v16));
LABEL_5:
    objc_autoreleasePoolPop(v17);
LABEL_20:
    CFRelease(v16);
    goto LABEL_21;
  }
  v18 = sub_10001D7D0(a2, a3);
  if (!v18)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:interface is NULL!", "_wifi_device_bssblacklist_command", v32);
    goto LABEL_5;
  }
  v19 = v18;
  v20 = sub_10001683C((uint64_t)v16, v18);
  v33 = a4;
  if (v20)
  {
    v21 = (uint64_t)v20;
    v22 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse with request:%@", "_wifi_device_bssblacklist_command", v22);
    objc_autoreleasePoolPop(v23);
    v24 = sub_10011CF3C(v21, v22);
    v25 = v24;
    if (v24)
    {
      if (CFDictionaryContainsKey(v24, CFSTR("networks")))
      {
        if (CFDictionaryContainsKey(v25, CFSTR("reasons")))
        {
          if (CFDictionaryContainsKey(v25, CFSTR("timestamps")))
          {
            if (CFDictionaryContainsKey(v25, CFSTR("reasonData")))
            {
              Value = (const __CFArray *)CFDictionaryGetValue(v25, CFSTR("networks"));
              v27 = sub_1000173D8(Value);
              if (v27)
              {
                v28 = v27;
                CFDictionarySetValue(v25, CFSTR("networks"), v27);
                CFRelease(v28);
                sub_100016858(v25, a6, a7);
                goto LABEL_17;
              }
              v31 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - _WiFiCreateRecordsFromNetworks failed", "_wifi_device_bssblacklist_command");
            }
            else
            {
              v31 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklist reasonData in response", "_wifi_device_bssblacklist_command");
            }
          }
          else
          {
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklist timestamps in response", "_wifi_device_bssblacklist_command");
          }
        }
        else
        {
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklist reasons in response", "_wifi_device_bssblacklist_command");
        }
      }
      else
      {
        v31 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No blacklisted WiFiNetworkRef (records) in response", "_wifi_device_bssblacklist_command");
      }
      objc_autoreleasePoolPop(v31);
    }
  }
  else
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_bssblacklist_command", v19);
    objc_autoreleasePoolPop(v30);
    v22 = 0;
    v25 = 0;
  }
LABEL_17:
  CFRelease(v19);
  CFRelease(v16);
  if (v22)
    CFRelease(v22);
  v16 = v25;
  a4 = v33;
  if (v25)
    goto LABEL_20;
LABEL_21:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

uint64_t sub_1000E5DC0(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, CFIndex a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFPropertyListRef v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  void *v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  void *v22;
  unsigned int v23;
  const void *v24;
  unsigned int v26;

  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) == 0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_update_network_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v13);
      goto LABEL_6;
    }
    v15 = sub_100016A7C((uint64_t)v12);
    if (!v15 || (v16 = v15, (v17 = sub_1000DCFD4(a4, a5)) == 0))
    {
LABEL_6:
      v14 = v12;
LABEL_14:
      CFRelease(v14);
      goto LABEL_15;
    }
    v18 = v17;
    v26 = a3;
    v14 = sub_10001D7D0(a2, a3);
    v19 = sub_1000161D4((uint64_t)v12);
    v20 = sub_10001683C((uint64_t)v12, v14);
    if (v20)
    {
      v21 = (uint64_t)v20;
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Update network <%@>, requested by \"%@\"", sub_10002B088(v18), v19);
      objc_autoreleasePoolPop(v22);
      sub_100099EA4(v16, v18, 1u);
      v23 = objc_msgSend(sub_100026664((CFDictionaryRef *)v18), "disable6EMode") == (id)2;
      v24 = sub_10002B088(v18);
      sub_10010A4F8(v21, v14, v24, v23);
    }
    CFRelease(v18);
    CFRelease(v12);
    a3 = v26;
    if (v14)
      goto LABEL_14;
  }
LABEL_15:
  sub_10001D7AC((vm_address_t)a4, a5);
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E5FA4(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  _DWORD *v10;
  void *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = (_DWORD *)v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_1000A718C(v10, v12);
          CFRelease(v13);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mac_randomisation_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E609C(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;
  const void *v13;
  uint64_t v14;
  void *v15;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = v10;
        v12 = sub_1000DCFD4(a2, a3);
        if (v12)
        {
          v13 = v12;
          v14 = sub_1000161D4((uint64_t)v8);
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Update Private Mac Network <%@>, requested by \"%@\"", sub_10002B088(v13), v14);
          objc_autoreleasePoolPop(v15);
          sub_1000ABEAC(v11, v13);
          CFRelease(v13);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_update_privateMac_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E61E8(unsigned int a1, UInt8 *a2, CFIndex length, _DWORD *a4)
{
  unsigned int v5;
  _WORD *v8;
  const void *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  const __CFArray *v14;
  void *v15;
  uint64_t v16;
  const char *v17;

  v5 = length;
  *a4 = 0;
  v8 = sub_1000DCFD4(a2, length);
  if (v8)
  {
    v9 = v8;
    v10 = sub_1000167F8();
    v11 = sub_10001674C(a1, v10);
    if (!v11)
    {
LABEL_14:
      CFRelease(v9);
      goto LABEL_15;
    }
    v12 = v11;
    if ((sub_100016834((uint64_t)v11) & 1) != 0)
    {
      v14 = (const __CFArray *)sub_100016A7C((uint64_t)v12);
      if (!v14)
      {
LABEL_13:
        CFRelease(v12);
        goto LABEL_14;
      }
      *a4 = sub_1000AC1B0(v14, v9);
      v13 = objc_autoreleasePoolPush();
      v15 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v16 = sub_1000161D4((uint64_t)v12);
        if (*a4)
          v17 = "Required";
        else
          v17 = "Not Required";
        objc_msgSend(v15, "WFLog:message:", 3, "Determining if special (quick) probe required for network. Client :  \"%@\" Result %s", v16, v17);
      }
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_private_mac_is_quick_probe_required(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v12));
    }
    objc_autoreleasePoolPop(v13);
    goto LABEL_13;
  }
LABEL_15:
  sub_10001D7AC((vm_address_t)a2, v5);
  return 0;
}

uint64_t sub_1000E633C(unsigned int a1, uint64_t a2, UInt8 *a3, CFIndex a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  _WORD *v12;
  const void *v13;
  uint64_t v14;
  const __CFArray *v15;
  void *v16;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_1000DCFD4(a3, a4);
      if (v12)
      {
        v13 = v12;
        v14 = sub_100016A7C((uint64_t)v10);
        if (v14)
        {
          v15 = (const __CFArray *)v14;
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ WFMacRandomisation : private MAC probe result <%d>", sub_1000161D4((uint64_t)v10), a2);
          objc_autoreleasePoolPop(v16);
          sub_1000AC3C0(v15, v13, a2);
        }
        CFRelease(v10);
        v10 = v13;
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_private_mac_probe_result(mach_port_t, int, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a3, a4);
  return 0;
}

uint64_t sub_1000E6488(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_1000ABE64(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_adaptive_roam_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E6580(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092C9C(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_multi_band(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E6640(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  _QWORD *v8;

  *a2 = 0;
  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = (_QWORD *)sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_100092CE0(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_hardware_failure(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E6700(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    v5 = sub_100016A7C((uint64_t)v3);
    if (v5)
    {
      v6 = v5;
      if ((sub_100016834((uint64_t)v4) & 1) == 0)
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_reset_network_settings(mach_port_t)", sub_1000161D4((uint64_t)v4));
LABEL_10:
        objc_autoreleasePoolPop(v7);
        goto LABEL_11;
      }
      if (!sub_100066938((uint64_t)v4, CFSTR("com.apple.wifi.manager-access")))
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ is not entitled to reset network settings", "kern_return_t _wifi_manager_reset_network_settings(mach_port_t)", sub_1000161D4((uint64_t)v4));
        goto LABEL_10;
      }
      sub_1000AC7D0(v6);
    }
LABEL_11:
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E680C(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    v5 = sub_100016A7C((uint64_t)v3);
    if (v5)
    {
      v6 = v5;
      if ((sub_100016834((uint64_t)v4) & 1) != 0)
      {
        sub_1000AD118(v6);
      }
      else
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_purge_expired_known_networks(mach_port_t)", sub_1000161D4((uint64_t)v4));
        objc_autoreleasePoolPop(v7);
      }
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E68CC(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  char v5;
  void *v6;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    v5 = sub_100016834((uint64_t)v3);
    v6 = objc_autoreleasePoolPush();
    if ((v5 & 1) != 0)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Cleanup of log buffer files requested by \"%@\"", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v6);
      sub_100080378();
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_cleanup_log_buffer_files(mach_port_t)", sub_1000161D4((uint64_t)v4));
      objc_autoreleasePoolPop(v6);
    }
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_1000E69A4(unsigned int a1, UInt8 *a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;

  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_10001D7D0(a2, a3);
      if (v12)
      {
        v13 = v12;
        if (sub_10001683C((uint64_t)v10, v12))
          *a4 = sub_100020CF0() >> 24;
        CFRelease(v13);
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_get_app_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E6AA4(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v11 = "on-to";
          if (!a2)
            v11 = "out-of";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCall handover notification: call moved %s WiFi", "kern_return_t _wifi_manager_wificall_handover_notification(mach_port_t, int)", v11);
        }
        objc_autoreleasePoolPop(v10);
        if (a2)
          sub_10009D17C(v9);
        else
          sub_10009D268(v9);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_wificall_handover_notification(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E6BC4(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFPropertyListRef v10;
  const void *v11;
  uint64_t v12;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_10001D7D0(a2, a3);
      if (v10)
      {
        v11 = v10;
        v12 = sub_100016A7C((uint64_t)v8);
        if (v12)
          sub_100012924(v12, v11, 0);
        CFRelease(v11);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_insert_missing_network_service(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E6CB8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  const __CFArray *v11;
  void *v12;
  const __CFArray *v13;
  const __CFArray *v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = (const __CFArray *)v10;
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: requested by \"%@\"", "_wifi_manager_copy_movement_states", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v12);
        v13 = sub_1000AD468(v11);
        if (v13)
        {
          v14 = v13;
          sub_100016858(v13, a2, a3);
          CFRelease(v14);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_movement_states(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_1000E6DF0(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFPropertyListRef v10;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      if (sub_100016A7C((uint64_t)v8))
      {
        v10 = sub_10001D7D0(a2, a3);
        if (v10)
          CFRelease(v10);
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_simulated_movement_states(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E6ED0(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
      {
        v9 = v8;
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (a2)
            v11 = "ON";
          else
            v11 = "OFF";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Manager low power mode %s requested by \"%@\"", v11, sub_1000161D4((uint64_t)v6));
        }
        objc_autoreleasePoolPop(v10);
        sub_1000161D4((uint64_t)v6);
        sub_1000AD4A8(v9, a2);
      }
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_battery_save_mode(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E7000(unsigned int a1, _DWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      v8 = sub_100016A7C((uint64_t)v6);
      if (v8)
        *a2 = sub_1000AD5F4(v8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_battery_save_mode(mach_port_t, int *)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_1000E70BC(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;

  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_100016A7C((uint64_t)v7);
    if (v9)
    {
      v10 = v9;
      if ((sub_100016834((uint64_t)v8) & 1) != 0)
      {
        v12 = sub_10001D7D0(a2, a3);
        if (v12)
        {
          v13 = v12;
          sub_1000AD8A0(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_initiate_network_transition(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_1000161D4((uint64_t)v8));
        objc_autoreleasePoolPop(v11);
      }
    }
    CFRelease(v8);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000E71B4(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = sub_100005830(v2);
    sub_100006360(v3);
    v2 = *(_QWORD *)(a1 + 32);
  }
  return sub_100031C0C(v2);
}

uint64_t sub_1000E71E8(unsigned int a1)
{
  if (a1 < 3)
    return a1 + 1;
  else
    return 0;
}

uint64_t sub_1000E71F8(uint64_t a1)
{
  if (a1 == 3)
    return 2;
  else
    return a1 == 2;
}

uint64_t sub_1000E7210(int a1)
{
  if (a1 == 1)
    return 1;
  else
    return 2;
}

BOOL sub_1000E7220(uint64_t a1)
{
  return a1 == 1;
}

uint64_t sub_1000E722C(unsigned int a1)
{
  if (a1 < 3)
    return a1 + 1;
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t sub_1000E7240(int a1)
{
  if ((a1 - 1) > 8)
    return 0;
  else
    return qword_1001BBB10[a1 - 1];
}

uint64_t sub_1000E78F0()
{
  kern_return_t v0;
  kern_return_t v1;
  void *v2;

  if (!qword_10026D750)
  {
    qword_10026D750 = _CFRuntimeRegisterClass(&unk_100231700);
    if (!qword_10026D750)
      sub_10018763C();
    v0 = IOMasterPort(0, dword_10026D758);
    if (v0)
    {
      v1 = v0;
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: can't get mach master port: %ld\n", "__WiFiDeviceManagerRegister", v1);
      objc_autoreleasePoolPop(v2);
    }
  }
  return qword_10026D750;
}

uint64_t sub_1000E7998(uint64_t a1, const void *a2, NSObject *a3)
{
  void *v6;
  void *v7;
  uint64_t Instance;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  CFMutableSetRef Mutable;
  CFMutableArrayRef v15;
  CFMutableArrayRef v16;
  CFMutableArrayRef v17;
  CFMutableArrayRef v18;
  CFMutableArrayRef v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  WiFiTimeDeferredNetworksAJManager *v22;
  CFMutableArrayRef v23;
  CFMutableArrayRef v24;
  CFMutableArrayRef v25;
  CFMutableArrayRef v26;
  CFMutableArrayRef v27;
  CFMutableArrayRef v28;
  CFMutableArrayRef v29;
  CFMutableSetRef v30;
  CFMutableArrayRef v31;
  CFMutableArrayRef v32;
  __CFArray *v33;
  __CFArray *v34;
  CFMutableSetRef v35;
  CFMutableSetRef v36;
  CFMutableArrayRef v37;
  CFArrayRef ArrayBySeparatingStrings;
  __CFNotificationCenter *LocalCenter;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  NSObject *v47;
  const __CFUUID *v48;
  const __CFUUID *v49;
  CFMutableDictionaryRef v50;
  CFMutableSetRef v51;
  CFMutableSetRef v52;
  CFMutableSetRef v53;
  CFMutableSetRef v54;
  CFMutableSetRef v55;
  CFMutableSetRef v56;
  id v57;
  WiFiNetworkDenyListManager *v58;
  CWFNetworkDenyList *v59;
  CFMutableDictionaryRef v60;
  NSObject *v61;
  NSObject *v62;
  WiFiHotspotNANInterface *v63;
  void *v64;
  WiFiHotspotInterface *v65;
  CFMutableArrayRef v66;
  CFMutableArrayRef v67;
  CFMutableArrayRef v68;
  CFMutableArrayRef v69;
  id v70;
  void *v71;
  CFMutableArrayRef v72;
  CFMutableArrayRef v73;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  WiFiScanObserver *v80;
  id v81;
  id v82;
  void *v83;
  void *v85;
  void *v86;
  _QWORD v87[5];
  _QWORD v88[5];
  _QWORD v89[5];
  _QWORD v90[5];
  _QWORD v91[5];
  _QWORD v92[6];

  v6 = objc_autoreleasePoolPush();
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceManagerCreate");
  objc_autoreleasePoolPop(v7);
  if (!a2)
    goto LABEL_123;
  sub_1000E78F0();
  Instance = _CFRuntimeCreateInstance(a1);
  if (!Instance)
    goto LABEL_123;
  v9 = Instance;
  bzero((void *)(Instance + 16), 0x2368uLL);
  CFRetain(a2);
  *(_QWORD *)(v9 + 64) = a2;
  *(_QWORD *)(v9 + 5600) = +[WiFiLocationManager sharedWiFiLocationManager](WiFiLocationManager, "sharedWiFiLocationManager");
  v10 = sub_10015FBD8((uint64_t)kCFAllocatorDefault);
  *(_QWORD *)(v9 + 96) = v10;
  if (!v10)
    goto LABEL_122;
  *(_DWORD *)(v9 + 108) = 0;
  *(_BYTE *)(v9 + 104) = 0;
  v11 = sub_100041010((uint64_t)kCFAllocatorDefault, (uint64_t)a2, a3);
  *(_QWORD *)(v9 + 120) = v11;
  if (!v11)
    goto LABEL_122;
  if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"))
    -[WiFiAIRAgent setWiFiManagerQueue:](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "setWiFiManagerQueue:", a3);
  v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 312) = v12;
  if (!v12)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create retry.timer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v12, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 312), (dispatch_function_t)sub_1000E9164);
  v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 360) = v13;
  if (!v13)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create autoJoinDeferral.timer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v13, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 360), (dispatch_function_t)sub_1000E9358);
  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 3504) = Mutable;
  if (!Mutable)
    goto LABEL_122;
  v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3536) = v15;
  if (!v15)
    goto LABEL_122;
  v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3528) = v16;
  if (!v16)
    goto LABEL_122;
  v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3552) = v17;
  if (!v17)
    goto LABEL_122;
  v18 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3544) = v18;
  if (!v18)
    goto LABEL_122;
  v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3576) = v19;
  if (!v19)
    goto LABEL_122;
  v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3568) = v20;
  if (!v20)
    goto LABEL_122;
  v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3560) = v21;
  if (!v21)
    goto LABEL_122;
  v22 = -[WiFiTimeDeferredNetworksAJManager initWithArgs:]([WiFiTimeDeferredNetworksAJManager alloc], "initWithArgs:", v9);
  *(_QWORD *)(v9 + 3656) = v22;
  -[WiFiTimeDeferredNetworksAJManager setDeferIntervalSecs:](v22, "setDeferIntervalSecs:", 60.0);
  objc_msgSend(*(id *)(v9 + 3656), "setNumDaysSinceAssocOverrideDeferral:", 2);
  v23 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3328) = v23;
  if (!v23)
    goto LABEL_122;
  *(_QWORD *)(v9 + 3336) = 0;
  v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3624) = v24;
  if (!v24)
    goto LABEL_122;
  v25 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3632) = v25;
  if (!v25)
    goto LABEL_122;
  v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3584) = v26;
  if (!v26)
    goto LABEL_122;
  v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3592) = v27;
  if (!v27)
    goto LABEL_122;
  v28 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3640) = v28;
  if (!v28)
    goto LABEL_122;
  v29 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3288) = v29;
  if (!v29)
    goto LABEL_122;
  v30 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 3320) = v30;
  if (!v30)
    goto LABEL_122;
  v31 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 1104) = v31;
  if (!v31)
    goto LABEL_122;
  v32 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 272) = v32;
  if (!v32)
    goto LABEL_122;
  v33 = sub_1000E9418((char *)dword_10026CCDC, 3);
  *(_QWORD *)(v9 + 5368) = v33;
  if (!v33)
    goto LABEL_122;
  v34 = sub_1000E9418((char *)dword_10026CCE8, 2);
  *(_QWORD *)(v9 + 5376) = v34;
  if (!v34)
    goto LABEL_122;
  v35 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 3600) = v35;
  if (!v35)
    goto LABEL_122;
  v36 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 3608) = v36;
  if (!v36)
    goto LABEL_122;
  v37 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 376) = v37;
  if (!v37)
    goto LABEL_122;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, CFSTR("Preferences SpringBoard Carousel WiFiPickerExtens Setup budd sharingd demod BundledIntentHandler SiriViewService assistantd assistant_service Siri SettingsIntentExtension NanoSettings PineBoard TVSettings SoundBoard RealityControlCenter MuseBuddyApp mobilewifitool WirelessStress coreautomationd wifiutil NanoWiFiViewService ATKWiFiFramework WiFiViewService hQT XCTestInternalAngel HPSetup AirPlaySenderUIApp TVSetup deviceaccessd AccessorySetupUI"), CFSTR(" "));
  *(_QWORD *)(v9 + 4936) = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
    goto LABEL_122;
  *(_BYTE *)(v9 + 3488) = 1;
  *(_DWORD *)(v9 + 3492) = 0;
  sub_100070808((uint64_t)a2, (uint64_t)sub_1000E94C0, v9);
  sub_100070814((uint64_t)a2, (uint64_t)sub_1000E94C0, v9);
  sub_100070760((uint64_t)a2, (uint64_t)sub_1000E9DB0, v9);
  sub_10007076C((uint64_t)a2, (uint64_t)sub_1000E9FA4, v9);
  sub_100070778((uint64_t)a2, (uint64_t)sub_1000EBD54, v9);
  sub_100070790((uint64_t)a2, (uint64_t)sub_1000EBD74, v9);
  sub_100070784((uint64_t)a2, (uint64_t)sub_1000EBF18, v9);
  sub_1000707C0((uint64_t)a2, (uint64_t)sub_1000EC1D8, v9);
  sub_1000707CC((uint64_t)a2, (uint64_t)sub_1000EC778, v9);
  sub_1000707D8((uint64_t)a2, (uint64_t)sub_1000EC84C, v9);
  sub_1000707E4((uint64_t)a2, (uint64_t)sub_1000ECCC8, v9);
  sub_1000707F0((uint64_t)a2, (uint64_t)sub_1000ECE60, v9);
  sub_1000707FC((uint64_t)a2, (uint64_t)sub_1000ECEE8, v9);
  sub_100070820((uint64_t)a2, (uint64_t)sub_1000ED088, v9);
  sub_10007085C((uint64_t)a2, (uint64_t)sub_1000ED3D4, v9);
  sub_100070844((uint64_t)a2, (uint64_t)sub_1000ED548, v9);
  sub_100070850((uint64_t)a2, (uint64_t)sub_1000ED8C8, v9);
  sub_10007079C((uint64_t)a2, (uint64_t)sub_10001EBD8, v9);
  sub_100070868((uint64_t)a2, (uint64_t)sub_1000EDDB0, v9);
  sub_100070874((uint64_t)a2, (uint64_t)sub_1000EDDD0, v9);
  sub_100070880((uint64_t)a2, (uint64_t)sub_10000F2D0, v9);
  sub_10007088C((uint64_t)a2, (uint64_t)sub_100030CE0, v9);
  sub_100070898((uint64_t)a2, (uint64_t)sub_1000EDDF0, v9);
  sub_1000708A4((uint64_t)a2, (uint64_t)sub_1000EDE10, v9);
  sub_1000708B0((uint64_t)a2, (uint64_t)sub_1000EE2E0, v9);
  sub_1000708BC((uint64_t)a2, (uint64_t)sub_1000EE300, v9);
  sub_1000708D4((uint64_t)a2, (uint64_t)sub_1000082C0, v9);
  sub_1000708E0((uint64_t)a2, (uint64_t)sub_1000EE320, v9);
  sub_1000708C8((uint64_t)a2, (uint64_t)sub_100030D00, v9);
  v89[0] = _NSConcreteStackBlock;
  v89[1] = 3221225472;
  v89[2] = sub_1000EE3EC;
  v89[3] = &unk_1002313D8;
  v89[4] = v9;
  -[WiFiUsageMonitor setFaultEventHandler:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setFaultEventHandler:", v89);
  sub_1000708EC((uint64_t)a2, (uint64_t)sub_1000EE5F4, v9);
  sub_100070754((uint64_t)a2, (uint64_t)sub_1000EE8DC, v9);
  sub_10007082C((uint64_t)a2, (uint64_t)sub_1000EE8FC, v9);
  sub_100070838((uint64_t)a2, (uint64_t)sub_1000EE91C, v9);
  sub_1000708F8((uint64_t)a2, (uint64_t)sub_1000EE93C, v9);
  sub_100070904((uint64_t)a2, (uint64_t)sub_1000EEC80, v9);
  sub_100070910((uint64_t)a2, (uint64_t)sub_1000EFBF8, v9);
  sub_100043910(*(_QWORD *)(v9 + 120), (uint64_t)sub_1000EFC0C, v9);
  sub_1000439B8(*(_QWORD *)(v9 + 120), (uint64_t)sub_1000EFEA8, v9);
  sub_100043A60(*(_QWORD *)(v9 + 120), (uint64_t)sub_1000EFEB0, v9);
  sub_10007091C((uint64_t)a2, (uint64_t)sub_1000F0110, v9);
  sub_100070928((uint64_t)a2, (uint64_t)sub_1000F02D4, v9);
  sub_100070934((uint64_t)a2, (uint64_t)sub_1000F047C, v9);
  sub_100070940((uint64_t)a2, (uint64_t)sub_1000F049C, v9);
  sub_10007094C((uint64_t)a2, (uint64_t)sub_1000F0558, v9);
  sub_100070958((uint64_t)a2, (uint64_t)sub_1000F0644, v9);
  sub_100070964((uint64_t)a2, (uint64_t)sub_1000F0C3C, v9);
  sub_100070970((uint64_t)a2, (uint64_t)sub_1000F1278, v9);
  sub_10007097C((uint64_t)a2, (uint64_t)sub_1000F1328, v9);
  sub_100070988((uint64_t)a2, (uint64_t)sub_1000F13F4, v9);
  sub_1000709C0((uint64_t)a2, (uint64_t)sub_1000F1410, v9);
  sub_1000707A8((uint64_t)a2, (uint64_t)sub_1000F1564, v9);
  sub_1000707B4((uint64_t)a2, (uint64_t)sub_1000F1850, v9);
  sub_1000709CC((uint64_t)a2, (uint64_t)sub_1000F18AC, v9);
  sub_1000709D8((uint64_t)a2, (uint64_t)sub_1000F1C60, v9);
  sub_1000709E4((uint64_t)a2, (uint64_t)sub_1000F1D40, v9);
  sub_1000709F0((uint64_t)a2, (uint64_t)sub_1000F2054, v9);
  sub_1000709FC((uint64_t)a2, (uint64_t)sub_1000F26C8, v9);
  sub_100070A08((uint64_t)a2, (uint64_t)sub_1000F26D4, v9);
  sub_100070A14((uint64_t)a2, (uint64_t)sub_1000F26FC, v9);
  sub_100070A38((uint64_t)a2, (uint64_t)sub_1000F2928, v9);
  sub_100070A20((uint64_t)a2, (uint64_t)sub_10000BBA0, v9);
  sub_100070A2C((uint64_t)a2, (uint64_t)sub_1000F2A54, v9);
  sub_100070A44((uint64_t)a2, (uint64_t)sub_1000F2AB8, v9);
  sub_100070A68((uint64_t)a2, (uint64_t)sub_1000F2C64, v9);
  sub_100070A80((uint64_t)a2, (uint64_t)sub_1000F2C84, v9);
  sub_100070A74((uint64_t)a2, (uint64_t)sub_1000F2CA4, v9);
  sub_100070A98((uint64_t)a2, (uint64_t)sub_1000F2CD8, v9);
  sub_100070AB0((uint64_t)a2, (uint64_t)sub_1000F2CF4, v9);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, (const void *)v9, (CFNotificationCallback)sub_1000F2FCC, CFSTR("com.apple.wifid.wifiroammanagerroamnotification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_100070A8C((uint64_t)a2, (uint64_t)sub_1000F3354, v9);
  sub_100070AA4((uint64_t)a2, (uint64_t)sub_1000F33C0, v9);
  CFNotificationCenterAddObserver(LocalCenter, (const void *)v9, (CFNotificationCallback)sub_1000F33D4, CFSTR("WiFiChipResetRequested"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  *(_QWORD *)(v9 + 4944) = 0;
  *(_WORD *)(v9 + 5360) = 0;
  *(_BYTE *)(v9 + 5362) = 0;
  *(_QWORD *)(v9 + 5448) = 0;
  *(_DWORD *)(v9 + 5455) = 0;
  *(CFAbsoluteTime *)(v9 + 5248) = CFAbsoluteTimeGetCurrent() + 315360000.0;
  v40 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 5240) = v40;
  if (!v40)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create mis.misIdleTimer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v40, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5240), (dispatch_function_t)sub_1000F345C);
  *(_DWORD *)(v9 + 5232) = 0;
  *(_QWORD *)(v9 + 6784) = 0x4072C00000000000;
  v41 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 5320) = v41;
  if (!v41)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create mis.misBroadcastToHiddenTimer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v41, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5320), (dispatch_function_t)sub_1000F3828);
  v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 5512) = v42;
  if (!v42)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create priorityLinkSetupPhase.timer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v42, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5512), (dispatch_function_t)sub_1000F38CC);
  *(_DWORD *)(v9 + 5520) = 0;
  v43 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 8592) = v43;
  if (!v43)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create _24GHzInfraNetworkData.timer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v43, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8592), (dispatch_function_t)sub_1000F3934);
  v44 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 8632) = v44;
  if (!v44)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create carPlayHidEventCtx.timer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v44, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8632), (dispatch_function_t)sub_1000F39A8);
  v45 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 1000) = v45;
  if (!v45)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create carPlayLinkDownCtx.timer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v45, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 1000), (dispatch_function_t)sub_1000F3A1C);
  v46 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 1056) = v46;
  if (!v46)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create carPlayLpcStats.timer", "WiFiDeviceManagerCreate");
    goto LABEL_112;
  }
  dispatch_set_context(v46, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 1056), (dispatch_function_t)sub_1000F3AA4);
  v47 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 5528) = v47;
  if (!v47)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create assocStateMonitor.timer", "WiFiDeviceManagerCreate");
LABEL_112:
    objc_autoreleasePoolPop(v86);
    goto LABEL_122;
  }
  dispatch_set_context(v47, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5528), (dispatch_function_t)sub_1000F4118);
  *(_QWORD *)(v9 + 5544) = 0;
  *(_QWORD *)(v9 + 5536) = 0;
  *(_BYTE *)(v9 + 5552) = 0;
  v48 = CFUUIDCreate(kCFAllocatorDefault);
  if (v48)
  {
    v49 = v48;
    *(_QWORD *)(v9 + 5488) = CFUUIDCreateString(kCFAllocatorDefault, v48);
    CFRelease(v49);
  }
  *(_QWORD *)(v9 + 3296) = 0;
  *(_OWORD *)(v9 + 5576) = 0u;
  *(_WORD *)(v9 + 5608) = 1;
  *(_BYTE *)(v9 + 34) = 0;
  *(_DWORD *)(v9 + 6208) = 0;
  *(_BYTE *)(v9 + 6216) = 0;
  *(_WORD *)(v9 + 36) = 257;
  *(_BYTE *)(v9 + 6184) = 0;
  bzero((void *)(v9 + 5616), 0x238uLL);
  *(_BYTE *)(v9 + 38) = 1;
  *(_QWORD *)(v9 + 6160) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 6056) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 6064) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 1168) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v50 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v9 + 3680) = v50;
  if (!v50)
    goto LABEL_122;
  v51 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5272) = v51;
  if (!v51)
    goto LABEL_122;
  v52 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5280) = v52;
  if (!v52)
    goto LABEL_122;
  v53 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5288) = v53;
  if (!v53)
    goto LABEL_122;
  v54 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5296) = v54;
  if (!v54)
    goto LABEL_122;
  v55 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5304) = v55;
  if (!v55)
    goto LABEL_122;
  v56 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v9 + 5312) = v56;
  if (!v56)
    goto LABEL_122;
  *(_QWORD *)(v9 + 6448) = 0;
  *(_OWORD *)(v9 + 6432) = 0u;
  *(_OWORD *)(v9 + 6416) = 0u;
  *(_OWORD *)(v9 + 6400) = 0u;
  *(_OWORD *)(v9 + 6384) = 0u;
  *(_OWORD *)(v9 + 6368) = 0u;
  *(_OWORD *)(v9 + 6352) = 0u;
  *(_OWORD *)(v9 + 6336) = 0u;
  *(_OWORD *)(v9 + 6320) = 0u;
  *(_OWORD *)(v9 + 6304) = 0u;
  *(_OWORD *)(v9 + 6288) = 0u;
  if (_os_feature_enabled_impl("WiFiManager", "NetworkDenyList"))
  {
    sub_100029860(*(_QWORD *)(v9 + 64));
    v57 = objc_msgSend(objc_alloc((Class)CWFNetworkDenyList), "initWithDenyListDeviceProfile:", 1);
    objc_msgSend(v57, "setEnabled:", 1);
    v92[0] = _NSConcreteStackBlock;
    v92[1] = 3221225472;
    v92[2] = sub_100125F24;
    v92[3] = &unk_100231760;
    v92[4] = v9;
    objc_msgSend(v57, "setBatteryInfoHandler:", v92);
    v91[0] = _NSConcreteStackBlock;
    v91[1] = 3221225472;
    v91[2] = sub_100126024;
    v91[3] = &unk_100231780;
    v91[4] = v9;
    objc_msgSend(v57, "setIsUserModeInteractiveHandler:", v91);
    v90[0] = _NSConcreteStackBlock;
    v90[1] = 3221225472;
    v90[2] = sub_10012604C;
    v90[3] = &unk_1002317A0;
    v90[4] = v9;
    objc_msgSend(v57, "setDenyListDidUpdateHandler:", v90);
    *(_QWORD *)(v9 + 6648) = v57;
    if (!v57)
      goto LABEL_122;
  }
  else
  {
    v58 = -[WiFiNetworkDenyListManager initWithArgs:interfaceName:]([WiFiNetworkDenyListManager alloc], "initWithArgs:interfaceName:", v9, sub_100029860(*(_QWORD *)(v9 + 64)));
    *(_QWORD *)(v9 + 6640) = v58;
    if (!v58)
      goto LABEL_122;
    v59 = -[WiFiNetworkDenyListManager networkDenyList](v58, "networkDenyList");
    *(_QWORD *)(v9 + 6648) = v59;
    if (!v59)
      goto LABEL_122;
  }
  *(_QWORD *)(v9 + 6656) = 0;
  *(_WORD *)(v9 + 6600) = -1;
  *(_QWORD *)(v9 + 6624) = +[WiFiNOIManager sharedWiFiNOIManagerWithQueue:](WiFiNOIManager, "sharedWiFiNOIManagerWithQueue:", a3);
  *(_DWORD *)(v9 + 72) = MGGetSInt32Answer(CFSTR("DeviceClassNumber"), 0);
  *(_QWORD *)(v9 + 80) = MGGetProductType();
  *(_BYTE *)(v9 + 88) = MGGetBoolAnswer(CFSTR("wapi"));
  *(_BYTE *)(v9 + 6632) = *(_DWORD *)(v9 + 72) == 7;
  *(_QWORD *)(v9 + 6656) = 0;
  *(_DWORD *)(v9 + 6664) = 0;
  *(_BYTE *)(v9 + 6712) = 0;
  v60 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v9 + 7064) = v60;
  if (!v60)
    goto LABEL_122;
  v61 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 6808) = v61;
  if (!v61)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create autoHotspotScanTimer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v61, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 6808), (dispatch_function_t)sub_1000F417C);
  *(CFAbsoluteTime *)(v9 + 6824) = CFAbsoluteTimeGetCurrent() + 315360000.0;
  v62 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 6816) = v62;
  if (!v62)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create autoHotspotLockStateTimer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v62, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 6816), (dispatch_function_t)sub_1000F43A8);
  if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS"))
  {
    v63 = objc_alloc_init(WiFiHotspotNANInterface);
    *(_QWORD *)(v9 + 6752) = v63;
    if (!v63)
    {
      v64 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ERROR: Couldn't create wifiHotspotNANInterfaceManager");
      objc_autoreleasePoolPop(v64);
    }
    *(_BYTE *)(v9 + 6760) = 0;
  }
  *(_DWORD *)(v9 + 6776) = -536870352;
  v65 = objc_alloc_init(WiFiHotspotInterface);
  *(_QWORD *)(v9 + 6744) = v65;
  if (v65)
  {
    v66 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(v9 + 6840) = v66;
    if (!v66)
      goto LABEL_122;
    *(_BYTE *)(v9 + 6897) = 0;
    *(_BYTE *)(v9 + 6800) = 0;
    *(_BYTE *)(v9 + 6968) = 0;
    *(_QWORD *)(v9 + 6952) = 0;
    *(_QWORD *)(v9 + 6944) = 0;
    v67 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(v9 + 6912) = v67;
    if (!v67)
      goto LABEL_122;
    v68 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(v9 + 6920) = v68;
    if (!v68)
      goto LABEL_122;
    v69 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(v9 + 6928) = v69;
    if (!v69)
      goto LABEL_122;
    v70 = objc_alloc_init((Class)NSMutableArray);
    *(_QWORD *)(v9 + 6936) = v70;
    if (!v70)
      goto LABEL_122;
    *(_QWORD *)(v9 + 6904) = 0;
    *(int64x2_t *)(v9 + 6864) = vdupq_n_s64(0x405E000000000000uLL);
    *(_DWORD *)(v9 + 6888) = 2;
    *(_QWORD *)(v9 + 6880) = 0x300000002;
    *(_BYTE *)(v9 + 7024) = 0;
    *(_QWORD *)(v9 + 6976) = 0;
    *(_DWORD *)(v9 + 6984) = 0;
    *(_BYTE *)(v9 + 7008) = 0;
    *(_QWORD *)(v9 + 7000) = 0;
    *(_QWORD *)(v9 + 6992) = 0;
    v71 = *(void **)(v9 + 6744);
    v88[0] = _NSConcreteStackBlock;
    v88[1] = 3221225472;
    v88[2] = sub_1000F44F4;
    v88[3] = &unk_100231418;
    v88[4] = v9;
    objc_msgSend(v71, "registerHotspotInterfaceUpdateNetworkCallback:withCallbackContext:", v88, v9);
  }
  *(_BYTE *)(v9 + 7057) = 0;
  *(_BYTE *)(v9 + 7043) = MGGetBoolAnswer(CFSTR("HasHighBandwidthRadio"));
  *(_BYTE *)(v9 + 7044) = 0;
  v72 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v9 + 3704) = v72;
  if (!v72
    || (v73 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks),
        (*(_QWORD *)(v9 + 3736) = v73) == 0))
  {
LABEL_122:
    CFRelease((CFTypeRef)v9);
LABEL_123:
    v83 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: failed to create deviceManager ref", "WiFiDeviceManagerCreate");
    v9 = 0;
    goto LABEL_89;
  }
  *(_BYTE *)(v9 + 40) = 0;
  *(_BYTE *)(v9 + 7312) = 0;
  *(_DWORD *)(v9 + 44) = 0;
  *(_DWORD *)(v9 + 47) = 0;
  v74 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 7320) = v74;
  if (!v74
    || (dispatch_set_context(v74, (void *)v9),
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7320), (dispatch_function_t)sub_1000F6824),
        *(_BYTE *)(v9 + 7336) = 0,
        v75 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3),
        (*(_QWORD *)(v9 + 7344) = v75) == 0))
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create bssBlacklist.expiryTimer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v75, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7344), (dispatch_function_t)sub_1000F688C);
  v76 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 7216) = v76;
  if (!v76)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create dps.displayTimer", "WiFiDeviceManagerCreate");
    goto LABEL_121;
  }
  dispatch_set_context(v76, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7216), (dispatch_function_t)sub_1000F6900);
  v77 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v9 + 7256) = v77;
  if (!v77)
  {
    v85 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create slowWiFi.displayTimer", "WiFiDeviceManagerCreate");
LABEL_121:
    objc_autoreleasePoolPop(v85);
    goto LABEL_122;
  }
  dispatch_set_context(v77, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7256), (dispatch_function_t)sub_1000F6A30);
  v78 = *(NSObject **)(v9 + 8968);
  if (v78
    || (v78 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3),
        (*(_QWORD *)(v9 + 8968) = v78) != 0))
  {
    dispatch_set_context(v78, (void *)v9);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8968), (dispatch_function_t)sub_1000F6B44);
    dispatch_activate(*(dispatch_object_t *)(v9 + 8968));
  }
  v79 = *(NSObject **)(v9 + 3768);
  if (v79
    || (v79 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3),
        (*(_QWORD *)(v9 + 3768) = v79) != 0))
  {
    dispatch_set_context(v79, (void *)v9);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 3768), (dispatch_function_t)sub_1000F6E38);
    dispatch_activate(*(dispatch_object_t *)(v9 + 3768));
  }
  *(_QWORD *)(v9 + 3728) = 0;
  *(_BYTE *)(v9 + 3688) = byte_10026DD62 == 0;
  *(_QWORD *)(v9 + 3712) = MGCopyAnswer(CFSTR("WifiAddressData"), 0);
  *(_QWORD *)(v9 + 7392) = 0;
  *(_DWORD *)(v9 + 7384) = 0;
  *(CFAbsoluteTime *)(v9 + 7304) = CFAbsoluteTimeGetCurrent();
  *(_BYTE *)(v9 + 7296) = 0;
  *(_QWORD *)(v9 + 696) = 0;
  *(_OWORD *)(v9 + 1072) = 0u;
  *(_DWORD *)(v9 + 5496) = 0;
  *(_BYTE *)(v9 + 5500) = 0;
  if (objc_opt_class(CARConnectionTimeStore))
    *(_QWORD *)(v9 + 968) = objc_alloc_init((Class)CARConnectionTimeStore);
  v80 = objc_alloc_init(WiFiScanObserver);
  *(_QWORD *)(v9 + 6680) = v80;
  v81 = objc_alloc_init((Class)WiFiSettlementConfiguration);
  v82 = objc_msgSend(objc_alloc((Class)WiFiSettlementObserver), "initWithScanProvider:configuration:", v80, v81);
  *(_QWORD *)(v9 + 8976) = v82;
  v87[0] = _NSConcreteStackBlock;
  v87[1] = 3221225472;
  v87[2] = sub_1000F6EFC;
  v87[3] = &unk_100231438;
  v87[4] = v9;
  objc_msgSend(v82, "addSettlementCallback:", v87);

  *(_BYTE *)(v9 + 9065) = 0;
  v83 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceManagerCreate");
LABEL_89:
  objc_autoreleasePoolPop(v83);
  objc_autoreleasePoolPop(v6);
  return v9;
}

void sub_1000E9164(uint64_t a1)
{
  int v2;
  void *v3;
  NSString *v4;
  uint8_t buf[4];
  const char *v6;

  v2 = *(_DWORD *)(a1 + 3280);
  v3 = objc_autoreleasePoolPush();
  if (v2 == 1)
  {
    if (qword_10026DD20)
    {
      v4 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Retrying auto association"))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v6 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v4, "UTF8String")), "UTF8String");
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v3);
    *(_DWORD *)(a1 + 3280) = 0;
    if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 4, sub_100025C3C(*(_QWORD *)(a1 + 64)));
      sub_1000FBCDC(a1, 0, (uint64_t)"__WiFiDeviceManagerRetryTimerCallback");
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting auto association retry but auto join state already is %@.", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000E9358(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto-join deferral expired. Triggering auto-join.");
  objc_autoreleasePoolPop(v2);
  *(_DWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 192) = 12;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_1000285E4(a1, 0xEuLL);
  }
  else
  {
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 14, sub_100025C3C(*(_QWORD *)(a1 + 64)));
    sub_1000FBA80(a1, 2, (uint64_t)"__WiFiDeviceManagerDeferralTimerCallback");
  }
}

__CFArray *sub_1000E9418(char *a1, CFIndex capacity)
{
  int v2;
  uint64_t v4;
  __CFArray *Mutable;
  CFIndex v6;
  CFNumberRef v7;
  CFNumberRef v8;

  v2 = capacity;
  v4 = capacity;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, capacity, &kCFTypeArrayCallBacks);
  if (v2 >= 1)
  {
    v6 = 0;
    do
    {
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1);
      if (v7)
      {
        v8 = v7;
        CFArraySetValueAtIndex(Mutable, v6, v7);
        CFRelease(v8);
      }
      ++v6;
      a1 += 4;
    }
    while (v4 != v6);
  }
  return Mutable;
}

void sub_1000E94C0(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  void *v7;
  void *v8;
  int v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  NSString *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  NSString *v17;
  char v18;
  const void *v19;
  char v20;
  const void *v21;
  void *v22;
  void (*v23)(uint64_t, void *, _QWORD);
  void *v24;
  void *v25;
  void *v26;
  const void *v27;
  const __CFDictionary *v28;
  CFTypeID TypeID;
  const __CFData *Value;
  void *v31;
  uint64_t v32;
  char *v33;
  NSString *v34;
  id v35;
  int v36;
  void *v37;
  id v38;
  const __CFDate *v39;
  const __CFDate *v40;
  void *v41;
  CFTypeRef v42;
  NSObject *v43;
  void *v44;
  const void *v45;
  _QWORD block[6];
  unsigned int v47;
  unint64_t v48;
  __int128 buf;
  uint64_t v50;
  uint64_t v51;

  if (a3)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = sub_10002A21C(a3, a2, 1);
    if (!v7)
    {
LABEL_41:
      objc_autoreleasePoolPop(v6);
      return;
    }
    v8 = v7;
    sub_1000CEBA4((uint64_t)v7);
    sub_1001147D4(a3, v8, 0);
    if (sub_100066DF8(*(_QWORD *)(a3 + 64)))
    {
      v9 = sub_100066B88(*(_QWORD *)(a3 + 64));
      v10 = (const void *)sub_100025C3C(a1);
      if (v9)
      {
        sub_1000672C0(a1, v10, 482, 0, (uint64_t)kCFBooleanTrue);
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v12 = sub_100029860(*(_QWORD *)(a3 + 64));
          v13 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("WiFi(%@) has valid IP Address and primary interface for network: %@, Preventing Disassociation"), v12, sub_10002B088(v8))), "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v13, "UTF8String")), "UTF8String");
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      else
      {
        sub_1000672C0(a1, v10, 482, 0, (uint64_t)kCFBooleanFalse);
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v16 = sub_100029860(*(_QWORD *)(a3 + 64));
          v17 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("WiFi(%@) has valid IP Address but not the primary interface for network: %@, Preventing Disassociation"), v16, sub_10002B088(v8))), "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v17, "UTF8String")), "UTF8String");
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      objc_autoreleasePoolPop(v11);
LABEL_19:
      v18 = 0;
LABEL_20:
      v19 = sub_10002B634(*(const __CFArray **)(a3 + 3704), (const __CFDictionary **)v8);
      v20 = v18 ^ 1;
      if (!a1)
        v20 = 1;
      if ((v20 & 1) == 0)
      {
        v21 = v19;
        if (sub_100078718(a1, v8))
        {
          v22 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> falling back to physical Mac since Interface not routable.", "__WiFiDeviceManagerPrimaryTimeoutCallback", sub_10002B088(v8));
          objc_autoreleasePoolPop(v22);
          if (*(_BYTE *)(a3 + 3688))
          {
            v23 = *(void (**)(uint64_t, void *, _QWORD))(a3 + 4712);
            if (v23)
              v23(a3, v8, *(_QWORD *)(a3 + 4720));
            if (v21)
            {
              *(_QWORD *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAAALL;
              LODWORD(buf) = 3;
              sub_100061728((uint64_t)v21, (uint64_t)&buf);
              sub_100061494((unsigned int *)&buf);
            }
            v24 = *(void **)(a3 + 7368);
            if (v24)
              objc_msgSend(v24, "addFaultEvent:forInterface:", 11, a2);
          }
        }
        else if (v21)
        {
          v48 = 0xAAAAAAAAAAAAAAAALL;
          v47 = 6;
          sub_100061728((uint64_t)v21, (uint64_t)&v47);
          sub_100061494(&v47);
          v25 = objc_autoreleasePoolPush();
          v26 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v27 = sub_10002B088(v8);
            objc_msgSend(v26, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> failed to get routable interface. PrivateMac used : <0 = used : %d>", "__WiFiDeviceManagerPrimaryTimeoutCallback", v27, v48);
          }
          objc_autoreleasePoolPop(v25);
          v28 = (const __CFDictionary *)sub_10002BE64((uint64_t)v21, CFSTR("PRIVATE_MAC_ADDRESS"));
          if (v28)
          {
            TypeID = CFDictionaryGetTypeID();
            if (TypeID == CFGetTypeID(v28))
            {
              Value = (const __CFData *)CFDictionaryGetValue(v28, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
              if (sub_10002B75C(Value))
              {
                if (!sub_10002B704((uint64_t)v8) && *(_QWORD *)(a3 + 4744))
                {
                  if (*(_QWORD *)(a3 + 240))
                  {
                    *(_QWORD *)&buf = 0;
                    *((_QWORD *)&buf + 1) = &buf;
                    v50 = 0x2020000000;
                    v51 = 0;
                    v42 = CFRetain(v21);
                    *(_QWORD *)(*((_QWORD *)&buf + 1) + 24) = v42;
                    CFRetain((CFTypeRef)a3);
                    v43 = *(NSObject **)(a3 + 240);
                    block[0] = _NSConcreteStackBlock;
                    block[1] = 3221225472;
                    block[2] = sub_100126098;
                    block[3] = &unk_10022F160;
                    block[4] = &buf;
                    block[5] = a3;
                    dispatch_async(v43, block);
                    _Block_object_dispose(&buf, 8);
                  }
                  else
                  {
                    v44 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerPrimaryTimeoutCallback");
                    objc_autoreleasePoolPop(v44);
                  }
                }
              }
            }
          }
        }
      }
      CFRelease(v8);
      goto LABEL_41;
    }
    v14 = *(void **)(a3 + 7368);
    if (v14)
      objc_msgSend(v14, "addFaultEvent:forInterface:", 13, sub_100029860(*(_QWORD *)(a3 + 64)));
    if (sub_10002B704((uint64_t)v8))
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ad-Hoc Network. Preventing disassociation");
      objc_autoreleasePoolPop(v15);
      goto LABEL_19;
    }
    if (*(_DWORD *)(a3 + 3280) != 14)
    {
      v45 = sub_10002BE64((uint64_t)v8, CFSTR("BSSID"));
      v31 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v32 = sub_100029860(*(_QWORD *)(a3 + 64));
        v33 = sub_100066DF8(*(_QWORD *)(a3 + 64)) ? "primary" : "routable";
        v34 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("WiFi(%@) failed to become %s interface for network: %@"), v32, v33, sub_10002B088(v8), v45)), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v34, "UTF8String")), "UTF8String");
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v31);
      if (sub_10002DAB4((uint64_t)v8))
      {
        sub_100072E44(*(_QWORD *)(a3 + 64), v8, 0);
      }
      else
      {
        v39 = (const __CFDate *)sub_1000C6A58((uint64_t)v8, 1);
        v40 = (const __CFDate *)sub_1000C6A58((uint64_t)v8, 0);
        if (!v40 || v39 && CFDateCompare(v39, v40, 0) == kCFCompareGreaterThan)
        {
          v41 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Network was intentionally joined.  Preventing disassociation.");
          objc_autoreleasePoolPop(v41);
          goto LABEL_67;
        }
      }
      sub_1000F7F48(a3, a2, 1005, "__WiFiDeviceManagerPrimaryTimeoutCallback", 7806);
      if (sub_1000C3B8C((_BOOL8)v8)
        && !sub_10002DAB4((uint64_t)v8)
        && (sub_100017A54((uint64_t)v8, CFSTR("WEP_AUTH_Flags")) & 4) != 0)
      {
        v35 = sub_100027D10(*(_QWORD *)(a3 + 3512));
        if ((objc_msgSend(*(id *)(a3 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v35) & 1) == 0)
        {
          v36 = sub_100119668(a3, (uint64_t)a2, 1, 1, v8, 0);
          *(_DWORD *)(a3 + 3280) = v36;
          if (v36 == 14)
          {
            v37 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatched password panel for open auth WEP network: %@", sub_10002B088(v8));
            objc_autoreleasePoolPop(v37);
          }
        }
        v38 = sub_1000FCB38(a3, 1, 0, (uint64_t)v45, 5);
        objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v38, v35);

      }
    }
LABEL_67:
    v18 = 1;
    goto LABEL_20;
  }
}

void sub_1000E9D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E9DB0(uint64_t a1, const void *a2, uint64_t a3)
{
  unsigned int v5;
  void *v6;
  void *v7;
  const char *v8;
  uint64_t v9;
  void *v10;
  _OWORD v11[7];
  uint64_t v12;
  CFStringRef v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (a3)
  {
    v5 = sub_100070EB0(*(_QWORD *)(a3 + 64), a2);
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v8 = sub_1000648F0(v5);
      objc_msgSend(v7, "WFLog:message:", 3, "%s: device powered %s, manager->poweredState %s", "__WiFiDeviceManagerPowerEventCallback", v8, sub_1000648F0(*(_DWORD *)(a3 + 20)));
    }
    objc_autoreleasePoolPop(v6);
    if (v5 == 1)
    {
      v9 = *(unsigned int *)(a3 + 20);
      if ((_DWORD)v9 == 1)
      {
        *(_DWORD *)(a3 + 192) = 3;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000285E4(a3, 0x12uLL);
        }
        else
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 18, sub_100025C3C(*(_QWORD *)(a3 + 64)));
          sub_1000FBA80(a3, 2, (uint64_t)"__WiFiDeviceManagerPowerEventCallback");
        }
        sub_1000FF824(a3);
        goto LABEL_13;
      }
    }
    else
    {
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      v12 = 3;
      memset(v11, 0, sizeof(v11));
      DWORD2(v11[0]) = 3;
      v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Power Off"));
      sub_100106C34(a3, (uint64_t)v11);
      sub_100107084(a3);
      v9 = *(unsigned int *)(a3 + 20);
      if (v5 == (_DWORD)v9)
      {
LABEL_13:
        v10 = *(void **)(a3 + 7368);
        if (v10)
          objc_msgSend(v10, "setPowerState:forInterface:", v5 != 0, a2);
        return;
      }
    }
    if (sub_100070FA8(*(_QWORD *)(a3 + 64), a2, v9))
      return;
    sub_10010906C(a3, (uint64_t)a2);
    goto LABEL_13;
  }
}

void sub_1000E9FA4(int a1, const void *a2, uint64_t a3, CFDictionaryRef theDict)
{
  void *Value;
  const void *v8;
  void *v9;
  const void *v10;
  CFTypeRef v11;
  CFTypeRef v12;
  int v13;
  int v14;
  void *v15;
  char v16;
  int v17;
  unsigned int v18;
  void *v19;
  CFNumberRef v20;
  void *v21;
  void *v22;
  int v23;
  const void *v24;
  const char *v25;
  __CFArray *Mutable;
  CFNumberRef v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  NSObject *v32;
  void *v33;
  const void *v34;
  const void *v35;
  _WORD *v36;
  char v37;
  void *v38;
  unsigned int v39;
  void *v40;
  unsigned int v41;
  const void *v42;
  int v43;
  char v44;
  void *v45;
  void *v46;
  const void *v47;
  void *v48;
  uint64_t v49;
  unsigned int v50;
  void *v51;
  uint64_t v52;
  const __CFString *v53;
  const __CFString *v54;
  int v55;
  int v56;
  void *v57;
  const void *v58;
  const void *v59;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  uint64_t v63;
  const __CFNumber *v64;
  const __CFNumber *v65;
  void *v66;
  unsigned __int8 *v67;
  int v68;
  unsigned int v69;
  void *v70;
  void *v71;
  const void *v72;
  CFIndex v73;
  CFIndex v74;
  CFIndex v75;
  const void *v76;
  void *v77;
  CFIndex v78;
  CFIndex v79;
  CFIndex v80;
  const void *v81;
  const void *v82;
  const void *v83;
  void *v84;
  int v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  _BOOL4 v93;
  int v94;
  int v95;
  char v96;
  const void *v97;
  void *v98;
  const __CFDictionary *v99;
  const __CFDictionary *v100;
  const void *v101;
  const void *v102;
  uint64_t v103;
  const void *v104;
  uint64_t v105;
  const __CFNumber *v106;
  id v107;
  const __CFArray *v108;
  const __CFArray *v109;
  void *v110;
  const char *v111;
  uint64_t v112;
  id v113;
  int v114;
  const __CFNumber *v115;
  const __CFNumber *v116;
  const __CFNumber *v117;
  _BOOL4 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  id v122;
  unsigned int v123;
  int v124;
  CFNumberRef v125;
  CFAbsoluteTime Current;
  CFDateRef v127;
  const __CFString *v128;
  _WORD *v129;
  const void *v130;
  void *v131;
  void *v132;
  const void *v133;
  const void *v134;
  const void *v135;
  char v136;
  const __CFString *v137;
  void *v138;
  __CFDictionary *v139;
  CFNumberRef v140;
  CFNumberRef v141;
  const __CFDictionary **v142;
  int v143;
  const __CFDictionary **v144;
  NSObject *v145;
  dispatch_time_t v146;
  void *v147;
  const void *v148;
  void *v149;
  NSObject *v150;
  dispatch_time_t v151;
  void *v152;
  const __CFNumber *v153;
  unsigned __int8 *v154;
  unsigned int v155;
  int v156;
  _WORD *v157;
  const void *v158;
  void *v159;
  uint64_t v160;
  void *v161;
  void *v162;
  const void *v163;
  const __CFString *v164;
  uint64_t v165;
  unsigned int v166;
  const __CFString *v167;
  uint64_t v168;
  _BOOL4 v169;
  void *v170;
  void *context;
  void *v172;
  uint64_t v173;
  unsigned int v174;
  int v175;
  int v176;
  unsigned __int8 *v177;
  _QWORD v178[6];
  unsigned int v179;
  char v180;
  char v181;
  unsigned int v182;
  unsigned int v183;
  _QWORD v184[5];
  _QWORD block[8];
  uint64_t v186;
  uint64_t *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  _DWORD valuePtr[3];
  CFRange v197;

  if (!a3 || !theDict)
    return;
  v177 = (unsigned __int8 *)(a3 + 5216);
  v195 = 0;
  v194 = 0;
  Value = (void *)CFDictionaryGetValue(theDict, CFSTR("LINK_CHANGED_NETWORK"));
  v8 = Value;
  if (Value || (v8 = *(const void **)(a3 + 3512)) != 0)
    v9 = sub_10002B170(a3, v8, 1);
  else
    v9 = 0;
  v176 = *(unsigned __int8 *)(a3 + 3411);
  v177[1400] = 0;
  *(_DWORD *)(a3 + 3392) = 0;
  v10 = *(const void **)(a3 + 6608);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a3 + 6608) = 0;
  }
  if (*(_QWORD *)(a3 + 4040))
  {
    v190 = 0;
    v191 = &v190;
    v192 = 0x2020000000;
    v193 = 0;
    v186 = 0;
    v187 = &v186;
    v188 = 0x2020000000;
    v189 = 0;
    if (a2)
    {
      v11 = CFRetain(a2);
      v191[3] = (uint64_t)v11;
    }
    v12 = CFRetain(theDict);
    v187[3] = (uint64_t)v12;
    if (!Value)
      goto LABEL_55;
    v13 = *(unsigned __int8 *)(a3 + 3412);
    v14 = *(unsigned __int8 *)(a3 + 3432);
    if (*(_BYTE *)(a3 + 55))
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "!!!! Simulating wifi-assist override condition (Debug Mode) !!!!");
      objc_autoreleasePoolPop(v15);
    }
    if (v13 || *(_BYTE *)(a3 + 55) && *(_BYTE *)(a3 + 52))
    {
      v16 = 0;
      v17 = 1;
    }
    else
    {
      v17 = 0;
      v16 = 1;
    }
    *(_BYTE *)(a3 + 52) = v17;
    if (v14 || *(_BYTE *)(a3 + 55) && *(_BYTE *)(a3 + 54))
    {
      *(_BYTE *)(a3 + 54) = 1;
      v18 = v17 + 1;
    }
    else
    {
      *(_BYTE *)(a3 + 54) = 0;
      if ((v16 & 1) != 0)
      {
        CFDictionarySetValue(theDict, CFSTR("WIFI_ASSIST_OVERRIDE"), kCFBooleanFalse);
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifi-assist override to auto", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist");
        goto LABEL_45;
      }
      v18 = 1;
    }
    CFDictionarySetValue(theDict, CFSTR("WIFI_ASSIST_OVERRIDE"), kCFBooleanTrue);
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifi-assist override to On for %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_10002B088(Value));
    objc_autoreleasePoolPop(v19);
    if (v18 > 1)
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        valuePtr[0] = 0;
        v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
        if (!v27)
          goto LABEL_351;
        CFArrayAppendValue(Mutable, v27);
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifi-assist override reason moving network %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_10002B088(Value));
        objc_autoreleasePoolPop(v28);
        CFRelease(v27);
        valuePtr[0] = 1;
        v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
        if (v20)
        {
          CFArrayAppendValue(Mutable, v20);
          v29 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:wifi-assist override reason network bad reputation %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_10002B088(Value));
          objc_autoreleasePoolPop(v29);
          CFDictionarySetValue(theDict, CFSTR("WIFI_ASSIST_OVERRIDE_REASONS"), Mutable);
        }
        else
        {
LABEL_351:
          v170 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFNumberCreate failed", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist");
          objc_autoreleasePoolPop(v170);
          v20 = 0;
        }
        goto LABEL_47;
      }
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFArrayCreateMutable failed", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist");
    }
    else
    {
      valuePtr[0] = *(_BYTE *)(a3 + 52) == 0;
      v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
      if (v20)
      {
        CFDictionarySetValue(theDict, CFSTR("WIFI_ASSIST_OVERRIDE_REASON"), v20);
        v21 = objc_autoreleasePoolPush();
        v22 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v23 = *(unsigned __int8 *)(a3 + 52);
          v24 = sub_10002B088(Value);
          v25 = "moving";
          if (!v23)
            v25 = "bad reputation";
          objc_msgSend(v22, "WFLog:message:", 4, "%s: wifi-assist override reason %s network %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", v25, v24);
        }
        objc_autoreleasePoolPop(v21);
        goto LABEL_46;
      }
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFNumberCreate failed", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist");
    }
LABEL_45:
    objc_autoreleasePoolPop(v30);
    v20 = 0;
LABEL_46:
    Mutable = 0;
LABEL_47:
    if (*(_BYTE *)(a3 + 55))
    {
      v31 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "!!!! End simulating wifi-assist override condition (Debug Mode) !!!!");
      objc_autoreleasePoolPop(v31);
      *(_BYTE *)(a3 + 52) = 0;
      *(_WORD *)(a3 + 54) = 0;
    }
    if (v20)
      CFRelease(v20);
    if (Mutable)
      CFRelease(Mutable);
LABEL_55:
    if (*(_QWORD *)(a3 + 240))
    {
      CFRetain((CFTypeRef)a3);
      v32 = *(NSObject **)(a3 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100126258;
      block[3] = &unk_100230978;
      block[4] = &v190;
      block[5] = &v186;
      block[6] = a3;
      block[7] = a2;
      dispatch_async(v32, block);
    }
    else
    {
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerLinkEventCallback");
      objc_autoreleasePoolPop(v33);
      v34 = (const void *)v191[3];
      if (v34)
      {
        CFRelease(v34);
        v191[3] = 0;
      }
      v35 = (const void *)v187[3];
      if (v35)
      {
        CFRelease(v35);
        v187[3] = 0;
      }
    }
    _Block_object_dispose(&v186, 8);
    _Block_object_dispose(&v190, 8);
  }
  v36 = (_WORD *)(a3 + 8606);
  if (!Value)
  {
    if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS") && v177[173] && v177[170])
    {
      v39 = objc_msgSend(*(id *)(a3 + 6752), "isNANPublisherStarted");
      v40 = objc_autoreleasePoolPush();
      if (v39)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Publisher Already Started", "__WiFiDeviceManagerLinkEventCallback");
        objc_autoreleasePoolPop(v40);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Sending CSA as NAN PH needs to be started!", "__WiFiDeviceManagerLinkEventCallback");
        objc_autoreleasePoolPop(v40);
        sub_10006AAE0(*(_QWORD *)(a3 + 64));
        sub_1001079C8(a3);
      }
      v177[173] = 0;
    }
    if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance")
      && -[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
    {
      sub_1000247B8(*(_QWORD *)(a3 + 120), 0, 0);
      -[WiFiAIRAgent terminateRequest](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "terminateRequest");
    }
    if (!v9)
    {
      v97 = *(const void **)(a3 + 3512);
      if (v97)
      {
        v9 = (void *)CFRetain(v97);
      }
      else
      {
        v9 = sub_1000764F8(*(_QWORD *)(a3 + 64));
        if (v9)
        {
          v108 = sub_10002B170(a3, v9, 1);
          if (v108)
          {
            v109 = v108;
            CFRelease(v9);
            v9 = v109;
          }
        }
      }
    }
    *v36 = 0;
    sub_1000FA884(a3, (uint64_t)a2);
    sub_1000FAF80((const void *)a3);
    *(_BYTE *)(a3 + 3411) = 0;
    *(_QWORD *)(a3 + 3416) = 0;
    *(CFAbsoluteTime *)(a3 + 3424) = CFAbsoluteTimeGetCurrent();
    *(_BYTE *)(a3 + 3413) = 0;
    *(CFAbsoluteTime *)(a3 + 6952) = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(a3 + 6944) = 0;
    sub_1000F9DAC((char *)a3, 1, 0);
    if (v177[1840])
      sub_10006A75C(*(_QWORD *)(a3 + 64), 0, 0, 0);
    v98 = objc_autoreleasePoolPush();
    v99 = sub_100069A5C(*(_QWORD *)(a3 + 64), a2);
    if (v99)
    {
      v100 = v99;
      v101 = CFDictionaryGetValue(v99, CFSTR("DEAUTH_EA"));
      if (v101)
      {
        v102 = v101;
        v103 = *(_QWORD *)(a3 + 3512);
        if (v103)
        {
          v104 = sub_10002BE64(v103, CFSTR("BSSID"));
          if (v104)
          {
            v105 = (uint64_t)v104;
            if (CFEqual(v104, v102))
            {
              v106 = (const __CFNumber *)CFDictionaryGetValue(v100, CFSTR("DEAUTH_REASON"));
              if (v106)
              {
                LODWORD(v190) = -1431655766;
                if (CFNumberGetValue(v106, kCFNumberIntType, &v190))
                {
                  v107 = sub_100027D10(*(_QWORD *)(a3 + 3512));
                  if ((_DWORD)v190 == 15
                    && (objc_msgSend(*(id *)(a3 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v107) & 1) == 0&& !*(_DWORD *)(a3 + 3280))
                  {
                    if (objc_msgSend(v107, "isEAP"))
                      v174 = objc_msgSend(objc_msgSend(v107, "matchingKnownNetworkProfile"), "isProfileBased");
                    else
                      v174 = 0;
                    v110 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                    {
                      v111 = "NO";
                      if (v174)
                        v111 = "YES";
                      v172 = v110;
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hasEnterprisePolicy: %s", "__WiFiDeviceManagerProcessDeauth", v111);
                      v110 = v172;
                    }
                    objc_autoreleasePoolPop(v110);
                    v112 = *(_QWORD *)(a3 + 64);
                    if (v174)
                    {
                      sub_100072E44(v112, *(const void **)(a3 + 3512), 1);
                    }
                    else if (!sub_100066DF8(v112))
                    {
                      *(_DWORD *)(a3 + 3280) = sub_100119668(a3, (uint64_t)a2, 1, 1, *(const void **)(a3 + 3512), 0);
                    }
                  }
                  v113 = sub_1000FCB38(a3, 4, (int)v190, v105, 5);
                  objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v113, v107);

                }
              }
            }
          }
        }
      }
      CFRelease(v100);
    }
    v114 = *(_DWORD *)(a3 + 3280);
    objc_autoreleasePoolPop(v98);
    valuePtr[0] = 0;
    v182 = -1431655766;
    v183 = 0;
    v181 = 0;
    v115 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_REASON_CODE"));
    v116 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_IS_INVOL"));
    v117 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_SUBREASON_CODE"));
    if (v115)
    {
      CFNumberGetValue(v115, kCFNumberIntType, valuePtr);
      if (valuePtr[0] == 1000)
      {
        v119 = 3;
        LOBYTE(v118) = 1;
        if (!v117)
        {
LABEL_242:
          if (v116)
            CFNumberGetValue(v116, kCFNumberSInt8Type, &v181);
          v120 = valuePtr[0];
          if (v9 && valuePtr[0] == 4)
          {
            if (sub_1000C475C((uint64_t)v9))
              v120 = 1029;
            if (sub_100073514(*(_QWORD *)(a3 + 64)) < 0x1F)
              v120 = 1030;
            if (sub_100007F24((uint64_t)v9))
              v121 = v120;
            else
              v121 = 1031;
            v122 = sub_100027D10((uint64_t)v9);
            v123 = objc_msgSend(*(id *)(a3 + 6648), "isNetworkInDenyListedState:scanResult:", 3, v122);
            if (objc_msgSend(*(id *)(a3 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v122) | v123)
              v120 = 1032;
            else
              v120 = v121;

          }
          else if (!v9)
          {
            goto LABEL_281;
          }
          if (sub_10001395C((uint64_t)v9))
          {
            v124 = valuePtr[0];
            v175 = v114;
            v173 = v119;
            if (v181)
            {
              if (valuePtr[0] == 1 && v183 == 7)
                v124 = 1;
              else
                v124 = 255;
            }
            LODWORD(v190) = v124;
            v125 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v190);
            sub_10002C478((uint64_t)v9, CFSTR("lastDisconnectReasonKey"), v125);
            Current = CFAbsoluteTimeGetCurrent();
            v127 = CFDateCreate(kCFAllocatorDefault, Current);
            sub_10002C478((uint64_t)v9, CFSTR("lastDisconnectTimestampKey"), v127);
            if (v177[1680])
            {
              if (v181)
              {
                if (valuePtr[0] == 1 && v183 == 3)
                {
                  v128 = (const __CFString *)sub_10002B088(v9);
                  v129 = sub_1000C323C(v128);
                  if (v129)
                  {
                    v130 = v129;
                    sub_10002C478((uint64_t)v129, CFSTR("lastDisconnectTimestampKey"), v127);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 6928), v130);
                    v131 = objc_autoreleasePoolPush();
                    v132 = (void *)qword_10026DD20;
                    if (qword_10026DD20)
                    {
                      context = v131;
                      v133 = sub_10002B088(v9);
                      objc_msgSend(v132, "WFLog:message:", 3, "%s: Blacklisting %@ hotspot: reason (%d) subreason (%d) \n", "__WiFiDeviceManagerLinkEventCallback", v133, valuePtr[0], v183);
                      v131 = context;
                    }
                    objc_autoreleasePoolPop(v131);
                    CFRelease(v130);
                  }
                }
              }
            }
            v134 = *(const void **)(a3 + 6976);
            if (v134)
            {
              CFRelease(v134);
              *(_QWORD *)(a3 + 6976) = 0;
            }
            *(_QWORD *)(a3 + 6976) = 0;
            *(_DWORD *)(a3 + 6460) = *(_DWORD *)(a3 + 6208);
            *(_DWORD *)(a3 + 6456) = v190;
            sub_10005C1E0((unsigned int *)(a3 + 6456));
            v114 = v175;
            if (v125)
              CFRelease(v125);
            if (v127)
              CFRelease(v127);
            v119 = v173;
          }
LABEL_281:
          v177[1680] = 0;
          v135 = *(const void **)(a3 + 6976);
          if (v135)
          {
            CFRelease(v135);
            *(_QWORD *)(a3 + 6976) = 0;
          }
          *(_QWORD *)(a3 + 6976) = 0;
          v177[1771] = 0;
          v136 = !v118;
          if (!v9)
            v136 = 1;
          if ((v136 & 1) == 0)
          {
            v137 = (const __CFString *)sub_10002BE64((uint64_t)v9, CFSTR("BSSID"));
            sub_1000C8160((uint64_t)v9, v137, v119);
            v138 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updating network disconnect reason to %d", "__WiFiDeviceManagerLinkEventCallback", v119);
            objc_autoreleasePoolPop(v138);
            sub_1001053C8((NSObject **)a3, v9);
          }
          sub_100046660(*(_QWORD *)(a3 + 120), 0, 1, 0);
          if (*(_BYTE *)(a3 + 433))
            sub_100024EE4(a3, 2);
          objc_msgSend(*(id *)(a3 + 3656), "setLinkDown");
          if (*(_BYTE *)(a3 + 433))
          {
            v139 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            LODWORD(v190) = *(unsigned __int8 *)(a3 + 417);
            v140 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v190);
            CFDictionarySetValue(v139, CFSTR("CATS_SCAN_METRIC_CACHE_HITS"), v140);
            if (v140)
              CFRelease(v140);
            LODWORD(v186) = *(unsigned __int8 *)(a3 + 418);
            v141 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v186);
            CFDictionarySetValue(v139, CFSTR("CATS_SCAN_METRIC_CACHE_MISS"), v141);
            if (v141)
              CFRelease(v141);
            sub_100061DD4(v139);
            if (v139)
              CFRelease(v139);
          }
          v142 = (const __CFDictionary **)v9;
          if (!v9)
            v142 = *(const __CFDictionary ***)(a3 + 3512);
          v178[0] = _NSConcreteStackBlock;
          v178[1] = 3221225472;
          v178[2] = sub_100126AA4;
          v178[3] = &unk_1002317E0;
          v180 = v181;
          v178[4] = a3;
          v178[5] = v120;
          v179 = v183;
          sub_10010367C(a3, v142, (uint64_t)v178);
          if (v9)
          {
            v143 = sub_10000BE8C((uint64_t)v9);
            v144 = (const __CFDictionary **)v9;
            if (v143)
            {
              *(_BYTE *)(a3 + 992) = v181 == 0;
              if ((unint64_t)(v120 - 1) > 1)
              {
                sub_10012634C(a3, (uint64_t)v9, v120, v183);
              }
              else
              {
                *(_QWORD *)(a3 + 976) = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
                *(_DWORD *)(a3 + 984) = v120;
                *(_DWORD *)(a3 + 988) = v183;
                v145 = *(NSObject **)(a3 + 1000);
                v146 = dispatch_time(0, 10000000000);
                dispatch_source_set_timer(v145, v146, 0xFFFFFFFFFFFFFFFFLL, 0);
                v147 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: trigger %d second timer to check whether or not CarPlay disconnect is intended.", "__WiFiDeviceManagerLinkEventCallback", 10);
                objc_autoreleasePoolPop(v147);
              }
              dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1056), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
              v144 = (const __CFDictionary **)v9;
            }
          }
          else
          {
            v144 = *(const __CFDictionary ***)(a3 + 3512);
          }
          v148 = sub_10002B634(*(const __CFArray **)(a3 + 3704), v144);
          if (v148)
          {
            LODWORD(v194) = 1;
            sub_100061728((uint64_t)v148, (uint64_t)&v194);
            sub_100061494((unsigned int *)&v194);
          }
          sub_100126B1C(a3);
          if (v9 && sub_10002DAB4((uint64_t)v9))
            sub_100072E44(*(_QWORD *)(a3 + 64), v9, 0);
          CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 272));
          if (v114 != 14 && v176)
          {
            *(_DWORD *)(a3 + 192) = 4;
            if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
            {
              sub_1000285E4(a3, 2uLL);
            }
            else
            {
              objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 2, sub_100025C3C(*(_QWORD *)(a3 + 64)));
              sub_1000FBA80(a3, 2, (uint64_t)"__WiFiDeviceManagerLinkEventCallback");
            }
          }
          if (*(_QWORD *)(a3 + 5408) && !*(_BYTE *)(a3 + 3305))
          {
            v149 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disassociated and auto-join disabled. Releasing PPM resource.", "__WiFiDeviceManagerLinkEventCallback");
            objc_autoreleasePoolPop(v149);
            sub_1000FB8B8(a3);
          }
          sub_1001147D4(a3, v9, 0);
          if (*(_DWORD *)(a3 + 72) == 7)
          {
            v150 = *(NSObject **)(a3 + 5528);
            v151 = dispatch_time(0, 45000000000);
            dispatch_source_set_timer(v150, v151, 0xFFFFFFFFFFFFFFFFLL, 0);
          }
          v152 = objc_autoreleasePoolPush();
          objc_msgSend(*(id *)(a3 + 6624), "disarmHomeNetworkTransitionTimer");
          objc_msgSend(*(id *)(a3 + 6704), "dismissJoinAlerts");
          objc_autoreleasePoolPop(v152);
          v153 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("CLIENT_REASON"));
          v154 = v177;
          if (!v153)
            goto LABEL_340;
          CFNumberGetValue(v153, kCFNumberIntType, &v182);
          v155 = v182;
          if (v182 == 2)
          {
            v156 = sub_100077738(*(_QWORD *)(a3 + 64));
            if (v9 && v156 == 1)
            {
              v157 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
              if (v157)
              {
                v158 = v157;
                v159 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client disabled link due to captive %@", "__WiFiDeviceManagerLinkEventCallback", sub_10002B088(v158));
                objc_autoreleasePoolPop(v159);
                v160 = sub_100025C3C(*(_QWORD *)(a3 + 64));
                sub_100119668(a3, v160, 6, 0, v158, 0);
                CFRelease(v158);
LABEL_339:
                v154 = v177;
                goto LABEL_340;
              }
              goto LABEL_340;
            }
            v155 = v182;
          }
          if (v155)
          {
            v161 = objc_autoreleasePoolPush();
            v162 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v163 = sub_10002B088(v9);
              v164 = sub_100064E30(v182);
              v165 = v182;
              v166 = sub_100077738(*(_QWORD *)(a3 + 64));
              objc_msgSend(v162, "WFLog:message:", 3, "%s: client disabled network %@ with reason %@(%d) assocType %@", "__WiFiDeviceManagerLinkEventCallback", v163, v164, v165, sub_100064E80(v166));
            }
            objc_autoreleasePoolPop(v161);
            goto LABEL_339;
          }
LABEL_340:
          v154[1497] = 0;
          sub_1001091D8(a3, 6u, valuePtr[0]);
          *(_DWORD *)(a3 + 3468) = 0;
          *(_OWORD *)(a3 + 3788) = 0u;
          *(_OWORD *)(a3 + 3804) = 0u;
          *(_QWORD *)(a3 + 3817) = 0;
          if (v9 && sub_1000C5964((uint64_t)v9))
          {
            v167 = sub_1000C3C04(v9);
            sub_1000DA384((uint64_t)v167);
          }
          goto LABEL_343;
        }
LABEL_241:
        CFNumberGetValue(v117, kCFNumberIntType, &v183);
        goto LABEL_242;
      }
      if (valuePtr[0] == 2)
      {
        v118 = *(_DWORD *)(a3 + 6208) < -80;
        v119 = (4 * v118);
        if (!v117)
          goto LABEL_242;
        goto LABEL_241;
      }
    }
    LOBYTE(v118) = 0;
    v119 = 0;
    if (!v117)
      goto LABEL_242;
    goto LABEL_241;
  }
  *v36 = 256;
  if (sub_1000CA53C((uint64_t)Value))
  {
    *(_BYTE *)v36 = 1;
    *(_OWORD *)(a3 + 8528) = 0u;
    *(_OWORD *)(a3 + 8544) = 0u;
    *(_OWORD *)(a3 + 8560) = 0u;
    *(CFAbsoluteTime *)(a3 + 8576) = CFAbsoluteTimeGetCurrent();
  }
  sub_1000FA884(a3, (uint64_t)a2);
  if (*(_DWORD *)(a3 + 72) == 7)
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 5528), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  v37 = 1;
  *(_BYTE *)(a3 + 3411) = 1;
  *(CFAbsoluteTime *)(a3 + 3416) = CFAbsoluteTimeGetCurrent();
  if (!sub_1000CB8DC((CFDictionaryRef *)Value))
    v37 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isMovingNetwork:", Value);
  sub_1000F9CF0(a3, v37);
  *(_BYTE *)(a3 + 3432) = 0;
  *(_WORD *)(a3 + 3448) = 0;
  if (v9
    && kCFBooleanFalse == sub_10002BE64((uint64_t)v9, CFSTR("WiFiNetworkAttributeIsTCPGood"))
    && objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isHistoricallyBadLinkQualityNetwork:", Value))
  {
    *(_BYTE *)(a3 + 3432) = 1;
  }
  if (!*(_BYTE *)(a3 + 3412))
    sub_1000F9FBC((unsigned __int8 *)a3);
  sub_1000FE5A4(a3, Value);
  sub_1000765BC(*(_QWORD *)(a3 + 64), (uint64_t)Value);
  if (v177[3])
  {
    if (sub_100107828(a3, 4))
    {
      sub_1000FE648((uint64_t *)a3, Value, 1, 3);
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting interface rank %s : reason %s ", "__WiFiDeviceManagerLinkEventCallback", "kSCNetworkServicePrimaryRankNever", " Concurrency");
      objc_autoreleasePoolPop(v38);
    }
    else
    {
      sub_1000F7F48(a3, a2, 1007, "__WiFiDeviceManagerLinkEventCallback", 8846);
    }
  }
  else
  {
    sub_1000FE648((uint64_t *)a3, Value, 0, 0);
  }
  sub_1000FE9FC(a3, Value);
  if (v9)
  {
    v41 = sub_1000C8B54((uint64_t)v9);
    v42 = sub_10002BE64((uint64_t)Value, CFSTR("BSSID"));
    v43 = sub_1000C86EC(v9, v42);
    v44 = v43;
    if (v43)
    {
      v45 = objc_autoreleasePoolPush();
      v46 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v47 = sub_10002BE64((uint64_t)Value, CFSTR("BSSID"));
        objc_msgSend(v46, "WFLog:message:", 3, "Edge BSS detected - BSSID %@ SSID %@", v47, sub_10002B088(Value));
      }
      objc_autoreleasePoolPop(v45);
    }
    if (v41)
    {
      v48 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Detected multiAP environment for %@", sub_10002B088(v9));
      objc_autoreleasePoolPop(v48);
    }
    v49 = *(_QWORD *)(a3 + 64);
    v50 = sub_10002A724(a3, v9);
    sub_100066F20(v49, (uint64_t)a2, v9, v50, 0, 0, 0);
    v51 = v9;
  }
  else
  {
    sub_100066F20(*(_QWORD *)(a3 + 64), (uint64_t)a2, 0, 1u, 0, 0, 0);
    v44 = 0;
    v51 = Value;
  }
  sub_100046660(*(_QWORD *)(a3 + 120), v51, 0, v44);
  objc_msgSend(*(id *)(a3 + 3656), "setLinkUpForNetwork:", v51);
  if (*(_BYTE *)(a3 + 433))
    *(_WORD *)(a3 + 417) = 0;
  *(CFAbsoluteTime *)(a3 + 704) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a3 + 952) = CFAbsoluteTimeGetCurrent();
  v52 = *(_QWORD *)(a3 + 976);
  if (v52)
  {
    v53 = (const __CFString *)sub_10002BE64((uint64_t)v51, CFSTR("SSID_STR"));
    v54 = (const __CFString *)sub_10002BE64(v52, CFSTR("SSID_STR"));
    v55 = 0;
    v56 = 1021;
    if (v53 && v54)
    {
      if (CFStringCompare(v53, v54, 0))
      {
        v55 = 0;
      }
      else
      {
        v56 = *(_DWORD *)(a3 + 984);
        v55 = *(_DWORD *)(a3 + 988);
        v57 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID (%@) matches", "__WiFiDeviceManagerLinkEventCallback", v53);
        objc_autoreleasePoolPop(v57);
      }
    }
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1000), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    sub_10012634C(a3, v52, v56, v55);
    v58 = *(const void **)(a3 + 976);
    if (v58)
    {
      CFRelease(v58);
      *(_QWORD *)(a3 + 976) = 0;
    }
  }
  if (sub_10000BE8C((uint64_t)Value))
  {
    *(_OWORD *)(a3 + 768) = 0u;
    *(_OWORD *)(a3 + 784) = 0u;
    *(_QWORD *)(a3 + 944) = 0;
    *(_OWORD *)(a3 + 912) = 0u;
    *(_OWORD *)(a3 + 928) = 0u;
    *(_OWORD *)(a3 + 880) = 0u;
    *(_OWORD *)(a3 + 896) = 0u;
    *(_OWORD *)(a3 + 848) = 0u;
    *(_OWORD *)(a3 + 864) = 0u;
    *(_OWORD *)(a3 + 816) = 0u;
    *(_OWORD *)(a3 + 832) = 0u;
    *(_OWORD *)(a3 + 800) = 0u;
    *(_OWORD *)(a3 + 736) = 0u;
    *(_OWORD *)(a3 + 752) = 0u;
    *(_DWORD *)(a3 + 748) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 768) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 840) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 792) = 0x7FFFFFFF;
    *(_QWORD *)(a3 + 816) = 0xFFFFFF807FFFFFFFLL;
    *(CFAbsoluteTime *)(a3 + 736) = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(a3 + 884) = 0;
    *(_BYTE *)(a3 + 1008) = 0;
    *(_QWORD *)(a3 + 1032) = 0;
    *(_OWORD *)(a3 + 1016) = 0u;
    *(_QWORD *)(a3 + 1048) = 0;
    *(_QWORD *)(a3 + 1040) = 0;
  }
  v184[0] = _NSConcreteStackBlock;
  v184[1] = 3221225472;
  v184[2] = sub_100126964;
  v184[3] = &unk_1002314B8;
  v184[4] = a3;
  sub_10010367C(a3, (const __CFDictionary **)v51, (uint64_t)v184);
  v59 = sub_10002B634(*(const __CFArray **)(a3 + 3704), (const __CFDictionary **)v51);
  if (v59)
  {
    LODWORD(v194) = 0;
    sub_100061728((uint64_t)v59, (uint64_t)&v194);
    sub_100061494((unsigned int *)&v194);
  }
  if (sub_10002DA5C((_BOOL8)Value) || sub_1000C475C((uint64_t)Value))
    sub_1000FF824(a3);
  Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3536));
  LODWORD(v190) = 0;
  v177[376] = 0;
  if (Count)
  {
    v197.length = Count;
    v197.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3536), v197, Value);
    if (FirstIndexOfValue != -1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3536), FirstIndexOfValue);
      if (ValueAtIndex)
      {
        v63 = (uint64_t)ValueAtIndex;
        v64 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("WiFiManagerKnownNetworksEventType"));
        v65 = v64;
        if (v64)
          CFNumberGetValue(v64, kCFNumberIntType, &v190);
        if (!sub_1000C5378(v63) && (!v65 || (_DWORD)v190 != 3))
        {
          v177[376] = 1;
          v66 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enabling learning logic for Hidden property of the network\n");
          objc_autoreleasePoolPop(v66);
        }
      }
    }
  }
  v67 = v177;
  if (v177[1840] && v177[3] && *v177 <= 0xDu && (v177[1841] & 4) != 0)
  {
    if ((v68 = sub_100017A54((uint64_t)Value, CFSTR("CHANNEL")), v69 = *v177, v69 <= 0xD)
      && v68 <= 13
      && v69 != v68
      || v69 >= 0xF && v68 >= 15 && v69 != v68)
    {
      *v177 = v68;
      v70 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Update MIS channel %d\n", *v177);
      objc_autoreleasePoolPop(v70);
      v67 = v177;
    }
  }
  if (*(_QWORD *)(a3 + 6744))
  {
    v67[1681] = 0;
    if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6912)))
    {
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 6912));
      v71 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Clearing all user suppressed Auto Hotspot Devices \n", "__WiFiDeviceManagerClearSuppressedAutoHotSpotDevices");
      objc_autoreleasePoolPop(v71);
    }
    if (objc_msgSend(*(id *)(a3 + 6936), "count"))
      objc_msgSend(*(id *)(a3 + 6936), "removeAllObjects");
    v72 = sub_10002BE64((uint64_t)Value, CFSTR("SSID_STR"));
    if (sub_10001395C((uint64_t)Value))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6920)))
      {
        v73 = CFArrayGetCount(*(CFArrayRef *)(a3 + 6920));
        if (v73 >= 1)
        {
          v74 = v73;
          v75 = 0;
          while (1)
          {
            v76 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 6920), v75);
            if (objc_msgSend(*(id *)(a3 + 6744), "isEqualHotspotDevicesName:compareTo:", v76, v72))
              break;
            if (v74 == ++v75)
              goto LABEL_163;
          }
          v77 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Connected to Personal Hotspot %@ Unblacklisting %@\n", "__WiFiDeviceManagerClearSuppressedAutoHotSpotDevices", v72, v76);
          objc_autoreleasePoolPop(v77);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a3 + 6920), v75);
        }
      }
    }
LABEL_163:
    if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6928)))
    {
      v78 = CFArrayGetCount(*(CFArrayRef *)(a3 + 6928));
      if (v78 >= 1)
      {
        v79 = v78;
        v80 = 0;
        while (1)
        {
          v81 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 6928), v80);
          if (v81)
          {
            v82 = v81;
            if (!sub_10002BE64((uint64_t)v81, CFSTR("lastDisconnectTimestampKey")))
              break;
            if (sub_10001395C((uint64_t)Value))
            {
              v83 = sub_10002B088(v82);
              if (CFEqual(v72, v83))
                break;
            }
            if (sub_1000C4C88((uint64_t)v82))
              break;
          }
          if (v79 == ++v80)
            goto LABEL_176;
        }
        v84 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Allowlisting Personal Hotspot %@\n", "__WiFiDeviceManagerClearSuppressedAutoHotSpotDevices", sub_10002B088(v82));
        objc_autoreleasePoolPop(v84);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a3 + 6928), v80);
      }
    }
  }
LABEL_176:
  v85 = sub_100017A54((uint64_t)Value, CFSTR("RSSI"));
  v86 = *(_QWORD *)(a3 + 64);
  v87 = sub_100077738(v86);
  sub_1000521A8(v86, 1, 0, v87, dword_10026DD64, v85, v51, SHIDWORD(v194));
  v88 = *(_QWORD *)(a3 + 3512);
  if (v88 && sub_10001395C(v88))
  {
    LODWORD(v190) = -1431655766;
    v89 = sub_100077F20(*(_QWORD *)(a3 + 64), &v190);
    if ((_DWORD)v89)
    {
      v90 = v89;
      LODWORD(v190) = 111;
      v91 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " fail to get auth type after connect, error %d", v90);
    }
    else
    {
      v91 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " Auth type for PH client is 0x%X", v190);
    }
    objc_autoreleasePoolPop(v91);
    v92 = v190;
    v93 = sub_1000C3B8C(*(_QWORD *)(a3 + 3512));
    v94 = sub_1000C433C(*(const __CFDictionary **)(a3 + 3512));
    *(_DWORD *)(a3 + 6468) = sub_100051EBC(v92, v93, v94);
  }
  dword_10026DD64 = 0;
  sub_1001091D8(a3, 3u, 0);
  *(_BYTE *)(a3 + 8821) = 0;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    sub_100013754(a3);
  v95 = sub_100008CEC((uint64_t)Value);
  *(_WORD *)(a3 + 3865) = 0;
  if (v95 > 79)
  {
    if (v95 == 80)
    {
      v96 = 2;
      goto LABEL_195;
    }
    if (v95 == 160)
    {
      v96 = 3;
      goto LABEL_195;
    }
  }
  else if (v95 == 20)
  {
    *(_BYTE *)(a3 + 3864) = 0;
  }
  else if (v95 == 40)
  {
    v96 = 1;
LABEL_195:
    *(_BYTE *)(a3 + 3864) = v96;
  }
LABEL_343:
  *(_DWORD *)(a3 + 6208) = 0;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_100013754(a3);
    sub_10000C120(a3);
  }
  sub_1000FE2A4(a3);
  v168 = *(_QWORD *)(a3 + 64);
  if (Value)
    v169 = sub_100126BCC(a3, (const __CFDictionary **)Value) != 0;
  else
    v169 = 0;
  sub_1000719FC(v168, v169);
  if (v9)
    CFRelease(v9);
}

void sub_1000EBD30(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EBD54(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, _QWORD);

  v2 = *(uint64_t (**)(uint64_t, _QWORD))(a2 + 4024);
  if (v2)
    return v2(a2, *(_QWORD *)(a2 + 4032));
  else
    return 0;
}

void sub_1000EBD74(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v7;
  int64_t v8;
  const void *v9;
  void (*v10)(uint64_t, const void *, _QWORD, uint64_t);
  void *v11;

  v7 = (const void *)sub_100068E60(a1);
  if (a3)
  {
    if (a2 && (_DWORD)a4 && v7 && CFEqual(v7, a2))
    {
      if (sub_10006FA28(*(_QWORD *)(a3 + 64)))
      {
        v8 = sub_100068E60(*(_QWORD *)(a3 + 64));
        if (v8)
        {
          v9 = (const void *)v8;
          *(_DWORD *)(a3 + 5424) = 0;
          sub_100073AD4(*(_QWORD *)(a3 + 64), v8, (uint64_t)sub_100126D50, a3);
          sub_100073AE0(*(_QWORD *)(a3 + 64), v9, (uint64_t)sub_100126F1C, a3);
          sub_100070994(*(_QWORD *)(a3 + 64), v9, (uint64_t)sub_1001271CC, a3);
          sub_100073B0C(*(_QWORD *)(a3 + 64), v9, (uint64_t)sub_100127540, a3);
          sub_100078078(*(_QWORD *)(a3 + 64), v9, (uint64_t)sub_100127608, a3);
          sub_1000787E8(*(_QWORD *)(a3 + 64), v9, (uint64_t)sub_100127838, a3);
          goto LABEL_9;
        }
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null awdlIfname.", "__WiFiDeviceManagerInitializeAwdlState");
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL is not supported on the device.", "__WiFiDeviceManagerInitializeAwdlState");
      }
      objc_autoreleasePoolPop(v11);
LABEL_10:
      v10 = *(void (**)(uint64_t, const void *, _QWORD, uint64_t))(a3 + 4424);
      if (v10)
        v10(a3, a2, *(_QWORD *)(a3 + 4432), a4);
      return;
    }
LABEL_9:
    if (!a2)
      return;
    goto LABEL_10;
  }
}

void sub_1000EBF18(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  const __CFArray *v5;
  const __CFArray *v6;
  int Count;
  CFIndex v8;
  uint64_t v9;
  const void *ValueAtIndex;
  uint64_t v11;
  const __CFNumber *v12;
  const __CFDictionary *v13;
  __CFDictionary *MutableCopy;
  CFDictionaryRef v15;
  void *v16;
  void *v17;
  void *v18;
  const void *v19;
  int valuePtr;
  void *values;
  void *keys;

  if (!a3 || !a3[515])
    return;
  valuePtr = -1431655766;
  keys = CFSTR("HostApEnabled");
  values = kCFBooleanFalse;
  if (!a4)
  {
    v15 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    ((void (*)(uint64_t *, uint64_t, CFDictionaryRef))a3[515])(a3, a3[516], v15);
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hostAP stopped", "__WiFiDeviceManagerHostApStateChangedEventCallback");
    objc_autoreleasePoolPop(v17);
    v13 = 0;
    goto LABEL_27;
  }
  v5 = sub_100109C30((uint64_t)a3);
  v6 = v5;
  if (v5 && (Count = CFArrayGetCount(v5), Count >= 1))
  {
    v8 = 0;
    v9 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v8);
      v11 = (uint64_t)ValueAtIndex;
      if (ValueAtIndex)
      {
        v12 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("networkRole"));
        if (v12)
        {
          CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr == 3)
            goto LABEL_13;
          v11 = 0;
        }
      }
      ++v8;
    }
    while (v9 != v8);
    if (!v11)
      goto LABEL_22;
LABEL_13:
    v13 = sub_1000173C0(v11);
    if (v13)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v13);
      if (MutableCopy)
      {
        v15 = MutableCopy;
        CFDictionaryAddValue(MutableCopy, CFSTR("HostApEnabled"), kCFBooleanTrue);
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hostAP started", "__WiFiDeviceManagerHostApStateChangedEventCallback");
        objc_autoreleasePoolPop(v16);
        ((void (*)(uint64_t *, uint64_t, CFDictionaryRef))a3[515])(a3, a3[516], v15);
        if (!v6)
          goto LABEL_27;
        goto LABEL_26;
      }
    }
  }
  else
  {
LABEL_22:
    v13 = 0;
  }
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error. Stopping HostAP network.", "__WiFiDeviceManagerHostApStateChangedEventCallback");
  objc_autoreleasePoolPop(v18);
  v19 = (const void *)sub_100025C3C(a3[8]);
  sub_100106328((uint64_t)a3, v19, 0, 0, 0);
  v15 = 0;
  if (!v6)
    goto LABEL_27;
LABEL_26:
  CFRelease(v6);
LABEL_27:
  if (v15)
    CFRelease(v15);
  if (v13)
    CFRelease(v13);
}

void sub_1000EC1D8(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  _WORD *v7;
  const __CFArray *v8;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const __CFString *v11;
  id v12;
  void *v13;
  uint64_t v14;
  double v15;
  CLLocationDegrees v16;
  double v17;
  CLLocationDegrees v18;
  double v19;
  const void *v20;
  void *v21;
  void *v22;
  const void *v23;
  void *v24;
  uint64_t v25;
  unsigned int v26;
  __CFDictionary *Mutable;
  CFAbsoluteTime Current;
  CFDateRef v29;
  CFDateRef v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const __CFArray *v36;
  CFIndex Count;
  char v38;
  void *v39;
  void (*v40)(uint64_t, const void *, void *, _QWORD, _QWORD, _QWORD);
  void (*v41)(uint64_t, const void *, _QWORD, uint64_t, _QWORD);
  int v42;
  _QWORD v43[5];
  CFRange v44;

  if (!a3)
    return;
  *(_DWORD *)(a3 + 6208) = 0;
  v5 = sub_10002A21C(a3, a2, 1);
  if (!v5)
    return;
  v6 = v5;
  v7 = (_WORD *)(a3 + 8606);
  v8 = *(const __CFArray **)(a3 + 3528);
  if (v8)
  {
    v44.length = CFArrayGetCount(*(CFArrayRef *)(a3 + 3528));
    v44.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v8, v44, v6);
    if (FirstIndexOfValue != -1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3528), FirstIndexOfValue);
      v11 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID"));
      sub_1000C8160((uint64_t)ValueAtIndex, v11, 1);
      sub_1000C71DC(ValueAtIndex, v6);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        v12 = sub_100009ACC(a3);
        if (v12)
        {
          v13 = v12;
          v14 = *(_QWORD *)(a3 + 6792);
          objc_msgSend(v12, "coordinate");
          v16 = v15;
          objc_msgSend(v13, "coordinate");
          v18 = v17;
          objc_msgSend(v13, "horizontalAccuracy");
          sub_1000A10CC(v14, ValueAtIndex, v16, v18, v19, objc_msgSend(v13, "timestamp"));

        }
      }
      sub_1001053C8((NSObject **)a3, ValueAtIndex);
      v20 = sub_10002BE64((uint64_t)v6, CFSTR("BSSID"));
      v42 = sub_1000C86EC(ValueAtIndex, v20);
      if (v42)
      {
        v21 = objc_autoreleasePoolPush();
        v22 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v23 = sub_10002BE64((uint64_t)v6, CFSTR("BSSID"));
          objc_msgSend(v22, "WFLog:message:", 3, "Edge BSS detected - BSSID %@ SSID %@", v23, sub_10002B088(v6));
        }
        objc_autoreleasePoolPop(v21);
      }
      if (sub_1000C8B54((uint64_t)ValueAtIndex))
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Detected multiAP environment for %@", sub_10002B088(v6));
        objc_autoreleasePoolPop(v24);
      }
      v25 = *(_QWORD *)(a3 + 64);
      v26 = sub_10002A724(a3, ValueAtIndex);
      sub_100066F20(v25, (uint64_t)a2, ValueAtIndex, v26, 0, 0, 0);
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      Current = CFAbsoluteTimeGetCurrent();
      v29 = CFDateCreate(kCFAllocatorDefault, Current);
      v30 = v29;
      if (Mutable && v29)
      {
        v31 = sub_10002BE64(*(_QWORD *)(a3 + 3512), CFSTR("BSSID"));
        v32 = sub_10002BE64(*(_QWORD *)(a3 + 3512), CFSTR("CHANNEL"));
        v33 = sub_10002BE64((uint64_t)v6, CFSTR("BSSID"));
        v34 = sub_10002BE64((uint64_t)v6, CFSTR("CHANNEL"));
        if (v31)
        {
          if (v32)
          {
            if (v33)
            {
              v35 = v34;
              if (v34)
              {
                CFDictionarySetValue(Mutable, CFSTR("RoamOriginBSSID"), v31);
                CFDictionarySetValue(Mutable, CFSTR("RoamOriginChannel"), v32);
                CFDictionarySetValue(Mutable, CFSTR("RoamDestBSSID"), v33);
                CFDictionarySetValue(Mutable, CFSTR("RoamDestChannel"), v35);
                CFDictionarySetValue(Mutable, CFSTR("RoamTimestamp"), v30);
                v36 = *(const __CFArray **)(a3 + 272);
                Count = CFArrayGetCount(v36);
                CFArrayInsertValueAtIndex(v36, Count % 100, Mutable);
              }
            }
          }
        }
      }
      else if (!Mutable)
      {
LABEL_26:
        if (v30)
          CFRelease(v30);
        v7 = (_WORD *)(a3 + 8606);
        v38 = v42;
        goto LABEL_29;
      }
      CFRelease(Mutable);
      goto LABEL_26;
    }
  }
  v38 = 0;
LABEL_29:
  *v7 = 256;
  if (sub_1000CA53C((uint64_t)v6))
  {
    *(_BYTE *)v7 = 1;
    *(_OWORD *)(a3 + 8528) = 0u;
    *(_OWORD *)(a3 + 8544) = 0u;
    *(_OWORD *)(a3 + 8560) = 0u;
    *(CFAbsoluteTime *)(a3 + 8576) = CFAbsoluteTimeGetCurrent();
  }
  sub_1000FA884(a3, (uint64_t)a2);
  ++*(_DWORD *)(a3 + 744);
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: transition attempts# %d", "__WiFiDeviceManagerUpdateNetworkTransitionStateOnBssidChanged", *(unsigned int *)(a3 + 3392));
  objc_autoreleasePoolPop(v39);
  *(_DWORD *)(a3 + 3392) = -1;
  if (!*(_BYTE *)(a3 + 6632))
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_1000285E4(a3, 0x23uLL);
    else
      sub_1000FA0A0(a3, 4);
  }
  sub_1000FE5A4(a3, v6);
  sub_100046660(*(_QWORD *)(a3 + 120), v6, 2, v38);
  sub_100126B1C(a3);
  v40 = *(void (**)(uint64_t, const void *, void *, _QWORD, _QWORD, _QWORD))(a3 + 3904);
  if (v40)
    v40(a3, a2, v6, 0, 0, *(_QWORD *)(a3 + 3912));
  v41 = *(void (**)(uint64_t, const void *, _QWORD, uint64_t, _QWORD))(a3 + 4392);
  if (v41)
    v41(a3, a2, *(_QWORD *)(a3 + 4400), 1, 0);
  if (*(_QWORD *)(a3 + 7368))
  {
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472;
    v43[2] = sub_100127DFC;
    v43[3] = &unk_1002314B8;
    v43[4] = a3;
    sub_10010367C(a3, (const __CFDictionary **)v6, (uint64_t)v43);
  }
  if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"))
    -[WiFiAIRAgent processRoamEvent:](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "processRoamEvent:", v6);
  CFRelease(v6);
  sub_1001091D8(a3, 4u, 0);
}

void sub_1000EC778(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;

  if (a3)
  {
    v7 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
    if (v7)
    {
      objc_msgSend(v7, "setRoamStart:forInterface:", a4, a2);
      sub_10004829C(*(_QWORD *)(a3 + 120));
      return;
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamManager is NULL", "__WiFiDeviceManagerRoamScanStartEventCallback");
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, WiFiDeviceManagerRef is NULL", "__WiFiDeviceManagerRoamScanStartEventCallback");
  }
  objc_autoreleasePoolPop(v8);
}

void sub_1000EC84C(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  __int128 v4;
  void *v9;
  const __CFNumber *Value;
  const __CFArray *v11;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  void *v14;
  const __CFNumber *v15;
  int v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFBoolean *v22;
  void *v23;
  BOOL v24;
  BOOL v25;
  const void *v26;
  const __CFString *v27;
  void (*v28)(uint64_t, const void *, _QWORD);
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  __int128 v34;
  __int128 v35;
  const __CFString *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int valuePtr[4];
  CFRange v41;

  v39 = 0;
  *(_QWORD *)valuePtr = 0;
  v38 = 0;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35 = v4;
  v37 = 0xAAAAAAAAAAAAAAAALL;
  v34 = v4;
  DWORD1(v35) = 0;
  HIDWORD(v35) = 0;
  v36 = CFSTR("Unknown");
  if (!a3)
    return;
  v9 = sub_10002A21C(a3, a2, 1);
  v32 = *(_QWORD *)(a3 + 3512);
  Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_TSN_DISABLED_FLAGS"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr[1]);
  if (v9)
  {
    v11 = *(const __CFArray **)(a3 + 3528);
    if (v11)
    {
      v41.length = CFArrayGetCount(*(CFArrayRef *)(a3 + 3528));
      v41.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11, v41, v9);
      if (FirstIndexOfValue == -1)
        ValueAtIndex = 0;
      else
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3528), FirstIndexOfValue);
LABEL_13:
      v15 = (const __CFNumber *)sub_1000316E0((uint64_t)v9);
      v16 = sub_10003153C((uint64_t)v9);
      if (v15)
      {
        v33 = -21846;
        CFNumberGetValue(v15, kCFNumberSInt16Type, &v33);
        WORD2(v35) = v33;
      }
      if (v16)
        WORD3(v35) = v16;
      goto LABEL_17;
    }
  }
  v14 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Known network hasn't created, update transition disabled flag after assoc finish", "__WiFiDeviceManagerSupplicantEventCallback");
  objc_autoreleasePoolPop(v14);
  ValueAtIndex = 0;
  if (v9)
    goto LABEL_13;
LABEL_17:
  if (sub_10007171C(a1))
  {
    v17 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_EAPOL_START_M1_DURATION"));
    if (v17)
      CFNumberGetValue(v17, kCFNumberSInt32Type, valuePtr);
    v18 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_M1_M2_DURATION"));
    if (v18)
      CFNumberGetValue(v18, kCFNumberSInt32Type, (char *)&v39 + 4);
    v19 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_M2_M3_DURATION"));
    if (v19)
      CFNumberGetValue(v19, kCFNumberSInt32Type, &v39);
    v20 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_M3_M4_DURATION"));
    if (v20)
      CFNumberGetValue(v20, kCFNumberSInt32Type, (char *)&v38 + 4);
    v21 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_TOTAL_4WAY_DURATION"));
    if (v21)
      CFNumberGetValue(v21, kCFNumberSInt32Type, &v38);
    v22 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("APPLE80211KEY_SUPPLICANTEVENT_JOINING_NEW_NETWORK"));
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "4WayHSDuration (us): eapol_start_m1_dur: %d m1_m2_dur: %d m2_m3_dur %d m3_m4_dur: %d total_4way_hs_dur: %d Auto-Joining New Network: %d", valuePtr[0], HIDWORD(v39), v39, HIDWORD(v38), v38, CFBooleanGetValue(v22));
    objc_autoreleasePoolPop(v23);
    *(_QWORD *)&v34 = __PAIR64__(HIDWORD(v39), valuePtr[0]);
    *((_QWORD *)&v34 + 1) = __PAIR64__(HIDWORD(v38), v39);
    LODWORD(v35) = v38;
    if (*(_DWORD *)(a3 + 5396) == 102)
    {
      v24 = (*(_BYTE *)(a3 + 5392) & 2) != 0 || *(_BYTE *)(a3 + 49) != 0;
      BYTE8(v35) = v24;
      if ((*(_BYTE *)(a3 + 5392) & 1) != 0)
      {
        v25 = 1;
LABEL_38:
        BYTE9(v35) = v25;
        HIDWORD(v35) = *(_DWORD *)(a3 + 6208);
        LOBYTE(v37) = CFBooleanGetValue(v22) != 0;
        v26 = sub_10002BE64((uint64_t)v9, CFSTR("BSSID"));
        if (v26)
        {
          v27 = (const __CFString *)+[WiFiUsageAccessPointProfile profileForBSSID:](WiFiUsageAccessPointProfile, "profileForBSSID:", v26);
          if (v27)
            v36 = v27;
        }
        sub_100062938((unsigned int *)&v34);
        goto LABEL_42;
      }
    }
    else
    {
      BYTE8(v35) = *(_BYTE *)(a3 + 49) != 0;
    }
    v25 = *(_BYTE *)(a3 + 50) != 0;
    goto LABEL_38;
  }
LABEL_42:
  if (v9)
  {
    if (sub_1000CA53C((uint64_t)v9))
    {
      v28 = *(void (**)(uint64_t, const void *, _QWORD))(a3 + 4360);
      if (v28)
      {
        v28(a3, a2, *(_QWORD *)(a3 + 4368));
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Signal WiFi to incriment 24GHz M1M4 Handshake Count");
        objc_autoreleasePoolPop(v29);
      }
    }
  }
  v30 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Getting transition disabled flags,  %u", "__WiFiDeviceManagerSupplicantEventCallback", valuePtr[1]);
  objc_autoreleasePoolPop(v30);
  v31 = valuePtr[1];
  if (valuePtr[1] != 0x80000000)
  {
    *(_DWORD *)(a3 + 3472) = valuePtr[1];
    if (v32 && v31)
    {
      sub_10002C478(v32, CFSTR("TransitionDisabledFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
      v31 = valuePtr[1];
    }
    sub_100127E74((NSObject **)a3, ValueAtIndex, v31, 1);
  }
  if (v9)
    CFRelease(v9);
}

void sub_1000ECCC8(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  id v7;
  void *v8;
  void *v9;
  const void *v10;
  id v11;
  const void *v12;
  void *v13;
  NSMutableDictionary *v14;
  id v15;
  void *v16;

  if (!a3)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, WiFiDeviceManagerRef is NULL", "__WiFiDeviceManagerRoamScanEndEventCallback");
    goto LABEL_15;
  }
  v7 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
  if (!v7)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamManager is NULL", "__WiFiDeviceManagerRoamScanEndEventCallback");
LABEL_15:
    objc_autoreleasePoolPop(v16);
    return;
  }
  v8 = v7;
  v9 = sub_10002A21C(a3, a2, 1);
  if (v9)
  {
    v10 = v9;
    objc_msgSend(v8, "setRoamEndState:forInterface:", a4, a2);
    if (objc_msgSend(v8, "canSubmitMetrics"))
    {
      v11 = objc_msgSend(v8, "copyRoamStatus");
      if (v11)
      {
        v12 = v11;
        v13 = objc_autoreleasePoolPush();
        v14 = +[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", v12);
        v15 = objc_msgSend(a4, "objectForKey:", CFSTR("ROAM_CACHE"));
        if (v15)
          -[NSMutableDictionary setObject:forKey:](v14, "setObject:forKey:", v15, CFSTR("ROAM_CACHE"));
        sub_100127EF0(a3, v10, (const __CFDictionary *)v14);
        objc_autoreleasePoolPop(v13);
        CFRelease(v12);
      }
    }
    CFRelease(v10);
  }
}

void sub_1000ECE60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v6;
  void *v7;

  v6 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
  if (v6)
  {
    objc_msgSend(v6, "setRoamPrep:forInterface:", a4, a2);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamManager is NULL", "__WiFiDeviceManagerRoamPrepEventCallback");
    objc_autoreleasePoolPop(v7);
  }
}

void sub_1000ECEE8(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const void *v8;
  void *v9;
  const void *v10;
  void *v11;
  id v12;
  id v13;

  v5 = objc_autoreleasePoolPush();
  if (a3)
  {
    v6 = (const __CFDictionary *)sub_10002A21C(a3, a2, 1);
    if (v6)
    {
      v7 = v6;
      v8 = *(const void **)(a3 + 3512);
      if (!v8
        || !CFEqual(v6, v8)
        || sub_10003145C((uint64_t)v7)
        || sub_10002DAB4((uint64_t)v7)
        || sub_1000C433C(v7))
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "APPLE80211_M_DECRYPTION_FAILURE! omitting disassociate because this is a WPA network");
        objc_autoreleasePoolPop(v9);
      }
      else
      {
        v10 = sub_10002BE64(*(_QWORD *)(a3 + 3512), CFSTR("BSSID"));
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received a decryption failure from the device.  Disassociating. ");
        objc_autoreleasePoolPop(v11);
        sub_1000F7F48(a3, a2, 1004, "__WiFiDeviceManagerDecryptionEventCallback", 7708);
        v12 = sub_100027D10(*(_QWORD *)(a3 + 3512));
        if ((objc_msgSend(*(id *)(a3 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v12) & 1) == 0)
          *(_DWORD *)(a3 + 3280) = sub_100119668(a3, (uint64_t)a2, 1, 1, *(const void **)(a3 + 3512), 0);
        v13 = sub_1000FCB38(a3, 3, 0, (uint64_t)v10, 5);
        objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v13, v12);

      }
      CFRelease(v7);
    }
  }
  objc_autoreleasePoolPop(v5);
}

void sub_1000ED088(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4)
{
  const void *v7;
  CFIndex Count;
  const __CFArray *v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex i;
  __CFDictionary *v13;
  __CFDictionary *v14;
  void (*v15)(uint64_t, const void *, const __CFArray *, _QWORD);
  __CFArray *v16;
  CFIndex v17;
  uint64_t v18;
  CFIndex v19;
  CFIndex v20;
  const void *ValueAtIndex;
  const void *v22;
  const void *v23;
  CFIndex v24;
  const void *v25;
  const void *v26;
  const void *v28;
  const void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (!a4)
    return;
  *(_BYTE *)(a4 + 3304) = 1;
  if (!sub_1001084C4(a4))
  {
    v9 = 0;
LABEL_6:
    Count = 0;
    goto LABEL_7;
  }
  v7 = sub_10002BF8C(*(_QWORD *)(a4 + 64), a2);
  if (v7)
  {
    Count = (CFIndex)v7;
    v9 = 0;
    goto LABEL_7;
  }
  v16 = sub_100064608(a3);
  v9 = v16;
  if (!v16)
    goto LABEL_6;
  Count = CFArrayGetCount(v16);
  if (Count)
  {
    v17 = CFArrayGetCount(*(CFArrayRef *)(a4 + 3584));
    if (v17)
    {
      if (Count < 1)
        goto LABEL_46;
      v18 = v17;
      v19 = 0;
      v20 = -1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v9, v19);
        if (ValueAtIndex)
        {
          v22 = sub_10002B088(ValueAtIndex);
          if (v18 >= 1)
          {
            v23 = v22;
            if (v22)
            {
              v24 = 0;
              while (1)
              {
                v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 3584), v24);
                if (v25)
                {
                  v26 = sub_10002B088(v25);
                  if (v26)
                  {
                    if (CFEqual(v23, v26))
                      break;
                  }
                }
                if (v18 == ++v24)
                  goto LABEL_39;
              }
              if (v24 < v20 || v20 == -1)
                v20 = v24;
            }
          }
        }
LABEL_39:
        ++v19;
      }
      while (v19 != Count);
      if (v20 == -1)
      {
LABEL_46:
        v31 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "PNO networks not from background scan candidates (known networks). Nothing to do.");
        objc_autoreleasePoolPop(v31);
      }
      else
      {
        v28 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 3584), v20);
        v29 = *(const void **)(a4 + 3512);
        if (v29 && CFEqual(v29, v28))
        {
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Previous network is the same as PNO network. Nothing to do.");
          objc_autoreleasePoolPop(v30);
        }
        else
        {
          v32 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Previous network is different from PNO network. Promoting %@.", sub_10002B088(v28));
          objc_autoreleasePoolPop(v32);
          sub_1000FE5A4(a4, v28);
        }
        *(_DWORD *)(a4 + 192) = 5;
        sub_1000FB44C(a4);
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000285E4(a4, 6uLL);
        }
        else
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 6, sub_100025C3C(*(_QWORD *)(a4 + 64)));
          sub_1000FBA80(a4, 2, (uint64_t)"__WiFiDeviceManagerPromotePNONetworks");
        }
      }
    }
    goto LABEL_6;
  }
LABEL_7:
  if (a3)
  {
    v10 = CFArrayGetCount(a3);
    if (v10 >= 1)
    {
      v11 = v10;
      for (i = 0; i != v11; ++i)
      {
        v13 = (__CFDictionary *)CFArrayGetValueAtIndex(a3, i);
        if (v13)
        {
          v14 = v13;
          CFDictionaryRemoveValue(v13, CFSTR("SSID_STR"));
          CFDictionaryRemoveValue(v14, CFSTR("SSID"));
        }
      }
    }
  }
  if (v9)
    CFRelease(v9);
  if (Count)
    CFRelease((CFTypeRef)Count);
  v15 = *(void (**)(uint64_t, const void *, const __CFArray *, _QWORD))(a4 + 4168);
  if (v15)
    v15(a4, a2, a3, *(_QWORD *)(a4 + 4048));
}

void sub_1000ED3D4(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  const void *v10;
  id v11;

  v5 = objc_autoreleasePoolPush();
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing BlackList Network Event", "__WiFiDeviceManagerBlackListNetworkCallback");
  objc_autoreleasePoolPop(v6);
  if (a3)
  {
    v7 = sub_10002A21C(a3, a2, 1);
    v8 = objc_autoreleasePoolPush();
    if (v7)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Blacklisting %@ for Background Scan", "__WiFiDeviceManagerBlackListNetworkCallback", sub_10002B088(v7));
      objc_autoreleasePoolPop(v8);
      v9 = sub_100027D10((uint64_t)v7);
      v10 = sub_10002BE64((uint64_t)v7, CFSTR("BSSID"));
      v11 = sub_1000FCB38(a3, 2, 0, (uint64_t)v10, 3);
      objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v11, v9);
      objc_msgSend(*(id *)(a3 + 7368), "addFaultEvent:forInterface:", 22, a2);

      CFRelease(v7);
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Received blackList event, but we are not associated", "__WiFiDeviceManagerBlackListNetworkCallback");
      objc_autoreleasePoolPop(v8);
    }
  }
  objc_autoreleasePoolPop(v5);
}

void sub_1000ED548(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int8 *a5, unsigned __int16 *a6, uint64_t a7)
{
  unsigned __int8 *v7;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFDataRef v19;
  void *v20;
  const char *v21;
  const char *v22;
  void *v23;
  CFMutableSetRef *v24;
  CFIndex Count;
  void *v26;
  void *v27;
  void *v28;

  v7 = (unsigned __int8 *)(a7 + 5217);
  if (*(_BYTE *)(a7 + 5219))
  {
    *v7 = a3;
    *(_BYTE *)(a7 + 5360) = a3;
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS STA Associated: %d associated clients", *v7);
    objc_autoreleasePoolPop(v13);
    if (a5)
    {
      v19 = CFDataCreate(kCFAllocatorDefault, a5, 6);
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v7[43])
          v21 = " Hidden ";
        else
          v21 = "Broadcast";
        if ((a4 & 1) != 0)
        {
          v22 = " Auto Hotspot Client ";
        }
        else if ((a4 & 2) != 0)
        {
          v22 = "Instant Hotspot Client ";
        }
        else
        {
          v22 = "Broadcast iOS Client";
          if ((a4 & 4) == 0)
            v22 = " Others ";
        }
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS Mode: %s, Client Type: %s client macAddr: %@", "__WiFiDeviceManagerSTAArriveCallback", v21, v22, v19);
      }
      objc_autoreleasePoolPop(v20);
      if ((a4 & 3) != 0)
      {
        v24 = (CFMutableSetRef *)(a7 + 5296);
      }
      else
      {
        Count = CFSetGetCount(*(CFSetRef *)(a7 + 5272));
        v24 = (CFMutableSetRef *)(a7 + 5288);
        if (!Count)
          v24 = (CFMutableSetRef *)(a7 + 5304);
      }
      CFSetAddValue(*v24, v19);
      if (v19)
        CFRelease(v19);
      sub_100107DE4(a7, 0);
    }
    if (!_MISSetHostCount || _MISSetHostCount(*(_QWORD *)(a7 + 4944), 2, a3, v14, v15, v16, v17, v18))
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error updating host count at MIS Service", "__WiFiDeviceManagerSTAArriveCallback");
      objc_autoreleasePoolPop(v26);
    }
    if (*v7 == 5)
      sub_10012855C(a7, 1);
    sub_1001074BC(a7, 0);
    *(CFAbsoluteTime *)(a7 + 5336) = CFAbsoluteTimeGetCurrent() + 3.0;
    v7[111] = 1;
    sub_100119020(a7, 1, a6, a4, 0);
    v27 = objc_autoreleasePoolPush();
    v28 = *(void **)(a7 + 7368);
    if (v28)
    {
      if (a5)
      {
        a5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2X:%.2X:%.2X:%.2X:%.2X:%.2X"), *a5, a5[1], a5[2], a5[3], a5[4], a5[5]);
        v28 = *(void **)(a7 + 7368);
      }
      objc_msgSend(v28, "addSoftApClientEvent:identifier:isAppleClient:isInstantHotspot:isAutoHotspot:isHidden:", 1, a5, (a4 | sub_10006495C(a6)) != 0, (a4 >> 1) & 1, a4 & 1, v7[43] != 0);
    }
    objc_autoreleasePoolPop(v27);
    if (objc_opt_class(CHSControlService))
      dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_100231800);
  }
  else
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: called while MIS is disabled", "__WiFiDeviceManagerSTAArriveCallback");
    objc_autoreleasePoolPop(v23);
  }
}

void sub_1000ED8C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, unsigned __int16 *a6, uint64_t a7)
{
  unsigned __int8 *v9;
  unsigned __int8 *v13;
  NSString *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  CFDataRef v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  _OWORD v39[10];
  uint64_t v40;

  v9 = a5;
  v13 = (unsigned __int8 *)(a7 + 5217);
  if (a5)
    v14 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2X:%.2X:%.2X:%.2X:%.2X:%.2X"), *a5, a5[1], a5[2], a5[3], a5[4], a5[5]);
  else
    v14 = 0;
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s ifname %@ staNum %d sta_capabilities %d macString %@ \n", "__WiFiDeviceManagerSTALeaveCallback", a2, a3, a4, v14);
  objc_autoreleasePoolPop(v15);
  if (v13[2])
  {
    v21 = *v13;
    if ((_DWORD)a3 == 255)
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS no traffic for long time. Tear down MIS");
      objc_autoreleasePoolPop(v22);
      v28 = v13[4];
      if (!_MISSetHostCount || _MISSetHostCount(*(_QWORD *)(a7 + 4944), 2, 0, v23, v24, v25, v26, v27))
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error updating host count at MIS Service", "__WiFiDeviceManagerSTALeaveCallback");
        objc_autoreleasePoolPop(v29);
      }
      *v13 = 0;
      if (v13[2] && !v28)
      {
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS idle timer expired, disabling tethering");
        objc_autoreleasePoolPop(v30);
        sub_100107084(a7);
        v40 = 0;
        memset(v39, 0, sizeof(v39));
        DWORD2(v39[0]) = 7;
        sub_100106C34(a7, (uint64_t)v39);
      }
    }
    else
    {
      if (v21 >= a3)
      {
        *v13 = a3;
        if (_MISSetHostCount)
        {
          if (_MISSetHostCount(*(_QWORD *)(a7 + 4944), 2, a3, v16, v17, v18, v19, v20))
          {
            v32 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error updating host count at MIS Service", "__WiFiDeviceManagerSTALeaveCallback");
            objc_autoreleasePoolPop(v32);
          }
        }
      }
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS STA Disassociated: %d associated clients", *v13);
      objc_autoreleasePoolPop(v33);
    }
    v13[143] = *v13;
    if (v9)
    {
      v34 = CFDataCreate(kCFAllocatorDefault, v9, 6);
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: misIsHidden: %d, client macAddr: %@", "__WiFiDeviceManagerSTALeaveCallback", v13[43], v34);
      objc_autoreleasePoolPop(v35);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5288), v34);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5296), v34);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5304), v34);
      if (v34)
        CFRelease(v34);
      sub_100107DE4(a7, 0);
    }
    if ((_DWORD)a3 != 255 && v13[1] == -*v13 && !v13[4])
    {
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting MIS idle timer", "__WiFiDeviceManagerSTALeaveCallback");
      objc_autoreleasePoolPop(v36);
      sub_1001074BC(a7, 3);
    }
    sub_100119020(a7, 0, a6, 0, 0);
    if (v21 >= 5 && *v13 <= 4u)
      sub_10012855C(a7, 0);
    v37 = objc_autoreleasePoolPush();
    v38 = *(void **)(a7 + 7368);
    if (v38)
    {
      if (v9)
      {
        v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2X:%.2X:%.2X:%.2X:%.2X:%.2X"), *v9, v9[1], v9[2], v9[3], v9[4], v9[5]);
        v38 = *(void **)(a7 + 7368);
      }
      objc_msgSend(v38, "addSoftApClientEvent:identifier:isAppleClient:isInstantHotspot:isAutoHotspot:isHidden:", 0, v9, sub_10006495C(a6) != 0, (a4 >> 1) & 1, a4 & 1, v13[43] != 0);
    }
    objc_autoreleasePoolPop(v37);
    if (objc_opt_class(CHSControlService))
      dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_100231820);
  }
  else
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: called while MIS is disabled", "__WiFiDeviceManagerSTALeaveCallback");
    objc_autoreleasePoolPop(v31);
  }
}

uint64_t sub_1000EDDB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 4008);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 4016));
  }
  return result;
}

uint64_t sub_1000EDDD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4216);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4224));
  }
  return result;
}

uint64_t sub_1000EDDF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 4264);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 4272));
  }
  return result;
}

void sub_1000EDE10(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  int v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFNumber *v11;
  _BOOL8 v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  uint64_t v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  uint64_t v22;
  const __CFNumber *v23;
  uint64_t v24;
  const __CFNumber *v25;
  uint64_t v26;
  const __CFNumber *v27;
  uint64_t v28;
  const __CFNumber *v29;
  uint64_t v30;
  const __CFNumber *v31;
  _BOOL8 v32;
  _BOOL8 v33;
  _BOOL8 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, _QWORD, CFDictionaryRef);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  _BOOL4 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t valuePtr;

  if (a3 && theDict)
  {
    if (!*(_QWORD *)(a3 + 7368))
      goto LABEL_34;
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("BSP_EventType"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberLongLongType, &valuePtr);
      v8 = valuePtr;
      v9 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("BSP_EventParams"));
      if (v9)
      {
        v10 = v9;
        if (v8 == 18)
        {
          v31 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("BSP_CoexMode"));
          if (v31)
          {
            CFNumberGetValue(v31, kCFNumberLongLongType, &valuePtr);
            v32 = valuePtr != 0;
          }
          else
          {
            v32 = 0;
          }
          objc_msgSend(*(id *)(a3 + 7368), "updateIsBSPActive:", v32);
          goto LABEL_34;
        }
        if (v8 != 19)
        {
LABEL_34:
          v39 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a3 + 4792);
          if (v39)
            v39(a3, a2, *(_QWORD *)(a3 + 4800), theDict);
          return;
        }
        objc_msgSend(*(id *)(a3 + 7368), "updateIsBSPActive:", 1);
        v11 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_Overflowed"));
        if (v11)
        {
          CFNumberGetValue(v11, kCFNumberLongLongType, &valuePtr);
          v12 = valuePtr != 0;
          v13 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_TimeToTST"));
          if (v13)
          {
            CFNumberGetValue(v13, kCFNumberLongLongType, &valuePtr);
            v46 = valuePtr;
            v14 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_SampleDurationMS"));
            if (!v14)
            {
              v33 = 0;
              v34 = 0;
              v28 = 0x7FFFFFFFFFFFFFFFLL;
              v24 = 0x7FFFFFFFFFFFFFFFLL;
              v35 = 0x7FFFFFFFFFFFFFFFLL;
              v36 = 0x7FFFFFFFFFFFFFFFLL;
              v38 = 0x7FFFFFFFFFFFFFFFLL;
              v19 = 0x7FFFFFFFFFFFFFFFLL;
              v22 = 0x7FFFFFFFFFFFFFFFLL;
              v26 = 0x7FFFFFFFFFFFFFFFLL;
              v30 = 0x7FFFFFFFFFFFFFFFLL;
              v37 = v46;
              goto LABEL_33;
            }
            CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr);
            v45 = valuePtr;
            v15 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_IsScanActive"));
            if (v15)
            {
              CFNumberGetValue(v15, kCFNumberLongLongType, &valuePtr);
              v44 = valuePtr != 0;
              v16 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_IsP2PActive"));
              if (v16)
              {
                CFNumberGetValue(v16, kCFNumberLongLongType, &valuePtr);
                v43 = valuePtr != 0;
                v17 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_TriggerCount"));
                if (v17)
                {
                  CFNumberGetValue(v17, kCFNumberLongLongType, &valuePtr);
                  v42 = valuePtr;
                  v18 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_MutePercentage"));
                  if (v18)
                  {
                    CFNumberGetValue(v18, kCFNumberLongLongType, &valuePtr);
                    v19 = valuePtr;
                    v20 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_MaxMuteMS"));
                    if (v20)
                    {
                      CFNumberGetValue(v20, kCFNumberLongLongType, &valuePtr);
                      v41 = valuePtr;
                      v21 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_AvgMuteMS"));
                      if (v21)
                      {
                        CFNumberGetValue(v21, kCFNumberLongLongType, &valuePtr);
                        v22 = valuePtr;
                        v23 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_ErrorPercentage"));
                        if (v23)
                        {
                          CFNumberGetValue(v23, kCFNumberLongLongType, &valuePtr);
                          v24 = valuePtr;
                          v25 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_TimeoutPercentageOfTriggers"));
                          if (v25)
                          {
                            CFNumberGetValue(v25, kCFNumberLongLongType, &valuePtr);
                            v26 = valuePtr;
                            v27 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_RejectOrFailPercentageOfTriggers"));
                            if (v27)
                            {
                              CFNumberGetValue(v27, kCFNumberLongLongType, &valuePtr);
                              v28 = valuePtr;
                              v29 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("BSP_LQM_MaxConsecutiveFails"));
                              if (v29)
                              {
                                CFNumberGetValue(v29, kCFNumberLongLongType, &valuePtr);
                                v30 = valuePtr;
LABEL_45:
                                v37 = v46;
                                v34 = v43;
                                v33 = v44;
                                v38 = v45;
                                v35 = v41;
                                v36 = v42;
                                goto LABEL_33;
                              }
                            }
                            else
                            {
                              v28 = 0x7FFFFFFFFFFFFFFFLL;
                            }
LABEL_44:
                            v30 = 0x7FFFFFFFFFFFFFFFLL;
                            goto LABEL_45;
                          }
                          v28 = 0x7FFFFFFFFFFFFFFFLL;
                        }
                        else
                        {
                          v28 = 0x7FFFFFFFFFFFFFFFLL;
                          v24 = 0x7FFFFFFFFFFFFFFFLL;
                        }
                      }
                      else
                      {
                        v28 = 0x7FFFFFFFFFFFFFFFLL;
                        v24 = 0x7FFFFFFFFFFFFFFFLL;
                        v22 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      v26 = 0x7FFFFFFFFFFFFFFFLL;
                      goto LABEL_44;
                    }
                    v28 = 0x7FFFFFFFFFFFFFFFLL;
                    v24 = 0x7FFFFFFFFFFFFFFFLL;
                    v35 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else
                  {
                    v28 = 0x7FFFFFFFFFFFFFFFLL;
                    v24 = 0x7FFFFFFFFFFFFFFFLL;
                    v35 = 0x7FFFFFFFFFFFFFFFLL;
                    v19 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  v22 = 0x7FFFFFFFFFFFFFFFLL;
                  v26 = 0x7FFFFFFFFFFFFFFFLL;
                  v30 = 0x7FFFFFFFFFFFFFFFLL;
                  v37 = v46;
                  v34 = v43;
                  v33 = v44;
                  v38 = v45;
                  v36 = v42;
LABEL_33:
                  LOBYTE(v40) = *(_BYTE *)(a3 + 7042) != 0;
                  objc_msgSend(*(id *)(a3 + 7368), "updateWithBspOverflowed:IsBSPActive:BspTimeToTST:BspSampleDurationMS:IsScanActiveBSP:IsP2PActiveBSP:BspTriggerCount:BspMutePercentage:BspMaxMuteMS:BspAvgMuteMS:BspErrorPercentage:BspTimeOutPercentageOfTriggers:BspRejectOrFailPercentageOfTriggers:bspMaxConsecutiveFails:supportsLinkRecommendation:forInterface:", v12, 1, v37, v38, v33, v34, v36, v19, v35, v22, v24, v26, v28, v30, v40,
                    a2);
                  goto LABEL_34;
                }
                v28 = 0x7FFFFFFFFFFFFFFFLL;
                v24 = 0x7FFFFFFFFFFFFFFFLL;
                v35 = 0x7FFFFFFFFFFFFFFFLL;
                v36 = 0x7FFFFFFFFFFFFFFFLL;
                v19 = 0x7FFFFFFFFFFFFFFFLL;
                v22 = 0x7FFFFFFFFFFFFFFFLL;
                v26 = 0x7FFFFFFFFFFFFFFFLL;
                v30 = 0x7FFFFFFFFFFFFFFFLL;
                v37 = v46;
                v34 = v43;
                v33 = v44;
              }
              else
              {
                v34 = 0;
                v28 = 0x7FFFFFFFFFFFFFFFLL;
                v24 = 0x7FFFFFFFFFFFFFFFLL;
                v35 = 0x7FFFFFFFFFFFFFFFLL;
                v36 = 0x7FFFFFFFFFFFFFFFLL;
                v19 = 0x7FFFFFFFFFFFFFFFLL;
                v22 = 0x7FFFFFFFFFFFFFFFLL;
                v26 = 0x7FFFFFFFFFFFFFFFLL;
                v30 = 0x7FFFFFFFFFFFFFFFLL;
                v37 = v46;
                v33 = v44;
              }
            }
            else
            {
              v33 = 0;
              v34 = 0;
              v28 = 0x7FFFFFFFFFFFFFFFLL;
              v24 = 0x7FFFFFFFFFFFFFFFLL;
              v35 = 0x7FFFFFFFFFFFFFFFLL;
              v36 = 0x7FFFFFFFFFFFFFFFLL;
              v19 = 0x7FFFFFFFFFFFFFFFLL;
              v22 = 0x7FFFFFFFFFFFFFFFLL;
              v26 = 0x7FFFFFFFFFFFFFFFLL;
              v30 = 0x7FFFFFFFFFFFFFFFLL;
              v37 = v46;
            }
            v38 = v45;
            goto LABEL_33;
          }
        }
        else
        {
          v12 = 1;
        }
        v33 = 0;
        v34 = 0;
        v28 = 0x7FFFFFFFFFFFFFFFLL;
        v24 = 0x7FFFFFFFFFFFFFFFLL;
        v35 = 0x7FFFFFFFFFFFFFFFLL;
        v36 = 0x7FFFFFFFFFFFFFFFLL;
        v37 = 0x7FFFFFFFFFFFFFFFLL;
        v38 = 0x7FFFFFFFFFFFFFFFLL;
        v19 = 0x7FFFFFFFFFFFFFFFLL;
        v22 = 0x7FFFFFFFFFFFFFFFLL;
        v26 = 0x7FFFFFFFFFFFFFFFLL;
        v30 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_33;
      }
    }
  }
}

uint64_t sub_1000EE2E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 4808);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 4816));
  }
  return result;
}

uint64_t sub_1000EE300(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 4280);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 4288));
  }
  return result;
}

void sub_1000EE320(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  void (*v6)(uint64_t, uint64_t, _QWORD, CFDictionaryRef);
  __int128 v7;
  __int128 v8;
  _BYTE v9[28];

  if (a3)
  {
    v6 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a3 + 4312);
    if (v6)
      v6(a3, a2, *(_QWORD *)(a3 + 4320), theDict);
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v9[12] = v7;
    v8 = v7;
    *(_OWORD *)v9 = v7;
    sub_100047288(*(_QWORD *)(a3 + 120), theDict);
    sub_100046CF0(*(_QWORD *)(a3 + 120), (uint64_t)&v8);
    if (arc4random_uniform(0x63u) <= 1)
      sub_1001047D4(a3, (uint64_t)&v8);
    if (*(unsigned __int8 *)(a3 + 3864) != BYTE3(v8))
      sub_100104520(a3, (uint64_t)&v8);
  }
}

void sub_1000EE3EC(uint64_t a1, const __CFString *a2)
{
  sub_1000EE3F4(*(_QWORD *)(a1 + 32), a2);
}

void sub_1000EE3F4(uint64_t a1, const __CFString *a2)
{
  const __CFString *v2;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  void *v6;
  void *v7;
  void *v8;

  if (a2)
    v2 = a2;
  else
    v2 = CFSTR("SoftErrorTriggeredChipReset");
  if (!a1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerResetChip");
    goto LABEL_22;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager->device is NULL", "WiFiDeviceManagerResetChip");
    goto LABEL_22;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resetTriggerInfo allocation failed!", "WiFiDeviceManagerResetChip");
LABEL_22:
    objc_autoreleasePoolPop(v8);
    return;
  }
  v5 = Mutable;
  if (CFStringGetLength(v2) <= 0 && MGGetBoolAnswer(CFSTR("InternalBuild")))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Will request to chip reset with no triggerReason", "WiFiDeviceManagerResetChip");
    objc_autoreleasePoolPop(v6);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
      sub_100187664();
  }
  CFDictionaryAddValue(v5, CFSTR("CHIP_RESET_TRIGGER"), v2);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling ChipReset with reason:%@", "WiFiDeviceManagerResetChip", v2);
  objc_autoreleasePoolPop(v7);
  sub_10006BD58(*(_QWORD *)(a1 + 64), v5);
  CFRelease(v5);
}

void sub_1000EE5F4(int a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  void (*v6)(uint64_t, uint64_t, CFDictionaryRef, _QWORD);
  const __CFBoolean *Value;
  _BYTE *v8;
  const __CFNumber *v9;
  void *v10;
  int v11;
  void *v12;
  __CFNotificationCenter *LocalCenter;
  void *v14;
  int v15;
  void *v16;

  if (a4)
  {
    v6 = *(void (**)(uint64_t, uint64_t, CFDictionaryRef, _QWORD))(a4 + 4472);
    if (v6)
      v6(a4, a2, theDict, *(_QWORD *)(a4 + 4480));
    if (theDict)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE"));
      if (Value)
      {
        v8 = (_BYTE *)(a4 + 5222);
        *(_BYTE *)(a4 + 3488) = CFBooleanGetValue(Value);
        v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_REASON"));
        if (v9)
          CFNumberGetValue(v9, kCFNumberSInt32Type, (void *)(a4 + 3492));
        if (!*(_BYTE *)(a4 + 3488))
        {
          sub_10013A94C(a4);
          v11 = *(_DWORD *)(a4 + 3492);
          if (v11 == -528345084)
          {
            v12 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "clearing slowWiFi HUD on S2R");
            objc_autoreleasePoolPop(v12);
            sub_10013AA70(a4);
            *(_BYTE *)(a4 + 3496) = 0;
            v11 = *(_DWORD *)(a4 + 3492);
          }
          else
          {
            *(_BYTE *)(a4 + 3496) = 1;
          }
          if (v11 == -528336895)
            objc_msgSend(*(id *)(a4 + 6648), "removeDenyListStateWithDenyListRemoveReason:", 7);
          if (*(_QWORD *)(a4 + 4944))
          {
            v15 = *(_DWORD *)(a4 + 3492);
            if (v15 == -528345084 || v15 == -528336891)
              return;
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS is in session. Driver is unavailable. Starting recovery timer!", "__WiFiDeviceManagerAvailableCallback");
            objc_autoreleasePoolPop(v16);
            *v8 = 1;
            sub_1001074BC(a4, 1);
          }
          sub_1000FB44C(a4);
          return;
        }
        if (*(_QWORD *)(a4 + 4944) && *v8)
        {
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS is in recovery. Driver is available. Restarting MIS network!", "__WiFiDeviceManagerAvailableCallback");
          objc_autoreleasePoolPop(v10);
          sub_100107ABC(a4);
        }
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          if (*(_BYTE *)(a4 + 3496))
            sub_1000285E4(a4, 7uLL);
        }
        else
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 7, sub_100025C3C(*(_QWORD *)(a4 + 64)));
          sub_1000FBA80(a4, 2, (uint64_t)"WiFiDeviceManagerAutoAssociateStart");
        }
        *(_BYTE *)(a4 + 7296) = 0;
        *(_BYTE *)(a4 + 3496) = 0;
        if (*(_BYTE *)(a4 + 3497))
        {
          LocalCenter = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterPostNotification(LocalCenter, CFSTR("WiFiChipResetCompleted"), 0, 0, 1u);
          *(_BYTE *)(a4 + 3497) = 0;
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: announced driver availability (WiFiChipResetCompleted)", "__WiFiDeviceManagerAvailableCallback");
          objc_autoreleasePoolPop(v14);
        }
      }
    }
  }
}

uint64_t sub_1000EE8DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 3976);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 3984));
  }
  return result;
}

uint64_t sub_1000EE8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4184);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4048));
  }
  return result;
}

uint64_t sub_1000EE91C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4200);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4048));
  }
  return result;
}

void sub_1000EE93C(uint64_t a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4)
{
  void *v7;
  const __CFString *v8;
  _BOOL8 v9;
  _BOOL4 v10;
  const void *v11;
  const void *v12;
  _BOOL8 v13;
  uint64_t v14;
  _BOOL8 v15;
  void (*v16)(uint64_t, const __CFString *, const void *, _BOOL8, _BOOL8, uint64_t, _BOOL8, _QWORD);
  void *v17;
  void *v18;
  NSString *v19;
  uint64_t v20;
  uint8_t buf[4];
  const char *v23;

  if (a4)
  {
    v20 = a4 + 5504;
    *(_BYTE *)(a4 + 5504) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a4 + 5512), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(_DWORD *)(a4 + 688) = 0;
    *(_QWORD *)(a4 + 680) = 0;
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disabling critical phase", "__WiFiDeviceManagerRouterIpv4Callback");
    objc_autoreleasePoolPop(v7);
    v8 = (const __CFString *)sub_100025C3C(a1);
    v9 = 0;
    if (a2 && v8)
      v9 = CFStringCompare(v8, a2, 0) == kCFCompareEqualTo;
    v10 = sub_100066DF8(a1);
    if (v10)
    {
      v11 = sub_10002BF8C(a1, a2);
      v12 = v11;
      if (v11 && sub_10000BE8C((uint64_t)v11))
        *(CFAbsoluteTime *)(a4 + 720) = CFAbsoluteTimeGetCurrent();
    }
    else
    {
      v12 = 0;
    }
    v13 = sub_100066EE4(a1);
    v14 = sub_100066F00(a1);
    v15 = sub_100066F0C(a1);
    v16 = *(void (**)(uint64_t, const __CFString *, const void *, _BOOL8, _BOOL8, uint64_t, _BOOL8, _QWORD))(a4 + 4408);
    if (v16)
      v16(a4, a2, v12, v9, v13, v14, v15, *(_QWORD *)(a4 + 4416));
    if (v10 && v9)
    {
      v17 = objc_autoreleasePoolPush();
      objc_msgSend(*(id *)(a4 + 6624), "disarmHomeNetworkTransitionTimer");
      objc_msgSend(*(id *)(a4 + 6624), "armHomeNetworkTransitionTimer:", a4);
      objc_autoreleasePoolPop(v17);
    }
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v19 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: ip address configuration completed for %@"), "__WiFiDeviceManagerRouterIpv4Callback", sub_10002B088(v12))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v23 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v19, "UTF8String")), "UTF8String");
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v18);
    if (v12)
      CFRelease(v12);
    sub_1000432AC(*(_QWORD *)(a4 + 120), a2, a3);
    if (*(_BYTE *)(v20 + 1392))
    {
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        objc_msgSend(*(id *)(a4 + 8824), "setRetrySchedule:", 4);
      else
        sub_1000FBA80(a4, 2, (uint64_t)"__WiFiDeviceManagerRouterIpv4Callback");
    }
    sub_1001091D8(a4, 5u, v13 | (2 * ((_DWORD)v14 != 0)));
    *(_BYTE *)(a4 + 3449) = 1;
    sub_1000FE2A4(a4);
  }
}

void sub_1000EEC80(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  uint64_t v9;
  _BOOL4 v10;
  unsigned __int8 v11;
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  void *v16;
  int v17;
  uint64_t v18;
  CFNumberRef v19;
  void *v20;
  char v21;
  id v22;
  void *v23;
  int v24;
  double v25;
  void *v26;
  char v27;
  uint64_t v28;
  int v29;
  void *v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  const void *v34;
  id v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  CFAbsoluteTime Current;
  const __CFDate *v44;
  const __CFDate *v45;
  int v46;
  id v47;
  void *v48;
  const char *v49;
  CFAbsoluteTime v50;
  const __CFDate *v51;
  double v52;
  const __CFDate *v53;
  void *v54;
  void *v55;
  const void *v56;
  void *v57;
  void *v58;
  id v59;
  void *v60;
  NSString *v61;
  const char *v62;
  CFStringRef v63;
  const __CFString *v64;
  CFDictionaryRef *v65;
  CFDictionaryRef *v66;
  id v67;
  void *v68;
  uint64_t v69;
  double v70;
  double v71;
  id v72;
  id v73;
  void *v74;
  dispatch_time_t v75;
  NSObject *global_queue;
  void *v77;
  void *context;
  _QWORD block[6];
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  CFTypeRef v83;
  void (*v84)(uint64_t);
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  __int128 valuePtr;
  uint64_t v91;
  CFTypeRef v92;
  CFDictionaryRef *v93;
  uint64_t *v94;
  uint64_t v95;

  if (!a3)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiDeviceManagerWiFiPrimaryInfCallback");
    goto LABEL_68;
  }
  sub_100042848(*(_QWORD *)(a3 + 120));
  sub_1001147D4(a3, *(const void **)(a3 + 3512), 0);
  v5 = sub_10002A21C(a3, a2, 1);
  if (!v5)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "__WiFiDeviceManagerWiFiPrimaryInfCallback");
LABEL_68:
    objc_autoreleasePoolPop(v30);
    return;
  }
  v6 = v5;
  if (!*(_BYTE *)(a3 + 3448))
  {
    if (*(_QWORD *)(a3 + 4728))
    {
      if (*(_QWORD *)(a3 + 240))
      {
        *(_QWORD *)&valuePtr = 0;
        *((_QWORD *)&valuePtr + 1) = &valuePtr;
        v91 = 0x2020000000;
        v92 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        v92 = CFRetain(v5);
        CFRetain((CFTypeRef)a3);
        v7 = *(NSObject **)(a3 + 240);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10013AB88;
        block[3] = &unk_10022F160;
        block[4] = &valuePtr;
        block[5] = a3;
        dispatch_async(v7, block);
        _Block_object_dispose(&valuePtr, 8);
      }
      else
      {
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerWiFiPrimaryInfCallback");
        objc_autoreleasePoolPop(v8);
      }
    }
    v9 = *(_QWORD *)(a3 + 3512);
    if (!v9 || sub_10000BE8C(v9))
      goto LABEL_90;
    if (!-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: suppressing join alert as setup is not completed", "__WiFiDeviceManagerShowJoinAlertIfAppropriate");
      goto LABEL_89;
    }
    if (sub_1000CAB28(*(_QWORD *)(a3 + 3512)) && !sub_100008280(*(_QWORD *)(a3 + 3512)))
    {
      v16 = objc_autoreleasePoolPush();
      v17 = sub_10001395C(*(_QWORD *)(a3 + 3512));
      if (!sub_100077738(*(_QWORD *)(a3 + 64)))
      {
        if (v17)
          v18 = 5;
        else
          v18 = 4;
        objc_msgSend(*(id *)(a3 + 6704), "dispatchLowDataModeAlertForNetwork:withReason:", sub_10002B088(*(const void **)(a3 + 3512)), v18);
      }
      LODWORD(valuePtr) = 1;
      v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v19)
      {
        sub_10002C478(*(_QWORD *)(a3 + 3512), CFSTR("SaveDataMode"), v19);
        CFRelease(v19);
        v20 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updating network low data mode to %d", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", valuePtr);
        objc_autoreleasePoolPop(v20);
        sub_1001053C8((NSObject **)a3, *(const void **)(a3 + 3512));
      }
      goto LABEL_89;
    }
    if (sub_100077738(*(_QWORD *)(a3 + 64)))
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ not auto-joined. Suppressing join alert.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", sub_10002B088(*(const void **)(a3 + 3512)));
      goto LABEL_89;
    }
    if (!*(_QWORD *)(a3 + 6720) || !*(_DWORD *)(a3 + 108))
    {
LABEL_90:
      if (!*(_BYTE *)(a3 + 3464))
      {
LABEL_123:
        v86 = 0;
        v87 = &v86;
        v88 = 0x2020000000;
        v89 = 0;
        if (!*(_BYTE *)(a3 + 6713))
        {
          v56 = sub_10002BE64((uint64_t)v6, CFSTR("BSSID"));
          v57 = objc_autoreleasePoolPush();
          if (v56)
          {
            v87[3] = (uint64_t)v6;
            CFRetain(v6);
            v80 = 0;
            v81 = &v80;
            v82 = 0x3052000000;
            v83 = sub_10002FAA8;
            v84 = sub_10002F9A4;
            v85 = 0xAAAAAAAAAAAAAAAALL;
            v85 = sub_10001E1C8((uint64_t)"__WiFiDeviceManagerFetchCurrentNetworkFrom3Bars");
            v58 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: fetching network %@ (bssid %@) from 3bars", "__WiFiDeviceManagerFetchCurrentNetworkFrom3Bars", v87[3], v56);
            objc_autoreleasePoolPop(v58);
            *(_BYTE *)(a3 + 6713) = 1;
            v59 = +[WiFi3BarsObserver sharedWiFi3BarsObserver](WiFi3BarsObserver, "sharedWiFi3BarsObserver");
            *(_QWORD *)&valuePtr = _NSConcreteStackBlock;
            *((_QWORD *)&valuePtr + 1) = 3221225472;
            v91 = (uint64_t)sub_10013B2DC;
            v92 = &unk_100231AE8;
            v93 = (CFDictionaryRef *)&v86;
            v94 = &v80;
            v95 = a3;
            objc_msgSend(v59, "forceFetch3BarsNetworkMatchingBSSID:completionHandler:", v56, &valuePtr);
            _Block_object_dispose(&v80, 8);
          }
          else if (qword_10026DD20)
          {
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bssid is null for network %@", "__WiFiDeviceManagerFetchCurrentNetworkFrom3Bars", v6);
          }
          objc_autoreleasePoolPop(v57);
        }
        _Block_object_dispose(&v86, 8);
        sub_10010159C(a3);
        if (!*(_BYTE *)(a3 + 3449))
        {
          v60 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v61 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: ip address configuration completed for %@"), "__WiFiDeviceManagerWiFiPrimaryInfCallback", sub_10002B088(v6))), "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              v62 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v61, "UTF8String")), "UTF8String");
              LODWORD(valuePtr) = 136446210;
              *(_QWORD *)((char *)&valuePtr + 4) = v62;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&valuePtr, 0xCu);
            }
          }
          objc_autoreleasePoolPop(v60);
          sub_1001091D8(a3, 5u, 4);
        }
        sub_10013AC04(a3, v6, 0);
        if (sub_1000C5964((uint64_t)v6))
        {
          v63 = sub_1000C37A0((CFDictionaryRef *)v6);
          if (v63)
          {
            v64 = sub_1000C3C04(v6);
            sub_1000D9D7C((uint64_t)v64, (uint64_t)v63);
            CFRelease(v63);
          }
        }
        v65 = sub_100122B08(a3);
        v66 = v65;
        if (v65)
        {
          v67 = -[CFDictionaryRef discoveredDevices](v65, "discoveredDevices");
          v68 = v67;
          if (v67
            && (v69 = CWFNetworkProfilePropertyDiscoveredDevicesTimestampKey,
                objc_msgSend(v67, "objectForKeyedSubscript:", CWFNetworkProfilePropertyDiscoveredDevicesTimestampKey))
            && (objc_msgSend(objc_msgSend(v68, "objectForKeyedSubscript:", v69), "timeIntervalSinceNow"),
                v71 = v70,
                v72 = objc_msgSend(v68, "objectForKeyedSubscript:", CWFNetworkProfilePropertyDiscoveredDevicesNamesKey),
                v73 = objc_msgSend(v68, "objectForKeyedSubscript:", CWFNetworkProfilePropertyDiscoveredDevicesCountKey),
                v71 > -86400.0)
            && (v71 > -3600.0 || v72 && v73))
          {
            v74 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping update, interval since last update (%f)", "__WiFiDeviceManagerUpdateLocalNetworkDiscoveredDevices", -v71);
            objc_autoreleasePoolPop(v74);
          }
          else
          {
            CFRetain((CFTypeRef)a3);
            CFRetain(v66);
            v75 = dispatch_time(0, 15000000000);
            global_queue = dispatch_get_global_queue(0, 0);
            *(_QWORD *)&valuePtr = _NSConcreteStackBlock;
            *((_QWORD *)&valuePtr + 1) = 3221225472;
            v91 = (uint64_t)sub_10013BE14;
            v92 = &unk_1002306C8;
            v93 = v66;
            v94 = (uint64_t *)a3;
            dispatch_after(v75, global_queue, &valuePtr);
          }
          CFRelease(v66);
        }
        else
        {
          v77 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: nil profile", "__WiFiDeviceManagerUpdateLocalNetworkDiscoveredDevices");
          objc_autoreleasePoolPop(v77);
        }
        goto LABEL_149;
      }
      v39 = objc_autoreleasePoolPush();
      if (!MGGetBoolAnswer(CFSTR("InternalBuild")) || *(_BYTE *)(a3 + 6632))
      {
LABEL_122:
        objc_autoreleasePoolPop(v39);
        goto LABEL_123;
      }
      v40 = *(void **)(a3 + 7072);
      if (v40)
      {
        if (objc_msgSend(v40, "isInProgress"))
        {
          v41 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: link throughput measurement already started.", "__WiFiDeviceManagerPerformThroughputMeasurement");
          objc_autoreleasePoolPop(v41);
          goto LABEL_122;
        }
        v42 = *(void **)(a3 + 7072);
        if (v42)
        {
          objc_msgSend(v42, "abort");

          *(_QWORD *)(a3 + 7072) = 0;
        }
      }
      Current = CFAbsoluteTimeGetCurrent();
      v44 = CFDateCreate(kCFAllocatorDefault, Current);
      v45 = (const __CFDate *)sub_10002BE64((uint64_t)v6, CFSTR("lastTputMeasurementDate"));
      v46 = sub_10002BF80(*(_QWORD *)(a3 + 64));
      if (v45)
      {
        if (CFDateGetTimeIntervalSinceDate(v44, v45) > dbl_1001BBC00[v46 == 0])
          goto LABEL_102;
LABEL_115:
        v54 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: throughput measurement was last run on %@", "__WiFiDeviceManagerPerformThroughputMeasurement", v45);
        objc_autoreleasePoolPop(v54);
        v55 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: throughput measurement throughput report %@", "__WiFiDeviceManagerPerformThroughputMeasurement", sub_10002BE64((uint64_t)v6, CFSTR("lastTputMeasurementResults")));
        objc_autoreleasePoolPop(v55);
        goto LABEL_120;
      }
      v50 = CFAbsoluteTimeGetCurrent();
      v51 = CFDateCreate(kCFAllocatorDefault, v50);
      v52 = sub_10002DFE4((uint64_t)v6);
      v53 = (const __CFDate *)sub_10002E000(v6);
      if (v53)
      {
        v52 = v52 + CFDateGetTimeIntervalSinceDate(v51, v53);
      }
      else
      {
        context = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get last association date for %@.", "__WiFiDeviceManagerPerformThroughputMeasurement", sub_10002B088(v6));
        objc_autoreleasePoolPop(context);
      }
      if (v51)
      {
        CFRelease(v51);
        if (v52 <= 259200.0)
          goto LABEL_115;
      }
      else if (v52 <= 259200.0)
      {
        goto LABEL_115;
      }
LABEL_102:
      v47 = objc_msgSend(objc_alloc((Class)WFMeasure), "initWithType:andReason:prevTestedOptions:andInterfaceName:", 1, CFSTR("Primary&Charging"), 0, sub_100025C3C(*(_QWORD *)(a3 + 64)));
      *(_QWORD *)(a3 + 7072) = v47;
      if (v47)
      {
        v80 = 0;
        v81 = &v80;
        v82 = 0x2020000000;
        v83 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        v83 = CFRetain(v6);
        *(_QWORD *)&valuePtr = _NSConcreteStackBlock;
        *((_QWORD *)&valuePtr + 1) = 3221225472;
        v91 = (uint64_t)sub_10013AE80;
        v92 = &unk_100231AC0;
        v93 = (CFDictionaryRef *)&v80;
        v94 = (uint64_t *)a3;
        LOBYTE(v95) = 0;
        objc_msgSend(*(id *)(a3 + 7072), "start:withCompletionQueue:", &valuePtr, *(_QWORD *)(a3 + 240));
        v48 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v49 = "as periodic test";
          if (!v45)
            v49 = "as first test";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: throughput measurement started for %@, triggered %s", "__WiFiDeviceManagerPerformThroughputMeasurement", v81[3], v49);
        }
        objc_autoreleasePoolPop(v48);
        _Block_object_dispose(&v80, 8);
      }
LABEL_120:
      if (v44)
        CFRelease(v44);
      goto LABEL_122;
    }
    v10 = sub_1000CB480(*(_QWORD *)(a3 + 3512));
    if (sub_10002BE64(*(_QWORD *)(a3 + 3512), CFSTR("WiFiNetworkAttributeIsPublic")) == kCFBooleanTrue)
      v11 = 1;
    else
      v11 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isOmnipresentNetwork:", *(_QWORD *)(a3 + 3512));
    v12 = *(_QWORD *)(a3 + 6720);
    if (v12 == 255)
    {
      v29 = 1;
      goto LABEL_74;
    }
    v13 = *(const void **)(a3 + 112);
    if (v13)
    {
      v14 = sub_10002B088(*(const void **)(a3 + 3512));
      if (CFEqual(v13, v14))
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: matching ATJ test network %@, bypass network type check.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", *(_QWORD *)(a3 + 112));
        objc_autoreleasePoolPop(v15);
        goto LABEL_42;
      }
      v12 = *(_QWORD *)(a3 + 6720);
    }
    if ((unint64_t)(v12 - 253) < 2)
      v21 = 1;
    else
      v21 = v11;
    if ((v21 & 1) == 0 && !v10)
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ not a public/carrier network. Suppressing join alert.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", sub_10002B088(*(const void **)(a3 + 3512)));
      goto LABEL_89;
    }
LABEL_42:
    v22 = sub_100009ACC(a3);
    if (v22)
    {
      if (objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isWithin:fromLocation:forNetwork:", v22, *(_QWORD *)(a3 + 3512), *(double *)(a3 + 6728)) == (id)1)
      {
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is not at known location.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", sub_10002B088(*(const void **)(a3 + 3512)));
        objc_autoreleasePoolPop(v23);
        v24 = 0;
      }
      else
      {
        v24 = 1;
      }

    }
    else
    {
      v24 = 1;
    }
    v25 = sub_1000C6A74(*(const void **)(a3 + 3512));
    if (v25 >= 0.0 && v25 <= *(double *)(a3 + 6736))
    {
      v27 = 0;
    }
    else
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is not joined recently.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", sub_10002B088(*(const void **)(a3 + 3512)));
      objc_autoreleasePoolPop(v26);
      v27 = 1;
    }
    v28 = *(_QWORD *)(a3 + 6720);
    if ((v28 & 0xFFFFFFFFFFFFFFFDLL) == 0xFC)
      v29 = 0;
    else
      v29 = v24;
    if ((v27 & 1) == 0 && (v28 & 0xFFFFFFFFFFFFFFFELL) != 0xFC && v29)
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is within range of known location or last joined date. Suppressing join alert.", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", sub_10002B088(*(const void **)(a3 + 3512)));
LABEL_89:
      objc_autoreleasePoolPop(v16);
      goto LABEL_90;
    }
LABEL_74:
    v16 = objc_autoreleasePoolPush();
    v31 = *(_QWORD *)(a3 + 64);
    v32 = (const void *)sub_100025C3C(v31);
    v33 = sub_10002BF8C(v31, v32);
    v34 = sub_10002B088(v33);
    v35 = sub_10012E8C8(a3);
    if ((objc_msgSend(v35, "containsObject:", v34) & 1) != 0)
    {
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is blacklisted from join alerts", "__WiFiDeviceManagerShowJoinAlertIfAppropriate", v34);
      objc_autoreleasePoolPop(v36);
    }
    else
    {
      if (v29)
        v37 = 3;
      else
        v37 = 2;
      if (v10)
        v38 = *(_QWORD *)(a3 + 6192);
      else
        v38 = 0;
      objc_msgSend(*(id *)(a3 + 6704), "dispatchJoinAlertForNetwork:withProviderName:andReason:", v34, v38, v37);
    }
    if (v35)
      CFRelease(v35);
    if (v33)
      CFRelease(v33);
    goto LABEL_89;
  }
LABEL_149:
  *(_BYTE *)(a3 + 3448) = 1;
  CFRelease(v6);
}

void sub_1000EFBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EFBF8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;

  if (a3)
    return sub_1000426D8(*(_QWORD *)(a3 + 120), a2, a4);
  return result;
}

void sub_1000EFC0C(uint64_t a1, const void *a2, uint64_t a3, int a4, uint64_t a5)
{
  void *v9;
  void *v10;
  const void *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  void (*v16)(uint64_t, uint64_t, uint64_t, _QWORD);
  void *v17;
  void *v18;
  void *v19;

  v9 = objc_autoreleasePoolPush();
  if (!a3)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Device Manager is NULL", "__WiFiLQAMgrTrigDiscEventCallback");
    goto LABEL_19;
  }
  if (!a2)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Device IfName is NULL", "__WiFiLQAMgrTrigDiscEventCallback");
LABEL_19:
    objc_autoreleasePoolPop(v18);
    goto LABEL_14;
  }
  v10 = sub_10002A21C(a3, a2, 1);
  v11 = sub_10002BE64((uint64_t)v10, CFSTR("BSSID"));
  if (v11)
  {
    if (v10)
    {
      v12 = (uint64_t)v11;
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAMgr Trigger Disconnected and Blacklisted Network %@", "__WiFiLQAMgrTrigDiscEventCallback", sub_10002B088(v10));
      objc_autoreleasePoolPop(v13);
      sub_1000F7F48(a3, a2, 1000, "__WiFiLQAMgrTrigDiscEventCallback", 10200);
      v14 = sub_100027D10((uint64_t)v10);
      v15 = sub_1000FCB38(a3, 6, a4, v12, 1);
      objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v15, v14);
      -[WiFiUsageMonitor setTdLogic_deferJoin:perBSSID:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setTdLogic_deferJoin:perBSSID:", 60 * (_QWORD)objc_msgSend(*(id *)(a3 + 6648), "denyListThresholdForReason:forSSIDThresholds:", 6, 1), 60 * (_QWORD)objc_msgSend(*(id *)(a3 + 6648), "denyListThresholdForReason:forSSIDThresholds:", 6, 0));

      if (*(_BYTE *)(a3 + 6216))
      {
        v16 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a3 + 4552);
        if (v16)
        {
          v16(a3, 6, a5, *(_QWORD *)(a3 + 4560));
        }
        else
        {
          v17 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerTriggerDisconnectNotification");
          objc_autoreleasePoolPop(v17);
        }
      }
LABEL_13:
      CFRelease(v10);
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, BSSID is NULL", "__WiFiLQAMgrTrigDiscEventCallback");
    objc_autoreleasePoolPop(v19);
    if (v10)
      goto LABEL_13;
  }
LABEL_14:
  objc_autoreleasePoolPop(v9);
}

uint64_t sub_1000EFEA8(uint64_t a1, const void *a2, uint64_t a3)
{
  return sub_100126120(a3, a2);
}

uint64_t sub_1000EFEB0(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  const void *v6;
  void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  void *v12;
  void *v13;
  uint64_t v14;

  if (!_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
    return 0;
  if (!a4)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: devicemanager null", "__WiFiDeviceManagerColocatedScopeTransitionCallback", v14);
    goto LABEL_26;
  }
  if (!a3)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: transitionNetwork null", "__WiFiDeviceManagerColocatedScopeTransitionCallback", v14);
    goto LABEL_26;
  }
  if (*(_BYTE *)(a4 + 6616))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: already in progress", "__WiFiDeviceManagerColocatedScopeTransitionCallback", v14);
    goto LABEL_26;
  }
  if (!sub_1000FE338((_QWORD *)a4, a3))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: transitionNetwork %@ is not a known network", "__WiFiDeviceManagerColocatedScopeTransitionCallback", sub_10002B088(a3));
    goto LABEL_26;
  }
  v6 = (const void *)sub_100029860(*(_QWORD *)(a4 + 64));
  v7 = sub_10002A21C(a4, v6, 1);
  if (!v7)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: current Network null", "__WiFiDeviceManagerColocatedScopeTransitionCallback", v14);
LABEL_26:
    objc_autoreleasePoolPop(v12);
    return 0;
  }
  v8 = v7;
  if (sub_10013E690(a4, (uint64_t)v7, (uint64_t)a3))
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000285E4(a4, 0x27uLL);
    }
    else
    {
      v9 = *(const void **)(a4 + 6608);
      if (v9)
      {
        CFRelease(v9);
        *(_QWORD *)(a4 + 6608) = 0;
      }
      *(_QWORD *)(a4 + 6608) = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)a3);
      sub_1000FA0A0(a4, 7);
    }
    v10 = 1;
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ColocatedScopeIds mismatch", "__WiFiDeviceManagerColocatedScopeTransitionCallback");
    objc_autoreleasePoolPop(v13);
    v10 = 0;
  }
  CFRelease(v8);
  return v10;
}

void sub_1000F0110(int a1, uint64_t a2, uint64_t a3, CFTypeRef cf)
{
  CFTypeID v7;
  const __CFNumber *Value;
  void *v9;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, _QWORD, CFTypeRef);
  unsigned int valuePtr;

  valuePtr = 0;
  if (!a3)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v12 = "%s: manager is NULL !";
    goto LABEL_23;
  }
  if (!cf || (v7 = CFGetTypeID(cf), v7 != CFDictionaryGetTypeID()))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_12:
      objc_autoreleasePoolPop(v10);
      return;
    }
    v12 = "%s:NULL event Data";
    v13 = 3;
LABEL_11:
    objc_msgSend(v11, "WFLog:message:", v13, v12, "__WiFiDeviceManagerLeakyAPEventCallback");
    goto LABEL_12;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("LEAKY_AP_STATS_VER"));
  if (!Value)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v12 = "%s, leakyAPStatsVersionRef is NULL";
LABEL_23:
    v13 = 4;
    goto LABEL_11;
  }
  CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr == 2)
  {
    v14 = *(void (**)(uint64_t, uint64_t, _QWORD, CFTypeRef))(a3 + 4488);
    if (v14)
      v14(a3, a2, *(_QWORD *)(a3 + 4496), cf);
  }
  else
  {
    if (valuePtr == 1)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignoring Leaky AP report version %d", valuePtr);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown LEaky AP report version %d", valuePtr);
    }
    objc_autoreleasePoolPop(v9);
  }
}

void sub_1000F02D4(uint64_t a1, _QWORD *a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  uint64_t v5;
  const void *v6;
  __CFDictionary *Mutable;
  const void *v8;
  void *v9;
  void *v10;
  int valuePtr;

  valuePtr = 1;
  if (!a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL !", "__WiFiDeviceManagerActiveProbeQueryCallback");
    goto LABEL_17;
  }
  if (!a2[15])
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA manager is NULL !", "__WiFiDeviceManagerActiveProbeQueryCallback");
LABEL_17:
    objc_autoreleasePoolPop(v10);
    return;
  }
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    v4 = v3;
    v5 = a2[8];
    v6 = (const void *)sub_100025C3C(v5);
    sub_1000672C0(v5, v6, 538, 0, (uint64_t)v4);
    CFRelease(v4);
  }
  if (!a2[695])
  {
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    a2[695] = Mutable;
    if (sub_100115414((uint64_t)a2, Mutable, 5, dword_1001BBD34, 3u, 1u, 0, 0))
    {
      v8 = (const void *)a2[695];
      if (v8)
      {
        CFRelease(v8);
        a2[695] = 0;
      }
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Triggering Active Probe failed!", "__WiFiDeviceManagerActiveProbeQueryCallback");
      objc_autoreleasePoolPop(v9);
    }
  }
}

uint64_t sub_1000F047C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4504);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4512));
  }
  return result;
}

void sub_1000F049C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v4)(uint64_t, uint64_t, uint64_t *, _QWORD);
  void *v5;
  uint64_t v6;

  v6 = a4;
  if (a3)
  {
    v4 = *(void (**)(uint64_t, uint64_t, uint64_t *, _QWORD))(a3 + 4552);
    if (v4)
    {
      v4(a3, 5, &v6, *(_QWORD *)(a3 + 4560));
      return;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerSymptomsEventCallback", v6);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerSymptomsEventCallback", v6);
  }
  objc_autoreleasePoolPop(v5);
}

void sub_1000F0558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  void *v5;

  if (a3)
  {
    if (a4)
    {
      v4 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a3 + 4552);
      if (v4)
      {
        v4(a3, 4, a4, *(_QWORD *)(a3 + 4560));
        return;
      }
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerTxFailEventCallback");
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: txFailHistoryData is NULL!", "__WiFiDeviceManagerTxFailEventCallback");
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerTxFailEventCallback");
  }
  objc_autoreleasePoolPop(v5);
}

void sub_1000F0644(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  CFDictionaryRef *v8;
  const __CFNumber *Value;
  int v10;
  const void *v11;
  void *v12;
  const void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  void *v18;
  _WORD *v19;
  char *v21;
  NSString *v22;
  id v23;
  void *v24;
  _WORD *v25;
  id v26;
  unint64_t v27;
  id v28;
  void *v29;
  id v30;
  int v31;
  void *v32;
  CFMutableArrayRef v33;
  void (*v34)(uint64_t, uint64_t, _QWORD, _QWORD);
  void *v35;
  void (*v36)(uint64_t, _QWORD, const __CFDictionary *);
  int v37;
  NSObject *v38;
  dispatch_time_t v39;
  id v40;
  id v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  const void *v47;
  CFDictionaryRef *v48;
  const void *v49;
  int v50;
  void *context;
  int valuePtr;
  int v53;
  __int16 v54;

  valuePtr = 0;
  if (!a3)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerRoamStatusEventCallback");
    goto LABEL_60;
  }
  if (!a1)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device is NULL!", "__WiFiDeviceManagerRoamStatusEventCallback");
LABEL_60:
    objc_autoreleasePoolPop(v43);
    return;
  }
  v8 = (CFDictionaryRef *)sub_1000764F8(a1);
  if (!a4)
  {
    v44 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: dict is NULL!", "__WiFiDeviceManagerRoamStatusEventCallback");
    objc_autoreleasePoolPop(v44);
    v33 = 0;
    v13 = 0;
    goto LABEL_70;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("ROAMEDEVENT_STATUS"));
  if (!Value
    || ((CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr), v10 = 0, (valuePtr + 528350197) > 0x3E)
     || ((1 << (valuePtr - 11)) & 0x73C0000000000017) == 0)
    && valuePtr != -528350204)
  {
    v10 = 1;
  }
  v11 = CFDictionaryGetValue(a4, CFSTR("ROAMEDEVENT_ORIGIN_ADDR"));
  v12 = sub_10002A21C(a3, a2, 1);
  if (v12)
  {
    v13 = v12;
    v50 = v10;
    v49 = v11;
    sub_1000765BC(*(_QWORD *)(a3 + 64), (uint64_t)v12);
    context = objc_autoreleasePoolPush();
    if (sub_100075280(*(_QWORD *)(a3 + 64)))
    {
      v14 = (void *)CFDictionaryGetValue(a4, CFSTR("ROAM_STATUS_SUBSTATE_INFO"));
      if (v14)
      {
        v15 = v14;
        v16 = objc_msgSend(v14, "objectForKey:", CFSTR("ROAM_STATUS_SUBSTATE_FLAGS"));
        if (v16)
        {
          if (objc_msgSend(v16, "intValue"))
          {
            v17 = objc_msgSend(v15, "objectForKey:", CFSTR("BSSID"));
            if (v17)
            {
              v18 = v17;
              v54 = 0;
              v53 = 0;
              v19 = objc_msgSend(v17, "bytes");
              if (v53 != *(_DWORD *)v19 || v54 != v19[2])
              {
                v21 = ether_ntoa((const ether_addr *)objc_msgSend(v18, "bytes"));
                v22 = v21
                    ? +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21)
                    : 0;
                v23 = sub_100132F18(v15, (uint64_t)v22);
                if (v23)
                {
                  v24 = v23;
                  if (objc_msgSend(v23, "count"))
                  {
                    v48 = v8;
                    v25 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v13);
                    sub_10002C478((uint64_t)v25, CFSTR("BSSID"), v22);
                    v47 = v25;
                    v26 = sub_100027D10((uint64_t)v25);
                    if (objc_msgSend(v24, "count"))
                    {
                      v27 = 0;
                      do
                      {
                        v28 = sub_1000FCB38(a3, 8, (uint64_t)objc_msgSend(v24, "objectAtIndex:", v27), (uint64_t)v22, 2);
                        objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v28, v26);

                        ++v27;
                      }
                      while (v27 < (unint64_t)objc_msgSend(v24, "count"));
                    }
                    v29 = *(void **)(a3 + 7368);
                    if (v29)
                      objc_msgSend(v29, "addFaultEvent:forInterface:", 9, sub_100025C3C(*(_QWORD *)(a3 + 64)));
                    v8 = v48;
                    if (v47)
                      CFRelease(v47);

                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v45 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s dict for roam status is nil", "__WiFiDeviceManagerProcessRoamStatusSubState");
        objc_autoreleasePoolPop(v45);
      }
    }
    objc_autoreleasePoolPop(context);
    if (sub_100077880(a1))
    {
      v30 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
      v31 = v50;
      if (!v30)
      {
        v46 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamManager is NULL", "__WiFiDeviceManagerRoamStatusEventCallback");
        objc_autoreleasePoolPop(v46);
        v33 = 0;
        goto LABEL_70;
      }
      v32 = v30;
      if (v50)
        v33 = sub_100071C70(*(_QWORD *)(a3 + 64));
      else
        v33 = 0;
      objc_msgSend(v32, "setRoamStatus:withBeaconCache:forInterface:", a4, v33, a2);
      if ((objc_msgSend(v32, "canSubmitMetrics") & 1) == 0)
        goto LABEL_41;
    }
    else
    {
      v33 = 0;
      v31 = v50;
    }
    sub_100127EF0(a3, v13, a4);
LABEL_41:
    v34 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a3 + 4552);
    if (v34)
    {
      v34(a3, 11, 0, *(_QWORD *)(a3 + 4560));
    }
    else
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerRoamStatusEventCallback");
      objc_autoreleasePoolPop(v35);
    }
    v36 = *(void (**)(uint64_t, _QWORD, const __CFDictionary *))(a3 + 4632);
    if (v36)
      v36(a3, *(_QWORD *)(a3 + 4640), a4);
    v37 = valuePtr;
    if (!valuePtr)
    {
      v38 = *(NSObject **)(a3 + 8968);
      v39 = dispatch_time(0, 1000000000);
      dispatch_source_set_timer(v38, v39, 0xFFFFFFFFFFFFFFFFLL, 0);
      v37 = valuePtr;
    }
    if (v8 && v37 && ((v31 ^ 1) & 1) == 0)
    {
      if (!v33)
        v33 = sub_100071C70(*(_QWORD *)(a3 + 64));
      v40 = sub_100027D10((uint64_t)v8);
      v41 = objc_msgSend(v40, "scanResultWithMatchingKnownNetworkProfile:", sub_100026664(v8));
      v42 = objc_msgSend((id)CWFKnownNetworksSupportingSeamlessSSIDTransitionForScanResult(v41, objc_msgSend(objc_msgSend(*(id *)(a3 + 8824), "knownNetworks"), "allObjects"), 1), "valueForKey:", CFSTR("SSID"));
      -[WiFiUsageMonitor updateKnownNetworksSupportingSeamless:forBSS:andSSID:beaconCache:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "updateKnownNetworksSupportingSeamless:forBSS:andSSID:beaconCache:", v42, v49, sub_10002B088(v13), v33);
      goto LABEL_71;
    }
LABEL_70:
    if (!v8)
    {
LABEL_72:
      if (v13)
        CFRelease(v13);
      if (v33)
        CFRelease(v33);
      return;
    }
LABEL_71:
    CFRelease(v8);
    goto LABEL_72;
  }
}

void sub_1000F0C3C(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  void *v7;
  void *v8;
  const void *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  void *v12;
  const __CFArray *v13;
  const __CFString *v14;
  CFTypeID v15;
  ether_addr *v16;
  char *v17;
  const __CFAllocator *v18;
  CFIndex v19;
  CFTypeID v20;
  const __CFNumber *Value;
  const __CFNumber *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  const __CFString *v37;
  const __CFString *v38;
  CFTypeID TypeID;
  CFStringRef Copy;
  void *v41;
  const __CFString *v42;
  const __CFString *v43;
  CFTypeID v44;
  CFStringRef v45;
  void *v46;
  void *v47;
  int v48;
  const void *v49;
  const void *v50;
  void *v51;
  void *v52;
  char buffer[24];
  CFRange v54;

  v7 = objc_autoreleasePoolPush();
  if (!a3)
  {
    v51 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerActionFrameEventCallback");
    goto LABEL_74;
  }
  v8 = sub_10002A21C(a3, a2, 1);
  if (!v8)
  {
    v51 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: currentNetwork is NULL!", "__WiFiDeviceManagerActionFrameEventCallback");
LABEL_74:
    objc_autoreleasePoolPop(v51);
    goto LABEL_68;
  }
  v9 = v8;
  v10 = (unsigned __int8 *)malloc_type_malloc(0x38uLL, 0x10600406BF8FC03uLL);
  if (!v10)
  {
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null afMetric", "__WiFiDeviceManagerActionFrameEventCallback");
    objc_autoreleasePoolPop(v52);
    goto LABEL_67;
  }
  v11 = v10;
  *((_QWORD *)v10 + 6) = 0;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  *(_OWORD *)v10 = 0u;
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: received action frame event for network %@: %@", "__WiFiDeviceManagerActionFrameEventCallback", sub_10002B088(v9), a4);
  objc_autoreleasePoolPop(v12);
  v13 = sub_10001F1E8((const __CFArray *)v9);
  if (!v13)
  {
LABEL_12:
    buffer[0] = 0;
    v18 = kCFAllocatorDefault;
    v17 = buffer;
    v19 = 1;
    goto LABEL_13;
  }
  v14 = (const __CFString *)v13;
  v15 = CFGetTypeID(v13);
  if (v15 != CFStringGetTypeID())
  {
    v20 = CFGetTypeID(v14);
    if (v20 == CFDataGetTypeID())
    {
      CFRetain(v14);
LABEL_14:
      v54.location = 0;
      v54.length = 3;
      CFDataGetBytes((CFDataRef)v14, v54, v11);
      CFRelease(v14);
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  memset(buffer, 170, 19);
  CFStringGetCString(v14, buffer, 19, 0);
  v16 = ether_aton(buffer);
  if (!v16)
    goto LABEL_15;
  v17 = (char *)v16;
  v18 = kCFAllocatorDefault;
  v19 = 6;
LABEL_13:
  v14 = (const __CFString *)CFDataCreate(v18, (const UInt8 *)v17, v19);
  if (v14)
    goto LABEL_14;
LABEL_15:
  Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("CATEGORY_CODE"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt8Type, v11 + 8);
  v22 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("ACTION_CODE"));
  if (v22)
    CFNumberGetValue(v22, kCFNumberSInt8Type, v11 + 9);
  v23 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("DIALOG_TOKEN"));
  if (v23)
    CFNumberGetValue(v23, kCFNumberSInt8Type, v11 + 10);
  v24 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("PREF_CANDIDATE_INCLUDED"));
  if (v24)
    CFNumberGetValue(v24, kCFNumberSInt8Type, v11 + 18);
  v25 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("ABRIDGED"));
  if (v25)
    CFNumberGetValue(v25, kCFNumberSInt8Type, v11 + 19);
  v26 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("DISASSOC_IMMINENT"));
  if (v26)
    CFNumberGetValue(v26, kCFNumberSInt8Type, v11 + 20);
  v27 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("BSS_TERM_INCLUDED"));
  if (v27)
    CFNumberGetValue(v27, kCFNumberSInt8Type, v11 + 21);
  v28 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("ESS_TERM_INCLUDED"));
  if (v28)
    CFNumberGetValue(v28, kCFNumberSInt8Type, v11 + 22);
  v29 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("DISASSOC_TIMEOUT"));
  if (v29)
    CFNumberGetValue(v29, kCFNumberSInt16Type, v11 + 14);
  v30 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("VALIDITY_INTERVAL"));
  if (v30)
    CFNumberGetValue(v30, kCFNumberSInt8Type, v11 + 16);
  v31 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("BTM_RSP_STATUS"));
  if (v31)
    CFNumberGetValue(v31, kCFNumberSInt8Type, v11 + 11);
  v32 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("BSS_TERM_DELAY"));
  if (v32)
    CFNumberGetValue(v32, kCFNumberSInt8Type, v11 + 17);
  *((_DWORD *)v11 + 1) = sub_10002A724(a3, v9);
  v33 = (const __CFNumber *)sub_1000316E0((uint64_t)v9);
  if (v33)
    CFNumberGetValue(v33, kCFNumberSInt32Type, v11 + 24);
  v34 = (const __CFNumber *)sub_1000C6AE4((uint64_t)v9);
  if (v34)
    CFNumberGetValue(v34, kCFNumberSInt32Type, v11 + 36);
  *((_DWORD *)v11 + 7) = sub_100008CEC((uint64_t)v9);
  *((_DWORD *)v11 + 8) = sub_1000C6B54((uint64_t)v9);
  v35 = (const __CFDictionary *)sub_10002BE64((uint64_t)v9, CFSTR("WPS_PROB_RESP_IE"));
  if (v35)
  {
    v36 = v35;
    v37 = (const __CFString *)CFDictionaryGetValue(v35, CFSTR("IE_KEY_WPS_MODEL_NAME"));
    if (v37 && (v38 = v37, TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v38)))
    {
      Copy = CFStringCreateCopy(kCFAllocatorDefault, v38);
    }
    else
    {
      v41 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelName. Not a CFString or NULL", "__WiFiDeviceManagerActionFrameEventCallback");
      objc_autoreleasePoolPop(v41);
      Copy = 0;
    }
    *((_QWORD *)v11 + 5) = Copy;
    v42 = (const __CFString *)CFDictionaryGetValue(v36, CFSTR("IE_KEY_WPS_MODEL_NUM"));
    if (v42 && (v43 = v42, v44 = CFStringGetTypeID(), v44 == CFGetTypeID(v43)))
    {
      v45 = CFStringCreateCopy(kCFAllocatorDefault, v43);
    }
    else
    {
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelNumber. Not a CFString or NULL", "__WiFiDeviceManagerActionFrameEventCallback");
      objc_autoreleasePoolPop(v46);
      v45 = 0;
    }
    *((_QWORD *)v11 + 6) = v45;
  }
  v47 = *(void **)(a3 + 7368);
  if (v47)
  {
    v48 = v11[9];
    if (v48 == 8)
    {
      objc_msgSend(v47, "sentBssTransitionResponse:status:terminationDelayRequested:", a2, v11[11], v11[17] != 0);
    }
    else if (v48 == 7)
    {
      objc_msgSend(v47, "receivedBssTransitionRequest:candidateListIncluded:isAbridged:disassociationImminent:bssTerminationIncluded:essDisassociationImminent:", a2, v11[18] != 0, v11[19] != 0, v11[20] != 0, v11[21] != 0, v11[22] != 0);
    }
  }
  sub_10005AA48((__int128 *)v11);
  v49 = (const void *)*((_QWORD *)v11 + 5);
  if (v49)
  {
    CFRelease(v49);
    *((_QWORD *)v11 + 5) = 0;
  }
  v50 = (const void *)*((_QWORD *)v11 + 6);
  if (v50)
    CFRelease(v50);
  free(v11);
LABEL_67:
  CFRelease(v9);
LABEL_68:
  objc_autoreleasePoolPop(v7);
}

void sub_1000F1278(uint64_t a1, uint64_t a2, id *a3, __CFDictionary **a4)
{
  void *v4;

  if (a3)
  {
    if (a4)
    {
      *a4 = sub_10013A2E8(a3);
      return;
    }
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AJMetrics is NULL!", "__WiFiDeviceManagerQueryAJMetricsCallback");
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerQueryAJMetricsCallback");
  }
  objc_autoreleasePoolPop(v4);
}

void sub_1000F1328(uint64_t a1, uint64_t a2, uint64_t a3, CFMutableDictionaryRef *a4)
{
  const __CFDictionary *v5;
  CFMutableDictionaryRef MutableCopy;
  void *v7;

  if (!a3)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is NULL!", "__WiFiDeviceManagerQueryLPHSMetricsCallback");
    goto LABEL_11;
  }
  if (!a4)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LPHSMetrics is NULL!", "__WiFiDeviceManagerQueryLPHSMetricsCallback");
LABEL_11:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v5 = *(const __CFDictionary **)(a3 + 7032);
  if (v5)
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v5);
  else
    MutableCopy = 0;
  *a4 = MutableCopy;
}

uint64_t sub_1000F13F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v5)(uint64_t, uint64_t, _QWORD, uint64_t);
  uint64_t result;

  v5 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a5 + 4600);
  if (v5)
    return v5(a5, a2, *(_QWORD *)(a5 + 4608), a3);
  return result;
}

void sub_1000F1410(int a1, int a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  const void *Value;
  const void *v7;
  IOPMAssertionID v8;
  void *v9;
  _DWORD *v10;
  const __CFString *v11;
  uint64_t v12;
  void *v13;

  Value = CFDictionaryGetValue(theDict, CFSTR("SOFTAP_LPM"));
  if (Value)
  {
    v7 = Value;
    if (CFEqual(Value, kCFBooleanFalse))
    {
      v8 = *(_DWORD *)(a5 + 5228);
      if (v8 && !IOPMAssertionRelease(v8))
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "All Clients in Sleep/Inactive Mode, Releasing Power Assertion for SoftAP LPM\n");
        objc_autoreleasePoolPop(v9);
        *(_DWORD *)(a5 + 5228) = 0;
      }
    }
    else if (CFEqual(v7, kCFBooleanTrue) && !*(_DWORD *)(a5 + 5228))
    {
      v10 = (_DWORD *)(a5 + 5228);
      v11 = sub_100070E94();
      v12 = IOPMAssertionCreateWithName(CFSTR("NoIdleSleepAssertion"), 0xFFu, v11, (IOPMAssertionID *)(a5 + 5228));
      v13 = objc_autoreleasePoolPush();
      if ((_DWORD)v12)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to prevent idle sleep during MIS Session, error=%d", v12);
        objc_autoreleasePoolPop(v13);
        *v10 = 0;
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Clients are in active mode, Holding Power Assertion for SoftAP LPM\n");
        objc_autoreleasePoolPop(v13);
      }
    }
  }
}

void sub_1000F1564(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  id v7;
  void *v8;
  const void *v9;
  void *v10;
  const void *v11;
  CFDictionaryRef v12;
  id v13;
  uint64_t v14;
  int v15;
  WiFiPerfPerAssoc *v16;
  uint64_t v17;
  WiFiPerfPerAssoc *v18;
  uint64_t v19;
  void *v20;
  NSData *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  void *v24;
  NSObject *v25;
  dispatch_time_t v26;
  WiFiPerfPerAssoc *v27;
  void *context;
  void *v29;

  v6 = objc_autoreleasePoolPush();
  v7 = -[WiFiPerfPerAssoc getBSSIDForCurrentSession](+[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance"), "getBSSIDForCurrentSession");
  v8 = sub_10002A21C(a3, a2, 1);
  v9 = sub_10002BE64((uint64_t)v8, CFSTR("BSSID"));
  v10 = *(void **)(a3 + 3512);
  if (!v9)
  {
    v16 = +[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance");
    v17 = sub_100077740(a1);
    v18 = v16;
    v19 = 0;
    v20 = v10;
    goto LABEL_25;
  }
  v11 = v9;
  if (v8)
  {
    v29 = v6;
    context = objc_autoreleasePoolPush();
    v12 = sub_1000173C0((uint64_t)v8);
    v13 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithDictionary:", v12);
    v14 = *(_QWORD *)(a3 + 64);
    if (v14)
    {
      *(_DWORD *)(a3 + 1208) = -1;
      bzero((void *)(a3 + 1212), 0x808uLL);
      v15 = sub_100074E58(v14, a3 + 1212);
      *(_DWORD *)(a3 + 1208) = v15;
      if (v15)
        goto LABEL_10;
    }
    else if (*(_DWORD *)(a3 + 1208))
    {
      goto LABEL_10;
    }
    if (*(_DWORD *)(a3 + 1212))
    {
      v21 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3 + 1216);
LABEL_11:
      v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, (const void *)(a3 + 3264));
      if (v22)
      {
        v23 = v22;
        objc_msgSend(v13, "setObject:forKeyedSubscript:", v22, CFSTR("IS_BEACON_AT_HE_RATE"));
        CFRelease(v23);
      }
      objc_msgSend(*(id *)(a3 + 7368), "updateBeaconInfo:andParsedIE:forInterface:", v21, v13, sub_100025C3C(*(_QWORD *)(a3 + 64)));
      if (v12)
        CFRelease(v12);
      if (v13)
        CFRelease(v13);
      objc_autoreleasePoolPop(context);
      v6 = v29;
      if (*(_DWORD *)(a3 + 1208))
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s unable to fetch RawBeacon (err:%d)", "__WiFiDeviceFetchCurrentBeaconData", *(unsigned int *)(a3 + 1208));
        objc_autoreleasePoolPop(v24);
      }
      goto LABEL_21;
    }
LABEL_10:
    v21 = 0;
    goto LABEL_11;
  }
LABEL_21:
  if (v7)
  {
    if ((objc_msgSend(v7, "isEqualToString:", v11) & 1) != 0)
      goto LABEL_26;
    -[WiFiPerfPerAssoc associatedStateDidChange:withAssociatedNetworkRecord:withChangeReason:](+[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance"), "associatedStateDidChange:withAssociatedNetworkRecord:withChangeReason:", 0, v10, 1020);
    v18 = +[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance");
    v19 = 1;
    v20 = v8;
    v17 = 2;
  }
  else
  {
    v25 = *(NSObject **)(a3 + 8968);
    v26 = dispatch_time(0, 1000000000);
    dispatch_source_set_timer(v25, v26, 0xFFFFFFFFFFFFFFFFLL, 0);
    v27 = +[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance");
    v17 = sub_100077738(a1);
    v18 = v27;
    v19 = 1;
    v20 = v8;
  }
LABEL_25:
  -[WiFiPerfPerAssoc associatedStateDidChange:withAssociatedNetworkRecord:withChangeReason:](v18, "associatedStateDidChange:withAssociatedNetworkRecord:withChangeReason:", v19, v20, v17);
LABEL_26:
  if (v8)
    CFRelease(v8);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    sub_10000C120(a3);
  sub_1000FE2A4(a3);
  objc_autoreleasePoolPop(v6);
}

void sub_1000F1850(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v4)(uint64_t, _QWORD);

  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    sub_1000285E4(a3, 0x29uLL);
  v4 = *(void (**)(uint64_t, _QWORD))(a3 + 4872);
  if (v4)
    v4(a3, *(_QWORD *)(a3 + 4880));
}

void sub_1000F18AC(uint64_t a1, const void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5)
{
  _BYTE *v7;
  void *v8;
  int ValueIfPresent;
  void *v10;
  BOOL v11;
  const void *v12;
  int v13;
  int v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const void *v22;
  void *v23;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  void *v27;
  void *v28;
  void *v29;
  const char *v30;
  void *v31;
  void *v32;
  void *value;
  char v34;
  __int16 valuePtr;
  CFRange v36;

  valuePtr = 0;
  v34 = 0;
  v7 = (_BYTE *)(a5 + 5592);
  v32 = 0;
  value = 0;
  v31 = 0;
  v8 = sub_10002A21C(a5, a2, 1);
  ValueIfPresent = CFDictionaryGetValueIfPresent(a3, CFSTR("INTERNET_ACCESS"), (const void **)&value);
  v10 = value;
  if (ValueIfPresent)
    v11 = value == 0;
  else
    v11 = 1;
  if (!v11)
  {
    v12 = *(const void **)(a5 + 5576);
    if (v12)
    {
      if (CFEqual(value, v12))
        goto LABEL_22;
      v10 = value;
    }
    *(_QWORD *)(a5 + 5576) = v10;
    if (v8)
    {
      v13 = sub_1000CA608((uint64_t)v8);
      if ((v13 - 1) > 1)
      {
        v17 = 0;
      }
      else
      {
        v14 = v13;
        if (*(_QWORD *)(a5 + 5576))
        {
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            if (*(const CFBooleanRef *)(a5 + 5576) == kCFBooleanTrue)
              v16 = "SET";
            else
              v16 = "ZERO";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: internetAccess bit %s", "__WiFiDeviceManagerWiFiNetworkIeUpdateCallback", v16);
          }
          objc_autoreleasePoolPop(v15);
        }
        if (v14 == 1)
          v17 = 3;
        else
          v17 = 0;
      }
      sub_1000FE648((uint64_t *)a5, v8, 1, v17);
    }
  }
LABEL_22:
  CFDictionaryGetValueIfPresent(a3, CFSTR("kWiFiHostApWiFiNetworkIeValidKey"), (const void **)&v31);
  if (!v31 || !*(_DWORD *)(a5 + 6804) || !v7[1304])
    goto LABEL_36;
  v18 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("WiFiHostApWiFiNetworkIeSsidKey"));
  if (!v18)
  {
    v28 = objc_autoreleasePoolPush();
    v29 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v30 = "Failed to get Network SSID Info";
      goto LABEL_51;
    }
LABEL_52:
    objc_autoreleasePoolPop(v28);
    goto LABEL_53;
  }
  v19 = v18;
  v20 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("WiFiHostApWiFiNetworkIeFlagKey"));
  if (!v20
    || (CFNumberGetValue(v20, kCFNumberSInt16Type, &valuePtr),
        (v21 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("WiFiHostApWiFiNetworkIeBatteryKey"))) == 0))
  {
    v28 = objc_autoreleasePoolPush();
    v29 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v30 = "Failed to get Network Flag Info";
LABEL_51:
      objc_msgSend(v29, "WFLog:message:", 3, v30);
      goto LABEL_52;
    }
    goto LABEL_52;
  }
  CFNumberGetValue(v21, kCFNumberSInt8Type, &v34);
  v7[1394] = v34;
  *(_WORD *)(a5 + 6984) = valuePtr;
  v22 = *(const void **)(a5 + 6976);
  if (v22)
  {
    CFRelease(v22);
    *(_QWORD *)(a5 + 6976) = 0;
  }
  *(_QWORD *)(a5 + 6976) = sub_1000C323C(v19);
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " Update Personal Hotspot Network IE received. wifi network %@\n", v19);
  objc_autoreleasePoolPop(v23);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if (!*(_DWORD *)(a5 + 3280))
      sub_1000285E4(a5, 0x1CuLL);
  }
  else
  {
    sub_1000F49C8(a5);
  }
LABEL_36:
  if (!*v7
    || !CFDictionaryGetValueIfPresent(a3, CFSTR("DIRECTED_NETWORK"), (const void **)&v32)
    || v32 == kCFBooleanTrue
    || (Count = CFArrayGetCount(*(CFArrayRef *)(a5 + 3536))) == 0
    || !v8)
  {
LABEL_53:
    if (!v8)
      return;
    goto LABEL_54;
  }
  v36.length = Count;
  v36.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a5 + 3536), v36, v8);
  if (FirstIndexOfValue != -1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a5 + 3536), FirstIndexOfValue);
    if (ValueAtIndex)
    {
      if (sub_100031670(ValueAtIndex))
      {
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Correcting directed property for broadcast network %@", sub_10002B088(v8));
        objc_autoreleasePoolPop(v27);
        *v7 = 0;
        sub_1000C4734((uint64_t)v8, 0);
        sub_1001053C8((NSObject **)a5, v8);
      }
    }
  }
LABEL_54:
  CFRelease(v8);
}

void sub_1000F1C60(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  id v7;
  void *v9;
  id v10;

  v10 = 0;
  v7 = *(id *)(a5 + 9072);
  if (v7
    || (v7 = objc_alloc_init((Class)AWDLServiceDiscoveryManager), (*(_QWORD *)(a5 + 9072) = v7) != 0))
  {
    if (a3)
    {
      if ((objc_msgSend(v7, "suspendAWDLWithError:", &v10) & 1) == 0)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SUSPEND AWDL for interface %@ FAILED, returned %ld", a2, objc_msgSend(v10, "code"));
LABEL_11:
        objc_autoreleasePoolPop(v9);
      }
    }
    else if ((objc_msgSend(v7, "resumeAWDLWithError:", &v10) & 1) == 0)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RESUME AWDL for interface %@ FAILED, returned %ld", a2, objc_msgSend(v10, "code"));
      goto LABEL_11;
    }
  }
}

void sub_1000F1D40(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t v8;
  BOOL v9;
  int v10;
  void *v11;
  const char *v12;
  void *v13;
  const void *v14;
  unsigned int v15;
  double Current;
  double v17;
  void *v18;
  void *v19;
  NSString *v20;
  NSString *v21;
  void (*v22)(uint64_t, uint64_t, NSString *, _QWORD);
  NSObject *v23;
  dispatch_time_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *value;

  if (a3)
  {
    value = 0;
    v8 = sub_10013F644((_BYTE *)a3);
    if (sub_100047BF0(*(_QWORD *)(a3 + 120)))
      v9 = 0;
    else
      v9 = v8 == 0;
    v10 = !v9;
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v12 = "FALSE";
      if (v10)
        v12 = "TRUE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DPS: latencySensitiveApps_bitmap:%llu isCriticalAppState:%s", v8, v12);
    }
    objc_autoreleasePoolPop(v11);
    v13 = sub_10002A21C(a3, a2, 1);
    if (v13)
    {
      v14 = v13;
      if (sub_1000CFCA8((uint64_t)v13))
      {
        v15 = 0;
        if (!CFDictionaryGetValueIfPresent(a4, CFSTR("DPS_SYMPTOMS_TRIGGER"), (const void **)&value) || !value)
          goto LABEL_20;
        if (!CFBooleanGetValue((CFBooleanRef)value))
        {
          v15 = 0;
LABEL_20:
          sub_10005D65C(a1, a4, v15, v10);
          Current = CFAbsoluteTimeGetCurrent();
          v17 = *(double *)(a3 + 7096);
          if (v17 == 0.0 || v17 + 120.0 <= Current)
          {
            *(_DWORD *)(a3 + 7232) = v15;
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DPS/DNS Symptoms HUD: starting display");
            objc_autoreleasePoolPop(v18);
            v19 = objc_autoreleasePoolPush();
            if (*(_DWORD *)(a3 + 7232))
            {
              *(_QWORD *)(a3 + 7224) = 0;
              v20 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("DNS Stall: %llus"), 0);
            }
            else
            {
              *(_QWORD *)(a3 + 7224) = 5;
              v20 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Data Stall: %llus"), 5);
            }
            v21 = v20;
            if (!*(_BYTE *)(a3 + 7237))
            {
              *(_BYTE *)(a3 + 7237) = 1;
              if (MGGetBoolAnswer(CFSTR("InternalBuild")))
              {
                v22 = *(void (**)(uint64_t, uint64_t, NSString *, _QWORD))(a3 + 4552);
                if (v22)
                  v22(a3, 18, v21, *(_QWORD *)(a3 + 4560));
              }
              v23 = *(NSObject **)(a3 + 7216);
              v24 = dispatch_time(0, 1000000000);
              dispatch_source_set_timer(v23, v24, 0xFFFFFFFFFFFFFFFFLL, 0);
            }
            objc_autoreleasePoolPop(v19);
            sub_100048084(*(_QWORD *)(a3 + 120), 1);
          }
          sub_1001091D8(a3, 0, 0);
          goto LABEL_34;
        }
        if (!*(_BYTE *)(a3 + 5496))
        {
          v15 = 4;
          goto LABEL_20;
        }
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: DNSSymptoms notification not allowed when Carplay is Active", "__WiFiDeviceManagerHandleDpsEvent", v27);
      }
      else
      {
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network='%@' doesn't support DPS recovery", "__WiFiDeviceManagerHandleDpsEvent", v14);
      }
      objc_autoreleasePoolPop(v26);
LABEL_34:
      CFRelease(v14);
      return;
    }
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, curNetwork is NULL", "__WiFiDeviceManagerHandleDpsEvent");
    objc_autoreleasePoolPop(v25);
  }
}

void sub_1000F2054(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  void *v7;
  double Current;
  double v9;
  const void *Value;
  const void *v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  void *v14;
  void *v15;
  void *v16;
  const void *v17;
  void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  _WORD *v23;
  id v24;
  _BOOL4 v25;
  void *v26;
  id v27;
  void *v28;
  _BYTE *v29;
  int v30;
  void *v31;
  void *v32;
  void *v33;
  NSString *v34;
  NSString *v35;
  void (*v36)(uint64_t, uint64_t, NSString *, _QWORD);
  NSObject *v37;
  dispatch_time_t v38;
  void *v39;
  void *v40;
  uint64_t valuePtr;

  v7 = objc_autoreleasePoolPush();
  valuePtr = 0;
  Current = CFAbsoluteTimeGetCurrent();
  if (!a3)
  {
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Device Manager is NULL", "__WiFiDeviceManagerHandleSlowWiFiEvent");
    goto LABEL_65;
  }
  if (!a2)
  {
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Device IfName is NULL", "__WiFiDeviceManagerHandleSlowWiFiEvent");
    goto LABEL_65;
  }
  v9 = Current;
  Value = CFDictionaryGetValue(a4, CFSTR("SLOWWIFI_IS_BAP_AP"));
  if (!Value)
  {
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, isBadAP key not found", "__WiFiDeviceManagerHandleSlowWiFiEvent");
    goto LABEL_65;
  }
  v11 = Value;
  v12 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("SLOWWIFI_ACTION_REASON"));
  CFNumberGetValue(v12, kCFNumberIntType, (char *)&valuePtr + 4);
  v13 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("SLOWWIFI_ACTION_STAGE"));
  CFNumberGetValue(v13, kCFNumberIntType, &valuePtr);
  if (!CFEqual(v11, kCFBooleanFalse))
  {
    v16 = *(void **)(a3 + 7368);
    if (v16)
      objc_msgSend(v16, "addFaultEvent:forInterface:", 10, sub_100025C3C(*(_QWORD *)(a3 + 64)));
    v17 = CFDictionaryGetValue(a4, CFSTR("SLOWWIFI_RECOVERY_ENABLED"));
    if (v17)
    {
      if (CFEqual(v17, kCFBooleanTrue))
      {
        if (v12)
        {
          v18 = sub_10002A21C(a3, a2, 1);
          if (v18)
          {
            v15 = v18;
            v19 = sub_10002BE64((uint64_t)v18, CFSTR("BSSID"));
            if (v19)
            {
              v20 = v19;
              v21 = CFDictionaryGetValue(a4, CFSTR("SLOWWIFI_BSSID"));
              if (v21)
              {
                v22 = (uint64_t)v21;
                if (CFEqual(v20, v21))
                {
                  v23 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v15);
                  v24 = sub_100027D10((uint64_t)v23);
                  v25 = sub_1000CFCA8((uint64_t)v23);
                  v26 = objc_autoreleasePoolPush();
                  if (v25)
                  {
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SlowWiFi detection blacklisted BSSID:%@", "__WiFiDeviceManagerHandleSlowWiFiEvent", v22);
                    objc_autoreleasePoolPop(v26);
                    v27 = sub_1000FCB38(a3, 8, SHIDWORD(valuePtr), v22, 2);
                    objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v27, v24);
                    objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v27, v24);
                    objc_msgSend(*(id *)(a3 + 6648), "setNetworkDenyListInfo:forScanResult:", v27, v24);

                    if (!v23)
                      goto LABEL_23;
                  }
                  else
                  {
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, 1, "%s, network does not support slow wifi recovery", "__WiFiDeviceManagerHandleSlowWiFiEvent");
                    objc_autoreleasePoolPop(v26);
                    if (!v23)
                      goto LABEL_23;
                  }
                  CFRelease(v23);
LABEL_23:

                  goto LABEL_24;
                }
                v40 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, event BSSID not equal to current BSSID", "__WiFiDeviceManagerHandleSlowWiFiEvent");
              }
              else
              {
                v40 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, event BSSID is NULL", "__WiFiDeviceManagerHandleSlowWiFiEvent");
              }
            }
            else
            {
              v40 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, current BSSID is NULL", "__WiFiDeviceManagerHandleSlowWiFiEvent");
            }
            objc_autoreleasePoolPop(v40);
            goto LABEL_34;
          }
          v39 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, curNetwork is NULL", "__WiFiDeviceManagerHandleSlowWiFiEvent");
        }
        else
        {
          v39 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SlowWiFi reason not found", "__WiFiDeviceManagerHandleSlowWiFiEvent");
        }
      }
      else
      {
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, SlowWiFi recovery not enabled", "__WiFiDeviceManagerHandleSlowWiFiEvent");
      }
    }
    else
    {
      v39 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, isRecoveryEnabled key not found", "__WiFiDeviceManagerHandleSlowWiFiEvent");
    }
LABEL_65:
    objc_autoreleasePoolPop(v39);
    goto LABEL_35;
  }
  v14 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, SlowWiFiEvent not due to AP", "__WiFiDeviceManagerHandleSlowWiFiEvent");
  objc_autoreleasePoolPop(v14);
  v15 = *(void **)(a3 + 7368);
  if (v15)
  {
    objc_msgSend(v15, "addFaultEvent:forInterface:", 19, sub_100025C3C(*(_QWORD *)(a3 + 64)));
    v15 = 0;
  }
LABEL_24:
  v28 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SlowWiFi: stage:%d reason:%d", valuePtr, HIDWORD(valuePtr));
  objc_autoreleasePoolPop(v28);
  if ((int)valuePtr >= 2 && SHIDWORD(valuePtr) <= 14 && HIDWORD(valuePtr) != 13)
  {
    v29 = (_BYTE *)(a3 + 7288);
    v30 = *(unsigned __int8 *)(a3 + 7288);
    v31 = objc_autoreleasePoolPush();
    if (!v30)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SlowWiFiHUD: action:%d reason:%d HUD_update:start", valuePtr, HIDWORD(valuePtr));
      objc_autoreleasePoolPop(v31);
      *(double *)(a3 + 7248) = v9;
      *(_QWORD *)(a3 + 7280) = valuePtr;
      *(_QWORD *)(a3 + 7272) = 35;
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SlowWiFi HUD: starting display");
      objc_autoreleasePoolPop(v32);
      v33 = objc_autoreleasePoolPush();
      *(_QWORD *)(a3 + 7224) = 0;
      v34 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Slow WiFi: %llus"), *(_QWORD *)(a3 + 7264));
      if (!*v29)
      {
        v35 = v34;
        *v29 = 1;
        if (MGGetBoolAnswer(CFSTR("InternalBuild")))
        {
          v36 = *(void (**)(uint64_t, uint64_t, NSString *, _QWORD))(a3 + 4552);
          if (v36)
            v36(a3, 17, v35, *(_QWORD *)(a3 + 4560));
        }
        v37 = *(NSObject **)(a3 + 7256);
        v38 = dispatch_time(0, 1000000000);
        dispatch_source_set_timer(v37, v38, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
      objc_autoreleasePoolPop(v33);
      if (v15)
        goto LABEL_34;
      goto LABEL_35;
    }
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SlowWiFiHUD: previous_stage:%d current_stage:%d previous_reason:%d current_reason:%d remaining_display_duration:%lld current_HUD_update:increment timeSinceFirstNotification:%lld", *(unsigned int *)(a3 + 7280), valuePtr, *(unsigned int *)(a3 + 7284), HIDWORD(valuePtr), *(_QWORD *)(a3 + 7272), (uint64_t)(v9 - *(double *)(a3 + 7248)));
    objc_autoreleasePoolPop(v31);
    *(_QWORD *)(a3 + 7272) = 35;
  }
  if (v15)
LABEL_34:
    CFRelease(v15);
LABEL_35:
  objc_autoreleasePoolPop(v7);
}

void sub_1000F26C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10013B264(a3, -1);
}

void sub_1000F26D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, uint64_t, _QWORD);

  if (a3 && (v3 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a3 + 4552)) != 0)
    v3(a3, 16, a2, *(_QWORD *)(a3 + 4560));
  else
    sub_10011BC48(a3, -1);
}

void sub_1000F26FC(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  void *v8;
  id v9;
  id v10;
  void *v11;
  const void *v12;
  const void *v13;
  NSString *v14;
  id v15;
  const void *v16;
  void *v17;
  void *v18;

  v8 = objc_autoreleasePoolPush();
  if (!a3)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL", "__WiFiDeviceManagerHandleBssPrunedEvent");
    goto LABEL_22;
  }
  if (!a4)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s dict is NULL", "__WiFiDeviceManagerHandleBssPrunedEvent");
    goto LABEL_22;
  }
  if (!sub_100075280(a1))
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Pruned event received when BssBlacklisting is not supported! Bailing", "__WiFiDeviceManagerHandleBssPrunedEvent");
    goto LABEL_22;
  }
  v9 = objc_msgSend(a4, "objectForKey:", CFSTR("PRUNEEVENT_REASON"));
  v10 = objc_msgSend(a4, "objectForKey:", CFSTR("BSSID"));
  if (!v10)
    goto LABEL_13;
  if (!v9)
    goto LABEL_13;
  v11 = v10;
  if (objc_msgSend(v9, "intValue") != -528337897)
    goto LABEL_13;
  v12 = sub_10002BF8C(a1, a2);
  if (!v12)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Current network is NULL. Not handling the BSS pruned event", "__WiFiDeviceManagerHandleBssPrunedEvent");
LABEL_22:
    objc_autoreleasePoolPop(v17);
    goto LABEL_13;
  }
  v13 = v12;
  v14 = (NSString *)ether_ntoa((const ether_addr *)objc_msgSend(v11, "bytes"));
  if (v14)
    v14 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14);
  sub_10002C478((uint64_t)v13, CFSTR("BSSID"), v14);
  v15 = sub_100027D10((uint64_t)v13);
  if (v15)
  {
    v16 = v15;
    objc_msgSend(*(id *)(a3 + 6648), "processDenyListedBSSForMetrics:", v15);
    CFRelease(v16);
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Current network is NULL. Not handling the BSS pruned event", "__WiFiDeviceManagerHandleBssPrunedEvent");
    objc_autoreleasePoolPop(v18);
  }
  CFRelease(v13);
LABEL_13:
  objc_autoreleasePoolPop(v8);
}

void sub_1000F2928(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v6;
  void *v7;
  void *v8;

  if (!a3)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL", "__WiFiDeviceManagerHandleTrafficInfoEvent");
    v8 = v7;
    goto LABEL_12;
  }
  v6 = objc_autoreleasePoolPush();
  if (!a4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s dict is NULL", "__WiFiDeviceManagerHandleTrafficInfoEvent");
    v8 = v6;
LABEL_12:
    objc_autoreleasePoolPop(v8);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Traffic Info Event Dictionary %@", a4);
  objc_autoreleasePoolPop(v6);
  sub_100049D30(*(_QWORD *)(a3 + 120), objc_msgSend(objc_msgSend(a4, "objectForKey:", CFSTR("CRITICAL_TRAFFIC_STATE")), "intValue") | (objc_msgSend(objc_msgSend(a4, "objectForKey:", CFSTR("NON_CRITICAL_TRAFFIC_STATE")), "intValue") << 8));
}

uint64_t sub_1000F2A54(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t (*v8)(uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t);

  result = a3[507];
  if (result)
  {
    v8 = (uint64_t (*)(uint64_t *, uint64_t, uint64_t, _QWORD, uint64_t))a3[507];
    v7 = sub_100025C3C(a3[8]);
    return v8(a3, v7, a4, 0, a3[508]);
  }
  return result;
}

void sub_1000F2AB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v4;
  const __CFString *v5;
  CFIndex Length;
  BOOL v7;
  _BOOL8 v8;
  void *v9;
  void *v10;
  void *v11;

  if (a3)
  {
    v4 = (unsigned __int8 *)(a3 + 5216);
    v5 = *(const __CFString **)(a3 + 7352);
    if (v5)
    {
      Length = CFStringGetLength(v5);
      v7 = Length == 0;
      v8 = Length != 0;
    }
    else
    {
      v8 = 0;
      v7 = 1;
    }
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: countryCodeDidBecomeAvailable=%d __WiFiDeviceManagerGetMISGlobalState=%d manager->mis.misEnabled=%d manager->softapUserPreferredBand=%d manager->mis.misChannel=%d", "__WiFiDeviceManagerProcessSupportedChannelInfoChangedEvent", v8, sub_1001076C4(a3), v4[3], *(unsigned int *)(a3 + 7048), *v4);
    objc_autoreleasePoolPop(v9);
    if (!v7 && sub_1001076C4(a3) && v4[3] && *(_DWORD *)(a3 + 7048) != 1 && *v4 <= 0xEu)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: country code changed to %@ while SoftAP hotspot is in 2.4GHz. Restarting to select new channel...", "__WiFiDeviceManagerProcessSupportedChannelInfoChangedEvent", *(_QWORD *)(a3 + 7352));
      objc_autoreleasePoolPop(v10);
      sub_100103E6C(a3, 1);
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiDeviceManagerProcessSupportedChannelInfoChangedEvent");
    objc_autoreleasePoolPop(v11);
  }
}

uint64_t sub_1000F2C64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4824);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4048));
  }
  return result;
}

uint64_t sub_1000F2C84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a4)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 4856);
    if (v4)
      return v4(a4, a2, a3, *(_QWORD *)(a4 + 4048));
  }
  return result;
}

void sub_1000F2CA4(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    *(_QWORD *)(a4 + 3817) = 0;
    *(_OWORD *)(a4 + 3788) = 0u;
    *(_OWORD *)(a4 + 3804) = 0u;
    if (a3)
    {
      v4 = *a3;
      v5 = a3[1];
      *(_QWORD *)(a4 + 3817) = *(_QWORD *)((char *)a3 + 29);
      *(_OWORD *)(a4 + 3788) = v4;
      *(_OWORD *)(a4 + 3804) = v5;
    }
    sub_1000FE2A4(a4);
  }
}

uint64_t sub_1000F2CD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;

  if (a6)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a6 + 4920))(a6, a2, a3, a4, a5, *(_QWORD *)(a6 + 4928));
  return result;
}

void sub_1000F2CF4(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, CFTypeRef *a5)
{
  const __CFArray *v7;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  CFIndex v10;
  void *ValueAtIndex;
  const void *v12;
  const void *v13;
  void *v14;
  const void *v15;
  CFIndex v16;
  void *v17;
  void *v18;
  int v19;
  void *v20;
  void *v21;
  const void *v22;
  const void *v23;
  void *v24;
  CFRange v25;

  if (!a3)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback");
    goto LABEL_32;
  }
  if (!a4)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: inNetwork is NULL!", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback");
    goto LABEL_32;
  }
  if (!a5)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: outAccount is NULL!", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback");
LABEL_32:
    objc_autoreleasePoolPop(v24);
    return;
  }
  *a5 = 0;
  v7 = *(const __CFArray **)(a3 + 3624);
  if (v7)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3624));
    v25.location = 0;
    v25.length = Count;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v7, v25, a4);
    if (FirstIndexOfValue != -1)
    {
      v10 = FirstIndexOfValue;
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(v7, FirstIndexOfValue);
      v12 = sub_10002BE64((uint64_t)a4, CFSTR("HS20AccountName"));
      v13 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("HS20AccountName"));
      if (!v12 && v13 && sub_1000C66D0(ValueAtIndex))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: immediately matched HS2.0 account %@, returning %@", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", sub_10002B088(ValueAtIndex), ValueAtIndex);
        objc_autoreleasePoolPop(v14);
        v15 = ValueAtIndex;
        goto LABEL_24;
      }
      v16 = v10 + 1;
      if (v10 + 1 < Count)
      {
        do
        {
          v17 = (void *)CFArrayGetValueAtIndex(v7, v16);
          if (v17)
          {
            v18 = v17;
            if (sub_1000C5FEC((uint64_t)a4, (uint64_t)v17))
            {
              v19 = sub_1000C66D0(v18);
              v20 = objc_autoreleasePoolPush();
              v21 = (void *)qword_10026DD20;
              if (v19)
              {
                if (qword_10026DD20)
                {
                  v23 = sub_10002B088(v18);
                  objc_msgSend(v21, "WFLog:message:", 3, "%s: found HS2.0 account %@ matching %@, returning %@", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", v23, sub_10002B088(a4), v18);
                }
                objc_autoreleasePoolPop(v20);
                v15 = v18;
LABEL_24:
                *a5 = CFRetain(v15);
                return;
              }
              if (qword_10026DD20)
              {
                v22 = sub_10002B088(v18);
                objc_msgSend(v21, "WFLog:message:", 3, "%s: next HS2.0 account %@ matching %@ has no credentials, skipping", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", v22, sub_10002B088(a4));
              }
              objc_autoreleasePoolPop(v20);
            }
          }
          ++v16;
        }
        while (Count != v16);
      }
    }
  }
}

void sub_1000F2FCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  void *v8;
  const __CFNumber *Value;
  const __CFNumber *v10;
  void *v11;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  CFDataRef v14;
  CFDataRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  UInt8 bytes[4];
  __int16 v25;
  int v26;
  unsigned __int8 valuePtr;

  valuePtr = 0;
  if (a2)
  {
    v8 = objc_autoreleasePoolPush();
    if (a5)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Notification %@ received", "__WiFiDeviceManagerRoamNotificationCallback", a3);
      objc_autoreleasePoolPop(v8);
      Value = (const __CFNumber *)CFDictionaryGetValue(a5, CFSTR("com.apple.wifid.wifiroammangerroamtype"));
      v8 = objc_autoreleasePoolPush();
      if (Value)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kWiFiRoamManagerRoamTypeKey value is %@", "__WiFiDeviceManagerRoamNotificationCallback", Value);
        v26 = -1431655766;
        objc_autoreleasePoolPop(v8);
        CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
        v10 = (const __CFNumber *)CFDictionaryGetValue(a5, CFSTR("com.apple.wifid.wifiroammangerroamreason"));
        v11 = objc_autoreleasePoolPush();
        if (v10)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kWiFiRoamManagerRoamReasonKey value is %@", "__WiFiDeviceManagerRoamNotificationCallback", v10);
          objc_autoreleasePoolPop(v11);
          CFNumberGetValue(v10, kCFNumberIntType, &v26);
          if (valuePtr >= 3u)
          {
            v19 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid band preference", "__WiFiDeviceManagerRoamNotificationCallback");
          }
          else
          {
            Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              v13 = Mutable;
              v25 = -1;
              *(_DWORD *)bytes = -1;
              v14 = CFDataCreate(kCFAllocatorDefault, bytes, 6);
              if (v14)
              {
                v15 = v14;
                CFDictionaryAddValue(v13, CFSTR("BSSID"), v14);
                v16 = CFNumberCreate(0, kCFNumberCharType, &valuePtr);
                if (v16)
                {
                  v17 = v16;
                  CFDictionaryAddValue(v13, CFSTR("BAND_PREFERENCE"), v16);
                  CFRelease(v17);
                  v18 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:calling DeviceSetRoam with :%@", "__WiFiDeviceManagerRoamNotificationCallback", v13);
                  objc_autoreleasePoolPop(v18);
                  sub_1000772B0(*(_QWORD *)(a2 + 64), (uint64_t)v13);
                }
                else
                {
                  v23 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numRef is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
                  objc_autoreleasePoolPop(v23);
                }
                CFRelease(v15);
              }
              else
              {
                v22 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bssidDataRef is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
                objc_autoreleasePoolPop(v22);
              }
              CFRelease(v13);
              return;
            }
            v19 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bssidInfo is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
          }
          v20 = v19;
        }
        else
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numRef for kWiFiRoamManagerRoamReason is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
          v20 = v11;
        }
        objc_autoreleasePoolPop(v20);
        return;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numRef for kWiFiRoamManagerRoamType is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: userInfo is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
    }
    objc_autoreleasePoolPop(v8);
    return;
  }
  v21 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "__WiFiDeviceManagerRoamNotificationCallback");
  objc_autoreleasePoolPop(v21);
}

void sub_1000F3354(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  void *v5;

  if (a3)
  {
    sub_100103F64(a3, a4, a5);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiDeviceManagerConfigureForXCTests");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000F33C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;

  if (a4)
  {
    v4 = *(void **)(a4 + 7368);
    if (v4)
      objc_msgSend(v4, "updateScanForwardStats:");
  }
}

void sub_1000F33D4(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (a2)
  {
    sub_1000EE3F4(a2, CFSTR("TriggerWatchdog"));
    *(_BYTE *)(a2 + 3497) = 1;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "__WiFiDeviceManagerChipResetRequestedCallback");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000F345C(uint64_t a1)
{
  unsigned __int8 *v2;
  char v3;
  char v4;
  uint64_t v5;
  const __CFSet *v6;
  const __CFSet *v7;
  void *v8;
  unsigned __int8 v9;
  void *v10;
  const char *v11;
  const char *v12;
  const __CFSet *v13;
  const __CFSet *v14;
  const __CFSet *v15;
  _BOOL8 v16;
  void *v17;
  void *v18;
  BOOL v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  if (a1)
  {
    v2 = (unsigned __int8 *)(a1 + 5217);
    v3 = *(_BYTE *)(a1 + 5217);
    v4 = *(_BYTE *)(a1 + 5218);
    v5 = *(unsigned __int8 *)(a1 + 5221);
    if (*(_DWORD *)(a1 + 5232) == 5)
    {
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 5272), CFSTR("wifid"));
      sub_100107DE4(a1, 0);
      v6 = *(const __CFSet **)(a1 + 5272);
      if (!v6 || !CFSetGetCount(v6))
      {
        v7 = *(const __CFSet **)(a1 + 5280);
        if (!v7 || !CFSetGetCount(v7))
        {
          v8 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No Discovery Client");
          objc_autoreleasePoolPop(v8);
          v5 = 0;
          v2[4] = 0;
        }
      }
    }
    if (*(_QWORD *)(a1 + 4136))
    {
      sub_100107DE4(a1, 0);
      (*(void (**)(uint64_t, _QWORD, uint64_t))(a1 + 4136))(a1, *(_QWORD *)(a1 + 4144), v5);
    }
    v9 = v4 + v3;
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v11 = "Enabled";
      if (v2[2])
        v12 = "Enabled";
      else
        v12 = "Disabled";
      if (!(_DWORD)v5)
        v11 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS idle timer expired. MIS is %s, associated clients = %d, nan associated clients = %d, discovery is %s", v12, v9, v2[1], v11);
    }
    objc_autoreleasePoolPop(v10);
    v16 = (~v2[1840] & 5) == 0
       && ((v13 = *(const __CFSet **)(a1 + 5288)) == 0 || !CFSetGetCount(v13))
       && ((v14 = *(const __CFSet **)(a1 + 5304)) == 0 || !CFSetGetCount(v14))
       && ((v15 = *(const __CFSet **)(a1 + 5312)) == 0 || !CFSetGetCount(v15))
       && *(_DWORD *)(a1 + 5232) == 4;
    if (v2[5])
      goto LABEL_28;
    if (!v2[2])
      goto LABEL_51;
    v19 = !v16;
    if (!v9)
      v19 = 0;
    if (!v19 && !(_DWORD)v5)
    {
LABEL_28:
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS idle timer expired (inRecovery: %d) (Concurrent Mode: %d), disabling tethering", v2[5], v16);
      objc_autoreleasePoolPop(v17);
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      DWORD2(v21) = 2;
      if (objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted"))
      {
        LODWORD(v28) = 2;
        *((_QWORD *)&v28 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Idle Timer expired"));
        *((_QWORD *)&v29 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("User request"));
        *((_QWORD *)&v27 + 1) = sub_100064914();
      }
      sub_100106C34(a1, (uint64_t)&v21);
      sub_100107084(a1);
    }
    else
    {
LABEL_51:
      if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS") && v2[2] && !v2[1])
      {
        v20 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "NANPHS: stopping NAN Publisher after idle time expired \n");
        objc_autoreleasePoolPop(v20);
        objc_msgSend(*(id *)(a1 + 6752), "stopPublisherForPHSOverNAN");
        v2[169] = 0;
        sub_1000F9DAC((char *)a1, 8, 0);
        v31 = 0;
        v29 = 0u;
        v30 = 0u;
        *(_QWORD *)&v27 = 0;
        *(_QWORD *)&v28 = 8;
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        *((_QWORD *)&v28 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("All Nan Clients Left"));
        *((_QWORD *)&v27 + 1) = sub_100064914();
        sub_100106C34(a1, (uint64_t)&v21);
      }
    }
    *(_DWORD *)(a1 + 5232) = 0;
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "__WiFiDeviceManagerMISIdleTimerCallback");
    objc_autoreleasePoolPop(v18);
  }
}

void sub_1000F3828(uint64_t a1)
{
  NSObject *v2;
  CFAbsoluteTime Current;
  dispatch_time_t v4;
  void *v5;

  v2 = *(NSObject **)(a1 + 5320);
  Current = CFAbsoluteTimeGetCurrent();
  v4 = dispatch_time(0, (uint64_t)((Current + 315360000.0) * 1000000000.0));
  dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Timer Expired\n", "__WiFiDeviceManagerBroadcastToHiddenTimerCallback");
  objc_autoreleasePoolPop(v5);
  sub_1001080EC(a1);
}

void sub_1000F38CC(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timeout - resetting critical phase state", "__WiFiDeviceManagerPriorityLinkSetupPhaseTimerCallback");
  objc_autoreleasePoolPop(v2);
  *(_BYTE *)(a1 + 5504) = 0;
}

void sub_1000F3934(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timeout - calling __WiFiDeviceManagerEvaluate24GHzInfraNetworkState", "__WiFiDeviceManager24GHzInfraNetworkCriticalTimerCallback");
  objc_autoreleasePoolPop(v2);
  sub_1000FA884(a1, 0);
  *(_BYTE *)(a1 + 8600) = 0;
}

uint64_t sub_1000F39A8(uint64_t a1)
{
  void *v2;
  uint64_t result;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay HID session timed out", "__WiFiDeviceManagerCarPlayHidSessionTimerCallback");
  objc_autoreleasePoolPop(v2);
  result = sub_100074ED8(*(_QWORD *)(a1 + 64), 1);
  *(_BYTE *)(a1 + 8640) = 0;
  return result;
}

void sub_1000F3A1C(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  const void *v4;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timed out", "__WiFiDeviceManagerCarPlayLinkDownMonitorTimerCallback");
  objc_autoreleasePoolPop(v2);
  v3 = *(_QWORD *)(a1 + 976);
  if (v3)
  {
    sub_10012634C(a1, v3, 1021, 0);
    v4 = *(const void **)(a1 + 976);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 976) = 0;
    }
  }
}

void sub_1000F3AA4(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  const __CFString *v5;
  uint64_t v6;
  id v7;
  void *v8;
  NSRegularExpression *v9;
  uint64_t v10;
  NSArray *v11;
  id v12;
  id v13;
  char v14;
  uint64_t v15;
  void *i;
  id v17;
  uint64_t v18;
  const char *v19;
  void *v20;
  NSRegularExpression *v21;
  NSArray *v22;
  id v23;
  id v24;
  uint64_t v25;
  void *j;
  id v27;
  uint64_t v28;
  uint64_t v29;
  NSArray *v30;
  id v31;
  id v32;
  uint64_t v33;
  void *k;
  id v35;
  uint64_t v36;
  NSRegularExpression *v37;
  NSRegularExpression *v38;
  NSArray *v39;
  id v40;
  id v41;
  uint64_t v42;
  void *m;
  uint64_t v44;
  void *v45;
  id v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _BYTE v75[128];
  _BYTE v76[128];
  _BYTE v77[128];
  _BYTE v78[128];
  __int128 v79;

  v79 = 0uLL;
  v2 = malloc_type_malloc(0x400uLL, 0xA56F5793uLL);
  if (v2)
  {
    v3 = v2;
    v4 = *(_QWORD *)(a1 + 64);
    v5 = (const __CFString *)sub_100025C3C(v4);
    v6 = sub_100069B44(v4, v5, "dump", "lpc", 0, v3, 0x400u);
    if (!(_DWORD)v6)
    {
      v3[1023] = 0;
      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithCString:encoding:", v3, 4);
      if (!v7)
      {
        v20 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to alloc string", "__WiFiDeviceManagerGetLPCStats", v52, v53, v54, v55, v56, v57, v58);
        goto LABEL_19;
      }
      v8 = v7;
      v9 = +[NSRegularExpression regularExpressionWithPattern:options:error:](NSRegularExpression, "regularExpressionWithPattern:options:error:", CFSTR("valid (\\d)"), 0, 0);
      v10 = 0;
      if (v9)
      {
        v11 = -[NSRegularExpression matchesInString:options:range:](v9, "matchesInString:options:range:", v8, 0, 0, objc_msgSend(v8, "length"));
        v71 = 0u;
        v72 = 0u;
        v73 = 0u;
        v74 = 0u;
        v12 = -[NSArray countByEnumeratingWithState:objects:count:](v11, "countByEnumeratingWithState:objects:count:", &v71, v78, 16);
        if (v12)
        {
          v13 = v12;
          v14 = 0;
          v15 = *(_QWORD *)v72;
          do
          {
            for (i = 0; i != v13; i = (char *)i + 1)
            {
              if (*(_QWORD *)v72 != v15)
                objc_enumerationMutation(v11);
              v17 = objc_msgSend(*(id *)(*((_QWORD *)&v71 + 1) + 8 * (_QWORD)i), "rangeAtIndex:", 1);
              if (objc_msgSend(objc_msgSend(v8, "substringWithRange:", v17, v18), "isEqualToString:", CFSTR("1")))v14 = 1;
            }
            v13 = -[NSArray countByEnumeratingWithState:objects:count:](v11, "countByEnumeratingWithState:objects:count:", &v71, v78, 16);
          }
          while (v13);
          if ((v14 & 1) != 0)
          {
            v21 = +[NSRegularExpression regularExpressionWithPattern:options:error:](NSRegularExpression, "regularExpressionWithPattern:options:error:", CFSTR("min_offset -(\\d+.\\d)dB"), 0, 0);
            v10 = 0;
            if (v21)
            {
              v22 = -[NSRegularExpression matchesInString:options:range:](v21, "matchesInString:options:range:", v8, 0, 0, objc_msgSend(v8, "length"));
              v67 = 0u;
              v68 = 0u;
              v69 = 0u;
              v70 = 0u;
              v23 = -[NSArray countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v67, v77, 16);
              if (v23)
              {
                v24 = v23;
                v25 = *(_QWORD *)v68;
                do
                {
                  for (j = 0; j != v24; j = (char *)j + 1)
                  {
                    if (*(_QWORD *)v68 != v25)
                      objc_enumerationMutation(v22);
                    v27 = objc_msgSend(*(id *)(*((_QWORD *)&v67 + 1) + 8 * (_QWORD)j), "rangeAtIndex:", 1);
                    objc_msgSend(objc_msgSend(v8, "substringWithRange:", v27, v28), "doubleValue");
                  }
                  v10 = v29;
                  v24 = -[NSArray countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v67, v77, 16);
                }
                while (v24);
              }
            }
            v9 = +[NSRegularExpression regularExpressionWithPattern:options:error:](NSRegularExpression, "regularExpressionWithPattern:options:error:", CFSTR("Rates\\W+TX\\s+:(\\s+\\d+\\(\\d+%\\)){3}\\s+(\\d+)\\(\\d+%\\)"), 0, 0);
            if (v9)
            {
              v30 = -[NSRegularExpression matchesInString:options:range:](v9, "matchesInString:options:range:", v8, 0, 0, objc_msgSend(v8, "length"));
              v63 = 0u;
              v64 = 0u;
              v65 = 0u;
              v66 = 0u;
              v31 = -[NSArray countByEnumeratingWithState:objects:count:](v30, "countByEnumeratingWithState:objects:count:", &v63, v76, 16);
              if (v31)
              {
                v32 = v31;
                v33 = *(_QWORD *)v64;
                do
                {
                  for (k = 0; k != v32; k = (char *)k + 1)
                  {
                    if (*(_QWORD *)v64 != v33)
                      objc_enumerationMutation(v30);
                    v35 = objc_msgSend(*(id *)(*((_QWORD *)&v63 + 1) + 8 * (_QWORD)k), "rangeAtIndex:", 2);
                    v37 = (NSRegularExpression *)objc_msgSend(objc_msgSend(v8, "substringWithRange:", v35, v36), "longLongValue");
                  }
                  v9 = v37;
                  v32 = -[NSArray countByEnumeratingWithState:objects:count:](v30, "countByEnumeratingWithState:objects:count:", &v63, v76, 16);
                }
                while (v32);
              }
              else
              {
                v9 = 0;
              }
            }
            v38 = +[NSRegularExpression regularExpressionWithPattern:options:error:](NSRegularExpression, "regularExpressionWithPattern:options:error:", CFSTR("Offsets\\W+TX\\s+:\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)"), 0, 0);
            if (v38)
            {
              v39 = -[NSRegularExpression matchesInString:options:range:](v38, "matchesInString:options:range:", v8, 0, 0, objc_msgSend(v8, "length"));
              v59 = 0u;
              v60 = 0u;
              v61 = 0u;
              v62 = 0u;
              v40 = -[NSArray countByEnumeratingWithState:objects:count:](v39, "countByEnumeratingWithState:objects:count:", &v59, v75, 16);
              if (v40)
              {
                v41 = v40;
                v42 = *(_QWORD *)v60;
                do
                {
                  for (m = 0; m != v41; m = (char *)m + 1)
                  {
                    if (*(_QWORD *)v60 != v42)
                      objc_enumerationMutation(v39);
                    v44 = 0;
                    v45 = *(void **)(*((_QWORD *)&v59 + 1) + 8 * (_QWORD)m);
                    do
                    {
                      v46 = objc_msgSend(v45, "rangeAtIndex:", v44 + 1);
                      *((_DWORD *)&v79 + v44++) = objc_msgSend(objc_msgSend(v8, "substringWithRange:", v46, v47), "integerValue");
                    }
                    while (v44 != 4);
                  }
                  v41 = -[NSArray countByEnumeratingWithState:objects:count:](v39, "countByEnumeratingWithState:objects:count:", &v59, v75, 16);
                }
                while (v41);
              }
            }
            *(_BYTE *)(a1 + 1008) = 1;
            *(_QWORD *)(a1 + 1016) = v10;
            *(_OWORD *)(a1 + 1024) = v79;
            *(_QWORD *)(a1 + 1040) = v9;
            v19 = "yes";
            goto LABEL_17;
          }
        }
        v9 = 0;
      }
      v19 = "no";
LABEL_17:
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: is LPC valid ? %s, min_offset -%.1f dB, topMcsTxCount %llu (AMPDU), txOffset %d:%d:%d:%d (%%)", "__WiFiDeviceManagerGetLPCStats", v19, v10, v9, v79, DWORD1(v79), DWORD2(v79), HIDWORD(v79));
LABEL_19:
      objc_autoreleasePoolPop(v20);
      free(v3);
      return;
    }
    v49 = v6;
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get LPC stats", "__WiFiDeviceManagerGetLPCStats");
    objc_autoreleasePoolPop(v50);
    free(v3);
  }
  else
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to alloc buf", "__WiFiDeviceManagerGetLPCStats");
    objc_autoreleasePoolPop(v48);
    v49 = 4294963395;
  }
  v51 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error %d", "__WiFiDeviceManagerGetLPCStats", v49);
  objc_autoreleasePoolPop(v51);
}

void sub_1000F4118(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Assoc timeout timer fired, triggering CoreCapture", "__WiFiDeviceManagerAssocStateTimerCallback");
  objc_autoreleasePoolPop(v2);
  sub_10011843C(a1);
}

void sub_1000F417C(uint64_t a1)
{
  int v2;
  void *v3;
  NSString *v4;
  uint64_t v5;
  uint8_t buf[4];
  const char *v7;

  v2 = *(_DWORD *)(a1 + 3280);
  v3 = objc_autoreleasePoolPush();
  if (v2 == 16)
  {
    if (qword_10026DD20)
    {
      v4 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Scanning for Hotspot Devices Timeout"))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v7 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v4, "UTF8String")), "UTF8String");
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v3);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v5 = *(_QWORD *)(a1 + 8864);
      if (v5)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD))(v5 + 16))(v5, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 60, 0), 0);
        _Block_release(*(const void **)(a1 + 8864));
        *(_QWORD *)(a1 + 8864) = 0;
      }
    }
    if (*(_DWORD *)(a1 + 3280) == 16)
      sub_1000F48F0(a1, 0);
    *(_DWORD *)(a1 + 3280) = sub_1000078D0(a1);
    *(_QWORD *)(a1 + 6872) = 0;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Scanning Hotspot Device timeout in state %@.", "__WiFiDeviceManagerScanHotspotDeviceTimeoutCallback", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
    objc_autoreleasePoolPop(v3);
  }
}

CFAbsoluteTime sub_1000F43A8(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  const void *v5;
  void *v6;
  const void *v7;
  NSObject *v8;
  dispatch_time_t v9;
  CFAbsoluteTime result;
  NSObject *v11;
  dispatch_time_t v12;

  v2 = *(_QWORD *)(a1 + 64);
  v3 = (const void *)sub_100025C3C(v2);
  v4 = sub_10002BF8C(v2, v3);
  if (v4)
  {
    v5 = v4;
    if (sub_10001395C((uint64_t)v4))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device in Lock state over an %d minutes. Disconnect from Hotspot!!", "__WiFiDeviceManagerAutoHotspotLockStateTimeoutCallback", 60);
      objc_autoreleasePoolPop(v6);
      v7 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      sub_1000F7F48(a1, v7, 1019, "__WiFiDeviceManagerAutoHotspotLockStateTimeoutCallback", 36523);
    }
    v8 = *(NSObject **)(a1 + 6816);
    v9 = dispatch_time(0, 315360000000000000);
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(CFAbsoluteTime *)(a1 + 6824) = CFAbsoluteTimeGetCurrent() + 315360000.0;
    CFRelease(v5);
  }
  else
  {
    v11 = *(NSObject **)(a1 + 6816);
    v12 = dispatch_time(0, 315360000000000000);
    dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0);
    result = CFAbsoluteTimeGetCurrent() + 315360000.0;
    *(CFAbsoluteTime *)(a1 + 6824) = result;
  }
  return result;
}

void sub_1000F44F4(uint64_t a1, char a2, NSObject **cf)
{
  NSObject *v6;
  uint64_t v7;
  void *v8;
  _QWORD block[6];
  char v10;

  if (cf)
  {
    if (cf[30])
    {
      CFRetain(cf);
      v6 = cf[30];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000F4600;
      block[3] = &unk_1002313F8;
      v7 = *(_QWORD *)(a1 + 32);
      block[4] = cf;
      block[5] = v7;
      v10 = a2;
      dispatch_async(v6, block);
      return;
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerCreate_block_invoke_2");
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerCreate_block_invoke_2");
  }
  objc_autoreleasePoolPop(v8);
}

void sub_1000F4600(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  uint64_t v13;
  void *v14;
  void *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];

  v2 = *(_QWORD **)(a1 + 32);
  if (v2[30])
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(unsigned int *)(v3 + 3280);
    dispatch_source_set_timer(*(dispatch_source_t *)(v3 + 6808), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_BYTE *)(a1 + 48))
        v6 = "found";
      else
        v6 = "not found";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hotspot networks %s", "WiFiDeviceManagerCreate_block_invoke_3", v6);
    }
    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a1 + 48))
    {
      v7 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 6744), "copySortedHotspotDevicesByAutoPreferences");
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sorted hotspot device list %@", "WiFiDeviceManagerCreate_block_invoke_3", v7);
      objc_autoreleasePoolPop(v8);
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      if (v9)
      {
        v10 = v9;
        v11 = *(_QWORD *)v17;
        do
        {
          for (i = 0; i != v10; i = (char *)i + 1)
          {
            if (*(_QWORD *)v17 != v11)
              objc_enumerationMutation(v7);
            CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 6840), *(const void **)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)i));
          }
          v10 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
        }
        while (v10);
      }
      *(CFAbsoluteTime *)(*(_QWORD *)(a1 + 40) + 6848) = CFAbsoluteTimeGetCurrent();
    }
    else
    {
      v7 = 0;
    }
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8864);
      if (v13)
      {
        (*(void (**)(uint64_t, _QWORD, id))(v13 + 16))(v13, 0, v7);
        _Block_release(*(const void **)(*(_QWORD *)(a1 + 40) + 8864));
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8864) = 0;
      }
    }

    if ((v4 - 20) > 0xFFFFFFFB)
    {
      if (sub_1000F4958(*(_QWORD *)(a1 + 40)))
      {
        sub_1000F49C8(*(_QWORD *)(a1 + 40));
      }
      else
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Auto hotspot attempt canceled because user auto join is disabled.", "WiFiDeviceManagerCreate_block_invoke_3");
        objc_autoreleasePoolPop(v15);
      }
    }
    else
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Received Update Hotspot Devices in state %d", "WiFiDeviceManagerCreate_block_invoke_3", v4);
      objc_autoreleasePoolPop(v14);
      sub_1000F48F0(*(_QWORD *)(a1 + 40), 0);
    }
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }
  else
  {
    CFRelease(v2);
  }
}

uint64_t sub_1000F48E8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 3280);
}

CFAbsoluteTime sub_1000F48F0(uint64_t a1, int a2)
{
  void *v3;
  CFAbsoluteTime result;

  v3 = *(void **)(a1 + 6744);
  if (a2)
  {
    objc_msgSend(v3, "startBrowsing");
    result = CFAbsoluteTimeGetCurrent();
    *(CFAbsoluteTime *)(a1 + 6960) = result;
    ++*(_DWORD *)(a1 + 6172);
  }
  else if (objc_msgSend(v3, "isScanning"))
  {
    objc_msgSend(*(id *)(a1 + 6744), "stopBrowsing");
    result = *(double *)(a1 + 6176) + CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6960);
    *(CFAbsoluteTime *)(a1 + 6176) = result;
  }
  return result;
}

uint64_t sub_1000F4958(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 6280);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager", "__WiFiDeviceManagerGetUserAutoJoin");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000F49C8(uint64_t a1)
{
  void *v2;
  void **v3;
  NSString *v4;
  const __CFArray *v5;
  uint64_t v6;
  CFIndex v7;
  void *v8;
  NSString *v9;
  const char *v10;
  int v11;
  CFMutableArrayRef v12;
  CFIndex v13;
  CFIndex v14;
  void *v15;
  BOOL v16;
  CFIndex i;
  void *v18;
  void *v19;
  const void *v20;
  int v21;
  uint64_t v22;
  const __CFNumber *v23;
  void *v24;
  void *v25;
  const __CFNumber *v26;
  __CFString *v27;
  CFIndex v28;
  const void *v29;
  uint64_t v30;
  _WORD *v31;
  const void *v32;
  const __CFArray *v33;
  CFIndex v34;
  __CFArray *v35;
  const void *v36;
  double v37;
  const __CFArray *v38;
  unsigned int v39;
  CFIndex Count;
  CFMutableStringRef Mutable;
  int v42;
  const void *v43;
  const __CFArray *v44;
  CFMutableArrayRef v45;
  int v46;
  CFIndex v47;
  CFIndex v48;
  const __CFString *v49;
  int v50;
  void *v51;
  void *v52;
  unsigned int v53;
  const __CFArray *v54;
  uint64_t v55;
  const __CFArray *v56;
  CFIndex v57;
  const void *v58;
  const void *v59;
  CFMutableArrayRef v60;
  CFIndex v61;
  uint64_t v62;
  CFIndex v63;
  const __CFDictionary **v64;
  const __CFDictionary **v65;
  uint64_t v66;
  void *v67;
  void *v68;
  void **v69;
  const void *v70;
  const __CFNumber *v71;
  __CFString *v72;
  _WORD *v73;
  const void *v74;
  CFIndex v75;
  const __CFDictionary **v76;
  const __CFDictionary **v77;
  id v78;
  void *v79;
  unsigned int v80;
  unsigned int v81;
  const __CFArray *v82;
  CFIndex v83;
  uint64_t v84;
  CFMutableArrayRef v85;
  const __CFArray *v86;
  CFIndex j;
  void *v88;
  void *v89;
  const __CFArray *v90;
  void *v91;
  unsigned int v92;
  void *v93;
  __CFArray *v94;
  __CFArray *v95;
  const __CFArray *v96;
  CFIndex v97;
  CFIndex v98;
  uint64_t v99;
  BOOL v100;
  CFIndex v101;
  CFIndex v102;
  void *ValueAtIndex;
  void *v104;
  const __CFNumber *v105;
  CFIndex v106;
  const __CFDictionary **v107;
  CFIndex FirstIndexOfValue;
  const void *v109;
  uint64_t v110;
  _WORD *v111;
  const void *v112;
  const __CFArray *v113;
  CFIndex v114;
  __CFString *v115;
  CFMutableStringRef v116;
  __CFString *v117;
  void *v118;
  void *v119;
  double v120;
  void *v121;
  __CFString *v122;
  void *v123;
  void *v124;
  void *v125;
  void *v126;
  CFIndex v127;
  const void *v128;
  __CFString *v129;
  __CFString *v130;
  void *v131;
  uint64_t v132;
  unsigned __int8 v133;
  unsigned __int8 v134;
  int v135;
  int v136;
  uint64_t v137;
  CFIndex v138;
  CFIndex v139;
  CFIndex v140;
  void *v141;
  unsigned int v142;
  const void *v143;
  __CFString *v144;
  void *v145;
  int v146;
  void *v147;
  void *v148;
  void *v149;
  const void *v150;
  CFIndex v151;
  CFIndex v152;
  __CFArray *v153;
  void *v154;
  void *v155;
  __CFString **v156;
  void *v157;
  void *v158;
  const __CFString *v159;
  _WORD *v160;
  uint64_t v161;
  const void *v162;
  int v163;
  void *v164;
  void *v165;
  void *v166;
  uint64_t v167;
  uint64_t v168;
  __CFArray *v169;
  void *v170;
  const char *v171;
  void *v172;
  void *v173;
  uint64_t v174;
  CFIndex idx;
  CFMutableStringRef v176;
  const void *v177;
  const void *v178;
  __CFString *cf;
  __CFString *cfa;
  void *context;
  unsigned int contexta;
  void *contextb;
  const void *v184;
  int v185;
  CFAllocatorRef alloc;
  CFIndex v187;
  CFIndex v188;
  unsigned int v189;
  CFIndex v190;
  double valuePtr;
  int v192;
  uint8_t buf[16];
  __int128 v194;
  __int128 v195;
  int v196;
  CFRange v197;
  CFRange v198;
  CFRange v199;
  CFRange v200;
  CFRange v201;
  CFRange v202;
  CFRange v203;
  CFRange v204;
  CFRange v205;
  CFRange v206;

  v2 = objc_autoreleasePoolPush();
  v3 = (void **)&qword_10026DD20;
  if (qword_10026DD20)
  {
    v4 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: current state: %@"), "__WiFiDeviceManagerStateMachineRun", sub_100031FD0(*(_DWORD *)(a1 + 3280)))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v4, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v2);
  switch(*(_DWORD *)(a1 + 3280))
  {
    case 0:
    case 1:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        goto LABEL_358;
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3568));
      objc_msgSend(*(id *)(a1 + 3656), "clearScanResultsForAutoJoinSessionReset");
      v49 = (const __CFString *)sub_100029860(*(_QWORD *)(a1 + 64));
      sub_10005B6CC(a1, v49, 0);
      buf[0] = 0;
      v50 = sub_10012B9CC(a1, buf);
      if (*(_BYTE *)(a1 + 32)
        && *(_BYTE *)(a1 + 33)
        && *(_DWORD *)(a1 + 176) == 3
        && buf[0]
        && !v50
        && !*(_BYTE *)(a1 + 3304)
        && *(_DWORD *)(a1 + 192) != 14
        && *(_DWORD *)(a1 + 5520) != 1)
      {
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Falling to 2Ghz scan to save power");
        objc_autoreleasePoolPop(v51);
        *(_DWORD *)(a1 + 28) = 1;
      }
      if (*(_BYTE *)(a1 + 24)
        && sub_100069F0C(*(_QWORD *)(a1 + 64))
        && (*(_DWORD *)(a1 + 5520) == 1 || *(_BYTE *)(a1 + 5504) || !*(_DWORD *)(a1 + 28)))
      {
        v52 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting multi-stage auto join mStageAutoJoinAttempts=%d", *(unsigned int *)(a1 + 28));
        objc_autoreleasePoolPop(v52);
        v53 = sub_1001287BC(a1);
      }
      else
      {
        v157 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Fallback to existing auto-join mStageAutoJoinAttempts=%d", *(unsigned int *)(a1 + 28));
        objc_autoreleasePoolPop(v157);
        v53 = sub_100129118(a1);
      }
      goto LABEL_330;
    case 2:
    case 3:
    case 4:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        goto LABEL_358;
      v38 = *(const __CFArray **)(a1 + 1096);
      v39 = *(_DWORD *)(a1 + 1088);
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624));
      Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
      contexta = v39;
      if (!v38 || v39)
        goto LABEL_361;
      v196 = 0;
      v194 = 0u;
      v195 = 0u;
      *(_OWORD *)buf = 0u;
      sub_10012EB08(a1);
      v42 = *(_DWORD *)(a1 + 3280);
      if (v42 == 4 || v42 == 2)
      {
        v43 = *(const void **)(a1 + 1152);
        if (v43)
        {
          CFRelease(v43);
          *(_QWORD *)(a1 + 1152) = 0;
        }
      }
      v44 = *(const __CFArray **)(a1 + 1112);
      if (!v44)
      {
        v44 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(a1 + 1112) = v44;
      }
      v45 = *(CFMutableArrayRef *)(a1 + 1168);
      if (!v45)
      {
        v45 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(a1 + 1168) = v45;
        v44 = *(const __CFArray **)(a1 + 1112);
      }
      if (!v44 || !v45)
      {
LABEL_361:
        if (Mutable)
          CFRelease(Mutable);
        goto LABEL_363;
      }
      v46 = *(_DWORD *)(a1 + 3280);
      if (!*(_BYTE *)(a1 + 5608) || v46 != 3)
        goto LABEL_177;
      v47 = CFArrayGetCount(v44);
      v48 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568)) + v47;
      if (v48 + CFArrayGetCount(*(CFArrayRef *)(a1 + 3560)))
      {
        v46 = *(_DWORD *)(a1 + 3280);
LABEL_177:
        if ((v46 - 3) <= 1)
          *(CFAbsoluteTime *)(a1 + 3296) = CFAbsoluteTimeGetCurrent();
        v185 = 1;
      }
      else
      {
        v185 = 0;
      }
      sub_10012EBDC(a1, v38);
      v97 = CFArrayGetCount(v38);
      v190 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3552));
      v98 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3544));
      v99 = 0;
      v100 = Count <= 0 && v98 == 0;
      if (v100 || v97 < 1)
        goto LABEL_247;
      v101 = v98;
      v102 = 0;
      v99 = 0;
      while (1)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v38, v102);
        if (!ValueAtIndex)
          goto LABEL_229;
        v104 = ValueAtIndex;
        if (*(_DWORD *)(a1 + 3280) == 2)
        {
          v105 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL"));
          LODWORD(valuePtr) = 0;
          if (v105)
          {
            CFNumberGetValue(v105, kCFNumberSInt32Type, &valuePtr);
            if ((LODWORD(valuePtr) - 1) <= 0xC)
              ++*(_DWORD *)&buf[4 * (LODWORD(valuePtr) - 1)];
          }
        }
        if (!sub_100124B34(a1, v104, 0))
          goto LABEL_229;
        if (Count >= 1 && sub_10002DA5C((_BOOL8)v104))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1112), v104);
        }
        else
        {
          if (sub_100007DCC(v104))
          {
            if (v190)
            {
              if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3552)) < 1)
              {
LABEL_202:
                if (Mutable)
                  sub_10012EEB4(a1, v104, Mutable);
              }
              else
              {
                v106 = 0;
                while (1)
                {
                  v107 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3552), v106);
                  if (!v107)
                    break;
                  if (sub_1000C5C74(v107, (const __CFDictionary **)v104))
                    goto LABEL_226;
                  if (++v106 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3552)))
                    goto LABEL_202;
                }
                v121 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "knownHiddenNetwork is NULL!, Added the hidden scan result");
                objc_autoreleasePoolPop(v121);
LABEL_226:
                if (v185)
                  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1112), v104);
                v99 = (v99 + 1);
              }
            }
            goto LABEL_229;
          }
          v202.location = 0;
          v202.length = v101;
          FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3544), v202, v104);
          if (FirstIndexOfValue != -1)
          {
            v109 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3544), FirstIndexOfValue);
            if (v109)
            {
              v110 = (uint64_t)v109;
              if (!sub_10000BE8C((uint64_t)v109) || sub_1000CA4F4((uint64_t)v104))
              {
                sub_10012BF90(a1, v104);
                if (sub_100124B34(a1, v104, 0))
                {
                  v111 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v104);
                  if (v111)
                  {
                    v112 = v111;
                    sub_1000C38BC((uint64_t)v111, v110);
                    v113 = *(const __CFArray **)(a1 + 1112);
                    v203.length = CFArrayGetCount(v113);
                    v203.location = 0;
                    v114 = CFArrayGetFirstIndexOfValue(v113, v203, v112);
                    if (v114 != -1)
                    {
                      idx = v114;
                      v177 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v114);
                      sub_10002B698((uint64_t)v177, CFSTR("AJFoundOnDualBand"), 1);
                      v178 = v112;
                      sub_10002B698((uint64_t)v112, CFSTR("AJFoundOnDualBand"), 1);
                      v115 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                      v116 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                      cf = v115;
                      if (v115 && v116)
                      {
                        v117 = v116;
                        sub_10012EFB4(a1, v177, v115);
                        sub_10012EFB4(a1, v178, v117);
                        v118 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                        {
                          v119 = v118;
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AJScan: Network found on two bands: {{ %@ }}, {{ %@ }}", cf, v117);
                          v118 = v119;
                        }
                        objc_autoreleasePoolPop(v118);
                        v116 = v117;
                      }
                      v176 = v116;
                      v120 = sub_1000C46B4((uint64_t)v177, CFSTR("Strength"));
                      v112 = v178;
                      if (v120 < sub_1000C46B4((uint64_t)v178, CFSTR("Strength")))
                        CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), idx, v178);
                      if (cf)
                        CFRelease(cf);
                      if (v176)
                        CFRelease(v176);
                      ++*(_DWORD *)(a1 + 5844);
LABEL_246:
                      CFRelease(v112);
                      goto LABEL_229;
                    }
                    v122 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                    cfa = v122;
                    if (*(_DWORD *)(a1 + 3280) == 3)
                    {
                      if (v122)
                      {
                        sub_10012EFB4(a1, v112, v122);
                        v123 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                        {
                          v124 = v123;
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Network found on 5Ghz only: {{ %@ }}", cfa);
                          v123 = v124;
                        }
                        objc_autoreleasePoolPop(v123);
                      }
                      ++*(_DWORD *)(a1 + 5840);
                      v125 = objc_autoreleasePoolPush();
                      if (v185)
                      {
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Used Network found on 5Ghz: {{ %@ }}", cfa);
                        objc_autoreleasePoolPop(v125);
                        goto LABEL_240;
                      }
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Missed Network found on 5Ghz: {{ %@ }}", cfa);
                      objc_autoreleasePoolPop(v125);
                    }
                    else
                    {
LABEL_240:
                      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1112), v112);
                    }
                    if (cfa)
                      CFRelease(cfa);
                    goto LABEL_246;
                  }
                }
              }
            }
          }
        }
LABEL_229:
        if (++v102 == v97)
        {
LABEL_247:
          if (Mutable)
          {
            if (CFStringGetLength(Mutable))
            {
              v126 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Skipped the non-matching hidden networks - %@", Mutable);
              objc_autoreleasePoolPop(v126);
            }
            CFRelease(Mutable);
          }
          if (*(_DWORD *)(a1 + 3280) == 3 && CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)) >= 1)
          {
            v127 = 0;
            do
            {
              v128 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v127);
              if (sub_10003153C((uint64_t)v128) == 1
                && !sub_100017A54((uint64_t)v128, CFSTR("AJFoundOnDualBand"))
                && !sub_100007DCC(v128))
              {
                v129 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                ++*(_DWORD *)(a1 + 5848);
                if (v129)
                {
                  v130 = v129;
                  sub_10012EFB4(a1, v128, v129);
                  v131 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Network found on 2Ghz only: {{ %@ }}", v130);
                  objc_autoreleasePoolPop(v131);
                  CFRelease(v130);
                }
              }
              ++v127;
            }
            while (v127 < CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)));
          }
          sub_10012F2B0(a1);
          objc_msgSend(*(id *)(a1 + 3656), "setScanResultsWithAutoJoinSessionCompletion:complete:", v38, 1);
          if (*(_DWORD *)(a1 + 3280) == 2)
          {
            v132 = 0;
            v133 = 0;
            v134 = 0;
            do
            {
              v135 = *(_DWORD *)&buf[v132];
              if (v135 > 9)
                v134 = 1;
              if (v135 > v133)
                v133 = *(_DWORD *)&buf[v132];
              v132 += 4;
            }
            while (v132 != 52);
          }
          else
          {
            v134 = 0;
            v133 = 0;
          }
          v136 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112));
          v137 = (v136 - v99);
          v138 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
          v139 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560));
          v140 = v139;
          *(_DWORD *)(a1 + 5860) += v99;
          *(_DWORD *)(a1 + 5852) += v139;
          *(_DWORD *)(a1 + 5856) += v138;
          *(_DWORD *)(a1 + 5864) += v137;
          if (*(_DWORD *)(a1 + 3280) == 2)
          {
            *(_DWORD *)(a1 + 6144) = ((2 * ((_DWORD)v99 != 0)) | (8 * (v134 != 0))) | (v133 << 16) | (v136 != (_DWORD)v99) | (16 * ((_DWORD)v138 != 0)) | (4 * ((_DWORD)v139 != 0));
            if (((_DWORD)v99
               || v136
               || (_DWORD)v138
               || (_DWORD)v139
               || v134
               || *(_BYTE *)(a1 + 5608)
               || *(_BYTE *)(a1 + 3304))
              && !sub_10012C418((_BYTE *)a1, 0))
            {
              v141 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Found {%d Nw, %d hidden %d HS, %d HS20, busych %d, force %d} 2.4Ghz network, triggering 5Ghz scan\n", v137, v99, v138, v140, v134, *(unsigned __int8 *)(a1 + 3304));
              objc_autoreleasePoolPop(v141);
              if ((_DWORD)v99)
                ++*(_DWORD *)(a1 + 5820);
              if (v136 != (_DWORD)v99)
                ++*(_DWORD *)(a1 + 5836);
              if ((_DWORD)v138)
                ++*(_DWORD *)(a1 + 5828);
              if ((_DWORD)v140)
                ++*(_DWORD *)(a1 + 5824);
              if (v134)
                ++*(_DWORD *)(a1 + 5832);
              v142 = sub_100129118(a1);
              goto LABEL_324;
            }
          }
          sub_10012F8CC(a1, *(const __CFArray **)(a1 + 1112));
          sub_10012F8CC(a1, *(const __CFArray **)(a1 + 3568));
          sub_10012F8CC(a1, *(const __CFArray **)(a1 + 3560));
          sub_10012FDD8(*(const __CFArray **)(a1 + 1112), 1, (CFTypeRef *)(a1 + 1152));
          if (sub_1001301A8(a1))
            goto LABEL_323;
LABEL_363:
          v167 = contexta;
          if (contexta)
          {
            v168 = a1;
            goto LABEL_387;
          }
          v142 = sub_100131444(a1);
          goto LABEL_324;
        }
      }
    case 5:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        goto LABEL_358;
      v54 = *(const __CFArray **)(a1 + 1096);
      v55 = *(unsigned int *)(a1 + 1088);
      contextb = objc_autoreleasePoolPush();
      if (!(_DWORD)v55)
      {
        v56 = *(const __CFArray **)(a1 + 3552);
        v57 = *(_QWORD *)(a1 + 1144);
        *(_QWORD *)(a1 + 1144) = v57 + 1;
        v58 = CFArrayGetValueAtIndex(v56, v57);
        if (v54)
        {
          v59 = v58;
          if (v58)
          {
            sub_10012EBDC(a1, v54);
            sub_10012FDD8(v54, 0, 0);
            if (*(_QWORD *)(a1 + 1112)
              || (v60 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks),
                  (*(_QWORD *)(a1 + 1112) = v60) != 0))
            {
              v61 = CFArrayGetCount(v54);
              if (v61)
              {
                v62 = v61;
                v199.location = 0;
                v199.length = v61;
                if (CFArrayGetFirstIndexOfValue(v54, v199, v59) != -1)
                {
                  v188 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112));
                  if (v62 >= 1)
                  {
                    v63 = 0;
                    alloc = (CFAllocatorRef)v62;
                    do
                    {
                      v64 = (const __CFDictionary **)CFArrayGetValueAtIndex(v54, v63);
                      if (v64)
                      {
                        v65 = v64;
                        v192 = 0;
                        v66 = sub_100125CA4(a1, v64, 1, &v192);
                        if ((uint64_t)sub_100017A54((uint64_t)v65, CFSTR("RSSI")) >= (int)v66)
                        {
                          v73 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v65);
                          if (v73)
                          {
                            v74 = v73;
                            sub_1000C38BC((uint64_t)v73, (uint64_t)v59);
                            if (sub_10002BE64((uint64_t)v74, CFSTR("BSSID")))
                            {
                              v75 = *(_QWORD *)(a1 + 1120);
                              if (v75 < v188)
                              {
                                v184 = v74;
                                do
                                {
                                  v76 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v75);
                                  if (v76)
                                  {
                                    v77 = v76;
                                    if (sub_1000C5C74(v76, v65))
                                    {
                                      v78 = sub_100027D10((uint64_t)v77);
                                      if (!objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v78))goto LABEL_131;
                                      *(_QWORD *)buf = 0;
                                      valuePtr = 0.0;
                                      if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v78, buf, &valuePtr))
                                      {
                                        if (sub_100047970(*(_DWORD **)(a1 + 120), v77, *(int *)buf, valuePtr))goto LABEL_131;
                                      }
                                      else
                                      {
                                        if (sub_100125740(a1, v77))
                                        {
LABEL_131:

                                          CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), v75, v74);
                                          break;
                                        }
                                        v79 = objc_autoreleasePoolPush();
                                        if (qword_10026DD20)
                                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Skipping problematic network %@ for auto-join", sub_10002B088(v77));
                                        objc_autoreleasePoolPop(v79);
                                        v62 = (uint64_t)alloc;
                                        v74 = v184;
                                      }

                                    }
                                  }
                                  ++v75;
                                }
                                while (v188 != v75);
                              }
                            }
                            CFRelease(v74);
                            v3 = (void **)&qword_10026DD20;
                          }
                        }
                        else
                        {
                          v67 = objc_autoreleasePoolPush();
                          v68 = *v3;
                          if (*v3)
                          {
                            v69 = v3;
                            v70 = sub_10002B088(v65);
                            v71 = sub_100017A54((uint64_t)v65, CFSTR("RSSI"));
                            if ((v192 - 1) > 3)
                              v72 = 0;
                            else
                              v72 = off_100232250[v192 - 1];
                            objc_msgSend(v68, "WFLog:message:", 4, "Filtered hidden network %@ with RSSI %ld (%@ threshold %d)", v70, v71, v72, v66);
                            v3 = v69;
                            v62 = (uint64_t)alloc;
                          }
                          objc_autoreleasePoolPop(v67);
                        }
                      }
                      ++v63;
                    }
                    while (v63 != v62);
                  }
                }
              }
            }
          }
        }
        v80 = sub_100131C40(a1, *(const void **)(a1 + 1160));
        goto LABEL_135;
      }
      v80 = sub_10000D074(a1, v55);
LABEL_135:
      v81 = v80;
      objc_autoreleasePoolPop(contextb);
      *(_DWORD *)(a1 + 3280) = v81;
      if (v81 > 1)
        goto LABEL_354;
      goto LABEL_325;
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        goto LABEL_358;
      v5 = *(const __CFArray **)(a1 + 1096);
      v6 = *(unsigned int *)(a1 + 1088);
      v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624));
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: current state: %@"), "__WiFiDeviceManagerProcessMultiStageScanResults", sub_100031FD0(*(_DWORD *)(a1 + 3280)))), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v10 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v10;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v8);
      if ((_DWORD)v6)
      {
        v169 = *(__CFArray **)(a1 + 3288);
        if (v169)
          CFArrayRemoveAllValues(v169);
        goto LABEL_367;
      }
      v11 = *(_DWORD *)(a1 + 3280);
      if (v11 == 11)
        v5 = *(const __CFArray **)(a1 + 1104);
      if (!v5)
        goto LABEL_367;
      if ((v11 & 0xFFFFFFFE) == 0xA)
      {
        sub_10012EB08(a1);
        *(CFAbsoluteTime *)(a1 + 3296) = CFAbsoluteTimeGetCurrent();
      }
      if (!*(_QWORD *)(a1 + 1112))
      {
        v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(a1 + 1112) = v12;
        if (!v12)
          goto LABEL_367;
      }
      sub_10012EBDC(a1, v5);
      v13 = CFArrayGetCount(v5);
      v14 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576));
      v15 = objc_autoreleasePoolPush();
      v187 = v14;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanned# %ld, known# %ld, isHS20AccountConfigured %d, topRankedKnownNetwork %@", "__WiFiDeviceManagerProcessMultiStageScanResults", v13, v14, v7 > 0, sub_10002B088(*(const void **)(a1 + 3376)));
      objc_autoreleasePoolPop(v15);
      v16 = v7 <= 0 && v14 == 0;
      if (v16 || v13 < 1)
        goto LABEL_56;
      for (i = 0; i != v13; ++i)
      {
        v18 = (void *)CFArrayGetValueAtIndex(v5, i);
        if (!v18)
          continue;
        v19 = v18;
        sub_10012BF90(a1, v18);
        if (!sub_100124B34(a1, v19, 0))
          continue;
        if (v7 >= 1 && sub_10002DA5C((_BOOL8)v19))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1112), v19);
          continue;
        }
        v20 = *(const void **)(a1 + 3376);
        if (v20 && ((v21 = *(_DWORD *)(a1 + 3280), v21 == 9) || v21 == 7))
        {
          if (CFEqual(v20, v19) != 1)
            continue;
          *(_DWORD *)buf = -1431655766;
          v22 = sub_100125CA4(a1, v19, 1, (int *)buf);
          v23 = sub_100017A54((uint64_t)v19, CFSTR("RSSI"));
          v24 = objc_autoreleasePoolPush();
          v25 = (void *)qword_10026DD20;
          if ((uint64_t)v23 < (int)v22)
          {
            v14 = v187;
            if (qword_10026DD20)
            {
              context = (void *)sub_10002B088(v19);
              v26 = sub_100017A54((uint64_t)v19, CFSTR("RSSI"));
              if ((*(_DWORD *)buf - 1) > 3)
                v27 = 0;
              else
                v27 = off_100232250[*(_DWORD *)buf - 1];
              objc_msgSend(v25, "WFLog:message:", 4, "Filtered top network %@ with RSSI %ld (%@ threshold %d)", context, v26, v27, v22);
            }
            objc_autoreleasePoolPop(v24);
            continue;
          }
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found the top network to match scanned network %@", "__WiFiDeviceManagerProcessMultiStageScanResults", sub_10002B088(v19));
          objc_autoreleasePoolPop(v24);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1112), *(const void **)(a1 + 3376));
          v30 = *(_QWORD *)(a1 + 3376);
          v14 = v187;
        }
        else
        {
          v197.location = 0;
          v197.length = v14;
          v28 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3576), v197, v19);
          if (v28 == -1)
            continue;
          v29 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), v28);
          if (!v29)
            continue;
          v30 = (uint64_t)v29;
          if (sub_10000BE8C((uint64_t)v29))
          {
            if (!sub_1000CA4F4((uint64_t)v19))
              continue;
          }
        }
        v31 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v19);
        if (v31)
        {
          v32 = v31;
          sub_1000C38BC((uint64_t)v31, v30);
          v33 = *(const __CFArray **)(a1 + 1112);
          v198.length = CFArrayGetCount(v33);
          v198.location = 0;
          v34 = CFArrayGetFirstIndexOfValue(v33, v198, v32);
          v35 = *(__CFArray **)(a1 + 1112);
          if (v34 == -1)
          {
            CFArrayAppendValue(v35, v32);
          }
          else
          {
            v36 = CFArrayGetValueAtIndex(v35, v34);
            v37 = sub_1000C46B4((uint64_t)v36, CFSTR("Strength"));
            if (v37 < sub_1000C46B4((uint64_t)v32, CFSTR("Strength")))
              CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), v34, v32);
          }
          CFRelease(v32);
          v14 = v187;
        }
      }
LABEL_56:
      sub_10012F2B0(a1);
      objc_msgSend(*(id *)(a1 + 3656), "setScanResultsWithAutoJoinSessionCompletion:complete:", v5, 0);
      sub_10012F8CC(a1, *(const __CFArray **)(a1 + 1112));
      sub_10012F8CC(a1, *(const __CFArray **)(a1 + 3568));
      sub_10012F8CC(a1, *(const __CFArray **)(a1 + 3560));
      v6 = 0;
      if (sub_1001301A8(a1))
        goto LABEL_323;
LABEL_367:
      v142 = sub_100132534((_DWORD *)a1, v6);
LABEL_324:
      *(_DWORD *)(a1 + 3280) = v142;
      if (v142 <= 1)
      {
LABEL_325:
        v156 = off_10022FC88;
LABEL_349:
        sub_100135D8C(a1, *v156, 0, 0);
LABEL_350:
        v53 = *(_DWORD *)(a1 + 3280);
LABEL_351:
        if (v53 <= 1)
        {
          v165 = *(void **)(a1 + 3272);
          if (v165)
          {

            *(_QWORD *)(a1 + 3272) = 0;
          }
          return;
        }
      }
LABEL_354:
      if (!*(_QWORD *)(a1 + 3272))
        *(_QWORD *)(a1 + 3272) = sub_10001E1C8((uint64_t)"__WiFiDeviceManagerStateMachineRun");
      return;
    case 0xC:
    case 0xF:
      v53 = sub_100129744(a1, *(void **)(a1 + 1184), *(const __CFDictionary **)(a1 + 1192), *(unsigned int *)(a1 + 1176));
      goto LABEL_330;
    case 0xD:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        goto LABEL_358;
      v189 = *(_DWORD *)(a1 + 3344);
      if (!v189)
      {
        v82 = *(const __CFArray **)(a1 + 3336);
        if (v82)
        {
          if (!*(_QWORD *)(a1 + 1112))
          {
            *(_QWORD *)(a1 + 1112) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            v82 = *(const __CFArray **)(a1 + 3336);
          }
          if (CFArrayGetCount(v82))
          {
            if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)))
            {
              v83 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3336));
              if (v83)
              {
                v84 = v83;
                v85 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                if (v85)
                {
                  v86 = v85;
                  if (v84 >= 1)
                  {
                    for (j = 0; v84 != j; ++j)
                    {
                      v88 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3336), j);
                      if (v88)
                      {
                        v89 = v88;
                        if (sub_100007F24((uint64_t)v88))
                        {
                          v90 = *(const __CFArray **)(a1 + 3640);
                          v200.length = CFArrayGetCount(v90);
                          v200.location = 0;
                          if (CFArrayGetFirstIndexOfValue(v90, v200, v89) == -1)
                          {
                            if (!sub_1000C993C((uint64_t)v89))
                              continue;
                            if (sub_100124B34(a1, v89, 0))
                            {
                              v201.length = CFArrayGetCount(v86);
                              v201.location = 0;
                              if (CFArrayContainsValue(v86, v201, v89))
                                continue;
                              CFArrayAppendValue(v86, v89);
                              v91 = objc_autoreleasePoolPush();
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found provisioned network %@, adding to tmp array", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_10002B088(v89));
                            }
                            else
                            {
                              v91 = objc_autoreleasePoolPush();
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Provisioned HS2.0 network %@ not eligible for aj", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_10002B088(v89));
                            }
                          }
                          else
                          {
                            v91 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS2.0 network %@ is in disabled network list", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_10002B088(v89));
                          }
                        }
                        else
                        {
                          v91 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is disabled %@", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_10002B088(v89));
                        }
                        objc_autoreleasePoolPop(v91);
                      }
                    }
                  }
                  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3336));
                  if (CFArrayGetCount(v86))
                  {
                    v94 = *(__CFArray **)(a1 + 3336);
                    v204.length = CFArrayGetCount(v86);
                    v204.location = 0;
                    CFArrayAppendArray(v94, v86, v204);
                    CFRelease(v86);
                    v95 = *(__CFArray **)(a1 + 1112);
                    v96 = *(const __CFArray **)(a1 + 3336);
                    v205.length = CFArrayGetCount(v96);
                    v205.location = 0;
                    CFArrayAppendArray(v95, v96, v205);
                    goto LABEL_312;
                  }
                  v148 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No provisioned HS2.0 networks found");
                  objc_autoreleasePoolPop(v148);
                  CFRelease(v86);
                }
              }
              else
              {
                v172 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No GAS responses to filter");
                objc_autoreleasePoolPop(v172);
              }
              v149 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No suitable HS2.0 networks found");
LABEL_311:
              objc_autoreleasePoolPop(v149);
LABEL_312:
              v150 = *(const void **)(a1 + 3336);
              if (v150)
              {
                CFRelease(v150);
                *(_QWORD *)(a1 + 3336) = 0;
              }
              v151 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
              if (v151)
              {
                v152 = v151;
                v153 = *(__CFArray **)(a1 + 1112);
                if (!v153)
                {
                  v153 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                  *(_QWORD *)(a1 + 1112) = v153;
                  if (!v153)
                  {
                    v173 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null scan.candidates.networks", "__WiFiDeviceManagerProcessGasResponses");
                    objc_autoreleasePoolPop(v173);
LABEL_386:
                    v168 = a1;
                    v167 = v189;
LABEL_387:
                    v142 = sub_10000D074(v168, v167);
                    goto LABEL_324;
                  }
                }
                v206.location = 0;
                v206.length = v152;
                CFArrayAppendArray(v153, *(CFArrayRef *)(a1 + 3568), v206);
                v154 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Appending deffered networks to candidates list", "__WiFiDeviceManagerProcessGasResponses");
                objc_autoreleasePoolPop(v154);
              }
              CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
              CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3568));
              objc_msgSend(*(id *)(a1 + 3656), "clearScanResultsForAutoJoinSessionReset");
              sub_10012F8CC(a1, *(const __CFArray **)(a1 + 1112));
              v155 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d manager->state.scan.candidates.networks %@", "__WiFiDeviceManagerProcessGasResponses", 27006, *(_QWORD *)(a1 + 1112));
              objc_autoreleasePoolPop(v155);
              if (sub_1001301A8(a1))
              {
LABEL_323:
                v142 = sub_100130A04(a1);
                goto LABEL_324;
              }
              goto LABEL_386;
            }
            v149 = objc_autoreleasePoolPush();
            v170 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_311;
            v171 = "No HS2.0 accounts";
          }
          else
          {
            v149 = objc_autoreleasePoolPush();
            v170 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_311;
            v171 = "GAS Query returned response count=0. Continuing...";
          }
        }
        else
        {
          v149 = objc_autoreleasePoolPush();
          v170 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_311;
          v171 = "GAS Query returned no responses. Continuing...";
        }
        objc_msgSend(v170, "WFLog:message:", 3, v171, v174);
        goto LABEL_311;
      }
      v149 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "GAS Query failed with err=%d. Continuing...", *(unsigned int *)(a1 + 3344));
      goto LABEL_311;
    case 0xE:
    case 0x11:
      v53 = sub_10012AD94(a1);
LABEL_330:
      *(_DWORD *)(a1 + 3280) = v53;
      goto LABEL_351;
    case 0x10:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
LABEL_358:
        v166 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s with state=%d not allowed with Unified Auto-Join", "__WiFiDeviceManagerStateMachineRun", *(unsigned int *)(a1 + 3280));
        objc_autoreleasePoolPop(v166);
        goto LABEL_350;
      }
      v92 = sub_10012B2AC(a1);
LABEL_168:
      *(_DWORD *)(a1 + 3280) = v92;
      if (v92 <= 1)
        goto LABEL_348;
      goto LABEL_354;
    case 0x12:
      v92 = sub_10012B860(a1, *(_QWORD *)(a1 + 6904));
      goto LABEL_168;
    case 0x13:
      if (*(_BYTE *)(a1 + 7008))
      {
        v93 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Waiting on Enable Remote Hotspot", "__WiFiDeviceManagerProcessEnableRemoteHotspotWaiting");
        objc_autoreleasePoolPop(v93);
LABEL_347:
        if (*(_DWORD *)(a1 + 3280) <= 1u)
        {
LABEL_348:
          v156 = off_100230158;
          goto LABEL_349;
        }
        goto LABEL_354;
      }
      v143 = *(const void **)(a1 + 6904);
      if (*(_QWORD *)(a1 + 6992))
      {
        v144 = (__CFString *)objc_msgSend(objc_msgSend(*(id *)(a1 + 6744), "getHotspotDeviceName:", *(_QWORD *)(a1 + 6904)), "copy");
        if (objc_msgSend(*(id *)(a1 + 6992), "code") == (id)-71146)
        {
          v145 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Connection Failure: Server blocked");
          objc_autoreleasePoolPop(v145);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6920), v143);
          sub_1000F48F0(a1, 0);
          *(_QWORD *)(a1 + 6872) = 0;
          *(_DWORD *)(a1 + 6880) = 0;
          *(_DWORD *)(a1 + 3280) = 0;
          sub_100134B1C(a1, v144, 2u);
          *(_QWORD *)(a1 + 6904) = 0;
        }
        v146 = *(_DWORD *)(a1 + 6880);
        v147 = objc_autoreleasePoolPush();
        if (v146)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Error (%@) enabling hotspot... Retry %d", *(_QWORD *)(a1 + 6992), *(unsigned int *)(a1 + 6880));
          objc_autoreleasePoolPop(v147);
          --*(_DWORD *)(a1 + 6880);
          *(_DWORD *)(a1 + 3280) = 18;
          sub_1000F49C8(a1);
        }
        else
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Error (%@) enabling hotspot after max retry", *(_QWORD *)(a1 + 6992));
          objc_autoreleasePoolPop(v147);
          sub_1000F48F0(a1, 0);
          *(_DWORD *)(a1 + 3280) = 0;
          *(_QWORD *)(a1 + 6872) = 0;
          sub_100134B1C(a1, v144, 1u);
        }
        *(_DWORD *)(a1 + 6456) = objc_msgSend(*(id *)(a1 + 6992), "code");
        *(_BYTE *)(a1 + 6464) = objc_msgSend(*(id *)(a1 + 6744), "isFamilyHotspot:", v143);
        sub_10005C1E0((unsigned int *)(a1 + 6456));

        goto LABEL_346;
      }
      if (*(_QWORD *)(a1 + 7000))
      {
        v158 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Hotspot Enabled %@", *(_QWORD *)(a1 + 7000));
        objc_autoreleasePoolPop(v158);
        v159 = (const __CFString *)objc_msgSend(*(id *)(a1 + 7000), "objectForKey:", CFSTR("ssid"), sub_1000F48F0(a1, 0));
        v160 = sub_1000C323C(v159);
        if (v160)
        {
          v161 = (uint64_t)v160;
          sub_1000C64F0(v160, (const __CFString *)objc_msgSend(*(id *)(a1 + 7000), "objectForKey:", CFSTR("password")));
          sub_10002C478(v161, CFSTR("CHANNEL"), objc_msgSend(*(id *)(a1 + 7000), "objectForKey:", CFSTR("channel")));
          v162 = *(const void **)(a1 + 6856);
          if (v162)
            CFRelease(v162);
          *(_QWORD *)(a1 + 6856) = v161;
          *(CFAbsoluteTime *)(a1 + 7016) = CFAbsoluteTimeGetCurrent();
          v163 = sub_100134C50(a1, *(const __CFArray **)(a1 + 6856), *(unsigned __int8 *)(a1 + 6968));
          if (!v163)
          {
            *(_DWORD *)(a1 + 3280) = 20;
            *(_DWORD *)(a1 + 6456) = 0;
            *(_BYTE *)(a1 + 6464) = objc_msgSend(*(id *)(a1 + 6744), "isFamilyHotspot:", v143);
            *(_BYTE *)(a1 + 6465) = 1;
            sub_1001345E4((uint64_t *)a1, CFSTR("userJoinScanning"), 0);
LABEL_346:

            *(_QWORD *)(a1 + 7000) = 0;
            goto LABEL_347;
          }
          *(_DWORD *)(a1 + 6456) = v163;
          *(_BYTE *)(a1 + 6464) = objc_msgSend(*(id *)(a1 + 6744), "isFamilyHotspot:", v143);
          sub_10005C1E0((unsigned int *)(a1 + 6456));
          sub_1001345E4((uint64_t *)a1, CFSTR("userJoinAssociationFailed"), 0);
        }
        v164 = *(void **)(a1 + 7000);
        if (v164)
        {

          *(_QWORD *)(a1 + 7000) = 0;
        }
      }
      *(_QWORD *)(a1 + 6872) = 0;
      goto LABEL_347;
    default:
      goto LABEL_354;
  }
}

id sub_1000F6824(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BssBlacklist expiry timer fired", "__WiFiDeviceManagerBssBlacklistExpiryTimerCallback");
  objc_autoreleasePoolPop(v2);
  return objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 2);
}

id sub_1000F688C(uint64_t a1)
{
  void *v2;
  id result;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: EAPATNotifBlacklist expiry timer fired", "__WiFiDeviceManagerEAPATNotifBlacklistExpiryTimerCallback");
  objc_autoreleasePoolPop(v2);
  result = objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 4);
  *(_BYTE *)(a1 + 7336) = 0;
  return result;
}

void sub_1000F6900(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  NSString *v4;
  NSString *v5;
  void (*v6)(uint64_t, uint64_t, NSString *, _QWORD);
  NSObject *v7;
  dispatch_time_t v8;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 7224) + 1;
    *(_QWORD *)(a1 + 7224) = v3;
    if (*(_DWORD *)(a1 + 7232))
    {
      if (!sub_100047C78(*(_QWORD *)(a1 + 120)))
        goto LABEL_11;
      v4 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("DNS Stall: %llus"), *(_QWORD *)(a1 + 7224));
    }
    else
    {
      v4 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Data Stall: %llus"), v3);
    }
    v5 = v4;
    if (*(_BYTE *)(a1 + 7237))
    {
      if (MGGetBoolAnswer(CFSTR("InternalBuild")))
      {
        v6 = *(void (**)(uint64_t, uint64_t, NSString *, _QWORD))(a1 + 4552);
        if (v6)
          v6(a1, 18, v5, *(_QWORD *)(a1 + 4560));
      }
      v7 = *(NSObject **)(a1 + 7216);
      v8 = dispatch_time(0, 1000000000);
      dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
      goto LABEL_12;
    }
LABEL_11:
    sub_10013A94C(a1);
    goto LABEL_12;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "__WiFiDeviceManagerDpsHUDTimerExpiryHandler");
LABEL_12:
  objc_autoreleasePoolPop(v2);
}

void sub_1000F6A30(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  NSString *v5;
  NSString *v6;
  void (*v7)(uint64_t, uint64_t, NSString *, _QWORD);
  NSObject *v8;
  dispatch_time_t v9;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 7272);
    *(_QWORD *)(a1 + 7272) = v3 - 1;
    v4 = *(_QWORD *)(a1 + 7264) + 1;
    *(_QWORD *)(a1 + 7264) = v4;
    if (v3 >= 2
      && (v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Slow WiFi: %llus"), v4),
          *(_BYTE *)(a1 + 7288)))
    {
      v6 = v5;
      if (MGGetBoolAnswer(CFSTR("InternalBuild")))
      {
        v7 = *(void (**)(uint64_t, uint64_t, NSString *, _QWORD))(a1 + 4552);
        if (v7)
          v7(a1, 17, v6, *(_QWORD *)(a1 + 4560));
      }
      v8 = *(NSObject **)(a1 + 7256);
      v9 = dispatch_time(0, 1000000000);
      dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
    else
    {
      sub_10013AA70(a1);
    }
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "__WiFiDeviceManagerSlowWiFiHUDTimerExpiryHandler");
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000F6B44(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void *v4;
  const void *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int v11;
  id v12;
  void *v13;
  void *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  void *v19;
  const char *v20;
  id v21;

  if (!a1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "__WiFiDeviceManagerAdaptiveRoamTimerCallback");
    goto LABEL_45;
  }
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "__WiFiDeviceManagerAdaptiveRoamTimerCallback");
LABEL_45:
    objc_autoreleasePoolPop(v19);
    goto LABEL_46;
  }
  v3 = (const void *)sub_100029860(v2);
  v4 = sub_10002A21C(a1, v3, 1);
  if (!v4)
  {
LABEL_46:
    v21 = 0;
    goto LABEL_21;
  }
  v5 = v4;
  if (_os_feature_enabled_impl("WiFiManager", "RealTimeRoamSuppression") && *(_BYTE *)(a1 + 7042))
  {
    if (-[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress")|| (v6 = *(unsigned __int8 *)(a1 + 3477), *(_BYTE *)(a1 + 3477)))
    {
      v6 = (*(_BYTE *)(a1 + 3468) & 1) == 0;
    }
    if (*(_BYTE *)(a1 + 3414))
      v7 = 1;
    else
      v7 = v6;
    if ((_DWORD)v7)
    {
      if (!*(_BYTE *)(a1 + 3476))
      {
        v21 = objc_alloc_init((Class)NSMutableDictionary);
        if (*(_BYTE *)(a1 + 3414))
          v8 = 4294967186;
        else
          v8 = 4294967216;
        objc_msgSend(v21, "setObject:forKey:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v8), CFSTR("IO80211InterfaceAdaptiveRoamRSSITrigger"));
        v9 = *(_QWORD *)(a1 + 64);
        v10 = (const void *)sub_100025C3C(v9);
        sub_1000672C0(v9, v10, 532, 0, (uint64_t)v21);
        *(_BYTE *)(a1 + 3476) = 1;
        objc_msgSend(*(id *)(a1 + 7368), "updateWithRoamingSuppression:", v7);
        goto LABEL_25;
      }
    }
    else if (*(_BYTE *)(a1 + 3476))
    {
      *(_BYTE *)(a1 + 3476) = 0;
      v12 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
      +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
      objc_msgSend(v12, "setLastRoamSuppressionRemovalTime:");
      v21 = 0;
      v11 = 1;
      goto LABEL_26;
    }
    v21 = 0;
LABEL_25:
    v11 = 0;
LABEL_26:
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v15 = "YES";
      if ((_DWORD)v7)
        v16 = "YES";
      else
        v16 = "NO";
      v20 = v16;
      if (*(_BYTE *)(a1 + 3476))
        v17 = "YES";
      else
        v17 = "NO";
      if (-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))
      {
        v18 = "YES";
      }
      else
      {
        v18 = "NO";
      }
      if (!-[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress"))v15 = "NO";
      objc_msgSend(v14, "WFLog:message:", 3, "%s: isRoamSuppressionRecommended=%s (applied=%s) isRealTimeAppActive=%s isWiFiCallInProgress=%s currentNetwork=%@ roamSuppressionRequest=%@", "__WiFiDeviceManagerAdaptiveRoamTimerCallback", v20, v17, v18, v15, sub_10002B088(v5), v21);
    }
    objc_autoreleasePoolPop(v13);
    if (*(_BYTE *)(a1 + 3476))
      goto LABEL_20;
    goto LABEL_19;
  }
  v11 = 0;
  v7 = 0;
  v21 = 0;
  *(_BYTE *)(a1 + 3476) = 0;
LABEL_19:
  objc_msgSend(*(id *)(a1 + 7368), "updateWithRoamingSuppression:", v7);
  sub_10013AC04(a1, v5, v11);
LABEL_20:
  CFRelease(v5);
LABEL_21:

}

void sub_1000F6E38(uint64_t a1)
{
  uint64_t v2;
  int v3;
  const void *v4;
  void *v5;
  const void *v6;
  void *v7;

  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
  {
    v3 = *(unsigned __int8 *)(a1 + 3414);
    v4 = (const void *)sub_100029860(v2);
    v5 = sub_10002A21C(a1, v4, 1);
    if (v5)
    {
      v6 = v5;
      sub_10010A578(a1, v3);
      CFRelease(v6);
    }
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "__WiFiDeviceManagerColocatedNetworkTransitionTimerCallback");
    objc_autoreleasePoolPop(v7);
  }
}

void sub_1000F6EFC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  void *v6;
  id v7;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: settlement status=%ld userInfo='%@'", "__WiFiDeviceManagerHandleSettlementChange", a2, a3);
  objc_autoreleasePoolPop(v6);
  if (*(_QWORD *)(v5 + 4392))
  {
    v7 = objc_msgSend(a3, "mutableCopy");
    objc_msgSend(v7, "setObject:forKey:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", a2), CFSTR("settlement"));
    v8 = sub_100029860(*(_QWORD *)(v5 + 64));
    (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, id))(v5 + 4392))(v5, v8, *(_QWORD *)(v5 + 4400), 7, v7);
    if (v7)
      CFRelease(v7);
  }
}

uint64_t sub_1000F6FE8(uint64_t result)
{
  *(_BYTE *)(result + 8960) = 1;
  return result;
}

uint64_t sub_1000F6FF8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8960);
}

uint64_t sub_1000F7004(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  const void *v6;
  const __CFString *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __SCNetworkInterface *ValueAtIndex;
  const __SCNetworkInterface *v13;
  const __CFString *BSDName;
  NSObject *v15;
  int v16;
  char v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  const void *v21;
  void *v22;
  const void *v23;
  void (*v24)(uint64_t, const void *, const __CFString *, const CFBooleanRef, _QWORD);
  uint64_t v25;
  float64x2_t v26;
  const mach_header_64 *v33;
  uint64x2_t v34;
  uint64_t v35;
  const mach_header_64 *v36;
  float64x2_t v37;
  uint64x2_t v38;
  BOOL v40;

  v40 = 0;
  v3 = *(unsigned __int8 *)(a1 + 16);
  if (*(_BYTE *)(a1 + 16))
    return v3;
  v3 = sub_10006BFD4(*(_QWORD **)(a1 + 64), a2, a3);
  if (!(_DWORD)v3)
    return v3;
  *(_BYTE *)(a1 + 16) = 1;
  v5 = *(_QWORD *)(a1 + 64);
  v6 = (const void *)sub_100025C3C(v5);
  *(_DWORD *)(a1 + 20) = sub_100070EB0(v5, v6);
  *(_DWORD *)(a1 + 128) = sub_100070EA0(*(_QWORD *)(a1 + 64));
  *(_OWORD *)(a1 + 132) = xmmword_1001BBC10;
  objc_msgSend(*(id *)(a1 + 3656), "setUsageRankForDeferral:", 3);
  v7 = (const __CFString *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v8 = SCNetworkInterfaceCopyAll();
  Count = CFArrayGetCount(v8);
  if (Count >= 1)
  {
    v10 = Count;
    v11 = 0;
    while (1)
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v8, v11);
      if (ValueAtIndex)
      {
        v13 = ValueAtIndex;
        BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
        if (BSDName)
        {
          if (CFStringCompare(BSDName, v7, 1uLL) == kCFCompareEqualTo)
            break;
        }
      }
      if (v10 == ++v11)
        goto LABEL_9;
    }
    CFRetain(v13);
    if (!v8)
      goto LABEL_11;
    goto LABEL_10;
  }
LABEL_9:
  v13 = 0;
  if (v8)
LABEL_10:
    CFRelease(v8);
LABEL_11:
  *(_QWORD *)(a1 + 5464) = v13;
  *(_BYTE *)(a1 + 33) = sub_100071680(*(_QWORD *)(a1 + 64));
  *(_BYTE *)(a1 + 7042) = sub_100071768(*(_QWORD *)(a1 + 64));
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 5416) = 100;
  v15 = *(NSObject **)(a1 + 240);
  if (v15)
    sub_1000F73B0(a1, v15);
  if (sub_10007168C(*(_QWORD *)(a1 + 64), &v40))
  {
    v16 = v40;
    v17 = 1;
  }
  else
  {
    v17 = 0;
    v16 = 0;
  }
  sub_100041C40(*(_QWORD *)(a1 + 120), v17, v16);
  v18 = *(_QWORD *)(a1 + 64);
  v19 = (const void *)sub_100025C3C(v18);
  v20 = sub_10002BF8C(v18, v19);
  v21 = v20;
  if (v20 && sub_10002DAB4((uint64_t)v20))
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disconnecting from EAP Network %@ on restart", "WiFiDeviceManagerOpen", sub_10002B088(v21));
    objc_autoreleasePoolPop(v22);
    v23 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_1000F7F48(a1, v23, 1010, "WiFiDeviceManagerOpen", 3597);
  }
  v24 = *(void (**)(uint64_t, const void *, const __CFString *, const CFBooleanRef, _QWORD))(a1 + 4744);
  if (v24)
    v24(a1, v21, CFSTR("ForcedDisassoc"), kCFBooleanTrue, *(_QWORD *)(a1 + 4752));
  if (v21)
    CFRelease(v21);
  sub_1000F8284(a1, 0);
  *(_BYTE *)(a1 + 7056) = sub_1000716F8(*(_QWORD *)(a1 + 64));
  *(_BYTE *)(a1 + 7040) = sub_100071704(*(_QWORD *)(a1 + 64));
  *(_BYTE *)(a1 + 7041) = sub_100071710(*(_QWORD *)(a1 + 64));
  sub_1000F83D0(a1);
  sub_1000F8630(a1);
  v25 = 0;
  *(_BYTE *)(a1 + 7400) = 1;
  *(_BYTE *)(a1 + 8600) = 0;
  *(_DWORD *)(a1 + 8601) = 0;
  *(_BYTE *)(a1 + 8605) = 0;
  *(_DWORD *)(a1 + 8606) = 0;
  *(_BYTE *)(a1 + 8610) = 0;
  v26 = (float64x2_t)vdupq_n_s64(0x4044000000000000uLL);
  __asm { FMOV            V2.2D, #10.0 }
  *(_QWORD *)(a1 + 8584) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  v33 = &_mh_execute_header;
  do
  {
    v34.i64[0] = v33;
    v34.i64[1] = HIDWORD(v33);
    *(float64x2_t *)(a1 + 7408 + v25) = vdivq_f64(_Q0, vaddq_f64(vdivq_f64(vsubq_f64(v26, vcvtq_f64_u64(v34)), _Q2), _Q0));
    v33 = (const mach_header_64 *)vadd_s32((int32x2_t)v33, (int32x2_t)0x200000002);
    v25 += 16;
  }
  while (v25 != 320);
  v35 = 0;
  v36 = &_mh_execute_header;
  v37 = (float64x2_t)vdupq_n_s64(0xC059000000000000);
  do
  {
    v38.i64[0] = v36;
    v38.i64[1] = HIDWORD(v36);
    *(float64x2_t *)(a1 + 7728 + v35) = vaddq_f64(vdivq_f64(vcvtq_f64_u64(v38), v37), _Q0);
    v36 = (const mach_header_64 *)vadd_s32((int32x2_t)v36, (int32x2_t)0x200000002);
    v35 += 16;
  }
  while (v35 != 800);
  *(_BYTE *)(a1 + 8640) = 0;
  *(_DWORD *)(a1 + 8616) = 0;
  *(_QWORD *)(a1 + 8624) = 0;
  *(_OWORD *)(a1 + 8644) = 0u;
  *(_OWORD *)(a1 + 8660) = 0u;
  *(_OWORD *)(a1 + 8676) = 0u;
  *(_OWORD *)(a1 + 8692) = 0u;
  *(_OWORD *)(a1 + 8708) = 0u;
  *(_OWORD *)(a1 + 8724) = 0u;
  *(_OWORD *)(a1 + 8740) = 0u;
  *(_QWORD *)(a1 + 8756) = 0;
  *(_DWORD *)(a1 + 8764) = 0;
  return v3;
}

void sub_1000F73B0(uint64_t a1, NSObject *a2)
{
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  NSObject *v8;
  SCDynamicStoreRef v9;
  void *v10;
  void *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  void *v26;
  unsigned int v27;
  void *v28;
  uint64_t v29;
  void (*v30)(uint64_t, _QWORD);
  void *v31;
  uint64_t v32;
  const void *v33;
  void *v34;
  void *v35;
  unsigned int v36;
  void *v37;
  char v38;
  void *v39;
  void *v40;
  id v41;
  id v42;
  const char *v43;
  void *v44;
  int v45;
  unsigned int v46;
  void *v47;
  uint64_t v48;
  int *v49;
  const char *v50;
  void *v51;
  NSObject *v52;
  NSObject *v53;
  void *v54;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v56;
  __CFNotificationCenter *v57;
  __CFNotificationCenter *v58;
  __CFNotificationCenter *v59;
  int *v60;
  char *v61;
  _QWORD v62[5];
  _QWORD v63[5];
  _QWORD v64[5];
  _QWORD v65[5];
  _QWORD v66[5];
  _QWORD v67[5];
  _QWORD v68[5];
  _QWORD v69[5];
  _QWORD v70[5];
  _QWORD v71[5];
  _QWORD v72[5];
  _QWORD v73[5];
  void **v74;
  uint64_t v75;
  uint64_t (*v76)(uint64_t, void *, void *);
  void *v77;
  uint64_t v78;
  void **handler;
  uint64_t v80;
  void *v81;
  void *v82;
  uint64_t v83;
  SCDynamicStoreContext context;
  unsigned int v85;

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceManagerScheduleWithQueue");
  objc_autoreleasePoolPop(v5);
  if (a2)
  {
    if (!*(_BYTE *)(a1 + 16) || *(_QWORD *)(a1 + 240))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: not opened or queue already assigned", "WiFiDeviceManagerScheduleWithQueue");
      goto LABEL_109;
    }
    *(_QWORD *)(a1 + 240) = a2;
    sub_10006C7AC(*(_QWORD *)(a1 + 64), a2);
    sub_1000433EC(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 240));
    v7 = *(NSObject **)(a1 + 312);
    if (v7)
      dispatch_activate(v7);
    v8 = *(NSObject **)(a1 + 360);
    if (v8)
      dispatch_activate(v8);
    if (!*(_QWORD *)(a1 + 5440)
      && (sub_10006FA34(*(_QWORD *)(a1 + 64)) || sub_1000716D8(*(_QWORD *)(a1 + 64))))
    {
      context.version = 0;
      memset(&context.retain, 0, 24);
      context.info = (void *)a1;
      v9 = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("WiFiDeviceManager"), (SCDynamicStoreCallBack)sub_1000F904C, &context);
      *(_QWORD *)(a1 + 5440) = v9;
      if (!v9)
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SCDynamicStoreCreate failed", "WiFiDeviceManagerScheduleWithQueue");
        goto LABEL_27;
      }
      sub_1000F9A60((SCDynamicStoreRef *)a1);
      if (!SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 5440), *(dispatch_queue_t *)(a1 + 240)))
      {
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error setting dynamic store queue.", "WiFiDeviceManagerScheduleWithQueue");
        objc_autoreleasePoolPop(v10);
      }
      if (!SCDynamicStoreSetDisconnectCallBack(*(_QWORD *)(a1 + 5440), sub_1000F9BC8))
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error subscribing to the dynamic store disconnect event.", "WiFiDeviceManagerScheduleWithQueue");
LABEL_27:
        objc_autoreleasePoolPop(v11);
      }
    }
    v12 = *(NSObject **)(a1 + 5240);
    if (v12)
      dispatch_activate(v12);
    v13 = *(NSObject **)(a1 + 5320);
    if (v13)
      dispatch_activate(v13);
    v14 = *(NSObject **)(a1 + 5512);
    if (v14)
      dispatch_activate(v14);
    v15 = *(NSObject **)(a1 + 8592);
    if (v15)
      dispatch_activate(v15);
    v16 = *(NSObject **)(a1 + 8632);
    if (v16)
      dispatch_activate(v16);
    v17 = *(NSObject **)(a1 + 1000);
    if (v17)
      dispatch_activate(v17);
    v18 = *(NSObject **)(a1 + 1056);
    if (v18)
      dispatch_activate(v18);
    v19 = *(NSObject **)(a1 + 5528);
    if (v19)
      dispatch_activate(v19);
    v20 = *(NSObject **)(a1 + 6808);
    if (v20)
      dispatch_activate(v20);
    v21 = *(NSObject **)(a1 + 6816);
    if (v21)
      dispatch_activate(v21);
    v22 = *(NSObject **)(a1 + 7320);
    if (v22)
      dispatch_activate(v22);
    v23 = *(NSObject **)(a1 + 7344);
    if (v23)
      dispatch_activate(v23);
    v24 = *(NSObject **)(a1 + 7216);
    if (v24)
      dispatch_activate(v24);
    v25 = *(NSObject **)(a1 + 7256);
    if (v25)
      dispatch_activate(v25);
    v26 = *(void **)(a1 + 5408);
    if (v26)
    {
      v27 = objc_msgSend(v26, "setupDevice:", a1);
      v28 = objc_autoreleasePoolPush();
      if (v27)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt batteryManager setup", "WiFiDeviceManagerScheduleWithQueue");
      }
      else if (qword_10026DD20)
      {
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt batteryManager setup failed. WiFi will default to full throttle", "WiFiDeviceManagerScheduleWithQueue");
      }
    }
    else
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt No Battery Power Manager support from CoreOS. WiFi will default to full throttle.", "WiFiDeviceManagerScheduleWithQueue");
    }
    objc_autoreleasePoolPop(v28);
    v29 = sub_10002BF80(*(_QWORD *)(a1 + 64));
    if ((_DWORD)v29)
    {
      v30 = *(void (**)(uint64_t, _QWORD))(a1 + 4904);
      if (v30)
        v30(a1, *(_QWORD *)(a1 + 4912));
      v31 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCC : Attempted setting available country code", "WiFiDeviceManagerScheduleWithQueue");
      objc_autoreleasePoolPop(v31);
    }
    sub_1000F9C18(v29, (const void *)a1, 0);
    v32 = *(_QWORD *)(a1 + 64);
    v33 = (const void *)sub_100025C3C(v32);
    v34 = (void *)sub_10002BF8C(v32, v33);
    if (v34)
    {
      v35 = v34;
      v36 = sub_10000BE8C((uint64_t)v34);
      v37 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: associated to %@, isCarplay %d", "WiFiDeviceManagerScheduleWithQueue", sub_10002B088(v35), v36);
      objc_autoreleasePoolPop(v37);
      v38 = 1;
      *(_BYTE *)(a1 + 3411) = 1;
      *(_BYTE *)(a1 + 5496) = v36;
      -[WiFiUserInteractionMonitor updateIsCarPlay:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "updateIsCarPlay:", v36 != 0);
      if (!sub_1000CB8DC((CFDictionaryRef *)v35))
        v38 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isMovingNetwork:", v35);
      sub_1000F9CF0(a1, v38);
      sub_1000F9DAC((char *)a1, 1, 1);
      if (!*(_BYTE *)(a1 + 3412))
        sub_1000F9FBC((unsigned __int8 *)a1);
      CFRelease(v35);
    }
    v62[0] = _NSConcreteStackBlock;
    v62[1] = 3221225472;
    v62[2] = sub_100026530;
    v62[3] = &unk_100231458;
    v62[4] = a1;
    -[WiFiUserInteractionMonitor registerStateChangeCallback:withCallbackContext:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "registerStateChangeCallback:withCallbackContext:", v62, a1);
    if (-[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress"))
    {
      *(_BYTE *)(a1 + 3409) = 1;
      v39 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: call active", "WiFiDeviceManagerScheduleWithQueue");
      objc_autoreleasePoolPop(v39);
    }
    else
    {
      *(_BYTE *)(a1 + 3409) = 0;
      v40 = *(void **)(a1 + 7368);
      if (v40)
        objc_msgSend(v40, "setCallState:", *(_BYTE *)(a1 + 3408) != 0);
    }
    sub_1000F83D0(a1);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v41 = objc_alloc_init((Class)CWFAutoJoinManager);
      *(_QWORD *)(a1 + 8824) = v41;
      if (v41
        && (v42 = objc_alloc_init((Class)NSMutableDictionary), (*(_QWORD *)(a1 + 8896) = v42) != 0))
      {
        context.version = (CFIndex)_NSConcreteStackBlock;
        context.info = (void *)3221225472;
        context.retain = (const void *(__cdecl *)(const void *))sub_100140B30;
        context.release = (void (__cdecl *)(const void *))&unk_100231CA0;
        context.copyDescription = (CFStringRef (__cdecl *)(const void *))a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAllowAutoJoinHandler:", &context);
        handler = _NSConcreteStackBlock;
        v80 = 3221225472;
        v81 = sub_1001418B8;
        v82 = &unk_100231CC0;
        v83 = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAllowKnownNetworkHandler:", &handler);
        objc_msgSend(*(id *)(a1 + 8824), "setKnownNetworkComparator:", 0);
        if (*(_BYTE *)(a1 + 6632))
        {
          v74 = _NSConcreteStackBlock;
          v75 = 3221225472;
          v76 = sub_100141CA4;
          v77 = &unk_100231CE0;
          v78 = a1;
          objc_msgSend(*(id *)(a1 + 8824), "setKnownNetworkComparator:", &v74);
        }
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 3221225472;
        v73[2] = sub_100141D84;
        v73[3] = &unk_100231D00;
        v73[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setScanForNetworksHandler:", v73);
        v72[0] = _NSConcreteStackBlock;
        v72[1] = 3221225472;
        v72[2] = sub_100142778;
        v72[3] = &unk_100231D20;
        v72[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setPerformGASQueryHandler:", v72);
        v71[0] = _NSConcreteStackBlock;
        v71[1] = 3221225472;
        v71[2] = sub_100142BE0;
        v71[3] = &unk_100231D40;
        v71[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAllowJoinCandidateHandler:", v71);
        v70[0] = _NSConcreteStackBlock;
        v70[1] = 3221225472;
        v70[2] = sub_100143004;
        v70[3] = &unk_100231D60;
        v70[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setJoinCandidateComparator:", v70);
        v69[0] = _NSConcreteStackBlock;
        v69[1] = 3221225472;
        v69[2] = sub_1001430DC;
        v69[3] = &unk_100231D80;
        v69[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAssociateToNetworkHandler:", v69);
        v68[0] = _NSConcreteStackBlock;
        v68[1] = 3221225472;
        v68[2] = sub_10014365C;
        v68[3] = &unk_100231DA0;
        v68[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAllowAutoHotspotHandler:", v68);
        v67[0] = _NSConcreteStackBlock;
        v67[1] = 3221225472;
        v67[2] = sub_100143C4C;
        v67[3] = &unk_100231DC0;
        v67[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setAllowHotspotHandler:", v67);
        v66[0] = _NSConcreteStackBlock;
        v66[1] = 3221225472;
        v66[2] = sub_100144230;
        v66[3] = &unk_100231DE0;
        v66[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setBrowseForHotspotsHandler:", v66);
        v65[0] = _NSConcreteStackBlock;
        v65[1] = 3221225472;
        v65[2] = sub_1001444A0;
        v65[3] = &unk_100231E00;
        v65[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setConnectToHotspotHandler:", v65);
        v64[0] = _NSConcreteStackBlock;
        v64[1] = 3221225472;
        v64[2] = sub_1001446C4;
        v64[3] = &unk_100231E20;
        v64[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setEventHandler:", v64);
        v63[0] = _NSConcreteStackBlock;
        v63[1] = 3221225472;
        v63[2] = sub_100144A50;
        v63[3] = &unk_100231E40;
        v63[4] = a1;
        objc_msgSend(*(id *)(a1 + 8824), "setUpdateKnownNetworkHandler:", v63);
        CFRetain((CFTypeRef)a1);
        objc_msgSend(*(id *)(a1 + 8824), "setTargetQueue:", *(_QWORD *)(a1 + 240));
        objc_msgSend(*(id *)(a1 + 8824), "setLockdownModeEnabled:", byte_10026DD61 != 0);
        v43 = "SUCCEEDED";
      }
      else
      {
        v43 = "FAILED";
      }
      v44 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "UAJM setup %s", v43);
      objc_autoreleasePoolPop(v44);
      sub_1000285E4(a1, 8uLL);
    }
    if (*(_BYTE *)(a1 + 433))
      sub_100024EE4(a1, 6);
    if (*(_QWORD *)(a1 + 9008))
    {
      v47 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kernel event monitor already initialized.", "__WiFiDeviceManagerSetupKernelEventMonitor", v61);
      goto LABEL_102;
    }
    v45 = socket(32, 3, 1);
    if ((v45 & 0x80000000) == 0)
    {
      v46 = v45;
      LODWORD(v75) = 2;
      v74 = (void **)(&_mh_execute_header + 1);
      if (ioctl(v45, 0x800C6502uLL, &v74))
      {
        v47 = objc_autoreleasePoolPush();
        v48 = qword_10026DD20;
        if (qword_10026DD20)
        {
          v49 = __error();
          v61 = strerror(*v49);
          v50 = "%s: SIOCSKEVFILT failed (%s)";
LABEL_100:
          v51 = (void *)v48;
LABEL_101:
          objc_msgSend(v51, "WFLog:message:", 4, v50, "__WiFiDeviceManagerSetupKernelEventMonitor", v61);
        }
      }
      else
      {
        v52 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v46, 0, *(dispatch_queue_t *)(a1 + 240));
        *(_QWORD *)(a1 + 9008) = v52;
        if (v52)
        {
          handler = _NSConcreteStackBlock;
          v80 = 3221225472;
          v81 = sub_100145954;
          v82 = &unk_100231E88;
          LODWORD(v83) = v46;
          dispatch_source_set_cancel_handler(v52, &handler);
          v53 = *(NSObject **)(a1 + 9008);
          context.version = (CFIndex)_NSConcreteStackBlock;
          context.info = (void *)3221225472;
          context.retain = (const void *(__cdecl *)(const void *))sub_10014595C;
          context.release = (void (__cdecl *)(const void *))&unk_100230B10;
          v85 = v46;
          context.copyDescription = (CFStringRef (__cdecl *)(const void *))a1;
          dispatch_source_set_event_handler(v53, &context);
          dispatch_activate(*(dispatch_object_t *)(a1 + 9008));
          v54 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kernel event monitor started", "__WiFiDeviceManagerSetupKernelEventMonitor");
          objc_autoreleasePoolPop(v54);
          sub_100145B44(a1);
          goto LABEL_107;
        }
        v47 = objc_autoreleasePoolPush();
        v51 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v50 = "%s: null manager->kernelEventSource";
          goto LABEL_101;
        }
      }
LABEL_102:
      objc_autoreleasePoolPop(v47);
LABEL_107:
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(DarwinNotifyCenter, (const void *)a1, (CFNotificationCallback)sub_1000FAAE4, CFSTR("com.apple.siri.connection.timeout"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      v56 = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(v56, (const void *)a1, (CFNotificationCallback)sub_1000FABD0, CFSTR("com.apple.apsd.connection-failure-notification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      v57 = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(v57, (const void *)a1, (CFNotificationCallback)sub_1000FACBC, CFSTR("com.apple.airplay.connection.stalled"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      v58 = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(v58, (const void *)a1, (CFNotificationCallback)sub_1000FADA8, CFSTR("com.apple.airplay.bufferedaudiounderrun"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      v59 = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(v59, (const void *)a1, (CFNotificationCallback)sub_1000FAE94, CFSTR("com.apple.airplay.realTimeAudioUnderrun"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceManagerScheduleWithQueue");
      goto LABEL_109;
    }
    v47 = objc_autoreleasePoolPush();
    v48 = qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_102;
    v60 = __error();
    v61 = strerror(*v60);
    v50 = "%s: null socket (%s).";
    goto LABEL_100;
  }
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: no queue", "WiFiDeviceManagerScheduleWithQueue");
LABEL_109:
  objc_autoreleasePoolPop(v6);
  objc_autoreleasePoolPop(v4);
}

void sub_1000F7F48(uint64_t a1, const void *a2, uint64_t a3, const char *a4, uint64_t a5)
{
  void (*v10)(uint64_t, const void *, _QWORD, _QWORD, _QWORD, _QWORD);
  const __CFDictionary **v11;
  void *v12;
  void *v13;
  const __CFString *v14;
  const char *v15;
  id v16;
  uint64_t v17;
  const void *v18;
  void *v19;
  CFTypeRef v20;
  NSObject *v21;
  void *v22;
  _QWORD block[6];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[6];
  int v29;

  if (*(_BYTE *)(a1 + 248))
    return;
  v10 = *(void (**)(uint64_t, const void *, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 3888);
  if (v10)
    v10(a1, a2, 0, 0, 0, *(_QWORD *)(a1 + 3896));
  v11 = (const __CFDictionary **)sub_10002A21C(a1, a2, 1);
  v12 = objc_autoreleasePoolPush();
  v13 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v14 = sub_100064AA8(a3);
    v15 = "";
    if (a4)
      v15 = a4;
    objc_msgSend(v13, "WFLog:message:", 3, "%s: network=%@ reason=%@(%d) asked to Disassociate by <%s:%d> ", "WiFiDeviceManagerDisassociate", v11, v14, a3, v15, a5);
  }
  objc_autoreleasePoolPop(v12);
  if (*(_QWORD *)(a1 + 7368))
  {
    v16 = (id)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v17 = *(_QWORD *)(a1 + 7368);
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    v28[2] = sub_10010A834;
    v28[3] = &unk_1002314E0;
    v29 = a3;
    v28[4] = v17;
    v28[5] = v16;
    sub_10010367C(a1, v11, (uint64_t)v28);
  }
  if (sub_10002DAB4((uint64_t)v11))
    sub_100072E44(*(_QWORD *)(a1 + 64), v11, 0);
  if (objc_msgSend(*(id *)(a1 + 6752), "isClientAssociated"))
  {
    if ((_DWORD)a3 != 1027)
    {
      *(_DWORD *)(a1 + 6544) = 1;
      v18 = *(const void **)(a1 + 6552);
      if (v18)
      {
        CFRelease(v18);
        *(_QWORD *)(a1 + 6552) = 0;
      }
      *(_QWORD *)(a1 + 6552) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("User Initiated"));
      *(double *)(a1 + 6488) = sub_100064914();
      objc_msgSend(*(id *)(a1 + 6752), "stopSubscriberForPHSOverNAN");
      if (!v11)
        return;
LABEL_24:
      CFRelease(v11);
      return;
    }
LABEL_23:
    if (!v11)
      return;
    goto LABEL_24;
  }
  sub_100072E54(*(_QWORD *)(a1 + 64), a2, 0, a3);
  sub_100046660(*(_QWORD *)(a1 + 120), 0, 1, 0);
  *(_WORD *)(a1 + 6600) = -1;
  v19 = objc_autoreleasePoolPush();
  objc_msgSend(*(id *)(a1 + 6624), "asyncTrackNetworksOfInterest:", 1);
  objc_autoreleasePoolPop(v19);
  *(_DWORD *)(a1 + 6664) = 0;
  if (!*(_QWORD *)(a1 + 3872))
    goto LABEL_23;
  if (*(_QWORD *)(a1 + 240))
  {
    v24 = 0;
    v25 = &v24;
    v26 = 0x2020000000;
    v27 = 0;
    if (a2)
    {
      v20 = CFRetain(a2);
      v25[3] = (uint64_t)v20;
    }
    CFRetain((CFTypeRef)a1);
    v21 = *(NSObject **)(a1 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10010A884;
    block[3] = &unk_10022F160;
    block[4] = &v24;
    block[5] = a1;
    dispatch_async(v21, block);
    _Block_object_dispose(&v24, 8);
    goto LABEL_23;
  }
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: runloop not yet setup. Invoking didAssociate callback directly.", "WiFiDeviceManagerDisassociate");
  objc_autoreleasePoolPop(v22);
  (*(void (**)(uint64_t, const void *, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 3872))(a1, a2, 0, 0, 0, *(_QWORD *)(a1 + 3880));
  if (v11)
    goto LABEL_24;
}

void sub_1000F826C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000F8284(uint64_t a1, int a2)
{
  void *v3;
  void *v4;
  void *v5;
  const char *v6;

  if (!a1)
    goto LABEL_12;
  if (a2 && !*(_BYTE *)(a1 + 5430))
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting AWDL MAC address in use", "__WiFiDeviceManagerSetAwdlMacAddressInUse");
    objc_autoreleasePoolPop(v3);
    objc_msgSend(+[WiFiP2PSPITransactionRequestor shared](WiFiP2PSPITransactionRequestor, "shared"), "beginTransaction:completionHandler:", 15, 0);
    return;
  }
  if (!a2 && *(_BYTE *)(a1 + 5430))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting AWDL MAC address not in use", "__WiFiDeviceManagerSetAwdlMacAddressInUse");
    objc_autoreleasePoolPop(v4);
    objc_msgSend(+[WiFiP2PSPITransactionRequestor shared](WiFiP2PSPITransactionRequestor, "shared"), "endTransaction:", 15);
  }
  else
  {
LABEL_12:
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v6 = "";
      if (!a2)
        v6 = "not ";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Skip setting AWDL MAC address %sin use, already configured", "__WiFiDeviceManagerSetAwdlMacAddressInUse", v6);
    }
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000F83D0(uint64_t a1)
{
  const void *v2;
  const __CFDictionary **v3;
  void *v4;
  void *v5;
  int v6;
  int v7;
  const __CFString *v8;
  void *v9;
  void *v10;
  int v11;
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  _BOOL8 v17;
  _BOOL8 v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const __CFString *v24;
  void *v25;
  _QWORD v26[6];

  if (a1)
  {
    v2 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v3 = (const __CFDictionary **)sub_10002A21C(a1, v2, 1);
    if (!v2)
      goto LABEL_19;
    v4 = objc_autoreleasePoolPush();
    v5 = *(void **)(a1 + 7368);
    if (v5)
    {
LABEL_18:
      objc_msgSend(v5, "startMonitoringWiFiInterface:withLinkSessionOnly:", v2, 0);
      objc_msgSend(*(id *)(a1 + 7368), "setPowerState:forInterface:", *(_DWORD *)(a1 + 20) == 1, v2);
      objc_msgSend(*(id *)(a1 + 7368), "setCurrentApplicationName:withAttributes:", *(_QWORD *)(a1 + 200), 0);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_1001408EC;
      v26[3] = &unk_1002315B0;
      v26[4] = a1;
      v26[5] = v2;
      sub_10010367C(a1, v3, (uint64_t)v26);
      objc_autoreleasePoolPop(v4);
LABEL_19:
      if (v3)
        CFRelease(v3);
      return;
    }
    v25 = v4;
    v6 = *(_DWORD *)(a1 + 176);
    *(_QWORD *)(a1 + 7368) = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
    v7 = *(_DWORD *)(a1 + 72);
    if (v7 == 4)
    {
      v8 = CFSTR("en0");
    }
    else
    {
      if (v7 == 7)
      {
        v24 = 0;
LABEL_10:
        v9 = objc_autoreleasePoolPush();
        v10 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v11 = sub_100031A74(*(_QWORD *)(a1 + 6792));
          v12 = CFSTR("NO");
          if (!v11)
            v12 = CFSTR("YES");
          objc_msgSend(v10, "WFLog:message:", 3, "%s: mode:%@", "__WiFiDeviceManagerInitializeWiFiUsageMonitor", v12);
        }
        objc_autoreleasePoolPop(v9);
        v13 = sub_100048110(*(_QWORD *)(a1 + 120));
        v15 = v14;
        v22 = v13;
        v23 = *(void **)(a1 + 7368);
        v16 = sub_100024674(*(_DWORD *)(a1 + 3352));
        if (*(_BYTE *)(a1 + 3409))
          v17 = 1;
        else
          v17 = *(_BYTE *)(a1 + 3408) != 0;
        v18 = *(_BYTE *)(a1 + 3410) != 0;
        v19 = *(_BYTE *)(a1 + 3464) != 0;
        LOBYTE(v21) = sub_100031A74(*(_QWORD *)(a1 + 6792)) == 0;
        LOBYTE(v20) = 0;
        objc_msgSend(v23, "initializeDeviceLockState:displayState:motionState:callState:mediaState:chargingState:companionConnectionState:andSecondaryInterfaceName:compatibilityMode:badLinkRssi:goodLinkRssi:", v6 != 1, (v6 - 1) < 2, v16, v17, v18, v19, v20, v24, v21, v22, v15);
        v5 = *(void **)(a1 + 7368);
        v4 = v25;
        goto LABEL_18;
      }
      v8 = *(const __CFString **)(a1 + 6200);
    }
    v24 = v8;
    goto LABEL_10;
  }
}

void sub_1000F8630(uint64_t a1)
{
  void *v2;
  __CFDictionary *v3;
  __CFDictionary *v4;
  id v5;
  id v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  _BYTE *v12;
  void *v13;
  const void *v14;
  void *v15;
  const void *v16;
  NSObject *v17;
  dispatch_time_t v18;
  void *v19;
  uint64_t v20;
  const void *v21;
  void *v22;
  void *v23;
  _QWORD v24[5];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  uint64_t v30;

  v2 = objc_autoreleasePoolPush();
  v25 = 0;
  v26 = &v25;
  v27 = 0x3052000000;
  v28 = sub_10002FAA8;
  v29 = sub_10002F9A4;
  v30 = 0;
  if (a1)
  {
    if (sub_100075280(*(_QWORD *)(a1 + 64)))
    {
      v3 = sub_10011D61C(a1, &off_1002540B8);
      v4 = v3;
      if (v3)
      {
        if (CFDictionaryContainsKey(v3, CFSTR("networks")))
        {
          v5 = -[__CFDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", CFSTR("networks"));
          v6 = -[__CFDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", CFSTR("reasons"));
          if (v5
            && (v7 = v6, v8 = objc_msgSend(v5, "count"), v8 == objc_msgSend(v7, "count"))
            && objc_msgSend(v7, "count"))
          {
            v9 = +[NSMutableArray array](NSMutableArray, "array");
            v26[5] = (uint64_t)v9;
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 3221225472;
            v24[2] = sub_10011DC88;
            v24[3] = &unk_100231668;
            v24[4] = &v25;
            objc_msgSend(v5, "enumerateObjectsUsingBlock:", v24);
          }
          else
          {
            v22 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No networks denylisted in BSS and AutoJoin denylists", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate");
            objc_autoreleasePoolPop(v22);
          }
          if (*(_QWORD *)(a1 + 7328)
            && objc_msgSend(*(id *)(a1 + 7328), "isEqualToSet:", +[NSSet setWithArray:](NSSet, "setWithArray:", v26[5])))
          {
            v10 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s No change in DenyListed BSSIDSet. Skipping driver update. %@", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate", *(_QWORD *)(a1 + 7328));
            objc_autoreleasePoolPop(v10);
          }
          else
          {
            v11 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
            v12 = (_BYTE *)(a1 + 7312);
            v13 = (void *)v26[5];
            if (v13 && objc_msgSend(v13, "count"))
            {
              objc_msgSend(v11, "setObject:forKey:", +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", 3), CFSTR("IO80211InterfaceBssidBlacklistMode"));
              objc_msgSend(v11, "setObject:forKey:", v26[5], CFSTR("IO80211InterfaceBssidBlacklistBssids"));
              v14 = *(const void **)(a1 + 7328);
              if (v14)
              {
                CFRelease(v14);
                *(_QWORD *)(a1 + 7328) = 0;
              }
              *(_QWORD *)(a1 + 7328) = CFSetCreateCopy(kCFAllocatorDefault, (CFSetRef)+[NSSet setWithArray:](NSSet, "setWithArray:", v26[5]));
              if (*v12)
              {
                v15 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DenyListed BSSIDSet expiry timer already running", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate");
              }
              else
              {
                *v12 = 1;
                v17 = *(NSObject **)(a1 + 7320);
                v18 = dispatch_time(0, 600000000000);
                dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
                v15 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DenyListed BSSIDSet expiry timer set to fire in %f seconds from now", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate", 0x4082C00000000000);
              }
            }
            else
            {
              objc_msgSend(v11, "setObject:forKey:", +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", 0), CFSTR("IO80211InterfaceBssidBlacklistMode"));
              v16 = *(const void **)(a1 + 7328);
              if (v16)
              {
                CFRelease(v16);
                *(_QWORD *)(a1 + 7328) = 0;
              }
              *v12 = 0;
              dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 7320), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
              v15 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DenyListed BSSIDSet expiry timer set to fire never", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate");
            }
            objc_autoreleasePoolPop(v15);
            v19 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate", v11);
            objc_autoreleasePoolPop(v19);
            v20 = *(_QWORD *)(a1 + 64);
            v21 = (const void *)sub_100025C3C(v20);
            sub_1000672C0(v20, v21, 372, 0, (uint64_t)v11);
          }
        }
        else
        {
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s networks key missing", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate");
          objc_autoreleasePoolPop(v23);
        }
        CFRelease(v4);
      }
    }
  }
  _Block_object_dispose(&v25, 8);
  objc_autoreleasePoolPop(v2);
}

void sub_1000F8AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000F8AF4(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 240);
  if (v2)
    sub_1000F8B54(a1, v2);
  v3 = *(const void **)(a1 + 5464);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 5464) = 0;
  }
  v4 = *(const void **)(a1 + 5584);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5584) = 0;
  }
  sub_10006DB04(*(_QWORD *)(a1 + 64));
  *(_BYTE *)(a1 + 16) = 0;
}

void sub_1000F8B54(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v8;
  __CFNotificationCenter *v9;
  __CFNotificationCenter *v10;
  __CFNotificationCenter *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  void *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceManagerUnscheduleFromQueue");
  objc_autoreleasePoolPop(v4);
  if (*(_BYTE *)(a1 + 16) && *(_QWORD *)(a1 + 240) == a2)
  {
    sub_1000FAF80((const void *)a1);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, CFSTR("com.apple.wifid.wifiroammanagerroamnotification"), 0);
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(DarwinNotifyCenter, (const void *)a1, CFSTR("com.apple.siri.connection.timeout"), 0);
    v8 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v8, (const void *)a1, CFSTR("com.apple.apsd.connection-failure-notification"), 0);
    v9 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v9, (const void *)a1, CFSTR("com.apple.airplay.connection.stalled"), 0);
    v10 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v10, (const void *)a1, CFSTR("com.apple.airplay.bufferedaudiounderrun"), 0);
    v11 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v11, (const void *)a1, CFSTR("com.apple.airplay.realTimeAudioUnderrun"), 0);
    SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 5440), 0);
    v12 = *(NSObject **)(a1 + 360);
    if (v12)
      dispatch_source_cancel(v12);
    v13 = *(NSObject **)(a1 + 312);
    if (v13)
      dispatch_source_cancel(v13);
    v14 = *(NSObject **)(a1 + 5240);
    if (v14)
      dispatch_source_cancel(v14);
    v15 = *(NSObject **)(a1 + 5320);
    if (v15)
      dispatch_source_cancel(v15);
    v16 = *(NSObject **)(a1 + 5512);
    if (v16)
      dispatch_source_cancel(v16);
    v17 = *(NSObject **)(a1 + 8592);
    if (v17)
      dispatch_source_cancel(v17);
    v18 = *(NSObject **)(a1 + 8632);
    if (v18)
      dispatch_source_cancel(v18);
    v19 = *(NSObject **)(a1 + 1000);
    if (v19)
      dispatch_source_cancel(v19);
    v20 = *(NSObject **)(a1 + 1056);
    if (v20)
      dispatch_source_cancel(v20);
    v21 = *(NSObject **)(a1 + 5528);
    if (v21)
      dispatch_source_cancel(v21);
    v22 = *(NSObject **)(a1 + 6808);
    if (v22)
      dispatch_source_cancel(v22);
    v23 = *(NSObject **)(a1 + 6816);
    if (v23)
      dispatch_source_cancel(v23);
    v24 = *(NSObject **)(a1 + 7320);
    if (v24)
      dispatch_source_cancel(v24);
    v25 = *(NSObject **)(a1 + 7344);
    if (v25)
      dispatch_source_cancel(v25);
    v26 = *(NSObject **)(a1 + 7216);
    if (v26)
      dispatch_source_cancel(v26);
    v27 = *(NSObject **)(a1 + 7256);
    if (v27)
      dispatch_source_cancel(v27);
    v28 = *(NSObject **)(a1 + 8968);
    if (v28)
    {
      dispatch_source_cancel(v28);
      dispatch_release(*(dispatch_object_t *)(a1 + 8968));
      *(_QWORD *)(a1 + 8968) = 0;
    }
    v29 = *(void **)(a1 + 7072);
    if (v29)
    {
      objc_msgSend(v29, "abort");

      *(_QWORD *)(a1 + 7072) = 0;
    }
    v30 = *(NSObject **)(a1 + 8984);
    if (v30)
      dispatch_source_cancel(v30);
    v31 = *(NSObject **)(a1 + 8992);
    if (v31)
      dispatch_source_cancel(v31);
    v32 = *(NSObject **)(a1 + 3768);
    if (v32)
    {
      dispatch_source_cancel(v32);
      dispatch_release(*(dispatch_object_t *)(a1 + 3768));
      *(_QWORD *)(a1 + 3768) = 0;
    }
    if (sub_10006FA28(*(_QWORD *)(a1 + 64)))
    {
      v33 = (const void *)sub_100068E60(*(_QWORD *)(a1 + 64));
      sub_1000FB00C(a1, v33);
    }
    if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance")
      && -[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
    {
      sub_1000247B8(*(_QWORD *)(a1 + 120), 0, 0);
      -[WiFiAIRAgent terminateRequest](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "terminateRequest");
    }
    sub_10006DB74(*(_QWORD *)(a1 + 64));
    sub_100043800(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 240));
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      objc_msgSend(*(id *)(a1 + 8824), "setEventHandler:", 0);
      objc_msgSend(*(id *)(a1 + 8824), "invalidate");

      *(_QWORD *)(a1 + 8824) = 0;
      v34 = *(_QWORD *)(a1 + 8928);
      if (v34)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD, _QWORD))(v34 + 16))(v34, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 58, 0), 0, 0);
        _Block_release(*(const void **)(a1 + 8928));
        *(_QWORD *)(a1 + 8928) = 0;

        *(_QWORD *)(a1 + 8936) = 0;
      }
      v35 = *(_QWORD *)(a1 + 8944);
      if (v35)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD, _QWORD))(v35 + 16))(v35, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 58, 0), 0, 0);
        _Block_release(*(const void **)(a1 + 8944));
        *(_QWORD *)(a1 + 8944) = 0;

        *(_QWORD *)(a1 + 8952) = 0;
      }
      v36 = *(_QWORD *)(a1 + 8840);
      if (v36)
      {
        (*(void (**)(uint64_t, NSError *))(v36 + 16))(v36, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 58, 0));
        _Block_release(*(const void **)(a1 + 8840));
        *(_QWORD *)(a1 + 8840) = 0;
        v37 = *(const void **)(a1 + 8832);
        if (v37)
        {
          CFRelease(v37);
          *(_QWORD *)(a1 + 8832) = 0;
        }
      }
      v38 = *(_QWORD *)(a1 + 8864);
      if (v38)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD))(v38 + 16))(v38, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 58, 0), 0);
        _Block_release(*(const void **)(a1 + 8864));
        *(_QWORD *)(a1 + 8864) = 0;
      }
      v39 = *(_QWORD *)(a1 + 8856);
      if (v39)
      {
        (*(void (**)(uint64_t, NSError *))(v39 + 16))(v39, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 58, 0));
        _Block_release(*(const void **)(a1 + 8856));
        *(_QWORD *)(a1 + 8856) = 0;

        *(_QWORD *)(a1 + 8848) = 0;
      }

      *(_QWORD *)(a1 + 8896) = 0;
      *(_QWORD *)(a1 + 8904) = 0;
      CFRelease((CFTypeRef)a1);
    }
    -[WiFiUserInteractionMonitor unregisterStateChangeCallback:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "unregisterStateChangeCallback:", a1);
    sub_1000FB144(a1);
    *(_QWORD *)(a1 + 240) = 0;
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceManagerUnscheduleFromQueue");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: not opened or unmatched queues", "WiFiDeviceManagerUnscheduleFromQueue");
  }
  objc_autoreleasePoolPop(v5);
}

uint64_t sub_1000F9044(uint64_t a1)
{
  return sub_10006FA34(*(_QWORD *)(a1 + 64));
}

void sub_1000F904C(int a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex v5;
  const void *ValueAtIndex;
  const void *v7;
  CFTypeID TypeID;
  int v9;
  const __SCDynamicStore *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  CFTypeID v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  CFTypeID v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  const __CFNumber *v20;
  void *v21;
  void *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  void *v25;
  _BYTE *v26;
  char v27;
  char v28;
  char v29;
  const void *v30;
  void *v31;
  const void *v32;
  void *v33;
  void *v34;
  _BOOL4 v35;
  const void *v36;
  int v37;
  int v38;
  void *v39;
  const char *v40;
  int v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFDictionary *v44;
  const __CFDictionary *v45;
  const void *Value;
  const void *v47;
  uint64_t v48;
  void *v49;
  int v50;
  void *v51;
  void *v52;
  void *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 valuePtr;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  __int16 v70;

  if (!a3)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceManagerDynamicStoreCallback: manager reference is NULL", v55, v56, v57, v58);
LABEL_26:
    objc_autoreleasePoolPop(v21);
    return;
  }
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    v5 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      if (ValueAtIndex)
      {
        v7 = ValueAtIndex;
        TypeID = CFStringGetTypeID();
        if (CFGetTypeID(v7) == TypeID)
        {
          if (CFEqual(v7, CFSTR("com.apple.sharing")))
            break;
        }
      }
      if (++v5 >= CFArrayGetCount(theArray))
        goto LABEL_9;
    }
    if (*(_BYTE *)(a3 + 208))
      v35 = *(_BYTE *)(a3 + 3464) == 0;
    else
      v35 = 0;
    v42 = SCDynamicStoreKeyCreate(kCFAllocatorDefault, CFSTR("%@"), CFSTR("com.apple.sharing"));
    if (v42)
    {
      v43 = v42;
      v44 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a3 + 5440), v42);
      if (v44)
      {
        v45 = v44;
        Value = CFDictionaryGetValue(v44, CFSTR("AutoUnlockInProgress"));
        if (Value && CFEqual(Value, kCFBooleanTrue))
        {
          if (*(_DWORD *)(a3 + 3280))
          {
            v47 = (const void *)sub_100029860(*(_QWORD *)(a3 + 64));
            sub_10010A9B0((uint64_t *)a3, v47, 1014);
            sub_1000FB44C(a3);
          }
          v48 = 1;
        }
        else
        {
          v49 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Auto-unlock not in progress. Resuming auto-join attempt.", "__WiFiDeviceManagerDynamicStoreCallback");
          objc_autoreleasePoolPop(v49);
          v48 = 0;
        }
        sub_100113150(a3, v48);
        CFRelease(v45);
      }
      else
      {
        v48 = 0;
      }
      CFRelease(v43);
    }
    else
    {
      v48 = 0;
    }
    if ((_DWORD)v48)
      v50 = 1;
    else
      v50 = v35;
    sub_1000F8284(a3, v50);
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: awdlMacAddressInUse=%d isDeviceLockedAndSuspendable=%d shouldDisassociate=%d", "__WiFiDeviceManagerDynamicStoreCallback", v48, v35, 0);
    goto LABEL_26;
  }
LABEL_9:
  if (sub_10006FA34(*(_QWORD *)(a3 + 64)))
  {
    v9 = sub_1001076C4(a3);
    if (!v9)
    {
      *(_BYTE *)(a3 + 5362) = 0;
      *(_WORD *)(a3 + 5360) = 0;
    }
    if (objc_opt_class(CHSControlService))
      dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_100231A70);
    LOBYTE(valuePtr) = 0;
    v70 = 0;
    v10 = *(const __SCDynamicStore **)(a3 + 5440);
    if (v10)
    {
      if (qword_10026D760)
      {
        v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(v10, (CFStringRef)qword_10026D760);
        if (v11)
        {
          v12 = v11;
          v13 = CFGetTypeID(v11);
          if (v13 == CFDictionaryGetTypeID())
          {
            v14 = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("Hosts"));
            if (v14)
            {
              v15 = v14;
              v16 = CFGetTypeID(v14);
              if (v16 == CFDictionaryGetTypeID())
              {
                v17 = (const __CFDictionary *)CFDictionaryGetValue(v15, CFSTR("Type"));
                if (v17)
                {
                  v18 = v17;
                  v19 = CFGetTypeID(v17);
                  if (v19 == CFDictionaryGetTypeID())
                  {
                    v20 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AirPort"));
                    if (v20)
                      CFNumberGetValue(v20, kCFNumberSInt8Type, &valuePtr);
                    else
                      LOBYTE(valuePtr) = *(_BYTE *)(a3 + 5360);
                    v23 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("Bluetooth"));
                    if (v23)
                      CFNumberGetValue(v23, kCFNumberSInt8Type, (char *)&v70 + 1);
                    else
                      HIBYTE(v70) = *(_BYTE *)(a3 + 5361);
                    v24 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("USB-Ethernet"));
                    if (v24)
                      CFNumberGetValue(v24, kCFNumberSInt8Type, &v70);
                    else
                      LOBYTE(v70) = *(_BYTE *)(a3 + 5362);
                    v25 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client count: WiFi %d, BT %d, USB %d ", "__WiFiDeviceManagerHotspotTransportTypeMetric", valuePtr, HIBYTE(v70), v70);
                    objc_autoreleasePoolPop(v25);
                    v26 = malloc_type_malloc(3uLL, 0x100004033FC2DF1uLL);
                    v27 = valuePtr;
                    *v26 = valuePtr;
                    v28 = HIBYTE(v70);
                    v26[1] = HIBYTE(v70);
                    v29 = v70;
                    v26[2] = v70;
                    *(_BYTE *)(a3 + 5360) = v27;
                    *(_BYTE *)(a3 + 5361) = v28;
                    *(_BYTE *)(a3 + 5362) = v29;
                    sub_100051888((uint64_t)v26);
                    CFRelease(v12);
                    free(v26);
LABEL_40:
                    if (v9)
                    {
                      v30 = (const void *)sub_100025C3C(*(_QWORD *)(a3 + 64));
                      v31 = sub_10002A21C(a3, v30, 1);
                      if (v31)
                      {
                        v32 = v31;
                        if (*(unsigned __int8 *)(a3 + 5361) != -*(_BYTE *)(a3 + 5360))
                        {
                          v33 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS client count: wifi=%d bt=%d. Now disconnecting from %@", *(unsigned __int8 *)(a3 + 5360), *(unsigned __int8 *)(a3 + 5361), sub_10002B088(v32));
                          objc_autoreleasePoolPop(v33);
                          if (sub_100107828(a3, 4))
                          {
                            sub_1000FE648((uint64_t *)a3, v32, 1, 3);
                            v34 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting interface rank %s : reason %s ", "__WiFiDeviceManagerDynamicStoreCallback", "kSCNetworkServicePrimaryRankNever", " Concurrency");
                            objc_autoreleasePoolPop(v34);
                          }
                          else
                          {
                            v36 = (const void *)sub_100025C3C(*(_QWORD *)(a3 + 64));
                            sub_1000F7F48(a3, v36, 1007, "__WiFiDeviceManagerDynamicStoreCallback", 25315);
                          }
                        }
                        CFRelease(v32);
                      }
                    }
                    v37 = *(unsigned __int8 *)(a3 + 5220);
                    if (v9 == v37)
                    {
                      v53 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                      {
                        if (v9)
                          v54 = "Enabled";
                        else
                          v54 = "Disabled";
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS is already %s on %@", v54, sub_100070E94());
                      }
                      objc_autoreleasePoolPop(v53);
                      if (!v9)
                      {
                        _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
LABEL_118:
                        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 10, sub_100025C3C(*(_QWORD *)(a3 + 64)));
                        sub_1000FBA80(a3, 2, (uint64_t)"__WiFiDeviceManagerDynamicStoreCallback");
                        return;
                      }
                    }
                    else
                    {
                      *(_BYTE *)(a3 + 5220) = v9;
                      v38 = *(unsigned __int8 *)(a3 + 5219);
                      v39 = objc_autoreleasePoolPush();
                      if (v9 == v38)
                      {
                        if (qword_10026DD20)
                        {
                          if (v9)
                            v40 = "Enabled";
                          else
                            v40 = "Disabled";
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS is already %s on %@", v40, sub_100070E94());
                        }
                        objc_autoreleasePoolPop(v39);
                        return;
                      }
                      if (!v9)
                      {
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Disabled: Attempting to disable MIS Service");
                        objc_autoreleasePoolPop(v39);
                        v69 = 0;
                        v67 = 0u;
                        v68 = 0u;
                        v65 = 0u;
                        v66 = 0u;
                        v63 = 0u;
                        v64 = 0u;
                        v61 = 0u;
                        v62 = 0u;
                        valuePtr = 0u;
                        v60 = 0u;
                        DWORD2(valuePtr) = 5;
                        LODWORD(v66) = 5;
                        *((_QWORD *)&v66 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Dynamic Store"));
                        sub_100106C34(a3, (uint64_t)&valuePtr);
                        *(_BYTE *)(a3 + 5384) = 0;
                        sub_100107084(a3);
LABEL_70:
                        v41 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
                        if (v9 != v37 && v41)
                        {
                          sub_1000285E4(a3, 0xAuLL);
                          return;
                        }
                        goto LABEL_118;
                      }
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Enabled: Attempting to enable MIS Service, misIsHidden %d misBcastClients %ld misIsNANPHS %d", *(unsigned __int8 *)(a3 + 5260), CFSetGetCount(*(CFSetRef *)(a3 + 5272)), *(unsigned __int8 *)(a3 + 5386));
                      objc_autoreleasePoolPop(v39);
                      v69 = 0;
                      v67 = 0u;
                      v68 = 0u;
                      v65 = 0u;
                      v66 = 0u;
                      v63 = 0u;
                      v64 = 0u;
                      v61 = 0u;
                      v62 = 0u;
                      valuePtr = 0u;
                      v60 = 0u;
                      LODWORD(valuePtr) = 4;
                      sub_100106C34(a3, (uint64_t)&valuePtr);
                      sub_100107ABC(a3);
                      sub_100107DE4(a3, 1);
                    }
                    if (*(unsigned __int8 *)(a3 + 5361) != -*(_BYTE *)(a3 + 5360))
                      return;
                    goto LABEL_70;
                  }
                  v52 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid typeDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
                }
                else
                {
                  v52 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null typeDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
                }
              }
              else
              {
                v52 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid hostsDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
              }
            }
            else
            {
              v52 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null hostsDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
            }
          }
          else
          {
            v52 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid misDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
          }
          objc_autoreleasePoolPop(v52);
          CFRelease(v12);
          goto LABEL_40;
        }
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null misDict", "__WiFiDeviceManagerHotspotTransportTypeMetric");
      }
      else
      {
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null dynamicstoreref keys", "__WiFiDeviceManagerHotspotTransportTypeMetric");
      }
    }
    else
    {
      v51 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null dynamicstoreref", "__WiFiDeviceManagerHotspotTransportTypeMetric");
    }
    objc_autoreleasePoolPop(v51);
    goto LABEL_40;
  }
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceManagerDynamicStoreCallback: MIS not supported on device");
  objc_autoreleasePoolPop(v22);
  v69 = 0;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  valuePtr = 0u;
  v60 = 0u;
  DWORD1(valuePtr) = 3;
  sub_100106C34(a3, (uint64_t)&valuePtr);
}

void sub_1000F9A60(SCDynamicStoreRef *a1)
{
  CFMutableArrayRef Mutable;
  __CFArray *v3;
  CFStringRef v4;
  CFStringRef v5;
  _QWORD v6[6];
  _QWORD v7[3];
  CFTypeRef v8;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    v3 = Mutable;
    v4 = SCDynamicStoreKeyCreate(kCFAllocatorDefault, CFSTR("com.apple.sharing"));
    if (v4)
    {
      v5 = v4;
      CFArrayAppendValue(v3, v4);
      CFRelease(v5);
    }
    if (qword_10026D760)
    {
      CFArrayAppendValue(v3, (const void *)qword_10026D760);
      if (CFArrayGetCount(v3) > 0)
        SCDynamicStoreSetNotificationKeys(a1[680], v3, 0);
      CFRelease(v3);
    }
    else
    {
      v7[0] = 0;
      v7[1] = v7;
      v7[2] = 0x2020000000;
      v8 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      v8 = CFRetain(v3);
      CFRetain(a1);
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472;
      v6[2] = sub_1001395D8;
      v6[3] = &unk_10022F160;
      v6[4] = v7;
      v6[5] = a1;
      dispatch_async((dispatch_queue_t)qword_10026DD40, v6);
      CFRelease(v3);
      _Block_object_dispose(v7, 8);
    }
  }
}

void sub_1000F9BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000F9BC8(uint64_t a1, SCDynamicStoreRef *a2)
{
  void *v2;

  if (a2)
  {
    sub_1000F9A60(a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Cannot reconnect to the dynamic store - info is NULL");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000F9C18(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  _QWORD v7[5];

  v5 = objc_autoreleasePoolPush();
  if (a2 && &_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiDeviceManagerNowPlayingStateDidChange", a3);
    objc_autoreleasePoolPop(v6);
    CFRetain(a2);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_10013D26C;
    v7[3] = &unk_100231BD0;
    v7[4] = a2;
    MRMediaRemoteGetNowPlayingApplicationPlaybackState(qword_10026DD40, v7);
  }
  objc_autoreleasePoolPop(v5);
}

uint64_t sub_1000F9CF0(uint64_t a1, char a2)
{
  void *v3;
  const char *v4;
  uint64_t v5;
  const void *v6;
  uint64_t *v7;

  *(_BYTE *)(a1 + 3412) = a2;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 3412))
      v4 = "TRUE";
    else
      v4 = "FALSE";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isOnMovingNetwork: %s", "__WiFiDeviceManagerMovingNetworkNotifyFamily", v4);
  }
  objc_autoreleasePoolPop(v3);
  v5 = *(_QWORD *)(a1 + 64);
  v6 = (const void *)sub_100025C3C(v5);
  if (*(_BYTE *)(a1 + 3412))
    v7 = (uint64_t *)&kCFBooleanTrue;
  else
    v7 = (uint64_t *)&kCFBooleanFalse;
  return sub_1000672C0(v5, v6, 471, 0, *v7);
}

char *sub_1000F9DAC(char *result, char a2, int a3)
{
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 v5;
  uint64_t v8;
  void *v9;
  void *v10;
  const __CFString *v11;
  double v12;
  void (*v13)(uint64_t, _QWORD, _QWORD, _QWORD);
  const void *v14;
  void *v15;
  const void *v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  _OWORD v20[10];
  uint64_t v21;

  v3 = (unsigned __int8 *)(result + 7056);
  v4 = result[7057];
  if (a3)
    v5 = v4 | a2;
  else
    v5 = v4 & ~a2;
  if (v5 == v4)
    return result;
  v8 = (uint64_t)result;
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v11 = sub_100064C9C(v3[1]);
    objc_msgSend(v10, "WFLog:message:", 3, "%s: current state %@(%d) new state %@(%d)", "WiFiDeviceManagerUpdateOpMode", v11, v3[1], sub_100064C9C(v5), v5);
  }
  objc_autoreleasePoolPop(v9);
  v3[1] = v5;
  v13 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v8 + 4648);
  if (v13)
    v13(v8, *v3, v5, *(_QWORD *)(v8 + 4656));
  if ((a2 & 4) != 0)
  {
    v14 = (const void *)sub_100025C3C(*(_QWORD *)(v8 + 64));
    v15 = sub_10002A21C(v8, v14, 1);
    v16 = v15;
    if (*v3 && (v5 & 1) != 0 && v15)
    {
      if (a3)
        v17 = 3;
      else
        v17 = 0;
      sub_1000FE648((uint64_t *)v8, v15, 1, v17);
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v19 = "kSCNetworkServicePrimaryRankNever";
        if (!a3)
          v19 = "kSCNetworkServicePrimaryRankDefault";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting interface rank %s : reason %s ", "WiFiDeviceManagerUpdateOpMode", v19, " Concurrency");
      }
      objc_autoreleasePoolPop(v18);
    }
    else if (!v15)
    {
LABEL_23:
      sub_10011B44C(v8);
      goto LABEL_24;
    }
    CFRelease(v16);
    goto LABEL_23;
  }
LABEL_24:
  if ((a2 & 2) != 0 && (v3[1] & 8) != 0)
  {
    memset(v20, 0, sizeof(v20));
    v21 = 1;
    v12 = sub_100106C34(v8, (uint64_t)v20);
  }
  result = (char *)objc_msgSend(*(id *)(v8 + 6752), "isClientAssociated", v12);
  if ((_DWORD)result)
    *(_BYTE *)(v8 + 6561) = 1;
  return result;
}

void sub_1000F9FBC(unsigned __int8 *a1)
{
  void *v2;
  __CFNotificationCenter *LocalCenter;
  uint64_t v4;

  if (&_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s, isCarplay %d, user forced %d", "__WiFiDeviceManagerAddMediaPlaybackStateObserver", a1[5496], a1[3413]);
    objc_autoreleasePoolPop(v2);
    if (!a1[5496] && !a1[3413])
    {
      MRMediaRemoteRegisterForNowPlayingNotifications(qword_10026DD40);
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterAddObserver(LocalCenter, a1, (CFNotificationCallback)sub_1000F9C18, kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      sub_1000F9C18(v4, a1, (uint64_t)CFSTR("Reading Initial State"));
    }
  }
}

void sub_1000FA0A0(uint64_t a1, int a2)
{
  void *v4;
  void *v5;
  const void **v6;
  const void *v7;
  const void *v8;
  void *v9;
  void *v10;
  id v11;
  unsigned int v12;
  void *v13;
  CFTypeRef *v14;
  void *v15;
  double v16;
  void *v17;
  const __CFArray *v18;
  void *v19;
  const void *v20;
  CFIndex v21;
  const void *ValueAtIndex;
  int v23;
  void *v24;
  CFDictionaryRef *v25;
  CFDictionaryRef *v26;
  void *v27;
  const __CFArray *v28;
  int Count;
  __CFArray *Mutable;
  const __CFArray *v31;
  const __CFArray *v32;
  void *v33;
  void *v34;
  CFIndex v35;
  uint64_t v36;
  CFRange v37;
  CFRange v38;
  CFRange v39;

  v4 = objc_autoreleasePoolPush();
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not allowed with Unified Auto-Join", "__WiFiDeviceManagerAttemptNetworkTransition", v36);
    goto LABEL_15;
  }
  if (a2 == 6)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s trigger is kWiFiMetricsNetworkTransitionNetworkOfInterest, reset last transtion scan time + time since linkup so we attempt transtion regardles of last attempt time", "__WiFiDeviceManagerAttemptNetworkTransition");
    objc_autoreleasePoolPop(v5);
    *(_QWORD *)(a1 + 3416) = 0;
    *(_QWORD *)(a1 + 3400) = 0;
    *(_DWORD *)(a1 + 3392) = 0;
    if (*(_QWORD *)(a1 + 6608))
    {
      v6 = (const void **)(a1 + 6608);
      goto LABEL_13;
    }
  }
  else
  {
    v7 = *(const void **)(a1 + 6608);
    if (v7)
    {
      v6 = (const void **)(a1 + 6608);
      if (a2 != 7)
      {
LABEL_13:
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Not attempting transition when colocatedScopeTransition network  %@ is set.. Bailing", "__WiFiDeviceManagerAttemptNetworkTransition", sub_10002B088(*v6));
LABEL_15:
        objc_autoreleasePoolPop(v10);
        goto LABEL_83;
      }
      sub_10013D488((CFArrayRef *)a1, v7);
      v8 = *(const void **)(a1 + 6608);
      *(_BYTE *)(a1 + 6616) = 1;
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Top network for colocatedScopeTransition: %@", "__WiFiDeviceManagerAttemptNetworkTransition", sub_10002B088(*v6));
      objc_autoreleasePoolPop(v9);
      if (v8)
        goto LABEL_82;
      goto LABEL_83;
    }
    if ((a2 & 0xFFFFFFFE) != 6 && !sub_10013D5A0(a1))
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not now...", "__WiFiDeviceManagerAttemptNetworkTransition", v36);
      goto LABEL_15;
    }
  }
  v11 = sub_100009ACC(a1);
  if (v11)
  {
    +[WiFiLocationManager logLocation:addPrefixString:](WiFiLocationManager, "logLocation:addPrefixString:", v11, CFSTR("__WiFiDeviceManagerAttemptNetworkTransition"));
    v12 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v11, 1, 900.0);
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isLocValid %d", "__WiFiDeviceManagerAttemptNetworkTransition", v12);
    objc_autoreleasePoolPop(v13);
    v14 = (CFTypeRef *)(a1 + 3368);
    v15 = *(void **)(a1 + 3384);
    if (v15)
    {
      if (v12)
      {
        objc_msgSend(v15, "distanceFromLocation:", v11);
        if (v16 > 30.0)
        {
          v17 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: moved significantly since the last location", "__WiFiDeviceManagerAttemptNetworkTransition");
LABEL_31:
          objc_autoreleasePoolPop(v17);
LABEL_32:
          v18 = (const __CFArray *)objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyScoreSortedNetworksAvailableAtLocation:", v11);
          v19 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: score sorted networks %@", "__WiFiDeviceManagerAttemptNetworkTransition", v18);
          objc_autoreleasePoolPop(v19);
          v20 = *(const void **)(a1 + 3384);
          if (v20)
            CFRelease(v20);
          *(_QWORD *)(a1 + 3384) = v11;
          CFRetain(v11);
          if (v18 && CFArrayGetCount(v18) && CFArrayGetCount(v18) >= 1)
          {
            v21 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v18, v21);
              if (ValueAtIndex)
                sub_10013D488((CFArrayRef *)a1, ValueAtIndex);
              ++v21;
            }
            while (CFArrayGetCount(v18) > v21);
          }
          if (*v14)
          {
            CFRelease(*v14);
            *v14 = 0;
          }
          if (v18)
          {
            *v14 = v18;
            CFRetain(v18);
            CFRelease(v18);
          }
          goto LABEL_54;
        }
        if (*(_DWORD *)(a1 + 3392) == -1)
        {
          v34 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: switched network/roamed since the last attempt", "__WiFiDeviceManagerAttemptNetworkTransition");
          objc_autoreleasePoolPop(v34);
          *(_DWORD *)(a1 + 3392) = 0;
          goto LABEL_32;
        }
      }
LABEL_54:
      CFRelease(v11);
      goto LABEL_55;
    }
    if (v12)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did not try location based logic last time we auto joined", "__WiFiDeviceManagerAttemptNetworkTransition");
      goto LABEL_31;
    }
  }
  else
  {
    v14 = (CFTypeRef *)(a1 + 3368);
    if (*(_QWORD *)(a1 + 3384))
      goto LABEL_55;
  }
  v23 = *(unsigned __int8 *)(a1 + 6632);
  v24 = objc_autoreleasePoolPush();
  if (v23)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did not try location based logic last time we auto joined and don't have a valid location. Will attempt transition anyways as preferAutoJoinHomeNetwork", "__WiFiDeviceManagerAttemptNetworkTransition");
    objc_autoreleasePoolPop(v24);
    if (v11)
      goto LABEL_54;
LABEL_55:
    if (*v14 && CFArrayGetCount((CFArrayRef)*v14))
    {
      if (!*(_BYTE *)(a1 + 6632))
      {
        v25 = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)*v14, 0);
        if (!v25)
          goto LABEL_64;
        v26 = v25;
        if (sub_1000CB8DC(v25)
          || objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isMovingNetwork:", v26))
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: top network <%@> is a moving network", "__WiFiDeviceManagerAttemptNetworkTransition", sub_10002B088(v26));
LABEL_63:
          objc_autoreleasePoolPop(v27);
          goto LABEL_64;
        }
        if (!sub_100007F24((uint64_t)v26) || !sub_100124B34(a1, v26, 0))
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: top network %@ is not eligible for aj ", "__WiFiDeviceManagerAttemptNetworkTransition", sub_10002B088(v26));
          goto LABEL_63;
        }
        v35 = sub_1000CB39C(*(const __CFArray **)(a1 + 3576), (uint64_t)v26);
        if (v35 == -1)
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: top network <%@> does not exist in known networks list, onto the next one ", "__WiFiDeviceManagerAttemptNetworkTransition", sub_10002B088(v26));
          goto LABEL_63;
        }
        v8 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), v35);
        goto LABEL_81;
      }
    }
    else if (!*(_BYTE *)(a1 + 6632))
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no rank sorted networks and not preferAutoJoinHomeNetwork", "__WiFiDeviceManagerAttemptNetworkTransition", v36);
      goto LABEL_15;
    }
    v28 = *(const __CFArray **)(a1 + 3528);
    if (v28)
    {
      Count = CFArrayGetCount(v28);
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Count)
      {
        v31 = *(const __CFArray **)(a1 + 3528);
        v38.length = CFArrayGetCount(v31);
        v38.location = 0;
        CFArrayAppendArray(Mutable, v31, v38);
      }
    }
    else
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    }
    if (*v14 && CFArrayGetCount((CFArrayRef)*v14))
    {
      v32 = (const __CFArray *)*v14;
      v39.length = CFArrayGetCount((CFArrayRef)*v14);
      v39.location = 0;
      CFArrayAppendArray(Mutable, v32, v39);
    }
    if (CFArrayGetCount(Mutable))
    {
      v37.length = CFArrayGetCount(Mutable);
      v37.location = 0;
      CFArraySortValues(Mutable, v37, (CFComparatorFunction)sub_1000C8C90, 0);
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NOI home-state sorted networks %@", "__WiFiDeviceManagerAttemptNetworkTransition", Mutable);
      objc_autoreleasePoolPop(v33);
      v8 = CFArrayGetValueAtIndex(Mutable, 0);
      if (!Mutable)
      {
LABEL_81:
        if (!v8)
        {
LABEL_64:
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no top network found", "__WiFiDeviceManagerAttemptNetworkTransition", v36);
          goto LABEL_15;
        }
LABEL_82:
        sub_10013DAFC(a1, v8);
        goto LABEL_83;
      }
    }
    else
    {
      v8 = 0;
      if (!Mutable)
        goto LABEL_81;
    }
    CFRelease(Mutable);
    goto LABEL_81;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did not try location based logic last time and don't have valid location to try now", "__WiFiDeviceManagerAttemptNetworkTransition");
  objc_autoreleasePoolPop(v24);
  if (v11)
    CFRelease(v11);
LABEL_83:
  objc_autoreleasePoolPop(v4);
}

void sub_1000FA884(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v5;
  unsigned __int8 v6;
  void *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  int v11;
  __n128 v12;
  double v13;
  double v14;
  void *v15;
  double v16;
  NSObject *v17;
  dispatch_time_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, _QWORD, __n128);
  void *v20;

  v2 = a1 + 7400;
  if (*(_BYTE *)(a1 + 7400))
  {
    v5 = (unsigned __int8 *)(a1 + 8606);
    if (*(_BYTE *)(a1 + 5496) || *(_BYTE *)(a1 + 3410) || *(_BYTE *)(a1 + 5498))
      v6 = 1;
    else
      v6 = -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive");
    v5[2] = v6;
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v8 = "Yes";
      if (*v5)
        v9 = "Yes";
      else
        v9 = "No";
      if (v5[2])
        v10 = "Yes";
      else
        v10 = "No";
      if (!v5[3])
        v8 = "No";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:isConnected %s, isTimeSensitiveAppRunning %s, isThereTrafficNow %s", "__WiFiDeviceManagerEvaluate24GHzInfraNetworkState", v9, v10, v8);
    }
    objc_autoreleasePoolPop(v7);
    v5[4] = 0;
    v11 = *v5;
    if (*v5)
    {
      if (v5[2] || (v11 = v5[3]) != 0)
      {
        v11 = 1;
        v5[4] = 1;
      }
    }
    if (*(unsigned __int8 *)(v2 + 1205) != v11)
    {
      v12.n128_f64[0] = CFAbsoluteTimeGetCurrent();
      v13 = *(double *)(a1 + 8584);
      if (v13 == 0.0 || (v14 = v12.n128_f64[0] - v13, v12.n128_u64[0] = 4.0, v14 >= 4.0) || v14 < 0.0)
      {
        v19 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, __n128))(a1 + 4344);
        if (v19)
        {
          v19(a1, a2, *(_QWORD *)(a1 + 4352), v5[4], v12);
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Signal WiFi critical state - %d", v5[4]);
          objc_autoreleasePoolPop(v20);
        }
        *(CFAbsoluteTime *)(a1 + 8584) = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)(a1 + 8601) = *(_DWORD *)v5;
        *(_BYTE *)(a1 + 8605) = v5[4];
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 8592), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(_BYTE *)(v2 + 1200) = 0;
      }
      else if (!*(_BYTE *)(v2 + 1200))
      {
        v15 = objc_autoreleasePoolPush();
        v16 = 4.0 - v14;
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%d secs remain for signaling WiFi critical state. Waiting...", (int)v16);
        objc_autoreleasePoolPop(v15);
        v17 = *(NSObject **)(a1 + 8592);
        v18 = dispatch_time(0, (uint64_t)(v16 * 1000000000.0));
        dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(_BYTE *)(v2 + 1200) = 1;
      }
    }
  }
}

void sub_1000FAAE4(uint64_t a1, uint64_t a2)
{
  void *v3;
  NSObject *v4;
  void *v5;
  _QWORD block[5];

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fault Notification com.apple.siri.connection.timeout", "__WiFiDeviceManagerHandleSiriTimedOutNotification");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    v4 = *(NSObject **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100145F58;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHandleSiriTimedOutNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000FABD0(uint64_t a1, uint64_t a2)
{
  void *v3;
  NSObject *v4;
  void *v5;
  _QWORD block[5];

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fault Notification com.apple.apsd.connection-failure-notification", "__WiFiDeviceManagerHandleApsdTimedOutNotification");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    v4 = *(NSObject **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10014609C;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHandleApsdTimedOutNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000FACBC(uint64_t a1, uint64_t a2)
{
  void *v3;
  NSObject *v4;
  void *v5;
  _QWORD block[5];

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fault Notification com.apple.airplay.connection.stalled", "__WiFiDeviceManagerHandleAirplayConnectionStallNotification");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    v4 = *(NSObject **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001461E0;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHandleAirplayConnectionStallNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000FADA8(uint64_t a1, uint64_t a2)
{
  void *v3;
  NSObject *v4;
  void *v5;
  _QWORD block[5];

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fault Notification com.apple.airplay.bufferedaudiounderrun", "__WiFiDeviceManagerHandleAirplayBufferedAudioUnderrunNotification");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    v4 = *(NSObject **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100146324;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHandleAirplayBufferedAudioUnderrunNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000FAE94(uint64_t a1, uint64_t a2)
{
  void *v3;
  NSObject *v4;
  void *v5;
  _QWORD block[5];

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fault Notification com.apple.airplay.realTimeAudioUnderrun", "__WiFiDeviceManagerHandleAirplayRealtimeAudioUnderrunNotification");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    v4 = *(NSObject **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10014645C;
    block[3] = &unk_10022EA38;
    block[4] = a2;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHandleAirplayRealtimeAudioUnderrunNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_1000FAF80(const void *a1)
{
  void *v2;
  __CFNotificationCenter *LocalCenter;

  if (&_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "__WiFiDeviceManagerRemoveMediaPlaybackStateObserver");
    objc_autoreleasePoolPop(v2);
    MRMediaRemoteUnregisterForNowPlayingNotifications();
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, a1, kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification, 0);
  }
}

void sub_1000FB00C(uint64_t a1, const void *a2)
{
  _WORD *v4;
  const void *v5;
  void *v6;
  _WORD *v7;
  const void *v8;
  void *v9;

  if (*(_DWORD *)(a1 + 5424))
  {
    if (sub_10010A034(a1))
    {
      v4 = sub_10010FF88(a1, 2);
      if (v4)
      {
        v5 = v4;
        if (sub_10010FBD8(a1, a2, v4, 0, 0))
        {
          v6 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed remove AWDL network", "__WiFideviceManagerTeardownAllAwdlSession");
          objc_autoreleasePoolPop(v6);
        }
        CFRelease(v5);
      }
    }
    if (sub_10010A010(a1))
    {
      v7 = sub_10010FF88(a1, 1);
      if (v7)
      {
        v8 = v7;
        if (sub_10010FBD8(a1, a2, v7, 0, 0))
        {
          v9 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed remove AWDL network", "__WiFideviceManagerTeardownAllAwdlSession");
          objc_autoreleasePoolPop(v9);
        }
        CFRelease(v8);
      }
    }
    *(_DWORD *)(a1 + 5424) = 0;
  }
}

void sub_1000FB144(uint64_t a1)
{
  NSObject *v2;
  void *v3;

  if (a1)
  {
    v2 = *(NSObject **)(a1 + 9008);
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*(dispatch_object_t *)(a1 + 9008));
      *(_QWORD *)(a1 + 9008) = 0;
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kernel event monitor stopped", "__WiFiDeviceManagerTeardownKernelEventMonitor");
    }
    else
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: kernel event monitor not initialized.", "__WiFiDeviceManagerTeardownKernelEventMonitor");
    }
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000FB1F0(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiDeviceManagerSetIDSSyncEngineRef");
    goto LABEL_10;
  }
  v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ids sync ref", "WiFiDeviceManagerSetIDSSyncEngineRef");
LABEL_10:
    objc_autoreleasePoolPop(v4);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "WiFiDeviceManagerSetIDSSyncEngineRef", sub_100029860(*(_QWORD *)(a1 + 64)));
  objc_autoreleasePoolPop(v4);
  *(_QWORD *)(a1 + 6568) = a2;
}

void sub_1000FB2E0(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  if (!*(_BYTE *)(a1 + 3305))
  {
    *(_BYTE *)(a1 + 3305) = 1;
    if (*(_QWORD *)(a1 + 5408))
    {
      v2 = objc_autoreleasePoolPush();
      v3 = (uint64_t)objc_msgSend(*(id *)(a1 + 5408), "requestPowerResource:withDetails:", 0, 0);
      objc_autoreleasePoolPop(v2);
      if (!(_DWORD)v3)
        return;
    }
    else
    {
      *(_DWORD *)(a1 + 192) = 0;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 15);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 15, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, "WiFiDeviceManagerEnable");
      }
      v3 = 4294963365;
    }
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : Requested resource but none available. Will not autojoin. Nothing to do here. %d", "WiFiDeviceManagerEnable", v3);
    objc_autoreleasePoolPop(v4);
  }
}

void sub_1000FB3FC(uint64_t a1, uint64_t a2)
{
  sub_1000FBA80(a1, 2, a2);
}

void sub_1000FB408(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 3305))
  {
    *(_BYTE *)(a1 + 3305) = 0;
    sub_1000FB44C();
    if (*(_QWORD *)(a1 + 5408))
      sub_1000FB8B8(a1);
  }
}

void sub_1000FB44C(uint64_t a1)
{
  const void *v2;
  int v3;
  void *v4;
  void *v5;
  uint64_t v6;
  const void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSErrorUserInfoKey v22;
  const __CFString *v23;

  if (!*(_DWORD *)(a1 + 3280))
  {
    if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
      return;
    goto LABEL_20;
  }
  v2 = *(const void **)(a1 + 1112);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  sub_1000FC5D8(a1, 0);
  sub_100072E4C(*(_QWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 3280);
  if ((v3 - 16) <= 4)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: in \"%@\" state, aborting", "WiFiDeviceManagerAbort", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
    objc_autoreleasePoolPop(v4);
    sub_1000F48F0(a1, 0);
    *(_BYTE *)(a1 + 7008) = 0;
    v3 = *(_DWORD *)(a1 + 3280);
  }
  if ((v3 - 12) >= 0xFFFFFFF6)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Scanning in progress, next system wake should not defer AJ scan");
    objc_autoreleasePoolPop(v5);
    *(_QWORD *)(a1 + 7304) = 0;
  }
  sub_100070B04(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 3312));
  *(_QWORD *)(a1 + 3312) = 0;
  if (*(_DWORD *)(a1 + 3280) == 1)
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 312), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  *(_DWORD *)(a1 + 3280) = 0;
  v6 = *(_QWORD *)(a1 + 224);
  if (!v6)
  {
LABEL_20:
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v8 = *(void **)(a1 + 8824);
      v22 = NSLocalizedDescriptionKey;
      v23 = CFSTR("WiFiDeviceManagerAbort()");
      objc_msgSend(v8, "cancelAutoJoinWithUUID:error:reply:", 0, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 53, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v23, &v22, 1)), 0);
      v9 = *(_QWORD *)(a1 + 8928);
      if (v9)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD, _QWORD))(v9 + 16))(v9, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 89, 0), 0, 0);
        _Block_release(*(const void **)(a1 + 8928));
        *(_QWORD *)(a1 + 8928) = 0;

        *(_QWORD *)(a1 + 8936) = 0;
      }
      v10 = *(_QWORD *)(a1 + 8944);
      if (v10)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD, _QWORD))(v10 + 16))(v10, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 89, 0), 0, 0);
        _Block_release(*(const void **)(a1 + 8944));
        *(_QWORD *)(a1 + 8944) = 0;

        *(_QWORD *)(a1 + 8952) = 0;
      }
      v11 = *(_QWORD *)(a1 + 8840);
      if (v11)
      {
        (*(void (**)(uint64_t, NSError *))(v11 + 16))(v11, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 89, 0));
        _Block_release(*(const void **)(a1 + 8840));
        *(_QWORD *)(a1 + 8840) = 0;
        v12 = *(const void **)(a1 + 8832);
        if (v12)
        {
          CFRelease(v12);
          *(_QWORD *)(a1 + 8832) = 0;
        }
      }
      v13 = *(_QWORD *)(a1 + 8864);
      if (v13)
      {
        (*(void (**)(uint64_t, NSError *, _QWORD))(v13 + 16))(v13, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 89, 0), 0);
        _Block_release(*(const void **)(a1 + 8864));
        *(_QWORD *)(a1 + 8864) = 0;
      }
      v14 = *(_QWORD *)(a1 + 8856);
      if (v14)
      {
        (*(void (**)(uint64_t, NSError *))(v14 + 16))(v14, +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 89, 0));
        _Block_release(*(const void **)(a1 + 8856));
        *(_QWORD *)(a1 + 8856) = 0;

        *(_QWORD *)(a1 + 8848) = 0;
      }
    }
    goto LABEL_32;
  }
  if (sub_1000D71EC(v6))
  {
    if (sub_1000D71F4(*(_QWORD *)(a1 + 224)) != 2)
    {
      v7 = *(const void **)(a1 + 224);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a1 + 224) = 0;
      }
      goto LABEL_20;
    }
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v18 = *(_QWORD *)(a1 + 224);
      v20 = sub_1000D71EC(v18);
      objc_msgSend(v17, "WFLog:message:", 3, "%s: not releasing pending notification %@ (type=%d,inputType=%d)", "WiFiDeviceManagerAbort", v18, v20, sub_1000D71F4(*(_QWORD *)(a1 + 224)));
    }
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not releasing ask to join notification %@", "WiFiDeviceManagerAbort", *(_QWORD *)(a1 + 224), v19, v21);
  }
  objc_autoreleasePoolPop(v16);
LABEL_32:
  sub_100135D8C(a1, CFSTR("autoJoinAborted"), 0, 0);
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Aborted current auto-join session.");
  objc_autoreleasePoolPop(v15);
}

void sub_1000FB8B8(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  const void *v9;
  void *v10;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerReleasePowerResource");
    goto LABEL_13;
  }
  if (!*(_QWORD *)(a1 + 5408))
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Power modules not attached.", "__WiFiDeviceManagerReleasePowerResource");
LABEL_13:
    objc_autoreleasePoolPop(v10);
    goto LABEL_14;
  }
  v3 = *(_QWORD *)(a1 + 64);
  v4 = (const void *)sub_100025C3C(v3);
  v5 = sub_10002BF8C(v3, v4);
  if (!v5)
  {
    v8 = *(_QWORD *)(a1 + 64);
    v9 = (const void *)sub_100068E60(v8);
    if (sub_100074164(v8, v9, 0))
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Power module attached - AWDL still enabled.", "__WiFiDeviceManagerReleasePowerResource");
    }
    else
    {
      if (!*(_BYTE *)(a1 + 3305))
      {
        objc_msgSend(*(id *)(a1 + 5408), "releasePowerResources");
        goto LABEL_14;
      }
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Power module attached - autojoin still enabled.", "__WiFiDeviceManagerReleasePowerResource");
    }
    goto LABEL_13;
  }
  v6 = v5;
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Power module attached - still connected to %@.", "__WiFiDeviceManagerReleasePowerResource", sub_10002B088(v6));
  objc_autoreleasePoolPop(v7);
  CFRelease(v6);
LABEL_14:
  objc_autoreleasePoolPop(v2);
}

void sub_1000FBA70(uint64_t a1)
{
  sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerAutoAssociateStart");
}

void sub_1000FBA80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000FBAD0(a1, a2, a3);
  sub_1000FBCDC(a1, 1, a3);
  if (!*(_DWORD *)(a1 + 3280))
    sub_1000FC5D8(a1, 0);
}

void sub_1000FBAD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  double v10;
  CFIndex v11;
  unsigned int v12;
  const __CFNumber *ValueAtIndex;
  uint64_t v14;
  void *v15;
  int v16;
  double valuePtr;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s called by %s", "__WiFiDeviceManagerResetRetryIntervals", a3);
  objc_autoreleasePoolPop(v6);
  if (a1)
  {
    *(_DWORD *)(a1 + 5632) = a2;
    if ((_DWORD)a2 == 2)
      *(_QWORD *)(a1 + 3296) = 0;
    valuePtr = NAN;
    v7 = *(const __CFArray **)(a1 + 320);
    if (v7
      && (Count = CFArrayGetCount(v7), (v9 = *(_QWORD *)(a1 + 328)) != 0)
      && (_DWORD)a2 != 2
      && (v10 = *(double *)(a1 + 336), v10 != 0.0)
      && (v11 = Count) != 0)
    {
      if (v9 >= Count)
      {
        v9 = Count - 1;
        *(_QWORD *)(a1 + 328) = Count - 1;
      }
      v12 = 1;
      if ((_DWORD)a2 == 1 && v10 >= 5.0)
      {
        if (*(_QWORD *)(a1 + 392))
          v12 = 2;
        else
          *(_QWORD *)(a1 + 336) = 0x4014000000000000;
      }
      if (v9 >= 1)
      {
        do
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), v9);
          if (ValueAtIndex)
          {
            CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
            if (valuePtr > 0.0 && valuePtr <= *(double *)(a1 + 336))
              break;
          }
          v14 = *(_QWORD *)(a1 + 328);
          v9 = v14 - 1;
          *(_QWORD *)(a1 + 328) = v14 - 1;
        }
        while (v14 > 1);
      }
      if (*(_DWORD *)(a1 + 348) < v12)
        *(_DWORD *)(a1 + 348) = v12;
      if (*(_DWORD *)(a1 + 6804) && !sub_10007788C(*(_QWORD *)(a1 + 64)) && *(double *)(a1 + 6872) == 0.0)
        *(_QWORD *)(a1 + 6872) = *(_QWORD *)(a1 + 6864);
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resetType=%d, retryIndex=%ld, quickRetry=%d, lastInterval=%f, intervals=(%ld) autoHSInterval=(%f)", "__WiFiDeviceManagerResetRetryIntervals", a2, *(_QWORD *)(a1 + 328), *(unsigned int *)(a1 + 348), *(_QWORD *)(a1 + 336), v11, *(_QWORD *)(a1 + 6872));
      objc_autoreleasePoolPop(v15);
    }
    else
    {
      *(_DWORD *)(a1 + 348) = 0;
      *(_QWORD *)(a1 + 328) = 0;
      *(_QWORD *)(a1 + 336) = 0;
    }
    v16 = *(_DWORD *)(a1 + 3280);
    if (v16 == 1)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 312), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      v16 = 0;
    }
    *(_DWORD *)(a1 + 3280) = v16;
  }
}

void sub_1000FBCDC(uint64_t a1, int a2, uint64_t a3)
{
  void *v6;
  void *v7;
  void *context;
  _BYTE *v9;
  int v10;
  void *v11;
  void *v12;
  void *v13;
  const char *v14;
  void *v15;
  void *v16;
  const char *v17;
  void *v18;
  __CFString **v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  const void *v26;
  int v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  NSString *v32;
  void *v33;
  int v34;
  void *v35;
  void *v36;
  NSString *v37;
  const char *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint8_t buf[4];
  const char *v45;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s called by %s", "__WiFiDeviceManagerAutoAssociate", a3);
  objc_autoreleasePoolPop(v6);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not allowed with Unified Auto-Join", "__WiFiDeviceManagerAutoAssociate");
    objc_autoreleasePoolPop(v7);
    return;
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1104));
  sub_100135D8C(a1, CFSTR("kWiFiAutoJoinStatusBegan"), 0, 0);
  if (CFAbsoluteTimeGetCurrent() > *(double *)(a1 + 6824))
  {
    context = dispatch_get_context(*(dispatch_object_t *)(a1 + 6816));
    sub_1000F43A8((uint64_t)context);
  }
  if (!*(_BYTE *)(a1 + 3305))
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = "Auto association attempt canceled because auto join is disabled.";
LABEL_24:
      objc_msgSend(v16, "WFLog:message:", 3, v17);
    }
LABEL_25:
    v18 = v15;
LABEL_26:
    objc_autoreleasePoolPop(v18);
    v19 = off_10022FC78;
LABEL_33:
    sub_100135D8C(a1, *v19, 0, 0);
    return;
  }
  v9 = (_BYTE *)(a1 + 5504);
  if (!*(_BYTE *)(a1 + 6280))
  {
    v10 = *v9;
    v11 = objc_autoreleasePoolPush();
    if (!v10)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto association attempt canceled because user auto join is disabled.");
      v18 = v11;
      goto LABEL_26;
    }
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User auto join preference bypassed because device is in priority-link setup phase/carplay");
    objc_autoreleasePoolPop(v11);
  }
  if (*(_DWORD *)(a1 + 20) != 1)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = "Auto association attempt canceled because device is not powered.";
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  if (*(_BYTE *)(a1 + 248))
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v14 = "Auto association attempt canceled because WiFi tethering is enabled.";
LABEL_30:
      objc_msgSend(v13, "WFLog:message:", 3, v14, v40, v41, v42, v43);
      goto LABEL_31;
    }
    goto LABEL_31;
  }
  if (*(_BYTE *)(a1 + 249))
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v14 = "Auto association attempt canceled because WiFi Direct Mode is enabled.";
      goto LABEL_30;
    }
LABEL_31:
    v20 = v12;
LABEL_32:
    objc_autoreleasePoolPop(v20);
    v19 = off_10022FC80;
    goto LABEL_33;
  }
  if (*(_DWORD *)(a1 + 3280))
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto association attempt canceled because auto join state is %@.", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
    objc_autoreleasePoolPop(v21);
    if (*(_DWORD *)(a1 + 3280) == 2)
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Setting forced Allband scan flag");
      objc_autoreleasePoolPop(v22);
      *(_BYTE *)(a1 + 3304) = 1;
    }
    return;
  }
  if ((*(_BYTE *)(a1 + 5219)
     || sub_100018E14(a1)
     || *(_DWORD *)(a1 + 5344)
     || *(unsigned __int8 *)(a1 + 5361) != -*(_BYTE *)(a1 + 5360))
    && (!*(_BYTE *)(a1 + 7056) || !sub_100107828(a1, 1)))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto association attempt canceled because MIS is enabled. MIS client count: wifi=%d bt=%d misBlockScan=%d MIS discovery state = %d", *(unsigned __int8 *)(a1 + 5360), *(unsigned __int8 *)(a1 + 5361), *(unsigned __int8 *)(a1 + 5328), *(unsigned __int8 *)(a1 + 5221));
    goto LABEL_31;
  }
  if ((*(_DWORD *)(a1 + 5396) == 102 && (*(_BYTE *)(a1 + 5392) & 1) != 0 || *(_BYTE *)(a1 + 50))
    && *(_DWORD *)(a1 + 5520) != 1
    && !*(_BYTE *)(a1 + 37))
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_31;
    v14 = "Auto association attempt canceled because BT SCO is enabled";
    goto LABEL_30;
  }
  if (sub_100018FE4(a1) && sub_10010A010(a1))
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_31;
    v14 = "Auto association attempt canceled because hosted AWDL session is active";
    goto LABEL_30;
  }
  if (sub_100018F14(a1))
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_31;
    v14 = "Auto-join deferral is active, will not continue auto-join";
    goto LABEL_30;
  }
  if (*(_BYTE *)(a1 + 6896) && *v9)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_31;
    v14 = "Associated in Auto Hotspot Mode and waiting for IP";
    goto LABEL_30;
  }
  v23 = *(_QWORD *)(a1 + 64);
  v24 = (const void *)sub_100025C3C(v23);
  v25 = sub_10002BF8C(v23, v24);
  if (v25)
  {
    v26 = v25;
    if (!*(_BYTE *)(a1 + 6896) || *(_DWORD *)(a1 + 176) == 1 && !*(_QWORD *)(a1 + 6976))
    {
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already connected to %@.", "__WiFiDeviceManagerAutoAssociate", sub_10002B088(v26));
      objc_autoreleasePoolPop(v30);
      sub_100135D8C(a1, CFSTR("autoJoinAlreadyAssoicated"), v26, 0);
      CFRelease(v26);
      return;
    }
    CFRelease(v25);
  }
  v27 = *(_DWORD *)(a1 + 5416);
  v28 = objc_autoreleasePoolPush();
  if (!v27)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto association attempt canceled because thermal index (%d) is below disabled threshold (%d).", *(unsigned int *)(a1 + 5416), 0);
    v20 = v28;
    goto LABEL_32;
  }
  v29 = *(void **)(a1 + 5408);
  if (v29 && (objc_msgSend(v29, "isPowerResourceAvailable:", 0) & 1) == 0)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " WiFiBatteryMgmt : Auto association attempt canceled because Battery resource is not available.");
    objc_autoreleasePoolPop(v35);
    if (!objc_msgSend(objc_msgSend(*(id *)(a1 + 5408), "pendingRequests"), "count"))
      sub_100135D8C(a1, CFSTR("autoJoinNotPermitted"), 0, 0);
    objc_autoreleasePoolPop(v28);
  }
  else
  {
    objc_autoreleasePoolPop(v28);
    if (!*(_BYTE *)(a1 + 3488) && *(_DWORD *)(a1 + 3492) == -528336895)
    {
      v12 = objc_autoreleasePoolPush();
      v13 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_31;
      v14 = "Auto association attempt canceled because of Driver Watchdog";
      goto LABEL_30;
    }
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v32 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: starting auto-join"), "__WiFiDeviceManagerAutoAssociate")), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v45 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v32, "UTF8String")), "UTF8String");
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v31);
    v33 = objc_autoreleasePoolPush();
    objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 3);
    objc_autoreleasePoolPop(v33);
    sub_1000FEFA0(a1);
    if (*(_BYTE *)(a1 + 24))
    {
      v34 = sub_100069F0C(*(_QWORD *)(a1 + 64));
      if (a2)
      {
        if (v34)
          *(_DWORD *)(a1 + 28) = 0;
      }
    }
    if (*(_BYTE *)(a1 + 104) || !sub_1001249C8(a1))
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinUpdatedWithState:interfaceName:", 1, sub_100025C3C(*(_QWORD *)(a1 + 64)));
      sub_1000F49C8(a1);
    }
    else
    {
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v37 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: auto association attempt cancelled because scan throttle is exceeded."), "__WiFiDeviceManagerAutoAssociate")), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        {
          v38 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v37, "UTF8String")), "UTF8String");
          *(_DWORD *)buf = 136446210;
          v45 = v38;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v36);
      *(_DWORD *)(a1 + 3280) = sub_1000078D0(a1);
      v39 = *(_DWORD *)(a1 + 348);
      if (v39)
        *(_DWORD *)(a1 + 348) = v39 - 1;
    }
  }
}

void sub_1000FC5D8(uint64_t a1, unsigned int a2)
{
  void *v3;
  void *v5;
  const char *v6;

  if (byte_10026DD61)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Lockdown Mode is enabled, ignoring SetATJOneShot %ld", "__WiFiDeviceManagerSetATJOneShot", a2);
    objc_autoreleasePoolPop(v3);
  }
  else if (*(unsigned __int8 *)(a1 + 104) != a2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v6 = "Enabling";
      if (!a2)
        v6 = "Disabling";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s one-shot ATJ", v6);
    }
    objc_autoreleasePoolPop(v5);
    *(_BYTE *)(a1 + 104) = a2;
    if (a2)
    {
      *(_DWORD *)(a1 + 192) = 1;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 15);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 15, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, (uint64_t)"__WiFiDeviceManagerSetATJOneShot");
      }
    }
  }
}

uint64_t sub_1000FC750(uint64_t a1)
{
  uint64_t v1;
  const void *v2;

  v1 = *(_QWORD *)(a1 + 64);
  v2 = (const void *)sub_100025C3C(v1);
  return sub_1000672C0(v1, v2, 512, 0, (uint64_t)kCFBooleanTrue);
}

void sub_1000FC790(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: reseting userCancelled networks", "__WiFiDeviceManagerResetUserCancelledNetworks");
    objc_autoreleasePoolPop(v2);
    CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3504));
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is nil", "__WiFiDeviceManagerResetUserCancelledNetworks");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000FC82C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3888) = a2;
  *(_QWORD *)(result + 3896) = a3;
  return result;
}

uint64_t sub_1000FC838(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4056) = a2;
  *(_QWORD *)(result + 4064) = a3;
  return result;
}

uint64_t sub_1000FC844(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4712) = a2;
  *(_QWORD *)(result + 4720) = a3;
  return result;
}

uint64_t sub_1000FC850(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3872) = a2;
  *(_QWORD *)(result + 3880) = a3;
  return result;
}

uint64_t sub_1000FC85C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3904) = a2;
  *(_QWORD *)(result + 3912) = a3;
  return result;
}

uint64_t sub_1000FC868(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3920) = a2;
  *(_QWORD *)(result + 3928) = a3;
  return result;
}

uint64_t sub_1000FC874(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3936) = a2;
  *(_QWORD *)(result + 3944) = a3;
  return result;
}

uint64_t sub_1000FC880(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3952) = a2;
  *(_QWORD *)(result + 3968) = a3;
  return result;
}

uint64_t sub_1000FC88C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3976) = a2;
  *(_QWORD *)(result + 3984) = a3;
  return result;
}

uint64_t sub_1000FC898(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 3992) = a2;
  *(_QWORD *)(result + 4000) = a3;
  return result;
}

uint64_t sub_1000FC8A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4024) = a2;
  *(_QWORD *)(result + 4032) = a3;
  return result;
}

uint64_t sub_1000FC8B0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4040) = a2;
  *(_QWORD *)(result + 4048) = a3;
  return result;
}

uint64_t sub_1000FC8BC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4072) = a2;
  *(_QWORD *)(result + 4080) = a3;
  return result;
}

uint64_t sub_1000FC8C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4088) = a2;
  *(_QWORD *)(result + 4096) = a3;
  return result;
}

uint64_t sub_1000FC8D4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4104) = a2;
  *(_QWORD *)(result + 4112) = a3;
  return result;
}

uint64_t sub_1000FC8E0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4120) = a2;
  *(_QWORD *)(result + 4128) = a3;
  return result;
}

uint64_t sub_1000FC8EC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4136) = a2;
  *(_QWORD *)(result + 4144) = a3;
  return result;
}

uint64_t sub_1000FC8F8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4152) = a2;
  *(_QWORD *)(result + 4160) = a3;
  return result;
}

uint64_t sub_1000FC904(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4168) = a2;
  *(_QWORD *)(result + 4176) = a3;
  return result;
}

uint64_t sub_1000FC910(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4184) = a2;
  *(_QWORD *)(result + 4192) = a3;
  return result;
}

uint64_t sub_1000FC91C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4200) = a2;
  *(_QWORD *)(result + 4208) = a3;
  return result;
}

uint64_t sub_1000FC928(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4008) = a2;
  *(_QWORD *)(result + 4016) = a3;
  return result;
}

uint64_t sub_1000FC934(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4216) = a2;
  *(_QWORD *)(result + 4224) = a3;
  return result;
}

uint64_t sub_1000FC940(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4232) = a2;
  *(_QWORD *)(result + 4240) = a3;
  return result;
}

uint64_t sub_1000FC94C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4248) = a2;
  *(_QWORD *)(result + 4256) = a3;
  return result;
}

uint64_t sub_1000FC958(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4264) = a2;
  *(_QWORD *)(result + 4272) = a3;
  return result;
}

uint64_t sub_1000FC964(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4280) = a2;
  *(_QWORD *)(result + 4288) = a3;
  return result;
}

uint64_t sub_1000FC970(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4296) = a2;
  *(_QWORD *)(result + 4304) = a3;
  return result;
}

uint64_t sub_1000FC97C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4328) = a2;
  *(_QWORD *)(result + 4336) = a3;
  return result;
}

uint64_t sub_1000FC988(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4344) = a2;
  *(_QWORD *)(result + 4352) = a3;
  return result;
}

uint64_t sub_1000FC994(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4360) = a2;
  *(_QWORD *)(result + 4368) = a3;
  return result;
}

uint64_t sub_1000FC9A0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4376) = a2;
  *(_QWORD *)(result + 4384) = a3;
  return result;
}

uint64_t sub_1000FC9AC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4600) = a2;
  *(_QWORD *)(result + 4608) = a3;
  return result;
}

uint64_t sub_1000FC9B8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4392) = a2;
  *(_QWORD *)(result + 4400) = a3;
  return result;
}

uint64_t sub_1000FC9C4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4616) = a2;
  *(_QWORD *)(result + 4624) = a3;
  return result;
}

uint64_t sub_1000FC9D0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4648) = a2;
  *(_QWORD *)(result + 4656) = a3;
  return result;
}

uint64_t sub_1000FC9DC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4408) = a2;
  *(_QWORD *)(result + 4416) = a3;
  return result;
}

uint64_t sub_1000FC9E8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4424) = a2;
  *(_QWORD *)(result + 4432) = a3;
  return result;
}

uint64_t sub_1000FC9F4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4520) = a2;
  *(_QWORD *)(result + 4528) = a3;
  return result;
}

uint64_t sub_1000FCA00(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4536) = a2;
  *(_QWORD *)(result + 4544) = a3;
  return result;
}

uint64_t sub_1000FCA0C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4584) = a2;
  *(_QWORD *)(result + 4592) = a3;
  return result;
}

uint64_t sub_1000FCA18(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4632) = a2;
  *(_QWORD *)(result + 4640) = a3;
  return result;
}

uint64_t sub_1000FCA24(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4664) = a2;
  *(_QWORD *)(result + 4672) = a3;
  return result;
}

uint64_t sub_1000FCA30(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4680) = a2;
  *(_QWORD *)(result + 4688) = a3;
  return result;
}

uint64_t sub_1000FCA3C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4728) = a2;
  *(_QWORD *)(result + 4736) = a3;
  return result;
}

void sub_1000FCA48(uint64_t a1, const void *a2)
{
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;

  v4 = objc_autoreleasePoolPush();
  v5 = sub_100027D10((uint64_t)a2);
  v6 = sub_1000FCB38(a1, 0, 0, 0, 5);
  objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v6, v5);
  v7 = *(_QWORD *)(a1 + 64);
  v8 = (const void *)sub_100025C3C(v7);
  v9 = sub_10002BF8C(v7, v8);
  if (v9)
  {
    v10 = v9;
    if (CFEqual(a2, v9) && objc_msgSend(*(id *)(a1 + 6648), "enabled"))
    {
      v11 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      sub_1000F7F48(a1, v11, 1002, "WiFiDeviceManagerTemporarilyDisableNetwork", 5761);
    }

    CFRelease(v10);
  }
  else
  {

  }
  objc_autoreleasePoolPop(v4);
}

id sub_1000FCB38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  id v11;
  void *v13;

  v10 = objc_autoreleasePoolPush();
  if (a1)
  {
    v11 = objc_alloc_init((Class)CWFNetworkDenyListInfo);
    objc_msgSend(v11, "setReason:", a2);
    objc_msgSend(v11, "setReasonData:", a3);
    objc_msgSend(v11, "setBSSID:", a4);
    objc_msgSend(v11, "setState:", a5);
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiDeviceManagerCreateDenyListInfo");
    objc_autoreleasePoolPop(v13);
    v11 = 0;
  }
  objc_autoreleasePoolPop(v10);
  return v11;
}

uint64_t sub_1000FCC14(uint64_t a1, const __CFArray *a2)
{
  int v4;
  void *v5;
  id v6;
  CFIndex v7;
  CFDictionaryRef *ValueAtIndex;
  void *v9;
  void *v10;
  const void *v11;
  void *v12;
  const __CFAllocator *v13;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v15;
  CFMutableSetRef v16;
  BOOL v17;
  CFMutableArrayRef v19;
  const __CFArray *v20;
  BOOL v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  _BOOL4 v29;
  const char *v30;
  const char *v31;
  CFIndex Count;
  CFIndex v33;
  CFIndex v34;
  int v35;
  void *v36;
  void *v37;
  const void *v38;
  uint64_t v39;
  CFDataRef v40;
  CFDataRef v41;
  CFDataRef v42;
  void *v43;
  const __CFString *v44;
  const __CFString *v45;
  void *v46;
  __CFString *v47;
  __CFString *v48;
  uint64_t v49;
  void *v50;
  __CFArray *v51;
  void *v52;
  void *v53;
  void *v54;
  __CFArray *v55;
  void *v56;
  const void *v57;
  __CFArray *v58;
  _BOOL4 v59;
  __CFArray *v60;
  __CFArray *v61;
  __CFArray *v62;
  __CFArray *v63;
  __CFArray *v64;
  CFIndex v65;
  uint64_t v66;
  CFNumberRef v67;
  CFNumberRef v68;
  CFNumberRef v69;
  CFIndex i;
  const void *v71;
  uint64_t v72;
  CFNumberRef v73;
  void *v74;
  CFNumberRef v75;
  __CFArray *v76;
  __CFArray *v77;
  const void *v78;
  char v79;
  void *v80;
  void *v81;
  int v82;
  const __CFNumber *v83;
  void *v84;
  void *v85;
  const __CFString *v86;
  uint64_t v87;
  const void *v88;
  uint64_t v89;
  void *v90;
  const void *v91;
  void *v92;
  const __CFArray *v93;
  uint64_t v94;
  unint64_t v95;
  const void *v97;
  const __CFNumber *v98;
  const __CFArray *v99;
  const __CFArray *v100;
  CFIndex v101;
  const __CFDictionary *v102;
  const __CFNumber *v103;
  const void *v104;
  int v105;
  CFMutableDictionaryRef v106;
  __CFDictionary *v107;
  CFNumberRef v108;
  CFNumberRef v109;
  CFNumberRef v110;
  CFNumberRef v111;
  CFNumberRef v112;
  CFNumberRef v113;
  uint64_t v114;
  const void *v115;
  uint64_t v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  uint64_t v123;
  void *v124;
  uint64_t v125;
  unsigned __int8 *v126;
  _BOOL4 v127;
  CFNumberRef v128;
  __CFSet *theSet;
  __CFArray *v130;
  uint64_t v131;
  __CFArray *v132;
  const __CFArray *theArray;
  const __CFArray *v134;
  CFTypeRef cf;
  CFNumberRef v136;
  CFNumberRef value;
  const __CFArray *v138;
  __CFArray *v139;
  const __CFArray *v140;
  unsigned int v141;
  unsigned int v142;
  int v143;
  int v144;
  _DWORD valuePtr[3];
  CFRange v146;
  CFRange v147;
  CFRange v148;
  CFRange v149;
  CFRange v150;
  CFRange v151;
  CFRange v152;
  CFRange v153;
  CFRange v154;
  CFRange v155;

  v126 = (unsigned __int8 *)(a1 + 5216);
  v141 = 0;
  v4 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (a1 && v4)
  {
    v5 = objc_autoreleasePoolPush();
    if (a2)
    {
      v6 = +[NSMutableSet set](NSMutableSet, "set");
      if (CFArrayGetCount(a2) >= 1)
      {
        v7 = 0;
        do
        {
          ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a2, v7);
          v9 = sub_100026664(ValueAtIndex);
          if (v9)
          {
            v10 = v9;
            objc_msgSend(v6, "addObject:", v9);

          }
          ++v7;
        }
        while (v7 < CFArrayGetCount(a2));
      }
    }
    else
    {
      v6 = 0;
    }
    objc_msgSend(*(id *)(a1 + 8824), "setKnownNetworks:", v6);
    objc_autoreleasePoolPop(v5);
  }
  v11 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v12 = sub_10002A21C(a1, v11, 1);
  sub_1000FE2A4(a1);
  v13 = kCFAllocatorDefault;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v16 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  theSet = v16;
  v130 = v15;
  if (Mutable)
    v17 = v15 == 0;
  else
    v17 = 1;
  if (v17 || v16 == 0)
  {
    v119 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create array", "WiFiDeviceManagerSetNetworks");
    objc_autoreleasePoolPop(v119);
    v93 = 0;
    v134 = 0;
    v82 = 0;
    if (v12)
      goto LABEL_205;
    goto LABEL_206;
  }
  v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v134 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v19)
    v21 = v20 == 0;
  else
    v21 = 1;
  if (v21)
  {
    v120 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create hs20 array", "WiFiDeviceManagerSetNetworks");
    objc_autoreleasePoolPop(v120);
    theArray = 0;
    goto LABEL_268;
  }
  theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (theArray)
  {
    v22 = sub_10002B088(v12);
    v23 = 1;
    cf = v12;
    if (v22)
    {
      v24 = *(_QWORD *)(a1 + 6656);
      if (v24)
      {
        if (CFEqual(v22, *(CFTypeRef *)(a1 + 6656)))
        {
          v25 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: '%@' removed via iCloud, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", v24);
          objc_autoreleasePoolPop(v25);
          v23 = 0;
          v12 = (void *)cf;
        }
        else
        {
          v23 = 1;
        }
      }
    }
    v132 = Mutable;
    if (v12 && !sub_1000FE338((_QWORD *)a1, v12) && !sub_1000FE3D8(a1, v12))
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: '%@' not previously known, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", sub_10002B088(cf));
      objc_autoreleasePoolPop(v26);
      v27 = objc_autoreleasePoolPush();
      v28 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v29 = sub_10002DA5C((_BOOL8)cf);
        v30 = "yes";
        if (v29)
          v31 = "yes";
        else
          v31 = "no";
        if (*(_DWORD *)(a1 + 5520) != 1)
          v30 = "no";
        objc_msgSend(v28, "WFLog:message:", 3, "%s: Current network is HS20 ? %s, Got CarPlay in-car ? %s", "WiFiDeviceManagerSetNetworks", v31, v30);
      }
      objc_autoreleasePoolPop(v27);
      v12 = (void *)cf;
      if (!sub_10002DA5C((_BOOL8)cf) || *(_DWORD *)(a1 + 5520) != 1)
        v23 = 0;
    }
    v139 = v19;
    v140 = v20;
    v138 = a2;
    if (a2)
    {
      Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        v33 = Count;
        v34 = 0;
        v35 = 0;
        while (1)
        {
          v36 = (void *)CFArrayGetValueAtIndex(a2, v34);
          if (!v36)
            goto LABEL_95;
          v37 = v36;
          v38 = *(const void **)(a1 + 3512);
          if (v38 && CFEqual(v38, v37))
            v35 = 1;
          if ((_DWORD)v23)
          {
            if (!v12)
            {
              v23 = 0;
              goto LABEL_81;
            }
            v23 = CFEqual(v12, v37) ? 0 : v23;
          }
          else if (!v12)
          {
            goto LABEL_81;
          }
          if (sub_10002DA5C((_BOOL8)v12) && sub_10002DA5C((_BOOL8)v37))
            break;
LABEL_74:
          if (sub_1000C46C8((uint64_t)v12))
          {
            v44 = sub_10003149C(v12);
            v45 = sub_10003149C(v37);
            if (CFEqual(v44, v45))
            {
              v46 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: connected to the same ambiguous SSID network %@, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", sub_10002B088(v37));
              objc_autoreleasePoolPop(v46);
              v23 = 0;
            }
          }
          if (CFEqual(v12, v37))
            sub_1000FE46C(a1, v37);
LABEL_81:
          if (sub_1000C3BC4((_BOOL8)v37))
          {
            if (sub_1000716C0(*(_QWORD *)(a1 + 64)))
            {
              v47 = CFStringCreateMutable(kCFAllocatorDefault, 0);
              if (!v47)
              {
                v82 = 0;
                v19 = v139;
                Mutable = v132;
                goto LABEL_200;
              }
              v48 = v47;
              v49 = v23;
              sub_1000C9564((uint64_t)v37, v47);
              v50 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Adding HS20 Account: %@", "WiFiDeviceManagerSetNetworks", v48);
              objc_autoreleasePoolPop(v50);
              CFRelease(v48);
              if (sub_100007F24((uint64_t)v37))
                v51 = v139;
              else
                v51 = v134;
              goto LABEL_100;
            }
            v53 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device does not support HS2.0. Will not program HS2.0 account", "WiFiDeviceManagerSetNetworks");
            objc_autoreleasePoolPop(v53);
          }
          else
          {
            if (!sub_100007F24((uint64_t)v37))
            {
              v49 = v23;
              v54 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping disabled network %@", "WiFiDeviceManagerSetNetworks", sub_10002B088(v37));
              objc_autoreleasePoolPop(v54);
              v51 = theArray;
LABEL_100:
              CFArrayAppendValue(v51, v37);
              goto LABEL_105;
            }
            if (sub_1000CAEC8((uint64_t)v37))
            {
              v49 = v23;
              v52 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is disabled until first user join", "WiFiDeviceManagerSetNetworks", sub_10002B088(v37));
              goto LABEL_104;
            }
            if (sub_1000CAF9C((const __CFDictionary **)v37))
            {
              v49 = v23;
              v52 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping infrequently joined public network %@", "WiFiDeviceManagerSetNetworks", sub_10002B088(v37));
LABEL_104:
              objc_autoreleasePoolPop(v52);
LABEL_105:
              a2 = v138;
              v23 = v49;
              goto LABEL_106;
            }
            CFArrayAppendValue(v132, v37);
            if (CFSetContainsValue(*(CFSetRef *)(a1 + 3504), v37))
              CFSetAddValue(theSet, v37);
            if (sub_100031670(v37))
              CFArrayAppendValue(v130, v37);
          }
LABEL_95:
          a2 = v138;
LABEL_106:
          if (v33 == ++v34)
            goto LABEL_113;
        }
        v39 = v23;
        v40 = sub_1000C4110((uint64_t)v37);
        v41 = sub_1000C4110((uint64_t)v12);
        v42 = v41;
        if (v41 && v40)
        {
          if (CFEqual(v41, v40))
          {
            v43 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: connected to the same HS2.0 BSSID, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks");
            objc_autoreleasePoolPop(v43);
            v39 = 0;
            v12 = (void *)cf;
          }
        }
        else if (!v41)
        {
LABEL_71:
          if (v40)
            CFRelease(v40);
          v23 = v39;
          goto LABEL_74;
        }
        CFRelease(v42);
        goto LABEL_71;
      }
      v35 = 0;
LABEL_113:
      if (*(_QWORD *)(a1 + 3512))
      {
        v19 = v139;
        v55 = v132;
        if (v35)
        {
          v58 = v130;
          v13 = kCFAllocatorDefault;
        }
        else
        {
          v56 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: previous network %@ forgotten/disabled.", "WiFiDeviceManagerSetNetworks", sub_10002B088(*(const void **)(a1 + 3512)));
          objc_autoreleasePoolPop(v56);
          v57 = *(const void **)(a1 + 3512);
          v58 = v130;
          v13 = kCFAllocatorDefault;
          if (v57)
          {
            CFRelease(v57);
            *(_QWORD *)(a1 + 3512) = 0;
          }
        }
LABEL_122:
        v59 = CFEqual(v55, *(CFTypeRef *)(a1 + 3528))
           && CFEqual(v58, *(CFTypeRef *)(a1 + 3536))
           && CFEqual(v19, *(CFTypeRef *)(a1 + 3624)) != 0;
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3528));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3536));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3624));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3632));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3328));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3640));
        v60 = *(__CFArray **)(a1 + 3528);
        v150.length = CFArrayGetCount(v55);
        v61 = v55;
        v150.location = 0;
        CFArrayAppendArray(v60, v55, v150);
        v62 = *(__CFArray **)(a1 + 3536);
        v151.length = CFArrayGetCount(v58);
        v151.location = 0;
        CFArrayAppendArray(v62, v58, v151);
        v63 = *(__CFArray **)(a1 + 3624);
        v152.length = CFArrayGetCount(v19);
        v152.location = 0;
        CFArrayAppendArray(v63, v19, v152);
        v64 = *(__CFArray **)(a1 + 3632);
        v153.length = CFArrayGetCount(v134);
        v153.location = 0;
        CFArrayAppendArray(v64, v134, v153);
        v65 = CFArrayGetCount(v19);
        v131 = v23;
        if (!v65)
          goto LABEL_160;
        v66 = v65;
        LOWORD(valuePtr[0]) = 268;
        value = CFNumberCreate(v13, kCFNumberSInt16Type, valuePtr);
        if (!value)
          goto LABEL_160;
        LOWORD(valuePtr[0]) = 3;
        v128 = CFNumberCreate(v13, kCFNumberSInt16Type, valuePtr);
        if (!v128)
        {
          v75 = value;
LABEL_159:
          CFRelease(v75);
          goto LABEL_160;
        }
        v127 = v59;
        LOWORD(valuePtr[0]) = 263;
        v67 = CFNumberCreate(v13, kCFNumberSInt16Type, valuePtr);
        if (v67)
        {
          LOWORD(valuePtr[0]) = 264;
          v68 = CFNumberCreate(v13, kCFNumberSInt16Type, valuePtr);
          if (v68)
          {
            LOWORD(valuePtr[0]) = 261;
            v69 = CFNumberCreate(v13, kCFNumberSInt16Type, valuePtr);
            if (v69)
            {
              v136 = v69;
              if (v66 >= 1)
              {
                for (i = 0; i != v66; ++i)
                {
                  v71 = CFArrayGetValueAtIndex(v19, i);
                  if (v71)
                  {
                    v72 = (uint64_t)v71;
                    if (sub_10002BE64((uint64_t)v71, CFSTR("DomainName")))
                    {
                      v146.length = CFArrayGetCount(v140);
                      v146.location = 0;
                      if (!CFArrayContainsValue(v140, v146, value))
                        CFArrayAppendValue(v140, value);
                    }
                    if (sub_10002BE64(v72, CFSTR("NaiRealmName")))
                    {
                      v147.length = CFArrayGetCount(v140);
                      v147.location = 0;
                      if (!CFArrayContainsValue(v140, v147, v67))
                        CFArrayAppendValue(v140, v67);
                    }
                    if (sub_10002BE64(v72, CFSTR("MCCandMNC")))
                    {
                      v148.length = CFArrayGetCount(v140);
                      v148.location = 0;
                      if (!CFArrayContainsValue(v140, v148, v68))
                        CFArrayAppendValue(v140, v68);
                    }
                    if (sub_10002BE64(v72, CFSTR("RoamingConsortiumOIs")))
                    {
                      v149.length = CFArrayGetCount(v140);
                      v149.location = 0;
                      if (!CFArrayContainsValue(v140, v149, v136))
                        CFArrayAppendValue(v140, v136);
                    }
                  }
                  v19 = v139;
                }
              }
              v20 = v140;
              if (CFArrayGetCount(v140))
              {
                v73 = v128;
                CFArrayAppendValue(v140, v128);
                v74 = objc_autoreleasePoolPush();
                v61 = v132;
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: created queries %@", "__WiFiDeviceManagerPrepareHS20Queries", v140);
              }
              else
              {
                v74 = objc_autoreleasePoolPush();
                v61 = v132;
                v73 = v128;
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Nothing to query about", "__WiFiDeviceManagerPrepareHS20Queries", v125);
              }
              objc_autoreleasePoolPop(v74);
              v75 = v136;
LABEL_154:
              CFRelease(value);
              CFRelease(v73);
              if (v67)
                CFRelease(v67);
              if (v68)
                CFRelease(v68);
              v59 = v127;
              if (v75)
                goto LABEL_159;
LABEL_160:
              v76 = *(__CFArray **)(a1 + 3328);
              v154.length = CFArrayGetCount(v20);
              v154.location = 0;
              CFArrayAppendArray(v76, v20, v154);
              v77 = *(__CFArray **)(a1 + 3640);
              v155.length = CFArrayGetCount(theArray);
              v155.location = 0;
              CFArrayAppendArray(v77, theArray, v155);
              v78 = *(const void **)(a1 + 3504);
              if (v78)
                CFRelease(v78);
              v12 = (void *)cf;
              *(_QWORD *)(a1 + 3504) = theSet;
              v79 = !v59;
              if (!cf)
                v79 = 1;
              Mutable = v61;
              if ((v79 & 1) == 0 && sub_10000BE8C((uint64_t)cf))
              {
                sub_1000FE648((uint64_t *)a1, cf, 0, 0);
                sub_1000FE9FC(a1, cf);
              }
              sub_1000FEDDC(a1);
              *(_WORD *)(a1 + 6600) = sub_1000FEEC0(a1, cf);
              if (!v59 || *(_DWORD *)(a1 + 5520) == 1)
              {
                if ((_DWORD)v23)
                {
LABEL_170:
                  sub_1000FB44C(a1);
                  goto LABEL_176;
                }
                if (cf)
                {
                  v80 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: known network list changed while associated, updating autojoin network list", "WiFiDeviceManagerSetNetworks");
                  objc_autoreleasePoolPop(v80);
                  sub_1000FEFA0(a1);
                }
                else if (*(_DWORD *)(a1 + 5520) == 1)
                {
                  goto LABEL_170;
                }
LABEL_176:
                if (*(_DWORD *)(a1 + 5520) == 1)
                {
                  sub_1000750A0(*(_QWORD *)(a1 + 64));
                  v81 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Aborting scan...", "WiFiDeviceManagerSetNetworks");
                  objc_autoreleasePoolPop(v81);
                }
                v82 = !v59;
                *(_DWORD *)(a1 + 28) = 0;
                sub_1000FBAD0(a1, 2, (uint64_t)"WiFiDeviceManagerSetNetworks");
                if (cf)
                {
                  v83 = (const __CFNumber *)sub_1000316E0((uint64_t)cf);
                  if (v83)
                    CFNumberGetValue(v83, kCFNumberIntType, &v141);
                  v84 = objc_autoreleasePoolPush();
                  v85 = (void *)qword_10026DD20;
                  if (!qword_10026DD20)
                    goto LABEL_188;
                  v86 = (const __CFString *)sub_10002B088(cf);
                  v87 = v141;
                  v88 = sub_1000316E0((uint64_t)cf);
                  v89 = sub_10003153C((uint64_t)v88);
                }
                else
                {
                  v90 = objc_autoreleasePoolPush();
                  v84 = v90;
                  v85 = (void *)qword_10026DD20;
                  if (!qword_10026DD20)
                  {
                    objc_autoreleasePoolPop(v90);
                    v12 = (void *)cf;
                    goto LABEL_192;
                  }
                  v89 = 0xFFFFFFFFLL;
                  v86 = CFSTR("None");
                  v87 = v141;
                }
                objc_msgSend(v85, "WFLog:message:", 3, "%s: currentNetwork: %@, channel: %d band: %d shouldDisassociate %d", "WiFiDeviceManagerSetNetworks", v86, v87, v89, v131);
                Mutable = v61;
LABEL_188:
                objc_autoreleasePoolPop(v84);
                v12 = (void *)cf;
                v19 = v139;
                if (cf && (_DWORD)v131)
                {
                  v91 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
                  sub_1000F7F48(a1, v91, 1003, "WiFiDeviceManagerSetNetworks", 6178);
                }
LABEL_192:
                if (*(_DWORD *)(a1 + 5520) != 1)
                  goto LABEL_200;
                *(_BYTE *)(a1 + 1064) = 0;
                if (!v126[1840] || !v126[3] || *v126 < 0xFu || (v126[1841] & 4) == 0)
                {
                  v92 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: 5Ghz MIS is inactive\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
                  objc_autoreleasePoolPop(v92);
LABEL_200:
                  if (!v19)
                    goto LABEL_202;
                  goto LABEL_201;
                }
                if (CFArrayGetCount(v138) == 1)
                {
                  v97 = CFArrayGetValueAtIndex(v138, 0);
                  if (sub_10000BE8C((uint64_t)v97))
                  {
                    if (sub_10002BE64((uint64_t)v97, CFSTR("CHANNEL")))
                    {
                      v98 = sub_100017A54((uint64_t)v97, CFSTR("CHANNEL"));
                      v142 = v98;
                      if (v98 <= 0x23)
                      {
                        v118 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: 2.4 Ghz CarPlay network\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin", v125);
                      }
                      else
                      {
                        v99 = (const __CFArray *)sub_10002BE64((uint64_t)v97, CFSTR("networkKnownBSSListKey"));
                        if (v99)
                        {
                          v100 = v99;
                          if (CFArrayGetCount(v99) >= 1)
                          {
                            v101 = 0;
                            while (1)
                            {
                              v102 = (const __CFDictionary *)CFArrayGetValueAtIndex(v100, v101);
                              v103 = (const __CFNumber *)CFDictionaryGetValue(v102, CFSTR("CHANNEL"));
                              v104 = CFDictionaryGetValue(v102, CFSTR("CHANNEL_FLAGS"));
                              if (v103)
                              {
                                if (v104)
                                {
                                  CFNumberGetValue(v103, kCFNumberSInt32Type, &v142);
                                  if (v142 < 0xF)
                                    break;
                                }
                              }
                              if (CFArrayGetCount(v100) <= ++v101)
                                goto LABEL_235;
                            }
                            v118 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: 2.4 Ghz channel is available\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin", v125);
                            goto LABEL_258;
                          }
                        }
LABEL_235:
                        v19 = v139;
                        if (!v126[1840] || !sub_100107828(a1, 1))
                        {
                          v117 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Concurrent mode is not allowed\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
                          goto LABEL_254;
                        }
                        if (sub_10006E3B0(*(_QWORD *)(a1 + 64), (int)v98))
                        {
                          if (sub_10006E2B4(*(_QWORD *)(a1 + 64), (int)v98))
                          {
                            v118 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Channel (%d) is DFS channel\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin", v98);
                          }
                          else if (sub_1001102D8(a1, (uint64_t)v98))
                          {
                            v118 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Channel (%d) is coex denylisted\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin", v98);
                          }
                          else
                          {
                            if (*v126 == v98)
                              goto LABEL_250;
                            if (*(_DWORD *)(a1 + 5264) == 80)
                              v105 = 1040;
                            else
                              v105 = 18;
                            v144 = v105;
                            valuePtr[0] = (_DWORD)v98;
                            v143 = 1;
                            v106 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                            if (v106)
                            {
                              v107 = v106;
                              v108 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, valuePtr);
                              if (v108)
                              {
                                v109 = v108;
                                CFDictionarySetValue(v107, CFSTR("IO80211InterfaceSoftAPCSAChannel"), v108);
                                CFRelease(v109);
                                v110 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v144);
                                if (v110)
                                {
                                  v111 = v110;
                                  CFDictionarySetValue(v107, CFSTR("IO80211InterfaceSoftAPCSAChannelFlag"), v110);
                                  CFRelease(v111);
                                  v112 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v143);
                                  if (v112)
                                  {
                                    v113 = v112;
                                    CFDictionarySetValue(v107, CFSTR("IO80211InterfaceSoftAPCSASwitchCount"), v112);
                                    CFRelease(v113);
                                    CFDictionarySetValue(v107, CFSTR("IO80211InterfaceSoftAPCSAForceDisconnect"), kCFBooleanFalse);
                                    v114 = *(_QWORD *)(a1 + 64);
                                    v115 = (const void *)sub_100025C3C(v114);
                                    v116 = sub_1000672C0(v114, v115, 349, 0, (uint64_t)v107);
                                    if (!(_DWORD)v116)
                                    {
                                      *v126 = valuePtr[0];
                                      CFRelease(v107);
LABEL_250:
                                      *(_BYTE *)(a1 + 1064) = 1;
                                      v117 = objc_autoreleasePoolPush();
                                      if (qword_10026DD20)
                                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Allow 5Ghz CarPlay & Hotspot concurrent mode\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
LABEL_254:
                                      objc_autoreleasePoolPop(v117);
LABEL_255:
                                      v12 = (void *)cf;
                                      v20 = v140;
                                      goto LABEL_200;
                                    }
                                    v123 = v116;
                                    v124 = objc_autoreleasePoolPush();
                                    if (qword_10026DD20)
                                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to switch MIS channel to %d, err %d", "__WiFiDeviceManagerSwitchMISChannel", valuePtr[0], v123);
                                    objc_autoreleasePoolPop(v124);
                                    v19 = v139;
                                  }
                                }
                              }
                              CFRelease(v107);
                              goto LABEL_255;
                            }
                            v118 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "__WiFiDeviceManagerSwitchMISChannel", v125);
                          }
                        }
                        else
                        {
                          v118 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid channel (%d)\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin", v98);
                        }
                      }
                    }
                    else
                    {
                      v118 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No channel inform\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
                    }
                  }
                  else
                  {
                    v118 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Not CarPlay network\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
                  }
                }
                else
                {
                  v118 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Not CarPlay join\n", "__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin");
                }
LABEL_258:
                objc_autoreleasePoolPop(v118);
                v12 = (void *)cf;
                v19 = v139;
                v20 = v140;
                goto LABEL_200;
              }
LABEL_268:
              v82 = 0;
              goto LABEL_200;
            }
          }
          v75 = 0;
        }
        else
        {
          v75 = 0;
          v68 = 0;
        }
        v73 = v128;
        goto LABEL_154;
      }
      v58 = v130;
      v19 = v139;
      v13 = kCFAllocatorDefault;
    }
    else
    {
      v122 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networks", "WiFiDeviceManagerSetNetworks");
      objc_autoreleasePoolPop(v122);
      v58 = v130;
    }
    v55 = v132;
    goto LABEL_122;
  }
  v121 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create disabledNetworks array", "WiFiDeviceManagerSetNetworks");
  objc_autoreleasePoolPop(v121);
  v82 = 0;
  theArray = 0;
LABEL_201:
  CFRelease(v19);
LABEL_202:
  if (v20)
    CFRelease(v20);
  v93 = theArray;
  if (v12)
LABEL_205:
    CFRelease(v12);
LABEL_206:
  if (v130)
    CFRelease(v130);
  if (Mutable)
    CFRelease(Mutable);
  if (v134)
    CFRelease(v134);
  if (v93)
    CFRelease(v93);
  *(_DWORD *)(a1 + 192) = 14;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if (*(_DWORD *)(a1 + 5520) == 1)
    {
      v94 = a1;
      v95 = 32;
LABEL_222:
      sub_1000285E4(v94, v95);
      return sub_1000FF824(a1);
    }
    if (v126[3605])
    {
      v94 = a1;
      v95 = 33;
      goto LABEL_222;
    }
    if (v82)
    {
      v94 = a1;
      v95 = 5;
      goto LABEL_222;
    }
  }
  else
  {
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 5, sub_100025C3C(*(_QWORD *)(a1 + 64)));
    sub_1000FBA80(a1, 0, (uint64_t)"WiFiDeviceManagerSetNetworks");
  }
  return sub_1000FF824(a1);
}

void sub_1000FE2A4(uint64_t a1)
{
  const void *v2;
  void *v3;
  void *v4;

  if (a1)
  {
    v2 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v3 = sub_10002A21C(a1, v2, 1);
    if (v3)
      CFRelease(v3);
    v4 = objc_autoreleasePoolPush();
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerForceUpdateCachedCurrentNetwork");
  }
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_1000FE330(uint64_t a1)
{
  return *(_QWORD *)(a1 + 6656);
}

BOOL sub_1000FE338(_QWORD *a1, const void *a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v7;
  CFRange v8;
  CFRange v9;
  CFRange v10;

  v4 = (const __CFArray *)a1[441];
  v8.length = CFArrayGetCount(v4);
  v8.location = 0;
  if (CFArrayContainsValue(v4, v8, a2))
    return 1;
  v5 = (const __CFArray *)a1[455];
  v9.length = CFArrayGetCount(v5);
  v9.location = 0;
  if (CFArrayContainsValue(v5, v9, a2))
    return 1;
  v7 = (const __CFArray *)a1[442];
  v10.length = CFArrayGetCount(v7);
  v10.location = 0;
  return CFArrayContainsValue(v7, v10, a2) != 0;
}

uint64_t sub_1000FE3D8(uint64_t a1, const void *a2)
{
  uint64_t result;
  const __CFArray *v5;
  const __CFArray *v6;
  CFRange v7;
  CFRange v8;

  if (!a2)
    return 0;
  result = sub_10002DA5C((_BOOL8)a2);
  if ((_DWORD)result)
  {
    v5 = *(const __CFArray **)(a1 + 3624);
    v7.length = CFArrayGetCount(v5);
    v7.location = 0;
    if (CFArrayContainsValue(v5, v7, a2))
    {
      return 1;
    }
    else
    {
      v6 = *(const __CFArray **)(a1 + 3632);
      v8.length = CFArrayGetCount(v6);
      v8.location = 0;
      return CFArrayContainsValue(v6, v8, a2) != 0;
    }
  }
  return result;
}

void sub_1000FE46C(uint64_t a1, const void *a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  BOOL v6;
  const __CFString *v8;
  _BOOL8 v9;
  void *v10;
  void *v11;
  unsigned int v12;
  const __CFString *v13;
  const __CFNumber *v14;
  char buffer[16];

  memset(buffer, 170, sizeof(buffer));
  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 72);
    v4 = v3 > 0xB;
    v5 = (1 << v3) & 0x80E;
    v6 = v4 || v5 == 0;
    if (!v6 && sub_100025C3C(*(_QWORD *)(a1 + 64)))
    {
      v8 = (const __CFString *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      CFStringGetCString(v8, buffer, 16, 0x8000100u);
      v9 = sub_1000CAB28((uint64_t)a2) != 0;
      network_config_set_interface_constrained(buffer, v9);
      v10 = objc_autoreleasePoolPush();
      v11 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v12 = sub_100008280((uint64_t)a2);
        v13 = sub_100064DC0(v12);
        v14 = sub_100008280((uint64_t)a2);
        objc_msgSend(v11, "WFLog:message:", 3, "%s: updated save data mode to %@(%d) for network %@", "__WiFiDeviceManagerApplyConstrainedInterfaceConfig", v13, v14, sub_10002B088(a2));
      }
      objc_autoreleasePoolPop(v10);
    }
  }
}

void sub_1000FE5A4(uint64_t a1, const void *a2)
{
  const void *v4;
  void *v5;
  const __CFArray *v6;

  v4 = *(const void **)(a1 + 3512);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 3512) = 0;
  }
  if (a2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s, %@", "WiFiDeviceManagerSetPreviousNetwork", a2);
    objc_autoreleasePoolPop(v5);
    v6 = sub_10002B170(a1, a2, 1);
    *(_QWORD *)(a1 + 3512) = v6;
    if (!v6)
      *(_QWORD *)(a1 + 3512) = CFRetain(a2);
  }
}

void sub_1000FE648(uint64_t *a1, const void *a2, char a3, uint64_t a4)
{
  _QWORD *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  void *v14;
  const __CFDictionary *v15;
  const void *Value;
  void *v17;
  const char *v18;
  void (*v19)(uint64_t *, _QWORD, uint64_t, uint64_t);
  void *v20;
  const char *v21;
  void *v22;
  _QWORD v23[6];
  int v24;

  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no link on interface. Setting primary to never.", "__WiFiDeviceManagerSetInterfaceRank");
    objc_autoreleasePoolPop(v14);
    if (a1[683])
    {
      v10 = 0;
      v13 = 0;
      v11 = 2863311530;
      v8 = a1 + 683;
      v12 = 3;
      if ((a3 & 1) == 0)
        goto LABEL_12;
      goto LABEL_10;
    }
LABEL_46:
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: netif is NULL!!!", "__WiFiDeviceManagerSetInterfaceRank");
    objc_autoreleasePoolPop(v22);
    return;
  }
  if (!a1[683])
    goto LABEL_46;
  v8 = a1 + 683;
  v9 = sub_10002B170((uint64_t)a1, a2, 1);
  v10 = v9;
  if (v9)
  {
    v11 = sub_1000CA608((uint64_t)v9);
    v12 = 0;
    v13 = (v11 - 1) < 2;
    if ((a3 & 1) == 0)
    {
LABEL_12:
      a1[697] = 0;
      if (v10)
      {
        if ((v11 - 1) <= 1)
        {
          v15 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("11U_INTERWORKING_IE"));
          if (v15)
          {
            Value = CFDictionaryGetValue(v15, CFSTR("INTERWORKING_ACCESS_INTERNET"));
            a1[697] = (uint64_t)Value;
            if (Value)
            {
              v17 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                if ((const CFBooleanRef)a1[697] == kCFBooleanTrue)
                  v18 = "SET";
                else
                  v18 = "ZERO";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: internetAccess bit %s for network %@", "__WiFiDeviceManagerSetInterfaceRank", v18, sub_10002B088(a2));
              }
              objc_autoreleasePoolPop(v17);
            }
          }
          if ((_DWORD)v11 == 2)
          {
            v12 = 0;
          }
          else if ((_DWORD)v11 == 1)
          {
            v12 = 3;
          }
          v19 = (void (*)(uint64_t *, _QWORD, uint64_t, uint64_t))a1[541];
          if (v19)
            v19(a1, 0, a1[542], v11);
          v13 = 1;
        }
        sub_1000FE46C((uint64_t)a1, v10);
      }
      goto LABEL_30;
    }
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v11 = 2863311530;
    if ((a3 & 1) == 0)
      goto LABEL_12;
  }
LABEL_10:
  v12 = a4;
LABEL_30:
  if (!(_DWORD)v12
    && !v13
    && _os_feature_enabled_impl("WiFiManager", "AdaptiveInterfaceRanking")
    && +[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"))
  {
    if (-[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
    {
      -[WiFiAIRAgent terminateRequest](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "terminateRequest");
    }
    sub_1000247B8(a1[15], 1, 0);
    SCNetworkInterfaceSetPrimaryRank(a1[683], 3);
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_1001261B8;
    v23[3] = &unk_1002317C0;
    v24 = 0;
    v23[4] = a1;
    v23[5] = a2;
    -[WiFiAIRAgent waitForConfirmationWithTimeout:withBssEnvironment:withMgrCallback:](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "waitForConfirmationWithTimeout:withBssEnvironment:withMgrCallback:", a2, sub_100126120((uint64_t)a1, a2), v23);
    if (!v10)
      return;
LABEL_44:
    CFRelease(v10);
    return;
  }
  SCNetworkInterfaceSetPrimaryRank(*v8, v12);
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if ((_DWORD)v12)
      v21 = "kSCNetworkServicePrimaryRankNever";
    else
      v21 = "kSCNetworkServicePrimaryRankDefault";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting interface rank %s for network %@", "__WiFiDeviceManagerSetInterfaceRank", v21, sub_10002B088(a2));
  }
  objc_autoreleasePoolPop(v20);
  if (v10)
    goto LABEL_44;
}

void sub_1000FE9FC(uint64_t a1, const void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  uint64_t v5;
  const __CFString *v6;
  const __CFString *NetworkInterfaceEntity;
  const __CFString *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFNumber *Value;
  unsigned int v12;
  void *v13;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  __CFDictionary *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  unsigned int valuePtr;
  int v25;

  valuePtr = 0;
  if (!a1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
    goto LABEL_28;
  }
  if (!*(_QWORD *)(a1 + 5464))
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: netif is NULL", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
    goto LABEL_28;
  }
  if (!*(_QWORD *)(a1 + 5440))
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: dynamicStoreRef is NULL", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
    goto LABEL_28;
  }
  v3 = sub_10002B170(a1, a2, 1);
  if (!v3)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no matching known network", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
LABEL_28:
    objc_autoreleasePoolPop(v19);
    return;
  }
  v4 = v3;
  v5 = sub_1000CA608((uint64_t)v3);
  v25 = v5;
  v6 = (const __CFString *)sub_100029860(*(_QWORD *)(a1 + 64));
  if (!v6)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: interfaceName is NULL.", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
    goto LABEL_33;
  }
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, v6, kSCEntNetAirPort);
  if (!NetworkInterfaceEntity)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: stateKey is NULL.", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
LABEL_33:
    objc_autoreleasePoolPop(v20);
    CFRelease(v4);
    return;
  }
  v8 = NetworkInterfaceEntity;
  v9 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 5440), NetworkInterfaceEntity);
  if (v9)
  {
    v10 = v9;
    Value = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("WiFiNetworkType"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      v12 = valuePtr;
    }
    else
    {
      v12 = 0;
    }
    if (v12 != (_DWORD)v5)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: update the network type from %d to %d", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry", valuePtr, v5);
      objc_autoreleasePoolPop(v13);
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v10);
      if (MutableCopy)
      {
        v15 = MutableCopy;
        v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v25);
        if (v16)
        {
          v17 = v16;
          CFDictionarySetValue(v15, CFSTR("WiFiNetworkType"), v16);
          SCDynamicStoreSetValue(*(SCDynamicStoreRef *)(a1 + 5440), v8, v15);
          CFRelease(v15);
          v18 = v17;
        }
        else
        {
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: networkTypeNum is NULL", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
          objc_autoreleasePoolPop(v23);
          v18 = v15;
        }
        CFRelease(v18);
      }
      else
      {
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: newConfig is NULL", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
        objc_autoreleasePoolPop(v22);
      }
    }
    CFRelease(v10);
  }
  else
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: config is NULL.", "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry");
    objc_autoreleasePoolPop(v21);
  }
  CFRelease(v4);
  CFRelease(v8);
}

void sub_1000FEDDC(uint64_t a1)
{
  void *v2;
  NSMutableArray *v3;
  uint64_t v4;
  int v5;
  unsigned __int16 v6;
  id v7;
  CFRange v8;

  v2 = objc_autoreleasePoolPush();
  v3 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", *(_QWORD *)(a1 + 3528));
  -[NSMutableArray addObjectsFromArray:](v3, "addObjectsFromArray:", *(_QWORD *)(a1 + 3624));
  v8.length = (CFIndex)-[NSMutableArray count](v3, "count");
  v8.location = 0;
  CFArraySortValues((CFMutableArrayRef)v3, v8, (CFComparatorFunction)sub_1000C88A0, 0);
  if (-[NSMutableArray count](v3, "count"))
  {
    v4 = 0;
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = -[NSMutableArray objectAtIndexedSubscript:](v3, "objectAtIndexedSubscript:", v4);
      if (sub_10002DFE4((uint64_t)v7) != 0.0 && sub_1000CBD04((uint64_t)v7) != v6)
        sub_1000CBCFC((uint64_t)v7, v6++);
      v4 = (unsigned __int16)++v5;
    }
    while ((unint64_t)-[NSMutableArray count](v3, "count") > (unsigned __int16)v5);
  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1000FEEC0(uint64_t a1, const void *a2)
{
  uint64_t v2;
  void *v5;
  NSMutableArray *v6;
  uint64_t v7;
  int v8;
  id v9;
  const __CFString *v10;
  const __CFString *v11;

  v2 = 0xFFFFLL;
  if (a1 && a2)
  {
    v5 = objc_autoreleasePoolPush();
    v6 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", *(_QWORD *)(a1 + 3528));
    -[NSMutableArray addObjectsFromArray:](v6, "addObjectsFromArray:", *(_QWORD *)(a1 + 3624));
    if (-[NSMutableArray count](v6, "count"))
    {
      v7 = 0;
      v8 = 0;
      while (1)
      {
        v9 = -[NSMutableArray objectAtIndexedSubscript:](v6, "objectAtIndexedSubscript:", v7);
        v10 = (const __CFString *)sub_10002B088(v9);
        v11 = (const __CFString *)sub_10002B088(a2);
        if (CFStringCompare(v10, v11, 0) == kCFCompareEqualTo)
          break;
        v7 = (unsigned __int16)++v8;
        if ((unint64_t)-[NSMutableArray count](v6, "count") <= (unsigned __int16)v8)
          goto LABEL_7;
      }
      v2 = sub_1000CBD04((uint64_t)v9);
    }
    else
    {
LABEL_7:
      v2 = 0xFFFFLL;
    }
    objc_autoreleasePoolPop(v5);
  }
  return v2;
}

void sub_1000FEFA0(uint64_t a1)
{
  uint64_t v2;
  const __CFNumber *v3;
  const __CFDate *v4;
  const __CFDate *v5;
  double Current;
  void *v7;
  const void *v8;
  uint64_t v9;
  double v10;
  NSString *v11;
  const char *v12;
  _BOOL4 v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  void *ValueAtIndex;
  const void *v18;
  const void *v19;
  void *v20;
  const void *v21;
  const __CFString *v22;
  const __CFString *v23;
  const void *v24;
  const __CFString *v25;
  const __CFString *v26;
  void *v27;
  NSString *v28;
  const char *v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex j;
  void *v33;
  const void *v34;
  void *v35;
  NSString *v36;
  const char *v37;
  const void *v38;
  CFIndex v39;
  CFMutableStringRef Mutable;
  __CFString *v41;
  const __CFArray *v42;
  CFIndex v43;
  uint64_t v44;
  CFIndex v45;
  uint64_t v46;
  const void *v47;
  const void *v48;
  const __CFString *v49;
  const __CFString *v50;
  const __CFString *v51;
  void *v52;
  NSString *v53;
  const char *v54;
  int v55;
  unsigned int valuePtr;
  uint8_t buf[4];
  const char *v58;
  CFRange v59;
  CFRange v60;
  CFRange v61;

  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3576));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3544));
  v2 = *(_QWORD *)(a1 + 3512);
  if (!v2
    || !sub_10001395C(v2)
    || sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("WiFiInstantHotspotJoining")) != kCFBooleanTrue
    && sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("WiFiAutoInstantHotspotJoining")) != kCFBooleanTrue)
  {
    goto LABEL_13;
  }
  v3 = (const __CFNumber *)sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("lastDisconnectReasonKey"));
  if (!v3)
    goto LABEL_13;
  valuePtr = -1431655766;
  CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
  if (valuePtr >= 3)
  {
    v55 = 0;
    v13 = valuePtr == 1019;
    goto LABEL_14;
  }
  v4 = (const __CFDate *)sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("lastDisconnectTimestampKey"));
  if (!v4 || (v5 = v4, Current = CFAbsoluteTimeGetCurrent(), Current - CFDateGetAbsoluteTime(v5) >= 300.0))
  {
LABEL_13:
    v55 = 0;
    v13 = 0;
    goto LABEL_14;
  }
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v8 = sub_10002B088(*(const void **)(a1 + 3512));
    v9 = valuePtr;
    v10 = CFAbsoluteTimeGetCurrent();
    v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s Previous Hotspot %@ disconnect reason %d time since linkDown %.1f"), "__WiFiDeviceManagerFilterNetworks", v8, v9, v10 - CFDateGetAbsoluteTime(v5))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v12 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v11, "UTF8String")), "UTF8String");
      *(_DWORD *)buf = 136446210;
      v58 = v12;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v7);
  v13 = 0;
  v55 = 1;
LABEL_14:
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
  if (Count >= 1)
  {
    v15 = Count;
    for (i = 0; i != v15; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), i);
      if (ValueAtIndex)
      {
        v18 = ValueAtIndex;
        if (sub_100124B34(a1, ValueAtIndex, 1u))
        {
          if (!*(_BYTE *)(a1 + 6896)
            || (v19 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64)), (v20 = sub_10002A21C(a1, v19, 1)) == 0)
            || (v21 = v20,
                v22 = sub_10003149C(v20),
                v23 = sub_10003149C(v18),
                LODWORD(v22) = CFEqual(v22, v23),
                CFRelease(v21),
                !(_DWORD)v22))
          {
            if (!v13
              || (v24 = *(const void **)(a1 + 3512)) == 0
              || (v25 = sub_10003149C(v24), v26 = sub_10003149C(v18), !CFEqual(v25, v26)))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3544), v18);
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3576), v18);
            }
          }
        }
        else
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v28 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: %@ not suitable"), "__WiFiDeviceManagerFilterNetworks", sub_10002B088(v18))), "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              v29 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v28, "UTF8String")), "UTF8String");
              *(_DWORD *)buf = 136446210;
              v58 = v29;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
          }
          objc_autoreleasePoolPop(v27);
        }
      }
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
  v30 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3536));
  if (v30 >= 1)
  {
    v31 = v30;
    for (j = 0; j != v31; ++j)
    {
      v33 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), j);
      if (v33)
      {
        v34 = v33;
        if (sub_100124B34(a1, v33, 1u))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3552), v34);
          v59.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576));
          v59.location = 0;
          if (CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3576), v59, v34) == -1)
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3576), v34);
        }
        else
        {
          v35 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v36 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: %@ not suitable"), "__WiFiDeviceManagerFilterNetworks", sub_10002B088(v34))), "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              v37 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v36, "UTF8String")), "UTF8String");
              *(_DWORD *)buf = 136446210;
              v58 = v37;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
          }
          objc_autoreleasePoolPop(v35);
        }
      }
    }
  }
  if (v55)
  {
    v38 = *(const void **)(a1 + 3512);
    if (v38)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3552), v38);
      v60.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576));
      v60.location = 0;
      if (CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3576), v60, *(const void **)(a1 + 3512)) == -1)
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3576), *(const void **)(a1 + 3512));
    }
  }
  v39 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576));
  if (v39)
  {
    v61.length = v39;
    v61.location = 0;
    CFArraySortValues(*(CFMutableArrayRef *)(a1 + 3576), v61, (CFComparatorFunction)sub_1000C894C, 0);
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
  {
    v41 = Mutable;
    v42 = *(const __CFArray **)(a1 + 3576);
    if (v42)
    {
      v43 = CFArrayGetCount(v42);
      if (v43)
      {
        v44 = v43;
        if (v43 >= 1)
        {
          v45 = 0;
          if (v43 >= 5)
            v46 = 5;
          else
            v46 = v43;
          do
          {
            v47 = CFArrayGetValueAtIndex(v42, v45);
            if (v47)
            {
              v48 = v47;
              if (sub_100007DCC(v47))
              {
                v49 = (const __CFString *)sub_10002BE64((uint64_t)v48, CFSTR("BSSID"));
                if (v49)
                  v50 = v49;
                else
                  v50 = CFSTR("null-bssid!");
              }
              else
              {
                v51 = (const __CFString *)sub_10002B088(v48);
                if (v51)
                  v50 = v51;
                else
                  v50 = CFSTR("null-ssid!");
              }
              CFStringAppend(v41, v50);
              CFStringAppendFormat(v41, 0, CFSTR(" "));
            }
            ++v45;
          }
          while (v46 != v45);
          if (v44 >= 6)
            CFStringAppendFormat(v41, 0, CFSTR(" ..."));
        }
      }
    }
    v52 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v53 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: Filtered networks - %@"), "__WiFiDeviceManagerFilterNetworks", v41)), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v54 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v53, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v58 = v54;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v52);
    CFRelease(v41);
  }
}

uint64_t sub_1000FF824(uint64_t a1)
{
  void *v2;
  const __CFArray *Mutable;
  const void *v4;
  void *v5;
  CFIndex v6;
  int v7;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef *v9;
  id v10;
  id v11;
  void *v12;
  unsigned int v13;
  void *v14;
  BOOL v15;
  const __CFString *v16;
  const __CFString *v17;
  void *v18;
  unsigned int v19;
  const void *v20;
  const void *v21;
  const __CFBoolean *v22;
  const __CFDictionary *v23;
  const __CFNumber *v24;
  const __CFString *v25;
  const __CFString *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  id v30;
  id v31;
  unsigned int v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  void *v37;
  const char *v38;
  uint64_t v39;
  id v40;
  unsigned __int8 v41;
  char v42;
  uint64_t v43;
  char v44;
  void *v45;
  CFIndex v46;
  CFIndex v47;
  CFIndex v48;
  const void *v49;
  const void *v50;
  void *v51;
  const __CFArray *v52;
  CFRange v53;
  void *v54;
  __CFDictionary *v55;
  uint64_t v56;
  const void *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  const void *v61;
  __CFArray *v63;
  const char *v64;
  id v65;
  void *v66;
  __CFArray *theArray;
  void *value;
  const void *v69;
  unsigned int v70;
  unsigned int v71;
  CFIndex Count;
  int v73;
  void *v74;
  CFRange v75;
  CFRange v76;
  CFRange v77;
  CFRange v78;

  v2 = objc_autoreleasePoolPush();
  if (!sub_10006C530(*(_QWORD *)(a1 + 64)))
  {
    v34 = 0;
    goto LABEL_122;
  }
  if (*(_DWORD *)(a1 + 20) == 1)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (*(_DWORD *)(a1 + 176))
    {
      if (sub_1000F4958(a1))
      {
        theArray = Mutable;
        v66 = v2;
        v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
        v5 = sub_10002A21C(a1, v4, 1);
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
        value = v5;
        if (Count >= 1)
        {
          v6 = 0;
          v7 = 0;
          while (1)
          {
            ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v6);
            if (ValueAtIndex)
              break;
LABEL_34:
            if (Count == ++v6)
              goto LABEL_57;
          }
          v9 = ValueAtIndex;
          v73 = v7;
          v10 = sub_100027D10((uint64_t)ValueAtIndex);
          v11 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 3, v10);
          v71 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v10);
          v70 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v10, 0, 0);
          v12 = sub_100026664(v9);
          if (v12)
          {
            v13 = objc_msgSend(*(id *)(a1 + 8824), "isKnownNetworkDisallowed:", v12);
          }
          else
          {
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unable to create CWFNetworkProfile. Skipping isKnownNetworkDisallowed check", "WiFiDeviceManagerSetBackgroundScan");
            objc_autoreleasePoolPop(v14);
            v13 = 0;
          }

          if (byte_10026DD61)
            v15 = v5 == 0;
          else
            v15 = 1;
          if (v15
            || (v16 = (const __CFString *)sub_10002B088(v5),
                v17 = (const __CFString *)sub_10002B088(v9),
                CFStringCompare(v16, v17, 0) == kCFCompareEqualTo))
          {
            v19 = 1;
          }
          else
          {
            v18 = sub_100026664(v9);
            v19 = objc_msgSend(v18, "isAllowedInLockdownMode");

          }
          v20 = sub_10002B634(*(const __CFArray **)(a1 + 3704), v9);
          if (v20
            && (v21 = v20,
                v22 = (const __CFBoolean *)sub_10002BE64((uint64_t)v20, CFSTR("NetworkUsedForSWUpgrade")),
                (v23 = (const __CFDictionary *)sub_10002BE64((uint64_t)v21, CFSTR("PRIVATE_MAC_ADDRESS"))) != 0)
            && (v24 = (const __CFNumber *)CFDictionaryGetValue(v23, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"))) != 0
            && sub_100064F80(v24) == 1
            && v22
            && v22 == kCFBooleanTrue
            && v5
            && (v25 = (const __CFString *)sub_10002B088(v5),
                v26 = (const __CFString *)sub_10002B088(v21),
                CFStringCompare(v25, v26, 0) == kCFCompareEqualTo))
          {
            v33 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v74 = v33;
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Forcing bg scan set for current network <%@>", "WiFiDeviceManagerSetBackgroundScan", sub_10002B088(v21));
              v33 = v74;
            }
            objc_autoreleasePoolPop(v33);
            v73 = 1;
            if ((v11 & 1) != 0)
              goto LABEL_30;
          }
          else if ((v11 & 1) != 0)
          {
            goto LABEL_30;
          }
          if (!sub_10002B704((uint64_t)v9)
            && sub_1000C488C((uint64_t)v9)
            && v19
            && !v13
            && ((v71 & 1) == 0 || v70))
          {
            CFArrayAppendValue(theArray, v9);
LABEL_33:

            v7 = v73;
            goto LABEL_34;
          }
LABEL_30:
          v27 = objc_autoreleasePoolPush();
          v28 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v69 = sub_10002B088(v9);
            v29 = a1;
            v30 = v10;
            v31 = v11;
            v32 = sub_10002B704((uint64_t)v9);
            v65 = v31;
            v10 = v30;
            a1 = v29;
            v5 = value;
            objc_msgSend(v28, "WFLog:message:", 4, "%s: network %@ excluded from BGScan: isWoWBlacklisted=%d isAJBlacklisted=%d isTDBlacklisted=%d isAdHoc=%d isWoWAllowed=%d isAutoJoinAllowedInLockdownMode=%d isKnownNetworkDisallowed=%d", "WiFiDeviceManagerSetBackgroundScan", v69, v65, v71, v70, v32, sub_1000C488C((uint64_t)v9), v19, v13);
          }
          objc_autoreleasePoolPop(v27);
          goto LABEL_33;
        }
        v7 = 0;
LABEL_57:
        Mutable = theArray;
        v39 = CFArrayGetCount(theArray);
        if (v39)
        {
          v75.location = 0;
          v75.length = v39;
          CFArraySortValues(theArray, v75, (CFComparatorFunction)sub_1000C894C, 0);
        }
        v40 = sub_100027D10((uint64_t)value);
        v41 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 3, v40);
        if (!value)
        {
          v2 = v66;
LABEL_74:
          if (v39 >= 17)
          {
            v77.length = v39 - 16;
            v77.location = 16;
            CFArrayReplaceValues(theArray, v77, 0, 0);
          }
          v46 = CFArrayGetCount(theArray);
          if (v46 >= 1)
          {
            v47 = v46;
            v48 = 0;
            while (1)
            {
              v49 = CFArrayGetValueAtIndex(Mutable, v48);
              v50 = sub_10002B088(v49);
              if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v40, 0, 0)&& !CFSetContainsValue(*(CFSetRef *)(a1 + 3600), v49))
              {
                v7 = 1;
              }
              if ((objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v40, 0, 0) & 1) == 0&& CFSetContainsValue(*(CFSetRef *)(a1 + 3600), v49))
              {
                v7 = 1;
              }
              if ((sub_100105808(a1, v49) || sub_1000137D8((uint64_t)v49) || sub_10002DA5C((_BOOL8)v49))
                && !CFSetContainsValue(*(CFSetRef *)(a1 + 3608), v49))
              {
                break;
              }
              if (!sub_100105808(a1, v49)
                && !sub_1000137D8((uint64_t)v49)
                && !sub_10002DA5C((_BOOL8)v49)
                && CFSetContainsValue(*(CFSetRef *)(a1 + 3608), v49))
              {
                v51 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Force reprogram Bgscan list for clear hotspot %@", "WiFiDeviceManagerSetBackgroundScan", v50);
                goto LABEL_96;
              }
              ++v48;
              Mutable = theArray;
              if (v47 == v48)
                goto LABEL_97;
            }
            v51 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Force reprogram Bgscan list for hotspot %@", "WiFiDeviceManagerSetBackgroundScan", v50);
LABEL_96:
            Mutable = theArray;
            objc_autoreleasePoolPop(v51);
            v7 = 1;
          }
LABEL_97:

LABEL_98:
          v52 = *(const __CFArray **)(a1 + 3592);
          if (CFArrayGetCount(v52) > 359)
            v53.length = 360;
          else
            v53.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3592));
          v53.location = 0;
          CFArrayAppendArray(Mutable, v52, v53);
          if (!CFEqual(Mutable, *(CFTypeRef *)(a1 + 3584)) || v7)
          {
            v55 = sub_100105878(a1, Mutable);
            if (!v55)
              goto LABEL_107;
            v56 = *(_QWORD *)(a1 + 64);
            v57 = (const void *)sub_100025C3C(v56);
            v58 = sub_100071774(v56, v57, (uint64_t)v55);
            if ((_DWORD)v58)
            {
              v34 = v58;
              v59 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceSetBackgroundScan returned err=%d", v34);
              objc_autoreleasePoolPop(v59);
              if (!Mutable)
                goto LABEL_118;
            }
            else
            {
              CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3584));
              v63 = *(__CFArray **)(a1 + 3584);
              v78.length = CFArrayGetCount(Mutable);
              v78.location = 0;
              CFArrayAppendArray(v63, Mutable, v78);
              sub_10010621C(a1);
              v34 = 0;
              if (!Mutable)
                goto LABEL_118;
            }
          }
          else
          {
            if (*(unsigned __int8 *)(a1 + 5456) == *(unsigned __int8 *)(a1 + 5457))
            {
              v54 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No Change in Background Scan Networks, Skip Re-Programming Background Scan\n");
              objc_autoreleasePoolPop(v54);
              v55 = 0;
LABEL_107:
              v34 = 4294963396;
              if (!Mutable)
                goto LABEL_118;
              goto LABEL_117;
            }
            v55 = sub_100105878(a1, Mutable);
            if (!v55)
              goto LABEL_107;
            v60 = *(_QWORD *)(a1 + 64);
            v61 = (const void *)sub_100025C3C(v60);
            v34 = sub_100071774(v60, v61, (uint64_t)v55);
            if (!Mutable)
            {
LABEL_118:
              if (v55)
                CFRelease(v55);
              if (value)
                CFRelease(value);
              goto LABEL_122;
            }
          }
LABEL_117:
          CFRelease(Mutable);
          goto LABEL_118;
        }
        v42 = v41;
        if (sub_10002DA5C((_BOOL8)value))
        {
          v2 = v66;
          if ((v42 & 1) != 0)
          {
LABEL_62:
            v43 = (uint64_t)value;
LABEL_72:
            if (sub_1000C475C(v43))
              sub_10010159C(a1);
            goto LABEL_74;
          }
        }
        else
        {
          if (sub_1000C475C((uint64_t)value))
            v44 = v42;
          else
            v44 = 1;
          v2 = v66;
          if ((v44 & 1) != 0)
            goto LABEL_62;
        }
        v76.location = 0;
        v76.length = v39;
        v43 = (uint64_t)value;
        if (!CFArrayContainsValue(theArray, v76, value))
        {
          CFArrayInsertValueAtIndex(theArray, 0, value);
          v45 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: adding Captive/HS2.0 network %@ to PNO list", "WiFiDeviceManagerSetBackgroundScan", sub_10002B088(value));
          objc_autoreleasePoolPop(v45);
          ++v39;
          v7 = 1;
        }
        goto LABEL_72;
      }
      v36 = objc_autoreleasePoolPush();
      v37 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v64 = "WiFiDeviceManagerSetBackgroundScan";
        v38 = "%s: User disabled auto join. Skip programming SSID into background scan";
        goto LABEL_54;
      }
    }
    else
    {
      v36 = objc_autoreleasePoolPush();
      v37 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v38 = "Device is inactive since boot. Skip programming SSID into background scan";
LABEL_54:
        objc_msgSend(v37, "WFLog:message:", 3, v38, v64);
      }
    }
    objc_autoreleasePoolPop(v36);
    value = 0;
    v7 = 0;
    goto LABEL_98;
  }
  v35 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device NOT POWERED. Skip programming Background Scan");
  objc_autoreleasePoolPop(v35);
  v34 = 4294963396;
LABEL_122:
  objc_autoreleasePoolPop(v2);
  return v34;
}

void sub_100100160(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;

  if (a1)
  {
    if (a2)
    {
      v4 = *(_QWORD *)(a1 + 64);
      v5 = (const void *)sub_100025C3C(v4);
      v6 = sub_10002BF8C(v4, v5);
      if (v6)
      {
        v7 = v6;
        v8 = sub_10002B088(v6);
        if (v8)
        {
          v9 = v8;
          if (CFEqual(a2, v8))
          {
            v10 = *(const void **)(a1 + 6656);
            if (v10)
            {
              CFRelease(v10);
              *(_QWORD *)(a1 + 6656) = 0;
            }
            *(_QWORD *)(a1 + 6656) = CFRetain(v9);
          }
        }
        CFRelease(v7);
      }
    }
    else
    {
      v11 = *(const void **)(a1 + 6656);
      if (v11)
        CFRelease(v11);
      *(_QWORD *)(a1 + 6656) = 0;
    }
  }
}

void sub_10010020C(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 3616);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 3616) = 0;
  }
  if (cf)
    *(_QWORD *)(a1 + 3616) = CFRetain(cf);
}

void sub_10010024C(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (a1 && cf)
  {
    CFRetain(cf);
    v4 = *(const void **)(a1 + 3704);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 3704) = cf;
    sub_1000FE2A4(a1);
  }
}

uint64_t sub_10010029C(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  const void *v4;

  if (result)
  {
    if (a2)
    {
      v3 = *(_QWORD *)(result + 64);
      v4 = (const void *)sub_100025C3C(v3);
      return sub_1000672C0(v3, v4, 484, 0, a2);
    }
  }
  return result;
}

void sub_1001002EC(uint64_t a1, CFTypeRef cf, int a3)
{
  const void *v6;

  v6 = *(const void **)(a1 + 320);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 320) = 0;
  }
  if (cf)
  {
    *(_QWORD *)(a1 + 320) = CFRetain(cf);
    *(_DWORD *)(a1 + 5628) = a3;
    sub_1000FBAD0(a1, 1, (uint64_t)"WiFiDeviceManagerSetRetryIntervals");
  }
}

void sub_10010035C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;

  *(_BYTE *)(a1 + 3688) = a2;
  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
  {
    sub_1000766D8(v2, a2);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No Device", "WiFiDeviceManagerSetMacRandomisationFeature");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1001003D0(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "WiFiDeviceManagerSetAmbiguousSSIDs");
    goto LABEL_10;
  }
  if (!cf)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifiAmbiguousSSIDs is null", "WiFiDeviceManagerSetAmbiguousSSIDs");
LABEL_10:
    objc_autoreleasePoolPop(v5);
    return;
  }
  CFRetain(cf);
  v4 = *(const void **)(a1 + 3720);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 3720) = cf;
}

void sub_100100490(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 6576) != a2)
  {
    *(_DWORD *)(a1 + 6576) = a2;
    if (a2)
    {
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 0x11uLL);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 17, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerSetJoinRecommendationMode");
      }
    }
  }
}

void sub_100100530(uint64_t a1, int a2)
{
  if (a2 == 5)
    sub_1000FC5D8(a1, 1u);
  else
    *(_DWORD *)(a1 + 160) = a2;
}

void sub_100100548(uint64_t a1, uint64_t a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "wake mode set to %d", a2);
  objc_autoreleasePoolPop(v4);
  *(_DWORD *)(a1 + 168) = a2;
}

id sub_1001005B0(uint64_t *a1, int a2, const void *a3)
{
  const void *v6;
  id result;

  sub_100160088(a1[12], a2);
  v6 = (const void *)a1[14];
  if (v6)
  {
    CFRelease(v6);
    a1[14] = 0;
  }
  if (a3)
    a1[14] = (uint64_t)CFRetain(a3);
  result = (id)a1[838];
  if (result)
    return objc_msgSend(result, "enableTestMode:", a2 != 0);
  return result;
}

void sub_100100624(uint64_t a1, uint64_t a2, int a3)
{
  void *v6;
  int v7;
  BOOL v8;
  char v9;
  void *v10;
  WiFiUserNotificationManager *v11;
  void *v12;
  void **v13;
  CFDictionaryRef v14;
  CFDictionaryRef v15;
  uint64_t v16;
  const void *v17;
  void *v18;
  uint64_t v19;
  const void *v20;
  const void *v21;
  const void *v22;
  double v23;
  NSObject *v24;
  dispatch_time_t v25;
  double v26;
  NSObject *v27;
  dispatch_time_t v28;
  char v30;
  void *v31;
  _BOOL8 v32;
  int v33;
  void *values;
  void *keys;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %d", "WiFiDeviceManagerSetUserInteractionMode", a2);
  objc_autoreleasePoolPop(v6);
  v7 = *(_DWORD *)(a1 + 176);
  if ((_DWORD)a2)
    v8 = v7 == 0;
  else
    v8 = 0;
  v9 = !v8;
  if (v7 != (_DWORD)a2)
  {
    if (*(_QWORD *)(a1 + 240))
    {
      if (!*(_QWORD *)(a1 + 6704))
      {
        v10 = objc_autoreleasePoolPush();
        v11 = -[WiFiUserNotificationManager initWithQueue:supportsWAPI:]([WiFiUserNotificationManager alloc], "initWithQueue:supportsWAPI:", *(_QWORD *)(a1 + 240), *(unsigned __int8 *)(a1 + 88));
        *(_QWORD *)(a1 + 6704) = v11;
        if (v11)
        {
          -[WiFiUserNotificationManager startListening](v11, "startListening");
          objc_msgSend(*(id *)(a1 + 6704), "registerCallback:withContext:", &stru_100231498, a1);
          *(_DWORD *)(a1 + 6716) = 0;
          objc_msgSend(*(id *)(a1 + 6704), "enableTestMode:", sub_100160100(*(_QWORD *)(a1 + 96)) != 0);
        }
        else
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create user notification manager", "WiFiDeviceManagerSetUserInteractionMode");
          objc_autoreleasePoolPop(v12);
        }
        objc_autoreleasePoolPop(v10);
      }
      if (*(_DWORD *)(a1 + 20) == 1)
      {
        keys = CFSTR("IO80211InterfaceRadioMODE");
        v13 = (void **)&kCFBooleanFalse;
        if ((_DWORD)a2 == 1)
          v13 = (void **)&kCFBooleanTrue;
        values = *v13;
        v14 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v14)
        {
          v15 = v14;
          v16 = *(_QWORD *)(a1 + 64);
          v17 = (const void *)sub_100025C3C(v16);
          sub_1000672C0(v16, v17, 473, 0, (uint64_t)v15);
          CFRelease(v15);
        }
      }
      else
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIMO Power Save Configuration cancelled because device is not powered.");
        objc_autoreleasePoolPop(v18);
      }
      if ((_DWORD)a2 == 1)
        *(_DWORD *)(a1 + 6716) = 0;
      if (!a3)
        *(CFAbsoluteTime *)(a1 + 216) = CFAbsoluteTimeGetCurrent();
      sub_10010159C(a1);
      v7 = *(_DWORD *)(a1 + 176);
    }
    if (v7 != (_DWORD)a2)
      goto LABEL_33;
  }
  if (*(unsigned __int8 *)(a1 + 208) != a3)
  {
LABEL_33:
    v19 = *(_QWORD *)(a1 + 64);
    v20 = (const void *)sub_100025C3C(v19);
    v21 = sub_10002BF8C(v19, v20);
    v22 = v21;
    if (!v21 || !sub_10001395C((uint64_t)v21))
      goto LABEL_40;
    if (a3)
    {
      v23 = *(double *)(a1 + 6824);
      if (v23 <= CFAbsoluteTimeGetCurrent() + 3600.0)
        goto LABEL_40;
      v24 = *(NSObject **)(a1 + 6816);
      v25 = dispatch_time(0, 3600000000000);
      dispatch_source_set_timer(v24, v25, 0xFFFFFFFFFFFFFFFFLL, 0);
      v26 = CFAbsoluteTimeGetCurrent() + 3600.0;
    }
    else
    {
      v27 = *(NSObject **)(a1 + 6816);
      v28 = dispatch_time(0, 315360000000000000);
      dispatch_source_set_timer(v27, v28, 0xFFFFFFFFFFFFFFFFLL, 0);
      v26 = CFAbsoluteTimeGetCurrent() + 315360000.0;
    }
    *(double *)(a1 + 6824) = v26;
LABEL_40:
    if (*(_DWORD *)(a1 + 6804) != 2 || (_DWORD)a2 == 1)
      v30 = 0;
    else
      v30 = 2;
    *(_BYTE *)(a1 + 7024) = v30 | *(_BYTE *)(a1 + 7024) & 0xFD;
    if (v22)
      CFRelease(v22);
  }
  *(_BYTE *)(a1 + 208) = a3;
  *(_DWORD *)(a1 + 176) = a2;
  sub_1000427E4(*(_QWORD *)(a1 + 120), a2);
  if ((_DWORD)a2 == 3)
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_1000285E4(a1, 0x3AuLL);
    else
      sub_1000FA0A0(a1, 0);
    objc_msgSend(*(id *)(a1 + 6704), "dismissJoinAlerts");
  }
  sub_10015FC9C(*(_QWORD *)(a1 + 96), a2);
  if ((v9 & 1) == 0)
    sub_1000FF824(a1);
  v31 = *(void **)(a1 + 7368);
  if (v31)
  {
    v32 = (*(_DWORD *)(a1 + 176) - 1) < 2;
    objc_msgSend(v31, "setDeviceLockState:", a3 != 0);
    objc_msgSend(*(id *)(a1 + 7368), "setDisplayState:", v32);
  }
  if (a3)
    a3 = *(_BYTE *)(a1 + 3464) == 0;
  if (sub_100018F14(a1))
    v33 = 1;
  else
    v33 = a3;
  sub_1000F8284(a1, v33);
}

void sub_100100A5C(id a1, int a2, id a3, int a4, void *a5)
{
  uint64_t v6;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  id v11;
  void *v12;
  _WORD *v13;
  const void *v14;
  _WORD *v15;
  void *v16;
  const void *v17;
  _WORD *v18;
  const void *v19;
  void *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  const void *v23;
  _WORD *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  const void *v31;
  CFDictionaryRef *v32;
  CFDictionaryRef *v33;
  CFStringRef v34;
  const __CFString *v35;
  void *v36;
  const void *v37;
  uint64_t v38;
  int v39;
  void *v40;
  const __CFString *v41;
  uint64_t v42;
  const __CFString *v43;
  id v44;
  void *v45;
  void *v46;
  const void *v47;
  uint64_t v48;
  void *v49;
  void *v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  void (*v55)(void *, const void *, uint64_t, uint64_t, _QWORD);
  void *v56;
  int valuePtr;

  v6 = *(_QWORD *)&a4;
  v8 = *(_QWORD *)&a2;
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: notifyType %d responseType %d", "__WiFiDeviceManagerHandleUserNotificationResponse", v8, v6);
  objc_autoreleasePoolPop(v9);
  switch((int)v8)
  {
    case 1:
      if ((_DWORD)v6 == 1)
      {
        v11 = objc_msgSend(objc_msgSend(a3, "scannedNetwork"), "scanProperties");
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user accepted recommendation for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", objc_msgSend(a3, "network"));
        objc_autoreleasePoolPop(v12);
        if (objc_msgSend(objc_msgSend(a3, "network"), "source") == (id)2)
          v13 = sub_1000C323C((const __CFString *)objc_msgSend(objc_msgSend(a3, "network"), "SSID"));
        else
          v13 = 0;
        if (!v13 && v11)
          v13 = sub_10002B314((uint64_t)kCFAllocatorDefault, v11);
        if (v13)
        {
          if (objc_msgSend(objc_msgSend(a3, "network"), "source") == (id)1)
          {
            sub_1000CC4DC((uint64_t)v13, objc_msgSend(objc_msgSend(a3, "network"), "uniqueIdentifier"));
            sub_1000CB1D4((uint64_t)v13, 3u);
          }
          sub_1000FB408((uint64_t)a5);
          if (objc_msgSend(objc_msgSend(a3, "network"), "password"))
          {
            v45 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting password for network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_10002B088(v13));
            objc_autoreleasePoolPop(v45);
            sub_1000C64F0(v13, (const __CFString *)objc_msgSend(objc_msgSend(a3, "network"), "password"));
          }
          sub_1001345E4((uint64_t *)a5, CFSTR("userJoinAssociating"), v13);
          v46 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found matching network in scan results, proceeding with association", "__WiFiDeviceManagerHandleUserNotificationResponse");
          objc_autoreleasePoolPop(v46);
          v47 = (const void *)sub_100025C3C(*((_QWORD *)a5 + 8));
          if (sub_10010AD4C((uint64_t)a5, v47, v13, 0, 0, (uint64_t)sub_10013EA38, 0, 1016))
          {
            sub_1000FB2E0((uint64_t)a5);
            v48 = sub_100025C3C(*((_QWORD *)a5 + 8));
            sub_100119668((uint64_t)a5, v48, 7, 0, v13, 0);
            sub_1001345E4((uint64_t *)a5, CFSTR("userJoinAssociationFailed"), v13);
          }
          goto LABEL_86;
        }
        v53 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scan required, no scan properties for network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", objc_msgSend(a3, "network"));
        v54 = v53;
        goto LABEL_99;
      }
      v40 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if ((_DWORD)v6)
          v41 = CFSTR("system");
        else
          v41 = CFSTR("user");
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ dismissed recommendation %@ current state %@", "__WiFiDeviceManagerHandleUserNotificationResponse", v41, a3, sub_100031FD0(*((_DWORD *)a5 + 820)));
      }
      objc_autoreleasePoolPop(v40);
      v42 = objc_opt_class(NSString);
      if ((objc_opt_isKindOfClass(a3, v42) & 1) != 0)
        goto LABEL_51;
      if (objc_msgSend(a3, "SSID"))
      {
        a3 = objc_msgSend(a3, "SSID");
LABEL_51:
        v19 = sub_1000C323C((const __CFString *)a3);
      }
      else
      {
        v19 = 0;
      }
      if (*((_DWORD *)a5 + 820) == 14)
      {
        sub_1000FB44C((uint64_t)a5);
        sub_100006F34((uint64_t)a5, 1);
        if (*((_DWORD *)a5 + 5) == 1)
        {
          *((_DWORD *)a5 + 48) = 16;
          if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          {
            sub_1000285E4((uint64_t)a5, 0x11uLL);
          }
          else
          {
            objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 17, sub_100025C3C(*((_QWORD *)a5 + 8)));
            sub_1000FBA80((uint64_t)a5, 2, (uint64_t)"__WiFiDeviceManagerHandleUserNotificationResponse");
          }
        }
      }
      break;
    case 2:
      v14 = (const void *)sub_100029860(*((_QWORD *)a5 + 8));
      v15 = sub_10002A21C((uint64_t)a5, v14, 1);
      if (!v15)
        goto LABEL_100;
      v13 = v15;
      if ((_DWORD)v6 == 3)
      {
        v49 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user launched settings for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v49);
        sub_10013427C(2, (CFDictionaryRef *)v13);
      }
      else if ((_DWORD)v6 == 2)
      {
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user disconnected from %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v16);
        sub_1000FCA48((uint64_t)a5, v13);
      }
      else
      {
        v50 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user dismissed join alert for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v50);
      }
LABEL_86:
      v19 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v13);
      goto LABEL_87;
    case 3:
      v17 = (const void *)sub_100029860(*((_QWORD *)a5 + 8));
      v18 = sub_10002A21C((uint64_t)a5, v17, 1);
      if (!v18)
        goto LABEL_100;
      v13 = v18;
      v19 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v18);
      if ((_DWORD)v6 == 3)
        goto LABEL_24;
      if ((_DWORD)v6 == 4)
      {
        v20 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user disables Low Data Mode for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v20);
        valuePtr = 2;
        v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        if (v21)
        {
          v22 = v21;
          sub_10002C478((uint64_t)v13, CFSTR("SaveDataMode"), v21);
          CFRelease(v22);
          sub_1001053C8((NSObject **)a5, v13);
        }
      }
      else
      {
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user dismissed low data mode alert for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v51);
      }
      goto LABEL_87;
    case 4:
      v23 = (const void *)sub_100029860(*((_QWORD *)a5 + 8));
      v24 = sub_10002A21C((uint64_t)a5, v23, 1);
      if (!v24)
        goto LABEL_100;
      v13 = v24;
      v19 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v24);
      if ((_DWORD)v6 == 3)
      {
LABEL_24:
        v25 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user launched settings for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3);
        objc_autoreleasePoolPop(v25);
        sub_10013427C(2, (CFDictionaryRef *)v13);
      }
LABEL_87:
      CFRelease(v13);
      break;
    case 5:
      v26 = objc_msgSend(objc_alloc((Class)CWFScanResult), "initWithScanRecord:includeProperties:", objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("ToScanResult")), 0);
      v27 = objc_msgSend(objc_alloc((Class)CWFScanResult), "initWithScanRecord:includeProperties:", objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("FromScanResult")), 0);
      v28 = objc_autoreleasePoolPush();
      if ((_DWORD)v6 == 1)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user joined colocated SSID network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", v26);
        objc_autoreleasePoolPop(v28);
        v29 = sub_1000CE200(v26);
        if (v29)
        {
          v30 = v29;
          sub_1000FB408((uint64_t)a5);
          if (sub_1000C5964((uint64_t)v30))
          {
            v31 = (const void *)sub_100029860(*((_QWORD *)a5 + 8));
            v32 = (CFDictionaryRef *)sub_10002A21C((uint64_t)a5, v31, 1);
            if (v32)
            {
              v33 = v32;
              v34 = sub_1000C37A0(v32);
              if (v34)
              {
                v35 = v34;
                v36 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting password for network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_10002B088(v30));
                objc_autoreleasePoolPop(v36);
                sub_1000C64F0(v30, v35);
                CFRelease(v35);
              }
              CFRelease(v33);
            }
          }
          sub_1001345E4((uint64_t *)a5, CFSTR("userJoinAssociating"), v30);
          v37 = (const void *)sub_100025C3C(*((_QWORD *)a5 + 8));
          if (sub_10010AD4C((uint64_t)a5, v37, v30, 0, 0, (uint64_t)sub_10013EA38, 0, 1016))
          {
            sub_1000FB2E0((uint64_t)a5);
            v38 = sub_100025C3C(*((_QWORD *)a5 + 8));
            sub_100119668((uint64_t)a5, v38, 7, 0, v30, 0);
            sub_1001345E4((uint64_t *)a5, CFSTR("userJoinAssociationFailed"), v30);
            sub_100127948((uint64_t)a5);
          }
          v19 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v30);
          CFRelease(v30);
        }
        else
        {
          v19 = 0;
        }
        v52 = objc_msgSend(-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("UserDismissedColocatedSSIDTimestamps")), "mutableCopy");
        if (!v52)
          v52 = objc_alloc_init((Class)NSMutableDictionary);
        objc_msgSend(v52, "setObject:forKeyedSubscript:", +[NSDate now](NSDate, "now"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), objc_msgSend(v26, "networkName")));
        -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v52, CFSTR("UserDismissedColocatedSSIDTimestamps"));

      }
      else
      {
        if (qword_10026DD20)
        {
          if ((_DWORD)v6)
            v43 = CFSTR("system");
          else
            v43 = CFSTR("user");
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ dismissed colocated SSID notification (scanResult=(%@), state=%@)", "__WiFiDeviceManagerHandleUserNotificationResponse", v43, v26, sub_100031FD0(*((_DWORD *)a5 + 820)));
        }
        objc_autoreleasePoolPop(v28);
        v19 = sub_1000CE200(v26);
        if (!(_DWORD)v6)
        {
          v44 = objc_msgSend(-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("UserDismissedColocatedSSIDTimestamps")), "mutableCopy");
          if (!v44)
            v44 = objc_alloc_init((Class)NSMutableDictionary);
          objc_msgSend(v44, "setObject:forKeyedSubscript:", +[NSDate now](NSDate, "now"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), objc_msgSend(v26, "networkName")));
          -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v44, CFSTR("UserDismissedColocatedSSIDTimestamps"));

          sub_100127948((uint64_t)a5);
        }
      }

      break;
    case 6:
      if (*((_DWORD *)a5 + 820) == 17)
      {
        *((_DWORD *)a5 + 820) = 12;
        v39 = sub_10013ECF4(v10, v6);
        v19 = 0;
        *((_DWORD *)a5 + 820) = sub_100134010((uint64_t)a5, v39);
      }
      else
      {
        v56 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Received notification in unexpected state: %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_100031FD0(*((_DWORD *)a5 + 820)));
        v54 = v56;
LABEL_99:
        objc_autoreleasePoolPop(v54);
LABEL_100:
        v19 = 0;
      }
      break;
    default:
      goto LABEL_100;
  }
  v55 = (void (*)(void *, const void *, uint64_t, uint64_t, _QWORD))*((_QWORD *)a5 + 585);
  if (v55)
    v55(a5, v19, v8, v6, *((_QWORD *)a5 + 586));
  if (v19)
    CFRelease(v19);
}

void sub_10010159C(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t v3;
  const void *v4;
  void *v5;
  const void *v6;
  CFAbsoluteTime Current;
  double v9;
  double v10;
  const char *v11;
  void *v12;
  void *v13;
  const void *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  id v18;
  unsigned int v19;
  void *v20;

  v2 = (unsigned __int8 *)(a1 + 7080);
  v3 = *(unsigned __int8 *)(a1 + 7082);
  v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v5 = sub_10002A21C(a1, v4, 1);
  if (v5)
  {
    v6 = v5;
    if (sub_1000C475C((uint64_t)v5) && (_DWORD)v3 == 0)
    {
      Current = CFAbsoluteTimeGetCurrent();
      v3 = 0;
      v9 = *(double *)(a1 + 216);
      v10 = Current - v9;
      v11 = "disabled";
      if (v9 != 0.0 && v10 <= 3600.0)
      {
        v3 = *(_BYTE *)(a1 + 3448) != 0;
        if (*(_BYTE *)(a1 + 3448))
          v11 = "enabled";
      }
      v12 = objc_autoreleasePoolPush();
      v13 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v14 = sub_10002B088(v6);
        v15 = "enable";
        if (*v2)
          v16 = "enable";
        else
          v16 = "disable";
        if (!v2[1])
          v15 = "disable";
        if (*(_BYTE *)(a1 + 3448))
          v17 = "primary";
        else
          v17 = "non-primary";
        objc_msgSend(v13, "WFLog:message:", 3, "%s: %@: attempting to %s WoW and %s LPAS with WoW on Captive %s (%s), last unlocked %.3f seconds ago.", "__WiFiDeviceManagerUpdateWoWOnNetworkCharacteristics", v14, v16, v15, v11, v17, *(_QWORD *)&v10);
      }
      objc_autoreleasePoolPop(v12);
    }
    v18 = sub_100027D10((uint64_t)v6);
    v19 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 3, v18);

    if (v2[3] != (_DWORD)v3 || v2[4] != v19)
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enableWowOnCaptive prev (%d) now (%d), isWoWDenyListed prev (%d) now(%d)\n", "__WiFiDeviceManagerUpdateWoWOnNetworkCharacteristics", v2[3], v3, v2[4], v19);
      objc_autoreleasePoolPop(v20);
      sub_100108684(a1, *v2, v2[1], v3, v19);
      v2[3] = v3;
      v2[4] = v19;
    }
    CFRelease(v6);
  }
}

uint64_t sub_1001017C4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 24) = a2;
  return result;
}

BOOL sub_1001017CC(uint64_t a1)
{
  return *(_BYTE *)(a1 + 24) != 0;
}

_BYTE *sub_1001017DC(_BYTE *result, char a2, char a3, char a4)
{
  result[32] = a2;
  result[5608] = a3;
  result[35] = a4;
  return result;
}

void sub_1001017F0(uint64_t a1, unsigned int a2)
{
  void *v3;

  if (byte_10026DD61)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Lockdown Mode is enabled, ignoring set WiFiAskToJoinPreferenceType %ld", "WiFiDeviceManagerSetAskToJoinPreference", a2);
    objc_autoreleasePoolPop(v3);
  }
  else
  {
    *(_DWORD *)(a1 + 108) = a2;
    sub_10015FFC8(*(_QWORD *)(a1 + 96), a2 == 2);
  }
}

void sub_100101880(uint64_t a1, int a2)
{
  sub_10007665C(*(_QWORD *)(a1 + 64), a2);
}

uint64_t sub_100101888(uint64_t result, int a2)
{
  *(_DWORD *)(result + 164) = a2;
  return result;
}

void sub_100101890(uint64_t a1, unsigned int a2)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disable=%d", "WiFiDeviceManagerSetBlackListDisable", a2);
  objc_autoreleasePoolPop(v4);
  v5 = objc_autoreleasePoolPush();
  v6 = *(void **)(a1 + 6648);
  if (a2)
  {
    objc_msgSend(v6, "removeAllDenyListedItems");
    sub_1000FC790(a1);
    v6 = *(void **)(a1 + 6648);
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }
  objc_msgSend(v6, "setEnabled:", v7);
  objc_autoreleasePoolPop(v5);
}

id sub_100101934(uint64_t a1, int a2)
{
  id result;

  result = *(id *)(a1 + 7368);
  if (result)
    return objc_msgSend(result, "setPrivacyRestrictionDisabled:", a2 != 0);
  return result;
}

void sub_10010194C(CFMutableArrayRef *a1, const __CFArray *a2, int a3)
{
  CFRange v6;

  CFArrayRemoveAllValues(a1[449]);
  if (a2 && CFArrayGetCount(a2))
  {
    v6.length = CFArrayGetCount(a2);
    v6.location = 0;
    CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)sub_1001019CC, a1);
  }
  if (a3)
    sub_1000FF824((uint64_t)a1);
}

void sub_1001019CC(const void *a1, uint64_t a2)
{
  const __CFArray *v4;
  CFRange v5;

  if (a1 && a2)
  {
    v4 = *(const __CFArray **)(a2 + 3592);
    v5.length = CFArrayGetCount(v4);
    v5.location = 0;
    if (!CFArrayContainsValue(v4, v5, a1))
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 3592), a1);
  }
}

id sub_100101A38(uint64_t a1, unsigned int a2, unsigned int a3)
{
  id result;

  *(_DWORD *)(a1 + 5392) = *(_DWORD *)(a1 + 5392) & 0xFFFFFFF3 | (4 * ((a3 >> 2) & 3));
  result = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
  if (result)
    return objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "setBTState:type:", *(unsigned int *)(a1 + 5392), a2);
  return result;
}

void sub_100101AA0(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  const __CFNumber *v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  void *v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  const void *v19;
  void *v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, _QWORD);
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int valuePtr;

  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_ACL_A2DP"));
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  v28 = 0;
  v5 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_ESCO"));
  CFNumberGetValue(v5, kCFNumberIntType, &v28);
  v27 = 0;
  v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_HID"));
  CFNumberGetValue(v6, kCFNumberIntType, &v27);
  HIDWORD(v26) = 0;
  v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_2G_AoS_UNI"));
  CFNumberGetValue(v7, kCFNumberIntType, (char *)&v26 + 4);
  LODWORD(v26) = 0;
  v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_5G_AoS_UNI"));
  CFNumberGetValue(v8, kCFNumberIntType, &v26);
  HIDWORD(v25) = 0;
  v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_2G_AoS_BI"));
  CFNumberGetValue(v9, kCFNumberIntType, (char *)&v25 + 4);
  LODWORD(v25) = 0;
  v10 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MWS_BT_CONNECTION_REPORT_5G_AoS_BI"));
  CFNumberGetValue(v10, kCFNumberIntType, &v25);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: A2DP: %d eSCO: %d HID: %d 2GHz AoS Uni: %d 5GHz AoS Uni: %d 2GHz AoS Bi: %d 5GHz AoS Bi: %d ", "WiFiDeviceManagerSetBluetoothConnectionsReport", valuePtr, v28, v27, HIDWORD(v26), v26, HIDWORD(v25), v25);
  objc_autoreleasePoolPop(v11);
  v12 = *(_DWORD *)(a1 + 5392);
  v13 = (v12 & 2) != valuePtr;
  if (valuePtr)
    v14 = (v12 & 2) != valuePtr;
  else
    v14 = 0;
  if (valuePtr)
    v15 = 0;
  else
    v15 = (v12 & 2) != 0;
  v16 = HIDWORD(v26) + v28;
  v17 = -HIDWORD(v25);
  if (((v12 & 1) == 0) == (HIDWORD(v26) + v28 + HIDWORD(v25) != 0))
  {
    if (v16 == v17)
      v15 = 1;
    else
      v14 = 1;
    v13 = 1;
  }
  *(_DWORD *)(a1 + 5392) = v12 & 0xFFFFFFFC | (2 * (valuePtr != 0)) | (v16 != v17);
  *(_DWORD *)(a1 + 5400) = v27 != 0;
  *(_DWORD *)(a1 + 5396) = 102;
  if (v13)
  {
    v18 = *(_QWORD *)(a1 + 64);
    v19 = (const void *)sub_100025C3C(v18);
    sub_10007156C(v18, v19, 0x66u, *(_DWORD *)(a1 + 5392));
  }
  if (+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"))
    objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "setBTState:type:", *(unsigned int *)(a1 + 5392), 102);
  *(_DWORD *)(a1 + 192) = 2;
  if (v15)
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000285E4(a1, 0x18uLL);
    }
    else
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 24, sub_100025C3C(*(_QWORD *)(a1 + 64)));
      sub_1000FBA80(a1, 1, (uint64_t)"WiFiDeviceManagerSetBluetoothConnectionsReport");
    }
  }
  v20 = *(void **)(a1 + 7368);
  if (v20)
  {
    LOBYTE(v24) = (v26 | v25) != 0;
    objc_msgSend(v20, "setBluetoothState:connectedDeviceCount:inA2dp:inSco:inUniAoS:inBiAoS:btAudioBand:", *(_DWORD *)(a1 + 5392) != 0, v27, valuePtr != 0, v28 != 0, v26 != 0, v25 != 0, v24);
  }
  if (v14)
  {
    v21 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    v22 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 4376);
    if (v22)
    {
      v22(a1, v21, *(_QWORD *)(a1 + 4384));
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Signal WiFi to Reset 24GHz M1M4 Handshake Count to Zero");
      objc_autoreleasePoolPop(v23);
    }
  }
}

void sub_100101E08(uint64_t a1, const void *a2)
{
  void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  CFIndex v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFDictionary *ValueAtIndex;
  unsigned int valuePtr;
  void *value;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "WiFiDeviceManagerSetCoexBlacklistedChannels", a2);
    objc_autoreleasePoolPop(v4);
    v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 56) = 0;
    }
    if (a2)
    {
      *(_QWORD *)(a1 + 56) = CFRetain(a2);
      v6 = *(_QWORD *)(a1 + 64);
      v7 = (const void *)sub_100068E60(v6);
      sub_100074260(v6, v7, *(const __CFArray **)(a1 + 56));
      if (*(_QWORD *)(a1 + 7368))
      {
        value = 0;
        valuePtr = 0;
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) < 1)
        {
          v13 = 0;
          v12 = 0;
          v11 = 0;
          v10 = 0;
          v9 = 0;
        }
        else
        {
          v8 = 0;
          v9 = 0;
          v10 = 0;
          v11 = 0;
          v12 = 0;
          v13 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v8);
            if (ValueAtIndex)
            {
              CFDictionaryGetValueIfPresent(ValueAtIndex, CFSTR("MWS_Channel_Number"), (const void **)&value);
              if (value)
              {
                CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
                if (valuePtr)
                {
                  if ((int)valuePtr > 13)
                  {
                    if (valuePtr > 0x33)
                    {
                      if (valuePtr > 0x63)
                      {
                        if (valuePtr > 0x94)
                          ++v9;
                        else
                          ++v10;
                      }
                      else
                      {
                        ++v11;
                      }
                    }
                    else
                    {
                      ++v12;
                    }
                  }
                  else
                  {
                    ++v13;
                  }
                }
              }
            }
            ++v8;
          }
          while (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) > v8);
        }
        objc_msgSend(*(id *)(a1 + 7368), "addSoftApCoexEvent:deniedUnii1ChannelMap:deniedUnii2aChannelMap:deniedUnii2cChannelMap:deniedUnii3ChannelMap:", v13, v12, v11, v10, v9);
      }
    }
  }
}

__CFArray *sub_100101FC8(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  void *v5;
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  void *v8;
  const __CFNumber *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  CFIndex v14;
  int v15;
  const void *ValueAtIndex;
  const void *v17;
  void *v18;
  id v19;
  id v20;
  CFIndex v21;
  const void *v22;
  const void *v23;
  void *v24;
  id v25;
  id v26;
  __CFArray *Copy;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  void *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  void *v33;
  const __CFString *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  const __CFNumber *v39;
  const __CFDictionary *v40;
  const __CFDictionary *v41;
  void *v42;
  void *v43;
  id v44;
  void *v45;
  void *v46;
  unint64_t v47;
  id v48;
  void *v49;
  const void *v50;
  id v51;
  void *v52;
  id v53;
  id v54;
  uint64_t v55;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v57;
  id v58;
  uint64_t v59;
  CFNumberRef v60;
  CFNumberRef v61;
  id v62;
  CFNumberRef v63;
  CFNumberRef v64;
  id v65;
  CFNumberRef v66;
  CFNumberRef v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v73;
  __CFArray *v74;
  const __CFDictionary *v75;
  const __CFDictionary *v76;
  void *v77;
  const __CFNumber *v78;
  void *v79;
  void *v80;
  void *v81;
  const char *v82;
  uint64_t v83;
  void *v84;
  CFTypeRef cf1;
  id v86;
  void *v87;
  void *v88;
  __CFArray *theArray;
  void *context;
  id contexta;
  unsigned int v92;
  uint64_t valuePtr;
  double v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;

  v4 = objc_autoreleasePoolPush();
  valuePtr = 0;
  v94 = 0.0;
  v92 = 0;
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
    goto LABEL_45;
  }
  v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: request is NULL!", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
    goto LABEL_45;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing Request:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", a2);
  objc_autoreleasePoolPop(v5);
  Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("AddTrigger"));
  if (Value)
  {
    v7 = Value;
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
    objc_autoreleasePoolPop(v8);
    v9 = (const __CFNumber *)CFDictionaryGetValue(v7, CFSTR("triggerReason"));
    if (v9)
    {
      CFNumberGetValue(v9, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      v10 = CFDictionaryGetValue(v7, CFSTR("SSID_STR"));
      if (v10)
      {
        v11 = v10;
        v87 = v4;
        v12 = CFDictionaryGetValue(v7, CFSTR("BSSID"));
        v13 = HIDWORD(valuePtr);
        context = objc_autoreleasePoolPush();
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) < 1)
          goto LABEL_18;
        v14 = 0;
        v15 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v14);
          v17 = sub_10002B088(ValueAtIndex);
          if (CFEqual(v17, v11))
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger", "__WiFiDeviceManagerWoWBlacklistingTestAddTrigger");
            objc_autoreleasePoolPop(v18);
            v19 = sub_100027D10((uint64_t)ValueAtIndex);
            v20 = sub_1000FCB38(a1, v13, 0, (uint64_t)v12, 3);
            objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v20, v19);

            v15 = 1;
          }
          ++v14;
        }
        while (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) > v14);
        if (!v15)
        {
LABEL_18:
          if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)) >= 1)
          {
            v21 = 0;
            do
            {
              v22 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v21);
              v23 = sub_10002B088(v22);
              if (CFEqual(v23, v11))
              {
                v24 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger", "__WiFiDeviceManagerWoWBlacklistingTestAddTrigger");
                objc_autoreleasePoolPop(v24);
                v25 = sub_100027D10((uint64_t)v22);
                v26 = sub_1000FCB38(a1, v13, 0, (uint64_t)v12, 3);
                objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v26, v25);

              }
              ++v21;
            }
            while (CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)) > v21);
          }
        }
        objc_autoreleasePoolPop(context);
        Copy = 0;
        v4 = v87;
        goto LABEL_88;
      }
LABEL_110:
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID is NULL!", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
      goto LABEL_45;
    }
LABEL_108:
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: triggerReason not present", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
    goto LABEL_45;
  }
  v28 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("ConfigThreshold"));
  if (v28)
  {
    v29 = v28;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: ConfigThreshold", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
    objc_autoreleasePoolPop(v30);
    v31 = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("triggerReason"));
    if (v31)
    {
      CFNumberGetValue(v31, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      v32 = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("perBSSIDThresh"));
      if (v32)
      {
        CFNumberGetValue(v32, kCFNumberSInt32Type, &valuePtr);
        objc_msgSend(*(id *)(a1 + 6648), "setDenyListingThresholds:value:forSSIDThresholds:", SHIDWORD(valuePtr), valuePtr, 0);
      }
      else
      {
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: perBSSIDThresh not present", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
        objc_autoreleasePoolPop(v38);
      }
      v39 = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("perSSIDThresh"));
      if (v39)
      {
        CFNumberGetValue(v39, kCFNumberSInt32Type, &v92);
        objc_msgSend(*(id *)(a1 + 6648), "setDenyListingThresholds:value:forSSIDThresholds:", SHIDWORD(valuePtr), v92, 1);
LABEL_46:
        Copy = 0;
        goto LABEL_88;
      }
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: perSSIDThresh not present", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
LABEL_45:
      objc_autoreleasePoolPop(v5);
      goto LABEL_46;
    }
    goto LABEL_108;
  }
  if (CFDictionaryContainsKey(a2, CFSTR("copyWoWBlacklistedNetworks")))
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (const __CFString *)objc_msgSend(*(id *)(a1 + 6648), "denyListedNetworkSSIDs:", 3);
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wowBlacklistedNetworksSsidList: %@", "__WiFiDeviceManagerWoWBlacklistCopyBlacklistedNetworksString", v34);
    objc_autoreleasePoolPop(v35);
    Copy = (__CFArray *)CFStringCreateCopy(kCFAllocatorDefault, v34);
    objc_autoreleasePoolPop(v33);
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: blacklist:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", Copy);
    v37 = v36;
    goto LABEL_87;
  }
  v40 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("copyWoWBlacklistedNetworkProblemList"));
  if (!v40)
  {
    if (CFDictionaryContainsKey(a2, CFSTR("copyBlacklistHistoryDump")))
    {
      v73 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyBlacklistHistoryDump", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
      objc_autoreleasePoolPop(v73);
      objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 3);
      v74 = sub_100102AD0(a1);
    }
    else
    {
      v75 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("configTimeout"));
      if (v75)
      {
        v76 = v75;
        v77 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: configTimeout:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", v76);
        objc_autoreleasePoolPop(v77);
        v78 = (const __CFNumber *)CFDictionaryGetValue(v76, CFSTR("timeoutValue"));
        if (v78)
        {
          if (CFNumberGetValue(v78, kCFNumberDoubleType, &v94))
            objc_msgSend(*(id *)(a1 + 6648), "setDenyListedStateExpiryIntervalInSec:state:", 3, v94);
          goto LABEL_46;
        }
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: numref is NULL!", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
        goto LABEL_45;
      }
      if (!CFDictionaryContainsKey(a2, CFSTR("copyWoWBlacklistThreshold")))
        goto LABEL_46;
      v79 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyWoWBlacklistThreshold", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
      objc_autoreleasePoolPop(v79);
      v74 = sub_100103064(a1);
    }
    Copy = v74;
    goto LABEL_88;
  }
  v41 = v40;
  v42 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyWoWBlacklistedNetworkProblemList", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse");
  objc_autoreleasePoolPop(v42);
  cf1 = CFDictionaryGetValue(v41, CFSTR("SSID_STR"));
  if (!cf1)
    goto LABEL_110;
  v43 = objc_autoreleasePoolPush();
  Copy = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Copy)
  {
    v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_120;
    v82 = "%s: problematicState is NULL!";
LABEL_116:
    v83 = 3;
LABEL_119:
    objc_msgSend(v81, "WFLog:message:", v83, v82, "__WiFiDeviceManagerCopyWoWDenyListProblemList");
    goto LABEL_120;
  }
  v86 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedState:", 3);
  if (!v86)
  {
    v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_120;
    v82 = "%s: networkDenyListTimestamps is NULL";
    goto LABEL_116;
  }
  v44 = objc_alloc_init((Class)NSMutableArray);
  if (!v44)
  {
    v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v82 = "%s: networkDenyListTimestampList is NULL";
      v83 = 4;
      goto LABEL_119;
    }
LABEL_120:
    v45 = 0;
LABEL_121:
    objc_autoreleasePoolPop(v80);

    goto LABEL_86;
  }
  v45 = v44;
  contexta = objc_alloc_init((Class)NSMutableArray);
  if (!contexta)
  {
    v80 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: networkDenyListReasonDataList is NULL", "__WiFiDeviceManagerCopyWoWDenyListProblemList");
    goto LABEL_121;
  }
  v46 = v86;
  if (!objc_msgSend(v86, "count"))
    goto LABEL_85;
  v84 = v43;
  v88 = v4;
  theArray = Copy;
  v47 = 0;
  do
  {
    v48 = objc_msgSend(v46, "objectAtIndex:", v47);
    v49 = sub_1000CE200(v48);
    v50 = sub_10002B088(v49);
    if (CFEqual(cf1, v50))
    {
      v51 = objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", v48, 3, v45, contexta);
      if (v51)
      {
        v52 = v51;
        v53 = objc_msgSend(v51, "count");
        if (v53 == objc_msgSend(v45, "count"))
        {
          v54 = objc_msgSend(v52, "count");
          if (v54 == objc_msgSend(contexta, "count"))
          {
            if (objc_msgSend(v52, "count"))
            {
              v55 = 0;
              while (1)
              {
                Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (!Mutable)
                {
                  v68 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: problematicEntry fail", "__WiFiDeviceManagerCopyWoWDenyListProblemList");
                  objc_autoreleasePoolPop(v68);
                  goto LABEL_69;
                }
                v57 = Mutable;
                v58 = objc_msgSend(v45, "objectAtIndex:", v55);
                v97 = -1;
                objc_msgSend(v58, "doubleValue");
                v97 = v59;
                v60 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v97);
                if (!v60)
                  break;
                v61 = v60;
                CFDictionaryAddValue(v57, CFSTR("problematicStateEntryTimestamp"), v60);
                CFRelease(v61);
                v62 = objc_msgSend(v52, "objectAtIndex:", v55);
                v96 = -1431655766;
                v96 = objc_msgSend(v62, "unsignedIntegerValue");
                v63 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v96);
                if (!v63)
                {
                  v70 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: kWiFiNetworkProblematicStateEntryReason fail", "__WiFiDeviceManagerCopyWoWDenyListProblemList");
                  v71 = v70;
                  goto LABEL_82;
                }
                v64 = v63;
                CFDictionaryAddValue(v57, CFSTR("problematicStateEntryReason"), v63);
                CFRelease(v64);
                v65 = objc_msgSend(contexta, "objectAtIndex:", v55);
                v95 = -1431655766;
                v95 = objc_msgSend(v65, "integerValue");
                v66 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v95);
                if (!v66)
                {
                  v69 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: kWiFiNetworkProblematicStateEntryReasonData fail", "__WiFiDeviceManagerCopyWoWDenyListProblemList");
                  goto LABEL_81;
                }
                v67 = v66;
                CFDictionaryAddValue(v57, CFSTR("problematicStateEntryReasonData"), v66);
                CFRelease(v67);
                CFArrayAppendValue(theArray, v57);
LABEL_68:
                CFRelease(v57);
LABEL_69:
                if (++v55 >= (unint64_t)objc_msgSend(v52, "count"))
                  goto LABEL_83;
              }
              v69 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: kWiFiNetworkProblematicStateEntryTimestamp fail", "__WiFiDeviceManagerCopyWoWDenyListProblemList");
LABEL_81:
              v71 = v69;
LABEL_82:
              objc_autoreleasePoolPop(v71);
              goto LABEL_68;
            }
          }
        }
      }
    }
LABEL_83:
    objc_msgSend(contexta, "removeAllObjects");
    objc_msgSend(v45, "removeAllObjects");
    ++v47;
    v46 = v86;
  }
  while (v47 < (unint64_t)objc_msgSend(v86, "count"));
  v4 = v88;
  Copy = theArray;
  v43 = v84;
LABEL_85:

LABEL_86:
  v37 = v43;
LABEL_87:
  objc_autoreleasePoolPop(v37);
LABEL_88:
  objc_autoreleasePoolPop(v4);
  return Copy;
}

__CFArray *sub_100102AD0(uint64_t a1)
{
  void *v2;
  __CFArray *Mutable;
  id v4;
  void *v5;
  uint64_t v6;
  id v7;
  void *v8;
  CFMutableDictionaryRef v9;
  __CFDictionary *v10;
  _WORD *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  _BOOL4 v14;
  _BOOL4 v15;
  const void *v16;
  int v17;
  int v19;
  CFNumberRef v20;
  CFNumberRef v21;
  id v22;
  void *v23;
  id v24;
  void *v25;
  id v26;
  CFMutableArrayRef v27;
  __CFArray *v28;
  unint64_t v29;
  CFMutableDictionaryRef v30;
  __CFDictionary *v31;
  id v32;
  CFNumberRef v33;
  id v34;
  uint64_t v35;
  CFNumberRef v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v43;
  __CFArray *v44;
  void *context;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  int valuePtr;

  v2 = objc_autoreleasePoolPush();
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: denyListHistory is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
    goto LABEL_62;
  }
  if (!a1)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
    goto LABEL_62;
  }
  v4 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedStateHistory:", 3);
  if (!v4)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: networkDenyListedNetworks is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
LABEL_62:
    objc_autoreleasePoolPop(v43);
    goto LABEL_55;
  }
  v5 = v4;
  context = v2;
  if (objc_msgSend(v4, "count"))
  {
    v6 = 0;
    v44 = Mutable;
    v46 = v5;
    v47 = a1;
    while (1)
    {
      valuePtr = 0;
      v7 = objc_msgSend(v5, "objectAtIndex:", v6);
      v8 = sub_1000CE200(v7);
      v9 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v9)
      {
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: results is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
        objc_autoreleasePoolPop(v38);
        goto LABEL_46;
      }
      v10 = v9;
      v11 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v8);
      v12 = sub_10002B170(a1, v11, 1);
      v13 = v12;
      if (!v11 || !v12)
      {
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: mergedNetwork is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
        objc_autoreleasePoolPop(v39);
        if (!v13)
          goto LABEL_44;
        goto LABEL_43;
      }
      v14 = sub_1000C5378((uint64_t)v12);
      v15 = sub_10002DAB4((uint64_t)v13);
      v16 = sub_10002B088(v11);
      CFDictionaryAddValue(v10, CFSTR("SSID_STR"), v16);
      LOBYTE(valuePtr) = sub_1000C5C14((uint64_t)v8);
      valuePtr = valuePtr;
      v17 = sub_1000CA608((uint64_t)v8) << 8;
      if (!v15 || !v14)
        v19 = 0;
      else
        v19 = 0x10000;
      valuePtr |= v17 | v19;
      v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v20)
      {
        v21 = v20;
        CFDictionaryAddValue(v10, CFSTR("wowBlacklistedNetworkFlags"), v20);
        CFRelease(v21);
      }
      v22 = objc_alloc_init((Class)NSMutableArray);
      a1 = v47;
      if (!v22)
      {
        v41 = objc_autoreleasePoolPush();
        v5 = v46;
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: networkDenyListTimestamps is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
        objc_autoreleasePoolPop(v41);
LABEL_43:
        CFRelease(v13);
        goto LABEL_44;
      }
      v23 = v22;
      v24 = objc_msgSend(*(id *)(v47 + 6648), "denyListedReasonHistoryForNetwork:state:timestamps:reasonData:", v7, 3, v22, 0);
      if (!v24)
        goto LABEL_34;
      v25 = v24;
      v26 = objc_msgSend(v24, "count");
      if (v26 != objc_msgSend(v23, "count"))
        goto LABEL_34;
      v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v27)
        break;
      v40 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: denyListingHistoryRecord is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
      objc_autoreleasePoolPop(v40);
      a1 = v47;
LABEL_35:
      CFRelease(v23);
      v5 = v46;
      if (v13)
        goto LABEL_43;
LABEL_44:
      if (v11)
        CFRelease(v11);
LABEL_46:
      if (++v6 >= (unint64_t)objc_msgSend(v5, "count"))
        goto LABEL_54;
    }
    v28 = v27;
    if (objc_msgSend(v25, "count"))
    {
      v29 = 0;
      do
      {
        v30 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v30)
        {
          v31 = v30;
          v32 = objc_msgSend(v25, "objectAtIndex:", v29);
          v49 = -1431655766;
          v49 = objc_msgSend(v32, "unsignedIntegerValue");
          v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v49);
          CFDictionaryAddValue(v31, CFSTR("wowBlacklistingReason"), v33);
          if (v33)
            CFRelease(v33);
          v34 = objc_msgSend(v23, "objectAtIndex:", v29);
          v48 = -1;
          objc_msgSend(v34, "doubleValue");
          v48 = v35;
          v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v48);
          CFDictionaryAddValue(v31, CFSTR("wowBlacklistingTimeStamp"), v36);
          if (v36)
            CFRelease(v36);
          CFArrayAppendValue(v28, v31);
          CFRelease(v31);
        }
        else
        {
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: results is NULL", "__WiFiDeviceManagerCopyWoWDenyListingHistory");
          objc_autoreleasePoolPop(v37);
        }
        ++v29;
      }
      while (v29 < (unint64_t)objc_msgSend(v25, "count"));
    }
    CFDictionaryAddValue(v10, CFSTR("wowBlackListingHistory"), v28);
    CFRelease(v28);
    Mutable = v44;
    a1 = v47;
LABEL_34:
    CFArrayAppendValue(Mutable, v10);
    CFRelease(v10);
    goto LABEL_35;
  }
LABEL_54:
  CFArrayGetCount(Mutable);
  v2 = context;
LABEL_55:
  objc_autoreleasePoolPop(v2);
  return Mutable;
}

__CFArray *sub_100103064(uint64_t a1)
{
  void *v2;
  CFMutableArrayRef Mutable;
  __CFArray *v4;
  CFMutableDictionaryRef v5;
  __CFDictionary *v6;
  CFMutableDictionaryRef v7;
  __CFDictionary *v8;
  uint64_t i;
  const __CFString *v10;
  CFMutableStringRef v11;
  __CFString *v12;
  CFMutableStringRef v13;
  __CFString *v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  uint64_t v19;
  CFNumberRef v20;
  CFNumberRef v21;
  __CFDictionary *v22;
  __CFDictionary *v23;
  void *v24;
  void *v26;
  __CFString *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  __CFArray *theArray;
  void *v35;
  uint64_t v36;
  unsigned __int8 v37;
  unsigned __int8 valuePtr;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
    goto LABEL_37;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: response is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
LABEL_37:
    objc_autoreleasePoolPop(v30);
    v4 = 0;
LABEL_41:
    v6 = 0;
LABEL_45:
    v8 = 0;
    goto LABEL_17;
  }
  v4 = Mutable;
  v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v5)
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: perSSIDInfo is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
    objc_autoreleasePoolPop(v31);
    goto LABEL_41;
  }
  v6 = v5;
  v7 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v7)
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: perBSSIDInfo is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
    objc_autoreleasePoolPop(v32);
    goto LABEL_45;
  }
  v8 = v7;
  theArray = v4;
  v35 = v2;
  for (i = 0; i != 10; ++i)
  {
    valuePtr = -86;
    valuePtr = objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 6648), "SSIDThresholds"), "objectAtIndexedSubscript:", i), "unsignedIntegerValue");
    v37 = -86;
    v37 = objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 6648), "BSSIDThresholds"), "objectAtIndexedSubscript:", i), "unsignedIntegerValue");
    v10 = (const __CFString *)CWFStringFromDenyListAddReason(i);
    v11 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    if (!v11)
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: keyStrRefSsid is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
      objc_autoreleasePoolPop(v28);
      goto LABEL_32;
    }
    v12 = v11;
    v13 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    if (!v13)
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: keyStrRefBssid is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
      objc_autoreleasePoolPop(v29);
      v27 = v12;
LABEL_31:
      CFRelease(v27);
LABEL_32:
      v4 = theArray;
      v2 = v35;
      goto LABEL_17;
    }
    v14 = v13;
    CFStringAppend(v12, CFSTR("PerSSID "));
    CFStringAppend(v12, v10);
    v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
    if (!v15
      || (v16 = v15,
          CFDictionaryAddValue(v6, v12, v15),
          CFRelease(v16),
          CFStringAppend(v14, CFSTR("PerBSSID ")),
          CFStringAppend(v14, v10),
          (v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &v37)) == 0))
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: numRef is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds");
      objc_autoreleasePoolPop(v26);
      CFRelease(v12);
      v27 = v14;
      goto LABEL_31;
    }
    v18 = v17;
    CFDictionaryAddValue(v8, v14, v17);
    CFRelease(v18);
    CFRelease(v12);
    CFRelease(v14);
  }
  v4 = theArray;
  CFArrayAppendValue(theArray, v6);
  CFArrayAppendValue(theArray, v8);
  objc_msgSend(*(id *)(a1 + 6648), "wowDenyListExpiry");
  v36 = v19;
  v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v36);
  if (v20)
  {
    v21 = v20;
    v22 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v22)
    {
      v23 = v22;
      CFDictionarySetValue(v22, CFSTR("unBlacklistingTimeoutInSec"), v21);
      CFArrayAppendValue(theArray, v23);
      CFRelease(v23);
    }
    CFRelease(v21);
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: response:%@", "__WiFiDeviceManagerWoWBlacklistCopyThresholds", theArray);
  }
  else
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: numRef is NULL", "__WiFiDeviceManagerWoWBlacklistCopyThresholds", v33);
  }
  objc_autoreleasePoolPop(v24);
  v2 = v35;
LABEL_17:
  CFRelease(CFSTR("PerSSID "));
  CFRelease(CFSTR("PerBSSID "));
  if (v6)
    CFRelease(v6);
  if (v8)
    CFRelease(v8);
  objc_autoreleasePoolPop(v2);
  return v4;
}

uint64_t sub_100103560(uint64_t a1)
{
  return *(_QWORD *)(a1 + 3512);
}

const __CFArray *sub_100103568(uint64_t a1, const void *a2)
{
  return sub_10002B170(a1, a2, 1);
}

uint64_t sub_100103570(uint64_t a1)
{
  return *(_QWORD *)(a1 + 3648);
}

void sub_100103578(uint64_t a1, const void *a2)
{
  const void *v4;
  const __CFArray *v5;

  v4 = *(const void **)(a1 + 3648);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 3648) = 0;
  }
  if (a2)
  {
    v5 = sub_10002B170(a1, a2, 1);
    *(_QWORD *)(a1 + 3648) = v5;
    if (!v5)
      *(_QWORD *)(a1 + 3648) = CFRetain(a2);
  }
}

void sub_1001035D0(uint64_t a1, const __CFDictionary **a2)
{
  void *v2;
  _QWORD v3[5];

  if (a2 && *(_QWORD *)(a1 + 7368))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001039F8;
    v3[3] = &unk_1002314B8;
    v3[4] = a1;
    sub_10010367C(a1, a2, (uint64_t)v3);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error notifying UsageMonitor", "WiFiDeviceManagerProcessKnownNetworkRemoval");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_10010367C(uint64_t a1, const __CFDictionary **a2, uint64_t a3)
{
  void *v6;
  void *v7;
  _WORD *v8;
  const void *v9;
  _WORD *v10;
  const __CFDictionary *v11;
  const void *v12;
  BOOL v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  const __CFString *v19;
  uint64_t v20;
  void *v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  CFDictionaryRef *v24;
  int v25;
  id v26;
  _QWORD block[14];
  int v28;
  int v29;
  BOOL v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  UInt8 buffer[4];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  CFRange v42;

  v38 = 0;
  v39 = &v38;
  v40 = 0x2020000000;
  v41 = 0;
  v34 = 0;
  v35 = &v34;
  v36 = 0x2020000000;
  v37 = 0;
  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiDeviceManagerCreateNetworkDetailsForUsageMonitor");
    objc_autoreleasePoolPop(v6);
  }
  if (!a2)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network", "__WiFiDeviceManagerCreateNetworkDetailsForUsageMonitor");
    objc_autoreleasePoolPop(v7);
  }
  if (a3)
  {
    if (a1 && a2 && !byte_10026DD60)
    {
      v8 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)a2);
      v39[3] = (uint64_t)v8;
      v9 = sub_10002B634(*(const __CFArray **)(a1 + 3704), a2);
      if (v9)
      {
        v10 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
        v35[3] = (uint64_t)v10;
      }
      v11 = *(const __CFDictionary **)(a1 + 3616);
      if (v11)
      {
        v12 = sub_10002B088(a2);
        v13 = CFDictionaryGetValue(v11, v12) != 0;
      }
      else
      {
        v13 = 0;
      }
      v15 = sub_100009ACC(a1);
      v16 = *(id *)(a1 + 8768);
      v17 = *(id *)(a1 + 8776);
      v18 = *(id *)(a1 + 8784);
      *(_DWORD *)buffer = 0;
      v19 = *(const __CFString **)(a1 + 7352);
      if (v19)
      {
        v42.length = CFStringGetLength(*(CFStringRef *)(a1 + 7352));
        v42.location = 0;
        CFStringGetBytes(v19, v42, 0x8000100u, 0, 0, buffer, 4, 0);
      }
      v25 = sub_10002A724(a1, (const void *)v39[3]);
      v26 = v18;
      v20 = *(unsigned __int8 *)(a1 + 7360);
      v21 = *(void **)(a1 + 7376);
      if (v21)
      {
        v22 = objc_msgSend(v21, "isAtPrimaryHomeLocation");
        v23 = objc_msgSend(*(id *)(a1 + 7376), "isAtNonPrimaryHomeLocation");
      }
      else
      {
        v22 = 0;
        v23 = 0;
      }
      v24 = sub_100122B08(a1);
      CFRetain((CFTypeRef)a1);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10013F728;
      block[3] = &unk_100231C10;
      block[10] = &v38;
      block[11] = &v34;
      block[4] = v24;
      block[5] = v15;
      block[6] = v16;
      block[7] = v17;
      v30 = v13;
      v28 = *(_DWORD *)buffer;
      v29 = v25;
      block[12] = a1;
      block[13] = v20;
      v31 = v22;
      v32 = v23;
      block[8] = v26;
      block[9] = a3;
      dispatch_async((dispatch_queue_t)qword_10026DD40, block);
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
    }
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null callbackBlock", "__WiFiDeviceManagerCreateNetworkDetailsForUsageMonitor");
    objc_autoreleasePoolPop(v14);
  }
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&v38, 8);
}

void sub_1001039AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v28 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1001039F8(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setForgetNetworkEvent:forInterface:", a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

const __CFArray *sub_100103A48(uint64_t a1, const void *a2)
{
  return sub_10002B170(a1, a2, 0);
}

void sub_100103A50(_QWORD *a1, const void *a2, CFTypeRef cf)
{
  const void *v6;
  const void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerSetCellularCarrierName");
    goto LABEL_20;
  }
  if (!cf)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null carrierName.", "WiFiDeviceManagerSetCellularCarrierName");
    goto LABEL_20;
  }
  if (!a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null ifName.", "WiFiDeviceManagerSetCellularCarrierName");
LABEL_20:
    objc_autoreleasePoolPop(v10);
    return;
  }
  v6 = (const void *)a1[774];
  if (v6)
  {
    CFRelease(v6);
    a1[774] = 0;
  }
  v7 = (const void *)a1[775];
  if (v7)
  {
    CFRelease(v7);
    a1[775] = 0;
  }
  a1[774] = CFRetain(cf);
  a1[775] = CFRetain(a2);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: cellular (%@) carrier name updated to %@", "WiFiDeviceManagerSetCellularCarrierName", a2, cf);
  objc_autoreleasePoolPop(v8);
  v9 = (void *)a1[921];
  if (v9)
  {
    if (a1[775])
      objc_msgSend(v9, "setSecondaryInterfaceName:");
  }
}

void sub_100103BD8(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
    {
      v5 = "is 5G";
      if (!a2)
        v5 = "is Not 5G";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: cellular Type %s \n", "WiFiDeviceManagerSetCellularRadioType5G", v5);
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 7043) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerSetCellularRadioType5G");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_100103CA0(uint64_t a1, int a2)
{
  unsigned __int8 *v4;
  void *v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  void *v12;
  void *v13;

  if (a1)
  {
    v4 = (unsigned __int8 *)(a1 + 5216);
    *(_DWORD *)(a1 + 7052) = a2;
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (a2 == 2)
        v7 = "5GHz";
      else
        v7 = "2.4GHz";
      v8 = *v4;
      Count = CFSetGetCount(*(CFSetRef *)(a1 + 5288));
      v10 = CFSetGetCount(*(CFSetRef *)(a1 + 5296));
      v11 = CFSetGetCount(*(CFSetRef *)(a1 + 5304));
      objc_msgSend(v6, "WFLog:message:", 3, "%s:NAN Concurrency SoftAP Preferred Band update to %s while misChannel=%d and Clients connected (Broadcast:%ld, Hidden:%ld Other Hidden %ld NanLink %ld)\n", "WiFiDeviceManagerSetSoftAPNANCocurrencyPreferredBand", v7, v8, Count, v10, v11, CFSetGetCount(*(CFSetRef *)(a1 + 5312)));
    }
    objc_autoreleasePoolPop(v5);
    if (a2 != 2 && *v4 >= 0xFu && v4[3])
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Restart legacy softAP to move to %s\n", "WiFiDeviceManagerSetSoftAPNANCocurrencyPreferredBand", "2.4GHz");
      objc_autoreleasePoolPop(v12);
      sub_100103E6C(a1, 0);
    }
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetSoftAPNANCocurrencyPreferredBand");
    objc_autoreleasePoolPop(v13);
  }
}

uint64_t sub_100103E6C(uint64_t a1, int a2)
{
  uint64_t result;
  void *v5;

  result = sub_1001076C4(a1);
  if ((_DWORD)result && *(_BYTE *)(a1 + 5219))
  {
    *(_BYTE *)(a1 + 5223) = 1;
    if (CFSetGetCount(*(CFSetRef *)(a1 + 5272)) > 0 || CFSetGetCount(*(CFSetRef *)(a1 + 5288)) >= 1)
      *(_BYTE *)(a1 + 5224) = 1;
    if (objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted") == 1)
    {
      *(_BYTE *)(a1 + 5387) = a2 != 0;
      *(_BYTE *)(a1 + 5388) = a2 == 0;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Stopping MIS misRestartNanPhs=%d misKeepNanPhsDuringMISStop=%d", "WiFiDeviceManagerRestartSoftAP", *(unsigned __int8 *)(a1 + 5387), *(unsigned __int8 *)(a1 + 5388));
    objc_autoreleasePoolPop(v5);
    return sub_100107084(a1);
  }
  return result;
}

id sub_100103F64(uint64_t a1, int a2, int a3)
{
  id result;

  result = *(id *)(a1 + 120);
  if (result)
  {
    sub_100042048((uint64_t)result, a2);
    result = *(id *)(a1 + 7368);
    if (result)
    {
      objc_msgSend(result, "enableXCTestNotifications");
      return objc_msgSend(*(id *)(a1 + 7368), "enableSubmitAnalyticsNoSampling:", a3 != 0);
    }
  }
  return result;
}

void sub_100103FB4(uint64_t a1, int a2)
{
  int v4;
  int v5;
  void *v6;
  void *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  void *v11;
  const char *v12;
  int v13;

  v4 = *(_DWORD *)(a1 + 7048);
  v5 = a2 != 0;
  *(_DWORD *)(a1 + 7048) = v5;
  if (!a2 && v4 != v5 && *(_BYTE *)(a1 + 5219))
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 5288)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5296)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5304)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5312)) > 0)
    {
      v6 = objc_autoreleasePoolPush();
      v7 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        Count = CFSetGetCount(*(CFSetRef *)(a1 + 5288));
        v9 = CFSetGetCount(*(CFSetRef *)(a1 + 5296));
        v10 = CFSetGetCount(*(CFSetRef *)(a1 + 5304));
        objc_msgSend(v7, "WFLog:message:", 3, "%s:User SoftAP Preferred Changed to %s while Clients connected (Broadcast:%ld, Hidden:%ld Other Hidden %ld NanLink %ld)\n", "WiFiDeviceManagerSetSoftAPUserPreferredBand", "Default", Count, v9, v10, CFSetGetCount(*(CFSetRef *)(a1 + 5312)));
      }
      objc_autoreleasePoolPop(v6);
      return;
    }
    v5 = *(_DWORD *)(a1 + 7048);
  }
  if (v5 != v4)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v12 = "Default";
      if (a2)
        v12 = "2.4GHz";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:User SoftAP Preferred Band %s\n", "WiFiDeviceManagerSetSoftAPUserPreferredBand", v12);
    }
    objc_autoreleasePoolPop(v11);
    v13 = sub_10010416C(a1);
    sub_100103E6C(a1, v13);
  }
}

uint64_t sub_10010416C(uint64_t a1)
{
  void *v1;
  uint64_t v2;

  if (a1)
  {
    if (!objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted"))
      return 1;
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Restart SoftAP but not NAN publisher if NAN publisher is already up\n", "__WiFiDeviceManagerShouldRestartNANPublisher");
    v2 = 0;
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager", "__WiFiDeviceManagerShouldRestartNANPublisher");
    v2 = 1;
  }
  objc_autoreleasePoolPop(v1);
  return v2;
}

void sub_100104224(uint64_t a1, uint64_t a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  int v6;
  const __CFString *v7;
  int v8;
  const __CFString *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  const void *v18;
  int v19;
  CFNumberRef v20;
  CFNumberRef v21;
  const void *v22;
  int v23;
  CFNumberRef v24;
  CFNumberRef v25;
  void *v26;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v5 = Mutable;
    v6 = *(unsigned __int16 *)(a1 + 1) >> 14;
    if (v6)
    {
      if (v6 == 1)
      {
        v7 = CFSTR("6");
      }
      else
      {
        if (v6 != 3)
          goto LABEL_9;
        v7 = CFSTR("5");
      }
    }
    else
    {
      v7 = CFSTR("2");
    }
    CFDictionarySetValue(Mutable, CFSTR("band_before"), v7);
LABEL_9:
    v8 = *(unsigned __int16 *)(a2 + 1) >> 14;
    if (v8)
    {
      if (v8 == 1)
      {
        v9 = CFSTR("6");
      }
      else
      {
        if (v8 != 3)
          goto LABEL_16;
        v9 = CFSTR("5");
      }
    }
    else
    {
      v9 = CFSTR("2");
    }
    CFDictionarySetValue(v5, CFSTR("band_after"), v9);
LABEL_16:
    if (*(unsigned __int8 *)(a1 + 9) >= 0xA2u)
    {
      v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a1 + 9));
      if (v10)
      {
        v11 = v10;
        CFDictionarySetValue(v5, CFSTR("rssi_before"), v10);
        CFRelease(v11);
      }
    }
    if (*(unsigned __int8 *)(a2 + 9) >= 0xA2u)
    {
      v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 9));
      if (v12)
      {
        v13 = v12;
        CFDictionarySetValue(v5, CFSTR("rssi_after"), v12);
        CFRelease(v13);
      }
    }
    if ((*(_DWORD *)(a1 + 32) - 1) < 0x257FFF)
    {
      v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 32));
      if (v14)
      {
        v15 = v14;
        CFDictionarySetValue(v5, CFSTR("txrate_before"), v14);
        CFRelease(v15);
      }
    }
    if ((*(_DWORD *)(a2 + 32) - 1) < 0x257FFF)
    {
      v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 32));
      if (v16)
      {
        v17 = v16;
        CFDictionarySetValue(v5, CFSTR("txrate_after"), v16);
        CFRelease(v17);
      }
    }
    v19 = *(_DWORD *)(a1 + 36);
    v18 = (const void *)(a1 + 36);
    if ((v19 - 1) < 0x257FFF)
    {
      v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v18);
      if (v20)
      {
        v21 = v20;
        CFDictionarySetValue(v5, CFSTR("rxrate_before"), v20);
        CFRelease(v21);
      }
    }
    v23 = *(_DWORD *)(a2 + 36);
    v22 = (const void *)(a2 + 36);
    if ((v23 - 1) < 0x257FFF)
    {
      v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v22);
      if (v24)
      {
        v25 = v24;
        CFDictionarySetValue(v5, CFSTR("rxrate_after"), v24);
        CFRelease(v25);
      }
    }
    sub_100063388((uint64_t)CFSTR("com.apple.wifi.mloSwitch"), (uint64_t)v5);
    CFRelease(v5);
    return;
  }
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metric is null", "WiFiDeviceManagerSubmitMloPrefBandSwitchMetric");
  objc_autoreleasePoolPop(v26);
}

void sub_100104520(uint64_t a1, uint64_t a2)
{
  id v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  CFNumberRef v18;
  CFNumberRef v19;
  void *v20;
  unsigned int valuePtr;

  valuePtr = 0;
  v4 = sub_100104784(a1);
  if (!v4)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL", "WiFiDeviceManagerSubmitObssMitTransitionMetric");
    goto LABEL_25;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metric is null", "WiFiDeviceManagerSubmitObssMitTransitionMetric");
LABEL_25:
    objc_autoreleasePoolPop(v20);
    goto LABEL_20;
  }
  v6 = Mutable;
  v7 = objc_msgSend(objc_msgSend(v4, "channel"), "band") - 1;
  if (v7 <= 2)
    CFDictionarySetValue(v6, CFSTR("band"), off_100231F88[v7]);
  v8 = *(char *)(a2 + 2);
  if (v8 <= 3)
    CFDictionarySetValue(v6, CFSTR("channelWidth"), off_100231FA0[v8]);
  v9 = *(char *)(a2 + 3);
  if (v9 <= 3)
    CFDictionarySetValue(v6, CFSTR("recommended_channelWidth"), off_100231FA0[v9]);
  v10 = *(_BYTE *)(a2 + 3) - *(_BYTE *)(a2 + 2);
  v11 = v10 + 3;
  if (v11 <= 6)
    CFDictionarySetValue(v6, CFSTR("recommended_channelWidthPerc"), off_100231FC0[v11]);
  v12 = *(char *)(a1 + 3866) + 3;
  if (v12 <= 6)
    CFDictionarySetValue(v6, CFSTR("previous_recommended_channelWidthOverCurrent"), off_100231FC0[v12]);
  v13 = *(char *)(a1 + 3864);
  if (v13 <= 3)
    CFDictionarySetValue(v6, CFSTR("previous_recommended_channelWidth"), off_100231FA0[v13]);
  v14 = *(_DWORD *)(a2 + 20);
  v15 = *(unsigned __int8 *)(a1 + 3865);
  v16 = v14 >= v15;
  v17 = v14 - v15;
  if (v17 != 0 && v16)
  {
    valuePtr = v17;
    v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v18)
    {
      v19 = v18;
      CFDictionarySetValue(v6, CFSTR("recommendationDuration"), v18);
      CFRelease(v19);
    }
  }
  *(_BYTE *)(a1 + 3864) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 3865) = *(_DWORD *)(a2 + 20);
  *(_BYTE *)(a1 + 3866) = v10;
  sub_100063388((uint64_t)CFSTR("com.apple.wifi.obssMitigation.transitionStats"), (uint64_t)v6);
  CFRelease(v6);
LABEL_20:

}

id sub_100104784(uint64_t a1)
{
  const void *v2;
  id result;
  const void *v4;
  id v5;

  v2 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  result = sub_10002A21C(a1, v2, 1);
  if (result)
  {
    v4 = result;
    v5 = sub_100027D10((uint64_t)result);
    CFRelease(v4);
    return v5;
  }
  return result;
}

void sub_1001047D4(uint64_t a1, uint64_t a2)
{
  id v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  uint64_t v26;
  char v27;
  int v28;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  uint64_t v34;
  int v35;
  CFNumberRef v36;
  CFNumberRef v37;
  void *v38;
  unsigned int v39;
  unsigned int valuePtr;
  int v41;
  char v42;
  unsigned __int8 v43;
  int v44;

  v44 = sub_100046CE8(*(_QWORD *)(a1 + 120));
  v43 = -127;
  v42 = 0;
  v41 = 0;
  v4 = sub_100104784(a1);
  if (!v4)
  {
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL", "WiFiDeviceManagerSubmitObssMitMetric");
    goto LABEL_49;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metric is null", "WiFiDeviceManagerSubmitObssMitMetric");
LABEL_49:
    objc_autoreleasePoolPop(v38);
    goto LABEL_44;
  }
  v6 = Mutable;
  v7 = objc_msgSend(objc_msgSend(v4, "channel"), "band") - 1;
  if (v7 <= 2)
    CFDictionarySetValue(v6, CFSTR("band"), off_100231F88[v7]);
  v8 = *(char *)(a2 + 2);
  if (v8 <= 3)
    CFDictionarySetValue(v6, CFSTR("channelWidth"), off_100231FA0[v8]);
  v9 = *(char *)(a2 + 3);
  if (v9 <= 3)
    CFDictionarySetValue(v6, CFSTR("recommended_channelWidth"), off_100231FA0[v9]);
  v10 = (char)(*(_BYTE *)(a2 + 3) - *(_BYTE *)(a2 + 2)) + 3;
  if (v10 <= 6)
    CFDictionarySetValue(v6, CFSTR("recommended_channelWidthOverCurrent"), off_100231FC0[v10]);
  v11 = *(_DWORD *)(a2 + 12);
  if (v11)
  {
    valuePtr = 100 * *(_DWORD *)(a2 + 8) / v11;
    v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v12)
    {
      v13 = v12;
      CFDictionarySetValue(v6, CFSTR("rxBadFCSOverRxFrames"), v12);
      CFRelease(v13);
    }
    v39 = (100 * *(_DWORD *)(a2 + 4)) / *(_DWORD *)(a2 + 12);
    v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v39);
    if (v14)
    {
      v15 = v14;
      CFDictionarySetValue(v6, CFSTR("rxBadPLCPOverRxFrames"), v14);
      CFRelease(v15);
    }
  }
  v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 12));
  if (v16)
  {
    v17 = v16;
    CFDictionarySetValue(v6, CFSTR("rxFrames"), v16);
    CFRelease(v17);
  }
  v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 16));
  if (v18)
  {
    v19 = v18;
    CFDictionarySetValue(v6, CFSTR("rxPER"), v18);
    CFRelease(v19);
  }
  v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v44);
  if (v20)
  {
    v21 = v20;
    CFDictionarySetValue(v6, CFSTR("p95_txLatency"), v20);
    CFRelease(v21);
  }
  v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 40));
  if (v22)
  {
    v23 = v22;
    CFDictionarySetValue(v6, CFSTR("rssi_core0"), v22);
    CFRelease(v23);
  }
  v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 41));
  if (v24)
  {
    v25 = v24;
    CFDictionarySetValue(v6, CFSTR("rssi_core1"), v24);
    CFRelease(v25);
  }
  v26 = 0;
  v27 = -127;
  do
  {
    v28 = *(char *)(a2 + 24 + v26);
    if (v28 > v27 && v28 < 0)
      v27 = *(_BYTE *)(a2 + 24 + v26);
    ++v26;
  }
  while (v26 != 8);
  v43 = v27;
  v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v43);
  if (v30)
  {
    v31 = v30;
    CFDictionarySetValue(v6, CFSTR("strongestNonPrimaryChannelEnergy"), v30);
    CFRelease(v31);
  }
  v42 = v43 - *(_BYTE *)(a2 + 40);
  v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v42);
  if (v32)
  {
    v33 = v32;
    CFDictionarySetValue(v6, CFSTR("diffStrongestNonPrimaryChannelEnergySOI"), v32);
    CFRelease(v33);
  }
  v34 = 0;
  v35 = 0;
  do
  {
    if (*(unsigned __int8 *)(a2 + 24 + v34) == v43)
      v35 += 20;
    ++v34;
  }
  while (v34 != 8);
  v41 = v35;
  v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v41);
  if (v36)
  {
    v37 = v36;
    CFDictionarySetValue(v6, CFSTR("channelWidthWithMaxEnergy"), v36);
    CFRelease(v37);
  }
  sub_100063388((uint64_t)CFSTR("com.apple.wifi.obssMitigation.stats"), (uint64_t)v6);
  CFRelease(v6);
LABEL_44:

}

uint64_t sub_100104C60(uint64_t a1, const void *a2)
{
  void *v4;
  id v5;
  uint64_t v6;
  void *v8;
  double v9;
  uint64_t v10;

  v4 = objc_autoreleasePoolPush();
  v9 = 0.0;
  v10 = 0;
  v5 = sub_100027D10((uint64_t)a2);
  v6 = 1;
  if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v5))
  {
    if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v5, &v10, &v9)&& !sub_100047970(*(_DWORD **)(a1 + 120), a2, v10, v9))
    {
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Trigger disconnected %@ is not suitable", "WiFiDeviceManagerKnownNetworkSuitableAfterTriggerDisconnect", sub_10002B088(a2));
      objc_autoreleasePoolPop(v8);
      v6 = 0;
      if (v5)
        goto LABEL_6;
      goto LABEL_7;
    }
    v6 = 1;
  }
  if (v5)
LABEL_6:

LABEL_7:
  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t sub_100104D64(uint64_t a1)
{
  return a1 + 1208;
}

uint64_t sub_100104D6C(uint64_t a1)
{
  const void *v2;
  void *v3;
  const void *v4;
  void *v5;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  void *v9;
  uint64_t v11;
  CFRange v12;

  v2 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  v3 = sub_10002A21C(a1, v2, 1);
  if (v3)
  {
    v4 = v3;
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Start 6E prefer off switch scan", "WiFiDeviceManager6EPreferOff");
    objc_autoreleasePoolPop(v5);
    v6 = *(const __CFArray **)(a1 + 3528);
    v12.length = CFArrayGetCount(v6);
    v12.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v12, v4);
    if (FirstIndexOfValue == -1)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no known network found", "WiFiDeviceManager6EPreferOff", v11);
    }
    else
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
      if (sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("Standalone")) == kCFBooleanTrue)
      {
        sub_1000285E4(a1, 0x34uLL);
        goto LABEL_10;
      }
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Current network is not standalone 6G %@", "WiFiDeviceManager6EPreferOff", ValueAtIndex);
    }
    objc_autoreleasePoolPop(v9);
LABEL_10:
    CFRelease(v4);
  }
  return 4294963396;
}

uint64_t sub_100104EC4(uint64_t a1)
{
  const void *v2;
  void *v3;
  const void *v4;
  const __CFNumber *v5;
  void *v7;
  int valuePtr;

  v2 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  v3 = sub_10002A21C(a1, v2, 1);
  if (v3)
  {
    v4 = v3;
    valuePtr = 0;
    v5 = (const __CFNumber *)sub_10002BE64((uint64_t)v3, CFSTR("CHANNEL_FLAGS"));
    if (v5 && (CFNumberGetValue(v5, kCFNumberIntType, &valuePtr), (valuePtr & 0x2000) != 0))
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: current channel is non 6G channel", "WiFiDeviceManager6EPreferOn");
      objc_autoreleasePoolPop(v7);
    }
    else
    {
      sub_1000285E4(a1, 0x35uLL);
    }
    CFRelease(v4);
  }
  return 4294963396;
}

void sub_100104F88(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 64);
    sub_100025C3C(v1);
    sub_100072118(v1);
  }
}

void sub_100104FBC(uint64_t a1, const __CFArray *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  void *v8;
  const void *v9;
  void *v10;
  BOOL v11;
  __CFArray *v12;
  const __CFArray *v13;
  CFIndex v14;
  int v15;
  int v16;
  void *v17;
  const void *ValueAtIndex;
  id v19;
  const __CFArray *v20;
  unsigned int v21;
  int v22;
  CFIndex v23;
  void *v24;
  const void *v25;
  id v26;
  const __CFArray *v27;
  unsigned int v28;
  int v29;
  _BOOL8 v30;
  uint64_t v31;
  void *v32;
  void *v33;
  const void *v34;
  const __CFArray *cf;
  CFRange v36;
  CFRange v37;

  v4 = *(_QWORD *)(a1 + 64);
  v5 = (const void *)sub_100025C3C(v4);
  v6 = sub_10002BF8C(v4, v5);
  if (v6)
  {
    v7 = v6;
    v8 = (void *)sub_10002BE64((uint64_t)v6, CFSTR("SSID"));
    v9 = *(const void **)(a1 + 3776);
    if (v8 == v9)
      goto LABEL_12;
    v10 = v8;
    if (v8)
      v11 = v9 == 0;
    else
      v11 = 1;
    if (!v11)
    {
      if ((objc_msgSend(v8, "isEqual:") & 1) != 0)
        goto LABEL_12;
      v9 = *(const void **)(a1 + 3776);
    }
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 3776) = 0;
    }
    *(_QWORD *)(a1 + 3776) = objc_msgSend(v10, "copy");
    *(_DWORD *)(a1 + 3784) = 0;
LABEL_12:
    v12 = sub_1000775BC(*(_QWORD *)(a1 + 64), 0x4E20u);
    v13 = sub_10002B170(a1, v7, 0);
    if (!v13)
    {
LABEL_46:
      CFRelease(v7);
      if (v12)
        CFRelease(v12);
      return;
    }
    v34 = v7;
    cf = v13;
    if (a2 && CFArrayGetCount(a2) >= 1)
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      do
      {
        v17 = objc_autoreleasePoolPush();
        ValueAtIndex = CFArrayGetValueAtIndex(a2, v14);
        v19 = sub_100027D10((uint64_t)ValueAtIndex);
        if (objc_msgSend(v19, "SSID") == *(id *)(a1 + 3776)
          || objc_msgSend(v19, "SSID")
          && *(_QWORD *)(a1 + 3776)
          && objc_msgSend(objc_msgSend(v19, "SSID"), "isEqual:", *(_QWORD *)(a1 + 3776)))
        {
          v20 = *(const __CFArray **)(a1 + 3528);
          v36.length = CFArrayGetCount(v20);
          v36.location = 0;
          if (CFArrayGetFirstIndexOfValue(v20, v36, ValueAtIndex) != -1)
          {
            v21 = objc_msgSend(objc_msgSend(v19, "channel"), "band");
            v15 |= v21 == 3;
            v16 |= v21 != 3;
          }
        }
        objc_autoreleasePoolPop(v17);
        ++v14;
      }
      while (v14 < CFArrayGetCount(a2));
      if (!v12)
        goto LABEL_36;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      if (!v12)
        goto LABEL_36;
    }
    if (CFArrayGetCount(v12) >= 1)
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v24 = objc_autoreleasePoolPush();
        v25 = CFArrayGetValueAtIndex(v12, v23);
        v26 = sub_100027D10((uint64_t)v25);
        if (objc_msgSend(v26, "SSID") == *(id *)(a1 + 3776)
          || objc_msgSend(v26, "SSID")
          && *(_QWORD *)(a1 + 3776)
          && objc_msgSend(objc_msgSend(v26, "SSID"), "isEqual:", *(_QWORD *)(a1 + 3776)))
        {
          v27 = *(const __CFArray **)(a1 + 3528);
          v37.length = CFArrayGetCount(v27);
          v37.location = 0;
          if (CFArrayGetFirstIndexOfValue(v27, v37, v25) != -1)
          {
            v28 = objc_msgSend(objc_msgSend(v26, "channel"), "band");
            v15 |= v28 == 3;
            v22 |= v28 != 3;
          }
        }
        objc_autoreleasePoolPop(v24);
        ++v23;
      }
      while (v23 < CFArrayGetCount(v12));
      goto LABEL_37;
    }
LABEL_36:
    v22 = 0;
LABEL_37:
    v29 = v15 & ((v16 | v22) ^ 1);
    v30 = sub_10002BE64((uint64_t)cf, CFSTR("Standalone")) == kCFBooleanTrue;
    if (v29 != v30)
    {
      v31 = v29 & 1;
      ++*(_DWORD *)(a1 + 3784);
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Tracking changed standalone6G (%d --> %d) for known network %@, counter=%d/%d", v30, v31, cf, *(unsigned int *)(a1 + 3784), 3);
      objc_autoreleasePoolPop(v32);
      if (*(_DWORD *)(a1 + 3784) >= 3u)
      {
        *(_DWORD *)(a1 + 3784) = 0;
        v33 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Updating standalone6G (%d --> %d) for known network %@", v30, v31, cf);
        objc_autoreleasePoolPop(v33);
        sub_10002C478((uint64_t)cf, CFSTR("Standalone"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v31));
        sub_1001053C8((NSObject **)a1, cf);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 3784) = 0;
    }
    CFRelease(cf);
    v7 = v34;
    goto LABEL_46;
  }
}

void sub_1001053C8(NSObject **cf, const void *a2)
{
  NSObject *v4;
  void *v5;
  _QWORD block[6];

  if (cf)
  {
    if (cf[565])
    {
      if (cf[30])
      {
        if (a2)
        {
          CFRetain(cf);
          CFRetain(a2);
          v4 = cf[30];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100135D3C;
          block[3] = &unk_10022EF88;
          block[4] = cf;
          block[5] = a2;
          dispatch_async(v4, block);
          return;
        }
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network", "__WiFiDeviceManagerUpdateNetworkAsync");
      }
      else
      {
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue", "__WiFiDeviceManagerUpdateNetworkAsync");
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null updateNetwork callback", "__WiFiDeviceManagerUpdateNetworkAsync");
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiDeviceManagerUpdateNetworkAsync");
  }
  objc_autoreleasePoolPop(v5);
}

void sub_10010552C(uint64_t a1, const __CFDictionary **a2)
{
  _QWORD v2[5];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10010557C;
  v2[3] = &unk_1002314B8;
  v2[4] = a1;
  sub_10010367C(a1, a2, (uint64_t)v2);
}

void sub_10010557C(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "updateCurrentNetworkDetails:", a2);

  }
}

BOOL sub_1001055B4(uint64_t a1, const void *a2)
{
  void *v4;
  void *v5;
  __CFArray *v6;
  const __CFArray *v7;
  id v8;
  unsigned int v9;
  BOOL v10;
  const __CFArray *v11;
  unsigned int v12;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFIndex v15;
  const void *v16;
  id v17;
  CFBooleanRef v18;
  _BOOL8 v19;
  void *v20;
  _BOOL8 v21;
  CFRange v23;

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Updating 6G standalone property in known network plist");
  objc_autoreleasePoolPop(v5);
  v6 = sub_1000775BC(*(_QWORD *)(a1 + 64), 0x4E20u);
  v7 = v6;
  if (!a2)
  {
    v21 = 0;
    if (!v6)
      goto LABEL_24;
    goto LABEL_23;
  }
  v8 = sub_100027D10((uint64_t)a2);
  v9 = objc_msgSend(objc_msgSend(v8, "channel"), "band");
  v10 = v9 == 3;
  if (v8)
  {
    v11 = *(const __CFArray **)(a1 + 3528);
    if (v11)
    {
      v12 = v9;
      v23.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
      v23.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11, v23, a2);
      if (FirstIndexOfValue != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
        if (v12 == 3 && v7 && CFArrayGetCount(v7) >= 1)
        {
          v15 = 0;
          do
          {
            v16 = CFArrayGetValueAtIndex(v7, v15);
            v17 = sub_100027D10((uint64_t)v16);
            if (objc_msgSend(v17, "SSID")
              && objc_msgSend(v8, "SSID")
              && objc_msgSend(objc_msgSend(v17, "SSID"), "isEqual:", objc_msgSend(v8, "SSID"))
              && objc_msgSend(objc_msgSend(v17, "channel"), "band") != 3)
            {
              v10 = 0;
            }
            ++v15;
          }
          while (v15 < CFArrayGetCount(v7));
        }
        v18 = (CFBooleanRef)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("Standalone"));
        if (ValueAtIndex)
        {
          v19 = v18 == kCFBooleanTrue;
          if (v19 != v10)
          {
            v20 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Know network %@ 6G standalone state changed from %d to %d", ValueAtIndex, v19, v10);
            objc_autoreleasePoolPop(v20);
            *(_DWORD *)(a1 + 3784) = 0;
            sub_10002C478((uint64_t)ValueAtIndex, CFSTR("Standalone"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v10));
            sub_1001053C8((NSObject **)a1, ValueAtIndex);
          }
        }
      }
    }
  }
  v21 = v10;
  if (v7)
LABEL_23:
    CFRelease(v7);
LABEL_24:
  objc_autoreleasePoolPop(v4);
  return v21;
}

BOOL sub_100105808(uint64_t a1, const void *a2)
{
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFRange v8;

  if (a1
    && a2
    && (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576))) != 0
    && (v8.length = Count,
        v8.location = 0,
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3576), v8, a2),
        FirstIndexOfValue != -1)
    && (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), FirstIndexOfValue)) != 0)
  {
    return sub_1000C475C((uint64_t)ValueAtIndex);
  }
  else
  {
    return 0;
  }
}

__CFDictionary *sub_100105878(uint64_t a1, const __CFArray *a2)
{
  __CFDictionary *Mutable;
  CFMutableArrayRef v5;
  const __CFArray *v6;
  unsigned __int8 *v7;
  __CFString *v8;
  CFIndex v9;
  void *ValueAtIndex;
  __CFDictionary *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  const void *v14;
  const __CFString *v15;
  int v16;
  CFNumberRef v17;
  CFNumberRef v18;
  void *v19;
  const __CFString *v20;
  __CFString *v21;
  __CFString *v22;
  void *v23;
  id v24;
  CFNumberRef v25;
  CFNumberRef v26;
  void *v27;
  const __CFString *v28;
  void *v29;
  const __CFString *v30;
  const __CFString *v31;
  void *v32;
  const __CFString *v33;
  void *v34;
  void *v35;
  const __CFString *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  __CFDictionary *v43;
  __CFDictionary *v44;
  const char *v45;
  const void *v46;
  const char *v47;
  const __CFString *v48;
  const __CFArray *v49;
  CFIndex v50;
  CFIndex v51;
  CFIndex i;
  const void *v53;
  CFIndex v54;
  uint64_t v55;
  CFIndex j;
  const __CFDictionary *v57;
  const void *Value;
  int v59;
  CFBooleanRef v60;
  CFBooleanRef v61;
  const __CFString *v62;
  void *v63;
  __CFDictionary *theDict;
  const __CFArray *v66;
  __CFArray *theArray;
  CFIndex Count;
  const __CFArray *v69;
  unsigned int v70;
  int v71;
  _BOOL8 valuePtr;
  CFRange v73;
  CFRange v74;

  valuePtr = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v5)
    {
      v6 = v5;
      v7 = (unsigned __int8 *)(a1 + 5456);
      v8 = CFStringCreateMutable(kCFAllocatorDefault, 0);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3600));
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3608));
      if (a2 && CFArrayGetCount(a2) >= 1)
      {
        if (v8)
          CFStringAppend(v8, CFSTR("Preparing background scan request for "));
        theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (theArray)
        {
          theDict = Mutable;
          v66 = v6;
          Count = CFArrayGetCount(a2);
          if (Count >= 1)
          {
            v9 = 0;
            v69 = a2;
            while (1)
            {
              ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, v9);
              v11 = sub_1000C33B4((uint64_t)ValueAtIndex);
              valuePtr = sub_100031670(ValueAtIndex) != 0;
              v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
              if (v12)
              {
                v13 = v12;
                CFDictionarySetValue(v11, CFSTR("HIDDEN_NETWORK"), v12);
                CFRelease(v13);
              }
              v14 = CFArrayGetValueAtIndex(a2, v9);
              v15 = (const __CFString *)sub_10002B088(v14);
              v71 = 0;
              v16 = sub_100125CA4(a1, ValueAtIndex, 0, &v71);
              if (*(_DWORD *)(a1 + 128) != v16)
              {
                v70 = *(_DWORD *)(a1 + 136) + v16;
                v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v70);
                if (v17)
                {
                  v18 = v17;
                  CFDictionarySetValue(v11, CFSTR("BGSCANRSSITHRES"), v17);
                  v19 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v20 = CFSTR("NULL");
                    if (v15)
                      v20 = v15;
                    if ((v71 - 1) > 3)
                      v21 = 0;
                    else
                      v21 = off_100232250[v71 - 1];
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s PNO RssiThres %d for unreliable network %@ (%@)", "__CreateBGScanRequest", v70, v20, v21);
                  }
                  objc_autoreleasePoolPop(v19);
                  CFRelease(v18);
                  a2 = v69;
                }
              }
              v22 = v8;
              v23 = objc_autoreleasePoolPush();
              v24 = sub_100027D10((uint64_t)ValueAtIndex);
              if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v24, 0, 0))
              {
                v70 = -1431655766;
                v70 = *(_DWORD *)(a1 + 136) + sub_1000478FC(*(_QWORD *)(a1 + 120));
                CFSetAddValue(*(CFMutableSetRef *)(a1 + 3600), ValueAtIndex);
                v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v70);
                if (v25)
                {
                  v26 = v25;
                  CFDictionarySetValue(v11, CFSTR("BGSCANRSSITHRES"), v25);
                  v27 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v28 = CFSTR("NULL");
                    if (v15)
                      v28 = v15;
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s LQAMgr enforced RssiThres %d for trgDisc network %@", "__CreateBGScanRequest", v70, v28);
                  }
                  objc_autoreleasePoolPop(v27);
                  CFRelease(v26);
                }
                a2 = v69;
              }

              objc_autoreleasePoolPop(v23);
              v8 = v22;
              if (sub_100105808(a1, ValueAtIndex)
                || sub_1000137D8((uint64_t)ValueAtIndex)
                || sub_10002DA5C((_BOOL8)ValueAtIndex))
              {
                CFSetAddValue(*(CFMutableSetRef *)(a1 + 3608), ValueAtIndex);
                CFDictionarySetValue(v11, CFSTR("DISALLOW_PNO"), kCFBooleanTrue);
                if (sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("WiFiNetworkUserAcceptedRecommendationAt")))
                {
                  v29 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v30 = CFSTR("NULL");
                    if (v15)
                      v30 = v15;
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user accepted recommendation to join captive %@, added to BGScan List", "__CreateBGScanRequest", v30);
                  }
                }
                else if (sub_1000CB0A0((uint64_t)ValueAtIndex) || sub_10002DA5C((_BOOL8)ValueAtIndex))
                {
                  v29 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v31 = CFSTR("NULL");
                    if (v15)
                      v31 = v15;
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Captive %@ added to BGScan List ", "__CreateBGScanRequest", v31);
                  }
                }
                else
                {
                  CFDictionarySetValue(v11, CFSTR("HOTSPOT"), kCFBooleanTrue);
                  v29 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v48 = CFSTR("NULL");
                    if (v15)
                      v48 = v15;
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Hotspot %@ added to BGScan List ", "__CreateBGScanRequest", v48);
                  }
                }
                objc_autoreleasePoolPop(v29);
              }
              if (sub_1000C46C8((uint64_t)ValueAtIndex))
              {
                CFDictionarySetValue(v11, CFSTR("DISALLOW_PNO"), kCFBooleanTrue);
                v32 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                {
                  v33 = CFSTR("NULL");
                  if (v15)
                    v33 = v15;
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Ambiguous ssid %@ added to BGScan List ", "__CreateBGScanRequest", v33);
                }
                objc_autoreleasePoolPop(v32);
              }
              if (byte_10026DD61)
              {
                v34 = sub_100026664((CFDictionaryRef *)ValueAtIndex);
                if ((objc_msgSend(v34, "isAllowedInLockdownMode") & 1) == 0)
                {
                  CFDictionarySetValue(v11, CFSTR("DISALLOW_PNO"), kCFBooleanTrue);
                  v35 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v36 = CFSTR("NULL");
                    if (v15)
                      v36 = v15;
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s ssid %@ not allowed to wake up host in lockdown mode ", "__CreateBGScanRequest", v36);
                  }
                  objc_autoreleasePoolPop(v35);
                }

              }
              if (v11)
              {
                CFArrayAppendValue(theArray, v11);
                CFRelease(v11);
              }
              if (v22 && v15)
                break;
              if (v15)
                goto LABEL_66;
LABEL_82:
              if (Count == ++v9)
                goto LABEL_88;
            }
            if (!CFEqual(v15, &stru_100238178))
              CFStringAppendFormat(v22, 0, CFSTR("\"%@\" "), v15);
LABEL_66:
            if (CFEqual(v15, &stru_100238178))
            {
              v37 = CFArrayGetValueAtIndex(a2, v9);
              v38 = sub_10002BE64((uint64_t)v37, CFSTR("BSSID"));
              if (v38)
              {
                v39 = v38;
                v40 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL"));
                if (v40)
                {
                  v41 = v40;
                  v42 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL_FLAGS"));
                  v43 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (v43)
                  {
                    v44 = v43;
                    CFDictionaryAddValue(v43, CFSTR("CHANNEL"), v41);
                    if (v42)
                      CFDictionaryAddValue(v44, CFSTR("CHANNEL_FLAGS"), v42);
                    v73.length = CFArrayGetCount(v66);
                    v73.location = 0;
                    if (!CFArrayContainsValue(v66, v73, v44))
                      CFArrayAppendValue(v66, v44);
                    CFRelease(v44);
                  }
                }
                a2 = v69;
                if (v22)
                {
                  if (sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("ENTRY_NETWORK")))
                    v45 = " EN";
                  else
                    v45 = "";
                  v46 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("EXIT_NETWORK"));
                  v47 = " EX";
                  if (!v46)
                    v47 = "";
                  CFStringAppendFormat(v22, 0, CFSTR("\"%@ ~%s%s\" "), v39, v45, v47);
                }
              }
            }
            goto LABEL_82;
          }
LABEL_88:
          Mutable = theDict;
          if (CFArrayGetCount(theArray))
            CFDictionarySetValue(theDict, CFSTR("SCAN_SSID_LIST"), theArray);
          CFRelease(theArray);
          v6 = v66;
          v7 = (unsigned __int8 *)(a1 + 5456);
        }
      }
      if (*v7)
      {
        v49 = *(const __CFArray **)(a1 + 5448);
        if (v49)
        {
          v50 = CFArrayGetCount(v49);
          if (v50 >= 1)
          {
            v51 = v50;
            for (i = 0; i != v51; ++i)
            {
              v53 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5448), i);
              v74.length = CFArrayGetCount(v6);
              v74.location = 0;
              if (!CFArrayContainsValue(v6, v74, v53))
                CFArrayAppendValue(v6, v53);
            }
          }
        }
      }
      v54 = CFArrayGetCount(v6);
      if (v54)
      {
        if (v8)
        {
          v55 = v54;
          CFStringAppend(v8, CFSTR("on channels: "));
          if (v55 >= 1)
          {
            for (j = 0; j != v55; ++j)
            {
              v57 = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, j);
              Value = CFDictionaryGetValue(v57, CFSTR("CHANNEL"));
              CFStringAppendFormat(v8, 0, CFSTR("%@ "), Value);
            }
          }
        }
      }
      CFDictionarySetValue(Mutable, CFSTR("SCAN_CHANNELS"), v6);
      v59 = *v7;
      if (*v7)
        v60 = kCFBooleanTrue;
      else
        v60 = kCFBooleanFalse;
      CFDictionarySetValue(Mutable, CFSTR("BGSCAN_CACHE"), v60);
      if (v59)
      {
        if (v7[2])
          v61 = kCFBooleanTrue;
        else
          v61 = kCFBooleanFalse;
        CFDictionarySetValue(Mutable, CFSTR("BGSCAN_CACHE_WSB_ROLLOVER"), v61);
        if (v8)
        {
          v62 = CFSTR("Background Scan Caching is Enabled");
LABEL_114:
          CFStringAppend(v8, v62);
          v7[1] = v59 != 0;
          v63 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", v8);
          objc_autoreleasePoolPop(v63);
          CFRelease(v8);
          goto LABEL_118;
        }
      }
      else if (v8)
      {
        v62 = CFSTR("Background Scan Caching is Disabled");
        goto LABEL_114;
      }
      v7[1] = v59 != 0;
LABEL_118:
      CFRelease(v6);
    }
  }
  return Mutable;
}

void sub_10010621C(uint64_t a1)
{
  const void *v2;
  const __CFDictionary **v3;
  uint64_t v4;
  const __CFDictionary **v5;
  int v6;

  if (a1)
  {
    v2 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v3 = (const __CFDictionary **)sub_10002A21C(a1, v2, 1);
    v4 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      v5 = v3;
      v6 = sub_100126BCC(a1, v3);
      sub_1000719FC(v4, v6);
      CFRelease(v5);
    }
    else
    {
      sub_1000719FC(*(_QWORD *)(a1 + 64), 0);
    }
  }
}

uint64_t sub_1001062AC(uint64_t a1)
{
  void *v2;
  const void *v3;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Resetting MIS state.", "WiFiDeviceManagerResetMISState");
  objc_autoreleasePoolPop(v2);
  v3 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  return sub_100106328(a1, v3, 0, 0, 0);
}

uint64_t sub_100106328(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;

  v10 = malloc_type_malloc(0x20uLL, 0xA004088793A40uLL);
  *v10 = a1;
  v10[1] = a4;
  v10[3] = a5;
  if (a3)
    v11 = CFRetain(a3);
  else
    v11 = 0;
  v10[2] = v11;
  v12 = sub_10006A0C4(*(_QWORD *)(a1 + 64), a2, (uint64_t)sub_10010F05C, (uint64_t)v10);
  if ((_DWORD)v12)
  {
    v13 = v12;
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to stop network (%d). deviceManager=%p", v13, a1);
    objc_autoreleasePoolPop(v14);
    free(v10);
  }
  return 0;
}

void sub_100106408(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  void *v4;
  const char *v5;
  void *v8;
  _OWORD v9[7];
  uint64_t v10;
  CFStringRef v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  if (*(unsigned __int8 *)(a1 + 5219) == (_DWORD)a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "enabled";
      if (!(_DWORD)a2)
        v5 = "disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS is already %s", v5);
    }
    objc_autoreleasePoolPop(v4);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if ((_DWORD)a2)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Force MIS Service enable", "WiFiDeviceManagerSetMISState");
      objc_autoreleasePoolPop(v8);
      sub_1001065B4(a1, a2, 0, 0, a3);
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Force MIS Service disable", "WiFiDeviceManagerSetMISState");
      objc_autoreleasePoolPop(v8);
      v14 = 0;
      v12 = 0u;
      v13 = 0u;
      v10 = 1;
      memset(v9, 0, sizeof(v9));
      DWORD2(v9[0]) = 1;
      v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("MIS Disabled"));
      sub_100106C34(a1, (uint64_t)v9);
      sub_1001065B4(a1, 0, 0, 0, a3);
      sub_100107084(a1);
    }
  }
}

void sub_1001065B4(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int *a5)
{
  unsigned __int8 *v10;
  void *v11;
  void *v12;
  const char *v13;
  const char *v14;
  unsigned int v15;
  void *v16;
  const char *v17;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  const char *v22;
  _BOOL4 v23;
  void *v24;
  const void *v25;
  void *v26;
  const void *v27;
  void *v28;
  const void *v29;
  int v30;
  const __CFSet *v31;
  const __CFSet *v32;
  void *v33;
  const char *v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  void *v38;
  void *v39;
  const char *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  if ((_DWORD)a2)
  {
    v51 = 0;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    LODWORD(v41) = *a5;
    sub_100106C34(a1, (uint64_t)&v41);
  }
  if (!sub_10006FA34(*(_QWORD *)(a1 + 64)))
  {
    if (*a5 != 5)
    {
      v51 = 0;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      DWORD1(v41) = 3;
      sub_100106C34(a1, (uint64_t)&v41);
    }
    return;
  }
  v10 = (unsigned __int8 *)(a1 + 5216);
  if (!(a3 | a2)
    && ((v31 = *(const __CFSet **)(a1 + 5272)) != 0 && CFSetGetCount(v31)
     || (v32 = *(const __CFSet **)(a1 + 5280)) != 0 && CFSetGetCount(v32)))
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (v10[5])
        v34 = "enabled";
      else
        v34 = "disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Discovery %s by more clients", v34);
    }
    objc_autoreleasePoolPop(v33);
    return;
  }
  if ((_DWORD)a2
    && *(_BYTE *)(a1 + 5219)
    && !*(_BYTE *)(a1 + 5384)
    && (a4 || CFSetGetCount(*(CFSetRef *)(a1 + 5272)) >= 1 && *(_DWORD *)(a1 + 7048) == 1))
  {
    v37 = *v10;
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (v37 > 0xD)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Discovery %s Force 2.4Ghz", "enabled");
      v15 = 1;
      goto LABEL_14;
    }
    if (qword_10026DD20)
    {
      v14 = "MIS Already enabled in 2.4GHz";
LABEL_12:
      objc_msgSend(v12, "WFLog:message:", 3, v14, v40);
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v13 = "disabled";
      if ((_DWORD)a2)
        v13 = "enabled";
      v40 = v13;
      v14 = "MIS Discovery %s";
      goto LABEL_12;
    }
  }
  v15 = 0;
LABEL_14:
  objc_autoreleasePoolPop(v11);
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 7040))
      v17 = "Support";
    else
      v17 = "Not Support";
    v18 = "is 5G";
    if (!*(_BYTE *)(a1 + 7043))
      v18 = "is not 5G";
    v19 = *(_DWORD *)(a1 + 7048);
    v20 = "5GHz";
    if (v19 == 1)
      v20 = "2.4GHz";
    if (v19)
      v21 = v20;
    else
      v21 = "Default";
    if (a4)
      v22 = "2.4GHz";
    else
      v22 = "Default";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS WiFi %s 5GHz SoftAP, Cellular Radio %s, User Preferred %s Band, Client Req %s\n", v17, v18, v21, v22);
  }
  objc_autoreleasePoolPop(v16);
  if ((_DWORD)a2)
    sub_1001074BC(a1, 0);
  v23 = sub_1001076C4(a1);
  *(_BYTE *)(a1 + 5221) = a2;
  *(_BYTE *)(a1 + 5384) = a4;
  *(_BYTE *)(a1 + 5386) = *a5 == 8;
  v24 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s misRestart %d misEnabled %d enable %d manager->mis.misEnabled %d numClients %d misIsNANPHS %d bringUpMethod %d\n", "WiFiDeviceManagerSetMISDiscoveryState", v15, v23, a2, *(unsigned __int8 *)(a1 + 5219), (*(_BYTE *)(a1 + 5218) + *(_BYTE *)(a1 + 5217)), *(unsigned __int8 *)(a1 + 5386), *a5);
  objc_autoreleasePoolPop(v24);
  if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS")
    && (_DWORD)a2
    && *(_DWORD *)(a1 + 6776) != -536870272
    && v23
    && *(_BYTE *)(a1 + 5219)
    && *a5 == 8)
  {
    v25 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v26 = sub_10002A21C(a1, v25, 1);
    if (v26)
    {
      v27 = v26;
      if (!sub_100107828(a1, 8) || *(_BYTE *)(a1 + 5385))
      {
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enabling MIS. Now disconnecting from %@", sub_10002B088(v27));
        objc_autoreleasePoolPop(v28);
        v29 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
        sub_1000F7F48(a1, v29, 1007, "WiFiDeviceManagerSetMISDiscoveryState", 19157);
        *(_BYTE *)(a1 + 5389) = 1;
      }
    }
    else
    {
      sub_1000FB44C(a1);
      if (objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted"))
      {
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Publisher Already Started Do not set SoftAP CSA", "WiFiDeviceManagerSetMISDiscoveryState");
        objc_autoreleasePoolPop(v38);
      }
      else
      {
        sub_10006AAE0(*(_QWORD *)(a1 + 64));
      }
      sub_1001079C8(a1);
    }
    *(_BYTE *)(a1 + 5386) = 1;
    return;
  }
  if (v15)
  {
    v30 = sub_10010416C(a1);
    sub_100103E6C(a1, v30);
    goto LABEL_83;
  }
  v35 = *(unsigned __int8 *)(a1 + 5219);
  if ((_DWORD)a2 && v23)
  {
    v36 = *a5;
    if (*(_BYTE *)(a1 + 5219))
    {
      if (v36 != 8)
      {
        v35 = 1;
        goto LABEL_75;
      }
    }
    else if (v36 != 8)
    {
LABEL_82:
      sub_100107ABC(a1);
      goto LABEL_83;
    }
    if (!*(_BYTE *)(a1 + 5386))
      *(_BYTE *)(a1 + 5386) = 1;
    goto LABEL_82;
  }
  if ((_DWORD)a2 || !*(_BYTE *)(a1 + 5219))
  {
LABEL_75:
    if ((_DWORD)a2 && v35 && *(_BYTE *)(a1 + 5260))
      sub_10006A410(*(_QWORD *)(a1 + 64), 1);
    goto LABEL_83;
  }
  if (*(unsigned __int8 *)(a1 + 5218) != -*(_BYTE *)(a1 + 5217))
  {
LABEL_83:
    if (*(_QWORD *)(a1 + 4136))
    {
      sub_100107DE4(a1, 1);
      (*(void (**)(uint64_t, _QWORD, _QWORD))(a1 + 4136))(a1, *(_QWORD *)(a1 + 4144), *(unsigned __int8 *)(a1 + 5221));
    }
    return;
  }
  if (a3)
  {
    if (*(_BYTE *)(a1 + 5222))
    {
      *(_BYTE *)(a1 + 5222) = 0;
      sub_1001074BC(a1, 0);
    }
    v51 = 0;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    DWORD2(v41) = 1;
    LODWORD(v48) = 1;
    *((_QWORD *)&v48 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("MIS Disabled"));
    sub_100106C34(a1, (uint64_t)&v41);
    sub_100107084(a1);
    goto LABEL_83;
  }
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting MIS idle timer", "WiFiDeviceManagerSetMISDiscoveryState");
  objc_autoreleasePoolPop(v39);
  sub_1001074BC(a1, 2);
}

double sub_100106C34(uint64_t a1, uint64_t a2)
{
  double v4;
  int v5;
  double v6;
  _BYTE *v7;
  int v8;
  int v9;
  uint64_t v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  int v13;
  void *v14;
  void *v15;
  uint64_t v16;
  const void *v17;
  double v18;
  double v19;
  int v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  const void *v26;
  void *v27;
  double result;
  const __CFDictionary *v29;
  const __CFNumber *Value;
  int v31;
  void *v32;
  double *v33;
  unsigned __int16 valuePtr;

  v4 = *(double *)(a2 + 16);
  if (v4 != 0.0)
  {
    *(double *)(a1 + 6304) = v4;
    sub_100118CA8(a1, 1);
  }
  if (*(_DWORD *)a2)
  {
    if (!*(_DWORD *)(a1 + 6288))
      *(_DWORD *)(a1 + 6288) = *(_DWORD *)a2;
    sub_100118CA8(a1, 1);
  }
  v5 = *(_DWORD *)(a2 + 4);
  if (v5)
    *(_DWORD *)(a1 + 6292) = v5;
  v6 = *(double *)(a2 + 24);
  if (v6 != 0.0)
  {
    *(double *)(a1 + 6312) = v6;
    sub_100118CA8(a1, 1);
  }
  v7 = (_BYTE *)(a1 + 5216);
  if (*(_DWORD *)(a2 + 4) < 2u)
  {
    v8 = 0;
  }
  else
  {
    sub_100118CA8(a1, 0);
    v8 = 1;
  }
  if (*(_BYTE *)(a2 + 160))
    *(_BYTE *)(a1 + 6448) = *(_BYTE *)(a2 + 160);
  v9 = *(_DWORD *)(a2 + 8);
  if (v9)
  {
    if (*(_DWORD *)(a1 + 6292) == 1)
    {
      *(_DWORD *)(a1 + 6296) = v9;
      *(double *)(a1 + 6320) = sub_100064914();
      if (*(double *)(a1 + 6384) != 0.0)
        *(double *)(a1 + 6392) = sub_100064914();
      v8 = 1;
    }
    sub_100118CA8(a1, 0);
  }
  *(_DWORD *)(a1 + 6356) = 0;
  v10 = *(_QWORD *)(a1 + 5208);
  if (v10)
  {
    valuePtr = 0;
    v11 = (const __CFNumber *)sub_10002BE64(v10, CFSTR("AP_MODE_AUTH_UPPER"));
    v12 = v11;
    if (v11 && CFNumberGetValue(v11, kCFNumberSInt16Type, &valuePtr))
    {
      v13 = (valuePtr >> 2) & 2 | (valuePtr >> 5) & 0x80;
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Faield to get SoftAP upper AUTH (numRef is NULL %d)", v12 == 0);
      objc_autoreleasePoolPop(v15);
      v13 = 0;
    }
    *(_DWORD *)(a1 + 6356) = v13;
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SoftAP has no network record");
    objc_autoreleasePoolPop(v14);
  }
  if (*(_BYTE *)(a2 + 72))
  {
    *(_BYTE *)(a1 + 6360) = *(_BYTE *)(a2 + 72);
    sub_100118CA8(a1, 1);
  }
  v16 = *(_QWORD *)(a2 + 80);
  if (v16)
  {
    v17 = *(const void **)(a1 + 6368);
    if (v17)
    {
      CFRelease(v17);
      *(_QWORD *)(a1 + 6368) = 0;
      v16 = *(_QWORD *)(a2 + 80);
    }
    *(_QWORD *)(a1 + 6368) = v16;
    sub_100118CA8(a1, 1);
  }
  if (*(_BYTE *)(a2 + 88))
  {
    *(_BYTE *)(a1 + 6376) = *(_BYTE *)(a2 + 88);
    sub_100118CA8(a1, 1);
  }
  v18 = *(double *)(a2 + 96);
  if (v18 != 0.0)
  {
    *(double *)(a1 + 6384) = v18;
    sub_100118CA8(a1, 1);
  }
  v19 = *(double *)(a2 + 104);
  if (v19 != 0.0)
  {
    *(double *)(a1 + 6392) = v19;
    sub_100118CA8(a1, 1);
  }
  v20 = *(_DWORD *)(a2 + 112);
  if (v20)
    *(_DWORD *)(a1 + 6400) = v20;
  v21 = *(_QWORD *)(a2 + 120);
  if (v21)
  {
    v22 = *(const void **)(a1 + 6408);
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(a1 + 6408) = 0;
      v21 = *(_QWORD *)(a2 + 120);
    }
    *(_QWORD *)(a1 + 6408) = v21;
  }
  if (*(_BYTE *)(a2 + 128))
    *(_BYTE *)(a1 + 6416) = *(_BYTE *)(a2 + 128);
  if (*(_BYTE *)(a2 + 144))
    *(_BYTE *)(a1 + 6432) = *(_BYTE *)(a2 + 144);
  v23 = *(_QWORD *)(a2 + 136);
  if (v23)
  {
    v24 = *(const void **)(a1 + 6424);
    if (v24)
    {
      CFRelease(v24);
      *(_QWORD *)(a1 + 6424) = 0;
      v23 = *(_QWORD *)(a2 + 136);
    }
    *(_QWORD *)(a1 + 6424) = v23;
  }
  v25 = *(_QWORD *)(a2 + 152);
  if (v25)
  {
    v26 = *(const void **)(a1 + 6440);
    if (v26)
    {
      CFRelease(v26);
      *(_QWORD *)(a1 + 6440) = 0;
      v25 = *(_QWORD *)(a2 + 152);
    }
    *(_QWORD *)(a1 + 6440) = v25;
  }
  if (*(_BYTE *)(a2 + 160))
    *(_BYTE *)(a1 + 6448) = *(_BYTE *)(a2 + 160);
  v27 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: PHSessionMetric: method=%d end=%d teardown=%d, misStart=%f softAPUp=%f sessionEnd=%f, appleDeviceConnectionCount=%d(%x) nonAppleDeviceConnectionCount=%d deviceDisconnectCount=%d, lpmDuration=%llu, channel=%d, securityTypes 0x%XnanPhPublisherFailureReason %d, nanPhNanStationCount %d, nanPhNanStartSessionTime %f nanPhNanSessionEndTime %f", "WiFiDeviceManagerRecordPHMetricStats", *(unsigned int *)(a1 + 6288), *(unsigned int *)(a1 + 6292), *(unsigned int *)(a1 + 6296), *(_QWORD *)(a1 + 6304), *(_QWORD *)(a1 + 6312), *(_QWORD *)(a1 + 6320), *(unsigned __int16 *)(a1 + 6328), *(unsigned __int16 *)(a1 + 6330), *(unsigned __int16 *)(a1 + 6332), *(unsigned __int16 *)(a1 + 6334), *(_QWORD *)(a1 + 6336), *(unsigned int *)(a1 + 6344),
      *(unsigned int *)(a1 + 6356),
      *(unsigned __int8 *)(a1 + 6360),
      *(unsigned __int8 *)(a1 + 6376),
      *(_QWORD *)(a1 + 6384),
      *(_QWORD *)(a1 + 6392));
  objc_autoreleasePoolPop(v27);
  if (v8)
  {
    if (*v7)
      *(_DWORD *)(a1 + 6344) = *v7;
    v29 = *(const __CFDictionary **)(a1 + 7032);
    if (v29)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("SOFTAP_LOWPOWER_STATS_LOWPOWER_STATE_DURATION"));
      if (Value)
        CFNumberGetValue(Value, kCFNumberSInt64Type, (void *)(a1 + 6336));
    }
    v31 = *(unsigned __int8 *)(a1 + 6352);
    v32 = objc_autoreleasePoolPush();
    if (v31)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: PHSessionMetric: submission already pending.", "WiFiDeviceManagerRecordPHMetricStats");
      objc_autoreleasePoolPop(v32);
    }
    else
    {
      v33 = (double *)(a1 + 6288);
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: PHSessionMetric: submission triggered.", "WiFiDeviceManagerRecordPHMetricStats");
      objc_autoreleasePoolPop(v32);
      return sub_10005BA58(v33);
    }
  }
  return result;
}

uint64_t sub_100107084(uint64_t a1)
{
  IOPMAssertionID v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  int v28;
  void *v29;
  void *v30;
  const void *v31;
  const void *v32;
  void *v33;
  const void *v34;
  int v35;
  NSObject *v36;
  CFAbsoluteTime Current;
  dispatch_time_t v38;
  void *v39;
  int v40;

  v2 = *(_DWORD *)(a1 + 5228);
  if (v2)
  {
    v3 = IOPMAssertionRelease(v2);
    if ((_DWORD)v3)
    {
      v4 = v3;
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Stop MIS: Unable to release MIS PM Assertion error=%d", v4);
      objc_autoreleasePoolPop(v5);
    }
    *(_DWORD *)(a1 + 5228) = 0;
  }
  if (*(_QWORD *)(a1 + 4944))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Stopping MIS session");
    objc_autoreleasePoolPop(v6);
    if (_MISStopService)
    {
      v18 = _MISStopService(*(_QWORD *)(a1 + 4944), a1 + 4952, v7, v8, v9, v10, v11, v12);
      if (!v18)
        goto LABEL_17;
    }
    else
    {
      v18 = -1;
    }
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to stop DHCP Service: %s\n", strerror(v18));
    objc_autoreleasePoolPop(v19);
LABEL_17:
    if (!_MISSetHostCount || _MISSetHostCount(*(_QWORD *)(a1 + 4944), 2, 0, v13, v14, v15, v16, v17))
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error resetting MIS host count", "__WiFiDeviceManagerStopMIS");
      objc_autoreleasePoolPop(v27);
    }
    if (_MISDetach)
    {
      v28 = _MISDetach(*(_QWORD *)(a1 + 4944), v20, v21, v22, v23, v24, v25, v26);
      if (!v28)
      {
LABEL_29:
        *(_QWORD *)(a1 + 4944) = 0;
        goto LABEL_30;
      }
    }
    else
    {
      v28 = -1;
    }
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to detach MIS session: %s\n", strerror(v28));
    objc_autoreleasePoolPop(v29);
    goto LABEL_29;
  }
LABEL_30:
  if (*(_QWORD *)(a1 + 5208))
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Stopping MIS Network: %@", sub_10002B088(*(const void **)(a1 + 5208)));
    objc_autoreleasePoolPop(v30);
    v31 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_10010FABC(a1, v31, *(void **)(a1 + 5208), (uint64_t)sub_1001394CC, a1);
    v32 = *(const void **)(a1 + 5208);
    if (v32)
    {
      CFRelease(v32);
      *(_QWORD *)(a1 + 5208) = 0;
    }
  }
  else if (*(_DWORD *)(a1 + 5344) == 2)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS stopped while waiting for hostap. Stopping network.", "__WiFiDeviceManagerStopMIS");
    objc_autoreleasePoolPop(v33);
    v34 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_100106328(a1, v34, 0, (uint64_t)sub_1001394CC, a1);
  }
  if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS")
    && objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted")
    && !*(_BYTE *)(a1 + 5388))
  {
    objc_msgSend(*(id *)(a1 + 6752), "stopPublisherForPHSOverNAN");
    *(_BYTE *)(a1 + 5386) = 0;
    sub_1000F9DAC((char *)a1, 8, 0);
    *(_BYTE *)(a1 + 5218) = 0;
  }
  v35 = *(unsigned __int8 *)(a1 + 5219);
  if (*(_BYTE *)(a1 + 5219))
  {
    *(_BYTE *)(a1 + 5219) = 0;
    sub_100108298((_QWORD *)a1);
    v36 = *(NSObject **)(a1 + 5320);
    Current = CFAbsoluteTimeGetCurrent();
    v38 = dispatch_time(0, (uint64_t)((Current + 315360000.0) * 1000000000.0));
    dispatch_source_set_timer(v36, v38, 0xFFFFFFFFFFFFFFFFLL, 0);
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Stopped Internet Connection Sharing over WiFi");
    objc_autoreleasePoolPop(v39);
  }
  *(_WORD *)(a1 + 5216) = 0;
  *(_BYTE *)(a1 + 5360) = 0;
  *(_BYTE *)(a1 + 5222) = 0;
  sub_1000F9DAC((char *)a1, 4, 0);
  sub_1001074BC(a1, 0);
  *(_DWORD *)(a1 + 192) = 13;
  v40 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (v35 && v40 && !*(_BYTE *)(a1 + 5219))
    return sub_1000285E4(a1, 10);
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 10, sub_100025C3C(*(_QWORD *)(a1 + 64)));
  return sub_1000FBA80(a1, 2, "__WiFiDeviceManagerStopMIS");
}

uint64_t sub_1001074A4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5219);
}

uint64_t sub_1001074B0(uint64_t result, char a2)
{
  *(_BYTE *)(result + 5219) = a2;
  return result;
}

void sub_1001074BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  double v5;
  int v6;
  double v7;
  CFAbsoluteTime Current;
  _BOOL4 v9;
  _BOOL4 v10;
  BOOL v11;
  void *v12;
  const char *v13;
  NSObject *v14;
  dispatch_time_t v15;
  void *v16;

  v2 = a2;
  v4 = a2 - 1;
  v5 = 90.0;
  if ((a2 - 1) < 2)
  {
LABEL_5:
    if (sub_1001076C4(a1) && !(_DWORD)v2 && *(_DWORD *)(a1 + 5232) == 5)
      return;
    if (v4 <= 4)
    {
      v6 = *(_DWORD *)(a1 + 5232);
      if (v6)
      {
        v7 = *(double *)(a1 + 5248);
        Current = CFAbsoluteTimeGetCurrent();
        v6 = *(_DWORD *)(a1 + 5232);
        if (v5 <= v7 - Current && ((_DWORD)v2 != 3 || v6 != 4))
        {
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Timer Already Running. current state (%d) current timeout (%.1f) requested state (%d) requested timeout (%.1f) ", *(unsigned int *)(a1 + 5232), *(_QWORD *)(a1 + 5248), v2, *(_QWORD *)&v5);
          objc_autoreleasePoolPop(v16);
          return;
        }
      }
      v9 = v6 == 5;
      v10 = (v2 & 0xFFFFFFFE) == 2;
      v11 = v10 && v9;
      if (v10 && v9)
        v2 = 5;
      else
        v2 = v2;
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v13 = " ";
        if (v11)
          v13 = "Extending";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Starting MIS Timer. %s state (%d) timeout (%.1f)", v13, v2, *(_QWORD *)&v5);
      }
      objc_autoreleasePoolPop(v12);
    }
    if ((_DWORD)v2 != 5 && *(_DWORD *)(a1 + 5232) == 5)
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 5272), CFSTR("wifid"));
    *(_DWORD *)(a1 + 5232) = v2;
    v14 = *(NSObject **)(a1 + 5240);
    v15 = dispatch_time(0, (uint64_t)(v5 * 1000000000.0));
    dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(double *)(a1 + 5248) = v5 + CFAbsoluteTimeGetCurrent();
    return;
  }
  switch((int)a2)
  {
    case 3:
    case 6:
      goto LABEL_5;
    case 4:
      return;
    case 5:
      v5 = 120.0;
      goto LABEL_5;
    default:
      v5 = 315360000.0;
      goto LABEL_5;
  }
}

BOOL sub_1001076C4(uint64_t a1)
{
  const __SCDynamicStore *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  CFTypeID v5;
  const void *Value;
  _BOOL8 v7;
  CFTypeID v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  CFNumberRef v15;
  uint64_t v17;
  uint64_t valuePtr;

  v17 = 0;
  valuePtr = 0;
  v2 = *(const __SCDynamicStore **)(a1 + 5440);
  if (!v2)
    return 0;
  if (!qword_10026D760)
    return 0;
  v3 = (const __CFDictionary *)SCDynamicStoreCopyValue(v2, (CFStringRef)qword_10026D760);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = CFGetTypeID(v3);
  if (v5 != CFDictionaryGetTypeID())
  {
LABEL_15:
    v7 = 0;
    goto LABEL_16;
  }
  Value = CFDictionaryGetValue(v4, CFSTR("State"));
  v7 = (_BOOL8)Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID() && CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, (char *)&valuePtr + 4))
    {
      v7 = HIDWORD(valuePtr) == 1023;
      if (_MISGetHostCount
        && !_MISGetHostCount(*(_QWORD *)(a1 + 4944), &valuePtr, (_DWORD *)&v17 + 1, v9, v10, v11, v12, v13))
      {
        v14 = valuePtr - HIDWORD(v17);
        if (valuePtr < HIDWORD(v17))
          v14 = 0;
        LODWORD(v17) = v14;
        if (v14 != *(_DWORD *)(a1 + 5256))
        {
          v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v17);
          sub_100107FCC(a1, (uint64_t)v15);
          *(_DWORD *)(a1 + 5256) = v17;
          if (v15)
            CFRelease(v15);
        }
      }
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_16:
  CFRelease(v4);
  return v7;
}

uint64_t sub_10010780C(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 5218) + *(_BYTE *)(a1 + 5217));
}

uint64_t sub_100107828(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  _BOOL8 v4;
  const void *v7;
  void *v8;
  BOOL v9;
  void *v10;
  void *v11;
  uint64_t v12;
  const __CFString *v13;
  uint64_t v14;
  const __CFString *v15;
  const char *v16;

  v2 = (unsigned __int8 *)(a1 + 7056);
  v3 = *(unsigned __int8 *)(a1 + 7057);
  if ((v3 & a2) != 0)
    return 1;
  if (*v2)
  {
    v7 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v8 = sub_10002A21C(a1, v7, 1);
    if (v8)
    {
      v2[1] |= 1u;
      CFRelease(v8);
    }
    v4 = 0;
    switch(v2[1])
    {
      case 0u:
        goto LABEL_13;
      case 1u:
      case 8u:
        v9 = (((_DWORD)a2 - 2) & 0xFFFFFFFD) == 0;
        goto LABEL_19;
      case 2u:
        v9 = (_DWORD)a2 == 4 || (_DWORD)a2 == 1;
        goto LABEL_19;
      case 4u:
        v4 = (a2 - 1) < 2;
        goto LABEL_22;
      case 5u:
        v9 = (_DWORD)a2 == 2;
LABEL_19:
        v4 = v9;
        break;
      default:
        goto LABEL_22;
    }
    goto LABEL_22;
  }
  v4 = v3 == 0;
  if ((_DWORD)a2 != 1)
  {
    if ((_DWORD)a2 != 2 || v3 != 1)
      goto LABEL_22;
    goto LABEL_13;
  }
  if (v3 == 2)
LABEL_13:
    v4 = 1;
LABEL_22:
  v10 = objc_autoreleasePoolPush();
  v11 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v12 = *v2;
    v13 = sub_100064C9C(v2[1]);
    v14 = v2[1];
    v15 = sub_100064C9C(a2);
    v16 = "Not Allowed";
    if (v4)
      v16 = "OK";
    objc_msgSend(v11, "WFLog:message:", 3, "%s: isSupported: %d current state: %@(%d) request: %@(%d) status: %s", "WiFiDeviceManagerIsOpModeAllowed", v12, v13, v14, v15, a2, v16);
  }
  objc_autoreleasePoolPop(v10);
  return v4;
}

char *sub_1001079C8(uint64_t a1)
{
  char *result;
  uint64_t v3;
  const void *v4;
  void *v5;

  result = (char *)objc_msgSend(*(id *)(a1 + 6752), "isNANPublisherStarted");
  if (!(_DWORD)result)
  {
    sub_10013635C(a1);
    objc_msgSend(*(id *)(a1 + 6752), "registerStaArriveCallback:withContext:", sub_100136418, a1);
    objc_msgSend(*(id *)(a1 + 6752), "registerStaLeaveCallback:withContext:", sub_100136638, a1);
    objc_msgSend(*(id *)(a1 + 6752), "registerPublisherMetricCallback:withContext:", sub_1001369AC, a1);
    v3 = MGCopyAnswer(CFSTR("UserAssignedDeviceName"), 0);
    if (v3)
    {
      v4 = (const void *)v3;
      objc_msgSend(*(id *)(a1 + 6752), "setDeviceNameForPHSOverNAN:", v3);
      CFRelease(v4);
    }
    objc_msgSend(*(id *)(a1 + 6752), "setDataPathSecCfgForPHSOverNAN:", 1);
    objc_msgSend(*(id *)(a1 + 6752), "startPublisherForPHSOverNAN");
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Preparing NAN interface info");
    objc_autoreleasePoolPop(v5);
    return sub_1000F9DAC((char *)a1, 8, 1);
  }
  return result;
}

double sub_100107ABC(uint64_t a1)
{
  _BYTE *v2;
  void *v3;
  double result;
  void *v5;
  void *v6;
  void *v7;
  const __CFString *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  int v12;
  void *v13;
  void *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v2 = (_BYTE *)(a1 + 5216);
  if (*(_BYTE *)(a1 + 5219) != 1 || *(_BYTE *)(a1 + 5222) || *(_BYTE *)(a1 + 5223) || *(_BYTE *)(a1 + 5386))
  {
    if (*(_DWORD *)(a1 + 5344))
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS start in pending, current state: %d", *(unsigned int *)(a1 + 5344));
      objc_autoreleasePoolPop(v3);
      return result;
    }
    if (sub_1001076C4(a1))
    {
      if (v2[6] && *v2)
      {
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS in recovery. Using previously selected channel.");
        objc_autoreleasePoolPop(v5);
        *(_DWORD *)(a1 + 5344) = 1;
      }
      else if (v2[7])
      {
        if (v2[171] == 1)
          v2[170] = 1;
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS in Restarting. misIsNANPHS %d", v2[170]);
        objc_autoreleasePoolPop(v6);
      }
      else if (!v2[5])
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Skip enabling MIS. Not on Internet Tethering screen.");
        objc_autoreleasePoolPop(v14);
        v25 = 0;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        v12 = 5;
LABEL_38:
        DWORD1(v15) = v12;
        return sub_100106C34(a1, (uint64_t)&v15);
      }
      if (*(_DWORD *)(a1 + 5228)
        || (v8 = sub_100070E94(),
            v9 = IOPMAssertionCreateWithName(CFSTR("NoIdleSleepAssertion"), 0xFFu, v8, (IOPMAssertionID *)(a1 + 5228)),
            !(_DWORD)v9))
      {
        v25 = 0;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        *(_QWORD *)&v16 = sub_100064914();
        sub_100106C34(a1, (uint64_t)&v15);
        sub_100136AF0(a1);
        return result;
      }
      v10 = v9;
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unable to prevent idle sleep during MIS start, error=%d", "__WiFiDeviceManagerStartMIS", v10);
      objc_autoreleasePoolPop(v11);
      *(_DWORD *)(a1 + 5228) = 0;
      v25 = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v12 = 19;
      goto LABEL_38;
    }
    v25 = 0;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    DWORD1(v15) = 4;
    sub_100106C34(a1, (uint64_t)&v15);
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User disabled MIS");
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS is already enabled");
    objc_autoreleasePoolPop(v13);
  }
  return result;
}

void sub_100107DE4(uint64_t a1, int a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  const __CFSet *v7;
  CFIndex Count;
  const __CFSet *v9;
  CFIndex v10;
  const __CFSet *v11;
  CFIndex v12;
  const __CFSet *v13;
  CFIndex v14;
  const __CFSet *v15;
  CFIndex v16;
  const __CFSet *v17;
  void *v18;
  NSObject *v19;
  dispatch_time_t v20;

  if (a1)
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 5272)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5288)) > 0
      || *(unsigned __int8 *)(a1 + 5260) | a2)
    {
      sub_1001080EC(a1);
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = *(unsigned __int8 *)(a1 + 5260);
        v7 = *(const __CFSet **)(a1 + 5272);
        if (v7)
          Count = CFSetGetCount(v7);
        else
          Count = 0;
        v9 = *(const __CFSet **)(a1 + 5280);
        if (v9)
          v10 = CFSetGetCount(v9);
        else
          v10 = 0;
        v11 = *(const __CFSet **)(a1 + 5288);
        if (v11)
          v12 = CFSetGetCount(v11);
        else
          v12 = 0;
        v13 = *(const __CFSet **)(a1 + 5296);
        if (v13)
          v14 = CFSetGetCount(v13);
        else
          v14 = 0;
        v15 = *(const __CFSet **)(a1 + 5304);
        if (v15)
          v16 = CFSetGetCount(v15);
        else
          v16 = 0;
        v17 = *(const __CFSet **)(a1 + 5312);
        if (v17)
          v17 = (const __CFSet *)CFSetGetCount(v17);
        objc_msgSend(v5, "WFLog:message:", 3, "%s: current misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broadcast STAs %ld, num hidden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld", "WiFiDeviceManagerSetMISHiddenOrBroadcastState", v6, Count, v10, v12, v14, v16, v17);
      }
      objc_autoreleasePoolPop(v4);
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Start Broadcast to Hidden state change timer\n");
      objc_autoreleasePoolPop(v18);
      v19 = *(NSObject **)(a1 + 5320);
      v20 = dispatch_time(0, 90000000000);
      dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
  }
}

void sub_100107FCC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v4 = *(_QWORD *)(a1 + 64);
  v5 = (const void *)sub_1000698C4(v4);
  v6 = sub_1000672C0(v4, v5, 508, 0, a2);
  if ((_DWORD)v6)
  {
    v7 = v6;
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to set MIS max STA (err = %d) deviceManager=%p\n", v7, a1);
    objc_autoreleasePoolPop(v8);
  }
}

void sub_10010806C(uint64_t a1, int a2, int a3, int a4, void *value)
{
  uint64_t v6;
  uint64_t v8;

  if (a1 && value)
  {
    if (a2)
    {
      v6 = 5280;
      if (!a3)
        v6 = 5272;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + v6), value);
LABEL_10:
      sub_100107DE4(a1, 0);
      return;
    }
    v8 = 5280;
    if (!a3)
      v8 = 5272;
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + v8), value);
    if (a4)
      goto LABEL_10;
  }
}

void sub_1001080EC(uint64_t a1)
{
  _BYTE *v2;
  _BOOL8 v3;
  void *v4;
  void *v5;
  const __CFSet *v6;
  CFIndex Count;
  const __CFSet *v8;
  CFIndex v9;
  const __CFSet *v10;
  CFIndex v11;
  const __CFSet *v12;
  CFIndex v13;
  const __CFSet *v14;
  CFIndex v15;
  const __CFSet *v16;
  uint64_t v17;

  if (a1)
  {
    v2 = (_BYTE *)(a1 + 5219);
    if (*(_BYTE *)(a1 + 5219))
    {
      v3 = CFSetGetCount(*(CFSetRef *)(a1 + 5272)) <= 0 && CFSetGetCount(*(CFSetRef *)(a1 + 5288)) < 1;
      v4 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v17 = v2[41];
        v6 = *(const __CFSet **)(a1 + 5272);
        if (v6)
          Count = CFSetGetCount(v6);
        else
          Count = 0;
        v8 = *(const __CFSet **)(a1 + 5280);
        if (v8)
          v9 = CFSetGetCount(v8);
        else
          v9 = 0;
        v10 = *(const __CFSet **)(a1 + 5288);
        if (v10)
          v11 = CFSetGetCount(v10);
        else
          v11 = 0;
        v12 = *(const __CFSet **)(a1 + 5296);
        if (v12)
          v13 = CFSetGetCount(v12);
        else
          v13 = 0;
        v14 = *(const __CFSet **)(a1 + 5304);
        if (v14)
          v15 = CFSetGetCount(v14);
        else
          v15 = 0;
        v16 = *(const __CFSet **)(a1 + 5312);
        if (v16)
          v16 = (const __CFSet *)CFSetGetCount(v16);
        objc_msgSend(v5, "WFLog:message:", 3, "%s: new misIsHidden: %d, current misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broadcast STAs %ld, num hidden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld", "__WiFiDeviceManagerSetBroadcastHiddenMode", v3, v17, Count, v9, v11, v13, v15, v16);
      }
      objc_autoreleasePoolPop(v4);
      if (v2[41] != v3)
      {
        v2[41] = v3;
        if (*v2)
        {
          sub_10006A2DC(*(_QWORD *)(a1 + 64), v3);
          sub_10011B44C(a1);
        }
      }
    }
  }
}

void sub_100108298(_QWORD *a1)
{
  unsigned __int8 *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  const __CFSet *v6;
  CFIndex Count;
  const __CFSet *v8;
  CFIndex v9;
  const __CFSet *v10;
  CFIndex v11;
  const __CFSet *v12;
  CFIndex v13;
  const __CFSet *v14;
  CFIndex v15;
  const __CFSet *v16;
  __CFSet *v17;
  __CFSet *v18;
  __CFSet *v19;
  __CFSet *v20;
  __CFSet *v21;
  __CFSet *v22;
  uint64_t v23;

  if (a1)
  {
    v2 = (unsigned __int8 *)a1 + 5221;
    v3 = objc_autoreleasePoolPush();
    v4 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v23 = *v2;
      v5 = v2[39];
      v6 = (const __CFSet *)a1[659];
      if (v6)
        Count = CFSetGetCount(v6);
      else
        Count = 0;
      v8 = (const __CFSet *)a1[660];
      if (v8)
        v9 = CFSetGetCount(v8);
      else
        v9 = 0;
      v10 = (const __CFSet *)a1[661];
      if (v10)
        v11 = CFSetGetCount(v10);
      else
        v11 = 0;
      v12 = (const __CFSet *)a1[662];
      if (v12)
        v13 = CFSetGetCount(v12);
      else
        v13 = 0;
      v14 = (const __CFSet *)a1[663];
      if (v14)
        v15 = CFSetGetCount(v14);
      else
        v15 = 0;
      v16 = (const __CFSet *)a1[664];
      if (v16)
        v16 = (const __CFSet *)CFSetGetCount(v16);
      objc_msgSend(v4, "WFLog:message:", 3, "%s (discovery:%d): Clearing misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broadcast STAs %ld, num hidden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld", "WiFiDeviceManagerClearMISHiddenOrBroadcastState", v23, v5, Count, v9, v11, v13, v15, v16);
    }
    objc_autoreleasePoolPop(v3);
    v2[39] = 0;
    if (!*v2)
    {
      v17 = (__CFSet *)a1[659];
      if (v17)
        CFSetRemoveAllValues(v17);
      v18 = (__CFSet *)a1[660];
      if (v18)
        CFSetRemoveAllValues(v18);
    }
    v19 = (__CFSet *)a1[661];
    if (v19)
      CFSetRemoveAllValues(v19);
    v20 = (__CFSet *)a1[662];
    if (v20)
      CFSetRemoveAllValues(v20);
    v21 = (__CFSet *)a1[663];
    if (v21)
      CFSetRemoveAllValues(v21);
    if (!v2[167])
    {
      v22 = (__CFSet *)a1[664];
      if (v22)
        CFSetRemoveAllValues(v22);
    }
  }
}

uint64_t sub_100108444(uint64_t a1, int a2)
{
  uint64_t v4;
  const void *v5;
  uint64_t *v6;

  v4 = *(_QWORD *)(a1 + 64);
  v5 = (const void *)sub_100025C3C(v4);
  v6 = (uint64_t *)&kCFBooleanFalse;
  if (!a2)
    v6 = (uint64_t *)&kCFBooleanTrue;
  sub_1000672C0(v4, v5, 511, 0, *v6);
  return sub_1000427D0(*(_QWORD *)(a1 + 120), a2);
}

uint64_t sub_1001084B0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5221);
}

uint64_t sub_1001084BC(uint64_t a1)
{
  return sub_10006C530(*(_QWORD *)(a1 + 64));
}

uint64_t sub_1001084C4(uint64_t a1)
{
  uint64_t result;

  result = sub_10006C530(*(_QWORD *)(a1 + 64));
  if ((_DWORD)result)
    return sub_100071758(*(_QWORD *)(a1 + 64)) != 0;
  return result;
}

uint64_t sub_1001084FC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5457);
}

void sub_100108508(uint64_t a1, int a2, int a3, int a4)
{
  unsigned __int8 *v8;
  void *v9;
  void *v10;
  int v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;

  v8 = (unsigned __int8 *)(a1 + 7080);
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v11 = sub_10006C530(*(_QWORD *)(a1 + 64));
    v12 = "YES";
    if (!v11)
      v12 = "NO";
    v13 = "enable";
    if (a2)
      v14 = "enable";
    else
      v14 = "disable";
    if (!a3)
      v13 = "disable";
    v15 = "enabled";
    if (!a4)
      v15 = "disabled";
    objc_msgSend(v10, "WFLog:message:", 3, "WoW Capable = %s, Attempting to %s WoW and %s LPAS with WoW on Captive %s", v12, v14, v13, v15);
  }
  objc_autoreleasePoolPop(v9);
  if (!*(_BYTE *)(a1 + 3411))
  {
    if (a2)
    {
      if (*v8 != a2)
      {
        sub_100006F34(a1, 3);
        if (*(_DWORD *)(a1 + 20) == 1)
        {
          *(_DWORD *)(a1 + 192) = 17;
          sub_1000FBA80(a1, 0, (uint64_t)"WiFiDeviceManagerSetWoWState");
        }
      }
    }
  }
  *v8 = a2;
  v8[1] = a3;
  v8[2] = a4;
  sub_100108684(a1, a2, a3, a4, 0);
  if (!a4)
    sub_10010159C(a1);
}

id sub_100108684(uint64_t a1, int a2, int a3, int a4, int a5)
{
  id result;
  CFBooleanRef v11;
  CFBooleanRef v12;
  CFBooleanRef v13;
  CFBooleanRef v14;
  const void *v15;
  uint64_t v16;
  const void *v17;
  CFBooleanRef v18;
  CFBooleanRef v19;
  CFBooleanRef v20;
  CFBooleanRef v21;
  void *keys[2];
  __int128 v23;

  result = (id)sub_10006C530(*(_QWORD *)(a1 + 64));
  if ((_DWORD)result)
  {
    *(_OWORD *)keys = *(_OWORD *)off_1002318E0;
    v23 = *(_OWORD *)off_1002318F0;
    v11 = kCFBooleanTrue;
    if (a2)
      v12 = kCFBooleanTrue;
    else
      v12 = kCFBooleanFalse;
    if (a3)
      v13 = kCFBooleanTrue;
    else
      v13 = kCFBooleanFalse;
    v18 = v12;
    v19 = v13;
    if (a4)
      v14 = kCFBooleanTrue;
    else
      v14 = kCFBooleanFalse;
    if (!a5)
      v11 = kCFBooleanFalse;
    v20 = v14;
    v21 = v11;
    result = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)&v18, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (result)
    {
      v15 = result;
      sub_100079484(*(_QWORD *)(a1 + 64), a2, a3);
      v16 = *(_QWORD *)(a1 + 64);
      v17 = (const void *)sub_100025C3C(v16);
      sub_1000672C0(v16, v17, 496, 0, (uint64_t)v15);
      CFRelease(v15);
      sub_10010621C(a1);
      return objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager", v18, v19), "sendWoWDidChangeEventWithInterfaceName:", sub_100029860(*(_QWORD *)(a1 + 64)));
    }
  }
  return result;
}

uint64_t sub_1001087EC(uint64_t result)
{
  if (result)
    return sub_100069F0C(*(_QWORD *)(result + 64));
  return result;
}

BOOL sub_1001087FC(uint64_t a1, uint64_t a2)
{
  return sub_100074344(*(_QWORD *)(a1 + 64), a2) == 0;
}

BOOL sub_10010881C(uint64_t a1, uint64_t a2)
{
  return sub_100074418(*(_QWORD *)(a1 + 64), a2) == 0;
}

uint64_t sub_10010883C(uint64_t a1, const void *a2, char a3)
{
  const void *v7;
  CFTypeRef v8;

  if (sub_1000744EC(*(_QWORD *)(a1 + 64), (uint64_t)a2))
    return 0;
  v7 = *(const void **)(a1 + 7352);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 7352) = 0;
  }
  if (a2)
    v8 = CFRetain(a2);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 7352) = v8;
  *(_BYTE *)(a1 + 7360) = a3;
  return 1;
}

BOOL sub_1001088B4(uint64_t a1, const __CFString *a2)
{
  _WORD *v4;
  void *v5;
  const __CFString *v6;
  void *v7;
  const char *v8;
  _BOOL8 v9;
  void *v10;
  void *v11;
  _BOOL8 v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v18;
  _BOOL8 v19;
  void *v20;
  _OWORD v21[7];
  uint64_t v22;
  CFStringRef v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v4 = sub_100108C88(a1);
  if (!v4)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error creating network struct", "WiFiDeviceManagerSetMisPassword");
    objc_autoreleasePoolPop(v14);
    return 0;
  }
  v5 = v4;
  if (!a2 || !CFStringGetLength(a2))
  {
    CFRelease(v5);
    return 0;
  }
  v6 = sub_1000C37A0((CFDictionaryRef *)v5);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v8 = "already";
    if (!v6)
      v8 = "not";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS password is %s present", "WiFiDeviceManagerSetMisPassword", v8);
  }
  objc_autoreleasePoolPop(v7);
  if (v6 && CFStringGetLength(v6))
  {
    if (CFStringCompare(a2, v6, 0))
    {
      v9 = sub_1000C64F0(v5, a2);
      if (!v9)
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed setting MIS password with one already present. Try removing and attempt again...", "WiFiDeviceManagerSetMisPassword");
        objc_autoreleasePoolPop(v18);
        sub_1000C65D8(v5);
        sub_1000C669C(v5);
        v19 = sub_1000C64F0(v5, a2);
        if (!v19)
        {
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error saving password in keychain");
          objc_autoreleasePoolPop(v20);
          CFRelease(v5);
          v9 = 0;
          goto LABEL_37;
        }
        v9 = v19;
      }
      if (sub_1001076C4(a1) && *(_BYTE *)(a1 + 5219))
      {
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Stopping MIS", "WiFiDeviceManagerSetMisPassword");
        objc_autoreleasePoolPop(v10);
        v26 = 0;
        v24 = 0u;
        v25 = 0u;
        v22 = 4;
        memset(v21, 0, sizeof(v21));
        DWORD2(v21[0]) = 4;
        v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Password Change"));
        sub_100106C34(a1, (uint64_t)v21);
        sub_100107084(a1);
      }
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: new and current passwords are equal", "WiFiDeviceManagerSetMisPassword");
      objc_autoreleasePoolPop(v15);
      v9 = 1;
    }
    goto LABEL_31;
  }
  v9 = sub_1000C64F0(v5, a2);
  if (v9)
  {
LABEL_31:
    if (sub_1001076C4(a1) && !*(_BYTE *)(a1 + 5219))
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting MIS", "WiFiDeviceManagerSetMisPassword");
      objc_autoreleasePoolPop(v16);
      sub_100107ABC(a1);
    }
    goto LABEL_36;
  }
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed setting new MIS password. Try removing any existing item and attempt again...", "WiFiDeviceManagerSetMisPassword");
  objc_autoreleasePoolPop(v11);
  sub_1000C65D8(v5);
  sub_1000C669C(v5);
  v12 = sub_1000C64F0(v5, a2);
  if (v12)
  {
    v9 = v12;
    goto LABEL_31;
  }
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error saving new password in keychain");
  objc_autoreleasePoolPop(v13);
  v9 = 0;
LABEL_36:
  CFRelease(v5);
  if (v6)
LABEL_37:
    CFRelease(v6);
  return v9;
}

_WORD *sub_100108C88(uint64_t a1)
{
  void *v2;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  _WORD *v13;
  int v15;
  __int16 valuePtr;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Preparing MIS Network Configuration Parameters");
  objc_autoreleasePoolPop(v2);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v4 = Mutable;
  v15 = -1431655766;
  valuePtr = 1;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (!v5)
    goto LABEL_11;
  v6 = v5;
  CFDictionaryAddValue(v4, CFSTR("AP_MODE_AUTH_LOWER"), v5);
  CFRelease(v6);
  valuePtr = 8;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (!v7)
    goto LABEL_11;
  v8 = v7;
  CFDictionaryAddValue(v4, CFSTR("AP_MODE_AUTH_UPPER"), v7);
  CFRelease(v8);
  v15 = 10;
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
  if (!v9)
    goto LABEL_11;
  v10 = v9;
  CFDictionaryAddValue(v4, CFSTR("AP_MODE_CYPHER_TYPE"), v9);
  CFRelease(v10);
  v15 = *(unsigned __int8 *)(a1 + 5216);
  v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
  if (!v11
    || (v12 = v11,
        CFDictionaryAddValue(v4, CFSTR("CHANNEL"), v11),
        CFRelease(v12),
        CFDictionaryAddValue(v4, CFSTR("SSID_STR"), CFSTR("_AppleWi-FiInternetTetheringSSID_")),
        (v13 = sub_10002B314((uint64_t)kCFAllocatorDefault, v4)) == 0))
  {
LABEL_11:
    v13 = 0;
  }
  CFRelease(v4);
  return v13;
}

void sub_100108E5C(uint64_t a1, CFStringRef *a2)
{
  CFDictionaryRef *v3;
  CFDictionaryRef *v4;
  void *v5;

  v3 = (CFDictionaryRef *)sub_100108C88(a1);
  if (v3)
  {
    v4 = v3;
    *a2 = 0;
    *a2 = sub_1000C37A0(v3);
    CFRelease(v4);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error creating network struct", "WiFiDeviceManagerCopyMisPassword");
    objc_autoreleasePoolPop(v5);
  }
}

uint64_t sub_100108EE4(uint64_t a1)
{
  sub_100025C3C(*(_QWORD *)(a1 + 64));
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_100108F0C(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  void *v7;
  void *v8;
  const void *v9;
  uint64_t result;
  _OWORD v11[7];
  uint64_t v12;
  CFStringRef v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (*(_DWORD *)(a1 + 20) == (_DWORD)a3)
    return 0;
  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 3;
  memset(v11, 0, sizeof(v11));
  DWORD2(v11[0]) = 3;
  v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Power Off"));
  sub_100106C34(a1, (uint64_t)v11);
  sub_100107084(a1);
  if (!(_DWORD)a3)
  {
    v6 = *(void **)(a1 + 8976);
    if (v6)
      objc_msgSend(v6, "resetSettlement");
    if (*(_DWORD *)(a1 + 5424))
    {
      v7 = *(void **)(a1 + 5432);
      if (v7)

      *(_QWORD *)(a1 + 5432) = 0;
      sub_1000FB00C(a1, a2);
    }
    v8 = sub_10002A21C(a1, a2, 1);
    if (v8)
    {
      v9 = v8;
      if (sub_10002DAB4((uint64_t)v8))
        sub_100072E44(*(_QWORD *)(a1 + 64), v9, 0);
      CFRelease(v9);
    }
  }
  result = sub_100070FA8(*(_QWORD *)(a1 + 64), a2, a3);
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a1 + 20) = a3;
    sub_10010906C(a1, (uint64_t)a2);
    sub_1001091D8(a1, 1u, a3);
    if (*(_DWORD *)(a1 + 20) == 1)
      sub_1000780BC(*(_QWORD *)(a1 + 64));
    return 0;
  }
  return result;
}

id sub_10010906C(uint64_t a1, uint64_t a2)
{
  void (*v3)(uint64_t, uint64_t, _QWORD);
  void *v4;
  uint64_t v5;
  const void *v6;
  id result;

  v3 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 3992);
  if (v3)
    v3(a1, a2, *(_QWORD *)(a1 + 4000));
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device powering %s", sub_1000648F0(*(_DWORD *)(a1 + 20)));
  objc_autoreleasePoolPop(v4);
  sub_1000FB44C(a1);
  sub_100006F34(a1, 1);
  if (*(_DWORD *)(a1 + 20) == 1)
  {
    sub_100115A20(a1);
    *(_DWORD *)(a1 + 192) = 3;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000285E4(a1, 8uLL);
    }
    else
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 8, sub_100025C3C(*(_QWORD *)(a1 + 64)));
      sub_1000FBA80(a1, 2, (uint64_t)"__WiFiDeviceManagerUpdatePower");
    }
    sub_1000FF824(a1);
    v5 = *(_QWORD *)(a1 + 64);
    v6 = (const void *)sub_100025C3C(v5);
    sub_10007156C(v5, v6, *(_DWORD *)(a1 + 5396), *(_DWORD *)(a1 + 5392));
  }
  result = (id)_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if ((_DWORD)result)
    return sub_100013754(a1);
  return result;
}

void sub_1001091D8(uint64_t a1, unsigned int a2, uint64_t a3)
{
  _BYTE *v6;
  double Current;
  double v8;
  _BOOL4 v9;
  void *v10;
  const __CFArray *v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  const void *v15;
  const __CFArray *v16;
  const void *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  const __CFDictionary *v20;
  unsigned int Count;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  unsigned int v24;
  unsigned int v25;
  const void **v26;
  int v27;
  const void **v28;
  const void **v29;
  const void **v30;
  unint64_t v31;
  uint64_t v32;
  const __CFString *Value;
  const __CFString *v34;
  BOOL v35;
  const __CFDictionary *v36;
  void *v37;
  const void *v38;
  void *v39;
  void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  char v44;
  _BYTE *v45;
  void *v46;
  void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  CFAbsoluteTime v51;
  void *v52;
  uint64_t v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  char v59;
  void *v60;
  void *v61;
  _BYTE *v62;
  __int128 v63;
  __int128 v64;

  v6 = (_BYTE *)(a1 + 7128);
  Current = CFAbsoluteTimeGetCurrent();
  v8 = *(double *)(a1 + 7096);
  v9 = v8 != 0.0;
  if (v8 + 120.0 <= Current)
    v9 = 0;
  v62 = v6;
  if (!a2 && v9)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: DPS event detected while already in monitoring period. Ignoring...", "__WiFiDeviceManagerEvaluateDpsStateChange");
LABEL_7:
    objc_autoreleasePoolPop(v10);
    v11 = 0;
LABEL_8:
    v12 = 1;
    goto LABEL_9;
  }
  if (!a2)
    LOBYTE(v9) = 1;
  if (v9)
  {
    v14 = *(_QWORD *)(a1 + 64);
    v15 = (const void *)sub_100025C3C(v14);
    v16 = (const __CFArray *)sub_10002BF8C(v14, v15);
    v11 = v16;
    if (v16)
    {
      v17 = sub_10002B088(v16);
      v18 = sub_10001F1E8(v11);
      v19 = sub_1000C41D4(v11);
    }
    else
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
    }
    switch(a2)
    {
      case 0u:
        v46 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: initiating DPS probing and monitoring period", "__WiFiDeviceManagerEvaluateDpsStateChange");
        objc_autoreleasePoolPop(v46);
        v47 = *(void **)(a1 + 7368);
        if (v47)
          objc_msgSend(v47, "addFaultEvent:forInterface:", 6, sub_100029860(*(_QWORD *)(a1 + 64)));
        goto LABEL_79;
      case 1u:
        if (!*v6)
          *v6 = 1;
        if (v6[1])
          goto LABEL_8;
        v55 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: power state changed while monitoring DPS.. State:%d", "__WiFiDeviceManagerEvaluateDpsStateChange", a3);
        objc_autoreleasePoolPop(v55);
        v12 = 1;
        v6[1] = 1;
        if (v6[2])
          goto LABEL_9;
        goto LABEL_116;
      case 2u:
        v56 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ControlCenterToggled: state:%d", a3);
        objc_autoreleasePoolPop(v56);
        if (*v6)
          goto LABEL_8;
        v57 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: link state changed while monitoring DPS", "__WiFiDeviceManagerEvaluateDpsStateChange");
        objc_autoreleasePoolPop(v57);
        v12 = 1;
        *v6 = 1;
        if (v6[1])
          goto LABEL_9;
        v6[2] = 1;
LABEL_116:
        sub_10005D65C(*(_QWORD *)(a1 + 64), 0, 2u, 0);
        goto LABEL_9;
      case 3u:
        if (v6[1])
        {
          if (!v11)
            goto LABEL_8;
        }
        else
        {
          v12 = 1;
          if (!v11 || !*v6)
          {
LABEL_9:
            v13 = 1;
            goto LABEL_16;
          }
        }
        sub_10005D65C(*(_QWORD *)(a1 + 64), 0, 3u, 0);
        goto LABEL_8;
      case 4u:
      case 5u:
        v40 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Event IP/roam state changed: info:%d", a3);
        objc_autoreleasePoolPop(v40);
        if (v11)
        {
          v41 = *(const void **)(a1 + 7104);
          v6 = v62;
          if (v41 && v17 && !CFEqual(v41, v17))
            v62[3] = 1;
          v42 = *(const void **)(a1 + 7112);
          if (v42 && v18 && !CFEqual(v42, v18))
            v62[4] = 1;
          v43 = *(const void **)(a1 + 7120);
          if (v43 && v19 && !CFEqual(v43, v19))
            v62[5] = 1;
          LOBYTE(v63) = v62[3];
          *(_WORD *)((char *)&v63 + 1) = *((_WORD *)v62 + 2);
          BYTE3(v63) = *v62;
          v44 = v62[1];
          DWORD1(v63) = -1431655766;
          *((_QWORD *)&v63 + 1) = __PAIR64__(a3, a2);
          BYTE4(v63) = v44;
          sub_100061040(&v63);
          v45 = v62;
          goto LABEL_81;
        }
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no connected network while in DPS monitoring period.", "__WiFiDeviceManagerEvaluateDpsStateChange");
        goto LABEL_7;
      case 6u:
        if (*v6)
          goto LABEL_8;
        v58 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: link went down while monitoring DPS.. reason:%d", "__WiFiDeviceManagerEvaluateDpsStateChange", a3);
        objc_autoreleasePoolPop(v58);
        v12 = 1;
        *v6 = 1;
        LOBYTE(v64) = v6[3];
        *(_WORD *)((char *)&v64 + 1) = *((_WORD *)v6 + 2);
        BYTE3(v64) = 1;
        v59 = v6[1];
        *(_QWORD *)((char *)&v64 + 4) = 0x6AAAAAAAALL;
        BYTE4(v64) = v59;
        HIDWORD(v64) = a3;
        sub_100061040(&v64);
        v13 = 0;
        goto LABEL_16;
      default:
LABEL_79:
        if (!v11)
        {
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: DPS received while not connected. Not proceeding.", "__WiFiDeviceManagerEvaluateDpsStateChange");
          goto LABEL_7;
        }
        *(double *)(a1 + 7096) = Current;
        v45 = (_BYTE *)(a1 + 7128);
        v6[110] = 0;
LABEL_81:
        *((_WORD *)v45 + 2) = 0;
        *(_DWORD *)v45 = 0;
        v48 = *(const void **)(a1 + 7104);
        if (v48)
        {
          CFRelease(v48);
          *(_QWORD *)(a1 + 7104) = 0;
        }
        v49 = *(const void **)(a1 + 7112);
        if (v49)
        {
          CFRelease(v49);
          *(_QWORD *)(a1 + 7112) = 0;
        }
        v50 = *(const void **)(a1 + 7120);
        if (v50)
        {
          CFRelease(v50);
          *(_QWORD *)(a1 + 7120) = 0;
        }
        if (v17)
          *(_QWORD *)(a1 + 7104) = CFRetain(v17);
        if (v18)
          *(_QWORD *)(a1 + 7112) = CFRetain(v18);
        if (v19)
          *(_QWORD *)(a1 + 7120) = CFRetain(v19);
        v12 = 1;
        if (v6[108])
          goto LABEL_9;
        v51 = CFAbsoluteTimeGetCurrent();
        v6[108] = 1;
        *(CFAbsoluteTime *)(a1 + 7088) = v51;
        v52 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DPS Probe: Starting probe on all ACs");
        objc_autoreleasePoolPop(v52);
        v53 = 0;
        do
        {
          sub_10013EF2C(v53, a1);
          v53 = (v53 + 1);
        }
        while ((_DWORD)v53 != 4);
        if (!a1)
        {
          v54 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "__WiFiDeviceManagerCheckAndSubmitAPInfo");
          objc_autoreleasePoolPop(v54);
          goto LABEL_54;
        }
        goto LABEL_8;
    }
  }
  v12 = 0;
  v11 = 0;
  v13 = a2 != 6;
LABEL_16:
  v20 = *(const __CFDictionary **)(a1 + 7240);
  if (v20)
    Count = CFDictionaryGetCount(v20);
  else
    Count = 0;
  v22 = (const __CFDictionary *)sub_100078920(*(_QWORD *)(a1 + 64));
  if (!v22)
  {
    v27 = 0;
    v26 = 0;
    v28 = 0;
    goto LABEL_35;
  }
  v23 = v22;
  v24 = CFDictionaryGetCount(v22);
  v25 = v24;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if (!v24 || Count > v24)
  {
LABEL_35:
    if (!v12)
      goto LABEL_46;
    goto LABEL_36;
  }
  if (!Count)
  {
    v26 = 0;
    v28 = 0;
LABEL_45:
    *(_QWORD *)(a1 + 7240) = CFDictionaryCreateCopy(kCFAllocatorDefault, v23);
    v27 = 1;
    if (!v12)
      goto LABEL_46;
LABEL_36:
    v36 = *(const __CFDictionary **)(a1 + 7240);
    if (v36 && CFDictionaryGetCount(v36) && ((v62[110] != 0) & ~v27) == 0)
    {
      v62[110] = 1;
      v37 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Sending AccessPointInfo update to WA: %@", *(_QWORD *)(a1 + 7240));
      objc_autoreleasePoolPop(v37);
      sub_100061270(*(const __CFDictionary **)(a1 + 7240));
    }
    goto LABEL_46;
  }
  v29 = (const void **)malloc_type_malloc(8 * v24, 0x6004044C4A2DFuLL);
  if (!v29)
  {
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: keys alloc failure", "__WiFiDeviceManagerCheckAndSubmitAPInfo");
    objc_autoreleasePoolPop(v60);
    if (!v13)
      goto LABEL_51;
    goto LABEL_54;
  }
  v26 = v29;
  bzero(v29, 8 * v25);
  v30 = (const void **)malloc_type_malloc(8 * v25, 0x6004044C4A2DFuLL);
  if (v30)
  {
    v28 = v30;
    bzero(v30, 8 * v25);
    CFDictionaryGetKeysAndValues(v23, v26, v28);
    v31 = 0;
    v32 = 8 * v25;
    do
    {
      Value = (const __CFString *)CFDictionaryGetValue(v23, v26[v31 / 8]);
      v34 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 7240), v26[v31 / 8]);
      if (Value)
        v35 = v34 == 0;
      else
        v35 = 1;
      if (v35 || CFStringCompare(Value, v34, 0))
      {
        v38 = *(const void **)(a1 + 7240);
        if (v38)
        {
          CFRelease(v38);
          *(_QWORD *)(a1 + 7240) = 0;
        }
        goto LABEL_45;
      }
      v31 += 8;
    }
    while (v32 != v31);
    v27 = 0;
    if (v12)
      goto LABEL_36;
LABEL_46:
    if (!v26)
      goto LABEL_48;
    goto LABEL_47;
  }
  v61 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: values alloc failure", "__WiFiDeviceManagerCheckAndSubmitAPInfo");
  objc_autoreleasePoolPop(v61);
  v28 = 0;
LABEL_47:
  free(v26);
LABEL_48:
  if (v28)
    free(v28);
  if (!v13)
  {
LABEL_51:
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DPS/DNS Symptoms: DPS Probe: cancelling DPS probe & clearing HUD because of link down");
    objc_autoreleasePoolPop(v39);
    sub_10013A94C(a1);
    sub_10013EE54(a1);
  }
LABEL_54:
  if (v11)
    CFRelease(v11);
}

uint64_t sub_100109A80(uint64_t a1, uint64_t a2)
{
  const void *v4;

  v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  return sub_100108F0C(a1, v4, a2);
}

id sub_100109AB4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 6752), "isClientAssociated");
}

__CFDictionary *sub_100109ACC(uint64_t a1, const void *a2)
{
  void *v3;
  uint64_t v4;
  __CFDictionary *Mutable;
  const void *v6;

  v3 = sub_10002A21C(a1, a2, 1);
  if (!v3)
    return 0;
  v4 = (uint64_t)v3;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v6 = sub_10002B750(v4);
    CFDictionarySetValue(Mutable, CFSTR("RoamKnownBSS"), v6);
    CFDictionarySetValue(Mutable, CFSTR("RoamEvents"), *(const void **)(a1 + 272));
  }
  return Mutable;
}

uint64_t sub_100109B74(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;

  v5 = sub_100071564();
  if (!(_DWORD)v5)
  {
    *(_BYTE *)(a1 + 249) = a3;
    if (a3)
    {
      sub_1000FB44C(a1);
    }
    else
    {
      *(_DWORD *)(a1 + 192) = 6;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 0xCuLL);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 12, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerSetWiFiDirectMode");
      }
    }
  }
  return v5;
}

CFArrayRef sub_100109C30(uint64_t a1)
{
  CFArrayRef result;
  CFIndex v3;
  size_t v4;
  char *v5;
  uint64_t v6;

  result = (CFArrayRef)CFSetGetCount(*(CFSetRef *)(a1 + 3320));
  if (result)
  {
    v3 = (CFIndex)result;
    __chkstk_darwin();
    v5 = (char *)&v6 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    memset(v5, 170, v4);
    CFSetGetValues(*(CFSetRef *)(a1 + 3320), (const void **)v5);
    return CFArrayCreate(kCFAllocatorDefault, (const void **)v5, v3, &kCFTypeArrayCallBacks);
  }
  return result;
}

__CFDictionary *sub_100109D00(uint64_t a1, const __CFString *a2)
{
  const __CFString *v4;
  __CFDictionary *Mutable;
  __CFDictionary *v6;
  _BYTE *v7;
  CFBooleanRef v8;
  CFBooleanRef v9;
  void *v10;
  const void *Value;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v13;
  void *v14;
  CFBooleanRef v15;
  int v16;
  const void **v17;
  int v18;
  CFNumberRef v19;
  void *v21;
  void *v22;
  int valuePtr;

  valuePtr = 0;
  v4 = (const __CFString *)sub_100068E60(*(_QWORD *)(a1 + 64));
  if (!v4)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No awdl Interface.", "WiFiDeviceManagerCopyInterfaceStateInfo");
    goto LABEL_36;
  }
  if (!a2)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null interface.", "WiFiDeviceManagerCopyInterfaceStateInfo");
LABEL_36:
    objc_autoreleasePoolPop(v21);
    return 0;
  }
  if (CFStringCompare(v4, a2, 0) == kCFCompareEqualTo)
  {
    v6 = sub_100068D8C(*(_QWORD *)(a1 + 64), a2);
    if (!v6)
      return v6;
    v10 = objc_autoreleasePoolPush();
    Value = CFDictionaryGetValue(v6, CFSTR("LINK_CHANGED_IS_AVAILABLE"));
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v6);
    if (!MutableCopy)
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null copiedInfoRef.", "WiFiDeviceManagerCopyInterfaceStateInfo");
      objc_autoreleasePoolPop(v22);
      goto LABEL_30;
    }
    v13 = MutableCopy;
    if (Value)
    {
      v14 = *(void **)(a1 + 5408);
      if (v14)
      {
        if (!objc_msgSend(v14, "isPowerResourceAvailable:", 1)
          || (v15 = kCFBooleanTrue, !CFEqual(Value, kCFBooleanTrue)))
        {
          v15 = kCFBooleanFalse;
        }
        CFDictionarySetValue(v13, CFSTR("LINK_CHANGED_IS_AVAILABLE"), v15);
      }
    }
    v16 = sub_10010A010(a1);
    v17 = (const void **)&kCFBooleanFalse;
    if (!v16)
      v17 = (const void **)&kCFBooleanTrue;
    CFDictionarySetValue(v13, CFSTR("RANGING_ALLOWED"), *v17);
    if (sub_10010A010(a1))
    {
      v18 = 1;
    }
    else
    {
      if (!sub_10010A034(a1))
      {
LABEL_27:
        v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(v13, CFSTR("RANGING_ACTIVE_SESSION"), v19);
        if (v19)
          CFRelease(v19);
        CFRelease(v6);
        v6 = v13;
LABEL_30:
        objc_autoreleasePoolPop(v10);
        return v6;
      }
      v18 = 2;
    }
    valuePtr = v18;
    goto LABEL_27;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = Mutable;
  if (Mutable)
  {
    v7 = (_BYTE *)(a1 + 5260);
    CFDictionarySetValue(Mutable, CFSTR("WiFiHostApStateIdentifier"), kCFBooleanTrue);
    if ((v7[1797] & 4) != 0)
      v8 = kCFBooleanTrue;
    else
      v8 = kCFBooleanFalse;
    CFDictionarySetValue(v6, CFSTR("WiFiHostApStateEnable"), v8);
    if (*v7)
      v9 = kCFBooleanTrue;
    else
      v9 = kCFBooleanFalse;
    CFDictionarySetValue(v6, CFSTR("WiFiHostApStateADHSMode"), v9);
  }
  return v6;
}

uint64_t sub_10010A010(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)sub_10010FF88(a1, 1);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1;
  }
  return result;
}

uint64_t sub_10010A034(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)sub_10010FF88(a1, 2);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1;
  }
  return result;
}

void *sub_10010A058(uint64_t a1, const void *a2)
{
  return sub_10002A21C(a1, a2, 0);
}

id sub_10010A060(uint64_t a1)
{
  id v2;

  v2 = -[NSString copy](-[NSUUID UUIDString](+[NSUUID UUID](NSUUID, "UUID"), "UUIDString"), "copy");
  *(_QWORD *)(a1 + 3856) = v2;
  return objc_msgSend(*(id *)(a1 + 8824), "setColocatedScopeID:", v2);
}

uint64_t sub_10010A0A4(uint64_t a1, const void *a2, int a3)
{
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const __CFArray *v10;
  CFIndex Count;
  uint64_t v12;
  int v13;
  void *v14;
  const __CFNumber *v15;
  CFIndex v16;
  int v17;
  const void *v18;
  const void *v19;
  const __CFNumber *v20;
  const void *v21;
  __int16 v22;
  void *v23;
  CFIndex v24;
  int v25;
  const void *ValueAtIndex;
  uint64_t v27;
  const void *v28;
  const __CFNumber *v29;
  uint64_t valuePtr;

  v6 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v7 = sub_10002BF8C(*(_QWORD *)(a1 + 64), v6);
  if (v7)
  {
    v8 = v7;
    v9 = sub_10002B088(v7);
    if (sub_10007946C(*(_QWORD *)(a1 + 64)))
    {
      valuePtr = 0;
      v10 = *(const __CFArray **)(a1 + 3736);
      if (v10)
        Count = CFArrayGetCount(v10);
      else
        Count = 0;
      v15 = (const __CFNumber *)sub_10002BE64((uint64_t)v8, CFSTR("CHANNEL_FLAGS"));
      if (v15)
        CFNumberGetValue(v15, kCFNumberIntType, (char *)&valuePtr + 4);
      if (a3 != 1)
      {
        if ((valuePtr & 0x200000000000) == 0)
        {
          if (Count >= 1)
          {
            v24 = 0;
            v25 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v24);
              if (ValueAtIndex)
              {
                v27 = (uint64_t)ValueAtIndex;
                v28 = sub_10002B088(ValueAtIndex);
                v29 = (const __CFNumber *)sub_10002BE64(v27, CFSTR("CHANNEL_FLAGS"));
                if (v29)
                {
                  CFNumberGetValue(v29, kCFNumberIntType, &valuePtr);
                  if (CFEqual(v9, a2))
                  {
                    if ((valuePtr & 0x2000) != 0)
                    {
                      if (CFEqual(v9, v28))
                      {
                        v14 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: same ssid is found with 6E enabled, do same ssid roaming", "WiFiDeviceManagerNetworkTransitionAction");
                        goto LABEL_60;
                      }
                      if ((valuePtr & 0x2000) != 0 && !CFEqual(v9, v28))
                        v25 = 1;
                    }
                  }
                  else if ((valuePtr & 0x2000) != 0 && CFEqual(a2, v28))
                  {
                    v25 = 1;
                  }
                }
              }
              ++v24;
            }
            while (Count != v24);
            if (!v25)
              goto LABEL_57;
            v23 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: different ssid is found with 6E enabled, do ssid transition", "WiFiDeviceManagerNetworkTransitionAction");
            goto LABEL_48;
          }
LABEL_57:
          if (CFEqual(v9, a2))
          {
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matching network in colocated cache with 6E enabled, do same ssid roaming", "WiFiDeviceManagerNetworkTransitionAction");
            goto LABEL_60;
          }
        }
LABEL_56:
        v12 = 0;
        goto LABEL_61;
      }
      if (CFEqual(v9, a2))
      {
        if ((valuePtr & 0x200000000000) != 0 && Count >= 1)
        {
          v16 = 0;
          v17 = 0;
          do
          {
            v18 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v16);
            if (v18)
            {
              v19 = v18;
              if (CFEqual(v9, a2))
              {
                v20 = (const __CFNumber *)sub_10002BE64((uint64_t)v19, CFSTR("CHANNEL_FLAGS"));
                if (v20)
                {
                  CFNumberGetValue(v20, kCFNumberIntType, &valuePtr);
                  v21 = sub_10002B088(v19);
                  v22 = valuePtr;
                  if ((valuePtr & 0x2000) == 0)
                  {
                    if (CFEqual(v9, v21))
                    {
                      v14 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: same ssid is found with 6E disabled, do same ssid roaming", "WiFiDeviceManagerNetworkTransitionAction");
                      goto LABEL_60;
                    }
                    v22 = valuePtr;
                  }
                  if ((v22 & 0x2000) == 0 && !CFEqual(v9, v21))
                    v17 = 1;
                }
              }
            }
            ++v16;
          }
          while (Count != v16);
          if (!v17)
            goto LABEL_51;
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: different ssid is found with 6E disabled, do ssid transition", "WiFiDeviceManagerNetworkTransitionAction");
LABEL_48:
          objc_autoreleasePoolPop(v23);
          v12 = 2;
LABEL_61:
          CFRelease(v8);
          return v12;
        }
LABEL_51:
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matched network in colocated cache with 6E disabled, do same ssid roaming", "WiFiDeviceManagerNetworkTransitionAction");
LABEL_60:
        objc_autoreleasePoolPop(v14);
        v12 = 1;
        goto LABEL_61;
      }
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: current ssid doesn't match requested network ssid with 6E disabled, no action", "WiFiDeviceManagerNetworkTransitionAction");
    }
    else
    {
      v13 = CFEqual(v9, a2);
      v14 = objc_autoreleasePoolPush();
      if (v13)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID transition is not supported, do same ssid roaming", "WiFiDeviceManagerNetworkTransitionAction");
        goto LABEL_60;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID transition is not supported, no action", "WiFiDeviceManagerNetworkTransitionAction");
    }
    objc_autoreleasePoolPop(v14);
    goto LABEL_56;
  }
  return 0;
}

void sub_10010A4F8(uint64_t a1, const void *a2, const void *a3, unsigned int a4)
{
  int v7;

  v7 = sub_10010A0A4(a1, a3, a4);
  if (v7 == 1)
  {
    sub_1000731E4(*(_QWORD *)(a1 + 64), a2, a4);
  }
  else if (v7 == 2)
  {
    sub_10010A578(a1, a4 == 1);
  }
}

void sub_10010A578(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;
  const void *v6;
  const void *v7;
  const __CFNumber *v8;
  const __CFArray *v9;
  CFIndex Count;
  void *v11;
  char v12;
  CFIndex v13;
  const void *v14;
  const void *v15;
  void *v16;
  const __CFNumber *v17;
  CFIndex v18;
  const void *ValueAtIndex;
  const __CFNumber *v20;
  CFIndex v21;
  const void *v22;
  const __CFNumber *v23;
  void *v24;
  uint64_t valuePtr;

  valuePtr = 0;
  if (sub_10007946C(*(_QWORD *)(a1 + 64)))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "2.4Gh/5Gh";
      if (!a2)
        v5 = "6Gh";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Initiate Colocated Network Transition. Transitioning to %s Colocated Network", v5);
    }
    objc_autoreleasePoolPop(v4);
    v6 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v7 = sub_10002BF8C(*(_QWORD *)(a1 + 64), v6);
    v8 = (const __CFNumber *)sub_10002BE64((uint64_t)v7, CFSTR("CHANNEL_FLAGS"));
    if (v8)
      CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    v9 = *(const __CFArray **)(a1 + 3736);
    if (v9)
      Count = CFArrayGetCount(v9);
    else
      Count = 0;
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Num Colocated Networks %ld", Count);
    objc_autoreleasePoolPop(v11);
    v12 = valuePtr;
    if (!a2)
    {
      if ((valuePtr & 0x18) != 0 && Count >= 1)
      {
        v18 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v18);
          if (ValueAtIndex)
          {
            v15 = ValueAtIndex;
            v20 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL_FLAGS"));
            if (v20)
            {
              CFNumberGetValue(v20, kCFNumberIntType, (char *)&valuePtr + 4);
              if ((valuePtr & 0x200000000000) != 0)
                break;
            }
          }
          if (Count == ++v18)
          {
            v12 = valuePtr;
            goto LABEL_32;
          }
        }
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]:Associated to 2.4Gh/5Gh. Top 6Gh Colocated Network for Transition = %@", v15);
      }
      else
      {
LABEL_32:
        if ((v12 & 8) == 0 || Count < 1)
          return;
        v21 = 0;
        while (1)
        {
          v22 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v21);
          if (v22)
          {
            v15 = v22;
            v23 = (const __CFNumber *)sub_10002BE64((uint64_t)v22, CFSTR("CHANNEL_FLAGS"));
            if (v23)
            {
              CFNumberGetValue(v23, kCFNumberIntType, (char *)&valuePtr + 4);
              if ((valuePtr & 0x1000000000) != 0)
                break;
            }
          }
          if (Count == ++v21)
            return;
        }
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]:Associated to 2.4Gh. Top 5Gh Colocated Network for Transition = %@", v15);
      }
      objc_autoreleasePoolPop(v24);
LABEL_45:
      sub_100120A64(a1, v15);
      return;
    }
    if ((valuePtr & 0x2000) != 0 && Count >= 1)
    {
      v13 = 0;
      while (1)
      {
        v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v13);
        if (v14)
        {
          v15 = v14;
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Associated to 6Gh. Top Colocated Network for Transition = %@", v15);
          objc_autoreleasePoolPop(v16);
          v17 = (const __CFNumber *)sub_10002BE64((uint64_t)v15, CFSTR("CHANNEL_FLAGS"));
          if (v17)
          {
            CFNumberGetValue(v17, kCFNumberIntType, (char *)&valuePtr + 4);
            if ((valuePtr & 0x1000000000) != 0)
              break;
          }
        }
        if (Count == ++v13)
          return;
      }
      goto LABEL_45;
    }
  }
}

void sub_10010A834(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(a1 + 32), "setJoinEvent:withReason:lastDisconnectReason:lastJoinFailure:andNetworkDetails:forInterface:", 0, 0, *(unsigned int *)(a1 + 48), 0, a2, *(_QWORD *)(a1 + 40));

  }
}

void sub_10010A884(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  const void *v7;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v2 + 240))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v2 + 3872))(v2, *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24), 0, 0, 0, *(_QWORD *)(v2 + 3880));
    CFRelease(v3[1]);
    v5 = *v3;
  }
  else
  {
    CFRelease((CFTypeRef)v2);
    v6 = *(_QWORD **)(a1 + 32);
    v3 = (CFTypeRef *)(a1 + 32);
    v5 = v6;
  }
  v7 = *(const void **)(v5[1] + 24);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(*((_QWORD *)*v3 + 1) + 24) = 0;
  }
}

_QWORD *sub_10010A904(_QWORD *result, int a2, CFTypeRef cf, int a4, int a5, int a6, int a7)
{
  _QWORD *v11;
  const void *v13;

  v11 = result;
  if (cf)
  {
    v13 = (const void *)result[479];
    if (v13)
    {
      CFRelease(v13);
      v11[479] = 0;
    }
    result = CFRetain(cf);
    v11[479] = result;
  }
  *((_DWORD *)v11 + 960) = a4;
  *((_DWORD *)v11 + 962) = a6;
  *((_DWORD *)v11 + 961) = a5;
  *((_DWORD *)v11 + 963) = a7;
  return result;
}

void sub_10010A974(uint64_t a1)
{
  const void *v2;

  v2 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  sub_1000F7F48(a1, v2, 1001, "WiFiDeviceManagerDisassociateAll", 20788);
}

void sub_10010A9B0(uint64_t *a1, const void *a2, uint64_t a3)
{
  const __CFDictionary **v6;
  void *v7;
  _QWORD v8[5];
  int v9;

  v6 = (const __CFDictionary **)sub_10002A21C((uint64_t)a1, a2, 1);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network=%@ reason=%@(%d)", "WiFiDeviceManagerCancelAssociation", v6, sub_100064AA8(a3), a3);
  objc_autoreleasePoolPop(v7);
  if (a1[921])
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_10010AAD0;
    v8[3] = &unk_100231500;
    v8[4] = a1;
    v9 = a3;
    sub_10010367C((uint64_t)a1, v6, (uint64_t)v8);
  }
  sub_100072F84(a1[8], a2, 0, a3, "WiFiDeviceManagerCancelAssociation", 20818);
  sub_100046660(a1[15], 0, 1, 0);
  if (v6)
    CFRelease(v6);
}

void sub_10010AAD0(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setJoinEvent:withReason:lastDisconnectReason:lastJoinFailure:andNetworkDetails:forInterface:", 0, 0, *(unsigned int *)(a1 + 40), 0, a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

uint64_t sub_10010AB34(uint64_t result, int a2)
{
  int v2;

  v2 = *(_DWORD *)(result + 404);
  if (a2)
    *(_DWORD *)(result + 404) = --v2;
  if (!v2)
    *(_QWORD *)(result + 408) = 0;
  return result;
}

uint64_t sub_10010AB54(_BYTE *a1, const void *a2, int a3)
{
  _BOOL4 v5;
  void *v6;
  _BOOL4 v7;
  char v8;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;

  v5 = sub_10010ACE4((uint64_t)a1, a2);
  if (sub_100018E70((uint64_t)a1))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue NDD request - sensitive action on", "WiFiDeviceManagerIsNDDAllowed", v12, v13);
LABEL_16:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  if (sub_100018FE4((uint64_t)a1)
    && (!sub_10010A010((uint64_t)a1) ? (v7 = v5) : (v7 = 0), !v7)
    || (!a1[3414] ? (v8 = 1) : (v8 = v5), (v8 & 1) == 0 && a3))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue NDD request - hosting AWDL session", "WiFiDeviceManagerIsNDDAllowed", v12, v13);
    goto LABEL_16;
  }
  v10 = !sub_100018E14((uint64_t)a1) || v5;
  if ((v10 & 1) == 0)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue NDD request - MIS discovery state %d MIS Scan Blocked = %d", "WiFiDeviceManagerIsNDDAllowed", a1[5221], a1[5328]);
    goto LABEL_16;
  }
  if (sub_100018D34((CFIndex)a1))
    v11 = v5;
  else
    v11 = 1;
  if ((v11 & 1) == 0)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue NDD request - autojoin is busy", "WiFiDeviceManagerIsNDDAllowed", v12, v13);
    goto LABEL_16;
  }
  return 1;
}

BOOL sub_10010ACE4(uint64_t a1, const void *a2)
{
  _BOOL8 result;
  const __CFArray *v5;
  CFRange v6;

  result = 0;
  if (a1 && a2)
  {
    v5 = *(const __CFArray **)(a1 + 4936);
    if (v5)
    {
      v6.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 4936));
      v6.location = 0;
      return CFArrayContainsValue(v5, v6, a2) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10010AD44(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3414);
}

uint64_t sub_10010AD4C(uint64_t a1, const void *a2, void *a3, const void *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v16;
  int v17;
  int v18;
  CFComparisonResult v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  const __CFArray *v23;
  CFIndex Count;
  uint64_t v25;
  const __CFString *v26;
  const __CFString *v27;
  CFIndex v28;
  int v29;
  const void *ValueAtIndex;
  uint64_t v31;
  const __CFString *v32;
  void *v33;
  void *v34;
  const void *v35;
  const char *v36;
  void *v37;
  id v38;
  id v39;
  void *v40;
  unsigned int v41;
  uint64_t v42;
  void *v43;
  void *v44;
  void *v45;
  const void *v46;
  NSObject *v47;
  const void *v48;
  _BYTE *v49;
  char v50;
  const void *v51;
  const void *v52;
  const __CFBoolean *v53;
  CFTypeRef v54;
  const void *v55;
  const void *v56;
  CFTypeRef v57;
  _BOOL4 v58;
  _BOOL4 v59;
  const void *v61;
  const void *v62;
  void *v63;
  void *v64;
  char v65;
  void *v66;
  void *v67;
  void *v68;
  const void *v69;
  const void *v70;
  char *v71;
  uint64_t v72;
  void (*v73)(uint64_t, CFTypeRef, void *, _QWORD, _QWORD, _QWORD);
  void *v74;
  void *v75;
  double Current;
  unsigned int v77;
  void *v78;
  const char *v79;
  void *v80;
  void *v81;
  const __CFNumber *v82;
  void *v83;
  id v84;
  void *v85;
  unsigned int v86;
  unsigned int v87;
  __CFArray *v88;
  void *v89;
  void *v90;
  _WORD *v91;
  CFAbsoluteTime v92;
  CFTypeRef v93;
  NSObject *v94;
  void *v95;
  NSObject *v96;
  void *v97;
  uint64_t v98;
  const void *v99;
  NSObject *v100;
  uint64_t v101;
  const __CFNumber *v102;
  void *v103;
  void *v104;
  void *v105;
  void *v106;
  unsigned int v107;
  unsigned int v108;
  void *v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  void *v114;
  unsigned int v115;
  char v116;
  char v117;
  void *v118;
  void *v119;
  const void *v120;
  void *v121;
  void *v122;
  const void *v123;
  void *v124;
  NSObject *v125;
  void *v126;
  void *v127;
  CFIndex FirstIndexOfValue;
  CFIndex v129;
  CFArrayRef *v130;
  void *v131;
  const void *v132;
  const void *v133;
  CFIndex v135;
  void *v136;
  void *v137;
  int v138;
  void *v139;
  id v140;
  void *v141;
  NSObject *v142;
  void *v143;
  void *v144;
  uint64_t v145;
  void *v146;
  const void *v147;
  char context;
  void *contexta;
  uint64_t v150;
  const __CFString *v151;
  const void *v152;
  _BYTE *v153;
  uint64_t v154;
  uint64_t v155;
  _BOOL4 v156;
  uint64_t v157;
  CFTypeRef cf;
  _QWORD v159[6];
  _QWORD v160[5];
  _QWORD v161[7];
  _QWORD v162[5];
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  CFStringRef v171;
  __int128 v172;
  __int128 v173;
  uint64_t v174;
  _QWORD v175[9];
  _QWORD v176[7];
  _QWORD v177[9];
  uint64_t v178;
  uint64_t *v179;
  uint64_t v180;
  void *v181;
  _QWORD block[10];
  CFRange v183;
  CFRange v184;

  if (!a1)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to join %@, null manager", "WiFiDeviceManagerAssociateAsync", sub_10002B088(a3));
    objc_autoreleasePoolPop(v21);
    return 4294963396;
  }
  v156 = a8 != 1018;
  sub_10010CA10(a3);
  dword_10026DD64 = 0;
  v157 = a8;
  cf = a2;
  v151 = a5;
  v152 = a4;
  v154 = a6;
  v155 = a7;
  switch((int)a8)
  {
    case 1008:
      dword_10026DD64 = 0x80000;
      v16 = 1;
      if (CFStringCompare(a5, CFSTR("Preferences"), 1uLL))
      {
        if (CFStringCompare(a5, CFSTR("homed"), 1uLL))
        {
          v17 = 1;
          if (CFStringCompare(a5, CFSTR("SpringBoard"), 1uLL))
          {
            v18 = 1;
            if (CFStringCompare(a5, CFSTR("WiFiPickerExtens"), 1uLL))
            {
              if (CFStringCompare(a5, CFSTR("HPSetup"), 1uLL) && CFStringCompare(a5, CFSTR("Setup"), 1uLL))
              {
                v19 = CFStringCompare(a5, CFSTR("sharingd"), 1uLL);
                v16 = 0;
                v17 = 0;
                v18 = 0;
                v20 = 8;
                if (v19 == kCFCompareEqualTo)
                  v20 = 14;
              }
              else
              {
                v16 = 0;
                v17 = 0;
                v18 = 0;
                v20 = 13;
              }
            }
            else
            {
              v16 = 0;
              v17 = 0;
              v20 = 3;
            }
          }
          else
          {
            v16 = 0;
            v18 = 0;
            v20 = 7;
          }
        }
        else
        {
          v16 = 0;
          v17 = 0;
          v18 = 0;
          v20 = 6;
        }
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v20 = 2;
      }
      goto LABEL_26;
    case 1011:
      v16 = 0;
      v17 = 0;
      v18 = 0;
      dword_10026DD64 = 0x40000;
      v20 = 5;
      goto LABEL_26;
    case 1013:
      v16 = 0;
      v17 = 0;
      v18 = 0;
      dword_10026DD64 = 0x20000;
      v20 = 9;
      goto LABEL_26;
    case 1016:
      v16 = 0;
      v17 = 0;
      v18 = 0;
      dword_10026DD64 = 0x800000;
      v20 = 4;
      goto LABEL_26;
    default:
      if ((_DWORD)a8 == 1018)
      {
        v16 = 0;
        v17 = 0;
        v18 = 0;
        dword_10026DD64 = 0x400000;
        v20 = 10;
LABEL_26:
        v150 = v20;
      }
      else
      {
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v150 = 0;
        dword_10026DD64 = 0x100000;
      }
      if (!a3)
        goto LABEL_47;
      v23 = *(const __CFArray **)(a1 + 5584);
      if (!v23)
        goto LABEL_47;
      Count = CFArrayGetCount(v23);
      if (!Count)
        goto LABEL_47;
      v25 = Count;
      v26 = (const __CFString *)sub_10002BE64((uint64_t)a3, CFSTR("PolicyUUID"));
      if (v25 < 1)
        goto LABEL_40;
      v27 = v26;
      v28 = 0;
      v29 = 1;
      break;
  }
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5584), v28);
    if (!ValueAtIndex)
      goto LABEL_38;
    v31 = (uint64_t)ValueAtIndex;
    if (sub_10003F5B4((uint64_t)ValueAtIndex) != 1)
      goto LABEL_38;
    if (!v27)
      break;
    v32 = (const __CFString *)sub_10003F540(v31);
    if (CFStringCompare(v27, v32, 0) == kCFCompareEqualTo && !sub_1000CB480((uint64_t)a3))
    {
LABEL_40:
      v29 = 1;
      goto LABEL_42;
    }
    v29 = 0;
LABEL_38:
    if (v25 == ++v28)
      goto LABEL_42;
  }
  v29 = 0;
LABEL_42:
  v33 = objc_autoreleasePoolPush();
  v34 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v35 = sub_10002B088(a3);
    v36 = "";
    if (!v29)
      v36 = "NOT ";
    objc_msgSend(v34, "WFLog:message:", 3, "%s: network %@ is %scompliant with the active policies!", "__WiFiDeviceManagerIsNetworkPolicyCompliant", v35, v36);
  }
  objc_autoreleasePoolPop(v33);
  if (!v29)
  {
    if (*(_QWORD *)(a1 + 240))
    {
      CFRetain(cf);
      CFRetain((CFTypeRef)a1);
      v47 = *(NSObject **)(a1 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10010CD3C;
      block[3] = &unk_100231520;
      block[4] = a1;
      block[5] = cf;
      block[6] = v154;
      block[7] = v155;
      dispatch_async(v47, block);
    }
    else
    {
      v63 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
      objc_autoreleasePoolPop(v63);
    }
    return 4294963366;
  }
LABEL_47:
  v37 = objc_autoreleasePoolPush();
  v38 = sub_100027D10((uint64_t)a3);
  if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v38))
  {
    v39 = objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", v38, 1, 0, 0);
    if (v39)
    {
      v40 = v39;
      if (objc_msgSend(v39, "count"))
      {
        v41 = objc_msgSend(objc_msgSend(v40, "objectAtIndex:", 0), "unsignedIntegerValue");
        dword_10026DD64 |= v41;
        ++*(_WORD *)(a1 + 6024);
        v42 = v150;
        if (v16 | v17 | v18)
          v42 = 11;
        v150 = v42;
      }
    }
  }

  objc_autoreleasePoolPop(v37);
  v43 = sub_10002A21C(a1, cf, 1);
  v44 = objc_autoreleasePoolPush();
  v45 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    if (v43)
      v46 = sub_10002B088(v43);
    else
      v46 = 0;
    v48 = sub_10002B088(a3);
    objc_msgSend(v45, "WFLog:message:", 3, "%s: current %@, assoc %@, reason %@(%d)", "WiFiDeviceManagerAssociateAsync", v46, v48, sub_100064AA8(v157), v157);
  }
  v49 = (_BYTE *)(a1 + 5217);
  objc_autoreleasePoolPop(v44);
  if (*(_DWORD *)(a1 + 3280) != 14)
  {
    v50 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
    if ((_DWORD)v157 != 1018 || (v50 & 1) == 0)
      sub_1000FB44C(a1);
  }
  if (!*(_BYTE *)(a1 + 3465) || !v43)
  {
    if (v43)
      goto LABEL_72;
    v58 = 0;
    v59 = v157 == 1008;
    goto LABEL_96;
  }
  v51 = sub_10002B088(v43);
  v52 = sub_10002B088(a3);
  if (CFEqual(v51, v52))
  {
    v53 = (const __CFBoolean *)sub_10002BE64((uint64_t)a3, CFSTR("JOINING_FROM_UI"));
    if ((_DWORD)v157 == 1008 || v53 == kCFBooleanTrue)
    {
      *(_QWORD *)&v163 = 0;
      *((_QWORD *)&v163 + 1) = &v163;
      *(_QWORD *)&v164 = 0x2020000000;
      *((_QWORD *)&v164 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (cf)
        v54 = CFRetain(cf);
      else
        v54 = 0;
      *((_QWORD *)&v164 + 1) = v54;
      v178 = 0;
      v179 = &v178;
      v180 = 0x2020000000;
      v181 = (void *)0xAAAAAAAAAAAAAAAALL;
      v181 = (void *)CFRetain(v43);
      v95 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user preferred cellular-outranked WiFi: %@", "WiFiDeviceManagerAssociateAsync", sub_10002B088(a3));
      objc_autoreleasePoolPop(v95);
      objc_msgSend(*(id *)(a1 + 7368), "addFaultEvent:forInterface:", 20, cf);
      sub_100078D0C(*(_QWORD *)(a1 + 64), *(_QWORD *)(*((_QWORD *)&v163 + 1) + 24), 1);
      if (*(_QWORD *)(a1 + 240))
      {
        CFRetain((CFTypeRef)a1);
        if (cf)
          CFRetain(cf);
        v96 = *(NSObject **)(a1 + 240);
        v177[0] = _NSConcreteStackBlock;
        v177[1] = 3221225472;
        v177[2] = sub_10010CD98;
        v177[3] = &unk_100231548;
        v177[4] = &v178;
        v177[5] = &v163;
        v177[6] = a1;
        v177[7] = v154;
        v177[8] = v155;
        dispatch_async(v96, v177);
      }
      else
      {
        v97 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
        objc_autoreleasePoolPop(v97);
      }
      v98 = v179[3];
      if (v98 && *(_QWORD *)(*((_QWORD *)&v163 + 1) + 24) && *(_QWORD *)(a1 + 4104))
      {
        sub_10002C478(v98, CFSTR("WiFiNetworkIsAutoJoined"), kCFBooleanFalse);
        sub_1000C69F0((const void *)v179[3], 1, +[NSDate date](NSDate, "date"));
        if (*(_QWORD *)(a1 + 240))
        {
          CFRetain((CFTypeRef)a1);
          CFRetain((CFTypeRef)v179[3]);
          v99 = *(const void **)(*((_QWORD *)&v163 + 1) + 24);
          if (v99)
            CFRetain(v99);
          v100 = *(NSObject **)(a1 + 240);
          v176[0] = _NSConcreteStackBlock;
          v176[1] = 3221225472;
          v176[2] = sub_10010CE1C;
          v176[3] = &unk_100231570;
          v176[6] = a1;
          v176[4] = &v178;
          v176[5] = &v163;
          dispatch_async(v100, v176);
        }
        else
        {
          v131 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
          objc_autoreleasePoolPop(v131);
        }
      }
      v132 = (const void *)v179[3];
      if (v132)
        CFRelease(v132);
      v133 = *(const void **)(*((_QWORD *)&v163 + 1) + 24);
      if (v133)
        CFRelease(v133);
      _Block_object_dispose(&v178, 8);
      _Block_object_dispose(&v163, 8);
      return 0;
    }
  }
LABEL_72:
  v55 = sub_10002B088(v43);
  v56 = sub_10002B088(a3);
  if (!CFEqual(v55, v56) || !sub_10002DAB4((uint64_t)a3) && !sub_10000BE8C((uint64_t)a3))
  {
    v58 = 0;
    v59 = v157 == 1008;
    if ((_DWORD)v157 == 1008 || (_DWORD)v157 == 1011)
    {
      v61 = sub_10002B088(v43);
      v62 = sub_10002B088(a3);
      if (!CFEqual(v61, v62))
      {
        v101 = sub_100070EA8(*(_QWORD *)(a1 + 64));
        v102 = sub_100017A54((uint64_t)a3, CFSTR("RSSI"));
        v103 = objc_autoreleasePoolPush();
        v104 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          contexta = v103;
          v147 = sub_10002B088(a3);
          objc_msgSend(v104, "WFLog:message:", 3, "%s: user switching to %@(%d), leaving %@(%d) ", "WiFiDeviceManagerAssociateAsync", v147, v102, sub_10002B088(v43), v101);
          v103 = contexta;
        }
        objc_autoreleasePoolPop(v103);
        v58 = (int)v101 > *(_DWORD *)(a1 + 128);
        v49 = (_BYTE *)(a1 + 5217);
        if (!a3)
          goto LABEL_103;
        goto LABEL_97;
      }
      v58 = 0;
      if (a3)
      {
LABEL_97:
        if (v59 && v49[2] && v49[1] == -*v49)
        {
          LODWORD(v178) = 0;
          v66 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MIS state is enabled. Force-disabling before association type (%d).", "WiFiDeviceManagerAssociateAsync", 1008);
          objc_autoreleasePoolPop(v66);
          v174 = 0;
          v172 = 0u;
          v173 = 0u;
          v169 = 0u;
          v170 = 6;
          v167 = 0u;
          v168 = 0u;
          v165 = 0u;
          v166 = 0u;
          v163 = 0u;
          v164 = 0u;
          DWORD2(v163) = 6;
          v171 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Network Transition"));
          sub_100106C34(a1, (uint64_t)&v163);
          sub_1001065B4(a1, 0, 1, 0, (unsigned int *)&v178);
        }
      }
LABEL_103:
      if (*(_QWORD *)(a1 + 7368))
      {
        v162[0] = _NSConcreteStackBlock;
        v162[1] = 3221225472;
        v162[2] = sub_10010CF74;
        v162[3] = &unk_1002314B8;
        v162[4] = a1;
        sub_10010367C(a1, (const __CFDictionary **)v43, (uint64_t)v162);
      }
      v65 = 0;
      context = 1;
LABEL_106:
      if ((_DWORD)v157 == 1018)
      {
        if ((v65 & 1) == 0)
          goto LABEL_110;
      }
      else
      {
        ++*(_DWORD *)(a1 + 3480);
        v67 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did increment user join counter (%d)", "WiFiDeviceManagerAssociateAsync", *(unsigned int *)(a1 + 3480));
        objc_autoreleasePoolPop(v67);
        if ((v65 & 1) == 0)
        {
LABEL_110:
          if (sub_10002BE64((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
          {
            v68 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Link down will be debounced", "WiFiDeviceManagerAssociateAsync");
            objc_autoreleasePoolPop(v68);
            if (!a3)
            {
LABEL_119:
              v153 = v49;
              v71 = (char *)malloc_type_malloc(0x38uLL, 0x10E00402A548A24uLL);
              v72 = (uint64_t)v71;
              *(_OWORD *)(v71 + 24) = 0u;
              *(_OWORD *)(v71 + 40) = 0u;
              *(_QWORD *)v71 = a1;
              *((_QWORD *)v71 + 1) = v154;
              *((_QWORD *)v71 + 2) = v155;
              *((_DWORD *)v71 + 8) = v157;
              *((_DWORD *)v71 + 9) = v156;
              if (v58)
              {
                *((_QWORD *)v71 + 3) = v43;
                CFRetain(v43);
              }
              v73 = *(void (**)(uint64_t, CFTypeRef, void *, _QWORD, _QWORD, _QWORD))(a1 + 3888);
              if (v73)
                v73(a1, cf, a3, 0, 0, *(_QWORD *)(a1 + 3896));
              v74 = objc_autoreleasePoolPush();
              objc_msgSend(*(id *)(a1 + 6624), "asyncTrackNetworksOfInterest:", 1);
              objc_autoreleasePoolPop(v74);
              sub_1000FEDDC(a1);
              if (a3)
              {
                v75 = objc_autoreleasePoolPush();
                if (!v151)
                {
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client is NULL!", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", v145);
                  goto LABEL_140;
                }
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Association client is %@", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", v151);
                objc_autoreleasePoolPop(v75);
                if (CFStringCompare(v151, CFSTR("Preferences"), 0))
                  goto LABEL_145;
                if (!v153[2] && !*(_DWORD *)(a1 + 5344) && v153[144] == -v153[143]
                  || *(_BYTE *)(a1 + 7056) && sub_100107828(a1, 1))
                {
                  Current = CFAbsoluteTimeGetCurrent();
                  if (Current - *(double *)(a1 + 3424) < 10.0 || Current - *(double *)(a1 + 3456) < 30.0)
                    goto LABEL_145;
                  v77 = *(_DWORD *)(a1 + 3352);
                  if (v77 <= 6 && ((1 << v77) & 0x58) != 0)
                  {
                    v75 = objc_autoreleasePoolPush();
                    v78 = (void *)qword_10026DD20;
                    if (!qword_10026DD20)
                    {
LABEL_140:
                      v80 = v75;
LABEL_144:
                      objc_autoreleasePoolPop(v80);
                      goto LABEL_145;
                    }
                    v146 = (void *)sub_100024674(*(_DWORD *)(a1 + 3352));
                    v79 = "%s: Device in motion (%@). Suppressing autojoin delayed alert.";
                  }
                  else
                  {
                    v183.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
                    v183.location = 0;
                    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3528), v183, a3);
                    if (FirstIndexOfValue == -1)
                    {
                      v184.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3536));
                      v184.location = 0;
                      v135 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3536), v184, a3);
                      if (v135 == -1)
                        goto LABEL_145;
                      v129 = v135;
                      v130 = (CFArrayRef *)(a1 + 3536);
                    }
                    else
                    {
                      v129 = FirstIndexOfValue;
                      v130 = (CFArrayRef *)(a1 + 3528);
                    }
                    v136 = (void *)CFArrayGetValueAtIndex(*v130, v129);
                    if (!v136)
                      goto LABEL_145;
                    v137 = v136;
                    sub_10002B290((uint64_t)v136, (uint64_t)a3);
                    if (!sub_100007F24((uint64_t)v137))
                    {
                      dword_10026DD64 |= 0x10000u;
                      goto LABEL_145;
                    }
                    if (sub_10001395C((uint64_t)v137)
                      || !sub_1000C488C((uint64_t)v137)
                      || sub_10002BE64((uint64_t)v137, CFSTR("HotspotDeviceIdentifier")))
                    {
                      v75 = objc_autoreleasePoolPush();
                      v78 = (void *)qword_10026DD20;
                      if (!qword_10026DD20)
                        goto LABEL_140;
                      v146 = (void *)sub_10002B088(v137);
                      v79 = "%s: not considering personal hotspot network %@ for delayed auto-join";
                    }
                    else if (sub_10001F440(v137))
                    {
                      v75 = objc_autoreleasePoolPush();
                      v78 = (void *)qword_10026DD20;
                      if (!qword_10026DD20)
                        goto LABEL_140;
                      v146 = (void *)sub_10002B088(v137);
                      v79 = "%s: not considering hidden network %@ for delayed auto-join";
                    }
                    else
                    {
                      if (!sub_1000137D8((uint64_t)v137))
                      {
                        v138 = sub_100124B34(a1, v137, 0);
                        v139 = objc_autoreleasePoolPush();
                        if (!v138)
                        {
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not considering non-suitable network %@ for delayed auto-join", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", sub_10002B088(v137));
                          objc_autoreleasePoolPop(v139);
                          goto LABEL_145;
                        }
                        v140 = sub_100027D10((uint64_t)a3);
                        if (objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v140, 0, 0))
                        {
                          v141 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: joining weak/trigger-disconnected network at %d, not considering for slow auto-join", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", sub_100017A54((uint64_t)a3, CFSTR("RSSI")));
                        }
                        else
                        {
                          if (!objc_msgSend(*(id *)(a1 + 3656), "canDeferNetwork:withUsageRank:andMotionState:", v137, sub_1000CBD04((uint64_t)v137), *(unsigned int *)(a1 + 3352)))
                          {
                            objc_autoreleasePoolPop(v139);

                            if (!v43)
                            {
                              dword_10026DD64 |= 0x200000u;
                              if (*(_QWORD *)(a1 + 240))
                              {
                                CFRetain((CFTypeRef)a1);
                                v142 = *(NSObject **)(a1 + 240);
                                v160[0] = _NSConcreteStackBlock;
                                v160[1] = 3221225472;
                                v160[2] = sub_10010D0B0;
                                v160[3] = &unk_10022EA38;
                                v160[4] = a1;
                                dispatch_async(v142, v160);
                              }
                              else
                              {
                                v143 = objc_autoreleasePoolPush();
                                if (qword_10026DD20)
                                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
                                objc_autoreleasePoolPop(v143);
                              }
                              v144 = *(void **)(a1 + 7368);
                              if (v144)
                                objc_msgSend(v144, "addFaultEvent:forInterface:", 12, sub_100029860(*(_QWORD *)(a1 + 64)));
                            }
                            goto LABEL_145;
                          }
                          v141 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not considering deferrable network %@ for delayed auto-join", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", sub_10002B088(v137));
                        }
                        objc_autoreleasePoolPop(v141);
                        objc_autoreleasePoolPop(v139);

LABEL_145:
                        *(_DWORD *)(a1 + 3472) = 0;
                        v82 = (const __CFNumber *)sub_10002BE64((uint64_t)a3, CFSTR("TransitionDisabledFlags"));
                        if (v82)
                          CFNumberGetValue(v82, kCFNumberSInt32Type, (void *)(a1 + 3472));
                        v83 = sub_100026664((CFDictionaryRef *)a3);
                        v84 = sub_100009ACC(a1);
                        if (CWFKnownNetworkAssociatedDuringAWDLRealTimeMode(v83, v84))
                        {
                          v85 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_PREFER_NON_6GHZ because AWDL real time mode was recently active while associated to this known network (%@)", "WiFiDeviceManagerAssociateAsync", v83);
                          objc_autoreleasePoolPop(v85);
                          v86 = sub_100017A54((uint64_t)a3, CFSTR("ASSOC_FLAGS"));
                          sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v86 & 0xFFFEFFFF | 0x10000);
                        }

                        if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EStandalone6GHz"))
                        {
                          if (sub_10002BF80(*(_QWORD *)(a1 + 64)))
                          {
                            v87 = sub_100017A54((uint64_t)a3, CFSTR("ASSOC_FLAGS"));
                            if ((v87 & 0x100000) == 0)
                            {
                              v88 = sub_1000775BC(*(_QWORD *)(a1 + 64), 0);
                              if (CWFScanResultHas6GHzOnlyBSS(a3, v88, &stru_100231590))
                              {
                                v89 = objc_autoreleasePoolPush();
                                if (qword_10026DD20)
                                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_6GHZ_ONLY because network has 6GHz-only BSS (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                                objc_autoreleasePoolPop(v89);
                                sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v87 & 0xFFEFFFFF | 0x100000);
                                v90 = sub_100026664((CFDictionaryRef *)a3);
                                objc_msgSend(v90, "setWas6GHzOnlyAt:", +[NSDate date](NSDate, "date"));
                                v91 = sub_1000CCB10(v90, 0);
                                sub_10002C478((uint64_t)v91, CFSTR("Standalone"), 0);
                                if (v91)
                                {
                                  sub_1000C38BC((uint64_t)a3, (uint64_t)v91);
                                  CFRelease(v91);
                                }

                              }
                              else if (objc_msgSend(v83, "wasRecently6GHzOnlyOnAnyDevice"))
                              {
                                v105 = objc_autoreleasePoolPush();
                                if (qword_10026DD20)
                                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_6GHZ_ONLY because known network was recently determined to be 6GHz-only (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                                objc_autoreleasePoolPop(v105);
                                sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v87 & 0xFFEFFFFF | 0x100000);
                              }
                              if (v88)
                                CFRelease(v88);
                            }
                          }
                        }

                        if (sub_100071728(*(_QWORD *)(a1 + 64)) && sub_1000C5124(a3))
                        {
                          v106 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_BEACON_PROTECTION because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                          objc_autoreleasePoolPop(v106);
                          v107 = sub_100017A54((uint64_t)a3, CFSTR("ASSOC_FLAGS"));
                          sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v107 & 0xFFFF7FFF | 0x8000);
                        }
                        if (sub_10007174C(*(_QWORD *)(a1 + 64)))
                        {
                          v108 = sub_1000C51F0((const __CFDictionary *)a3);
                          v109 = objc_autoreleasePoolPush();
                          if (v108)
                          {
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                            objc_autoreleasePoolPop(v109);
                            v110 = sub_100017A54((uint64_t)a3, CFSTR("ASSOC_FLAGS"));
                            sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v110 & 0xFFFBFFFF | 0x40000);
                            v111 = sub_100017A54((uint64_t)a3, CFSTR("WSEC_FLAGS"));
                            v112 = sub_1000C5200((const __CFDictionary *)a3);
                            v109 = objc_autoreleasePoolPush();
                            if (v112)
                            {
                              v113 = v111 | 0x20000;
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_RESTRICT mode network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                            }
                            else
                            {
                              v113 = v111 | 0x10000;
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_ENABLE because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                            }
                          }
                          else
                          {
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_DISABLE mode network is incapable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                            v113 = 0;
                          }
                          objc_autoreleasePoolPop(v109);
                          sub_10002B698((uint64_t)a3, CFSTR("WSEC_FLAGS"), v113);
                        }
                        if (sub_100071740(*(_QWORD *)(a1 + 64))
                          && sub_1000C519C((CFDictionaryRef *)a3))
                        {
                          v114 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_OCV because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3);
                          objc_autoreleasePoolPop(v114);
                          v115 = sub_100017A54((uint64_t)a3, CFSTR("ASSOC_FLAGS"));
                          sub_10002B698((uint64_t)a3, CFSTR("ASSOC_FLAGS"), v115 & 0xFFFDFFFF | 0x20000);
                        }
                        v116 = context ^ 1;
                        if (!v43)
                          v116 = 0;
                        if ((v116 & 1) == 0)
                          sub_1000750A0(*(_QWORD *)(a1 + 64));
                        *(CFAbsoluteTime *)(a1 + 3456) = CFAbsoluteTimeGetCurrent();
                        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "willAssociateWithNetwork:isAutoJoin:interfaceName:", a3, 0, cf);
                        if (v153[2] || v153[144] != -v153[143])
                          *(_DWORD *)(a1 + 6348) = 1;
                        if (sub_10002BE64((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
                        {
                          v117 = 1;
                        }
                        else
                        {
                          sub_10010A060(a1);
                          sub_10002C478((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), *(const void **)(a1 + 3856));
                          v117 = 0;
                        }
                        *(_BYTE *)(v72 + 48) = v117;
                        if (_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
                        {
                          sub_10010D1E0((uint64_t)a3);
                          v118 = objc_autoreleasePoolPush();
                          v119 = (void *)qword_10026DD20;
                          if (qword_10026DD20)
                          {
                            v120 = sub_10002B088(a3);
                            objc_msgSend(v119, "WFLog:message:", 3, "%s: Setting ColocatedScopeId for %@ - '%@'", "WiFiDeviceManagerAssociateAsync", v120, sub_10002BE64((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID")));
                          }
                          objc_autoreleasePoolPop(v118);
                        }
                        sub_10010D248(a1, a3);
                        v121 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Join with colocated scopeID (%@), network (%@)", sub_10002BE64((uint64_t)a3, CFSTR("COLOCATED_NETWORK_SCOPE_ID")), a3);
                        objc_autoreleasePoolPop(v121);
                        sub_10001E764(*(_QWORD *)(a1 + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%p"), CFSTR("UserJoin"), v72), (CFNumberRef)0xA);
                        v22 = sub_1000721D8(*(_QWORD *)(a1 + 64), cf, a3, v152, (uint64_t)sub_10010D444, v72, v156);
                        if ((_DWORD)v22)
                        {
                          sub_10001E764(*(_QWORD *)(a1 + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%p"), CFSTR("UserJoin"), v72), 0);
                          if ((_DWORD)v157 != 1018)
                          {
                            --*(_DWORD *)(a1 + 3480);
                            v122 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did decrement user join counter (%d)", "WiFiDeviceManagerAssociateAsync", *(unsigned int *)(a1 + 3480));
                            objc_autoreleasePoolPop(v122);
                          }
                          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "associationDoneWithNetwork:error:interfaceName:", a3, v22, cf);
                          v123 = *(const void **)(v72 + 24);
                          if (v123)
                          {
                            CFRelease(v123);
                            *(_QWORD *)(v72 + 24) = 0;
                          }
                          free((void *)v72);
                        }
                        else
                        {
                          sub_10010E1C0(a1, a3);
                          sub_1000F9DAC((char *)a1, 1, 1);
                          if (*(_QWORD *)(a1 + 7368))
                          {
                            v159[0] = _NSConcreteStackBlock;
                            v159[1] = 3221225472;
                            v159[2] = sub_10010E378;
                            v159[3] = &unk_1002315B0;
                            v159[4] = a1;
                            v159[5] = v150;
                            sub_10010367C(a1, (const __CFDictionary **)a3, (uint64_t)v159);
                          }
                        }
                        if (v43)
                          CFRelease(v43);
                        return v22;
                      }
                      v75 = objc_autoreleasePoolPush();
                      v78 = (void *)qword_10026DD20;
                      if (!qword_10026DD20)
                        goto LABEL_140;
                      v146 = (void *)sub_10002B088(v137);
                      v79 = "%s: not considering hotspot network %@ for delayed auto-join";
                    }
                  }
                  objc_msgSend(v78, "WFLog:message:", 3, v79, "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", v146);
                  goto LABEL_140;
                }
                v81 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not considering delayed auto-join due to MIS", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed");
              }
              else
              {
                v81 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is NULL!", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed");
              }
              v80 = v81;
              goto LABEL_144;
            }
          }
          else
          {
            sub_100072E54(*(_QWORD *)(a1 + 64), cf, 0, 1008);
            if (!a3)
              goto LABEL_119;
          }
LABEL_117:
          if (v43)
          {
            v69 = sub_10002B088(v43);
            v70 = sub_10002B088(a3);
            if (!CFEqual(v69, v70))
            {
              if (*(_QWORD *)(a1 + 4744))
              {
                if (*(_QWORD *)(a1 + 240))
                {
                  *(_QWORD *)&v163 = 0;
                  *((_QWORD *)&v163 + 1) = &v163;
                  v164 = 0x2020000000uLL;
                  v178 = 0;
                  v179 = &v178;
                  v180 = 0x2020000000;
                  v181 = (void *)0xAAAAAAAAAAAAAAAALL;
                  v92 = CFAbsoluteTimeGetCurrent();
                  v181 = CFDateCreate(kCFAllocatorDefault, v92);
                  v93 = CFRetain(v43);
                  *(_QWORD *)(*((_QWORD *)&v163 + 1) + 24) = v93;
                  CFRetain((CFTypeRef)a1);
                  v94 = *(NSObject **)(a1 + 240);
                  v161[0] = _NSConcreteStackBlock;
                  v161[1] = 3221225472;
                  v161[2] = sub_10010CFD4;
                  v161[3] = &unk_100231570;
                  v161[4] = &v163;
                  v161[5] = &v178;
                  v161[6] = a1;
                  dispatch_async(v94, v161);
                  _Block_object_dispose(&v178, 8);
                  _Block_object_dispose(&v163, 8);
                }
                else
                {
                  v127 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
                  objc_autoreleasePoolPop(v127);
                }
              }
            }
          }
          goto LABEL_119;
        }
      }
      if (!a3)
        goto LABEL_119;
      goto LABEL_117;
    }
LABEL_96:
    if (a3)
      goto LABEL_97;
    goto LABEL_103;
  }
  if (!sub_10000BE8C((uint64_t)v43) || !sub_10002BE64((uint64_t)a3, CFSTR("JOINING_FROM_UI")))
  {
    v64 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Same SSID %@ and EAP network. Skip disassociation.", sub_10002B088(v43));
    objc_autoreleasePoolPop(v64);
    context = 0;
    v58 = 0;
    v65 = 1;
    goto LABEL_106;
  }
  if (*(_QWORD *)(a1 + 240))
  {
    *(_QWORD *)&v163 = 0;
    *((_QWORD *)&v163 + 1) = &v163;
    *(_QWORD *)&v164 = 0x2020000000;
    *((_QWORD *)&v164 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (cf)
      v57 = CFRetain(cf);
    else
      v57 = 0;
    *((_QWORD *)&v164 + 1) = v57;
    v178 = 0;
    v179 = &v178;
    v180 = 0x2020000000;
    v181 = (void *)0xAAAAAAAAAAAAAAAALL;
    v181 = (void *)CFRetain(v43);
    CFRetain((CFTypeRef)a1);
    v125 = *(NSObject **)(a1 + 240);
    v175[0] = _NSConcreteStackBlock;
    v175[1] = 3221225472;
    v175[2] = sub_10010CE9C;
    v175[3] = &unk_100231548;
    v175[4] = &v178;
    v175[5] = &v163;
    v175[6] = a1;
    v175[7] = v154;
    v175[8] = v155;
    dispatch_async(v125, v175);
    _Block_object_dispose(&v178, 8);
    _Block_object_dispose(&v163, 8);
  }
  else
  {
    v124 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerAssociateAsync");
    objc_autoreleasePoolPop(v124);
  }
  sub_1000FE648((uint64_t *)a1, 0, 0, 0);
  v126 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: joining from UI. Setting interface rank kSCNetworkServicePrimaryRankDefault", "WiFiDeviceManagerAssociateAsync");
  objc_autoreleasePoolPop(v126);
  sub_1000FE9FC(a1, v43);
  return 0;
}

void sub_10010C9D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  uint64_t v49;

  _Block_object_dispose((const void *)(v49 - 208), 8);
  _Block_object_dispose(&a49, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10010CA10(const void *a1)
{
  uint64_t result;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t (*v7)(const void *);
  const __CFDictionary *v8;
  const __CFAllocator *Default;
  __CFDictionary *MutableCopy;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  void *v19;
  __int128 v20;
  void *(*v21)(uint64_t);
  void *v22;
  uint64_t *v23;

  result = sub_10002DAB4((uint64_t)a1);
  if (!(_DWORD)result)
    return result;
  result = (uint64_t)sub_10002BE64((uint64_t)a1, CFSTR("ShareableEAPConfig"));
  if (!result)
    return result;
  v3 = sub_10002BE64((uint64_t)a1, CFSTR("ShareableEAPTrustExceptions"));
  if (v3)
  {
    v4 = v3;
    v5 = sub_10002B088(a1);
    EAPTLSSetTrustExceptionBindings(CFSTR("WirelessSSID"), v5, v4);
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network doesn't contain property kWiFiNetworkShareableEAPTrustExceptions, hopefully this network (%@) doesn't need them. Attempting to ingest anyway.", "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary", sub_10002B088(a1));
    objc_autoreleasePoolPop(v11);
  }
  if (!qword_10026D768)
  {
    v20 = off_100231BF0;
    v21 = 0;
    qword_10026D768 = _sl_dlopen(&v20, 0);
  }
  if (!qword_10026D768)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isEAP8021XAvailable() indicated the function doesn't exist. Soft link failed. EAP8021X deps missing.", "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary");
    objc_autoreleasePoolPop(v12);
    return 0;
  }
  v6 = sub_10002BE64((uint64_t)a1, CFSTR("ShareableEAPConfig"));
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v7 = (uint64_t (*)(const void *))off_10026D770;
  v19 = off_10026D770;
  if (!off_10026D770)
  {
    *(_QWORD *)&v20 = _NSConcreteStackBlock;
    *((_QWORD *)&v20 + 1) = 3221225472;
    v21 = sub_10013E960;
    v22 = &unk_100230858;
    v23 = &v16;
    sub_10013E960((uint64_t)&v20);
    v7 = (uint64_t (*)(const void *))v17[3];
  }
  _Block_object_dispose(&v16, 8);
  if (!v7)
    sub_1001876A8();
  v8 = (const __CFDictionary *)v7(v6);
  if (!v8)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v15 = sub_10002B088(a1);
      objc_msgSend(v14, "WFLog:message:", 3, "%s: soft_EAPClientConfigurationCopyAndImport() returned NULL. BAIL (SSID: %@)", "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary", v15, v16);
    }
    objc_autoreleasePoolPop(v13);
    return 0;
  }
  Default = CFAllocatorGetDefault();
  MutableCopy = CFDictionaryCreateMutableCopy(Default, 0, v8);
  CFDictionarySetValue(MutableCopy, CFSTR("EAPClientConfiguration"), v8);
  CFDictionarySetValue(MutableCopy, CFSTR("EnableUserInterface"), kCFBooleanFalse);
  sub_10002C478((uint64_t)a1, CFSTR("EnterpriseProfile"), MutableCopy);
  sub_10002C478((uint64_t)a1, CFSTR("ShareableEAPConfig"), 0);
  sub_10002C478((uint64_t)a1, CFSTR("ShareableEAPTrustExceptions"), 0);
  CFRelease(v8);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return 1;
}

void sub_10010CD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10010CD3C(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 48))();
    v2 = *(_QWORD **)(a1 + 32);
  }
  CFRelease(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

void sub_10010CD98(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD **)(a1 + 48);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 56))();
    v2 = *(_QWORD **)(a1 + 48);
  }
  CFRelease(v2);
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v4)
    CFRelease(v4);
}

void sub_10010CE1C(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = a1[6];
  if (*(_QWORD *)(v2 + 240))
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v2 + 4104))(v2, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24), *(_QWORD *)(v2 + 4112), *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24));
    v2 = a1[6];
  }
  CFRelease((CFTypeRef)v2);
  v3 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(*(_QWORD *)(a1[5] + 8) + 24);
  if (v4)
    CFRelease(v4);
}

void sub_10010CE9C(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD **)(a1 + 48);
  if (v2[30])
  {
    v3 = a1 + 40;
    (*(void (**)(void))(a1 + 56))();
    CFRetain(*(CFTypeRef *)(a1 + 48));
    v4 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24);
    if (!v5)
      return;
LABEL_10:
    CFRelease(v5);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24) = 0;
    return;
  }
  CFRelease(v2);
  v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v8 = *(_QWORD *)(a1 + 40);
  v7 = a1 + 40;
  v5 = *(const void **)(*(_QWORD *)(v8 + 8) + 24);
  if (v5)
  {
    v3 = v7;
    goto LABEL_10;
  }
}

void sub_10010CF74(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setJoinEvent:withReason:lastDisconnectReason:lastJoinFailure:andNetworkDetails:forInterface:", 0, 0, 1008, 0, a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

void sub_10010CFD4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(a1 + 48);
  if (*(_QWORD *)(v2 + 240))
  {
    v3 = a1 + 40;
    (*(void (**)(uint64_t, _QWORD, const __CFString *, _QWORD, _QWORD))(v2 + 4744))(v2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), CFSTR("LinkDownTimestamp"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(v2 + 4752));
    CFRelease(*(CFTypeRef *)(a1 + 48));
    v4 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24);
    if (!v5)
      return;
LABEL_10:
    CFRelease(v5);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24) = 0;
    return;
  }
  CFRelease((CFTypeRef)v2);
  v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v8 = *(_QWORD *)(a1 + 40);
  v7 = a1 + 40;
  v5 = *(const void **)(*(_QWORD *)(v8 + 8) + 24);
  if (v5)
  {
    v3 = v7;
    goto LABEL_10;
  }
}

void sub_10010D0B0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  void *v4;
  const void *v5;
  void *v6;
  void *v7;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 6280))
    {
      v3 = *(_QWORD *)(v1 + 4552);
      v4 = objc_autoreleasePoolPush();
      if (v3)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerDelayedAutoJoinNotification", "__WiFiDeviceManagerDelayedAutoJoinNotification");
        objc_autoreleasePoolPop(v4);
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(v1 + 4552))(v1, 3, 0, *(_QWORD *)(v1 + 4560));
        goto LABEL_12;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerDelayedAutoJoinNotification");
      v6 = v4;
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto-join is disabled.", "__WiFiDeviceManagerDelayedAutoJoinNotification");
      v6 = v7;
    }
    objc_autoreleasePoolPop(v6);
LABEL_12:
    v5 = *(const void **)(a1 + 32);
    goto LABEL_13;
  }
  v5 = *(const void **)(a1 + 32);
LABEL_13:
  CFRelease(v5);
}

NSDictionary *__cdecl sub_10010D1C4(id a1, id a2)
{
  CFDictionaryRef v2;

  v2 = sub_1000173C0((uint64_t)a2);
  return (NSDictionary *)(id)CFMakeCollectable(v2);
}

void sub_10010D1E0(uint64_t a1)
{
  id v2;
  id v3;

  v2 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyColocatedScopeIdForNetwork:", a1);
  if (v2)
  {
    v3 = v2;
    sub_10002C478(a1, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), v2);

  }
}

void sub_10010D248(uint64_t a1, const void *a2)
{
  int v4;
  const void *v5;
  void *v6;
  const __CFArray *v7;
  CFIndex Count;
  void *v9;
  const void *v10;
  NSString *v11;
  void *v12;
  CFIndex i;
  const void *ValueAtIndex;

  v4 = sub_10007946C(*(_QWORD *)(a1 + 64));
  if (a2 && v4)
  {
    v5 = sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID"));
    if (v5)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Assign ScopeID for %@", "__WiFiDeviceManagerAssignColocatedGroupScopeID", sub_10002B088(a2));
      objc_autoreleasePoolPop(v6);
    }
    v7 = *(const __CFArray **)(a1 + 3736);
    if (v7)
      Count = CFArrayGetCount(v7);
    else
      Count = 0;
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated Network Count = %ld ", "__WiFiDeviceManagerAssignColocatedGroupScopeID", Count);
    objc_autoreleasePoolPop(v9);
    if (v5 || (v10 = *(const void **)(a1 + 3752)) == 0)
    {
      if (!v5)
      {
        v11 = -[NSUUID UUIDString](+[NSUUID UUID](NSUUID, "UUID"), "UUIDString");
        if (!v11)
          return;
        v5 = v11;
        sub_10002C478((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), v11);
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Configured ColocatedScopeId for %@ - '%@'", "__WiFiDeviceManagerAssignColocatedGroupScopeID", sub_10002B088(a2), v5);
        objc_autoreleasePoolPop(v12);
        *(_QWORD *)(a1 + 3752) = objc_msgSend(objc_alloc((Class)NSString), "initWithString:", v5);
      }
    }
    else
    {
      sub_10002C478((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), *(const void **)(a1 + 3752));
      v5 = v10;
    }
    if (*(_BYTE *)(a1 + 3744) == 1 && sub_100121218(a1, (uint64_t)a2) && Count > 0)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), i);
        if (ValueAtIndex)
          sub_10002C478((uint64_t)ValueAtIndex, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), v5);
      }
    }
  }
}

void sub_10010D444(uint64_t a1, const void *a2, void *a3, const void *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v11;
  void *v12;
  int *v13;
  _BOOL4 v14;
  id v15;
  void *v16;
  WiFiPerfPerAssoc *v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  CFStringRef v27;
  CFStringRef v28;
  const void *v29;
  const void *v30;
  CFStringRef v31;
  CFStringRef v32;
  CFAbsoluteTime Current;
  CFDateRef v34;
  CFDateRef v35;
  void *v36;
  const void *v37;
  CFAbsoluteTime v38;
  CFDateRef v39;
  id v40;
  void *v41;
  uint64_t v42;
  double v43;
  CLLocationDegrees v44;
  double v45;
  CLLocationDegrees v46;
  double v47;
  const void *v48;
  void *v49;
  CFBooleanRef v50;
  void *v51;
  const void *v52;
  unsigned int v53;
  NSObject *v54;
  void *v55;
  CFTypeRef v56;
  NSObject *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  const void *v62;
  const void *v63;
  uint64_t v64;
  const void *v65;
  const void *v66;
  CFTypeID TypeID;
  BOOL v68;
  const __CFData *Value;
  unsigned int v70;
  int *v71;
  const void *v72;
  unsigned int v73;
  unsigned int v74;
  CFTypeRef v75;
  NSObject *v76;
  const __CFBoolean *v77;
  CFTypeRef v78;
  NSObject *v79;
  void *v80;
  void (*v81)(uint64_t, const void *, void *, const void *, uint64_t, _QWORD);
  uint64_t v82;
  const void *v83;
  void *v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  const void *v88;
  const void *v89;
  _BOOL4 v90;
  void *context;
  _QWORD v92[6];
  _QWORD v93[6];
  _QWORD v94[6];
  int v95;
  _QWORD block[8];
  int v97;
  _QWORD v98[5];
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  __CFArray *v102;
  _QWORD v103[5];
  int v104;

  context = objc_autoreleasePoolPush();
  v11 = *(_QWORD *)a6;
  if (a6[9] == 1)
  {
    --*(_DWORD *)(v11 + 3480);
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: did decrement user join counter (%d)", "__WiFiDeviceManagerClientAssociateCallback", *(unsigned int *)(v11 + 3480));
    objc_autoreleasePoolPop(v12);
  }
  sub_10001E764(*(_QWORD *)(v11 + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%p"), CFSTR("UserJoin"), a6), 0);
  v13 = &OBJC_IVAR___WiFiNOIManager__sortedTopHomeNetworks;
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "associationDoneWithNetwork:error:interfaceName:", a3, a5, a2);
  if (!(_DWORD)a5)
  {
    v14 = a3 != 0;
    if (!a3)
    {
LABEL_85:
      sub_1000F9DAC((char *)v11, 1, 1);
      sub_1001269DC(v11, a3);
      goto LABEL_86;
    }
    v15 = sub_100027D10((uint64_t)a3);
    objc_msgSend(*(id *)(v11 + 6648), "removeNetworkDenyListInfoWithReason:forScanResult:", 1, v15);
    objc_msgSend(*(id *)(v11 + 6648), "removeNetworkDenyListInfoForTrigger:forNetwork:", 0, v15);

    sub_1001328A8(v11, a3, 0);
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: joined %@, reason type %d", "__WiFiDeviceManagerClientAssociateCallback", sub_10002B088(a3), a6[8]);
    objc_autoreleasePoolPop(v16);
    if (+[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance"))
    {
      v99 = 0;
      v100 = &v99;
      v101 = 0x2020000000;
      v102 = (__CFArray *)0xAAAAAAAAAAAAAAAALL;
      v102 = sub_1000774C0(*(_QWORD *)(v11 + 64));
      v17 = +[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance");
      v18 = v100[3];
      v98[0] = _NSConcreteStackBlock;
      v98[1] = 3221225472;
      v98[2] = sub_100136010;
      v98[3] = &unk_100230858;
      v98[4] = &v99;
      -[WiFiPerfPerAssoc ingestScanResults:currentSSID:andReply:](v17, "ingestScanResults:currentSSID:andReply:", v18, sub_10002B088(a3), v98);
      _Block_object_dispose(&v99, 8);
    }
    sub_100125A48(v11, a3, 0);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v19 = sub_10002B088(a3);
      if (v19)
        objc_msgSend(*(id *)(v11 + 8896), "removeObjectForKey:", v19);
    }
    v20 = *(const void **)(v11 + 3440);
    if (v20)
    {
      CFRelease(v20);
      *(_QWORD *)(v11 + 3440) = 0;
    }
    v21 = (const void *)*((_QWORD *)a6 + 3);
    if (v21)
    {
      CFRetain(v21);
      *(_BYTE *)(v11 + 3413) = 1;
      *(_QWORD *)(v11 + 3440) = *((_QWORD *)a6 + 3);
      *(_DWORD *)(v11 + 3392) = -1;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        v22 = (const void *)*((_QWORD *)a6 + 3);
        if (v22)
        {
          v23 = sub_10002BE64((uint64_t)a3, CFSTR("addedAt"));
          v24 = sub_10002BE64((uint64_t)v22, CFSTR("addedAt"));
          if (v23)
          {
            if (v24 && *(_QWORD *)(v11 + 4520))
            {
              v25 = sub_1000C9A4C((uint64_t)a3);
              v26 = sub_10002B088(a3);
              v27 = v25
                  ? CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("'%@' (%@)"), v26, v25)
                  : CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("'%@'"), v26, v86);
              v28 = v27;
              if (v27)
              {
                v88 = a4;
                v29 = sub_1000C9A4C((uint64_t)v22);
                v30 = sub_10002B088(v22);
                if (v29)
                  v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("'%@' (%@)"), v30, v29);
                else
                  v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("'%@'"), v30, v87);
                v32 = v31;
                if (v31)
                {
                  Current = CFAbsoluteTimeGetCurrent();
                  v34 = CFDateCreate(kCFAllocatorDefault, Current);
                  if (v34)
                  {
                    v35 = v34;
                    v36 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting user-defined network priority %@ as more-preferred than previous network %@", "__WiFiDeviceManagerUpdateNetworkUserPriority", v28, v32);
                    objc_autoreleasePoolPop(v36);
                    sub_1000CF518((uint64_t)v22, (CFDictionaryRef *)a3, v35);
                    sub_1001053C8((NSObject **)v11, v22);
                    CFRelease(v35);
                  }
                  CFRelease(v28);
                }
                else
                {
                  v32 = v28;
                }
                CFRelease(v32);
                a4 = v88;
              }
            }
          }
        }
        v37 = sub_10002B088(*((const void **)a6 + 3));
        if (v37)
          objc_msgSend(*(id *)(v11 + 8896), "removeObjectForKey:", v37);
      }
    }
    v38 = CFAbsoluteTimeGetCurrent();
    v39 = CFDateCreate(kCFAllocatorDefault, v38);
    if (v39)
      sub_1000C69F0(a3, 1, v39);
    if (!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      goto LABEL_49;
    v40 = sub_100009ACC(v11);
    if (v40)
    {
      v41 = v40;
      v42 = *(_QWORD *)(v11 + 6792);
      objc_msgSend(v40, "coordinate");
      v44 = v43;
      objc_msgSend(v41, "coordinate");
      v46 = v45;
      objc_msgSend(v41, "horizontalAccuracy");
      sub_1000A10CC(v42, a3, v44, v46, v47, objc_msgSend(v41, "timestamp"));

    }
    if (v39 && *(_BYTE *)(v11 + 3414))
    {
      v48 = a4;
      sub_1000C79E0(a3, v39);
    }
    else
    {
LABEL_49:
      v48 = a4;
      if (!v39)
      {
LABEL_51:
        sub_1001327E4(v11, a3);
        if (*(_BYTE *)(v11 + 3412))
        {
          v49 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: tagging network %@ as moving", "__WiFiDeviceManagerClientAssociateCallback", sub_10002B088(a3));
          objc_autoreleasePoolPop(v49);
          sub_10002C478((uint64_t)a3, CFSTR("WiFiNetworkAttributeIsMoving"), kCFBooleanTrue);
          v50 = kCFBooleanFalse;
        }
        else
        {
          v50 = kCFBooleanFalse;
          sub_10002C478((uint64_t)a3, CFSTR("WiFiNetworkAttributeIsMoving"), kCFBooleanFalse);
        }
        sub_10002C478((uint64_t)a3, CFSTR("WiFiInstantHotspotJoining"), v50);
        sub_10002C478((uint64_t)a3, CFSTR("WiFiAutoInstantHotspotJoining"), v50);
        sub_100127E74((NSObject **)v11, a3, *(_DWORD *)(v11 + 3472), 0);
        v51 = sub_10002A21C(v11, a2, 1);
        a4 = v48;
        if (v51)
        {
          v52 = v51;
          v13 = &OBJC_IVAR___WiFiNOIManager__sortedTopHomeNetworks;
          if (*(_DWORD *)(v11 + 3472))
            sub_10002C478((uint64_t)v51, CFSTR("TransitionDisabledFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
          sub_1000FE5A4(v11, v52);
          sub_1000C71DC(a3, v52);
          CFRelease(v52);
        }
        else
        {
          sub_1000FE5A4(v11, a3);
          v13 = &OBJC_IVAR___WiFiNOIManager__sortedTopHomeNetworks;
        }
        v53 = a6[8];
        if (v53 == 1011 || v53 == 1008)
          *(_BYTE *)(v11 + 3413) = 1;
        if (*(_QWORD *)(v11 + 3920))
        {
          if (*(_QWORD *)(v11 + 240))
          {
            if (a2)
              CFRetain(a2);
            CFRetain(a3);
            if (a4)
              CFRetain(a4);
            CFRetain((CFTypeRef)v11);
            v54 = *(NSObject **)(v11 + 240);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_10013604C;
            block[3] = &unk_1002315D0;
            block[4] = v11;
            block[5] = a2;
            block[6] = a3;
            block[7] = a4;
            v97 = 0;
            dispatch_async(v54, block);
          }
          else
          {
            v55 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerClientAssociateCallback");
            objc_autoreleasePoolPop(v55);
          }
        }
        if (*(_QWORD *)(v11 + 3872))
        {
          if (*(_QWORD *)(v11 + 240))
          {
            v99 = 0;
            v100 = &v99;
            v101 = 0x2020000000;
            v102 = 0;
            v56 = CFRetain(a3);
            v100[3] = (uint64_t)v56;
            CFRetain((CFTypeRef)v11);
            v57 = *(NSObject **)(v11 + 240);
            v94[0] = _NSConcreteStackBlock;
            v94[1] = 3221225472;
            v94[2] = sub_1001360F0;
            v94[3] = &unk_100231908;
            v94[4] = &v99;
            v94[5] = v11;
            v95 = 0;
            dispatch_async(v57, v94);
            _Block_object_dispose(&v99, 8);
          }
          else
          {
            v58 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerClientAssociateCallback");
            objc_autoreleasePoolPop(v58);
          }
        }
        *(_WORD *)(v11 + 6600) = sub_1000FEEC0(v11, a3);
        v59 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: usage rank for %@ is now : %d", "__WiFiDeviceManagerClientAssociateCallback", sub_10002B088(a3), *(unsigned __int16 *)(v11 + 6600));
        objc_autoreleasePoolPop(v59);
        v60 = objc_autoreleasePoolPush();
        v61 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v62 = sub_10002B088(a3);
          objc_msgSend(v61, "WFLog:message:", 3, "%s: Submit metric to update scores for user switched to %@, and left %@", "__WiFiDeviceManagerClientAssociateCallback", v62, sub_10002B088(*((const void **)a6 + 3)));
        }
        objc_autoreleasePoolPop(v60);
        sub_10005DF4C(v11, a3, *((const void **)a6 + 3));
        v14 = 1;
        goto LABEL_85;
      }
    }
    CFRelease(v39);
    goto LABEL_51;
  }
  if (*(_QWORD *)(v11 + 7368))
  {
    v103[0] = _NSConcreteStackBlock;
    v103[1] = 3221225472;
    v103[2] = sub_100135FAC;
    v103[3] = &unk_100231500;
    v103[4] = v11;
    v104 = a5;
    sub_10010367C(v11, (const __CFDictionary **)a3, (uint64_t)v103);
  }
  v14 = a3 != 0;
  sub_1001147D4(v11, a3, 0);
  sub_1000F9DAC((char *)v11, 1, 0);
LABEL_86:
  sub_100132A2C(v11, a3);
  sub_100132B40(v11, (uint64_t)a3);
  v63 = sub_10002B634(*(const __CFArray **)(v11 + 3704), (const __CFDictionary **)a3);
  if ((_DWORD)a5 == -3924)
    goto LABEL_111;
  v64 = (uint64_t)v63;
  if (sub_10002B704((uint64_t)a3) || !v64)
  {
    if (!v64)
      goto LABEL_111;
  }
  else
  {
    v65 = sub_10002BE64(v64, CFSTR("PRIVATE_MAC_ADDRESS"));
    if (v65)
    {
      v66 = v65;
      v90 = v14;
      TypeID = CFDictionaryGetTypeID();
      v68 = TypeID == CFGetTypeID(v66);
      v14 = v90;
      if (v68)
      {
        Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v66, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
        v70 = sub_10002B75C(Value);
        if ((_DWORD)a5)
        {
          if (v70)
          {
            v89 = a2;
            v71 = v13;
            v72 = a4;
            v73 = sub_100017A54(v64, CFSTR("FailureCountCurrent"));
            v74 = sub_100017A54(v64, CFSTR("FailureCountThresholdCurrent"));
            if (*(_QWORD *)(v11 + 4744))
            {
              if (*(_QWORD *)(v11 + 240))
              {
                v99 = 0;
                v100 = &v99;
                v101 = 0x2020000000;
                v102 = 0;
                if (v90)
                {
                  v75 = CFRetain(a3);
                  v100[3] = (uint64_t)v75;
                }
                CFRetain((CFTypeRef)v11);
                v76 = *(NSObject **)(v11 + 240);
                v93[0] = _NSConcreteStackBlock;
                v93[1] = 3221225472;
                v93[2] = sub_10013618C;
                v93[3] = &unk_10022F160;
                v93[4] = &v99;
                v93[5] = v11;
                dispatch_async(v76, v93);
                _Block_object_dispose(&v99, 8);
              }
              else
              {
                v84 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerClientAssociateCallback");
                objc_autoreleasePoolPop(v84);
              }
            }
            v85 = v74 - v73;
            a4 = v72;
            v13 = v71;
            a2 = v89;
            v14 = v90;
            if (v85 == 1)
              sub_10002C478((uint64_t)a3, CFSTR("FailureThresholdMet"), kCFBooleanTrue);
          }
        }
      }
    }
  }
  if ((_DWORD)a5)
  {
    v77 = (const __CFBoolean *)sub_10002BE64(v64, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
    if (v77)
    {
      if (v77 == kCFBooleanTrue && *(_QWORD *)(v11 + 4712))
      {
        if (*(_QWORD *)(v11 + 240))
        {
          v99 = 0;
          v100 = &v99;
          v101 = 0x2020000000;
          v102 = 0;
          if (v14)
          {
            v78 = CFRetain(a3);
            v100[3] = (uint64_t)v78;
          }
          CFRetain((CFTypeRef)v11);
          v79 = *(NSObject **)(v11 + 240);
          v92[0] = _NSConcreteStackBlock;
          v92[1] = 3221225472;
          v92[2] = sub_100136214;
          v92[3] = &unk_10022F160;
          v92[4] = &v99;
          v92[5] = v11;
          dispatch_async(v79, v92);
          _Block_object_dispose(&v99, 8);
        }
        else
        {
          v80 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerClientAssociateCallback");
          objc_autoreleasePoolPop(v80);
        }
      }
    }
  }
LABEL_111:
  v81 = (void (*)(uint64_t, const void *, void *, const void *, uint64_t, _QWORD))*((_QWORD *)a6 + 1);
  if (v81)
    v81(v11, a2, a3, a4, a5, *((_QWORD *)a6 + 2));
  if ((_DWORD)a5 && *(_DWORD *)(v11 + 3280) != 14)
  {
    *(_DWORD *)(v11 + 192) = 7;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      if (*((_BYTE *)a6 + 48) == 1)
        v82 = 59;
      else
        v82 = 3;
      sub_1000285E4(v11, v82);
    }
    else
    {
      objc_msgSend(objc_msgSend(v13 + 826, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 3, a2);
      sub_1000FBA80(v11, 2, "__WiFiDeviceManagerClientAssociateCallback");
    }
  }
  sub_100127948(v11);
  v83 = (const void *)*((_QWORD *)a6 + 3);
  if (v83)
  {
    CFRelease(v83);
    *((_QWORD *)a6 + 3) = 0;
  }
  free(a6);
  objc_autoreleasePoolPop(context);
}

void sub_10010E19C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

void sub_10010E1C0(uint64_t a1, const void *a2)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  const void *v10;
  const char *v11;
  void *v12;
  uint64_t v13;
  const void *v14;
  const void *v15;

  if (!a1 || !a2)
  {
    v8 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v14 = (const void *)a1;
    v15 = a2;
    v11 = "%s: bad args: manager %p network %p";
    goto LABEL_21;
  }
  v4 = (unsigned int *)(a1 + 6580);
  if (*(_DWORD *)(a1 + 6580))
  {
    v8 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v14 = (const void *)*v4;
    v11 = "%s: PM assertion already acquired with ID:%d";
LABEL_21:
    v13 = 4;
LABEL_15:
    objc_msgSend(v12, "WFLog:message:", v13, v11, "__WiFiDeviceManagerAcquireWakeAssertionForAutoJoin", v14, v15);
LABEL_16:
    objc_autoreleasePoolPop(v8);
    return;
  }
  if (sub_1000C5378((uint64_t)a2) && (sub_10002DAB4((uint64_t)a2) || sub_1000C5964((uint64_t)a2)))
  {
    v5 = IOPMAssertionCreateWithName(CFSTR("NoIdleSleepAssertion"), 0xFFu, CFSTR("com.apple.wifi-autojoin"), (IOPMAssertionID *)(a1 + 6580));
    if ((_DWORD)v5)
    {
      v6 = v5;
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to prevent idle sleep during autojoin, error=%d", "__WiFiDeviceManagerAcquireWakeAssertionForAutoJoin", v6);
      objc_autoreleasePoolPop(v7);
      *(_DWORD *)(a1 + 6580) = 0;
      *(_QWORD *)(a1 + 6584) = 0;
    }
    else
    {
      *(CFAbsoluteTime *)(a1 + 6584) = CFAbsoluteTimeGetCurrent();
      *(_QWORD *)(a1 + 6592) = CFRetain(a2);
    }
    v8 = objc_autoreleasePoolPush();
    v9 = qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v10 = sub_10002B088(a2);
    v15 = *(const void **)(a1 + 6584);
    v14 = v10;
    v11 = "%s: wake assertion held for network %@ current timestamp:%f";
    v12 = (void *)v9;
    v13 = 3;
    goto LABEL_15;
  }
}

void sub_10010E378(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setJoinEvent:withReason:lastDisconnectReason:lastJoinFailure:andNetworkDetails:forInterface:", 1, *(_QWORD *)(a1 + 40), 0, 0, a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

uint64_t sub_10010E3D8(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  const void *v13;

  v10 = (uint64_t *)malloc_type_malloc(0x38uLL, 0x10E0040400D9003uLL);
  if (!v10)
    return 4294963395;
  v11 = v10;
  sub_1000FB44C(a1);
  *(_BYTE *)(a1 + 248) = 1;
  *v11 = a1;
  v11[1] = a4;
  v11[5] = a5;
  v11[3] = (uint64_t)CFRetain(a3);
  *((_DWORD *)v11 + 8) = 1;
  v12 = sub_100069F18(*(_QWORD *)(a1 + 64), a2, a3, (uint64_t)sub_10010E4BC, (uint64_t)v11);
  if ((_DWORD)v12)
  {
    v13 = (const void *)v11[3];
    if (v13)
      CFRelease(v13);
    free(v11);
    sub_100069FBC(*(_QWORD *)(a1 + 64), a2, 0, 0);
  }
  return v12;
}

void sub_10010E4BC(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7;
  _WORD *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  void (*v11)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  CFTypeRef v12;

  v7 = (uint64_t)*a4;
  v8 = sub_10002B314((uint64_t)kCFAllocatorDefault, a4[3]);
  if (v8)
  {
    v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a4 + 4);
    if (v9)
    {
      v10 = v9;
      sub_10002C478((uint64_t)v8, CFSTR("networkRole"), v9);
      CFRelease(v10);
    }
    if (!(_DWORD)a3)
    {
      CFSetAddValue(*(CFMutableSetRef *)(v7 + 3320), v8);
      goto LABEL_8;
    }
  }
  else if (!(_DWORD)a3)
  {
    goto LABEL_8;
  }
  sub_10010E5C0(v7, a2, (uint64_t)v8, 0, 0);
LABEL_8:
  v11 = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a4[1];
  if (v11)
    v11(v7, a2, a3, v8, 0, a4[5]);
  v12 = a4[3];
  if (v12)
  {
    CFRelease(v12);
    a4[3] = 0;
  }
  if (v8)
    CFRelease(v8);
  free(a4);
}

uint64_t sub_10010E5C0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  v10 = malloc_type_malloc(0x20uLL, 0xA004088793A40uLL);
  *(_BYTE *)(a1 + 248) = 0;
  *v10 = a1;
  v10[1] = a4;
  v10[2] = a3;
  v10[3] = a5;
  v11 = sub_100069FBC(*(_QWORD *)(a1 + 64), a2, (uint64_t)sub_10010E6DC, (uint64_t)v10);
  if ((_DWORD)v11)
  {
    v12 = v11;
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to stop network (%d). deviceManager=%p", v12, a1);
    objc_autoreleasePoolPop(v13);
  }
  *(_DWORD *)(a1 + 192) = 8;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_1000285E4(a1, 11);
  }
  else
  {
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 11, a2);
    sub_1000FBA80(a1, 2, "WiFiDeviceManagerStopAdHocNetwork");
  }
  return 0;
}

void sub_10010E6DC(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  void (*v5)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v6;

  v6 = *a4;
  v5 = (void (*)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD))a4[1];
  if (v5)
    v5(*a4, a2, a3, 0, a4[3]);
  CFSetRemoveValue(*(CFMutableSetRef *)(v6 + 3320), (const void *)a4[2]);
  free(a4);
}

uint64_t sub_10010E720(uint64_t a1, const void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  _QWORD *v11;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v13;
  const __CFBoolean *Value;
  const __CFString *Mutable;
  _BOOL8 v16;
  BOOL v17;
  uint64_t v18;
  CFComparisonResult v19;
  uint64_t v21;
  const void *v22;
  const void *v23;
  void *v24;
  uint64_t v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  void *v33;
  void *v34;
  uint64_t v35;
  _BOOL8 v36;
  CFNumberRef v37;
  void *v38;
  uint64_t v39;
  char v40;
  char v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  void *v46;
  void *v48;
  int *v49;
  uint64_t v50;
  char v51;
  char v52;
  char v53;
  uint64_t v54;
  char v55;
  int v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  uint64_t v61;
  int v62;
  const __CFDictionary *v63;
  __CFDictionary *v64;
  const void *v65;
  _BOOL8 v66;
  _OWORD v67[10];
  uint64_t v68;
  unsigned int valuePtr[4];

  v10 = malloc_type_malloc(0x38uLL, 0x10E0040400D9003uLL);
  if (!v10)
  {
    v57 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null startData", "WiFiDeviceManagerStartWiFiDirectGroup");
    objc_autoreleasePoolPop(v57);
    return 4294963395;
  }
  if (!a3)
  {
    v58 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null request", "WiFiDeviceManagerStartWiFiDirectGroup");
    objc_autoreleasePoolPop(v58);
    return 4294963396;
  }
  v11 = v10;
  *v10 = a1;
  v10[1] = a4;
  v10[5] = a5;
  *((_DWORD *)v10 + 8) = 3;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a3);
  if (!MutableCopy)
  {
    v59 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null hostAPDictionary", "WiFiDeviceManagerStartWiFiDirectGroup");
    objc_autoreleasePoolPop(v59);
    return 4294963394;
  }
  v13 = MutableCopy;
  v11[3] = CFRetain(MutableCopy);
  Value = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("AP_MODE_MOVETOIOS_MIGRATION"));
  if (!Value || Value != kCFBooleanTrue)
    goto LABEL_65;
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  LODWORD(v67[0]) = 0;
  *(_QWORD *)valuePtr = 0;
  v66 = 0;
  if (!sub_100032160(*(_QWORD *)(a1 + 64), (uint64_t)Mutable))
  {
    v16 = CFStringCompare(Mutable, CFSTR("XZ"), 0) == kCFCompareEqualTo
       || CFStringCompare(Mutable, &stru_100238178, 0) == kCFCompareEqualTo
       || CFStringCompare(Mutable, CFSTR("JP"), 0) == kCFCompareEqualTo
       || CFStringCompare(Mutable, CFSTR("TN"), 0) == kCFCompareEqualTo
       || CFStringCompare(Mutable, CFSTR("YE"), 0) == kCFCompareEqualTo;
    v66 = v16;
  }
  v64 = v13;
  v65 = a2;
  v17 = sub_100136288(Mutable);
  v18 = 0;
  do
  {
    v19 = CFStringCompare(Mutable, off_100231928[v18], 0);
    if (v19 == kCFCompareEqualTo)
      break;
  }
  while (v18++ != 37);
  v21 = *(_QWORD *)(a1 + 64);
  v22 = (const void *)sub_100068E60(v21);
  v61 = sub_100074164(v21, v22, valuePtr);
  v23 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v24 = sub_10002A21C(a1, v23, 1);
  v25 = (uint64_t)v24;
  v63 = a3;
  if (!v24)
  {
    v28 = 0;
    v29 = 0;
    v30 = 0;
LABEL_31:
    v31 = 0;
    goto LABEL_32;
  }
  v26 = (const __CFNumber *)sub_10002BE64((uint64_t)v24, CFSTR("CHANNEL"));
  v27 = (const __CFNumber *)sub_10002BE64(v25, CFSTR("CHANNEL_FLAGS"));
  if (v27)
    CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr[1]);
  if (v26)
    CFNumberGetValue(v26, kCFNumberSInt32Type, v67);
  if ((valuePtr[1] & 8) != 0)
  {
    v29 = 0;
    v30 = 0;
    v28 = 1;
  }
  else
  {
    v28 = 0;
    if ((valuePtr[1] & 0x10) != 0)
    {
      v30 = 0;
      v29 = 1;
    }
    else
    {
      v29 = 0;
      v30 = (valuePtr[1] >> 13) & 1;
    }
  }
  if (!sub_100071668(*(_QWORD *)(a1 + 64)))
    goto LABEL_31;
  v31 = (valuePtr[1] >> 11) & 1;
LABEL_32:
  if (v31 | v30)
    v32 = 1;
  else
    v32 = v66;
  if ((v32 & 1) != 0
    || v25 && v29 && sub_10006E2B4(*(_QWORD *)(a1 + 64), v67[0])
    || *(_BYTE *)(a1 + 3414))
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v62 = v28;
      v35 = sub_100071668(*(_QWORD *)(a1 + 64));
      v36 = 0;
      if (v25 && v29)
        v36 = sub_10006E2B4(*(_QWORD *)(a1 + 64), v67[0]) != 0;
      objc_msgSend(v34, "WFLog:message:", 3, "MIGRATION: %s Starting SoftAp on 2.4GHz (RegulatoryRestricted: %d, Infra6G: %d, InfraBWHigherThan80MHz:%d, isChip160MHzCapable:%d, Infra5G_DFS:%d AWDLRealTimeMode:%d)", "__WiFiDeviceManagerSelectPHChannel", v66, v30, v31, v35, v36, *(unsigned __int8 *)(a1 + 3414));
      v28 = v62;
    }
    objc_autoreleasePoolPop(v33);
    if (v25 && v28)
    {
      v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v67);
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION: Selecting 2.4G infra channel :%d ", LODWORD(v67[0]));
      v13 = v64;
    }
    else
    {
      v39 = 0;
      v13 = v64;
      while (!sub_10006E3B0(*(_QWORD *)(a1 + 64), dword_10026CCDC[v39]))
      {
        if (++v39 == 3)
          goto LABEL_53;
      }
      v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &dword_10026CCDC[v39]);
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION: Selecting 2G  channel :%d\n", dword_10026CCDC[v39]);
    }
    objc_autoreleasePoolPop(v38);
    if (!v37)
      goto LABEL_53;
    goto LABEL_58;
  }
  if (v29 && !(_DWORD)v61)
  {
    v48 = objc_autoreleasePoolPush();
    v13 = v64;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION: Selecting 5G infra channel :%d ", LODWORD(v67[0]));
    v49 = (int *)v67;
    goto LABEL_79;
  }
  v50 = 0;
  if (v19)
    v51 = v17;
  else
    v51 = 1;
  v52 = 1;
  v13 = v64;
  while (1)
  {
    v53 = v52;
    v49 = &dword_10026CCE8[v50];
    if (!sub_10006E3B0(*(_QWORD *)(a1 + 64), *v49))
      goto LABEL_95;
    v54 = *v49;
    if ((_DWORD)v54 != 138)
      break;
    if ((v51 & 1) == 0)
      goto LABEL_93;
LABEL_95:
    v52 = 0;
    v50 = 1;
    if ((v53 & 1) == 0)
      goto LABEL_53;
  }
  if ((v54 - 142) < 0x18)
    v55 = v51;
  else
    v55 = 0;
  if ((v55 & 1) != 0)
    goto LABEL_95;
LABEL_93:
  v56 = sub_1001102D8(a1, v54);
  if (v19 && v56)
    goto LABEL_95;
  v48 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION: Selecting 5G  channel :%d  AwdlActive: %d", *v49, v61);
LABEL_79:
  objc_autoreleasePoolPop(v48);
  v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v49);
  if (v37)
  {
LABEL_58:
    CFDictionarySetValue(v13, CFSTR("CHANNEL"), v37);
    if (Mutable)
      CFRelease(Mutable);
    v40 = 1;
    Mutable = (const __CFString *)v37;
    a2 = v65;
    goto LABEL_61;
  }
LABEL_53:
  v40 = 0;
  v41 = 0;
  a2 = v65;
  if (Mutable)
  {
LABEL_61:
    CFRelease(Mutable);
    v41 = v40;
  }
  v42 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION:%s: END print request  dictionary %@ and hostAPDict: %@", "WiFiDeviceManagerStartWiFiDirectGroup", v63, v13);
  objc_autoreleasePoolPop(v42);
  if ((v41 & 1) != 0)
  {
LABEL_65:
    v43 = sub_10006A020(*(_QWORD *)(a1 + 64), a2, v13, (uint64_t)sub_10010EEE8, (uint64_t)v11);
    if ((_DWORD)v43)
    {
      v44 = v43;
      v68 = 0;
      memset(v67, 0, sizeof(v67));
      DWORD1(v67[0]) = 15;
      sub_100106C34(a1, (uint64_t)v67);
      v45 = (const void *)v11[3];
      if (v45)
        CFRelease(v45);
      free(v11);
    }
    else
    {
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: aborting ongoing auto-join on network start", "WiFiDeviceManagerStartWiFiDirectGroup");
      objc_autoreleasePoolPop(v46);
      sub_1000FB44C(a1);
      v44 = 0;
    }
  }
  else
  {
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIGRATION:%s: SoftAP failed to start", "WiFiDeviceManagerStartWiFiDirectGroup");
    objc_autoreleasePoolPop(v60);
    v44 = 4294963394;
  }
  CFRelease(v13);
  return v44;
}

void sub_10010EEE8(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7;
  _WORD *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  __n128 v11;
  void *v12;
  void (*v13)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __n128);
  CFTypeRef v14;
  _OWORD v15[10];
  uint64_t v16;

  v7 = (uint64_t)*a4;
  v8 = sub_10002B314((uint64_t)kCFAllocatorDefault, a4[3]);
  if (!v8)
  {
    if (!(_DWORD)a3)
      goto LABEL_8;
LABEL_7:
    v16 = 0;
    memset(v15, 0, sizeof(v15));
    DWORD1(v15[0]) = 16;
    v11.n128_f64[0] = sub_100106C34(v7, (uint64_t)v15);
    goto LABEL_11;
  }
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a4 + 4);
  if (v9)
  {
    v10 = v9;
    sub_10002C478((uint64_t)v8, CFSTR("networkRole"), v9);
    CFRelease(v10);
  }
  if ((_DWORD)a3)
    goto LABEL_7;
  CFSetAddValue(*(CFMutableSetRef *)(v7 + 3320), v8);
LABEL_8:
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: aborting ongoing auto-join on network start", "__WiFiDeviceManagerClientStartWiFiDirectGroupCallback");
  objc_autoreleasePoolPop(v12);
  sub_1000FB44C(v7);
LABEL_11:
  v13 = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __n128))a4[1];
  if (v13)
    v13(v7, a2, a3, v8, 0, a4[5], v11);
  v14 = a4[3];
  if (v14)
  {
    CFRelease(v14);
    a4[3] = 0;
  }
  if (v8)
    CFRelease(v8);
  free(a4);
}

void sub_10010F05C(int a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  void (*v5)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v6;
  const void *v7;
  const void *v8;

  v6 = *a4;
  v5 = (void (*)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD))a4[1];
  if (v5)
    v5(*a4, a2, a3, 0, a4[3]);
  v7 = (const void *)a4[2];
  if (v7)
  {
    if (CFSetContainsValue(*(CFSetRef *)(v6 + 3320), v7))
      CFSetRemoveValue(*(CFMutableSetRef *)(v6 + 3320), (const void *)a4[2]);
    v8 = (const void *)a4[2];
    if (v8)
      CFRelease(v8);
  }
  free(a4);
}

uint64_t sub_10010F0C0(uint64_t a1, const __CFString *a2, int a3, const void *a4, uint64_t a5, uint64_t a6, const void *a7)
{
  if (a3 == 1)
    return sub_10010E3D8(a1, a2, a4, a5, a6);
  if ((a3 & 0xFFFFFFFE) == 2)
    return sub_10010E720(a1, a2, (const __CFDictionary *)a4, a5, a6);
  if (a3 == 4)
    return sub_10010F118(a1, a2, (const __CFDictionary *)a4, a5, a6, a7);
  return 4294963396;
}

uint64_t sub_10010F118(uint64_t a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, const void *a6)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  int v18;
  int v19;
  void *v20;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  CFTypeRef v25;
  _QWORD *v26;
  _QWORD *v27;
  CFTypeRef v28;
  void *v29;
  NSObject *v30;
  void *v31;
  CFTypeRef v32;
  void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  void *v37;
  _WORD *v38;
  const void *v39;
  void *v40;
  CFTypeRef v41;
  void *v42;
  uint64_t v43;
  const void *v44;
  const void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  _QWORD block[8];
  _QWORD v52[3];
  CFTypeRef v53;

  if (!a1)
    return 4294963396;
  if (sub_100107828(a1, 2))
  {
    if (!sub_100073FF0(*(_QWORD *)(a1 + 64), a2))
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: AWDL bringup requested while link state is down.", "WiFiDeviceManagerStartAwdl");
      objc_autoreleasePoolPop(v12);
    }
    if (!*(_DWORD *)(a1 + 5416))
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to start AWDL, thermal index (%d) is below disabled threshold (%d).", "WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5416), 0);
      goto LABEL_33;
    }
    if (*(_BYTE *)(a1 + 3408) && CFDictionaryGetValue(a3, CFSTR("APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW")))
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to start AWDL in follow mode, VoIP Call Active.", "WiFiDeviceManagerStartAwdl");
      v14 = v13;
      goto LABEL_34;
    }
    if (*(_QWORD *)(a1 + 5408))
    {
      v17 = objc_autoreleasePoolPush();
      if ((objc_msgSend(*(id *)(a1 + 5408), "isPowerResourceAvailable:", 1) & 1) == 0)
      {
        v26 = malloc_type_malloc(0x38uLL, 0x10E0040400D9003uLL);
        if (v26)
        {
          v27 = v26;
          *v26 = a1;
          v26[1] = a4;
          v26[5] = a5;
          v26[2] = CFRetain(a2);
          if (a3)
            v28 = CFRetain(a3);
          else
            v28 = 0;
          v27[3] = v28;
          *((_DWORD *)v27 + 8) = 4;
          if (a6)
            v32 = CFRetain(a6);
          else
            v32 = 0;
          v27[6] = v32;
          v33 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt :  Power module is attached - checking for resource availability before starting AWDL.", "WiFiDeviceManagerStartAwdl");
          objc_autoreleasePoolPop(v33);
          v16 = (uint64_t)objc_msgSend(*(id *)(a1 + 5408), "requestPowerResource:withDetails:", 1, v27);
          objc_autoreleasePoolPop(v17);
          if ((_DWORD)v16)
          {
            v34 = (const void *)v27[2];
            if (v34)
            {
              CFRelease(v34);
              v27[2] = 0;
            }
            v35 = (const void *)v27[3];
            if (v35)
            {
              CFRelease(v35);
              v27[3] = 0;
            }
            v36 = (const void *)v27[6];
            if (v36)
            {
              CFRelease(v36);
              v27[6] = 0;
            }
            free(v27);
          }
        }
        else
        {
          objc_autoreleasePoolPop(v17);
          return 4294963395;
        }
        return v16;
      }
      objc_autoreleasePoolPop(v17);
    }
    v18 = sub_100074164(*(_QWORD *)(a1 + 64), a2, 0);
    v19 = v18;
    if (a3)
    {
      if (*(_DWORD *)(a1 + 5424))
      {
        if (v18)
        {
          if (CFDictionaryGetValue(a3, CFSTR("AWDL_INFO_ASSISTED_DISCOVERY_METRIC")))
          {
            if (!sub_10010A010(a1))
            {
              if (sub_10010A034(a1))
              {
                v38 = sub_10010FF88(a1, 2);
                if (v38)
                {
                  v39 = v38;
                  if (sub_10010FBD8(a1, a2, v38, 0, 0))
                  {
                    CFRelease(v39);
                    v40 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error trying to stop AWDL in Follow Mode.", "WiFiDeviceManagerStartAwdl");
                  }
                  else
                  {
                    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 3320), v39);
                    v40 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL in Follow Mode. Exit Follow Mode", "WiFiDeviceManagerStartAwdl");
                  }
                  objc_autoreleasePoolPop(v40);
                }
              }
            }
          }
        }
      }
    }
    if (*(_DWORD *)(a1 + 5424) && v19)
    {
      if (a3
        && CFDictionaryGetValue(a3, CFSTR("APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW"))
        && sub_10010A010(a1))
      {
        v20 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL is already started in Assisted Discovery. Follow Mode not allowed. Refcount=%d", "WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5424), v50);
LABEL_33:
        v14 = v20;
LABEL_34:
        objc_autoreleasePoolPop(v14);
        return 4294963366;
      }
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL is already started. Refcount=%d. Invoking client network started callback.", "WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5424));
      objc_autoreleasePoolPop(v29);
      if (*(_QWORD *)(a1 + 240))
      {
        v52[0] = 0;
        v52[1] = v52;
        v52[2] = 0x2020000000;
        v53 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        v53 = CFRetain(a2);
        CFRetain((CFTypeRef)a1);
        v30 = *(NSObject **)(a1 + 240);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1001100B0;
        block[3] = &unk_10022EB28;
        block[4] = v52;
        block[5] = a1;
        block[6] = a4;
        block[7] = a5;
        dispatch_async(v30, block);
        _Block_object_dispose(v52, 8);
      }
      else
      {
        v37 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerStartAwdl");
        objc_autoreleasePoolPop(v37);
      }
      goto LABEL_92;
    }
    if (sub_100107828(a1, 2))
    {
      if (!sub_100073FF0(*(_QWORD *)(a1 + 64), a2))
      {
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: AWDL bringup requested while link state is down.", "__WiFiDeviceManagerRequestAwdlBringup");
        objc_autoreleasePoolPop(v22);
      }
      v23 = malloc_type_malloc(0x38uLL, 0x10E0040400D9003uLL);
      if (v23)
      {
        v24 = (uint64_t)v23;
        *v23 = a1;
        v23[1] = a4;
        v23[5] = a5;
        if (a3)
          v25 = CFRetain(a3);
        else
          v25 = 0;
        *(_QWORD *)(v24 + 24) = v25;
        *(_DWORD *)(v24 + 32) = 4;
        if (a6)
          v41 = CFRetain(a6);
        else
          v41 = 0;
        *(_QWORD *)(v24 + 48) = v41;
        v42 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hosting AWDL session. Aborting auto-join", "__WiFiDeviceManagerRequestAwdlBringup");
        objc_autoreleasePoolPop(v42);
        sub_1000FB44C(a1);
        sub_1000750A0(*(_QWORD *)(a1 + 64));
        v43 = sub_10006AFEC(*(_QWORD *)(a1 + 64), a2, a3, (uint64_t)sub_10013A068, v24, a6);
        if (!(_DWORD)v43)
        {
          *(_BYTE *)(a1 + 5429) = 1;
          sub_1000F9DAC((char *)a1, 2, 1);
LABEL_92:
          ++*(_DWORD *)(a1 + 5424);
          v47 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL refCount is now [%d].", "WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5424));
          objc_autoreleasePoolPop(v47);
          if (*(_DWORD *)(a1 + 5424) != 1)
            return 0;
          v48 = *(void **)(a1 + 5432);
          if (v48)

          v16 = 0;
          *(_QWORD *)(a1 + 5432) = sub_10001E1C8((uint64_t)"WiFiDeviceManagerStartAwdl");
          return v16;
        }
        v16 = v43;
        v44 = *(const void **)(v24 + 24);
        if (v44)
        {
          CFRelease(v44);
          *(_QWORD *)(v24 + 24) = 0;
        }
        v45 = *(const void **)(v24 + 48);
        if (v45)
          CFRelease(v45);
        free((void *)v24);
        v46 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error bringing up AWDL session. Re-enabling auto-join", "__WiFiDeviceManagerRequestAwdlBringup");
        objc_autoreleasePoolPop(v46);
        *(_DWORD *)(a1 + 192) = 10;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000285E4(a1, 9uLL);
        }
        else
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 9, sub_100025C3C(*(_QWORD *)(a1 + 64)));
          sub_1000FBA80(a1, 2, (uint64_t)"__WiFiDeviceManagerRequestAwdlBringup");
        }
      }
      else
      {
        v16 = 4294963395;
      }
    }
    else
    {
      v31 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to start AWDL due to concurrency.", "__WiFiDeviceManagerRequestAwdlBringup");
      objc_autoreleasePoolPop(v31);
      v16 = 82;
    }
    v49 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error bringing up AWDL (=%d)", "WiFiDeviceManagerStartAwdl", v16);
    objc_autoreleasePoolPop(v49);
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to start AWDL due to concurrency.", "WiFiDeviceManagerStartAwdl");
    objc_autoreleasePoolPop(v15);
    return 82;
  }
  return v16;
}

void sub_10010F970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10010F988(uint64_t a1, const void *a2, int a3, uint64_t a4, uint64_t a5)
{
  int v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex v12;
  const void *ValueAtIndex;
  uint64_t v14;
  const __CFNumber *v15;
  uint64_t v16;
  const __CFArray *v18;
  const __CFArray *v19;
  int valuePtr;

  valuePtr = 0;
  if (a3 == 2)
    v9 = 3;
  else
    v9 = a3;
  v10 = sub_100109C30(a1);
  if (!v10)
    return 4294963394;
  v11 = v10;
  if (CFArrayGetCount(v10) < 1)
    goto LABEL_11;
  v12 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v11, v12);
    if (ValueAtIndex)
    {
      v14 = (uint64_t)ValueAtIndex;
      v15 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("networkRole"));
      if (v15)
      {
        CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr == v9)
          break;
      }
    }
    if (CFArrayGetCount(v11) <= ++v12)
      goto LABEL_11;
  }
  v18 = (const __CFArray *)sub_10002B2DC((uint64_t)kCFAllocatorDefault, v14);
  if (v18)
  {
    v19 = v18;
    v16 = sub_10010FABC(a1, a2, v18, a4, a5);
    CFRelease(v11);
    v11 = v19;
  }
  else
  {
LABEL_11:
    v16 = 4294963394;
  }
  CFRelease(v11);
  return v16;
}

uint64_t sub_10010FABC(uint64_t a1, const void *a2, void *value, uint64_t a4, uint64_t a5)
{
  const void *v10;
  const __CFNumber *v11;
  int valuePtr;

  if (!value)
    return 4294963396;
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 3320), value))
    return 4294963396;
  v10 = CFSetGetValue(*(CFSetRef *)(a1 + 3320), value);
  v11 = (const __CFNumber *)sub_10002BE64((uint64_t)v10, CFSTR("networkRole"));
  if (!v11)
    return 4294963394;
  valuePtr = -1431655766;
  CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr == 1)
  {
    sub_10010E5C0(a1, a2, (uint64_t)v10, a4, a5);
    return 0;
  }
  if ((valuePtr & 0xFFFFFFFE) == 2)
  {
    sub_100106328(a1, a2, v10, a4, a5);
    return 0;
  }
  if (valuePtr == 4)
    return sub_10010FBD8(a1, a2, v10, a4, a5);
  else
    return 4294963396;
}

uint64_t sub_10010FBD8(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  CFTypeRef v17;
  void *v18;
  const void *v19;
  void *v20;
  _QWORD block[8];
  int v23;

  v5 = *(_DWORD *)(a1 + 5424);
  if (!v5)
    return 4294963396;
  *(_DWORD *)(a1 + 5424) = v5 - 1;
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL refCount is now [%d].", "WiFiDeviceManagerStopAwdl", *(unsigned int *)(a1 + 5424));
  objc_autoreleasePoolPop(v11);
  if (*(_DWORD *)(a1 + 5424))
  {
    if (a4 && *(_QWORD *)(a1 + 240))
    {
      CFRetain((CFTypeRef)a1);
      v12 = *(NSObject **)(a1 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1001101D8;
      block[3] = &unk_1002315D0;
      block[4] = a1;
      block[5] = a4;
      v23 = 0;
      block[6] = a2;
      block[7] = a5;
      dispatch_async(v12, block);
    }
    return 0;
  }
  else
  {
    v14 = *(void **)(a1 + 5432);
    if (v14)

    *(_QWORD *)(a1 + 5432) = 0;
    v15 = malloc_type_malloc(0x20uLL, 0xA004088793A40uLL);
    if (v15)
    {
      v16 = v15;
      *v15 = a1;
      v15[1] = a4;
      v15[3] = a5;
      if (a3)
        v17 = CFRetain(a3);
      else
        v17 = 0;
      v16[2] = v17;
      v13 = sub_10006B0CC(*(_QWORD *)(a1 + 64), a2, a3, (uint64_t)sub_10013A25C, (uint64_t)v16);
      *(_DWORD *)(a1 + 192) = 11;
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hosted AWDL session is down. Triggering auto-join", "__WiFiDeviceManagerRequestAwdlTeardown");
      objc_autoreleasePoolPop(v18);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 9);
        if (!(_DWORD)v13)
          return v13;
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 9, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, "__WiFiDeviceManagerRequestAwdlTeardown");
        if (!(_DWORD)v13)
          return v13;
      }
      v19 = (const void *)v16[2];
      if (v19)
        CFRelease(v19);
      free(v16);
    }
    else
    {
      v13 = 4294963395;
    }
    sub_1000F9DAC((char *)a1, 2, 0);
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error tearing down AWDL (=%d)", "WiFiDeviceManagerStopAwdl", v13);
    objc_autoreleasePoolPop(v20);
  }
  return v13;
}

uint64_t sub_10010FE60(uint64_t a1, CFArrayRef theArray)
{
  uint64_t v2;
  CFIndex v5;
  void *ValueAtIndex;
  void *v7;
  const __CFNumber *v8;
  uint64_t v9;
  const void *v10;
  const void *v11;

  v2 = 0;
  if (a1 && theArray)
  {
    if (CFArrayGetCount(theArray) < 1)
    {
      return 0;
    }
    else
    {
      v2 = 0;
      v5 = 0;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, v5);
        if (ValueAtIndex)
        {
          v7 = ValueAtIndex;
          v8 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("networkRole"));
          v9 = *(_QWORD *)(a1 + 64);
          if (v8 == (const __CFNumber *)4)
          {
            v10 = (const void *)sub_100068E60(v9);
            v2 = sub_10010FABC(a1, v10, v7, 0, 0);
          }
          else
          {
            v11 = (const void *)sub_100025C3C(v9);
            v2 = sub_10010FABC(a1, v11, v7, 0, 0);
            if (!(_DWORD)v2)
            {
              if (((unint64_t)v8 & 0xFFFFFFFFFFFFFFFELL) == 2)
              {
                *(_BYTE *)(a1 + 5219) = 0;
                sub_1000F9DAC((char *)a1, 4, 0);
              }
              v2 = 0;
            }
          }
        }
        ++v5;
      }
      while (v5 < CFArrayGetCount(theArray));
    }
  }
  return v2;
}

_WORD *sub_10010FF88(uint64_t a1, int a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  const void *ValueAtIndex;
  uint64_t v7;
  const __CFNumber *v8;
  uint64_t v9;
  __CFString *v10;
  _WORD *v11;
  int valuePtr;

  v3 = sub_100109C30(a1);
  if (!v3)
    return 0;
  v4 = v3;
  valuePtr = -1431655766;
  if (CFArrayGetCount(v3) < 1)
  {
LABEL_13:
    v11 = 0;
    goto LABEL_14;
  }
  v5 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
    if (!ValueAtIndex)
      goto LABEL_12;
    v7 = (uint64_t)ValueAtIndex;
    v8 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("networkRole"));
    if (!v8)
      goto LABEL_12;
    CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
    if (valuePtr != 4)
      goto LABEL_12;
    if (a2 == 2)
      break;
    if (a2 == 1)
    {
      v9 = v7;
      v10 = CFSTR("AWDL_INFO_ASSISTED_DISCOVERY_METRIC");
      goto LABEL_11;
    }
LABEL_12:
    if (CFArrayGetCount(v4) <= ++v5)
      goto LABEL_13;
  }
  v9 = v7;
  v10 = CFSTR("APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW");
LABEL_11:
  if (!sub_10002BE64(v9, v10))
    goto LABEL_12;
  v11 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, v7);
LABEL_14:
  CFRelease(v4);
  return v11;
}

void sub_1001100B0(uint64_t a1)
{
  uint64_t *v2;
  const void *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  void (*v6)(_QWORD, _QWORD, uint64_t, const void *, _QWORD, _QWORD);
  uint64_t v7;
  const void *v8;
  const void *v9;
  int valuePtr;

  v2 = *(uint64_t **)(a1 + 40);
  if (v2[30])
  {
    v3 = sub_10002BF8C(v2[8], *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    valuePtr = 4;
    if (v3)
    {
      v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v4)
      {
        v5 = v4;
        sub_10002C478((uint64_t)v3, CFSTR("networkRole"), v4);
        CFRelease(v5);
      }
    }
    v6 = *(void (**)(_QWORD, _QWORD, uint64_t, const void *, _QWORD, _QWORD))(a1 + 48);
    if (v6)
    {
      if (v3)
        v7 = 0;
      else
        v7 = 4294963395;
      v6(*(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v7, v3, 0, *(_QWORD *)(a1 + 56));
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
    v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    if (v3)
      CFRelease(v3);
  }
  else
  {
    CFRelease(v2);
    v9 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void sub_1001101D8(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 40))();
    v2 = *(_QWORD **)(a1 + 32);
  }
  CFRelease(v2);
}

uint64_t sub_100110218(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4440) = a2;
  *(_QWORD *)(result + 4448) = a3;
  return result;
}

uint64_t sub_100110224(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4504) = a2;
  *(_QWORD *)(result + 4512) = a3;
  return result;
}

uint64_t sub_100110230(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 344) = a2;
  return 0;
}

uint64_t sub_10011023C(uint64_t a1, uint64_t a2, double a3)
{
  void *v6;

  if (a1 && (*(_QWORD *)(a1 + 392) != a2 || *(double *)(a1 + 384) != a3))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "scan throttle set to %ld over %f seconds", a2, *(_QWORD *)&a3);
    objc_autoreleasePoolPop(v6);
    *(_QWORD *)(a1 + 392) = a2;
    *(double *)(a1 + 384) = a3;
  }
  return 0;
}

uint64_t sub_1001102D8(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  CFIndex v5;
  const __CFDictionary *ValueAtIndex;
  void *v8;
  void *v9;
  uint64_t v10;
  int valuePtr;
  void *value;

  if (!(_DWORD)a2)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid channel %d", "WiFiDeviceManagerIsChannelCoexBlacklisted", 0);
    goto LABEL_21;
  }
  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerIsChannelCoexBlacklisted", v10);
    goto LABEL_21;
  }
  v3 = *(const __CFArray **)(a1 + 56);
  if (!v3)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null blacklistedChannels", "WiFiDeviceManagerIsChannelCoexBlacklisted", v10);
LABEL_21:
    objc_autoreleasePoolPop(v9);
    return 0;
  }
  value = 0;
  valuePtr = 0;
  if (CFArrayGetCount(v3) < 1)
    return 0;
  v5 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v5);
    if (ValueAtIndex)
    {
      CFDictionaryGetValueIfPresent(ValueAtIndex, CFSTR("MWS_Channel_Number"), (const void **)&value);
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
        if (valuePtr == (_DWORD)a2)
          break;
      }
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) <= ++v5)
      return 0;
  }
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: channel %d is a deny-listed coex channel", "WiFiDeviceManagerIsChannelCoexBlacklisted", a2);
  objc_autoreleasePoolPop(v8);
  return 1;
}

uint64_t sub_100110470(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;

  v10 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
  *v10 = a1;
  v10[1] = a4;
  v10[2] = a5;
  v11 = sub_1000746DC(*(_QWORD *)(a1 + 64), a2, a3, 0, (uint64_t)sub_100110504, (uint64_t)v10);
  if ((_DWORD)v11)
    free(v10);
  return v11;
}

void sub_100110504(int a1, uint64_t a2, CFArrayRef theArray, int a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t, CFArrayRef, uint64_t, uint64_t);

  v10 = *a6;
  if (theArray && CFArrayGetCount(theArray))
    sub_1001399D0(v10, theArray);
  v11 = (void (*)(uint64_t, uint64_t, CFArrayRef, uint64_t, uint64_t))a6[1];
  if (v11)
    v11(v10, a2, theArray, a5, a6[2]);
  free(a6);
}

void sub_100110580(uint64_t a1, const void *a2)
{
  CFIndex Count;
  uint64_t v5;
  __CFArray *MutableCopy;
  const __CFArray *v7;
  CFIndex v8;
  void *ValueAtIndex;
  const void *v10;
  void *v11;
  void *v12;
  CFRange v13;

  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiDeviceManagerFindMergeHS20Account");
    goto LABEL_25;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624));
  v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3632)) + Count;
  if (!v5)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No HS2.0 accounts", "__WiFiDeviceManagerFindMergeHS20Account");
LABEL_25:
    objc_autoreleasePoolPop(v12);
    return;
  }
  MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, *(CFArrayRef *)(a1 + 3624));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3632)))
  {
    v7 = *(const __CFArray **)(a1 + 3632);
    v13.length = CFArrayGetCount(v7);
    v13.location = 0;
    CFArrayAppendArray(MutableCopy, v7, v13);
  }
  if (!a2 || sub_1000C993C((uint64_t)a2) || v5 < 1)
  {
LABEL_17:
    if (MutableCopy)
LABEL_18:
      CFRelease(MutableCopy);
  }
  else
  {
    v8 = 0;
    while (1)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(MutableCopy, v8);
      if (ValueAtIndex)
      {
        v10 = ValueAtIndex;
        if (!sub_1000C66D0(ValueAtIndex))
        {
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: provisioned HS2.0 account %@ has no credentials.", "__WiFiDeviceManagerFindMergeHS20Account", sub_10002B088(v10));
          objc_autoreleasePoolPop(v11);
          goto LABEL_17;
        }
        if (sub_1000C9B20(a2, v10))
          break;
      }
      if (v5 == ++v8)
        goto LABEL_17;
    }
    sub_1000C9914((uint64_t)a2, 1);
    sub_1000C38BC((uint64_t)a2, (uint64_t)v10);
    if (MutableCopy)
      goto LABEL_18;
  }
}

uint64_t sub_100110780(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4)
{
  return sub_100074788(*(_QWORD *)(a1 + 64), a2, a3, a4);
}

uint64_t sub_100110788(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10006BC88(*(_QWORD *)(a1 + 64), a2, a3);
}

uint64_t sub_100110790(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  return sub_100074B3C(*(_QWORD *)(a1 + 64), a2, a3, a4);
}

uint64_t sub_100110798(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, uint64_t a5, double a6)
{
  _QWORD *v12;
  CFIndex v13;
  int v14;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  void *v17;
  uint64_t v18;
  id v20;
  void *v21;
  id v22;
  char valuePtr;

  v12 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
  if (CFArrayGetCount(a3) >= 1)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v13);
      if (ValueAtIndex)
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW"));
        if (Value)
        {
          valuePtr = -86;
          CFNumberGetValue(Value, kCFNumberSInt8Type, &valuePtr);
          if (valuePtr)
            v14 = 1;
        }
      }
      ++v13;
    }
    while (CFArrayGetCount(a3) > v13);
    if (*(_BYTE *)(a1 + 3408) && v14)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to start Ranging in follow mode, VoIP Call Active.", "WiFiDeviceManagerRangingStartAsync");
      objc_autoreleasePoolPop(v17);
      goto LABEL_15;
    }
    if (v14 && sub_10010A010(a1))
    {
LABEL_15:
      v18 = 4294963366;
LABEL_17:
      free(v12);
      return v18;
    }
  }
  *v12 = a1;
  v12[1] = a4;
  v12[2] = a5;
  v18 = sub_100074A5C(*(_QWORD *)(a1 + 64), a2, a3, (uint64_t)sub_10011097C, (uint64_t)v12, a6);
  if ((_DWORD)v18)
    goto LABEL_17;
  if (a3 && *(_QWORD *)(a1 + 7368))
  {
    if (CFArrayGetCount(a3))
    {
      v20 = objc_msgSend(-[__CFArray objectAtIndex:](a3, "objectAtIndex:", 0), "objectForKey:", CFSTR("RANGING_NUM_MEASUREMENTS"));
      v21 = *(void **)(a1 + 7368);
      if (v20)
        v22 = objc_msgSend(v20, "unsignedIntegerValue");
      else
        v22 = 0;
      objc_msgSend(v21, "rangingStartedWithNumMeasurements:", v22);
    }
    return 0;
  }
  return v18;
}

void sub_10011097C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  void (*v6)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD);

  v6 = (void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD))a5[1];
  if (v6)
    v6(*a5, a2, a3, a4, a5[2]);
  free(a5);
}

uint64_t sub_1001109B0(uint64_t a1, uint64_t a2)
{
  void *v4;
  const void *v5;
  void *v6;
  const void *v7;
  void *v8;
  const void *v9;
  void *v10;
  void *v11;
  const void *v12;
  void *v14;
  void *v15;
  void *v16;

  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerSetThermalIndex");
    v15 = v14;
    goto LABEL_29;
  }
  if (*(_DWORD *)(a1 + 5416) == (_DWORD)a2)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: thermal index unchanged (%d).", "WiFiDeviceManagerSetThermalIndex", a2);
    v15 = v16;
LABEL_29:
    objc_autoreleasePoolPop(v15);
    return 0;
  }
  *(_DWORD *)(a1 + 5416) = a2;
  sub_100110C4C(a1, 1);
  if (*(_DWORD *)(a1 + 5416))
  {
    if (*(_BYTE *)(a1 + 3305))
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resource has become available for auto-join. Triggering auto-join...", "WiFiDeviceManagerSetThermalIndex");
      objc_autoreleasePoolPop(v4);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 0x16uLL);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 22, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerSetThermalIndex");
      }
    }
  }
  else
  {
    v5 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v6 = sub_10002A21C(a1, v5, 1);
    if (v6)
    {
      v7 = v6;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resource no longer available for association. Disassociating...", "WiFiDeviceManagerSetThermalIndex");
      objc_autoreleasePoolPop(v8);
      v9 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      sub_1000F7F48(a1, v9, 1006, "WiFiDeviceManagerSetThermalIndex", 27364);
      CFRelease(v7);
    }
    if (*(_BYTE *)(a1 + 3305))
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: resource no longer available for auto-join. Aborting...", "WiFiDeviceManagerSetThermalIndex");
      objc_autoreleasePoolPop(v10);
      sub_1000FB44C(a1);
    }
    if (*(_DWORD *)(a1 + 5424))
    {
      v11 = *(void **)(a1 + 5432);
      if (v11)

      *(_QWORD *)(a1 + 5432) = 0;
      v12 = (const void *)sub_100068E60(*(_QWORD *)(a1 + 64));
      sub_1000FB00C(a1, v12);
    }
  }
  return sub_100074CD4(*(_QWORD *)(a1 + 64), a2);
}

void sub_100110C4C(uint64_t a1, int a2)
{
  const __CFString *v4;
  __CFDictionary *v5;
  __CFDictionary *v6;
  const __CFDictionary *MutableCopy;
  uint64_t v8;
  const __CFString *v9;
  int v10;
  int v11;
  BOOL v12;
  int v13;
  const __CFBoolean *Value;
  void *v15;
  const void **v16;
  void (*v17)(uint64_t, int64_t, _QWORD, const __CFDictionary *);
  int64_t v18;

  if (*(_QWORD *)(a1 + 4440))
  {
    v4 = (const __CFString *)sub_100068E60(*(_QWORD *)(a1 + 64));
    v5 = sub_100109D00(a1, v4);
    if (v5)
    {
      v6 = v5;
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v5);
      CFRelease(v6);
      if (MutableCopy)
      {
        v8 = *(_QWORD *)(a1 + 64);
        v9 = (const __CFString *)sub_100068E60(v8);
        v10 = sub_100073FF0(v8, v9);
        v11 = 0;
        if (a2)
          v12 = 1;
        else
          v12 = *(_QWORD *)(a1 + 5408) == 0;
        v13 = v12;
        if (v10 && v13)
          v11 = *(_DWORD *)(a1 + 5416) != 0;
        Value = (const __CFBoolean *)CFDictionaryGetValue(MutableCopy, CFSTR("LINK_CHANGED_IS_AVAILABLE"));
        if (Value)
        {
          if (CFBooleanGetValue(Value) == v11)
          {
LABEL_23:
            CFRelease(MutableCopy);
            return;
          }
        }
        else
        {
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: availabilityRef was NULL, so sending the awdl state info to client.", "__WiFiDeviceManagerUpdateInterfaceAvailability");
          objc_autoreleasePoolPop(v15);
        }
        v16 = (const void **)&kCFBooleanTrue;
        if (!v11)
          v16 = (const void **)&kCFBooleanFalse;
        CFDictionarySetValue(MutableCopy, CFSTR("LINK_CHANGED_IS_AVAILABLE"), *v16);
        v17 = *(void (**)(uint64_t, int64_t, _QWORD, const __CFDictionary *))(a1 + 4440);
        v18 = sub_100068E60(*(_QWORD *)(a1 + 64));
        v17(a1, v18, *(_QWORD *)(a1 + 4448), MutableCopy);
        goto LABEL_23;
      }
    }
  }
}

uint64_t sub_100110DCC(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFMutableDictionaryRef *a4)
{
  const __CFNumber *Value;
  const __CFNumber *v9;
  void *v10;
  __CFDictionary *MutableCopy;
  uint64_t v12;
  const __CFNumber *v13;
  unsigned int v14;
  void *v15;
  const __CFNumber *v16;
  unsigned int v17;
  void *v18;
  const __CFNumber *v19;
  const __CFDictionary *v20;
  void *v21;
  id v22;
  void *v23;
  void (*v24)(uint64_t, uint64_t, uint64_t, _QWORD);
  const __CFNumber *v25;
  const __CFDictionary *v26;
  id v27;
  const __CFNumber *v28;
  const void *v29;
  void *v30;
  void *v31;
  void *v32;
  const __CFNumber *v33;
  const void *v34;
  uint64_t v35;
  const void *v36;
  void (*v37)(uint64_t, uint64_t, _QWORD, const void *);
  id v38;
  void *v39;
  id v40;
  void *v41;
  double v42;
  double v43;
  double v44;
  double v45;
  id v46;
  double v47;
  double v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  id v54;
  uint64_t v55;
  id v56;
  void *v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  const char *v66;
  void *v67;
  const __CFNumber *v68;
  const __CFNumber *v69;
  const __CFNumber *v70;
  void *v71;
  const char *v72;
  const __CFNumber *v73;
  int v74;
  void *v75;
  const char *v76;
  const char *v77;
  const char *v78;
  const char *v79;
  const char *v80;
  const __CFNumber *v81;
  void *v83;
  const char *v84;
  void *v85;
  const char *v86;
  void *v87;
  uint64_t v88;
  const char *v89;
  void *v90;
  uint64_t v91;
  int valuePtr;
  unsigned int v93;
  unsigned int v94;

  valuePtr = -1431655766;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugModule"));
  if (!Value)
    return sub_10007528C(*(_QWORD *)(a1 + 64), a2, theDict, a4);
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  switch(valuePtr)
  {
    case 3:
      if (!a1)
      {
        v30 = objc_autoreleasePoolPush();
        v83 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_62;
        v84 = "__WiFiDeviceManagerDebugAutoJoin";
        goto LABEL_178;
      }
      if (theDict)
      {
        v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
        if (!v9)
          return 4294963396;
        v94 = -1431655766;
        CFNumberGetValue(v9, kCFNumberIntType, &v94);
        switch(v94)
        {
          case 0u:
            v10 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Dumping Auto-Join Stats");
            objc_autoreleasePoolPop(v10);
            MutableCopy = sub_10013A2E8((id *)a1);
            goto LABEL_41;
          case 1u:
            v63 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Reset Auto-Join Stats");
            objc_autoreleasePoolPop(v63);
            bzero((void *)(a1 + 5616), 0x238uLL);
            goto LABEL_156;
          case 4u:
            *(_BYTE *)(a1 + 34) = 0;
            v64 = objc_autoreleasePoolPush();
            v65 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_103;
            v66 = "Enabled Periodic 5Ghz Scan";
            goto LABEL_102;
          case 5u:
            *(_BYTE *)(a1 + 34) = 1;
            v64 = objc_autoreleasePoolPush();
            v65 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_103;
            v66 = "Disabled Periodic 5Ghz Scan";
            goto LABEL_102;
          case 6u:
            *(_BYTE *)(a1 + 5609) = 0;
            v64 = objc_autoreleasePoolPush();
            v65 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_103;
            v66 = "Considering geotags for 5Ghz Scan";
            goto LABEL_102;
          case 7u:
            *(_BYTE *)(a1 + 5609) = 1;
            v64 = objc_autoreleasePoolPush();
            v65 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_103;
            v66 = "Not considering geotags for 5Ghz Scan";
LABEL_102:
            objc_msgSend(v65, "WFLog:message:", 3, v66);
LABEL_103:
            v67 = v64;
            goto LABEL_155;
          case 8u:
            v93 = 0;
            v68 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (v68 && CFNumberGetValue(v68, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 132) = v93;
              v15 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for AutoJoinUnreliableNwRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93);
              goto LABEL_161;
            }
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinUnreliableNwRssiThres valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_18;
          case 9u:
            v93 = 0;
            v69 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (v69 && CFNumberGetValue(v69, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 136) = v93;
              v15 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for AutoJoinPnoRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93);
              goto LABEL_161;
            }
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinPnoRssiThres valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_18;
          case 0xAu:
            v93 = 0;
            v70 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (v70 && CFNumberGetValue(v70, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 140) = v93;
              v15 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for AutoJoinDrivingRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93);
              goto LABEL_161;
            }
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_18;
          case 0xBu:
            if (!CFDictionaryContainsValue(theDict, CFSTR("DebugCommandValueDict")))
            {
              *(_BYTE *)(a1 + 36) = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict")) == kCFBooleanTrue;
              v71 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                if (*(_BYTE *)(a1 + 36))
                  v72 = "Disabled";
                else
                  v72 = "Enabled";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for 24GhzAJScanDuringBTAndDriving: 2.4Ghz AJ Scans %s", "__WiFiDeviceManagerDebugAutoJoin", v72);
              }
              goto LABEL_154;
            }
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdDisable24GhzAJScanDuringBTAndDriving no value", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_62;
          case 0xCu:
            v93 = 0;
            v73 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (!v73)
            {
              v30 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin", v91);
              goto LABEL_62;
            }
            v74 = CFNumberGetValue(v73, kCFNumberSInt32Type, &v93);
            v75 = objc_autoreleasePoolPush();
            if (v74)
            {
              if (qword_10026DD20)
              {
                v76 = "YES";
                if (!v93)
                  v76 = "NO";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for AutoJoinSimulateScanRSSI: Simulating:%s RSSI:%d", "__WiFiDeviceManagerDebugAutoJoin", v76, v93);
              }
              objc_autoreleasePoolPop(v75);
              v12 = 0;
              if (v93)
              {
                *(_DWORD *)(a1 + 44) = v93;
                *(_BYTE *)(a1 + 40) = 1;
              }
              else
              {
                *(_DWORD *)(a1 + 44) = 0;
                *(_BYTE *)(a1 + 40) = 0;
              }
              return v12;
            }
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin");
            v31 = v75;
            goto LABEL_63;
          case 0xDu:
            if (!CFDictionaryContainsValue(theDict, CFSTR("DebugCommandValueDict")))
            {
              *(_BYTE *)(a1 + 48) = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict")) == kCFBooleanTrue;
              v71 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                if (*(_BYTE *)(a1 + 48))
                  v77 = "On";
                else
                  v77 = "Off";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for DebugCmdAutoJoinDrivingCarPlay: Carplay is %s", "__WiFiDeviceManagerDebugAutoJoin", v77);
              }
              goto LABEL_154;
            }
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinDrivingCarPlay no value", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_62;
          case 0xEu:
            if (!CFDictionaryContainsValue(theDict, CFSTR("DebugCommandValueDict")))
            {
              *(_BYTE *)(a1 + 49) = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict")) == kCFBooleanTrue;
              v71 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                if (*(_BYTE *)(a1 + 49))
                  v78 = "On";
                else
                  v78 = "Off";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for DebugCmdBTA2DPEnable: BTA2DP is %s", "__WiFiDeviceManagerDebugAutoJoin", v78);
              }
              goto LABEL_154;
            }
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdBTA2DPEnable no value", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_62;
          case 0xFu:
            if (!CFDictionaryContainsValue(theDict, CFSTR("DebugCommandValueDict")))
            {
              *(_BYTE *)(a1 + 37) = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict")) == kCFBooleanTrue;
              v71 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                if (*(_BYTE *)(a1 + 37))
                  v79 = "Enabled";
                else
                  v79 = "Disabled";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for DebugCmdAutoJoinBTSCODisable: AJ Scans for BTSCO %s", "__WiFiDeviceManagerDebugAutoJoin", v79);
              }
              goto LABEL_154;
            }
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdAutoJoinBTSCODisable no value", "__WiFiDeviceManagerDebugAutoJoin", v91);
            goto LABEL_62;
          case 0x10u:
            if (CFDictionaryContainsValue(theDict, CFSTR("DebugCommandValueDict")))
            {
              v30 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdBTSCOEnable no value", "__WiFiDeviceManagerDebugAutoJoin", v91);
              goto LABEL_62;
            }
            *(_BYTE *)(a1 + 50) = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict")) == kCFBooleanTrue;
            v71 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              if (*(_BYTE *)(a1 + 50))
                v80 = "On";
              else
                v80 = "Off";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for DebugCmdBTSCOEnable: BTSCO is %s", "__WiFiDeviceManagerDebugAutoJoin", v80);
            }
LABEL_154:
            v67 = v71;
LABEL_155:
            objc_autoreleasePoolPop(v67);
            goto LABEL_156;
          case 0x11u:
            v93 = 0;
            v81 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (!v81 || !CFNumberGetValue(v81, kCFNumberSInt32Type, &v93))
            {
              v15 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s DebugCmdTopNetworksRankLimit valRef is NULL", "__WiFiDeviceManagerDebugAutoJoin", v91);
              goto LABEL_18;
            }
            *(_DWORD *)(a1 + 144) = v93;
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using Debug Value for DebugCmdTopNetworksRankLimit = %d", "__WiFiDeviceManagerDebugAutoJoin", v93);
LABEL_161:
            v12 = 0;
            break;
          default:
            goto LABEL_60;
        }
        goto LABEL_162;
      }
      v30 = objc_autoreleasePoolPush();
      v85 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_62;
      v86 = "__WiFiDeviceManagerDebugAutoJoin";
      goto LABEL_193;
    case 5:
      if (!a1)
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL", "__WiFiDeviceManagerDebugRoamMgr", v91);
        goto LABEL_18;
      }
      if (!theDict)
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s request is NULL", "__WiFiDeviceManagerDebugRoamMgr", v91);
        goto LABEL_18;
      }
      v13 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
      if (v13)
      {
        v94 = -1431655766;
        if (CFNumberGetValue(v13, kCFNumberIntType, &v94))
        {
          v14 = v94;
          v15 = objc_autoreleasePoolPush();
          if (v14)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unknown debug command %d", "__WiFiDeviceManagerDebugRoamMgr", v94);
LABEL_18:
            v12 = 4294963396;
LABEL_162:
            v62 = v15;
            goto LABEL_163;
          }
          v38 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
          if (v38)
          {
            v39 = v38;
            v40 = -[__CFDictionary valueForKey:](theDict, "valueForKey:", CFSTR("DebugCommandValueDict"));
            if (v40)
            {
              v41 = v40;
              objc_msgSend(objc_msgSend(v40, "valueForKey:", CFSTR("minLinkUpWaitSec")), "doubleValue");
              v43 = v42;
              objc_msgSend(objc_msgSend(v41, "valueForKey:", CFSTR("minRetryWaitSec")), "doubleValue");
              v45 = v44;
              v46 = objc_msgSend(objc_msgSend(v41, "valueForKey:", CFSTR("maxRetriesSec")), "integerValue");
              objc_msgSend(objc_msgSend(v41, "valueForKey:", CFSTR("windowSizeSec")), "doubleValue");
              v48 = v47;
              objc_msgSend(v39, "setParamMinRoamWaitTimeFromLinkUpInSec:", v43);
              objc_msgSend(v39, "setParamMinRoamRetryWaitTime:", v45);
              objc_msgSend(v39, "setParamMaxRoamRetriesInWindow:", v46);
              objc_msgSend(v39, "setParamWindowSizeInSec:", v48);
              v49 = objc_autoreleasePoolPush();
              v12 = qword_10026DD20;
              if (qword_10026DD20)
              {
                objc_msgSend(v39, "paramMinRoamWaitTimeFromLinkUpInSec");
                v51 = v50;
                objc_msgSend(v39, "paramMinRoamRetryWaitTime");
                v53 = v52;
                v54 = objc_msgSend(v39, "paramMaxRoamRetriesInWindow");
                objc_msgSend(v39, "paramWindowSizeInSec");
                objc_msgSend((id)v12, "WFLog:message:", 3, "%s: Configuring RoamManager paramMinRoamWaitTimeFromLinkUpInSec: %.1f paramMinRoamRetryWaitTime: %.1f paramMaxRoamRetriesInWindow: %d paramWindowSizeInSec: %.1f", "__WiFiDeviceManagerDebugRoamMgr", v51, v53, v54, v55);
                v12 = 0;
              }
              goto LABEL_80;
            }
            v49 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s kWiFiDebugCommandValueDict is NULL", "__WiFiDeviceManagerDebugRoamMgr");
          }
          else
          {
            v49 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s WiFiRoamManager is NULL", "__WiFiDeviceManagerDebugRoamMgr");
          }
          v12 = 4294963396;
LABEL_80:
          objc_autoreleasePoolPop(v49);
          goto LABEL_162;
        }
      }
      return 4294963396;
    case 6:
      if (!a1)
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL", "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition", v91);
        goto LABEL_26;
      }
      if (!theDict)
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s request is NULL", "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition", v91);
        goto LABEL_26;
      }
      v16 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
      if (!v16)
        return 4294963396;
      v94 = -1431655766;
      if (!CFNumberGetValue(v16, kCFNumberIntType, &v94))
        return 4294963396;
      v17 = v94;
      v18 = objc_autoreleasePoolPush();
      if (v17)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unknown debug command %d", "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition", v94);
LABEL_26:
        v12 = 4294963396;
        goto LABEL_90;
      }
      v56 = -[__CFDictionary valueForKey:](theDict, "valueForKey:", CFSTR("DebugCommandValueDict"));
      if (!v56)
      {
        v90 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s kWiFiDebugCommandValueDict is NULL", "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition");
        objc_autoreleasePoolPop(v90);
        goto LABEL_26;
      }
      v57 = v56;
      v58 = objc_msgSend(objc_msgSend(v56, "valueForKey:", CFSTR("movingNetwork")), "intValue");
      v59 = objc_msgSend(objc_msgSend(v57, "valueForKey:", CFSTR("edgeBssWalkout")), "intValue");
      v60 = objc_msgSend(objc_msgSend(v57, "valueForKey:", CFSTR("badRepNetwork")), "intValue");
      *(_BYTE *)(a1 + 54) = v60 != 0;
      *(_BYTE *)(a1 + 52) = v58 != 0;
      *(_BYTE *)(a1 + 53) = v59 != 0;
      v61 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Simulating wifi-assist conditions badReputationNetwork:%d  movingNetwork:%d edgeBssWalkOut: %d", "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition", *(unsigned __int8 *)(a1 + 54), *(unsigned __int8 *)(a1 + 52), *(unsigned __int8 *)(a1 + 53));
      objc_autoreleasePoolPop(v61);
      if (v60 || v58 || v59)
      {
        v12 = 0;
        *(_BYTE *)(a1 + 55) = 1;
      }
      else
      {
        v12 = 0;
        *(_BYTE *)(a1 + 55) = 0;
      }
LABEL_90:
      v62 = v18;
LABEL_163:
      objc_autoreleasePoolPop(v62);
      return v12;
    case 8:
      if (!a1)
      {
        v30 = objc_autoreleasePoolPush();
        v83 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_62;
        v84 = "__WiFiDeviceManagerDebugPH";
        goto LABEL_178;
      }
      if (!theDict)
      {
        v30 = objc_autoreleasePoolPush();
        v85 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_62;
        v86 = "__WiFiDeviceManagerDebugPH";
        goto LABEL_193;
      }
      v19 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
      if (!v19)
        return 4294963396;
      v94 = -1431655766;
      CFNumberGetValue(v19, kCFNumberIntType, &v94);
      if (v94 == 1)
      {
        v20 = *(const __CFDictionary **)(a1 + 7032);
        if (v20)
          MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v20);
        else
          MutableCopy = 0;
LABEL_41:
        v12 = 0;
        *a4 = MutableCopy;
        return v12;
      }
      goto LABEL_60;
    case 10:
      sub_1001091D8(a1, 0, 0);
      goto LABEL_156;
    case 13:
      if (!a4)
        return 4294963396;
      v21 = *(void **)(a1 + 7368);
      if (!v21)
        return 4294963393;
      v22 = objc_msgSend(v21, "summaryForInterface:", a2);
      goto LABEL_40;
    case 15:
      if (!a4)
        return 4294963396;
      v23 = *(void **)(a1 + 7368);
      if (!v23)
        return 4294963393;
      v22 = objc_msgSend(v23, "lastBssSessionInfoForInterface:", a2);
LABEL_40:
      MutableCopy = (__CFDictionary *)objc_msgSend(v22, "copy");
      goto LABEL_41;
    case 16:
      if (a1 && (v24 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 4552)) != 0)
        v24(a1, 16, a2, *(_QWORD *)(a1 + 4560));
      else
        sub_10011BC48(a1, -1);
      goto LABEL_156;
    case 17:
      if (!a1)
      {
        v30 = objc_autoreleasePoolPush();
        v83 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_62;
        v84 = "__WiFiDeviceManagerDebugSimulateBSP";
        goto LABEL_178;
      }
      if (!theDict)
      {
        v30 = objc_autoreleasePoolPush();
        v85 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_62;
        v86 = "__WiFiDeviceManagerDebugSimulateBSP";
        goto LABEL_193;
      }
      v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
      if (!v25)
        return 4294963396;
      v94 = -1431655766;
      CFNumberGetValue(v25, kCFNumberIntType, &v94);
      v26 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
      if (v26)
      {
        if (v94 > 0xE)
          goto LABEL_60;
        if (((1 << v94) & 0x703F) != 0)
        {
          sub_1000EDE10((int)v26, a2, a1, v26);
        }
        else
        {
          v34 = CFDictionaryGetValue(v26, CFSTR("BSP_CommandParams"));
          v35 = *(_QWORD *)(a1 + 64);
          v36 = (const void *)sub_100025C3C(v35);
          sub_10002DC20(v35, v36, CFSTR("BSP_CommandParams"), (uint64_t)v34);
        }
        goto LABEL_156;
      }
      v30 = objc_autoreleasePoolPush();
      v87 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_62;
      v88 = v94;
      v89 = "__WiFiDeviceManagerDebugSimulateBSP";
      goto LABEL_196;
    case 19:
      if (!a4)
        return 4294963396;
      if (!+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"))
        return 4294963393;
      v27 = objc_alloc_init((Class)NSMutableDictionary);
      objc_msgSend(v27, "setObject:forKeyedSubscript:", -[WiFiUserInteractionMonitor description](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "description"), CFSTR("description"));
      v12 = 0;
      *a4 = (CFMutableDictionaryRef)v27;
      return v12;
    case 20:
      if (!a1)
      {
        v30 = objc_autoreleasePoolPush();
        v83 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v84 = "__WiFiDeviceManagerDebugSimulateUCM";
LABEL_178:
          objc_msgSend(v83, "WFLog:message:", 4, "%s manager is NULL", v84, v91);
        }
        goto LABEL_62;
      }
      if (!theDict)
      {
        v30 = objc_autoreleasePoolPush();
        v85 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v86 = "__WiFiDeviceManagerDebugSimulateUCM";
LABEL_193:
          objc_msgSend(v85, "WFLog:message:", 4, "%s request is NULL", v86, v91);
        }
        goto LABEL_62;
      }
      v28 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
      if (!v28)
        return 4294963396;
      v94 = -1431655766;
      CFNumberGetValue(v28, kCFNumberIntType, &v94);
      v29 = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
      if (!v29)
      {
        v30 = objc_autoreleasePoolPush();
        v87 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v88 = v94;
          v89 = "__WiFiDeviceManagerDebugSimulateUCM";
LABEL_196:
          objc_msgSend(v87, "WFLog:message:", 4, "%s dictRef for %d is NULL", v89, v88);
        }
        goto LABEL_62;
      }
      if (v94)
      {
LABEL_60:
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown debug command %d", v94, v91);
LABEL_62:
        v31 = v30;
LABEL_63:
        objc_autoreleasePoolPop(v31);
        return 4294963396;
      }
      v37 = *(void (**)(uint64_t, uint64_t, _QWORD, const void *))(a1 + 4808);
      if (v37)
        v37(a1, a2, *(_QWORD *)(a1 + 4816), v29);
LABEL_156:
      v12 = 0;
      break;
    case 21:
      v32 = *(void **)(a1 + 7368);
      if (!v32)
        return 4294963393;
      objc_msgSend(v32, "resetDeviceSessionforInterface:", a2);
      goto LABEL_156;
    case 22:
      if (a1)
      {
        v33 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
        if (v33)
        {
          v94 = -1431655766;
          if (CFNumberGetValue(v33, kCFNumberIntType, &v94))
            objc_msgSend(*(id *)(a1 + 7368), "updateLinkTestInterval:", (int)v94);
        }
      }
      goto LABEL_156;
    default:
      return sub_10007528C(*(_QWORD *)(a1 + 64), a2, theDict, a4);
  }
  return v12;
}

uint64_t sub_100112030(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4472) = a2;
  *(_QWORD *)(result + 4480) = a3;
  return result;
}

void sub_10011203C(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  _BYTE *v6;
  const __CFNumber *Value;
  const __CFNumber *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  __CFArray *Mutable;
  CFMutableArrayRef v12;
  __CFArray *v13;
  BOOL v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  CFIndex v18;
  const __CFDictionary *ValueAtIndex;
  const void *v20;
  CFIndex Count;
  CFIndex v22;
  CFIndex v23;
  const __CFDictionary *v24;
  const void *v25;
  void *v26;
  uint64_t valuePtr;
  CFRange v28;

  v6 = (_BYTE *)(a1 + 5456);
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("BGSCAN_CACHE"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, (char *)&valuePtr + 4);
    *v6 = BYTE4(valuePtr);
  }
  v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("BGSCAN_CACHE_WSB_ROLLOVER"));
  if (v8)
  {
    CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    v6[2] = valuePtr;
  }
  v9 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("SCAN_CHANNELS"));
  if (!v9)
  {
    v13 = 0;
    Mutable = 0;
    if (!a3)
      goto LABEL_17;
    goto LABEL_16;
  }
  v10 = v9;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v13 = v12;
  if (Mutable)
    v14 = v12 == 0;
  else
    v14 = 1;
  if (v14)
    goto LABEL_17;
  v15 = *(_QWORD *)(a1 + 64);
  v16 = (const void *)sub_100025C3C(v15);
  if (sub_100017A68(v15, v16, Mutable))
    goto LABEL_11;
  if (CFArrayGetCount(Mutable) >= 1)
  {
    v18 = 0;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v18);
      if (ValueAtIndex)
      {
        v20 = CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
        CFArrayAppendValue(v13, v20);
      }
      ++v18;
    }
    while (CFArrayGetCount(Mutable) > v18);
  }
  Count = CFArrayGetCount(v10);
  if (Count < 1)
  {
LABEL_11:
    v17 = *(const void **)(a1 + 5448);
    if (v17)
    {
      CFRelease(v17);
      *(_QWORD *)(a1 + 5448) = 0;
    }
    *(_QWORD *)(a1 + 5448) = CFRetain(v10);
    if (!a3)
    {
LABEL_17:
      if (!Mutable)
        goto LABEL_19;
      goto LABEL_18;
    }
LABEL_16:
    sub_1000FF824(a1);
    goto LABEL_17;
  }
  v22 = Count;
  v23 = 0;
  while (1)
  {
    v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v23);
    v25 = CFDictionaryGetValue(v24, CFSTR("CHANNEL"));
    v28.length = CFArrayGetCount(v13);
    v28.location = 0;
    if (!CFArrayContainsValue(v13, v28, v25))
      break;
    if (v22 == ++v23)
      goto LABEL_11;
  }
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Client sent Invalid channel %s %@", "WiFiDeviceManagerSetBGScanCacheState", v25);
  objc_autoreleasePoolPop(v26);
  if (Mutable)
LABEL_18:
    CFRelease(Mutable);
LABEL_19:
  if (v13)
    CFRelease(v13);
}

void sub_1001122B4(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  const void *v4;
  void *v5;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 64);
    v4 = (const void *)sub_100025C3C(v3);
    sub_10007186C(v3, v4, a2);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerSetScanBackoffReport");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_10011233C(uint64_t a1, const __CFDictionary *a2)
{
  const __CFString *v4;
  const __CFString *Value;
  const __CFString *v6;
  const __CFNumber *v7;
  const __CFBoolean *v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  const void *v14;
  const __CFNumber *v15;
  const __CFDictionary *v16;
  const __CFBoolean *v17;
  const __CFNumber *v18;
  int v19;
  __CFDictionary *v20;
  __CFDictionary *Mutable;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  void *v25;
  const void *v26;
  const __CFNumber *v27;
  char v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFNumber *v33;
  void *v34;
  CFIndex Count;
  CFIndex v36;
  CFIndex v37;
  const void *v38;
  void *v39;
  void *v40;
  const void *v41;
  const __CFString *v42;
  const void *v43;
  const __CFBoolean *v44;
  __CFDictionary *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  const char *v51;
  void *v52;
  void *v53;
  const void *v54;
  void *v55;
  const void *v56;
  const __CFArray *v57;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const void *v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int valuePtr;
  unsigned int v67;
  char v68;
  CFRange v69;

  valuePtr = 0;
  if (!a1)
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerSetTestParams", v64, v65);
    goto LABEL_75;
  }
  if (!a2)
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null mutableTestParams", "WiFiDeviceManagerSetTestParams", v64, v65);
    goto LABEL_75;
  }
  v4 = (const __CFString *)sub_100029860(*(_QWORD *)(a1 + 64));
  Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("WiFiTestCommandInterfaceName"));
  if (!v4)
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Current Interface is Null!", "WiFiDeviceManagerSetTestParams", v64, v65);
    goto LABEL_75;
  }
  v6 = Value;
  if (!Value)
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:test Interface is Null!", "WiFiDeviceManagerSetTestParams", v64, v65);
    goto LABEL_75;
  }
  if (CFStringCompare(Value, v4, 0))
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ignore this device %@, test interface %@", "WiFiDeviceManagerSetTestParams", v4, v6);
    goto LABEL_75;
  }
  v7 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("WiFiTestCommandType"));
  if (!v7)
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null cmdNum", "WiFiDeviceManagerSetTestParams", v64, v65);
LABEL_75:
    objc_autoreleasePoolPop(v48);
    return;
  }
  CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
  if (valuePtr >= 0xC9)
  {
    sub_1000767E0(*(_QWORD *)(a1 + 64), a2);
    return;
  }
  CFDictionaryRemoveValue(a2, CFSTR("WiFiTestCommandType"));
  if (valuePtr == 103)
  {
    v68 = 0;
    v24 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
    if (v24)
    {
      v25 = sub_10002A21C(a1, v24, 1);
      if (v25)
      {
        v26 = v25;
        v27 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("WiFiTestCommandParamIsEdge"));
        if (v27)
        {
          CFNumberGetValue(v27, kCFNumberCharType, &v68);
          v28 = v68;
        }
        else
        {
          v28 = 0;
        }
        sub_100046660(*(_QWORD *)(a1 + 120), v26, 2, v28);
        return;
      }
      v49 = objc_autoreleasePoolPush();
      v50 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_87;
      v51 = "no current network";
      goto LABEL_86;
    }
    v49 = objc_autoreleasePoolPush();
    v50 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_87;
    v51 = "interface is NULL!";
LABEL_86:
    objc_msgSend(v50, "WFLog:message:", 4, v51);
    goto LABEL_87;
  }
  if (valuePtr != 102)
  {
    if (valuePtr != 101)
      return;
    v8 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("enabled"));
    v9 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("learningPeriod"));
    v10 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("expiryPeriod"));
    v11 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("envType"));
    v12 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("roamTriggerRssi"));
    v13 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("roamDelta"));
    v14 = CFDictionaryGetValue(a2, CFSTR("voipAndMotionTest"));
    v15 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("voipState"));
    v16 = a2;
    v17 = v8;
    v18 = (const __CFNumber *)CFDictionaryGetValue(v16, CFSTR("motionState"));
    if (v17)
    {
      v19 = CFBooleanGetValue(v17);
      *(_BYTE *)(a1 + 256) = v19;
      if (!v19)
      {
        v20 = 0;
        Mutable = 0;
        v22 = 0;
        v23 = 0;
        *(_DWORD *)(a1 + 260) = 259200;
        *(_QWORD *)(a1 + 264) = 2592000;
        *(_QWORD *)(a1 + 280) = 0;
        *(_DWORD *)(a1 + 287) = 0;
LABEL_98:
        v54 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
        v55 = sub_10002A21C(a1, v54, 1);
        if (v55)
        {
          v56 = v55;
          v57 = *(const __CFArray **)(a1 + 3528);
          if (v57)
          {
            v69.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
            v69.location = 0;
            FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v57, v69, v56);
            if (FirstIndexOfValue != -1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
              if (ValueAtIndex)
              {
                v60 = ValueAtIndex;
                v61 = *(_QWORD *)(a1 + 64);
                v62 = sub_100029860(v61);
                v63 = sub_10002A724(a1, v60);
                sub_100066F20(v61, v62, v60, v63, v23, v22, *(__int16 *)(a1 + 284));
              }
            }
          }
          CFRelease(v56);
        }
LABEL_104:
        if (v20)
          CFRelease(v20);
        goto LABEL_106;
      }
    }
    else if (!*(_BYTE *)(a1 + 256))
    {
      return;
    }
    if (v9)
      CFNumberGetValue(v9, kCFNumberIntType, (void *)(a1 + 260));
    if (v10)
      CFNumberGetValue(v10, kCFNumberIntType, (void *)(a1 + 264));
    if (v11)
      CFNumberGetValue(v11, kCFNumberIntType, (void *)(a1 + 268));
    if (v12)
      CFNumberGetValue(v12, kCFNumberIntType, (void *)(a1 + 280));
    v43 = v14;
    if (v13)
      CFNumberGetValue(v13, kCFNumberIntType, (void *)(a1 + 284));
    if (v14)
    {
      Mutable = 0;
      v23 = 0;
      v22 = 0;
      v20 = 0;
      if (v15 && v18)
      {
        CFNumberGetValue(v15, kCFNumberCharType, (void *)(a1 + 289));
        CFNumberGetValue(v18, kCFNumberCharType, (void *)(a1 + 290));
        v20 = 0;
        Mutable = 0;
        *(_BYTE *)(a1 + 288) = 1;
        goto LABEL_60;
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 280) && *(_DWORD *)(a1 + 284))
      {
        v44 = v17;
        Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          v45 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v45)
          {
            v20 = v45;
            CFDictionarySetValue(v45, CFSTR("IO80211InterfaceRoamTargetRssiDelta"), v13);
            CFDictionarySetValue(Mutable, CFSTR("IO80211InterfaceRoamMotionTrafficParams"), v20);
            v22 = 0;
            v23 = 2;
            goto LABEL_57;
          }
          v53 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: offsetOptions create failed", "__WiFiDeviceManagerSetRoamTestParams");
        }
        else
        {
          v53 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: offsetOptDict create failed", "__WiFiDeviceManagerSetRoamTestParams");
        }
        objc_autoreleasePoolPop(v53);
        if (!v44)
        {
LABEL_106:
          if (Mutable)
            CFRelease(Mutable);
          return;
        }
        v20 = 0;
        v22 = 0;
        v23 = 0;
        goto LABEL_98;
      }
      v23 = 0;
      Mutable = 0;
      v20 = 0;
      v22 = 2;
    }
LABEL_57:
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Roam Test Parameters: enabled %d learningPeriod %d expiryPeriod %d envType %d roamTriggerRssi %d roamDelta %d", "__WiFiDeviceManagerSetRoamTestParams", *(unsigned __int8 *)(a1 + 256), *(unsigned int *)(a1 + 260), *(unsigned int *)(a1 + 264), *(unsigned int *)(a1 + 268), *(unsigned int *)(a1 + 280), *(unsigned int *)(a1 + 284));
    objc_autoreleasePoolPop(v46);
    if (!v43)
      goto LABEL_98;
LABEL_60:
    v47 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Roam VoipAndMotionTest Parameters: voipState %d motionState %d", "__WiFiDeviceManagerSetRoamTestParams", *(unsigned __int8 *)(a1 + 289), *(unsigned __int8 *)(a1 + 290));
    objc_autoreleasePoolPop(v47);
    sub_100113D98(a1);
    goto LABEL_104;
  }
  v67 = 0;
  if (!*(_QWORD *)(a1 + 3528))
  {
    v49 = objc_autoreleasePoolPush();
    v50 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_87;
    v51 = "Known broadcast list is NULL!";
    goto LABEL_86;
  }
  v29 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("SSID_STR"));
  if (!v29)
  {
    v49 = objc_autoreleasePoolPush();
    v50 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_87;
    v51 = "ssid not specified!";
    goto LABEL_86;
  }
  v30 = v29;
  v31 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("BSSID"));
  if (!v31)
  {
    v49 = objc_autoreleasePoolPush();
    v50 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v51 = "bssid not specified!";
      goto LABEL_86;
    }
LABEL_87:
    v52 = v49;
LABEL_88:
    objc_autoreleasePoolPop(v52);
    return;
  }
  v32 = v31;
  v33 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("disconnectReason"));
  v34 = objc_autoreleasePoolPush();
  if (!v33)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "disconnectReason not specified!");
    v52 = v34;
    goto LABEL_88;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "disconnectReason %@", v33);
  objc_autoreleasePoolPop(v34);
  CFNumberGetValue(v33, kCFNumberIntType, &v67);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
  if (Count >= 1)
  {
    v36 = Count;
    v37 = 0;
    while (1)
    {
      v38 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v37);
      v39 = objc_autoreleasePoolPush();
      v40 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v41 = sub_10002B088(v38);
        objc_msgSend(v40, "WFLog:message:", 3, "%s: updated network %@ disconnectReason to %d", "__WiFiDeviceManagerAddDisconnectReason", v41, v67);
      }
      objc_autoreleasePoolPop(v39);
      if (v38)
      {
        v42 = (const __CFString *)sub_10002B088(v38);
        if (CFStringCompare(v30, v42, 0) == kCFCompareEqualTo)
          break;
      }
      if (v36 == ++v37)
        return;
    }
    sub_1000C8160((uint64_t)v38, v32, v67);
    sub_1001053C8((NSObject **)a1, v38);
  }
}

uint64_t sub_100112C84(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return 4294963396;
  v3 = sub_100048D30(*(_QWORD *)(a1 + 120), a2);
  v4 = sub_100048110(*(_QWORD *)(a1 + 120));
  objc_msgSend(*(id *)(a1 + 7368), "setTdLogic_badRssiThreshold:goodRssiThreshold:", v4, v5);
  return v3;
}

uint64_t sub_100112CD4(uint64_t a1, uint64_t a2)
{
  void *v5;
  BOOL v6;

  v6 = 0;
  if (a1)
  {
    if (a2)
    {
      *(_BYTE *)(a1 + 6216) = *(_BYTE *)(a2 + 5);
      sub_10007168C(*(_QWORD *)(a1 + 64), &v6);
      *(_BYTE *)(a2 + 6) &= v6;
    }
    return sub_1000420C4(*(_QWORD *)(a1 + 120), a2);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL Device Manager !", "WiFiDeviceManagerSetLQAConfig");
    objc_autoreleasePoolPop(v5);
    return 4294963396;
  }
}

uint64_t sub_100112D80(uint64_t a1, int a2)
{
  void *v3;

  if (a1)
    return sub_1000421C0(*(_QWORD *)(a1 + 120), a2);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL Device Manager !", "WiFiDeviceManagerSetRNFState");
  objc_autoreleasePoolPop(v3);
  return 4294963396;
}

void sub_100112DF8(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    objc_msgSend(*(id *)(a1 + 6648), "setDefaultDenyListThresholds");
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL Device Manager!", "WiFiDeviceManagerSetWoWBlacklistThresholds");
  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_100112E64(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  _BYTE *v4;
  int v5;
  void *v8;
  uint64_t v9;
  void *v10;
  const __CFSet *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  unsigned int v17;

  if (a1)
  {
    v4 = (_BYTE *)(a1 + 5217);
    *(_DWORD *)(a1 + 6776) = *a2;
    v5 = *a2;
    if (*a2 == -536870144 || v5 == -536870256)
    {
      sub_100079490(*(_QWORD *)(a1 + 64), 1);
      if (v4[2] && v4[1] == -*v4)
      {
        v17 = 0;
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disable MIS on Wake: Client Count %d", (v4[1] + *v4));
        objc_autoreleasePoolPop(v8);
        sub_1001065B4(a1, 0, 1, 0, &v17);
      }
      if (!a3)
      {
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null wakeReason.", "__WiFiDeviceManagerSystemWokenForAutoUnlock");
        objc_autoreleasePoolPop(v16);
      }
      v9 = 1;
    }
    else
    {
      if (v5 != -536870272)
        return 0;
      sub_100079490(*(_QWORD *)(a1 + 64), 0);
      if (*(_DWORD *)(a1 + 5424))
      {
        v12 = *(const __CFSet **)(a1 + 3320);
        if (v12)
        {
          if (CFSetGetCount(v12))
          {
            v13 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: system is going to sleep. Tearing down hosted AWDL session.", "WiFiDeviceManagerSetSystemPMState");
            objc_autoreleasePoolPop(v13);
            v14 = *(void **)(a1 + 5432);
            if (v14)

            *(_QWORD *)(a1 + 5432) = 0;
            CFSetApplyFunction(*(CFSetRef *)(a1 + 3320), (CFSetApplierFunction)sub_1001130D0, (void *)a1);
          }
        }
      }
      sub_100113150(a1, 0);
      sub_10010159C(a1);
      v9 = 0;
    }
    v4[2079] = v9;
    v15 = *(void **)(a1 + 7368);
    if (v15)
      objc_msgSend(v15, "setSystemWakeState:wokenByWiFi:", v9, sub_100064EA4());
    return sub_1000422A8(*(unsigned __int8 **)(a1 + 120), v9);
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL Device Manager !", "WiFiDeviceManagerSetSystemPMState");
    objc_autoreleasePoolPop(v10);
    return 4294963396;
  }
}

void sub_1001130D0(uint64_t a1, uint64_t a2)
{
  const void *v3;
  void *v4;

  if (a2)
  {
    v3 = (const void *)sub_100068E60(*(_QWORD *)(a2 + 64));
    sub_1000FB00C(a2, v3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHostedAwdlSessionTearDownApplier");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_100113150(uint64_t a1, int a2)
{
  int v3;
  unsigned int v4;
  BOOL v5;
  void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  dispatch_time_t v10;

  v3 = *(_DWORD *)(a1 + 352);
  v4 = v3 & 0xFFFFFFFE | (a2 != 0);
  *(_DWORD *)(a1 + 352) = v4;
  if (v3)
    v5 = 1;
  else
    v5 = v4 == 0;
  if (v5)
  {
    if (!v4)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 360), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto-join deferral canceled.");
      objc_autoreleasePoolPop(v6);
      if (v3)
      {
        *(_DWORD *)(a1 + 192) = 12;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000285E4(a1, 0xEuLL);
        }
        else
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 14, sub_100025C3C(*(_QWORD *)(a1 + 64)));
          sub_1000FBA80(a1, 2, (uint64_t)"__WiFiDeviceManagerSetAutoJoinDeferral");
        }
      }
    }
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    v8 = v7;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto-join will be deferred for 2 seconds.");
    objc_autoreleasePoolPop(v8);
    v9 = *(NSObject **)(a1 + 360);
    v10 = dispatch_time(0, 2000000000);
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(CFAbsoluteTime *)(a1 + 368) = CFAbsoluteTimeGetCurrent();
  }
}

uint64_t sub_1001132C4(uint64_t a1, int a2)
{
  const void *v4;
  void *v5;
  const void *v6;
  uint64_t v7;
  void *v8;
  const char *v9;

  v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v5 = sub_10002A21C(a1, v4, 1);
  if (!v5)
    return 4294963366;
  v6 = v5;
  if (sub_1000CA608((uint64_t)v5) - 1 <= 1 && *(_BYTE *)(a1 + 5496))
  {
    v7 = sub_100074ED8(*(_QWORD *)(a1 + 64), a2 ^ 1u);
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v9 = "off";
      if (a2)
        v9 = "on";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: speech session is %s in CarPlay", "WiFiDeviceManagerSetSpeechSessionState", v9);
    }
    objc_autoreleasePoolPop(v8);
  }
  else
  {
    v7 = 4294963366;
  }
  CFRelease(v6);
  return v7;
}

uint64_t sub_1001133B0(uint64_t a1, uint64_t a2)
{
  void *v4;
  const char *v5;
  void (*v6)(uint64_t, uint64_t, uint64_t);
  const __CFString *v7;
  const __CFString *v8;
  double v9;
  double v10;
  uint64_t v12;
  double v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  int v17;
  const void *v18;
  void *v19;
  const void *v20;
  const __CFNumber *v21;
  unsigned int v22;
  NSObject *v23;
  dispatch_time_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  void *v28;
  NSDate *v29;
  void *v30;
  CARConnectionEvent *v31;
  NSDate *v32;
  CARConnectionEvent *v33;
  NSDate *v34;
  uint64_t v35;
  void *v36;
  NSObject *v37;
  _QWORD v39[5];
  _QWORD valuePtr[5];
  void **v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t, uint64_t);
  const __CFString *v44;
  const __CFString *v45;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a2 + 24))
      v5 = "Y";
    else
      v5 = "N";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay session vehicle inform: model %@, manufacturer %@, hardware version %@, isSessionActive %s", "WiFiDeviceManagerSetCarPlaySessionState", *(_OWORD *)a2, *(_QWORD *)(a2 + 16), v5);
  }
  objc_autoreleasePoolPop(v4);
  if (!*(_BYTE *)(a2 + 24))
  {
    v23 = *(NSObject **)(a1 + 1056);
    v24 = -1;
    v25 = -1;
LABEL_41:
    dispatch_source_set_timer(v23, v24, v25, 0);
    return 0;
  }
  v6 = *(void (**)(uint64_t, uint64_t, uint64_t))a2;
  *(_QWORD *)(a1 + 8768) = *(_QWORD *)a2;
  v7 = *(const __CFString **)(a2 + 8);
  *(_QWORD *)(a1 + 8776) = v7;
  v8 = *(const __CFString **)(a2 + 16);
  *(_QWORD *)(a1 + 8784) = v8;
  *(_BYTE *)(a1 + 940) = 1;
  v9 = *(double *)(a1 + 704);
  v10 = v9 - *(double *)(a1 + 696);
  if (v10 > 0.0 && v10 <= 10.0)
  {
    v12 = (v10 * 1000.0);
    v13 = *(double *)(a1 + 712);
    v14 = ((v13 - v9) * 1000.0);
    LODWORD(v41) = v12;
    HIDWORD(v41) = ((v13 - v9) * 1000.0);
    v15 = (*(double *)(a1 + 720) - v13) * 1000.0;
    v16 = v15;
    HIDWORD(v42) = 43690;
    v43 = (void (*)(uint64_t, uint64_t, uint64_t))CFSTR("Unknown");
    LODWORD(v42) = v15;
    v17 = *(unsigned __int8 *)(a1 + 728);
    BYTE4(v42) = *(_BYTE *)(a1 + 728);
    v44 = CFSTR("Unknown");
    v45 = CFSTR("Unknown");
    if (v6)
    {
      v43 = v6;
      v44 = v7;
      v45 = v8;
    }
    v18 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v19 = sub_10002A21C(a1, v18, 1);
    if (v19)
    {
      v20 = v19;
      v21 = (const __CFNumber *)sub_1000316E0((uint64_t)v19);
      if (v21)
      {
        LOWORD(valuePtr[0]) = -21846;
        CFNumberGetValue(v21, kCFNumberSInt16Type, valuePtr);
        v22 = LOWORD(valuePtr[0]);
        HIWORD(v42) = valuePtr[0];
      }
      else
      {
        v22 = 0;
      }
      CFRelease(v20);
    }
    else
    {
      v22 = 0;
    }
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v27 = "yes";
      if (!v17)
        v27 = "no";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timeBasicAssocTaken %u ms, time4WayHSTaken %u ms, timeDhcpTaken %u ms, wasScanCanceled %s, channel %u", "__WiFiDeviceManagerSubmitCarPlayConnectMetrics", v12, v14, v16, v27, v22);
    }
    objc_autoreleasePoolPop(v26);
    sub_1000625BC((unsigned int *)&v41);
  }
  v28 = *(void **)(a1 + 968);
  if (v28)
  {
    v29 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *(double *)(a1 + 704));
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay basic assoc date (%@),  ", "__WiFiDeviceManagerSendCarConnectionTime", v29);
    objc_autoreleasePoolPop(v30);
    if (v29)
    {
      v31 = +[CARConnectionEvent eventWithName:type:date:payload:](CARConnectionEvent, "eventWithName:type:date:payload:", CFSTR("Basic assoc completed"), 2, v29, 0);
      v41 = _NSConcreteStackBlock;
      v42 = 3221225472;
      v43 = sub_10013C86C;
      v44 = (const __CFString *)&unk_100231BB0;
      v45 = CFSTR("Basic assoc completed");
      objc_msgSend(v28, "sendConnectionEvent:completion:", v31, &v41);
    }
    v32 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *(double *)(a1 + 712));
    if (v32)
    {
      v33 = +[CARConnectionEvent eventWithName:type:date:payload:](CARConnectionEvent, "eventWithName:type:date:payload:", CFSTR("WPA HS completed"), 2, v32, 0);
      valuePtr[0] = _NSConcreteStackBlock;
      valuePtr[1] = 3221225472;
      valuePtr[2] = sub_10013C8E4;
      valuePtr[3] = &unk_100231BB0;
      valuePtr[4] = CFSTR("WPA HS completed");
      objc_msgSend(v28, "sendConnectionEvent:completion:", v33, valuePtr);
    }
    v34 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *(double *)(a1 + 720));
    if (v34)
    {
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472;
      v39[2] = sub_10013C95C;
      v39[3] = &unk_100231BB0;
      v39[4] = CFSTR("DHCP completed");
      objc_msgSend(v28, "sendConnectionEvent:completion:", +[CARConnectionEvent eventWithName:type:date:payload:](CARConnectionEvent, "eventWithName:type:date:payload:", CFSTR("DHCP completed"), 2, v34, 0), v39);
    }
  }
  if ((_os_feature_enabled_impl("WiFiManager", "LMTPCFor5GHzCarPlay") & 1) != 0
    || _os_feature_enabled_impl("WiFiManager", "LMTPCFor24GHzCarPlay"))
  {
    v35 = *(_QWORD *)(a1 + 64);
    if (v35)
    {
      if (sub_100071674(v35))
      {
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: chipset supports LPC", "WiFiDeviceManagerSetCarPlaySessionState");
        objc_autoreleasePoolPop(v36);
        v37 = *(NSObject **)(a1 + 1056);
        v24 = dispatch_time(0, 600000000000);
        v23 = v37;
        v25 = 600000000000;
        goto LABEL_41;
      }
    }
  }
  return 0;
}

uint64_t sub_1001137F0(uint64_t a1, unsigned int *a2)
{
  const void *v4;
  void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  CFAbsoluteTime Current;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  signed int v24;
  int *v25;
  int v26;
  int v27;
  int *v28;
  int v29;
  unsigned int v30;
  double v31;
  void *v32;
  const char *v33;
  void *v34;
  double v35;
  unint64_t v36;
  double v37;
  uint64_t v38;
  NSObject *v39;
  dispatch_time_t v40;
  void *v41;

  v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v5 = sub_10002A21C(a1, v4, 1);
  if (!v5)
    return 0;
  v6 = v5;
  if (sub_1000CA608((uint64_t)v5) - 1 > 1 || !*(_BYTE *)(a1 + 5496))
    goto LABEL_39;
  v7 = 0;
  v8 = *a2;
  v9 = *((_QWORD *)a2 + 1);
  if (v8 <= 2)
  {
    v10 = a2[1];
    if (v10 <= 0x1E)
    {
      if (*(_DWORD *)(a1 + 3352) == 4)
        v11 = (double)v10;
      else
        v11 = (double)v10 * 0.8;
      Current = CFAbsoluteTimeGetCurrent();
      v13 = Current;
      v14 = Current / 0x3C;
      v15 = v14 - 30 * ((143165577 * (unint64_t)v14) >> 32);
      v16 = (Current - *(double *)(a1 + 8624));
      if (v16 >= 0x3C)
      {
        v17 = v16 / 0x3C;
        if (v16 / 0x3C >= 0x1E)
          v17 = 30;
        v18 = v17 + v15;
        if (v18 >= 0x1E)
          v19 = 30;
        else
          v19 = v18;
        v20 = v19 - (v18 > 0x1D);
        v21 = v18 - v20;
        if (v15 < v20)
        {
          v22 = *(_DWORD *)(a1 + 8764);
          v23 = v13 / 0x708;
          v24 = v14 - 30 * (v13 / 0x708);
          v25 = (int *)(a1 - 120 * v23 + 4 * v14 + 8648);
          do
          {
            v26 = *v25++;
            v22 -= v26;
            *(_DWORD *)(a1 + 8764) = v22;
            ++v24;
          }
          while (v20 > v24);
        }
        if ((int)v21 >= 1)
        {
          v27 = *(_DWORD *)(a1 + 8764);
          v28 = (int *)(a1 + 8644);
          do
          {
            v29 = *v28++;
            v27 -= v29;
            *(_DWORD *)(a1 + 8764) = v27;
            --v21;
          }
          while (v21);
        }
      }
      *(_DWORD *)(a1 + 4 * v15 + 8644) += v10;
      v30 = *(_DWORD *)(a1 + 8764) + v10;
      *(_DWORD *)(a1 + 8764) = v30;
      v31 = dbl_1001BBC20[(_DWORD)v8 == 1];
      if ((_DWORD)v8 == 2)
        v31 = 540.0;
      if (v31 < (double)v30)
        v11 = 0.0;
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v33 = "no";
        if (v11 != 0.0)
          v33 = "yes";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: can relax power ? %s, current duration %u, total duration for past 30 minutes %u, current rate %.1lf", "__WiFiDeviceManagerAdjustDurationOfCarPlayHidSession", v33, v10, *(unsigned int *)(a1 + 8764), (double)*(unsigned int *)(a1 + 8764) / 1800.0);
      }
      objc_autoreleasePoolPop(v32);
      v7 = v11;
    }
  }
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: priority %d, adjusted duration %u, type %@, motion state %d", "__WiFiDeviceManagerAdjustDurationOfCarPlayHidSession", v8, v7, v9, *(unsigned int *)(a1 + 3352));
  objc_autoreleasePoolPop(v34);
  if ((_DWORD)v7
    && ((v35 = CFAbsoluteTimeGetCurrent(), v37 = v35, !*(_BYTE *)(a1 + 8640))
     || (LODWORD(v36) = *(_DWORD *)(a1 + 8616), *(double *)(a1 + 8624) - v35 + (double)v36 < (double)v7)))
  {
    v38 = sub_100074ED8(*(_QWORD *)(a1 + 64), 0);
    if (!(_DWORD)v38)
    {
      v39 = *(NSObject **)(a1 + 8632);
      v40 = dispatch_time(0, 1000000000 * v7);
      dispatch_source_set_timer(v39, v40, 0xFFFFFFFFFFFFFFFFLL, 0);
      v41 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay HID session is active for %u seconds", "WiFiDeviceManagerSetCarPlayHidSessionState", v7);
      objc_autoreleasePoolPop(v41);
      v38 = 0;
      *(_DWORD *)(a1 + 8616) = v7;
      *(double *)(a1 + 8624) = v37;
      *(_BYTE *)(a1 + 8640) = 1;
    }
  }
  else
  {
LABEL_39:
    v38 = 0;
  }
  CFRelease(v6);
  return v38;
}

uint64_t sub_100113B84(uint64_t a1, int a2, double a3)
{
  int v6;
  void *v8;
  void *v9;
  void *v10;
  uint64_t result;
  void *v12;

  if (a1)
  {
    v6 = *(_DWORD *)(a1 + 3352);
    if (a2 != 4 && v6 == 4)
    {
      if (!-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
      {
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: motion state changed from driving and no alternative network interface. Triggering auto-join", "WiFiDeviceManagerSetMotionState");
        objc_autoreleasePoolPop(v8);
        if (!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          goto LABEL_22;
LABEL_20:
        sub_1000285E4(a1, 0x38uLL);
        goto LABEL_22;
      }
      v6 = *(_DWORD *)(a1 + 3352);
    }
    if (v6 == 4)
    {
      if ((a2 | 2) != 6)
        goto LABEL_17;
    }
    else if (v6 == 6 && (a2 | 2) != 6)
    {
LABEL_17:
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: motion state changed from driving. Resetting auto-join intervals.", "WiFiDeviceManagerSetMotionState");
      objc_autoreleasePoolPop(v9);
      if (!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerSetMotionState");
        goto LABEL_22;
      }
      goto LABEL_20;
    }
LABEL_22:
    *(_DWORD *)(a1 + 3352) = a2;
    *(double *)(a1 + 3360) = a3;
    sub_1000433C8(*(_QWORD *)(a1 + 120), a2, a3);
    sub_100079478(*(_QWORD *)(a1 + 64), *(_DWORD *)(a1 + 3352) > 1u);
    sub_100113D98(a1);
    v10 = *(void **)(a1 + 7368);
    if (v10)
      objc_msgSend(v10, "setMotionState:", sub_100024674(*(_DWORD *)(a1 + 3352)));
    result = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
    if (result)
    {
      objc_msgSend((id)result, "setDeviceMotionState:", *(unsigned int *)(a1 + 3352));
      return 0;
    }
    return result;
  }
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerSetMotionState");
  objc_autoreleasePoolPop(v12);
  return 4294963396;
}

void sub_100113D98(uint64_t a1)
{
  void *v1;
  int v3;
  uint64_t v4;
  _BYTE *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v17;
  __CFDictionary *v18;
  __CFDictionary *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  const void *v23;
  void *v24;
  const __CFArray *v25;
  uint64_t v26;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const void *v29;
  const __CFNumber *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  const char *v38;
  const __CFNumber *v39;
  __CFDictionary *cf;
  unint64_t valuePtr;
  CFRange v42;

  valuePtr = 0;
  if (*(_BYTE *)(a1 + 3414) == 1)
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not changing AppRoamPolicy due to AWDL realtime session in progress", "__WiFiDeviceManagerSetAppRoamPolicy");
LABEL_4:
    objc_autoreleasePoolPop(v1);
    return;
  }
  v3 = *(unsigned __int8 *)(a1 + 256);
  if (*(_BYTE *)(a1 + 256))
  {
    if (!*(_BYTE *)(a1 + 288))
    {
      v4 = 0;
      goto LABEL_32;
    }
    v4 = *(unsigned __int8 *)(a1 + 290);
    v5 = (_BYTE *)(a1 + 289);
  }
  else
  {
    v4 = *(unsigned int *)(a1 + 3352);
    v5 = (_BYTE *)(a1 + 3408);
  }
  if (!*v5)
  {
LABEL_32:
    if (*(_DWORD *)(a1 + 300) == 2)
      return;
    v17 = 0;
    v19 = 0;
    v39 = 0;
    v15 = 0;
    v21 = 0;
    *(_OWORD *)(a1 + 296) = xmmword_1001BBC30;
    v20 = 2;
    v22 = "NO";
LABEL_34:
    v38 = v22;
    v23 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
    v24 = sub_10002A21C(a1, v23, 1);
    cf = v17;
    if (v24)
    {
      v25 = *(const __CFArray **)(a1 + 3528);
      if (!v25)
      {
        v26 = v4;
        v30 = v15;
        goto LABEL_44;
      }
      v26 = v4;
      v42.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
      v42.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v25, v42, v24);
      if (FirstIndexOfValue != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
        if (!ValueAtIndex)
        {
          v30 = v15;
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is NULL", "__WiFiDeviceManagerSetAppRoamPolicy", v37);
          goto LABEL_77;
        }
        v29 = ValueAtIndex;
        v30 = v15;
        LODWORD(v25) = sub_10002A724(a1, ValueAtIndex);
        if ((v25 & 0xFFFFFFFD) != 4)
        {
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not multiAP environment for %@. Exiting!", "__WiFiDeviceManagerSetAppRoamPolicy", sub_10002B088(v29));
LABEL_77:
          objc_autoreleasePoolPop(v31);
          v13 = v39;
          goto LABEL_51;
        }
LABEL_44:
        v32 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting AppRoamPolicy with roamDelta %d isVoipCallActive %s motionState %d", "__WiFiDeviceManagerSetAppRoamPolicy", valuePtr, v38, v26);
        objc_autoreleasePoolPop(v32);
        v13 = v39;
        if (!(_DWORD)v25)
        {
          v25 = (const __CFArray *)objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Current network not found in known networks, defaulting to multiAP !", "__WiFiDeviceManagerSetAppRoamPolicy");
          objc_autoreleasePoolPop(v25);
          LODWORD(v25) = 4;
        }
        v33 = *(_QWORD *)(a1 + 64);
        v34 = sub_100029860(v33);
        sub_100066F20(v33, v34, v24, v25, v21, v20, *(__int16 *)(a1 + 308));
        if (!v24)
        {
LABEL_52:
          v15 = v30;
          v17 = cf;
          if (!v13)
          {
LABEL_54:
            if (v15)
              CFRelease(v15);
            if (v19)
              CFRelease(v19);
            if (v17)
              CFRelease(v17);
            return;
          }
LABEL_53:
          CFRelease(v13);
          goto LABEL_54;
        }
LABEL_51:
        CFRelease(v24);
        goto LABEL_52;
      }
    }
    else
    {
      v26 = v4;
    }
    v30 = v15;
    LODWORD(v25) = 0;
    goto LABEL_44;
  }
  if ((v4 & 0xFFFFFFFE) == 2)
  {
    v6 = -70;
    v7 = 8;
  }
  else
  {
    if ((v4 & 0xFFFFFFFB) != 1)
    {
      v1 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not triggering motion state based roam", "__WiFiDeviceManagerSetAppRoamPolicy");
      goto LABEL_4;
    }
    v6 = -75;
    v7 = 12;
  }
  valuePtr = __PAIR64__(v6, v7);
  if (v3)
  {
    v8 = *(unsigned int *)(a1 + 280);
    if ((_DWORD)v8)
    {
      v9 = *(unsigned int *)(a1 + 284);
      if ((_DWORD)v9)
      {
        valuePtr = __PAIR64__(v8, v9);
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (*(_BYTE *)(a1 + 288))
            v11 = " Simulating VoIP Call active!";
          else
            v11 = "!";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: !!DEBUG MODE%s Roam Trigger %d And Roam Delta %d", "__WiFiDeviceManagerSetAppRoamPolicy", v11, v8, v9);
        }
        objc_autoreleasePoolPop(v10);
        v6 = v8;
        v7 = v9;
      }
    }
  }
  if (*(_DWORD *)(a1 + 296) != 2 || *(_DWORD *)(a1 + 308) != v7 || *(_DWORD *)(a1 + 304) != v6)
  {
    *(_QWORD *)(a1 + 296) = 2;
    *(_DWORD *)(a1 + 308) = v7;
    *(_DWORD *)(a1 + 304) = v6;
    v12 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    if (v12)
    {
      v13 = v12;
      v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      if (v14)
      {
        v15 = v14;
        Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          v17 = Mutable;
          v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v18)
          {
            v19 = v18;
            v39 = v13;
            CFDictionarySetValue(v18, CFSTR("IO80211InterfaceRoamTargetRssiDelta"), v15);
            CFDictionarySetValue(v17, CFSTR("IO80211InterfaceRoamMotionTrafficParams"), v19);
            v20 = 0;
            v21 = 2;
            v22 = "YES";
            goto LABEL_34;
          }
          v36 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: offsetOptions create failed", "__WiFiDeviceManagerSetAppRoamPolicy");
        }
        else
        {
          v36 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: offsetOptDict create failed", "__WiFiDeviceManagerSetAppRoamPolicy");
          v17 = 0;
        }
      }
      else
      {
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: roamDeltaRef create failed", "__WiFiDeviceManagerSetAppRoamPolicy");
        v17 = 0;
        v15 = 0;
      }
      objc_autoreleasePoolPop(v36);
      v19 = 0;
      goto LABEL_53;
    }
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: roamTriggerRssiRef create failed", "__WiFiDeviceManagerSetAppRoamPolicy");
    objc_autoreleasePoolPop(v35);
  }
}

void sub_1001143A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  if (a1)
  {
    v4 = sub_100029860(*(_QWORD *)(a1 + 64));
    if (v4)
    {
      sub_1000AD3B0(*(_QWORD *)(a1 + 6792), a1, v4, a2);
      return;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - interface is NULL!", "__WiFiDeviceManagerTdConfirmedCallback");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Manager is NULL!", "__WiFiDeviceManagerTdConfirmedCallback");
  }
  objc_autoreleasePoolPop(v5);
}

void sub_100114468(uint64_t a1, int a2, int a3, int a4)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  BOOL v9;
  CFBooleanRef v10;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  uint64_t v13;
  const void *v14;
  int v15;
  int valuePtr;
  void *values[3];
  void *keys[2];
  const __CFString *v19;

  v15 = a3;
  valuePtr = a2;
  if (sub_1000716CC(*(_QWORD *)(a1 + 64)))
  {
    *(_OWORD *)keys = *(_OWORD *)off_1002315F0;
    v19 = CFSTR("IO80211InterfaceDualPowerCellularTxShort");
    memset(values, 170, sizeof(values));
    v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
    v8 = v7;
    if (v6)
      v9 = v7 == 0;
    else
      v9 = 1;
    if (v9)
    {
      if (!v6)
      {
LABEL_12:
        if (v8)
          CFRelease(v8);
        return;
      }
    }
    else
    {
      v10 = kCFBooleanTrue;
      if (!a4)
        v10 = kCFBooleanFalse;
      values[0] = v6;
      values[1] = v7;
      values[2] = v10;
      v11 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v11)
      {
        v12 = v11;
        v13 = *(_QWORD *)(a1 + 64);
        v14 = (const void *)sub_100025C3C(v13);
        sub_1000672C0(v13, v14, 499, 0, (uint64_t)v12);
        CFRelease(v12);
      }
      *(_BYTE *)(a1 + 6184) = v15 == 1;
    }
    CFRelease(v6);
    goto LABEL_12;
  }
}

uint64_t sub_1001145F0(uint64_t a1, int a2)
{
  const CFBooleanRef *v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  v2 = &kCFBooleanTrue;
  if (!a2)
    v2 = &kCFBooleanFalse;
  v3 = (uint64_t)*v2;
  v4 = *(_QWORD *)(a1 + 64);
  v5 = (const void *)sub_100025C3C(v4);
  return sub_1000672C0(v4, v5, 486, 0, v3);
}

uint64_t sub_100114644(uint64_t a1, int a2)
{
  const CFBooleanRef *v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  v2 = &kCFBooleanTrue;
  if (!a2)
    v2 = &kCFBooleanFalse;
  v3 = (uint64_t)*v2;
  v4 = *(_QWORD *)(a1 + 64);
  v5 = (const void *)sub_100025C3C(v4);
  return sub_1000672C0(v4, v5, 448, 0, v3);
}

void sub_100114698(uint64_t a1, double a2)
{
  void *v4;
  void *v5;

  if (a1)
  {
    if (*(double *)(a1 + 6784) != a2)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timeout %f", "WiFiDeviceManagerSetNANOffHeadConnectionExpiry", *(_QWORD *)&a2);
      objc_autoreleasePoolPop(v4);
      *(double *)(a1 + 6784) = a2;
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetNANOffHeadConnectionExpiry");
    objc_autoreleasePoolPop(v5);
  }
}

double sub_100114768(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(double *)(a1 + 6784);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "WiFiDeviceManagerGetNANOffHeadConnectionExpiry");
  objc_autoreleasePoolPop(v2);
  return 0.0;
}

void sub_1001147D4(uint64_t a1, const void *a2, int a3)
{
  IOPMAssertionID v5;
  const __CFString *v6;
  const __CFString *v7;
  void *v8;
  void *v9;
  const void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  const void *v14;
  const void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;

  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad args: manager %p network %p", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", 0, a2);
    goto LABEL_26;
  }
  v5 = *(_DWORD *)(a1 + 6580);
  if (!v5)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: PM assertion not held.", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", v17, v18);
    goto LABEL_26;
  }
  if (!*(_QWORD *)(a1 + 6592))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: PM assertion Network NULL.", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", v17, v18);
LABEL_26:
    v13 = v16;
    goto LABEL_14;
  }
  if (a2 && !a3)
  {
    v6 = (const __CFString *)sub_10002B088(*(const void **)(a1 + 6592));
    v7 = (const __CFString *)sub_10002B088(a2);
    if (CFStringCompare(v6, v7, 0))
    {
      v8 = objc_autoreleasePoolPush();
      v9 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v10 = sub_10002B088(a2);
        objc_msgSend(v9, "WFLog:message:", 4, "%s: Bail out as Join Assertion was held for different network! network->ssid:%@ manager->autoJoinPMAssertionNetwork:%@ ", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", v10, sub_10002B088(*(const void **)(a1 + 6592)));
      }
LABEL_13:
      v13 = v8;
LABEL_14:
      objc_autoreleasePoolPop(v13);
      return;
    }
    v5 = *(_DWORD *)(a1 + 6580);
  }
  v11 = IOPMAssertionRelease(v5);
  v8 = objc_autoreleasePoolPush();
  v12 = (void *)qword_10026DD20;
  if ((_DWORD)v11)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to release autojoin PM Assertion error=%d", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", v11, v18);
    goto LABEL_13;
  }
  if (qword_10026DD20)
  {
    v14 = sub_10002B088(a2);
    objc_msgSend(v12, "WFLog:message:", 3, "%s: wake assertion released for network %@ current timestamp:%f", "__WiFiDeviceManagerReleaseWakeAssertionForAutoJoin", v14, CFAbsoluteTimeGetCurrent());
  }
  objc_autoreleasePoolPop(v8);
  *(_DWORD *)(a1 + 6580) = 0;
  *(_QWORD *)(a1 + 6584) = 0;
  v15 = *(const void **)(a1 + 6592);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 6592) = 0;
  }
}

uint64_t sub_1001149F4(uint64_t a1, int a2)
{
  void **v3;
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  uint64_t v6;
  const void *v7;
  void *v9;
  void *values;
  void *keys;

  if (a1)
  {
    *(_BYTE *)(a1 + 3689) = a2 != 0;
    keys = CFSTR("IO80211InterfaceBatterySaveModeState");
    v3 = (void **)&kCFBooleanTrue;
    if (!a2)
      v3 = (void **)&kCFBooleanFalse;
    values = *v3;
    v4 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)(a1 + 64);
      v7 = (const void *)sub_100025C3C(v6);
      sub_1000672C0(v6, v7, 472, 0, (uint64_t)v5);
      CFRelease(v5);
    }
    return 0;
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL Device Manager !", "WiFiDeviceManagerSetBatterySaverModeConfiguration");
    objc_autoreleasePoolPop(v9);
    return 4294963396;
  }
}

uint64_t sub_100114B24()
{
  return _os_feature_enabled_impl("WiFiManager", "IgnoreAVCAssertion") ^ 1;
}

uint64_t sub_100114B4C(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFBoolean *v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  BOOL *v10;
  void *v11;
  void *v12;
  const void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  const char *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v23;
  void *v24;
  _BOOL8 v25;
  CFDictionaryRef v26;
  CFDictionaryRef v27;
  uint64_t v28;
  const void *v29;
  CFDictionaryRef v30;
  CFDictionaryRef v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  void *values;
  void *keys;

  if (!a1 || !theDict)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_41;
    v18 = "Error: %s: device manager or policy dict is NULL";
    goto LABEL_65;
  }
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("appPolicyUUID"));
  v5 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("appPolicyState"));
  v6 = CFBooleanGetValue(v5);
  v7 = -[WiFiUserInteractionMonitor isCoPresenceActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCoPresenceActive");
  if (Value)
    v8 = v5 == 0;
  else
    v8 = 1;
  if (v8)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_41;
    v18 = "Error: %s: policy dict has NULL values";
LABEL_65:
    v21 = 4;
    goto LABEL_40;
  }
  v9 = v7;
  v10 = (BOOL *)(a1 + 5497);
  if (CFStringCompare(Value, CFSTR("CB06911C-82BE-44A9-8359-F8C02AAF82DB"), 0))
    goto LABEL_8;
  if (*v10 == (_DWORD)v6 && *(unsigned __int8 *)(a1 + 5499) == v9)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v34 = v6;
      v18 = "%s: Duplicate avc assertion (callState=%d), bail out";
LABEL_39:
      v21 = 3;
LABEL_40:
      objc_msgSend(v17, "WFLog:message:", v21, v18, "WiFiDeviceManagerSetAppPolicy", v34);
      goto LABEL_41;
    }
    goto LABEL_41;
  }
  if (_os_feature_enabled_impl("WiFiManager", "IgnoreAVCAssertion"))
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v34 = v6;
      v18 = "%s: avc assertion (callState=%d) not for infra, bail out";
      goto LABEL_39;
    }
LABEL_41:
    objc_autoreleasePoolPop(v16);
    return 4294963396;
  }
  *(_BYTE *)(a1 + 3408) = v6;
  *v10 = v5 == kCFBooleanTrue;
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: FT call started/ended ? %d ", "WiFiDeviceManagerSetAppPolicy", v6);
  objc_autoreleasePoolPop(v23);
  v24 = *(void **)(a1 + 7368);
  if (v24)
  {
    if (*(_BYTE *)(a1 + 3409))
      v25 = 1;
    else
      v25 = *(_BYTE *)(a1 + 3408) != 0;
    objc_msgSend(v24, "setCallState:", v25);
  }
  sub_1000427BC(*(_QWORD *)(a1 + 120), -[WiFiUserInteractionMonitor isAVConferenceActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAVConferenceActive"));
  sub_100113D98(a1);
  if (!(_DWORD)v6)
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_1000285E4(a1, 0x1AuLL);
    else
      sub_1000FA0A0(a1, 1);
  }
  values = v5;
  keys = CFSTR("IO80211InterfaceCallStatus");
  v30 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v30)
  {
    v31 = v30;
    v32 = *(_QWORD *)(a1 + 64);
    v33 = (const void *)sub_100025C3C(v32);
    sub_100079574(v32, v33, v31);
    CFRelease(v31);
  }
  Value = CFSTR("FACETIME_UUID");
LABEL_8:
  if (CFStringCompare(Value, CFSTR("WiFiCallingUUID"), 0) == kCFCompareEqualTo)
  {
    if (*(unsigned __int8 *)(a1 + 3408) != (_DWORD)v6)
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFi call started/ended ? %d ", "WiFiDeviceManagerSetAppPolicy", v6);
      objc_autoreleasePoolPop(v19);
      *(_BYTE *)(a1 + 3408) = v6;
      v20 = *(void **)(a1 + 7368);
      if (v20)
        objc_msgSend(v20, "setCallState:", (*(unsigned __int8 *)(a1 + 3409) | v6) != 0);
      sub_100113D98(a1);
      if (!(_DWORD)v6)
      {
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          sub_1000285E4(a1, 0x1AuLL);
        else
          sub_1000FA0A0(a1, 1);
      }
      values = v5;
      keys = CFSTR("IO80211InterfaceCallStatus");
      v26 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v26)
      {
        v27 = v26;
        v28 = *(_QWORD *)(a1 + 64);
        v29 = (const void *)sub_100025C3C(v28);
        sub_100079574(v28, v29, v27);
        CFRelease(v27);
      }
      goto LABEL_9;
    }
    return 4294963396;
  }
LABEL_9:
  if (CFStringCompare(Value, CFSTR("airplay"), 0) == kCFCompareEqualTo)
  {
    *(_BYTE *)(a1 + 5498) = v5 == kCFBooleanTrue;
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s manager->latencySensitiveServices.airplayOverInfra:%u", "WiFiDeviceManagerSetAppPolicy", *(unsigned __int8 *)(a1 + 5498));
    objc_autoreleasePoolPop(v11);
    -[WiFiUserInteractionMonitor updateIsAirplayActiveOverInfra:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "updateIsAirplayActiveOverInfra:", v5 == kCFBooleanTrue);
  }
  if (CFStringCompare(Value, CFSTR("kApple80211KeyGameModeUUIDString"), 0) == kCFCompareEqualTo)
  {
    *(_BYTE *)(a1 + 5500) = v5 == kCFBooleanTrue;
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s manager->latencySensitiveServices.gameMode:%u", "WiFiDeviceManagerSetAppPolicy", *(unsigned __int8 *)(a1 + 5500));
    objc_autoreleasePoolPop(v12);
    sub_100114644(a1, *(unsigned __int8 *)(a1 + 5500));
  }
  if (*(_BYTE *)(a1 + 3408) && sub_10006FA28(*(_QWORD *)(a1 + 64)))
  {
    v13 = (const void *)sub_100068E60(*(_QWORD *)(a1 + 64));
    sub_1000FB00C(a1, v13);
  }
  v14 = sub_100073F80(*(_QWORD *)(a1 + 64), Value, v5);
  sub_1000FA884(a1, 0);
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s()CATS App update: device=%p deviceManager:%p\n ", "WiFiDeviceManagerSetAppPolicy", a1, *(_QWORD *)(a1 + 64));
  objc_autoreleasePoolPop(v15);
  if (*(_BYTE *)(a1 + 433))
    sub_100024EE4(a1, 5);
  return v14;
}

uint64_t sub_100115154(uint64_t a1, uint64_t a2, void *key)
{
  void *Value;
  id v7;
  uint64_t v8;
  id v9;
  void *v10;
  WiFiUserInteractionMonitor *v11;
  void *v12;
  uint64_t v13;
  void *v15;
  uint64_t v16;
  unsigned __int8 v17;

  if (!a1)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: device manager is NULL", "WiFiDeviceManagerAppTrafficRegistration");
    goto LABEL_29;
  }
  if (!a2)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: trafficReg is NULL", "WiFiDeviceManagerAppTrafficRegistration");
    goto LABEL_29;
  }
  if (!key)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: clientID is NULL", "WiFiDeviceManagerAppTrafficRegistration");
    goto LABEL_29;
  }
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 7064), key);
  if (!Value
    || (v7 = Value,
        v8 = objc_opt_class(AWDLServiceDiscoveryManager),
        (objc_opt_isKindOfClass(v7, v8) & 1) == 0))
  {
    v7 = objc_alloc_init((Class)AWDLServiceDiscoveryManager);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 7064), key, v7);
  }
  v17 = 0;
  v9 = objc_msgSend(objc_alloc((Class)AWDLTrafficRegistrationConfiguration), "initWithDictionary:isActive:", a2, &v17);
  if (!v9)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to send traffic registration because failed to parse dictionary", v16);
LABEL_29:
    objc_autoreleasePoolPop(v15);
    v10 = 0;
    v13 = 4294963396;
    goto LABEL_18;
  }
  v10 = v9;
  if (v17)
  {
    if ((objc_msgSend(v7, "setTrafficRegistration:error:", v9, 0) & 1) != 0)
      goto LABEL_10;
LABEL_20:
    v13 = 4294963365;
    goto LABEL_18;
  }
  if (!objc_msgSend(v7, "clearTrafficRegistration:error:", v9, 0))
    goto LABEL_20;
LABEL_10:
  if ((objc_msgSend(v10, "options") & 1) != 0
    && objc_msgSend(objc_msgSend(v10, "peerAddress"), "isEqual:", objc_msgSend(objc_alloc((Class)WiFiMACAddress), "initWithAddress:", 0)))
  {
    *(_BYTE *)(a1 + 5498) = v17;
    v11 = +[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance");
    -[WiFiUserInteractionMonitor updateIsAirplayActiveOverInfra:](v11, "updateIsAirplayActiveOverInfra:", v17);
  }
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s manager->latencySensitiveServices.airplayOverInfra:%u", "WiFiDeviceManagerAppTrafficRegistration", *(unsigned __int8 *)(a1 + 5498));
  objc_autoreleasePoolPop(v12);
  sub_1000FA884(a1, 0);
  if (*(_BYTE *)(a1 + 433))
    sub_100024EE4(a1, 4);
  v13 = 0;
LABEL_18:

  return v13;
}

uint64_t sub_1001153E4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4488) = a2;
  *(_QWORD *)(result + 4496) = a3;
  return result;
}

uint64_t sub_1001153F0(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4, unsigned int a5, const void *a6)
{
  return sub_100115414(a1, 0, a2, a3, a4, a5, a6, (uint64_t)sub_1001157F0);
}

uint64_t sub_100115414(uint64_t a1, __CFDictionary *a2, uint64_t a3, unsigned int *a4, unsigned int a5, unsigned int a6, const void *a7, uint64_t a8)
{
  CFNumberRef v16;
  CFMutableArrayRef Mutable;
  __CFArray *v18;
  __CFDictionary *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  void *v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  uint64_t v29;
  void *v31;
  const __CFNumber *v32;
  _QWORD v33[3];

  if (!a1)
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
    goto LABEL_49;
  }
  memset(v33, 170, sizeof(v33));
  if (!(_DWORD)a3)
  {
    v16 = 0;
    if (a5)
      goto LABEL_5;
    goto LABEL_15;
  }
  v33[2] = a3;
  v16 = CFNumberCreate(0, kCFNumberCFIndexType, &v33[2]);
  if (!v16)
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numProbesRef is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
LABEL_49:
    objc_autoreleasePoolPop(v31);
    return 4294963394;
  }
  if (a5)
  {
LABEL_5:
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (!Mutable)
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeSizeArrRef is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
      v25 = 0;
      v28 = 0;
      v18 = 0;
      goto LABEL_53;
    }
    v18 = Mutable;
    v32 = v16;
    v19 = a2;
    v20 = a8;
    v21 = a5;
    do
    {
      v22 = *a4++;
      v33[1] = v22;
      v23 = CFNumberCreate(0, kCFNumberCFIndexType, &v33[1]);
      if (!v23)
      {
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeSizeRef is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
        v25 = 0;
        v28 = 0;
        v29 = 4294963394;
        v16 = v32;
        goto LABEL_29;
      }
      v24 = v23;
      CFArrayAppendValue(v18, v23);
      CFRelease(v24);
      --v21;
    }
    while (v21);
    a8 = v20;
    a2 = v19;
    v16 = v32;
    if (!a6)
      goto LABEL_16;
    goto LABEL_10;
  }
LABEL_15:
  v18 = 0;
  if (!a6)
  {
LABEL_16:
    v25 = 0;
    goto LABEL_17;
  }
LABEL_10:
  v33[0] = a6;
  v25 = CFNumberCreate(0, kCFNumberCFIndexType, v33);
  if (!v25)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeTimeoutSecsRef is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
    v25 = 0;
LABEL_46:
    v28 = 0;
LABEL_53:
    v29 = 4294963394;
    goto LABEL_29;
  }
LABEL_17:
  v27 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v27)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeOptions is NULL !", "__WiFiDeviceManagerTriggerActiveProbe");
    goto LABEL_46;
  }
  v28 = v27;
  if (v16)
    CFDictionarySetValue(v27, CFSTR("kWiFiLqaMgrNumProbes"), v16);
  if (v18)
    CFDictionarySetValue(v28, CFSTR("kWiFiLqaMgrProbeSize"), v18);
  if (v25)
    CFDictionarySetValue(v28, CFSTR("kWiFiLqaMgrProbeTimeoutSecs"), v25);
  if (a7)
    CFDictionarySetValue(v28, CFSTR("kWiFiLqaMgrIpv4Addr"), a7);
  v29 = sub_100042AB8(*(_QWORD *)(a1 + 120), v28, a2, a8, a1);
  if (!(_DWORD)v29)
    goto LABEL_30;
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to Enqueue active probing with %d probes", "__WiFiDeviceManagerTriggerActiveProbe", a3);
LABEL_29:
  objc_autoreleasePoolPop(v26);
LABEL_30:
  if (v16)
    CFRelease(v16);
  if (v25)
    CFRelease(v25);
  if (v28)
    CFRelease(v28);
  if (v18)
    CFRelease(v18);
  return v29;
}

void sub_1001157F0(void *value, CFMutableArrayRef theArray, uint64_t a3, uint64_t a4)
{
  void (*v6)(uint64_t, _QWORD, _QWORD, uint64_t, CFMutableArrayRef);

  CFArrayAppendValue(theArray, value);
  v6 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, CFMutableArrayRef))(a4 + 4392);
  if (v6)
    v6(a4, 0, *(_QWORD *)(a4 + 4400), 6, theArray);
}

void sub_100115844(uint64_t a1, int a2)
{
  NSObject *v3;
  dispatch_time_t v4;

  *(_BYTE *)(a1 + 5504) = a2;
  v3 = *(NSObject **)(a1 + 5512);
  if (a2)
    v4 = dispatch_time(0, 10000000000);
  else
    v4 = -1;
  dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
  *(_DWORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 680) = 0;
}

void sub_1001158A8(uint64_t a1, int a2)
{
  double Current;

  *(_DWORD *)(a1 + 5520) = a2;
  *(_BYTE *)(a1 + 1064) = 0;
  if (a2 == 1)
  {
    Current = CFAbsoluteTimeGetCurrent();
    if (Current - *(double *)(a1 + 696) > 10.0)
    {
      *(double *)(a1 + 696) = Current;
      *(_BYTE *)(a1 + 728) = 0;
    }
  }
}

void sub_1001158F4(uint64_t a1, uint64_t a2)
{
  sub_100076148(*(_QWORD *)(a1 + 64), a2);
}

uint64_t sub_1001158FC(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  if (a1)
  {
    if (!sub_100018FE4(a1) && !*(_BYTE *)(a1 + 3414))
      return 0;
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifid is hosting AWDL session.", "WiFiDeviceManagerIsHostingAwdlSession");
    v3 = 1;
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerIsHostingAwdlSession");
    v3 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

void sub_1001159BC(uint64_t a1, CFArrayRef theArray)
{
  const void *v4;

  v4 = *(const void **)(a1 + 5584);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5584) = 0;
  }
  if (theArray)
    *(_QWORD *)(a1 + 5584) = CFArrayCreateCopy(kCFAllocatorDefault, theArray);
}

uint64_t sub_100115A08(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return sub_100079398(*(_QWORD *)(a1 + 64), a2);
  else
    return 83;
}

void sub_100115A20(uint64_t a1)
{
  void *v2;
  void *v3;
  const void *v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  uint64_t v7;
  const void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *values[2];
  void *keys[2];

  v2 = (void *)MGCopyAnswer(CFSTR("ProductType"), 0);
  v3 = (void *)MGCopyAnswer(CFSTR("ProductVersion"), 0);
  v4 = v3;
  if (v2)
  {
    if (v3)
    {
      *(_OWORD *)keys = *(_OWORD *)off_100231608;
      values[0] = v2;
      values[1] = v3;
      v5 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v5)
      {
        v6 = v5;
        v7 = *(_QWORD *)(a1 + 64);
        v8 = (const void *)sub_100025C3C(v7);
        sub_1000672C0(v7, v8, 490, 0, (uint64_t)v6);
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: productType:%@ iosVersion:%@", "WiFiDeviceManagerSetDeviceInfo", v2, v4);
        objc_autoreleasePoolPop(v9);
LABEL_7:
        CFRelease(v2);
        if (!v4)
          goto LABEL_9;
        goto LABEL_8;
      }
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s; failed to create dictionary",
          "WiFiDeviceManagerSetDeviceInfo");
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: iosVersion is NULL", "WiFiDeviceManagerSetDeviceInfo");
    }
    objc_autoreleasePoolPop(v11);
    v6 = 0;
    goto LABEL_7;
  }
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: productType is NULL", "WiFiDeviceManagerSetDeviceInfo");
  objc_autoreleasePoolPop(v10);
  v6 = 0;
  if (v4)
LABEL_8:
    CFRelease(v4);
LABEL_9:
  if (v6)
    CFRelease(v6);
}

void sub_100115C30(uint64_t a1, const void *a2)
{
  const void *v4;
  CFTypeRef v5;
  const void *v6;
  CFTypeRef v7;
  NSObject *global_queue;
  const __CFBoolean *v9;
  const __CFBoolean *v10;
  CFTypeID v11;
  void *v12;
  void *v13;
  void *v14;
  _QWORD block[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  if (!a1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerForgetNetwork");
    goto LABEL_16;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "WiFiDeviceManagerForgetNetwork");
LABEL_16:
    objc_autoreleasePoolPop(v13);
    goto LABEL_11;
  }
  v4 = sub_10002B088(a2);
  v5 = CFRetain(v4);
  v21[3] = (uint64_t)v5;
  v6 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  v7 = CFRetain(v6);
  v17[3] = (uint64_t)v7;
  objc_msgSend(*(id *)(a1 + 6648), "removeAllDenyListEntriesWithNetworkName:", v21[3]);
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100115EF8;
  block[3] = &unk_100231620;
  block[4] = &v16;
  block[5] = &v20;
  dispatch_async(global_queue, block);
  if (!sub_10001395C((uint64_t)a2))
    goto LABEL_11;
  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiDeviceManagerForgetNetwork");
    goto LABEL_19;
  }
  v9 = (const __CFBoolean *)sub_10002BE64((uint64_t)a2, CFSTR("AutoHotspotDisableWiFiAutoJoinUntilUserJoin"));
  v10 = v9;
  if (!v9)
    goto LABEL_11;
  v11 = CFGetTypeID(v9);
  if (v11 != CFBooleanGetTypeID())
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid value type", "WiFiDeviceManagerForgetNetwork");
LABEL_19:
    objc_autoreleasePoolPop(v14);
    goto LABEL_11;
  }
  if (CFBooleanGetValue(v10))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Auto Hotspot Disable for %@", "WiFiDeviceManagerForgetNetwork", sub_10002B088(a2));
    objc_autoreleasePoolPop(v12);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6928), a2);
  }
LABEL_11:
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
}

void sub_100115ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100115EF8(uint64_t a1)
{
  const void *v2;
  const void *v3;

  IPConfigurationForgetNetwork(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_100115F6C(uint64_t a1, const void *a2)
{
  const void *v3;
  CFTypeRef v4;
  const void *v5;
  CFTypeRef v6;
  NSObject *global_queue;
  void *v8;
  _QWORD block[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  if (!a1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerForgetPrivateMacNetworkLease");
    goto LABEL_9;
  }
  if (!*(_QWORD *)(a1 + 64))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "WiFiDeviceManagerForgetPrivateMacNetworkLease");
LABEL_9:
    objc_autoreleasePoolPop(v8);
    goto LABEL_4;
  }
  v3 = sub_10002B088(a2);
  v4 = CFRetain(v3);
  v15[3] = (uint64_t)v4;
  v5 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  v6 = CFRetain(v5);
  v11[3] = (uint64_t)v6;
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001160EC;
  block[3] = &unk_100231620;
  block[4] = &v10;
  block[5] = &v14;
  dispatch_async(global_queue, block);
LABEL_4:
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
}

void sub_1001160C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1001160EC(uint64_t a1)
{
  const void *v2;
  const void *v3;

  IPConfigurationForgetNetwork(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_100116160(uint64_t a1, void *a2)
{
  void *v3;
  const char *v4;

  if (a1 && a2)
  {
    sub_1001161F4(a1, a2, 0);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v4 = "manager";
      if (a1)
        v4 = "network";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s is NULL", "WiFiDeviceManagerForceBssidAssociation", v4);
    }
    objc_autoreleasePoolPop(v3);
  }
}

NSError *sub_1001161F4(uint64_t a1, void *a2, int a3)
{
  _BYTE *v6;
  unsigned int v7;
  void *v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  void *v16;
  unsigned int v17;
  void *v18;
  id v19;
  void *v20;
  unsigned int v21;
  void *v22;
  NSString *v23;
  void (*v24)(uint64_t, uint64_t, void *, _QWORD, _QWORD, _QWORD);
  uint64_t v25;
  void *v26;
  const __CFNumber *v27;
  void *v28;
  id v29;
  void *v30;
  char *v31;
  void *v32;
  char *v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  void *v37;
  void *v38;
  const void *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  const void *v43;
  uint64_t v44;
  NSError *v45;
  void *v46;
  char *v48;
  const void *v49;
  _QWORD v50[6];
  NSErrorUserInfoKey v51;
  const __CFString *v52;
  uint8_t buf[4];
  const char *v54;

  v6 = (_BYTE *)(a1 + 5219);
  if ((!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin")
     || !_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition")
     || !v6[1397])
    && !sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
  {
    v7 = sub_100017A54((uint64_t)a2, CFSTR("ASSOC_FLAGS"));
    sub_10002B698((uint64_t)a2, CFSTR("ASSOC_FLAGS"), v7 & 0xFFFFFFFE | 1);
  }
  *(_BYTE *)(a1 + 1200) = sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")) != 0;
  if (sub_100071728(*(_QWORD *)(a1 + 64)) && sub_1000C5124(a2))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_BEACON_PROTECTION because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
    objc_autoreleasePoolPop(v8);
    v9 = sub_100017A54((uint64_t)a2, CFSTR("ASSOC_FLAGS"));
    sub_10002B698((uint64_t)a2, CFSTR("ASSOC_FLAGS"), v9 & 0xFFFF7FFF | 0x8000);
  }
  if (sub_10007174C(*(_QWORD *)(a1 + 64)))
  {
    v10 = sub_1000C51F0((const __CFDictionary *)a2);
    v11 = objc_autoreleasePoolPush();
    if (v10)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
      objc_autoreleasePoolPop(v11);
      v12 = sub_100017A54((uint64_t)a2, CFSTR("ASSOC_FLAGS"));
      sub_10002B698((uint64_t)a2, CFSTR("ASSOC_FLAGS"), v12 & 0xFFFBFFFF | 0x40000);
      v13 = sub_100017A54((uint64_t)a2, CFSTR("WSEC_FLAGS"));
      v14 = sub_1000C5200((const __CFDictionary *)a2);
      v11 = objc_autoreleasePoolPush();
      if (v14)
      {
        v15 = v13 | 0x20000;
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_RESTRICT mode network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
      }
      else
      {
        v15 = v13 | 0x10000;
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_ENABLE because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_DISABLE mode network is incapable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
      v15 = 0;
    }
    objc_autoreleasePoolPop(v11);
    sub_10002B698((uint64_t)a2, CFSTR("WSEC_FLAGS"), v15);
  }
  if (sub_100071740(*(_QWORD *)(a1 + 64)) && sub_1000C519C((CFDictionaryRef *)a2))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_OCV because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2);
    objc_autoreleasePoolPop(v16);
    v17 = sub_100017A54((uint64_t)a2, CFSTR("ASSOC_FLAGS"));
    sub_10002B698((uint64_t)a2, CFSTR("ASSOC_FLAGS"), v17 & 0xFFFDFFFF | 0x20000);
  }
  v18 = sub_100026664((CFDictionaryRef *)a2);
  v19 = sub_100009ACC(a1);
  if (CWFKnownNetworkAssociatedDuringAWDLRealTimeMode(v18, v19))
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_ASSOC_F_PREFER_NON_6GHZ because AWDL real time mode was recently active while associated to this known network (%@)", "__WiFiDeviceManagerAssociateCandidate", v18);
    objc_autoreleasePoolPop(v20);
    v21 = sub_100017A54((uint64_t)a2, CFSTR("ASSOC_FLAGS"));
    sub_10002B698((uint64_t)a2, CFSTR("ASSOC_FLAGS"), v21 & 0xFFFEFFFF | 0x10000);
  }

  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Attempting auto join association of %@"), sub_10002B088(a2))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v54 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v23, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v22);
  if (!sub_100124B34(a1, a2, 1u))
  {
    v51 = NSLocalizedDescriptionKey;
    v52 = CFSTR("Assoc Candidate network not suitable for auto-join");
    v45 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 1, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v52, &v51, 1));
    if (!(_DWORD)v45)
      return v45;
    goto LABEL_68;
  }
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "willAssociateWithNetwork:isAutoJoin:interfaceName:", a2, 1, sub_100025C3C(*(_QWORD *)(a1 + 64)));
  v24 = *(void (**)(uint64_t, uint64_t, void *, _QWORD, _QWORD, _QWORD))(a1 + 3888);
  if (v24)
  {
    v25 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    v24(a1, v25, a2, 0, 0, *(_QWORD *)(a1 + 3896));
  }
  sub_1000FEDDC(a1);
  v26 = objc_autoreleasePoolPush();
  objc_msgSend(*(id *)(a1 + 6624), "asyncTrackNetworksOfInterest:", 1);
  objc_autoreleasePoolPop(v26);
  if (*v6 || v6[142] != -v6[141])
    *(_DWORD *)(a1 + 6348) = 1;
  *(_DWORD *)(a1 + 3472) = 0;
  v27 = (const __CFNumber *)sub_10002BE64((uint64_t)a2, CFSTR("TransitionDisabledFlags"));
  if (v27)
    CFNumberGetValue(v27, kCFNumberSInt32Type, (void *)(a1 + 3472));
  *(CFAbsoluteTime *)(a1 + 3456) = CFAbsoluteTimeGetCurrent();
  if (*(_QWORD *)(a1 + 7328))
  {
    v28 = objc_autoreleasePoolPush();
    v29 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    v30 = *(void **)(a1 + 7328);
    v31 = (char *)objc_msgSend(v30, "count");
    if ((unint64_t)(v31 - 1) <= 9)
    {
      objc_msgSend(v29, "setObject:forKey:", objc_msgSend(v30, "allObjects"), CFSTR("BSS_BLACKLIST_BSSIDS"));
      sub_10002C478((uint64_t)a2, CFSTR("BSS_BLACKLIST"), v29);
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "BssBlacklist: %@", sub_10002BE64((uint64_t)a2, CFSTR("BSS_BLACKLIST")), v49);
      goto LABEL_54;
    }
    v33 = v31;
    if ((unint64_t)v31 < 0xB)
    {
      v32 = objc_autoreleasePoolPush();
      v36 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v48 = v33;
        v35 = "Unable to add BssBlacklist key to network for join. Count:%lu";
        goto LABEL_53;
      }
    }
    else
    {
      objc_msgSend(v29, "setObject:forKey:", objc_msgSend(objc_msgSend(v30, "allObjects"), "subarrayWithRange:", 0, 10), CFSTR("BSS_BLACKLIST_BSSIDS"));
      sub_10002C478((uint64_t)a2, CFSTR("BSS_BLACKLIST"), v29);
      v32 = objc_autoreleasePoolPush();
      v34 = qword_10026DD20;
      if (qword_10026DD20)
      {
        v48 = v33;
        v49 = sub_10002BE64((uint64_t)a2, CFSTR("BSS_BLACKLIST"));
        v35 = "BssBlacklist capped to 3. Count:%lu. %@";
        v36 = (void *)v34;
LABEL_53:
        objc_msgSend(v36, "WFLog:message:", 4, v35, v48, v49);
      }
    }
LABEL_54:
    objc_autoreleasePoolPop(v32);
    objc_autoreleasePoolPop(v28);
  }
  if (_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
  {
    sub_10010D1E0((uint64_t)a2);
    v37 = objc_autoreleasePoolPush();
    v38 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v39 = sub_10002B088(a2);
      objc_msgSend(v38, "WFLog:message:", 3, "%s: Setting ColocatedScopeId for %@ - '%@'", "__WiFiDeviceManagerAssociateCandidate", v39, sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")));
    }
    objc_autoreleasePoolPop(v37);
  }
  sub_10010D248(a1, a2);
  if (sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
    v40 = 12;
  else
    v40 = 1;
  if (!sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")))
  {
    sub_10010A060(a1);
    sub_10002C478((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), *(const void **)(a1 + 3856));
  }
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto Join with colocated scopeID (%@), network (%@)", sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID")), a2);
  objc_autoreleasePoolPop(v41);
  v42 = *(_QWORD *)(a1 + 64);
  v43 = (const void *)sub_100025C3C(v42);
  v44 = sub_100072264(v42, v43, a2, 0, a3, (uint64_t)sub_10013C9D4, a1, (_QWORD *)(a1 + 3312));
  if ((_DWORD)v44)
  {
    v45 = (NSError *)v44;
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "associationDoneWithNetwork:error:interfaceName:", a2, v44, sub_100025C3C(*(_QWORD *)(a1 + 64)));
LABEL_68:
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error initiating association request: %d", v45);
    objc_autoreleasePoolPop(v46);
    return v45;
  }
  sub_10010E1C0(a1, a2);
  if (*(_QWORD *)(a1 + 7368))
  {
    v50[0] = _NSConcreteStackBlock;
    v50[1] = 3221225472;
    v50[2] = sub_10013CFBC;
    v50[3] = &unk_1002315B0;
    v50[4] = a1;
    v50[5] = v40;
    sub_10010367C(a1, (const __CFDictionary **)a2, (uint64_t)v50);
  }
  return 0;
}

void sub_100116B48(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  __CFDictionary *v13;
  _QWORD *v14;
  uint64_t v15;
  const void *v16;
  void *v17;
  void *v18;
  uint64_t v19;

  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerUserForcedAssociation", v19);
    goto LABEL_25;
  }
  if (!a2)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network.", "WiFiDeviceManagerUserForcedAssociation", v19);
    goto LABEL_25;
  }
  if (*(_QWORD *)(a1 + 6240))
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already associating to %@", "WiFiDeviceManagerUserForcedAssociation", sub_10002B088(*(const void **)(a1 + 6240)));
LABEL_25:
    objc_autoreleasePoolPop(v17);
    return;
  }
  v8 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v9 = sub_10002A21C(a1, v8, 1);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Currently associated to %@", "WiFiDeviceManagerUserForcedAssociation", sub_10002B088(v9));
  objc_autoreleasePoolPop(v10);
  CFRetain(a2);
  *(_QWORD *)(a1 + 6240) = a2;
  *(_QWORD *)(a1 + 6224) = a3;
  *(_QWORD *)(a1 + 6232) = a4;
  if (v9 && CFEqual(v9, a2))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already associated to requested network: %@", "WiFiDeviceManagerUserForcedAssociation", sub_10002B088(a2));
    objc_autoreleasePoolPop(v11);
    sub_100116E5C((_QWORD *)a1, (uint64_t)a2, 0);
    goto LABEL_17;
  }
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: starting forced association scan for %@", "WiFiDeviceManagerUserForcedAssociation", sub_10002B088(a2));
  objc_autoreleasePoolPop(v12);
  v13 = sub_100116F8C((const __CFArray *)a2, 0, *(_DWORD *)(a1 + 128), 0x6Eu, 1);
  v14 = malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
  if (v14)
  {
    v15 = (uint64_t)v14;
    *v14 = a1;
    v16 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_100018C78(a1, v16, v13, 0, (uint64_t)sub_100117440, v15, 0, 11);
    if (!v13)
      goto LABEL_16;
    goto LABEL_15;
  }
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "WiFiDeviceManagerUserForcedAssociation");
  objc_autoreleasePoolPop(v18);
  if (v13)
LABEL_15:
    CFRelease(v13);
LABEL_16:
  if (v9)
LABEL_17:
    CFRelease(v9);
}

void sub_100116E5C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  const void *v8;
  void *v9;
  void *v10;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerDispatchUserForcedAssociationCallback");
    v10 = v9;
    goto LABEL_14;
  }
  v6 = a1[778];
  v7 = objc_autoreleasePoolPush();
  if (!v6)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null callback", "__WiFiDeviceManagerDispatchUserForcedAssociationCallback");
    v10 = v7;
LABEL_14:
    objc_autoreleasePoolPop(v10);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: result %d", "__WiFiDeviceManagerDispatchUserForcedAssociationCallback", a3);
  objc_autoreleasePoolPop(v7);
  ((void (*)(_QWORD *, uint64_t, uint64_t, _QWORD))a1[778])(a1, a3, a2, a1[779]);
  a1[778] = 0;
  a1[779] = 0;
  v8 = (const void *)a1[780];
  if (v8)
  {
    CFRelease(v8);
    a1[780] = 0;
  }
}

__CFDictionary *sub_100116F8C(const __CFArray *a1, const __CFArray *a2, int a3, unsigned int a4, int a5)
{
  __CFDictionary *Mutable;
  __CFString *v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  uint64_t v14;
  const void *v15;
  CFTypeID TypeID;
  CFMutableArrayRef v17;
  CFIndex Count;
  unint64_t v19;
  CFIndex v20;
  unint64_t v21;
  const void *ValueAtIndex;
  const void *v23;
  const void *v24;
  __CFDictionary *v25;
  __CFDictionary *v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  CFNumberRef v29;
  CFIndex v30;
  uint64_t v31;
  CFIndex i;
  const __CFDictionary *v33;
  const void *Value;
  void *v35;
  __CFArray *theArray;
  int valuePtr;
  unsigned int v39;
  int v40;

  v39 = a4;
  v40 = a3;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return Mutable;
  v10 = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFDictionarySetValue(Mutable, CFSTR("SCAN_MERGE"), kCFBooleanTrue);
  CFDictionarySetValue(Mutable, CFSTR("MONITOR_QBSS_LOAD"), kCFBooleanTrue);
  CFDictionarySetValue(Mutable, CFSTR("SCAN_INC_BSS_LIST"), kCFBooleanTrue);
  valuePtr = a5;
  v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, CFSTR("SCAN_TYPE"), v11);
  if (v11)
    CFRelease(v11);
  valuePtr = 3;
  v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, CFSTR("SCAN_BSS_TYPE"), v12);
  if (v12)
    CFRelease(v12);
  v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
  CFDictionarySetValue(Mutable, CFSTR("SCAN_RSSI_THRESHOLD"), v13);
  if (v13)
    CFRelease(v13);
  if (!a1)
    goto LABEL_35;
  v14 = sub_1000C312C();
  if (v14 != CFGetTypeID(a1))
  {
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1) && CFArrayGetCount(a1) >= 1)
    {
      if (v10)
        CFStringAppend(v10, CFSTR("Performing auto-join broadcast and directed scan for "));
      v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v17)
      {
        theArray = v17;
        Count = CFArrayGetCount(a1);
        v19 = Count - 1;
        if (Count >= 1)
        {
          v20 = 0;
          if (v19 >= 8)
            v19 = 8;
          v21 = v19 + 1;
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(a1, v20);
            v23 = sub_10002B088(ValueAtIndex);
            if (v23)
            {
              v24 = v23;
              v25 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (v25)
              {
                v26 = v25;
                CFDictionarySetValue(v25, CFSTR("SSID_STR"), v24);
                CFArrayAppendValue(theArray, v26);
                CFRelease(v26);
                if (v10)
                  CFStringAppendFormat(v10, 0, CFSTR("\"%@\" "), v24);
              }
            }
            ++v20;
          }
          while (v21 != v20);
        }
        if (CFArrayGetCount(theArray))
        {
          v27 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v27)
          {
            v28 = v27;
            CFDictionarySetValue(v27, CFSTR("SSID_STR"), &stru_100238178);
            CFArrayAppendValue(theArray, v28);
            CFRelease(v28);
          }
          CFDictionarySetValue(Mutable, CFSTR("SCAN_SSID_LIST"), theArray);
        }
        CFRelease(theArray);
      }
      goto LABEL_37;
    }
LABEL_35:
    if (v10)
      CFStringAppend(v10, CFSTR("Performing auto-join broadcast scan "));
    goto LABEL_37;
  }
  if (v10)
    CFStringAppend(v10, CFSTR("Performing auto-join directed scan for "));
  v15 = sub_10002B088(a1);
  if (v15)
    CFDictionarySetValue(Mutable, CFSTR("SSID_STR"), v15);
  if (v10)
    CFStringAppendFormat(v10, 0, CFSTR("\"%@\" "), v15);
LABEL_37:
  if (a4)
  {
    v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v39);
    CFDictionarySetValue(Mutable, CFSTR("SCAN_DWELL_TIME"), v29);
    if (v10)
      CFStringAppendFormat(v10, 0, CFSTR("with a modified dwell time of %dms "), v39);
    if (v29)
      CFRelease(v29);
  }
  if (a2)
  {
    v30 = CFArrayGetCount(a2);
    if (v30)
    {
      if (v10)
      {
        v31 = v30;
        CFStringAppend(v10, CFSTR("on channels: "));
        if (v31 >= 1)
        {
          for (i = 0; i != v31; ++i)
          {
            v33 = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, i);
            Value = CFDictionaryGetValue(v33, CFSTR("CHANNEL"));
            CFStringAppendFormat(v10, 0, CFSTR("%@ "), Value);
          }
        }
      }
      CFDictionarySetValue(Mutable, CFSTR("SCAN_CHANNELS"), a2);
    }
  }
  if (v10)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", v10);
    objc_autoreleasePoolPop(v35);
    CFRelease(v10);
  }
  return Mutable;
}

void sub_100117440(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  _QWORD *v8;
  const void *v9;
  void *ValueAtIndex;
  void *v11;
  void *v12;
  const void *v13;
  void *v14;
  void *v15;
  const char *v16;
  void *v17;
  void *v18;

  if (!a6)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "__WiFiDeviceManagerUserForcedAssociationScanCallback");
    goto LABEL_14;
  }
  v8 = (_QWORD *)*a6;
  sub_10012D59C(*a6, a3);
  v9 = (const void *)v8[780];
  if (v9)
  {
    if (a3 && CFArrayGetCount(a3))
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, 0);
      if (CFEqual(v9, ValueAtIndex))
      {
LABEL_6:
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabling device manager", "__WiFiDeviceManagerUserForcedAssociationScanCallback");
        objc_autoreleasePoolPop(v11);
        sub_1000FB408((uint64_t)v8);
        sub_1000C38BC((uint64_t)ValueAtIndex, (uint64_t)v9);
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found matching network in scan results, proceeding with association", "__WiFiDeviceManagerUserForcedAssociationScanCallback");
        objc_autoreleasePoolPop(v12);
        v13 = (const void *)sub_100025C3C(v8[8]);
        sub_10010AD4C((uint64_t)v8, v13, ValueAtIndex, 0, 0, (uint64_t)sub_10013D090, 0, 1011);
        goto LABEL_15;
      }
      if (sub_1000C433C((const __CFDictionary *)ValueAtIndex) && (sub_1000C5C14((uint64_t)v9) & 2) != 0)
      {
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanned network is SAE, provided network is WPA capable", "__WiFiDeviceManagerUserForcedAssociationScanCallback");
        objc_autoreleasePoolPop(v17);
        goto LABEL_6;
      }
      sub_100116E5C(v8, (uint64_t)v9, 1);
      v14 = objc_autoreleasePoolPush();
      v15 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v16 = "%s: scanned network is not equal";
        goto LABEL_13;
      }
    }
    else
    {
      sub_100116E5C(v8, (uint64_t)v9, 1);
      v14 = objc_autoreleasePoolPush();
      v15 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v16 = "%s: scan results were empty";
LABEL_13:
        objc_msgSend(v15, "WFLog:message:", 3, v16, "__WiFiDeviceManagerUserForcedAssociationScanCallback");
      }
    }
LABEL_14:
    objc_autoreleasePoolPop(v14);
    goto LABEL_15;
  }
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is NULL", "__WiFiDeviceManagerUserForcedAssociationScanCallback");
  objc_autoreleasePoolPop(v18);
  sub_100116E5C(v8, 0, 1);
LABEL_15:
  free(a6);
}

void sub_1001176E8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  __CFDictionary *v13;
  _QWORD *v14;
  uint64_t v15;
  const void *v16;
  void *v17;
  void *v18;
  uint64_t v19;

  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerAddNetworkScan", v19);
    goto LABEL_25;
  }
  if (!a2)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network.", "WiFiDeviceManagerAddNetworkScan", v19);
    goto LABEL_25;
  }
  if (*(_QWORD *)(a1 + 6272))
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already associating to %@", "WiFiDeviceManagerAddNetworkScan", sub_10002B088(*(const void **)(a1 + 6272)));
LABEL_25:
    objc_autoreleasePoolPop(v17);
    return;
  }
  v8 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v9 = sub_10002A21C(a1, v8, 1);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Currently associated to %@", "WiFiDeviceManagerAddNetworkScan", sub_10002B088(v9));
  objc_autoreleasePoolPop(v10);
  CFRetain(a2);
  *(_QWORD *)(a1 + 6272) = a2;
  *(_QWORD *)(a1 + 6256) = a3;
  *(_QWORD *)(a1 + 6264) = a4;
  if (v9 && CFEqual(v9, a2))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already associated to requested network: %@", "WiFiDeviceManagerAddNetworkScan", sub_10002B088(a2));
    objc_autoreleasePoolPop(v11);
    sub_100117A00((_QWORD *)a1, (uint64_t)a2, 3, 0);
    goto LABEL_17;
  }
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: starting forced association scan for %@", "WiFiDeviceManagerAddNetworkScan", sub_10002B088(a2));
  objc_autoreleasePoolPop(v12);
  v13 = sub_100116F8C(0, 0, *(_DWORD *)(a1 + 128), 0, 1);
  v14 = malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
  if (v14)
  {
    v15 = (uint64_t)v14;
    *v14 = a1;
    v16 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_100018C78(a1, v16, v13, 0, (uint64_t)sub_100117B64, v15, 0, 11);
    if (!v13)
      goto LABEL_16;
    goto LABEL_15;
  }
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "WiFiDeviceManagerAddNetworkScan");
  objc_autoreleasePoolPop(v18);
  if (v13)
LABEL_15:
    CFRelease(v13);
LABEL_16:
  if (v9)
LABEL_17:
    CFRelease(v9);
}

void sub_100117A00(_QWORD *a1, uint64_t a2, uint64_t a3, const __CFArray *a4)
{
  uint64_t v8;
  void *v9;
  void *v10;
  CFIndex Count;
  void *v12;
  void *v13;
  const void *v14;

  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerDispatchAddNetworkScanCallback");
    v13 = v12;
    goto LABEL_12;
  }
  v8 = a1[782];
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)qword_10026DD20;
  if (!v8)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null callback", "__WiFiDeviceManagerDispatchAddNetworkScanCallback");
    v13 = v9;
LABEL_12:
    objc_autoreleasePoolPop(v13);
    return;
  }
  if (qword_10026DD20)
  {
    if (a4)
      Count = CFArrayGetCount(a4);
    else
      Count = 0;
    objc_msgSend(v10, "WFLog:message:", 3, "%s: result %d count %ld", "__WiFiDeviceManagerDispatchAddNetworkScanCallback", a3, Count);
  }
  objc_autoreleasePoolPop(v9);
  ((void (*)(_QWORD *, uint64_t, const __CFArray *, uint64_t, _QWORD))a1[782])(a1, a3, a4, a2, a1[783]);
  a1[782] = 0;
  a1[783] = 0;
  v14 = (const void *)a1[784];
  if (v14)
  {
    CFRelease(v14);
    a1[784] = 0;
  }
}

void sub_100117B64(int a1, int a2, CFArrayRef theArray, uint64_t a4, int a5, _QWORD *a6)
{
  _QWORD *v9;
  const __CFArray *MutableCopy;
  __CFArray *v11;
  void *v12;
  CFRange v13;

  if (a6)
  {
    v9 = (_QWORD *)*a6;
    if (theArray
      && CFArrayGetCount(theArray)
      && (MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, theArray)) != 0)
    {
      v11 = MutableCopy;
      v13.length = CFArrayGetCount(MutableCopy);
      v13.location = 0;
      CFArraySortValues(v11, v13, (CFComparatorFunction)sub_1000C8AAC, 0);
      sub_100117A00(v9, v9[784], a5 != 0, v11);
      CFRelease(v11);
    }
    else
    {
      sub_100117A00(v9, v9[784], a5 != 0, 0);
    }
  }
  else
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "__WiFiDeviceManagerAddNetworkScanCallback");
    objc_autoreleasePoolPop(v12);
  }
  free(a6);
}

uint64_t sub_100117C70(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4552) = a2;
  *(_QWORD *)(result + 4560) = a3;
  return result;
}

uint64_t sub_100117C7C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4760) = a2;
  *(_QWORD *)(result + 4768) = a3;
  return result;
}

void sub_100117C88(uint64_t a1)
{
  void *v2;
  void *v3;
  const void *v4;
  void *v5;
  const __CFArray *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, _QWORD);
  const void *v8;
  void *v9;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "WiFiDeviceManagerNoNetworksFoundNotification");
    goto LABEL_6;
  }
  if (*(_DWORD *)(a1 + 20) != 1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifi is off", "WiFiDeviceManagerNoNetworksFoundNotification");
    goto LABEL_6;
  }
  if (sub_1001158FC(a1))
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: in AWDL session, not reporting no network soft-error", "WiFiDeviceManagerNoNetworksFoundNotification");
    goto LABEL_6;
  }
  v4 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  v5 = sub_10002A21C(a1, v4, 1);
  if (!v5)
  {
    v6 = *(const __CFArray **)(a1 + 3368);
    if (v6 && CFArrayGetCount(v6))
    {
      if (sub_100070734(*(_QWORD *)(a1 + 64)))
      {
        v7 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 4552);
        if (v7)
        {
          v7(a1, 2, 0, *(_QWORD *)(a1 + 4560));
          goto LABEL_13;
        }
        v3 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "WiFiDeviceManagerNoNetworksFoundNotification");
      }
      else
      {
        v3 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: EAP is not idle, not reporting no network soft-error", "WiFiDeviceManagerNoNetworksFoundNotification");
      }
    }
    else
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no known networks at this location, not reporting no network soft-error", "WiFiDeviceManagerNoNetworksFoundNotification");
    }
LABEL_6:
    objc_autoreleasePoolPop(v3);
LABEL_13:
    objc_autoreleasePoolPop(v2);
    return;
  }
  v8 = v5;
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: associated, not reporting no network soft-error", "WiFiDeviceManagerNoNetworksFoundNotification");
  objc_autoreleasePoolPop(v9);
  objc_autoreleasePoolPop(v2);
  CFRelease(v8);
}

void sub_100117EC0(uint64_t a1, const __CFString *a2, unint64_t a3, const void *a4, const void *a5, const void *a6)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  CFStringRef Copy;
  const __CFString *v15;
  void *v16;
  CFDataRef v17;
  const void *v18;
  const __CFArray *v19;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const void *v22;
  void *v23;
  CFDataRef v24;
  void *v25;
  CFDataRef v26;
  void *v27;
  void *v28;
  void *v29;
  UInt8 bytes[4];
  __int16 v31;
  UInt8 v32[4];
  __int16 v33;
  CFRange v34;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 64))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v13 = Mutable;
        if ((unint64_t)a2 | a3)
        {
          if (a2)
          {
            Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
            if (Copy)
            {
              v15 = Copy;
              CFDictionaryAddValue(v13, CFSTR("BSSID"), Copy);
              v16 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssidStrRef:%@ bssidLen:%ld ", "WiFiDeviceManagerSetRoam", v15, CFStringGetLength(v15));
              objc_autoreleasePoolPop(v16);
              v17 = 0;
              if (!a3)
                goto LABEL_35;
              goto LABEL_21;
            }
            v29 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssidStrRef is NULL", "WiFiDeviceManagerSetRoam");
LABEL_60:
            objc_autoreleasePoolPop(v29);
LABEL_47:
            CFRelease(v13);
            return;
          }
          v31 = -1;
          *(_DWORD *)bytes = -1;
          v24 = CFDataCreate(kCFAllocatorDefault, bytes, 6);
          if (v24)
          {
            v17 = v24;
            CFDictionaryAddValue(v13, CFSTR("BSSID"), v24);
            v15 = 0;
            if (!a3)
            {
LABEL_35:
              if (a4)
                CFDictionaryAddValue(v13, CFSTR("BAND_FOR_CHANNEL"), a4);
              if (a5)
                CFDictionaryAddValue(v13, CFSTR("BAND_PREFERENCE"), a5);
              if (a6)
                CFDictionaryAddValue(v13, CFSTR("ROAM_FLAGS"), a6);
              v27 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:calling DeviceSetRoam with :%@", "WiFiDeviceManagerSetRoam", v13);
              objc_autoreleasePoolPop(v27);
              sub_1000772B0(*(_QWORD *)(a1 + 64), (uint64_t)v13);
              if (v15)
                CFRelease(v15);
              if (v17)
                CFRelease(v17);
              goto LABEL_47;
            }
LABEL_21:
            CFDictionaryAddValue(v13, CFSTR("CHANNEL"), (const void *)a3);
            goto LABEL_35;
          }
LABEL_56:
          v29 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssidDataRef is NULL", "WiFiDeviceManagerSetRoam");
          goto LABEL_60;
        }
        v18 = *(const void **)(a1 + 3512);
        if (v18)
        {
          v19 = *(const __CFArray **)(a1 + 3528);
          if (!v19)
            goto LABEL_27;
          v34.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
          v34.location = 0;
          FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v19, v34, v18);
          if (FirstIndexOfValue == -1
            || (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue)) == 0)
          {
            v19 = 0;
          }
          else
          {
            v22 = ValueAtIndex;
            v19 = sub_1000C8B54((uint64_t)ValueAtIndex);
            if ((_DWORD)v19)
            {
              v23 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Detected multiAP environment for %@", sub_10002B088(v22));
LABEL_25:
              objc_autoreleasePoolPop(v23);
            }
          }
LABEL_27:
          v25 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isMultiAP:%u", "WiFiDeviceManagerSetRoam", v19);
          objc_autoreleasePoolPop(v25);
          if (!v18 || (_DWORD)v19)
          {
            v33 = -1;
            *(_DWORD *)v32 = -1;
            v26 = CFDataCreate(kCFAllocatorDefault, v32, 6);
          }
          else
          {
            v26 = sub_1000C4110((uint64_t)v18);
          }
          v17 = v26;
          if (v26)
          {
            CFDictionaryAddValue(v13, CFSTR("BSSID"), v26);
            v15 = 0;
            goto LABEL_35;
          }
          goto LABEL_56;
        }
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: currentNetwork is NULL", "WiFiDeviceManagerSetRoam");
        v19 = 0;
        goto LABEL_25;
      }
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssidInfo allocation failed!", "WiFiDeviceManagerSetRoam");
    }
    else
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager->device is NULL", "WiFiDeviceManagerSetRoam");
    }
  }
  else
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetRoam");
  }
  objc_autoreleasePoolPop(v28);
}

void sub_10011835C(uint64_t a1, const void *a2)
{
  uint64_t v3;
  void *v4;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      if (*(_BYTE *)(a1 + 38))
      {
        sub_100078A0C(v3, a2);
        return;
      }
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Debug CoreCapture is disabled", "WiFiDeviceManagerTriggerCoreCapture");
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager->device is NULL", "WiFiDeviceManagerTriggerCoreCapture");
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerTriggerCoreCapture");
  }
  objc_autoreleasePoolPop(v4);
}

void sub_10011843C(uint64_t a1)
{
  double Current;
  double v3;
  char v4;
  unsigned __int8 *v5;
  double v6;
  double v7;
  void *v8;
  void *v9;
  void *v10;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = *(double *)(a1 + 5544);
  if (v3 == 0.0 || Current - v3 > 1800.0)
  {
    *(double *)(a1 + 5544) = Current;
    v4 = 1;
    v3 = Current;
  }
  else
  {
    v4 = *(_BYTE *)(a1 + 5552) + 1;
  }
  v5 = (unsigned __int8 *)(a1 + 5552);
  *(_BYTE *)(a1 + 5552) = v4;
  v6 = Current - v3;
  v7 = Current - *(double *)(a1 + 5536);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: timeSinceFirstDisassoc: %f minutes, link lost: %d times, timeSinceLastChipTrap: %f hour, lastChipTrapTime: %f \n", "WiFiDeviceManagerTriggerReport", v6 / 60.0, *v5, v7 / 3600.0, *(_QWORD *)(a1 + 5536));
  objc_autoreleasePoolPop(v8);
  if (*v5 >= 0xAu && v6 <= 1800.0 && (v7 >= 36000.0 || *(double *)(a1 + 5536) == 0.0))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Trigger Watchdog at driver:%@", "WiFiDeviceManagerTriggerReport", CFSTR("AssocTimeoutWatchdog"));
    objc_autoreleasePoolPop(v9);
    sub_10011835C(a1, CFSTR("AssocTimeoutWatchdog"));
    *v5 = 0;
    *(_QWORD *)(a1 + 5544) = 0;
    *(double *)(a1 + 5536) = Current;
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Trigger CoreCapture at driver:%@", "WiFiDeviceManagerTriggerReport", CFSTR("AssocTimeoutCoreCapture"));
    objc_autoreleasePoolPop(v10);
    sub_10011835C(a1, CFSTR("AssocTimeoutCoreCapture"));
  }
}

uint64_t sub_100118638(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned int *)(a1 + 6208);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "WiFiDeviceManagerGetCurrentRssi");
  objc_autoreleasePoolPop(v2);
  return 0;
}

uint64_t sub_1001186A4(uint64_t a1)
{
  if (a1)
    return a1 + 5616;
  else
    return 0;
}

uint64_t sub_1001186B8(uint64_t a1)
{
  if (a1)
    return a1 + 9032;
  else
    return 0;
}

uint64_t sub_1001186CC(uint64_t a1, CFArrayRef theArray, __CFArray *a3)
{
  CFIndex v6;
  const void *ValueAtIndex;
  const __CFArray *v8;
  const __CFArray *v9;
  void *v11;
  CFRange v12;
  CFRange v13;

  if (a1 && theArray && a3)
  {
    if (CFArrayGetCount(theArray) >= 1)
    {
      v6 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
        v8 = *(const __CFArray **)(a1 + 3536);
        v12.length = CFArrayGetCount(v8);
        v12.location = 0;
        LODWORD(v8) = CFArrayContainsValue(v8, v12, ValueAtIndex);
        v9 = *(const __CFArray **)(a1 + 3528);
        v13.length = CFArrayGetCount(v9);
        v13.location = 0;
        if (v8 | CFArrayContainsValue(v9, v13, ValueAtIndex))
          CFArrayAppendValue(a3, ValueAtIndex);
        ++v6;
      }
      while (v6 < CFArrayGetCount(theArray));
    }
    if (CFArrayGetCount(a3))
      return 1;
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: called with improper arguments!", "WiFiDeviceManagerFilterForKnownNetworksInScanResults");
    objc_autoreleasePoolPop(v11);
  }
  return 0;
}

BOOL sub_100118800(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 5396) == 102 && (*(_BYTE *)(result + 5392) & 1) != 0 || *(_BYTE *)(result + 50) != 0;
  return result;
}

BOOL sub_100118834(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 5396) == 102 && (*(_BYTE *)(result + 5392) & 2) != 0 || *(_BYTE *)(result + 49) != 0;
  return result;
}

void sub_100118868(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  void *v16;
  void *v17;

  if (a1)
  {
    v8 = *(_QWORD *)(a1 + 64);
    v9 = (const void *)sub_100025C3C(v8);
    v10 = sub_10002BF8C(v8, v9);
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting user auto join %d (trigger %d, locState %d)", "WiFiDeviceManagerSetUserAutoJoin", a2, a3, a4);
    objc_autoreleasePoolPop(v11);
    if (a2 || !v10 || *(_BYTE *)(a1 + 6280))
    {
      if (*(unsigned __int8 *)(a1 + 6280) == a2)
      {
LABEL_32:
        if (v10)
          CFRelease(v10);
        return;
      }
    }
    else
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: new state is disabled while connected to network %@", "WiFiDeviceManagerSetUserAutoJoin", v10);
      objc_autoreleasePoolPop(v12);
    }
    *(_BYTE *)(a1 + 6280) = a2;
    v13 = *(void **)(a1 + 7368);
    if (v13)
      objc_msgSend(v13, "setControlCenterState:withKnownLocation:forInterface:", a2 != 0, (_DWORD)a4 != 3, sub_100025C3C(*(_QWORD *)(a1 + 64)));
    sub_1001091D8(a1, 2u, a2 != 0);
    if (a2)
    {
      sub_100118BE8(a1);
      sub_1000FB44C(a1);
      sub_100006F34(a1, 1);
      *(_DWORD *)(a1 + 192) = 15;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a1, 0x28uLL);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 40, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerSetUserAutoJoin");
      }
    }
    else
    {
      v14 = objc_autoreleasePoolPush();
      if (v10)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join disabled, disconnecting from current network %@", "WiFiDeviceManagerSetUserAutoJoin", sub_10002B088(v10));
        objc_autoreleasePoolPop(v14);
        if (sub_10002DAB4((uint64_t)v10))
          sub_100072E44(*(_QWORD *)(a1 + 64), v10, 0);
        v15 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
        sub_1000F7F48(a1, v15, 1011, "WiFiDeviceManagerSetUserAutoJoin", 34266);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No current network", "WiFiDeviceManagerSetUserAutoJoin");
        objc_autoreleasePoolPop(v14);
      }
      if (objc_msgSend(*(id *)(a1 + 6752), "isClientAssociated"))
      {
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: stopping Internet Relay over NAN", "WiFiDeviceManagerSetUserAutoJoin");
        objc_autoreleasePoolPop(v16);
        objc_msgSend(*(id *)(a1 + 6752), "stopSubscriberForPHSOverNAN");
      }
      sub_100118BE8(a1);
      sub_1000FB44C(a1);
      sub_100006F34(a1, 1);
      *(_DWORD *)(a1 + 192) = 15;
    }
    sub_1000FF824(a1);
    goto LABEL_32;
  }
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager", "WiFiDeviceManagerSetUserAutoJoin");
  objc_autoreleasePoolPop(v17);
}

void sub_100118BE8(uint64_t a1)
{
  void (*v1)(uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v2;
  void *v3;

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "__WiFiDeviceManagerUserAutoJoinPreferenceChangedNotification");
    goto LABEL_9;
  }
  v1 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 4552);
  if (!v1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: softErrorManagerService callback is NULL!", "__WiFiDeviceManagerUserAutoJoinPreferenceChangedNotification");
LABEL_9:
    objc_autoreleasePoolPop(v3);
    return;
  }
  if (*(_BYTE *)(a1 + 6280))
    v2 = 7;
  else
    v2 = 8;
  v1(a1, v2, 0, *(_QWORD *)(a1 + 4560));
}

void sub_100118CA8(uint64_t a1, int a2)
{
  unsigned __int8 *v4;
  void *v5;
  void *v6;
  const void *v7;
  const __CFSet *v8;
  const __CFSet *v9;
  const __CFSet *v10;
  CFIndex v11;
  const __CFSet *v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFSet *v18;
  CFIndex v19;
  const __CFSet *v20;
  const __CFDictionary *v21;
  const __CFNumber *Value;
  const __CFString *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  unsigned int v28;
  const __CFString *v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  __CFString *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  BOOL v38;
  uint64_t v39;
  const void *v40;
  int v41;
  CFIndex *usedBufLen;
  CFIndex v43;
  CFIndex Count;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  void *v52;
  int v53;
  const __CFString *v54;
  void *v55;
  UInt8 buffer[4];
  double valuePtr[2];
  CFRange v58;

  v55 = objc_autoreleasePoolPush();
  valuePtr[0] = 0.0;
  *(_DWORD *)buffer = 0;
  if (a1 && *(_QWORD *)(a1 + 7368))
  {
    v4 = (unsigned __int8 *)(a1 + 5216);
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v52 = v5;
      v7 = sub_10002B088(*(const void **)(a1 + 5208));
      v50 = *v4;
      v51 = v7;
      v49 = *(unsigned __int8 *)(a1 + 5217);
      v48 = *(unsigned int *)(a1 + 5256);
      v47 = *(unsigned __int8 *)(a1 + 5362);
      v46 = *(unsigned __int8 *)(a1 + 5361);
      v45 = *(unsigned __int8 *)(a1 + 5360);
      v8 = *(const __CFSet **)(a1 + 5288);
      if (v8)
        Count = CFSetGetCount(v8);
      else
        Count = 0;
      v9 = *(const __CFSet **)(a1 + 5296);
      if (v9)
        v43 = CFSetGetCount(v9);
      else
        v43 = 0;
      v53 = a2;
      v10 = *(const __CFSet **)(a1 + 5304);
      if (v10)
        v11 = CFSetGetCount(v10);
      else
        v11 = 0;
      v12 = *(const __CFSet **)(a1 + 5312);
      if (v12)
        v13 = CFSetGetCount(v12);
      else
        v13 = 0;
      v14 = *(unsigned __int8 *)(a1 + 5219);
      v15 = *(unsigned __int8 *)(a1 + 5221);
      v16 = *(unsigned __int8 *)(a1 + 5260);
      v17 = *(unsigned __int8 *)(a1 + 5328);
      v18 = *(const __CFSet **)(a1 + 5272);
      if (v18)
        v19 = CFSetGetCount(v18);
      else
        v19 = 0;
      v20 = *(const __CFSet **)(a1 + 5280);
      if (v20)
        v20 = (const __CFSet *)CFSetGetCount(v20);
      objc_msgSend(v6, "WFLog:message:", 3, "%s: PHSession: Network=%@;Channel=%d;STACount=%d(Max=%d,USB=%d,BT=%d,WiFi=%d,Broadcast=%ld,Hidden=%ld;Other=%ld;"
        "NanLink=%ld);MISEnabled=%d;MISDiscoveryEnabled=%d;MISHidden=%d;MISScanBlocked=%d;LegacyClients=%ld;InstantClient"
        "s=%ld;Force2.4GHz=%d;ForceDisconnectInfra=%d",
        "__WiFiDeviceManagerUpdateSoftApUsageSession",
        v51,
        v50,
        v49,
        v48,
        v47,
        v46,
        v45,
        Count,
        v43,
        v11,
        v13,
        v14,
        v15,
        v16,
        v17,
        v19,
        v20,
        *(unsigned __int8 *)(a1 + 5384),
        *(unsigned __int8 *)(a1 + 5385));
      a2 = v53;
      v5 = v52;
    }
    objc_autoreleasePoolPop(v5);
    v21 = *(const __CFDictionary **)(a1 + 7032);
    if (v21)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("SOFTAP_LOWPOWER_STATS_LOWPOWER_STATE_DURATION"));
      if (Value)
        CFNumberGetValue(Value, kCFNumberDoubleType, valuePtr);
    }
    v23 = *(const __CFString **)(a1 + 7352);
    if (v23)
    {
      v58.length = CFStringGetLength(*(CFStringRef *)(a1 + 7352));
      v58.location = 0;
      CFStringGetBytes(v23, v58, 0x8000100u, 0, 0, buffer, 4, 0);
    }
    v24 = *(double *)(a1 + 6304);
    if (v24 == 0.0)
    {
      v27 = 0.0;
    }
    else
    {
      v25 = *(double *)(a1 + 6312);
      v26 = v25 - v24;
      if (v25 == 0.0)
        v27 = 0.0;
      else
        v27 = v26;
    }
    v28 = *(_DWORD *)(a1 + 6288) - 1;
    if (v28 > 7)
      v29 = CFSTR("Unknown");
    else
      v29 = off_100231FF8[v28];
    v54 = v29;
    v30 = *(_DWORD *)(a1 + 6292) - 1;
    if (v30 > 0x12)
      v31 = 0;
    else
      v31 = (uint64_t)*(&off_100232038 + v30);
    v32 = *(_DWORD *)(a1 + 6296) - 1;
    if (v32 > 6)
      v33 = 0;
    else
      v33 = off_1002320D0[v32];
    v34 = *(void **)(a1 + 7368);
    v35 = *v4;
    v36 = *(int *)buffer;
    v37 = *(_BYTE *)(a1 + 5260) != 0;
    v38 = *(_BYTE *)(a1 + 3411) != 0;
    v39 = *(_QWORD *)(a1 + 64);
    v40 = (const void *)sub_100068E60(v39);
    v41 = sub_100074164(v39, v40, 0);
    BYTE3(usedBufLen) = *(_DWORD *)(a1 + 7048) != 0;
    BYTE2(usedBufLen) = v41 != 0;
    BYTE1(usedBufLen) = v38;
    LOBYTE(usedBufLen) = v37;
    objc_msgSend(v34, "setSoftApState:requester:status:changeReason:channelNumber:countryCode:isHidden:isInfraConnected:isAwdlUp:lowPowerModeDuration:compatibilityMode:requestToUpLatency:", a2 != 0, v54, v31, v33, v35, v36, valuePtr[0], v27, usedBufLen);
  }
  objc_autoreleasePoolPop(v55);
}

void sub_100119020(uint64_t a1, int a2, unsigned __int16 *a3, __int16 a4, int a5)
{
  unsigned __int8 *v6;
  unsigned int v9;
  void *v10;

  v6 = (unsigned __int8 *)(a1 + 5218);
  if (!a2)
  {
    ++*(_WORD *)(a1 + 6334);
    goto LABEL_9;
  }
  if (sub_10006495C(a3) | a5)
  {
    ++*(_WORD *)(a1 + 6328);
    *(_WORD *)(a1 + 6330) |= a4;
    if (!a5)
      goto LABEL_9;
  }
  else
  {
    ++*(_WORD *)(a1 + 6332);
    if (!a5)
      goto LABEL_9;
  }
  v9 = v6[1158];
  if (*v6 > v9)
    v6[1158] = v9 + 1;
LABEL_9:
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: PHSessionMetric: method=%d end=%d teardown=%d, misStart=%f softAPUp=%fsessionEnd=%f, appleDeviceConnectionCount=%d(%x) nonAppleDeviceConnectionCount=%ddeviceDisconnectCount=%d, lpmDuration=%llu, channel=%d nanPhNanStationCount=%d", "WiFiDeviceManagerRecordPHMetricSTAAssocEvent", *(unsigned int *)(a1 + 6288), *(unsigned int *)(a1 + 6292), *(unsigned int *)(a1 + 6296), *(_QWORD *)(a1 + 6304), *(_QWORD *)(a1 + 6312), *(_QWORD *)(a1 + 6320), *(unsigned __int16 *)(a1 + 6328), *(unsigned __int16 *)(a1 + 6330), *(unsigned __int16 *)(a1 + 6332), *(unsigned __int16 *)(a1 + 6334), *(_QWORD *)(a1 + 6336), *(unsigned int *)(a1 + 6344), v6[1158]);
  objc_autoreleasePoolPop(v10);
}

void sub_10011914C(uint64_t a1, uint64_t a2)
{
  WiFiRecommendationStub *v3;
  void *v4;

  if (a1)
  {
    v3 = -[WiFiRecommendationStub initWithWiFiNetwork:]([WiFiRecommendationStub alloc], "initWithWiFiNetwork:", a2);
    *(_DWORD *)(a1 + 3280) = sub_100119204(a1, v3, 1);
    if (v3)
      CFRelease(v3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is nil", "WiFiDeviceManagerDispatchSimulatedJoinRecommendationNotification");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_100119204(uint64_t a1, void *a2, int a3)
{
  uint64_t v3;
  void *v7;
  id v8;
  void *v9;
  unsigned int v10;
  _WORD *v11;
  void *v12;
  void (*v13)(uint64_t, _WORD *, uint64_t, uint64_t, _QWORD);
  void *v15;
  uint64_t v16;

  v3 = *(unsigned int *)(a1 + 3280);
  if (!a2)
    return v3;
  v7 = objc_autoreleasePoolPush();
  if (a3)
  {
    v8 = 0;
    goto LABEL_9;
  }
  if (!*(_DWORD *)(a1 + 6576) || !*(_DWORD *)(a1 + 108))
  {
LABEL_30:
    objc_autoreleasePoolPop(v7);
    return v3;
  }
  if (*(_DWORD *)(a1 + 6716))
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: already displayed recommendation in this session (state %d)", "__WiFiDeviceManagerDispatchRecommendation", *(unsigned int *)(a1 + 6716));
    goto LABEL_29;
  }
  if (!-[WiFiUserInteractionMonitor isNetworkRecommendationAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkRecommendationAllowed"))
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: recommendation not allowed due to user interaction state", "__WiFiDeviceManagerDispatchRecommendation", v16);
LABEL_29:
    objc_autoreleasePoolPop(v15);
    goto LABEL_30;
  }
  v8 = sub_100009ACC(a1);
LABEL_9:
  objc_msgSend(*(id *)(a1 + 6704), "enableTestMode:", sub_100160100(*(_QWORD *)(a1 + 96)) != 0);
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: dispatching recommendation for %@", "__WiFiDeviceManagerDispatchRecommendation", objc_msgSend(a2, "SSID"));
  objc_autoreleasePoolPop(v9);
  v10 = objc_msgSend(*(id *)(a1 + 6704), "dispatchNotificationWithRecommendation:currentLocation:force:", a2, v8, a3 != 0);
  if (v10 == 2)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: blacklisting recommendation for %@", "__WiFiDeviceManagerDispatchRecommendation", objc_msgSend(a2, "SSID"));
    objc_autoreleasePoolPop(v12);
    v11 = sub_1000C323C((const __CFString *)objc_msgSend(a2, "SSID"));
    v13 = *(void (**)(uint64_t, _WORD *, uint64_t, uint64_t, _QWORD))(a1 + 4680);
    if (v13)
      v13(a1, v11, 1, 6, *(_QWORD *)(a1 + 4688));
    goto LABEL_19;
  }
  if (!v10)
  {
    *(_DWORD *)(a1 + 6716) = 2;
    if (*(_QWORD *)(a1 + 4664))
    {
      v11 = sub_1000C323C((const __CFString *)objc_msgSend(a2, "SSID"));
      (*(void (**)(uint64_t, _WORD *, uint64_t, _QWORD))(a1 + 4664))(a1, v11, 1, *(_QWORD *)(a1 + 4672));
      v3 = 14;
LABEL_19:
      if (v11)
        CFRelease(v11);
      goto LABEL_22;
    }
    v3 = 14;
  }
LABEL_22:
  objc_autoreleasePoolPop(v7);
  if (v8)
    CFRelease(v8);
  return v3;
}

void sub_100119488(uint64_t a1, const void *a2)
{
  const void *v3;
  int v4;
  void *v5;

  if (a1)
  {
    v3 = sub_10002B088(a2);
    v4 = *(_DWORD *)(a1 + 3280);
    if (v3)
      objc_msgSend(*(id *)(a1 + 6704), "dispatchNotificationWithRandomMAC:", v3);
    *(_DWORD *)(a1 + 3280) = v4;
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is nil", "WiFiDeviceManagerDispatchSimulatedRandomMACNotification");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_100119518(uint64_t a1, const void *a2)
{
  id v4;
  id v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  if (a1)
  {
    if (_os_feature_enabled_impl("WiFiManager", "AskToJoinPersonalHotspotBanner"))
    {
      v4 = objc_msgSend(*(id *)(a1 + 6704), "dispatchNotificationWithAskToJoinHotspotRecommendation:", sub_10002B088(a2));
      if ((_DWORD)v4)
      {
        v5 = v4;
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot Recommendation notification failed: %d", "WiFiDeviceManagerDispatchSimulatedAskToJoinHotspotNotification", v5);
        objc_autoreleasePoolPop(v6);
      }
      else
      {
        *(_DWORD *)(a1 + 3280) = 14;
      }
    }
    else
    {
      v7 = sub_100025C3C(*(_QWORD *)(a1 + 64));
      *(_DWORD *)(a1 + 3280) = sub_100119668(a1, v7, 10, 0, a2, 0);
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %@", "WiFiDeviceManagerDispatchSimulatedAskToJoinHotspotNotification", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is nil", "WiFiDeviceManagerDispatchSimulatedAskToJoinHotspotNotification", v9);
  }
  objc_autoreleasePoolPop(v8);
}

uint64_t sub_100119668(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  void *v12;
  _BOOL4 v13;
  void *v14;
  _BOOL4 v15;
  void *v16;
  unsigned int v17;
  BOOL v19;
  uint64_t v21;
  const void *v22;
  uint64_t v23;

  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type=%@(%d)", "__WiFiDeviceManagerDispatchNotification", sub_100064E5C(a3), a3);
  objc_autoreleasePoolPop(v12);
  if (!*(_QWORD *)(a1 + 3936))
  {
LABEL_9:
    if ((_DWORD)a3 == 2)
    {
      if (!a5)
        return *(unsigned int *)(a1 + 3280);
LABEL_25:
      if (sub_10002DAB4((uint64_t)a5))
        sub_100072E44(*(_QWORD *)(a1 + 64), a5, 1);
      return *(unsigned int *)(a1 + 3280);
    }
LABEL_17:
    v17 = sub_1000C5BD8(a5);
    v19 = (_DWORD)a3 == 1 || v17 != 0;
    if (!a5 || !v19)
      return *(unsigned int *)(a1 + 3280);
    goto LABEL_25;
  }
  v13 = sub_1000CB480((uint64_t)a5);
  if ((a3 & 0xFFFFFFFD) == 1 && v13)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is carrier-bundle based. Suppressing user password prompt. (%@)", "__WiFiDeviceManagerDispatchNotification", a5, v23);
LABEL_8:
    objc_autoreleasePoolPop(v14);
    goto LABEL_9;
  }
  v15 = sub_1000C5378((uint64_t)a5);
  if ((_DWORD)a3 == 1 && v15)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is profile based. Suppressing user password prompt. (%@)", "__WiFiDeviceManagerDispatchNotification", sub_10002B088(a5));
    objc_autoreleasePoolPop(v16);
    goto LABEL_17;
  }
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, const void *, uint64_t, _QWORD))(a1 + 3936))(a1, a2, a3, a4, a5, a6, *(_QWORD *)(a1 + 3944));
  if (!v21)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification for type %@(%d)", "__WiFiDeviceManagerDispatchNotification", sub_100064E5C(a3), a3);
    goto LABEL_8;
  }
  v22 = (const void *)v21;
  if (!(_DWORD)a3 && *(_DWORD *)(a1 + 108) != 2)
    sub_100160B34(*(_QWORD *)(a1 + 96));
  sub_1000BFB70((uint64_t)v22, (uint64_t)sub_10013E778, a1);
  sub_1000D7408((uint64_t)v22, *(_QWORD *)(a1 + 240));
  *(_QWORD *)(a1 + 224) = CFRetain(v22);
  sub_100135D8C(a1, CFSTR("autoJoinWaiting"), a5, 0);
  return 14;
}

void sub_1001198D4(uint64_t a1, const void *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;

  if (a1)
  {
    v4 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    *(_DWORD *)(a1 + 3280) = sub_100119668(a1, v4, 2, 0, a2, 0);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %@", "WiFiDeviceManagerDispatchSimulatedEAPTrustNotification", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is nil", "WiFiDeviceManagerDispatchSimulatedEAPTrustNotification", v6);
  }
  objc_autoreleasePoolPop(v5);
}

__CFDictionary *sub_1001199A8(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  _WORD *v5;
  const void *v6;
  CFIndex v7;
  const void *ValueAtIndex;
  CFIndex v9;
  const void *v10;
  id v11;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v13;
  id v14;
  unint64_t v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  __CFArray *v20;
  __CFArray *v21;
  unint64_t v22;
  id v23;
  CFNumberRef v24;
  _WORD *v25;
  void *v26;
  CFIndex Count;
  __CFDictionary *v28;
  void *v30;
  uint64_t v31;
  void *context;
  void *v33;
  __CFArray *theArray;
  uint64_t v35;
  unint64_t valuePtr;
  CFTypeRef cf;
  CFNumberRef number;
  void *value;
  unsigned int v40;

  v33 = objc_autoreleasePoolPush();
  number = 0;
  value = 0;
  valuePtr = 13;
  cf = 0;
  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
    goto LABEL_33;
  }
  v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: request is NULL!", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
    goto LABEL_33;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Processing Request:%@", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", a2);
  objc_autoreleasePoolPop(v4);
  CFDictionaryGetValueIfPresent(a2, CFSTR("command"), (const void **)&value);
  if (!value)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s with no command", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
    goto LABEL_33;
  }
  CFDictionaryGetValueIfPresent(a2, CFSTR("reason"), (const void **)&number);
  if (number)
    CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
  CFDictionaryGetValueIfPresent(a2, CFSTR("network"), &cf);
  if (cf)
  {
    v5 = sub_10002B314((uint64_t)kCFAllocatorDefault, cf);
    if (!v5)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s couldn't convert record to network", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
      goto LABEL_33;
    }
    v6 = v5;
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) < 1)
    {
LABEL_14:
      ValueAtIndex = 0;
    }
    else
    {
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v7);
        if (CFEqual(v6, ValueAtIndex))
          break;
        if (++v7 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)))
          goto LABEL_14;
      }
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)) >= 1)
    {
      v9 = 0;
      while (1)
      {
        v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v9);
        if (CFEqual(v6, v10))
          break;
        if (++v9 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)))
          goto LABEL_22;
      }
      ValueAtIndex = v10;
    }
LABEL_22:
    CFRelease(v6);
  }
  else
  {
    ValueAtIndex = 0;
  }
  if (CFStringCompare((CFStringRef)value, CFSTR("kAutoJoinBlacklistSet"), 0))
  {
    if (CFStringCompare((CFStringRef)value, CFSTR("kAutoJoinBlacklistClear"), 0))
      goto LABEL_34;
    if (ValueAtIndex)
    {
      if (valuePtr != 13)
      {
        v11 = sub_100027D10((uint64_t)ValueAtIndex);
        objc_msgSend(*(id *)(a1 + 6648), "removeNetworkDenyListInfoWithReason:forScanResult:", valuePtr, v11);

        goto LABEL_34;
      }
      goto LABEL_71;
    }
LABEL_69:
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't find network to set blacklist condition", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
    goto LABEL_33;
  }
  if (!ValueAtIndex)
    goto LABEL_69;
  if (valuePtr == 13)
  {
LABEL_71:
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't determine blacklist condition to set", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", v31);
    goto LABEL_33;
  }
  if (sub_100119F8C(a1, valuePtr, (uint64_t)ValueAtIndex))
    goto LABEL_34;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - __WiFiDeviceManagerSetAutoJoinBlacklistedNetworkCondition %lu failed", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", valuePtr);
LABEL_33:
  objc_autoreleasePoolPop(v4);
LABEL_34:
  context = objc_autoreleasePoolPush();
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v13 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v14 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedState:", 1);
  if (objc_msgSend(v14, "count"))
  {
    v15 = 0;
    theArray = Mutable;
    v35 = a1;
    do
    {
      v16 = objc_msgSend(v14, "objectAtIndex:", v15);
      v17 = sub_1000CE200(v16);
      v18 = objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", v16, 1, 0, 0);
      if (v18)
      {
        v19 = v18;
        if (objc_msgSend(v18, "count"))
        {
          v20 = v13;
          v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (objc_msgSend(v19, "count"))
          {
            v22 = 0;
            do
            {
              v23 = objc_msgSend(v19, "objectAtIndex:", v22);
              v40 = -1431655766;
              v40 = objc_msgSend(v23, "unsignedIntegerValue");
              v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
              CFArrayAppendValue(v21, v24);
              if (v24)
                CFRelease(v24);
              ++v22;
            }
            while (v22 < (unint64_t)objc_msgSend(v19, "count"));
          }
          v13 = v20;
          CFArrayAppendValue(v20, v21);
          if (v21)
            CFRelease(v21);
          v25 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v17);
          Mutable = theArray;
          CFArrayAppendValue(theArray, v25);
          a1 = v35;
          if (v25)
            CFRelease(v25);
        }
      }
      ++v15;
    }
    while (v15 < (unint64_t)objc_msgSend(v14, "count"));
  }
  if (CFArrayGetCount(Mutable))
  {
    v26 = v33;
    if (CFArrayGetCount(v13) && (Count = CFArrayGetCount(v13), Count == CFArrayGetCount(Mutable)))
    {
      v28 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v28, CFSTR("networks"), Mutable);
      CFDictionarySetValue(v28, CFSTR("reasons"), v13);
    }
    else
    {
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Mismatched reason and network array counts ", "__WiFiDeviceManagerCopyAutoJoinBlacklistedNetworksAndReasons");
      objc_autoreleasePoolPop(v30);
      v28 = 0;
    }
  }
  else
  {
    v28 = 0;
    v26 = v33;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v13)
    CFRelease(v13);
  objc_autoreleasePoolPop(context);
  objc_autoreleasePoolPop(v26);
  return v28;
}

uint64_t sub_100119F8C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  void *v6;
  id v7;
  uint64_t v8;
  const void *v9;
  id v10;
  const void *v11;
  void *v13;
  const void *v14;
  int v15;

  v6 = objc_autoreleasePoolPush();
  v7 = sub_100027D10(a3);
  v8 = 0;
  if (!a1 || !a3)
    goto LABEL_12;
  objc_msgSend(*(id *)(a1 + 6648), "setDenyListedStateExpiryIntervalInSec:state:", 1, 60.0);
  if (a2 > 7)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - unrecognized WiFiDenyListAddReason", "__WiFiDeviceManagerSetAutoJoinBlacklistedNetworkCondition");
    objc_autoreleasePoolPop(v13);
    v8 = 0;
    if (v7)
      goto LABEL_13;
    goto LABEL_14;
  }
  if (((1 << a2) & 0x4F) != 0)
  {
    v9 = sub_10002BE64(a3, CFSTR("BSSID"));
    v10 = sub_1000FCB38(a1, a2, 0, (uint64_t)v9, 1);
  }
  else
  {
    if (((1 << a2) & 0x90) == 0)
    {
      v14 = sub_10002BE64(a3, CFSTR("BSSID"));
      v15 = 5;
      v10 = sub_1000FCB38(a1, 5, 0, (uint64_t)v14, 1);
      do
      {
        objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v10, v7);
        --v15;
      }
      while (v15);
      goto LABEL_9;
    }
    v11 = sub_10002BE64(a3, CFSTR("BSSID"));
    v10 = sub_1000FCB38(a1, a2, 0, (uint64_t)v11, 1);
    objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v10, v7);
    objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v10, v7);
  }
  objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v10, v7);
LABEL_9:
  if (v10)

  v8 = 1;
LABEL_12:
  if (v7)
LABEL_13:

LABEL_14:
  objc_autoreleasePoolPop(v6);
  return v8;
}

uint64_t sub_10011A160(uint64_t result, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, uint64_t, _QWORD);

  if (result)
  {
    v3 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(result + 4536);
    if (v3)
    {
      v3(result, a3, a2, *(_QWORD *)(result + 4544));
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_10011A19C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 176) == 1;
}

void sub_10011A1AC(uint64_t a1)
{
  void (*v2)(uint64_t, _QWORD);
  void *v3;

  if (a1)
  {
    v2 = *(void (**)(uint64_t, _QWORD))(a1 + 4568);
    if (v2)
      v2(a1, *(_QWORD *)(a1 + 4576));
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_1000285E4(a1, 0x1CuLL);
    else
      sub_1000FA0A0(a1, 6);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiDeviceManagerAttemptHomeNetworkTransition");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_10011A268(uint64_t a1, int a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const char *v7;
  void *ValueAtIndex;
  void *v9;
  void *v10;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  const char *v14;
  void *v15;
  void *v16;
  void *v17;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    if (a2 == 1)
      v7 = "Invalidating";
    else
      v7 = "Disabling";
    do
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v6);
      if (ValueAtIndex)
      {
        v9 = ValueAtIndex;
        if (sub_1000C3F88((uint64_t)ValueAtIndex) == 1)
        {
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s %s home NOI for broadcast network '%@'", "WiFiDeviceManagerDisableHomeNetwork", v7, sub_10002B088(v9));
          objc_autoreleasePoolPop(v10);
          sub_10011A420(a1, v9, a2);
        }
      }
      ++v6;
    }
    while (v5 != v6);
  }
  v11 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3536));
  if (v11 >= 1)
  {
    v12 = v11;
    v13 = 0;
    if (a2 == 1)
      v14 = "Invalidating";
    else
      v14 = "Disabling";
    do
    {
      v15 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v13);
      if (v15)
      {
        v16 = v15;
        if (sub_1000C3F88((uint64_t)v15) == 1)
        {
          v17 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%s home NOI for directed network '%@'", "WiFiDeviceManagerDisableHomeNetwork", v14, sub_10002B088(v16));
          objc_autoreleasePoolPop(v17);
          sub_10011A420(a1, v16, a2);
        }
      }
      ++v13;
    }
    while (v12 != v13);
  }
}

void sub_10011A420(uint64_t a1, void *a2, int a3)
{
  void *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  const void *v10;

  if (a3)
  {
    sub_1000CBF00(a2, 2);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    v6 = objc_msgSend(*(id *)(a1 + 6624), "copyHomeNetworkTransitionDate");
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disabling NOI home network '%@' until %@", "__WiFiDeviceManagerDisableHomeNetworkHelper", sub_10002B088(a2), v6);
    objc_autoreleasePoolPop(v7);
    sub_1000C682C((uint64_t)a2, v6);
    sub_1000C68E8((CFMutableDictionaryRef *)a2, 0, CFSTR("DisableHomeNetwork"));

    objc_autoreleasePoolPop(v5);
  }
  v8 = objc_autoreleasePoolPush();
  v9 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v10 = sub_10002B088(a2);
    objc_msgSend(v9, "WFLog:message:", 4, "%s: Updating NOI home-state key for '%@' to %d", "__WiFiDeviceManagerDisableHomeNetworkHelper", v10, sub_1000C3F88((uint64_t)a2));
  }
  objc_autoreleasePoolPop(v8);
  sub_1001053C8((NSObject **)a1, a2);
}

uint64_t sub_10011A558(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4568) = a2;
  *(_QWORD *)(result + 4576) = a3;
  return result;
}

uint64_t sub_10011A564(const void *a1)
{
  void *v2;
  uint64_t v3;
  void *v5;
  const void *v6;
  void *v7;

  if (a1)
  {
    if (sub_1000CB480((uint64_t)a1))
    {
      v2 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = sub_10002B088(a1);
        v3 = 3;
        objc_msgSend(v5, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it's carrier based.", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", v6);
      }
      else
      {
        v3 = 3;
      }
    }
    else if (sub_1000C5408((uint64_t)a1) && sub_10002DAB4((uint64_t)a1))
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it was added by a third party (WiFiNetworkIsAppBased() is true)", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", sub_10002B088(a1));
      v3 = 8;
    }
    else if (sub_1000C5BD8(a1))
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it requires a one time password (WiFiNetworkRequiresOneTimePassword() is true)", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", sub_10002B088(a1));
      v3 = 9;
    }
    else if (sub_1000C5378((uint64_t)a1) && !sub_10002DAB4((uint64_t)a1))
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it's currently determined to be profile based and is not EAP (WPA/WPA2 Personal, Open and WEP configurations not supported for profile based networks)", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", sub_10002B088(a1));
      v3 = 6;
    }
    else if (sub_10002DAB4((uint64_t)a1)
           && -[ManagedConfigWrapper isEAPShareBlockedByManagedDefault](+[ManagedConfigWrapper sharedInstance](ManagedConfigWrapper, "sharedInstance"), "isEAPShareBlockedByManagedDefault"))
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it's EAP auth and the profile to block EAP credential sharing is installed", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", sub_10002B088(a1));
      v3 = 7;
    }
    else
    {
      v2 = objc_autoreleasePoolPush();
      if (-[ManagedConfigWrapper isWiFiNetworkSubjectToMDM:](+[ManagedConfigWrapper sharedInstance](ManagedConfigWrapper, "sharedInstance"), "isWiFiNetworkSubjectToMDM:", a1))
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it's subject to MDM.", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", sub_10002B088(a1));
        objc_autoreleasePoolPop(v7);
        v3 = 2;
      }
      else
      {
        v3 = 1;
      }
    }
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Can't determine shareable status, network argument is NULL", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup");
    v3 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_10011A820(const void *a1)
{
  const __CFAllocator *Default;
  CFNumberRef v3;
  CFNumberRef v4;
  unsigned int valuePtr;

  valuePtr = sub_10011A564(a1);
  Default = CFAllocatorGetDefault();
  v3 = CFNumberCreate(Default, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    v4 = v3;
    sub_10002C478((uint64_t)a1, CFSTR("ShareableStatus"), v3);
    CFRelease(v4);
  }
  return valuePtr;
}

uint64_t sub_10011A888(const void *a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  CFAllocatorRef Default;
  CFDictionaryRef *v5;
  CFDictionaryRef *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  uint64_t v14;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *value;

  value = 0;
  if (!sub_10002DAB4((uint64_t)a1))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not appending EAP info for nearby device setup as the supplied network argument does NOT use EAP auth (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    goto LABEL_23;
  }
  if (-[ManagedConfigWrapper isEAPShareBlockedByManagedDefault](+[ManagedConfigWrapper sharedInstance](ManagedConfigWrapper, "sharedInstance"), "isEAPShareBlockedByManagedDefault"))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Network with SSID: %@ is unshareable as it's EAP auth and the profile to block EAP credential sharing is installed. Will not append EAP credentials", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    goto LABEL_23;
  }
  if (sub_1000C5408((uint64_t)a1))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not appending EAP info for nearby device setup as the supplied network comes from a third party (WiFiNetworkIsAppBased() true). (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    goto LABEL_23;
  }
  v2 = sub_1000C33D0((uint64_t)a1);
  if (!v2)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Got NULL back from WiFiNetworkCopyFilteredRecord(), bailing and not appending EAP info. SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
LABEL_23:
    objc_autoreleasePoolPop(v16);
    return 0;
  }
  v3 = v2;
  Default = CFAllocatorGetDefault();
  v5 = (CFDictionaryRef *)sub_10002B314((uint64_t)Default, v3);
  if (!v5)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Failed to create WiFiNetworkRef from the result of WiFiNetworkCopyFilteredRecord(), bailing and not appending EAP info. SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    objc_autoreleasePoolPop(v17);
    CFRelease(v3);
    return 0;
  }
  v6 = v5;
  v7 = sub_1000C34F4(v5, 0);
  v8 = v7;
  if (v7)
  {
    CFDictionaryGetValueIfPresent(v7, CFSTR("EAPClientConfiguration"), (const void **)&value);
    if (value)
    {
      v9 = (const void *)EAPClientConfigurationCopyShareable();
      if (v9)
      {
        v10 = v9;
        sub_10002C478((uint64_t)a1, CFSTR("ShareableEAPConfig"), v9);
        v11 = sub_10002B088(a1);
        v12 = (const void *)EAPTLSCopyTrustExceptionBindings(CFSTR("WirelessSSID"), v11);
        if (v12)
        {
          v13 = v12;
          sub_10002C478((uint64_t)a1, CFSTR("ShareableEAPTrustExceptions"), v12);
          CFRelease(v13);
        }
        else
        {
          v19 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s failed to copy trust exceptions for network with SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
          objc_autoreleasePoolPop(v19);
        }
        CFRelease(v10);
        v14 = 1;
        goto LABEL_12;
      }
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s EAPUtilCopyShareableConfiguration() didn't return a shareable EAP config, most likely cause is unsupported EAPAcceptTypes (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s no kEAPOLControlEAPClientConfiguration for network (SSID: %@), won't append", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
    }
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s no eapProfile (or Got NULL back from WiFiNetworkCopyPreparedEAPProfile()) for network (SSID: %@), won't append", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_10002B088(a1));
  }
  objc_autoreleasePoolPop(v18);
  v14 = 0;
LABEL_12:
  CFRelease(v3);
  CFRelease(v6);
  if (v8)
    CFRelease(v8);
  return v14;
}

uint64_t sub_10011AC28(uint64_t a1, const void *a2)
{
  void *v2;
  const void *v3;
  uint64_t v4;
  void *v6;
  void *v7;

  if (a1 && a2)
  {
    v2 = sub_10002A21C(a1, a2, 1);
    if (sub_10002DAB4((uint64_t)v2))
    {
      v3 = sub_10002B088(v2);
      EAPTLSSetTrustExceptionBindings(CFSTR("WirelessSSID"), v3, &off_100254020);
      v4 = 1;
      if (v2)
LABEL_5:
        CFRelease(v2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not destroying EAP trust for current network is it's not EAP  (SSID: %@)", "WiFiDeviceManagerDestroyEAPTrustExceptionsForCurrentNetwork", sub_10002B088(v2));
      objc_autoreleasePoolPop(v7);
      v4 = 0;
      if (v2)
        goto LABEL_5;
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s requires manager and interface name args", "WiFiDeviceManagerDestroyEAPTrustExceptionsForCurrentNetwork");
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  return v4;
}

void sub_10011AD38(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a1)
  {
    if (a2)
    {
      *(_QWORD *)(a1 + 5408) = a2;
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Battery Manager set ", "WiFiDeviceManagerSetBatteryManager");
    }
    else
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Battery manager is NULL", "WiFiDeviceManagerSetBatteryManager");
    }
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetBatteryManager");
  }
  objc_autoreleasePoolPop(v2);
}

void sub_10011ADFC(uint64_t a1, unsigned int a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabled %d", "WiFiDeviceManagerSetAvailabilityEngineIsEnabled", a2);
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 6712) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetAvailabilityEngineIsEnabled");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_10011AEB0(uint64_t result)
{
  if (result)
    return sub_10007785C(*(_QWORD *)(result + 64));
  return result;
}

uint64_t sub_10011AEC0(uint64_t result)
{
  if (result)
    return sub_100077868(*(_QWORD *)(result + 64));
  return result;
}

uint64_t sub_10011AED0(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    result = _os_feature_enabled_impl("WiFiManager", "WPA3PersonalHotspot");
    if ((_DWORD)result)
    {
      result = sub_100077874(*(_QWORD *)(v1 + 64));
      if ((_DWORD)result)
        return sub_100071650(*(_QWORD *)(v1 + 64)) != 0;
    }
  }
  return result;
}

uint64_t sub_10011AF24(uint64_t result)
{
  if (result)
    return sub_100071650(*(_QWORD *)(result + 64));
  return result;
}

uint64_t sub_10011AF34(uint64_t a1)
{
  void *v2;

  if (!a1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: device manager is NULL", "WiFiDeviceManagerLQMConfig");
    objc_autoreleasePoolPop(v2);
  }
  return 4294963393;
}

uint64_t sub_10011AF9C(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 240);
  return result;
}

void sub_10011AFAC(uint64_t a1, int a2)
{
  void *v3;
  void *v4;
  void *v5;
  const void *v6;
  void *v7;
  const void *v8;
  void *v9;
  const void *v10;
  void *v11;
  void *v12;
  const void *v13;
  void *v14;
  void *v15;

  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : NULL Manager", "WiFiDeviceManagerHandleChangedPowerBudgetValue");
    objc_autoreleasePoolPop(v14);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : NULL Manager", "WiFiDeviceManagerHandleChangedPowerBudgetValue");
    v5 = v15;
    goto LABEL_6;
  }
  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : resource has become available for auto-join/awdl. manager->state.enable(%d)", "WiFiDeviceManagerHandleChangedPowerBudgetValue", *(unsigned __int8 *)(a1 + 3305));
    objc_autoreleasePoolPop(v3);
    v4 = objc_autoreleasePoolPush();
    objc_msgSend(*(id *)(a1 + 5408), "requestPowerResource:withDetails:", 0, 0);
    v5 = v4;
LABEL_6:
    objc_autoreleasePoolPop(v5);
    return;
  }
  v6 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v7 = sub_10002A21C(a1, v6, 1);
  if (v7)
  {
    v8 = v7;
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : resource no longer available for connection. Disassociating...", "WiFiDeviceManagerHandleChangedPowerBudgetValue");
    objc_autoreleasePoolPop(v9);
    v10 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_1000F7F48(a1, v10, 1006, "WiFiDeviceManagerHandleChangedPowerBudgetValue", 36175);
    CFRelease(v8);
  }
  else if (*(_BYTE *)(a1 + 3305))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : resource no longer available for auto-join. Aborting...", "WiFiDeviceManagerHandleChangedPowerBudgetValue");
    objc_autoreleasePoolPop(v11);
    sub_1000FB44C(a1);
    sub_1000FB8B8(a1);
  }
  if (*(_DWORD *)(a1 + 5424))
  {
    v12 = *(void **)(a1 + 5432);
    if (v12)

    *(_QWORD *)(a1 + 5432) = 0;
    v13 = (const void *)sub_100068E60(*(_QWORD *)(a1 + 64));
    sub_1000FB00C(a1, v13);
  }
}

void sub_10011B1DC(uint64_t a1, int a2, _QWORD *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;

  if (!a3)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null request.", "WiFiDeviceManagerHandleUnchangedPowerBudgetValue");
    goto LABEL_32;
  }
  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device manager.", "WiFiDeviceManagerHandleUnchangedPowerBudgetValue");
LABEL_32:
    objc_autoreleasePoolPop(v6);
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : NULL Request or Null Device Manager", "WiFiDeviceManagerHandleUnchangedPowerBudgetValue");
    objc_autoreleasePoolPop(v17);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiBatteryMgmt : power budget resource is present and unchanged!.", "WiFiDeviceManagerHandleUnchangedPowerBudgetValue");
  objc_autoreleasePoolPop(v6);
  if (*a3)
  {
    if (*a3 != 1)
      return;
    v7 = a3[1];
    if (!v7)
      return;
    if (a2)
    {
      v8 = sub_10010F118(a1, *(const __CFString **)(v7 + 16), *(const __CFDictionary **)(v7 + 24), *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 40), *(const void **)(v7 + 48));
      if (!(_DWORD)v8)
        goto LABEL_20;
      v9 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(v7 + 8);
      if (!v9)
        goto LABEL_20;
      v10 = v8;
      v11 = *(_QWORD *)(v7 + 16);
      v12 = *(_QWORD *)(v7 + 40);
      v13 = a1;
    }
    else
    {
      v9 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(v7 + 8);
      if (!v9)
      {
LABEL_20:
        v14 = *(const void **)(v7 + 16);
        if (v14)
        {
          CFRelease(v14);
          *(_QWORD *)(v7 + 16) = 0;
        }
        v15 = *(const void **)(v7 + 24);
        if (v15)
        {
          CFRelease(v15);
          *(_QWORD *)(v7 + 24) = 0;
        }
        v16 = *(const void **)(v7 + 48);
        if (v16)
          CFRelease(v16);
        free((void *)v7);
        return;
      }
      v11 = *(_QWORD *)(v7 + 16);
      v12 = *(_QWORD *)(v7 + 40);
      v13 = a1;
      v10 = 4294963390;
    }
    v9(v13, v11, v10, 0, 0, v12);
    goto LABEL_20;
  }
  if (a2 && *(_BYTE *)(a1 + 3305))
  {
    *(_DWORD *)(a1 + 192) = 9;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000285E4(a1, 0x17uLL);
    }
    else
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 23, sub_100025C3C(*(_QWORD *)(a1 + 64)));
      sub_1000FBA80(a1, 2, (uint64_t)"WiFiDeviceManagerAutoAssociateStart");
    }
  }
}

void sub_10011B44C(uint64_t a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  CFBooleanRef v4;
  CFBooleanRef v5;
  void (*v6)(uint64_t, uint64_t, _QWORD, __CFDictionary *);
  uint64_t v7;

  if (*(_QWORD *)(a1 + 4440))
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v3 = Mutable;
      CFDictionarySetValue(Mutable, CFSTR("WiFiHostApStateIdentifier"), kCFBooleanTrue);
      if ((*(_BYTE *)(a1 + 7057) & 4) != 0)
        v4 = kCFBooleanTrue;
      else
        v4 = kCFBooleanFalse;
      CFDictionarySetValue(v3, CFSTR("WiFiHostApStateEnable"), v4);
      if (*(_BYTE *)(a1 + 5260))
        v5 = kCFBooleanTrue;
      else
        v5 = kCFBooleanFalse;
      CFDictionarySetValue(v3, CFSTR("WiFiHostApStateADHSMode"), v5);
      v6 = *(void (**)(uint64_t, uint64_t, _QWORD, __CFDictionary *))(a1 + 4440);
      v7 = sub_1000698C4(*(_QWORD *)(a1 + 64));
      v6(a1, v7, *(_QWORD *)(a1 + 4448), v3);
      CFRelease(v3);
    }
  }
}

void sub_10011B558(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  int v6;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: test mode %d", "WiFiDeviceManagerAutoInstantHotspotTestMode", a2);
    objc_autoreleasePoolPop(v4);
    switch((int)a2)
    {
      case 1:
        v5 = a1;
        v6 = 1;
        goto LABEL_7;
      case 2:
        v5 = a1;
        v6 = 0;
LABEL_7:
        sub_100006188(v5, v6);
        break;
      case 3:
        *(_BYTE *)(a1 + 6832) = 0;
        break;
      case 4:
        *(_BYTE *)(a1 + 6832) = 1;
        break;
      default:
        return;
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerAutoInstantHotspotTestMode");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10011B664(uint64_t a1, int a2)
{
  int v4;
  double v5;
  void *v6;
  void *v7;
  NSObject *v8;
  dispatch_time_t v9;
  void *v10;

  v4 = *(_DWORD *)(a1 + 3280);
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    if (-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
    {
      if (*(_DWORD *)(a1 + 20) == 1
        && sub_10011BAA8(a1)
        && (v4 - 16) >= 5
        && (objc_msgSend(*(id *)(a1 + 3656), "isTimeDeferredNetworksPresent") & 1) == 0
        && v4 != 12)
      {
        v5 = 0.0;
        if (CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6944) <= 180.0)
          v5 = *(double *)(a1 + 6944) - CFAbsoluteTimeGetCurrent() + 180.0;
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: autoHS mode = %d Primary Interface = %d AutoHotspotAssociated=%d wifiNetworkAutoJoinFailed=%d autoHotspotEnableRequest=%d RemainTimingout=%f", "__WiFiDeviceManagerScanForAutoInstantHotspot", *(unsigned int *)(a1 + 6804), sub_10007788C(*(_QWORD *)(a1 + 64)), *(unsigned __int8 *)(a1 + 6896), *(unsigned __int8 *)(a1 + 6897), *(unsigned __int8 *)(a1 + 6800), *(_QWORD *)&v5);
        objc_autoreleasePoolPop(v6);
        if (!*(_BYTE *)(a1 + 6896)
          && *(_BYTE *)(a1 + 6897)
          && sub_10011BAA8(a1)
          && (a2 || CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6944) > 180.0))
        {
          CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 6840));
          *(_DWORD *)(a1 + 6888) = 2;
          *(_QWORD *)(a1 + 6880) = 0x300000002;
          *(_BYTE *)(a1 + 6968) = 0;
          v7 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Scanning for Hotspot Devices: curr state %d next state %d", "__WiFiDeviceManagerScanForAutoInstantHotspot", *(unsigned int *)(a1 + 3280), 16);
          objc_autoreleasePoolPop(v7);
          if (*(_DWORD *)(a1 + 3280) == 16)
            sub_1000F48F0(a1, 0);
          *(_DWORD *)(a1 + 6892) = 0;
          *(_DWORD *)(a1 + 3280) = 16;
          *(CFAbsoluteTime *)(a1 + 6944) = CFAbsoluteTimeGetCurrent();
          *(_OWORD *)(a1 + 6456) = 0u;
          *(_OWORD *)(a1 + 6472) = 0u;
          *(_OWORD *)(a1 + 6488) = 0u;
          *(_OWORD *)(a1 + 6504) = 0u;
          *(_OWORD *)(a1 + 6520) = 0u;
          *(_OWORD *)(a1 + 6536) = 0u;
          *(_OWORD *)(a1 + 6552) = 0u;
          v8 = *(NSObject **)(a1 + 6808);
          v9 = dispatch_time(0, 30000000000);
          dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0);
          objc_msgSend(*(id *)(a1 + 6744), "startBrowsing");
          *(CFAbsoluteTime *)(a1 + 6960) = CFAbsoluteTimeGetCurrent();
          ++*(_DWORD *)(a1 + 6172);
        }
      }
    }
    else
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setup not completed yet.", "__WiFiDeviceManagerScanForAutoInstantHotspot");
      objc_autoreleasePoolPop(v10);
    }
  }
}

void sub_10011B934(uint64_t a1, uint64_t a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabled %@(%d)", "WiFiDeviceManagerSetAutoInstantHotspotMode", sub_100064E0C(a2), a2);
    objc_autoreleasePoolPop(v4);
    *(_DWORD *)(a1 + 6804) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetAutoInstantHotspotMode");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10011B9F4(uint64_t a1, double a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: interval %f", "WiFiDeviceManagerSetAutoInstantHotspotTriggerInterval", *(_QWORD *)&a2);
    objc_autoreleasePoolPop(v4);
    *(double *)(a1 + 6864) = a2;
    *(double *)(a1 + 6872) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetAutoInstantHotspotTriggerInterval");
    objc_autoreleasePoolPop(v4);
  }
}

const __CFNumber *sub_10011BAA8(uint64_t a1)
{
  const __CFNumber *result;
  void *v3;

  if (!*(_DWORD *)(a1 + 6804) || sub_10007788C(*(_QWORD *)(a1 + 64)) || *(_BYTE *)(a1 + 7024))
    return 0;
  if (CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6952) > 15.0
    && (*(_DWORD *)(a1 + 6804) != 1 || *(_BYTE *)(a1 + 6800))
    || (result = sub_10011BB88(a1), (_DWORD)result))
  {
    if (!-[WiFiUserInteractionMonitor isAnyCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAnyCallInProgress"))return (const __CFNumber *)1;
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: call is in progress, not scanning for auto hotspot.", "__WiFiDeviceManagerIsAutoHotspotTriggerStateValid");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  return result;
}

const __CFNumber *sub_10011BB88(uint64_t a1)
{
  const __CFNumber *result;
  unsigned int valuePtr;

  result = *(const __CFNumber **)(a1 + 3512);
  if (result)
  {
    result = (const __CFNumber *)sub_10001395C((uint64_t)result);
    if ((_DWORD)result)
    {
      if (sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("WiFiAutoInstantHotspotJoining")) != kCFBooleanTrue)
        return 0;
      result = (const __CFNumber *)sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("lastDisconnectReasonKey"));
      if (result)
      {
        valuePtr = -1431655766;
        CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
        return (const __CFNumber *)(valuePtr <= 2 && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6952) <= 600.0);
      }
    }
  }
  return result;
}

uint64_t sub_10011BC40(uint64_t a1)
{
  return *(unsigned int *)(a1 + 6972);
}

void sub_10011BC48(uint64_t a1, int a2)
{
  CFNumberRef v3;
  uint64_t v4;
  const void *v5;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 64);
    v5 = (const void *)sub_100025C3C(v4);
    sub_1000672C0(v4, v5, 537, 0, (uint64_t)v3);
  }
  if (v3)
    CFRelease(v3);
}

void sub_10011BCC0(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  _QWORD v9[5];

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting 3bars source: %@", "WiFiDeviceManagerSet3BarsSource", a2);
    objc_autoreleasePoolPop(v5);
    if (!*(_QWORD *)(a1 + 6672))
    {
      v6 = objc_alloc_init((Class)NSMutableSet);
      *(_QWORD *)(a1 + 6696) = a2;
      objc_msgSend(v6, "addObject:", a2);
      v7 = objc_alloc_init((Class)WiFiWalletSource);
      *(_QWORD *)(a1 + 6688) = v7;
      if (v7)
        objc_msgSend(v6, "addObject:", v7);
      *(_QWORD *)(a1 + 6672) = objc_msgSend(objc_alloc((Class)WiFiAvailabilityEngine), "initWithProviders:sources:", +[NSSet setWithObjects:](NSSet, "setWithObjects:", *(_QWORD *)(a1 + 6680), 0), v6);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: initialized availability engine", "WiFiDeviceManagerSet3BarsSource");
      objc_autoreleasePoolPop(v8);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_10011BE6C;
      v9[3] = &unk_100231640;
      v9[4] = a1;
      objc_msgSend(*(id *)(a1 + 6672), "setAvailabilityChangedCallback:", v9);
      if (v6)
        CFRelease(v6);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: 3bars source is nil", "WiFiDeviceManagerSet3BarsSource");
    objc_autoreleasePoolPop(v5);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_10011BE6C(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: recommendations found: %@", "__WiFiDeviceManagerHandleNetworkAvailabilityChange", a2);
  objc_autoreleasePoolPop(v3);
}

_QWORD *sub_10011BEC8(_QWORD *result, uint64_t a2, double a3, double a4)
{
  _QWORD *v7;
  void *v8;
  _BOOL8 v9;

  if (result)
  {
    v7 = result;
    if (result[840] != a2 || *((double *)result + 841) != a3 || *((double *)result + 842) != a4)
    {
      result[840] = a2;
      *((double *)result + 841) = a3;
      *((double *)result + 842) = a4;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: mode:%ld time:%f secs, distance: %f m", "WiFiDeviceManagerSetJoinAlertParams", a2, *(_QWORD *)&a4, *(_QWORD *)&a3);
      objc_autoreleasePoolPop(v8);
      v9 = v7[840] == 255 || *((_DWORD *)v7 + 1644) == 255;
      return objc_msgSend((id)v7[838], "enableTestMode:", v9);
    }
  }
  return result;
}

void sub_10011BFB8(uint64_t a1, const __CFArray *a2)
{
  uint64_t v4;
  const void *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex v8;
  CFMutableDictionaryRef Mutable;
  const void *v10;
  const void *v11;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  __CFDictionary *v14;
  const __CFString *Value;
  const void *v16;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v18;
  const void *v19;
  void *v20;
  __CFDictionary *v21;
  void *v22;
  NSDate *v23;
  const __CFArray *v24;
  CFIndex v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const __CFAllocator *v31;
  __CFDictionary *v32;
  const void *v33;
  __CFDictionary *v34;
  const __CFArray *v35;
  CFMutableArrayRef v36;
  const __CFArray *v37;
  const __CFArray *v38;
  CFMutableArrayRef v39;
  CFIndex v40;
  const __CFDictionary *v41;
  const __CFDictionary *v42;
  __CFDictionary *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const __CFNumber *v47;
  const __CFNumber *v48;
  CFIndex v49;
  const __CFDictionary *v50;
  const __CFDictionary *v51;
  const void *v52;
  const void *v53;
  const __CFNumber *v54;
  const __CFNumber *v55;
  unint64_t v56;
  CFNumberRef v57;
  CFNumberRef v58;
  CFNumberRef v59;
  CFNumberRef v60;
  CFIndex FirstIndexOfValue;
  CFIndex v62;
  void *v63;
  const void *v64;
  CFMutableDictionaryRef MutableCopy;
  void *v66;
  const __CFArray *v67;
  uint64_t v68;
  const __CFDictionary *theDict;
  CFAllocatorRef allocator;
  const __CFDictionary *v71;
  const __CFArray *theArray;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t valuePtr;
  CFRange v77;
  CFRange v78;

  if (!a1)
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerGetInterfaceDataUsage");
    goto LABEL_107;
  }
  if (!a2)
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null mutableIfStatsArrayRef.", "WiFiDeviceManagerGetInterfaceDataUsage");
    goto LABEL_107;
  }
  v4 = sub_100029860(*(_QWORD *)(a1 + 64));
  if (!v4)
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null ifName.", "WiFiDeviceManagerGetInterfaceDataUsage");
LABEL_107:
    objc_autoreleasePoolPop(v66);
    return;
  }
  v5 = (const void *)v4;
  v6 = (const __CFArray *)DHCPSDHCPLeaseListCreate();
  theArray = a2;
  v68 = a1;
  if (v6)
  {
    v7 = v6;
    if (CFArrayGetCount(v6) < 1)
    {
      Mutable = 0;
    }
    else
    {
      v8 = 0;
      Mutable = 0;
      v10 = (const void *)kDHCPSPropDHCPHWAddress;
      v11 = (const void *)kDHCPSPropName;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v8);
        if (ValueAtIndex)
        {
          v13 = ValueAtIndex;
          if (Mutable
            || (Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) != 0)
          {
            v14 = Mutable;
            Value = (const __CFString *)CFDictionaryGetValue(v13, v10);
            v16 = CFDictionaryGetValue(v13, v11);
            ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, Value, CFSTR(","));
            if (ArrayBySeparatingStrings)
            {
              v18 = ArrayBySeparatingStrings;
              if (CFArrayGetCount(ArrayBySeparatingStrings) >= 2)
              {
                v19 = CFArrayGetValueAtIndex(v18, 1);
                if (v19)
                {
                  if (v16)
                    CFDictionaryAddValue(v14, v19, v16);
                }
              }
              CFRelease(v18);
            }
            Mutable = v14;
          }
        }
        ++v8;
      }
      while (v8 < CFArrayGetCount(v7));
    }
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DHCP client hostnames: %@", "WiFiDeviceManagerGetInterfaceDataUsage", Mutable);
    objc_autoreleasePoolPop(v20);
    CFRelease(v7);
  }
  else
  {
    Mutable = 0;
  }
  v21 = sub_100077AB8(*(_QWORD *)(a1 + 64), v5);
  v22 = objc_autoreleasePoolPush();
  theDict = v21;
  if (!v21)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ifUsageRef. Nothing to update.", "WiFiDeviceManagerGetInterfaceDataUsage");
    objc_autoreleasePoolPop(v22);
    if (Mutable)
      goto LABEL_97;
    return;
  }
  v71 = Mutable;
  v23 = -[NSCalendar dateFromComponents:](+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"), "dateFromComponents:", -[NSCalendar components:fromDate:](+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"), "components:fromDate:", 28, +[NSDate date](NSDate, "date")));
  v24 = theArray;
  if (CFArrayGetCount(theArray) < 1)
    goto LABEL_33;
  v25 = 0;
  while (1)
  {
    v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v24, v25);
    if (v26)
    {
      v27 = v26;
      v28 = CFDictionaryGetValue(v26, CFSTR("DataUsageInterfaceName"));
      v29 = CFDictionaryGetValue(v27, CFSTR("DataUsageDate"));
      if (v28)
      {
        v30 = v29;
        if (v29)
        {
          if (CFEqual(v28, v5) && CFEqual(v30, v23))
            break;
        }
      }
    }
    ++v25;
    v24 = theArray;
    if (v25 >= CFArrayGetCount(theArray))
      goto LABEL_33;
  }
  v31 = kCFAllocatorDefault;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v27);
  CFArrayRemoveValueAtIndex(theArray, v25);
  if (MutableCopy)
  {
    v34 = MutableCopy;
  }
  else
  {
LABEL_33:
    v31 = kCFAllocatorDefault;
    v32 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v33 = v5;
    v34 = v32;
    CFDictionarySetValue(v32, CFSTR("DataUsageInterfaceName"), v33);
    CFDictionarySetValue(v34, CFSTR("DataUsageDate"), v23);
  }
  objc_autoreleasePoolPop(v22);
  v35 = (const __CFArray *)CFDictionaryGetValue(v34, CFSTR("DataUsageInterfacePeerList"));
  Mutable = v71;
  if (v35)
    v36 = CFArrayCreateMutableCopy(v31, 0, v35);
  else
    v36 = CFArrayCreateMutable(v31, 0, &kCFTypeArrayCallBacks);
  v37 = v36;
  v38 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("DataUsageInterfacePeerList"));
  if (v38)
  {
    v39 = CFArrayCreateMutableCopy(v31, 0, v38);
    if (!v37)
      goto LABEL_86;
  }
  else
  {
    v39 = 0;
    if (!v37)
      goto LABEL_86;
  }
  v67 = v39;
  if (CFArrayGetCount(v37) >= 1)
  {
    v40 = 0;
    allocator = v31;
    do
    {
      v75 = 0;
      valuePtr = 0;
      v73 = 0;
      v74 = 0;
      v41 = (const __CFDictionary *)CFArrayGetValueAtIndex(v37, v40);
      if (v41)
      {
        v42 = CFDictionaryCreateMutableCopy(v31, 0, v41);
        if (v42)
        {
          v43 = v42;
          v44 = CFDictionaryGetValue(v42, CFSTR("DataUsageInterfacePeerAddr"));
          if (v44)
          {
            v45 = v44;
            if (!CFDictionaryGetValue(v43, CFSTR("DataUsageInterfacePeerDisplayName"))
              && v71
              && CFDictionaryGetValue(v71, v45))
            {
              v46 = CFDictionaryGetValue(v71, v45);
              CFDictionarySetValue(v43, CFSTR("DataUsageInterfacePeerDisplayName"), v46);
            }
            v47 = (const __CFNumber *)CFDictionaryGetValue(v43, CFSTR("DataUsageInterfacePeerLastBytes"));
            if (v47)
              CFNumberGetValue(v47, kCFNumberSInt64Type, &valuePtr);
            v48 = (const __CFNumber *)CFDictionaryGetValue(v43, CFSTR("DataUsageInterfacePeerTotalBytes"));
            if (v48)
              CFNumberGetValue(v48, kCFNumberSInt64Type, &v75);
            if (v38 && CFArrayGetCount(v38) >= 1)
            {
              v49 = 0;
              while (1)
              {
                v50 = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, v49);
                if (v50)
                {
                  v51 = v50;
                  v52 = CFDictionaryGetValue(v50, CFSTR("DataUsageInterfacePeerAddr"));
                  if (v52)
                  {
                    v53 = v52;
                    v54 = (const __CFNumber *)CFDictionaryGetValue(v51, CFSTR("DataUsageInterfacePeerLastBytes"));
                    if (v54)
                      CFNumberGetValue(v54, kCFNumberSInt64Type, &v74);
                    v55 = (const __CFNumber *)CFDictionaryGetValue(v51, CFSTR("DataUsageInterfacePeerTotalBytes"));
                    if (v55)
                      CFNumberGetValue(v55, kCFNumberSInt64Type, &v73);
                    if (CFEqual(v45, v53))
                      break;
                  }
                }
                if (++v49 >= CFArrayGetCount(v38))
                  goto LABEL_65;
              }
              v31 = allocator;
              if (v67)
              {
                if (CFArrayGetCount(v67))
                {
                  v77.length = CFArrayGetCount(v67);
                  v77.location = 0;
                  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v67, v77, v51);
                  if (FirstIndexOfValue != -1)
                  {
                    v62 = FirstIndexOfValue;
                    v63 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: processed peer at index %ld", "WiFiDeviceManagerGetInterfaceDataUsage", v62);
                    objc_autoreleasePoolPop(v63);
                    CFArrayRemoveValueAtIndex(v67, v62);
                  }
                }
              }
              v56 = v74;
              if (v74 < valuePtr)
                v75 += valuePtr;
            }
            else
            {
LABEL_65:
              v56 = 0;
              v75 += valuePtr;
              v31 = allocator;
            }
            valuePtr = v56;
            v57 = CFNumberCreate(v31, kCFNumberSInt64Type, &valuePtr);
            if (v57)
            {
              v58 = v57;
              CFDictionarySetValue(v43, CFSTR("DataUsageInterfacePeerLastBytes"), v57);
              CFRelease(v58);
            }
            v59 = CFNumberCreate(v31, kCFNumberSInt64Type, &v75);
            if (v59)
            {
              v60 = v59;
              CFDictionarySetValue(v43, CFSTR("DataUsageInterfacePeerTotalBytes"), v59);
              CFRelease(v60);
            }
            CFArraySetValueAtIndex(v37, v40, v43);
          }
          CFRelease(v43);
        }
      }
      ++v40;
    }
    while (v40 < CFArrayGetCount(v37));
  }
  v39 = v67;
  if (v67 && CFArrayGetCount(v67))
  {
    v78.length = CFArrayGetCount(v67);
    v78.location = 0;
    CFArrayAppendArray(v37, v67, v78);
  }
  CFDictionarySetValue(v34, CFSTR("DataUsageInterfacePeerList"), v37);
  Mutable = v71;
LABEL_86:
  if (v34)
    CFArrayAppendValue(theArray, v34);
  v64 = *(const void **)(v68 + 7032);
  if (v64)
  {
    CFRelease(v64);
    *(_QWORD *)(v68 + 7032) = 0;
  }
  *(_QWORD *)(v68 + 7032) = sub_10006A634(*(_QWORD *)(v68 + 64));
  if (v39)
    CFRelease(v39);
  if (v37)
    CFRelease(v37);
  if (v34)
    CFRelease(v34);
  CFRelease(theDict);
  if (Mutable)
LABEL_97:
    CFRelease(Mutable);
}

void sub_10011C840(uint64_t a1, unsigned int a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Debug CoreCapture %d", "WiFiDeviceManagerSetDebugCoreCapture", a2);
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 38) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetDebugCoreCapture");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10011C8F0(uint64_t a1, unsigned int a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CoreCapture On Assisted AJ Failure %d", "WiFiDeviceManagerSetCoreCaptureOnAssistedAJFailure", a2);
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 39) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerSetCoreCaptureOnAssistedAJFailure");
    objc_autoreleasePoolPop(v4);
  }
}

id sub_10011C9A0(uint64_t a1)
{
  void *v1;
  id v2;
  void *v3;
  id v4;
  id v5;
  void *i;
  void *v7;
  id v8;
  id v9;
  const __CFString *v10;
  const __CFString *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *j;
  unsigned int v18;
  void *v20;
  id obj;
  uint64_t v22;
  id v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];
  _BYTE v33[128];

  if (!a1)
    return 0;
  v1 = *(void **)(a1 + 6672);
  if (!v1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: availability engine is NULL", "WiFiDeviceManagerCopyNetworkRecommendations");
    goto LABEL_50;
  }
  v2 = objc_msgSend(v1, "availableNetworks");
  if (!v2 || (v3 = v2, !objc_msgSend(v2, "count")))
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no available networks", "WiFiDeviceManagerCopyNetworkRecommendations");
LABEL_50:
    objc_autoreleasePoolPop(v20);
    return 0;
  }
  v23 = objc_alloc_init((Class)NSMutableArray);
  if (!v23)
    return 0;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v28, v33, 16);
  if (v4)
  {
    v5 = v4;
    obj = v3;
    v22 = *(_QWORD *)v29;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v29 != v22)
          objc_enumerationMutation(obj);
        v7 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i);
        v8 = objc_alloc_init((Class)NSMutableDictionary);
        if (objc_msgSend(v7, "SSID"))
          objc_msgSend(v8, "setObject:forKey:", objc_msgSend(v7, "SSID"), CFSTR("ssid"));
        if (objc_msgSend(objc_msgSend(v7, "network"), "accessPoints"))
          objc_msgSend(v8, "setObject:forKey:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(objc_msgSend(objc_msgSend(v7, "network"), "accessPoints"), "count")), CFSTR("apCount"));
        if ((objc_opt_respondsToSelector(objc_msgSend(v7, "network"), "uniqueIdentifier") & 1) != 0)
          objc_msgSend(v8, "setObject:forKey:", objc_msgSend((id)objc_opt_self(objc_msgSend(v7, "network")), "uniqueIdentifier"), CFSTR("uniqueIdentifier"));
        v9 = objc_msgSend(objc_msgSend(v7, "network"), "source");
        v10 = CFSTR("unknown");
        if (v9 == (id)2)
          v10 = CFSTR("3bars");
        if (v9 == (id)1)
          v11 = CFSTR("wallet");
        else
          v11 = v10;
        objc_msgSend(v8, "setObject:forKey:", v11, CFSTR("source"));
        if (objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "BSSID"))
          objc_msgSend(v8, "setObject:forKey:", objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "BSSID"), CFSTR("scannedBSSID"));
        if (objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "essMembers"))
          objc_msgSend(v8, "setObject:forKey:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "essMembers"), "count")), CFSTR("essMemberCount"));
        if (objc_msgSend(objc_msgSend(v7, "network"), "popularityScore"))
          objc_msgSend(v8, "setObject:forKey:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(objc_msgSend(objc_msgSend(v7, "network"), "popularityScore"), "score")), CFSTR("popularityScore"));
        if (objc_msgSend(objc_msgSend(v7, "network"), "password"))
          objc_msgSend(v8, "setObject:forKey:", objc_msgSend(objc_msgSend(v7, "network"), "password"), CFSTR("password"));
        if (objc_msgSend(objc_msgSend(v7, "network"), "attributes"))
        {
          v12 = objc_alloc_init((Class)NSMutableString);
          v24 = 0u;
          v25 = 0u;
          v26 = 0u;
          v27 = 0u;
          v13 = objc_msgSend(objc_msgSend(v7, "network"), "attributes");
          v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
          if (v14)
          {
            v15 = v14;
            v16 = *(_QWORD *)v25;
            do
            {
              for (j = 0; j != v15; j = (char *)j + 1)
              {
                if (*(_QWORD *)v25 != v16)
                  objc_enumerationMutation(v13);
                v18 = objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)j), "intValue") - 1;
                if (v18 <= 5)
                  objc_msgSend(v12, "appendString:", off_100232108[v18]);
              }
              v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
            }
            while (v15);
          }
          if (objc_msgSend(v12, "length"))
            objc_msgSend(v8, "setObject:forKey:", objc_msgSend(v12, "stringByTrimmingCharactersInSet:", +[NSCharacterSet whitespaceCharacterSet](NSCharacterSet, "whitespaceCharacterSet")), CFSTR("attributes"));

        }
        objc_msgSend(v23, "addObject:", v8);

      }
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v28, v33, 16);
    }
    while (v5);
  }
  return v23;
}

uint64_t sub_10011CE48(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4696) = a2;
  *(_QWORD *)(result + 4704) = a3;
  return result;
}

uint64_t sub_10011CE54(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

void sub_10011CE5C(uint64_t a1)
{
  uint64_t v2;
  void *v3;

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null wifidevice manager", "WiFiDeviceManagerResetAvailabilityEngine");
    goto LABEL_10;
  }
  v2 = *(_QWORD *)(a1 + 6704);
  v3 = objc_autoreleasePoolPush();
  if (!v2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null user notification manager", "WiFiDeviceManagerResetAvailabilityEngine");
LABEL_10:
    objc_autoreleasePoolPop(v3);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: reseting user notification states", "WiFiDeviceManagerResetAvailabilityEngine");
  objc_autoreleasePoolPop(v3);
  objc_msgSend(*(id *)(a1 + 6704), "reset");
}

__CFDictionary *sub_10011CF3C(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  _WORD *v5;
  const void *v6;
  CFIndex v7;
  const void *ValueAtIndex;
  CFIndex v9;
  const void *v10;
  _WORD *v11;
  const void *v12;
  const __CFNumber *v13;
  void *v14;
  int v15;
  void *v16;
  uint64_t v17;
  void *v18;
  id v19;
  const void *v20;
  id v21;
  void *v22;
  id v23;
  void *v24;
  __CFDictionary *v25;
  void *v26;
  void *v28;
  uint64_t v29;
  int valuePtr;
  uint64_t v31;
  CFTypeRef cf;
  CFNumberRef number;
  void *value;

  v4 = objc_autoreleasePoolPush();
  number = 0;
  value = 0;
  v31 = 13;
  cf = 0;
  if (!a1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    goto LABEL_76;
  }
  if (!a2)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: request is NULL!", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    goto LABEL_76;
  }
  CFDictionaryGetValueIfPresent(a2, CFSTR("command"), (const void **)&value);
  if (!value)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s with no command", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    goto LABEL_76;
  }
  if (!sub_100075280(*(_QWORD *)(a1 + 64)))
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BssBlacklist not supported on this platform.. Bailing!", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    goto LABEL_76;
  }
  CFDictionaryGetValueIfPresent(a2, CFSTR("network"), &cf);
  if (!cf)
  {
    v11 = 0;
    goto LABEL_22;
  }
  v5 = sub_10002B314((uint64_t)kCFAllocatorDefault, cf);
  if (!v5)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s couldn't convert record to network", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    goto LABEL_76;
  }
  v6 = v5;
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) < 1)
  {
LABEL_11:
    ValueAtIndex = 0;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v7);
      if (CFEqual(v6, ValueAtIndex))
        break;
      if (++v7 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)))
        goto LABEL_11;
    }
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)) < 1)
  {
LABEL_16:
    if (!ValueAtIndex)
    {
LABEL_20:
      v11 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    v9 = 0;
    while (1)
    {
      v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v9);
      if (CFEqual(v6, v10))
        break;
      if (++v9 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3536)))
        goto LABEL_16;
    }
    ValueAtIndex = v10;
    if (!v10)
      goto LABEL_20;
  }
  v11 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
  v12 = sub_10002BE64((uint64_t)v6, CFSTR("BSSID"));
  sub_10002C478((uint64_t)v11, CFSTR("BSSID"), v12);
LABEL_21:
  CFRelease(v6);
LABEL_22:
  if (CFStringCompare((CFStringRef)value, CFSTR("kBssBlacklistSet"), 0) == kCFCompareEqualTo)
  {
    CFDictionaryGetValueIfPresent(a2, CFSTR("reason"), (const void **)&number);
    if (number)
      CFNumberGetValue(number, kCFNumberLongType, &v31);
    if (!v11)
    {
LABEL_74:
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't find network to set blacklist condition", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
LABEL_76:
      objc_autoreleasePoolPop(v28);
      v25 = sub_10011D61C(a1, &off_1002540A0);
      goto LABEL_63;
    }
    v17 = v31;
    v18 = objc_autoreleasePoolPush();
    if (v17 == 13)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't determine blacklist condition to set", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse", v29);
    }
    else
    {
      v19 = sub_100027D10((uint64_t)v11);
      objc_msgSend(*(id *)(a1 + 6648), "setDenyListedStateExpiryIntervalInSec:state:", 1, 60.0);
      if (v17 == 8)
      {
        v20 = sub_10002BE64((uint64_t)v11, CFSTR("BSSID"));
        v21 = sub_1000FCB38(a1, 8, 0, (uint64_t)v20, 2);
        objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v21, v19);
        objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v21, v19);
        objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v21, v19);
        v22 = *(void **)(a1 + 7368);
        if (v22)
          objc_msgSend(v22, "addFaultEvent:forInterface:", 9, sub_100025C3C(*(_QWORD *)(a1 + 64)));
        if (v21)

      }
      else
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - unrecognized WiFiDenyListAddReason", "__WiFiDeviceManagerSetBssBlacklistedNetworkCondition");
        objc_autoreleasePoolPop(v24);
      }
      if (v19)

      objc_autoreleasePoolPop(v18);
      if (v17 == 8)
        goto LABEL_55;
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - __WiFiDeviceManagerSetBssBlacklistedNetworkCondition %lu failed", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse", v31);
    }
    objc_autoreleasePoolPop(v18);
LABEL_55:
    v25 = sub_10011D61C(a1, &off_1002540A0);
LABEL_62:
    CFRelease(v11);
    goto LABEL_63;
  }
  v13 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("timeout"));
  if (v13 && (valuePtr = 0, CFNumberGetValue(v13, kCFNumberIntType, &valuePtr)))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Configuring BssBlacklist Expiry interval to %d", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse", valuePtr);
    objc_autoreleasePoolPop(v14);
    objc_msgSend(*(id *)(a1 + 6648), "setDenyListedStateExpiryIntervalInSec:state:", 2, (double)valuePtr);
    v15 = 1;
  }
  else
  {
    v15 = 0;
  }
  if (CFStringCompare((CFStringRef)value, CFSTR("kBssBlacklistClear"), 0) == kCFCompareEqualTo)
  {
    if (v11)
    {
      v23 = sub_100027D10((uint64_t)v11);
      objc_msgSend(*(id *)(a1 + 6648), "removeNetworkDenyListInfoWithReason:forScanResult:", 1, v23);

      goto LABEL_57;
    }
    goto LABEL_74;
  }
  if (CFStringCompare((CFStringRef)value, CFSTR("kBssBlacklistRemove"), 0))
  {
    if (CFStringCompare((CFStringRef)value, CFSTR("kBssBlacklistExpire"), 0) == kCFCompareEqualTo)
    {
      objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 2);
      if (!objc_msgSend(*(id *)(a1 + 6648), "denyListedNetworkCount"))
      {
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't perform BSS unblacklist", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
LABEL_81:
        objc_autoreleasePoolPop(v16);
        goto LABEL_61;
      }
    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 6648), "removeDenyListStateWithDenyListRemoveReason:", 5);
    if (!objc_msgSend(*(id *)(a1 + 6648), "denyListedNetworkCount"))
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Couldn't perform time triggered BSS unblacklist", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
      goto LABEL_81;
    }
  }
LABEL_57:
  if (v15)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Resetting BssBlacklist Expiry interval", "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse");
    objc_autoreleasePoolPop(v26);
    objc_msgSend(*(id *)(a1 + 6648), "setDenyListedStateExpiryIntervalInSec:state:", 2, 300.0);
  }
LABEL_61:
  v25 = sub_10011D61C(a1, &off_1002540A0);
  if (v11)
    goto LABEL_62;
LABEL_63:
  objc_autoreleasePoolPop(v4);
  return v25;
}

__CFDictionary *sub_10011D61C(uint64_t a1, void *a2)
{
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v4;
  CFMutableArrayRef v5;
  CFMutableArrayRef v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  void *v12;
  void *v13;
  unint64_t v14;
  id v15;
  void *v16;
  const void *v17;
  id v18;
  id v19;
  id v20;
  void *v21;
  __CFArray *v22;
  unint64_t v23;
  id v24;
  CFNumberRef v25;
  _WORD *v26;
  __CFArray *v27;
  unint64_t v28;
  id v29;
  uint64_t v30;
  CFNumberRef v31;
  __CFArray *v32;
  unint64_t v33;
  id v34;
  CFNumberRef v35;
  CFIndex Count;
  CFIndex v37;
  CFIndex v38;
  __CFDictionary *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v44;
  uint64_t v45;
  id v46;
  id obj;
  uint64_t v48;
  __CFArray *v49;
  __CFArray *v50;
  __CFArray *v51;
  __CFArray *theArray;
  void *v53;
  id v54;
  uint64_t valuePtr;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _BYTE v61[128];

  v44 = objc_autoreleasePoolPush();
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  obj = a2;
  v7 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v57, v61, 16);
  if (!v7)
  {
LABEL_51:
    v39 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(v39, CFSTR("networks"), Mutable);
    CFDictionarySetValue(v39, CFSTR("reasons"), v4);
    CFDictionarySetValue(v39, CFSTR("timestamps"), v6);
    CFDictionarySetValue(v39, CFSTR("reasonData"), v5);
LABEL_61:
    v41 = v44;
    if (v6)
      goto LABEL_62;
    goto LABEL_63;
  }
  v8 = v7;
  v9 = *(_QWORD *)v58;
  v51 = v5;
  theArray = v4;
  v49 = Mutable;
  v50 = v6;
  v45 = *(_QWORD *)v58;
LABEL_3:
  v10 = 0;
  v46 = v8;
  while (1)
  {
    if (*(_QWORD *)v58 != v9)
      objc_enumerationMutation(obj);
    v54 = objc_msgSend(*(id *)(*((_QWORD *)&v57 + 1) + 8 * v10), "integerValue");
    v11 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedState:");
    if (!v11)
      goto LABEL_49;
    v12 = v11;
    if (!objc_msgSend(v11, "count"))
      goto LABEL_49;
    v48 = v10;
    if (objc_msgSend(v12, "count"))
    {
      v13 = v12;
      v14 = 0;
      v53 = v12;
      do
      {
        v15 = objc_msgSend(v13, "objectAtIndex:", v14);
        v16 = sub_1000CE200(v15);
        if (v16)
        {
          v17 = v16;
          v18 = +[NSMutableArray array](NSMutableArray, "array");
          v19 = +[NSMutableArray array](NSMutableArray, "array");
          v20 = objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", v15, v54, v18, v19);
          if (v20)
          {
            v21 = v20;
            if (objc_msgSend(v20, "count"))
            {
              v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
              if (objc_msgSend(v21, "count"))
              {
                v23 = 0;
                do
                {
                  v24 = objc_msgSend(v21, "objectAtIndex:", v23);
                  LODWORD(valuePtr) = -1431655766;
                  LODWORD(valuePtr) = objc_msgSend(v24, "unsignedIntegerValue");
                  v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                  CFArrayAppendValue(v22, v25);
                  if (v25)
                    CFRelease(v25);
                  ++v23;
                }
                while (v23 < (unint64_t)objc_msgSend(v21, "count"));
              }
              CFArrayAppendValue(theArray, v22);
              if (v22)
                CFRelease(v22);
              v26 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v17);
              Mutable = v49;
              CFArrayAppendValue(v49, v26);
              v13 = v53;
              if (v26)
                CFRelease(v26);
            }
          }
          if (v18 && objc_msgSend(v18, "count"))
          {
            v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (objc_msgSend(v18, "count"))
            {
              v28 = 0;
              do
              {
                v29 = objc_msgSend(v18, "objectAtIndex:", v28);
                valuePtr = -1;
                objc_msgSend(v29, "doubleValue");
                valuePtr = v30;
                v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
                CFArrayAppendValue(v27, v31);
                if (v31)
                  CFRelease(v31);
                ++v28;
              }
              while (v28 < (unint64_t)objc_msgSend(v18, "count"));
            }
            CFArrayAppendValue(v50, v27);
            v13 = v53;
            if (v27)
              CFRelease(v27);
          }
          if (v19 && objc_msgSend(v19, "count"))
          {
            v32 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (objc_msgSend(v19, "count"))
            {
              v33 = 0;
              do
              {
                v34 = objc_msgSend(v19, "objectAtIndex:", v33);
                LODWORD(valuePtr) = -1431655766;
                LODWORD(valuePtr) = objc_msgSend(v34, "unsignedIntegerValue");
                v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                CFArrayAppendValue(v32, v35);
                if (v35)
                  CFRelease(v35);
                ++v33;
              }
              while (v33 < (unint64_t)objc_msgSend(v19, "count"));
            }
            CFArrayAppendValue(v51, v32);
            if (v32)
              CFRelease(v32);
          }
          CFRelease(v17);
        }
        ++v14;
      }
      while (v14 < (unint64_t)objc_msgSend(v13, "count"));
    }
    if (!CFArrayGetCount(Mutable))
    {
      v39 = 0;
      v41 = v44;
      v5 = v51;
      v4 = theArray;
      v6 = v50;
      if (!v50)
        goto LABEL_63;
LABEL_62:
      CFRelease(v6);
      goto LABEL_63;
    }
    v4 = theArray;
    v6 = v50;
    v5 = v51;
    if (!CFArrayGetCount(theArray))
      break;
    Count = CFArrayGetCount(theArray);
    if (Count != CFArrayGetCount(Mutable))
      break;
    if (!CFArrayGetCount(v50) || (v37 = CFArrayGetCount(theArray), v37 != CFArrayGetCount(v50)))
    {
      v42 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Mismatched reason and timestamp array counts ", "__WiFiDeviceManagerCopyDenyListedNetworksAndReasons");
      goto LABEL_60;
    }
    v9 = v45;
    v8 = v46;
    v10 = v48;
    if (!CFArrayGetCount(v51) || (v38 = CFArrayGetCount(theArray), v38 != CFArrayGetCount(v51)))
    {
      v42 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Mismatched reason and reasonData array counts ", "__WiFiDeviceManagerCopyDenyListedNetworksAndReasons");
LABEL_60:
      objc_autoreleasePoolPop(v42);
      v39 = 0;
      goto LABEL_61;
    }
LABEL_49:
    if ((id)++v10 == v8)
    {
      v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v61, 16);
      if (v8)
        goto LABEL_3;
      goto LABEL_51;
    }
  }
  v40 = objc_autoreleasePoolPush();
  v41 = v44;
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Mismatched reason and network array counts ", "__WiFiDeviceManagerCopyDenyListedNetworksAndReasons");
  objc_autoreleasePoolPop(v40);
  v39 = 0;
  if (v50)
    goto LABEL_62;
LABEL_63:
  if (v5)
    CFRelease(v5);
  if (Mutable)
    CFRelease(Mutable);
  if (v4)
    CFRelease(v4);
  objc_autoreleasePoolPop(v41);
  return v39;
}

id sub_10011DC88(uint64_t a1, uint64_t a2)
{
  const char *v3;

  v3 = (const char *)objc_msgSend((id)sub_10002BE64(a2, CFSTR("BSSID")), "UTF8String");
  return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "addObject:", +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", ether_aton(v3), 6));
}

uint64_t sub_10011DCE4(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  const void *v4;

  v3 = *(_QWORD *)(a1 + 64);
  v4 = (const void *)sub_100025C3C(v3);
  return sub_1000715E0(v3, v4, a2);
}

void sub_10011DD18(uint64_t a1, const __CFDictionary *a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  const __CFNumber *v6;
  const __CFNumber *v7;
  CFMutableArrayRef v8;
  __CFArray *v9;
  const void *v10;
  const void *v11;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  const void *v16;
  const void *ValueAtIndex;
  const void *v18;
  CFTypeID v19;
  CFTypeID TypeID;
  CFTypeID v21;
  const void *v22;
  const void *v23;
  const void *v24;
  __CFDictionary *v25;
  __CFDictionary *v26;
  __CFDictionary *v27;
  const __CFString *v28;
  void *v29;
  uint64_t v30;
  const void *v31;
  const __CFNumber *value;
  __CFDictionary *theDict;
  void *key;
  int valuePtr;

  valuePtr = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v5 = Mutable;
    v6 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("ADAPTIVE_ROAM_RSSI_TRIGGER"));
    if (v6
      && (v7 = v6,
          CFNumberGetValue(v6, kCFNumberIntType, &valuePtr),
          *(_DWORD *)(a1 + 7384) = valuePtr,
          (v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) != 0))
    {
      v9 = v8;
      v10 = *(const void **)(a1 + 7392);
      if (v10)
      {
        CFRelease(v10);
        *(_QWORD *)(a1 + 7392) = 0;
      }
      v11 = CFDictionaryGetValue(a2, CFSTR("ADAPTIVE_ROAM_CHANNELS_INFO"));
      *(_QWORD *)(a1 + 7392) = v11;
      if (v11)
      {
        value = v7;
        theDict = v5;
        CFRetain(v11);
        v12 = *(const __CFArray **)(a1 + 7392);
        if (v12)
        {
          Count = CFArrayGetCount(v12);
          if (Count >= 1)
          {
            v14 = Count;
            v15 = 0;
            key = (void *)kWAMessageKeyChannel;
            v16 = (const void *)kWAMessageKeyChannelFlags;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7392), v15);
              if (ValueAtIndex)
              {
                v18 = ValueAtIndex;
                v19 = CFGetTypeID(ValueAtIndex);
                TypeID = CFDictionaryGetTypeID();
                v21 = CFGetTypeID(v18);
                if (v21 == CFNumberGetTypeID())
                  v22 = v18;
                else
                  v22 = 0;
                if (v19 == TypeID)
                {
                  v23 = CFDictionaryGetValue((CFDictionaryRef)v18, key);
                  v24 = CFDictionaryGetValue((CFDictionaryRef)v18, v16);
                  if (!v23)
                    goto LABEL_23;
                  v22 = v24;
                  if (!v24)
                    goto LABEL_23;
                  v25 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (!v25)
                    goto LABEL_23;
                  v26 = v25;
                  CFDictionarySetValue(v25, CFSTR("IO80211Channel"), v23);
                  v27 = v26;
                  v28 = CFSTR("IO80211ChannelFlags");
                }
                else
                {
                  if (!v22)
                    goto LABEL_23;
                  v27 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (!v27)
                    goto LABEL_23;
                  v26 = v27;
                  v28 = CFSTR("IO80211Channel");
                }
                CFDictionarySetValue(v27, v28, v22);
                CFArrayAppendValue(v9, v26);
                CFRelease(v26);
              }
LABEL_23:
              ++v15;
            }
            while (v14 != v15);
          }
        }
        v5 = theDict;
        CFDictionarySetValue(theDict, CFSTR("IO80211InterfaceAdaptiveRoamChanList"), v9);
        CFDictionarySetValue(theDict, CFSTR("IO80211InterfaceAdaptiveRoamRSSITrigger"), value);
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Adaptive Roam Params %@", theDict);
        objc_autoreleasePoolPop(v29);
        v30 = *(_QWORD *)(a1 + 64);
        v31 = (const void *)sub_100025C3C(v30);
        sub_1000672C0(v30, v31, 532, 0, (uint64_t)theDict);
        if (*(_QWORD *)(a1 + 7368))
          objc_msgSend(*(id *)(a1 + 7368), "setRoamingConfiguration:withChannelList:forInterface:", *(int *)(a1 + 7384), +[NSMutableSet setWithArray:](NSMutableSet, "setWithArray:", v9), sub_100025C3C(*(_QWORD *)(a1 + 64)));
      }
      CFRelease(v5);
    }
    else
    {
      v9 = v5;
    }
    CFRelease(v9);
  }
}

void sub_10011E028(uint64_t a1)
{
  NSMutableString *v2;
  id v3;
  void *v4;
  const char *v5;
  void *i;
  void *v7;
  id v8;
  const char *v9;
  uint64_t v10;
  NSString *v11;
  const char *v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *j;
  NSString *v18;
  const char *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  int v23;
  unsigned __int8 *v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  id v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint8_t v45[128];
  uint8_t buf[4];
  const char *v47;
  _BYTE v48[128];

  v2 = objc_opt_new(NSMutableString);
  v35 = a1;
  if (a1)
  {
    v3 = +[WiFiUsageAccessPointProfile beaconsAndWPSInfo](WiFiUsageAccessPointProfile, "beaconsAndWPSInfo");
    if (objc_msgSend(v3, "count"))
    {
      -[NSMutableString appendFormat:](v2, "appendFormat:", CFSTR("ApProfile and WPS info for the latest %lu BSSID this device associaed with in the past 7 days:"), objc_msgSend(v3, "count"));
      v4 = objc_autoreleasePoolPush();
      v5 = "WiFiDeviceManagerDumpToLog";
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - HexDump of beacons from the latest %lu BSSID this device associated with in the past 7 days (timestamped when received by wifid):", "WiFiDeviceManagerDumpToLog", objc_msgSend(v3, "count"));
      objc_autoreleasePoolPop(v4);
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v36 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
      if (v36)
      {
        v33 = *(_QWORD *)v42;
        v34 = v3;
        do
        {
          for (i = 0; i != v36; i = (char *)i + 1)
          {
            if (*(_QWORD *)v42 != v33)
              objc_enumerationMutation(v3);
            v7 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)i);
            v8 = objc_msgSend(v3, "objectForKeyedSubscript:", v7);
            objc_msgSend(v7, "timeIntervalSince1970");
            v9 = v5;
            v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s - %f: %@"), v5, v10, +[WiFiUsagePrivacyFilter toHEXString:length:](WiFiUsagePrivacyFilter, "toHEXString:length:", objc_msgSend(objc_msgSend(v8, "beacon"), "bytes"), objc_msgSend(objc_msgSend(v8, "beacon"), "length")));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              v12 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v11, "UTF8String")), "UTF8String");
              *(_DWORD *)buf = 136446210;
              v47 = v12;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
            -[NSMutableString appendFormat:](v2, "appendFormat:", CFSTR("\n%@ '%@' %@ (%@) - "), objc_msgSend(v8, "bssid"), objc_msgSend(v8, "ssid"), objc_msgSend(v8, "apProfile_shortID"), objc_msgSend(v8, "apProfileID"));
            v39 = 0u;
            v40 = 0u;
            v37 = 0u;
            v38 = 0u;
            v13 = objc_msgSend(objc_msgSend(v8, "apProfileWPSInfo"), "allKeys");
            v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v37, v45, 16);
            if (v14)
            {
              v15 = v14;
              v16 = *(_QWORD *)v38;
              do
              {
                for (j = 0; j != v15; j = (char *)j + 1)
                {
                  if (*(_QWORD *)v38 != v16)
                    objc_enumerationMutation(v13);
                  -[NSMutableString appendFormat:](v2, "appendFormat:", CFSTR("%@=%@ "), *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)j), objc_msgSend(objc_msgSend(v8, "apProfileWPSInfo"), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)j)));
                }
                v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v37, v45, 16);
              }
              while (v15);
            }
            v5 = v9;
            v3 = v34;
          }
          v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
        }
        while (v36);
      }
      v18 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s - %@"), v5, v2);
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v19 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v18, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v47 = v19;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    else
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s -  HexDump of beacon from the latest AP we associated with (beacon captures shotly after association)", "WiFiDeviceManagerDumpToLog");
      objc_autoreleasePoolPop(v20);
      if (*(_DWORD *)(v35 + 1208))
        goto LABEL_26;
      v22 = *(unsigned int *)(v35 + 1212);
      if ((_DWORD)v22)
      {
        v23 = 0;
        v24 = (unsigned __int8 *)(v35 + 1216);
        v25 = v35 + 1216 + v22;
        do
        {
          v26 = 0xA2E2E2E2E2E2ELL;
          if (v24 == (unsigned __int8 *)(v35 + 1216))
            v26 = 0xA2D2D2D2D2D2DLL;
          qword_10026D778 = v26;
          v27 = (char *)&qword_10026D778 + 7;
          while (1)
          {
            v28 = v23;
            if ((v23 & 0xF) == 0)
            {
              v29 = snprintf(v27, (char *)&dword_10026DB78 - v27, "%04X ", v23);
              if (&v27[v29] <= (char *)&dword_10026DB78)
                v27 += v29;
              else
                v27 = (char *)&dword_10026DB78;
            }
            v30 = snprintf(v27, (char *)&dword_10026DB78 - v27, "%02X ", *v24);
            if (&v27[v30] <= (char *)&dword_10026DB78)
              v27 += v30;
            else
              v27 = (char *)&dword_10026DB78;
            if ((++v23 & 0xF) == 0 && v27 < (char *)&unk_10026DB77)
            {
              *v27++ = 10;
              if (&qword_10026D778 - v27 + 1024 <= 0x82)
                break;
            }
            if ((unint64_t)++v24 >= v25)
              goto LABEL_48;
          }
          ++v24;
LABEL_48:
          v31 = (char *)((char *)&qword_10026D778 - v27 + 1024);
          if ((unint64_t)v24 >= v25)
            snprintf(v27, (size_t)v31, "\n------");
          else
            snprintf(v27, (size_t)v31, "......");
          v32 = objc_autoreleasePoolPush();
          v23 = v28 + 1;
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s OtaSystemInfo bytes printed:%d of %d\n%s", "__RawBeaconHexDumpToDLOG", (v28 + 1), *(unsigned int *)(v35 + 1212), &qword_10026D778);
          objc_autoreleasePoolPop(v32);
        }
        while ((unint64_t)v24 < v25);
        if (*(_DWORD *)(v35 + 1208))
        {
LABEL_26:
          v21 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - beacon content from latest AP not available", "WiFiDeviceManagerDumpToLog");
          objc_autoreleasePoolPop(v21);
        }
      }
    }
  }

}

uint64_t sub_10011E664(uint64_t result, char a2)
{
  *(_BYTE *)(result + 8820) = a2;
  return result;
}

uint64_t sub_10011E670(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 6792) = a2;
  return result;
}

uint64_t sub_10011E678(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4776) = a2;
  *(_QWORD *)(result + 4784) = a3;
  return result;
}

void sub_10011E684(uint64_t a1, uint64_t a2)
{
  void *v4;
  const __CFString *v5;
  const __CFString *v6;
  _BOOL4 v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSInit %@: Enter device:%p deviceManager:%p manager:%p", "WifiDeviceManagerCatsInit", sub_10002570C(a1), *(_QWORD *)(a1 + 64), a1, a2);
  objc_autoreleasePoolPop(v4);
  if (a1 && a2)
  {
    *(_QWORD *)(a1 + 424) = a2;
    *(_BYTE *)(a1 + 435) = 0;
    *(_BYTE *)(a1 + 464) = 0;
    *(_WORD *)(a1 + 433) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    v5 = (const __CFString *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v6 = (const __CFString *)sub_100029860(*(_QWORD *)(a1 + 64));
    v7 = 0;
    if (v5 && v6)
      v7 = CFStringCompare(v5, v6, 0) == kCFCompareEqualTo;
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v10 = *(_QWORD *)(a1 + 64);
      if (v10)
        v10 = sub_100029860(v10);
      objc_msgSend(v9, "WFLog:message:", 3, "%s: CATS %@: Trace deviceManager:%p rc=%d\n", "WifiDeviceManagerCatsIsMainInterface", v10, a1, v7);
    }
    objc_autoreleasePoolPop(v8);
    *(_BYTE *)(a1 + 432) = v7;
    if (v7)
    {
      sub_100011778(a1, 0);
      if ((sub_10014098C(a1 + 424, 0, (uint64_t)sub_1000132CC) & 0x80000000) != 0)
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS Error registering P2P callback\n", "WifiDeviceManagerCatsRegisterClients");
        objc_autoreleasePoolPop(v11);
      }
      if ((sub_10014098C(a1 + 424, 1, (uint64_t)sub_10000ECC4) & 0x80000000) != 0)
      {
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS Error registering UCM callback\n", "WifiDeviceManagerCatsRegisterClients");
        objc_autoreleasePoolPop(v12);
      }
      if ((sub_10014098C(a1 + 424, 2, (uint64_t)sub_100011B3C) & 0x80000000) != 0)
      {
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS Error registering Scan Manager callback\n", "WifiDeviceManagerCatsRegisterClients");
        objc_autoreleasePoolPop(v13);
      }
      if (_os_feature_enabled_impl("WiFiManager", "CATS"))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS %@: Enable Trace deviceManager:%p\n", "WifiDeviceManagerEnableCats", sub_10002570C(a1), a1);
        objc_autoreleasePoolPop(v14);
        if (!*(_BYTE *)(a1 + 433) && *(_BYTE *)(a1 + 432))
        {
          *(_BYTE *)(a1 + 433) = 1;
          sub_100024EE4(a1, 7);
        }
      }
    }
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = *(_QWORD *)(a1 + 64);
      if (v17)
      {
        v18 = sub_100029860(v17);
        v19 = *(_QWORD *)(a1 + 64);
      }
      else
      {
        v19 = 0;
        v18 = 0;
      }
      objc_msgSend(v16, "WFLog:message:", 3, "%s: CATSInit %@: Exit: device:%p deviceManager:%p manager:%p m:%d en:%d\n", "WifiDeviceManagerCatsInit", v18, v19, a1, a2, *(unsigned __int8 *)(a1 + 432), _os_feature_enabled_impl("WiFiManager", "CATS"));
    }
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSInit Invalid deviceManager or manager handle", "WifiDeviceManagerCatsInit", v20, v21, v22, v23, v24, v25);
  }
  objc_autoreleasePoolPop(v15);
}

void sub_10011E9DC(uint64_t a1)
{
  void *v1;

  if (a1 && *(_BYTE *)(a1 + 432))
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s() CATS Trace: DeInit Enter\n", "WifiDeviceManagerCatsDeInit");
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSDeInit Invalid deviceManager info", "WifiDeviceManagerCatsDeInit");
  }
  objc_autoreleasePoolPop(v1);
}

void sub_10011EA74(_QWORD *a1, void *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[7];

  v6 = objc_autoreleasePoolPush();
  if (objc_msgSend(a2, "mode"))
  {
    v7 = sub_10001E1C8((uint64_t)"WiFiDeviceManagerStartAutoJoinWithParams");
    CFRetain(a1);
    v8 = (void *)a1[1103];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10011EB40;
    v9[3] = &unk_100231690;
    v9[5] = a3;
    v9[6] = a1;
    v9[4] = v7;
    objc_msgSend(v8, "performAutoJoinWithParameters:reply:", a2, v9);
  }
  else
  {
    sub_1000285E4((uint64_t)a1, (unint64_t)objc_msgSend(a2, "trigger"));
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10011EB40(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  v4 = objc_autoreleasePoolPush();
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
    (*(void (**)(uint64_t, uint64_t))(v5 + 16))(v5, a2);
  CFRelease(*(CFTypeRef *)(a1 + 48));

  objc_autoreleasePoolPop(v4);
}

void sub_10011EB98(const __CFDictionary *a1, const __CFDictionary *a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  if (a1 && a2)
  {
    if (sub_1000C50F4((uint64_t)a2)
      && sub_1000C5104((uint64_t)a2)
      && !CFDictionaryGetValue(a1, CFSTR("RSN_IE")))
    {
      sub_10002C478((uint64_t)a2, CFSTR("RSN_IE"), 0);
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WPA1 only network but WPA2 property is existing in network profile. Removing WPA2 property for association ", "WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork");
      objc_autoreleasePoolPop(v4);
    }
    if (sub_1000C3B8C((_BOOL8)a2)
      && sub_10002DAB4((uint64_t)a2)
      && !CFDictionaryGetValue(a1, CFSTR("RSN_IE"))
      && !CFDictionaryGetValue(a1, CFSTR("WPA_IE")))
    {
      sub_10002C478((uint64_t)a2, CFSTR("RSN_IE"), 0);
      sub_10002C478((uint64_t)a2, CFSTR("WPA_IE"), 0);
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Dynamic WEP but WPA property is existing in network profile. Removing WPA property for association ", "WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork");
      objc_autoreleasePoolPop(v5);
    }
    if (sub_1000C3B8C((_BOOL8)a2)
      && sub_1000C50F4((uint64_t)a2)
      && !CFDictionaryGetValue(a1, CFSTR("WPA_IE")))
    {
      sub_10002C478((uint64_t)a2, CFSTR("WPA_IE"), 0);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WEP only but WPA property is existing in network profile. Removing WPA property for association ", "WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork");
      objc_autoreleasePoolPop(v6);
    }
    if (sub_10002DAB4((uint64_t)a2)
      && CFDictionaryGetValue(a1, CFSTR("WPA_IE"))
      && !CFDictionaryGetValue(a1, CFSTR("RSN_IE")))
    {
      sub_10002C478((uint64_t)a2, CFSTR("RSN_IE"), 0);
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WPA1 only enterprise network but WPA2 property is existing in network profile. Removing WPA2 property for association ", "WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork");
      objc_autoreleasePoolPop(v7);
    }
    if (sub_1000C50F4((uint64_t)a2)
      && sub_1000C5104((uint64_t)a2)
      && sub_1000C433C(a2)
      && !CFDictionaryGetValue(a1, CFSTR("WPA_IE")))
    {
      sub_10002C478((uint64_t)a2, CFSTR("WPA_IE"), 0);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WPA3 transition network but WPA1 property is existing in network profile. Removing WPA1 property for association ", "WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork");
      objc_autoreleasePoolPop(v8);
    }
  }
}

id sub_10011EE88(uint64_t a1)
{
  return objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "metric"), "copy");
}

id sub_10011EEA0(uint64_t a1)
{
  return objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "statistics"), "copy");
}

id sub_10011EEB8(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 8824), "resetStatistics");
}

void sub_10011EEC0(uint64_t a1, int a2)
{
  sub_100078B44(*(_QWORD *)(a1 + 64), a2);
}

void sub_10011EEC8(uint64_t a1, int a2)
{
  sub_100078BD4(*(_QWORD *)(a1 + 64), a2);
}

void sub_10011EED0(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v5 = "allowing";
    if (!a2)
      v5 = "disallowing";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s %s power save", "WiFiDeviceManagerAllowPowerSaveMode", v5);
  }
  objc_autoreleasePoolPop(v4);
  sub_100077748(*(_QWORD *)(a1 + 64), a2);
}

void sub_10011EF5C(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;
  void *v6;
  uint64_t v7;
  void *v8;

  if (a1)
  {
    *(_BYTE *)(a1 + 3465) = a2;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "TRUE";
      if (!a2)
        v5 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isOutrankedByCellular=%s", "WiFiDeviceManagerSetSymptomsCellOutrankRecommendation", v5);
    }
    objc_autoreleasePoolPop(v4);
    v6 = *(void **)(a1 + 7368);
    v7 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    objc_msgSend(v6, "setCellularOutrankingState:forInterface:", a2 != 0, v7);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiDeviceManagerSetSymptomsCellOutrankRecommendation");
    objc_autoreleasePoolPop(v8);
  }
}

void sub_10011F054(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: networkQualityDict=%@", "WiFiDeviceManagerNotifyNetworkQualityResults", a2);
    objc_autoreleasePoolPop(v4);
    v5 = *(void **)(a1 + 7368);
    v6 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    objc_msgSend(v5, "notifyNetworkQualityResults:forInterface:", a2, v6);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiDeviceManagerNotifyNetworkQualityResults");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10011F114(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  const __CFNumber *Value;
  const void *v6;
  uint64_t v7;
  const void *v8;
  CFMutableStringRef Mutable;
  CFMutableStringRef v10;
  CFMutableDictionaryRef v11;
  __CFDictionary *v12;
  CFNumberRef v13;
  CFMutableDictionaryRef v14;
  __CFDictionary *v15;
  CFMutableArrayRef v16;
  __CFArray *v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  CFNumberRef v23;
  CFIndex v24;
  uint64_t v25;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v27;
  BOOL v28;
  void *v29;
  CFNumberRef v30;
  uint64_t v31;
  const void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t valuePtr;
  uint64_t v38;
  int v39;
  uint64_t v40;

  if (!a1)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager is NULL", "WiFiDeviceManagerProcessBSPCommand");
    objc_autoreleasePoolPop(v33);
    return;
  }
  v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s dict is NULL", "WiFiDeviceManagerProcessBSPCommand");
    objc_autoreleasePoolPop(v4);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d BSPCommand Dictionary %@", "WiFiDeviceManagerProcessBSPCommand", 45545, a2);
  objc_autoreleasePoolPop(v4);
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("BSP_CommandType"));
  if (!Value)
    return;
  CFNumberGetValue(Value, kCFNumberLongLongType, &valuePtr);
  if (valuePtr != 2)
  {
    if (valuePtr == 4)
    {
      v6 = CFDictionaryGetValue(a2, CFSTR("BSP_CommandParams"));
      v7 = *(_QWORD *)(a1 + 64);
      v8 = (const void *)sub_100025C3C(v7);
      sub_10002DC20(v7, v8, CFSTR("BSP_CommandParams"), (uint64_t)v6);
    }
    return;
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s cannot create countryCodeRef", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
    objc_autoreleasePoolPop(v34);
    return;
  }
  v10 = Mutable;
  if (sub_100032160(*(_QWORD *)(a1 + 64), (uint64_t)Mutable))
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s cannot get countryCode", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
    goto LABEL_63;
  }
  v11 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v11)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate dictRef", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
LABEL_63:
    objc_autoreleasePoolPop(v35);
    v32 = v10;
    goto LABEL_48;
  }
  v12 = v11;
  v40 = 3;
  v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v40);
  if (!v13)
  {
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate eventTypeRef", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
    goto LABEL_68;
  }
  CFDictionarySetValue(v12, CFSTR("BSP_EventType"), v13);
  v14 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v14)
  {
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate eventParamsRef", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
LABEL_68:
    v15 = 0;
    goto LABEL_71;
  }
  v15 = v14;
  v39 = 0;
  v38 = 1;
  v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v16)
  {
    v17 = v16;
    v18 = *(_QWORD *)(a1 + 64);
    v19 = (const void *)sub_100025C3C(v18);
    v20 = sub_100069D4C(v18, v19, v17);
    if ((_DWORD)v20)
    {
      v21 = v20;
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Device return error %d for supported channels", "__WiFiDeviceManagerSendBSPRegulatoryInfo", v21);
      goto LABEL_18;
    }
    if (CFArrayGetCount(v17) < 1)
    {
      v25 = 1;
LABEL_37:
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d countryCode=%@, regulatoryInfo = 0x%llx", "__WiFiDeviceManagerSendBSPRegulatoryInfo", 45524, v10, v25);
      objc_autoreleasePoolPop(v29);
      v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v38);
      if (v30)
      {
        v23 = v30;
        CFDictionarySetValue(v15, CFSTR("BSP_RegulatoryInfo"), v30);
        CFDictionarySetValue(v12, CFSTR("BSP_EventParams"), v15);
        v31 = sub_100029860(*(_QWORD *)(a1 + 64));
        sub_1000EDE10(v31, v31, a1, v12);
        goto LABEL_41;
      }
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate regulatoryInfoRef", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
LABEL_18:
      objc_autoreleasePoolPop(v22);
      v23 = 0;
LABEL_41:
      CFRelease(v17);
      goto LABEL_42;
    }
    v24 = 0;
    v25 = 1;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v24);
      if (ValueAtIndex)
      {
        v27 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
        if (v27)
        {
          if (CFNumberGetValue(v27, kCFNumberSInt32Type, &v39))
          {
            if ((v39 - 50) >= 0xFFFFFFF2)
            {
              v25 |= 2uLL;
            }
            else
            {
              v28 = (v39 - 166) >= 0xFFFFFFE8 || v39 == 138;
              if (!v28 || (v39 - 100) < 0x2D)
                goto LABEL_34;
              v25 |= 0x10uLL;
            }
            v38 = v25;
          }
        }
      }
LABEL_34:
      if (CFArrayGetCount(v17) <= ++v24)
        goto LABEL_37;
    }
  }
  v36 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cannot allocate suppChannelList", "__WiFiDeviceManagerSendBSPRegulatoryInfo");
LABEL_71:
  objc_autoreleasePoolPop(v36);
  v23 = 0;
LABEL_42:
  CFRelease(v10);
  CFRelease(v12);
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
  if (v23)
  {
    v32 = v23;
LABEL_48:
    CFRelease(v32);
  }
}

uint64_t sub_10011F6BC(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Sending link status %d", *(unsigned __int8 *)(a1 + 3449));
  objc_autoreleasePoolPop(v2);
  return *(unsigned __int8 *)(a1 + 3449);
}

id sub_10011F71C(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  const __CFString *v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  NSData *v10;
  void *v11;
  uint64_t v13;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc_init((Class)NSMutableDictionary);
  if (*(_QWORD *)(a1 + 8976))
  {
    v4 = objc_alloc_init((Class)NSMutableDictionary);
    if (objc_msgSend(*(id *)(a1 + 8976), "status"))
      v5 = CFSTR("Settled");
    else
      v5 = CFSTR("Unsettled");
    objc_msgSend(v4, "setObject:forKey:", v5, CFSTR("description"));
    objc_msgSend(v4, "setObject:forKey:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(a1 + 8976), "status")), CFSTR("status"));
    objc_msgSend(v4, "setObject:forKey:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 8976), "confidence")), CFSTR("confidence"));
    if (objc_msgSend(*(id *)(a1 + 8976), "settledDate"))
      objc_msgSend(v4, "setObject:forKey:", objc_msgSend(*(id *)(a1 + 8976), "settledDate"), CFSTR("date"));
    objc_msgSend(v3, "setObject:forKey:", v4, CFSTR("settlement"));

  }
  v6 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v6, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 3352)), CFSTR("state"));
  objc_msgSend(v6, "setObject:forKey:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *(double *)(a1 + 3360)), CFSTR("startTime"));
  objc_msgSend(v6, "setObject:forKey:", sub_100024674(*(_DWORD *)(a1 + 3352)), CFSTR("description"));
  objc_msgSend(v6, "setObject:forKey:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", -[WiFiUserInteractionMonitor isCarModeActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCarModeActive")), CFSTR("carMode"));
  objc_msgSend(v3, "setObject:forKey:", v6, CFSTR("motion"));

  v7 = sub_100009ACC(a1);
  if (v7)
  {
    v8 = v7;
    v9 = objc_alloc_init((Class)NSMutableDictionary);
    v13 = 0;
    v10 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:](NSKeyedArchiver, "archivedDataWithRootObject:requiringSecureCoding:error:", v8, 1, &v13);
    if (v13)
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to encode location", "WiFiDeviceManagerCopyMovementStates");
      objc_autoreleasePoolPop(v11);
    }
    else
    {
      objc_msgSend(v9, "setObject:forKey:", v10, CFSTR("location"));
    }
    objc_msgSend(v3, "setObject:forKey:", v9, CFSTR("location"));

  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_10011F9C4(uint64_t a1)
{
  unsigned __int8 *v2;
  void *v3;
  void *v4;
  void *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  _BOOL4 v9;

  v2 = (unsigned __int8 *)(a1 + 5496);
  if ((sub_100018E70(a1) & 1) == 0
    && *v2 != 1
    && v2[1] != 1
    && v2[2] != 1
    && v2[3] != 1
    && (*(_DWORD *)(a1 + 176) - 1) >= 2
    && (!sub_100018FE4(a1) || !sub_10010A010(a1))
    && *(_BYTE *)(a1 + 3414) != 1
    && !sub_100018E14(a1)
    && !sub_100018D34(a1))
  {
    return 1;
  }
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Rejecting sensing: isSensing:%d carplay:%d faceTime:%d airplayOverInfra:%d coPresence:%d isCharging:%d userMode:%d\n", sub_100018E70(a1), *v2, v2[1], v2[2], v2[3], *(unsigned __int8 *)(a1 + 3464), *(unsigned int *)(a1 + 176));
  objc_autoreleasePoolPop(v3);
  v4 = objc_autoreleasePoolPush();
  v5 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v6 = sub_100018FE4(a1);
    v7 = sub_10010A010(a1);
    v8 = *(unsigned __int8 *)(a1 + 3414);
    v9 = sub_100018E14(a1);
    objc_msgSend(v5, "WFLog:message:", 3, "Rejecting sensing: AWDLEnabled:%d AssistedDiscHostedNetwork:%d RealTimeMode:%d MISScanBlocked:%d AutoJoinBusy:%d\n", v6, v7, v8, v9, sub_100018D34(a1));
  }
  objc_autoreleasePoolPop(v4);
  return 0;
}

uint64_t sub_10011FB78(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t result;

  result = 4294963396;
  if (a1 && a2 && a3)
  {
    if (sub_100078DE8(*(_QWORD *)(a1 + 64)))
      return sub_100078DF4(*(_QWORD *)(a1 + 64), a2, a3);
    else
      return 4294963389;
  }
  return result;
}

uint64_t sub_10011FBE0(uint64_t a1, const void *a2, void *a3, void (*a4)(uint64_t, const void *, _QWORD, uint64_t, uint64_t), uint64_t a5)
{
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;
  int v15;
  id v16;
  id v17;
  id v18;
  signed int v19;
  signed int v20;
  void *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  dispatch_time_t v25;
  NSObject *v26;
  NSObject *v27;
  NSDate *v28;
  double v29;
  double v30;
  double v31;
  double v32;
  unsigned int v33;
  double v34;
  double v35;
  uint64_t v36;
  NSObject *v37;
  dispatch_time_t v38;
  void *v39;
  void *v40;
  uint64_t v42;
  id v43;
  const char *v44;
  void *v45;
  void *context;
  _QWORD v48[9];
  _QWORD handler[9];
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  unint64_t v57;

  v54 = 0;
  v55 = &v54;
  v56 = 0x2020000000;
  v57 = 0xAAAAAAAAAAAAAAAALL;
  v50 = 0;
  v51 = &v50;
  v52 = 0x2020000000;
  v53 = 0xAAAAAAAAAAAAAAAALL;
  if ((MGGetBoolAnswer(CFSTR("InternalBuild")) & 1) == 0
    || !_os_feature_enabled_impl("WiFiManager", "Sensing")
    || !sub_100078F38(*(_QWORD *)(a1 + 64)))
  {
    v9 = 0;
    v10 = 4294963389;
    goto LABEL_37;
  }
  v9 = 0;
  v10 = 4294963396;
  if (a2 && a3)
  {
    v11 = sub_10007930C(*(_QWORD *)(a1 + 64));
    v12 = sub_100079318(*(_QWORD *)(a1 + 64));
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName: %@ numReportsRem: %d, expectedTotalReports: %d, sensingParams: %@", "WiFiDeviceManagerSensingEnableAsync", a2, v11, v12, a3);
    objc_autoreleasePoolPop(v13);
    if (v11 | v12)
    {
      v9 = 0;
      v10 = 37;
      goto LABEL_37;
    }
    v14 = objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_SCHEDULE_ONCE_AFTER"));
    v15 = objc_msgSend(v14, "intValue");
    v16 = objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_SCHEDULE_DAILY_AT"));
    v17 = objc_msgSend(v16, "intValue");
    v18 = objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_NUMBER_OF_REPORTS"));
    v19 = objc_msgSend(v18, "intValue");
    v55[3] = v19;
    v20 = objc_msgSend(v18, "intValue");
    v9 = 0;
    v51[3] = v20;
    if (v14)
    {
      v10 = 0;
      if (v15 == -2)
        goto LABEL_22;
      if (!v55[3])
        goto LABEL_21;
      v21 = malloc_type_malloc(0x20uLL, 0xE00402064D7F7uLL);
      *(_QWORD *)v21 = a1;
      *((_QWORD *)v21 + 1) = a4;
      *((_QWORD *)v21 + 2) = CFRetain(a3);
      *((_QWORD *)v21 + 3) = a5;
      v22 = *(NSObject **)(a1 + 8984);
      if (v22)
      {
        dispatch_source_cancel(v22);
        dispatch_release(*(dispatch_object_t *)(a1 + 8984));
        *(_QWORD *)(a1 + 8984) = 0;
      }
      if (v15 >= 1)
      {
        *(_QWORD *)(a1 + 8984) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(a1 + 240));
        CFRetain(a2);
        CFRetain(a3);
        v23 = *(NSObject **)(a1 + 8984);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_1001202E8;
        handler[3] = &unk_1002316B8;
        handler[4] = &v54;
        handler[5] = a1;
        handler[6] = a2;
        handler[7] = a3;
        handler[8] = v21;
        dispatch_source_set_event_handler(v23, handler);
        v24 = *(NSObject **)(a1 + 8984);
        v25 = dispatch_time(0, 1000000000 * v15);
        dispatch_source_set_timer(v24, v25, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_activate(*(dispatch_object_t *)(a1 + 8984));
        v10 = 0;
        goto LABEL_16;
      }
      if (v15)
      {
LABEL_21:
        v9 = 0;
        v10 = 0;
LABEL_22:
        if (!v16)
          goto LABEL_37;
        goto LABEL_23;
      }
      sub_1000792F0(*(_QWORD *)(a1 + 64));
      v42 = v55[3];
      v55[3] = v42 - 1;
      sub_100079300(*(_QWORD *)(a1 + 64), v42 - 1);
      v43 = objc_alloc_init((Class)NSDateFormatter);
      objc_msgSend(v43, "setDateFormat:", CFSTR("yyyy/MM/dd hh:mm:ss:SSS"));
      objc_msgSend(v43, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
      if (sub_10011F9C4(a1))
      {
        v10 = sub_100078F44(*(_QWORD *)(a1 + 64), a2, a3, (uint64_t)sub_1001204B4, (uint64_t)v21);
        context = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v44 = "failed to start";
          if (!(_DWORD)v10)
            v44 = "started";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: One-time sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync", v44, v10, v55[3], objc_msgSend(v43, "stringFromDate:", +[NSDate date](NSDate, "date")));
        }
        objc_autoreleasePoolPop(context);
      }
      else
      {
        v45 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rejecting sensing due to on-going high priority event\n", "WiFiDeviceManagerSensingEnableAsync");
        objc_autoreleasePoolPop(v45);
        v10 = 16;
      }

      if (!(_DWORD)v10)
      {
LABEL_16:
        v9 = 1;
        if (!v16)
          goto LABEL_37;
        goto LABEL_23;
      }
      sub_100079300(*(_QWORD *)(a1 + 64), 0);
      CFRelease(*((CFTypeRef *)v21 + 2));
      free(v21);
      v9 = 0;
      if (!v16)
        goto LABEL_37;
    }
    else
    {
      v10 = 0;
      if (!v16)
        goto LABEL_37;
    }
LABEL_23:
    if ((_DWORD)v17 != -2 && v51[3])
    {
      v26 = *(NSObject **)(a1 + 8992);
      if (v26)
      {
        dispatch_source_cancel(v26);
        dispatch_release(*(dispatch_object_t *)(a1 + 8992));
        *(_QWORD *)(a1 + 8992) = 0;
      }
      if ((_DWORD)v17 != -1)
      {
        *(_QWORD *)(a1 + 8992) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(a1 + 240));
        CFRetain(a2);
        CFRetain(a3);
        v27 = *(NSObject **)(a1 + 8992);
        v48[0] = _NSConcreteStackBlock;
        v48[1] = 3221225472;
        v48[2] = sub_10012063C;
        v48[3] = &unk_1002316E0;
        v48[4] = a3;
        v48[5] = &v50;
        v48[6] = a1;
        v48[7] = a2;
        v48[8] = a3;
        dispatch_source_set_event_handler(v27, v48);
        v28 = -[NSCalendar startOfDayForDate:](+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"), "startOfDayForDate:", +[NSDate date](NSDate, "date"));
        -[NSDate timeIntervalSince1970](v28, "timeIntervalSince1970");
        v30 = v29;
        -[NSDate timeIntervalSince1970](+[NSDate date](NSDate, "date"), "timeIntervalSince1970");
        v32 = v31;
        v33 = objc_msgSend(objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_COMMENT")), "isEqualToString:", CFSTR("automatic collection scheduled"));
        v34 = v30 + 86400.0;
        if (v33)
          v35 = v34 - v32 + (double)(int)v17 + 86400.0;
        else
          v35 = v34 - v32 + (double)(int)v17;
        if (v33)
          v36 = 604800000000000;
        else
          v36 = 86400000000000;
        v37 = *(NSObject **)(a1 + 8992);
        v38 = dispatch_time(0, (uint64_t)(v35 * 1000000000.0));
        dispatch_source_set_timer(v37, v38, v36, 0);
        dispatch_activate(*(dispatch_object_t *)(a1 + 8992));
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: midnightOfToday %@, midnightOfTomorrow %f, now %f, scheduledStartInSecondsAfterMidnight %d, dispatchTimerStart %f, interval %llu", "WiFiDeviceManagerSensingEnableAsync", v28, *(_QWORD *)&v34, *(_QWORD *)&v32, v17, *(_QWORD *)&v35, v36);
        objc_autoreleasePoolPop(v39);
      }
    }
  }
LABEL_37:
  if (a4 && (v9 & 1) == 0)
  {
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Invoking WiFiClientSensingCallback", "WiFiDeviceManagerSensingEnableAsync");
    objc_autoreleasePoolPop(v40);
    a4(a1, a2, 0, v10, a5);
  }
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v54, 8);
  return v10;
}

void sub_1001202A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1001202E8(uint64_t a1)
{
  uint64_t v2;
  id v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  void *v7;

  sub_1000792F0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 64));
  v2 = *(_QWORD *)(a1 + 40);
  --*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  sub_100079300(*(_QWORD *)(v2 + 64), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v3 = objc_alloc_init((Class)NSDateFormatter);
  objc_msgSend(v3, "setDateFormat:", CFSTR("yyyy/MM/dd hh:mm:ss:SSS"));
  objc_msgSend(v3, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
  if (!sub_10011F9C4(*(_QWORD *)(a1 + 40)))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rejecting sensing due to on-going high priority event\n", "WiFiDeviceManagerSensingEnableAsync_block_invoke");
    objc_autoreleasePoolPop(v7);

    goto LABEL_12;
  }
  v4 = sub_100078F44(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 64), *(const void **)(a1 + 48), *(void **)(a1 + 56), (uint64_t)sub_1001204B4, *(_QWORD *)(a1 + 64));
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if ((_DWORD)v4)
      v6 = "failed to start";
    else
      v6 = "started";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: One-time delayed sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync_block_invoke", v6, v4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), objc_msgSend(v3, "stringFromDate:", +[NSDate date](NSDate, "date")));
  }
  objc_autoreleasePoolPop(v5);

  if ((_DWORD)v4)
  {
LABEL_12:
    sub_100079300(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 64), 0);
    CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 64) + 16));
    free(*(void **)(a1 + 64));
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

void sub_1001204B4(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  void *v8;
  int v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  void *v13;
  void *v14;

  v8 = (void *)a4[2];
  v9 = sub_10007930C(a1);
  if (sub_100079318(a1))
    return;
  if (!v9)
    goto LABEL_11;
  v10 = *a4;
  sub_100079300(a1, v9 - 1);
  v11 = objc_alloc_init((Class)NSDateFormatter);
  objc_msgSend(v11, "setDateFormat:", CFSTR("yyyy/MM/dd hh:mm:ss:SSS"));
  objc_msgSend(v11, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
  if (!sub_10011F9C4(v10))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rejecting sensing due to on-going high priority event\n", "__WiFiDeviceManagerClientSensingCallback");
    objc_autoreleasePoolPop(v14);

    goto LABEL_11;
  }
  v12 = sub_100078F44(a1, a2, v8, (uint64_t)sub_1001204B4, (uint64_t)a4);
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s sensing enable event retVal[%d]\n", "__WiFiDeviceManagerClientSensingCallback", v12);
  objc_autoreleasePoolPop(v13);

  if ((_DWORD)v12)
LABEL_11:
    sub_100145244(a1, a2, a3, v8, a4);
}

void sub_10012063C(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  uint64_t v6;
  void *v7;
  const char *v8;
  void *v9;

  v2 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_COMMENT")), "isEqualToString:", CFSTR("automatic collection scheduled"));
  v3 = *(_QWORD *)(a1 + 48);
  if (!v2 || *(_BYTE *)(v3 + 3464))
  {
    sub_1000792F0(*(_QWORD *)(v3 + 64));
    v4 = *(_QWORD *)(a1 + 48);
    --*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    sub_100079300(*(_QWORD *)(v4 + 64), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v5 = objc_alloc_init((Class)NSDateFormatter);
    objc_msgSend(v5, "setDateFormat:", CFSTR("yyyy/MM/dd hh:mm:ss:SSS"));
    objc_msgSend(v5, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
    if (sub_10011F9C4(*(_QWORD *)(a1 + 48)))
    {
      v6 = sub_100078F44(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 64), *(const void **)(a1 + 56), *(void **)(a1 + 64), (uint64_t)sub_100120838, *(_QWORD *)(a1 + 48));
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if ((_DWORD)v6)
          v8 = "failed to start";
        else
          v8 = "started";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Daily sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync_block_invoke_2", v8, v6, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), objc_msgSend(v5, "stringFromDate:", +[NSDate date](NSDate, "date")));
      }
      objc_autoreleasePoolPop(v7);

      if (!(_DWORD)v6)
        goto LABEL_15;
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rejecting sensing due to on-going high priority event\n", "WiFiDeviceManagerSensingEnableAsync_block_invoke_2");
      objc_autoreleasePoolPop(v9);

    }
    sub_100079300(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 64), 0);
LABEL_15:
    CFRelease(*(CFTypeRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 64));
  }
}

void sub_100120838(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  NSDictionary *v8;
  int v9;
  id v10;
  uint64_t v11;
  void *v12;
  void *v13;

  v8 = -[NSUserDefaults dictionaryForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "dictionaryForKey:", CFSTR("WIFI_SENSING"));
  v9 = sub_10007930C(a1);
  if (sub_100079318(a1))
    return;
  if (!v9)
    goto LABEL_11;
  sub_100079300(a1, v9 - 1);
  v10 = objc_alloc_init((Class)NSDateFormatter);
  objc_msgSend(v10, "setDateFormat:", CFSTR("yyyy/MM/dd hh:mm:ss:SSS"));
  objc_msgSend(v10, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
  if (!sub_10011F9C4(a4))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rejecting sensing due to on-going high priority event\n", "__WiFiDeviceManagerSensingDailyCallback");
    objc_autoreleasePoolPop(v13);

    goto LABEL_11;
  }
  v11 = sub_100078F44(a1, a2, v8, (uint64_t)sub_100120838, a4);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s sensing enable event retVal[%d]\n", "__WiFiDeviceManagerSensingDailyCallback", v11);
  objc_autoreleasePoolPop(v12);

  if ((_DWORD)v11)
LABEL_11:
    sub_100145244(a1, a2, a3, v8, 0);
}

uint64_t sub_1001209D8(uint64_t a1, const void *a2)
{
  NSObject *v4;
  NSObject *v5;

  if (!_os_feature_enabled_impl("WiFiManager", "Sensing")
    || !sub_100078F38(*(_QWORD *)(a1 + 64)))
  {
    return 4294963389;
  }
  v4 = *(NSObject **)(a1 + 8984);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 8984));
    *(_QWORD *)(a1 + 8984) = 0;
  }
  v5 = *(NSObject **)(a1 + 8992);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*(dispatch_object_t *)(a1 + 8992));
    *(_QWORD *)(a1 + 8992) = 0;
  }
  return sub_100079140(*(_QWORD *)(a1 + 64), a2);
}

void sub_100120A64(uint64_t a1, const void *a2)
{
  void *v4;
  const void *v5;
  const void *v6;
  void *v7;
  void *v8;
  const void *v9;
  void *v10;
  char *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  const void *v22;
  const void *v23;

  v4 = objc_autoreleasePoolPush();
  v5 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  v6 = sub_10002BF8C(*(_QWORD *)(a1 + 64), v5);
  v7 = objc_autoreleasePoolPush();
  v8 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v9 = sub_10002B088(a2);
    objc_msgSend(v8, "WFLog:message:", 3, "[NWTRANSIT]: %s: topNetwork: %@, current: %@", "__WiFiDeviceManagerTransitionToColocatedNetwork", v9, sub_10002B088(v6));
  }
  objc_autoreleasePoolPop(v7);
  if (v6)
  {
    if (sub_10002B088(v6))
    {
      if (CFEqual(v6, a2))
      {
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: no need for transition...", "__WiFiDeviceManagerTransitionToColocatedNetwork");
        objc_autoreleasePoolPop(v10);
      }
      else
      {
        v11 = (char *)malloc_type_malloc(0x38uLL, 0x10E00402A548A24uLL);
        *(_OWORD *)(v11 + 24) = 0u;
        *(_OWORD *)(v11 + 40) = 0u;
        *(_QWORD *)v11 = a1;
        *((_QWORD *)v11 + 1) = sub_10013E5A4;
        *((_QWORD *)v11 + 2) = 0;
        *((_DWORD *)v11 + 8) = 1013;
        sub_10010D248(a1, v6);
        *(_BYTE *)(a1 + 3760) = 1;
        if (!sub_100121218(a1, (uint64_t)v6) || *(_BYTE *)(a1 + 3744) != 1)
          goto LABEL_23;
        v12 = (void *)sub_10002BE64((uint64_t)v6, CFSTR("COLOCATED_NETWORK_SCOPE_ID"));
        v23 = sub_10002BE64((uint64_t)a2, CFSTR("COLOCATED_NETWORK_SCOPE_ID"));
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: SCOPE ID for %@ = %@ ", "__WiFiDeviceManagerMatchColocatedScopeID", sub_10002B088(v6), v12);
        objc_autoreleasePoolPop(v13);
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: SCOPE ID for %@ = %@ ", "__WiFiDeviceManagerMatchColocatedScopeID", sub_10002B088(a2), v23);
        objc_autoreleasePoolPop(v14);
        if (v12 && v23 && objc_msgSend(v12, "isEqualToString:", v23))
        {
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: SCOPE ID Matches, Debounce the Link");
          objc_autoreleasePoolPop(v15);
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT] %s: Link down will be debounced", "__WiFiDeviceManagerTransitionToColocatedNetwork");
          objc_autoreleasePoolPop(v16);
        }
        else
        {
LABEL_23:
          v17 = objc_autoreleasePoolPush();
          v18 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v19 = sub_10002B088(v6);
            objc_msgSend(v18, "WFLog:message:", 3, "[NWTRANSIT]: %s: Disconnect from '%@', attempting network transition to '%@'", "__WiFiDeviceManagerTransitionToColocatedNetwork", v19, sub_10002B088(v6));
          }
          objc_autoreleasePoolPop(v17);
          v20 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
          sub_1000F7F48(a1, v20, 1013, "__WiFiDeviceManagerTransitionToColocatedNetwork", 47128);
        }
        v21 = sub_1000721D8(*(_QWORD *)(a1 + 64), v5, a2, 0, (uint64_t)sub_100145CE8, (uint64_t)v11, 1013);
        if ((_DWORD)v21)
        {
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "associationDoneWithNetwork:error:interfaceName:", a2, v21, v5);
          *(_BYTE *)(a1 + 3760) = 0;
          v22 = (const void *)*((_QWORD *)v11 + 3);
          if (v22)
            CFRelease(v22);
          free(v11);
        }
      }
    }
    CFRelease(v6);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_100120E00(uint64_t a1, const __CFDictionary *a2)
{
  const void *v4;
  const __CFArray *Value;
  CFIndex Count;
  void *v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  _QWORD *v10;
  _BYTE *v11;
  BOOL v12;
  const void *v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  const void *v17;
  void *v18;
  void *v19;
  void *v20;
  const void *v21;
  const void *v22;
  const __CFNumber *v23;
  const void *v24;
  const void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  int v30;
  int valuePtr;

  v30 = 0;
  if (!a1 || !a2)
    goto LABEL_38;
  v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
  Value = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("COLOCATED_NETWORK_GROUP"));
  *(_QWORD *)(a1 + 3736) = Value;
  if (Value)
    Count = CFArrayGetCount(Value);
  else
    Count = 0;
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated Network Count = %ld ", "WiFiDeviceManagerSetColocatedNetworks", Count);
  objc_autoreleasePoolPop(v7);
  if (Count > 1)
    goto LABEL_17;
  valuePtr = 2;
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  v9 = sub_100116F8C(0, 0, *(_DWORD *)(a1 + 128), 0x6Eu, 11);
  CFDictionarySetValue(v9, CFSTR("SCAN_FLAGS"), v8);
  if (v9)
  {
    v10 = malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
    if (v10)
    {
      v11 = v10;
      *v10 = a1;
      v10[1] = 0;
      v10[3] = 0;
      if (CFDictionaryContainsKey(v9, CFSTR("SSID_STR")))
        v12 = 1;
      else
        v12 = CFDictionaryContainsKey(v9, CFSTR("SCAN_SSID_LIST")) != 0;
      v11[32] = v12;
      v13 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      v14 = sub_100018C78(a1, v13, v9, 0, (uint64_t)sub_10012D384, (uint64_t)v11, 0, 23);
      if ((_DWORD)v14)
      {
        v28 = v14;
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error initiating scan request: %d", v28);
        objc_autoreleasePoolPop(v29);
        free(v11);
      }
    }
    else
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "__WiFiDeviceManagerColocatedNetworkScan");
      objc_autoreleasePoolPop(v27);
    }
    CFRelease(v9);
    if (v8)
LABEL_16:
      CFRelease(v8);
  }
  else
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create scan request", "__WiFiDeviceManagerColocatedNetworkScan");
    objc_autoreleasePoolPop(v26);
    if (v8)
      goto LABEL_16;
  }
LABEL_17:
  v15 = sub_10002BF8C(*(_QWORD *)(a1 + 64), v4);
  if (v15)
  {
    v16 = v15;
    v17 = sub_10002BE64((uint64_t)v15, CFSTR("COLOCATED_NETWORK_SCOPE_ID"));
    if (!v17)
    {
      v17 = *(const void **)(a1 + 3752);
      sub_10002C478((uint64_t)v16, CFSTR("COLOCATED_NETWORK_SCOPE_ID"), v17);
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Retrieved ColocatedScopeId for %@ - '%@'", "WiFiDeviceManagerSetColocatedNetworks", sub_10002B088(v16), v17);
      objc_autoreleasePoolPop(v18);
    }
    if (sub_100121218(a1, (uint64_t)v16) && v17 && Count >= 2)
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated Group already present", "WiFiDeviceManagerSetColocatedNetworks");
      objc_autoreleasePoolPop(v19);
LABEL_35:
      v23 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("COLOCATED_NETWORK_GROUP_STATUS"));
      if (v23)
      {
        CFNumberGetValue(v23, kCFNumberIntType, &v30);
        *(_BYTE *)(a1 + 3744) = v30;
        if (CFDictionaryGetValue(a2, CFSTR("COLOCATED_NETWORK_GROUP_SCOPE_ID")))
        {
          sub_10010D248(a1, v16);
          return;
        }
      }
      goto LABEL_38;
    }
    v21 = *(const void **)(a1 + 3736);
    if (v21)
    {
      CFRelease(v21);
      *(_QWORD *)(a1 + 3736) = 0;
    }
    v22 = CFDictionaryGetValue(a2, CFSTR("COLOCATED_NETWORK_GROUP"));
    *(_QWORD *)(a1 + 3736) = v22;
    if (v22)
    {
      CFRetain(v22);
      goto LABEL_35;
    }
LABEL_38:
    v24 = *(const void **)(a1 + 3736);
    if (v24)
    {
      CFRelease(v24);
      *(_QWORD *)(a1 + 3736) = 0;
    }
    v25 = *(const void **)(a1 + 3752);
    if (v25)
    {
      CFRelease(v25);
      *(_QWORD *)(a1 + 3752) = 0;
    }
    *(_BYTE *)(a1 + 3744) = 0;
    return;
  }
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Not Associated, Bail out");
  objc_autoreleasePoolPop(v20);
}

const __CFArray *sub_100121218(uint64_t a1, uint64_t a2)
{
  const __CFArray *result;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;

  result = *(const __CFArray **)(a1 + 3736);
  if (result)
  {
    Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v7);
        if (ValueAtIndex)
        {
          if (sub_1000C6060(a2, (uint64_t)ValueAtIndex))
            break;
        }
        if (v6 == ++v7)
          return 0;
      }
      return (const __CFArray *)1;
    }
  }
  return result;
}

void sub_100121294(uint64_t a1, const __CFDictionary *a2)
{
  const void *v4;
  const void *v5;
  const __CFNumber *v6;
  const __CFNumber *Value;
  const __CFNumber *v8;
  const __CFNumber *v9;
  void *v10;
  const char *v11;
  const __CFArray *v12;
  CFIndex Count;
  void *v14;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  CFIndex j;
  const void *v21;
  const __CFNumber *v22;
  CFIndex v23;
  const void *v24;
  const __CFNumber *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t valuePtr;

  v28 = 0;
  valuePtr = 0;
  v27 = 0;
  if (sub_10007946C(*(_QWORD *)(a1 + 64)))
  {
    v4 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v5 = sub_10002BF8C(*(_QWORD *)(a1 + 64), v4);
    v6 = (const __CFNumber *)sub_10002BE64((uint64_t)v5, CFSTR("CHANNEL_FLAGS"));
    if (v6)
      CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
    Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("6E_NETWORK_TRANSITION"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, (char *)&v28 + 4);
      v8 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("LEGACY_NETWORK_TRANSITION"));
      if (v8)
      {
        CFNumberGetValue(v8, kCFNumberIntType, &v28);
        v9 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("CHANNEL"));
        if (v9)
          CFNumberGetValue(v9, kCFNumberIntType, (char *)&v27 + 4);
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if ((_DWORD)v28)
            v11 = "2.4Gh/5Gh";
          else
            v11 = "6Gh";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Initiate Colocated Network Transition. Transitioning to %s Colocated Network", v11);
        }
        objc_autoreleasePoolPop(v10);
        v12 = *(const __CFArray **)(a1 + 3736);
        if (v12)
          Count = CFArrayGetCount(v12);
        else
          Count = 0;
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Num Colocated Networks %ld", Count);
        objc_autoreleasePoolPop(v14);
        if ((_DWORD)v28)
        {
          if ((valuePtr & 0x2000) != 0 && Count >= 1)
          {
            for (i = 0; Count != i; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), i);
              if (ValueAtIndex)
              {
                v17 = ValueAtIndex;
                v18 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL_FLAGS"));
                v19 = (const __CFNumber *)sub_10002BE64((uint64_t)v17, CFSTR("CHANNEL"));
                CFNumberGetValue(v19, kCFNumberIntType, &v27);
                CFNumberGetValue(v18, kCFNumberIntType, (char *)&valuePtr + 4);
                if (!HIDWORD(v27) && (valuePtr & 0x1000000000) != 0)
                {
                  v26 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Associated to 6Gh. No Target channel. Top Colocated Network for Transition = %@", v17);
                  goto LABEL_54;
                }
                if (HIDWORD(v27) == (_DWORD)v27)
                {
                  v26 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Associated to 6Gh. Colocated network available in Peer Channel. Network = %@", v17);
                  goto LABEL_54;
                }
                if (v18 && (valuePtr & 0x800000000) != 0)
                {
                  v26 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: Associated to 6Gh. Top Colocated Network for Transition = %@", v17);
                  goto LABEL_54;
                }
              }
            }
          }
        }
        else if ((valuePtr & 0x18) != 0 && Count >= 1)
        {
          for (j = 0; j != Count; ++j)
          {
            v21 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), j);
            if (v21)
            {
              v17 = v21;
              v22 = (const __CFNumber *)sub_10002BE64((uint64_t)v21, CFSTR("CHANNEL_FLAGS"));
              if (v22)
              {
                CFNumberGetValue(v22, kCFNumberIntType, (char *)&valuePtr + 4);
                if ((valuePtr & 0x200000000000) != 0)
                {
                  v26 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]:Associated to 2.4Gh/5Gh. Top 6Gh Colocated Network for Transition = %@", v17);
                  goto LABEL_54;
                }
              }
            }
          }
          if ((valuePtr & 8) == 0)
            return;
          v23 = 0;
          while (1)
          {
            v24 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3736), v23);
            if (v24)
            {
              v17 = v24;
              v25 = (const __CFNumber *)sub_10002BE64((uint64_t)v24, CFSTR("CHANNEL_FLAGS"));
              if (v25)
              {
                CFNumberGetValue(v25, kCFNumberIntType, (char *)&valuePtr + 4);
                if ((valuePtr & 0x1000000000) != 0)
                  break;
              }
            }
            if (Count == ++v23)
              return;
          }
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]:Associated to 2.4Gh. Top 5Gh Colocated Network for Transition = %@", v17);
LABEL_54:
          objc_autoreleasePoolPop(v26);
          sub_100120A64(a1, v17);
        }
      }
    }
  }
}

uint64_t sub_10012162C(uint64_t result)
{
  if (result)
    return sub_10007946C(*(_QWORD *)(result + 64));
  return result;
}

uint64_t sub_10012163C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 7044) = a2;
  return result;
}

void sub_100121648(uint64_t a1, const void *a2, int a3)
{
  int v6;
  void *v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  const void *v12;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_8;
    v11 = "WiFiDeviceManagerEvaluateStandaloneNetworkForUserPrompts";
    v9 = "%s: null device manager";
    goto LABEL_14;
  }
  if (!-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
  {
    v7 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_8;
    v9 = "suppressing standalone 6G notifications as setup is not complete";
LABEL_14:
    v10 = 4;
    goto LABEL_7;
  }
  v6 = sub_10012174C(a1, a2);
  if (a3 && !v6)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_8:
      objc_autoreleasePoolPop(v7);
      return;
    }
    v11 = "WiFiDeviceManagerEvaluateStandaloneNetworkForUserPrompts";
    v12 = a2;
    v9 = "%s: no colocated candidate found for %@";
    v10 = 3;
LABEL_7:
    objc_msgSend(v8, "WFLog:message:", v10, v9, v11, v12);
    goto LABEL_8;
  }
}

uint64_t sub_10012174C(uint64_t a1, const void *a2)
{
  void *v4;
  __CFArray *v5;
  const __CFArray *v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  WiFiColocatedNetworkManager *v12;
  id v13;
  id v14;
  id v15;
  __CFArray *Mutable;
  uint64_t v17;
  void *i;
  void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  CFIndex v23;
  const void *ValueAtIndex;
  WiFiColocatedNetworkManager *v25;
  uint64_t v26;
  void *v28;
  void *v29;
  void *v30;
  void *context;
  const void *v32;
  WiFiColocatedNetworkManager *v33;
  void *v34;
  const __CFArray *v35;
  void *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];

  v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiNetworkRef returned NULL", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
    goto LABEL_40;
  }
  if (!a1)
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiDeviceManagerRef is NULL", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
LABEL_40:
    objc_autoreleasePoolPop(v29);
    v8 = 0;
    v10 = 0;
    v25 = 0;
    v26 = 0;
    goto LABEL_31;
  }
  v5 = sub_100121BB0(a1);
  v6 = v5;
  if (v5 && CFArrayGetCount(v5))
  {
    v7 = sub_100121D60(v6);
    if (v7)
    {
      v8 = v7;
      v9 = sub_100104784(a1);
      if (v9)
      {
        v10 = v9;
        v11 = CWFColocatedNetworksMatchingScanResult(v9, v8, objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "knownNetworks"), "allObjects"));
        if (v11)
        {
          v32 = a2;
          v12 = -[WiFiColocatedNetworkManager initWithNetwork:colocatedNetworks:]([WiFiColocatedNetworkManager alloc], "initWithNetwork:colocatedNetworks:", v10, v11);
          v13 = -[NSArray copy](-[WiFiColocatedNetworkManager colocatedNetworks](v12, "colocatedNetworks"), "copy");
          v35 = v6;
          v36 = v4;
          v33 = v12;
          v34 = v8;
          context = objc_autoreleasePoolPush();
          if (v13
            && (v39 = 0u,
                v40 = 0u,
                v37 = 0u,
                v38 = 0u,
                (v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v37, v41, 16)) != 0))
          {
            v15 = v14;
            Mutable = 0;
            v17 = *(_QWORD *)v38;
            do
            {
              for (i = 0; i != v15; i = (char *)i + 1)
              {
                if (*(_QWORD *)v38 != v17)
                  objc_enumerationMutation(v13);
                v19 = sub_1000CE200(*(void **)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i));
                if (v19)
                {
                  v20 = v19;
                  if (!Mutable)
                    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                  CFArrayAppendValue(Mutable, v20);
                  CFRelease(v20);
                }
              }
              v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v37, v41, 16);
            }
            while (v15);
          }
          else
          {
            Mutable = 0;
          }
          objc_autoreleasePoolPop(context);

          if (objc_msgSend(objc_msgSend(v10, "channel"), "is6GHz"))
          {
            v21 = sub_10002B088(v32);
            if (v21)
            {
              v22 = v21;
              if (CFArrayGetCount(Mutable) >= 1)
              {
                v23 = 0;
                do
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v23);
                  sub_10002C478((uint64_t)ValueAtIndex, CFSTR("LimitedCompatibilityNetworkName"), v22);
                  ++v23;
                }
                while (v23 < CFArrayGetCount(Mutable));
              }
            }
          }
          v25 = v33;
          sub_100121E18((uint64_t *)a1, v32, v33);
          v26 = 1;
          v6 = v35;
          v4 = v36;
          v8 = v34;
          if (!v35)
            goto LABEL_29;
          goto LABEL_28;
        }
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no candidates found", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
      }
      else
      {
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult() returned NULL", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
        v10 = 0;
      }
    }
    else
    {
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerCreateCoreWiFiScanResultsFromNetworks() returned NULL", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
      v10 = 0;
      v8 = 0;
    }
    objc_autoreleasePoolPop(v30);
    v26 = 0;
    v25 = 0;
    Mutable = 0;
  }
  else
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Beacon cache was empty", "WiFiDeviceManagerAttemptToShowColocatedJoinNotification");
    objc_autoreleasePoolPop(v28);
    v8 = 0;
    v10 = 0;
    Mutable = 0;
    v25 = 0;
    v26 = 0;
    if (!v6)
      goto LABEL_29;
  }
LABEL_28:
  CFRelease(v6);
LABEL_29:
  if (Mutable)
    CFRelease(Mutable);
LABEL_31:

  objc_autoreleasePoolPop(v4);
  return v26;
}

__CFArray *sub_100121BB0(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  const __CFArray *v3;
  __CFArray *v4;
  CFIndex v5;
  const void *ValueAtIndex;
  _WORD *v7;
  const void *v8;
  void *v10;
  void *v11;

  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiDeviceManagerRef is NULL", "__WiFiDeviceManagerCopyDeviceScanCache");
    goto LABEL_15;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CFArrayCreateMutable() returned NULL", "__WiFiDeviceManagerCopyDeviceScanCache");
LABEL_15:
    objc_autoreleasePoolPop(v10);
    return 0;
  }
  v3 = Mutable;
  sub_100071C00(*(_QWORD *)(a1 + 64), (uint64_t)Mutable);
  if (CFArrayGetCount(v3))
  {
    v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (CFArrayGetCount(v3) >= 1)
    {
      v5 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, v5);
        v7 = sub_10002B314((uint64_t)kCFAllocatorDefault, ValueAtIndex);
        if (v7)
        {
          v8 = v7;
          CFArrayAppendValue(v4, v7);
          CFRelease(v8);
        }
        ++v5;
      }
      while (v5 < CFArrayGetCount(v3));
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Beacon cache was empty", "__WiFiDeviceManagerCopyDeviceScanCache");
    objc_autoreleasePoolPop(v11);
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

id sub_100121D60(const __CFArray *a1)
{
  void *v2;
  CFIndex v3;
  id v4;
  const void *ValueAtIndex;
  id v6;
  void *v7;

  v2 = objc_autoreleasePoolPush();
  if (a1 && CFArrayGetCount(a1) >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v3);
      if (ValueAtIndex)
      {
        v6 = sub_100027D10((uint64_t)ValueAtIndex);
        if (v6)
        {
          v7 = v6;
          if (!v4)
            v4 = objc_alloc_init((Class)NSMutableArray);
          objc_msgSend(v4, "addObject:", v7);

        }
      }
      ++v3;
    }
    while (CFArrayGetCount(a1) > v3);
  }
  else
  {
    v4 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v4;
}

void sub_100121E18(uint64_t *a1, const void *a2, const void *a3)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  uint64_t v12;
  void *v13;
  uint64_t (*v14)(uint64_t *, uint64_t, uint64_t, _QWORD, const void *, CFDictionaryRef, uint64_t);
  uint64_t v15;
  const void *v16;
  void *v17;
  void *v18;
  const char *v19;
  void *v20;
  const char *v21;
  void *values;
  void *keys;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager", "__WiFiDeviceManagerShowColocatedJoinNotification");
    goto LABEL_29;
  }
  if (!-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v19 = "suppressing limited compatibility modal as setup is not complete";
LABEL_28:
      objc_msgSend(v18, "WFLog:message:", 4, v19, v21);
    }
LABEL_29:
    objc_autoreleasePoolPop(v17);
    goto LABEL_15;
  }
  if (!a2)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: current network is null", "__WiFiDeviceManagerShowColocatedJoinNotification");
    goto LABEL_29;
  }
  if (!a3)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: candidate manager is nil", "__WiFiDeviceManagerShowColocatedJoinNotification");
    goto LABEL_29;
  }
  v7 = (void *)sub_10002B088(a2);
  if (!v7)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: current network name is null", "__WiFiDeviceManagerShowColocatedJoinNotification");
    goto LABEL_29;
  }
  v8 = v7;
  CFRetain(a2);
  CFRetain(a3);
  a1[1128] = (uint64_t)a2;
  a1[495] = (uint64_t)a3;
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: dispatching user assisted colocated network join alert for candidate/s", "__WiFiDeviceManagerShowColocatedJoinNotification");
  objc_autoreleasePoolPop(v9);
  values = v8;
  keys = CFSTR("SSID_STR");
  v10 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v10)
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v21 = "__WiFiDeviceManagerShowColocatedJoinNotification";
      v19 = "%s: failed to create additionalInformation";
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  v11 = v10;
  v12 = sub_100025C3C(a1[8]);
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type=%@(%d)", "__WiFiDeviceManagerDispatchStandaloneLimitedNetworkNotification", sub_100064E5C(0xDu), 13);
  objc_autoreleasePoolPop(v13);
  v14 = (uint64_t (*)(uint64_t *, uint64_t, uint64_t, _QWORD, const void *, CFDictionaryRef, uint64_t))a1[494];
  if (v14)
  {
    v15 = v14(a1, v12, 13, 0, a3, v11, a1[496]);
    if (v15)
    {
      v16 = (const void *)v15;
      sub_1000BFB70(v15, (uint64_t)sub_10013E778, (uint64_t)a1);
      sub_1000D7408((uint64_t)v16, a1[30]);
      a1[28] = (uint64_t)CFRetain(v16);
      sub_100135D8C((uint64_t)a1, CFSTR("autoJoinWaiting"), 0, 0);
    }
    else
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create notification for type %@(%d)", "__WiFiDeviceManagerDispatchStandaloneLimitedNetworkNotification", sub_100064E5C(0xDu), 13);
      objc_autoreleasePoolPop(v20);
    }
  }
  CFRelease(v11);
LABEL_15:
  objc_autoreleasePoolPop(v6);
}

void sub_10012219C(uint64_t *a1, const __CFString *a2)
{
  const void *v4;
  void *v5;
  const void *v6;
  __CFArray *v7;
  __CFArray *v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  const void *v13;
  const __CFString *v14;
  void *v15;
  __CFDictionary *v16;
  const void *v17;
  id v18;
  const void *v19;
  id v20;
  id v21;
  WiFiColocatedNetworkManager *v22;
  void *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];

  if (!a1)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerDispatchSimulatedColocatedJoinNotification");
    goto LABEL_28;
  }
  v4 = (const void *)sub_100025C3C(a1[8]);
  v5 = sub_10002A21C((uint64_t)a1, v4, 1);
  if (!v5)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device is not connected to a network", "WiFiDeviceManagerDispatchSimulatedColocatedJoinNotification");
LABEL_28:
    objc_autoreleasePoolPop(v23);
    v18 = 0;
    goto LABEL_23;
  }
  v6 = v5;
  v7 = sub_1000775BC(a1[8], 0);
  v8 = v7;
  if (v7)
  {
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v9 = -[__CFArray countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v25;
      while (2)
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v25 != v11)
            objc_enumerationMutation(v8);
          v13 = *(const void **)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i);
          v14 = (const __CFString *)sub_10002B088(v13);
          if (CFStringCompare(v14, a2, 0) == kCFCompareEqualTo)
          {
            v19 = sub_10002B088(v6);
            if (v19)
              sub_10002C478((uint64_t)v13, CFSTR("LimitedCompatibilityNetworkName"), v19);
            v20 = sub_100027D10((uint64_t)v13);
            v18 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", v20, 0);
            v21 = sub_100104784((uint64_t)a1);
            if (v21)
            {
              v22 = -[WiFiColocatedNetworkManager initWithNetwork:colocatedNetworks:]([WiFiColocatedNetworkManager alloc], "initWithNetwork:colocatedNetworks:", v21, v18);
              sub_100121E18(a1, v6, v22);

            }
            goto LABEL_21;
          }
        }
        v10 = -[__CFArray countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
        if (v10)
          continue;
        break;
      }
    }
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanning for %@", "WiFiDeviceManagerDispatchSimulatedColocatedJoinNotification", a2);
    objc_autoreleasePoolPop(v15);
  }
  v16 = sub_100116F8C(0, 0, 0, 0x6Eu, 1);
  CFDictionarySetValue(v16, CFSTR("SSID_STR"), a2);
  v17 = (const void *)sub_100025C3C(a1[8]);
  sub_100018C78((uint64_t)a1, v17, v16, 0, (uint64_t)sub_1001224A0, (uint64_t)a1, 0, 22);
  v18 = 0;
LABEL_21:
  CFRelease(v6);
  if (v8)
    CFRelease(v8);
LABEL_23:

}

void sub_1001224A0(int a1, int a2, CFArrayRef theArray, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  const void *v8;
  void *v9;
  const void *ValueAtIndex;
  id v11;
  const void *v12;
  const void *v13;
  id v14;
  void *v15;
  WiFiColocatedNetworkManager *v16;
  void *v17;
  const void *v18;
  const void *v19;
  void *v20;
  void *v21;

  if (!a6)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback");
    goto LABEL_17;
  }
  if (!theArray || !CFArrayGetCount(theArray))
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scan results were empty", "__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback");
LABEL_17:
    objc_autoreleasePoolPop(v20);
    v11 = 0;
    v16 = 0;
    v9 = 0;
LABEL_21:
    v15 = 0;
    goto LABEL_10;
  }
  v8 = (const void *)sub_100025C3C(a6[8]);
  v9 = sub_10002A21C((uint64_t)a6, v8, 1);
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
  v11 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", ValueAtIndex, CFArrayGetValueAtIndex(theArray, 1), 0);
  v12 = CFArrayGetValueAtIndex(theArray, 0);
  v13 = CFArrayGetValueAtIndex(theArray, 1);
  v14 = sub_100104784((uint64_t)a6);
  if (!v14)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult() returned NULL", "__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback");
    objc_autoreleasePoolPop(v21);
    v16 = 0;
    goto LABEL_21;
  }
  v15 = v14;
  v16 = -[WiFiColocatedNetworkManager initWithNetwork:colocatedNetworks:]([WiFiColocatedNetworkManager alloc], "initWithNetwork:colocatedNetworks:", v14, v11);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: simulating colocated join notification for %@", "__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback", -[WiFiColocatedNetworkManager colocatedNetworks](v16, "colocatedNetworks"));
  objc_autoreleasePoolPop(v17);
  v18 = sub_10002B088(v9);
  if (v18)
  {
    v19 = v18;
    sub_10002C478((uint64_t)v12, CFSTR("LimitedCompatibilityNetworkName"), v18);
    sub_10002C478((uint64_t)v13, CFSTR("LimitedCompatibilityNetworkName"), v19);
  }
  sub_100121E18(a6, v9, v16);
LABEL_10:

  if (v9)
    CFRelease(v9);
}

void sub_100122730(uint64_t a1, const void *a2)
{
  void *v4;
  const void *v5;
  const void *v6;
  int v7;
  void *v8;
  void *v9;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager", "WiFiDeviceManagerDispatchAppJoinNotification");
    goto LABEL_14;
  }
  v5 = sub_10002B088(a2);
  if (!v5)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network name is null", "WiFiDeviceManagerDispatchAppJoinNotification");
    goto LABEL_14;
  }
  v6 = v5;
  if (!sub_10002BE64((uint64_t)a2, CFSTR("OriginatingApp")))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: app name is null", "WiFiDeviceManagerDispatchAppJoinNotification");
LABEL_14:
    objc_autoreleasePoolPop(v9);
    goto LABEL_7;
  }
  CFRetain(a2);
  *(_QWORD *)(a1 + 6248) = a2;
  v7 = sub_1000CEBA4((uint64_t)a2);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: dispatching user forced association notify alert for network='%@'", "WiFiDeviceManagerDispatchAppJoinNotification", a2);
  objc_autoreleasePoolPop(v8);
  objc_msgSend(*(id *)(a1 + 6704), "dispatchAccessoryJoinAlertForNetwork:unsecured:", v6, v7 != 0);
LABEL_7:
  objc_autoreleasePoolPop(v4);
}

void sub_1001228AC(uint64_t a1)
{
  id v2;
  void *v3;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  unsigned int v6;
  const __CFString *v7;
  const __CFString *v8;
  CFBooleanRef v9;
  __CFDictionary *v10;
  void *v11;
  void *v12;
  void *v13;
  CFDictionaryRef *v14;

  if (-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: User has already set up device", "WiFiDeviceManagerSubmitSetupMetric");
    goto LABEL_22;
  }
  v2 = sub_100104784(a1);
  if (!v2)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL", "WiFiDeviceManagerSubmitSetupMetric");
LABEL_22:
    objc_autoreleasePoolPop(v11);
    v14 = 0;
    v3 = 0;
    goto LABEL_17;
  }
  v3 = v2;
  v14 = sub_100122B08(a1);
  if (v14)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v5 = Mutable;
      v6 = objc_msgSend(objc_msgSend(v3, "channel"), "band");
      if (v6 == 3)
      {
        CFDictionarySetValue(v5, CFSTR("infraBand"), CFSTR("6"));
        if (-[CFDictionaryRef isStandalone6G](v14, "isStandalone6G"))
          v9 = kCFBooleanTrue;
        else
          v9 = kCFBooleanFalse;
        CFDictionarySetValue(v5, CFSTR("isSplitSSID"), v9);
        v7 = CFSTR("suppressedBanner");
        v10 = v5;
        v8 = (const __CFString *)kCFBooleanTrue;
      }
      else
      {
        if (v6 == 2)
        {
          v7 = CFSTR("infraBand");
          v8 = CFSTR("5");
        }
        else
        {
          if (v6 != 1)
          {
LABEL_16:
            sub_100063388((uint64_t)CFSTR("com.apple.wifi.setup"), (uint64_t)v5);
            CFRelease(v5);
            goto LABEL_17;
          }
          v7 = CFSTR("infraBand");
          v8 = CFSTR("2");
        }
        v10 = v5;
      }
      CFDictionarySetValue(v10, v7, v8);
      goto LABEL_16;
    }
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metric is null", "WiFiDeviceManagerSubmitSetupMetric");
    objc_autoreleasePoolPop(v13);
  }
  else
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiNetworkProfile returned NULL", "WiFiDeviceManagerSubmitSetupMetric");
    objc_autoreleasePoolPop(v12);
    v14 = 0;
  }
LABEL_17:

}

CFDictionaryRef *sub_100122B08(uint64_t a1)
{
  const void *v2;
  CFDictionaryRef *result;
  CFDictionaryRef *v4;
  void *v5;

  v2 = (const void *)sub_100029860(*(_QWORD *)(a1 + 64));
  result = (CFDictionaryRef *)sub_10002A21C(a1, v2, 1);
  if (result)
  {
    v4 = result;
    v5 = sub_100026664(result);
    CFRelease(v4);
    return (CFDictionaryRef *)v5;
  }
  return result;
}

void sub_100122B58(_QWORD *a1, uint64_t a2)
{
  void *v4;
  void *v5;
  unsigned int v6;
  void *v7;
  void *v8;
  __CFDictionary *Mutable;
  __CFDictionary *v10;
  const void *v11;
  const __CFDictionary *v12;
  const void *Value;
  const void *v14;
  void *v15;
  CFDictionaryRef *v16;
  CFDictionaryRef *v17;
  const __CFString *v18;
  const __CFString *v19;
  void *v20;
  NSObject *v21;
  const char *v22;
  void *v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  _QWORD block[6];

  v4 = objc_autoreleasePoolPush();
  v5 = (void *)a1[495];
  v6 = sub_1000D71FC(a2);
  v7 = sub_1000CE200(objc_msgSend(v5, "retrieveNextCandidate"));
  v8 = objc_autoreleasePoolPush();
  if (!v7)
  {
    if (qword_10026DD20)
    {
      v22 = "Could not create WiFiNetworkRef from scan result";
      v23 = (void *)qword_10026DD20;
LABEL_28:
      objc_msgSend(v23, "WFLog:message:", 4, v22, v25);
    }
LABEL_29:
    objc_autoreleasePoolPop(v8);
    goto LABEL_18;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ResponseType=%@", "__WiFiDeviceManagerProcessColocatedJoinNotification", sub_1000D75DC(v6));
  objc_autoreleasePoolPop(v8);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v8 = objc_autoreleasePoolPush();
    v23 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v25 = "__WiFiDeviceManagerProcessColocatedJoinNotification";
      v22 = "%s: metric is null";
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  v10 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("BannerType"), CFSTR("limitednetworkjoin"));
  if (v6 - 2 < 2)
  {
    CFDictionarySetValue(v10, CFSTR("UserAction"), CFSTR("dismissed"));
    v11 = (const void *)a1[1128];
    if (v11)
    {
      CFRelease(v11);
      a1[1128] = 0;
    }
    goto LABEL_16;
  }
  if (v6 == 1)
  {
    CFDictionarySetValue(v10, CFSTR("UserAction"), CFSTR("join"));
    v12 = (const __CFDictionary *)sub_100029860(a2);
    if (v12)
    {
      Value = CFDictionaryGetValue(v12, CFSTR("SSID_STR"));
      if (Value)
      {
        v14 = Value;
        v15 = sub_100122F18((uint64_t)a1, (uint64_t)Value);
        if (v15)
        {
          v16 = (CFDictionaryRef *)sub_1000CCB10(v15, objc_msgSend(v15, "properties"));
          if (v16)
          {
            v17 = v16;
            if (!sub_1000C5964((uint64_t)v16))
            {
              v19 = 0;
              goto LABEL_20;
            }
            v18 = sub_1000C37A0(v17);
            if (v18)
            {
              v19 = v18;
              sub_1000C64F0(v7, v18);
LABEL_20:
              CFRelease(v17);
              v20 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabling device manager", "__WiFiDeviceManagerProcessColocatedJoinNotification");
              objc_autoreleasePoolPop(v20);
              sub_1000FB408((uint64_t)a1);
              CFRetain(v7);
              a1[1127] = v7;
              v21 = a1[30];
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_1001230B4;
              block[3] = &unk_10022EF88;
              block[4] = a1;
              block[5] = v7;
              dispatch_async(v21, block);
              sub_100063388((uint64_t)CFSTR("com.apple.wifi.6eNotification"), (uint64_t)v10);
              if (v19)
                CFRelease(v19);
              goto LABEL_17;
            }
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to retrieve password for %@", "__WiFiDeviceManagerProcessColocatedJoinNotification", v14);
          }
          else
          {
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to  %@", "__WiFiDeviceManagerProcessColocatedJoinNotification", v14);
          }
        }
        else
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no matching profile for %@", "__WiFiDeviceManagerProcessColocatedJoinNotification", v14);
        }
      }
      else
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no SSID in additional information", "__WiFiDeviceManagerProcessColocatedJoinNotification", v26);
      }
    }
    else
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: notification for %@ is missing additional information", "__WiFiDeviceManagerProcessColocatedJoinNotification", sub_10002B088(v7));
    }
    objc_autoreleasePoolPop(v24);
    goto LABEL_17;
  }
LABEL_16:
  sub_100063388((uint64_t)CFSTR("com.apple.wifi.6eNotification"), (uint64_t)v10);
LABEL_17:
  CFRelease(v10);
LABEL_18:
  objc_autoreleasePoolPop(v4);
}

void *sub_100122F18(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;
  void *v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiDeviceManagerFindKnownNetworkMatchingNetworkName");
    goto LABEL_17;
  }
  v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "knownNetworks"), "allObjects");
  if (!v5)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: known network profiles is nil", "__WiFiDeviceManagerFindKnownNetworkMatchingNetworkName");
LABEL_17:
    objc_autoreleasePoolPop(v13);
    goto LABEL_11;
  }
  v6 = v5;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (!v7)
  {
LABEL_11:
    v11 = 0;
    goto LABEL_12;
  }
  v8 = v7;
  v9 = *(_QWORD *)v15;
LABEL_5:
  v10 = 0;
  while (1)
  {
    if (*(_QWORD *)v15 != v9)
      objc_enumerationMutation(v6);
    v11 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * v10);
    if ((objc_msgSend(objc_msgSend(v11, "networkName"), "isEqualToString:", a2) & 1) != 0)
      break;
    if (v8 == (id)++v10)
    {
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
      if (v8)
        goto LABEL_5;
      goto LABEL_11;
    }
  }
LABEL_12:
  objc_autoreleasePoolPop(v4);
  return v11;
}

uint64_t sub_1001230B4(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (const void *)sub_100025C3C(*(_QWORD *)(v2 + 64));
  return sub_10010AD4C(v2, v3, *(void **)(a1 + 40), 0, 0, (uint64_t)sub_100123100, 0, 1026);
}

void sub_100123100(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  const __CFString *v14;
  const __CFString *v15;
  void *v16;
  void *v17;
  const void *v18;
  const __CFString *v19;
  const __CFString *v20;
  NSObject *v21;
  const void *v22;
  void *v23;
  void *v24;
  _QWORD block[6];

  v9 = *(void **)(a1 + 3960);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %d reqInfo %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", a5, a4);
  objc_autoreleasePoolPop(v10);
  v11 = *(void **)(a1 + 9016);
  v12 = objc_autoreleasePoolPush();
  if (v11)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabling device manager", "__WiFiDeviceManagerColocatedJoinAssociationCallback");
    objc_autoreleasePoolPop(v12);
    sub_1000FB2E0(a1);
    if ((_DWORD)a5)
    {
      if (sub_1000C5964((uint64_t)v11))
      {
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing password for %@ due to failed association", "__WiFiDeviceManagerColocatedJoinAssociationCallback", v11);
        objc_autoreleasePoolPop(v13);
        sub_1000C65D8(v11);
      }
      goto LABEL_12;
    }
    v14 = (const __CFString *)sub_10002B088(a3);
    v15 = (const __CFString *)sub_10002B088(v11);
    if (CFStringCompare(v14, v15, 0))
    {
LABEL_12:
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: launching settings to complete join for %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", v11);
      objc_autoreleasePoolPop(v16);
      sub_10013427C(0, (CFDictionaryRef *)v11);
      return;
    }
    sub_100094420(*(_QWORD *)(a1 + 6792), a3, 18);
    if (objc_msgSend(v9, "numberOfCandidates"))
    {
      v17 = sub_1000CE200(objc_msgSend(v9, "retrieveNextCandidate"));
      if (v17)
      {
        v18 = v17;
        if (!sub_1000C5964((uint64_t)v17))
        {
LABEL_20:
          CFRetain(v18);
          *(_QWORD *)(a1 + 9016) = v18;
          v21 = *(NSObject **)(a1 + 240);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100145ECC;
          block[3] = &unk_10022EF88;
          block[4] = v18;
          block[5] = a1;
          dispatch_async(v21, block);
          return;
        }
        v19 = sub_1000C37A0(*(CFDictionaryRef **)(a1 + 9024));
        if (v19)
        {
          v20 = v19;
          sub_1000C64F0(v18, v19);
          CFRelease(v20);
          goto LABEL_20;
        }
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get password for %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", *(_QWORD *)(a1 + 9024));
        objc_autoreleasePoolPop(v24);
      }
      else
      {
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not create WiFiNetworkRef from scan result");
        objc_autoreleasePoolPop(v23);
      }
    }
    else
    {
      v22 = *(const void **)(a1 + 9016);
      if (v22)
      {
        CFRelease(v22);
        *(_QWORD *)(a1 + 9016) = 0;
      }
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: join candidate is null", "__WiFiDeviceManagerColocatedJoinAssociationCallback");
    objc_autoreleasePoolPop(v12);
  }
}

uint64_t sub_1001233D0()
{
  objc_autoreleasePoolPop(objc_autoreleasePoolPush());
  return 0;
}

void sub_1001233EC(uint64_t a1)
{
  void *v2;
  id v3;
  _BYTE *v4;
  void *v5;
  const char *v6;
  uint64_t v7;

  if (a1)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedState:", 3);
    if (v3)
    {
      v4 = (_BYTE *)(a1 + 9065);
      *(_BYTE *)(a1 + 9065) = objc_msgSend(v3, "count") != 0;
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (*v4)
          v6 = "YES";
        else
          v6 = "NO";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WoW Denylist non-empty: %s", "WiFiDeviceManagerProcessWoWDenylistUpdate", v6);
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to get WoW Denylisted networks", "WiFiDeviceManagerProcessWoWDenylistUpdate", v7);
    }
    objc_autoreleasePoolPop(v5);
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1001234DC(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 3448);
  return result;
}

uint64_t sub_1001234E8(uint64_t *a1, const void *a2, CFTypeRef cf1, const void *a4)
{
  CFTypeRef *v8;
  const void *v9;

  if (CFEqual(cf1, CFSTR("IO80211InterfaceBGScanParams")))
  {
    v8 = (CFTypeRef *)(a1 + 684);
    v9 = (const void *)a1[684];
    if (v9)
    {
LABEL_3:
      CFRelease(v9);
      *v8 = 0;
    }
  }
  else
  {
    if (!CFEqual(cf1, CFSTR("IO80211InterfaceBGDynamicProfileParams")))
      return sub_10002DC20(a1[8], a2, cf1, (uint64_t)a4);
    v8 = (CFTypeRef *)(a1 + 685);
    v9 = (const void *)a1[685];
    if (v9)
      goto LABEL_3;
  }
  *v8 = CFRetain(a4);
  return sub_10002DC20(a1[8], a2, cf1, (uint64_t)a4);
}

uint64_t sub_100123590(uint64_t *a1, const void *a2, void *a3)
{
  void *v6;
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  void *v13;
  NSNumber *v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  void *j;
  void *v20;
  id v21;
  _WORD *v22;
  const void *v23;
  const __CFArray *v24;
  NSNumber *v25;
  uint64_t v26;
  void *v28;
  void *v29;
  void *v30;
  CFMutableArrayRef *v31;
  const void *v32;
  void *v33;
  id obj;
  id obja;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  const __CFString *v44;
  NSNumber *v45;
  _QWORD v46[3];
  _QWORD v47[3];
  _BYTE v48[128];
  _QWORD v49[2];
  _QWORD v50[2];
  _BYTE v51[128];

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerSetBackgroundScanConfiguration");
    goto LABEL_48;
  }
  if (!a2)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null interfaceName.", "WiFiDeviceManagerSetBackgroundScanConfiguration");
    goto LABEL_48;
  }
  if (!a3)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null config.", "WiFiDeviceManagerSetBackgroundScanConfiguration");
LABEL_48:
    objc_autoreleasePoolPop(v28);
    v26 = 4294963396;
    goto LABEL_41;
  }
  v7 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v32 = a2;
  v33 = v6;
  v30 = a3;
  v31 = (CFMutableArrayRef *)a1;
  if ((objc_msgSend(a3, "modifyMap") & 1) != 0)
  {
    v29 = v7;
    v8 = +[NSMutableArray array](NSMutableArray, "array");
    v40 = 0u;
    v41 = 0u;
    v42 = 0u;
    v43 = 0u;
    obj = objc_msgSend(a3, "channels");
    v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v40, v51, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v41;
      do
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v41 != v11)
            objc_enumerationMutation(obj);
          v13 = *(void **)(*((_QWORD *)&v40 + 1) + 8 * (_QWORD)i);
          v49[0] = CFSTR("CHANNEL");
          v14 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v13, "channel"));
          v49[1] = CFSTR("CHANNEL_FLAGS");
          v50[0] = v14;
          v50[1] = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v13, "flags"));
          objc_msgSend(v8, "addObject:", +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v50, v49, 2));
        }
        v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v40, v51, 16);
      }
      while (v10);
    }
    v7 = v29;
    objc_msgSend(v29, "setObject:forKeyedSubscript:", v8, CFSTR("SCAN_CHANNELS"));
    a2 = v32;
    v6 = v33;
  }
  if ((objc_msgSend(a3, "modifyMap") & 4) != 0)
    objc_msgSend(v7, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a3, "cacheEnabled")), CFSTR("BGSCAN_CACHE"));
  if ((objc_msgSend(a3, "modifyMap") & 8) != 0)
    objc_msgSend(v7, "setObject:forKeyedSubscript:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a3, "cacheRollover")), CFSTR("BGSCAN_CACHE_WSB_ROLLOVER"));
  if (objc_msgSend(v7, "count"))
  {
    sub_10011203C((uint64_t)a1, (CFDictionaryRef)v7, 0);
    if ((objc_msgSend(a3, "modifyMap") & 2) == 0)
    {
LABEL_35:
      sub_1000FF824((uint64_t)a1);
      goto LABEL_36;
    }
LABEL_21:
    v15 = +[NSMutableSet set](NSMutableSet, "set");
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    obja = objc_msgSend(a3, "networks");
    v16 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
    if (v16)
    {
      v17 = v16;
      v18 = *(_QWORD *)v37;
      do
      {
        for (j = 0; j != v17; j = (char *)j + 1)
        {
          if (*(_QWORD *)v37 != v18)
            objc_enumerationMutation(obja);
          v20 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)j);
          v21 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
          objc_msgSend(v21, "setObject:forKeyedSubscript:", objc_msgSend(v20, "BSSID"), CFSTR("BSSID"));
          objc_msgSend(v21, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(objc_msgSend(v20, "channel"), "channel")), CFSTR("CHANNEL"));
          objc_msgSend(v21, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(objc_msgSend(v20, "channel"), "flags")), CFSTR("CHANNEL_FLAGS"));
          if (objc_msgSend(v20, "entry"))
            objc_msgSend(v21, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ENTRY_NETWORK"));
          if (objc_msgSend(v20, "exit"))
            objc_msgSend(v21, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("EXIT_NETWORK"));
          v22 = sub_10002B314((uint64_t)kCFAllocatorDefault, v21);
          if (v22)
          {
            v23 = v22;
            sub_10002C478((uint64_t)v22, CFSTR("forceBGScanParamsCompare"), kCFBooleanTrue);
            objc_msgSend(v15, "addObject:", v23);
            CFRelease(v23);
          }
        }
        v17 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
      }
      while (v17);
    }
    v24 = (const __CFArray *)objc_msgSend(v15, "allObjects");
    a1 = (uint64_t *)v31;
    sub_10010194C(v31, v24, 0);
    a2 = v32;
    v6 = v33;
    a3 = v30;
    goto LABEL_35;
  }
  if ((objc_msgSend(a3, "modifyMap") & 2) != 0)
    goto LABEL_21;
LABEL_36:
  if ((objc_msgSend(a3, "modifyMap") & 0x10) == 0)
    goto LABEL_51;
  v46[0] = CFSTR("IO80211InterfaceBGScanDynamicProfileStartTime");
  v47[0] = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(a3, "scanFrequency"));
  v46[1] = CFSTR("IO80211InterfaceBGScanDynamicProfileScanFreq");
  v25 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(a3, "scanFrequency"));
  v46[2] = CFSTR("IO80211InterfaceBGScanDynamicProfileDuration");
  v47[1] = v25;
  v47[2] = &off_100253290;
  v26 = sub_1001234E8(a1, a2, CFSTR("IO80211InterfaceBGDynamicProfileParams"), +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v47, v46, 3));
  if (!(_DWORD)v26)
  {
LABEL_51:
    if ((objc_msgSend(a3, "modifyMap") & 0x20) == 0
      || (v44 = CFSTR("IO80211InterfaceBGScanLostNetTO"),
          v45 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(a3, "lostNetworkScanCount")), v26 = sub_1001234E8(a1, a2, CFSTR("IO80211InterfaceBGScanParams"), +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v45, &v44, 1)), !(_DWORD)v26))
    {
      v26 = 0;
    }
  }
LABEL_41:
  objc_autoreleasePoolPop(v6);
  return v26;
}

id sub_100123BD4(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  void *i;
  void *v12;
  id v13;
  id v14;
  uint64_t v15;
  const __CFArray *v16;
  id v17;
  CFIndex v18;
  const void *ValueAtIndex;
  void *v20;
  CFDictionaryRef v21;
  const __CFDictionary *v22;
  id v23;
  const void *Value;
  id v25;
  void *v26;
  uint64_t v27;
  void *v29;
  uint64_t v30;
  void *context;
  void *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[128];

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    v3 = objc_alloc_init((Class)CWFBackgroundScanConfiguration);
    v4 = *(void **)(a1 + 5480);
    if (v4)
      objc_msgSend(v3, "setScanFrequency:", objc_msgSend(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("IO80211InterfaceBGScanDynamicProfileScanFreq")), "unsignedIntegerValue"));
    v5 = *(void **)(a1 + 5472);
    if (v5)
      objc_msgSend(v3, "setLostNetworkScanCount:", objc_msgSend(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("IO80211InterfaceBGScanLostNetTO")), "unsignedIntegerValue"));
    context = v2;
    objc_msgSend(v3, "setCacheEnabled:", *(_BYTE *)(a1 + 5457) != 0);
    objc_msgSend(v3, "setCacheRollover:", *(_BYTE *)(a1 + 5458) != 0);
    v6 = *(void **)(a1 + 5448);
    v32 = v3;
    if (v6)
    {
      v30 = a1;
      v7 = +[NSMutableArray array](NSMutableArray, "array");
      v33 = 0u;
      v34 = 0u;
      v35 = 0u;
      v36 = 0u;
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v33, v37, 16);
      if (v8)
      {
        v9 = v8;
        v10 = *(_QWORD *)v34;
        do
        {
          for (i = 0; i != v9; i = (char *)i + 1)
          {
            if (*(_QWORD *)v34 != v10)
              objc_enumerationMutation(v6);
            v12 = *(void **)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)i);
            v13 = objc_alloc_init((Class)CWFChannel);
            objc_msgSend(v13, "setChannel:", objc_msgSend(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("CHANNEL")), "unsignedIntegerValue"));
            v14 = objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("CHANNEL_FLAGS"));
            if (v14)
            {
              v15 = (uint64_t)objc_msgSend(v14, "unsignedIntValue");
            }
            else if ((unint64_t)objc_msgSend(v13, "channel") <= 0xE)
            {
              v15 = 10;
            }
            else
            {
              v15 = 18;
            }
            objc_msgSend(v13, "setFlags:", v15);
            objc_msgSend(v7, "addObject:", v13);
          }
          v9 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v33, v37, 16);
        }
        while (v9);
      }
      objc_msgSend(v3, "setChannels:", v7);
      a1 = v30;
    }
    v16 = *(const __CFArray **)(a1 + 3592);
    if (v16)
    {
      v17 = +[NSMutableArray array](NSMutableArray, "array");
      if (CFArrayGetCount(v16) >= 1)
      {
        v18 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v16, v18);
          v20 = objc_autoreleasePoolPush();
          if (ValueAtIndex && (v21 = sub_1000173C0((uint64_t)ValueAtIndex)) != 0)
          {
            v22 = v21;
            v23 = objc_alloc_init((Class)CWFBackgroundScanNetwork);
            Value = CFDictionaryGetValue(v22, CFSTR("BSSID"));
            objc_msgSend(v23, "setBSSID:", CWFCorrectEthernetAddressString(Value));
            v25 = objc_alloc_init((Class)CWFChannel);
            objc_msgSend(v25, "setChannel:", objc_msgSend((id)CFDictionaryGetValue(v22, CFSTR("CHANNEL")), "unsignedIntegerValue"));
            v26 = (void *)CFDictionaryGetValue(v22, CFSTR("CHANNEL_FLAGS"));
            if (v26)
            {
              v27 = (uint64_t)objc_msgSend(v26, "unsignedIntValue");
            }
            else if ((unint64_t)objc_msgSend(v25, "channel") <= 0xE)
            {
              v27 = 10;
            }
            else
            {
              v27 = 18;
            }
            objc_msgSend(v25, "setFlags:", v27);
            objc_msgSend(v23, "setChannel:", v25);
            objc_msgSend(v23, "setEntry:", objc_msgSend(-[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", CFSTR("ENTRY_NETWORK")), "BOOLValue"));
            objc_msgSend(v23, "setExit:", objc_msgSend(-[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", CFSTR("EXIT_NETWORK")), "BOOLValue"));
            objc_autoreleasePoolPop(v20);
            CFRelease(v22);
            if (v23)
            {
              objc_msgSend(v17, "addObject:", v23);

            }
          }
          else
          {
            objc_autoreleasePoolPop(v20);
          }
          ++v18;
        }
        while (v18 < CFArrayGetCount(v16));
      }
      v3 = v32;
      objc_msgSend(v32, "setNetworks:", v17);
    }
    objc_msgSend(v3, "setModifyMap:", 0);
    v2 = context;
  }
  else
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerCopyBackgroundScanConfiguration");
    objc_autoreleasePoolPop(v29);
    v3 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

NSMutableArray *sub_100124020(uint64_t a1)
{
  id v2;
  NSMutableArray *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *context;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];

  v2 = objc_msgSend(*(id *)(a1 + 6648), "networksInDenyListedState:", 1);
  if (objc_msgSend(v2, "count"))
    v3 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", objc_msgSend(v2, "count"));
  else
    v3 = 0;
  context = objc_autoreleasePoolPush();
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v2);
        -[NSMutableArray addObject:](v3, "addObject:", +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", objc_msgSend(*(id *)(*((_QWORD *)&v10 + 1) + 8 * (_QWORD)v7), "copy"), CFSTR("network"), objc_msgSend(objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * (_QWORD)v7), 1, 0, 0), "copy"), CFSTR("reasons"), 0));
        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v5);
  }
  objc_autoreleasePoolPop(context);
  return v3;
}

BOOL sub_1001241D0(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_100119F8C(a1, a2, a3) != 0;
}

uint64_t sub_1001241EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5;

  v5 = sub_100027D10(a3);
  objc_msgSend(*(id *)(a1 + 6648), "removeNetworkDenyListInfoWithReason:forScanResult:", a2, v5);

  return 1;
}

void sub_100124238(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  NSObject *v15;
  NSObject *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  uint64_t v52;
  IOPMAssertionID v53;
  IOPMAssertionID v54;
  NSObject *v55;
  NSObject *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const void *v67;
  const void *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  const void *v76;
  const void *v77;
  const void *v78;
  const void *v79;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  const void *v84;
  IOPMAssertionID v85;
  NSObject *v86;
  NSObject *v87;
  const void *v88;
  const void *v89;
  const void *v90;
  const void *v91;
  const void *v92;
  const void *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  const void *v97;
  NSObject *v98;
  NSObject *v99;
  NSObject *v100;
  NSObject *v101;
  const void *v102;
  const void *v103;
  const void *v104;
  const void *v105;
  const void *v106;
  const void *v107;
  const void *v108;
  const void *v109;
  const void *v110;
  void *v111;
  NSObject *v112;
  NSObject *v113;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s %d\n", "__WiFiDeviceManagerRelease", 2543);
  objc_autoreleasePoolPop(v2);
  v9 = objc_autoreleasePoolPush();
  v10 = *(_QWORD *)(a1 + 240);
  if (v10)
    sub_1000F8B54(a1, v10);
  v11 = *(const void **)(a1 + 3512);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 3512) = 0;
  }
  v12 = *(const void **)(a1 + 3648);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 3648) = 0;
  }
  v13 = *(const void **)(a1 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v14 = *(const void **)(a1 + 96);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v15 = *(NSObject **)(a1 + 312);
  if (v15)
  {
    dispatch_release(v15);
    *(_QWORD *)(a1 + 312) = 0;
  }
  v16 = *(NSObject **)(a1 + 360);
  if (v16)
  {
    dispatch_release(v16);
    *(_QWORD *)(a1 + 360) = 0;
  }
  v17 = *(const void **)(a1 + 3504);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 3504) = 0;
  }
  v18 = *(const void **)(a1 + 3536);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 3536) = 0;
  }
  v19 = *(const void **)(a1 + 3528);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 3528) = 0;
  }
  v20 = *(const void **)(a1 + 3552);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(a1 + 3552) = 0;
  }
  v21 = *(const void **)(a1 + 3544);
  if (v21)
  {
    CFRelease(v21);
    *(_QWORD *)(a1 + 3544) = 0;
  }
  v22 = *(const void **)(a1 + 3576);
  if (v22)
  {
    CFRelease(v22);
    *(_QWORD *)(a1 + 3576) = 0;
  }
  v23 = *(const void **)(a1 + 3584);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a1 + 3584) = 0;
  }
  v24 = *(const void **)(a1 + 3592);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(a1 + 3592) = 0;
  }
  v25 = *(const void **)(a1 + 3568);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a1 + 3568) = 0;
  }
  v26 = *(const void **)(a1 + 3560);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 3560) = 0;
  }
  v27 = *(const void **)(a1 + 3656);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a1 + 3656) = 0;
  }
  v28 = *(const void **)(a1 + 3600);
  if (v28)
  {
    CFRelease(v28);
    *(_QWORD *)(a1 + 3600) = 0;
  }
  v29 = *(const void **)(a1 + 3608);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(a1 + 3608) = 0;
  }
  v30 = *(const void **)(a1 + 3328);
  if (v30)
  {
    CFRelease(v30);
    *(_QWORD *)(a1 + 3328) = 0;
  }
  v31 = *(const void **)(a1 + 3336);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(a1 + 3336) = 0;
  }
  v32 = *(const void **)(a1 + 3624);
  if (v32)
  {
    CFRelease(v32);
    *(_QWORD *)(a1 + 3624) = 0;
  }
  v33 = *(const void **)(a1 + 3632);
  if (v33)
  {
    CFRelease(v33);
    *(_QWORD *)(a1 + 3632) = 0;
  }
  v34 = *(const void **)(a1 + 3640);
  if (v34)
  {
    CFRelease(v34);
    *(_QWORD *)(a1 + 3640) = 0;
  }
  v35 = *(const void **)(a1 + 3288);
  if (v35)
  {
    CFRelease(v35);
    *(_QWORD *)(a1 + 3288) = 0;
  }
  v36 = *(const void **)(a1 + 3320);
  if (v36)
  {
    CFRelease(v36);
    *(_QWORD *)(a1 + 3320) = 0;
  }
  v37 = *(const void **)(a1 + 1104);
  if (v37)
  {
    CFRelease(v37);
    *(_QWORD *)(a1 + 1104) = 0;
  }
  v38 = *(const void **)(a1 + 1168);
  if (v38)
  {
    CFRelease(v38);
    *(_QWORD *)(a1 + 1168) = 0;
  }
  v39 = *(const void **)(a1 + 376);
  if (v39)
  {
    CFRelease(v39);
    *(_QWORD *)(a1 + 376) = 0;
  }
  v40 = *(const void **)(a1 + 272);
  if (v40)
  {
    CFRelease(v40);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v41 = *(const void **)(a1 + 5440);
  if (v41)
  {
    CFRelease(v41);
    *(_QWORD *)(a1 + 5440) = 0;
  }
  v42 = *(const void **)(a1 + 120);
  if (v42)
  {
    CFRelease(v42);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v43 = *(const void **)(a1 + 4936);
  if (v43)
  {
    CFRelease(v43);
    *(_QWORD *)(a1 + 4936) = 0;
  }
  v44 = *(const void **)(a1 + 976);
  if (v44)
  {
    CFRelease(v44);
    *(_QWORD *)(a1 + 976) = 0;
  }
  v45 = *(const void **)(a1 + 56);
  if (v45)
  {
    CFRelease(v45);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v46 = *(NSObject **)(a1 + 5512);
  if (v46)
  {
    dispatch_release(v46);
    *(_QWORD *)(a1 + 5512) = 0;
  }
  v47 = *(NSObject **)(a1 + 8592);
  if (v47)
  {
    dispatch_release(v47);
    *(_QWORD *)(a1 + 8592) = 0;
  }
  v48 = *(NSObject **)(a1 + 8632);
  if (v48)
  {
    dispatch_release(v48);
    *(_QWORD *)(a1 + 8632) = 0;
  }
  v49 = *(NSObject **)(a1 + 1000);
  if (v49)
  {
    dispatch_release(v49);
    *(_QWORD *)(a1 + 1000) = 0;
  }
  v50 = *(NSObject **)(a1 + 1056);
  if (v50)
  {
    dispatch_release(v50);
    *(_QWORD *)(a1 + 1056) = 0;
  }
  v51 = *(NSObject **)(a1 + 5528);
  if (v51)
  {
    dispatch_release(v51);
    *(_QWORD *)(a1 + 5528) = 0;
  }
  v52 = *(_QWORD *)(a1 + 4944);
  if (v52)
  {
    if (_MISDetach)
      _MISDetach(v52, v10, v3, v4, v5, v6, v7, v8);
    *(_QWORD *)(a1 + 4944) = 0;
  }
  v53 = *(_DWORD *)(a1 + 5228);
  if (v53)
  {
    IOPMAssertionRelease(v53);
    *(_DWORD *)(a1 + 5228) = 0;
  }
  v54 = *(_DWORD *)(a1 + 6764);
  if (v54)
  {
    IOPMAssertionRelease(v54);
    *(_DWORD *)(a1 + 6764) = 0;
  }
  v55 = *(NSObject **)(a1 + 5240);
  if (v55)
  {
    dispatch_release(v55);
    *(_QWORD *)(a1 + 5240) = 0;
  }
  v56 = *(NSObject **)(a1 + 5320);
  if (v56)
  {
    dispatch_release(v56);
    *(_QWORD *)(a1 + 5320) = 0;
  }
  v57 = *(const void **)(a1 + 5368);
  if (v57)
  {
    CFRelease(v57);
    *(_QWORD *)(a1 + 5368) = 0;
  }
  v58 = *(const void **)(a1 + 5376);
  if (v58)
  {
    CFRelease(v58);
    *(_QWORD *)(a1 + 5376) = 0;
  }
  v59 = *(const void **)(a1 + 5448);
  if (v59)
  {
    CFRelease(v59);
    *(_QWORD *)(a1 + 5448) = 0;
  }
  v60 = *(const void **)(a1 + 5472);
  if (v60)
  {
    CFRelease(v60);
    *(_QWORD *)(a1 + 5472) = 0;
  }
  v61 = *(const void **)(a1 + 5480);
  if (v61)
  {
    CFRelease(v61);
    *(_QWORD *)(a1 + 5480) = 0;
  }
  objc_msgSend(*(id *)(a1 + 5408), "resetDevice");
  *(_QWORD *)(a1 + 5408) = 0;
  v62 = *(const void **)(a1 + 5488);
  if (v62)
  {
    CFRelease(v62);
    *(_QWORD *)(a1 + 5488) = 0;
  }
  v63 = *(const void **)(a1 + 3368);
  if (v63)
  {
    CFRelease(v63);
    *(_QWORD *)(a1 + 3368) = 0;
  }
  v64 = *(const void **)(a1 + 3376);
  if (v64)
  {
    CFRelease(v64);
    *(_QWORD *)(a1 + 3376) = 0;
  }
  v65 = *(const void **)(a1 + 3384);
  if (v65)
  {
    CFRelease(v65);
    *(_QWORD *)(a1 + 3384) = 0;
  }
  v66 = *(const void **)(a1 + 3440);
  if (v66)
  {
    CFRelease(v66);
    *(_QWORD *)(a1 + 3440) = 0;
  }
  v67 = *(const void **)(a1 + 6160);
  if (v67)
  {
    CFRelease(v67);
    *(_QWORD *)(a1 + 6160) = 0;
  }
  v68 = *(const void **)(a1 + 6056);
  if (v68)
  {
    CFRelease(v68);
    *(_QWORD *)(a1 + 6056) = 0;
  }
  v69 = *(const void **)(a1 + 6064);
  if (v69)
  {
    CFRelease(v69);
    *(_QWORD *)(a1 + 6064) = 0;
  }
  v70 = *(const void **)(a1 + 5272);
  if (v70)
  {
    CFRelease(v70);
    *(_QWORD *)(a1 + 5272) = 0;
  }
  v71 = *(const void **)(a1 + 5280);
  if (v71)
  {
    CFRelease(v71);
    *(_QWORD *)(a1 + 5280) = 0;
  }
  v72 = *(const void **)(a1 + 5288);
  if (v72)
  {
    CFRelease(v72);
    *(_QWORD *)(a1 + 5288) = 0;
  }
  v73 = *(const void **)(a1 + 5296);
  if (v73)
  {
    CFRelease(v73);
    *(_QWORD *)(a1 + 5296) = 0;
  }
  v74 = *(const void **)(a1 + 5304);
  if (v74)
  {
    CFRelease(v74);
    *(_QWORD *)(a1 + 5304) = 0;
  }
  v75 = *(const void **)(a1 + 5312);
  if (v75)
  {
    CFRelease(v75);
    *(_QWORD *)(a1 + 5312) = 0;
  }
  v76 = *(const void **)(a1 + 3680);
  if (v76)
  {
    CFRelease(v76);
    *(_QWORD *)(a1 + 3680) = 0;
  }
  v77 = *(const void **)(a1 + 6552);
  if (v77)
  {
    CFRelease(v77);
    *(_QWORD *)(a1 + 6552) = 0;
  }
  v78 = *(const void **)(a1 + 6504);
  if (v78)
  {
    CFRelease(v78);
    *(_QWORD *)(a1 + 6504) = 0;
  }
  v79 = *(const void **)(a1 + 6520);
  if (v79)
  {
    CFRelease(v79);
    *(_QWORD *)(a1 + 6520) = 0;
  }
  v80 = *(const void **)(a1 + 6536);
  if (v80)
  {
    CFRelease(v80);
    *(_QWORD *)(a1 + 6536) = 0;
  }
  v81 = *(const void **)(a1 + 6368);
  if (v81)
  {
    CFRelease(v81);
    *(_QWORD *)(a1 + 6368) = 0;
  }
  v82 = *(const void **)(a1 + 6408);
  if (v82)
  {
    CFRelease(v82);
    *(_QWORD *)(a1 + 6408) = 0;
  }
  v83 = *(const void **)(a1 + 6424);
  if (v83)
  {
    CFRelease(v83);
    *(_QWORD *)(a1 + 6424) = 0;
  }
  v84 = *(const void **)(a1 + 6440);
  if (v84)
  {
    CFRelease(v84);
    *(_QWORD *)(a1 + 6440) = 0;
  }
  v85 = *(_DWORD *)(a1 + 6580);
  if (v85)
  {
    IOPMAssertionRelease(v85);
    *(_DWORD *)(a1 + 6580) = 0;
    *(_QWORD *)(a1 + 6584) = 0;
  }
  v86 = *(NSObject **)(a1 + 6808);
  if (v86)
  {
    dispatch_release(v86);
    *(_QWORD *)(a1 + 6808) = 0;
  }
  v87 = *(NSObject **)(a1 + 6816);
  if (v87)
  {
    dispatch_release(v87);
    *(_QWORD *)(a1 + 6816) = 0;
  }
  v88 = *(const void **)(a1 + 6840);
  if (v88)
  {
    CFRelease(v88);
    *(_QWORD *)(a1 + 6840) = 0;
  }
  v89 = *(const void **)(a1 + 6912);
  if (v89)
  {
    CFRelease(v89);
    *(_QWORD *)(a1 + 6912) = 0;
  }
  v90 = *(const void **)(a1 + 6920);
  if (v90)
  {
    CFRelease(v90);
    *(_QWORD *)(a1 + 6920) = 0;
  }
  v91 = *(const void **)(a1 + 6928);
  if (v91)
  {
    CFRelease(v91);
    *(_QWORD *)(a1 + 6928) = 0;
  }

  *(_QWORD *)(a1 + 6936) = 0;
  v92 = *(const void **)(a1 + 6656);
  if (v92)
  {
    CFRelease(v92);
    *(_QWORD *)(a1 + 6656) = 0;
  }
  v93 = *(const void **)(a1 + 7032);
  if (v93)
  {
    CFRelease(v93);
    *(_QWORD *)(a1 + 7032) = 0;
  }

  *(_QWORD *)(a1 + 6640) = 0;
  v94 = *(const void **)(a1 + 7064);
  if (v94)
  {
    CFRelease(v94);
    *(_QWORD *)(a1 + 7064) = 0;
  }
  v95 = *(const void **)(a1 + 6672);
  if (v95)
  {
    CFRelease(v95);
    *(_QWORD *)(a1 + 6672) = 0;
  }
  v96 = *(const void **)(a1 + 6680);
  if (v96)
  {
    CFRelease(v96);
    *(_QWORD *)(a1 + 6680) = 0;
  }
  v97 = *(const void **)(a1 + 6688);
  if (v97)
  {
    CFRelease(v97);
    *(_QWORD *)(a1 + 6688) = 0;
  }
  *(_QWORD *)(a1 + 6696) = 0;

  *(_QWORD *)(a1 + 6704) = 0;
  *(_QWORD *)(a1 + 6744) = 0;

  *(_QWORD *)(a1 + 6752) = 0;
  v98 = *(NSObject **)(a1 + 7320);
  if (v98)
  {
    dispatch_release(v98);
    *(_QWORD *)(a1 + 7320) = 0;
    *(_BYTE *)(a1 + 7312) = 0;
  }
  v99 = *(NSObject **)(a1 + 7344);
  if (v99)
  {
    dispatch_release(v99);
    *(_QWORD *)(a1 + 7344) = 0;
    *(_BYTE *)(a1 + 7336) = 0;
  }
  v100 = *(NSObject **)(a1 + 7216);
  if (v100)
  {
    dispatch_release(v100);
    *(_QWORD *)(a1 + 7216) = 0;
  }
  v101 = *(NSObject **)(a1 + 7256);
  if (v101)
  {
    dispatch_release(v101);
    *(_QWORD *)(a1 + 7256) = 0;
  }
  v102 = *(const void **)(a1 + 3704);
  if (v102)
  {
    CFRelease(v102);
    *(_QWORD *)(a1 + 3704) = 0;
  }
  v103 = *(const void **)(a1 + 3696);
  if (v103)
  {
    CFRelease(v103);
    *(_QWORD *)(a1 + 3696) = 0;
  }
  v104 = *(const void **)(a1 + 3712);
  if (v104)
  {
    CFRelease(v104);
    *(_QWORD *)(a1 + 3712) = 0;
  }
  v105 = *(const void **)(a1 + 7392);
  if (v105)
  {
    CFRelease(v105);
    *(_QWORD *)(a1 + 7392) = 0;
  }
  v106 = *(const void **)(a1 + 8976);
  if (v106)
  {
    CFRelease(v106);
    *(_QWORD *)(a1 + 8976) = 0;
  }
  v107 = *(const void **)(a1 + 3776);
  if (v107)
  {
    CFRelease(v107);
    *(_QWORD *)(a1 + 3776) = 0;
  }
  v108 = *(const void **)(a1 + 3736);
  if (v108)
  {
    CFRelease(v108);
    *(_QWORD *)(a1 + 3736) = 0;
  }
  v109 = *(const void **)(a1 + 3752);
  if (v109)
  {
    CFRelease(v109);
    *(_QWORD *)(a1 + 3752) = 0;
  }
  *(_BYTE *)(a1 + 3744) = 0;
  *(_BYTE *)(a1 + 3760) = 0;
  v110 = *(const void **)(a1 + 3832);
  if (v110)
  {
    CFRelease(v110);
    *(_QWORD *)(a1 + 3832) = 0;
  }

  *(_QWORD *)(a1 + 3856) = 0;
  *(_OWORD *)(a1 + 3788) = 0u;
  *(_OWORD *)(a1 + 3804) = 0u;
  *(_QWORD *)(a1 + 3817) = 0;
  v111 = *(void **)(a1 + 968);
  if (v111)
  {

    *(_QWORD *)(a1 + 968) = 0;
  }
  v112 = *(NSObject **)(a1 + 8984);
  if (v112)
  {
    dispatch_release(v112);
    *(_QWORD *)(a1 + 8984) = 0;
  }
  v113 = *(NSObject **)(a1 + 8992);
  if (v113)
  {
    dispatch_release(v113);
    *(_QWORD *)(a1 + 8992) = 0;
  }
  qword_10026D750 = 0;
  objc_autoreleasePoolPop(v9);
}

uint64_t sub_1001249C8(uint64_t a1)
{
  double Current;
  const __CFArray *MutableCopy;
  CFIndex v4;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v6;
  void *v8;
  double valuePtr;

  if (!*(_QWORD *)(a1 + 376) || !*(_QWORD *)(a1 + 392) || *(double *)(a1 + 384) == 0.0)
    return 0;
  Current = CFAbsoluteTimeGetCurrent();
  MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, *(CFArrayRef *)(a1 + 376));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 376));
  if (MutableCopy)
  {
    if (CFArrayGetCount(MutableCopy) >= 1)
    {
      v4 = 0;
      do
      {
        valuePtr = 0.0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(MutableCopy, v4);
        if (ValueAtIndex)
        {
          v6 = ValueAtIndex;
          CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
          if (valuePtr < Current && Current - valuePtr < *(double *)(a1 + 384))
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 376), v6);
        }
        ++v4;
      }
      while (v4 < CFArrayGetCount(MutableCopy));
    }
    CFRelease(MutableCopy);
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 376)) < *(_QWORD *)(a1 + 392))
    return 0;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scan throttle exceeded: there have been %ld attempts in the past %f seconds", "__WiFiDeviceManagerIsScanThrottleLimitExceeded", CFArrayGetCount(*(CFArrayRef *)(a1 + 376)), *(_QWORD *)(a1 + 384));
  objc_autoreleasePoolPop(v8);
  return 1;
}

uint64_t sub_100124B34(uint64_t a1, void *a2, unsigned int a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  id v13;
  unsigned int v14;
  unsigned int v15;
  id v16;
  unsigned int v17;
  int v18;
  void *v19;
  void *v20;
  const void *v21;
  void *v22;
  const __CFNumber *v23;
  void *v24;
  void *v25;
  const void *v26;
  void *v27;
  const void *v28;
  void *v29;
  id v30;
  WiFiUserInteractionMonitor *v31;
  const void *v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  double v41;
  uint64_t v42;
  __int16 v43;

  v6 = objc_autoreleasePoolPush();
  if (!a2)
  {
    v7 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = a3;
      v9 = "%s: null network,  isFilteringAJCandidates %d";
LABEL_28:
      objc_msgSend(v10, "WFLog:message:", 3, v9, "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v35, v36);
      goto LABEL_29;
    }
    goto LABEL_29;
  }
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 3504), a2))
  {
    v7 = objc_autoreleasePoolPush();
    v8 = qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = (unint64_t)sub_10002B088(a2);
      v36 = a3;
      v9 = "%s: user canceled network %@, isFilteringAJCandidates %d";
LABEL_27:
      v10 = (void *)v8;
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  if (&_CNForgetSSID && sub_10002BE64((uint64_t)a2, kCNSIsWhitelistedCaptiveNetworkProperty) == kCFBooleanTrue)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = (unint64_t)sub_10002B088(a2);
      v9 = "%s: %@ auto-join disabled for potentially bypassing captive detection";
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  if (sub_1000CAEC8((uint64_t)a2))
  {
    v7 = objc_autoreleasePoolPush();
    v8 = qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = (unint64_t)sub_10002B088(a2);
      v36 = a3;
      v9 = "%s: disabled until first user join network %@ isFilteringAJCandidates %d";
      goto LABEL_27;
    }
LABEL_29:
    objc_autoreleasePoolPop(v7);
    v11 = 0;
    goto LABEL_30;
  }
  if (sub_1000CAF9C((const __CFDictionary **)a2))
  {
    v7 = objc_autoreleasePoolPush();
    v8 = qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = (unint64_t)sub_10002B088(a2);
      v9 = "%s: disabled because %@ is an infrequently joined public network";
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  if (sub_1000CEDAC((uint64_t)a2))
  {
    v7 = objc_autoreleasePoolPush();
    v8 = qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = (unint64_t)sub_10002B088(a2);
      v9 = "%s: accessory network (%@) is not suitable for autojoin";
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  if (a3)
  {
    if (sub_1001255AC(a1, a2))
    {
LABEL_22:
      v7 = objc_autoreleasePoolPush();
      v8 = qword_10026DD20;
      if (qword_10026DD20)
      {
        v35 = (unint64_t)sub_10002B088(a2);
        v36 = a3;
        v9 = "%s: disabled for missing password Network %@ isFilteringAJCandidates %d";
        goto LABEL_27;
      }
      goto LABEL_29;
    }
  }
  else
  {
    if (sub_1000CA1F0((CFDictionaryRef *)a2))
    {
      v7 = objc_autoreleasePoolPush();
      v8 = qword_10026DD20;
      if (qword_10026DD20)
      {
        v35 = (unint64_t)sub_10002B088(a2);
        v36 = 0;
        v9 = "%s: disabled for Fully Loaded Network %@ isFilteringAJCandidates %d";
        goto LABEL_27;
      }
      goto LABEL_29;
    }
    if (sub_1001255AC(a1, a2))
      goto LABEL_22;
    if (sub_1000C5964((uint64_t)a2) && !sub_10002DAB4((uint64_t)a2) && !sub_1000C5BD8(a2))
    {
      v43 = 0;
      v32 = (const void *)sub_1000C6348((CFDictionaryRef *)a2, (BOOL *)&v43 + 1, 0.1);
      if (v32)
      {
        if (HIBYTE(v43))
          goto LABEL_35;
      }
      else
      {
        v32 = (const void *)sub_1000C64BC(a2, (BOOL *)&v43, 0.1);
        if (!v32)
        {
          v33 = HIBYTE(v43) | v43;
          v7 = objc_autoreleasePoolPush();
          if (!v33)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No password found for %@, return as unsuitable", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2), v36);
            goto LABEL_29;
          }
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Keychain fetch for %@ timed out, password presence unknown, ignoring", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2));
          objc_autoreleasePoolPop(v7);
          goto LABEL_35;
        }
        if ((_BYTE)v43)
          goto LABEL_35;
      }
      CFRelease(v32);
    }
  }
LABEL_35:
  v13 = sub_100027D10((uint64_t)a2);
  v41 = 0.0;
  v42 = 0;
  v14 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkTemporarilyDenyListedForAutoJoin:", v13);
  v15 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v13);
  v40 = v13;
  v16 = objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v13, &v42, &v41);
  if (a3)
    v17 = 0;
  else
    v17 = v15;
  v18 = v17 | v14;
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network '%@', isFilteringAJCandidates %d, isSSIDTemporarilyDenylisted %d, isBSSIDDenylisted %d, isTDDenylisted %d", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2), a3, v14, v15, v16);
  objc_autoreleasePoolPop(v19);
  v11 = (v18 | v16) ^ 1;
  if (a3)
  {
    if ((v16 & 1) != 0 || sub_10012596C(a1, a2))
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabled for non-TD, non-onDemand problematic Network %@ isFilteringAJCandidates %d", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2), 1);
      objc_autoreleasePoolPop(v20);
      v11 = 1;
    }
  }
  else
  {
    if (((v18 ^ 1 | v16) & 1) == 0)
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not considering problematic Network %@ isSSIDTemporarilyDenylisted %d isBSSIDDenylisted %d isFilteringAJCandidates %d isTDDenylisted %d", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2), v14, v15, 0, v16);
      goto LABEL_97;
    }
    if ((_DWORD)v16)
    {
      if (sub_100047970(*(_DWORD **)(a1 + 120), a2, v42, v41))
        v11 = 1;
      else
        v11 = v11;
    }
    if (sub_100125740(a1, a2))
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Use problematic network %@ for auto-join, as rssi improved", sub_10002B088(a2));
      objc_autoreleasePoolPop(v25);
      v11 = 1;
    }
    v26 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v27 = sub_10002A21C(a1, v26, 1);
    if (v27)
    {
      v28 = v27;
      if (!sub_10002DA5C((_BOOL8)v27) && CFEqual(v28, a2))
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping current network %@ as auto-join candidate", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2));
        objc_autoreleasePoolPop(v29);
        v11 = 0;
      }
      CFRelease(v28);
    }
  }
  if (((_os_feature_enabled_impl("WiFiManager", "AJPolicyTuning") ^ 1 | v16 | v18) & 1) != 0)
    goto LABEL_108;
  v21 = *(const void **)(a1 + 3512);
  if (v21
    && CFEqual(v21, a2)
    && !sub_100077740(*(_QWORD *)(a1 + 64))
    && !-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ previously disconnected network and no alternative network interface - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2));
    goto LABEL_106;
  }
  if (-[WiFiUserInteractionMonitor isPriorityNetwork:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isPriorityNetwork:", a2))
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: current network %@ is a Priority Network", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", sub_10002B088(a2));
    objc_autoreleasePoolPop(v22);
    if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Priority Network with no RT traffic - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34);
      goto LABEL_106;
    }
    v23 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
    v24 = objc_autoreleasePoolPush();
    if ((uint64_t)v23 >= -70)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Priority Network with RT traffic and Favorable RSSI - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34);
LABEL_106:
      v11 = 1;
      goto LABEL_107;
    }
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Priority Network with RT traffic and Unfavorable RSSI - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
  }
  else if (-[WiFiUserInteractionMonitor isPublicNetwork:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isPublicNetwork:", a2)|| sub_1000CB480((uint64_t)a2)&& -[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
  {
    v30 = objc_msgSend(*(id *)(a1 + 8976), "confidence");
    v31 = +[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance");
    if (v30 == (id)2)
    {
      if (-[WiFiUserInteractionMonitor isLowQualityNetwork:](v31, "isLowQualityNetwork:", a2))
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, High Confidence Settlement, Low Quality - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
      }
      else
      {
        if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive")|| !-[WiFiUserInteractionMonitor isCellularInexpensive5G](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularInexpensive5G"))
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, High Confidence Settlement, Ok Quality with no RT traffic or Expensive Cellular - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34);
          goto LABEL_106;
        }
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, High Confidence Settlement, Ok Quality with RT traffic and Inexpensive Cellular - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
      }
    }
    else if (-[WiFiUserInteractionMonitor isCarModeActive](v31, "isCarModeActive") || (*(_DWORD *)(a1 + 3352) | 2) == 6)
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, Low Confidence Settlement, Driving - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
    }
    else if (-[WiFiUserInteractionMonitor isLowQualityNetwork:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isLowQualityNetwork:", a2))
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, Low Confidence Settlement, Low Quality, Not Driving - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
    }
    else
    {
      if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive")|| !-[WiFiUserInteractionMonitor isCellularInexpensive5G](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularInexpensive5G"))
      {
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, Low Confidence Settlement, Ok Quality, Not Driving with no RT traffic or Expensive Cellular - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34);
        goto LABEL_106;
      }
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Public, Carrier (no cellular), or Outdoor Network, Low Confidence Settlement, Ok Quality, Not Driving with RT traffic and Inexpensive Cellular - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
    }
  }
  else
  {
    if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive")|| !-[WiFiUserInteractionMonitor isCellularInexpensive5G](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularInexpensive5G"))
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Non-Public, Non-Carrier (or cellular available), Non-Outdoor Network, with RT traffic and Inexpensive Cellular - ok to autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34);
      goto LABEL_106;
    }
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Non-Public, Non-Carrier (or cellular available), Non-Outdoor Network, with RT traffic and Inexpensive Cellular - defer autojoin", "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v34, v36, v37, v38, v39);
  }
LABEL_97:
  v11 = 0;
LABEL_107:
  objc_autoreleasePoolPop(v24);
LABEL_108:
  if (v40)

LABEL_30:
  objc_autoreleasePoolPop(v6);
  return v11;
}

const __CFNumber *sub_1001255AC(uint64_t a1, const void *a2)
{
  const void *v4;
  const void *v5;
  const __CFNumber *result;
  void *v7;
  void *v8;
  void *v9;
  double valuePtr;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiDeviceManagerIsNetworkInMissingPasswordList");
    goto LABEL_20;
  }
  if (!*(_QWORD *)(a1 + 3680))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networksMissingPassword", "__WiFiDeviceManagerIsNetworkInMissingPasswordList");
    goto LABEL_20;
  }
  v4 = sub_10002B088(a2);
  if (!v4)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssid", "__WiFiDeviceManagerIsNetworkInMissingPasswordList");
LABEL_20:
    v8 = v9;
LABEL_11:
    objc_autoreleasePoolPop(v8);
    return 0;
  }
  v5 = v4;
  valuePtr = 0.0;
  result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 3680), v4);
  if (result)
  {
    CFNumberGetValue(result, kCFNumberDoubleType, &valuePtr);
    if (CFAbsoluteTimeGetCurrent() - valuePtr > 86400.0
      || sub_10000BE8C((uint64_t)a2) && *(_DWORD *)(a1 + 5520) == 1)
    {
      sub_100125A48(a1, a2, 0);
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unblacklisting network %@", "__WiFiDeviceManagerIsNetworkInMissingPasswordList", v5);
      v8 = v7;
      goto LABEL_11;
    }
    return (const __CFNumber *)1;
  }
  return result;
}

uint64_t sub_100125740(uint64_t a1, void *a2)
{
  void *v4;
  id v5;
  id v6;
  const __CFNumber *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerHasNetworkRssiImproved", v15, v16, v17);
    goto LABEL_14;
  }
  if (*(_DWORD *)(a1 + 168) != 2)
  {
LABEL_15:
    v10 = 0;
    goto LABEL_16;
  }
  v5 = sub_100027D10((uint64_t)a2);
  if ((objc_msgSend(*(id *)(a1 + 6648), "isNetworkInDenyListedState:scanResult:", 1, v5) & 1) == 0)
  {

LABEL_12:
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid scannedRssi", "__WiFiDeviceManagerHasNetworkRssiImproved", v15, v16, v17);
    goto LABEL_14;
  }
  v6 = objc_msgSend(*(id *)(a1 + 6648), "RSSIWhenNetworkWasDenyListed:", v5);
  v7 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));

  if (!(_DWORD)v7)
    goto LABEL_12;
  if (!(_DWORD)v6)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid denyListedRssi", "__WiFiDeviceManagerHasNetworkRssiImproved", v15, v16, v17);
    goto LABEL_14;
  }
  v18 = 0;
  v8 = sub_100125CA4(a1, a2, 1, &v18);
  if ((int)v8 > (int)v7)
  {
    v13 = v8;
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if ((v18 - 1) > 3)
        v14 = 0;
      else
        v14 = off_100232250[v18 - 1];
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scannedRssi %d below threshold %d (%@)", "__WiFiDeviceManagerHasNetworkRssiImproved", v7, v13, v14);
    }
LABEL_14:
    objc_autoreleasePoolPop(v11);
    goto LABEL_15;
  }
  if ((int)v7 - (int)v6 < 10)
    goto LABEL_15;
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: allow problematic network %@ for auto-join (rssi: %d(%d))", "__WiFiDeviceManagerHasNetworkRssiImproved", sub_10002B088(a2), v7, v6);
  objc_autoreleasePoolPop(v9);
  v10 = 1;
LABEL_16:
  objc_autoreleasePoolPop(v4);
  return v10;
}

uint64_t sub_10012596C(uint64_t a1, const void *a2)
{
  const __CFNumber *v3;
  void *v4;
  uint64_t v5;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 168) != 2)
      return 0;
    v3 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI-based unblacklisting: including %@ (rssi=%d) for scan.", sub_10002B088(a2), v3);
    v5 = 1;
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerIsRssiBasedUnblacklistingAllowed");
    v5 = 0;
  }
  objc_autoreleasePoolPop(v4);
  return v5;
}

void sub_100125A48(uint64_t a1, const void *a2, int a3)
{
  const void *v5;
  const void *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  CFAbsoluteTime valuePtr;

  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiDeviceManagerManageMissingPasswordList");
    goto LABEL_22;
  }
  if (!a2)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "__WiFiDeviceManagerManageMissingPasswordList");
    goto LABEL_22;
  }
  if (!*(_QWORD *)(a1 + 3680))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networksMissingPassword", "__WiFiDeviceManagerManageMissingPasswordList");
    goto LABEL_22;
  }
  v5 = sub_10002B088(a2);
  if (!v5)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssid", "__WiFiDeviceManagerManageMissingPasswordList");
LABEL_22:
    objc_autoreleasePoolPop(v12);
    return;
  }
  v6 = v5;
  if (a3)
  {
    valuePtr = CFAbsoluteTimeGetCurrent();
    v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
    if (v7)
    {
      v8 = v7;
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 3680), v6, v7);
      CFRelease(v8);
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Added %@ at %f", "__WiFiDeviceManagerManageMissingPasswordList", v6, *(_QWORD *)&valuePtr);
      v10 = v9;
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null originTimeNum", "__WiFiDeviceManagerManageMissingPasswordList");
      v10 = v13;
    }
    objc_autoreleasePoolPop(v10);
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Remove %@, added at %@", "__WiFiDeviceManagerManageMissingPasswordList", v6, CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 3680), v6));
    objc_autoreleasePoolPop(v11);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 3680), v6);
  }
}

uint64_t sub_100125CA4(uint64_t a1, void *a2, int a3, int *a4)
{
  uint64_t v8;
  const __CFArray *v9;
  const __CFArray *v10;
  int v11;
  int v12;
  unsigned int *v13;
  int v14;
  CFDataRef v15;
  CFDataRef v16;
  void *v18;
  UInt8 bytes[4];
  unsigned int v20;
  int v21;

  v8 = *(unsigned int *)(a1 + 128);
  v9 = sub_10002B170(a1, a2, 1);
  if (v9)
  {
    v10 = v9;
    v11 = sub_1000FEEC0(a1, v9);
    if (sub_1000CBE60((uint64_t)v10) != 1
      && sub_1000C3F88((uint64_t)v10) != 1
      && *(_DWORD *)(a1 + 144) < v11)
    {
      v12 = *(_DWORD *)(a1 + 3352);
      if (v12 == 6)
      {
        v13 = (unsigned int *)(a1 + 140);
        v14 = 2;
        goto LABEL_12;
      }
      if (v12 == 4)
      {
        v13 = (unsigned int *)(a1 + 140);
        v14 = 1;
        goto LABEL_12;
      }
      if (sub_1000CB8DC((CFDictionaryRef *)a2)
        || objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isMovingNetwork:", a2))
      {
        v13 = (unsigned int *)(a1 + 132);
        v14 = 3;
        goto LABEL_12;
      }
      if (sub_1000CB87C((CFDictionaryRef *)a2)
        || objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isOmnipresentNetwork:", a2))
      {
        v13 = (unsigned int *)(a1 + 132);
        v14 = 4;
LABEL_12:
        v8 = *v13;
        if (!a4)
          goto LABEL_19;
        goto LABEL_18;
      }
    }
    v14 = 0;
    if (!a4)
    {
LABEL_19:
      if (!a3 || (uint64_t)sub_100017A54((uint64_t)a2, CFSTR("RSSI")) >= (int)v8)
        goto LABEL_24;
      if (*(_QWORD *)(a1 + 6160))
      {
        *(_DWORD *)bytes = v14;
        v20 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
        v21 = v11;
        v15 = CFDataCreate(kCFAllocatorDefault, bytes, 12);
        if (v15)
        {
          v16 = v15;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6160), v15);
          CFRelease(v16);
LABEL_24:
          CFRelease(v10);
          return v8;
        }
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null dataRef", "__WiFiDeviceManagerGetAutoJoinThreshold");
      }
      else
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null excludedDueToAJThresholdThisSession", "__WiFiDeviceManagerGetAutoJoinThreshold");
      }
      objc_autoreleasePoolPop(v18);
      goto LABEL_24;
    }
LABEL_18:
    *a4 = v14;
    goto LABEL_19;
  }
  return v8;
}

void sub_100125EC4(uint64_t a1)
{
  void *v1;

  if (!a1)
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL manager", "__WiFiDeviceManagerIsMIS5GhzEnabled");
    objc_autoreleasePoolPop(v1);
  }
}

void sub_100125F24(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void (*v4)(uint64_t, unsigned int *, unsigned __int8 *, _QWORD);
  void *v5;
  uint64_t v6;
  void *v7;
  unsigned int v8;
  unsigned __int8 v9;

  v9 = 0;
  v8 = 0;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(void (**)(uint64_t, unsigned int *, unsigned __int8 *, _QWORD))(v3 + 4536);
    if (v4)
    {
      v4(v3, &v8, &v9, *(_QWORD *)(v3 + 4544));
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s BatteryInfo. batterylevel:%u. externalPowerSupply:%u", "__WiFiDeviceManagerCreateNetworkDenyList_block_invoke", v8, v9);
      objc_autoreleasePoolPop(v5);
      v6 = 1;
      if (!a2)
        return;
LABEL_10:
      (*(void (**)(uint64_t, uint64_t, BOOL, _QWORD))(a2 + 16))(a2, v6, v9 != 0, v8);
      return;
    }
  }
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Callbacks not available ", "__WiFiDeviceManagerCreateNetworkDenyList_block_invoke");
  objc_autoreleasePoolPop(v7);
  v6 = 0;
  if (a2)
    goto LABEL_10;
}

uint64_t sub_100126024(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(a2 + 16))(a2, 1, *(_DWORD *)(*(_QWORD *)(result + 32) + 176) == 1);
  return result;
}

void sub_10012604C(uint64_t a1, uint64_t a2)
{
  sub_1000F8630(*(_QWORD *)(a1 + 32));
  sub_1001233EC(*(_QWORD *)(a1 + 32));
  if (a2)
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1);
}

void sub_100126098(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  const void *v7;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v2 + 240))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, _QWORD, const __CFString *, const CFBooleanRef, _QWORD))(v2 + 4744))(v2, *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24), CFSTR("FailureCountCurrent"), kCFBooleanTrue, *(_QWORD *)(v2 + 4752));
    CFRelease(v3[1]);
    v5 = *v3;
  }
  else
  {
    CFRelease((CFTypeRef)v2);
    v6 = *(_QWORD **)(a1 + 32);
    v3 = (CFTypeRef *)(a1 + 32);
    v5 = v6;
  }
  v7 = *(const void **)(v5[1] + 24);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(*((_QWORD *)*v3 + 1) + 24) = 0;
  }
}

uint64_t sub_100126120(uint64_t a1, const void *a2)
{
  uint64_t result;
  const __CFArray *v5;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFRange v8;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      v5 = *(const __CFArray **)(a1 + 3528);
      if (!v5)
        return sub_10002A724(a1, a2);
      v8.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
      v8.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v5, v8, a2);
      if (FirstIndexOfValue == -1)
        return sub_10002A724(a1, a2);
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
      if (!ValueAtIndex)
        return sub_10002A724(a1, a2);
      result = sub_10002A724(a1, ValueAtIndex);
      if (!(_DWORD)result)
        return sub_10002A724(a1, a2);
    }
  }
  return result;
}

void sub_1001261B8(uint64_t a1)
{
  void *v2;

  sub_1000247B8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 120), 0, 0);
  SCNetworkInterfaceSetPrimaryRank(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 5464), *(unsigned int *)(a1 + 48));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting interface rank %s for network %@", "__WiFiDeviceManagerSetInterfaceRank_block_invoke", "kSCNetworkServicePrimaryRankDefault", sub_10002B088(*(const void **)(a1 + 40)));
  objc_autoreleasePoolPop(v2);
}

void sub_100126258(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void (*v5)(_QWORD *, _QWORD, _QWORD, uint64_t, _QWORD);
  const void *v6;
  const void *v7;
  const void *v8;
  _QWORD *v9;
  uint64_t v10;

  v2 = a1[6];
  if (*(_QWORD *)(v2 + 240))
  {
    v3 = a1 + 5;
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v2 + 4040))(v2, *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24), *(_QWORD *)(v2 + 4048), *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    v4 = (_QWORD *)a1[6];
    v5 = (void (*)(_QWORD *, _QWORD, _QWORD, uint64_t, _QWORD))v4[549];
    if (v5)
    {
      v5(v4, a1[7], v4[550], 1, 0);
      v4 = (_QWORD *)a1[6];
    }
    CFRelease(v4);
    v6 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
    }
    v7 = *(const void **)(*(_QWORD *)(*v3 + 8) + 24);
    if (!v7)
      return;
LABEL_12:
    CFRelease(v7);
    *(_QWORD *)(*(_QWORD *)(*v3 + 8) + 24) = 0;
    return;
  }
  CFRelease((CFTypeRef)v2);
  v8 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
  }
  v10 = a1[5];
  v9 = a1 + 5;
  v7 = *(const void **)(*(_QWORD *)(v10 + 8) + 24);
  if (v7)
  {
    v3 = v9;
    goto LABEL_12;
  }
}

void sub_10012634C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  unsigned __int16 v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  const __CFNumber *v19;
  __int16 v20;
  int v21;
  double v22;
  double v23;
  double v24;
  int v25;
  const char *v26;
  int v27;
  unsigned __int16 v28;
  double v29;
  __int128 v30;
  int64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  void *v39;
  const char *v40;
  void *v41;
  void *v42;
  __int16 valuePtr;
  _BYTE v44[24];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;

  if (!*(_BYTE *)(a1 + 940))
    return;
  v8 = (unsigned __int16)sub_1000C6B54(a2);
  v9 = sub_100008CEC(a2);
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0u;
  LODWORD(v45) = (CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 736));
  LODWORD(v52) = a4;
  v10 = sub_100064AA8(a3);
  v11 = CFSTR("unknown");
  if (v10)
    v11 = v10;
  *((_QWORD *)&v51 + 1) = v11;
  if ((v8 & 0x100) != 0)
  {
    v12 = CFSTR("11ax");
  }
  else if ((v8 & 0x80) != 0)
  {
    v12 = CFSTR("11ac");
  }
  else if ((v8 & 0x10) != 0)
  {
    v12 = CFSTR("11n");
  }
  else
  {
    v12 = CFSTR("legacy");
  }
  *((_QWORD *)&v52 + 1) = v12;
  WORD5(v50) = v9;
  *(_QWORD *)v44 = CFSTR("Unknown");
  *(_QWORD *)&v44[8] = CFSTR("Unknown");
  *(_QWORD *)&v44[16] = CFSTR("Unknown");
  if (*(_QWORD *)(a1 + 8768))
  {
    *(_QWORD *)v44 = *(_QWORD *)(a1 + 8768);
    *(_OWORD *)&v44[8] = *(_OWORD *)(a1 + 8776);
  }
  *(_QWORD *)((char *)&v45 + 4) = *(_QWORD *)(a1 + 744);
  v13 = (int)*(double *)(a1 + 760);
  HIDWORD(v45) = *(_DWORD *)(a1 + 752);
  LODWORD(v46) = v13;
  DWORD1(v46) = *(_DWORD *)(a1 + 756);
  *((_QWORD *)&v46 + 1) = *(_QWORD *)(a1 + 768);
  v14 = *(_DWORD *)(a1 + 776);
  LODWORD(v47) = (int)*(double *)(a1 + 784);
  DWORD1(v47) = v14;
  *((_QWORD *)&v47 + 1) = *(_QWORD *)(a1 + 792);
  v15 = *(_DWORD *)(a1 + 800);
  LODWORD(v48) = (int)*(double *)(a1 + 808);
  DWORD1(v48) = v15;
  *((_QWORD *)&v48 + 1) = *(_QWORD *)(a1 + 816);
  v16 = *(_DWORD *)(a1 + 824);
  LODWORD(v49) = (int)*(double *)(a1 + 832);
  DWORD1(v49) = v16;
  *((_QWORD *)&v49 + 1) = *(_QWORD *)(a1 + 840);
  v17 = *(_DWORD *)(a1 + 848);
  LODWORD(v50) = (int)*(double *)(a1 + 856);
  DWORD1(v50) = v17;
  if (*(_DWORD *)(a1 + 884))
    v18 = 1;
  else
    v18 = 5;
  HIDWORD(v50) = *(_DWORD *)(a1 + 864);
  LODWORD(v51) = v18;
  v19 = (const __CFNumber *)sub_1000316E0(a2);
  if (v19)
  {
    valuePtr = -21846;
    CFNumberGetValue(v19, kCFNumberSInt16Type, &valuePtr);
    v20 = valuePtr;
  }
  else
  {
    v20 = 0;
  }
  WORD4(v50) = v20;
  *(_QWORD *)(a1 + 1048) = 0;
  if (*(_BYTE *)(a1 + 1008))
  {
    if (*(double *)(a1 + 832) <= 60.0)
    {
      v21 = *(_DWORD *)(a1 + 752);
      if (v21)
      {
        v22 = 1.0 / (double)v21;
        v23 = v22
            * (double)(8
                     * (unint64_t)((double)(800
                                                 * (unint64_t)((double)*(unint64_t *)(a1 + 944) * 0.95))
                                        * 1.87));
        v24 = v23 / (double)(1000 * v45);
        if ((v8 & 0x100) != 0)
        {
          if (v9 == 80 && v21 > 600500)
            goto LABEL_44;
          if (v9 == 20)
          {
            v27 = 143400;
          }
          else
          {
            if (v9 != 40)
              goto LABEL_45;
            v27 = 286800;
          }
          goto LABEL_43;
        }
        if ((v8 & 0x80) != 0)
        {
          if (v9 == 80 && v21 > 433300)
            goto LABEL_44;
          if (v9 != 20)
          {
            if (v9 != 40)
              goto LABEL_45;
            v27 = 200000;
            goto LABEL_43;
          }
          v28 = 21164;
        }
        else
        {
          if ((v8 & 0x10) == 0)
          {
            v25 = 0;
            v26 = "N";
LABEL_47:
            v39 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v40 = "Y";
              if (!v25)
                v40 = "N";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LPC - valid %s, rssi %.1lf, txRateMax %d, totalTxFrames %llu, bitAirTime %.4lf (us), totalAirTime %.2lf (ms), txDutyCycle %.3lf (%%), phyMode %@, isMimo %s, duration %d (s), power reduction %.2lf (uAh), txoffset %d:%d:%d:%d (%%)", "__WiFiDeviceManagerSubmitCarPlayLinkQualityMetrics", v26, *(_QWORD *)(a1 + 832), *(unsigned int *)(a1 + 752), *(_QWORD *)(a1 + 944), v22 * 1000.0, *(_QWORD *)&v23, v24 * 100.0, *((_QWORD *)&v52 + 1), v40, v45, *(_QWORD *)(a1 + 1048), *(unsigned int *)(a1 + 1024),
                *(unsigned int *)(a1 + 1028),
                *(unsigned int *)(a1 + 1032),
                *(unsigned int *)(a1 + 1036));
            }
            objc_autoreleasePoolPop(v39);
            goto LABEL_52;
          }
          if (v9 == 40 && v21 > 150000)
            goto LABEL_44;
          if (v9 != 20)
            goto LABEL_45;
          v28 = 6664;
        }
        v27 = v28 | 0x10000;
LABEL_43:
        if (v21 > v27)
        {
LABEL_44:
          v25 = 1;
          v29 = 40.0;
LABEL_46:
          v30 = *(_OWORD *)(a1 + 1024);
          v31.i64[0] = SDWORD2(v30);
          v31.i64[1] = SHIDWORD(v30);
          v32 = vcvtq_f64_s64(v31);
          v31.i64[0] = (int)v30;
          v31.i64[1] = SDWORD1(v30);
          v33 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
          v34 = vdivq_f64(vcvtq_f64_s64(v31), v33);
          v35 = vdivq_f64(v32, v33);
          v36 = vmulq_n_f64((float64x2_t)xmmword_1001BBC40, v29);
          v37 = vmulq_f64(v35, vmulq_n_f64((float64x2_t)xmmword_1001BBC50, v29));
          v38 = vmulq_f64(v34, v36);
          v37.f64[0] = v24 * (v38.f64[0] + 0.0 + v38.f64[1] + v37.f64[0] + v37.f64[1]) * 1000.0;
          *(float64_t *)(a1 + 1048) = v37.f64[0];
          LOBYTE(v53) = 1;
          *((_QWORD *)&v53 + 1) = *(_QWORD *)(a1 + 1016);
          v54 = *(_OWORD *)(a1 + 1024);
          *((_QWORD *)&v55 + 1) = *(_QWORD *)&v37.f64[0];
          v26 = "Y";
          goto LABEL_47;
        }
LABEL_45:
        v25 = 0;
        v29 = 20.0;
        goto LABEL_46;
      }
    }
  }
LABEL_52:
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v42 = v41;
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rssi(max:min:avg:last) %d:%d:%d:%d, snr %d:%d:%d:%d, cca %d:%d:%d:%d, txRate %d:%d:%d:%d, rxRate %d:%d:%d:%d, numberOfTxErrorEvents %u, channel %d, bandwidth %u, linkDuration %u, roamedCount %u, linkDownReason %@, linkDownSubReason %d, lqmInterval %u, vehicleModel %@, vehicleManufacturer %@, hardwareVersion %@, phyMode %@", "__WiFiDeviceManagerSubmitCarPlayLinkQualityMetrics", HIDWORD(v48), DWORD2(v48), v49, DWORD1(v49), HIDWORD(v47), DWORD2(v47), v48, DWORD1(v48), HIDWORD(v49), DWORD2(v49), v50, DWORD1(v50),
      HIDWORD(v45),
      DWORD2(v45),
      v46,
      DWORD1(v46),
      HIDWORD(v46),
      DWORD2(v46),
      v47,
      DWORD1(v47),
      HIDWORD(v50),
      SWORD4(v50),
      WORD5(v50),
      v45,
      DWORD1(v45),
      *((_QWORD *)&v51 + 1),
      v52,
      v51,
      *(_OWORD *)v44,
      *(_QWORD *)&v44[16],
      *((_QWORD *)&v52 + 1));
    v41 = v42;
  }
  objc_autoreleasePoolPop(v41);
  sub_100061F78((uint64_t)v44);
}

void sub_100126964(uint64_t a1, void *a2)
{
  _BOOL8 v3;

  if (a2)
  {
    v3 = sub_100077738(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)) != 1;
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setLinkEvent:isInvoluntary:linkChangeReason:linkChangeSubreason:withNetworkDetails:forInterface:", 1, v3, 0, 0, a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

void sub_1001269DC(uint64_t a1, const void *a2)
{
  __int16 v4;
  const void *v5;
  uint64_t v6;
  int v7;

  if (*(_BYTE *)(a1 + 7056))
  {
    if (a2)
    {
      if (sub_1000CB480((uint64_t)a2)
        || sub_1000C5378((uint64_t)a2)
        || sub_10002DAB4((uint64_t)a2)
        || sub_1000C475C((uint64_t)a2)
        || sub_10001F440(a2))
      {
        return;
      }
      v7 = sub_10003153C((uint64_t)a2);
      if (v7)
        v4 = 1 << v7;
      else
        v4 = 0;
      v6 = *(_QWORD *)(a1 + 64);
      v5 = sub_10002B088(a2);
    }
    else
    {
      v4 = 0;
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 64);
    }
    sub_10006A75C(v6, 0, v4, v5);
  }
}

void sub_100126AA4(uint64_t a1, void *a2)
{
  if (a2)
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setLinkEvent:isInvoluntary:linkChangeReason:linkChangeSubreason:withNetworkDetails:forInterface:", 0, *(_BYTE *)(a1 + 52) != 0, *(_QWORD *)(a1 + 40), *(int *)(a1 + 48), a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

void sub_100126B1C(uint64_t a1)
{
  void *v2;
  const void *v3;
  void *v4;

  if (*(_QWORD *)(a1 + 120))
  {
    if (*(_QWORD *)(a1 + 5560))
    {
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignore Pending Active Probe !");
      objc_autoreleasePoolPop(v2);
      sub_100046514(*(_QWORD *)(a1 + 120), *(CFTypeRef *)(a1 + 5560));
      v3 = *(const void **)(a1 + 5560);
      if (v3)
      {
        CFRelease(v3);
        *(_QWORD *)(a1 + 5560) = 0;
      }
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Null LQA manager\n");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_100126BCC(uint64_t a1, const __CFDictionary **a2)
{
  const void *v4;
  const void *v5;
  CFBooleanRef v6;
  const __CFDictionary *v7;
  const __CFNumber *Value;
  BOOL v9;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  const __CFArray *v18;
  CFIndex Count;

  if (!sub_1001084C4(a1) && !sub_100071760(*(_QWORD *)(a1 + 64)))
    return 1;
  v4 = sub_10002B634(*(const __CFArray **)(a1 + 3704), a2);
  if (!v4)
    return 1;
  v5 = v4;
  v6 = (CFBooleanRef)sub_10002BE64((uint64_t)v4, CFSTR("NetworkUsedForSWUpgrade"));
  v7 = (const __CFDictionary *)sub_10002BE64((uint64_t)v5, CFSTR("PRIVATE_MAC_ADDRESS"));
  if (!v7)
    return 1;
  Value = (const __CFNumber *)CFDictionaryGetValue(v7, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
  if (!Value)
    return 1;
  v9 = sub_100064F80(Value) != 1 || v6 == 0;
  if (v9 || v6 != kCFBooleanTrue)
    return 1;
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Forcing associated while sleep to return FALSE for current network <%@>", "__WiFiDeviceManagerNetworkIsQualifiedForAssociatedSleep", sub_10002B088(v5));
  objc_autoreleasePoolPop(v12);
  v13 = objc_autoreleasePoolPush();
  v14 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v15 = sub_10002B088(a2);
    v16 = sub_1001084C4(a1);
    v17 = sub_100071760(*(_QWORD *)(a1 + 64));
    v18 = *(const __CFArray **)(a1 + 3584);
    if (v18)
      Count = CFArrayGetCount(v18);
    else
      Count = -1;
    objc_msgSend(v14, "WFLog:message:", 3, "%s: network %@ not qualified for associated sleep: WoW=%d LPAS=%d BgScanCandidateCount=%ld privateMacAssociatedWhileSleepIsOK = %hhu", "__WiFiDeviceManagerNetworkIsQualifiedForAssociatedSleep", v15, v16, v17, Count, 0);
  }
  objc_autoreleasePoolPop(v13);
  return 0;
}

void sub_100126D50(int a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  const __CFBoolean *Value;
  const __CFBoolean *v9;
  int v10;
  void *v11;
  const char *v12;
  const char *v13;
  void (*v14)(uint64_t, uint64_t, _QWORD, CFDictionaryRef);
  void *v15;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v17;
  CFBooleanRef v18;

  if (!theDict || !a5)
    return;
  Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("LINK_CHANGED_IS_AVAILABLE"));
  if (!Value)
  {
    v14 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a5 + 4440);
    if (!v14)
      return;
    goto LABEL_21;
  }
  v9 = Value;
  v10 = CFBooleanGetValue(Value);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v12 = "TRUE";
    if (v10)
      v13 = "TRUE";
    else
      v13 = "FALSE";
    if (!*(_BYTE *)(a5 + 5429))
      v12 = "FALSE";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL availability changed to %s, pendingRequest %s", "__WiFiDeviceManagerAwdlAvailableCallback", v13, v12);
  }
  objc_autoreleasePoolPop(v11);
  v14 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a5 + 4440);
  if (v14)
  {
    if (*(_QWORD *)(a5 + 5408))
    {
      v15 = objc_autoreleasePoolPush();
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
      if (MutableCopy)
      {
        v17 = MutableCopy;
        if (!objc_msgSend(*(id *)(a5 + 5408), "isPowerResourceAvailable:", 1)
          || (v18 = kCFBooleanTrue, !CFEqual(v9, kCFBooleanTrue)))
        {
          v18 = kCFBooleanFalse;
        }
        CFDictionarySetValue(v17, CFSTR("LINK_CHANGED_IS_AVAILABLE"), v18);
        objc_autoreleasePoolPop(v15);
        (*(void (**)(uint64_t, uint64_t, _QWORD, __CFDictionary *))(a5 + 4440))(a5, a2, *(_QWORD *)(a5 + 4448), v17);
        CFRelease(v17);
        return;
      }
      objc_autoreleasePoolPop(v15);
      v14 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a5 + 4440);
    }
LABEL_21:
    v14(a5, a2, *(_QWORD *)(a5 + 4448), theDict);
  }
}

void sub_100126F1C(int a1, const void *a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  BOOL *v8;
  const void *Value;
  int v10;
  int v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void (*v16)(uint64_t, const void *, _QWORD, CFDictionaryRef);
  void (*v17)(uint64_t, const void *, _QWORD, uint64_t, CFDictionaryRef);
  void *v18;

  if (theDict && a5)
  {
    v8 = (BOOL *)(a5 + 5428);
    Value = CFDictionaryGetValue(theDict, CFSTR("LINK_CHANGED_IS_LINKDOWN"));
    if (Value)
    {
      v10 = CFEqual(Value, kCFBooleanTrue);
      v11 = *(_DWORD *)(a5 + 5424);
      if (v10)
      {
        if (v11)
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL link-down received when refCount is %d", "__WiFiDeviceManagerAwdlLinkEventCallback", *(unsigned int *)(a5 + 5424));
          objc_autoreleasePoolPop(v12);
          if (!*(_BYTE *)(a5 + 5429)
            && (objc_msgSend(+[WiFiP2PAWDLState currentState](WiFiP2PAWDLState, "currentState"), "isEnabled") & 1) == 0)
          {
            v13 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL link-down tearing down all active AWDL sessions", "__WiFiDeviceManagerAwdlLinkEventCallback");
            objc_autoreleasePoolPop(v13);
            sub_1000FB00C(a5, a2);
          }
        }
      }
      else if (v11)
      {
        kdebug_trace(731381788, 0, 0, 0, 0);
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: AWDL link up, refcount %d", "__WiFiDeviceManagerAwdlLinkEventCallback", *(unsigned int *)(a5 + 5424));
        objc_autoreleasePoolPop(v14);
      }
      v15 = *(void **)(a5 + 7368);
      if (v15)
        objc_msgSend(v15, "setAwdlState:inMode:", v10 == 0, 0);
    }
    else
    {
      v10 = 1;
    }
    sub_1000F9DAC((char *)a5, 2, v10 == 0);
    v16 = *(void (**)(uint64_t, const void *, _QWORD, CFDictionaryRef))(a5 + 4440);
    if (v16)
      v16(a5, a2, *(_QWORD *)(a5 + 4448), theDict);
    v17 = *(void (**)(uint64_t, const void *, _QWORD, uint64_t, CFDictionaryRef))(a5 + 4392);
    if (v17)
      v17(a5, a2, *(_QWORD *)(a5 + 4400), 3, theDict);
    if (v10 && *v8)
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hosted AWDL session is down. Triggering auto-join", "__WiFiDeviceManagerAwdlLinkEventCallback");
      objc_autoreleasePoolPop(v18);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000285E4(a5, 9uLL);
      }
      else
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinStartedWithTrigger:interfaceName:", 9, sub_100025C3C(*(_QWORD *)(a5 + 64)));
        sub_1000FBA80(a5, 0, (uint64_t)"__WiFiDeviceManagerAwdlLinkEventCallback");
      }
    }
    *v8 = v10 == 0;
  }
}

void sub_1001271CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  const __CFString *v7;
  __CFDictionary *v8;
  __CFDictionary *v9;
  __CFDictionary *MutableCopy;
  const void **v11;
  void (*v12)(uint64_t, int64_t, _QWORD, __CFDictionary *);
  int64_t v13;
  CFAbsoluteTime Current;
  CFDateRef v15;
  CFDateRef v16;
  const void *v17;
  void *v18;
  const void *v19;

  if (a3)
  {
    if (*(unsigned __int8 *)(a3 + 3414) != (_DWORD)a2)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AwdlRealTime: Before %d, Now %d", "__WiFiDeviceManagerAwdlRealTimeModeEventCallback", *(unsigned __int8 *)(a3 + 3414), a2);
      objc_autoreleasePoolPop(v5);
      *(_BYTE *)(a3 + 3414) = a2;
      -[WiFiUsageMonitor updateRealTimeCoex:type:reasons:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "updateRealTimeCoex:type:reasons:", (_DWORD)a2 != 0, 0, objc_msgSend(objc_msgSend(objc_alloc_init((Class)WiFiP2PAWDLStateMonitor), "copyActiveServiceUniqueIdentifiers"), "sortedArrayUsingSelector:", "localizedCaseInsensitiveCompare:"));
      if ((_DWORD)a2 && sub_1001076C4(a3) && *(_BYTE *)(a3 + 5219) && *(unsigned __int8 *)(a3 + 5216) >= 0xFu)
        sub_100103E6C(a3, 0);
      sub_100048CC0(*(_QWORD *)(a3 + 120), *(_BYTE *)(a3 + 3414));
      if (+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"))
        objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "setAwdlRealTimeModeActive:", *(_BYTE *)(a3 + 3414) != 0);
      if (sub_10007946C(*(_QWORD *)(a3 + 64)) && !sub_1001158FC(a3))
      {
        if (!(_DWORD)a2 && CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 3728) > 60.0)
        {
          sub_10010A578(a3, 0);
          *(CFAbsoluteTime *)(a3 + 3728) = CFAbsoluteTimeGetCurrent();
        }
      }
      else if (!(_DWORD)a2)
      {
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000285E4(a3, 0x39uLL);
        }
        else if (*(_BYTE *)(a3 + 3411))
        {
          sub_1000FA0A0(a3, 3);
        }
        else
        {
          sub_1000FBA80(a3, 2, (uint64_t)"__WiFiDeviceManagerAwdlRealTimeModeEventCallback");
        }
      }
      sub_1000F9DAC((char *)a3, 2, a2);
      v7 = (const __CFString *)sub_100068E60(*(_QWORD *)(a3 + 64));
      v8 = sub_100109D00(a3, v7);
      if (v8)
      {
        v9 = v8;
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v8);
        CFRelease(v9);
        if (MutableCopy)
        {
          v11 = (const void **)&kCFBooleanTrue;
          if (!(_DWORD)a2)
            v11 = (const void **)&kCFBooleanFalse;
          CFDictionarySetValue(MutableCopy, CFSTR("AWDL_REAL_TIME_MODE"), *v11);
          v12 = *(void (**)(uint64_t, int64_t, _QWORD, __CFDictionary *))(a3 + 4440);
          if (v12)
          {
            v13 = sub_100068E60(*(_QWORD *)(a3 + 64));
            v12(a3, v13, *(_QWORD *)(a3 + 4448), MutableCopy);
          }
          CFRelease(MutableCopy);
        }
      }
      if ((_DWORD)a2)
      {
        Current = CFAbsoluteTimeGetCurrent();
        v15 = CFDateCreate(kCFAllocatorDefault, Current);
        if (v15)
        {
          v16 = v15;
          v17 = (const void *)sub_100025C3C(*(_QWORD *)(a3 + 64));
          v18 = sub_10002A21C(a3, v17, 1);
          if (v18)
          {
            v19 = v18;
            sub_1000C79E0(v18, v16);
            sub_1001053C8((NSObject **)a3, v19);
            CFRelease(v19);
          }
          CFRelease(v16);
        }
        sub_100127948(a3);
      }
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL Device Manager !", "__WiFiDeviceManagerAwdlRealTimeModeEventCallback");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_100127540(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v8;
  void (*v9)(uint64_t, uint64_t, _QWORD, uint64_t);

  if (a3 && a5)
  {
    if (*(_DWORD *)(a5 + 5424))
    {
      kdebug_trace(731381792, 0, 0, 0, 0);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: peer list changed", "__WiFiDeviceManagerAwdlPeerPresenceCallback");
      objc_autoreleasePoolPop(v8);
    }
    v9 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a5 + 4440);
    if (v9)
      v9(a5, a2, *(_QWORD *)(a5 + 4448), a3);
  }
}

void sub_100127608(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  const __CFArray *v8;
  const __CFArray *v9;
  int Count;
  CFIndex v11;
  uint64_t v12;
  const void *ValueAtIndex;
  const void *v14;
  const __CFNumber *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  int v18;
  int valuePtr;

  v5 = objc_autoreleasePoolPush();
  if (a3)
  {
    v6 = (unsigned __int8 *)(a3 + 5216);
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Channel %d  %d", "__WiFiDeviceManagerSoftAPChannelChangedEventCallback", a2, *v6);
    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a3 + 5219))
    {
      v7 = *v6;
      if (v7 != (_DWORD)a2 && (a2 >= 0xF && v7 > 0xE || a2 <= 0xD && v7 <= 0xD))
      {
        *v6 = a2;
        CFSetAddValue(*(CFMutableSetRef *)(a3 + 5272), CFSTR("wifid"));
        sub_100107DE4(a3, 0);
        sub_10006A2DC(*(_QWORD *)(a3 + 64), 0);
        sub_1001074BC(a3, 5);
        v8 = sub_100109C30(a3);
        if (v8)
        {
          v9 = v8;
          valuePtr = -1431655766;
          Count = CFArrayGetCount(v8);
          if (Count >= 1)
          {
            v11 = 0;
            v12 = Count;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v9, v11);
              if (ValueAtIndex)
              {
                v14 = ValueAtIndex;
                v15 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("networkRole"));
                if (v15)
                {
                  CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
                  if (valuePtr == 3)
                  {
                    v18 = *v6;
                    v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v18);
                    if (!v16)
                      break;
                    v17 = v16;
                    CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 3320), v14);
                    sub_10002C478((uint64_t)v14, CFSTR("CHANNEL"), v17);
                    CFSetAddValue(*(CFMutableSetRef *)(a3 + 3320), v14);
                    CFRelease(v17);
                  }
                }
              }
              ++v11;
            }
            while (v12 != v11);
          }
          CFRelease(v9);
        }
      }
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is Null!", "__WiFiDeviceManagerSoftAPChannelChangedEventCallback");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_100127838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;

  if (!a3)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManagerRef is Null!", "__WiFiDeviceManagerP2pThreadCoexEventCallback");
    v9 = v10;
    goto LABEL_9;
  }
  v7 = *(_QWORD *)(a3 + 4760);
  v8 = objc_autoreleasePoolPush();
  if (!v7)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoex callback is NULL!", "__WiFiDeviceManagerP2pThreadCoexEventCallback");
    v9 = v8;
LABEL_9:
    objc_autoreleasePoolPop(v9);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: p2pThreadCoexEventDict:%@ ", "__WiFiDeviceManagerP2pThreadCoexEventCallback", a4);
  objc_autoreleasePoolPop(v8);
  (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a3 + 4760))(a3, a2, *(_QWORD *)(a3 + 4768), a4);
}

void sub_100127948(uint64_t a1)
{
  void *v2;
  __CFArray *v3;
  __CFArray *v4;
  id v5;
  id v6;
  void *v7;
  void *v8;
  NSString *const **v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  id v20;
  void *v21;
  uint64_t v22;
  void *i;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  _BYTE v42[128];

  v2 = objc_autoreleasePoolPush();
  if (!_os_feature_enabled_impl("CoreWiFi", "AskToJoin6E"))
    goto LABEL_45;
  if (!a1)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiDeviceManagerRef is NULL", "__WiFiDeviceManagerCheckForColocatedSSIDs");
    goto LABEL_44;
  }
  v3 = sub_1000775BC(*(_QWORD *)(a1 + 64), 0);
  if (!v3)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CFArrayCreateMutable() returned NULL", "__WiFiDeviceManagerCheckForColocatedSSIDs");
LABEL_44:
    objc_autoreleasePoolPop(v27);
LABEL_45:
    v7 = 0;
    v5 = 0;
    goto LABEL_39;
  }
  v4 = v3;
  v5 = sub_100121D60(v3);
  if (v5)
  {
    v6 = sub_100104784(a1);
    if (v6)
    {
      v7 = v6;
      v8 = (void *)CWFColocatedNetworksMatchingScanResult(v6, v5, objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "knownNetworks"), "allObjects"));
      v9 = &ACAccountStoreDidChangeNotification_ptr;
      v10 = -[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("UserDismissedColocatedSSIDTimestamps"));
      v37 = 0u;
      v38 = 0u;
      v39 = 0u;
      v40 = 0u;
      v11 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
      if (v11)
      {
        v12 = v11;
        v31 = a1;
        v29 = v7;
        v30 = v5;
        v13 = *(_QWORD *)v38;
LABEL_8:
        v14 = 0;
        while (1)
        {
          if (*(_QWORD *)v38 != v13)
            objc_enumerationMutation(v8);
          v15 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * v14);
          if (!objc_msgSend(objc_msgSend(v10, "allKeys"), "containsObject:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), objc_msgSend(v15, "networkName"))))break;
          v16 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Colocated SSID candidate already dismissed by user (%@)", "__WiFiDeviceManagerCheckForColocatedSSIDs", v15);
          objc_autoreleasePoolPop(v16);
          if (v12 == (id)++v14)
          {
            v12 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
            if (v12)
              goto LABEL_8;
            v15 = 0;
            break;
          }
        }
        v5 = v30;
        v7 = v29;
        a1 = v31;
        v9 = &ACAccountStoreDidChangeNotification_ptr;
      }
      else
      {
        v15 = 0;
      }
      if (os_variant_has_internal_content("com.apple.WiFiManager"))
      {
        v17 = objc_msgSend(objc_msgSend((id)v9[457], "standardUserDefaults"), "objectForKey:", CFSTR("ColocatedSSIDNotificationForceMatchSSID"));
        if (v17)
        {
          v18 = v17;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
          v19 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
          if (v19)
          {
            v20 = v19;
            v32 = a1;
            v21 = v7;
            v22 = *(_QWORD *)v34;
            while (2)
            {
              for (i = 0; i != v20; i = (char *)i + 1)
              {
                if (*(_QWORD *)v34 != v22)
                  objc_enumerationMutation(v5);
                v24 = *(void **)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)i);
                if (objc_msgSend(objc_msgSend(v24, "networkName"), "isEqualToString:", v18))
                {
                  v25 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: [internal] Force matched SSID candidate %@", "__WiFiDeviceManagerCheckForColocatedSSIDs", v15);
                  objc_autoreleasePoolPop(v25);
                  v15 = v24;
                  goto LABEL_33;
                }
              }
              v20 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
              if (v20)
                continue;
              break;
            }
LABEL_33:
            v7 = v21;
            a1 = v32;
          }
        }
      }
      v26 = objc_autoreleasePoolPush();
      if (v15)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Dispatching colocated SSID notification for %@", "__WiFiDeviceManagerCheckForColocatedSSIDs", v15);
        objc_autoreleasePoolPop(v26);
        objc_msgSend(*(id *)(a1 + 6704), "dispatchNotificationWithColocatedScanResult:fromScanResult:", v15, v7);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No valid colocated SSID candidates", "__WiFiDeviceManagerCheckForColocatedSSIDs");
        objc_autoreleasePoolPop(v26);
      }
      goto LABEL_38;
    }
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult() returned NULL", "__WiFiDeviceManagerCheckForColocatedSSIDs");
  }
  else
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: __WiFiDeviceManagerCreateCoreWiFiScanResultsFromNetworks() returned NULL", "__WiFiDeviceManagerCheckForColocatedSSIDs");
  }
  objc_autoreleasePoolPop(v28);
  v7 = 0;
LABEL_38:
  CFRelease(v4);
LABEL_39:

  objc_autoreleasePoolPop(v2);
}

void sub_100127DFC(uint64_t a1, void *a2)
{
  _BOOL8 v3;

  if (a2)
  {
    v3 = sub_100077738(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)) != 1;
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 7368), "setLinkEvent:isInvoluntary:linkChangeReason:linkChangeSubreason:withNetworkDetails:forInterface:", 1, v3, 0, 0, a2, sub_100025C3C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64)));

  }
}

void sub_100127E74(NSObject **a1, const void *a2, int a3, int a4)
{
  if (a1 && a2 && a3)
  {
    sub_10002C478((uint64_t)a2, CFSTR("TransitionDisabledFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
    if (a4)
      sub_1001053C8(a1, a2);
  }
}

void sub_100127EF0(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const __CFNumber *Value;
  const __CFNumber *v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFData *v18;
  const __CFData *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFData *v29;
  const __CFData *v30;
  void *v31;
  id v32;
  int v33;
  id v34;
  void *v35;
  const __CFArray *v36;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  int v39;
  unsigned int v40;
  unint64_t v41;
  const __CFDate *v42;
  double Current;
  unsigned int v44;
  int v45;
  uint64_t v46;
  const void *v47;
  uint64_t v48;
  const void *v49;
  void *v50;
  void *v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;
  CFRange v56;

  if (!a1)
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, WiFiDeviceManagerRef is NULL", "__WiFiDeviceManagerSubmitRoamStatusMetrics");
    goto LABEL_71;
  }
  if (!a3)
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamStatusdict is NULL", "__WiFiDeviceManagerSubmitRoamStatusMetrics");
LABEL_71:
    objc_autoreleasePoolPop(v50);
    return;
  }
  v6 = malloc_type_malloc(0xB8uLL, 0x10000406E508D01uLL);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v6[22] = 0;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)v6 = 0u;
    *((_DWORD *)v6 + 4) = sub_1000C5C14((uint64_t)a2);
    Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_STATUS"));
    if (Value)
      CFNumberGetValue(Value, kCFNumberSInt32Type, (void *)(v7 + 24));
    v9 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_REASON"));
    if (v9)
      CFNumberGetValue(v9, kCFNumberSInt32Type, (void *)(v7 + 28));
    v10 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_FLAGS"));
    if (v10)
      CFNumberGetValue(v10, kCFNumberSInt32Type, (void *)(v7 + 20));
    v11 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_PROFILE_TYPE"));
    if (v11)
      CFNumberGetValue(v11, kCFNumberSInt32Type, (void *)(v7 + 32));
    v12 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_RSSI"));
    if (v12)
      CFNumberGetValue(v12, kCFNumberSInt32Type, (void *)(v7 + 36));
    v13 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_RSSI"));
    if (v13)
      CFNumberGetValue(v13, kCFNumberSInt32Type, (void *)(v7 + 40));
    v14 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_CHANNEL"));
    if (v14)
      CFNumberGetValue(v14, kCFNumberSInt32Type, (void *)(v7 + 44));
    v15 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_CHANNEL"));
    if (v15)
      CFNumberGetValue(v15, kCFNumberSInt32Type, (void *)(v7 + 48));
    v16 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_CHANNEL_FLAGS"));
    if (v16)
      CFNumberGetValue(v16, kCFNumberSInt32Type, (void *)(v7 + 52));
    v17 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_CHANNEL_FLAGS"));
    if (v17)
      CFNumberGetValue(v17, kCFNumberSInt32Type, (void *)(v7 + 56));
    v18 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_OUI"));
    if (v18)
    {
      v52.location = 0;
      v52.length = 3;
      CFDataGetBytes(v18, v52, (UInt8 *)(v7 + 60));
    }
    v19 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_OUI"));
    if (v19)
    {
      v53.location = 0;
      v53.length = 3;
      CFDataGetBytes(v19, v53, (UInt8 *)(v7 + 63));
    }
    v20 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TIME_STARTED"));
    if (v20)
      CFNumberGetValue(v20, kCFNumberSInt64Type, (void *)v7);
    v21 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TIME_ENDED"));
    if (v21)
      CFNumberGetValue(v21, kCFNumberSInt64Type, (void *)(v7 + 8));
    v22 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_AUTHTYPE"));
    if (v22)
      CFNumberGetValue(v22, kCFNumberSInt32Type, (void *)(v7 + 144));
    v23 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_AUTHTYPE"));
    if (v23)
      CFNumberGetValue(v23, kCFNumberSInt32Type, (void *)(v7 + 148));
    v24 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_AKMS"));
    if (v24)
      CFNumberGetValue(v24, kCFNumberSInt32Type, (void *)(v7 + 152));
    v25 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_AKMS"));
    if (v25)
      CFNumberGetValue(v25, kCFNumberSInt32Type, (void *)(v7 + 156));
    v26 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_PHYMODE"));
    if (v26)
      CFNumberGetValue(v26, kCFNumberSInt32Type, (void *)(v7 + 160));
    v27 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_PHYMODE"));
    if (v27)
      CFNumberGetValue(v27, kCFNumberSInt32Type, (void *)(v7 + 164));
    v28 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_CHANNELS_SCANNED_COUNT"));
    if (v28)
      CFNumberGetValue(v28, kCFNumberSInt16Type, (void *)(v7 + 180));
    v29 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_ORIGIN_ADDR"));
    if (v29)
    {
      v54.location = 0;
      v54.length = 6;
      CFDataGetBytes(v29, v54, (UInt8 *)(v7 + 168));
    }
    v30 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_TARGET_ADDR"));
    if (v30)
    {
      v55.location = 0;
      v55.length = 6;
      CFDataGetBytes(v30, v55, (UInt8 *)(v7 + 174));
    }
    v31 = objc_autoreleasePoolPush();
    v32 = -[__CFDictionary objectForKey:](a3, "objectForKey:", CFSTR("ROAM_CACHE"));
    objc_autoreleasePoolPop(v31);
    v33 = sub_100077880(*(_QWORD *)(a1 + 64));
    v34 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
    if (v34)
    {
      v35 = v34;
      sub_100048A6C(*(_QWORD *)(a1 + 120), (_DWORD *)(v7 + 68), (_DWORD *)(v7 + 72), (_DWORD *)(v7 + 76), (_DWORD *)(v7 + 80), (unint64_t *)(v7 + 88), (unint64_t *)(v7 + 128), (unint64_t *)(v7 + 136));
      v36 = *(const __CFArray **)(a1 + 3528);
      if (v36)
      {
        v56.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
        v56.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v36, v56, a2);
        if (FirstIndexOfValue != -1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
          if (v33 && objc_msgSend(v35, "isRoamLateDueToDelta"))
            sub_1000C7C1C((uint64_t)ValueAtIndex, a2, (int)objc_msgSend(v35, "minRssiDeltaInRoamCache"), (int)objc_msgSend(v35, "maxRssiDeltaInRoamCache"));
          v39 = *(unsigned __int16 *)(v7 + 20);
          v40 = sub_1000C3F88((uint64_t)ValueAtIndex);
          *(_DWORD *)(v7 + 20) = v39 | (v40 << 24) | (sub_1000CBE60((uint64_t)ValueAtIndex) << 16);
          *(_DWORD *)(v7 + 32) = sub_10002A724(a1, ValueAtIndex);
        }
      }
      if (v33)
        *(_DWORD *)(v7 + 100) = *(_DWORD *)(v7 + 8) - *(_DWORD *)v7;
      v41 = sub_10002E000(a2);
      if (v41)
      {
        v42 = (const __CFDate *)v41;
        Current = CFAbsoluteTimeGetCurrent();
        *(_QWORD *)(v7 + 104) = (unint64_t)(Current - CFDateGetAbsoluteTime(v42));
      }
      v44 = objc_msgSend(v35, "lastHostTriggeredRoamReason");
      v45 = *(_DWORD *)(a1 + 3352);
      *(_DWORD *)(v7 + 112) = v44;
      *(_DWORD *)(v7 + 116) = v45;
      *(_BYTE *)(v7 + 120) = *(_BYTE *)(a1 + 3408) != 0;
      *(_BYTE *)(v7 + 121) = objc_msgSend(v35, "isRoamLateDueToDelta");
      objc_msgSend(v35, "setLastHostTriggeredRoamReason:", 0);
      v46 = *(_QWORD *)(a1 + 64);
      v47 = sub_10002B088(a2);
      sub_100059E78(v46, v7, (uint64_t)v47, v32);
      if (v33)
      {
        objc_msgSend(v35, "didSubmitMetrics");
      }
      else
      {
        v48 = *(_QWORD *)(a1 + 64);
        v49 = sub_10002B088(a2);
        sub_100059E78(v48, v7, (uint64_t)v49, v32);
      }
      sub_100048A40(*(_QWORD *)(a1 + 120));
    }
    else
    {
      v51 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, roamManager is NULL", "__WiFiDeviceManagerSubmitRoamStatusMetrics");
      objc_autoreleasePoolPop(v51);
    }
    free((void *)v7);
  }
}

void sub_10012855C(uint64_t a1, int a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  void *v8;
  CFBooleanRef v9;
  CFBooleanRef v10;
  __int16 valuePtr;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 4120))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v5 = Mutable;
        if (a2)
        {
          valuePtr = 0;
          v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
          if (v6)
          {
            v7 = v6;
            CFDictionaryAddValue(v5, CFSTR("HostApDisableHotspotAdvertiseReason"), v6);
            CFRelease(v7);
          }
          v8 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HostAP Max Client Connected: Disable Hotspot Advertising\n", "__WiFiDeviceManagerHostApStateChangedMaxClientsConnected");
        }
        else
        {
          v8 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HostAP Max Client Allowed: Enable Hotspot Advertising\n", "__WiFiDeviceManagerHostApStateChangedMaxClientsConnected");
        }
        objc_autoreleasePoolPop(v8);
        if (*(_BYTE *)(a1 + 5219))
          v9 = kCFBooleanTrue;
        else
          v9 = kCFBooleanFalse;
        CFDictionaryAddValue(v5, CFSTR("HostApEnabled"), v9);
        if (a2)
          v10 = kCFBooleanTrue;
        else
          v10 = kCFBooleanFalse;
        CFDictionaryAddValue(v5, CFSTR("HostApDisableHotspotAdvertise"), v10);
        (*(void (**)(uint64_t, _QWORD, __CFDictionary *))(a1 + 4120))(a1, *(_QWORD *)(a1 + 4128), v5);
        CFRelease(v5);
      }
    }
  }
}

void sub_1001286E4(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Requesting PersonalHotspotControl extension to reload because SoftAP client arrives");
  objc_autoreleasePoolPop(v1);
  -[CHSControlService reloadControlsForExtension:kind:reason:](+[CHSControlService sharedInstance](CHSControlService, "sharedInstance"), "reloadControlsForExtension:kind:reason:", CFSTR("com.apple.WiFiKit.PersonalHotspotControl"), CFSTR("PersonalHotspotControl"), CFSTR("Requesting PersonalHotspotControl extension to reload because personal hotspot client arrives"));
}

void sub_100128750(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Requesting PersonalHotspotControl extension to reload because SoftAP client leaves");
  objc_autoreleasePoolPop(v1);
  -[CHSControlService reloadControlsForExtension:kind:reason:](+[CHSControlService sharedInstance](CHSControlService, "sharedInstance"), "reloadControlsForExtension:kind:reason:", CFSTR("com.apple.WiFiKit.PersonalHotspotControl"), CFSTR("PersonalHotspotControl"), CFSTR("Requesting PersonalHotspotControl extension to reload because personal hotspot client leaves"));
}

uint64_t sub_1001287BC(uint64_t a1)
{
  void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  __CFArray *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  unsigned int v10;
  void *v11;
  const __CFArray *v12;
  void *v13;
  CFIndex v14;
  void *v15;
  void *v16;
  CFIndex v17;
  void *v18;
  const __CFArray *v19;
  void *ValueAtIndex;
  uint64_t v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  int v24;
  const __CFArray *v25;
  const __CFArray *v26;
  CFIndex v27;
  const __CFDictionary *v28;
  const __CFNumber *Value;
  const __CFNumber *v30;
  void *v31;
  void *v32;
  void *v33;
  const __CFNumber *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  void *v42;
  const __CFNumber *v43;
  void *v44;
  CFDictionaryRef v45;
  CFDictionaryRef v46;
  __CFArray *Mutable;
  const __CFArray *v48;
  void *v49;
  NSString *v50;
  const char *v51;
  void *v52;
  unsigned int v53;
  uint64_t v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  int v59;
  uint8_t buf[4];
  const char *v61;
  void *values[2];
  __int128 valuePtr;
  CFRange v64;

  v2 = objc_autoreleasePoolPush();
  v3 = *(const void **)(a1 + 1112);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  v4 = *(const void **)(a1 + 3376);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 3376) = 0;
  }
  v5 = *(const void **)(a1 + 3368);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 3368) = 0;
  }
  v6 = *(const void **)(a1 + 3384);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 3384) = 0;
  }
  *(_BYTE *)(a1 + 3304) = 0;
  *(_DWORD *)(a1 + 1136) = 0;
  v7 = *(__CFArray **)(a1 + 3288);
  if (v7)
    CFArrayRemoveAllValues(v7);
  *(_DWORD *)(a1 + 5620) = 0;
  v8 = (const __CFArray *)sub_100009ACC(a1);
  if (!v8)
    goto LABEL_33;
  v9 = v8;
  +[WiFiLocationManager logLocation:addPrefixString:](WiFiLocationManager, "logLocation:addPrefixString:", v8, CFSTR("__WiFiDeviceManagerScanPreviousNetworkChannel"));
  v10 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v9, 1, 60.0);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: isValid %d", "__WiFiDeviceManagerScanPreviousNetworkChannel", v10 != 0);
  objc_autoreleasePoolPop(v11);
  if (!v10)
    goto LABEL_32;
  v12 = (const __CFArray *)objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyScoreSortedNetworksAvailableAtLocation:", v9);
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: score sorted networks %@", "__WiFiDeviceManagerScanPreviousNetworkChannel", v12);
  objc_autoreleasePoolPop(v13);
  *(_QWORD *)(a1 + 3384) = v9;
  CFRetain(v9);
  CFRelease(v9);
  if (!v12)
  {
LABEL_33:
    if (*(_QWORD *)(a1 + 3512))
    {
      v19 = *(const __CFArray **)(a1 + 3576);
      v64.length = CFArrayGetCount(v19);
      v64.location = 0;
      if (CFArrayGetFirstIndexOfValue(v19, v64, *(const void **)(a1 + 3512)) != -1)
      {
        ValueAtIndex = *(void **)(a1 + 3512);
        if (ValueAtIndex)
        {
          v21 = 6;
          goto LABEL_39;
        }
      }
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3576)))
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), 0);
      v21 = 6;
      if (ValueAtIndex)
        goto LABEL_39;
    }
    else
    {
      ValueAtIndex = 0;
      LODWORD(v21) = 6;
    }
LABEL_61:
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "multi-stage auto-join: No previous network (%p)", ValueAtIndex);
    v37 = v36;
    goto LABEL_64;
  }
  if (!CFArrayGetCount(v12) || CFArrayGetCount(v12) < 1)
  {
    v9 = v12;
LABEL_32:
    CFRelease(v9);
    goto LABEL_33;
  }
  v14 = 0;
  while (1)
  {
    v15 = (void *)CFArrayGetValueAtIndex(v12, v14);
    if (v15)
      break;
LABEL_29:
    if (CFArrayGetCount(v12) <= ++v14)
      goto LABEL_30;
  }
  v16 = v15;
  sub_10012BF90(a1, v15);
  if (!sub_100124B34(a1, v16, 0))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: top network %@ is not eligible for aj ", "__WiFiDeviceManagerScanPreviousNetworkChannel", sub_10002B088(v16));
    goto LABEL_28;
  }
  v17 = sub_1000CB39C(*(const __CFArray **)(a1 + 3576), (uint64_t)v16);
  if (v17 == -1)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: top network <%@> does not exist in filtered known networks list, onto the next one ", "__WiFiDeviceManagerScanPreviousNetworkChannel", sub_10002B088(v16));
LABEL_28:
    objc_autoreleasePoolPop(v18);
    goto LABEL_29;
  }
  v55 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), v17);
  if (!v55)
  {
LABEL_30:
    v9 = v12;
    goto LABEL_32;
  }
  ValueAtIndex = v55;
  *(_DWORD *)(a1 + 5620) = 11;
  v56 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Enter location based AJ's 1st stage - top network %@", "__WiFiDeviceManagerScanPreviousNetworkChannel", ValueAtIndex);
  objc_autoreleasePoolPop(v56);
  *(_QWORD *)(a1 + 3376) = ValueAtIndex;
  CFRetain(ValueAtIndex);
  *(_QWORD *)(a1 + 3368) = v12;
  CFRetain(v12);
  CFRelease(v12);
  v21 = 7;
LABEL_39:
  if (!sub_100124B34(a1, ValueAtIndex, 0))
    goto LABEL_61;
  if (sub_10000BE8C((uint64_t)ValueAtIndex) && !*(_DWORD *)(a1 + 688))
  {
    *(_BYTE *)(a1 + 672) = 1;
    *(_QWORD *)(a1 + 664) = 0;
    *(_DWORD *)(a1 + 688) = 1;
  }
  v22 = (const __CFNumber *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL"));
  if (!v22)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "multi-stage auto-join: No channel info");
    v37 = v42;
LABEL_64:
    objc_autoreleasePoolPop(v37);
    v38 = 4294963396;
    goto LABEL_65;
  }
  v23 = v22;
  v58 = v2;
  if (!sub_10000BE8C((uint64_t)ValueAtIndex)
    || (*(_BYTE *)(a1 + 672) = 0,
        v24 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("CHANNEL")),
        LODWORD(valuePtr) = v24,
        *(_DWORD *)(a1 + 668) = v24,
        v24 > 14)
    || (v25 = (const __CFArray *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("networkKnownBSSListKey"))) == 0
    || (v26 = v25, CFArrayGetCount(v25) < 2)
    || CFArrayGetCount(v26) < 1)
  {
LABEL_54:
    v32 = (void *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL_FLAGS"));
    if (v32)
    {
      v33 = v32;
      v30 = v23;
      goto LABEL_56;
    }
    v44 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "multi-stage auto-join: No channel flags info");
    objc_autoreleasePoolPop(v44);
    v38 = 4294963396;
    goto LABEL_84;
  }
  v27 = 0;
  while (1)
  {
    v28 = (const __CFDictionary *)CFArrayGetValueAtIndex(v26, v27);
    Value = (const __CFNumber *)CFDictionaryGetValue(v28, CFSTR("CHANNEL"));
    if (Value)
    {
      v30 = Value;
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      if ((int)valuePtr >= 36)
      {
        v31 = (void *)CFDictionaryGetValue(v28, CFSTR("CHANNEL_FLAGS"));
        if (v31)
          break;
      }
    }
    if (CFArrayGetCount(v26) <= ++v27)
      goto LABEL_54;
  }
  v33 = v31;
  *(_DWORD *)(a1 + 668) = valuePtr;
  *(_BYTE *)(a1 + 672) = 1;
  v57 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Re-directed to connect to chanenl %d", "__WiFiDeviceManagerScanPreviousNetworkChannel", valuePtr);
  objc_autoreleasePoolPop(v57);
LABEL_56:
  v59 = 0;
  if (sub_10012C188(a1, &v59))
  {
    v34 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("CHANNEL"));
    if (((_DWORD)v34 - 1) <= 0xD)
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 2.4Ghz channel %d for %@", "__WiFiDeviceManagerScanPreviousNetworkChannel", v34, sub_10002B088(ValueAtIndex));
      goto LABEL_80;
    }
  }
  v59 = 0;
  if (!sub_10012C418((_BYTE *)a1, &v59)
    || (v43 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("CHANNEL")), (int)v43 < 15))
  {
    valuePtr = *(_OWORD *)&off_100231A60;
    values[0] = v30;
    values[1] = v33;
    v45 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&valuePtr, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v45)
    {
      v46 = v45;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        v48 = Mutable;
        CFArrayAppendValue(Mutable, v46);
        sub_100125EC4(a1);
        v49 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v50 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("multi-stage auto-join: Scanning(%s) for previous network %@ on channel %@"), "Active", sub_10002B088(ValueAtIndex), v30)), "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            v51 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v50, "UTF8String")), "UTF8String");
            *(_DWORD *)buf = 136446210;
            v61 = v51;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
          }
        }
        objc_autoreleasePoolPop(v49);
        if (*(_DWORD *)(a1 + 5520) == 1 || *(_BYTE *)(a1 + 5504))
        {
          v52 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay scan dewll time (%d), channel (%d), dual band (%d)", "__WiFiDeviceManagerScanPreviousNetworkChannel", 40, *(unsigned int *)(a1 + 668), *(unsigned __int8 *)(a1 + 672));
          objc_autoreleasePoolPop(v52);
          v53 = 40;
        }
        else
        {
          v53 = 110;
        }
        v54 = sub_10012C500(a1, *(const __CFArray **)(a1 + 3552), v48, v53, 25);
        if (!(_DWORD)v54)
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3288), v46);
          CFRelease(v46);
          CFRelease(v48);
          *(_DWORD *)(a1 + 3284) = v21;
          v2 = v58;
          goto LABEL_71;
        }
        v38 = v54;
        CFRelease(v46);
        CFRelease(v48);
LABEL_84:
        v2 = v58;
        goto LABEL_65;
      }
      CFRelease(v46);
    }
    v38 = 4294963394;
    goto LABEL_84;
  }
  v35 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 5Ghz channel %d for %@", "__WiFiDeviceManagerScanPreviousNetworkChannel", v43, sub_10002B088(ValueAtIndex));
LABEL_80:
  v2 = v58;
  objc_autoreleasePoolPop(v35);
  *(_DWORD *)(a1 + 6168) = v59;
  v38 = 4294963394;
LABEL_65:
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "multi-stage auto-join: Error scanning for previous network, err=%d", v38);
  objc_autoreleasePoolPop(v39);
  if (*(_DWORD *)(a1 + 5520) == 1 || *(_BYTE *)(a1 + 5504))
  {
    *(_DWORD *)(a1 + 3284) = v21;
    v40 = sub_10012CA98((_DWORD *)a1);
  }
  else
  {
    v40 = sub_10012CB54(a1);
  }
  v21 = v40;
LABEL_71:
  objc_autoreleasePoolPop(v2);
  return v21;
}

uint64_t sub_100129118(uint64_t a1)
{
  const void *v2;
  const void *v3;
  CFIndex Count;
  int v5;
  _BOOL4 v6;
  int v7;
  int v8;
  char v9;
  unsigned int v10;
  __CFArray *Mutable;
  CFMutableArrayRef v12;
  __CFArray *v13;
  BOOL v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  int v20;
  int v21;
  int v22;
  void *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v28;
  void *Value;
  const __CFNumber *v30;
  const __CFNumber *v31;
  CFDictionaryRef v32;
  CFDictionaryRef v33;
  const char *v34;
  CFIndex v35;
  CFIndex v36;
  void *v37;
  const char *v38;
  NSString *v39;
  const char *v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v47;
  int v48;
  int valuePtr;
  void *values[2];
  void *keys[2];

  v47 = 0;
  if (*(_DWORD *)(a1 + 3280) != 2)
  {
    v2 = *(const void **)(a1 + 1112);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 1112) = 0;
    }
    *(_DWORD *)(a1 + 1136) = 0;
  }
  v3 = *(const void **)(a1 + 1168);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 1168) = 0;
  }
  *(_QWORD *)(a1 + 1144) = 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3552));
  v5 = sub_10012B9CC(a1, &v47);
  v6 = *(_DWORD *)(a1 + 176) != 3 && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 3296) > 30.0;
  if (*(_BYTE *)(a1 + 34))
    v6 = 0;
  if (!*(_BYTE *)(a1 + 32) || !*(_BYTE *)(a1 + 33))
  {
    v7 = 7;
    goto LABEL_17;
  }
  if (*(_BYTE *)(a1 + 35))
  {
    v7 = 9;
LABEL_17:
    *(_DWORD *)(a1 + 5620) = v7;
LABEL_18:
    *(_BYTE *)(a1 + 3304) = 0;
    v8 = 16;
    v9 = 1;
    goto LABEL_19;
  }
  if (*(_DWORD *)(a1 + 3280) != 2)
  {
    if (v5 | v6)
    {
      if (v47)
      {
        if (v5)
        {
          v7 = 5;
        }
        else
        {
          if (!v6)
            goto LABEL_18;
          v7 = 6;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if (!*(_BYTE *)(a1 + 3304))
      {
        v9 = 0;
        *(_DWORD *)(a1 + 5620) = 3;
        ++*(_WORD *)(a1 + 6120);
        v8 = 8;
        goto LABEL_19;
      }
      if (v47)
        goto LABEL_18;
    }
    v7 = 8;
    goto LABEL_17;
  }
  if (!*(_BYTE *)(a1 + 5608)
    || (v24 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)),
        v25 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568)) + v24,
        v25 + CFArrayGetCount(*(CFArrayRef *)(a1 + 3560))))
  {
    *(_DWORD *)(a1 + 5620) = 4;
  }
  v9 = 0;
  ++*(_WORD *)(a1 + 6116);
  *(_BYTE *)(a1 + 3304) = 0;
  v8 = 16;
LABEL_19:
  if (Count)
    v10 = 110;
  else
    v10 = 0;
  valuePtr = -1431655766;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v13 = v12;
  if (Mutable)
    v14 = v12 == 0;
  else
    v14 = 1;
  if (v14)
    goto LABEL_30;
  v15 = *(_QWORD *)(a1 + 64);
  v16 = (const void *)sub_100025C3C(v15);
  v17 = sub_100017A68(v15, v16, v13);
  if ((_DWORD)v17)
  {
    v18 = v17;
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AJScan: Device return error %d for supported channels. Scanning ALL channels\n", v18);
    objc_autoreleasePoolPop(v19);
    goto LABEL_30;
  }
  v48 = 0;
  v20 = sub_10012C188(a1, &v48);
  *(_DWORD *)(a1 + 6168) = v48;
  v21 = sub_10012C418((_BYTE *)a1, &v48);
  v22 = v21;
  if (v20)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Disallowing 2.4Ghz channels");
    objc_autoreleasePoolPop(v23);
    v8 = 16;
    goto LABEL_43;
  }
  if ((v9 & 1) != 0)
  {
    if (v21)
    {
      v8 = 8;
      goto LABEL_43;
    }
LABEL_30:
    v8 = 0;
    goto LABEL_56;
  }
LABEL_43:
  if (CFArrayGetCount(v13) >= 1)
  {
    v26 = 0;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v26);
      if (ValueAtIndex)
      {
        v28 = ValueAtIndex;
        Value = (void *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
        v30 = (const __CFNumber *)CFDictionaryGetValue(v28, CFSTR("SUP_CHANNEL_FLAGS"));
        if (Value)
        {
          v31 = v30;
          if (v30)
          {
            if (CFNumberGetValue(v30, kCFNumberSInt32Type, &valuePtr))
            {
              if ((valuePtr & v8) != 0)
              {
                if (!v22
                  || (LODWORD(keys[0]) = -1431655766,
                      CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, keys),
                      LODWORD(keys[0]))
                  && LODWORD(keys[0]) <= 0xE)
                {
                  *(_OWORD *)keys = *(_OWORD *)&off_100231A60;
                  values[0] = Value;
                  values[1] = v31;
                  v32 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (v32)
                  {
                    v33 = v32;
                    CFArrayAppendValue(Mutable, v32);
                    CFRelease(v33);
                  }
                }
              }
            }
          }
        }
      }
      ++v26;
    }
    while (v26 < CFArrayGetCount(v13));
  }
LABEL_56:
  if (*(_BYTE *)(a1 + 5608))
  {
    v34 = " ";
    if (*(_DWORD *)(a1 + 3280) == 2)
    {
      v35 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112));
      v36 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568)) + v35;
      if (!(v36 + CFArrayGetCount(*(CFArrayRef *)(a1 + 3560))))
        v34 = "- Fake ";
    }
  }
  else
  {
    v34 = " ";
  }
  v37 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v38 = "ALL";
    if (v8 == 16)
      v38 = "5Ghz";
    if (v8 == 8)
      v38 = "2.4Ghz";
    v39 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("AJScan: Starting Broadcast scan(%s) with %s channels %s"), "Active", v38, v34)), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v40 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v39, "UTF8String")), "UTF8String");
      LODWORD(keys[0]) = 136446210;
      *(void **)((char *)keys + 4) = (void *)v40;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)keys, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v37);
  v41 = 6;
  if (v8 == 16)
    v42 = 3;
  else
    v42 = 4;
  if (v8 == 16)
    v41 = 5;
  if (v8 == 8)
    v43 = 2;
  else
    v43 = v42;
  if (v8 == 8)
    v44 = 4;
  else
    v44 = v41;
  v45 = sub_10012C500(a1, 0, Mutable, v10, v44);
  if ((_DWORD)v45)
    return sub_10000D074(a1, v45);
  if (v13)
    CFRelease(v13);
  if (Mutable)
    CFRelease(Mutable);
  return v43;
}

uint64_t sub_100129744(uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4)
{
  void *v8;
  NSString *v9;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFNumber *v17;
  void *v18;
  const __CFArray *v19;
  const __CFArray *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  id v24;
  void *v25;
  uint64_t v26;
  double v27;
  CLLocationDegrees v28;
  double v29;
  CLLocationDegrees v30;
  double v31;
  CFAbsoluteTime Current;
  CFDateRef v33;
  CFAbsoluteTime v34;
  CFDateRef v35;
  void *v36;
  id v37;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  CFBooleanRef v42;
  BOOL v43;
  CFTypeRef v44;
  CFTypeRef v45;
  NSObject *v46;
  void *v47;
  const void *v48;
  void *v49;
  NSString *v50;
  const char *v51;
  uint64_t v52;
  void *v54;
  const __CFArray *v55;
  const __CFBoolean *v56;
  const __CFDictionary **v57;
  const void *v58;
  const __CFDictionary *v59;
  CFTypeID TypeID;
  const __CFData *v61;
  uint64_t v62;
  CFTypeID v63;
  CFTypeID v64;
  __CFDictionary *v65;
  void *v66;
  void (*v67)(uint64_t, const __CFDictionary **, _QWORD);
  void *v68;
  void *v69;
  uint64_t v70;
  CFTypeRef v71;
  NSObject *v72;
  uint64_t v73;
  const __CFString *v74;
  CFComparisonResult v75;
  void *v76;
  id v77;
  uint64_t v78;
  const void *v79;
  id v80;
  void *v81;
  const void *v82;
  NSString *v83;
  const char *v84;
  const __CFArray *v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  const __CFArray *v93;
  unsigned int v94;
  id v95;
  double v96;
  const __CFArray *v97;
  const __CFArray *v98;
  CFIndex FirstIndexOfValue;
  uint64_t v100;
  void *v101;
  void *v102;
  void *v103;
  const void *v104;
  double v105;
  dispatch_time_t v106;
  dispatch_source_t source;
  NSObject *sourcea;
  NSDate *v109;
  _BOOL4 v110;
  const __CFData *v111;
  char value;
  CFNumberRef valuea;
  CFTypeRef cf;
  CFTypeRef cfa;
  const __CFArray *v116;
  const __CFDictionary **v117;
  void *context;
  _QWORD block[7];
  int v120;
  double v121;
  __int128 theDict;
  uint64_t v123;
  void *v124;
  uint64_t v125;
  int v126;
  uint8_t v127[4];
  const char *v128;
  __int128 buf;
  uint64_t v130;
  void *v131;
  __int128 *p_theDict;
  uint64_t v133;
  CFRange v134;
  CFRange v135;

  context = objc_autoreleasePoolPush();
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: current state: %@"), "__WiFiDeviceManagerProcessAssociationResult", sub_100031FD0(*(_DWORD *)(a1 + 3280)))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v8);
  v121 = 0.0;
  if (a3)
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a3);
  else
    MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v11 = MutableCopy;
  if (MutableCopy)
  {
    v12 = sub_100031FD0(*(_DWORD *)(a1 + 3280));
    CFDictionaryAddValue(v11, CFSTR("reason"), v12);
  }
  if (!(_DWORD)a4)
  {
    if (!sub_10002DAB4((uint64_t)a2))
      goto LABEL_19;
    *(_DWORD *)v127 = 0;
    *(_QWORD *)&theDict = 0;
    buf = 0uLL;
    v13 = (const __CFString *)sub_100029860(*(_QWORD *)(a1 + 64));
    CFStringGetCString(v13, (char *)&buf, 16, 0);
    if (EAPOLControlCopyStateAndStatus(&buf, v127, &theDict))
      goto LABEL_17;
    if (!(_QWORD)theDict)
    {
LABEL_19:
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ not an EAP  network, not checking AT notification code", "__WiFiDeviceManagerProcessAssociationResult", sub_10002B088(a2));
      objc_autoreleasePoolPop(v18);
      v19 = sub_10002B170(a1, a2, 1);
      v20 = v19;
      if (v19)
      {
        v21 = sub_10002BE64((uint64_t)v19, CFSTR("ALLOW_WPA2_PSK"));
        if (v21)
          sub_10002C478((uint64_t)a2, CFSTR("ALLOW_WPA2_PSK"), v21);
        v22 = sub_10002BE64((uint64_t)v20, CFSTR("ALLOW_OWE_TSN"));
        if (v22)
          sub_10002C478((uint64_t)a2, CFSTR("ALLOW_OWE_TSN"), v22);
        sub_1000C71DC(v20, a2);
        v23 = (const void *)sub_10002E000(v20);
        if (v23)
          sub_10002C478((uint64_t)a2, CFSTR("prevJoined"), v23);
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          v24 = sub_100009ACC(a1);
          v25 = v24;
          if (v24)
          {
            v26 = *(_QWORD *)(a1 + 6792);
            objc_msgSend(v24, "coordinate");
            v28 = v27;
            objc_msgSend(v25, "coordinate");
            v30 = v29;
            objc_msgSend(v25, "horizontalAccuracy");
            sub_1000A10CC(v26, a2, v28, v30, v31, objc_msgSend(v25, "timestamp"));

          }
          if (*(_BYTE *)(a1 + 3414))
          {
            Current = CFAbsoluteTimeGetCurrent();
            v33 = CFDateCreate(kCFAllocatorDefault, Current);
            if (v33)
            {
              sub_1000C79E0(a2, v33);
              CFRelease(v33);
            }
          }
        }
        CFRelease(v20);
      }
      v34 = CFAbsoluteTimeGetCurrent();
      v35 = CFDateCreate(kCFAllocatorDefault, v34);
      if (v35)
      {
        sub_1000C69F0(a2, 0, v35);
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting auto association date for %@ to %@", "__WiFiDeviceManagerProcessAssociationResult", sub_10002B088(a2), v35);
        objc_autoreleasePoolPop(v36);
        CFRelease(v35);
      }
      sub_1001327E4(a1, a2);
      if (a2)
      {
        v37 = sub_100027D10((uint64_t)a2);
        objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v37, 0, &v121);
        sub_1000427FC(*(_QWORD *)(a1 + 120), v121);

        sub_1001328A8(a1, a2, 0);
        v38 = sub_100027D10((uint64_t)a2);
        objc_msgSend(*(id *)(a1 + 6648), "removeNetworkDenyListInfoWithReason:forScanResult:", 1, v38);
        objc_msgSend(*(id *)(a1 + 6648), "removeNetworkDenyListInfoForTrigger:forNetwork:", 0, v38);

      }
      else
      {
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to set blacklist last trigger disconnect", "__WiFiDeviceManagerProcessAssociationResult");
        objc_autoreleasePoolPop(v39);
        sub_1001328A8(a1, 0, 0);
        v40 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to clear blacklist trigger", "__WiFiDeviceManagerProcessAssociationResult");
        objc_autoreleasePoolPop(v40);
      }
      if (*(_BYTE *)(a1 + 3412))
      {
        v41 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: tagging network %@ as moving", "__WiFiDeviceManagerProcessAssociationResult", sub_10002B088(a2));
        objc_autoreleasePoolPop(v41);
        sub_10002C478((uint64_t)a2, CFSTR("WiFiNetworkAttributeIsMoving"), kCFBooleanTrue);
        v42 = kCFBooleanFalse;
      }
      else
      {
        v42 = kCFBooleanFalse;
        sub_10002C478((uint64_t)a2, CFSTR("WiFiNetworkAttributeIsMoving"), kCFBooleanFalse);
      }
      sub_10002C478((uint64_t)a2, CFSTR("WiFiInstantHotspotJoining"), v42);
      sub_10002C478((uint64_t)a2, CFSTR("WiFiAutoInstantHotspotJoining"), v42);
      if (*(_DWORD *)(a1 + 3472))
        v43 = a2 == 0;
      else
        v43 = 1;
      if (!v43)
        sub_10002C478((uint64_t)a2, CFSTR("TransitionDisabledFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
      sub_1000FE5A4(a1, a2);
      if (*(_QWORD *)(a1 + 3872))
      {
        if (*(_QWORD *)(a1 + 240))
        {
          *(_QWORD *)&buf = 0;
          *((_QWORD *)&buf + 1) = &buf;
          v130 = 0x2020000000;
          v131 = 0;
          *(_QWORD *)&theDict = 0;
          *((_QWORD *)&theDict + 1) = &theDict;
          v123 = 0x2020000000;
          v124 = 0;
          if (a2)
          {
            v44 = CFRetain(a2);
            *(_QWORD *)(*((_QWORD *)&buf + 1) + 24) = v44;
          }
          if (v11)
          {
            v45 = CFRetain(v11);
            *(_QWORD *)(*((_QWORD *)&theDict + 1) + 24) = v45;
          }
          CFRetain((CFTypeRef)a1);
          v46 = *(NSObject **)(a1 + 240);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100132934;
          block[3] = &unk_100231848;
          block[4] = &buf;
          block[5] = &theDict;
          block[6] = a1;
          v120 = 0;
          dispatch_async(v46, block);
          _Block_object_dispose(&theDict, 8);
          _Block_object_dispose(&buf, 8);
        }
        else
        {
          v47 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerProcessAssociationResult");
          objc_autoreleasePoolPop(v47);
        }
      }
      sub_1000FBAD0(a1, 2, (uint64_t)"__WiFiDeviceManagerProcessAssociationResult");
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3568));
      objc_msgSend(*(id *)(a1 + 3656), "clearScanResultsForAutoJoinSessionReset");
      sub_100135D8C(a1, CFSTR("autoJoinSuccess"), a2, 0);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        v48 = sub_10002B088(a2);
        if (v48)
          objc_msgSend(*(id *)(a1 + 8896), "removeObjectForKey:", v48);
      }
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        sub_100132594(a1, (uint64_t)a2, 0);
      sub_100132A2C(a1, a2);
      sub_100132B40(a1, (uint64_t)a2);
      if (v11)
        CFRelease(v11);
      *(_WORD *)(a1 + 6600) = sub_1000FEEC0(a1, a2);
      sub_1000F9DAC((char *)a1, 1, 1);
      sub_1001269DC(a1, a2);
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v50 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Auto join association succeeded, network: %@"), sub_10002B088(a2))), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v51 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v50, "UTF8String")), "UTF8String");
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = v51;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v49);
      v52 = 0;
      goto LABEL_77;
    }
    v14 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)theDict, CFSTR("AdditionalProperties"));
    if (!v14
      || (v15 = (const __CFDictionary *)CFDictionaryGetValue(v14, CFSTR("EAPAKASIMNotificationActionInfo")),
          (v16 = v15) == 0)
      || !CFDictionaryGetValue(v15, CFSTR("Code"))
      || (v17 = (const __CFNumber *)CFDictionaryGetValue(v16, CFSTR("Code")), sub_10001F500(v17) == -1))
    {
LABEL_17:
      if ((_QWORD)theDict)
        CFRelease((CFTypeRef)theDict);
      goto LABEL_19;
    }
    if ((_QWORD)theDict)
      CFRelease((CFTypeRef)theDict);
    v54 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: EAP AT notification code found associating to %@, reporting error", "__WiFiDeviceManagerProcessAssociationResult", sub_10002B088(a2));
    objc_autoreleasePoolPop(v54);
    a4 = 4294963355;
  }
  v52 = *(unsigned int *)(a1 + 3280);
  if (a2)
  {
    v110 = sub_10002DAB4((uint64_t)a2);
    v55 = sub_10002B170(a1, a2, 1);
    v116 = v55;
    v56 = kCFBooleanFalse;
    if (v55)
      v57 = (const __CFDictionary **)v55;
    else
      v57 = (const __CFDictionary **)a2;
  }
  else
  {
    v110 = 0;
    v116 = 0;
    v57 = 0;
    v56 = kCFBooleanFalse;
  }
  v117 = v57;
  v58 = sub_10002B634(*(const __CFArray **)(a1 + 3704), v57);
  cf = v58;
  if (v58)
  {
    v59 = (const __CFDictionary *)sub_10002BE64((uint64_t)v58, CFSTR("PRIVATE_MAC_ADDRESS"));
    if (v59 && (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v59)))
    {
      v61 = (const __CFData *)CFDictionaryGetValue(v59, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
      v111 = sub_10002B75C(v61);
    }
    else
    {
      v111 = 0;
    }
    v56 = (const __CFBoolean *)sub_10002BE64((uint64_t)cf, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
  }
  else
  {
    v111 = 0;
    v59 = 0;
  }
  sub_1000CEBA4((uint64_t)v117);
  v62 = *(unsigned __int8 *)(a1 + 3688);
  if (!*(_BYTE *)(a1 + 3688))
    goto LABEL_125;
  if (!v56 || v56 != kCFBooleanTrue)
  {
    v70 = (uint64_t)cf;
    if (cf && (_DWORD)v111)
    {
      v70 = (uint64_t)cf;
      if (!sub_10002B704((uint64_t)v117) && *(_QWORD *)(a1 + 4744))
      {
        if (*(_QWORD *)(a1 + 240))
        {
          *(_QWORD *)&theDict = 0;
          *((_QWORD *)&theDict + 1) = &theDict;
          v123 = 0x2020000000;
          v124 = 0;
          v71 = CFRetain(cf);
          *(_QWORD *)(*((_QWORD *)&theDict + 1) + 24) = v71;
          CFRetain((CFTypeRef)a1);
          v72 = *(NSObject **)(a1 + 240);
          *(_QWORD *)&buf = _NSConcreteStackBlock;
          *((_QWORD *)&buf + 1) = 3221225472;
          v130 = (uint64_t)sub_10013359C;
          v131 = &unk_10022F160;
          p_theDict = &theDict;
          v133 = a1;
          dispatch_async(v72, &buf);
          _Block_object_dispose(&theDict, 8);
        }
        else
        {
          v103 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerProcessAssociationFailure");
          objc_autoreleasePoolPop(v103);
          v70 = (uint64_t)cf;
        }
      }
    }
    else if (!cf)
    {
      goto LABEL_124;
    }
    *(_QWORD *)((char *)&theDict + 4) = 0xAAAAAAAAAAAAAAAALL;
    LODWORD(theDict) = 5;
    sub_100061728(v70, (uint64_t)&theDict);
    sub_100061494((unsigned int *)&theDict);
    goto LABEL_124;
  }
  if (!v59)
  {
LABEL_124:
    v62 = 0;
LABEL_125:
    value = 1;
    goto LABEL_126;
  }
  v63 = CFDictionaryGetTypeID();
  v64 = CFGetTypeID(v59);
  v62 = 0;
  value = 1;
  if (v63 == v64 && (_DWORD)v111)
  {
    v65 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v59);
    valuea = sub_100064FE0(1);
    CFDictionarySetValue(v65, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), valuea);
    CFDictionarySetValue(v65, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 3712));
    sub_10002C478((uint64_t)v117, CFSTR("PRIVATE_MAC_ADDRESS"), v65);
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Network <%@> falling back to physical Mac due to Assoc failure", "__WiFiDeviceManagerProcessAssociationFailure", sub_10002B088(v117));
    objc_autoreleasePoolPop(v66);
    if (valuea)
      CFRelease(valuea);
    v67 = *(void (**)(uint64_t, const __CFDictionary **, _QWORD))(a1 + 4712);
    if (v67)
      v67(a1, v117, *(_QWORD *)(a1 + 4720));
    if (cf)
    {
      *(_QWORD *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAAALL;
      LODWORD(buf) = 2;
      sub_100061728((uint64_t)cf, (uint64_t)&buf);
      sub_100061494((unsigned int *)&buf);
    }
    if (v65)
      CFRelease(v65);
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Changing mac address of <%@> from Private to HW to Retry. Current count is <%ld>", sub_10002B088(v117), *(_QWORD *)(a1 + 1128));
    objc_autoreleasePoolPop(v68);
    v69 = *(void **)(a1 + 7368);
    if (v69)
      objc_msgSend(v69, "addFaultEvent:forInterface:", 11, sub_100025C3C(*(_QWORD *)(a1 + 64)));
    value = 0;
    v62 = 1;
  }
LABEL_126:
  cfa = (CFTypeRef)v62;
  if (*(_QWORD *)(a1 + 7368))
  {
    *(_QWORD *)&theDict = _NSConcreteStackBlock;
    *((_QWORD *)&theDict + 1) = 3221225472;
    v123 = (uint64_t)sub_100133624;
    v124 = &unk_100231500;
    v125 = a1;
    v126 = a4;
    sub_10010367C(a1, v117, (uint64_t)&theDict);
  }
  if (sub_10002DAB4((uint64_t)v116) && sub_1000C5378((uint64_t)v116))
    sub_100135D8C(a1, CFSTR("autoJoinStatusEAPFromProfileFailedToJoin"), 0, 0);
  v73 = (uint64_t)v117;
  if (a4 >= 0xFFFFF0C5 && (_DWORD)a4 != -100)
    goto LABEL_138;
  if (!v11
    || (v74 = (const __CFString *)CFDictionaryGetValue(v11, CFSTR("reason")),
        v75 = CFStringCompare(CFSTR("Guessing 2ghz Network"), v74, 0),
        v73 = (uint64_t)v117,
        v75))
  {
    if (v73)
    {
      v76 = objc_autoreleasePoolPush();
      v77 = sub_100027D10((uint64_t)v117);
      v78 = 7;
      if ((a4 + 369033216) < 0x15 || (a4 + 369032216) < 2)
        goto LABEL_137;
      if ((_DWORD)a4 == -369032214)
      {
        v94 = objc_msgSend((id)sub_10002BE64((uint64_t)v117, CFSTR("JOIN_EXTENDED_STATUS")), "intValue");
        if (v94 == 1031)
        {
LABEL_176:
          objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", sub_1000FCB38(a1, 12, -369032214, 0, 5), v77);
          v95 = objc_alloc_init((Class)NSDate);
          v109 = sub_1000649A4((uint64_t)v95, 5, 0, 0);
          -[NSDate timeIntervalSinceDate:](v109, "timeIntervalSinceDate:", v95);
          if (*(_BYTE *)(a1 + 7336))
          {
            source = (dispatch_source_t)objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: EAPATNotifBlacklist expiry timer already running", "__WiFiDeviceManagerProcessAssociationFailure");
          }
          else
          {
            v105 = v96;
            *(_BYTE *)(a1 + 7336) = 1;
            sourcea = *(NSObject **)(a1 + 7344);
            v106 = dispatch_time(0, (uint64_t)(v96 * 1000000000.0));
            dispatch_source_set_timer(sourcea, v106, 0xFFFFFFFFFFFFFFFFLL, 0);
            source = (dispatch_source_t)objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: EAPATNotifBlacklist expiry timer set to fire in %f seconds from now", "__WiFiDeviceManagerProcessAssociationFailure", *(_QWORD *)&v105);
          }
          objc_autoreleasePoolPop(source);
          if (v95)
            CFRelease(v95);
          if (v109)
            CFRelease(v109);
          goto LABEL_216;
        }
        if (v94 == 1026)
        {
          objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", sub_1000FCB38(a1, 11, -369032214, 0, 5), v77);
          goto LABEL_176;
        }
        v104 = sub_10002BE64((uint64_t)v117, CFSTR("BSSID"));
        objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", sub_1000FCB38(a1, 7, -369032214, (uint64_t)v104, 5), v77);
      }
LABEL_216:
      v78 = 5;
LABEL_137:
      v79 = sub_10002BE64((uint64_t)v117, CFSTR("BSSID"));
      v80 = sub_1000FCB38(a1, v78, (int)a4, (uint64_t)v79, 5);
      objc_msgSend(*(id *)(a1 + 6648), "setNetworkDenyListInfo:forScanResult:", v80, v77);

      objc_autoreleasePoolPop(v76);
      v73 = (uint64_t)v117;
    }
LABEL_138:
    sub_100132B40(a1, v73);
    v81 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v82 = v117 ? sub_10002B088(v117) : CFSTR("Unknown");
      v83 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to associate with %@, reason %d, WFMacRandomisation : is mac address private ? : <%d>"), v82, a4, v111)), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v84 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v83, "UTF8String")), "UTF8String");
        *(_DWORD *)v127 = 136446210;
        v128 = v84;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", v127, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v81);
    if ((int)a4 > -3913)
    {
      if ((_DWORD)a4 == -3912)
      {
        v91 = sub_100025C3C(*(_QWORD *)(a1 + 64));
        v52 = sub_100119668(a1, v91, 1, 1, v117, 0);
        v92 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %@", "__WiFiDeviceManagerProcessAssociationFailure", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
        objc_autoreleasePoolPop(v92);
        goto LABEL_184;
      }
      v85 = v116;
      if ((_DWORD)a4 == 82)
      {
        v52 = 0;
        goto LABEL_185;
      }
      if ((_DWORD)a4 == -100)
      {
        if (sub_1000C5BD8(v117))
          v86 = 3;
        else
          v86 = 1;
        v87 = sub_100025C3C(*(_QWORD *)(a1 + 64));
        v52 = sub_100119668(a1, v87, v86, 1, v117, 0);
        v88 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %@", "__WiFiDeviceManagerProcessAssociationFailure", sub_100031FD0(*(_DWORD *)(a1 + 3280)));
        objc_autoreleasePoolPop(v88);
        v85 = v116;
        if ((_DWORD)v52 == 14)
        {
          sub_100125A48(a1, v117, 1);
          v52 = 14;
LABEL_184:
          v85 = v116;
        }
LABEL_185:
        if ((value & 1) != 0 || *(uint64_t *)(a1 + 1128) > 1)
        {
          *(_QWORD *)(a1 + 1128) = 0;
LABEL_191:
          if (v85)
            CFRelease(v85);
          goto LABEL_193;
        }
LABEL_187:
        v101 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Retrying (WFMacRandomisation : Attempting again for migration? <%d> autojoin association of %@ with retry count %ld", cfa, sub_10002B088(v117), *(_QWORD *)(a1 + 1128));
        objc_autoreleasePoolPop(v101);
        *(int64x2_t *)(a1 + 1120) = vaddq_s64(*(int64x2_t *)(a1 + 1120), (int64x2_t)xmmword_1001BBC60);
        v85 = v116;
        goto LABEL_191;
      }
LABEL_164:
      if ((_DWORD)a4 == -3905 && v110)
      {
        v93 = *(const __CFArray **)(a1 + 1112);
        if (v93)
        {
          if (CFArrayGetCount(v93))
          {
            v85 = v116;
            if (*(_QWORD *)(a1 + 1128) < 2uLL)
              goto LABEL_187;
            goto LABEL_185;
          }
          goto LABEL_184;
        }
      }
      goto LABEL_185;
    }
    v85 = v116;
    if ((_DWORD)a4 != -369033215)
    {
      if ((_DWORD)a4 != -369033213)
        goto LABEL_164;
      sub_100135D8C(a1, CFSTR("autoJoinEAPNeedsUserFix"), 0, 0);
      if (!v11)
        goto LABEL_184;
      *(_QWORD *)(a1 + 1128) = -1;
      if (CFDictionaryGetValue(v11, CFSTR("TLSServerCertificateChain")))
      {
        v89 = sub_100025C3C(*(_QWORD *)(a1 + 64));
        v90 = sub_100119668(a1, v89, 2, 2, v117, (uint64_t)v11);
LABEL_183:
        v52 = v90;
        goto LABEL_184;
      }
      v97 = (const __CFArray *)CFDictionaryGetValue(v11, CFSTR("RequiredProperties"));
      v98 = v97;
      if (!v97)
        goto LABEL_184;
      v134.length = CFArrayGetCount(v97);
      v134.location = 0;
      if (!CFArrayGetFirstIndexOfValue(v98, v134, CFSTR("UserName")))
      {
        v135.length = CFArrayGetCount(v98);
        v135.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v98, v135, CFSTR("UserPassword"));
        v85 = v116;
        if (!FirstIndexOfValue)
          goto LABEL_185;
      }
    }
    v100 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    v90 = sub_100119668(a1, v100, 3, 1, v117, 0);
    goto LABEL_183;
  }
  v52 = (uint64_t)sub_1000078D0(a1);
LABEL_193:
  v102 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %d, state %d\n", "__WiFiDeviceManagerProcessAssociationResult", a4, v52);
  objc_autoreleasePoolPop(v102);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if ((_DWORD)v52 == 14)
    {
      v52 = 14;
    }
    else
    {
      sub_100135D8C(a1, CFSTR("autoJoinAssociationFailure"), 0, 0);
      sub_100132420(a1, (uint64_t)a2, (int)a4, CWFManagerErrorDomain, (uint64_t)CFSTR("Association failed"));
      v52 = 0;
    }
  }
  else
  {
    if ((_DWORD)v52 == 12)
      v52 = sub_100130A04(a1);
    if (v52 <= 5 && ((1 << v52) & 0x23) != 0)
      sub_100135D8C(a1, CFSTR("autoJoinAssociationFailure"), 0, 0);
  }
  if (v11)
    CFRelease(v11);
LABEL_77:
  objc_autoreleasePoolPop(context);
  return v52;
}

void sub_10012AD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012AD94(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  const void *v5;
  uint64_t v6;
  unsigned int v7;
  void *v8;
  void *v9;
  void *v10;
  const void *v11;
  CFAbsoluteTime Current;
  CFDateRef v13;
  NSError *v14;
  int v15;
  int v16;
  uint64_t v17;
  const void *v18;
  CFAbsoluteTime v20;
  CFDateRef v21;
  NSDate *v22;
  void *v23;
  _WORD *v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  _QWORD block[6];
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;

  v2 = *(unsigned int *)(a1 + 3280);
  v3 = *(_QWORD *)(a1 + 224);
  if (!v3 || !sub_1000D71FC(v3))
    return v2;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: notification %@ currentState %@", "__WiFiDeviceManagerProcessUserResponse", *(_QWORD *)(a1 + 224), sub_100031FD0(v2));
  objc_autoreleasePoolPop(v4);
  *(_DWORD *)(a1 + 3280) = 12;
  v5 = *(const void **)(a1 + 224);
  *(_QWORD *)(a1 + 224) = 0;
  switch(sub_1000D71EC((uint64_t)v5))
  {
    case 0u:
      v6 = (uint64_t)sub_100133EAC(a1, (uint64_t)v5);
      goto LABEL_28;
    case 1u:
    case 3u:
      v6 = sub_100133688(a1, (uint64_t)v5);
      goto LABEL_28;
    case 2u:
      v6 = sub_100133940(a1, (uint64_t)v5);
      goto LABEL_28;
    case 5u:
      v2 = *(unsigned int *)(a1 + 3280);
      v7 = sub_1000D71FC((uint64_t)v5);
      v8 = (void *)sub_1000C053C((uint64_t)v5);
      v9 = objc_autoreleasePoolPush();
      v10 = (void *)qword_10026DD20;
      if (v8)
      {
        if (qword_10026DD20)
        {
          v11 = sub_10002B088(v8);
          objc_msgSend(v10, "WFLog:message:", 3, "%s: network %@ ResponseType=%@", "__WiFiDeviceManagerProcessJoinRecommendationNotification", v11, sub_1000D75DC(v7));
        }
        objc_autoreleasePoolPop(v9);
        switch(v7)
        {
          case 1u:
            Current = CFAbsoluteTimeGetCurrent();
            v13 = CFDateCreate(kCFAllocatorDefault, Current);
            sub_10002C478((uint64_t)v8, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"), v13);
            if (v13)
              CFRelease(v13);
            v14 = sub_1001161F4(a1, v8, 1);
            if ((_DWORD)v14)
              goto LABEL_39;
            break;
          case 2u:
            sub_1001328A8(a1, v8, 1);
            goto LABEL_27;
          case 3u:
            goto LABEL_27;
          case 5u:
            v20 = CFAbsoluteTimeGetCurrent();
            v21 = CFDateCreate(kCFAllocatorDefault, v20);
            v22 = sub_1000649A4((uint64_t)v21, 5, 0, 0);
            v23 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user muted network, disabling network until %@", "__WiFiDeviceManagerProcessJoinRecommendationNotification", v22);
            objc_autoreleasePoolPop(v23);
            sub_1000C68E8((CFMutableDictionaryRef *)v8, 0, CFSTR("JoinRecommendation"));
            sub_1000C682C((uint64_t)v8, v22);
            sub_1001053C8((NSObject **)a1, v8);
            if (v21)
              CFRelease(v21);
            if (v22)
              CFRelease(v22);
            break;
          default:
            goto LABEL_29;
        }
        goto LABEL_29;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "__WiFiDeviceManagerProcessJoinRecommendationNotification");
      v27 = v9;
      goto LABEL_55;
    case 0xAu:
      v15 = sub_1000D71FC((uint64_t)v5);
      v6 = sub_100134010(a1, v15);
      goto LABEL_28;
    case 0xCu:
      v2 = *(unsigned int *)(a1 + 3280);
      v16 = sub_1000D71FC((uint64_t)v5);
      v17 = sub_1000C053C((uint64_t)v5);
      if (v17)
      {
        if (v16 != 3)
        {
          if (v16 != 2)
          {
            if (v16 != 1)
              goto LABEL_29;
            v8 = (void *)v17;
            v18 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
            sub_1000F7F48(a1, v18, 1019, "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendationNotification", 36940);
            if (sub_1000C5C14((uint64_t)v8))
            {
              sub_10013427C(0, (CFDictionaryRef *)v8);
              goto LABEL_29;
            }
            v14 = sub_1001161F4(a1, v8, 0);
            if ((_DWORD)v14)
            {
LABEL_39:
              v6 = sub_100129744(a1, v8, 0, (uint64_t)v14);
              goto LABEL_28;
            }
            sub_100135D8C(a1, CFSTR("autoJoinAssociating"), v8, 0);
            if (*(_QWORD *)(a1 + 4584))
            {
              if (*(_QWORD *)(a1 + 240))
              {
                v30 = 0;
                v31 = &v30;
                v32 = 0x2020000000;
                v33 = 0;
                v24 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v8);
                v31[3] = (uint64_t)v24;
                if (v24)
                {
                  CFRetain((CFTypeRef)a1);
                  v25 = *(NSObject **)(a1 + 240);
                  block[0] = _NSConcreteStackBlock;
                  block[1] = 3221225472;
                  block[2] = sub_1001348F8;
                  block[3] = &unk_10022F160;
                  block[4] = &v30;
                  block[5] = a1;
                  dispatch_async(v25, block);
                }
                _Block_object_dispose(&v30, 8);
              }
              else
              {
                v26 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendationNotification");
                objc_autoreleasePoolPop(v26);
              }
            }
            v2 = 12;
            goto LABEL_29;
          }
          *(_BYTE *)(a1 + 6987) = 0;
        }
LABEL_27:
        v6 = sub_100130A04(a1);
LABEL_28:
        v2 = v6;
        goto LABEL_29;
      }
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendationNotification");
      v27 = v28;
LABEL_55:
      objc_autoreleasePoolPop(v27);
LABEL_29:
      if (v5)
        CFRelease(v5);
      return v2;
    default:
      v2 = *(unsigned int *)(a1 + 3280);
      goto LABEL_29;
  }
}

void sub_10012B294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012B2AC(uint64_t a1)
{
  unsigned int v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  CFIndex v6;
  uint64_t v7;
  void *v8;
  CFIndex v9;
  CFIndex v10;
  void *v11;
  CFIndex v12;
  int v13;
  void *v14;
  id v15;
  const void *v16;
  CFIndex v17;
  const void *ValueAtIndex;
  const void *v19;
  const void *v20;
  int v21;
  const __CFDate *v22;
  const __CFDate *v23;
  void *v24;
  void *v25;
  double Current;
  double v27;
  void *v28;
  uint64_t v29;
  id v32;
  const void *v33;
  const __CFString *v34;
  id v35;
  id v36;
  uint64_t v37;
  void *v38;
  _WORD *v39;
  const void *v40;
  uint64_t v41;
  void *v42;
  unsigned int v43;
  uint64_t v44;
  int v45;

  v2 = *(_DWORD *)(a1 + 3280);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 6840));
  v4 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6912));
  v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6920));
  v6 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6928));
  v44 = Count;
  if (!Count)
    goto LABEL_51;
  v7 = v6;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hotspot interface found device %@", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", *(_QWORD *)(a1 + 6840));
  objc_autoreleasePoolPop(v8);
  if (v44 < 1)
  {
    Count = 0;
    goto LABEL_51;
  }
  v43 = v2;
  v9 = 0;
  while (1)
  {
    Count = (CFIndex)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6840), v9);
    if (v4 < 1)
    {
LABEL_10:
      v45 = 1;
    }
    else
    {
      v10 = 0;
      while (!objc_msgSend(*(id *)(a1 + 6744), "isEqualHotspotDevices:compareTo:", CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6912), v10), Count))
      {
        if (v4 == ++v10)
          goto LABEL_10;
      }
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot blacklisted: User cancelled \n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices");
      objc_autoreleasePoolPop(v11);
      v45 = 0;
    }
    if (v5 < 1)
    {
LABEL_18:
      v13 = 1;
      if (!v7)
        goto LABEL_29;
    }
    else
    {
      v12 = 0;
      while (!objc_msgSend(*(id *)(a1 + 6744), "isEqualHotspotDevices:compareTo:", CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6920), v12), Count))
      {
        if (v5 == ++v12)
          goto LABEL_18;
      }
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot blacklisted: Peer declined \n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices");
      objc_autoreleasePoolPop(v14);
      v13 = 0;
      if (!v7)
      {
LABEL_29:
        v21 = 1;
        goto LABEL_35;
      }
    }
    v15 = objc_msgSend(*(id *)(a1 + 6744), "getHotspotDeviceName:", Count);
    if (v7 < 1)
      goto LABEL_29;
    v16 = v15;
    v17 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6928), v17);
      if (ValueAtIndex)
      {
        v19 = ValueAtIndex;
        v20 = sub_10002B088(ValueAtIndex);
        if (CFEqual(v16, v20))
          break;
      }
      if (v7 == ++v17)
        goto LABEL_28;
    }
    v22 = (const __CFDate *)sub_10002BE64((uint64_t)v19, CFSTR("lastDisconnectTimestampKey"));
    if (v22 && (v23 = v22, !sub_1000C4C88((uint64_t)v19)))
    {
      Current = CFAbsoluteTimeGetCurrent();
      v27 = Current - CFDateGetAbsoluteTime(v23);
      v28 = objc_autoreleasePoolPush();
      if (v27 >= 3600.0)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Remove Hotspot from Denylist\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices");
        objc_autoreleasePoolPop(v28);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 6928), v17);
LABEL_28:
        v21 = 1;
        goto LABEL_35;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot denylisted due to Deauth on %@\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", v23);
      objc_autoreleasePoolPop(v28);
      v21 = 0;
    }
    else
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot %@ denylisted until user Join\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", sub_10002B088(v19));
      objc_autoreleasePoolPop(v24);
      v21 = 0;
    }
LABEL_35:
    if (!objc_msgSend(*(id *)(a1 + 6744), "isHotspotDeviceSupportADHS:", Count))
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ADHS not Supported. Ignoring hotspot\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices");
      objc_autoreleasePoolPop(v25);
      goto LABEL_41;
    }
    if ((v45 & v13 & v21 & 1) != 0)
      break;
LABEL_41:
    if (++v9 == v44)
      goto LABEL_51;
  }
  *(_QWORD *)(a1 + 6904) = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6840), v9);
  if (sub_10011BB88(a1))
  {
    v32 = objc_msgSend(*(id *)(a1 + 6744), "getHotspotDeviceName:", *(_QWORD *)(a1 + 6904));
    v33 = sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("SSID_STR"));
    if (CFEqual(v32, v33))
      *(_BYTE *)(a1 + 6968) = 1;
  }
  if (*(_DWORD *)(a1 + 6804) != 1 || *(_BYTE *)(a1 + 6968))
  {
    v29 = sub_10012B860(a1, *(_QWORD *)(a1 + 6904));
    goto LABEL_52;
  }
  v34 = (const __CFString *)objc_msgSend(*(id *)(a1 + 6744), "getHotspotDeviceName:", *(_QWORD *)(a1 + 6904));
  if (_os_feature_enabled_impl("WiFiManager", "AskToJoinPersonalHotspotBanner"))
  {
    v35 = objc_msgSend(*(id *)(a1 + 6704), "dispatchNotificationWithAskToJoinHotspotRecommendation:", v34);
    if ((_DWORD)v35)
    {
      v36 = v35;
      v37 = *(unsigned int *)(a1 + 3280);
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Hotspot Recommendation notification failed: %d", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", v36);
      objc_autoreleasePoolPop(v38);
    }
    else
    {
      v37 = 14;
    }
LABEL_70:
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: State %d", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", v37);
    objc_autoreleasePoolPop(v42);
    if ((_DWORD)v37 == 14)
    {
      *(_DWORD *)(a1 + 6716) = 1;
      return 17;
    }
LABEL_51:
    sub_1000F48F0(a1, 0);
    *(_QWORD *)(a1 + 6872) = 0;
    v29 = *(unsigned int *)(a1 + 6892);
    goto LABEL_52;
  }
  v39 = sub_1000C323C(v34);
  if (v39)
  {
    v40 = v39;
    v41 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    v37 = sub_100119668(a1, v41, 10, 0, v40, 0);
    CFRelease(v40);
    goto LABEL_70;
  }
  v29 = v43;
LABEL_52:
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") && (v29 & 0xFFFFFFFD) != 0x11)
    sub_100134768(a1, (uint64_t)objc_msgSend(*(id *)(a1 + 6744), "getHotspotDeviceName:", Count), 45, (CFErrorDomain)NSPOSIXErrorDomain, (uint64_t)CFSTR("Failed to process candidate hotspot device"));
  return v29;
}

uint64_t sub_10012B860(uint64_t a1, uint64_t a2)
{
  id v3;
  NSObject *global_queue;
  uint64_t v5;
  _QWORD v7[8];
  _QWORD v8[6];
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  uint64_t v15;

  v10 = 0;
  v11 = &v10;
  v12 = 0x3052000000;
  v13 = sub_10002FAA8;
  v14 = sub_10002F9A4;
  v15 = a2;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x3052000000;
  v9[3] = sub_10002FAA8;
  v9[4] = sub_10002F9A4;
  v9[5] = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x3052000000;
  v8[3] = sub_10002FAA8;
  v8[4] = sub_10002F9A4;
  v8[5] = 0;
  if (!*(_BYTE *)(a1 + 7008))
  {
    *(_DWORD *)(a1 + 3280) = 19;
    *(_BYTE *)(a1 + 7008) = 1;
    sub_1001345E4((uint64_t *)a1, CFSTR("userJoinStarted"), 0);
    v3 = (id)v11[5];
    global_queue = dispatch_get_global_queue(0, 0);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1001349CC;
    v7[3] = &unk_1002318C0;
    v7[4] = v8;
    v7[5] = &v10;
    v7[6] = v9;
    v7[7] = a1;
    dispatch_async(global_queue, v7);
  }
  v5 = *(unsigned int *)(a1 + 3280);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(&v10, 8);
  return v5;
}

void sub_10012B99C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012B9CC(uint64_t a1, _BYTE *a2)
{
  void *v4;
  void *v5;
  id v6;
  int v7;
  double v8;
  void *v9;
  id v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  const void *v17;
  CFIndex v18;
  const void *ValueAtIndex;
  CFIndex v20;
  void *v21;
  void *v22;
  void *v23;
  const char *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v33;
  void *v34;
  void *v35;
  id v36;

  v4 = objc_autoreleasePoolPush();
  v36 = 0;
  if (!a1)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Manager is NULL!", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
    goto LABEL_71;
  }
  if (!a2)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:LeechLocation field is NULL!", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
LABEL_71:
    v34 = v33;
LABEL_72:
    objc_autoreleasePoolPop(v34);
    v6 = 0;
LABEL_73:
    LOBYTE(v7) = 1;
    v12 = 0.0;
    goto LABEL_56;
  }
  if (*(_BYTE *)(a1 + 5609))
  {
    *a2 = 1;
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:Debug mode to not consider geotagged results is enabled!", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
    objc_autoreleasePoolPop(v5);
    v6 = 0;
    LOBYTE(v7) = 0;
    v8 = 0.0;
    goto LABEL_60;
  }
  *(_OWORD *)(a1 + 6124) = 0u;
  *a2 = 0;
  v6 = sub_100009ACC(a1);
  v9 = objc_autoreleasePoolPush();
  if (!v6)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Location is NULL!", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
    v34 = v9;
    goto LABEL_72;
  }
  v10 = objc_msgSend(v6, "timestamp");
  if (!v10)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location timestamp is nil", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
    objc_autoreleasePoolPop(v35);
    objc_autoreleasePoolPop(v9);
    goto LABEL_73;
  }
  objc_msgSend(v10, "timeIntervalSinceNow");
  v12 = v11;
  objc_autoreleasePoolPop(v9);
  if (v12 <= -120.0)
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location is older than 120 secs", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
    goto LABEL_55;
  }
  if ((objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyHigherBandNetworksAvailableAtLocation:intoArray:", v6, &v36) & 1) == 0)
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed in copying high band networks!", "__WiFiDeviceManagerIsGeotagged5GhzNetworkPresent");
LABEL_55:
    objc_autoreleasePoolPop(v31);
    LOBYTE(v7) = 1;
    goto LABEL_56;
  }
  *a2 = 1;
  v8 = 0.0;
  if (!v36 || (v13 = (uint64_t)objc_msgSend(v36, "count"), v13 < 1))
  {
    LOBYTE(v7) = 0;
    goto LABEL_60;
  }
  v14 = v13;
  v15 = 0;
  v7 = 0;
  do
  {
    v16 = objc_msgSend(v36, "objectAtIndexedSubscript:", v15);
    if (!v16)
    {
      v22 = objc_autoreleasePoolPush();
      v23 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v24 = "Network NULL from network store!";
        goto LABEL_25;
      }
LABEL_26:
      v25 = v22;
      goto LABEL_27;
    }
    v17 = v16;
    v18 = sub_1000CB39C(*(const __CFArray **)(a1 + 3528), (uint64_t)v16);
    if (v18 == -1 || (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v18)) == 0)
    {
      v20 = sub_1000CB39C(*(const __CFArray **)(a1 + 3536), (uint64_t)v17);
      if (v20 == -1)
      {
        ++*(_DWORD *)(a1 + 6136);
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Considering %@ network from store not in known list!", sub_10002B088(v17));
        v28 = v27;
LABEL_35:
        objc_autoreleasePoolPop(v28);
        v7 = 1;
        goto LABEL_36;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v20);
      if (!ValueAtIndex)
      {
        v22 = objc_autoreleasePoolPush();
        v23 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v24 = "knownNetwork NULL!";
LABEL_25:
          objc_msgSend(v23, "WFLog:message:", 4, v24);
        }
        goto LABEL_26;
      }
    }
    if (sub_10002DA5C((_BOOL8)ValueAtIndex))
    {
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "In proximity of Geotagged hotspot20 %@ - Ignoring!", sub_10002B088(ValueAtIndex));
      objc_autoreleasePoolPop(v21);
      ++*(_DWORD *)(a1 + 6124);
      goto LABEL_36;
    }
    if (!sub_1000137D8((uint64_t)ValueAtIndex))
    {
      if (sub_10000BE8C((uint64_t)ValueAtIndex))
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "In proximity of Geotagged carplay nw %@ - Ignoring!", sub_10002B088(ValueAtIndex));
        goto LABEL_46;
      }
      if (sub_10001395C((uint64_t)ValueAtIndex))
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "In proximity of Geotagged PH %@ - Ignoring!", sub_10002B088(ValueAtIndex));
LABEL_46:
        v25 = v29;
LABEL_27:
        objc_autoreleasePoolPop(v25);
        goto LABEL_36;
      }
      if (sub_10001F440(ValueAtIndex))
        ++*(_DWORD *)(a1 + 5860);
      else
        ++*(_DWORD *)(a1 + 6136);
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "In proximity of Geotagged Network %@", sub_10002B088(ValueAtIndex));
      v28 = v30;
      goto LABEL_35;
    }
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "In proximity of Geotagged hotspot %@ - Ignoring!", sub_10002B088(ValueAtIndex));
    objc_autoreleasePoolPop(v26);
    ++*(_DWORD *)(a1 + 6128);
LABEL_36:
    ++v15;
  }
  while (v14 != v15);
  if (!v7)
    goto LABEL_60;
LABEL_56:
  if (v12 <= -0.001)
    v8 = v12 * -1000.0;
  else
    v8 = 1.0;
LABEL_60:
  *(double *)(a1 + 6152) = v8;
  if (v36)

  if (v6)
    CFRelease(v6);
  objc_autoreleasePoolPop(v4);
  return v7;
}

void sub_10012BF90(uint64_t a1, void *a2)
{
  void *v4;
  id v5;
  id v6;
  void *v7;
  unint64_t v8;
  int v9;
  id v10;
  unsigned __int16 v11;
  int v13;
  int v14;
  int v15;
  void *v16;

  if (!sub_100124B34(a1, a2, 0))
  {
    v4 = objc_autoreleasePoolPush();
    v5 = sub_100027D10((uint64_t)a2);
    v6 = objc_msgSend(*(id *)(a1 + 6648), "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:", v5, 1, 0, 0);
    if (v6)
    {
      v7 = v6;
      if (objc_msgSend(v6, "count"))
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = objc_msgSend(v7, "objectAtIndex:", v8);
          if (v10)
          {
            v11 = (unsigned __int16)objc_msgSend(v10, "unsignedIntegerValue");
            if (v11 <= 0xCu && ((1 << v11) & v9) == 0)
            {
              v9 |= (unsigned __int16)(1 << v11);
              ++*(_WORD *)(a1 + 2 * v11 + 5972);
            }
          }
          ++v8;
        }
        while (v8 < (unint64_t)objc_msgSend(v7, "count"));
      }
      if ((objc_msgSend(*(id *)(a1 + 6648), "isNetworkDenyListedForAutoJoinDueToTrigDisc:RSSI:timestamp:", v5, 0, 0) & 1) != 0)
      {
        v13 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
        if (v13 > -96)
        {
          if (v13 > -91)
          {
            if (v13 > -86)
            {
              if (v13 > -81)
              {
                if (v13 > -76)
                {
                  v15 = *(_DWORD *)(a1 + 6140);
                  if (v13 > -71)
                    v14 = v15 | 0x40;
                  else
                    v14 = v15 | 0x20;
                }
                else
                {
                  v14 = *(_DWORD *)(a1 + 6140) | 0x10;
                }
              }
              else
              {
                v14 = *(_DWORD *)(a1 + 6140) | 8;
              }
            }
            else
            {
              v14 = *(_DWORD *)(a1 + 6140) | 4;
            }
          }
          else
          {
            v14 = *(_DWORD *)(a1 + 6140) | 2;
          }
        }
        else
        {
          v14 = *(_DWORD *)(a1 + 6140) | 1;
        }
        *(_DWORD *)(a1 + 6140) = v14;
      }
    }
    else
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s !__WiFiDeviceManagerIsNetworkSuitableForAutojoin but couldn't get problematicNetwork", "__WiFiDeviceManagerTrackBlacklistedNetworksExcludedFromAutoJoin");
      objc_autoreleasePoolPop(v16);
    }

    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_10012C188(uint64_t a1, _DWORD *a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v10;
  const char *v11;
  uint64_t v12;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL manager", "__WiFiDeviceManagerDisallow24GhzAJScans");
    goto LABEL_22;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ajTestMode.isCarPlay is ON", "__WiFiDeviceManagerDisallow24GhzAJScans");
    objc_autoreleasePoolPop(v4);
  }
  if (*(_BYTE *)(a1 + 49))
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ajTestMode.isBTA2DP is ON", "__WiFiDeviceManagerDisallow24GhzAJScans");
    objc_autoreleasePoolPop(v5);
  }
  if (*(_BYTE *)(a1 + 50))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ajTestMode.isBTSCO is ON", "__WiFiDeviceManagerDisallow24GhzAJScans");
    objc_autoreleasePoolPop(v6);
  }
  if (a2)
    *a2 = 0;
  if (!*(_BYTE *)(a1 + 5496) && !*(_BYTE *)(a1 + 48))
  {
    if (*(_BYTE *)(a1 + 7056)
      && *(_BYTE *)(a1 + 5219)
      && *(unsigned __int8 *)(a1 + 5216) <= 0xDu
      && (*(_BYTE *)(a1 + 7057) & 4) != 0)
    {
      if (a2)
        *a2 = 4;
      v7 = objc_autoreleasePoolPush();
      v10 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_52;
      v11 = "AJScan: Disallowing 2.4Ghz channels due to Active MIS session";
    }
    else if (*(_BYTE *)(a1 + 36)
           && *(_DWORD *)(a1 + 3352) == 4
           && (*(_DWORD *)(a1 + 5396) == 102 && (*(_BYTE *)(a1 + 5392) & 2) != 0 || *(_BYTE *)(a1 + 49)))
    {
      if (a2)
        *a2 = 1;
      v7 = objc_autoreleasePoolPush();
      v10 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_52;
      v11 = "AJScan: Disallowing 2.4Ghz channels due to BT-A2DP active while driving";
    }
    else
    {
      if (!*(_BYTE *)(a1 + 37)
        || (*(_DWORD *)(a1 + 5396) != 102 || (*(_BYTE *)(a1 + 5392) & 1) == 0) && !*(_BYTE *)(a1 + 50))
      {
        return 0;
      }
      if (a2)
        *a2 = 2;
      v7 = objc_autoreleasePoolPush();
      v10 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_52;
      v11 = "AJScan: Disallowing 2.4Ghz channels due to BT-SCO active";
    }
    objc_msgSend(v10, "WFLog:message:", 4, v11);
LABEL_52:
    v8 = 1;
    goto LABEL_23;
  }
  if (a2)
    *a2 = 3;
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Disallowing 2.4Ghz channels due to CarPlay", v12);
LABEL_22:
  v8 = 0;
LABEL_23:
  objc_autoreleasePoolPop(v7);
  return v8;
}

uint64_t sub_10012C418(_BYTE *a1, _DWORD *a2)
{
  uint64_t v2;
  void *v4;

  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL manager", "__WiFiDeviceManagerDisallow5GhzChannelAJScans");
    v2 = 0;
    goto LABEL_16;
  }
  if (a2)
    *a2 = 0;
  if (a1[7056] && a1[5219] && a1[5216] >= 0xFu && (a1[7057] & 4) != 0 && !a1[1064])
  {
    if (a2)
      *a2 = 4;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "AJScan: Disallowing 5Ghz channels due to Active 5GHz MIS session");
    v2 = 1;
LABEL_16:
    objc_autoreleasePoolPop(v4);
    return v2;
  }
  return 0;
}

uint64_t sub_10012C500(uint64_t a1, const __CFArray *a2, CFArrayRef theArray, unsigned int a4, uint64_t a5)
{
  __CFDictionary *v10;
  const __CFDictionary *v11;
  id v12;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFString *Mutable;
  __CFString *v20;
  uint64_t v21;
  const __CFString *v22;
  void *v23;
  uint64_t v24;
  const __CFString *v25;
  uint64_t v26;
  const __CFString *v27;
  uint64_t v28;
  const __CFString *v29;
  uint64_t v30;
  const __CFString *v31;
  const __CFString *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  BOOL v39;
  const void *v40;
  void *v42;
  void *v43;
  void *v44;

  if (!theArray || !*(_BYTE *)(a1 + 3414) || CFArrayGetCount(theArray) == 1)
  {
    v10 = sub_100116F8C(a2, theArray, 0, a4, 1);
    if (!v10)
      return 4294963396;
    v11 = v10;
    v12 = sub_100009ACC(a1);
    v13 = objc_autoreleasePoolPush();
    if (v12)
    {
      v14 = objc_msgSend(v12, "timestamp");
      if (!v14)
      {
        v44 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location timestamp is nil", "__WiFiDeviceManagerCollectAutoJoinMetrics");
        objc_autoreleasePoolPop(v44);
        objc_autoreleasePoolPop(v13);
LABEL_41:
        CFRelease(v12);
LABEL_42:
        *(_DWORD *)(a1 + 192) = 18;
        v37 = (uint64_t *)malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
        if (v37)
        {
          v38 = v37;
          objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "autoJoinUpdatedWithState:interfaceName:", 2, sub_100025C3C(*(_QWORD *)(a1 + 64)));
          *v38 = a1;
          v38[1] = 0;
          v38[3] = 0;
          if (CFDictionaryContainsKey(v11, CFSTR("SSID_STR")))
            v39 = 1;
          else
            v39 = CFDictionaryContainsKey(v11, CFSTR("SCAN_SSID_LIST")) != 0;
          *((_BYTE *)v38 + 32) = v39;
          v40 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
          v24 = sub_100018C78(a1, v40, v11, 0, (uint64_t)sub_10012D384, (uint64_t)v38, (_QWORD *)(a1 + 3312), a5);
          if ((_DWORD)v24)
          {
            v43 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error initiating scan request: %d", v24);
            objc_autoreleasePoolPop(v43);
            free(v38);
          }
        }
        else
        {
          v42 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "__WiFiDeviceManagerScan");
          objc_autoreleasePoolPop(v42);
          v24 = 4294963396;
        }
        CFRelease(v11);
        return v24;
      }
      objc_msgSend(v14, "timeIntervalSinceNow");
      *(_QWORD *)(a1 + 6104) = v15;
      objc_autoreleasePoolPop(v13);
      objc_msgSend(v12, "horizontalAccuracy");
      *(_QWORD *)(a1 + 6080) = v16;
      objc_msgSend(v12, "coordinate");
      *(_QWORD *)(a1 + 6088) = v17;
      objc_msgSend(v12, "coordinate");
      *(_QWORD *)(a1 + 6096) = v18;
      if (*(double *)(a1 + 6088) != 0.0)
      {
        ++*(_WORD *)(a1 + 6112);
        goto LABEL_13;
      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Location is Nil");
      objc_autoreleasePoolPop(v13);
      *(_OWORD *)(a1 + 6096) = 0u;
      *(_OWORD *)(a1 + 6080) = 0u;
    }
    ++*(_WORD *)(a1 + 6114);
LABEL_13:
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    if (Mutable)
    {
      v20 = Mutable;
      v21 = *(int *)(a1 + 5620);
      if (v21 > 0xC)
        v22 = CFSTR("UnknownScan");
      else
        v22 = off_100232138[v21];
      if (*(_BYTE *)(a1 + 33) && *(_BYTE *)(a1 + 32))
        v25 = CFSTR("Scan-{");
      else
        v25 = CFSTR("_Scan-{");
      CFStringAppend(Mutable, v25);
      CFStringAppend(v20, v22);
      v26 = *(int *)(a1 + 5628);
      if (v26 <= 3)
      {
        v27 = off_1002321A0[v26];
        CFStringAppend(v20, CFSTR(" "));
        CFStringAppend(v20, v27);
      }
      v28 = *(int *)(a1 + 5632);
      if (v28 > 2)
      {
        CFStringAppendFormat(v20, 0, CFSTR(" %dsecs"), *(unsigned int *)(a1 + 5640));
      }
      else
      {
        v29 = off_1002321C0[v28];
        CFStringAppend(v20, CFSTR(" "));
        CFStringAppend(v20, v29);
      }
      v30 = *(int *)(a1 + 192);
      if (v30 <= 0xE)
      {
        v31 = off_1002321D8[v30];
        CFStringAppend(v20, CFSTR(" "));
        CFStringAppend(v20, v31);
      }
      CFStringAppend(v20, CFSTR("}  Expecting-["));
      CFStringAppendFormat(v20, 0, CFSTR("%dNW, %dHid, %dHS20, %dHS"), *(unsigned int *)(a1 + 6136), *(unsigned int *)(a1 + 6132), *(unsigned int *)(a1 + 6124), *(unsigned int *)(a1 + 6128));
      CFStringAppend(v20, CFSTR("] @ "));
      v32 = sub_100024674(*(_DWORD *)(a1 + 3352));
      CFStringAppendFormat(v20, 0, CFSTR("{%@, %.3f, %.3f, %.1fm, %.1fsecs}]"), v32, *(_QWORD *)(a1 + 6088), *(_QWORD *)(a1 + 6096), *(_QWORD *)(a1 + 6080), *(_QWORD *)(a1 + 6104));
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AJScan: %@", v20);
      objc_autoreleasePoolPop(v33);
      CFRelease(v20);
    }
    v34 = *(unsigned int *)(a1 + 5620);
    if (v34 <= 0xC)
    {
      *(_DWORD *)(a1 + 5624) = v34;
      ++*(_WORD *)(a1 + 5616 + 2 * v34 + 252);
      ++*(_DWORD *)(a1 + 5616 + 4 * v34 + 304);
    }
    v35 = *(unsigned int *)(a1 + 5632);
    if (v35 <= 2)
      ++*(_DWORD *)(a1 + 4 * v35 + 5664);
    v36 = *(unsigned int *)(a1 + 5636);
    if (v36 <= 0x11)
      ++*(_DWORD *)(a1 + 4 * v36 + 5676);
    *(_DWORD *)(a1 + 5620) = 13;
    *(_QWORD *)(a1 + 5632) = 0x1200000003;
    if (!v12)
      goto LABEL_42;
    goto LABEL_41;
  }
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Multi channel scan attempt not permitted because AWDL real time mode is active");
  objc_autoreleasePoolPop(v23);
  return 4294963366;
}

uint64_t sub_10012CA98(_DWORD *a1)
{
  int v1;
  unsigned int v2;
  void *v4;

  v1 = a1[821];
  if (v1 == 10)
    return sub_10012D770((uint64_t)a1);
  if (v1 == 6)
  {
    v2 = a1[166] + 1;
    a1[166] = v2;
    if (a1[172] == 1 && v2 <= 2)
      return sub_1001287BC();
    a1[166] = 0;
    a1[172] = 2;
    return sub_10012D770((uint64_t)a1);
  }
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Something went wrong. Should not come here.", "__WiFiDeviceManagerScheduleCarPlayRetry");
  objc_autoreleasePoolPop(v4);
  return 1;
}

uint64_t sub_10012CB54(uint64_t a1)
{
  const void *v2;
  void *v3;
  const __CFString *v4;
  NSString *v5;
  const __CFArray *v6;
  CFIndex Count;
  uint64_t v8;
  CFMutableArrayRef Mutable;
  const __CFArray *v10;
  CFIndex v11;
  uint64_t v12;
  const void *ValueAtIndex;
  __CFDictionary *v14;
  __CFDictionary *v15;
  CFIndex v16;
  uint64_t v17;
  size_t v18;
  char *v19;
  char *v20;
  const __CFDictionary *v21;
  const __CFNumber *Value;
  const void *v23;
  void *v25;
  const void *v26;
  CFMutableStringRef v27;
  void *v28;
  NSString *v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  CFMutableStringRef v33;
  void *v35;
  void *v36;
  void *v37;
  const char *v38;
  uint64_t v39;
  void *v40;
  const char *v41;
  CFMutableStringRef v42;
  uint64_t v43;
  CFMutableStringRef *v44;
  unsigned int valuePtr;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  CFMutableStringRef v49;

  v2 = *(const void **)(a1 + 1112);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  *(_DWORD *)(a1 + 1136) = 0;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = sub_100031FD0(*(_DWORD *)(a1 + 3284));
    v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: last state: %@, current state: %@, topNetwork %@"), "__WiFiDeviceManagerScanMRUNetworkChannels", v4, sub_100031FD0(*(_DWORD *)(a1 + 3280)), *(_QWORD *)(a1 + 3376))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v47 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v5, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v3);
  v6 = *(const __CFArray **)(a1 + 3576);
  if (!v6)
  {
    v36 = objc_autoreleasePoolPush();
    v37 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_81;
    v41 = "__WiFiDeviceManagerScanMRUNetworkChannels";
    v38 = "%s: NULL known filtered networks";
LABEL_74:
    v39 = 3;
LABEL_80:
    objc_msgSend(v37, "WFLog:message:", v39, v38, v41);
    goto LABEL_81;
  }
  Count = CFArrayGetCount(v6);
  if (!Count)
  {
    v36 = objc_autoreleasePoolPush();
    v37 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_81;
    v41 = "__WiFiDeviceManagerScanMRUNetworkChannels";
    v38 = "%s: No known filtered networks";
    goto LABEL_74;
  }
  v8 = Count;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null mruNetworkChanList", "__WiFiDeviceManagerScanMRUNetworkChannels");
    objc_autoreleasePoolPop(v40);
    v31 = 4294963394;
    goto LABEL_78;
  }
  v10 = Mutable;
  *(_DWORD *)(a1 + 5620) = 1;
  v42 = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (v8 < 1)
  {
    v12 = 8;
    goto LABEL_50;
  }
  v11 = 0;
  v12 = 8;
  while (1)
  {
    if (CFArrayGetCount(v10) > 3)
      goto LABEL_50;
    if (*(_DWORD *)(a1 + 3284) == 7)
    {
      *(_DWORD *)(a1 + 5620) = 12;
      ValueAtIndex = *(const void **)(a1 + 3376);
      v12 = 9;
      if (!ValueAtIndex)
        goto LABEL_50;
    }
    else
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), v11);
      if (!ValueAtIndex)
        goto LABEL_47;
    }
    v14 = sub_1000C85C4((uint64_t)ValueAtIndex);
    if (v14)
    {
      v15 = v14;
      v16 = CFDictionaryGetCount(v14);
      if (!v16)
      {
        CFRelease(v15);
        goto LABEL_47;
      }
      v17 = v16;
      v44 = &v42;
      __chkstk_darwin();
      v19 = (char *)&v42 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
      memset(v19, 170, v18);
      CFDictionaryGetKeysAndValues(v15, 0, (const void **)v19);
      if (v17 >= 1)
      {
        v43 = 0;
        v20 = v19 - 8;
        do
        {
          if (CFArrayGetCount(v10) > 3)
            break;
          v21 = *(const __CFDictionary **)&v20[8 * v17];
          if (v21)
          {
            Value = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("CHANNEL"));
            v23 = CFDictionaryGetValue(*(CFDictionaryRef *)&v20[8 * v17], CFSTR("CHANNEL_FLAGS"));
            if (Value && v23 != 0)
            {
              *(_DWORD *)buf = 0;
              if (sub_10012C188(a1, buf))
              {
                valuePtr = -1431655766;
                CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
                if (!valuePtr)
                  goto LABEL_43;
                if (valuePtr <= 0xE)
                {
                  v25 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 2.4Ghz MRU channel %d", "__WiFiDeviceManagerScanMRUNetworkChannels", valuePtr);
LABEL_36:
                  objc_autoreleasePoolPop(v25);
                  *(_DWORD *)(a1 + 6168) = *(_DWORD *)buf;
                  goto LABEL_43;
                }
              }
              *(_DWORD *)buf = 0;
              if (!sub_10012C418((_BYTE *)a1, buf))
                goto LABEL_37;
              valuePtr = -1431655766;
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              if (valuePtr)
              {
                if (valuePtr < 0xF)
                {
LABEL_37:
                  if (sub_10012E050(*(const __CFArray **)(a1 + 3288), Value) != 1)
                  {
                    CFArrayAppendValue(v10, *(const void **)&v20[8 * v17]);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3288), *(const void **)&v20[8 * v17]);
                    if (v42)
                    {
                      if (!v43)
                      {
                        v26 = sub_10002B088(ValueAtIndex);
                        CFStringAppendFormat(v42, 0, CFSTR(" \"%@\" on channels: "), v26);
                      }
                      CFStringAppendFormat(v42, 0, CFSTR("%@ "), Value);
                    }
                    ++v43;
                  }
                  goto LABEL_43;
                }
                v25 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 5Ghz MRU channel %d", "__WiFiDeviceManagerScanMRUNetworkChannels", valuePtr);
                goto LABEL_36;
              }
            }
          }
LABEL_43:
          --v17;
        }
        while ((unint64_t)(v17 + 1) > 1);
      }
      CFRelease(v15);
      if (*(_DWORD *)(a1 + 3284) == 7)
        break;
    }
LABEL_47:
    if (++v11 == v8)
      goto LABEL_50;
  }
  v35 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Top Networks MRU channels: %@", v42);
  objc_autoreleasePoolPop(v35);
LABEL_50:
  if (!CFArrayGetCount(v10))
  {
    v32 = objc_autoreleasePoolPush();
    v33 = v42;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No MRU channels", "__WiFiDeviceManagerScanMRUNetworkChannels");
    objc_autoreleasePoolPop(v32);
    if (v33)
      CFRelease(v33);
    CFRelease(v10);
    *(_DWORD *)(a1 + 3284) = v12;
    return sub_10012E0D8(a1);
  }
  v27 = v42;
  if (v42)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v29 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Scanning(%s) for MRU Networks"), "Active")), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v30 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v29, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v47 = v30;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v28);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      v47 = "Active";
      v48 = 2112;
      v49 = v27;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "{AUTOJOIN, SCAN} Scanning(%s) for MRU Networks: %@", buf, 0x16u);
    }
    CFRelease(v27);
  }
  v31 = sub_10012C500(a1, *(const __CFArray **)(a1 + 3552), v10, 0, 2);
  CFRelease(v10);
  if ((_DWORD)v31)
  {
LABEL_78:
    v36 = objc_autoreleasePoolPush();
    v37 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v41 = (const char *)v31;
      v38 = "multi-stage auto-join: Error scanning for MRU Networks, err=%d";
      v39 = 4;
      goto LABEL_80;
    }
LABEL_81:
    objc_autoreleasePoolPop(v36);
    return sub_10012E0D8(a1);
  }
  *(_DWORD *)(a1 + 3284) = v12;
  return v12;
}

void sub_10012D384(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v10;
  void *v11;
  unsigned int v12;
  CFIndex v13;
  const void *ValueAtIndex;
  const __CFArray *v15;
  const __CFArray *v16;
  const void *v17;
  const void *v18;
  const __CFString *v19;
  __CFArray *v20;
  void *v21;
  CFRange v22;
  CFRange v23;
  CFRange v24;

  v9 = *a6;
  v10 = sub_100070AFC(*(_QWORD *)(*a6 + 64));
  free(a6);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto join scan completed (%d) with current state: %@", a5, sub_100031FD0(*(_DWORD *)(v9 + 3280)));
  objc_autoreleasePoolPop(v11);
  if (v10 == *(_QWORD *)(v9 + 3312))
  {
    sub_10012D59C(v9, a3);
    *(_QWORD *)(v9 + 1096) = a3;
    *(_DWORD *)(v9 + 1088) = a5;
    v12 = *(_DWORD *)(v9 + 3280);
    if (v12 <= 0xB)
    {
      if (((1 << v12) & 0xFDC) != 0)
      {
        if (a3 && CFArrayGetCount(a3))
        {
          if (CFArrayGetCount(a3) >= 1)
          {
            v13 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(a3, v13);
              v15 = *(const __CFArray **)(v9 + 3536);
              v22.length = CFArrayGetCount(v15);
              v22.location = 0;
              LODWORD(v15) = CFArrayContainsValue(v15, v22, ValueAtIndex);
              v16 = *(const __CFArray **)(v9 + 3528);
              v23.length = CFArrayGetCount(v16);
              v23.location = 0;
              if (v15 | CFArrayContainsValue(v16, v23, ValueAtIndex))
              {
                v17 = sub_10002B088(ValueAtIndex);
                if (v17)
                {
                  v18 = v17;
                  v19 = (const __CFString *)sub_100029860(*(_QWORD *)(v9 + 64));
                  sub_10005B6CC(v9, v19, v18);
                }
              }
              ++v13;
            }
            while (v13 < CFArrayGetCount(a3));
          }
          v20 = *(__CFArray **)(v9 + 1104);
          v24.length = CFArrayGetCount(a3);
          v24.location = 0;
          CFArrayAppendArray(v20, a3, v24);
        }
        goto LABEL_19;
      }
      if (v12 == 5)
LABEL_19:
        sub_1000F49C8(v9);
    }
    *(_QWORD *)(v9 + 1096) = 0;
    return;
  }
  v21 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignorning old request.  CurrentCommand=%lld PendingCommand=%lld", v10, *(_QWORD *)(v9 + 3312));
  objc_autoreleasePoolPop(v21);
}

void sub_10012D59C(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4;
  const void *ValueAtIndex;
  const void *v6;
  const __CFArray *Mutable;
  CFIndex v8;
  const void *v9;
  const void *v10;
  void *v11;

  if (!theArray)
    return;
  if (!a1)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null ajMetrics.", "__WiFiDeviceManagerTrackScanResultsForAWDMetrics");
    goto LABEL_25;
  }
  if (!*(_QWORD *)(a1 + 6056))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scannedSSIDsThisSession.", "__WiFiDeviceManagerTrackScanResultsForAWDMetrics");
    goto LABEL_25;
  }
  if (!*(_QWORD *)(a1 + 6064))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null knownSSIDsScannedThisSession.", "__WiFiDeviceManagerTrackScanResultsForAWDMetrics");
LABEL_25:
    objc_autoreleasePoolPop(v11);
    return;
  }
  if (CFArrayGetCount(theArray) >= 1)
  {
    v4 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4);
      v6 = sub_10002B088(ValueAtIndex);
      if (v6)
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 6056), v6);
      ++v4;
    }
    while (v4 < CFArrayGetCount(theArray));
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (sub_1001186CC(a1, theArray, Mutable) && CFArrayGetCount(Mutable) >= 1)
  {
    v8 = 0;
    do
    {
      v9 = CFArrayGetValueAtIndex(Mutable, v8);
      v10 = sub_10002B088(v9);
      if (v10)
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 6064), v10);
      ++v8;
    }
    while (v8 < CFArrayGetCount(Mutable));
  }
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t sub_10012D770(uint64_t a1)
{
  const void *v2;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v4;
  int v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  CFMutableArrayRef v15;
  __CFArray *v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  CFMutableStringRef v22;
  int v23;
  void *v24;
  int v25;
  void *v26;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v29;
  void *Value;
  void *v31;
  CFDictionaryRef v32;
  CFDictionaryRef v33;
  int v34;
  void *v35;
  void *v36;
  NSString *v37;
  const char *v38;
  void *v39;
  void *v40;
  void *v41;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  uint32_t v48;
  double v49;
  NSObject *v50;
  dispatch_time_t v51;
  void *v52;
  NSString *v53;
  const char *v54;
  __CFString *theString;
  int valuePtr;
  int v57;
  void *values[2];
  void *keys[2];

  v2 = *(const void **)(a1 + 1112);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Couldn't allocate channelList", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
    objc_autoreleasePoolPop(v10);
    v11 = 4294963394;
    goto LABEL_89;
  }
  v4 = Mutable;
  *(_DWORD *)(a1 + 3284) = 10;
  v5 = *(_DWORD *)(a1 + 688);
  if (v5 == 4)
  {
    if (*(_BYTE *)(a1 + 672))
      goto LABEL_18;
LABEL_15:
    *(_DWORD *)(a1 + 688) = 0;
LABEL_33:
    CFRelease(v4);
    goto LABEL_92;
  }
  if (v5 == 3)
    goto LABEL_15;
  if (v5 != 2)
  {
    LODWORD(v12) = 0;
    goto LABEL_23;
  }
  v6 = *(_DWORD *)(a1 + 668);
  if (v6 < 36)
  {
    if (!v6)
    {
      LODWORD(v12) = 0;
      goto LABEL_21;
    }
LABEL_18:
    LODWORD(v12) = 0;
    v13 = 3;
LABEL_22:
    *(_DWORD *)(a1 + 688) = v13;
    goto LABEL_23;
  }
  v7 = *(_DWORD *)(a1 + 664);
  *(_DWORD *)(a1 + 664) = v7 + 1;
  if (v7 > 1)
  {
    LODWORD(v12) = 0;
    *(_DWORD *)(a1 + 664) = 0;
LABEL_21:
    v13 = 4;
    goto LABEL_22;
  }
  if (v6 > 0x90)
  {
    v8 = (v6 & 0x80000007) == 5;
    v9 = 4;
  }
  else
  {
    v8 = (v6 & 7) == 0;
    v9 = -4;
  }
  if (!v8)
    v9 = -v9;
  v12 = (v6 + v9);
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay channel - orginal(%d) adjacent(%d)", "__WiFiDeviceManagerScanCarPlayRemainingChannels", *(unsigned int *)(a1 + 668), v12);
  objc_autoreleasePoolPop(v39);
LABEL_23:
  v14 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay scan state %d", "__WiFiDeviceManagerScanCarPlayRemainingChannels", *(unsigned int *)(a1 + 688));
  objc_autoreleasePoolPop(v14);
  v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v15)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Couldn't allocate suppChannelList", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
    objc_autoreleasePoolPop(v21);
    goto LABEL_33;
  }
  v16 = v15;
  v17 = *(_QWORD *)(a1 + 64);
  v18 = (const void *)sub_100025C3C(v17);
  v19 = sub_100017A68(v17, v18, v16);
  if ((_DWORD)v19)
  {
    v11 = v19;
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Couldn't get supported channels", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
    objc_autoreleasePoolPop(v20);
    goto LABEL_88;
  }
  v22 = CFStringCreateMutable(kCFAllocatorDefault, 0);
  v57 = 0;
  v23 = *(_DWORD *)(a1 + 688);
  if (v23 == 4)
  {
LABEL_37:
    if (sub_10012C418((_BYTE *)a1, &v57))
    {
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 5Ghz channel", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
      objc_autoreleasePoolPop(v24);
      sub_100125EC4(a1);
LABEL_45:
      v11 = 0;
      goto LABEL_86;
    }
    goto LABEL_46;
  }
  if (v23 != 3)
  {
    if (v23 != 2)
      goto LABEL_46;
    goto LABEL_37;
  }
  v25 = sub_10012C188(a1, &v57);
  *(_DWORD *)(a1 + 6168) = v57;
  if (v25)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disallowing 2Ghz channel", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
    objc_autoreleasePoolPop(v26);
    goto LABEL_45;
  }
LABEL_46:
  theString = v22;
  if (CFArrayGetCount(v16) >= 1)
  {
    for (i = 0; i < CFArrayGetCount(v16); ++i)
    {
      valuePtr = -1431655766;
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, i);
      if (ValueAtIndex)
      {
        v29 = ValueAtIndex;
        Value = (void *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
        v31 = (void *)CFDictionaryGetValue(v29, CFSTR("SUP_CHANNEL_FLAGS"));
        if (Value)
        {
          if (v31)
          {
            *(_OWORD *)keys = *(_OWORD *)&off_100231A60;
            values[0] = Value;
            values[1] = v31;
            v32 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (!v32)
            {
              v40 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Couldn't allocate channelEntry", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
              objc_autoreleasePoolPop(v40);
              v11 = 4294963394;
LABEL_85:
              v22 = theString;
              goto LABEL_86;
            }
            v33 = v32;
            CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, &valuePtr);
            v34 = *(_DWORD *)(a1 + 688);
            if (v34 == 4)
            {
              if (valuePtr >= 36)
                goto LABEL_65;
            }
            else
            {
              if (v34 == 2)
              {
                if ((_DWORD)v12 == valuePtr)
                {
                  if (theString)
                    CFStringAppendFormat(theString, 0, CFSTR("%@ "), Value);
                  CFArrayAppendValue(v4, v33);
                  break;
                }
                goto LABEL_68;
              }
              if (v34 == 3 && valuePtr <= 14)
              {
LABEL_65:
                if (theString)
                  CFStringAppendFormat(theString, 0, CFSTR("%@ "), Value);
                CFArrayAppendValue(v4, v33);
              }
            }
LABEL_68:
            CFRelease(v33);
            continue;
          }
          v35 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null channel flag", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
        }
        else
        {
          v35 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null channel number", "__WiFiDeviceManagerScanCarPlayRemainingChannels");
        }
        objc_autoreleasePoolPop(v35);
      }
    }
  }
  v11 = sub_10012C500(a1, *(const __CFArray **)(a1 + 3552), v4, 0x28u, 24);
  if ((_DWORD)v11)
    goto LABEL_85;
  v22 = theString;
  if (theString)
  {
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v37 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Scanning(%s) CarPlay remaining channels: %@"), "Active", theString)), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v38 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v37, "UTF8String")), "UTF8String");
        LODWORD(keys[0]) = 136446210;
        *(void **)((char *)keys + 4) = (void *)v38;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)keys, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v36);
    v11 = 0;
  }
  else
  {
LABEL_86:
    if (!v22)
      goto LABEL_88;
  }
  CFRelease(v22);
LABEL_88:
  CFRelease(v16);
  CFRelease(v4);
  if ((_DWORD)v11)
  {
LABEL_89:
    v41 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "CarPlay multi-stage auto-join: Error scanning remaining channels, err=%d", v11);
    objc_autoreleasePoolPop(v41);
    goto LABEL_94;
  }
LABEL_92:
  if (*(_DWORD *)(a1 + 688))
    return 10;
LABEL_94:
  *(_DWORD *)(a1 + 688) = 0;
  v43 = *(double *)(a1 + 680);
  v44 = 0.5;
  if (v43 == 0.0 || (v45 = v43 + v43, v44 = 4.0, v45 > 4.0))
    v45 = v44;
  *(double *)(a1 + 680) = v45;
  v46 = v45 - v45 * 0.1;
  v47 = v45 + v45 * 0.1;
  v48 = arc4random();
  v49 = v46 + (double)(v48 + ((v48 / 0x7FFFFFFF) | ((v48 / 0x7FFFFFFF) << 31))) / 2147483650.0 * (v47 - v46);
  v50 = *(NSObject **)(a1 + 312);
  v51 = dispatch_time(0, (uint64_t)(v49 * 1000000000.0));
  dispatch_source_set_timer(v50, v51, 0xFFFFFFFFFFFFFFFFLL, 0);
  v52 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v53 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: Performing next automatic assocation in %.3f(%.3f) seconds"), "__WiFiDeviceManagerScanCarPlayRemainingChannels", *(_QWORD *)&v49, *(_QWORD *)(a1 + 680))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v54 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v53, "UTF8String")), "UTF8String");
      LODWORD(keys[0]) = 136446210;
      *(void **)((char *)keys + 4) = (void *)v54;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)keys, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v52);
  return 1;
}

uint64_t sub_10012E050(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __CFDictionary *ValueAtIndex;
  const void *Value;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v6);
    Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL"));
    if (CFEqual(a2, Value))
      break;
    if (v5 == ++v6)
      return 0;
  }
  return 1;
}

uint64_t sub_10012E0D8(uint64_t a1)
{
  const void *v2;
  void *v3;
  const __CFString *v4;
  NSString *v5;
  int v6;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v8;
  __CFArray *v9;
  BOOL v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  __CFString *v14;
  int v15;
  void *v16;
  const char *v17;
  NSString *v18;
  const char *v19;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v22;
  void *Value;
  void *v24;
  void *v25;
  CFDictionaryRef v26;
  CFDictionaryRef v27;
  void *v28;
  void *v29;
  NSString *v30;
  const char *v31;
  uint64_t v32;
  char v33;
  void *v34;
  uint64_t result;
  void *v36;
  void *v37;
  void *v38;
  unsigned int v39;
  __CFArray *theArray;
  int v41;
  int v42;
  void *values[2];
  uint8_t buf[16];

  v2 = *(const void **)(a1 + 1112);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  *(_DWORD *)(a1 + 1136) = 0;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = sub_100031FD0(*(_DWORD *)(a1 + 3284));
    v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: last state: %@, current state: %@, topNetwork %@"), "__WiFiDeviceManagerScanRemainingChannels", v4, sub_100031FD0(*(_DWORD *)(a1 + 3280)), *(_QWORD *)(a1 + 3376))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v5, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v3);
  v6 = 10;
  if (*(_DWORD *)(a1 + 3284) == 9)
  {
    if (*(_QWORD *)(a1 + 3376))
      v6 = 11;
    else
      v6 = 10;
  }
  v39 = v6;
  *(_DWORD *)(a1 + 3284) = v6;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v9 = v8;
  if (Mutable)
    v10 = v8 == 0;
  else
    v10 = 1;
  if (v10)
  {
    v37 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to create remaining or supp ch list array", "__WiFiDeviceManagerScanRemainingChannels");
    objc_autoreleasePoolPop(v37);
    v32 = 4294963394;
LABEL_52:
    v33 = 1;
    if (!v9)
      goto LABEL_54;
    goto LABEL_53;
  }
  v11 = *(_QWORD *)(a1 + 64);
  v12 = (const void *)sub_100025C3C(v11);
  v13 = sub_100017A68(v11, v12, v9);
  if ((_DWORD)v13)
  {
    v32 = v13;
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s :Device failed to return supported channels.", "__WiFiDeviceManagerScanRemainingChannels");
  }
  else
  {
    if (CFArrayGetCount(v9))
    {
      theArray = Mutable;
      v14 = CFStringCreateMutable(kCFAllocatorDefault, 0);
      v42 = 0;
      v15 = sub_10012C188(a1, &v42);
      *(_DWORD *)(a1 + 6168) = v42;
      v41 = sub_10012C418((_BYTE *)a1, &v42);
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v17 = " in 5Ghz only.";
        if (!v15)
          v17 = ".";
        v18 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("multi-stage auto-join: Attempting to scan remaining channels%s"), v17)), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v19 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v18, "UTF8String")), "UTF8String");
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v16);
      if (CFArrayGetCount(v9) >= 1)
      {
        for (i = 0; i < CFArrayGetCount(v9); ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, i);
          if (ValueAtIndex)
          {
            v22 = ValueAtIndex;
            Value = (void *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
            v24 = (void *)CFDictionaryGetValue(v22, CFSTR("SUP_CHANNEL_FLAGS"));
            if (Value)
            {
              v25 = v24;
              if (v24)
              {
                if (sub_10012E050(*(const __CFArray **)(a1 + 3288), Value) != 1)
                {
                  if (!v15
                    || (*(_DWORD *)buf = 0, !CFNumberGetValue((CFNumberRef)v25, kCFNumberSInt32Type, buf))
                    || (buf[0] & 8) == 0)
                  {
                    if (!v41
                      || (*(_DWORD *)buf = -1431655766,
                          CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, buf),
                          *(_DWORD *)buf)
                      && *(_DWORD *)buf <= 0xEu)
                    {
                      *(_OWORD *)buf = *(_OWORD *)&off_100231A60;
                      values[0] = Value;
                      values[1] = v25;
                      v26 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (v26)
                      {
                        v27 = v26;
                        CFArrayAppendValue(theArray, v26);
                        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3288), v27);
                        CFRelease(v27);
                        if (v14)
                          CFStringAppendFormat(v14, 0, CFSTR("%@ "), Value);
                      }
                    }
                  }
                }
                continue;
              }
              v28 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null channel flag", "__WiFiDeviceManagerScanRemainingChannels");
            }
            else
            {
              v28 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null channel number", "__WiFiDeviceManagerScanRemainingChannels");
            }
            objc_autoreleasePoolPop(v28);
          }
        }
      }
      sub_100125EC4(a1);
      Mutable = theArray;
      if (v14)
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v30 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Scanning(%s) remaining channels: %@"), "Active", v14)), "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            v31 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v30, "UTF8String")), "UTF8String");
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v31;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
          }
        }
        objc_autoreleasePoolPop(v29);
      }
      if (CFArrayGetCount(theArray))
      {
        *(_DWORD *)(a1 + 5620) = 2;
        v32 = sub_10012C500(a1, *(const __CFArray **)(a1 + 3552), theArray, 0, 3);
        if (!v14)
          goto LABEL_52;
      }
      else
      {
        v32 = 4294963394;
        if (!v14)
          goto LABEL_52;
      }
      CFRelease(v14);
      goto LABEL_52;
    }
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Empty supported channels.", "__WiFiDeviceManagerScanRemainingChannels");
    v32 = 0;
  }
  objc_autoreleasePoolPop(v38);
  v33 = 0;
LABEL_53:
  CFRelease(v9);
LABEL_54:
  if (Mutable)
    CFRelease(Mutable);
  if ((_DWORD)v32)
  {
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "multi-stage auto-join: Error scanning remaining channels, err=%d", v32);
    objc_autoreleasePoolPop(v34);
    return sub_10000D074(a1, v32);
  }
  else
  {
    result = v39;
    if ((v33 & 1) == 0)
    {
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fallback to all channel scans", "__WiFiDeviceManagerScanRemainingChannels");
      objc_autoreleasePoolPop(v36);
      return sub_100129118(a1);
    }
  }
  return result;
}

id sub_10012E8C8(uint64_t a1)
{
  void *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  uint64_t v10;
  id v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  _UNKNOWN **v16;
  id v17;
  id v18;
  id v19;
  id v20;
  _UNKNOWN **v21;
  void *context;
  id v24;
  id obj;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[128];

  if (!a1)
    return 0;
  v2 = objc_autoreleasePoolPush();
  v3 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, _QWORD))(a1 + 4696))(a1, *(_QWORD *)(a1 + 4704));
  if (!v3 || (v4 = v3, !CFDictionaryGetCount(v3)))
  {
    objc_autoreleasePoolPop(v2);
    return 0;
  }
  context = v2;
  v5 = -[__CFDictionary allKeys](v4, "allKeys");
  v24 = objc_msgSend(v5, "mutableCopy");
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  obj = v5;
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v26, v30, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v27;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(_QWORD *)v27 != v8)
          objc_enumerationMutation(obj);
        v10 = *(_QWORD *)(*((_QWORD *)&v26 + 1) + 8 * (_QWORD)i);
        v11 = -[__CFDictionary objectForKey:](v4, "objectForKey:", v10);
        v12 = objc_msgSend(v11, "objectForKey:", CFSTR("type"));
        if (v12)
        {
          v13 = v12;
          v14 = objc_msgSend(v11, "objectForKey:", CFSTR("notificationType"));
          if (v14)
          {
            v15 = v14;
            v16 = (_UNKNOWN **)objc_msgSend(v11, "objectForKey:", CFSTR("count"));
            v17 = objc_msgSend(v13, "unsignedIntValue");
            v18 = objc_msgSend(v15, "unsignedIntValue");
            v19 = objc_msgSend(v11, "objectForKey:", CFSTR("timestamp"));
            if (v19)
            {
              v20 = v19;
              if (v16)
                v21 = v16;
              else
                v21 = &off_1002532A8;
              if (+[WiFiUserNotificationManager canRepromptForNotificationType:blacklistType:atDate:count:](WiFiUserNotificationManager, "canRepromptForNotificationType:blacklistType:atDate:count:", v18, v17, v20, objc_msgSend(v21, "integerValue")))
              {
                objc_msgSend(v24, "removeObject:", v10);
              }
            }
          }
        }
      }
      v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v26, v30, 16);
    }
    while (v7);
  }
  objc_autoreleasePoolPop(context);
  return v24;
}

void sub_10012EB08(uint64_t a1)
{
  CFNumberRef v2;
  CFNumberRef v3;
  void *v4;
  CFAbsoluteTime valuePtr;

  if (*(_QWORD *)(a1 + 376))
  {
    if (*(_QWORD *)(a1 + 392))
    {
      if (*(double *)(a1 + 384) != 0.0)
      {
        valuePtr = CFAbsoluteTimeGetCurrent();
        v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
        if (v2)
        {
          v3 = v2;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 376), v2);
          CFRelease(v3);
          v4 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: there have been %ld auto-join attempts in the last %f seconds", "__WiFiDeviceManagerUpdateScanThrottleCounter", CFArrayGetCount(*(CFArrayRef *)(a1 + 376)), *(_QWORD *)(a1 + 384));
          objc_autoreleasePoolPop(v4);
        }
      }
    }
  }
}

void sub_10012EBDC(uint64_t a1, const __CFArray *a2)
{
  CFMutableStringRef Mutable;
  __CFString *v5;
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v9;
  void *v10;
  NSString *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  const char *v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  __CFString *v19;

  if (!a2)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v15 = "ScanResults is Null!";
LABEL_20:
      objc_msgSend(v14, "WFLog:message:", 4, v15);
    }
LABEL_21:
    objc_autoreleasePoolPop(v13);
    return;
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v15 = "logMessage is Null!";
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  v5 = Mutable;
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      if (ValueAtIndex)
      {
        v9 = (const __CFString *)sub_10002B088(ValueAtIndex);
        if (i >= Count - 1)
          CFStringAppend(v5, v9);
        else
          CFStringAppendFormat(v5, 0, CFSTR("%@, "), v9);
      }
    }
  }
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN, SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@ found %d networks"), sub_100031FD0(*(_DWORD *)(a1 + 3280)), Count)), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v17 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v11, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v10);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    v12 = sub_100031FD0(*(_DWORD *)(a1 + 3280));
    *(_DWORD *)buf = 138412546;
    v17 = (const char *)v12;
    v18 = 2112;
    v19 = v5;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "{AUTOJOIN, SCAN} %@ found: %@", buf, 0x16u);
  }
  CFRelease(v5);
}

void sub_10012EEB4(uint64_t a1, const void *a2, __CFString *a3)
{
  const void *v5;

  if (a1 && a2)
  {
    if (sub_100007DCC(a2))
      v5 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    else
      v5 = sub_10002B088(a2);
    CFStringAppendFormat(a3, 0, CFSTR("%@"), v5);
    if (sub_10002DAB4((uint64_t)a2))
      CFStringAppend(a3, CFSTR("(E)"));
    if (sub_1000C3B8C((_BOOL8)a2))
      CFStringAppend(a3, CFSTR("(WEP)"));
    if (sub_10003145C((uint64_t)a2))
      CFStringAppend(a3, CFSTR("(W)"));
    if (sub_1000C433C((const __CFDictionary *)a2))
      CFStringAppend(a3, CFSTR("(SAE)"));
    CFStringAppendFormat(a3, 0, CFSTR(", "));
  }
}

void sub_10012EFB4(uint64_t a1, const void *a2, __CFString *a3)
{
  const __CFString *v6;
  const void *v7;
  const void *v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  _BOOL4 v11;
  const __CFString *v12;

  if (a1 && a2)
  {
    if (sub_100007DCC(a2))
      v6 = CFSTR("*");
    else
      v6 = (const __CFString *)sub_10002B088(a2);
    CFStringAppend(a3, v6);
    CFStringAppendFormat(a3, 0, CFSTR("-"));
    v7 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    CFStringAppendFormat(a3, 0, CFSTR("%@"), v7);
    CFStringAppendFormat(a3, 0, CFSTR("-"));
    v8 = sub_1000316E0((uint64_t)a2);
    CFStringAppendFormat(a3, 0, CFSTR("( C:%@, "), v8);
    v9 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
    CFStringAppendFormat(a3, 0, CFSTR("R:%ld, "), v9);
    v10 = sub_100017A54((uint64_t)a2, CFSTR("AGE"));
    CFStringAppendFormat(a3, 0, CFSTR("A:%ld,"), v10);
    if (sub_10002DA5C((_BOOL8)a2))
    {
      v11 = sub_1000C6274((uint64_t)a2);
      CFStringAppend(a3, CFSTR(","));
      if (v11)
        v12 = CFSTR(" HS2.0-h");
      else
        v12 = CFSTR(" HS2.0-r");
      CFStringAppend(a3, v12);
    }
    if (sub_100131848(a1, a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" HS"));
    }
    if (sub_100105808(a1, a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" Cap"));
    }
    if (sub_10000BE8C((uint64_t)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" Car"));
    }
    if (sub_10002B704((uint64_t)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" Ad"));
    }
    if (sub_10002DAB4((uint64_t)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" EAP"));
    }
    if (sub_1000C3B8C((_BOOL8)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" WEP"));
    }
    if (sub_10003145C((uint64_t)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" WPA"));
    }
    if (sub_1000C433C((const __CFDictionary *)a2))
    {
      CFStringAppend(a3, CFSTR(","));
      CFStringAppend(a3, CFSTR(" SAE"));
    }
    CFStringAppendFormat(a3, 0, CFSTR(")"));
  }
}

void sub_10012F2B0(uint64_t a1)
{
  CFMutableStringRef Mutable;
  __CFString *v3;
  CFIndex v4;
  __CFArray *v5;
  int v6;
  const void *ValueAtIndex;
  const void *v8;
  const void *v9;
  char v10;
  char v11;
  const void *v12;
  const void *v13;
  unsigned int v14;
  char v15;
  char v16;
  const __CFArray *v17;
  void *v18;
  const void *v19;
  const __CFString *v20;
  BOOL v21;
  CFIndex v22;
  const __CFArray *v23;
  CFIndex v24;
  const void *v25;
  CFIndex FirstIndexOfValue;
  void *v27;
  void *v28;
  CFIndex Count;
  uint64_t v30;
  CFRange v31;
  CFRange v32;

  if (!a1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager object is NULL", "__WiFiDeviceManagerPrepareDeferredNetworkList");
    goto LABEL_86;
  }
  if (!*(_QWORD *)(a1 + 1112))
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scan candidates is NULL", "__WiFiDeviceManagerPrepareDeferredNetworkList");
    goto LABEL_86;
  }
  if (!*(_QWORD *)(a1 + 3568))
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deferred network list is NULL", "__WiFiDeviceManagerPrepareDeferredNetworkList");
    goto LABEL_86;
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s  logMessage is NULL", "__WiFiDeviceManagerPrepareDeferredNetworkList");
LABEL_86:
    objc_autoreleasePoolPop(v28);
    return;
  }
  v3 = Mutable;
  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)))
    goto LABEL_77;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)) < 1)
    goto LABEL_77;
  v4 = 0;
  v30 = 0;
  v5 = 0;
  v6 = 1;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v4);
    if (!ValueAtIndex)
      goto LABEL_59;
    v8 = ValueAtIndex;
    if (sub_10000BE8C((uint64_t)ValueAtIndex))
    {
      if (*(_DWORD *)(a1 + 5520) == 1)
        goto LABEL_59;
    }
    v9 = *(const void **)(a1 + 3512);
    if (v9)
    {
      if (CFEqual(v9, v8)
        && !sub_100077740(*(_QWORD *)(a1 + 64))
        && !-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
      {
        goto LABEL_59;
      }
    }
    if (sub_1000CEBA4((uint64_t)v8)
      && (sub_100013900((uint64_t)v8)
       || sub_10002BE64((uint64_t)v8, CFSTR("WiFiNetworkAttributeIsPublic")) == kCFBooleanTrue))
    {
      v10 = 0;
      v11 = 1;
    }
    else
    {
      v11 = 0;
      v10 = 1;
    }
    v12 = *(const void **)(a1 + 3512);
    if (v12
      && (!CFEqual(v12, v8) || sub_100104C60(a1, v8))
      && (v13 = *(const void **)(a1 + 3512)) != 0
      && CFEqual(v13, v8))
    {
      v14 = 0;
    }
    else
    {
      v14 = objc_msgSend(*(id *)(a1 + 3656), "canDeferNetwork:withUsageRank:andMotionState:", v8, sub_1000FEEC0(a1, v8), *(unsigned int *)(a1 + 3352));
      v30 += v14;
      if (v14)
        goto LABEL_30;
    }
    if (Count < 1)
    {
LABEL_30:
      if (v14)
        goto LABEL_31;
      goto LABEL_33;
    }
    if (sub_10002DA5C((_BOOL8)v8))
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3560), v8);
      v15 = 0;
      ++v30;
      goto LABEL_32;
    }
LABEL_33:
    if (!sub_100131848(a1, v8))
    {
      if (((v11 ^ 1) & 1) != 0)
        goto LABEL_59;
      ++v30;
LABEL_31:
      v15 = 1;
LABEL_32:
      v16 = 1;
      goto LABEL_42;
    }
    v17 = *(const __CFArray **)(a1 + 3568);
    v31.length = CFArrayGetCount(v17);
    v31.location = 0;
    if (CFArrayGetFirstIndexOfValue(v17, v31, v8) == -1)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3568), v8);
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: duplicate network %@ found, skipping.", "__WiFiDeviceManagerPrepareDeferredNetworkList", sub_10002B088(v8));
      objc_autoreleasePoolPop(v18);
    }
    v16 = 0;
    ++v30;
    v15 = 1;
LABEL_42:
    v19 = sub_10002B088(v8);
    if (v6)
    {
      if (v19)
        v20 = (const __CFString *)sub_10002B088(v8);
      else
        v20 = CFSTR("(null)");
      CFStringAppend(v3, v20);
      if ((v15 & 1) == 0)
      {
LABEL_49:
        CFStringAppend(v3, CFSTR("("));
        CFStringAppend(v3, CFSTR("HS2.0"));
        CFStringAppend(v3, CFSTR(")"));
      }
    }
    else
    {
      CFStringAppendFormat(v3, 0, CFSTR(", %@"), v19);
      if ((v15 & 1) == 0)
        goto LABEL_49;
    }
    if ((v16 & 1) == 0)
    {
      CFStringAppend(v3, CFSTR("("));
      CFStringAppend(v3, CFSTR("HS"));
      CFStringAppend(v3, CFSTR(")"));
      if (!v14)
        goto LABEL_53;
LABEL_52:
      CFStringAppend(v3, CFSTR("("));
      CFStringAppend(v3, CFSTR("time-defer"));
      CFStringAppend(v3, CFSTR(")"));
      goto LABEL_53;
    }
    if (v14)
      goto LABEL_52;
LABEL_53:
    if ((v10 & 1) == 0)
    {
      CFStringAppend(v3, CFSTR("("));
      CFStringAppend(v3, CFSTR("public"));
      CFStringAppend(v3, CFSTR(")"));
    }
    if (v5 || (v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) != 0)
      CFArrayAppendValue(v5, v8);
    v6 = 0;
LABEL_59:
    ++v4;
  }
  while (v4 < CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)));
  v21 = v5 == 0;
  if (v5)
  {
    if (CFArrayGetCount(v5) >= 1)
    {
      v22 = 0;
      do
      {
        v23 = *(const __CFArray **)(a1 + 1112);
        v24 = CFArrayGetCount(v23);
        v25 = CFArrayGetValueAtIndex(v5, v22);
        v32.location = 0;
        v32.length = v24;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v23, v32, v25);
        if (FirstIndexOfValue != -1)
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), FirstIndexOfValue);
        ++v22;
      }
      while (v22 < CFArrayGetCount(v5));
    }
  }
  else
  {
    v21 = 1;
  }
  if (v30 > 0)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Deferring auto-join attempt for %@ ", v3);
    objc_autoreleasePoolPop(v27);
  }
  if (!v21)
    CFRelease(v5);
LABEL_77:
  CFRelease(v3);
}

void sub_10012F8CC(uint64_t a1, const __CFArray *a2)
{
  CFMutableStringRef Mutable;
  CFIndex v5;
  char v6;
  int v7;
  __CFString *v8;
  void *ValueAtIndex;
  void *v10;
  const __CFNumber *v11;
  int v12;
  void *v13;
  int v14;
  unsigned int v15;
  _BOOL4 v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const __CFNumber *v21;
  const __CFString *v22;
  void *v23;
  __CFString *v24;
  NSString *v25;
  const char *v26;
  void *v27;
  const __CFNumber *v28;
  uint64_t v29;
  uint8_t buf[4];
  const char *v31;

  if (!a1)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is Null!", "__WiFiDeviceManagerFilterCandidatesWithRssiThreshold");
    goto LABEL_51;
  }
  if (!a2)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no scan candidate network", "__WiFiDeviceManagerFilterCandidatesWithRssiThreshold");
LABEL_51:
    objc_autoreleasePoolPop(v27);
    return;
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (CFArrayGetCount(a2) < 1)
  {
    v6 = 0;
    v7 = -1431655766;
    if (!Mutable)
      return;
LABEL_33:
    if (!CFStringGetLength(Mutable))
    {
LABEL_45:
      CFRelease(Mutable);
      return;
    }
    v23 = objc_autoreleasePoolPush();
    if (v6)
    {
      if (!qword_10026DD20)
        goto LABEL_44;
      v24 = (v7 - 1) > 3 ? 0 : off_100232250[v7 - 1];
      v25 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Filtering scan results in %@ due to AJ RSSI threshold: %@"), v24, Mutable)), "UTF8String"));
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_44;
    }
    else
    {
      if (!qword_10026DD20)
        goto LABEL_44;
      v25 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Filtering scan results due to AJ RSSI threshold: %@"), Mutable)), "UTF8String"));
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_44;
    }
    v26 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v25, "UTF8String")), "UTF8String");
    *(_DWORD *)buf = 136446210;
    v31 = v26;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
LABEL_44:
    objc_autoreleasePoolPop(v23);
    goto LABEL_45;
  }
  v5 = 0;
  v6 = 0;
  v7 = -1431655766;
  v8 = Mutable;
  do
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, v5);
    if (ValueAtIndex)
    {
      v10 = ValueAtIndex;
      *(_DWORD *)buf = -1431655766;
      v11 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("RSSI"));
      v12 = sub_100125CA4(a1, v10, 1, (int *)buf);
      if ((*(_DWORD *)buf - 1) < 2)
      {
        v7 = *(_DWORD *)buf;
        v6 = 1;
      }
      if (*(_BYTE *)(a1 + 40) && *(_DWORD *)(a1 + 44))
      {
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Using Simulated RSSI Value(%d) instead of actual RSSI value(%d)", "__WiFiDeviceManagerFilterCandidatesWithRssiThreshold", *(unsigned int *)(a1 + 44), v11);
        objc_autoreleasePoolPop(v13);
        LODWORD(v11) = *(_DWORD *)(a1 + 44);
        Mutable = v8;
      }
      if ((int)v11 < v12)
      {
        if (Mutable)
        {
          v14 = *(_DWORD *)buf;
          v15 = *(_DWORD *)buf - 5;
          v16 = sub_100007DCC(v10);
          if (v15 >= 0xFFFFFFFE)
          {
            if (v16)
              v18 = sub_10002BE64((uint64_t)v10, CFSTR("BSSID"));
            else
              v18 = sub_10002B088(v10);
            v20 = v18;
            v21 = sub_100017A54((uint64_t)v10, CFSTR("RSSI"));
            v22 = CFSTR("MovingNw");
            if (v14 != 3)
              v22 = 0;
            if (v14 == 4)
              v22 = CFSTR("OmnipresentNw");
            Mutable = v8;
            CFStringAppendFormat(v8, 0, CFSTR("%@(%ld {%@}), "), v20, v21, v22);
          }
          else
          {
            if (v16)
              v17 = sub_10002BE64((uint64_t)v10, CFSTR("BSSID"));
            else
              v17 = sub_10002B088(v10);
            v19 = v17;
            Mutable = v8;
            v28 = sub_100017A54((uint64_t)v10, CFSTR("RSSI"));
            CFStringAppendFormat(v8, 0, CFSTR("%@(%ld), "), v19, v28, v29);
          }
        }
        CFArrayRemoveValueAtIndex(a2, v5--);
      }
    }
    ++v5;
  }
  while (v5 < CFArrayGetCount(a2));
  if (Mutable)
    goto LABEL_33;
}

void sub_10012FDD8(const __CFArray *a1, int a2, CFTypeRef *a3)
{
  __CFString *Mutable;
  int Count;
  CFIndex v8;
  uint64_t v9;
  __CFDictionary *v10;
  CFIndex v11;
  uint64_t v12;
  const void *ValueAtIndex;
  const void *v14;
  const __CFString *v15;
  _BOOL4 v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  CFDictionaryRef v21;
  CFDictionaryRef v22;
  void *v23;
  CFIndex v24;
  CFMutableStringRef v25;
  __CFString *v26;
  size_t v27;
  char *v28;
  const __CFAllocator *v29;
  CFIndex i;
  const void *Value;
  void *v32;
  CFTypeRef *v33;
  CFAllocatorRef v34;
  void *values[2];
  void *keys[2];

  v34 = kCFAllocatorDefault;
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (!a1 || (Count = CFArrayGetCount(a1), Count < 1))
  {
    v10 = 0;
    v9 = 0;
    goto LABEL_26;
  }
  v33 = a3;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = Count - 1;
  v12 = Count;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v8);
    if (ValueAtIndex)
    {
      v14 = ValueAtIndex;
      if (Mutable)
      {
        if (a2 && sub_100007DCC(ValueAtIndex))
          ++v9;
        v15 = (const __CFString *)sub_10002B088(v14);
        if (v8 >= v11)
          CFStringAppend(Mutable, v15);
        else
          CFStringAppendFormat(Mutable, 0, CFSTR("%@, "), v15);
      }
      v16 = sub_100007DCC(v14);
      if (a2)
      {
        if (v16)
        {
          v17 = (void *)sub_10002BE64((uint64_t)v14, CFSTR("CHANNEL"));
          if (v17)
          {
            v18 = v17;
            v19 = (void *)sub_10002BE64((uint64_t)v14, CFSTR("CHANNEL_FLAGS"));
            if (v19)
            {
              v20 = v19;
              if (v10
                || (v10 = CFDictionaryCreateMutable(v34, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) != 0)
              {
                *(_OWORD *)keys = *(_OWORD *)&off_100231A60;
                values[0] = v18;
                values[1] = v20;
                v21 = CFDictionaryCreate(v34, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (v21)
                {
                  v22 = v21;
                  CFDictionarySetValue(v10, v18, v21);
                  CFRelease(v22);
                }
              }
            }
          }
        }
      }
    }
    ++v8;
  }
  while (v12 != v8);
  if (v10)
  {
    a3 = v33;
    if (!CFDictionaryGetCount(v10))
    {
      CFRelease(v10);
      v10 = 0;
      if (!Mutable)
        goto LABEL_30;
      goto LABEL_27;
    }
LABEL_26:
    if (!Mutable)
      goto LABEL_30;
    goto LABEL_27;
  }
  a3 = v33;
  if (!Mutable)
    goto LABEL_30;
LABEL_27:
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto join scan found: %@", Mutable);
  objc_autoreleasePoolPop(v23);
  CFRelease(Mutable);
LABEL_30:
  if (v9)
  {
    if (v10)
    {
      v24 = CFDictionaryGetCount(v10);
      v25 = CFStringCreateMutable(v34, 0);
      if (v25)
      {
        v26 = v25;
        v27 = 8 * v24;
        __chkstk_darwin();
        v28 = (char *)&v33 - ((8 * v24 + 15) & 0xFFFFFFFFFFFFFFF0);
        v33 = a3;
        v34 = v29;
        if (v24)
          memset((char *)&v33 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0), 170, 8 * v24);
        else
          v27 = 0;
        bzero(v28, v27);
        CFDictionaryGetKeysAndValues(v10, 0, (const void **)v28);
        if (v24 >= 1)
        {
          for (i = 0; i != v24; ++i)
          {
            Value = CFDictionaryGetValue(*(CFDictionaryRef *)&v28[8 * i], CFSTR("CHANNEL"));
            if (Value)
            {
              if (i >= v24 - 1)
                CFStringAppendFormat(v26, 0, CFSTR("%@"), Value);
              else
                CFStringAppendFormat(v26, 0, CFSTR("%@, "), Value);
            }
          }
        }
        v32 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto join scan found %ld hidden networks on channels %@", v9, v26);
        objc_autoreleasePoolPop(v32);
        CFRelease(v26);
        a3 = v33;
      }
    }
  }
  if (a3)
  {
    if (*a3)
      CFRelease(*a3);
    *a3 = v10;
  }
  else if (v10)
  {
    CFRelease(v10);
  }
}

CFIndex sub_1001301A8(uint64_t a1)
{
  void *v2;
  NSString *v3;
  const __CFArray *v4;
  CFIndex result;
  CFIndex v6;
  const void *v7;
  CFMutableStringRef Mutable;
  __CFString *v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  void *v13;
  NSString *v14;
  const char *v15;
  CFIndex v16;
  CFIndex v17;
  const void *v18;
  const void *v19;
  const __CFString *v20;
  _BOOL4 v21;
  const __CFString *v22;
  _BOOL4 v23;
  const __CFString *v24;
  _BOOL4 v25;
  _BOOL4 v26;
  const __CFString *v27;
  unsigned int v28;
  const __CFString *v29;
  _BOOL4 v30;
  const __CFString *v31;
  _BOOL4 v32;
  const __CFString *v33;
  int v34;
  const __CFString *v35;
  unsigned int v36;
  const __CFString *v37;
  const void *v38;
  _BOOL4 v39;
  unsigned int v40;
  _BOOL4 v41;
  _BOOL4 v42;
  int v43;
  unsigned int v44;
  CFIndex FirstIndexOfValue;
  CFIndex v46;
  const void *ValueAtIndex;
  CFBooleanRef v48;
  int v49;
  char v50;
  char v51;
  const __CFDate *v52;
  const __CFDate *v53;
  double Current;
  void *v55;
  const void *v56;
  char *v57;
  double v58;
  NSString *v59;
  const char *v60;
  void *v61;
  const void *v62;
  uint8_t buf[4];
  const char *v64;
  CFRange v65;
  CFRange v66;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v3 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: current state: %@ "), "__WiFiDeviceManagerPrepareCandidates", sub_100031FD0(*(_DWORD *)(a1 + 3280)))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v64 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v3, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v2);
  v4 = *(const __CFArray **)(a1 + 1112);
  if (v4)
  {
    result = CFArrayGetCount(v4);
    if (!result)
      return result;
    v6 = result;
    v65.location = 0;
    v65.length = result;
    CFArraySortValues(*(CFMutableArrayRef *)(a1 + 1112), v65, (CFComparatorFunction)sub_1001318C4, (void *)a1);
    if (*(_DWORD *)(a1 + 3280) == 11)
      goto LABEL_10;
    v7 = *(const void **)(a1 + 3512);
    if (!v7)
      goto LABEL_10;
    if (sub_100131848(a1, v7))
      goto LABEL_10;
    if (sub_10002DA5C(*(_QWORD *)(a1 + 3512)))
      goto LABEL_10;
    v66.location = 0;
    v66.length = v6;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 1112), v66, *(const void **)(a1 + 3512));
    if (FirstIndexOfValue == -1)
      goto LABEL_10;
    v46 = FirstIndexOfValue;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), FirstIndexOfValue);
    if (sub_10001395C(*(_QWORD *)(a1 + 3512)))
    {
      v48 = (CFBooleanRef)sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("WiFiInstantHotspotJoining"));
      if (v48 == kCFBooleanTrue)
      {
        sub_10002C478((uint64_t)ValueAtIndex, CFSTR("WiFiInstantHotspotJoining"), v48);
        v49 = 1;
      }
      else
      {
        v49 = 0;
      }
      if (sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("WiFiAutoInstantHotspotJoining")) == kCFBooleanTrue)
      {
        sub_10002C478((uint64_t)ValueAtIndex, CFSTR("WiFiAutoInstantHotspotJoining"), kCFBooleanTrue);
        v50 = 1;
        goto LABEL_65;
      }
    }
    else
    {
      v49 = 0;
    }
    v50 = 0;
LABEL_65:
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), v46);
    CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), 0, ValueAtIndex);
    if (ValueAtIndex)
      CFRelease(ValueAtIndex);
    v51 = v50 ^ 1;
    if (v49)
      v51 = 0;
    if ((v51 & 1) == 0)
    {
      v52 = (const __CFDate *)sub_10002BE64(*(_QWORD *)(a1 + 3512), CFSTR("lastDisconnectTimestampKey"));
      if (v52)
      {
        v53 = v52;
        Current = CFAbsoluteTimeGetCurrent();
        if (Current - CFDateGetAbsoluteTime(v53) > 300.0)
        {
          v55 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v56 = sub_10002B088(*(const void **)(a1 + 3512));
            v57 = v49 ? "Instant" : "Auto instant";
            v58 = CFAbsoluteTimeGetCurrent();
            v59 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s Ignore Previous Hotspot %@ type(%s) disconnect time since linkDown %f"), "__WiFiDeviceManagerPrepareCandidates", v56, v57, v58 - CFDateGetAbsoluteTime(v53))), "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              v60 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v59, "UTF8String")), "UTF8String");
              *(_DWORD *)buf = 136446210;
              v64 = v60;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
          }
          objc_autoreleasePoolPop(v55);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1112), 0);
        }
      }
    }
LABEL_10:
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    if (!Mutable)
    {
LABEL_17:
      *(_QWORD *)(a1 + 1128) = 0;
      *(_QWORD *)(a1 + 1120) = 0;
      return 1;
    }
    v9 = Mutable;
    v10 = *(const __CFArray **)(a1 + 1112);
    if (!v10 || (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)), v12 = Count - 1, Count < 1))
    {
LABEL_13:
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v14 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Attempting auto-join for networks in following order: %@"), v9)), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v15 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v14, "UTF8String")), "UTF8String");
          *(_DWORD *)buf = 136446210;
          v64 = v15;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v13);
      CFRelease(v9);
      goto LABEL_17;
    }
    v16 = Count;
    v17 = 0;
    while (1)
    {
      v18 = CFArrayGetValueAtIndex(v10, v17);
      if (v18)
      {
        v19 = v18;
        if (sub_100007DCC(v18))
          v20 = (const __CFString *)sub_10002BE64((uint64_t)v19, CFSTR("BSSID"));
        else
          v20 = (const __CFString *)sub_10002B088(v19);
        CFStringAppend(v9, v20);
        if (sub_10002DA5C((_BOOL8)v19))
        {
          v21 = sub_1000C6274((uint64_t)v19);
          CFStringAppend(v9, CFSTR("("));
          if (v21)
            v22 = CFSTR("HS2.0-h");
          else
            v22 = CFSTR("HS2.0-r");
          CFStringAppend(v9, v22);
          v23 = sub_100131848(a1, v19);
          v24 = CFSTR(",");
          if (v23)
          {
LABEL_31:
            CFStringAppend(v9, v24);
            CFStringAppend(v9, CFSTR("HS"));
          }
          v26 = sub_100105808(a1, v19);
          v27 = CFSTR(",");
          if (v26)
          {
LABEL_33:
            CFStringAppend(v9, v27);
            CFStringAppend(v9, CFSTR("C"));
          }
          v28 = sub_10002B704((uint64_t)v19);
          v29 = CFSTR(",");
          if (v28)
          {
LABEL_35:
            CFStringAppend(v9, v29);
            CFStringAppend(v9, CFSTR("A"));
          }
          v30 = sub_10002DAB4((uint64_t)v19);
          v31 = CFSTR(",");
          if (v30)
          {
LABEL_37:
            CFStringAppend(v9, v31);
            CFStringAppend(v9, CFSTR("EAP"));
          }
          v32 = sub_1000C3B8C((_BOOL8)v19);
          v33 = CFSTR(",");
          if (v32)
          {
LABEL_39:
            CFStringAppend(v9, v33);
            CFStringAppend(v9, CFSTR("WEP"));
          }
          v34 = sub_10003145C((uint64_t)v19);
          v35 = CFSTR(",");
          if (v34)
          {
LABEL_41:
            CFStringAppend(v9, v35);
            CFStringAppend(v9, CFSTR("W"));
          }
          v36 = sub_1000C433C((const __CFDictionary *)v19);
          v37 = CFSTR(",");
          if (v36)
          {
LABEL_43:
            CFStringAppend(v9, v37);
            CFStringAppend(v9, CFSTR("SAE"));
          }
          v38 = sub_1000316E0((uint64_t)v19);
          if (v17 >= v12)
            CFStringAppendFormat(v9, 0, CFSTR(", %@)"), v38);
          else
            CFStringAppendFormat(v9, 0, CFSTR(", %@), "), v38);
          goto LABEL_47;
        }
        v25 = sub_100131848(a1, v19);
        v24 = CFSTR("(");
        if (v25)
          goto LABEL_31;
        v39 = sub_100105808(a1, v19);
        v27 = CFSTR("(");
        if (v39)
          goto LABEL_33;
        v40 = sub_10002B704((uint64_t)v19);
        v29 = CFSTR("(");
        if (v40)
          goto LABEL_35;
        v41 = sub_10002DAB4((uint64_t)v19);
        v31 = CFSTR("(");
        if (v41)
          goto LABEL_37;
        v42 = sub_1000C3B8C((_BOOL8)v19);
        v33 = CFSTR("(");
        if (v42)
          goto LABEL_39;
        v43 = sub_10003145C((uint64_t)v19);
        v35 = CFSTR("(");
        if (v43)
          goto LABEL_41;
        v44 = sub_1000C433C((const __CFDictionary *)v19);
        v37 = CFSTR("(");
        if (v44)
          goto LABEL_43;
        v62 = sub_1000316E0((uint64_t)v19);
        CFStringAppendFormat(v9, 0, CFSTR("(%@), "), v62);
      }
LABEL_47:
      if (v16 == ++v17)
        goto LABEL_13;
    }
  }
  v61 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no scan candidate network", "__WiFiDeviceManagerPrepareCandidates");
  objc_autoreleasePoolPop(v61);
  return 0;
}

uint64_t sub_100130A04(uint64_t a1)
{
  int v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  void *ValueAtIndex;
  void *v8;
  NSString *v9;
  const char *v10;
  void *v11;
  int v12;
  _BOOL4 v13;
  double v14;
  unsigned __int8 v15;
  const void *v16;
  const void *v17;
  void *v18;
  char v19;
  id v20;
  void *v21;
  id v22;
  void *v23;
  double v24;
  void *v25;
  unsigned int v26;
  const void *v27;
  void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  void *v32;
  void *v33;
  const void *v34;
  const void *v35;
  void *v36;
  const void *v37;
  const void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  const void *v45;
  void *v46;
  uint64_t v47;
  void *v49;
  const void *v50;
  void *v51;
  NSError *v52;
  void *v53;
  void *v54;
  const void *v55;
  const void *v56;
  uint64_t v57;
  int v58;
  _BYTE *v59;
  uint8_t buf[4];
  const char *v61;

  v59 = (_BYTE *)(a1 + 6896);
  v2 = sub_100107828(a1, 1);
  if (!v2)
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin cancelled due to concurrent state %@(%d)", sub_100064C9C(v59[161]), v59[161]);
    objc_autoreleasePoolPop(v46);
    ValueAtIndex = 0;
    v47 = 4294963393;
    goto LABEL_84;
  }
  v3 = *(const __CFArray **)(a1 + 1112);
  if (!v3)
    goto LABEL_110;
  Count = CFArrayGetCount(v3);
  v58 = v2;
  if (!Count || (v5 = Count, v6 = *(_QWORD *)(a1 + 1120), v6 >= Count))
  {
    ValueAtIndex = 0;
LABEL_112:
    v54 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Done processing AJ candidates, %ld", "__WiFiDeviceManagerProcessCandidates", *(_QWORD *)(a1 + 1120));
    objc_autoreleasePoolPop(v54);
    v47 = 0;
    v2 = v58;
    goto LABEL_84;
  }
  while (1)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v6);
    v8 = objc_autoreleasePoolPush();
    if (!ValueAtIndex)
      break;
    if (qword_10026DD20)
    {
      v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Autojoin is processing network %ld of %ld candidates"), *(_QWORD *)(a1 + 1120) + 1, v5)), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v10 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v61 = v10;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v8);
    if ((!*(_BYTE *)(a1 + 24) || !sub_100069F0C(*(_QWORD *)(a1 + 64)) || *(_DWORD *)(a1 + 28))
      && sub_100007DCC(ValueAtIndex))
    {
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin candidate contains hidden ssid");
      objc_autoreleasePoolPop(v49);
      v50 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CHANNEL"));
      return sub_100131C40(a1, v50);
    }
    ++*(_QWORD *)(a1 + 1120);
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager->joinRecommendationMode = %d", "__WiFiDeviceManagerProcessCandidates", *(unsigned int *)(a1 + 6576));
    objc_autoreleasePoolPop(v11);
    v12 = *(_DWORD *)(a1 + 3280);
    if (*(_DWORD *)(a1 + 6576) && *(_DWORD *)(a1 + 108) == 2)
    {
      v13 = sub_1000CB480((uint64_t)ValueAtIndex);
      if (sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("WiFiNetworkAttributeIsPublic")) == kCFBooleanTrue)
        v15 = 1;
      else
        v15 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isOmnipresentNetwork:", ValueAtIndex);
      if (*(_DWORD *)(a1 + 6576) == 255)
        goto LABEL_42;
      v16 = *(const void **)(a1 + 112);
      if (!v16 || (v17 = sub_10002B088(ValueAtIndex), !CFEqual(v16, v17)))
      {
        if (v13)
          v19 = 1;
        else
          v19 = v15;
        if ((v19 & 1) != 0)
          goto LABEL_30;
        v25 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ not a public/carrier network. Suppressing approve-to-join alert.", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", sub_10002B088(ValueAtIndex), v56, v57);
        goto LABEL_50;
      }
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: matching ATJ test network %@, bypass network type check.", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", *(_QWORD *)(a1 + 112));
      objc_autoreleasePoolPop(v18);
LABEL_30:
      v20 = sub_100009ACC(a1);
      if (v20)
      {
        v21 = v20;
        v22 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "isWithin:fromLocation:forNetwork:", v20, *(_QWORD *)(a1 + 3512), *(double *)(a1 + 6728));
        if (v22 == (id)1)
        {
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is not at known location.", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", sub_10002B088(*(const void **)(a1 + 3512)));
          objc_autoreleasePoolPop(v23);
        }

        v14 = sub_1000C6A74(ValueAtIndex);
        if (v22 == (id)1)
        {
LABEL_42:
          if (-[WiFiUserInteractionMonitor isNetworkingAppInForeground](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance", v14), "isNetworkingAppInForeground"))
          {
            v26 = *(_DWORD *)(a1 + 3352);
            if (v26 <= 6 && ((1 << v26) & 0x58) != 0)
            {
              v25 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device in motion (%@). Suppressing approve-to-join alert.", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", sub_100024674(*(_DWORD *)(a1 + 3352)));
              goto LABEL_49;
            }
            v25 = objc_autoreleasePoolPush();
            v43 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Dispatching auto join recommendation for %@", sub_10002B088(ValueAtIndex));
            objc_autoreleasePoolPop(v43);
            v44 = sub_100025C3C(*(_QWORD *)(a1 + 64));
            v12 = sub_100119668(a1, v44, 5, 0, ValueAtIndex, 0);
          }
          else
          {
            v25 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not in networking app. Suppressing approve-to-join alert.", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", v55);
LABEL_49:
            v12 = 21;
          }
LABEL_50:
          objc_autoreleasePoolPop(v25);
          goto LABEL_51;
        }
      }
      else
      {
        v14 = sub_1000C6A74(ValueAtIndex);
      }
      v24 = v14;
      v14 = *(double *)(a1 + 6736);
      if (v24 >= v14)
        goto LABEL_42;
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is within range of known location or last joined date. Suppressing approve-to-join alert. (isWithinRange %d, %f seconds)", "__WiFiDeviceManagerShowApproveToJoinIfAppropriate", sub_10002B088(ValueAtIndex), 1, *(_QWORD *)&v24);
      goto LABEL_50;
    }
LABEL_51:
    if (v12 == 21)
    {
      v41 = objc_autoreleasePoolPush();
      v42 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v55 = sub_10002B088(ValueAtIndex);
        objc_msgSend(v42, "WFLog:message:", 3, "%s: not the right time to ask for approval to join for %@. Retrying next candidate.", "__WiFiDeviceManagerProcessCandidates");
      }
      objc_autoreleasePoolPop(v41);
      goto LABEL_77;
    }
    if (v12 == 14)
    {
      v53 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: requesting approval to join. Waiting for user input for %@.", "__WiFiDeviceManagerProcessCandidates", sub_10002B088(ValueAtIndex));
      objc_autoreleasePoolPop(v53);
      return 14;
    }
    if (*v59)
    {
      v27 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      v28 = sub_10002A21C(a1, v27, 1);
      if (v28)
      {
        v29 = v28;
        v30 = sub_10002B088(v28);
        v31 = sub_10002B088(ValueAtIndex);
        LODWORD(v30) = CFEqual(v30, v31);
        CFRelease(v29);
        if ((_DWORD)v30)
          goto LABEL_77;
      }
      v32 = objc_autoreleasePoolPush();
      v33 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v55 = sub_10002B088(ValueAtIndex);
        objc_msgSend(v33, "WFLog:message:", 3, "%s: Disconnect from Hotspot. Attempting network transition to %@!!", "__WiFiDeviceManagerProcessCandidates");
      }
      objc_autoreleasePoolPop(v32);
      v34 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      sub_1000F7F48(a1, v34, 1019, "__WiFiDeviceManagerProcessCandidates", 15481);
    }
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v35 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      v36 = sub_10002A21C(a1, v35, 1);
      if (v36)
      {
        v37 = v36;
        v38 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("COLOCATED_NETWORK_SCOPE_ID"));
        v39 = objc_autoreleasePoolPush();
        v40 = (void *)qword_10026DD20;
        if (v38)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Link down will be debounced", "__WiFiDeviceManagerProcessCandidates");
          objc_autoreleasePoolPop(v39);
        }
        else
        {
          if (qword_10026DD20)
          {
            v55 = sub_10002B088(v37);
            v56 = sub_10002B088(ValueAtIndex);
            objc_msgSend(v40, "WFLog:message:", 3, "%s: Disconnect from '%@', attempting network transition to '%@'", "__WiFiDeviceManagerProcessCandidates");
          }
          objc_autoreleasePoolPop(v39);
          v45 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
          sub_1000F7F48(a1, v45, 1013, "__WiFiDeviceManagerProcessCandidates", 15494);
        }
        CFRelease(v37);
      }
    }
    if (!sub_10012C418((_BYTE *)a1, 0) || (sub_10003153C((uint64_t)ValueAtIndex) & 0xFFFFFFFE) != 2)
    {
      if (sub_10012C418((_BYTE *)a1, 0) || sub_10012C188(a1, 0))
      {
        sub_10002C478((uint64_t)ValueAtIndex, CFSTR("FORCE_BSSID"), kCFBooleanTrue);
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Forceing BSSID Join: %@\n", "__WiFiDeviceManagerProcessCandidates", sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID")));
        objc_autoreleasePoolPop(v51);
      }
      v52 = sub_1001161F4(a1, ValueAtIndex, 0);
      if ((_DWORD)v52)
        return sub_100129744(a1, ValueAtIndex, 0, v52);
      sub_100135D8C(a1, CFSTR("autoJoinAssociating"), ValueAtIndex, 0);
      return 12;
    }
LABEL_77:
    v6 = *(_QWORD *)(a1 + 1120);
    if (v6 >= v5)
      goto LABEL_112;
  }
  v2 = v58;
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "__WiFiDeviceManagerProcessCandidates");
  objc_autoreleasePoolPop(v8);
LABEL_110:
  ValueAtIndex = 0;
  v47 = 0;
LABEL_84:
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_100132420(a1, (uint64_t)ValueAtIndex, (int)v47, CWFManagerErrorDomain, (uint64_t)CFSTR("Failed to process join candidate"));
    return 0;
  }
  else if (*(_BYTE *)(a1 + 24) && sub_100069F0C(*(_QWORD *)(a1 + 64)) && !*(_DWORD *)(a1 + 28))
  {
    return sub_100132534((_DWORD *)a1, v47);
  }
  else if (v2)
  {
    return sub_100131444(a1);
  }
  else
  {
    return sub_10000D074(a1, v47);
  }
}

uint64_t sub_100131444(uint64_t a1)
{
  const void *v2;
  const __CFArray *v3;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFIndex v7;
  __CFString *v8;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  CFIndex Count;
  CFIndex v20;
  __CFArray *v21;
  void *v22;
  uint64_t v24;
  int valuePtr;
  CFRange v26;

  v2 = *(const void **)(a1 + 1112);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 1112) = 0;
  }
  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 3328)))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No GAS queries.", "__WiFiDeviceManagerProcessDeferredNetworks");
    goto LABEL_26;
  }
  v3 = *(const __CFArray **)(a1 + 3560);
  if (!v3)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No scan results", "__WiFiDeviceManagerProcessDeferredNetworks");
    goto LABEL_26;
  }
  if (!CFArrayGetCount(v3))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No HS2.0 networks to query", v24);
LABEL_26:
    objc_autoreleasePoolPop(v18);
    goto LABEL_27;
  }
  valuePtr = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
LABEL_27:
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
    if (Count)
    {
      v20 = Count;
      v21 = *(__CFArray **)(a1 + 1112);
      if (!v21)
      {
        v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(a1 + 1112) = v21;
      }
      v26.location = 0;
      v26.length = v20;
      CFArrayAppendArray(v21, *(CFArrayRef *)(a1 + 3568), v26);
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Appending deffered networks to candidates list", "__WiFiDeviceManagerProcessDeferredNetworks");
      objc_autoreleasePoolPop(v22);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3568));
    objc_msgSend(*(id *)(a1 + 3656), "clearScanResultsForAutoJoinSessionReset");
    sub_10012F8CC(a1, *(const __CFArray **)(a1 + 1112));
    if (sub_1001301A8(a1))
      return sub_100130A04(a1);
    v16 = 0;
    return sub_10000D074(a1, v16);
  }
  v5 = Mutable;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryAddValue(v5, CFSTR("GAS_PROTOCOL"), v6);
  CFDictionaryAddValue(v5, CFSTR("GAS_QUERY"), *(const void **)(a1 + 3328));
  CFDictionaryAddValue(v5, CFSTR("GAS_NETWORKS"), *(const void **)(a1 + 3560));
  v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560));
  v8 = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (v7 >= 1)
  {
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3560), i);
      v11 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID"));
      if (v11)
      {
        if (i >= v7 - 1)
          CFStringAppend(v8, v11);
        else
          CFStringAppendFormat(v8, 0, CFSTR("%@, "), v11);
      }
    }
  }
  v12 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
  if (v12)
  {
    v13 = v12;
    *v12 = a1;
    v12[1] = sub_1001326CC;
    v12[2] = a1;
    v14 = *(_QWORD *)(a1 + 64);
    v15 = (const void *)sub_100025C3C(v14);
    v16 = sub_1000746E4(v14, v15, v5, 0, (uint64_t)sub_100110504, (uint64_t)v13, (_QWORD *)(a1 + 3312));
    if ((_DWORD)v16)
      free(v13);
  }
  else
  {
    v16 = 4294963395;
  }
  CFRelease(v5);
  if (v6)
    CFRelease(v6);
  v17 = objc_autoreleasePoolPush();
  if ((_DWORD)v16)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to send GAS query. Error %d", v16);
    objc_autoreleasePoolPop(v17);
    if (v8)
      CFRelease(v8);
    return sub_10000D074(a1, v16);
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending GAS request to %@", "__WiFiDeviceManagerProcessDeferredNetworks", v8);
  objc_autoreleasePoolPop(v17);
  if (v8)
    CFRelease(v8);
  return 13;
}

BOOL sub_100131848(uint64_t a1, const void *a2)
{
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFRange v8;

  if (a1
    && a2
    && !sub_10002DA5C((_BOOL8)a2)
    && (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3576))) != 0
    && (v8.length = Count,
        v8.location = 0,
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3576), v8, a2),
        FirstIndexOfValue != -1)
    && (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3576), FirstIndexOfValue)) != 0)
  {
    return sub_100013840((uint64_t)ValueAtIndex);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1001318C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  CFIndex Count;
  CFIndex v9;
  const __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  const void *v15;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFIndex v18;
  const void *v19;
  const __CFDate *v20;
  const __CFDate *v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  CFComparisonResult v25;
  void *v26;
  void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  CFRange v34;
  CFRange v35;

  if (!a3)
    goto LABEL_50;
  if (a1 | a2)
    v6 = -1;
  else
    v6 = 0;
  if (a2)
    result = 1;
  else
    result = v6;
  if (!a1 || !a2)
    return result;
  Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3576));
  if (!Count)
  {
LABEL_50:
    v19 = (const void *)a2;
    ValueAtIndex = (const void *)a1;
    return sub_1000C609C((uint64_t)ValueAtIndex, (uint64_t)v19);
  }
  v9 = Count;
  if (*(_DWORD *)(a3 + 3280) != 11)
    goto LABEL_26;
  v10 = *(const __CFArray **)(a3 + 3368);
  if (!v10 || !CFArrayGetCount(v10))
    goto LABEL_26;
  v11 = sub_1000CB39C(*(const __CFArray **)(a3 + 3368), a1);
  v12 = sub_1000CB39C(*(const __CFArray **)(a3 + 3368), a2);
  v13 = objc_autoreleasePoolPush();
  v14 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v15 = sub_10002B088((const void *)a1);
    objc_msgSend(v14, "WFLog:message:", 3, "%s: ranking: %@(%ld), %@(%ld)", "__WiFiDeviceManagerNetworkCompareAutoJoinPriority", v15, v11, sub_10002B088((const void *)a2), v12);
  }
  objc_autoreleasePoolPop(v13);
  if (v11 != -1 && v12 != -1)
  {
    if (v11 > v12)
      return 1;
    else
      return -1;
  }
  result = v11 == -1 ? 1 : -1;
  if (v11 == -1 && v12 == -1)
  {
LABEL_26:
    v34.location = 0;
    v34.length = v9;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3576), v34, (const void *)a1);
    ValueAtIndex = (const void *)a1;
    if (FirstIndexOfValue != -1)
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3576), FirstIndexOfValue);
    v35.location = 0;
    v35.length = v9;
    v18 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3576), v35, (const void *)a2);
    v19 = (const void *)a2;
    if (v18 != -1)
      v19 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3576), v18);
    if (*(_BYTE *)(a3 + 6632))
    {
      result = sub_1000C8C90((uint64_t)ValueAtIndex, (uint64_t)v19, 0);
      if (result)
        return result;
      v20 = (const __CFDate *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("lastUpdated"));
      v21 = (const __CFDate *)sub_10002BE64((uint64_t)v19, CFSTR("lastUpdated"));
      v22 = sub_100017A54(a1, CFSTR("RSSI"));
      v23 = sub_100017A54(a2, CFSTR("RSSI"));
      if (v20)
      {
        if (v21)
        {
          if ((uint64_t)v22 >= -65)
          {
            v24 = v23;
            if ((uint64_t)v23 >= -65)
            {
              v25 = CFDateCompare(v20, v21, 0);
              v26 = objc_autoreleasePoolPush();
              v27 = (void *)qword_10026DD20;
              if (v25 == kCFCompareGreaterThan)
              {
                if (qword_10026DD20)
                {
                  v28 = sub_10002B088(ValueAtIndex);
                  objc_msgSend(v27, "WFLog:message:", 4, "Preferred %@(%ld, %@) over %@ (%ld, %@)", v28, v22, v20, sub_10002B088(v19), v24, v21);
                }
                objc_autoreleasePoolPop(v26);
                return -1;
              }
              if (qword_10026DD20)
              {
                v33 = sub_10002B088(v19);
                objc_msgSend(v27, "WFLog:message:", 4, "Preferred %@(%ld, %@) over %@ (%ld, %@)", v33, v24, v21, sub_10002B088(ValueAtIndex), v22, v20);
              }
              objc_autoreleasePoolPop(v26);
              return 1;
            }
          }
        }
      }
    }
    if (*(_QWORD *)(a3 + 6976))
    {
      v29 = sub_10002B088((const void *)a1);
      v30 = sub_10002B088(*(const void **)(a3 + 6976));
      if (CFEqual(v29, v30))
        return -1;
      v31 = sub_10002B088((const void *)a2);
      v32 = sub_10002B088(*(const void **)(a3 + 6976));
      if (CFEqual(v31, v32))
        return 1;
    }
    return sub_1000C609C((uint64_t)ValueAtIndex, (uint64_t)v19);
  }
  return result;
}

uint64_t sub_100131C40(uint64_t a1, const void *a2)
{
  CFIndex Count;
  CFMutableStringRef Mutable;
  const __CFArray *v6;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  CFIndex v14;
  CFIndex v15;
  CFIndex j;
  void *v17;
  CFIndex v18;
  CFIndex Length;
  void *v20;
  const __CFDictionary **v21;
  CFIndex v22;
  const __CFDictionary **v23;
  const __CFArray *v24;
  void *v25;
  void *v26;
  const __CFString *v27;
  void *v28;
  void *v30;
  CFIndex v31;
  __CFArray *v32;
  CFIndex v33;
  const __CFDictionary **v34;
  const __CFArray *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex i;
  const __CFDictionary **v39;
  const __CFDictionary **v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  CFIndex v45;
  const __CFDictionary *v46;
  const void *Value;
  CFDictionaryRef v48;
  CFDictionaryRef v49;
  uint64_t v50;
  const __CFArray *v51;
  void *v53;
  uint64_t v54;
  int v55;
  const void *v56;
  void *v57;
  const __CFArray *cf;
  void *v59[2];
  void *keys[2];
  void *values;
  CFRange v62;
  CFRange v63;
  CFRange v64;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3552));
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  v6 = *(const __CFArray **)(a1 + 1112);
  if (!v6)
    goto LABEL_116;
  v7 = CFArrayGetCount(v6);
  if (!v7 || (v8 = *(_QWORD *)(a1 + 1120), v8 >= v7))
  {
    v57 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error: scan index invalid, %ld", "__WiFiDeviceManagerScanForHiddenNetworks", *(_QWORD *)(a1 + 1120));
    objc_autoreleasePoolPop(v57);
LABEL_116:
    v50 = 4294963394;
    if (!Mutable)
      return sub_10000D074(a1, v50);
    goto LABEL_95;
  }
  if (!*(_QWORD *)(a1 + 1152))
    goto LABEL_100;
  if (*(const void **)(a1 + 1160) != a2)
    *(_QWORD *)(a1 + 1160) = a2;
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v8);
  if (!sub_100007DCC(ValueAtIndex))
    goto LABEL_100;
  if (*(_QWORD *)(a1 + 1144) >= (int)Count)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin reset hidden index %ld, hiddenCount %d", *(_QWORD *)(a1 + 1144), Count);
    objc_autoreleasePoolPop(v11);
    *(_QWORD *)(a1 + 1144) = 0;
    v10 = *(_QWORD *)(a1 + 1120) + 1;
    *(_QWORD *)(a1 + 1120) = v10;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 1120);
  }
  if (v10 < 1)
    goto LABEL_18;
  v12 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), v10 - 1);
  if (!v12)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Previous Scan Candidate is Null!, index %ld", *(_QWORD *)(a1 + 1120));
    objc_autoreleasePoolPop(v13);
LABEL_18:
    v12 = 0;
  }
  v14 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1112));
  if (!v12 || *(_QWORD *)(a1 + 1144) || (v15 = v14, !sub_10001F440(v12)))
  {
LABEL_34:
    if (CFStringGetLength(Mutable))
    {
      v62.length = CFStringGetLength(Mutable);
      v62.location = 0;
      CFStringDelete(Mutable, v62);
    }
    v21 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), *(_QWORD *)(a1 + 1120));
    v22 = *(_QWORD *)(a1 + 1144);
    if (v22 < (int)Count)
    {
      do
      {
        v23 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3552), v22);
        v24 = *(const __CFArray **)(a1 + 1168);
        v63.length = CFArrayGetCount(v24);
        v63.location = 0;
        if (CFArrayGetFirstIndexOfValue(v24, v63, v23) == -1)
        {
          if (sub_1000C5C74(v21, v23))
            goto LABEL_43;
          if (Mutable)
            sub_10012EEB4(a1, v23, Mutable);
        }
        ++v22;
      }
      while ((int)Count != v22);
      v22 = (int)Count;
    }
LABEL_43:
    if (!CFStringGetLength(Mutable))
      goto LABEL_68;
    v25 = objc_autoreleasePoolPush();
    v26 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_67:
      objc_autoreleasePoolPop(v25);
LABEL_68:
      *(_QWORD *)(a1 + 1144) = v22;
      if (CFStringGetLength(Mutable))
      {
        v64.length = CFStringGetLength(Mutable);
        v64.location = 0;
        CFStringDelete(Mutable, v64);
      }
      v31 = *(_QWORD *)(a1 + 1144);
      if (v31 < CFArrayGetCount(*(CFArrayRef *)(a1 + 3552)))
      {
        values = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 1152), a2);
        cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        v32 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v33 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 1152));
        v34 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3552), *(_QWORD *)(a1 + 1144));
        if (v33)
        {
          v35 = *(const __CFArray **)(a1 + 1112);
          if (v35)
          {
            v36 = CFArrayGetCount(v35);
            if (v36 >= 1)
            {
              v37 = v36;
              for (i = 0; i != v37; ++i)
              {
                v39 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), i);
                if (v39)
                {
                  v40 = v39;
                  if (sub_10001F440(v39))
                  {
                    if (sub_1000C5C74(v34, v40))
                    {
                      v41 = (void *)sub_10002BE64((uint64_t)v40, CFSTR("CHANNEL"));
                      if (v41)
                      {
                        v42 = v41;
                        v43 = (void *)sub_10002BE64((uint64_t)v40, CFSTR("CHANNEL_FLAGS"));
                        if (v43)
                        {
                          v44 = v43;
                          if (CFArrayGetCount(v32) < 1)
                          {
LABEL_85:
                            *(_OWORD *)keys = *(_OWORD *)&off_100231A60;
                            v59[0] = v42;
                            v59[1] = v44;
                            v48 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)v59, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                            if (v48)
                            {
                              v49 = v48;
                              CFArrayAppendValue(v32, v48);
                              CFRelease(v49);
                            }
                          }
                          else
                          {
                            v45 = 0;
                            while (1)
                            {
                              v46 = (const __CFDictionary *)CFArrayGetValueAtIndex(v32, v45);
                              if (v46)
                              {
                                Value = CFDictionaryGetValue(v46, CFSTR("CHANNEL"));
                                if (CFEqual(v42, Value))
                                  break;
                              }
                              if (++v45 >= CFArrayGetCount(v32))
                                goto LABEL_85;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        sub_100125EC4(a1);
        *(_DWORD *)(a1 + 5620) = 10;
        if (CFArrayGetCount(v32) < 1)
        {
          v51 = cf;
          v50 = sub_10012C500(a1, (const __CFArray *)v34, cf, 0, 7);
          if (!cf)
          {
LABEL_91:
            if (v32)
              CFRelease(v32);
            if ((_DWORD)v50)
            {
              if (!Mutable)
                return sub_10000D074(a1, v50);
LABEL_95:
              CFRelease(Mutable);
              return sub_10000D074(a1, v50);
            }
            v55 = 0;
            v54 = 5;
            if (!Mutable)
            {
LABEL_102:
              if (!v55)
                return v54;
              v56 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), *(_QWORD *)(a1 + 1120));
              if (!v56 || sub_100007DCC(v56))
                ++*(_QWORD *)(a1 + 1120);
              return sub_100130A04(a1);
            }
LABEL_101:
            CFRelease(Mutable);
            goto LABEL_102;
          }
        }
        else
        {
          v50 = sub_10012C500(a1, (const __CFArray *)v34, v32, 0, 7);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1168), v34);
          v51 = cf;
          if (!cf)
            goto LABEL_91;
        }
        CFRelease(v51);
        goto LABEL_91;
      }
      v53 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin reset hidden index %ld, hiddenCount %d as all directed networks scanned for matching security", *(_QWORD *)(a1 + 1144), Count);
      objc_autoreleasePoolPop(v53);
      *(_QWORD *)(a1 + 1144) = 0;
LABEL_100:
      v54 = 12;
      v55 = 1;
      if (!Mutable)
        goto LABEL_102;
      goto LABEL_101;
    }
    if (v21)
    {
      if (sub_10002DAB4((uint64_t)v21))
      {
        v27 = CFSTR("EAP");
LABEL_66:
        objc_msgSend(v26, "WFLog:message:", 3, "Autojoin looking for %@ hidden network, so skipping - %@", v27, Mutable);
        goto LABEL_67;
      }
      if (sub_10003145C((uint64_t)v21))
      {
        v27 = CFSTR("WPA");
        goto LABEL_66;
      }
      if (sub_1000C3B8C((_BOOL8)v21))
      {
        v27 = CFSTR("WEP");
        goto LABEL_66;
      }
      if (sub_1000C433C((const __CFDictionary *)v21))
      {
        v27 = CFSTR("SAE");
        goto LABEL_66;
      }
    }
    v27 = CFSTR("OPEN");
    goto LABEL_66;
  }
  for (j = *(_QWORD *)(a1 + 1120); j < CFArrayGetCount(*(CFArrayRef *)(a1 + 1112)); ++j)
  {
    v17 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1112), *(_QWORD *)(a1 + 1120));
    if (!sub_100007DCC(v17))
    {
      if (CFStringGetLength(Mutable))
      {
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin is processing network %ld of %ld candidates, skipped candidate - %@", *(_QWORD *)(a1 + 1120) + 1, v15, Mutable);
        objc_autoreleasePoolPop(v30);
      }
      goto LABEL_100;
    }
    if (!sub_1000C5C74((const __CFDictionary **)v17, (const __CFDictionary **)v12))
      break;
    if (Mutable)
      sub_10012EEB4(a1, v17, Mutable);
    ++*(_QWORD *)(a1 + 1120);
  }
  v18 = *(_QWORD *)(a1 + 1120);
  Length = CFStringGetLength(Mutable);
  if (v18 < v15)
  {
    if (Length)
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin is processing network %ld of %ld candidates, skipped candidates - %@", *(_QWORD *)(a1 + 1120) + 1, v15, Mutable);
      objc_autoreleasePoolPop(v20);
    }
    goto LABEL_34;
  }
  if (Length)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Autojoin completed processing %ld candidates, skipped candidates - %@", *(_QWORD *)(a1 + 1120) + 1, Mutable);
    objc_autoreleasePoolPop(v28);
  }
  if (Mutable)
    CFRelease(Mutable);
  return sub_100130A04(a1);
}

void sub_100132420(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorDomain a4, uint64_t a5)
{
  void *v10;
  NSDictionary *v11;
  CFErrorDomain v12;
  uint64_t v13;
  NSErrorUserInfoKey v14;
  uint64_t v15;

  v10 = objc_autoreleasePoolPush();
  if (!a3)
    a3 = 57;
  if (!a4)
    a4 = kCFErrorDomainPOSIX;
  if (a5)
  {
    v14 = NSLocalizedDescriptionKey;
    v15 = a5;
    v11 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1);
    v12 = a4;
    v13 = a3;
  }
  else
  {
    v12 = a4;
    v13 = a3;
    v11 = 0;
  }
  sub_100132594(a1, a2, (uint64_t)+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v12, v13, v11));
  objc_autoreleasePoolPop(v10);
}

uint64_t sub_100132534(_DWORD *a1, uint64_t a2)
{
  unsigned int v3;

  if (a1[1380] == 1 || *((_BYTE *)a1 + 5504))
    return sub_10012CA98(a1);
  v3 = a1[821];
  if (v3 <= 0xB)
  {
    if (((1 << v3) & 0xC0) != 0)
      return sub_10012CB54((uint64_t)a1);
    if (((1 << v3) & 0x300) != 0)
      return sub_10012E0D8((uint64_t)a1);
    if (((1 << v3) & 0xC00) != 0)
      return sub_100131444((uint64_t)a1);
  }
  return sub_10000D074(a1, a2);
}

void sub_100132594(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  v6 = objc_autoreleasePoolPush();
  if (a1)
  {
    v7 = *(_QWORD *)(a1 + 8840);
    if (v7)
    {
      v8 = *(_QWORD *)(a1 + 8832);
      if (v8)
      {
        if (a2)
        {
          if (!sub_1000C6060(a2, v8))
            goto LABEL_10;
          v7 = *(_QWORD *)(a1 + 8840);
        }
        (*(void (**)(uint64_t, uint64_t))(v7 + 16))(v7, a3);
        _Block_release(*(const void **)(a1 + 8840));
        *(_QWORD *)(a1 + 8840) = 0;
        CFRelease(*(CFTypeRef *)(a1 + 8832));
        *(_QWORD *)(a1 + 8832) = 0;
        v9 = *(_QWORD *)(a1 + 8920);
        v10 = v9 + 1;
        v11 = v9 == -1;
        *(_QWORD *)(a1 + 8920) = v10;
        if (*(_QWORD *)(a1 + 8912) >= 6uLL && !v11)
        {
          sub_10001E764(*(_QWORD *)(a1 + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend(*(id *)(a1 + 8904), "UUIDString")), 0);
          sub_10001E764(*(_QWORD *)(a1 + 64), 9, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend(*(id *)(a1 + 8904), "UUIDString")), 0);
        }
      }
    }
  }
LABEL_10:
  objc_autoreleasePoolPop(v6);
}

void sub_1001326CC(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4)
{
  void *v7;
  uint64_t v8;
  const void *v9;
  CFMutableArrayRef MutableCopy;
  uint64_t v11;
  void *v12;

  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto join GAS query completed (%d) with current state: %@", a4, sub_100031FD0(*(_DWORD *)(a1 + 3280)));
  objc_autoreleasePoolPop(v7);
  v8 = sub_100070AFC(*(_QWORD *)(a1 + 64));
  if (v8 == *(_QWORD *)(a1 + 3312))
  {
    v9 = *(const void **)(a1 + 3336);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 3336) = 0;
    }
    if (a3)
      MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, a3);
    else
      MutableCopy = 0;
    *(_QWORD *)(a1 + 3336) = MutableCopy;
    *(_DWORD *)(a1 + 3344) = a4;
    sub_1000F49C8(a1);
  }
  else
  {
    v11 = v8;
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignorning old request.  CurrentCommand=%lld PendingCommand=%lld", v11, *(_QWORD *)(a1 + 3312));
    objc_autoreleasePoolPop(v12);
  }
}

void sub_1001327E4(uint64_t a1, const void *a2)
{
  void *v4;
  const __CFArray *v5;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const __CFArray *v8;
  CFIndex v9;
  CFRange v10;
  CFRange v11;

  v4 = objc_autoreleasePoolPush();
  if (a1 && a2)
  {
    v5 = *(const __CFArray **)(a1 + 3528);
    if (v5)
    {
      v10.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
      v10.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v5, v10, a2);
      if (FirstIndexOfValue != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), FirstIndexOfValue);
        if (ValueAtIndex)
          goto LABEL_9;
      }
    }
    v8 = *(const __CFArray **)(a1 + 3536);
    if (v8)
    {
      v11.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3536));
      v11.location = 0;
      v9 = CFArrayGetFirstIndexOfValue(v8, v11, a2);
      if (v9 != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), v9);
        if (ValueAtIndex)
LABEL_9:
          objc_msgSend(*(id *)(a1 + 6624), "setNetworkOfInterest:", ValueAtIndex);
      }
    }
  }
  objc_autoreleasePoolPop(v4);
}

void sub_1001328A8(uint64_t a1, const void *a2, int a3)
{
  void *v6;
  unsigned int v7;
  __CFSet *v8;

  if (a1)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = objc_msgSend(*(id *)(a1 + 6648), "enabled");
    objc_autoreleasePoolPop(v6);
    if (v7)
    {
      v8 = *(__CFSet **)(a1 + 3504);
      if (a3)
        CFSetAddValue(v8, a2);
      else
        CFSetRemoveValue(v8, a2);
    }
  }
}

void sub_100132934(uint64_t a1)
{
  uint64_t *v2;
  void (*v3)(uint64_t *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(uint64_t **)(a1 + 48);
  if (v2[30])
  {
    v3 = (void (*)(uint64_t *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))v2[484];
    v4 = sub_100025C3C(v2[8]);
    v5 = a1 + 40;
    v3(v2, v4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(unsigned int *)(a1 + 56), *(_QWORD *)(*(_QWORD *)(a1 + 48) + 3880));
    CFRelease(*(CFTypeRef *)(a1 + 48));
    v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    v7 = *(const void **)(*(_QWORD *)(*(_QWORD *)v5 + 8) + 24);
    if (!v7)
      return;
LABEL_10:
    CFRelease(v7);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 8) + 24) = 0;
    return;
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v10 = *(_QWORD *)(a1 + 40);
  v9 = a1 + 40;
  v7 = *(const void **)(*(_QWORD *)(v10 + 8) + 24);
  if (v7)
  {
    v5 = v9;
    goto LABEL_10;
  }
}

