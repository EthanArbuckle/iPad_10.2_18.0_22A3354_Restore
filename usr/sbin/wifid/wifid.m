void sub_100005670(uint64_t a1, const void *a2)
{
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 136), a2);
  if (sub_100005830((uint64_t)a2) == 1)
  {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 144), a2);
    sub_100013B90(a1, *(_QWORD *)(a1 + 832));
    if (CFSetGetCount(*(CFSetRef *)(a1 + 144)) >= 2)
    {
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        sub_100007F68(a1, 30);
      else
        sub_100090860(a1, 0);
    }
  }
  else if (sub_100005830((uint64_t)a2) == 2)
  {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 152), a2);
    sub_100013B90(a1, *(_QWORD *)(a1 + 832));
  }
}

void sub_100005740(uint64_t a1, const void *a2)
{
  int v4;
  __CFSet *v5;

  v4 = CFSetContainsValue(*(CFSetRef *)(a1 + 160), a2);
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 136), a2);
  sub_100005F98((CFDictionaryRef *)a1, (uint64_t)a2);
  sub_1000066D8(a1, a2);
  if (sub_100005830((uint64_t)a2) == 1)
  {
    v5 = *(__CFSet **)(a1 + 144);
LABEL_5:
    CFSetRemoveValue(v5, a2);
    sub_100013B90(a1, *(_QWORD *)(a1 + 832));
    return;
  }
  if (sub_100005830((uint64_t)a2) == 2)
  {
    v5 = *(__CFSet **)(a1 + 152);
    goto LABEL_5;
  }
  if (v4)
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_100007F68(a1, 30);
    else
      sub_100090860(a1, 0);
  }
}

uint64_t sub_100005830(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100005838(uint64_t a1, void *value, int a3)
{
  int v5;
  int v7;
  int v8;
  unsigned int v9;
  CFIndex Count;
  int v11;
  CFIndex v12;
  unsigned int v13;
  const void *v14;
  void *v15;
  const char *v16;
  const char *v17;

  v5 = *(unsigned __int8 *)(a1 + 1184);
  if (!value)
    goto LABEL_8;
  v7 = CFSetContainsValue(*(CFSetRef *)(a1 + 1192), value);
  if (a3)
  {
    if (v7)
      goto LABEL_8;
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 1192), value);
    v8 = 1;
  }
  else
  {
    if (!v7)
      goto LABEL_8;
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 1192), value);
    v8 = -1;
  }
  *(_DWORD *)(a1 + 1200) += v8;
LABEL_8:
  v9 = objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isQuiesceWiFiActivityRegistered");
  Count = CFSetGetCount(*(CFSetRef *)(a1 + 1192));
  if (Count > 0)
    v11 = 1;
  else
    v11 = v9;
  if (v5 == v11)
    return 0;
  v12 = Count;
  *(_BYTE *)(a1 + 1184) = v11;
  if (v11)
  {
    v13 = 0;
    *(_DWORD *)(a1 + 1204) = *(_DWORD *)(a1 + 316);
LABEL_15:
    v14 = (const void *)sub_1000161D4((uint64_t)value);
    sub_10008F33C(a1, v13, v14);
    goto LABEL_16;
  }
  v13 = *(_DWORD *)(a1 + 1204);
  if (v13 != *(_DWORD *)(a1 + 316))
    goto LABEL_15;
LABEL_16:
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v16 = "unquiesced";
    if (v11)
      v16 = "quiesced";
    v17 = "no";
    if (v9)
      v17 = "yes";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi is %s (clients=%ld activity=%s)", v16, v12, v17);
  }
  objc_autoreleasePoolPop(v15);
  return 0;
}

uint64_t sub_1000059A0(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  void *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  __CFArray *v13;
  __CFArray *v14;

  *a2 = 0;
  *a3 = 0;
  v6 = sub_1000167F8();
  v7 = sub_10001674C(a1, v6);
  if (v7)
  {
    v8 = v7;
    if ((sub_100016834((uint64_t)v7) & 1) != 0)
    {
      v10 = (const __CFArray *)sub_100016A7C((uint64_t)v8);
      if (v10)
      {
        v11 = sub_10000B29C(v10);
        if (v11)
        {
          v12 = v11;
          v13 = sub_10000BF9C((uint64_t)v8, v11);
          if (v13)
          {
            v14 = v13;
            sub_100016858(v13, a2, a3);
            CFRelease(v14);
          }
          CFRelease(v12);
        }
      }
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_devices(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v8));
      objc_autoreleasePoolPop(v9);
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t sub_100005AA4(unsigned int a1, const void *a2)
{
  pthread_mutex_lock(&stru_10026CB08);
  if (qword_10026D6B8)
    CFDictionarySetValue((CFMutableDictionaryRef)qword_10026D6B8, (const void *)a1, a2);
  return pthread_mutex_unlock(&stru_10026CB08);
}

uint64_t sub_100005AF0(uint64_t a1)
{
  void *v1;
  unsigned int v3;

  v3 = 0;
  if (!sub_100032234(*(_QWORD *)(a1 + 64), (uint64_t)&v3))
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiMC : Retrieved band support :[%d]", "WiFiDeviceManagerGetCountryBandSupport", v3);
    objc_autoreleasePoolPop(v1);
  }
  return v3;
}

void sub_100005B68(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4;
  const void *ValueAtIndex;
  _QWORD v6[4];

  if (a1)
  {
    if (theArray && CFArrayGetCount(theArray) >= 1)
    {
      v4 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4);
        if (ValueAtIndex)
          sub_10002C478((uint64_t)ValueAtIndex, CFSTR("forceBGScanParamsCompare"), kCFBooleanTrue);
        ++v4;
      }
      while (v4 < CFArrayGetCount(theArray));
    }
    v6[0] = a1;
    v6[1] = 0xAAAAAAAA00000008;
    v6[2] = theArray;
    v6[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v6);
  }
}

void sub_100005C88(uint64_t a1, int a2)
{
  _BYTE *v4;
  CFIndex Count;
  void *v6;
  void *v7;
  const void *v8;
  const void *v9;

  v4 = (_BYTE *)(a1 + 5688);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5696));
  if (a2 && *(_QWORD *)(a1 + 5672))
  {
    v4[32] = 1;
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "scanCache: Defering purging scan cache");
    objc_autoreleasePoolPop(v6);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "scanCache: Purging scan cache");
    objc_autoreleasePoolPop(v7);
    if (Count)
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 5696));
    v8 = *(const void **)(a1 + 5672);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 5672) = 0;
    }
    v9 = *(const void **)(a1 + 5680);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 5680) = 0;
    }
    *v4 = 0;
  }
}

uint64_t sub_100005D74(unsigned int a1, int a2, uint64_t a3, int a4, unsigned int *a5, _DWORD *a6, __int128 *a7)
{
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  const void *v20;
  unsigned int v21;
  void *v22;
  void *v23;
  void *v25;
  __int128 v26[2];

  *a5 = 0;
  *a6 = 0;
  v14 = qword_10026D748;
  if (!qword_10026D748)
  {
    pthread_once(&stru_10026CCC8, (void (*)(void))sub_1000DA878);
    v14 = qword_10026D748;
  }
  v15 = (uint64_t *)sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    v17 = v15[2];
    v18 = a7[1];
    v26[0] = *a7;
    v26[1] = v18;
    v19 = sub_10000B624((uint64_t)kCFAllocatorDefault, a2, v17, a3, 60, a4, v26);
    if (v19)
    {
      v20 = (const void *)v19;
      if (!sub_1000083F0(v19))
      {
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_open(mach_port_t, int, int, mach_port_t, mach_port_t *, int *, audit_token_t)", sub_1000161D4((uint64_t)v20));
        objc_autoreleasePoolPop(v23);
        *a6 = 1;
        CFRelease(v20);
        goto LABEL_13;
      }
      sub_100032310((uint64_t)v20, (uint64_t)sub_100006E28, (uint64_t)v16);
      sub_100032308((uint64_t)v20, v16[3]);
      sub_100005670(v16[2], v20);
      v21 = sub_100032328((uint64_t)v20);
      *a5 = v21;
      sub_100005AA4(v21, v20);
      if (a2 != 1)
      {
LABEL_13:
        CFRelease(v16);
        return 0;
      }
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Attached client %@ is background application", sub_1000161D4((uint64_t)v20));
    }
    else
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to create WiFi Manager client for pid=%d", a3);
    }
    objc_autoreleasePoolPop(v22);
    goto LABEL_13;
  }
  v25 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to acquire WiFiServerRef for mach port");
  objc_autoreleasePoolPop(v25);
  return 0;
}

void sub_100005F98(CFDictionaryRef *a1, uint64_t a2)
{
  CFStringRef v4;
  CFStringRef v5;
  __CFDictionary *Value;
  __CFDictionary *v7;
  const void *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  const void *ValueAtIndex;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;

  if (a2)
  {
    v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d"), 14);
    if (v4)
    {
      v5 = v4;
      Value = (__CFDictionary *)CFDictionaryGetValue(a1[266], v4);
      if (!Value)
        goto LABEL_14;
      v7 = Value;
      v8 = (const void *)sub_1000161D4(a2);
      CFDictionaryRemoveValue(v7, v8);
      if (CFDictionaryGetCount(v7) != 3)
        goto LABEL_14;
      CFDictionaryRemoveValue(a1[266], v5);
      v9 = sub_10000B29C((CFArrayRef)a1);
      if (!v9)
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "__WiFiManagerEventClearRateLimit");
        objc_autoreleasePoolPop(v15);
        goto LABEL_14;
      }
      v10 = v9;
      if (CFArrayGetCount(v9))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v10, 0);
        if (ValueAtIndex && (v12 = (uint64_t)ValueAtIndex, (v13 = sub_1000161D4((uint64_t)ValueAtIndex)) != 0))
        {
          sub_100029860(v13);
          if (!sub_10011AF34(v12))
          {
LABEL_13:
            CFRelease(v10);
LABEL_14:
            CFRelease(v5);
            return;
          }
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to set default LQM interval", "__WiFiManagerEventClearRateLimit");
        }
        else
        {
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device manager is null", "__WiFiManagerEventClearRateLimit");
        }
      }
      else
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device managers array is empty", "__WiFiManagerEventClearRateLimit");
      }
      objc_autoreleasePoolPop(v14);
      goto LABEL_13;
    }
  }
}

void sub_100006188(uint64_t a1, int a2)
{
  const void *v3;
  void *v4;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiDeviceManagerStartAutoInstantHotspotAssociation");
    goto LABEL_14;
  }
  if (!*(_DWORD *)(a1 + 6804))
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: autoHotspotMode is not set", "WiFiDeviceManagerStartAutoInstantHotspotAssociation");
LABEL_14:
    objc_autoreleasePoolPop(v5);
    return;
  }
  *(_BYTE *)(a1 + 6800) = a2;
  if (a2)
  {
    *(_QWORD *)(a1 + 6952) = 0;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      v3 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
      v4 = sub_10002A21C(a1, v3, 1);
      if (v4)
        CFRelease(v4);
      else
        sub_1000285E4(a1, 0x3DuLL);
    }
    else
    {
      sub_10011B664(a1, 1);
    }
  }
}

uint64_t sub_100006360(unsigned int a1)
{
  pthread_mutex_lock(&stru_10026CB08);
  if (qword_10026D6B8)
    CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_10026D6B8, (const void *)a1);
  return pthread_mutex_unlock(&stru_10026CB08);
}

id *sub_1000063A4(id *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (objc_msgSend(a1[212], "isAuthorized"))
      a1 = (id *)objc_msgSend(objc_msgSend(a1[212], "latestLocation"), "copy");
    else
      a1 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return a1;
}

uint64_t sub_1000063FC(unsigned int a1, int a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  char v7;
  void *v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    v7 = sub_100016834((uint64_t)v5);
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if ((v7 & 1) != 0)
    {
      if (qword_10026DD20)
      {
        v10 = sub_1000161D4((uint64_t)v6);
        v11 = "normal";
        if (a2 == 3)
          v11 = "cloud";
        if (a2 == 1)
          v11 = "background";
        objc_msgSend(v9, "WFLog:message:", 3, "Client %@ set type to %s application", v10, v11);
      }
      objc_autoreleasePoolPop(v8);
      if (sub_100005830((uint64_t)v6) != a2)
      {
        v12 = sub_100016A7C((uint64_t)v6);
        if (v12)
        {
          v13 = v12;
          sub_100005740(v12, v6);
          sub_10006507C((uint64_t)v6, a2);
          sub_100005670(v13, v6);
        }
      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_client_type(mach_port_t, int)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v8);
    }
    CFRelease(v6);
  }
  return 0;
}

void sub_100006544(uint64_t a1)
{
  uint64_t v2;

  if (*(_QWORD *)(a1 + 144))
  {
    CFRetain((CFTypeRef)a1);
    v2 = *(_QWORD *)(a1 + 88);
    if (v2)
      sub_100031C74(v2, 0, 0);
    (*(void (**)(uint64_t, _QWORD))(a1 + 144))(a1, *(_QWORD *)(a1 + 152));
    CFRelease((CFTypeRef)a1);
  }
}

void sub_10000659C(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  void *v7;
  const __CFString *v8;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerAppStateManagerBundleIdCallback");
    goto LABEL_15;
  }
  v6 = *(unsigned __int8 *)(a1 + 2120);
  v7 = objc_autoreleasePoolPush();
  if (!v6)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: availabilty engine v2 is not enabed", "__WiFiManagerAppStateManagerBundleIdCallback");
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return;
  }
  if (qword_10026DD20)
  {
    if ((a3 - 1) > 7)
      v8 = CFSTR("Unknown");
    else
      v8 = off_100230D80[a3 - 1];
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bundleId: %@ state: %@", "__WiFiManagerAppStateManagerBundleIdCallback", a2, v8);
  }
  objc_autoreleasePoolPop(v7);
  if (a3 == 8)
    sub_100006B34((id *)a1);
}

void sub_1000066D8(uint64_t a1, const void *a2)
{
  const __CFDictionary *v4;

  v4 = (const __CFDictionary *)sub_100032330((uint64_t)a2);
  CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)sub_100093F00, 0);
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 160), a2);
  sub_1000094BC(a1, *(unsigned __int8 *)(a1 + 24));
}

uint64_t sub_100006724(unsigned int a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = sub_1000167F8();
  v3 = sub_10001674C(a1, v2);
  if (v3)
  {
    v4 = v3;
    sub_100006544((uint64_t)v3);
    CFRelease(v4);
  }
  return 0;
}

uint64_t sub_100006768(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;
  NDR_record_t v5;
  int v6;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    v6 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v6;
    v5 = NDR_record;
    goto LABEL_12;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68))
    || (v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 72)))
  {
    v6 = -300;
    goto LABEL_11;
  }
  result = sub_100014BF0(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_12:
  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

void sub_100006838(uint64_t a1, int a2, const __CFString *a3)
{
  uint64_t v6;
  unint64_t v7;
  void *v8;
  void *v9;
  void *v10;

  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 832);
    switch(a2)
    {
      case 1:
        v7 = v6 | 1;
        if (a3)
        {
          v8 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is in foreground.", "__WiFiManagerAppStateManagerCallback", a3);
          objc_autoreleasePoolPop(v8);
        }
        goto LABEL_14;
      case 2:
        if ((v6 & 1) != 0)
        {
          v9 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no more foreground app.", "__WiFiManagerAppStateManagerCallback");
          objc_autoreleasePoolPop(v9);
        }
        v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
        goto LABEL_14;
      case 4:
        v7 = v6 | 2;
        goto LABEL_14;
      case 8:
        v7 = v6 & 0xFFFFFFFFFFFFFFFDLL;
LABEL_14:
        *(_QWORD *)(a1 + 832) = v7;
        sub_100013B90(a1, v6);
        sub_100009B80(a1, a3, a2);
        break;
      default:
        return;
    }
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerAppStateManagerCallback");
    objc_autoreleasePoolPop(v10);
  }
}

void sub_1000069C0(uint64_t a1, const void *a2, int a3)
{
  void *v6;
  const void *v7;
  const void *v8;
  _QWORD context[4];

  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not allowed with Unified Auto-Join", "WiFiManagerSetRetryIntervals");
    objc_autoreleasePoolPop(v6);
  }
  else if (!a2 || (v7 = *(const void **)(a1 + 264)) == 0 || !CFEqual(a2, v7))
  {
    v8 = *(const void **)(a1 + 264);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 264) = 0;
    }
    if (a2)
    {
      *(_QWORD *)(a1 + 264) = CFRetain(a2);
      *(_DWORD *)(a1 + 272) = a3;
    }
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000001CLL;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_100006B20(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100006B34(id *a1)
{
  void *v2;
  void *v3;
  id *v4;
  unsigned int v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerStart3BarsFetchForCurrentLocation");
  if (a1)
  {
    v4 = sub_1000063A4(a1);
    v5 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v4, 0, 3600.0);
    v6 = objc_autoreleasePoolPush();
    if (v5)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: fetching networks for current location", "WiFiManagerStart3BarsFetchForCurrentLocation");
      objc_autoreleasePoolPop(v6);
      objc_msgSend(+[WiFi3BarsObserver sharedWiFi3BarsObserver](WiFi3BarsObserver, "sharedWiFi3BarsObserver"), "fetch3BarsNetworksForLocation:", v4);
      if (v4)
LABEL_6:
        CFRelease(v4);
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location not valid", "WiFiManagerStart3BarsFetchForCurrentLocation");
      objc_autoreleasePoolPop(v6);
      if (v4)
        goto LABEL_6;
    }
  }

  objc_autoreleasePoolPop(v2);
}

void sub_100006E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100006E28(void *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFUUID *v6;
  CFStringRef v7;

  v4 = sub_1000161D4((uint64_t)a1);
  NSLog(CFSTR("%s: Client %@ terminated, cleanup state"), "__WiFiServerClientTerminationCallback", v4);
  v5 = sub_100016A7C((uint64_t)a1);
  sub_10000A77C(v5, a1, 0, 2);
  sub_100005838(v5, a1, 0);
  sub_100031998(v5, (uint64_t)a1);
  if ((sub_100032338((uint64_t)a1) & 0x8000) != 0)
    sub_100093D9C(v5);
  v6 = (const __CFUUID *)sub_100032318((uint64_t)a1);
  v7 = CFUUIDCreateString(kCFAllocatorDefault, v6);
  sub_100031A7C(v5, (uint64_t)v7);
  sub_100005740(*(_QWORD *)(a2 + 16), a1);
  sub_100032310((uint64_t)a1, 0, 0);
  if (v7)
    CFRelease(v7);
  if (a1)
    CFRelease(a1);
}

void sub_100006F34(uint64_t a1, int a2)
{
  void *v4;
  void *v5;
  const __CFString *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if ((a2 - 1) > 6)
      v6 = CFSTR("none");
    else
      v6 = off_100231F50[a2 - 1];
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type=%@", "WiFiDeviceManagerReset", v6);
  }
  objc_autoreleasePoolPop(v5);
  v7 = 2;
  switch(a2)
  {
    case 1:
      sub_1000FC790(a1);
      v7 = 7;
      goto LABEL_8;
    case 3:
LABEL_8:
      objc_msgSend(*(id *)(a1 + 6648), "removeDenyListStateWithDenyListRemoveReason:", v7);
      if (objc_msgSend(*(id *)(a1 + 6648), "denyListedNetworkCount"))
        sub_1000FB44C(a1);
      if (objc_msgSend(*(id *)(a1 + 6936), "count"))
        objc_msgSend(*(id *)(a1 + 6936), "removeAllObjects");
      break;
    case 4:
      v8 = *(void **)(a1 + 6648);
      v9 = 5;
      goto LABEL_16;
    case 5:
      sub_1000FC790(a1);
      break;
    case 6:
      sub_1000FC790(a1);
      v8 = *(void **)(a1 + 6648);
      v9 = 3;
      goto LABEL_16;
    case 7:
      sub_1000FC790(a1);
      v8 = *(void **)(a1 + 6648);
      v9 = 4;
LABEL_16:
      objc_msgSend(v8, "removeDenyListStateWithDenyListRemoveReason:", v9);
      if (objc_msgSend(*(id *)(a1 + 6648), "denyListedNetworkCount"))
        sub_1000FB44C(a1);
      break;
    default:
      break;
  }
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_10000708C(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;
  const void *v14;
  uint64_t v15;

  *a4 = 0;
  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) != 0)
    {
      v12 = sub_10001D7D0(a2, a3);
      if (v12)
      {
        v13 = v12;
        v14 = sub_10001683C((uint64_t)v10, v12);
        if (v14)
        {
          v15 = (uint64_t)v14;
          if (sub_100016A7C((uint64_t)v10))
            *a4 = sub_100031FF4(v15);
        }
        CFRelease(v13);
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_get_power(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v10);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

BOOL sub_1000071A0(unsigned int *a1, uint64_t a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  const void *ValueAtIndex;
  uint64_t v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  const char *v13;

  v4 = sub_10000B29C((CFArrayRef)a1);
  v5 = v4;
  if (a2 && v4)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v4, 0);
    if (ValueAtIndex)
    {
      v7 = (uint64_t)ValueAtIndex;
      v8 = sub_100031FFC((uint64_t)ValueAtIndex, a2);
      if (v8)
      {
        v9 = sub_100005AF0(v7);
        if (a1[504] != (_DWORD)v9)
        {
          v10 = v9;
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFiMC : band support changed. Before : %d, after : %d", a1[504], v10);
          objc_autoreleasePoolPop(v11);
          a1[504] = v10;
          sub_10009322C(a1, CFSTR("WiFiCountryBandSupportKey"), v10, 1);
        }
      }
    }
    else
    {
      v8 = 0;
    }
    goto LABEL_12;
  }
  v8 = 0;
  if (v4)
LABEL_12:
    CFRelease(v5);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v13 = "succeeded";
    if (!v8)
      v13 = "failed";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: <%@> %s", "WiFiManagerGetLocale", a2, v13);
  }
  objc_autoreleasePoolPop(v12);
  return v8;
}

void sub_1000072F4(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  _WORD *v6;
  const void *v7;
  const __CFDate *v8;
  CFAbsoluteTime Current;
  const __CFDate *v10;
  const __CFDate *v11;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  double v16;
  const void *v17;
  IOPMAssertionID v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  v2 = (_BYTE *)(a1 + 5219);
  v3 = *(_QWORD *)(a1 + 64);
  v4 = (const void *)sub_100025C3C(v3);
  sub_1000672C0(v3, v4, 481, 0, 0);
  if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive")&& *(_BYTE *)(a1 + 3476))
  {
    sub_1000F6B44(a1);
  }
  if (*(_DWORD *)(a1 + 5424))
  {
    v5 = (const void *)sub_100068E60(*(_QWORD *)(a1 + 64));
    if (sub_10010A010(a1))
    {
      v6 = sub_10010FF88(a1, 1);
      if (v6)
      {
        v7 = v6;
        v8 = (const __CFDate *)sub_10002BE64((uint64_t)v6, CFSTR("lastJoined"));
        Current = CFAbsoluteTimeGetCurrent();
        v10 = CFDateCreate(kCFAllocatorDefault, Current);
        v11 = v10;
        if (v8 && v10)
        {
          if (CFDateGetTimeIntervalSinceDate(v10, v8) >= 20.0)
          {
            v12 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: remove AWDL network(Assisted Discovery) due to Timeout", "__WiFiDeviceManagerAssistedDiscoverySessionTimeout");
            objc_autoreleasePoolPop(v12);
            if (sub_10010FBD8(a1, v5, v7, 0, 0))
            {
              v13 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed remove AWDL network", "__WiFiDeviceManagerAssistedDiscoverySessionTimeout");
              objc_autoreleasePoolPop(v13);
            }
          }
        }
        else if (!v10)
        {
LABEL_18:
          CFRelease(v7);
          goto LABEL_19;
        }
        CFRelease(v11);
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v2[1677] && v2[1825])
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disconnect from Hotspot. LTE/5G Available!!", "WiFiDeviceManagerHeartbeatHadler");
    objc_autoreleasePoolPop(v14);
    v15 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    sub_1000F7F48(a1, v15, 1019, "WiFiDeviceManagerHeartbeatHadler", 30085);
  }
  if (objc_msgSend(*(id *)(a1 + 6752), "isClientAssociated"))
  {
    v16 = *(double *)(a1 + 6768);
    if (v16 != 0.0)
    {
      v16 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6768);
      if (v16 >= *(double *)(a1 + 6784))
      {
        *(double *)(a1 + 6488) = sub_100064914();
        *(_DWORD *)(a1 + 6544) = 3;
        v17 = *(const void **)(a1 + 6552);
        if (v17)
        {
          CFRelease(v17);
          *(_QWORD *)(a1 + 6552) = 0;
        }
        *(_QWORD *)(a1 + 6552) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("Off Head"));
        objc_msgSend(*(id *)(a1 + 6752), "stopSubscriberForPHSOverNAN");
        v16 = sub_10005C1E0((unsigned int *)(a1 + 6456));
      }
    }
  }
  if (v2[3846])
    objc_msgSend(*(id *)(a1 + 6648), "removeExpiredDenyListedState:", 3, v16);
  if (!*v2 && !*(_DWORD *)(a1 + 5344))
  {
    v18 = *(_DWORD *)(a1 + 5228);
    if (v18)
    {
      v19 = IOPMAssertionRelease(v18);
      if ((_DWORD)v19)
      {
        v20 = v19;
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s MIS session not active: release MIS PM Assertion, error=%d", "WiFiDeviceManagerHeartbeatHadler", v20);
        objc_autoreleasePoolPop(v21);
      }
      *(_DWORD *)(a1 + 5228) = 0;
    }
  }
}

const __SCPreferences *sub_100007620(const __SCPreferences *prefs)
{
  const __SCPreferences *v1;
  int v2;
  const char *v3;
  void *v4;
  const char *v5;

  if (prefs)
  {
    v1 = prefs;
    if (qword_10026D600)
      dispatch_assert_queue_V2((dispatch_queue_t)qword_10026D600);
    prefs = (const __SCPreferences *)SCPreferencesLock(v1, 1u);
    if (!(_DWORD)prefs)
    {
      SCPreferencesSynchronize(v1);
      prefs = (const __SCPreferences *)SCPreferencesLock(v1, 1u);
      if (!(_DWORD)prefs)
      {
        v2 = SCError();
        v3 = SCErrorString(v2);
        v4 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v5 = "SCError Unavailable";
          if (v3)
            v5 = v3;
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "SCPreferencesLock() %s", v5);
        }
        objc_autoreleasePoolPop(v4);
        return 0;
      }
    }
  }
  return prefs;
}

uint64_t sub_1000076D4(SCPreferencesRef prefs, int a2)
{
  int v4;
  const char *v5;
  void *v6;
  const char *v7;
  int v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  int v12;
  const char *v13;
  void *v14;
  const char *v15;

  if (qword_10026D600)
    dispatch_assert_queue_V2((dispatch_queue_t)qword_10026D600);
  if (a2)
  {
    if (SCPreferencesCommitChanges(prefs))
    {
      if (SCPreferencesApplyChanges(prefs))
        goto LABEL_15;
      v4 = SCError();
      v5 = SCErrorString(v4);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v7 = "SCError Unavailable";
        if (v5)
          v7 = v5;
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "SCPreferencesApplyChanges() %s", v7);
      }
    }
    else
    {
      v8 = SCError();
      v9 = SCErrorString(v8);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v10 = "SCError Unavailable";
        if (v9)
          v10 = v9;
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "SCPreferencesCommitChanges() %s", v10);
      }
    }
    objc_autoreleasePoolPop(v6);
  }
LABEL_15:
  v11 = SCPreferencesUnlock(prefs);
  if (!(_DWORD)v11)
  {
    v12 = SCError();
    v13 = SCErrorString(v12);
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v15 = "SCError Unavailable";
      if (v13)
        v15 = v13;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "SCPreferencesUnlock() %s", v15);
    }
    objc_autoreleasePoolPop(v14);
  }
  return v11;
}

uint64_t sub_100007828(uint64_t a1)
{
  uint64_t result;
  void *v3;

  if (a1)
  {
    result = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PublicAirPlayNetwork"));
    if ((_DWORD)result)
      return sub_10002BE64(a1, CFSTR("PublicAirPlayNetwork")) == kCFBooleanTrue;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsPublicAirPlayNetwork");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  return result;
}

const __CFArray *sub_1000078D0(uint64_t a1)
{
  const __CFArray *result;
  int v3;
  double v4;
  unsigned int v5;
  double v6;
  double v7;
  uint32_t v8;
  double v9;
  NSObject *v10;
  dispatch_time_t v11;
  void *v12;
  NSString *v13;
  double v14;
  double v15;
  uint32_t v16;
  double v17;
  NSObject *v18;
  dispatch_time_t v19;
  const char *v20;
  CFIndex Count;
  uint64_t v22;
  uint64_t v23;
  const __CFNumber *ValueAtIndex;
  void *v25;
  void *v26;
  double valuePtr;
  uint8_t buf[4];
  const char *v29;

  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not allowed with Unified Auto-Join", "__WiFiDeviceManagerScheduleNextRetry");
    objc_autoreleasePoolPop(v25);
    return 0;
  }
  result = *(const __CFArray **)(a1 + 320);
  if (!result)
    return result;
  valuePtr = NAN;
  v3 = *(_DWORD *)(a1 + 348);
  if (v3)
  {
    *(_DWORD *)(a1 + 348) = v3 - 1;
    if (v3 != 1)
    {
      valuePtr = 1.0;
      v4 = 1.0;
      goto LABEL_9;
    }
  }
  result = (const __CFArray *)CFArrayGetValueAtIndex(result, *(_QWORD *)(a1 + 328));
  if (!result)
    return result;
  CFNumberGetValue(result, kCFNumberDoubleType, &valuePtr);
  v4 = valuePtr;
  if (valuePtr <= 0.0)
    return 0;
  *(double *)(a1 + 336) = valuePtr;
LABEL_9:
  *(_DWORD *)(a1 + 5644) = *(_QWORD *)(a1 + 328);
  if (*(_DWORD *)(a1 + 3280) == 2)
  {
    v4 = v4 + 2.0;
    valuePtr = v4;
  }
  v5 = *(_DWORD *)(a1 + 344);
  if (v5)
  {
    if (v4 >= (double)v5)
      v4 = (double)v5;
    valuePtr = v4;
    v6 = v4 - v4 * 0.1;
    v7 = v4 + v4 * 0.1;
    v8 = arc4random();
    v9 = v6 + (double)(v8 + ((v8 / 0x7FFFFFFF) | ((v8 / 0x7FFFFFFF) << 31))) / 2147483650.0 * (v7 - v6);
    v10 = *(NSObject **)(a1 + 312);
    v11 = dispatch_time(0, (uint64_t)(v9 * 1000000000.0));
    dispatch_source_set_timer(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0);
    v12 = objc_autoreleasePoolPush();
    if (!qword_10026DD20)
      goto LABEL_20;
    v13 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: Performing next automatic assocation in %.3f(%.3f) seconds, retry cap=%d"), "__WiFiDeviceManagerScheduleNextRetry", *(_QWORD *)&v9, *(_QWORD *)&valuePtr, *(unsigned int *)(a1 + 344))), "UTF8String"));
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
  }
  else
  {
    v14 = v4 - v4 * 0.1;
    v15 = v4 + v4 * 0.1;
    v16 = arc4random();
    v17 = v14 + (double)(v16 + ((v16 / 0x7FFFFFFF) | ((v16 / 0x7FFFFFFF) << 31))) / 2147483650.0 * (v15 - v14);
    v18 = *(NSObject **)(a1 + 312);
    v19 = dispatch_time(0, (uint64_t)(v17 * 1000000000.0));
    dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0);
    v12 = objc_autoreleasePoolPush();
    if (!qword_10026DD20)
      goto LABEL_20;
    v13 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: Performing next automatic assocation in %.3f(%.3f) seconds"), "__WiFiDeviceManagerScheduleNextRetry", *(_QWORD *)&v17, *(_QWORD *)&valuePtr)), "UTF8String"));
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
  }
  v20 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v13, "UTF8String")), "UTF8String");
  *(_DWORD *)buf = 136446210;
  v29 = v20;
  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
LABEL_20:
  objc_autoreleasePoolPop(v12);
  *(_DWORD *)(a1 + 5640) = valuePtr;
  if (*(_BYTE *)(a1 + 24) && sub_100069F0C(*(_QWORD *)(a1 + 64)) && !*(_DWORD *)(a1 + 28))
    *(_DWORD *)(a1 + 28) = 1;
  if (v3)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: in quick autojoin retry, %d more remaining.", "__WiFiDeviceManagerScheduleNextRetry", *(unsigned int *)(a1 + 348));
    objc_autoreleasePoolPop(v26);
  }
  else
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 320));
    v22 = *(_QWORD *)(a1 + 328);
    v23 = v22 + 1;
    if (v22 + 1 < Count)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), v22 + 1);
      if (ValueAtIndex)
      {
        CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
        if (valuePtr > 0.0)
          *(_QWORD *)(a1 + 328) = v23;
      }
    }
  }
  return (const __CFArray *)1;
}

BOOL sub_100007DCC(const void *a1)
{
  const void *v1;
  const void *v2;

  v1 = sub_10002B088(a1);
  if (v1 && (v2 = v1, !CFEqual(v1, &stru_100238178)))
    return CFEqual(v2, CFSTR(" ")) != 0;
  else
    return 1;
}

uint64_t sub_100007E20(uint64_t a1)
{
  const __CFNumber *v2;
  _BOOL4 v3;
  _BOOL4 v4;
  int v5;
  _BOOL4 v6;
  _BOOL4 v7;
  unsigned int valuePtr;

  valuePtr = 3;
  v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("ShareMode"));
  if (v2)
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
  v3 = a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PayloadUUID"));
  v4 = sub_10002DAB4(a1);
  v5 = sub_10003145C(a1);
  if (a1)
  {
    v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("WEP")) == kCFBooleanTrue;
    v7 = sub_10002CFA8(*(const __CFDictionary **)(a1 + 16)) == 0;
  }
  else
  {
    v6 = 0;
    v7 = 1;
  }
  if (v5)
    v7 = 0;
  if (v4)
    v7 = 1;
  if (v3 || v6 || v7)
    return 1;
  else
    return valuePtr;
}

BOOL sub_100007F24(uint64_t a1)
{
  const void *Value;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("enabled"));
  return !Value || CFEqual(Value, kCFBooleanFalse) == 0;
}

void sub_100007F68(uint64_t a1, uint64_t a2)
{
  int v3;
  _QWORD context[4];
  uint64_t v5;

  v5 = a2;
  v3 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (a1)
  {
    if (v3)
    {
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000079;
      context[2] = &v5;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
}

uint64_t sub_100007FDC(uint64_t a1, int a2, int a3, int a4)
{
  void *v8;
  const __CFArray *v9;
  CFIndex Count;
  double Current;
  double v12;
  void *v13;
  uint64_t v14;
  __CFArray *v15;
  __CFArray *v16;
  void *v17;
  const char *v18;
  const void *v19;
  void *v20;
  uint64_t v22;
  uint64_t v23;

  v8 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerFlushKnownNetworksCache", v22, v23);
    goto LABEL_9;
  }
  if (sub_1000304D4((_QWORD *)a1))
    goto LABEL_10;
  if (!*(_BYTE *)(a1 + 1328))
    goto LABEL_10;
  v9 = *(const __CFArray **)(a1 + 224);
  if (!v9)
    goto LABEL_10;
  Count = CFArrayGetCount(v9);
  Current = CFAbsoluteTimeGetCurrent();
  if (!a3)
  {
    v12 = Current - *(double *)(a1 + 232);
    if (v12 < 30.0)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Skip this flush attempt, flush %d seconds later, networks were fetched from the plist just %f seconds ago", "WiFiManagerFlushKnownNetworksCache", 30, *(_QWORD *)&v12);
LABEL_9:
      objc_autoreleasePoolPop(v13);
LABEL_10:
      v14 = 0;
      goto LABEL_23;
    }
  }
  v15 = sub_1000172FC(*(const __CFArray **)(a1 + 224), a2);
  if (!v15)
    goto LABEL_10;
  v16 = v15;
  v14 = sub_100087488((_QWORD *)a1, CFSTR("List of known networks"), v15, a4);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v18 = "Successfully flushed";
    if (!(_DWORD)v14)
      v18 = "Failed to flush";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s %ld known networks to the plist", "WiFiManagerFlushKnownNetworksCache", v18, Count);
  }
  objc_autoreleasePoolPop(v17);
  if (!Count)
  {
    v19 = *(const void **)(a1 + 224);
    if (v19)
    {
      CFRelease(v19);
      *(_QWORD *)(a1 + 224) = 0;
    }
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Cleared known networks cache", "WiFiManagerFlushKnownNetworksCache");
    objc_autoreleasePoolPop(v20);
  }
  CFRelease(v16);
LABEL_23:
  objc_autoreleasePoolPop(v8);
  return v14;
}

BOOL sub_1000081D8(uint64_t a1)
{
  void *v3;

  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("PrivacyProxyEnabled")))
      return sub_10002BE64(a1, CFSTR("PrivacyProxyEnabled")) == kCFBooleanTrue;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetPrivacyProxyEnabled");
    objc_autoreleasePoolPop(v3);
  }
  return 1;
}

const __CFNumber *sub_100008280(uint64_t a1)
{
  const __CFNumber *result;
  unsigned int valuePtr;

  valuePtr = 0;
  result = (const __CFNumber *)sub_10002BE64(a1, CFSTR("SaveDataMode"));
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

void sub_1000082C0(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  void (*v6)(uint64_t, uint64_t, _QWORD, CFDictionaryRef);
  const __CFDictionary *Value;
  const __CFNumber *v8;
  const __CFNumber *v9;
  int v10;
  char v11;
  int valuePtr;

  if (a3)
  {
    v6 = *(void (**)(uint64_t, uint64_t, _QWORD, CFDictionaryRef))(a3 + 4296);
    if (v6)
      v6(a3, a2, *(_QWORD *)(a3 + 4304), theDict);
    sub_10000E198(*(_QWORD *)(a3 + 120), theDict);
    Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("QUAL_SCORE"));
    if (Value)
    {
      valuePtr = 0;
      v8 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("LINK_RECOMMENDATION_FLAGS"));
      if (v8)
      {
        CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
        v11 = 0;
        v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RT_TRAFFIC_STATE"));
        if (v9)
        {
          CFNumberGetValue(v9, kCFNumberSInt8Type, &v11);
          *(_BYTE *)(a3 + 3477) = v11 & 3;
          if (_os_feature_enabled_impl("WiFiManager", "RealTimeRoamSuppression"))
          {
            v10 = *(unsigned __int8 *)(a3 + 7042);
            if (*(_BYTE *)(a3 + 7042))
            {
              if (-[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress")|| (v10 = *(unsigned __int8 *)(a3 + 3477), *(_BYTE *)(a3 + 3477)))
              {
                v10 = (*(_DWORD *)(a3 + 3468) & 1) == 0;
              }
            }
          }
          else
          {
            v10 = 0;
          }
          if (valuePtr != *(_DWORD *)(a3 + 3468) || v10 != *(unsigned __int8 *)(a3 + 3476))
          {
            *(_DWORD *)(a3 + 3468) = valuePtr;
            sub_1000F6B44(a3);
          }
        }
      }
    }
  }
}

uint64_t sub_1000083F0(uint64_t a1)
{
  __int128 v2;
  __SecTask *v3;
  __SecTask *v4;
  CFTypeRef v5;
  const void *v6;
  CFTypeID TypeID;
  uint64_t v8;
  void *v10;
  audit_token_t token;
  CFErrorRef error;

  error = 0;
  v2 = *(_OWORD *)(a1 + 36);
  *(_OWORD *)token.val = *(_OWORD *)(a1 + 20);
  *(_OWORD *)&token.val[4] = v2;
  v3 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &token);
  v4 = v3;
  if (!v3)
  {
LABEL_17:
    v8 = 0;
    v6 = 0;
    goto LABEL_6;
  }
  v5 = SecTaskCopyValueForEntitlement(v3, CFSTR("com.apple.wifi.manager-access"), &error);
  if (!v5)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Client \"%@\" has no entitlement", *(_QWORD *)(a1 + 64));
    objc_autoreleasePoolPop(v10);
    goto LABEL_17;
  }
  v6 = v5;
  TypeID = CFBooleanGetTypeID();
  if (TypeID == CFGetTypeID(v6) && CFEqual(v6, kCFBooleanTrue))
  {
    v8 = 1;
    *(_DWORD *)(a1 + 136) = 1;
  }
  else
  {
    v8 = 0;
  }
LABEL_6:
  if (error)
  {
    CFRelease(error);
    error = 0;
  }
  if (v6)
    CFRelease(v6);
  if (v4)
    CFRelease(v4);
  return v8;
}

CFDictionaryRef sub_100008514(uint64_t a1, const void *a2, const __CFString *a3)
{
  const void *v6;
  const void *v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  int i;
  int v12;
  CFTypeID v15;
  void (*v16)(uint64_t, _QWORD, _QWORD, void **);
  void (*v17)(uint64_t, _QWORD, _QWORD, CFTypeRef *);
  const void *v18;
  const void *CFProperty;
  CFTypeID v20;
  void *v21;
  const __CFAllocator *v22;
  const __CFDictionary *v23;
  CFDictionaryRef Copy;
  CFTypeID v25;
  void *v26;
  CFTypeID v27;
  int InfoCopy;
  BOOL v29;
  int j;
  const void *v32;
  CFTypeID v33;
  void *v34;
  void *v35;
  const void *v37;
  const void *v38;
  const __CFNumber *v39;
  const __CFNumber *v40;
  void *v41;
  CFTypeRef valuePtr;
  CFTypeRef cf;
  int v44;
  float v45;
  CFTypeRef v46[3];
  void *value;
  CFTypeRef v48;

  cf = 0;
  v6 = sub_10002DEA0(a1, a2);
  if (!v6)
  {
    v41 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    v35 = v41;
LABEL_84:
    objc_autoreleasePoolPop(v35);
    return (CFDictionaryRef)cf;
  }
  v7 = v6;
  v8 = CFGetTypeID(a3);
  if (v8 == CFNumberGetTypeID())
  {
    LODWORD(valuePtr) = 0;
    if (CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &valuePtr))
    {
      v9 = CFGetTypeID(v7);
      if (v9 == sub_10002DE64())
      {
        sub_10015CE30(v7, valuePtr, 0, &cf);
      }
      else
      {
        for (i = 6; ; --i)
        {
          v12 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), valuePtr, 0, &cf);
          if (v12 != -3905 && v12 != 61 && v12 != 16)
            break;
          if (!i)
            break;
          usleep(0x7A120u);
        }
        if ((_DWORD)valuePtr == 115 && cf != 0)
        {
          v15 = CFGetTypeID(cf);
          if (v15 == CFDictionaryGetTypeID())
          {
            v16 = *(void (**)(uint64_t, _QWORD, _QWORD, void **))(a1 + 5224);
            if (v16)
            {
              value = (void *)0xAAAAAAAAAAAAAAAALL;
              v16(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 5232), &value);
              if (value)
              {
                CFDictionaryAddValue((CFMutableDictionaryRef)cf, CFSTR("AutoJoinPowerDiag"), value);
                if (value)
                {
                  CFRelease(value);
                  value = 0;
                }
              }
              v17 = *(void (**)(uint64_t, _QWORD, _QWORD, CFTypeRef *))(a1 + 5240);
              if (v17)
              {
                v46[0] = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
                v17(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 5248), v46);
                if (v46[0])
                {
                  CFDictionaryAddValue((CFMutableDictionaryRef)cf, CFSTR("AutoHotspotLPHSPowerStats"), v46[0]);
                  if (v46[0])
                    CFRelease(v46[0]);
                }
              }
            }
          }
        }
      }
    }
    return (CFDictionaryRef)cf;
  }
  v10 = CFGetTypeID(a3);
  if (v10 != CFStringGetTypeID())
    return (CFDictionaryRef)cf;
  if (a3 && CFEqual(a3, CFSTR("LastRangingSessionMetric")))
    return (CFDictionaryRef)objc_msgSend(-[WiFiUsageMonitor lastRangingSessionMetric](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "lastRangingSessionMetric"), "copy");
  v18 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), a3);
  cf = v18;
  if (v18)
  {
    CFProperty = v18;
    CFRetain(v18);
    if (!a3)
      return (CFDictionaryRef)cf;
    v20 = CFGetTypeID(a3);
    if (v20 == CFStringGetTypeID() && CFEqual(a3, CFSTR("IO80211InterfaceWoWWakeUpParams")))
    {
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Querying %@ on %@ from device->properties returned %@", "WiFiDeviceCopyProperty", a3, a2, CFProperty);
      objc_autoreleasePoolPop(v21);
    }
    goto LABEL_79;
  }
  v45 = NAN;
  *(_OWORD *)v46 = *(_OWORD *)&off_10022F7B8;
  if (CFEqual(a3, CFSTR("RSSI")))
  {
    v44 = *(_DWORD *)(a1 + 264);
    v22 = kCFAllocatorDefault;
    value = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v44);
    v48 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v45);
    v23 = CFDictionaryCreate(kCFAllocatorDefault, v46, (const void **)&value, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v23);
    if (value)
    {
      CFRelease(value);
      value = 0;
    }
    if (v48)
    {
      CFRelease(v48);
      v48 = 0;
    }
    if (v23)
      CFRelease(v23);
  }
  else
  {
    if (!CFEqual(a3, CFSTR("ScaledRSSI")) && !CFEqual(a3, CFSTR("Strength")))
    {
      cf = 0;
      v22 = kCFAllocatorDefault;
LABEL_50:
      CFProperty = IORegistryEntryCreateCFProperty(*(_DWORD *)(a1 + 24), a3, v22, 0);
      cf = CFProperty;
      if (!CFProperty)
      {
        if (a3)
        {
          v25 = CFGetTypeID(a3);
          if (v25 == CFStringGetTypeID())
          {
            if (CFEqual(a3, CFSTR("IO80211InterfaceWoWWakeUpParams")))
            {
              v26 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Querying %@ on %@ from IORegistryEntryCreateCFProperty returned NULL", "WiFiDeviceCopyProperty", a3, a2);
              objc_autoreleasePoolPop(v26);
            }
          }
        }
        value = 0;
        v27 = CFGetTypeID(v7);
        if (v27 == sub_10002DE64())
        {
          InfoCopy = sub_10015CF28((uint64_t)v7);
        }
        else
        {
          for (j = 6; ; --j)
          {
            InfoCopy = Apple80211GetInfoCopy(*(_QWORD *)(a1 + 16), &value);
            if (InfoCopy != -3905 && InfoCopy != 61 && InfoCopy != 16)
              break;
            if (!j)
              break;
            usleep(0x7A120u);
          }
        }
        if (InfoCopy)
          v29 = 1;
        else
          v29 = value == 0;
        if (v29)
        {
          CFProperty = 0;
        }
        else
        {
          v32 = CFDictionaryGetValue((CFDictionaryRef)value, a3);
          cf = v32;
          if (v32)
          {
            CFProperty = v32;
            CFRetain(v32);
          }
          else if (CFEqual(a3, CFSTR("ScaledRate")))
          {
            v37 = sub_10002BF8C(a1, a2);
            v46[0] = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
            valuePtr = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
            v45 = 1.0;
            if (v37)
            {
              v38 = v37;
              sub_1000C4250((uint64_t)v37, &valuePtr, v46);
              if (valuePtr != v46[0])
              {
                v39 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)value, CFSTR("RATE"));
                v40 = sub_10001F500(v39);
                v45 = sub_100064810((uint64_t)v40, (uint64_t)valuePtr, (uint64_t)v46[0]);
              }
              CFProperty = CFNumberCreate(v22, kCFNumberFloatType, &v45);
              cf = CFProperty;
              CFRelease(v38);
            }
            else
            {
              CFProperty = CFNumberCreate(v22, kCFNumberFloatType, &v45);
              cf = CFProperty;
            }
          }
          else
          {
            CFProperty = 0;
          }
          if (value)
            CFRelease(value);
        }
      }
      if (!a3)
        return (CFDictionaryRef)cf;
LABEL_79:
      v33 = CFGetTypeID(a3);
      if (v33 != CFStringGetTypeID() || !CFEqual(a3, CFSTR("IO80211InterfaceWoWWakeUpParams")))
        return (CFDictionaryRef)cf;
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Querying %@ on %@ received %@", "WiFiDeviceCopyProperty", a3, a2, CFProperty);
      v35 = v34;
      goto LABEL_84;
    }
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 268);
    v22 = kCFAllocatorDefault;
    Copy = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloatType, &valuePtr);
  }
  cf = Copy;
  if (!Copy)
    goto LABEL_50;
  return Copy;
}

void sub_100008BCC(int a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v4;
  NSUserDefaults *v5;
  void *v6;

  if (theDict)
  {
    Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("countryCodeUserDefault"));
    if (Value)
    {
      v4 = Value;
      if (CFStringCompare(Value, CFSTR("XZ"), 0)
        && CFStringCompare(v4, &stru_100238178, 0)
        && CFStringCompare(v4, CFSTR("X0"), 0)
        && CFStringCompare(v4, CFSTR("X2"), 0)
        && CFStringCompare(v4, CFSTR("X3"), 0))
      {
        v5 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
        if (v5)
          -[NSUserDefaults setObject:forKey:](v5, "setObject:forKey:", theDict, CFSTR("countryCodeUserDefaultData"));
      }
      else
      {
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " Skipping saving country code [%@] to user defaults", v4);
        objc_autoreleasePoolPop(v6);
      }
    }
  }
}

uint64_t sub_100008CEC(uint64_t a1)
{
  const __CFNumber *v1;
  void *v3;
  unsigned __int16 valuePtr;

  valuePtr = 0;
  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetChannelWidthInMHz");
    goto LABEL_9;
  }
  v1 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("CHANNEL_WIDTH"));
  if (!v1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null APPLE80211KEY_CHANNEL_WIDTH", "WiFiNetworkGetChannelWidthInMHz");
LABEL_9:
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  CFNumberGetValue(v1, kCFNumberSInt16Type, &valuePtr);
  return valuePtr;
}

uint64_t sub_100008DA8(uint64_t a1)
{
  int v2;
  int v3;
  _BOOL8 v4;
  _BOOL8 v5;
  _BOOL4 v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  void *v11;

  v2 = _os_feature_enabled_impl("WiFiManager", "LinkRecommendationTD");
  if (!a1
    || (v3 = v2, (_os_feature_enabled_impl("WiFiManager", "RealTimeFastTD") & 1) == 0)
    && !_os_feature_enabled_impl("WiFiManager", "LinkRecommendationTD")
    || sub_10000BE8C(*(_QWORD *)(a1 + 48))
    || sub_10001395C(*(_QWORD *)(a1 + 48))
    || *(_DWORD *)(a1 + 2796) >= *(_DWORD *)(a1 + 648))
  {
    v4 = 0;
    v8 = 0;
    v5 = 0;
    goto LABEL_28;
  }
  v4 = -[WiFiUserInteractionMonitor isCarModeActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCarModeActive")|| (*(_DWORD *)(a1 + 2776) & 0xFFFFFFFD) == 4;
  if (sub_1000CF9B0(*(CFDictionaryRef **)(a1 + 48)))
    v5 = *(_DWORD *)(a1 + 2776) == 2;
  else
    v5 = 0;
  if (-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))
  {
    v6 = 1;
    if (!v3)
    {
LABEL_15:
      v7 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v6 = *(_BYTE *)(a1 + 2952) != 0;
    if (!v3)
      goto LABEL_15;
  }
  v7 = (*(unsigned __int8 *)(a1 + 2948) >> 1) & 1;
LABEL_18:
  if (v6)
    v8 = v7;
  else
    v8 = 0;
  if (*(_BYTE *)(a1 + 248))
  {
    if (*(_DWORD *)(a1 + 56))
      v9 = 1;
    else
      v9 = v8;
    if (*(_DWORD *)(a1 + 2776) == 2)
      v8 = 1;
    else
      v8 = v9;
  }
LABEL_28:
  if ((_DWORD)v8)
    v10 = 1;
  else
    v10 = v4 | v5;
  if ((_DWORD)v10 == 1)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: inHighMobility:%d isUsingPublicNetwork:%d tdMonitoringRequired:%d", "__WiFiLQAMgrIsUnderEvaluationForFastDisconnect", v4, v5, v8);
    objc_autoreleasePoolPop(v11);
  }
  return v10;
}

void sub_100008F98(uint64_t a1)
{
  CFAbsoluteTime Current;
  CFDateRef v3;
  __CFDictionary *Mutable;
  void *v5;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(kCFAllocatorDefault, Current);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(Mutable, CFSTR("countryCodeUserDefault"), *(const void **)(a1 + 32));
  CFDictionarySetValue(Mutable, CFSTR("countryCodeUserDefaultDate"), v3);
  sub_100008BCC(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), Mutable);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Saving Country Code information to user defaults : [%@]", "-[WiFiLocaleManagerUser setUserDefaultCountryCode:]_block_invoke", *(_QWORD *)(a1 + 32));
  objc_autoreleasePoolPop(v5);
  if (v3)
    CFRelease(v3);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_10000909C(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "wifiSoftErrorEventHandler:eventType:eventData:", *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 48));

}

uint64_t sub_1000090DC(uint64_t a1, const void *a2)
{
  const void *v4;
  CFTypeID v5;
  void *v6;
  uint64_t v7;
  int i;
  uint64_t v9;
  void *v11;
  uint64_t v13;

  v13 = 0;
  v4 = sub_10002DEA0(a1, a2);
  if (!v4)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "WiFiDeviceCopyLQMSummary", a2);
    goto LABEL_19;
  }
  v5 = CFGetTypeID(v4);
  if (v5 == sub_10002DE64())
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: not supported on virtual interface %@", "WiFiDeviceCopyLQMSummary", a2);
    objc_autoreleasePoolPop(v6);
    v7 = 4294963393;
LABEL_17:
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: returned error %d", "WiFiDeviceCopyLQMSummary", v7);
LABEL_19:
    objc_autoreleasePoolPop(v11);
    return v13;
  }
  for (i = 6; ; --i)
  {
    v9 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 386, 0, &v13);
    v7 = v9;
    if ((int)v9 <= 15)
    {
      if ((_DWORD)v9 != -3905)
        break;
    }
    else if ((_DWORD)v9 != 61 && (_DWORD)v9 != 16)
    {
      goto LABEL_17;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if ((_DWORD)v9)
    goto LABEL_17;
  return v13;
}

BOOL sub_100009230(_QWORD *a1, double *a2)
{
  void *v4;
  _BOOL8 v5;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    v5 = sub_10003036C(a1, CFSTR("DisableSoftErrorReporting"), 0);
    if (a2)
      *a2 = (double)sub_100030300(a1, CFSTR("SoftErrorReportingTimeout"), 0);
  }
  else
  {
    v5 = 0;
  }
  objc_autoreleasePoolPop(v4);
  return v5;
}

BOOL sub_1000092B8(uint64_t a1)
{
  _BOOL8 v2;
  void *v3;
  const char *v4;
  void *v6;
  _QWORD context[3];
  uint64_t v8;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiManagerIsAlwaysOnWiFiEnabled");
    goto LABEL_16;
  }
  if (!sub_10000AF8C(a1))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto-join disabled.", "WiFiManagerIsAlwaysOnWiFiEnabled");
LABEL_16:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000048;
  context[2] = 0;
  v8 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  if ((_BYTE)v8)
    v2 = sub_10009F818(a1) == 0;
  else
    v2 = 0;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = "Disabled";
    if (v2)
      v4 = "Enabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AlwaysOnWiFi: %s", v4);
  }
  objc_autoreleasePoolPop(v3);
  return v2;
}

void sub_1000093F8(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  CFIndex Count;
  void *v8;
  _QWORD context[2];
  CFTypeRef cf;
  CFIndex v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a3)
  {
    if (a4)
    {
      v12 = 0xAAAAAAAAAAAAAA01;
      context[0] = a3;
      context[1] = a1;
      cf = sub_100029868(kCFAllocatorDefault, a4);
      Count = CFSetGetCount(*(CFSetRef *)(a3 + 136));
      v13 = 0;
      v14 = 0;
      v11 = Count;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000159A4, context);
      if (cf)
        CFRelease(cf);
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendWiFiAssistEventWithInterfaceName:linkQualityMetricInfo:", a2, a4);
    }
    v8 = *(void **)(a3 + 1728);
    if (v8)
      sub_10000E880((void *)a3, v8, 12, a4);
  }
}

void sub_1000094BC(uint64_t a1, int a2)
{
  _BOOL4 v4;
  _BOOL4 v5;
  int v6;
  void *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v4 = sub_1000092B8(a1);
  if (*(_DWORD *)(a1 + 788) == 2)
  {
    v5 = v4;
    v6 = a2 && *(_BYTE *)(a1 + 25) && *(_BYTE *)(a1 + 1328) && (*(_BYTE *)(a1 + 832) & 0x3F | v4) != 0;
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v8 = "TRUE";
      if (a2)
        v9 = "TRUE";
      else
        v9 = "FALSE";
      if (*(_BYTE *)(a1 + 25))
        v10 = "TRUE";
      else
        v10 = "FALSE";
      if (*(_BYTE *)(a1 + 1328))
        v11 = "TRUE";
      else
        v11 = "FALSE";
      v12 = *(_QWORD *)(a1 + 832);
      if ((v12 & 4) != 0)
        v13 = "TRUE";
      else
        v13 = "FALSE";
      if ((v12 & 0x3B) == 0)
        v8 = "FALSE";
      v14 = "Enabled";
      if (!v5)
        v14 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %s, manager->enable.setting %s, manager->unlockedSinceBoot %s, SB state %s, Process state %s AlwaysOnWiFi %s manager app state %llu", "__WiFiManagerSetEnableState", v9, v10, v11, v13, v8, v14, v12);
    }
  }
  else
  {
    v6 = a2 && *(_BYTE *)(a1 + 25) && *(_BYTE *)(a1 + 1328) != 0;
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v15 = "TRUE";
      if (a2)
        v16 = "TRUE";
      else
        v16 = "FALSE";
      if (*(_BYTE *)(a1 + 25))
        v17 = "TRUE";
      else
        v17 = "FALSE";
      if (!*(_BYTE *)(a1 + 1328))
        v15 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %s, manager->enable.setting %s, manager->unlockedSinceBoot %s", "__WiFiManagerSetEnableState", v16, v17, v15, v18, v19, v20, v21);
    }
  }
  objc_autoreleasePoolPop(v7);
  *(_BYTE *)(a1 + 24) = v6;
  sub_1000300E0(a1, v6, 0);
}

uint64_t sub_100009674(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = sub_1000096D4(*(_DWORD *)(result + 12), *(_QWORD *)(result + 32));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t sub_1000096D4(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  void *v7;

  v4 = sub_1000167F8();
  v5 = sub_10001674C(a1, v4);
  if (v5)
  {
    v6 = v5;
    if ((sub_100016834((uint64_t)v5) & 1) != 0)
    {
      sub_100009788((uint64_t)v6, a2);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_event_mask(mach_port_t, uint64_t)", sub_1000161D4((uint64_t)v6));
      objc_autoreleasePoolPop(v7);
    }
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_100009788(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 128) = a2;
  return result;
}

void sub_100009790(_QWORD *a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE v13[128];

  v2 = objc_autoreleasePoolPush();
  if (a1[4])
  {
    v3 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v4 = objc_msgSend(*(id *)(a1[5] + 48), "allKeys", 0);
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v10;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v10 != v7)
            objc_enumerationMutation(v4);
          objc_msgSend(v3, "setObject:forKeyedSubscript:", objc_msgSend(objc_msgSend(*(id *)(a1[5] + 48), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * (_QWORD)v8)), "objectForKeyedSubscript:", a1[4]), *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * (_QWORD)v8));
          v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
      }
      while (v6);
    }
    if (objc_msgSend(v3, "count"))
      *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40) = objc_msgSend(v3, "copy");
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000098F8(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a1 && a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 8))
  {
    sub_10002E0C8(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "__WiFiManagerDispatchCatsUcmUpdateEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_100009AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100009ACC(uint64_t a1)
{
  void *v2;
  void *v3;
  unsigned int v4;
  id v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_autoreleasePoolPush();
  v4 = objc_msgSend(*(id *)(a1 + 5600), "isAuthorized");
  objc_autoreleasePoolPop(v3);
  if (v4)
  {
    v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 5600), "latestLocation"), "copy");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not authorized to use location", "WiFiDeviceManagerCopyLeechedLocation");
    objc_autoreleasePoolPop(v6);
    v5 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v5;
}

void sub_100009B80(uint64_t a1, const __CFString *a2, int a3)
{
  void *v5;
  char v6;
  CFIndex length;
  CFIndex v8;
  CFIndex v9;
  BOOL v10;
  void *v11;

  if ((a3 == 4 || a3 == 1)
    && -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))
  {
    if (a2)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Currently Running Critical Apps %@", a2);
      objc_autoreleasePoolPop(v5);
    }
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  length = CFStringFind(a2, CFSTR("icloud.restore"), 1uLL).length;
  v8 = CFStringFind(a2, CFSTR("mobile.backup"), 1uLL).length;
  v9 = CFStringFind(a2, CFSTR("nfa"), 1uLL).length;
  v10 = (CFStringFind(a2, CFSTR("druva"), 1uLL).length | v9 | v8 | length) == 0;
  if (a2 && !v10)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Currently Running NonCritical Apps %@", a2);
    objc_autoreleasePoolPop(v11);
  }
  *(_BYTE *)(a1 + 2274) = v6;
  *(_BYTE *)(a1 + 2275) = !v10;
  sub_100031750(a1);
}

CFArrayRef sub_100009CDC(CFArrayRef result)
{
  CFArrayRef v1;
  CFIndex v2;
  size_t v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v1 = result;
    result = (CFArrayRef)*((_QWORD *)result + 12);
    if (result)
    {
      result = (CFArrayRef)CFSetGetCount(result);
      if (result)
      {
        v2 = (CFIndex)result;
        __chkstk_darwin();
        v4 = (char *)&v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
        memset(v4, 170, v3);
        CFSetGetValues(*((CFSetRef *)v1 + 12), (const void **)v4);
        return CFArrayCreate(kCFAllocatorDefault, (const void **)v4, v2, &kCFTypeArrayCallBacks);
      }
    }
  }
  return result;
}

uint64_t sub_100009DB4(uint64_t a1)
{
  notify_set_state(dword_10026DC90, *(_QWORD *)(a1 + 32));
  return notify_post("com.apple.airport.userNotification");
}

void sub_100009DE0(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  CFMutableArrayRef *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  int valuePtr;

  v2 = objc_autoreleasePoolPush();
  v3 = (void *)a1[4];
  if ((a1[5] & 0xFFFFFFFFFFFFFFFELL) == 0x36 && v3)
  {
    if (objc_msgSend(v3, "code") == (id)37)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID transition arbitrator is running, ignore duplicated steering request", "WiFiDeviceManagerStartAutoJoinAndReply_block_invoke_2");
      objc_autoreleasePoolPop(v4);
    }
    else
    {
      valuePtr = 4;
      v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      v7 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a1[6] + 3852));
      sub_100117EC0(a1[6], CFSTR("FF:FF:FF:FF:FF:FF"), 0, 0, v6, v7);
      if (v6)
        CFRelease(v6);
      if (v7)
        CFRelease(v7);
    }
  }
  else
  {
    sub_10000D074(a1[6], (int)objc_msgSend(v3, "code"));
  }
  objc_msgSend(*(id *)(a1[6] + 3656), "setScanResultsWithAutoJoinSessionCompletion:complete:", *(_QWORD *)(a1[6] + 1104), 1);
  v5 = (CFMutableArrayRef *)a1[6];
  if (v5[138])
  {
    CFArrayRemoveAllValues(v5[138]);
    v5 = (CFMutableArrayRef *)a1[6];
  }
  CFRelease(v5);
  objc_autoreleasePoolPop(v2);
}

void sub_100009F30(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[6];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 104);
  if (v3)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_10002FB70;
    v4[3] = &unk_10022EB70;
    v4[4] = v2;
    v4[5] = a2;
    dispatch_async(v3, v4);
  }
}

void sub_10000A1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000A1EC(uint64_t a1, io_registry_entry_t a2, int a3)
{
  void *v6;
  int v7;
  double Current;
  double v9;
  uint64_t CFProperties;
  BOOL v12;
  const __CFNumber *Value;
  const __CFNumber *v14;
  int v15;
  void *v16;
  unsigned int v17;
  unsigned int v18;
  void *v19;
  CFTypeRef CFProperty;
  const void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t valuePtr;
  CFMutableDictionaryRef properties[4];

  if (!a1 || !a2)
    return;
  v6 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerBatteryEventCallback");
  v7 = *(unsigned __int8 *)(a1 + 314);
  valuePtr = 0;
  properties[0] = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v9 = *(double *)(a1 + 992);
  if (v9 != 0.0 && Current < v9)
    goto LABEL_32;
  CFProperties = IORegistryEntryCreateCFProperties(a2, properties, kCFAllocatorDefault, 0);
  if ((_DWORD)CFProperties)
    v12 = 1;
  else
    v12 = properties[0] == 0;
  if (v12)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IORegistryEntryCreateCFProperties failed with error %d", "__WiFiManagerGetBatteryLevel", CFProperties);
    objc_autoreleasePoolPop(v16);
    goto LABEL_19;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(properties[0], CFSTR("CurrentCapacity"));
  if (!Value
    || !CFNumberGetValue(Value, kCFNumberIntType, &valuePtr)
    || (v14 = (const __CFNumber *)CFDictionaryGetValue(properties[0], CFSTR("MaxCapacity"))) == 0
    || !CFNumberGetValue(v14, kCFNumberIntType, (char *)&valuePtr + 4))
  {
LABEL_19:
    v15 = 0;
    goto LABEL_20;
  }
  v15 = 1;
LABEL_20:
  if (properties[0])
  {
    CFRelease(properties[0]);
    properties[0] = 0;
  }
  v17 = *(_DWORD *)(a1 + 984);
  if (v15)
  {
    v18 = (100 * valuePtr) / HIDWORD(valuePtr);
    *(_DWORD *)(a1 + 984) = v18;
    *(double *)(a1 + 992) = Current + (double)(60 * (v18 / 0xA));
    if (v17 <= 9)
    {
      if (v18 < 0xA)
        goto LABEL_32;
    }
    else if (v18 >= 0xA)
    {
      goto LABEL_32;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 984) = 0;
    *(_QWORD *)(a1 + 992) = 0;
    if (v17 <= 9)
      goto LABEL_32;
  }
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Battery state has changed. Remaining %d percent", *(unsigned int *)(a1 + 984));
  objc_autoreleasePoolPop(v19);
LABEL_32:
  if (a3 == -536723200)
  {
    CFProperty = IORegistryEntryCreateCFProperty(a2, CFSTR("ExternalConnected"), kCFAllocatorDefault, 0);
    v21 = CFProperty;
    if (CFProperty && CFEqual(CFProperty, kCFBooleanTrue))
    {
      if (!*(_BYTE *)(a1 + 314))
      {
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "External power source attached");
        objc_autoreleasePoolPop(v22);
        if ((*(_BYTE *)(a1 + 832) & 0xF) == 0 && *(_DWORD *)(a1 + 788) != 2)
          sub_100031B4C(a1);
        *(_BYTE *)(a1 + 314) = 1;
      }
    }
    else
    {
      if (*(_BYTE *)(a1 + 314))
      {
        *(_BYTE *)(a1 + 314) = 0;
        v23 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "External power source removed");
        objc_autoreleasePoolPop(v23);
        if ((*(_BYTE *)(a1 + 832) & 0xF) == 0)
          sub_1000317E8(a1);
      }
      if (!v21)
      {
        if (!*(_DWORD *)(a1 + 984))
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: externally powered platform. Cancelling disassociation timer.", "__WiFiManagerBatteryEventCallback");
          objc_autoreleasePoolPop(v24);
          if ((*(_BYTE *)(a1 + 832) & 0xF) == 0 && *(_DWORD *)(a1 + 788) != 2)
            sub_100031B4C(a1);
          *(_BYTE *)(a1 + 314) = 1;
        }
        goto LABEL_49;
      }
    }
    CFRelease(v21);
  }
LABEL_49:
  sub_10000A77C(a1, 0, *(unsigned __int8 *)(a1 + 1162), 2);
  properties[0] = (CFMutableDictionaryRef)a1;
  properties[1] = (CFMutableDictionaryRef)0xAAAAAAAA0000004ALL;
  properties[2] = 0;
  properties[3] = (CFMutableDictionaryRef)1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, properties);
  sub_10000C2DC((const __CFArray *)a1, *(unsigned __int8 *)(a1 + 314), *(_DWORD *)(a1 + 984));
  if (v7 != *(unsigned __int8 *)(a1 + 314))
    sub_100014478(a1);

}

void sub_10000A5CC(_QWORD *a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  char v4;
  double Current;
  double v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  double *v12;
  double v13;
  double v14;
  double v15;
  void *v16;
  double *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  const char *v21;
  char valuePtr;

  valuePtr = 0;
  if (!theDict)
  {
    v19 = objc_autoreleasePoolPush();
    v20 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v21 = "null ccaDict";
LABEL_26:
      objc_msgSend(v20, "WFLog:message:", 3, v21);
    }
LABEL_27:
    objc_autoreleasePoolPop(v19);
    return;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("CCA"));
  if (!Value)
  {
    v19 = objc_autoreleasePoolPush();
    v20 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v21 = "null ccaNum";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  CFNumberGetValue(Value, kCFNumberSInt8Type, &valuePtr);
  v4 = valuePtr;
  Current = CFAbsoluteTimeGetCurrent();
  v6 = Current;
  v7 = a1 + 225;
  v8 = a1[286];
  v9 = a1[287];
  if (v8)
  {
    v10 = v9 - 1;
    if (!v9)
      v10 = 29;
    v11 = (double *)&v7[2 * v10];
    v13 = v11[1];
    v12 = v11 + 1;
    v14 = Current - v13;
    v15 = -(v6 - v13);
    if (v6 - v13 < 0.0)
      v14 = v15;
    if (v14 < 5.0)
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Too frequent(%f secs) CCA event from driver\n", v6 - *v12);
      objc_autoreleasePoolPop(v16);
      v9 = a1[287];
      v8 = a1[286];
    }
  }
  if (v9 == 30)
    v9 = 0;
  v17 = (double *)&v7[2 * v9];
  *(_BYTE *)v17 = v4;
  v17[1] = v6;
  if (v8 > 29)
  {
    if (v9 == a1[285])
    {
      if (v9 == 29)
        v18 = 0;
      else
        v18 = v9 + 1;
      a1[285] = v18;
    }
  }
  else
  {
    a1[286] = v8 + 1;
  }
  a1[287] = v9 + 1;
}

void sub_10000A77C(uint64_t a1, const void *a2, int a3, int a4)
{
  int Count;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  void *v14;
  int v15;
  CFIndex v16;
  int v17;
  int v18;
  int v19;
  __CFSet *v20;
  void *v21;
  void *v22;
  CFIndex v23;
  const char *v24;
  const char *v25;
  const char *v26;
  void *v27;
  CFIndex v28;
  const char *v29;
  const char *v30;
  const char *v31;
  void *v32;
  const char *v33;
  unsigned int v34;
  _QWORD context[4];
  _QWORD v36[3];
  uint64_t v37;

  Count = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
  if (a2)
  {
    v9 = CFSetContainsValue(*(CFSetRef *)(a1 + 1168), a2);
    if (a3)
    {
      if (v9)
        return;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 1168), a2);
    }
    else
    {
      if (!v9)
        return;
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 1168), a2);
    }
  }
  v10 = objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isWoWActivityRegistered");
  v34 = v10;
  if (*(_BYTE *)(a1 + 1163))
  {
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v11 = v10;
    v13 = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
    if (v13)
      v11 = 1;
    if (v11)
      v12 = v13;
    else
      v12 = 0;
  }
  v14 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "manager->wow.lpasSetting %d CFSetGetCount(manager->wow.wowClients) %ld isWowActivityRegistered=%d manager->wow.overrideWoWState %d manager->externalPower %d manager->iokit.battery.chargeLevel %d", *(unsigned __int8 *)(a1 + 1162), CFSetGetCount(*(CFSetRef *)(a1 + 1168)), v34, *(unsigned __int8 *)(a1 + 1163), *(unsigned __int8 *)(a1 + 314), *(unsigned int *)(a1 + 984));
  objc_autoreleasePoolPop(v14);
  v15 = *(unsigned __int8 *)(a1 + 1162);
  if (!*(_BYTE *)(a1 + 1162))
    goto LABEL_24;
  v16 = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
  v17 = v34;
  if (v16)
    v17 = 1;
  if (v17 == 1)
  {
    v15 = *(unsigned __int8 *)(a1 + 1163);
    if (!*(_BYTE *)(a1 + 1163))
    {
LABEL_24:
      if (a4)
        goto LABEL_25;
LABEL_29:
      v18 = 1;
      goto LABEL_30;
    }
  }
  if (*(_BYTE *)(a1 + 314) || *(_DWORD *)(a1 + 984) >= 0xAu)
  {
    v15 = 1;
    goto LABEL_24;
  }
  v15 = 0;
  if (!a4)
    goto LABEL_29;
LABEL_25:
  if (a4 == 1)
    v18 = 0;
  else
    v18 = *(unsigned __int8 *)(a1 + 1164);
LABEL_30:
  if (*(unsigned __int8 *)(a1 + 1160) != v11
    || *(unsigned __int8 *)(a1 + 1176) != v15
    || *(unsigned __int8 *)(a1 + 1164) != v18)
  {
    *(_BYTE *)(a1 + 1161) = v11;
    *(_BYTE *)(a1 + 1176) = v15;
    *(_BYTE *)(a1 + 1164) = v18;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000007;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    v36[0] = a1;
    v36[1] = 0xAAAAAAAA00000030;
    v36[2] = 0;
    v37 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v36);
    v19 = v37;
    *(_BYTE *)(a1 + 1160) = v37;
    if (!a2 || *(unsigned __int8 *)(a1 + 1161) == v19)
    {
      if (!v19)
        goto LABEL_52;
    }
    else
    {
      v20 = *(__CFSet **)(a1 + 1168);
      if (a3)
        CFSetRemoveValue(v20, a2);
      else
        CFSetAddValue(v20, a2);
      if (!*(_BYTE *)(a1 + 1160))
        goto LABEL_52;
    }
    if (CFSetGetCount(*(CFSetRef *)(a1 + 1168)))
    {
      v21 = objc_autoreleasePoolPush();
      v22 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v23 = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
        v24 = "Enabled";
        if (*(_BYTE *)(a1 + 1176))
          v25 = "Enabled";
        else
          v25 = "Disabled";
        if (*(_BYTE *)(a1 + 1163))
          v26 = "Enabled";
        else
          v26 = "Disabled";
        if (!*(_BYTE *)(a1 + 1164))
          v24 = "Disabled";
        objc_msgSend(v22, "WFLog:message:", 3, "WoW Enabled by %ld Clients, lpas is %s, WoW Override is %s, Captive %s", v23, v25, v26, v24);
      }
LABEL_62:
      objc_autoreleasePoolPop(v21);
      if (!*(_BYTE *)(a1 + 26) && !*(_BYTE *)(a1 + 1329) && (*(_BYTE *)(a1 + 1160) || *(_BYTE *)(a1 + 1176)))
      {
        v32 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (*(_BYTE *)(a1 + 1160))
            v33 = "WoW";
          else
            v33 = "LPAS";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: re-enabling auto-join for %s", "WiFiManagerSetWoWState", v33);
        }
        objc_autoreleasePoolPop(v32);
        sub_1000094BC(a1, 1);
      }
      objc_msgSend(*(id *)(a1 + 2416), "updateWowState:lpasState:lowPowerState:batterySaverState:", *(_BYTE *)(a1 + 1160) != 0, *(_BYTE *)(a1 + 1176) != 0, *(_BYTE *)(a1 + 1162) != 0, *(_QWORD *)(a1 + 1600) != 0);
      goto LABEL_73;
    }
LABEL_52:
    v21 = objc_autoreleasePoolPush();
    v27 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v28 = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
      v29 = "Enabled";
      if (*(_BYTE *)(a1 + 1176))
        v30 = "Enabled";
      else
        v30 = "Disabled";
      if (*(_BYTE *)(a1 + 1163))
        v31 = "Enabled";
      else
        v31 = "Disabled";
      if (!*(_BYTE *)(a1 + 1164))
        v29 = "Disabled";
      objc_msgSend(v27, "WFLog:message:", 3, "WoW Disabled, %ld WoW Clients, lpas is %s, WoW Override is %s, Captive %s", v28, v30, v31, v29);
    }
    goto LABEL_62;
  }
LABEL_73:
  if (a2)
  {
    if (v12 != Count)
    {
      LOBYTE(v36[0]) = *(_BYTE *)(a1 + 1160);
      CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B9268, v36);
    }
  }
}

uint64_t sub_10000ABD4(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFPropertyListRef v18;
  const __CFString *v19;
  const __CFString *v20;
  const void *v21;
  uint64_t v22;
  CFTypeID v23;
  void *v24;
  uint64_t v25;
  CFDictionaryRef v26;
  CFTypeID v27;
  void *v28;
  void *context;
  void *contexta;
  UInt8 *v32;

  *a6 = 0;
  *a7 = 0;
  v14 = sub_1000167F8();
  v15 = sub_10001674C(a1, v14);
  if (v15)
  {
    v16 = v15;
    if ((sub_100016834((uint64_t)v15) & 1) != 0)
    {
      v18 = sub_10001D7D0(a2, a3);
      v19 = (const __CFString *)sub_10001D7D0(a4, a5);
      v20 = v19;
      if (v18 && v19)
      {
        v32 = a4;
        v21 = sub_10001683C((uint64_t)v16, v18);
        if (!v21)
          goto LABEL_25;
        v22 = (uint64_t)v21;
        v23 = CFGetTypeID(v20);
        if (v23 == CFStringGetTypeID() && CFEqual(v20, CFSTR("IO80211InterfaceWoWWakeUpParams")))
        {
          v24 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            context = v24;
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: \"%@\" querying %@ on %@", "_wifi_device_copy_property", sub_1000161D4((uint64_t)v16), v20, v18);
            v24 = context;
          }
          objc_autoreleasePoolPop(v24);
        }
        v25 = sub_1000161D4(v22);
        v26 = sub_100008514(v25, v18, v20);
        v27 = CFGetTypeID(v20);
        if (v27 == CFStringGetTypeID() && CFEqual(v20, CFSTR("IO80211InterfaceWoWWakeUpParams")))
        {
          v28 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            contexta = v28;
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: \"%@\" querying %@ on %@ received %@", "_wifi_device_copy_property", sub_1000161D4((uint64_t)v16), v20, v18, v26);
            v28 = contexta;
          }
          objc_autoreleasePoolPop(v28);
        }
        if (v26)
        {
          sub_100016858(v26, a6, a7);
          CFRelease(v18);
        }
        else
        {
LABEL_25:
          v26 = (CFDictionaryRef)v18;
        }
        CFRelease(v26);
        a4 = v32;
      }
      else
      {
        if (v18)
          CFRelease(v18);
        if (!v20)
          goto LABEL_23;
      }
      CFRelease(v20);
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v16));
      objc_autoreleasePoolPop(v17);
    }
LABEL_23:
    CFRelease(v16);
  }
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_10000AE60(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  mach_port_name_t v4;
  const void *v5;
  const void *v6;
  CFStringRef v7;
  void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;

  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    v3 = sub_100005830(v2);
    sub_100006360(v3);
    v2 = *(_QWORD *)(a1 + 88);
  }
  sub_100031C0C(v2);
  v4 = *(_DWORD *)(a1 + 96);
  if (v4)
    mach_port_deallocate(mach_task_self_, v4);
  v5 = *(const void **)(a1 + 112);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v6 = *(const void **)(a1 + 120);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v7 = CFUUIDCreateString(kCFAllocatorDefault, *(CFUUIDRef *)(a1 + 72));
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Removing client for \"%@\" (%@)", *(_QWORD *)(a1 + 64), v7);
  objc_autoreleasePoolPop(v8);
  if (v7)
    CFRelease(v7);
  v9 = *(const void **)(a1 + 64);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v10 = *(const void **)(a1 + 72);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v11 = *(const void **)(a1 + 104);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v12 = *(const void **)(a1 + 160);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v13 = *(const void **)(a1 + 168);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 168) = 0;
  }
}

uint64_t sub_10000AF8C(uint64_t a1)
{
  void *v2;
  void *v3;
  const __SCPreferences *v4;
  void *v5;
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  const __SCPreferences *v12;
  void *v13;
  uint64_t v14;
  void *v15;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 1955))
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: fetching user auto join state from the plist", "WiFiManagerGetUserAutoJoinState");
      objc_autoreleasePoolPop(v3);
      *(_BYTE *)(a1 + 1954) = sub_10003036C((_QWORD *)a1, CFSTR("UserAutoJoinState"), 1);
      *(_BYTE *)(a1 + 1953) = 1;
      v4 = sub_10001D90C((_QWORD *)a1, CFSTR("UserAutoJoinDisabledLoc"));
      v5 = objc_autoreleasePoolPush();
      if (v4)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found location data for user auto join disabled", "WiFiManagerGetUserAutoJoinState");
        objc_autoreleasePoolPop(v5);
        v6 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClass:fromData:error:", objc_opt_class(CLLocation), v4, 0);
        if (v6 && (v7 = v6, v8 = objc_opt_class(CLLocation), (objc_opt_isKindOfClass(v7, v8) & 1) != 0))
        {
          v9 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting disabled location to %@", "WiFiManagerGetUserAutoJoinState", v7);
          objc_autoreleasePoolPop(v9);
          *(_QWORD *)(a1 + 1960) = v7;
          v10 = v7;
          *(_BYTE *)(a1 + 1953) = 0;
        }
        else
        {
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid location property in the plist, clearing out", "WiFiManagerGetUserAutoJoinState");
          objc_autoreleasePoolPop(v11);
          sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisabledLoc"), 0, 0);
        }
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no location data in plist", "WiFiManagerGetUserAutoJoinState");
        objc_autoreleasePoolPop(v5);
      }
      v12 = sub_10001D90C((_QWORD *)a1, CFSTR("UserAutoJoinDisableTimestamp"));
      v13 = objc_autoreleasePoolPush();
      if (v12)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found disabled date %@", "WiFiManagerGetUserAutoJoinState", v12);
        objc_autoreleasePoolPop(v13);
        *(_QWORD *)(a1 + 1968) = v12;
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no disabled date in plist", "WiFiManagerGetUserAutoJoinState");
        objc_autoreleasePoolPop(v13);
      }
      *(_BYTE *)(a1 + 1955) = 1;
    }
    v14 = *(unsigned __int8 *)(a1 + 1954);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join state %d", "WiFiManagerGetUserAutoJoinState", v14);
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerGetUserAutoJoinState");
    v14 = 1;
  }
  objc_autoreleasePoolPop(v15);
  objc_autoreleasePoolPop(v2);
  return v14;
}

CFArrayRef sub_10000B29C(CFArrayRef result)
{
  CFArrayRef v1;
  CFIndex v2;
  size_t v3;
  char *v4;
  uint64_t v5;

  if (result)
  {
    v1 = result;
    result = (CFArrayRef)*((_QWORD *)result + 13);
    if (result)
    {
      result = (CFArrayRef)CFSetGetCount(result);
      if (result)
      {
        v2 = (CFIndex)result;
        __chkstk_darwin();
        v4 = (char *)&v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
        memset(v4, 170, v3);
        CFSetGetValues(*((CFSetRef *)v1 + 13), (const void **)v4);
        return CFArrayCreate(kCFAllocatorDefault, (const void **)v4, v2, &kCFTypeArrayCallBacks);
      }
    }
  }
  return result;
}

uint64_t sub_10000B624(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, __int128 *a7)
{
  uint64_t Instance;
  uint64_t v15;
  CFMutableDictionaryRef Mutable;
  _QWORD *v17;
  mach_port_t v18;
  mach_port_name_t v19;
  mach_port_t v20;
  mach_port_name_t v21;
  __int128 v22;
  CFStringRef v23;
  const __CFUUID *v24;
  CFStringRef v25;
  void *v26;
  __int128 v27;
  CFMutableDictionaryRef v28;
  CFMutableArrayRef v29;
  CFMutableArrayRef v30;
  void *v32;
  void *v33;
  void *v34;
  const char *v35;
  integer_t port_info_out;
  mach_msg_type_number_t port_info_outCnt;
  mach_port_t previous;
  mach_port_name_t name;
  _OWORD buffer[2];

  previous = -1431655766;
  name = 0;
  port_info_out = -1431655766;
  port_info_outCnt = 1;
  if (!a5)
  {
LABEL_25:
    v15 = 0;
LABEL_38:
    if (name)
      mach_port_mod_refs(mach_task_self_, name, 1u, -1);
    if (v15)
    {
      CFRelease((CFTypeRef)v15);
      return 0;
    }
    return v15;
  }
  if (!qword_10026D608)
    pthread_once(&stru_10026C998, (void (*)(void))sub_100065040);
  Instance = _CFRuntimeCreateInstance(a1);
  if (!Instance)
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to create WiFiClientRef in CFRuntime");
    objc_autoreleasePoolPop(v32);
    goto LABEL_25;
  }
  v15 = Instance;
  *(_QWORD *)(Instance + 176) = 0;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 160) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_DWORD *)(Instance + 16) = a2;
  *(_DWORD *)(Instance + 96) = a6;
  mach_port_allocate(mach_task_self_, 1u, &name);
  if (mach_port_request_notification(mach_task_self_, name, 70, 1u, name, 0x15u, &previous))
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_37;
    v35 = "Failed to request MACH_NOTIFY_NO_SENDERS";
LABEL_36:
    objc_msgSend(v34, "WFLog:message:", 4, v35);
    goto LABEL_37;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v15 + 104) = Mutable;
  if (!Mutable)
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_37;
    v35 = "Failed to allocate device client backing store";
    goto LABEL_36;
  }
  v17 = sub_100031C7C((uint64_t)kCFAllocatorDefault, a5, name, 0);
  *(_QWORD *)(v15 + 88) = v17;
  if (!v17)
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_37;
    v35 = "Failed to allocate client port";
    goto LABEL_36;
  }
  mach_port_insert_right(mach_task_self_, name, name, 0x14u);
  v18 = mach_task_self_;
  v19 = sub_100005830(*(_QWORD *)(v15 + 88));
  if (mach_port_get_attributes(v18, v19, 1, &port_info_out, &port_info_outCnt))
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_37;
    v35 = "Unable to allocate acquire client reply port attributes";
    goto LABEL_36;
  }
  port_info_out = 64;
  v20 = mach_task_self_;
  v21 = sub_100005830(*(_QWORD *)(v15 + 88));
  if (mach_port_set_attributes(v20, v21, 1, &port_info_out, port_info_outCnt))
  {
    v33 = objc_autoreleasePoolPush();
    v34 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v35 = "Unable to allocate set client reply port attributes";
      goto LABEL_36;
    }
LABEL_37:
    objc_autoreleasePoolPop(v33);
    goto LABEL_38;
  }
  sub_100031C74(*(_QWORD *)(v15 + 88), (uint64_t)sub_10006506C, v15);
  *(_QWORD *)(v15 + 80) = a3;
  *(_DWORD *)(v15 + 56) = a4;
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  buffer[0] = v22;
  buffer[1] = v22;
  if (proc_name(a4, buffer, 0x20u) < 1)
    v23 = 0;
  else
    v23 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)buffer, 0x8000100u);
  *(_QWORD *)(v15 + 64) = v23;
  v24 = CFUUIDCreate(kCFAllocatorDefault);
  *(_QWORD *)(v15 + 72) = v24;
  if (!v24)
    goto LABEL_38;
  v25 = CFUUIDCreateString(kCFAllocatorDefault, v24);
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Creating client for \"%@\" (%@)", v23, v25);
  objc_autoreleasePoolPop(v26);
  if (v25)
    CFRelease(v25);
  v27 = *a7;
  *(_OWORD *)(v15 + 36) = a7[1];
  *(_OWORD *)(v15 + 20) = v27;
  v28 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(v15 + 120) = v28;
  if (!v28)
    goto LABEL_38;
  v29 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v15 + 160) = v29;
  if (!v29)
    goto LABEL_38;
  v30 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v15 + 168) = v30;
  if (!v30)
    goto LABEL_38;
  return v15;
}

void sub_10000BAB8(uint64_t a1, int val)
{
  uint64_t v2;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t state64;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 && *(_DWORD *)(v2 + 2400) == val)
  {
    state64 = 0;
    if (notify_is_valid_token(val))
      notify_get_state(val, &state64);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: received LPEM notification with reason code (%llu)", "WiFiManagerScheduleWithQueue_block_invoke_11", state64);
    objc_autoreleasePoolPop(v5);
    v6 = *(_QWORD *)(a1 + 32);
    if (state64)
    {
      *(_BYTE *)(v6 + 2404) = 1;
      v7 = v6;
      v8 = 0;
    }
    else
    {
      if (!*(_BYTE *)(v6 + 2404))
        return;
      *(_BYTE *)(v6 + 2404) = 0;
      v8 = sub_10008F890((_QWORD *)v6);
      v7 = v6;
    }
    sub_10008F33C(v7, v8, CFSTR("LPEM"));
  }
}

void sub_10000BBA0(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  void *v7;
  void *v8;
  const void *v9;
  id v10;
  id v11;
  CFMutableArrayRef Mutable;
  const __CFArray *v13;
  __CFArray *v14;
  __CFArray *v15;
  __CFArray *v16;
  __CFArray *v17;
  void *v18;
  void *v19;

  v7 = objc_autoreleasePoolPush();
  if (!a3)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s manager nil", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
    goto LABEL_23;
  }
  if (!a4)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s eventData nil", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
    goto LABEL_23;
  }
  v8 = sub_10002A21C(a3, a2, 1);
  if (!v8)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s currentNetwork nil", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
LABEL_23:
    objc_autoreleasePoolPop(v18);
    goto LABEL_16;
  }
  v9 = v8;
  v10 = objc_msgSend(a4, "objectForKey:", CFSTR("BEACON_CACHE_UPDATED_EVENT_NUM_CHAN"));
  v11 = objc_msgSend(a4, "objectForKey:", CFSTR("BEACON_CACHE_UPDATED_EVENT_STATUS"));
  if (v10)
  {
    if (v11)
    {
      if (objc_msgSend(v11, "unsignedIntValue"))
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Status is not successful", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
      }
      else if (objc_msgSend(v10, "unsignedIntValue") <= 1)
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Not enough channels", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
      }
      else
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (Mutable)
        {
          v13 = Mutable;
          sub_100071C00(*(_QWORD *)(a3 + 64), (uint64_t)Mutable);
          if (CFArrayGetCount(v13))
          {
            v14 = sub_100071D5C(*(_QWORD *)(a3 + 64), (uint64_t)a2, 0, v13, 0);
            if (v14)
            {
              v15 = v14;
              v16 = (__CFArray *)sub_100043A6C(*(_QWORD *)(a3 + 120));
              if (v16)
              {
                v17 = v16;
                sub_100062EE0(v9, v15, v16);
                CFRelease(v15);
                v15 = v17;
              }
              CFRelease(v15);
            }
          }
          CFRelease(v13);
          goto LABEL_15;
        }
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s beaconScanCache alloc cache failed", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
      }
    }
    else
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s statusNum nil", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s chanNum nil", "__WiFiDeviceManagerProcessBeaconCacheUpdatedEvent");
  }
  objc_autoreleasePoolPop(v19);
LABEL_15:
  CFRelease(v9);
LABEL_16:
  objc_autoreleasePoolPop(v7);
}

uint64_t sub_10000BE8C(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *Value;
  CFBooleanRef v4;
  BOOL v5;
  uint64_t v6;
  const void *v7;
  void *v9;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsCarPlay");
    goto LABEL_20;
  }
  v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network record", "WiFiNetworkIsCarPlay");
LABEL_20:
    objc_autoreleasePoolPop(v9);
    return 0;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v2, CFSTR("APPLE_DEVICE_IE"));
  if (Value)
  {
    v4 = (CFBooleanRef)CFDictionaryGetValue(Value, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_CARPLAY"));
    if (v4)
      v5 = v4 == kCFBooleanTrue;
    else
      v5 = 0;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  v7 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("CARPLAY_NETWORK"));
  if (v7)
  {
    if (CFEqual(v7, kCFBooleanTrue))
      return 1;
    else
      return v6;
  }
  return v6;
}

__CFArray *sub_10000BF9C(uint64_t a1, const __CFArray *a2)
{
  const void *v4;
  __CFDictionary *Mutable;
  CFMutableArrayRef v6;
  __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v12;
  uint64_t v13;
  __CFArray *v14;
  const __CFArray *v15;
  CFIndex v16;
  const __CFDictionary *v17;
  const void *Value;
  CFIndex v19;
  CFRange v21;

  v4 = *(const void **)(a1 + 112);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 112) = 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v7 = v6;
  if (!a2 || !v6)
  {
LABEL_14:
    if (!v7)
      goto LABEL_18;
    goto LABEL_15;
  }
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v9 = Count;
    for (i = 0; i != v9; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      if (ValueAtIndex)
      {
        v12 = ValueAtIndex;
        v13 = sub_1000161D4((uint64_t)ValueAtIndex);
        v14 = sub_10000DF90(v13);
        if (v14)
        {
          v15 = v14;
          v21.length = CFArrayGetCount(v14);
          v21.location = 0;
          CFArrayAppendArray(v7, v15, v21);
          if (CFArrayGetCount(v15) >= 1)
          {
            v16 = 0;
            do
            {
              v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v16);
              Value = CFDictionaryGetValue(v17, CFSTR("VIRT_IF_NAME"));
              CFDictionaryAddValue(Mutable, Value, v12);
              ++v16;
            }
            while (v16 < CFArrayGetCount(v15));
          }
          CFRelease(v15);
        }
      }
    }
    goto LABEL_14;
  }
LABEL_15:
  v19 = CFDictionaryGetCount(Mutable);
  if (v19)
    v19 = (CFIndex)CFRetain(Mutable);
  *(_QWORD *)(a1 + 112) = v19;
LABEL_18:
  if (Mutable)
    CFRelease(Mutable);
  return v7;
}

void sub_10000C120(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  const void *v6;
  CFDictionaryRef *v7;
  CFDictionaryRef *v8;
  id v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;

  v2 = objc_autoreleasePoolPush();
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UAJM feature is disabled", "__WiFiDeviceManagerUnifiedAutoJoinUpdateAssociatedNetwork");
    goto LABEL_17;
  }
  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiDeviceManagerUnifiedAutoJoinUpdateAssociatedNetwork");
LABEL_17:
    v13 = v12;
LABEL_21:
    objc_autoreleasePoolPop(v13);
    goto LABEL_12;
  }
  v3 = *(_QWORD *)(a1 + 8824);
  v4 = objc_autoreleasePoolPush();
  if (!v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UAJM is null", "__WiFiDeviceManagerUnifiedAutoJoinUpdateAssociatedNetwork");
    v13 = v4;
    goto LABEL_21;
  }
  v5 = *(_QWORD *)(a1 + 64);
  if (v5)
  {
    v6 = (const void *)sub_100025C3C(v5);
    v7 = (CFDictionaryRef *)sub_10002A21C(a1, v6, 1);
    v8 = v7;
    if (v7)
    {
      v9 = sub_100027D10((uint64_t)v7);
      if (v9)
      {
        v10 = sub_100026664(v8);
        if (v10)
        {
          v11 = objc_msgSend(v9, "scanResultWithMatchingKnownNetworkProfile:", v10);

          v9 = v11;
        }
        goto LABEL_9;
      }
    }
    else
    {
      v9 = 0;
    }
    v10 = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v8 = 0;
  }
LABEL_9:
  objc_autoreleasePoolPop(v4);

  if (v8)
    CFRelease(v8);
  objc_msgSend(*(id *)(a1 + 8824), "setAssociatedNetwork:", v9);

LABEL_12:
  objc_autoreleasePoolPop(v2);
}

void sub_10000C2DC(const __CFArray *a1, unsigned int a2, int a3)
{
  void *v5;
  const __CFString *v6;
  void *v7;
  CFArrayRef v8;
  const __CFArray *v9;
  __objc2_prot_list **p_prots;
  void *v11;
  void *v12;
  const char *v13;
  CFIndex v14;
  const void *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  CFIndex Count;
  void *v22;
  void *v23;
  __objc2_prot_list *v24;
  const __CFDictionary *v25;
  const __CFNumber *Value;
  id v27;
  void *v28;
  CFNumberRef v29;
  CFNumberRef v30;
  uint64_t v31;
  const __CFDictionary *v32;
  CFIndex v33;
  _QWORD *v34;
  void *v35;
  CFTypeRef *v36;
  CFTypeID v37;
  const __CFNumber *v38;
  const __CFNumber *v39;
  CFTypeID v40;
  CFNumberRef v41;
  CFTypeID v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  CFTypeID v45;
  CFNumberRef v46;
  void *v47;
  const void *v48;
  CFNumberRef v49;
  CFNumberRef v50;
  uint64_t v51;
  int v52;
  const __CFDictionary *v53;
  CFIndex v54;
  void *v55;
  void *v56;
  CFTypeRef *v57;
  const void **v58;
  CFTypeID v59;
  CFTypeID v60;
  void *v61;
  const void *v62;
  void *v63;
  void *v64;
  const char *v65;
  void *v66;
  const char *v67;
  void *context;
  uint64_t v69;
  const __CFString *v70;
  const __CFArray *v71;
  CFIndex v72;
  const __CFDictionary *v73;
  const __CFDictionary *v74;
  void *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  unsigned int Current;
  int valuePtr;
  int v81;

  v81 = a3;
  context = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Posting metrics for AJ");
  objc_autoreleasePoolPop(v5);
  valuePtr = 115;
  v6 = (const __CFString *)CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "External power state is %d", a2);
  objc_autoreleasePoolPop(v7);
  v8 = sub_10000B29C(a1);
  if (v8)
  {
    v9 = v8;
    p_prots = &OBJC_PROTOCOL___TBXPCServiceProtocol.prots;
    if (qword_10026D5D8)
    {
      if (*(unsigned __int8 *)(qword_10026D5D8 + 64) == a2)
      {
        v11 = objc_autoreleasePoolPush();
        v12 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v67 = (const char *)*(unsigned __int8 *)(qword_10026D5D8 + 64);
          v13 = "External power state is same as before %d, bailing out";
          goto LABEL_10;
        }
        goto LABEL_11;
      }
      *(_BYTE *)(qword_10026D5D8 + 64) = a2;
      Current = CFAbsoluteTimeGetCurrent();
      if (CFArrayGetCount(v9) >= 1)
      {
        v14 = 0;
        v69 = kWAMessageMetricNameAJPowerMetric;
        v70 = v6;
        v71 = v9;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v9, v14);
          if (ValueAtIndex)
          {
            v16 = sub_1000161D4((uint64_t)ValueAtIndex);
            if (!v16)
            {
              v11 = objc_autoreleasePoolPush();
              v12 = (void *)qword_10026DD20;
              if (!qword_10026DD20)
                goto LABEL_11;
              v13 = "Device not present";
              goto LABEL_10;
            }
            v17 = v16;
            v18 = (const void *)sub_100025C3C(v16);
            v19 = sub_100008514(v17, v18, v6);
            if (!v19)
            {
              v11 = objc_autoreleasePoolPush();
              v12 = (void *)qword_10026DD20;
              if (!qword_10026DD20)
                goto LABEL_11;
              v13 = "Failed to get property";
LABEL_10:
              objc_msgSend(v12, "WFLog:message:", 3, v13, v67);
              goto LABEL_11;
            }
            v20 = v19;
            v72 = v14;
            Count = CFDictionaryGetCount(v19);
            v22 = malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
            bzero(v22, 8 * Count);
            v23 = malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
            bzero(v23, 8 * Count);
            CFDictionaryGetKeysAndValues(v20, (const void **)v22, (const void **)v23);
            v24 = p_prots[187];
            if (LOBYTE(v24[8].count))
            {
              v25 = (const __CFDictionary *)v24[7].count;
              if (!v25)
              {
                v63 = objc_autoreleasePoolPush();
                v64 = (void *)qword_10026DD20;
                if (qword_10026DD20)
                {
                  v65 = "Inital metrics dictionary not present";
                  goto LABEL_98;
                }
LABEL_99:
                objc_autoreleasePoolPop(v63);
                v9 = v71;
                if (v22)
                  goto LABEL_83;
                goto LABEL_84;
              }
              v78 = 0;
              Value = (const __CFNumber *)CFDictionaryGetValue(v25, CFSTR("metricsTotalTime"));
              if (Value)
                CFNumberGetValue(Value, kCFNumberIntType, (char *)&v78 + 4);
              HIDWORD(v78) = Current - HIDWORD(v78);
              if (HIDWORD(v78) <= 0x707)
              {
                v61 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System not on puck time is %u s < 30min, not posting", HIDWORD(v78));
                objc_autoreleasePoolPop(v61);
                v62 = (const void *)p_prots[187][7].count;
                v9 = v71;
                if (v62)
                {
                  CFRelease(v62);
                  p_prots[187][7].count = 0;
                }
                if (v22)
LABEL_83:
                  free(v22);
LABEL_84:
                if (v23)
                  free(v23);
                CFRelease(v20);
                break;
              }
              v27 = objc_msgSend(objc_alloc((Class)WAMessage), "initWithMetricName:options:", v69, 5);
              if (!v27)
              {
                v63 = objc_autoreleasePoolPush();
                v64 = (void *)qword_10026DD20;
                if (qword_10026DD20)
                {
                  v67 = "WiFiMetricsManagerSubmitWiFiAJPowerMetrics";
                  v65 = "%s: null waMsg";
LABEL_98:
                  objc_msgSend(v64, "WFLog:message:", 3, v65, v67);
                }
                goto LABEL_99;
              }
              v28 = v27;
              v73 = v20;
              v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)&v78 + 4);
              objc_msgSend(v28, "addFieldForKey:value:options:", CFSTR("metricsTotalTime"), v29, 5);
              if (v29)
                CFRelease(v29);
              v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v81);
              objc_msgSend(v28, "addFieldForKey:value:options:", CFSTR("finalChargeLevel"), v30, 5);
              if (v30)
                CFRelease(v30);
              objc_msgSend(v28, "addFieldForKey:value:options:", CFSTR("initialChargeLevel"), CFDictionaryGetValue((CFDictionaryRef)p_prots[187][7].count, CFSTR("initialChargeLevel")), 5);
              if (Count >= 1)
              {
                v31 = 0;
                v75 = v23;
                do
                {
                  if (!CFStringHasPrefix(*((CFStringRef *)v22 + v31), CFSTR("CACHED"))
                    && !CFEqual(*((CFTypeRef *)v22 + v31), CFSTR("AutoHotspotLPHSPowerStats")))
                  {
                    if (CFEqual(*((CFTypeRef *)v22 + v31), CFSTR("AutoJoinPowerDiag")))
                    {
                      v32 = (const __CFDictionary *)*((_QWORD *)v23 + v31);
                      v33 = CFDictionaryGetCount(v32);
                      v34 = malloc_type_malloc(8 * v33, 0x6004044C4A2DFuLL);
                      bzero(v34, 8 * v33);
                      v35 = malloc_type_malloc(8 * v33, 0x6004044C4A2DFuLL);
                      bzero(v35, 8 * v33);
                      v77 = v34;
                      CFDictionaryGetKeysAndValues(v32, (const void **)v34, (const void **)v35);
                      if (v33 >= 1)
                      {
                        v36 = (CFTypeRef *)v35;
                        do
                        {
                          v78 = 0;
                          v37 = CFGetTypeID(*v36);
                          if (v37 == CFNumberGetTypeID())
                          {
                            v38 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(qword_10026D5D8 + 56), (const void *)*v34);
                            if (v38)
                            {
                              v39 = v38;
                              v40 = CFGetTypeID(v38);
                              if (v40 == CFNumberGetTypeID())
                                CFNumberGetValue(v39, kCFNumberIntType, (char *)&v78 + 4);
                            }
                            CFNumberGetValue((CFNumberRef)*v36, kCFNumberIntType, &v78);
                            HIDWORD(v78) = v78 - HIDWORD(v78);
                            v41 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)&v78 + 4);
                            objc_msgSend(v28, "addFieldForKey:value:options:", *v34, v41, 5);
                            if (v41)
                              CFRelease(v41);
                          }
                          ++v34;
                          ++v36;
                          --v33;
                        }
                        while (v33);
                      }
                      free(v77);
                      free(v35);
                      p_prots = (__objc2_prot_list **)(&OBJC_PROTOCOL___TBXPCServiceProtocol + 16);
                      v23 = v75;
                    }
                    else
                    {
                      v78 = 0;
                      v42 = CFGetTypeID(*((CFTypeRef *)v23 + v31));
                      if (v42 == CFNumberGetTypeID())
                      {
                        v43 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)p_prots[187][7].count, *((const void **)v22 + v31));
                        if (v43)
                        {
                          v44 = v43;
                          v45 = CFGetTypeID(v43);
                          if (v45 == CFNumberGetTypeID())
                            CFNumberGetValue(v44, kCFNumberIntType, (char *)&v78 + 4);
                        }
                        CFNumberGetValue(*((CFNumberRef *)v23 + v31), kCFNumberIntType, &v78);
                        HIDWORD(v78) = v78 - HIDWORD(v78);
                        v46 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)&v78 + 4);
                        objc_msgSend(v28, "addFieldForKey:value:options:", *((_QWORD *)v22 + v31), v46, 5);
                        if (v46)
                          CFRelease(v46);
                      }
                    }
                  }
                  ++v31;
                }
                while (v31 != Count);
              }
              v47 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Posting AJ power metrics\n");
              objc_autoreleasePoolPop(v47);
              sub_100052064(v28);
              v48 = (const void *)p_prots[187][7].count;
              v20 = v73;
              if (v48)
              {
                CFRelease(v48);
                p_prots[187][7].count = 0;
              }

            }
            else
            {
              p_prots[187][7].count = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              v49 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &Current);
              CFDictionaryAddValue((CFMutableDictionaryRef)p_prots[187][7].count, CFSTR("metricsTotalTime"), v49);
              if (v49)
                CFRelease(v49);
              v50 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v81);
              CFDictionaryAddValue((CFMutableDictionaryRef)p_prots[187][7].count, CFSTR("initialChargeLevel"), v50);
              if (v50)
                CFRelease(v50);
              if (Count >= 1)
              {
                v51 = 0;
                v74 = v20;
                v76 = v23;
                do
                {
                  if (!CFStringHasPrefix(*((CFStringRef *)v22 + v51), CFSTR("CACHED"))
                    && !CFEqual(*((CFTypeRef *)v22 + v51), CFSTR("AutoHotspotLPHSPowerStats")))
                  {
                    v52 = CFEqual(*((CFTypeRef *)v22 + v51), CFSTR("AutoJoinPowerDiag"));
                    v53 = (const __CFDictionary *)*((_QWORD *)v23 + v51);
                    if (v52)
                    {
                      v54 = CFDictionaryGetCount(*((CFDictionaryRef *)v23 + v51));
                      v55 = malloc_type_malloc(8 * v54, 0x6004044C4A2DFuLL);
                      bzero(v55, 8 * v54);
                      v56 = malloc_type_malloc(8 * v54, 0x6004044C4A2DFuLL);
                      bzero(v56, 8 * v54);
                      CFDictionaryGetKeysAndValues(v53, (const void **)v55, (const void **)v56);
                      p_prots = &OBJC_PROTOCOL___TBXPCServiceProtocol.prots;
                      if (v54 >= 1)
                      {
                        v57 = (CFTypeRef *)v56;
                        v58 = (const void **)v55;
                        do
                        {
                          v59 = CFGetTypeID(*v57);
                          if (v59 == CFNumberGetTypeID())
                            CFDictionaryAddValue(*(CFMutableDictionaryRef *)(qword_10026D5D8 + 56), *v58, *v57);
                          ++v58;
                          ++v57;
                          --v54;
                        }
                        while (v54);
                      }
                      free(v55);
                      free(v56);
                      v20 = v74;
                      v23 = v76;
                    }
                    else
                    {
                      v60 = CFGetTypeID(*((CFTypeRef *)v23 + v51));
                      p_prots = &OBJC_PROTOCOL___TBXPCServiceProtocol.prots;
                      if (v60 == CFNumberGetTypeID())
                        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(qword_10026D5D8 + 56), *((const void **)v22 + v51), *((const void **)v23 + v51));
                    }
                  }
                  ++v51;
                }
                while (v51 != Count);
              }
            }
            CFRelease(v20);
            if (v22)
              free(v22);
            v6 = v70;
            v9 = v71;
            v14 = v72;
            if (v23)
              free(v23);
          }
          ++v14;
        }
        while (v14 < CFArrayGetCount(v9));
      }
    }
    else
    {
      v11 = objc_autoreleasePoolPush();
      v12 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v13 = "metrics not present";
        goto LABEL_10;
      }
LABEL_11:
      objc_autoreleasePoolPop(v11);
    }
    CFRelease(v9);
    if (v6)
      goto LABEL_88;
  }
  else
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device manager not present");
    objc_autoreleasePoolPop(v66);
    if (v6)
LABEL_88:
      CFRelease(v6);
  }
  objc_autoreleasePoolPop(context);
}

void sub_10000CCC8(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  const __CFNumber *v7;
  int v8;
  int v9;
  void *v10;
  void *v11;
  double v12;
  void *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  int ValueIfPresent;
  uint64_t v17;
  CFNumberRef v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef number;
  void *value;
  uint64_t v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  unsigned __int8 valuePtr;

  v38 = 0;
  v37 = 0;
  v36 = 0;
  value = 0;
  v35 = 0;
  v32 = 0;
  number = 0;
  v30 = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  if (a3 && theDict)
  {
    valuePtr = -86;
    v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("ASR_SESSION_STATE"));
    if (v7)
    {
      CFNumberGetValue(v7, kCFNumberSInt8Type, &valuePtr);
      v8 = *(unsigned __int8 *)(a3 + 2232);
      v9 = v8;
      if (v8 != valuePtr)
      {
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "11ax ASR session: new-state = 0x%x, prev-state = 0x%x", valuePtr, *(unsigned __int8 *)(a3 + 2232));
        objc_autoreleasePoolPop(v10);
        v9 = *(unsigned __int8 *)(a3 + 2232);
        v8 = valuePtr;
      }
      if (!v9 && v8)
      {
        *(CFAbsoluteTime *)(a3 + 2240) = CFAbsoluteTimeGetCurrent();
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "11ax ASR session: STARTED");
        objc_autoreleasePoolPop(v11);
        v9 = *(unsigned __int8 *)(a3 + 2232);
        v8 = valuePtr;
      }
      if (v9 && !v8)
      {
        v12 = CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 2240);
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "11ax ASR session: duration = %f seconds", *(_QWORD *)&v12);
        objc_autoreleasePoolPop(v13);
        sub_100061CEC(v12);
        LOBYTE(v8) = valuePtr;
      }
      *(_BYTE *)(a3 + 2232) = v8;
    }
    v14 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RT_TRAFFIC_STATE"));
    v15 = v14;
    if (v14)
      CFNumberGetValue(v14, kCFNumberSInt8Type, (char *)&v38 + 1);
    ValueIfPresent = CFDictionaryGetValueIfPresent(theDict, CFSTR("QUAL_SCORE"), (const void **)&value);
    v17 = 0;
    if (ValueIfPresent)
    {
      v18 = 0;
      if (value)
      {
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("CHANQUAL_SCORE"), (const void **)&number)
          && number)
        {
          CFNumberGetValue(number, kCFNumberSInt8Type, &v38);
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("TX_LATENCY_SCORE"), (const void **)&v30)
          && v30)
        {
          CFNumberGetValue(v30, kCFNumberSInt8Type, (char *)&v37 + 1);
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("RX_LATENCY_SCORE"), (const void **)&v29)
          && v29)
        {
          CFNumberGetValue(v29, kCFNumberSInt8Type, &v37);
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("TX_LOSS_SCORE"), (const void **)&v28) && v28)
          CFNumberGetValue(v28, kCFNumberSInt8Type, (char *)&v36 + 1);
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("RX_LOSS_SCORE"), (const void **)&v27) && v27)
          CFNumberGetValue(v27, kCFNumberSInt8Type, &v36);
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("P95_TX_LATENCY_SCORE"), (const void **)&v32)
          && v32)
        {
          CFNumberGetValue(v32, kCFNumberSInt32Type, (char *)&v35 + 4);
        }
        v19 = CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("LINK_RECOMMENDATION_FLAGS"), (const void **)&v31);
        v17 = 0;
        v18 = v31;
        if (v19 && v31)
        {
          CFNumberGetValue(v31, kCFNumberSInt32Type, &v35);
          v18 = v31;
          v17 = (int)v35;
        }
      }
    }
    else
    {
      v18 = 0;
    }
    v20 = 0x7FFFFFFFFFFFFFFFLL;
    if (number)
      v21 = (char)v38;
    else
      v21 = 0x7FFFFFFFFFFFFFFFLL;
    if (v30)
      v22 = SHIBYTE(v37);
    else
      v22 = 0x7FFFFFFFFFFFFFFFLL;
    if (v29)
      v23 = (char)v37;
    else
      v23 = 0x7FFFFFFFFFFFFFFFLL;
    if (v28)
      v24 = SHIBYTE(v36);
    else
      v24 = 0x7FFFFFFFFFFFFFFFLL;
    if (v27)
      v25 = (char)v36;
    else
      v25 = 0x7FFFFFFFFFFFFFFFLL;
    if (v32)
      v26 = SHIDWORD(v35);
    else
      v26 = 0x7FFFFFFFFFFFFFFFLL;
    if (!v18)
      v17 = 0x7FFFFFFFFFFFFFFFLL;
    if (v15)
      v20 = HIBYTE(v38);
    objc_msgSend(*(id *)(a3 + 2416), "updateWithChQualScore:txLatencyScore:rxLatencyScore:txLossScore:rxLossScore:txLatencyP95:linkRecommendationFlags:rtTrafficStatus:forInterface:", v21, v22, v23, v24, v25, v26, v17, v20, a2);
  }
}

const __CFArray *sub_10000D074(uint64_t a1, int a2)
{
  void *v4;
  NSString *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  const void *v11;
  const void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const __CFArray *result;
  int v17;
  int v18;
  void *v19;
  id v20;
  WiFiScanResultsPreparer *v21;
  NSArray *v22;
  NSMutableArray *v23;
  void *v24;
  id v25;
  id v26;
  uint64_t v27;
  CFBooleanRef v28;
  void *i;
  uint64_t v30;
  id v31;
  const void *v32;
  uint64_t v33;
  const __CFBoolean *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  void *v38;
  int v39;
  void *v40;
  const void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  const char *v48;
  void *v49;
  const __CFArray *v50;
  void *v51;
  unsigned __int8 v52;
  id v53;
  WiFiScanResultsPreparer *v54;
  void *v55;
  id v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  const void *v60;
  const void *v61;
  const void *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  void *context;
  WiFiScanResultsPreparer *v70;
  void *v71;
  NSObject **cf;
  NSArray *v73;
  NSMutableArray *v74;
  const void *v75;
  const void *v76;
  const void *v77;
  unsigned int v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint8_t buf[4];
  const char *v84;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: current state: %@"), "__WiFiDeviceManagerDetermineNextAction", sub_100031FD0(*(_DWORD *)(a1 + 3280)))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v84 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v5, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    if (a2 == 82)
    {
      sub_1000FB44C(a1);
      return 0;
    }
    return sub_1000078D0(a1);
  }
  v6 = *(const __CFArray **)(a1 + 1104);
  if (v6 && *(_BYTE *)(a1 + 6896) && *(_BYTE *)(a1 + 6987) && *(_QWORD *)(a1 + 6976))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1104));
    v8 = Count;
    if (Count < 1)
    {
      if (Count)
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendedFromScanResults");
        objc_autoreleasePoolPop(v14);
      }
    }
    else
    {
      v9 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, v9);
        if (ValueAtIndex)
        {
          v11 = ValueAtIndex;
          v12 = sub_10002B088(ValueAtIndex);
          v13 = sub_10002B088(*(const void **)(a1 + 6976));
          if (CFEqual(v12, v13))
            break;
        }
        if (v8 == ++v9)
          goto LABEL_21;
      }
      if (v8 != v9)
      {
        v15 = sub_100025C3C(*(_QWORD *)(a1 + 64));
        *(_DWORD *)(a1 + 3280) = sub_100119668(a1, v15, 12, 0, v11, 0);
      }
    }
  }
LABEL_21:
  if (*(_DWORD *)(a1 + 3280) == 14)
    return (const __CFArray *)14;
  v17 = *(_DWORD *)(a1 + 3352);
  switch(v17)
  {
    case 4:
      v46 = objc_autoreleasePoolPush();
      v47 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_101;
      v48 = "Not prompting ATJ, driving";
      goto LABEL_100;
    case 6:
      v46 = objc_autoreleasePoolPush();
      v47 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_101;
      v48 = "Not prompting ATJ, still driving";
      goto LABEL_100;
    case 3:
      v46 = objc_autoreleasePoolPush();
      v47 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_101;
      v48 = "Not prompting ATJ, running";
      goto LABEL_100;
  }
  if (!*(_BYTE *)(a1 + 6280))
  {
    v46 = objc_autoreleasePoolPush();
    v47 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_101;
    v48 = "Not prompting ATJ, due to user disabled auto join";
    goto LABEL_100;
  }
  if (!*(_DWORD *)(a1 + 108))
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ask-to-join is set to off", "__WiFiDeviceManagerDetermineNextAction", v68);
    goto LABEL_101;
  }
  v18 = *(_DWORD *)(a1 + 176);
  v19 = objc_autoreleasePoolPush();
  if (v18 != 1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not interactive. Suppressing ATJ action", "__WiFiDeviceManagerDetermineNextAction");
    v49 = v19;
    goto LABEL_102;
  }
  if ((*(_DWORD *)(a1 + 3280) - 2) <= 2)
  {
    objc_msgSend(*(id *)(a1 + 6680), "ingestScanResults:ofType:clientName:directed:", *(_QWORD *)(a1 + 1104), 1, CFSTR("wifid"), 0);
    if (*(_BYTE *)(a1 + 6712))
    {
      v20 = sub_10012E8C8(a1);
      v21 = -[WiFiScanResultsPreparer initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:]([WiFiScanResultsPreparer alloc], "initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:", a1, *(_QWORD *)(a1 + 6672), *(_QWORD *)(a1 + 1104), 0, v20);
      if (v20)
        CFRelease(v20);
      v22 = -[WiFiScanResultsPreparer preparedScanResults](v21, "preparedScanResults");
      v71 = v19;
      cf = (NSObject **)a1;
      context = objc_autoreleasePoolPush();
      v70 = v21;
      if (v22)
      {
        v23 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", *(_QWORD *)(a1 + 3528));
        -[NSMutableArray addObjectsFromArray:](v23, "addObjectsFromArray:", *(_QWORD *)(a1 + 3536));
        v74 = v23;
        -[NSMutableArray addObjectsFromArray:](v23, "addObjectsFromArray:", *(_QWORD *)(a1 + 3640));
        v24 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s count %lu", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", -[NSArray count](v22, "count"));
        objc_autoreleasePoolPop(v24);
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v25 = -[NSArray countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v79, buf, 16);
        if (v25)
        {
          v26 = v25;
          v27 = *(_QWORD *)v80;
          v28 = kCFBooleanTrue;
          v73 = v22;
          do
          {
            for (i = 0; i != v26; i = (char *)i + 1)
            {
              if (*(_QWORD *)v80 != v27)
                objc_enumerationMutation(v22);
              v30 = *(_QWORD *)(*((_QWORD *)&v79 + 1) + 8 * (_QWORD)i);
              if (!v30)
                continue;
              if (v28 != sub_10002BE64(*(_QWORD *)(*((_QWORD *)&v79 + 1) + 8 * (_QWORD)i), CFSTR("WiFiNetworkAttributeIsKnown")))continue;
              v31 = -[NSMutableArray objectAtIndex:](v74, "objectAtIndex:", -[NSMutableArray indexOfObject:](v74, "indexOfObject:", v30));
              if (!v31)
                continue;
              v32 = v31;
              v33 = v27;
              v34 = v28;
              v35 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeIsPotentiallyCaptive"));
              v36 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeIsSuspicious"));
              v37 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeIsTCPGood"));
              v76 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeIsPotentiallyMoving"));
              v77 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeIsPublic"));
              v75 = sub_10002BE64(v30, CFSTR("WiFiNetworkAttributeHighPopularity"));
              if (!v35 || v35 == sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPotentiallyCaptive")))
              {
                v39 = 0;
              }
              else
              {
                sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPotentiallyCaptive"), v35);
                if (CFBooleanGetValue((CFBooleanRef)v35))
                {
                  v38 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isPotentiallyCaptive", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
                  objc_autoreleasePoolPop(v38);
                }
                v39 = 1;
              }
              v28 = v34;
              if (v36)
              {
                v27 = v33;
                if (v36 != sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsSuspicious")))
                {
                  sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsSuspicious"), v36);
                  if (CFBooleanGetValue((CFBooleanRef)v36))
                  {
                    v40 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isSuspicious", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
                    objc_autoreleasePoolPop(v40);
                  }
                  v39 = 1;
                }
                if (!v37)
                  goto LABEL_68;
              }
              else
              {
                v27 = v33;
                if (!v37)
                  goto LABEL_68;
              }
              v41 = v77;
              if (v37 == sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsTCPGood")))
                goto LABEL_69;
              sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsTCPGood"), v37);
              if (CFBooleanGetValue((CFBooleanRef)v37))
              {
                v39 = 1;
                goto LABEL_69;
              }
              v42 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isTCPGood is false", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
              objc_autoreleasePoolPop(v42);
              v39 = 1;
LABEL_68:
              v41 = v77;
LABEL_69:
              if (!v76)
              {
                v22 = v73;
LABEL_77:
                if (v41)
                  goto LABEL_78;
                goto LABEL_86;
              }
              v22 = v73;
              if (v76 == sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPotentiallyMoving")))
                goto LABEL_77;
              sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPotentiallyMoving"), v76);
              if (CFBooleanGetValue((CFBooleanRef)v76))
              {
                v43 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isPotentiallyMoving", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
                objc_autoreleasePoolPop(v43);
                v39 = 1;
                v41 = v77;
                if (!v77)
                  goto LABEL_86;
LABEL_78:
                if (v41 != sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPublic")))
                {
                  sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeIsPublic"), v41);
                  if (CFBooleanGetValue((CFBooleanRef)v41))
                  {
                    v44 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isPublic", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
                    objc_autoreleasePoolPop(v44);
                    v39 = 1;
                  }
                  else
                  {
                    v39 = 1;
                  }
                }
                goto LABEL_86;
              }
              v39 = 1;
              if (v41)
                goto LABEL_78;
LABEL_86:
              if (!v75 || v75 == sub_10002BE64((uint64_t)v32, CFSTR("WiFiNetworkAttributeHighPopularity")))
              {
                if (!v39)
                  continue;
              }
              else
              {
                sub_10002C478((uint64_t)v32, CFSTR("WiFiNetworkAttributeHighPopularity"), v75);
                if (CFBooleanGetValue((CFBooleanRef)v75))
                {
                  v45 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' isHighlyPopular", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults", sub_10002B088(v32));
                  objc_autoreleasePoolPop(v45);
                }
              }
              sub_1001053C8(cf, v32);
            }
            v26 = -[NSArray countByEnumeratingWithState:objects:count:](v22, "countByEnumeratingWithState:objects:count:", &v79, buf, 16);
          }
          while (v26);
        }
      }
      else
      {
        v66 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null preparedScanResults!", "__WiFiDeviceManagerUpdateKnownNetworksWithPreparedScanResults");
        objc_autoreleasePoolPop(v66);
      }
      objc_autoreleasePoolPop(context);

      v19 = v71;
      a1 = (uint64_t)cf;
    }
  }
  objc_autoreleasePoolPop(v19);
  v78 = 0;
  if (sub_10012C188(a1, &v78))
  {
    v46 = objc_autoreleasePoolPush();
    v47 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_101:
      v49 = v46;
LABEL_102:
      objc_autoreleasePoolPop(v49);
      return sub_1000078D0(a1);
    }
    v67 = v78;
    v48 = "Not prompting ATJ, auto-join scan suppressed due to reason=%d";
LABEL_100:
    objc_msgSend(v47, "WFLog:message:", 3, v48, v67, v68);
    goto LABEL_101;
  }
  v50 = *(const __CFArray **)(a1 + 1104);
  v51 = objc_autoreleasePoolPush();
  if (!*(_DWORD *)(a1 + 108))
  {
    v65 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ask-to-join is set to off", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults");
    goto LABEL_166;
  }
  if (-[WiFiUserInteractionMonitor isAskToJoinAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAskToJoinAllowed"))
  {
    if (*(_DWORD *)(a1 + 176) != 1)
      goto LABEL_167;
  }
  else
  {
    v52 = -[WiFiUserInteractionMonitor isNetworkRecommendationAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkRecommendationAllowed");
    if (*(_DWORD *)(a1 + 176) != 1)
    {
LABEL_167:
      v56 = 0;
      v57 = 0;
      v54 = 0;
      goto LABEL_126;
    }
    if ((v52 & 1) == 0)
    {
      v65 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ask to join not allowed due to user interaction state", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults");
      goto LABEL_166;
    }
  }
  if (!v50)
  {
    v65 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanResults is null", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults");
    goto LABEL_166;
  }
  if (!CFArrayGetCount(v50))
  {
    v65 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanResults is empty", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults");
LABEL_166:
    objc_autoreleasePoolPop(v65);
    goto LABEL_167;
  }
  v53 = sub_10012E8C8(a1);
  v54 = -[WiFiScanResultsPreparer initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:]([WiFiScanResultsPreparer alloc], "initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:", a1, *(_QWORD *)(a1 + 6672), v50, 0, v53);
  if (v53)
    CFRelease(v53);
  if (-[WiFiScanResultsPreparer topRecommendableNetwork](v54, "topRecommendableNetwork"))
  {
    v55 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found recommended network %@", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults", -[WiFiScanResultsPreparer topRecommendableNetwork](v54, "topRecommendableNetwork"));
    objc_autoreleasePoolPop(v55);
    v56 = -[WiFiScanResultsPreparer topRecommendableNetwork](v54, "topRecommendableNetwork");
    v57 = 1;
  }
  else if (-[WiFiScanResultsPreparer prominentScanResultsCount](v54, "prominentScanResultsCount"))
  {
    v58 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: prominent display network count: %ld", "__WiFiDeviceManagerDetermineAskToJoinActionFromScanResults", -[WiFiScanResultsPreparer prominentScanResultsCount](v54, "prominentScanResultsCount"));
    objc_autoreleasePoolPop(v58);
    v56 = 0;
    if (-[WiFiUserInteractionMonitor isNetworkingAppInForeground](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkingAppInForeground"))
    {
      v57 = 2;
    }
    else
    {
      v57 = 0;
    }
  }
  else
  {
    v56 = 0;
    v57 = 0;
  }
LABEL_126:

  objc_autoreleasePoolPop(v51);
  if (!(_DWORD)v57)
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scan results do not qualify for ask to join", "__WiFiDeviceManagerDetermineNextAction", v68);
    goto LABEL_101;
  }
  if (!sub_100160124(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 1104), *(const __CFArray **)(a1 + 3576), v57))
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not prompting ATJ action (%d), condition not fulfilled", "__WiFiDeviceManagerDetermineNextAction", v57);
    goto LABEL_101;
  }
  if ((_DWORD)v57 == 1)
  {
    result = (const __CFArray *)sub_100119204(a1, v56, 0);
  }
  else
  {
    v59 = *(_QWORD *)(a1 + 64);
    v60 = (const void *)sub_100025C3C(v59);
    v61 = sub_10002BF8C(v59, v60);
    if (v61)
    {
      v62 = v61;
      v63 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already connected to %@. Not prompting ATJ.", "__WiFiDeviceManagerDetermineNextAction", sub_10002B088(v62));
      objc_autoreleasePoolPop(v63);
      CFRelease(v62);
      return sub_1000078D0(a1);
    }
    if (!sub_100160118(*(_QWORD *)(a1 + 96)) && !*(_BYTE *)(a1 + 104))
    {
      v46 = objc_autoreleasePoolPush();
      v47 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_101;
      v48 = "Not prompting ATJ";
      goto LABEL_100;
    }
    sub_1000FC5D8(a1, 0);
    v64 = sub_100025C3C(*(_QWORD *)(a1 + 64));
    result = (const __CFArray *)sub_100119668(a1, v64, 0, 0, 0, 0);
  }
  if ((_DWORD)result != 14)
    return sub_1000078D0(a1);
  return result;
}

__CFArray *sub_10000DF90(uint64_t a1)
{
  CFIndex Count;
  const void **v3;
  const void **v4;
  const void **v5;
  const void **v6;
  __CFArray *Mutable;
  uint64_t i;
  __CFDictionary *v9;
  __CFDictionary *v10;
  CFTypeID v11;
  uint64_t v12;
  const void *v13;
  void *v15;
  CFNumberRef cf;
  uint64_t valuePtr;

  valuePtr = 0;
  cf = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  if (!cf)
    return 0;
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  if (Count)
  {
    v3 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
    if (v3)
    {
      v4 = v3;
      v5 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
      if (v5)
      {
        v6 = v5;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v4, v5);
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
        for (i = 0; i != Count; ++i)
        {
          v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v9)
          {
            v10 = v9;
            CFDictionaryAddValue(v9, CFSTR("VIRT_IF_NAME"), v4[i]);
            v11 = CFGetTypeID(v6[i]);
            v12 = sub_10002DE64();
            v13 = cf;
            if (v11 != v12 || (v13 = sub_10000E178((uint64_t)v6[i])) != 0)
              CFDictionaryAddValue(v10, CFSTR("VIRT_IF_ROLE"), v13);
            CFArrayAppendValue(Mutable, v10);
            CFRelease(v10);
          }
        }
        free(v6);
      }
      else
      {
        Mutable = 0;
      }
      free(v4);
      goto LABEL_14;
    }
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No virtual interfaces found");
    objc_autoreleasePoolPop(v15);
  }
  Mutable = 0;
LABEL_14:
  CFRelease(cf);
  return Mutable;
}

const void *sub_10000E178(uint64_t a1)
{
  const __CFDictionary *v1;

  if (a1 && (v1 = *(const __CFDictionary **)(a1 + 32)) != 0)
    return CFDictionaryGetValue(v1, CFSTR("VIRT_IF_ROLE"));
  else
    return 0;
}

double sub_10000E198(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  int ValueIfPresent;
  void *v8;
  void *v9;
  double result;
  void *v11;
  void *value;
  uint64_t v13;
  __int16 v14;
  __int16 v15;
  __int16 valuePtr;

  valuePtr = 0;
  v15 = 0;
  v14 = 0;
  value = 0;
  v13 = 0;
  v11 = 0;
  if (a1 && theDict)
  {
    v4 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RT_TRAFFIC_STATE"));
    if (v4)
      CFNumberGetValue(v4, kCFNumberSInt8Type, (char *)&valuePtr + 1);
    v5 = -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive");
    v6 = -[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen");
    if ((v5 & 1) == 0 && ((v6 & 1) != 0 || *(int *)(a1 + 2796) > -70))
      sub_1000246C0(a1);
    else
      sub_100043EF8(a1);
    ValueIfPresent = CFDictionaryGetValueIfPresent(theDict, CFSTR("QUAL_SCORE"), (const void **)&value);
    v8 = value;
    if (ValueIfPresent && value)
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("CHANQUAL_SCORE"), (const void **)&v11) && v11)
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt8Type, &valuePtr);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("TX_LATENCY_SCORE"), (const void **)&v11) && v11)
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt8Type, (char *)&v15 + 1);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("RX_LATENCY_SCORE"), (const void **)&v11) && v11)
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt8Type, &v15);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("TX_LOSS_SCORE"), (const void **)&v11) && v11)
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt8Type, (char *)&v14 + 1);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("RX_LOSS_SCORE"), (const void **)&v11) && v11)
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt8Type, &v14);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("P95_TX_LATENCY_SCORE"), (const void **)&v11)
        && v11)
      {
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, (char *)&v13 + 4);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("LINK_RECOMMENDATION_FLAGS"), (const void **)&v11)&& v11)
      {
        CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &v13);
      }
      v8 = value;
    }
    if (v8)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: channel score: chq=%u, tx-lat=%u, rx-lat=%u, tx-loss=%u, rx-loss=%u, txPer=%.1f%%, p95-lat=%u, RT=0x%x, link-recommendation=0x%x\n", "WiFiLQAMgrLinkRecommendationNotify", (char)valuePtr, SHIBYTE(v15), (char)v15, SHIBYTE(v14), (char)v14, *(float *)(a1 + 2960), HIDWORD(v13), HIBYTE(valuePtr), v13);
      objc_autoreleasePoolPop(v9);
      *(_BYTE *)(a1 + 2953) = valuePtr;
      *(_BYTE *)(a1 + 2954) = HIBYTE(v15);
      *(_BYTE *)(a1 + 2955) = v15;
      *(_BYTE *)(a1 + 2956) = HIBYTE(v14);
      *(_BYTE *)(a1 + 2957) = v14;
      *(_BYTE *)(a1 + 2952) = HIBYTE(valuePtr);
      *(_DWORD *)(a1 + 2944) = HIDWORD(v13);
      *(_DWORD *)(a1 + 2948) = v13;
    }
    else
    {
      result = 0.0;
      *(_OWORD *)(a1 + 2944) = 0u;
    }
  }
  return result;
}

void sub_10000E868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000E880(void *a1, void *a2, int a3, CFTypeRef a4)
{
  id v8;
  id v9;
  NSObject *v10;
  void *v11;
  _QWORD block[4];
  id v13[3];
  int v14;
  id location;

  v8 = objc_initWeak(&location, a2);

  if (!a2)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:SoftErrorManagerRef is NULL!", "WiFiSoftErrorManagerEvent");
    goto LABEL_14;
  }
  if (!a1)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "WiFiSoftErrorManagerEvent");
LABEL_14:
    objc_autoreleasePoolPop(v11);
    goto LABEL_9;
  }
  if (a3 == 4)
    goto LABEL_7;
  if (a3 != 12 && a3 != 6)
    goto LABEL_8;
  if (a4)
  {
LABEL_7:
    a4 = CFRetain(a4);
LABEL_8:
    v9 = objc_loadWeakRetained(&location);
    objc_msgSend(v9, "updateReportingPreference");

    v10 = qword_10026DD40;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000909C;
    block[3] = &unk_10022ECC8;
    objc_copyWeak(v13, &location);
    v14 = a3;
    v13[1] = a1;
    v13[2] = (id)a4;
    dispatch_async(v10, block);
    objc_destroyWeak(v13);
  }
LABEL_9:
  objc_destroyWeak(&location);
}

void sub_10000EA0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_10000EC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000ECB0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10000ECC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (a1 && a2 && a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate UCM\n", "WiFiDeviceManagerCatsUcmUpdate");
    objc_autoreleasePoolPop(v6);
    v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 4776);
    if (v7)
    {
      v7(a1, a2, a3);
      return;
    }
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: catsUcmUpdate callback is NULL!", "WiFiDeviceManagerCatsUcmUpdate");
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate UCM Invalid arguments", "WiFiDeviceManagerCatsUcmUpdate");
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10000EDC4(uint64_t a1, uint64_t a2, const void *a3, void *a4, int a5, uint64_t a6)
{
  uint64_t v7;
  CFTypeRef v9;
  CFTypeRef v10;
  const __CFDictionary *Value;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  unint64_t v19;
  id v20;
  uint64_t v21;
  void *i;
  id v23;
  void *v24;
  id v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  id v29;
  unint64_t v30;
  id v31;
  _BOOL4 v33;
  id v34;
  const __CFString *v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _DWORD context[2];
  CFTypeRef cf;
  CFTypeRef v43;
  const void *v44;
  uint64_t v45;
  uint64_t v46;

  if (!a3 || !a4)
    return;
  v7 = a6;
  context[1] = -1431655766;
  context[0] = a5;
  v43 = 0;
  v44 = 0;
  v45 = a1;
  v46 = a6;
  v9 = sub_100029868(kCFAllocatorDefault, a3);
  cf = v9;
  if (!v9)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: serialization failed for scan data: %@", "__WiFiManagerDispatchClientScanCacheUpdateEvent", a3);
    objc_autoreleasePoolPop(v12);
    goto LABEL_16;
  }
  v10 = v9;
  v43 = sub_100029868(kCFAllocatorDefault, a4);
  if (v43)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("scanRequest"));
    if (Value)
      v44 = CFDictionaryGetValue(Value, CFSTR("ScanReqClientPid"));
    CFSetApplyFunction(*(CFSetRef *)(v7 + 136), (CFSetApplierFunction)sub_10001472C, context);
    v10 = cf;
    if (!cf)
      goto LABEL_16;
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: serialization failed for trimmed scan data: %@", "__WiFiManagerDispatchClientScanCacheUpdateEvent", a4);
    objc_autoreleasePoolPop(v13);
  }
  CFRelease(v10);
  cf = 0;
LABEL_16:
  if (v43)
    CFRelease(v43);
  v14 = objc_autoreleasePoolPush();
  objc_msgSend(*(id *)(v7 + 192), "update80211dCountryCodes:", a4);
  objc_autoreleasePoolPop(v14);
  if (&_RDUpdateCountryCodeFromWiFiAPs)
  {
    v15 = objc_msgSend(a4, "objectForKey:", CFSTR("scanRequest"));
    v16 = objc_msgSend(a4, "objectForKey:", CFSTR("scanResults"));
    if (objc_msgSend(objc_msgSend(v15, "objectForKey:", CFSTR("SCAN_CHANNELS")), "count") != (id)1)
    {
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, context, 16);
      if (v17)
      {
        v18 = v17;
        v36 = v7;
        v19 = 0;
        v20 = 0;
        v21 = *(_QWORD *)v38;
        do
        {
          for (i = 0; i != v18; i = (char *)i + 1)
          {
            if (*(_QWORD *)v38 != v21)
              objc_enumerationMutation(v16);
            v23 = objc_msgSend(objc_msgSend(*(id *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i), "objectForKey:", CFSTR("80211D_IE")), "objectForKey:", CFSTR("IE_KEY_80211D_COUNTRY_CODE"));
            if (v23)
            {
              v24 = v23;
              if (!v20)
                v20 = objc_msgSend(objc_alloc((Class)NSCountedSet), "initWithCapacity:", 0);
              objc_msgSend(v20, "addObject:", objc_msgSend(v24, "uppercaseString"));
              ++v19;
            }
          }
          v18 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, context, 16);
        }
        while (v18);
        if (v19 < 3)
        {
          v35 = 0;
        }
        else
        {
          v25 = objc_msgSend(v20, "objectEnumerator");
          v26 = (const __CFString *)objc_msgSend(v25, "nextObject");
          if (v26)
          {
            v27 = v26;
            v28 = 0;
            v29 = 0;
            v30 = 0;
            do
            {
              v31 = objc_msgSend(v20, "countForObject:", v27);
              v33 = (unint64_t)v31 < 2 || (unint64_t)v31 < v30;
              if (v33)
                v34 = (id)v30;
              else
                v34 = v31;
              if (!v33)
              {
                v29 = (id)v30;
                v28 = v27;
              }
              v27 = (const __CFString *)objc_msgSend(v25, "nextObject");
              v30 = (unint64_t)v34;
            }
            while (v27);
          }
          else
          {
            v34 = 0;
            v29 = 0;
            v28 = 0;
          }
          if (v34 == v29)
            v35 = 0;
          else
            v35 = v28;
        }
        v7 = v36;
      }
      else
      {
        v20 = 0;
        v35 = 0;
      }
      sub_100093564(v7, v35, 0);

    }
  }
}

void sub_10000F2D0(int a1, const void *a2, uint64_t a3, CFDictionaryRef theDict)
{
  _BYTE *v7;
  double v8;
  double v9;
  int v10;
  double v11;
  double v12;
  double v13;
  unsigned int v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double Current;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  char v32;
  void *v33;
  const char *v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  void *v54;
  void *v55;
  void *v56;
  CFNumberRef v57;
  CFNumberRef v58;
  const __CFNumber *v59;
  const __CFNumber *v60;
  const __CFNumber *v61;
  void *v62;
  id v63;
  void *v64;
  CFNumberRef v65;
  void (*v66)(uint64_t, const void *, _QWORD, CFDictionaryRef);
  void (*v67)(uint64_t, const void *, _QWORD, _QWORD, CFDictionaryRef);
  int v68;
  float v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t valuePtr;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *value;
  void *v80[2];

  v69 = 0.0;
  if (!a3)
    return;
  v7 = (_BYTE *)(a3 + 7042);
  if (theDict)
  {
    if (!*(_BYTE *)(a3 + 7400) || !*(_BYTE *)(a3 + 8606) || *(_BYTE *)(a3 + 8608))
    {
LABEL_67:
      value = 0;
      v80[0] = 0;
      v77 = 0;
      v78 = 0;
      v74 = 0;
      v75 = 0;
      v72 = 0;
      valuePtr = 0;
      v71 = 0;
      v70 = 0;
      v35 = *(_QWORD *)(a3 + 3512);
      if (v35)
      {
        if (sub_10000BE8C(v35))
        {
          v76 = (void *)CFDictionaryGetValue(theDict, CFSTR("RSSI"));
          if (v76)
          {
            if (CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 736) >= 5.0 && *(_BYTE *)(a3 + 940))
            {
              ++*(_DWORD *)(a3 + 880);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXFAIL"), (const void **)&v75) && v75)
                CFNumberGetValue((CFNumberRef)v75, kCFNumberIntType, &v71);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("SNR"), (const void **)v80) && v80[0])
                CFNumberGetValue((CFNumberRef)v80[0], kCFNumberSInt32Type, (char *)&valuePtr + 4);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA"), (const void **)&value) && value)
                CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("RXRATE"), (const void **)&v77) && v77)
                CFNumberGetValue((CFNumberRef)v77, kCFNumberSInt32Type, &v72);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXRATE"), (const void **)&v78) && v78)
                CFNumberGetValue((CFNumberRef)v78, kCFNumberSInt32Type, (char *)&v72 + 4);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("RSSI"), (const void **)&v76) && v76)
                CFNumberGetValue((CFNumberRef)v76, kCFNumberSInt32Type, (char *)&v71 + 4);
              if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXFRAMES"), (const void **)&v74) && v74)
                CFNumberGetValue((CFNumberRef)v74, kCFNumberSInt32Type, &v70);
              v36 = HIDWORD(v72);
              v37 = *(_DWORD *)(a3 + 880);
              if (SHIDWORD(v72) >= 1)
              {
                v38 = *(_DWORD *)(a3 + 748);
                if (v38 >= SHIDWORD(v72))
                  v38 = HIDWORD(v72);
                *(_DWORD *)(a3 + 748) = v38;
                v39 = *(_DWORD *)(a3 + 752);
                if (v39 <= v36)
                  v39 = v36;
                *(_DWORD *)(a3 + 752) = v39;
                *(double *)(a3 + 760) = *(double *)(a3 + 760) + ((double)v36 - *(double *)(a3 + 760)) / (double)v37;
                *(_DWORD *)(a3 + 756) = v36;
              }
              v40 = v72;
              if ((int)v72 >= 1)
              {
                v41 = *(_DWORD *)(a3 + 768);
                if (v41 >= (int)v72)
                  v41 = v72;
                *(_DWORD *)(a3 + 768) = v41;
                v42 = *(_DWORD *)(a3 + 772);
                if (v42 <= v40)
                  v42 = v40;
                *(_DWORD *)(a3 + 772) = v42;
                *(double *)(a3 + 784) = *(double *)(a3 + 784) + ((double)v40 - *(double *)(a3 + 784)) / (double)v37;
                *(_DWORD *)(a3 + 776) = v40;
              }
              v43 = valuePtr;
              if ((int)valuePtr >= 1)
              {
                v44 = *(_DWORD *)(a3 + 840);
                if (v44 >= (int)valuePtr)
                  v44 = valuePtr;
                *(_DWORD *)(a3 + 840) = v44;
                v45 = *(_DWORD *)(a3 + 844);
                if (v45 <= v43)
                  v45 = v43;
                *(_DWORD *)(a3 + 844) = v45;
                *(double *)(a3 + 856) = *(double *)(a3 + 856) + ((double)v43 - *(double *)(a3 + 856)) / (double)v37;
                *(_DWORD *)(a3 + 848) = v43;
              }
              v46 = HIDWORD(valuePtr);
              if (SHIDWORD(valuePtr) >= 1)
              {
                v47 = *(_DWORD *)(a3 + 792);
                if (v47 >= SHIDWORD(valuePtr))
                  v47 = HIDWORD(valuePtr);
                *(_DWORD *)(a3 + 792) = v47;
                v48 = *(_DWORD *)(a3 + 796);
                if (v48 <= v46)
                  v48 = v46;
                *(_DWORD *)(a3 + 796) = v48;
                *(double *)(a3 + 808) = *(double *)(a3 + 808) + ((double)v46 - *(double *)(a3 + 808)) / (double)v37;
                *(_DWORD *)(a3 + 800) = v46;
              }
              v49 = HIDWORD(v71);
              if (v71 < 0)
              {
                v50 = *(_DWORD *)(a3 + 816);
                if (v50 >= SHIDWORD(v71))
                  v50 = HIDWORD(v71);
                *(_DWORD *)(a3 + 816) = v50;
                v51 = *(_DWORD *)(a3 + 820);
                if (v51 <= v49)
                  v51 = v49;
                *(_DWORD *)(a3 + 820) = v51;
                *(double *)(a3 + 832) = *(double *)(a3 + 832) + ((double)v49 - *(double *)(a3 + 832)) / (double)v37;
                *(_DWORD *)(a3 + 824) = v49;
              }
              v52 = v71;
              *(_DWORD *)(a3 + 4 * ((v37 - 1) % 0xC) + 888) = v71;
              if (v52)
              {
                v53 = *(_DWORD *)(a3 + 936) + 1;
                *(_DWORD *)(a3 + 936) = v53;
                if (v53 >= 3
                  && (*(double *)(a3 + 872) == 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 872) >= 60.0))
                {
                  ++*(_DWORD *)(a3 + 864);
                  v54 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: numberOfTxErrorEvents increased to %d", "__WiFiDeviceManagerTrackCarPlayLinkQuality", *(unsigned int *)(a3 + 864));
                  objc_autoreleasePoolPop(v54);
                  *(CFAbsoluteTime *)(a3 + 872) = CFAbsoluteTimeGetCurrent();
                }
              }
              if (*(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 880) % 0xCu) + 888))
                --*(_DWORD *)(a3 + 936);
              *(_QWORD *)(a3 + 944) += v70;
              v55 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rssi(max:min:avg:last) %d:%d:%d:%d, snr %d:%d:%d:%d, cca %d:%d:%d:%d, txRate %d:%d:%d:%d, rxRate %d:%d:%d:%d, numberOfTxErrorEvents %u, numberOfNoneZeroPer %u, roamedCount %u, totalTxFrames %llu", "__WiFiDeviceManagerTrackCarPlayLinkQuality", *(unsigned int *)(a3 + 820), *(unsigned int *)(a3 + 816), (int)*(double *)(a3 + 832), *(unsigned int *)(a3 + 824), *(unsigned int *)(a3 + 796), *(unsigned int *)(a3 + 792), (int)*(double *)(a3 + 808), *(unsigned int *)(a3 + 800), *(unsigned int *)(a3 + 844), *(unsigned int *)(a3 + 840), (int)*(double *)(a3 + 856), *(unsigned int *)(a3 + 848), *(unsigned int *)(a3 + 752),
                  *(unsigned int *)(a3 + 748),
                  (int)*(double *)(a3 + 760),
                  *(unsigned int *)(a3 + 756),
                  *(unsigned int *)(a3 + 772),
                  *(unsigned int *)(a3 + 768),
                  (int)*(double *)(a3 + 784),
                  *(unsigned int *)(a3 + 776),
                  *(unsigned int *)(a3 + 864),
                  *(unsigned int *)(a3 + 936),
                  *(unsigned int *)(a3 + 744),
                  *(_QWORD *)(a3 + 944));
              objc_autoreleasePoolPop(v55);
            }
          }
        }
      }
      goto LABEL_135;
    }
    value = 0;
    v80[0] = 0;
    v77 = 0;
    v78 = 0;
    v75 = 0;
    v76 = 0;
    valuePtr = 0;
    v74 = 0;
    v71 = 0;
    v72 = 0;
    v70 = 0;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("SNR"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA"), (const void **)&v78) && v78)
      CFNumberGetValue((CFNumberRef)v78, kCFNumberSInt32Type, &valuePtr);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXFRAMES"), (const void **)&v77) && v77)
      CFNumberGetValue((CFNumberRef)v77, kCFNumberSInt32Type, (char *)&v72 + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXFWFRAMES"), (const void **)v80) && v80[0])
      CFNumberGetValue((CFNumberRef)v80[0], kCFNumberSInt32Type, &v70);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("RXFRAMES"), (const void **)&v76) && v76)
      CFNumberGetValue((CFNumberRef)v76, kCFNumberSInt32Type, &v72);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("RXRATE"), (const void **)&v74) && v74)
      CFNumberGetValue((CFNumberRef)v74, kCFNumberSInt32Type, &v71);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("TXRATE"), (const void **)&v75) && v75)
      CFNumberGetValue((CFNumberRef)v75, kCFNumberSInt32Type, (char *)&v71 + 4);
    v8 = *(double *)(a3 + 8544);
    if (v8 == 0.0)
      v9 = (double)SHIDWORD(valuePtr);
    else
      v9 = v8 * 0.6 + (double)SHIDWORD(valuePtr) * 0.4;
    *(double *)(a3 + 8544) = v9;
    v10 = (int)v9;
    v11 = 1.0;
    if (v10 <= 39)
      v11 = *(double *)(a3 + 8 * (v10 & ~(v10 >> 31)) + 7408);
    v12 = *(double *)(a3 + 8552);
    if (v12 == 0.0)
      v13 = (double)(int)valuePtr;
    else
      v13 = v12 * 0.6 + (double)(int)valuePtr * 0.4;
    *(double *)(a3 + 8552) = v13;
    v14 = (int)v13 & ~((int)v13 >> 31);
    if (v14 >= 0x63)
      v14 = 99;
    v15 = *(double *)(a3 + 8 * v14 + 7728);
    v16 = *(double *)(a3 + 8560);
    if (v16 <= (double)SHIDWORD(v71))
      v16 = (double)SHIDWORD(v71);
    *(double *)(a3 + 8560) = v16;
    v17 = *(double *)(a3 + 8568);
    if (v17 <= (double)(int)v71)
      v17 = (double)(int)v71;
    *(double *)(a3 + 8568) = v17;
    v18 = v11 * v16;
    v19 = v11 * v17;
    v20 = *(double *)(a3 + 8528);
    if (v20 == 0.0)
      v21 = (double)(v70 + HIDWORD(v72));
    else
      v21 = v20 * 0.6 + (double)(v70 + HIDWORD(v72)) * 0.4;
    v22 = v15 * v18;
    v23 = v15 * v19;
    *(double *)(a3 + 8528) = v21;
    v24 = *(double *)(a3 + 8536);
    if (v24 == 0.0)
      v25 = (double)(int)v72;
    else
      v25 = v24 * 0.6 + (double)(int)v72 * 0.4;
    *(double *)(a3 + 8536) = v25;
    Current = CFAbsoluteTimeGetCurrent();
    v27 = Current - *(double *)(a3 + 8576);
    if (v27 <= 0.0)
      v27 = 5.0;
    *(double *)(a3 + 8576) = Current;
    v28 = *(double *)(a3 + 8528) * 800.0 * 8.0 / 1000.0 / v27;
    v29 = *(double *)(a3 + 8536) * 800.0 * 8.0 / 1000.0 / v27;
    if (v28 / (v22 + 0.01) <= 0.99)
      v30 = v28 / (v22 + 0.01);
    else
      v30 = 0.99;
    if (v29 / (v23 + 0.01) <= 0.99)
      v31 = v29 / (v23 + 0.01);
    else
      v31 = 0.99;
    v32 = 1;
    if (v30 <= 0.05 && v31 <= 0.05)
    {
      if (v30 >= 0.01 || v31 >= 0.01)
        goto LABEL_61;
      v32 = 0;
    }
    *(_BYTE *)(a3 + 8609) = v32;
LABEL_61:
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_BYTE *)(a3 + 8609))
        v34 = "Yes";
      else
        v34 = "No";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SNR %.1lf, CCA %.1lf, Tx bandwidth %.1lf (kbps), Rx bandwidth %.1lf, Tx data rate %.1lf (kbps), Rx data rate  %.1lf, Tx air time %.3lf %%, Rx air time %.3lf %%, Good background traffic ? %s", "__WiFiDeviceManagerMonitor24GHzInfraNetworkTraffic", *(_QWORD *)(a3 + 8544), *(_QWORD *)(a3 + 8552), *(_QWORD *)&v22, *(_QWORD *)&v23, *(_QWORD *)&v28, *(_QWORD *)&v29, v30 * 100.0, v31 * 100.0, v34);
    }
    objc_autoreleasePoolPop(v33);
    sub_1000FA884(a3, (uint64_t)a2);
    goto LABEL_67;
  }
LABEL_135:
  v56 = sub_10002A21C(a3, a2, 1);
  v69 = sub_100020E40(*(_QWORD *)(a3 + 120), v56, theDict, *v7 != 0);
  if (v69 != 0.0)
  {
    v57 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloatType, &v69);
    if (v57)
    {
      v58 = v57;
      CFDictionaryAddValue(theDict, CFSTR("SCALED_LQM"), v57);
      CFRelease(v58);
    }
  }
  if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance")
    && -[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
  {
    sub_1000247B8(*(_QWORD *)(a3 + 120), 1, 0);
  }
  v59 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RSSI"));
  if (v59)
  {
    CFNumberGetValue(v59, kCFNumberSInt32Type, (void *)(a3 + 6208));
    v60 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("CCA"));
    if (v60)
      CFNumberGetValue(v60, kCFNumberSInt8Type, (void *)(a3 + 6212));
    v61 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("SNR"));
    if (v61)
      CFNumberGetValue(v61, kCFNumberSInt16Type, (void *)(a3 + 6214));
    CFDictionaryRemoveValue(theDict, CFSTR("ROAM_STATE"));
    v62 = objc_autoreleasePoolPush();
    v63 = -[__CFDictionary objectForKey:](theDict, "objectForKey:", CFSTR("CCA_STATS"));
    if (v63)
    {
      v64 = v63;
      objc_msgSend(v63, "removeObjectForKey:", CFSTR("CCA_TIMESTAMP_TOTAL"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_SELF_TOTAL"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_OTHER_TOTAL"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_INTERFERENCE_TOTAL"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_TIMESTAMP_SLEEP"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_SELF_SLEEP"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_OTHER_SLEEP"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_INTERFERENCE_SLEEP"));
      objc_msgSend(v64, "removeObjectForKey:", CFSTR("CCA_TIMESTAMP_WAKE"));
    }
    objc_autoreleasePoolPop(v62);
    v68 = *(_DWORD *)(a3 + 6664);
    if (!v68 && *(unsigned __int16 *)(a3 + 6600) - 1 <= 1)
      v68 = 5;
    v65 = CFNumberCreate(0, kCFNumberIntType, &v68);
    CFDictionarySetValue(theDict, CFSTR("kLQM_HOME_WORK_STATUS"), v65);
    if (v65)
      CFRelease(v65);
    v66 = *(void (**)(uint64_t, const void *, _QWORD, CFDictionaryRef))(a3 + 4232);
    if (v66)
      v66(a3, a2, *(_QWORD *)(a3 + 4240), theDict);
    v67 = *(void (**)(uint64_t, const void *, _QWORD, _QWORD, CFDictionaryRef))(a3 + 4392);
    if (v67)
      v67(a3, a2, *(_QWORD *)(a3 + 4400), 0, theDict);
    sub_1000FE2A4(a3);
  }
  if (v56)
    CFRelease(v56);
}

void sub_10000FF08(uint64_t a1)
{
  const void *v2;

  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 136))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 128), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_10000FF58(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;
  NSObject *v4;
  void *v5;
  _QWORD block[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  if (a1)
  {
    if (cf)
    {
      v3 = CFRetain(cf);
      v8[3] = (uint64_t)v3;
    }
    v4 = *(NSObject **)(a1 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100011194;
    block[3] = &unk_10022F160;
    block[4] = &v7;
    block[5] = a1;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerForegroundAppChangeCallback");
    objc_autoreleasePoolPop(v5);
  }
  _Block_object_dispose(&v7, 8);
}

void sub_100010038(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

const __CFDictionary *sub_100010050(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFDictionary *Copy;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  void *v12;
  void *v13;
  void *v15;
  const char *v16;
  void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *Value;

  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    v15 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v16 = "%s: WiFiLQAMgrRef is NULL";
LABEL_10:
      v17 = v12;
      objc_msgSend(v15, "WFLog:message:", 4, v16, "WiFiLQAMgrCopyCoalescedUndispatchedLQMEvent");
      v12 = v17;
    }
LABEL_11:
    Copy = 0;
    goto LABEL_5;
  }
  v1 = *(const __CFDictionary **)(a1 + 152);
  if (!v1)
  {
    v12 = objc_autoreleasePoolPush();
    v15 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v16 = "%s: coalescedUndispatchedLQMEvent is NULL";
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v1);
  Value = CFDictionaryGetValue(Copy, CFSTR("RSSI"));
  v23 = CFDictionaryGetValue(Copy, CFSTR("CCA"));
  v22 = CFDictionaryGetValue(Copy, CFSTR("SNR"));
  v21 = CFDictionaryGetValue(Copy, CFSTR("TXFAIL"));
  v20 = CFDictionaryGetValue(Copy, CFSTR("TXFRAMES"));
  v19 = CFDictionaryGetValue(Copy, CFSTR("TXFWFRAMES"));
  v3 = CFDictionaryGetValue(Copy, CFSTR("TXFWFAIL"));
  v4 = CFDictionaryGetValue(Copy, CFSTR("TXRETRANS"));
  v5 = CFDictionaryGetValue(Copy, CFSTR("RXFRAMES"));
  v6 = CFDictionaryGetValue(Copy, CFSTR("RXRETRYFRMS"));
  v7 = CFDictionaryGetValue(Copy, CFSTR("RXBEACONFRMS"));
  v8 = CFDictionaryGetValue(Copy, CFSTR("RXBEACONSCHED"));
  v9 = CFDictionaryGetValue(Copy, CFSTR("RXRATE"));
  v10 = CFDictionaryGetValue(Copy, CFSTR("TXRATE"));
  v11 = CFDictionaryGetValue(Copy, CFSTR("TXFBRATE"));
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v18 = v5;
    v13 = v12;
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Rssi: %@ Snr:%@ Cca: %@ TxFrames: %@ TxFail: %@ BcnRx: %@ BcnSch: %@  RxFrames: %@ RxRetries: %@ TxRate: %@ RxRate: %@ FBRate: %@ TxFwFrms: %@ TxFwFail:%@ TxRetries: %@", "WiFiLQAMgrCopyCoalescedUndispatchedLQMEvent", Value, v22, v23, v20, v21, v7, v8, v18, v6, v10, v9, v11, v19,
      v3,
      v4);
    v12 = v13;
  }
LABEL_5:
  objc_autoreleasePoolPop(v12);
  return Copy;
}

void sub_1000102D0(uint64_t a1)
{
  _BOOL8 v2;
  void *v3;
  void *v4;
  uint64_t v5;
  const __CFArray *v6;
  const __CFArray *v7;
  void *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  void *v11;
  void *v12;
  id v13;
  const void *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFDictionary *MutableCopy;
  void *v18;
  __CFArray *Mutable;
  const __CFArray *Value;
  const __CFArray *v21;
  CFIndex v22;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v24;
  const __CFDate *v25;
  const __CFDate *v26;
  double Current;
  CFMutableDictionaryRef v28;
  CFMutableDictionaryRef v29;
  void *v30;
  uint64_t v31;
  const __CFArray *v32;
  const __CFArray *v33;
  const void *v34;
  const void *v35;
  CFAbsoluteTime v36;
  const __CFDate *v37;
  const __CFDictionary *v38;
  const __CFBoolean *v39;
  const __CFDate *v40;
  void *v41;
  void *v42;
  void *v43;
  const __CFArray *v44;
  const __CFArray *v45;
  const void *v46;
  const __CFArray *v47;
  const __CFArray *v48;
  CFStringRef v49;
  void *v50;
  double v51;
  double v52;
  double v53;
  void *v54;
  void *v55;
  void *v56;
  CFAbsoluteTime v57;
  const __CFDate *v58;
  const __CFDate *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  CFStringRef v64;
  void *v65;
  const __CFString *v66;
  void *v67;
  void *v68;
  const __CFArray *v69;
  CFIndex Count;
  CFIndex v71;
  CFIndex v72;
  BOOL v73;
  void *v74;
  void *v75;
  const __CFString *v76;
  const void *v77;
  void *v78;
  char v79;
  void *v80;
  void *v81;
  void *v82;
  const char *v83;
  void *v84;
  int v85;
  void *v86;
  char v87;
  uint64_t v88;
  _QWORD context[4];
  uint64_t v90;
  unint64_t v91;
  __CFArray *v92;
  uint64_t v93;

  ++*(_QWORD *)(a1 + 1496);
  if (*(_BYTE *)(a1 + 1328))
    goto LABEL_200;
  if (MKBUserUnlockedSinceBoot(0))
  {
    v2 = MKBGetDeviceLockState(0) == 1;
    v3 = objc_autoreleasePoolPush();
    v4 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      -[NSProcessInfo systemUptime](+[NSProcessInfo processInfo](NSProcessInfo, "processInfo"), "systemUptime");
      objc_msgSend(v4, "WFLog:message:", 3, "%s: First unlock polled %.2fs since boot", "__WiFiManagerHeartBeatFire", v5);
    }
    objc_autoreleasePoolPop(v3);
    sub_10008C888(a1, v2, 1);
  }
  if (*(_BYTE *)(a1 + 1328))
  {
LABEL_200:
    if (*(_QWORD *)(a1 + 240) <= 0x13uLL)
    {
      if (-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
      {
        v6 = *(const __CFArray **)(a1 + 224);
        if (!v6 || !CFArrayGetCount(v6))
        {
          sub_10008674C(a1);
          v7 = *(const __CFArray **)(a1 + 224);
          if (v7 && CFArrayGetCount(v7))
          {
            v8 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting %d known networks", "__WiFiManagerHeartBeatFire", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
            objc_autoreleasePoolPop(v8);
            sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
          }
          ++*(_QWORD *)(a1 + 240);
        }
      }
    }
    if (*(_BYTE *)(a1 + 1328))
    {
      if (*(_QWORD *)(a1 + 248) <= 0x13uLL)
      {
        v9 = *(const __CFArray **)(a1 + 352);
        if (!v9 || !CFArrayGetCount(v9))
        {
          sub_1000875B0(a1);
          v10 = *(const __CFArray **)(a1 + 352);
          if (v10 && CFArrayGetCount(v10))
          {
            v11 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting %d private Mac networks after %d attempts", "__WiFiManagerHeartBeatFire", CFArrayGetCount(*(CFArrayRef *)(a1 + 352)), *(_QWORD *)(a1 + 248));
            objc_autoreleasePoolPop(v11);
            sub_100087FE4(a1);
          }
          ++*(_QWORD *)(a1 + 248);
        }
      }
    }
  }
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000003ELL;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  -[WiFiUserInteractionMonitor runPeriodicTasks](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "runPeriodicTasks");
  if (*(_BYTE *)(a1 + 1208) || *(_BYTE *)(a1 + 1209))
  {
    v12 = *(void **)(a1 + 2520);
    if (v12 && (v13 = objc_msgSend(v12, "cellularICCID")) != 0)
    {
      v14 = v13;
      v15 = sub_1000A5F44((_QWORD *)a1);
      if (v15)
      {
        v16 = v15;
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v15);
        CFRelease(v16);
      }
      else
      {
        MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, v14);
      if (Value)
      {
        v21 = Value;
        if (CFArrayGetCount(Value) >= 1)
        {
          v22 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v22);
            if (ValueAtIndex)
            {
              v24 = ValueAtIndex;
              v25 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DataUsageDate"));
              if (!v25
                || (v26 = v25, Current = CFAbsoluteTimeGetCurrent(), Current - CFDateGetAbsoluteTime(v26) <= 5356800.0))
              {
                v28 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v24);
                if (v28)
                {
                  v29 = v28;
                  CFArrayAppendValue(Mutable, v28);
                  CFRelease(v29);
                }
              }
            }
            ++v22;
          }
          while (v22 < CFArrayGetCount(v21));
        }
      }
      v90 = a1;
      v91 = 0xAAAAAAAA00000065;
      v92 = Mutable;
      v93 = 0;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &v90);
      CFDictionarySetValue(MutableCopy, v14, Mutable);
      -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", MutableCopy, CFSTR("InterfaceDataUsageV1"));
      if (Mutable)
        CFRelease(Mutable);
      if (MutableCopy)
        CFRelease(MutableCopy);
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to retrieve ICCID.", "__WiFiManagerRunDataUsageCheck");
      objc_autoreleasePoolPop(v18);
    }
  }
  if (MGGetBoolAnswer(CFSTR("apple-internal-install"))
    && !*(_BYTE *)(a1 + 2288)
    && *(double *)(a1 + 2280) != 0.0
    && *(_BYTE *)(a1 + 2276))
  {
    v51 = CFAbsoluteTimeGetCurrent();
    v52 = *(double *)(a1 + 2280);
    v53 = v51 <= v52 ? v52 - v51 : v51 - v52;
    if (!*(_BYTE *)(a1 + 314) || v53 > 1800.0)
    {
      v54 = *(void **)(a1 + 1480);
      if (objc_msgSend(v54, "isMegaWiFiProfileInstalled"))
      {
        objc_msgSend(v54, "uninstallMegaWiFiProfile");
        v55 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MegaWiFiProfile has been uninstalled, charging=%d timeElapsed=%d", "__WiFiManagerHeartBeatFire", *(unsigned __int8 *)(a1 + 314), (int)v53);
        objc_autoreleasePoolPop(v55);
      }
      *(_QWORD *)(a1 + 2280) = 0;
      *(_BYTE *)(a1 + 2276) = 0;
    }
  }
  if (!*(_BYTE *)(a1 + 528)
    && -[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted")&& MKBUserUnlockedSinceBoot(0) == 1)
  {
    *(_BYTE *)(a1 + 528) = 1;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : kWiFiPrivateMacFirstUnlockAfterSWUpgrade is : <%hhu>", "__WiFiManagerHeartBeatFire", *(unsigned __int8 *)(a1 + 528));
    objc_autoreleasePoolPop(v30);
  }
  v31 = *(_QWORD *)(a1 + 1496);
  if (__ROR8__(0xAAAAAAAAAAAAAAABLL * v31, 1) <= 0x2AAAAAAAAAAAAAAAuLL)
  {
    sub_100007FDC(a1, 1, 0, 0);
    v90 = a1;
    v91 = 0xAAAAAAAA0000003DLL;
    v92 = 0;
    v93 = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &v90);
    v31 = *(_QWORD *)(a1 + 1496);
  }
  if (__ROR8__(0xAAAAAAAAAAAAAAABLL * v31, 2) > 0x1555555555555555uLL)
    return;
  if (!sub_1000A24A0((const __CFArray *)a1))
  {
    v32 = sub_100009CDC((CFArrayRef)a1);
    if (v32)
    {
      v33 = v32;
      v34 = CFArrayGetValueAtIndex(v32, 0);
      v35 = (const void *)sub_100025C3C((uint64_t)v34);
      sub_100012924(a1, v35, 1);
      CFRelease(v33);
    }
  }
  v36 = CFAbsoluteTimeGetCurrent();
  v37 = CFDateCreate(kCFAllocatorDefault, v36);
  if (+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"))
  {
    v38 = (const __CFDictionary *)-[WiFiSoftApUsageMonitor statsDictionary](+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"), "statsDictionary");
    v39 = (const __CFBoolean *)CFDictionaryGetValue(v38, kSoftApStatsValid);
    if (v39)
    {
      if (v39 == kCFBooleanTrue)
      {
        v40 = (const __CFDate *)CFDictionaryGetValue(v38, kSoftApOldestActiveTime);
        if (v40)
        {
          if (CFDateGetTimeIntervalSinceDate(v37, v40) >= 1209600.0)
            -[WiFiSoftApUsageMonitor resetStats](+[WiFiSoftApUsageMonitor sharedInstance](WiFiSoftApUsageMonitor, "sharedInstance"), "resetStats");
        }
      }
    }
  }
  if (v37)
    CFRelease(v37);
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Check for networks with deleted keychain password, count: %ld", "WiFiManagerCheckDeletedPasswordNetworks", CFArrayGetCount(*(CFArrayRef *)(a1 + 2528)));
  objc_autoreleasePoolPop(v41);
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 2528)) < 1)
    goto LABEL_118;
  v42 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2528), 0);
  v43 = objc_autoreleasePoolPush();
  if (!v42)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networkWithDeletedKeychainPassword", "WiFiManagerCheckDeletedPasswordNetworks");
    goto LABEL_117;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Checking network %@ to see if we need to prompt for the missing password TTR", "WiFiManagerCheckDeletedPasswordNetworks", sub_10002B088(v42));
  objc_autoreleasePoolPop(v43);
  v44 = sub_10000B29C((CFArrayRef)a1);
  if (!v44)
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device managers array", "WiFiManagerCheckDeletedPasswordNetworks");
LABEL_117:
    objc_autoreleasePoolPop(v43);
LABEL_118:
    v45 = 0;
LABEL_119:
    v49 = 0;
    v48 = 0;
    goto LABEL_120;
  }
  v45 = v44;
  v46 = CFArrayGetValueAtIndex(v44, 0);
  if (!v46)
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device manager", "WiFiManagerCheckDeletedPasswordNetworks");
    objc_autoreleasePoolPop(v86);
    goto LABEL_119;
  }
  v47 = sub_100103A48((uint64_t)v46, v42);
  if (!v47)
  {
    v56 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network %@ is no longer in the known networks list. No need to remember it for missing password purposes. ", "WiFiManagerCheckDeletedPasswordNetworks", sub_10002B088(v42));
    objc_autoreleasePoolPop(v56);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 2528));
    goto LABEL_119;
  }
  v48 = v47;
  v49 = sub_1000C37A0((CFDictionaryRef *)v42);
  if (sub_1000C5964((uint64_t)v42) && v49)
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Password for %@ is now present in the keychain. No need to remember it for missing password purposes", "WiFiManagerCheckDeletedPasswordNetworks", sub_10002B088(v42));
    objc_autoreleasePoolPop(v50);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 2528));
  }
  else
  {
    v57 = CFAbsoluteTimeGetCurrent();
    v58 = CFDateCreate(kCFAllocatorDefault, v57);
    v59 = (const __CFDate *)sub_1000CA3FC((uint64_t)v42);
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Checking password mod date %@ against current time", "WiFiManagerCheckDeletedPasswordNetworks", v59);
    objc_autoreleasePoolPop(v60);
    if (v59 && CFDateGetTimeIntervalSinceDate(v58, v59) > 900.0)
    {
      v61 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is present in known networks and its password has not been in the keychain for > %d seconds in the keychain. Prompting user for TTR", "WiFiManagerCheckDeletedPasswordNetworks", sub_10002B088(v42), 900);
      objc_autoreleasePoolPop(v61);
      *(_QWORD *)(a1 + 2536) = v42;
      if (sub_100159B4C(a1 + 2536))
      {
        v62 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: User accepted the TTR prompt. Removing all entries from the networksWithDeletedKeychainPassword array", "WiFiManagerCheckDeletedPasswordNetworks");
        objc_autoreleasePoolPop(v62);
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 2528));
      }
    }
    if (v58)
      CFRelease(v58);
  }
LABEL_120:
  v63 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: End of deleted password network checks, network count: %ld", "WiFiManagerCheckDeletedPasswordNetworks", CFArrayGetCount(*(CFArrayRef *)(a1 + 2528)));
  objc_autoreleasePoolPop(v63);
  if (v45)
    CFRelease(v45);
  if (v49)
    CFRelease(v49);
  if (v48)
    CFRelease(v48);
  if (*(_BYTE *)(a1 + 2552))
    return;
  v64 = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u);
  LOBYTE(v90) = 0;
  LOBYTE(context[0]) = 0;
  v65 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Start", "WiFiManagerMigrateWiFiKeychainEntries");
  objc_autoreleasePoolPop(v65);
  if (*(_BYTE *)(a1 + 2552))
  {
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Empty account name password migration already completed", "WiFiManagerMigrateWiFiKeychainEntries");
    v87 = 0;
LABEL_197:
    objc_autoreleasePoolPop(v68);
    *(_BYTE *)(a1 + 2552) = v87;
    if (!v64)
      return;
    goto LABEL_160;
  }
  v66 = (const __CFString *)sub_1000D7AA0(v64, (BOOL *)&v90, 0.1);
  v67 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: passwordFetchTimedOut: %d", "WiFiManagerMigrateWiFiKeychainEntries", v90);
  objc_autoreleasePoolPop(v67);
  if ((_BYTE)v90)
  {
    v78 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Empty account name password fetch timed out", "WiFiManagerMigrateWiFiKeychainEntries");
    v77 = 0;
    v79 = 0;
    goto LABEL_154;
  }
  v68 = objc_autoreleasePoolPush();
  if (!v66)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No AirPort keychain entry with an empty account name. Migration complete.", "WiFiManagerMigrateWiFiKeychainEntries");
    v87 = 1;
    goto LABEL_197;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: emptyStringAccountPassword is: %s", "WiFiManagerMigrateWiFiKeychainEntries", "non-null");
  objc_autoreleasePoolPop(v68);
  v69 = *(const __CFArray **)(a1 + 224);
  if (v69 && CFArrayGetCount(v69))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 224));
    if (Count < 1)
    {
      v77 = 0;
    }
    else
    {
      v71 = Count;
      v72 = 0;
      v73 = 1;
      while (1)
      {
        v74 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 224), v72);
        if (v74)
        {
          v75 = v74;
          if (sub_1000CB2D0((uint64_t)v74) == 1 && sub_1000C5964((uint64_t)v75))
          {
            v76 = (const __CFString *)sub_10002B088(v75);
            if (CFStringCompare(v76, v64, 0) == kCFCompareEqualTo)
              break;
          }
        }
        v73 = ++v72 < v71;
        if (v71 == v72)
        {
          v77 = 0;
          goto LABEL_151;
        }
      }
      v80 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Found network profile with empty string account name: %@", "WiFiManagerMigrateWiFiKeychainEntries", sub_1000C3C04(v75));
      objc_autoreleasePoolPop(v80);
      v81 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Checking if empty-string account password has already been migrated", "WiFiManagerMigrateWiFiKeychainEntries");
      objc_autoreleasePoolPop(v81);
      v77 = (const void *)sub_1000C6348((CFDictionaryRef *)v75, (BOOL *)&v90, 0.1);
      v82 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v83 = "non-null";
        if (!v77)
          v83 = "null";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: attempted migrated password fetch returned, passwordFetchTimedOut: %d, migratedPassword is: %s", "WiFiManagerMigrateWiFiKeychainEntries", v90, v83);
      }
      objc_autoreleasePoolPop(v82);
      if ((_BYTE)v90)
      {
        v84 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: password fetch for %@ timed out", "WiFiManagerMigrateWiFiKeychainEntries", sub_1000C3C04(v75));
        objc_autoreleasePoolPop(v84);
        if (v73)
        {
LABEL_174:
          v79 = 0;
LABEL_155:
          *(_BYTE *)(a1 + 2552) = v79;
          if (!v66)
            goto LABEL_157;
          goto LABEL_156;
        }
      }
      else
      {
        if (v77)
        {
          v78 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: keychain entry for %@ already present, migration complete", "WiFiManagerMigrateWiFiKeychainEntries", sub_1000C3C04(v75));
          goto LABEL_153;
        }
        sub_1000C6458(v75, v66, (BOOL *)context, 0.1);
        v85 = LOBYTE(context[0]);
        v78 = objc_autoreleasePoolPush();
        v77 = (const void *)qword_10026DD20;
        if (!v85)
        {
          if (qword_10026DD20)
          {
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: password for %@ successfully migrated", "WiFiManagerMigrateWiFiKeychainEntries", sub_1000C3C04(v75));
            v77 = 0;
          }
          goto LABEL_153;
        }
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Attempted password set/migration for %@ timed out", "WiFiManagerMigrateWiFiKeychainEntries", sub_1000C3C04(v75));
        objc_autoreleasePoolPop(v78);
        v77 = 0;
        if (v73)
          goto LABEL_174;
      }
    }
LABEL_151:
    v78 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No known network matched criteria for empty-account migration", "WiFiManagerMigrateWiFiKeychainEntries", v88);
LABEL_153:
    v79 = 1;
LABEL_154:
    objc_autoreleasePoolPop(v78);
    goto LABEL_155;
  }
  v77 = 0;
  *(_BYTE *)(a1 + 2552) = 0;
LABEL_156:
  CFRelease(v66);
LABEL_157:
  if (v77)
    CFRelease(v77);
  if (v64)
LABEL_160:
    CFRelease(v64);
}

void sub_100011194(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const void *v4;
  _QWORD v5[4];

  if (-[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen"))
  {
    v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = *(_QWORD *)(a1 + 40);
  v5[1] = 0xAAAAAAAA0000006ALL;
  v5[2] = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 24);
  v5[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(v5[0] + 104), (CFSetApplierFunction)sub_10002E0D4, v5);
  v4 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_100011244(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  int v5;
  const __CFNumber *v6;
  int v7;
  int v8;
  const __CFNumber *v9;
  int v10;
  int v11;
  const __CFNumber *v12;
  int v13;
  int v14;
  const __CFNumber *v15;
  int v16;
  int v17;
  const __CFNumber *v18;
  int v19;
  int v20;
  const __CFNumber *v21;
  int v22;
  int v23;
  const __CFNumber *v24;
  int v25;
  int v26;
  const __CFNumber *v27;
  int v28;
  int v29;
  const __CFNumber *v30;
  int v31;
  int v32;
  const __CFNumber *v33;
  int v34;
  int v35;
  double v36;
  float v37;
  void *v38;
  void *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t valuePtr;

  v44 = 0;
  valuePtr = 0;
  v42 = 0;
  v43 = 0;
  v41 = 0;
  v40 = 0;
  if (theDict)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LQM_TX_STATS_TX_SUCCESS"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      v5 = HIDWORD(valuePtr);
    }
    else
    {
      v5 = 0;
    }
    v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_DROP_MISC"));
    if (v6)
    {
      CFNumberGetValue(v6, kCFNumberSInt32Type, (char *)&v44 + 4);
      v7 = HIDWORD(v44);
    }
    else
    {
      v7 = 0;
    }
    v8 = v7 + v5;
    v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_NO_BUFF"));
    if (v9)
    {
      CFNumberGetValue(v9, kCFNumberSInt32Type, &v44);
      v10 = v44;
    }
    else
    {
      v10 = 0;
    }
    v11 = v8 + v10;
    v12 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_NO_RESOURCE"));
    if (v12)
    {
      CFNumberGetValue(v12, kCFNumberSInt32Type, (char *)&v43 + 4);
      v13 = HIDWORD(v43);
    }
    else
    {
      v13 = 0;
    }
    v14 = v11 + v13;
    v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_NO_ACK"));
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberSInt32Type, &v43);
      v16 = v43;
    }
    else
    {
      v16 = 0;
    }
    v17 = v14 + v16;
    v18 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_CHIP_MODE_ERROR"));
    if (v18)
    {
      CFNumberGetValue(v18, kCFNumberSInt32Type, (char *)&v42 + 4);
      v19 = HIDWORD(v42);
    }
    else
    {
      v19 = 0;
    }
    v20 = v17 + v19;
    v21 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_EXPIRED"));
    if (v21)
    {
      CFNumberGetValue(v21, kCFNumberSInt32Type, &v42);
      v22 = v42;
    }
    else
    {
      v22 = 0;
    }
    v23 = v20 + v22;
    v24 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_FAIL"));
    if (v24)
    {
      CFNumberGetValue(v24, kCFNumberSInt32Type, &valuePtr);
      v25 = valuePtr;
    }
    else
    {
      v25 = 0;
    }
    v26 = v23 + v25;
    v27 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_FW_FREE_PACKET"));
    if (v27)
    {
      CFNumberGetValue(v27, kCFNumberSInt32Type, (char *)&v41 + 4);
      v28 = HIDWORD(v41);
    }
    else
    {
      v28 = 0;
    }
    v29 = v26 + v28;
    v30 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_MAX_RETRIES"));
    if (v30)
    {
      CFNumberGetValue(v30, kCFNumberSInt32Type, &v41);
      v31 = v41;
    }
    else
    {
      v31 = 0;
    }
    v32 = v29 + v31;
    v33 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("APPLE80211KEY_LQM_TX_STATS_TX_FORCE_LIFETIME_EXPIRED"));
    if (v33)
    {
      CFNumberGetValue(v33, kCFNumberSInt32Type, &v40);
      v34 = v40;
    }
    else
    {
      v34 = 0;
    }
    v35 = v32 + v34;
    if (v35)
    {
      v36 = (double)v35;
      v37 = (double)(v35 - HIDWORD(valuePtr)) / (double)v35 * 100.0;
      *(float *)(a1 + 2960) = v37;
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "LQM-TX: Success:%d(%.1f%%) FwFail:%d(%.1f%%) FwMaxRetries:%d(%.1f%%) NoACK:%d(%.1f%%) MiscDrops:%d(%.1f%%) NoBuf:%d(%.1f%%) FwNoRes:%d(%.1f%%) ChipErr:%d(%.1f%%) Exp:%d(%.1f%%) FwFcdExpiry:%d(%.1f%%) FwFree:%d(%.1f%%)", HIDWORD(valuePtr), (double)SHIDWORD(valuePtr) / v36 * 100.0, valuePtr, (double)(int)valuePtr / v36 * 100.0, v41, (double)(int)v41 / v36 * 100.0, v43, (double)(int)v43 / v36 * 100.0, HIDWORD(v44), (double)SHIDWORD(v44) / v36 * 100.0, v44, (double)(int)v44 / v36 * 100.0, HIDWORD(v43), (double)SHIDWORD(v43) / v36 * 100.0,
          HIDWORD(v42),
          (double)SHIDWORD(v42) / v36 * 100.0,
          v42,
          (double)(int)v42 / v36 * 100.0,
          v40,
          (double)v40 / v36 * 100.0,
          HIDWORD(v41),
          (double)SHIDWORD(v41) / v36 * 100.0);
      objc_autoreleasePoolPop(v38);
    }
    else
    {
      *(_DWORD *)(a1 + 2960) = 0;
    }
  }
  else
  {
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: txStatsRef is null", "WiFiLQAMgrLqmTxNotify");
    objc_autoreleasePoolPop(v39);
  }
}

void sub_100011654(uint64_t *a1, CFTypeRef cf)
{
  const void *v4;
  void *v5;
  void *v6;

  if (a1)
  {
    v4 = (const void *)a1[25];
    if (v4)
    {
      CFRelease(v4);
      a1[25] = 0;
    }
    if (cf)
      a1[25] = (uint64_t)CFRetain(cf);
    sub_100011864(a1[15], cf);
    sub_100011724((uint64_t)a1, 1, cf);
    v5 = (void *)a1[921];
    if (v5)
      objc_msgSend(v5, "setCurrentApplicationName:withAttributes:", cf, 0);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager.", "WiFiDeviceManagerSetForegroundAppBundleId");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_100011724(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  if (a1 && *(_BYTE *)(a1 + 433))
  {
    if ((_DWORD)a2 == 1)
    {
      if (!sub_100011778(a1, cf))
        return;
      a2 = 1;
    }
    sub_100024EE4(a1, a2);
  }
}

BOOL sub_100011778(uint64_t a1, CFTypeRef cf)
{
  int v4;
  int v5;
  const void *v6;
  CFTypeRef v7;
  void *v8;

  v4 = cf != 0;
  v5 = *(unsigned __int8 *)(a1 + 456);
  v6 = *(const void **)(a1 + 448);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 448) = 0;
  }
  if (cf)
  {
    v7 = CFRetain(cf);
  }
  else
  {
    v7 = 0;
    v4 = 0;
  }
  *(_QWORD *)(a1 + 448) = v7;
  *(_BYTE *)(a1 + 456) = v4;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS %@:  deviceManager:%p FgApp:%@ stateChange:%d whitelisted=%d\n", "WifiDeviceManagerCatsWhitelistedApp", sub_10002570C(a1), a1, *(_QWORD *)(a1 + 448), v5 != v4, cf != 0);
  objc_autoreleasePoolPop(v8);
  return v5 != v4;
}

void sub_100011864(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (a1)
  {
    v4 = *(const void **)(a1 + 208);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 208) = 0;
    }
    if (cf)
      *(_QWORD *)(a1 + 208) = CFRetain(cf);
  }
}

uint64_t sub_1000118A8(uint64_t a1)
{
  const __CFArray *v2;
  int Count;
  int v4;
  CFIndex v5;
  uint64_t v6;
  uint64_t v7;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  void *v10;
  void *v11;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
    return 0;
  v2 = *(const __CFArray **)(a1 + 24);
  if (!v2)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrGetLongWindowRSSI");
    goto LABEL_23;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Current Network is NULL", "__WiFiLQAMgrGetLongWindowRSSI");
    goto LABEL_23;
  }
  Count = CFArrayGetCount(v2);
  v4 = Count;
  if (!Count)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: No LQM reports available", "__WiFiLQAMgrGetLongWindowRSSI");
LABEL_23:
    objc_autoreleasePoolPop(v11);
    return 0;
  }
  if (Count < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = Count;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v5);
    if (!ValueAtIndex)
      break;
    Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RSSI"));
    if (!Value)
      goto LABEL_15;
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v6 = (valuePtr + v6);
    if (v7 == ++v5)
    {
      if (!v4)
        return v6;
      return ((int)v6 / v4);
    }
  }
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM Report at %d index is NULL", "__WiFiLQAMgrGetLongWindowRSSI", v5);
  objc_autoreleasePoolPop(v10);
LABEL_15:
  v4 = v5;
  if ((_DWORD)v5)
    return ((int)v6 / v4);
  return v6;
}

void sub_100011A50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v5)(uint64_t, _QWORD);
  uint64_t msg;
  mach_msg_header_t *v7;

  switch(a2)
  {
    case 8:
      dispatch_release(*(dispatch_object_t *)(a1 + 72));
      CFRelease((CFTypeRef)a1);
      break;
    case 7:
      msg = dispatch_mach_msg_get_msg(a3, 0);
      mach_port_mod_refs(mach_task_self_, *(_DWORD *)(msg + 12), 1u, -1);
      break;
    case 2:
      if (*(_DWORD *)(dispatch_mach_msg_get_msg(a3, 0) + 20) == 70)
      {
        v5 = *(void (**)(uint64_t, _QWORD))(a1 + 96);
        if (v5)
          v5(a1, *(_QWORD *)(a1 + 104));
      }
      else if ((dispatch_mach_mig_demux(0, &off_100231348, 1, a3) & 1) == 0)
      {
        v7 = (mach_msg_header_t *)dispatch_mach_msg_get_msg(a3, 0);
        mach_msg_destroy(v7);
      }
      break;
  }
}

void sub_100011B3C(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  void *v6;
  const __CFNumber *Value;
  void *v8;
  void *v9;
  unsigned __int8 valuePtr;

  v6 = objc_autoreleasePoolPush();
  if (a1 && a2 && a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate Scan Manager\n", "WiFiDeviceManagerCatsScanUpdate");
    objc_autoreleasePoolPop(v6);
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("CATS_APP_PRIORITY"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
      *(_BYTE *)(a2 + 416) = valuePtr;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate appPolicy=%d", "WiFiDeviceManagerCatsScanUpdate", valuePtr);
      objc_autoreleasePoolPop(v8);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate APPLE80211KEY_CATS_APP_PRIORITY key not found", "WiFiDeviceManagerCatsScanUpdate");
      objc_autoreleasePoolPop(v9);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate Scan Manager Invalid arguments", "WiFiDeviceManagerCatsScanUpdate");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_100011C94(_BYTE *a1, uint64_t a2, CFDictionaryRef theDict)
{
  const __CFDictionary *v3;
  void *v6;
  const __CFNumber *v7;
  float v8;
  CFNumberRef v9;
  CFNumberRef v10;
  __CFDictionary *MutableCopy;
  __CFDictionary *v12;
  const __CFNumber *v13;
  const __CFDictionary *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  _WORD *v17;
  int v18;
  CFAbsoluteTime Current;
  CFDateRef v20;
  CFNumberRef v21;
  const void **v22;
  double v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  void *v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  unint64_t v36;
  void *v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  void *v42;
  unsigned int v43;
  _QWORD *v44;
  unsigned int v45;
  unsigned int v46;
  double *v47;
  double v48;
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  double v54;
  double *v55;
  uint64_t v56;
  void *v57;
  void (*v58)(_BYTE *, uint64_t, _QWORD, __CFDictionary *);
  CFDateRef v59;
  void *v60;
  void *v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  CFDictionaryRef theDicta;
  void *value;
  void *v67;
  CFNumberRef v68;
  CFNumberRef v69;
  int v70;
  uint64_t valuePtr;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  CFNumberRef v75;
  CFNumberRef number;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;

  valuePtr = 0;
  v70 = 0;
  v68 = 0;
  v69 = 0;
  v67 = 0;
  if (!theDict)
  {
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqmDict is null", "__WiFiDeviceProcessRSSIEvent");
    objc_autoreleasePoolPop(v60);
    return;
  }
  v3 = theDict;
  if (a1[208])
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Hijacking the RSSI event with simulated link:%@", "__WiFiDeviceProcessRSSIEvent", *((_QWORD *)a1 + 27));
    objc_autoreleasePoolPop(v6);
    v3 = (const __CFDictionary *)*((_QWORD *)a1 + 27);
  }
  v7 = (const __CFNumber *)CFDictionaryGetValue(v3, CFSTR("RSSI"));
  if (!v7)
    return;
  CFNumberGetValue(v7, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  v8 = sub_100031420(SHIDWORD(valuePtr));
  *(float *)&valuePtr = v8;
  *((_DWORD *)a1 + 66) = HIDWORD(valuePtr);
  *((float *)a1 + 67) = v8;
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloatType, &valuePtr);
  if (!v9)
  {
    v61 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scaledRSSINumRef", "__WiFiDeviceProcessRSSIEvent");
    objc_autoreleasePoolPop(v61);
    return;
  }
  v10 = v9;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v3);
  if (!MutableCopy)
  {
    v62 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null lqmMutableDict", "__WiFiDeviceProcessRSSIEvent");
    objc_autoreleasePoolPop(v62);
    v59 = v10;
    goto LABEL_131;
  }
  v12 = MutableCopy;
  CFDictionaryAddValue(MutableCopy, CFSTR("SCALED_RSSI"), v10);
  theDicta = 0;
  value = 0;
  a1[307] = 0;
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("CCA"), (const void **)&value))
  {
    v13 = (const __CFNumber *)value;
    if (value)
    {
      a1[308] = 0;
      CFNumberGetValue(v13, kCFNumberSInt8Type, a1 + 308);
      a1[307] = 1;
    }
  }
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("CCA_STATS"), (const void **)&theDicta))
  {
    v14 = theDicta;
    if (theDicta)
    {
      v77 = 0;
      v75 = 0;
      number = 0;
      *(_WORD *)(a1 + 309) = 0;
      a1[311] = 0;
      if (CFDictionaryGetValueIfPresent(v14, CFSTR("CCA_SELF_TOTAL"), (const void **)&v77) && v77)
        CFNumberGetValue((CFNumberRef)v77, kCFNumberSInt8Type, a1 + 309);
      if (CFDictionaryGetValueIfPresent(theDicta, CFSTR("CCA_OTHER_TOTAL"), (const void **)&number) && number)
        CFNumberGetValue(number, kCFNumberSInt8Type, a1 + 310);
      if (CFDictionaryGetValueIfPresent(theDicta, CFSTR("CCA_INTERFERENCE_TOTAL"), (const void **)&v75) && v75)
        CFNumberGetValue(v75, kCFNumberSInt8Type, a1 + 311);
      if (!a1[307])
      {
        a1[308] = a1[310] + a1[309] + a1[311];
        a1[307] = 1;
      }
    }
  }
  a1[272] = 0;
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("SNR"), (const void **)&v69))
  {
    v15 = v69;
    if (v69)
    {
      *((_QWORD *)a1 + 35) = 0;
      CFNumberGetValue(v15, kCFNumberSInt16Type, &v70);
      *((_QWORD *)a1 + 35) = (__int16)v70;
      a1[272] = 1;
      CFDictionaryAddValue(v12, CFSTR("SNR"), v69);
    }
  }
  a1[288] = 0;
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("NOISE"), (const void **)&v68))
  {
    v16 = v68;
    if (v68)
    {
      *((_QWORD *)a1 + 37) = 0;
      CFNumberGetValue(v16, kCFNumberSInt16Type, (char *)&v70 + 2);
      *((_QWORD *)a1 + 37) = SHIWORD(v70);
      a1[288] = 1;
      CFDictionaryAddValue(v12, CFSTR("NOISE"), v68);
    }
  }
  v17 = a1 + 305;
  v63 = 0;
  v64 = 0;
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("PER_CORE_RSSI"), (const void **)&v67))
  {
    v18 = sub_100024E48((const __CFArray *)v67, &v64, &v63);
    a1[304] = v18;
    if (v18)
    {
      *v17 = 0;
      a1[305] = v64;
      a1[306] = v63;
      CFDictionaryAddValue(v12, CFSTR("PER_CORE_RSSI"), v67);
    }
  }
  else
  {
    a1[304] = 0;
  }
  if (CFDictionaryGetValueIfPresent(v3, CFSTR("PER_CORE_NOISE"), (const void **)&v67) && v67)
    CFDictionaryAddValue(v12, CFSTR("PER_CORE_NOISE"), v67);
  Current = CFAbsoluteTimeGetCurrent();
  v20 = CFDateCreate(kCFAllocatorDefault, Current);
  if (v20)
    CFDictionaryAddValue(v12, CFSTR("LQMTIMESTAMP"), v20);
  v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 4316);
  CFDictionaryAddValue(v12, CFSTR("WiFiIPState"), v21);
  v22 = (const void **)&kCFBooleanTrue;
  if (!a1[4312])
    v22 = (const void **)&kCFBooleanFalse;
  CFDictionaryAddValue(v12, CFSTR("WiFiHasNoGatewayIP"), *v22);
  if (v21)
    CFRelease(v21);
  v23 = CFAbsoluteTimeGetCurrent();
  v24 = a1 + 312;
  v25 = *((_QWORD *)a1 + 161);
  v26 = *((_QWORD *)a1 + 160);
  if (v26)
  {
    v27 = v25 - 1;
    if (!v25)
      v27 = 29;
    v28 = v23 - *(double *)&v24[32 * v27 + 24];
    v29 = -v28;
    if (v28 >= 0.0)
      v29 = v23 - *(double *)&v24[32 * v27 + 24];
    if (v29 < 1.0)
    {
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Too frequent(%f secs) rssi event from driver, ignore updating RSSI in RSSI history\n", *(_QWORD *)&v28);
LABEL_114:
      objc_autoreleasePoolPop(v30);
      goto LABEL_125;
    }
  }
  if (v25 == 30)
    v25 = 0;
  v31 = &v24[32 * v25];
  v32 = *((_QWORD *)a1 + 37);
  *(_QWORD *)v31 = *((int *)a1 + 66);
  *((_QWORD *)v31 + 1) = v32;
  *((_QWORD *)v31 + 2) = *((_QWORD *)a1 + 35);
  *((double *)v31 + 3) = v23;
  if (v26 > 29)
  {
    if (v25 == *((_QWORD *)a1 + 159))
    {
      if (v25 == 29)
        v33 = 0;
      else
        v33 = v25 + 1;
      *((_QWORD *)a1 + 159) = v33;
    }
  }
  else
  {
    *((_QWORD *)a1 + 160) = v26 + 1;
  }
  *((_QWORD *)a1 + 161) = v25 + 1;
  v34 = CFAbsoluteTimeGetCurrent();
  v79 = 0;
  v80 = 0;
  v77 = 0;
  v78 = 0;
  v75 = 0;
  number = 0;
  v73 = 0;
  v74 = 0;
  v72 = 0;
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("TXFRAMES"), (const void **)&number) && number)
    CFNumberGetValue(number, kCFNumberIntType, &v80);
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("TXFAIL"), (const void **)&v77) && v77)
    CFNumberGetValue((CFNumberRef)v77, kCFNumberIntType, (char *)&v80 + 4);
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("RXBEACONFRMS"), (const void **)&v75) && v75)
    CFNumberGetValue(v75, kCFNumberIntType, (char *)&v79 + 4);
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("RXBEACONSCHED"), (const void **)&v74) && v74)
    CFNumberGetValue(v74, kCFNumberIntType, &v79);
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("TXFWFAIL"), (const void **)&v73) && v73)
    CFNumberGetValue(v73, kCFNumberIntType, (char *)&v78 + 4);
  if (CFDictionaryGetValueIfPresent(v12, CFSTR("TXFWFRAMES"), (const void **)&v72) && v72)
    CFNumberGetValue(v72, kCFNumberIntType, &v78);
  v36 = *((_QWORD *)a1 + 499);
  if (v36 >= 0x1F)
  {
    v37 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Invalid currIndx %ld. Resetting!\n", "__WiFiDeviceUpdateTransmitReceiveHistory", *((_QWORD *)a1 + 499));
    objc_autoreleasePoolPop(v37);
    goto LABEL_84;
  }
  if (v36 == 30)
  {
LABEL_84:
    v36 = 0;
    *((_QWORD *)a1 + 499) = 0;
  }
  v38 = a1 + 2304;
  v39 = *((_QWORD *)a1 + 498);
  if (!v39)
    goto LABEL_94;
  v40 = v36 - 1;
  if (!v36)
    v40 = 29;
  v41 = v34 - *(double *)&v38[56 * v40 + 48];
  v35 = -v41;
  if (v41 >= 0.0)
    v35 = v34 - *(double *)&v38[56 * v40 + 48];
  if (v35 < 1.0)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Too frequent(%f secs) LQM event from driver, ignore updating txrx history\n", *(_QWORD *)&v41);
    objc_autoreleasePoolPop(v42);
  }
  else
  {
LABEL_94:
    v43 = v80;
    v44 = &v38[56 * v36];
    *v44 = v80;
    v45 = v78;
    v44[2] = v78;
    v46 = v79;
    v44[4] = v79;
    if (v43)
    {
      LODWORD(v35) = HIDWORD(v80);
      v35 = (double)*(unint64_t *)&v35 / (double)v43 * 100.0;
      v43 = (int)v35;
    }
    v38[56 * v36 + 8] = v43;
    if (v45)
    {
      LODWORD(v35) = HIDWORD(v78);
      v45 = (int)((double)*(unint64_t *)&v35 / (double)v45 * 100.0);
    }
    v38[56 * v36 + 24] = v45;
    if (v46)
    {
      if (v46 > HIDWORD(v79))
        v46 = (int)((double)(v46 - HIDWORD(v79)) / (double)v46 * 100.0);
      else
        LOBYTE(v46) = 0;
    }
    v47 = (double *)&v38[56 * v36];
    *((_BYTE *)v47 + 40) = v46;
    v47[6] = v34;
    if (v39 <= 29)
      *((_QWORD *)a1 + 498) = v39 + 1;
    *((_QWORD *)a1 + 499) = v36 + 1;
  }
  if (CFDictionaryContainsKey(v12, CFSTR("PER_CORE_RSSI")))
  {
    v48 = CFAbsoluteTimeGetCurrent();
    v49 = a1 + 1296;
    v50 = *((_QWORD *)a1 + 224);
    v51 = *((_QWORD *)a1 + 223);
    if (v51)
    {
      v52 = v50 - 1;
      if (!v50)
        v52 = 29;
      v53 = v48 - *(double *)&v49[16 * v52 + 8];
      v54 = -v53;
      if (v53 >= 0.0)
        v54 = v48 - *(double *)&v49[16 * v52 + 8];
      if (v54 < 1.0)
      {
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Too frequent(%f secs) per-Core Rssi event from driver, ignore updating Core0, Core1 RSSI in Per Core RSSI History\n", *(_QWORD *)&v53);
        goto LABEL_114;
      }
    }
    if (v50 == 30)
      v50 = 0;
    v55 = (double *)&v49[16 * v50];
    *(_WORD *)v55 = *v17;
    v55[1] = v48;
    if (v51 > 29)
    {
      if (v50 == *((_QWORD *)a1 + 222))
      {
        if (v50 == 29)
          v56 = 0;
        else
          v56 = v50 + 1;
        *((_QWORD *)a1 + 222) = v56;
      }
    }
    else
    {
      *((_QWORD *)a1 + 223) = v51 + 1;
    }
    *((_QWORD *)a1 + 224) = v50 + 1;
  }
LABEL_125:
  v57 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Feeding RSSI data to LQM - RSSI:%d Core0-RSSI:%d Core1-RSSI:%d \n", "__WiFiDeviceProcessRSSIEvent", *((unsigned int *)a1 + 66), (char)a1[305], (char)a1[306]);
  objc_autoreleasePoolPop(v57);
  v58 = (void (*)(_BYTE *, uint64_t, _QWORD, __CFDictionary *))*((_QWORD *)a1 + 605);
  if (v58)
    v58(a1, a2, *((_QWORD *)a1 + 606), v12);
  CFRelease(v10);
  CFRelease(v12);
  if (v20)
  {
    v59 = v20;
LABEL_131:
    CFRelease(v59);
  }
}

void sub_100012660(uint64_t a1, CFDictionaryRef theDict)
{
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v5;
  CFMutableDictionaryRef Mutable;
  uint64_t i;
  __CFString *v8;
  BOOL v9;
  BOOL v10;
  CFNumberRef v11;
  const void *v12;
  CFMutableDictionaryRef v13;
  void *v14;
  void *v15;
  int v16;
  CFNumberRef number;
  int valuePtr;
  void *value;

  if (a1)
  {
    if (theDict)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
      if (MutableCopy)
      {
        v5 = MutableCopy;
        if (*(_QWORD *)(a1 + 152)
          || (Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks), (*(_QWORD *)(a1 + 152) = Mutable) != 0))
        {
          for (i = 0; i != 9; ++i)
          {
            value = 0;
            valuePtr = 0;
            v8 = off_10022F068[i];
            if (CFDictionaryGetValueIfPresent(theDict, v8, (const void **)&value))
              v9 = value == 0;
            else
              v9 = 1;
            if (!v9)
            {
              CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
              number = 0;
              v16 = 0;
              if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 152), v8, (const void **)&number))
                v10 = number == 0;
              else
                v10 = 1;
              if (!v10)
                CFNumberGetValue(number, kCFNumberIntType, &v16);
              v16 += valuePtr;
              v11 = CFNumberCreate(0, kCFNumberIntType, &v16);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 152), v8, v11);
              CFDictionarySetValue(v5, v8, v11);
              if (v11)
                CFRelease(v11);
            }
          }
          v12 = *(const void **)(a1 + 152);
          if (v12)
          {
            CFRelease(v12);
            *(_QWORD *)(a1 + 152) = 0;
          }
          v13 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v5);
          *(_QWORD *)(a1 + 152) = v13;
          if (v13)
            goto LABEL_25;
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s coalescedUndispatchedLQMEvent is NULL!!!", "WiFiLQAMgrCoalesceUndispatchedLQMEvent");
        }
        else
        {
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: coalescedUndispatchedLQMEvent create failed", "WiFiLQAMgrCoalesceUndispatchedLQMEvent");
        }
        objc_autoreleasePoolPop(v14);
LABEL_25:
        CFRelease(v5);
        return;
      }
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqmDictCopy is NULL", "WiFiLQAMgrCoalesceUndispatchedLQMEvent");
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqmDict is NULL", "WiFiLQAMgrCoalesceUndispatchedLQMEvent");
    }
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrCoalesceUndispatchedLQMEvent");
  }
  objc_autoreleasePoolPop(v15);
}

void sub_100012924(uint64_t a1, const void *a2, int a3)
{
  __CFArray *Mutable;
  const __SCPreferences *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex v9;
  const __SCNetworkSet *ValueAtIndex;
  const __SCNetworkSet *v11;
  CFStringRef SetID;
  CFStringRef Name;
  _BOOL4 v14;
  const __CFDictionary *v15;
  int v16;
  BOOL v17;
  _BOOL4 v18;
  void *v19;
  void *v20;
  char v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFIndex v24;
  int v25;
  const __SCNetworkService *v26;
  const __SCNetworkService *v27;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v29;
  CFStringRef BSDName;
  CFStringRef InterfaceType;
  CFStringRef v32;
  int v33;
  int v34;
  int v35;
  void *v36;
  BOOL v37;
  void *v38;
  const __CFArray *v39;
  CFIndex v40;
  const __SCNetworkInterface *v41;
  const __SCNetworkInterface *v42;
  CFStringRef v43;
  CFStringRef v44;
  CFStringRef v45;
  int v46;
  int v47;
  int v48;
  void *v49;
  void *v50;
  BOOL v51;
  const __SCNetworkInterface *v52;
  const __SCPreferences *v53;
  int v54;
  void *v55;
  const char *v56;
  const char *v57;
  const __SCNetworkInterface *v58;
  CFIndex v59;
  const __SCNetworkSet *v60;
  const __SCNetworkSet *v61;
  const __SCNetworkService *v62;
  const __SCNetworkService *v63;
  int v64;
  void *v65;
  void *v66;
  const char *v67;
  CFStringRef v68;
  CFStringRef ServiceID;
  CFStringRef v70;
  void *v71;
  void *v72;
  void *v73;
  const char *v74;
  uint64_t v75;
  id v76;
  SCPreferencesRef prefs;
  uint64_t v78;
  CFMutableArrayRef theArray;
  const __CFArray *v80;
  BOOL v82;
  const __SCNetworkInterface *cf2;
  const void *v84;
  BOOL v85;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v78 = a1;
  v6 = *(const __SCPreferences **)(a1 + 1064);
  v84 = a2;
  v76 = (id)sub_10001E1C8((uint64_t)"WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
  if (!a2)
  {
    v71 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null ifName.", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
    objc_autoreleasePoolPop(v71);
    if (Mutable)
      goto LABEL_105;
    goto LABEL_106;
  }
  if (!Mutable)
  {
    v72 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scSetsToModify.", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
    objc_autoreleasePoolPop(v72);
    goto LABEL_106;
  }
  if (!v6)
  {
    v73 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null preferences.", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
    goto LABEL_136;
  }
  if (!sub_100007620(v6))
  {
    v73 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: prefLock failed", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
LABEL_136:
    objc_autoreleasePoolPop(v73);
    goto LABEL_105;
  }
  prefs = v6;
  v7 = SCNetworkSetCopyAll(v6);
  v8 = v7;
  if (!v7)
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scSets.", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
    v39 = 0;
    goto LABEL_89;
  }
  theArray = Mutable;
  v80 = v7;
  if (CFArrayGetCount(v7) < 1)
    goto LABEL_66;
  v9 = 0;
  while (2)
  {
    ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v8, v9);
    if (!ValueAtIndex)
      goto LABEL_60;
    v11 = ValueAtIndex;
    SetID = SCNetworkSetGetSetID(ValueAtIndex);
    Name = SCNetworkSetGetName(v11);
    if (Name)
    {
      v14 = CFEqual(CFSTR("Automatic"), Name) != 0;
      if (!SetID)
        goto LABEL_24;
    }
    else
    {
      v14 = 0;
      if (!SetID)
        goto LABEL_24;
    }
    v15 = *(const __CFDictionary **)(v78 + 208);
    if (v15)
    {
      v16 = CFDictionaryContainsValue(v15, SetID);
      v17 = v16 != 0;
      if (v16)
        v18 = v14;
      else
        v18 = 0;
      if (v18)
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network set %@ is in both automatic and custom network sets", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SetID);
        objc_autoreleasePoolPop(v19);
        v17 = 1;
      }
      if (!v14)
        goto LABEL_25;
      goto LABEL_22;
    }
LABEL_24:
    v17 = 0;
    if (!v14)
    {
LABEL_25:
      v21 = !v17;
      if (a3)
        v21 = 1;
      if ((v21 & 1) != 0)
        goto LABEL_60;
      v20 = objc_autoreleasePoolPush();
      v82 = v14;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: examining <%@> network set %@ for a network service matching BSD name %@ and interface type %@", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", Name, SetID, v84, kSCNetworkInterfaceTypeIEEE80211);
      goto LABEL_30;
    }
LABEL_22:
    v20 = objc_autoreleasePoolPush();
    v82 = v14;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: examining <Automatic> network set %@ for a network service matching BSD name %@ and interface type %@", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SetID, v84, kSCNetworkInterfaceTypeIEEE80211, v75);
LABEL_30:
    objc_autoreleasePoolPop(v20);
    v22 = SCNetworkSetCopyServices(v11);
    v23 = v22;
    if (!v22 || CFArrayGetCount(v22) < 1)
      goto LABEL_62;
    v24 = 0;
    v25 = 1;
    do
    {
      v26 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v23, v24);
      if (v26)
      {
        v27 = v26;
        Interface = SCNetworkServiceGetInterface(v26);
        if (Interface)
        {
          v29 = Interface;
          BSDName = SCNetworkInterfaceGetBSDName(Interface);
          InterfaceType = SCNetworkInterfaceGetInterfaceType(v29);
          v32 = InterfaceType;
          if (!BSDName)
          {
            if (!InterfaceType)
              goto LABEL_53;
            v35 = CFEqual(InterfaceType, kSCNetworkInterfaceTypeIEEE80211);
            goto LABEL_49;
          }
          v33 = CFEqual(BSDName, v84);
          v34 = v33;
          if (v32)
          {
            v35 = CFEqual(v32, kSCNetworkInterfaceTypeIEEE80211);
            if (v34 && v35)
            {
              v36 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: FOUND network service %@ with matching BSD name %@ and interface type %@", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SCNetworkServiceGetServiceID(v27), BSDName, v32);
              v25 = 0;
LABEL_52:
              objc_autoreleasePoolPop(v36);
              goto LABEL_53;
            }
            if (v34)
            {
LABEL_47:
              v36 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network service %@ with matching BSD name %@ but interface type %@ is present", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SCNetworkServiceGetServiceID(v27), BSDName, v32);
              goto LABEL_52;
            }
LABEL_49:
            if (!v35)
              goto LABEL_53;
            v36 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network service %@ with matching interface type %@ but BSD name %@ is present", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SCNetworkServiceGetServiceID(v27), v32, BSDName);
            goto LABEL_52;
          }
          if (v33)
            goto LABEL_47;
        }
      }
LABEL_53:
      ++v24;
    }
    while (v24 < CFArrayGetCount(v23));
    if (!v25)
    {
      if (v23)
        goto LABEL_56;
      goto LABEL_57;
    }
LABEL_62:
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ADDING examined network set to list for adding WiFi network service", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent");
    objc_autoreleasePoolPop(v38);
    CFArrayAppendValue(Mutable, v11);
    if (v23)
LABEL_56:
      CFRelease(v23);
LABEL_57:
    v37 = v82;
    if (!a3)
      v37 = 0;
    v8 = v80;
    if (!v37)
    {
LABEL_60:
      if (++v9 >= CFArrayGetCount(v8))
        break;
      continue;
    }
    break;
  }
LABEL_66:
  if (!CFArrayGetCount(Mutable))
  {
    v51 = 0;
    v39 = 0;
    goto LABEL_91;
  }
  v39 = SCNetworkInterfaceCopyAll();
  if (CFArrayGetCount(v39) < 1)
    goto LABEL_86;
  v40 = 0;
  while (2)
  {
    v41 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v39, v40);
    if (!v41)
    {
LABEL_85:
      if (++v40 >= CFArrayGetCount(v39))
        goto LABEL_86;
      continue;
    }
    break;
  }
  v42 = v41;
  v43 = SCNetworkInterfaceGetBSDName(v41);
  v44 = SCNetworkInterfaceGetInterfaceType(v42);
  v45 = v44;
  if (!v43)
  {
    if (!v44 || !CFEqual(v44, kSCNetworkInterfaceTypeIEEE80211))
      goto LABEL_85;
    goto LABEL_79;
  }
  v46 = CFEqual(v43, v84);
  v47 = v46;
  if (!v45)
  {
    if (v46)
      goto LABEL_82;
    goto LABEL_85;
  }
  v48 = CFEqual(v45, kSCNetworkInterfaceTypeIEEE80211);
  if (!v47 || !v48)
  {
    if (v47)
    {
LABEL_82:
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network interface %@ with matching BSD name %@ but interface type %@ is present", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SCNetworkInterfaceGetLocalizedDisplayName(v42), v43, v45);
    }
    else
    {
      if (!v48)
        goto LABEL_85;
LABEL_79:
      v49 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network interface %@ with matching interface type %@ but BSD name %@ is present", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", SCNetworkInterfaceGetLocalizedDisplayName(v42), v45, v43);
    }
    objc_autoreleasePoolPop(v49);
    goto LABEL_85;
  }
  v58 = (const __SCNetworkInterface *)CFRetain(v42);
  if (!v58)
  {
LABEL_86:
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to find any SC network interface matching BSD name %@ and interface type %@", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", v84, kSCNetworkInterfaceTypeIEEE80211);
    v8 = v80;
LABEL_89:
    objc_autoreleasePoolPop(v50);
    v51 = 0;
LABEL_91:
    v52 = 0;
LABEL_92:
    v53 = prefs;
    goto LABEL_93;
  }
  v52 = v58;
  if (CFArrayGetCount(Mutable) < 1)
  {
    v51 = 0;
    v8 = v80;
    goto LABEL_92;
  }
  v59 = 0;
  v85 = 0;
  v8 = v80;
  v53 = prefs;
  cf2 = v52;
  do
  {
    v60 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(Mutable, v59);
    if (v60)
    {
      v61 = v60;
      v62 = SCNetworkServiceCreate(v53, v52);
      v63 = v62;
      if (v62)
      {
        SCNetworkServiceSetName(v62, CFSTR("Wi-Fi by wifid"));
        SCNetworkServiceEstablishDefaultConfiguration(v63);
        v64 = SCNetworkSetAddService(v61, v63);
        v85 = (v85 | v64) != 0;
      }
      else
      {
        v64 = 0;
      }
      v65 = objc_autoreleasePoolPush();
      v66 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        if (v64)
          v67 = "success";
        else
          v67 = "failure";
        v68 = SCNetworkServiceGetName(v63);
        ServiceID = SCNetworkServiceGetServiceID(v63);
        v70 = SCNetworkSetGetName(v61);
        v74 = v67;
        v53 = prefs;
        objc_msgSend(v66, "WFLog:message:", 4, "%s: %s ADDING <%@> network service %@ to <%@> network set %@", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", v74, v68, ServiceID, v70, SCNetworkSetGetSetID(v61), v76);
      }
      objc_autoreleasePoolPop(v65);
      if (v63)
        CFRelease(v63);
      Mutable = theArray;
      v8 = v80;
      v52 = cf2;
    }
    ++v59;
  }
  while (v59 < CFArrayGetCount(Mutable));
  v51 = v85;
LABEL_93:
  v54 = sub_1000076D4(v53, v51);
  v55 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v56 = "changes";
    if (!v51)
      v56 = "no changes";
    v57 = "successfully";
    if (!v54)
      v57 = "unsuccessfully";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s committed, prefs %s unlocked", "WiFiManagerHelperInsertWiFiServiceToNetworkSetsIfNotPresent", v56, v57);
  }
  objc_autoreleasePoolPop(v55);
  if (v52)
    CFRelease(v52);
  if (v39)
    CFRelease(v39);
  if (v8)
    CFRelease(v8);
LABEL_105:
  CFRelease(Mutable);
LABEL_106:

}

void sub_1000132CC(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  id v5;
  void *v6;
  const __CFNumber *Value;
  void *v8;
  const __CFNumber *v9;
  void *v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  _QWORD v19[5];
  _QWORD v20[5];
  _QWORD v21[5];
  _QWORD v22[5];
  _QWORD v23[5];
  uint64_t v24;
  unsigned __int8 valuePtr;

  if (!a1 || !a2 || !a3)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate P2P Invalid arguments", "WiFiDeviceManagerCatsP2PUpdate");
    goto LABEL_23;
  }
  v5 = +[WiFiP2PSPITransactionRequestor shared](WiFiP2PSPITransactionRequestor, "shared");
  if (!v5)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fails to create WiFiP2PSPITransactionRequestor", "WiFiDeviceManagerCatsP2PUpdate");
    goto LABEL_23;
  }
  v6 = v5;
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("CATS_APP_PRIORITY"));
  if (!Value)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate APPLE80211KEY_CATS_APP_PRIORITY key not found", "WiFiDeviceManagerCatsP2PUpdate");
LABEL_23:
    objc_autoreleasePoolPop(v14);
    return;
  }
  CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate appPolicy (%d -> %d)", "WiFiDeviceManagerCatsP2PUpdate", *(unsigned __int8 *)(a2 + 435), valuePtr);
  objc_autoreleasePoolPop(v8);
  v24 = 0;
  v9 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("CATS_APP_BITMAP"));
  if (v9)
  {
    CFNumberGetValue(v9, kCFNumberLongLongType, &v24);
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate appBitMap (0x%llx -> 0x%llx)", "WiFiDeviceManagerCatsP2PUpdate", *(_QWORD *)(a2 + 440), v24);
    objc_autoreleasePoolPop(v10);
    v11 = (v24 ^ *(_DWORD *)(a2 + 440)) & 0x40;
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate coPresenceBitChanged = %d", "WiFiDeviceManagerCatsP2PUpdate", v11 >> 6);
    objc_autoreleasePoolPop(v12);
    if (*(unsigned __int8 *)(a2 + 435) != valuePtr || v11)
    {
      v13 = 2;
      switch(*(_BYTE *)(a2 + 435))
      {
        case 0:
          v13 = 3;
          goto LABEL_31;
        case 1:
          goto LABEL_31;
        case 2:
          if ((*(_BYTE *)(a2 + 440) & 0x40) != 0)
            v13 = 12;
          else
            v13 = 1;
          goto LABEL_31;
        case 3:
          v13 = 12;
LABEL_31:
          objc_msgSend(v6, "endTransaction:", v13);
          switch(valuePtr)
          {
            case 0u:
              v20[0] = _NSConcreteStackBlock;
              v20[1] = 3221225472;
              v20[2] = sub_100140B10;
              v20[3] = &unk_100231C30;
              v20[4] = a2;
              v16 = v20;
              v17 = v6;
              v18 = 3;
              goto LABEL_39;
            case 1u:
              v21[0] = _NSConcreteStackBlock;
              v21[1] = 3221225472;
              v21[2] = sub_100030D14;
              v21[3] = &unk_100231C30;
              v21[4] = a2;
              v16 = v21;
              v17 = v6;
              v18 = 2;
              goto LABEL_39;
            case 2u:
              if ((v24 & 0x40) != 0)
              {
                v23[0] = _NSConcreteStackBlock;
                v23[1] = 3221225472;
                v23[2] = sub_100140AF0;
                v23[3] = &unk_100231C30;
                v23[4] = a2;
                v16 = v23;
LABEL_38:
                v17 = v6;
                v18 = 12;
              }
              else
              {
                v22[0] = _NSConcreteStackBlock;
                v22[1] = 3221225472;
                v22[2] = sub_100140B00;
                v22[3] = &unk_100231C30;
                v22[4] = a2;
                v16 = v22;
                v17 = v6;
                v18 = 1;
              }
LABEL_39:
              objc_msgSend(v17, "beginTransaction:completionHandler:", v18, v16);
              break;
            case 3u:
              v19[0] = _NSConcreteStackBlock;
              v19[1] = 3221225472;
              v19[2] = sub_100140B20;
              v19[3] = &unk_100231C30;
              v19[4] = a2;
              v16 = v19;
              goto LABEL_38;
            default:
              return;
          }
          break;
        default:
          return;
      }
    }
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate APPLE80211KEY_CATS_APP_BITMAP key not found", "WiFiDeviceManagerCatsP2PUpdate");
    objc_autoreleasePoolPop(v15);
  }
}

void sub_1000136E8(_QWORD *a1)
{
  CFTypeID v2;
  uint64_t v3;
  const void *v4;

  if (a1)
  {
    v2 = CFGetTypeID(a1);
    v3 = qword_10026D6C8;
    if (!qword_10026D6C8)
    {
      pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
      v3 = qword_10026D6C8;
    }
    if (v2 == v3)
    {
      v4 = (const void *)a1[2];
      if (v4)
      {
        CFRelease(v4);
        a1[2] = 0;
      }
    }
  }
}

id sub_100013754(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void *v4;
  const void *v5;

  v2 = *(_QWORD *)(a1 + 8888);
  if (v2 != 5)
  {
    v3 = (const void *)sub_100025C3C(*(_QWORD *)(a1 + 64));
    v4 = sub_10002A21C(a1, v3, 1);
    if (v4)
    {
      v5 = v4;
      if (sub_10001395C((uint64_t)v4))
      {
        v2 = 4;
      }
      else if (sub_1000137D8((uint64_t)v5))
      {
        v2 = 4;
      }
      else
      {
        v2 = 3;
      }
      CFRelease(v5);
    }
  }
  return objc_msgSend(*(id *)(a1 + 8824), "setRetrySchedule:", v2);
}

BOOL sub_1000137D8(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IsHotspot")) == kCFBooleanTrue
      || sub_100013840(a1)
      || sub_10002DA5C(a1);
}

BOOL sub_100013840(uint64_t a1)
{
  if (sub_10002BE64(a1, CFSTR("DomainName")))
    return 0;
  if (sub_10002BE64(a1, CFSTR("IsHotspot")) == kCFBooleanTrue
    || &_CNForgetSSID
    && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue
    || sub_10002C798(a1, 18)
    || sub_10002C798(a1, 23))
  {
    return 1;
  }
  return sub_100013900(a1) != 0;
}

const __CFDictionary *sub_100013900(uint64_t a1)
{
  const __CFDictionary *result;
  char valuePtr;

  valuePtr = 0;
  result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("11U_INTERWORKING_IE"));
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("INTERWORKING_ACCESS_NETWORK_TYPE"));
    if (result)
    {
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      return (const __CFDictionary *)((valuePtr & 0xFE) == 2);
    }
  }
  return result;
}

uint64_t sub_10001395C(uint64_t a1)
{
  const void *v2;
  CFTypeID v3;
  const void *Value;
  uint64_t result;
  void *v6;
  void *v7;
  void *v8;
  const void *v9;
  CFTypeID v10;
  unsigned __int8 *v11;
  CFIndex Length;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network.", "WiFiNetworkIsApplePersonalHotspot", v16);
    goto LABEL_11;
  }
  v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null network record.", "WiFiNetworkIsApplePersonalHotspot", v16);
    goto LABEL_11;
  }
  v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad record type %ld", "WiFiNetworkIsApplePersonalHotspot", CFGetTypeID(*(CFTypeRef *)(a1 + 16)));
    v7 = v8;
    goto LABEL_15;
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IsPersonalHotspot"));
  if (Value && CFEqual(Value, kCFBooleanTrue))
    return 1;
  result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("IE"));
  if (!result)
    return result;
  v9 = (const void *)result;
  v10 = CFGetTypeID((CFTypeRef)result);
  if (v10 != CFDataGetTypeID())
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad ieList type %ld", "__WiFiNetworkIsAppleDevice", CFGetTypeID(v9));
LABEL_11:
    v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return 0;
  }
  result = (uint64_t)CFDataGetBytePtr((CFDataRef)v9);
  if (result)
  {
    v11 = (unsigned __int8 *)result;
    Length = CFDataGetLength((CFDataRef)v9);
    if (Length << 32 >= 1)
    {
      v13 = 0;
      while (*v11 != 221 || v11[1] != 10 || *(_DWORD *)(v11 + 2) != 116528896 || *(_DWORD *)(v11 + 5) != 50397446)
      {
        v15 = v11[1] + 2;
        v13 += v15;
        v11 += v15;
        if (v13 >= (int)Length)
          return 0;
      }
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_100013B90(uint64_t a1, uint64_t a2)
{
  int v4;
  char v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  _BOOL4 v14;
  char v15;
  char v16;
  int v17;
  char v18;
  int v19;
  _BOOL4 v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  const char *v27;
  const char *v28;
  CFMutableStringRef v29;
  CFMutableStringRef v30;
  void *v31;
  void *v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  int v36;
  const __CFString *v37;
  const __CFString *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  const void **v42;
  int v43;
  unsigned int v44;
  void *v45;
  const __CFString *v46;
  const __CFString *v47;
  const char *v48;
  const char *v49;
  char v50;
  _BOOL4 v51;
  int v52;
  char v53;
  _BOOL4 v54;
  char v55;
  char v56;
  unint64_t v57;
  uint64_t context;
  unint64_t v59;
  unint64_t *v60;
  uint64_t v61;

  if (!*(_BYTE *)(a1 + 2217))
    sub_10008C6C0(a1);
  v4 = *(_DWORD *)(a1 + 788);
  if (v4 == 2)
  {
    v5 = 0;
  }
  else if (v4 == 1)
  {
    v5 = *(_QWORD *)(a1 + 848) == 0;
  }
  else
  {
    v5 = *(_BYTE *)(a1 + 864);
  }
  if (CFSetGetCount(*(CFSetRef *)(a1 + 144))
    || objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isBackgroundActivityRegistered"))
  {
    v6 = *(_QWORD *)(a1 + 832) | 8;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 832) & 0xFFFFFFFFFFFFFFF7;
  }
  *(_QWORD *)(a1 + 832) = v6;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 152))
    || objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isForegroundActivityRegistered"))
  {
    v7 = *(_QWORD *)(a1 + 832) | 0x10;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 832) & 0xFFFFFFFFFFFFFFEFLL;
  }
  *(_QWORD *)(a1 + 832) = v7;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 168))
    || objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isWiFiBoundActivityRegistered"))
  {
    v8 = *(_QWORD *)(a1 + 832) | 0x20;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 832) & 0xFFFFFFFFFFFFFFDFLL;
  }
  *(_QWORD *)(a1 + 832) = v8;
  v9 = v8 ^ a2;
  if (*(_QWORD *)(a1 + 864))
    v8 = 0;
  v57 = v8;
  context = a1;
  v59 = 0xAAAAAAAA0000003BLL;
  v60 = &v57;
  v61 = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Delta state =%lld", "__WiFiManagerApplicationStateUpdate", v9);
  objc_autoreleasePoolPop(v10);
  if ((v9 & 0x11) != 0)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v12 = "entered";
      if ((*(_QWORD *)(a1 + 832) & 0x11) == 0)
        v12 = "exited";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Foreground Network Application %s.", v12);
    }
    objc_autoreleasePoolPop(v11);
    if ((*(_BYTE *)(a1 + 832) & 0x11) != 0)
    {
      v13 = 1144;
      if (!v5)
        v13 = 1128;
      sub_1000069C0(a1, *(const void **)(a1 + v13), 2 * (v5 != 0));
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 3;
      v53 = 1;
      v18 = 1;
      v19 = 1;
      v20 = 1;
    }
    else
    {
      v53 = 1;
      if (v5)
        v23 = 2;
      else
        v23 = 1;
      v24 = 1144;
      if (!v5)
        v24 = 1136;
      sub_1000069C0(a1, *(const void **)(a1 + v24), v23);
      sub_1000B99A4(a1);
      v15 = 0;
      v16 = 0;
      v19 = 0;
      v17 = 0;
      v20 = 0;
      v14 = (*(_BYTE *)(a1 + 832) & 4) == 0;
      v18 = 1;
    }
  }
  else
  {
    v14 = 0;
    v21 = *(_QWORD *)(a1 + 832);
    if ((v21 & 0x11) != 0)
    {
      v53 = 1;
      v15 = 0;
      v18 = 1;
      v16 = 0;
      v19 = 0;
      v17 = 0;
      v20 = 0;
    }
    else
    {
      v53 = 1;
      v15 = 0;
      v18 = 1;
      v16 = 0;
      v19 = 0;
      v17 = 0;
      v20 = 0;
      if ((v9 & 0x2A) != 0)
      {
        v22 = *(_DWORD *)(a1 + 788);
        if ((v21 & 0x2A) != 0)
        {
          v14 = 0;
          v53 = 0;
          v16 = 0;
          v17 = 0;
          v20 = v22 == 2;
          v15 = v5;
          v19 = 1;
        }
        else
        {
          v14 = 0;
          v15 = 0;
          v18 = 0;
          v19 = 0;
          v20 = 0;
          if (v22 == 2)
            v17 = 3;
          else
            v17 = 0;
          v53 = 1;
          v16 = v5;
        }
      }
    }
  }
  v54 = v14;
  v55 = v18;
  v56 = v15;
  v52 = v19;
  if ((v9 & 0x2A) != 0)
  {
    if ((v9 & 2) != 0)
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if ((*(_QWORD *)(a1 + 832) & 2) != 0)
          v27 = "entered";
        else
          v27 = "exited";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Background Network Application %s", v27);
      }
    }
    else if ((v9 & 8) != 0)
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if ((*(_QWORD *)(a1 + 832) & 8) != 0)
          v28 = "entered";
        else
          v28 = "exited";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Background Daemon Application %s", v28);
      }
    }
    else
    {
      if ((v9 & 0x20) == 0)
        goto LABEL_68;
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if ((*(_QWORD *)(a1 + 832) & 0x20) != 0)
          v26 = "entered";
        else
          v26 = "exited";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Direct to Cloud Daemon %s", v26);
      }
    }
    objc_autoreleasePoolPop(v25);
  }
LABEL_68:
  if ((*(_BYTE *)(a1 + 832) & 0x2A) != 0)
  {
    v51 = v20;
    v29 = sub_1000145CC(a1);
    v30 = sub_10001457C(a1);
    v31 = objc_autoreleasePoolPush();
    v32 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v33 = *(_QWORD *)(a1 + 832);
      if ((v33 & 2) != 0)
        v34 = "Present";
      else
        v34 = "Not Present";
      if ((v33 & 8) != 0)
        v35 = "Present";
      else
        v35 = "Not Present";
      v48 = v35;
      v49 = v34;
      v50 = v16;
      v36 = v17;
      v37 = CFSTR("none");
      if (v29)
        v38 = v29;
      else
        v38 = CFSTR("none");
      v47 = v38;
      v39 = objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isBackgroundActivityRegistered");
      if (v30)
        v37 = v30;
      v46 = v37;
      v17 = v36;
      v16 = v50;
      objc_msgSend(v32, "WFLog:message:", 3, "BG Application: %s, BG Daemon: %s. Daemons: %@ (activity=%d) Cloud Clients: %@ (activity=%d)", v49, v48, v47, v39, v46, objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isWiFiBoundActivityRegistered"));
    }
    objc_autoreleasePoolPop(v31);
    if (v29)
      CFRelease(v29);
    v20 = v51;
    if (v30)
      CFRelease(v30);
  }
  if ((v9 & 4) == 0)
  {
    v40 = v52;
    goto LABEL_92;
  }
  v41 = *(_QWORD *)(a1 + 832);
  if ((v41 & 4) != 0)
  {
    v17 = 2;
    v40 = 1;
LABEL_92:
    if (!v54)
      goto LABEL_94;
    goto LABEL_93;
  }
  v40 = v52;
  if ((v41 & 0x11) != 0)
    goto LABEL_92;
LABEL_93:
  sub_1000317E8(a1);
  if ((*(_BYTE *)(a1 + 832) & 0x2A) != 0)
  {
LABEL_95:
    sub_10001462C(a1);
    goto LABEL_96;
  }
LABEL_94:
  if ((v53 & 1) == 0)
    goto LABEL_95;
LABEL_96:
  if ((v55 & 1) == 0 && !*(_BYTE *)(a1 + 1176) && !*(_BYTE *)(a1 + 1160))
    sub_100093B60(a1);
  if (v56)
    sub_1000069C0(a1, *(const void **)(a1 + 1144), 2);
  if (v16)
  {
    if (*(_BYTE *)(a1 + 1176))
    {
      v42 = (const void **)(a1 + 1152);
      v43 = 3;
LABEL_105:
      sub_1000069C0(a1, *v42, v43);
      goto LABEL_107;
    }
    if (!*(_BYTE *)(a1 + 1160))
    {
      sub_1000094BC(a1, 0);
      v42 = (const void **)(a1 + 1136);
      v43 = 1;
      goto LABEL_105;
    }
  }
LABEL_107:
  if (v17)
    sub_100031928(a1, v17);
  v44 = -[WiFiUserInteractionMonitor isNetworkRecommendationAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkRecommendationAllowed");
  if (_os_feature_enabled_impl("WiFiManager", "AskToJoinPersonalHotspotBanner"))
  {
    if (!v40
      || !-[WiFiUserInteractionMonitor isPersonalHotspotRecommendationAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isPersonalHotspotRecommendationAllowed"))
    {
      goto LABEL_112;
    }
  }
  else if (!v44)
  {
LABEL_112:
    LOBYTE(v57) = 0;
    goto LABEL_115;
  }
  LOBYTE(v57) = 1;
LABEL_115:
  context = a1;
  v59 = 0xAAAAAAAA0000005CLL;
  v60 = &v57;
  v61 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    sub_100014478(a1);
  if (v40)
  {
    v45 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s triggering Auto-Join for CWFAutoJoinTriggerApplicationState", "__WiFiManagerApplicationStateUpdate");
    objc_autoreleasePoolPop(v45);
    sub_1000094BC(a1, 1);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_100007F68(a1, 31);
    else
      sub_100090860(a1, v20);
    if (*(_DWORD *)(a1 + 788) == 2)
    {
      if (*(_BYTE *)(a1 + 314))
        sub_1000898A0(a1, 1, 6, 0);
    }
  }
}

void sub_100014478(uint64_t a1)
{
  int v2;
  uint64_t v3;
  _QWORD context[4];
  uint64_t v5;

  v2 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (a1 && v2)
  {
    v5 = 1;
    if (*(_BYTE *)(a1 + 1504))
    {
      v3 = 5;
    }
    else if (*(_BYTE *)(a1 + 314))
    {
      v3 = 2;
    }
    else if (-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable")|| *(_QWORD *)(a1 + 864)|| !*(_QWORD *)(a1 + 848))
    {
      if (!-[WiFiUserInteractionMonitor isAVConferenceActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAVConferenceActive"))
      {
        if (!*(_QWORD *)(a1 + 848))
        {
          if (!*(_QWORD *)(a1 + 864))
            goto LABEL_14;
          v3 = 7;
          goto LABEL_13;
        }
        if (!-[WiFiUserInteractionMonitor isNetworkingAppInForeground](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkingAppInForeground"))
        {
LABEL_14:
          context[0] = a1;
          context[1] = 0xAAAAAAAA0000007ALL;
          context[2] = &v5;
          context[3] = 1;
          CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
          return;
        }
      }
      v3 = 6;
    }
    else
    {
      v3 = 11;
    }
LABEL_13:
    v5 = v3;
    goto LABEL_14;
  }
}

CFMutableStringRef sub_10001457C(uint64_t a1)
{
  CFMutableStringRef Mutable;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
    CFSetApplyFunction(*(CFSetRef *)(a1 + 168), (CFSetApplierFunction)sub_100093EC8, Mutable);
  return Mutable;
}

CFMutableStringRef sub_1000145CC(uint64_t a1)
{
  CFMutableStringRef Mutable;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
    CFSetApplyFunction(*(CFSetRef *)(a1 + 144), (CFSetApplierFunction)sub_10001596C, Mutable);
  return Mutable;
}

void sub_10001462C(uint64_t a1)
{
  int v2;
  double v3;
  void *v4;
  void *v5;

  v2 = *(_DWORD *)(a1 + 952);
  if (v2 == 3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation timer already fired, so not pausing");
    objc_autoreleasePoolPop(v5);
    sub_1000094BC(a1, 1);
  }
  else if (v2 == 2)
  {
    *(_DWORD *)(a1 + 952) = 1;
    v3 = *(double *)(a1 + 944);
    *(double *)(a1 + 936) = v3 - CFAbsoluteTimeGetCurrent();
    sub_100093A70(a1, 0, 315360000.0);
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Pausing disassociation timer with remaing interval of %f s", *(_QWORD *)(a1 + 936));
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10001472C(CFTypeRef cf, uint64_t a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  void *v7;
  _QWORD block[8];
  _QWORD v9[3];
  CFTypeRef v10;
  _QWORD v11[3];
  CFTypeRef v12;
  _QWORD v13[3];
  CFTypeRef v14;
  _QWORD valuePtr[3];
  CFTypeRef v16;

  v4 = *(_QWORD *)(a2 + 40);
  if (!*(_QWORD *)(a2 + 24)
    || (v5 = sub_10001493C((uint64_t)cf),
        LODWORD(valuePtr[0]) = -1431655766,
        CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberIntType, valuePtr),
        LODWORD(valuePtr[0]) != v5))
  {
    if (*(_QWORD *)(v4 + 32))
    {
      valuePtr[0] = 0;
      valuePtr[1] = valuePtr;
      valuePtr[2] = 0x2020000000;
      v16 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      v16 = CFRetain(cf);
      v13[0] = 0;
      v13[1] = v13;
      v13[2] = 0x2020000000;
      v14 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      v14 = CFRetain(*(CFTypeRef *)(a2 + 32));
      v11[0] = 0;
      v11[1] = v11;
      v11[2] = 0x2020000000;
      v12 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      v12 = CFRetain(*(CFTypeRef *)(a2 + 8));
      v9[0] = 0;
      v9[1] = v9;
      v9[2] = 0x2020000000;
      v10 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      v10 = CFRetain(*(CFTypeRef *)(a2 + 16));
      v6 = *(NSObject **)(v4 + 32);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10002919C;
      block[3] = &unk_1002309E0;
      block[4] = valuePtr;
      block[5] = v13;
      block[6] = v11;
      block[7] = v9;
      dispatch_async(v6, block);
      _Block_object_dispose(v9, 8);
      _Block_object_dispose(v11, 8);
      _Block_object_dispose(v13, 8);
      _Block_object_dispose(valuePtr, 8);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: queue not yet setup. Invoking callback directly.", "__WiFiManagerDispatchScanCacheUpdateEvent");
      objc_autoreleasePoolPop(v7);
      sub_100029264((uint64_t)cf, *(_QWORD *)(a2 + 32), *(const void **)(a2 + 8), *(const void **)(a2 + 16));
    }
  }
}

void sub_1000148FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Block_object_dispose((const void *)(v15 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10001493C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_100014944(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = sub_1000164D4(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), (vm_offset_t *)(a2 + 28), (mach_msg_type_number_t *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void sub_100014A24(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, const void *a5)
{
  int v10;
  void *v11;
  void *v12;
  uint64_t v13;
  CFIndex Count;
  const __CFString *v15;
  void *v16;
  const __CFString *v17;

  v10 = sub_100016A8C((uint64_t)a5);
  v11 = objc_autoreleasePoolPush();
  v12 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v13 = sub_1000161D4((uint64_t)a5);
    if (a3)
      Count = CFArrayGetCount(a3);
    else
      Count = 0;
    objc_msgSend(v12, "WFLog:message:", 3, "Async scan request completed for \"%@\" (%d), found %ld networks", v13, a4, Count);
  }
  objc_autoreleasePoolPop(v11);
  v15 = (const __CFString *)sub_1000161D4((uint64_t)a5);
  if (CFStringCompare(v15, CFSTR("locationd"), 0) == kCFCompareEqualTo)
  {
    sub_10010AB34(a1, a4);
    kdebug_trace(731381824, 0, 0, 0, 0);
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Locationd scan done.");
    objc_autoreleasePoolPop(v16);
  }
  if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EMaxCompatibility"))
  {
    v17 = (const __CFString *)sub_1000161D4((uint64_t)a5);
    if (CFStringCompare(v17, CFSTR("configd"), 0) == kCFCompareEqualTo
      && (~sub_1000650B4((uint64_t)a5) & 3) == 0)
    {
      sub_100104FBC(a1, a3);
    }
  }
  sub_10001CB7C((uint64_t)a5, a1, a2, a3, a4);
  sub_100016A84((uint64_t)a5, v10 & 0xFFFFFFFE);
  if (a5)
  {
    if ((v10 & 1) != 0)
      CFRelease(a5);
  }
}

uint64_t sub_100014BF0(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  void *v15;
  CFPropertyListRef v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFNumber *Value;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  const void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  int v32;
  int v33;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v35;
  const __CFArray *v36;
  const __CFArray *v37;
  __CFArray *v38;
  CFMutableArrayRef v39;
  void *v40;
  __CFArray *v41;
  void *v42;
  void *v43;
  const __CFString *v44;
  CFComparisonResult v45;
  const __CFString *v46;
  __CFArray *Mutable;
  CFMutableArrayRef v48;
  CFIndex v49;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  __CFDictionary *v56;
  __CFDictionary *v57;
  CFIndex v58;
  const __CFDictionary *v59;
  const void *v60;
  CFIndex v61;
  const __CFDictionary *v62;
  const __CFDictionary *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  __CFDictionary *v67;
  __CFDictionary *v68;
  void *v69;
  void *v70;
  void *v71;
  const __CFString *v72;
  const __CFString *v73;
  _BOOL4 v74;
  const __CFString *v75;
  int v76;
  void *v77;
  void *v78;
  const char *v79;
  uint64_t v80;
  const char *v81;
  const void **v82;
  unsigned int v83;
  const void **v84;
  void *v85;
  const void *v86;
  CFNumberRef v87;
  CFNumberRef v88;
  CFAbsoluteTime Current;
  CFDateRef v90;
  CFDateRef v91;
  const __CFNumber *v92;
  _BOOL4 v93;
  int v94;
  const __CFString *v95;
  int v96;
  void *v98;
  void *v99;
  void *v100;
  uint64_t v101;
  unsigned int v102;
  UInt8 *v103;
  int v104;
  const void *v105;
  unsigned int v106;
  __CFDictionary *v107;
  _DWORD *v108;
  __CFArray *v109;
  const void *v110;
  const __CFDictionary *theDict;
  const __CFArray *theArray;
  __CFArray *v113;
  int v114;
  int v115;
  int v116;
  uint64_t valuePtr;
  uint64_t v118;
  CFRange v119;

  valuePtr = 0;
  v118 = 0;
  v115 = 1;
  v116 = 0;
  *a6 = -3900;
  v12 = sub_1000167F8();
  v13 = sub_10001674C(a1, v12);
  if (!v13)
    goto LABEL_142;
  v14 = v13;
  if ((sub_100016834((uint64_t)v13) & 1) == 0)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_scan_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v14));
    objc_autoreleasePoolPop(v15);
    goto LABEL_141;
  }
  v16 = sub_10001D7D0(a2, a3);
  v17 = (const __CFDictionary *)sub_10001D7D0(a4, a5);
  v18 = v17;
  if (!v16 || !v17)
    goto LABEL_137;
  v110 = sub_10001683C((uint64_t)v14, v16);
  if (!v110)
  {
    v99 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unable to find device manager for interface %@", "_wifi_device_scan_async", v16);
    objc_autoreleasePoolPop(v99);
    goto LABEL_138;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_MAXAGE"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  v20 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_NUM_SCANS"));
  if (v20)
    CFNumberGetValue(v20, kCFNumberCFIndexType, &v118);
  v21 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_LOW_PRIORITY"));
  if (v21)
    CFNumberGetValue(v21, kCFNumberCFIndexType, &valuePtr);
  v22 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_LOW_LATENCY"));
  if (v22)
    CFNumberGetValue(v22, kCFNumberCFIndexType, &v116);
  theDict = v18;
  v23 = CFDictionaryGetValue(v18, CFSTR("SSID_STR"));
  v24 = objc_autoreleasePoolPush();
  v25 = (void *)qword_10026DD20;
  if (v23)
  {
    if (qword_10026DD20)
    {
      v26 = sub_1000161D4((uint64_t)v14);
      v27 = "low";
      if ((_DWORD)valuePtr)
        v28 = "low";
      else
        v28 = "normal";
      if (!v116)
        v27 = "normal";
      objc_msgSend(v25, "WFLog:message:", 3, "Async directed scan for \"%@\" requested by \"%@\" for %ld iterations with maxage=%d priority %s and latency %s on %@", v23, v26, v118, HIDWORD(valuePtr), v28, v27, v16);
    }
  }
  else if (qword_10026DD20)
  {
    v29 = sub_1000161D4((uint64_t)v14);
    v30 = "low";
    if ((_DWORD)valuePtr)
      v31 = "low";
    else
      v31 = "normal";
    if (!v116)
      v30 = "normal";
    objc_msgSend(v25, "WFLog:message:", 3, "Async scan requested by \"%@\" for %ld iterations with maxage=%d priority %s and latency %s on %@", v29, v118, HIDWORD(valuePtr), v31, v30, v16, v101);
  }
  objc_autoreleasePoolPop(v24);
  *a6 = 0;
  v32 = sub_100016A8C((uint64_t)v14);
  if ((v32 & 1) != 0)
  {
    v42 = objc_autoreleasePoolPush();
    v18 = theDict;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Already scanning, will not queue request. ");
    objc_autoreleasePoolPop(v42);
    sub_10001CB7C((uint64_t)v14, (uint64_t)v110, v16, 0, 37);
    goto LABEL_138;
  }
  v33 = v32;
  v18 = theDict;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  if (!MutableCopy)
  {
    *a6 = -3901;
    goto LABEL_138;
  }
  v35 = MutableCopy;
  v104 = v33;
  v108 = a6;
  v36 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("SCAN_CHANNELS"));
  v107 = v35;
  v106 = a3;
  v105 = v16;
  if (!v36 || (v37 = v36, CFArrayGetCount(v36) < 1))
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Scan Requested with Empty Channels List (Scan all channels!) by %@ \n", "_wifi_device_scan_async", sub_1000161D4((uint64_t)v14));
    objc_autoreleasePoolPop(v43);
    if (sub_1000161D4((uint64_t)v14))
    {
      v44 = (const __CFString *)sub_1000161D4((uint64_t)v14);
      v45 = CFStringCompare(v44, CFSTR("WirelessStress"), 0);
      v46 = (const __CFString *)sub_1000161D4((uint64_t)v14);
      if (CFStringCompare(v46, CFSTR("coreautomationd"), 0) == kCFCompareEqualTo
        || (theArray = 0, v109 = 0, v113 = 0, v45 == kCFCompareEqualTo))
      {
        v103 = a4;
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v48 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        theArray = Mutable;
        v113 = v48;
        if (!Mutable || !v48)
        {
          v109 = 0;
          *v108 = -3902;
          goto LABEL_130;
        }
        if (sub_1000191A0((uint64_t)v110, Mutable))
        {
          *v108 = -3902;
          v100 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error - Device failed to return supported channels! \n", "_wifi_device_scan_async");
          objc_autoreleasePoolPop(v100);
          v109 = 0;
          v18 = theDict;
          v41 = Mutable;
          goto LABEL_131;
        }
        if (CFArrayGetCount(Mutable) >= 1)
        {
          v49 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v49);
            if (ValueAtIndex)
            {
              v51 = ValueAtIndex;
              v52 = CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL"));
              if (v52)
              {
                v53 = v52;
                v54 = CFDictionaryGetValue(v51, CFSTR("SUP_CHANNEL_FLAGS"));
                if (v54)
                {
                  v55 = v54;
                  v56 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (!v56)
                  {
                    v109 = 0;
                    *v108 = -3901;
                    a4 = v103;
                    goto LABEL_148;
                  }
                  v57 = v56;
                  CFDictionaryAddValue(v56, CFSTR("CHANNEL"), v53);
                  CFDictionaryAddValue(v57, CFSTR("CHANNEL_FLAGS"), v55);
                  CFArrayAppendValue(v113, v57);
                  CFRelease(v57);
                }
              }
            }
            ++v49;
            Mutable = theArray;
          }
          while (CFArrayGetCount(theArray) > v49);
        }
        CFDictionarySetValue(v35, CFSTR("SCAN_CHANNELS"), v113);
        v109 = 0;
        a4 = v103;
        goto LABEL_89;
      }
    }
    else
    {
      theArray = 0;
      v109 = 0;
      v113 = 0;
    }
LABEL_90:
    v72 = (const __CFString *)sub_1000161D4((uint64_t)v14);
    if (CFStringCompare(v72, CFSTR("locationd"), 0))
    {
      v73 = (const __CFString *)sub_1000161D4((uint64_t)v14);
      v74 = CFStringCompare(v73, CFSTR("milod"), 0) == kCFCompareEqualTo;
    }
    else
    {
      v74 = 1;
    }
    v35 = v107;
    if (CFDictionaryGetValue(v18, CFSTR("SSID_STR"))
      || _os_feature_enabled_impl("CoreWiFi", "WiFi6EAlwaysFollowup"))
    {
      if (!v74)
        CFDictionarySetValue(v107, CFSTR("SCAN_6GHZ_FOLLOWUP"), kCFBooleanTrue);
      CFDictionarySetValue(v107, CFSTR("SCAN_INCL_ORIG_RNR"), kCFBooleanTrue);
    }
    v75 = (const __CFString *)sub_1000161D4((uint64_t)v14);
    if (CFStringCompare(v75, CFSTR("pipelined"), 0) == kCFCompareEqualTo)
    {
      v76 = valuePtr;
      v77 = objc_autoreleasePoolPush();
      v78 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        if (v76)
          v79 = "Low priority, non-low-latency scan request from \"%@\" \n";
        else
          v79 = "Normal priority, low-latency scan request from \"%@\" \n";
        v80 = sub_1000161D4((uint64_t)v14);
        v81 = v79;
        v18 = theDict;
        objc_msgSend(v78, "WFLog:message:", 3, v81, v80);
      }
      objc_autoreleasePoolPop(v77);
      v82 = (const void **)&kCFBooleanFalse;
      if (!v76)
        v82 = (const void **)&kCFBooleanTrue;
      v35 = v107;
      CFDictionarySetValue(v107, CFSTR("SCAN_LOW_LATENCY"), *v82);
    }
    v83 = sub_1000190B8(v35);
    if (v74)
    {
      if (v116)
        v84 = (const void **)&kCFBooleanTrue;
      else
        v84 = (const void **)&kCFBooleanFalse;
      CFDictionarySetValue(v35, CFSTR("SCAN_LOW_LATENCY"), *v84);
      if (!v116 && v83)
      {
        CFDictionarySetValue(v35, CFSTR("SCAN_LOW_PRIORITY"), kCFBooleanTrue);
        CFDictionarySetValue(v35, CFSTR("SCAN_PRIO_OVERRIDE"), kCFBooleanTrue);
      }
      kdebug_trace(731381820, 0, 0, 0, 0);
      v85 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Normal priority scan request from \"%@\", is5GScan=%d\n", sub_1000161D4((uint64_t)v14), v83);
      objc_autoreleasePoolPop(v85);
      v35 = v107;
    }
    v86 = (const void *)sub_1000161D4((uint64_t)v14);
    CFDictionarySetValue(v35, CFSTR("ScanReqClientName"), v86);
    v114 = sub_10001493C((uint64_t)v14);
    v87 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v114);
    if (v87)
    {
      v88 = v87;
      CFDictionarySetValue(v35, CFSTR("ScanReqClientPid"), v87);
      CFRelease(v88);
    }
    Current = CFAbsoluteTimeGetCurrent();
    v90 = CFDateCreate(kCFAllocatorDefault, Current);
    a3 = v106;
    v16 = v105;
    if (v90)
    {
      v91 = v90;
      CFDictionarySetValue(v35, CFSTR("ScanReqReceiptTimestamp"), v90);
      CFRelease(v91);
    }
    sub_100016A84((uint64_t)v14, v104 | 1);
    v92 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_MERGE"));
    if (v92)
    {
      CFNumberGetValue(v92, kCFNumberCFIndexType, &v115);
      v93 = v115 != 0;
    }
    else
    {
      v93 = 1;
    }
    if (v83)
      v94 = v93 | 2;
    else
      v94 = v93;
    sub_10001CB74((uint64_t)v14, v94);
    v95 = (const __CFString *)sub_1000161D4((uint64_t)v14);
    v96 = sub_100017D98((uint64_t)v110, v105, v35, v95, (uint64_t)sub_100014A24, (uint64_t)v14);
    *v108 = v96;
    if (v96)
      sub_100016A84((uint64_t)v14, v104 & 0xFFFFFFFE);
    else
      CFRetain(v14);
    goto LABEL_130;
  }
  v102 = a5;
  v38 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v109 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v39 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  theArray = v38;
  v113 = v39;
  if (!v38 || !v109 || !v39)
  {
    *v108 = -3902;
    a5 = v102;
    goto LABEL_130;
  }
  if (sub_1000191A0((uint64_t)v110, v38) || !CFArrayGetCount(v38))
  {
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error - Device failed to return supported channels! \n", "_wifi_device_scan_async");
    objc_autoreleasePoolPop(v40);
    *v108 = -3902;
    v41 = v38;
    a5 = v102;
    goto LABEL_131;
  }
  a5 = v102;
  if (CFArrayGetCount(theArray) >= 1)
  {
    v58 = 0;
    do
    {
      v59 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v58);
      if (v59)
      {
        v60 = CFDictionaryGetValue(v59, CFSTR("SUP_CHANNEL"));
        CFArrayAppendValue(v109, v60);
      }
      ++v58;
    }
    while (v58 < CFArrayGetCount(theArray));
  }
  if (CFArrayGetCount(v37) < 1)
  {
LABEL_87:
    if (CFArrayGetCount(v113) <= 0)
    {
      v98 = objc_autoreleasePoolPush();
      a3 = v106;
      v18 = theDict;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error - Scan Channel List Empty!!! (No valid channel to scan!) \n", "_wifi_device_scan_async");
      objc_autoreleasePoolPop(v98);
      *v108 = -3900;
      goto LABEL_146;
    }
    CFDictionarySetValue(v107, CFSTR("SCAN_CHANNELS"), v113);
LABEL_89:
    v18 = theDict;
    goto LABEL_90;
  }
  v61 = 0;
  while (1)
  {
    v62 = (const __CFDictionary *)CFArrayGetValueAtIndex(v37, v61);
    if (v62)
      break;
LABEL_86:
    if (++v61 >= CFArrayGetCount(v37))
      goto LABEL_87;
  }
  v63 = v62;
  v64 = CFDictionaryGetValue(v62, CFSTR("CHANNEL"));
  v65 = CFDictionaryGetValue(v63, CFSTR("CHANNEL_FLAGS"));
  if (!v64)
  {
    v69 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error - Invalid Channel(0) filtered from Scan List \n", "_wifi_device_scan_async");
    v70 = v69;
    goto LABEL_85;
  }
  v66 = v65;
  v119.length = CFArrayGetCount(v109);
  v119.location = 0;
  if (!CFArrayContainsValue(v109, v119, v64))
  {
    v71 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error - Invalid Channel(%@) filtered from Scan List \n", "_wifi_device_scan_async", v64);
    v70 = v71;
LABEL_85:
    objc_autoreleasePoolPop(v70);
    goto LABEL_86;
  }
  v67 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v67)
  {
    v68 = v67;
    CFDictionaryAddValue(v67, CFSTR("CHANNEL"), v64);
    if (v66)
      CFDictionaryAddValue(v68, CFSTR("CHANNEL_FLAGS"), v66);
    CFArrayAppendValue(v113, v68);
    CFRelease(v68);
    goto LABEL_86;
  }
  *v108 = -3902;
LABEL_148:
  a3 = v106;
  v16 = v105;
  v18 = theDict;
LABEL_146:
  v35 = v107;
LABEL_130:
  v41 = theArray;
  if (theArray)
LABEL_131:
    CFRelease(v41);
  if (v109)
    CFRelease(v109);
  if (v113)
    CFRelease(v113);
  CFRelease(v35);
LABEL_137:
  if (v16)
LABEL_138:
    CFRelease(v16);
  if (v18)
    CFRelease(v18);
LABEL_141:
  CFRelease(v14);
LABEL_142:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  return 0;
}

void sub_10001596C(uint64_t a1, __CFString *a2)
{
  const __CFString *v3;

  v3 = (const __CFString *)sub_1000161D4(a1);
  CFStringAppend(a2, v3);
  CFStringAppend(a2, CFSTR(" "));
}

void sub_1000159A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  const __CFData *v7;
  UInt8 *BytePtr;
  CFIndex Length;
  CFPropertyListRef v10;
  const void *v11;
  const __CFString *v12;
  const __CFString *v13;
  char v14;
  CFStringRef v15;
  const __CFDictionary *Value;
  const __CFDictionary *v17;
  const __CFNumber *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  CFNumberRef v23;
  CFNumberRef v24;
  int v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  void *v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  void *v33;
  CFNumberRef v34;
  CFTypeRef v35;
  uint64_t v36;
  uint64_t v37;
  const void *v38;
  CFNumberRef v39;
  CFNumberRef v40;
  void *v41;
  void *v42;
  void *v43;
  double v44;
  double v45;
  BOOL v46;
  double v47;
  void *v50;
  void *v51;
  int v52;
  int valuePtr;
  double context;
  unint64_t v55;
  CFTypeRef cf;
  uint64_t v57;
  double Current;

  if (!a2)
    return;
  v3 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    return;
  if (!*(_QWORD *)(a2 + 8))
    return;
  v4 = *(_QWORD *)(a2 + 24);
  if (!v4)
    return;
  v6 = *(unsigned __int8 *)(a2 + 32);
  if (v6 == 1)
  {
    v7 = *(const __CFData **)(a2 + 16);
    if (v7)
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a2 + 16));
      Length = CFDataGetLength(v7);
      v10 = sub_10001D7D0(BytePtr, Length);
      if (v10)
      {
        v11 = v10;
        context = *(double *)&v3;
        v55 = 0xAAAAAAAA0000005FLL;
        cf = v10;
        v57 = 1;
        CFSetApplyFunction(*(CFSetRef *)(v3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
        CFRelease(v11);
LABEL_9:
        *(_BYTE *)(a2 + 32) = 0;
        v3 = *(_QWORD *)a2;
        v4 = *(_QWORD *)(a2 + 24);
        goto LABEL_10;
      }
      v50 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null payload", "__WiFiManagerEventCoalesceUndispatchedEventData");
    }
    else
    {
      v50 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null serializedEventData", "__WiFiManagerEventCoalesceUndispatchedEventData");
    }
    objc_autoreleasePoolPop(v50);
    goto LABEL_9;
  }
LABEL_10:
  context = 0.0;
  v12 = (const __CFString *)sub_1000161D4(a1);
  v13 = v12;
  valuePtr = 0;
  if (v12)
  {
    if (CFStringCompare(v12, CFSTR("SpringBoard"), 1uLL) == kCFCompareEqualTo
      || CFStringCompare(v13, CFSTR("symptomsd"), 1uLL) == kCFCompareEqualTo
      || (v14 = 1, CFStringCompare(v13, CFSTR("WirelessRadioMan"), 1uLL) == kCFCompareEqualTo))
    {
      v14 = 0;
    }
  }
  else
  {
    v14 = 1;
  }
  v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d"), 14);
  if (v15)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 2128), v15);
    if (Value)
    {
      v17 = Value;
      v18 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("EventRateRateDispachedCount"));
      if (!v18 || !CFNumberGetValue(v18, kCFNumberIntType, &valuePtr))
      {
        v42 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unable to get pending clients", "__WiFiManagerEventIsRateDispatchable");
        objc_autoreleasePoolPop(v42);
        v30 = 0;
        v25 = 1;
        goto LABEL_60;
      }
      Current = NAN;
      Current = CFAbsoluteTimeGetCurrent();
      v19 = (const __CFDictionary *)CFDictionaryGetValue(v17, v13);
      if (v19)
      {
        v20 = v19;
        v21 = (const __CFNumber *)CFDictionaryGetValue(v19, CFSTR("EventRateClientPrevDispatchTimestampKey"));
        if (v21 && CFNumberGetValue(v21, kCFNumberDoubleType, &context))
        {
          v52 = 0;
          v22 = (const __CFNumber *)CFDictionaryGetValue(v20, CFSTR("EventRateClientIntervalKey"));
          if (v22 && CFNumberGetValue(v22, kCFNumberIntType, &v52))
          {
            if (context == 0.0 || Current - context < 0.01 || Current - context > (double)v52 + -0.1)
            {
              ++valuePtr;
              v23 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &Current);
              if (v23)
              {
                v24 = v23;
                CFDictionarySetValue(v20, CFSTR("EventRateClientPrevDispatchTimestampKey"), v23);
                CFDictionarySetValue(v17, v13, v20);
                CFRelease(v24);
              }
              v25 = 1;
              goto LABEL_49;
            }
            if ((v14 & 1) != 0)
            {
LABEL_48:
              v25 = 0;
LABEL_49:
              v30 = 0;
              goto LABEL_56;
            }
            v41 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Client RLEvent %d NOT allowed - %@ Remaining: %2.4f Interval: %2.2f clientCount: %d numClients: %d", "__WiFiManagerEventIsRateDispatchable", 14, v13, Current - (context + (double)v52), (double)v52, valuePtr, v4);
            v32 = v41;
          }
          else
          {
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: client interval not set", "__WiFiManagerEventIsRateDispatchable");
            v32 = v31;
          }
          objc_autoreleasePoolPop(v32);
          goto LABEL_48;
        }
LABEL_43:
        v30 = 0;
        v25 = 0;
LABEL_56:
        if (v4 <= valuePtr)
          valuePtr = 0;
        v34 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(v17, CFSTR("EventRateRateDispachedCount"), v34);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 2128), v15, v17);
        if (v34)
          CFRelease(v34);
LABEL_60:
        CFRelease(v15);
        goto LABEL_61;
      }
      v26 = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("EventRatePrevDispatchTimestampKey"));
      if (!v26 || !CFNumberGetValue(v26, kCFNumberDoubleType, &context))
        goto LABEL_43;
      v52 = 0;
      v27 = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("EventRateDefaultIntervalKey"));
      if (v27 && CFNumberGetValue(v27, kCFNumberIntType, &v52))
      {
        if ((context == 0.0 || Current - context < 0.5 || Current - context > (double)v52 + -0.5)
          && valuePtr <= (int)v4)
        {
          if (!valuePtr)
          {
            v39 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &Current);
            if (v39)
            {
              v40 = v39;
              CFDictionarySetValue(v17, CFSTR("EventRatePrevDispatchTimestampKey"), v39);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 2128), v15, v17);
              CFRelease(v40);
            }
          }
          ++valuePtr;
          v30 = 1;
          goto LABEL_55;
        }
        if ((v14 & 1) != 0)
        {
LABEL_54:
          v30 = 0;
LABEL_55:
          v25 = v30;
          goto LABEL_56;
        }
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Event %d not allowed - %@ Remaining: %2.4f DefInterval: %2.2f clientCount: %d numClients: %d", "__WiFiManagerEventIsRateDispatchable", 14, v13, Current - (context + (double)v52), (double)v52, valuePtr, v4);
        v29 = v28;
      }
      else
      {
        v33 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: default interval not set", "__WiFiManagerEventIsRateDispatchable");
        v29 = v33;
      }
      objc_autoreleasePoolPop(v29);
      goto LABEL_54;
    }
  }
  else
  {
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null eventDict", "__WiFiManagerEventIsRateDispatchable");
    objc_autoreleasePoolPop(v43);
  }
  v44 = CFAbsoluteTimeGetCurrent();
  Current = v44;
  v45 = *(double *)(v3 + 2136);
  v46 = v45 == 0.0;
  v47 = v44 - v45;
  if (!v46 && v47 >= 0.5 && v47 <= 4.5)
  {
    v30 = 0;
  }
  else
  {
    if (v6)
      *(double *)(v3 + 2136) = v44;
    v30 = 1;
  }
  v25 = v30;
  if (v15)
    goto LABEL_60;
LABEL_61:
  if (!v25)
    goto LABEL_71;
  if (!v30)
  {
    ++*(_QWORD *)(a2 + 40);
    sub_1000161DC(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
    return;
  }
  v35 = *(CFTypeRef *)(a2 + 48);
  if (v35)
    goto LABEL_70;
  v36 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    Current = 0.0;
    context = *(double *)&v36;
    v55 = 0xAAAAAAAA00000060;
    cf = &Current;
    v57 = 1;
    CFSetApplyFunction(*(CFSetRef *)(v36 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    if (cf)
    {
      v35 = sub_100029868(kCFAllocatorDefault, cf);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      if (v35)
      {
        *(_QWORD *)(a2 + 48) = v35;
LABEL_70:
        sub_1000161DC(a1, *(_QWORD *)(a2 + 8), v35);
        goto LABEL_71;
      }
      v51 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null serializedEventData", "__WiFiManagerEventCopyCoalescedUndispatchedEventData");
    }
    else
    {
      v51 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null data.arg", "__WiFiManagerEventCopyCoalescedUndispatchedEventData");
    }
  }
  else
  {
    v51 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerEventCopyCoalescedUndispatchedEventData");
  }
  objc_autoreleasePoolPop(v51);
  *(_QWORD *)(a2 + 48) = 0;
LABEL_71:
  v37 = *(_QWORD *)(a2 + 40) + 1;
  *(_QWORD *)(a2 + 40) = v37;
  if (v37 == *(_QWORD *)(a2 + 24))
  {
    if (v30)
      sub_100030434(*(_QWORD *)a2, 14);
    v38 = *(const void **)(a2 + 48);
    if (v38)
    {
      CFRelease(v38);
      *(_QWORD *)(a2 + 48) = 0;
    }
  }
}

uint64_t sub_1000161D4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

void sub_1000161DC(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0xEu, a3);
}

uint64_t sub_1000161E8(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) != 0 && *(_DWORD *)(result + 24) == 1 && *(_DWORD *)(result + 4) == 64)
  {
    if (*(_BYTE *)(result + 39) == 1)
    {
      v3 = *(_DWORD *)(result + 40);
      if (v3 == *(_DWORD *)(result + 52))
      {
        result = sub_10001627C(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(_QWORD *)(result + 56));
        *(_DWORD *)(a2 + 32) = result;
        return result;
      }
    }
    v4 = -300;
  }
  else
  {
    v4 = -304;
  }
  *(_DWORD *)(a2 + 32) = v4;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_10001627C(unsigned int a1, UInt8 *a2, unsigned int a3, unint64_t a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  void *v11;
  CFPropertyListRef v12;
  const void *v13;
  const void *v14;
  uint64_t v15;
  CFDictionaryRef *v16;
  void *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;

  v8 = sub_1000167F8();
  v9 = sub_10001674C(a1, v8);
  if (v9)
  {
    v10 = v9;
    if ((sub_100016834((uint64_t)v9) & 1) == 0)
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_event_mask(mach_port_t, vm_offset_t, mach_msg_type_number_t, uint64_t)", sub_1000161D4((uint64_t)v10));
      objc_autoreleasePoolPop(v11);
      goto LABEL_20;
    }
    v12 = sub_10001D7D0(a2, a3);
    if (!v12)
    {
LABEL_20:
      CFRelease(v10);
      goto LABEL_21;
    }
    v13 = v12;
    v14 = sub_10001683C((uint64_t)v10, v12);
    if (!v14)
    {
LABEL_19:
      CFRelease(v13);
      goto LABEL_20;
    }
    v15 = (uint64_t)v14;
    v16 = (CFDictionaryRef *)sub_100016A7C((uint64_t)v10);
    if (((unint64_t)sub_100029720((uint64_t)v10, v15) ^ a4) == 0x8000)
    {
      v17 = objc_autoreleasePoolPush();
      if ((a4 & 0x8000) != 0)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client %@ requested diagnostics event", "_wifi_device_set_event_mask", sub_1000161D4((uint64_t)v10));
        objc_autoreleasePoolPop(v17);
        v20 = sub_100032338((uint64_t)v10);
        sub_100009788((uint64_t)v10, v20 | 0x8000);
        sub_100093C94((uint64_t)v16);
        v19 = 1;
        if (sub_10011AF34(v15))
          goto LABEL_18;
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client %@ stopped diagnostics event", "_wifi_device_set_event_mask", sub_1000161D4((uint64_t)v10));
        objc_autoreleasePoolPop(v17);
        v18 = sub_100032338((uint64_t)v10);
        sub_100009788((uint64_t)v10, v18 & 0xFFFFFFFFFFFF7FFFLL);
        sub_100093D9C((uint64_t)v16);
        if (sub_10011AF34(v15))
          goto LABEL_18;
        v19 = 0;
      }
      sub_1000A5224(v16, (uint64_t)v10, 14, v19);
    }
LABEL_18:
    sub_100016A04((uint64_t)v10, v15, v13, a4);
    sub_1000168FC((uint64_t)v16, v15, a4);
    goto LABEL_19;
  }
LABEL_21:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

uint64_t sub_1000164D4(unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  void *v13;
  void *v14;
  const __CFDictionary *v15;
  CFDictionaryRef v16;
  const void *v17;
  void *v18;
  const void *v19;
  const __CFAllocator *Default;
  CFNumberRef v21;
  CFNumberRef v22;
  void *v23;
  CFDictionaryRef v24;
  CFDictionaryRef v25;
  CFDictionaryRef v26;
  int valuePtr;

  valuePtr = 0;
  *a4 = 0;
  *a5 = 0;
  v10 = sub_1000167F8();
  v11 = sub_10001674C(a1, v10);
  if (v11)
  {
    v12 = v11;
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Copy current network requested by \"%@\"", sub_1000161D4((uint64_t)v12));
    objc_autoreleasePoolPop(v13);
    if ((sub_100016834((uint64_t)v12) & 1) == 0)
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
      objc_autoreleasePoolPop(v14);
      goto LABEL_26;
    }
    v15 = (const __CFDictionary *)sub_10001D7D0(a2, a3);
    if (!v15)
    {
LABEL_26:
      CFRelease(v12);
      goto LABEL_27;
    }
    v16 = v15;
    v17 = sub_10001683C((uint64_t)v12, v15);
    if (!v17 || (v18 = sub_1000169FC((uint64_t)v17, v16)) == 0)
    {
      v26 = v16;
LABEL_25:
      CFRelease(v26);
      goto LABEL_26;
    }
    v19 = v18;
    if (sub_10002DAB4((uint64_t)v18))
    {
      if ((sub_100016834((uint64_t)v12) & 0x11) == 1)
      {
        if (!sub_100066938((uint64_t)v12, CFSTR("com.apple.wifi.eap-nearby-device-setup-config-copy")))
        {
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ is not entitled for EAPNearbySetup", "kern_return_t _wifi_device_copy_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_1000161D4((uint64_t)v12));
          objc_autoreleasePoolPop(v23);
          goto LABEL_22;
        }
        sub_100065064((uint64_t)v12, 17);
      }
      valuePtr = sub_10011A820(v19);
      if (valuePtr == 1 && !sub_10011A888(v19))
      {
        valuePtr = 4;
        Default = CFAllocatorGetDefault();
        v21 = CFNumberCreate(Default, kCFNumberIntType, &valuePtr);
        if (v21)
        {
          v22 = v21;
          sub_10002C478((uint64_t)v19, CFSTR("ShareableStatus"), v21);
          CFRelease(v22);
        }
      }
    }
LABEL_22:
    v24 = sub_1000173C0((uint64_t)v19);
    if (v24)
    {
      v25 = v24;
      sub_100016858(v24, a4, a5);
      CFRelease(v16);
      v16 = v25;
    }
    CFRelease(v16);
    v26 = (CFDictionaryRef)v19;
    goto LABEL_25;
  }
LABEL_27:
  sub_10001D7AC((vm_address_t)a2, a3);
  return 0;
}

const void *sub_10001674C(unsigned int a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  v3 = sub_100016794(a1);
  v4 = v3;
  if (v3 && CFGetTypeID(v3) != a2)
  {
    CFRelease(v4);
    return 0;
  }
  return v4;
}

const void *sub_100016794(unsigned int a1)
{
  const void *Value;
  const void *v3;

  pthread_mutex_lock(&stru_10026CB08);
  if (qword_10026D6B8)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_10026D6B8, (const void *)a1);
    v3 = Value;
    if (Value)
      CFRetain(Value);
  }
  else
  {
    v3 = 0;
  }
  pthread_mutex_unlock(&stru_10026CB08);
  return v3;
}

uint64_t sub_1000167F8()
{
  uint64_t result;

  result = qword_10026D608;
  if (!qword_10026D608)
  {
    pthread_once(&stru_10026C998, (void (*)(void))sub_100065040);
    return qword_10026D608;
  }
  return result;
}

uint64_t sub_100016834(uint64_t a1)
{
  return *(unsigned int *)(a1 + 136);
}

const void *sub_10001683C(uint64_t a1, const void *a2)
{
  const __CFDictionary *v2;

  if (a1 && a2 && (v2 = *(const __CFDictionary **)(a1 + 112)) != 0)
    return CFDictionaryGetValue(v2, a2);
  else
    return 0;
}

void sub_100016858(const void *a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  const __CFData *v5;
  const __CFData *v6;
  vm_map_read_t v7;
  const UInt8 *BytePtr;
  kern_return_t v9;
  mach_msg_type_number_t dataCnt;

  v5 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a1);
  if (v5)
  {
    v6 = v5;
    dataCnt = -1431655766;
    *a3 = CFDataGetLength(v5);
    v7 = mach_task_self_;
    BytePtr = CFDataGetBytePtr(v6);
    v9 = vm_read(v7, (vm_address_t)BytePtr, *a3, a2, &dataCnt);
    CFRelease(v6);
    if (v9)
      *a2 = 0;
    *a3 = dataCnt;
  }
}

void sub_1000168FC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD context[2];
  unint64_t v6;

  if (a3 == 0x4000000000)
  {
    context[1] = a2;
    v6 = 0xAAAAAAAAAAAAAAAALL;
    context[0] = a1;
    LOBYTE(v6) = *(_BYTE *)(a1 + 913);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B9270, context);
  }
  sub_1000169D8(a2, (a3 >> 46) & 1);
}

void sub_100016964(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;

  if (a1)
  {
    *(_QWORD *)(a1 + 624) = a2;
    *(_QWORD *)(a1 + 632) = a3;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrRegisterTDConfirmedCallback");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000169D8(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  void (*v4)(uint64_t, uint64_t);

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 120);
  if (a2)
  {
    v4 = sub_1001143A8;
  }
  else
  {
    v4 = 0;
    v2 = 0;
  }
  sub_100016964(v3, (uint64_t)v4, v2);
}

void *sub_1000169FC(uint64_t a1, const void *a2)
{
  return sub_10002A21C(a1, a2, 1);
}

void sub_100016A04(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  CFNumberRef v6;
  CFNumberRef v7;
  uint64_t valuePtr;

  valuePtr = a4;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  v7 = v6;
  if (a3 && v6)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), a3, v6);
LABEL_4:
    CFRelease(v7);
    return;
  }
  if (v6)
    goto LABEL_4;
}

uint64_t sub_100016A7C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t sub_100016A84(uint64_t result, int a2)
{
  *(_DWORD *)(result + 52) = a2;
  return result;
}

uint64_t sub_100016A8C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

void sub_100016A94(uint64_t a1, uint64_t a2, CFTypeRef cf, uint64_t a4, uint64_t a5)
{
  _BYTE *v7;
  const void *v8;
  CFTypeID v10;
  __CFArray *v11;
  const __CFArray *v12;
  BOOL v13;
  __CFArray *v14;
  void *v15;
  void *v16;
  const __CFAllocator *v17;
  CFMutableArrayRef Mutable;
  CFIndex v19;
  const void *ValueAtIndex;
  const void *v21;
  _BYTE *v22;
  void *v23;
  CFIndex Count;
  CFIndex v25;
  CFIndex i;
  const void *v27;
  CFMutableDictionaryRef v28;
  CFMutableDictionaryRef v29;
  void *v30;
  CFIndex v31;
  NSString *v32;
  uint64_t v34;
  __CFArray *v35;
  const __CFNumber *Value;
  _QWORD *v37;
  uint64_t v38;
  CFIndex v39;
  const void *v40;
  const __CFNumber *v41;
  const __CFAllocator *v42;
  const void *v43;
  void *v44;
  double v45;
  NSObject *v46;
  dispatch_time_t v47;
  __CFDictionary *v48;
  __CFDictionary *v49;
  __CFArray *v50;
  __CFDictionary *v51;
  __CFArray *v52;
  __CFDictionary *v53;
  __CFDictionary *v54;
  __CFArray *v55;
  __CFArray *v56;
  void (*v57)(uint64_t, uint64_t, __CFDictionary *, __CFDictionary *, _QWORD, _QWORD);
  const void *v58;
  const void *v59;
  void *v60;
  void *v61;
  void *v62;
  __CFArray *theArray;
  CFTypeRef cfa;
  __CFDictionary *cfb;
  uint64_t v66;
  void (*v68)(uint64_t, uint64_t, __CFArray *, uint64_t, uint64_t, uint64_t);
  uint8_t buf[4];
  const char *v71;

  v7 = (_BYTE *)(a1 + 5688);
  v8 = *(const void **)(a1 + 5672);
  v68 = *(void (**)(uint64_t, uint64_t, __CFArray *, uint64_t, uint64_t, uint64_t))(a1 + 4728);
  v66 = *(_QWORD *)(a1 + 4736);
  if (!cf || (v10 = CFGetTypeID(cf), v10 != CFArrayGetTypeID()))
  {
    v14 = 0;
    goto LABEL_11;
  }
  v11 = sub_10001785C((const __CFArray *)cf, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248));
  v12 = v11;
  if (v7[208])
    v13 = 1;
  else
    v13 = v11 == 0;
  if (v13)
  {
    v14 = v11;
    if (v11)
    {
LABEL_25:
      v17 = kCFAllocatorDefault;
      v12 = v14;
      goto LABEL_26;
    }
LABEL_11:
    v12 = 0;
    goto LABEL_33;
  }
  v15 = objc_autoreleasePoolPush();
  v16 = v15;
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Filtering WAPI networks", "__WiFiDeviceProcessScanDoneEvent");
  objc_autoreleasePoolPop(v16);
  v17 = kCFAllocatorDefault;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    v14 = Mutable;
    if (CFArrayGetCount(v12) >= 1)
    {
      v19 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v12, v19);
        v21 = ValueAtIndex;
        if (ValueAtIndex && sub_10002DAF0((_BOOL8)ValueAtIndex))
        {
          v22 = v7;
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: filtered out WAPI network %@", "__WiFiDeviceProcessScanDoneEvent", sub_10002B088(v21));
          objc_autoreleasePoolPop(v23);
          v7 = v22;
        }
        else
        {
          CFArrayAppendValue(v14, v21);
        }
        ++v19;
      }
      while (v19 < CFArrayGetCount(v12));
    }
    CFRelease(v12);
    goto LABEL_25;
  }
LABEL_26:
  v14 = CFArrayCreateMutable(v17, 0, &kCFTypeArrayCallBacks);
  if (v14)
  {
    Count = CFArrayGetCount(v12);
    if (Count >= 1)
    {
      v25 = Count;
      for (i = 0; i != v25; ++i)
      {
        v27 = CFArrayGetValueAtIndex(v12, i);
        if (v27)
        {
          v28 = sub_1000174C4((uint64_t)v27);
          if (!v28)
            break;
          v29 = v28;
          CFArrayAppendValue(v14, v28);
          CFRelease(v29);
        }
      }
    }
  }
LABEL_33:
  v30 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v31 = v12 ? CFArrayGetCount(v12) : 0;
    v32 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Completed Apple80211ScanAsync on %@ (0x%x) with %ld networks"), a2, a5, v31)), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v71 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v32, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v30);
  if ((a5 & 0xFFFFFFFD) == 0xE0820445 || (_DWORD)a5 == -528350142)
    v34 = 16;
  else
    v34 = a5;
  if (v8)
    CFRetain(v8);
  if (v7[32])
  {
    sub_100005C88(a1, 0);
    v7[32] = 0;
  }
  v35 = sub_1000176C4(v12, v14, (CFDictionaryRef)v8);
  if (v14 && v8 && !(_DWORD)v34 && v12)
  {
    *(_DWORD *)buf = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v8, CFSTR("SCAN_TYPE"));
    if (Value)
      CFNumberGetValue(Value, kCFNumberIntType, buf);
    if (*(_DWORD *)buf != 3 && !*v7 && !sub_1000173E0((const __CFDictionary *)v8))
    {
      if (!*(_QWORD *)(a1 + 5696))
      {
        v44 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: scanRequest or scanResults or cache empty", "__WiFiDeviceAddScanCacheEntry");
        objc_autoreleasePoolPop(v44);
        v42 = kCFAllocatorDefault;
        goto LABEL_71;
      }
      theArray = *(__CFArray **)(a1 + 5696);
      v37 = sub_10015B190((uint64_t)kCFAllocatorDefault);
      if (!v37)
      {
        v42 = kCFAllocatorDefault;
        v60 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiCacheEntryCreateMutable failed", "__WiFiDeviceAddScanCacheEntry");
        objc_autoreleasePoolPop(v60);
        goto LABEL_71;
      }
      v38 = (uint64_t)v37;
      cfa = v37;
      if (sub_10015B1F0((uint64_t)v37, v8))
      {
        if (sub_10015B250(v38))
        {
          if (CFArrayGetCount(v12) >= 1)
          {
            v39 = 0;
            do
            {
              v40 = CFArrayGetValueAtIndex(v12, v39);
              v41 = sub_100017A54((uint64_t)v40, CFSTR("AGE"));
              sub_10002B698((uint64_t)v40, CFSTR("ORIG_AGE"), (uint64_t)v41);
              ++v39;
            }
            while (v39 < CFArrayGetCount(v12));
          }
          if (sub_10015B220((uint64_t)cfa, v12))
          {
            CFArrayAppendValue(theArray, cfa);
            v42 = kCFAllocatorDefault;
            v43 = cfa;
LABEL_67:
            CFRelease(v43);
LABEL_71:
            if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
              v45 = 30.0;
            else
              v45 = 14.0;
            sub_10001740C(*(const __CFArray **)(a1 + 5696), v45);
            v46 = *(NSObject **)(a1 + 5712);
            v47 = dispatch_time(0, (uint64_t)(v45 * 1000000000.0));
            dispatch_source_set_timer(v46, v47, 0xFFFFFFFFFFFFFFFFLL, 0);
            v48 = CFDictionaryCreateMutable(v42, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            cfb = v48;
            if (v48
              && (v49 = v48, CFDictionaryAddValue(v48, CFSTR("scanRequest"), v8), (v50 = sub_1000173D8(v12)) != 0))
            {
              v51 = v49;
              v52 = v50;
              CFDictionaryAddValue(v51, CFSTR("scanResults"), v50);
              CFRelease(v52);
              v53 = CFDictionaryCreateMutable(v42, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              v54 = v53;
              if (v53)
              {
                CFDictionaryAddValue(v53, CFSTR("scanRequest"), v8);
                v55 = sub_1000173D8(v14);
                if (v55)
                {
                  v56 = v55;
                  CFDictionaryAddValue(v54, CFSTR("scanResults"), v55);
                  CFRelease(v56);
                }
              }
            }
            else
            {
              v54 = 0;
            }
            v57 = *(void (**)(uint64_t, uint64_t, __CFDictionary *, __CFDictionary *, _QWORD, _QWORD))(a1 + 4744);
            if (v57)
              v57(a1, a2, cfb, v54, 0, *(_QWORD *)(a1 + 4752));
            if (cfb)
              CFRelease(cfb);
            if (v54)
              CFRelease(v54);
            goto LABEL_85;
          }
          v62 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiCacheEntrySetResults failed", "__WiFiDeviceAddScanCacheEntry");
        }
        else
        {
          v62 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiCacheEntrySetTimestampNow failed", "__WiFiDeviceAddScanCacheEntry");
        }
        objc_autoreleasePoolPop(v62);
        v42 = kCFAllocatorDefault;
      }
      else
      {
        v42 = kCFAllocatorDefault;
        v61 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiCacheEntrySetRequest failed", "__WiFiDeviceAddScanCacheEntry");
        objc_autoreleasePoolPop(v61);
      }
      v43 = cfa;
      goto LABEL_67;
    }
  }
LABEL_85:
  v58 = *(const void **)(a1 + 5672);
  if (v58)
  {
    CFRelease(v58);
    *(_QWORD *)(a1 + 5672) = 0;
  }
  *(_QWORD *)(a1 + 4728) = 0;
  *(_QWORD *)(a1 + 4736) = 0;
  if (v68)
    v68(a1, a2, v35, a4, v34, v66);
  v59 = *(const void **)(a1 + 5680);
  if (v59)
  {
    CFRelease(v59);
    *(_QWORD *)(a1 + 5680) = 0;
  }
  *v7 = 0;
  sub_100017CB0(a1);
  if (v12)
    CFRelease(v12);
  if (v14)
    CFRelease(v14);
  if (v35)
    CFRelease(v35);
  if (v8)
    CFRelease(v8);
}

__CFArray *sub_1000172FC(const __CFArray *a1, int a2)
{
  CFMutableArrayRef Mutable;
  __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDictionary *v10;
  const __CFDictionary *v11;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v5 = Mutable;
  if (a1)
  {
    if (Mutable)
    {
      Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        v7 = Count;
        for (i = 0; v7 != i; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            if (a2 == 1)
            {
              v10 = sub_1000C33D0((uint64_t)ValueAtIndex);
LABEL_10:
              v11 = v10;
              if (v10)
              {
                CFArrayAppendValue(v5, v10);
                CFRelease(v11);
              }
              continue;
            }
            if (!a2)
            {
              v10 = sub_1000173C0((uint64_t)ValueAtIndex);
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
  return v5;
}

CFDictionaryRef sub_1000173C0(uint64_t a1)
{
  return CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a1 + 16));
}

__CFArray *sub_1000173D8(const __CFArray *a1)
{
  return sub_1000172FC(a1, 0);
}

uint64_t sub_1000173E0(const __CFDictionary *a1)
{
  const __CFBoolean *Value;

  if (a1 && (Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("SCAN_TRIM_RESULTS"))) != 0)
    return CFBooleanGetValue(Value);
  else
    return 0;
}

void sub_10001740C(const __CFArray *a1, double a2)
{
  CFIndex Count;
  double Current;
  double v6;
  CFIndex v7;
  uint64_t v8;
  CFIndex v9;
  const void *ValueAtIndex;
  double v11;
  CFRange v12;

  Count = CFArrayGetCount(a1);
  Current = CFAbsoluteTimeGetCurrent();
  if (Count)
  {
    v6 = Current;
    if (Current != 0.0)
    {
      v7 = 0;
      v8 = Count & ~(Count >> 63);
      while (v8 != v7)
      {
        v9 = v7;
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (ValueAtIndex)
        {
          v11 = sub_10015B27C((uint64_t)ValueAtIndex);
          v7 = v9 + 1;
          if (v6 - v11 > a2)
            continue;
        }
        if (!v9)
          return;
        goto LABEL_8;
      }
      v9 = v8;
      if (v8)
      {
LABEL_8:
        v12.location = 0;
        v12.length = v9;
        CFArrayReplaceValues(a1, v12, 0, 0);
      }
    }
  }
}

CFMutableDictionaryRef sub_1000174C4(uint64_t a1)
{
  CFMutableDictionaryRef result;
  __CFDictionary *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  _WORD *v14;

  result = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (result)
  {
    v3 = result;
    v4 = sub_10002BE64(a1, CFSTR("RSSI"));
    if (v4)
      CFDictionaryAddValue(v3, CFSTR("RSSI"), v4);
    v5 = sub_10002BE64(a1, CFSTR("BSSID"));
    if (v5)
      CFDictionaryAddValue(v3, CFSTR("BSSID"), v5);
    v6 = sub_10002BE64(a1, CFSTR("CHANNEL"));
    if (v6)
      CFDictionaryAddValue(v3, CFSTR("CHANNEL"), v6);
    v7 = sub_10002BE64(a1, CFSTR("CHANNEL_FLAGS"));
    if (v7)
      CFDictionaryAddValue(v3, CFSTR("CHANNEL_FLAGS"), v7);
    v8 = sub_10002BE64(a1, CFSTR("AGE"));
    if (v8)
      CFDictionaryAddValue(v3, CFSTR("AGE"), v8);
    v9 = sub_10002BE64(a1, CFSTR("IE"));
    if (v9)
      CFDictionaryAddValue(v3, CFSTR("IE"), v9);
    v10 = sub_10002BE64(a1, CFSTR("80211D_IE"));
    if (v10)
      CFDictionaryAddValue(v3, CFSTR("80211D_IE"), v10);
    v11 = sub_10002BE64(a1, CFSTR("AP_MODE"));
    if (v11)
      CFDictionaryAddValue(v3, CFSTR("AP_MODE"), v11);
    v12 = sub_10002BE64(a1, CFSTR("SSID_STR"));
    if (v12)
      CFDictionaryAddValue(v3, CFSTR("SSID_STR"), v12);
    v13 = sub_10002BE64(a1, CFSTR("SSID"));
    if (v13)
      CFDictionaryAddValue(v3, CFSTR("SSID"), v13);
    v14 = sub_10002B314((uint64_t)kCFAllocatorDefault, v3);
    CFRelease(v3);
    return (CFMutableDictionaryRef)v14;
  }
  return result;
}

__CFArray *sub_1000176C4(const __CFArray *a1, const __CFArray *a2, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  int v7;
  int v8;
  int v9;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v15;
  const __CFNumber *v16;
  BOOL v17;
  _BOOL4 v18;
  const void *v19;
  void *v20;
  const void *v21;
  const void *v22;
  int valuePtr;

  valuePtr = 0;
  if (theDict && (Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("SCAN_RSSI_THRESHOLD"))) != 0)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v7 = valuePtr;
  }
  else
  {
    v7 = 0;
  }
  v8 = sub_1000173E0(theDict);
  if (!a1)
    return 0;
  v9 = v8;
  if (v7)
    goto LABEL_7;
  if (!v8)
    return (__CFArray *)CFRetain(a1);
  if (a2)
  {
    a1 = a2;
    return (__CFArray *)CFRetain(a1);
  }
LABEL_7:
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
        if (ValueAtIndex)
        {
          v15 = ValueAtIndex;
          v16 = sub_100017A54((uint64_t)ValueAtIndex, CFSTR("RSSI"));
          v17 = v7 && (uint64_t)v16 < v7;
          v18 = !v17;
          if (v16 && v18)
          {
            if (v9)
            {
              if (a2)
              {
                v19 = CFArrayGetValueAtIndex(a2, i);
                v20 = (void *)CFRetain(v19);
              }
              else
              {
                v20 = sub_1000174C4((uint64_t)v15);
              }
              v21 = v20;
              if (v20)
                v22 = v20;
              else
                v22 = v15;
              CFArrayAppendValue(Mutable, v22);
              if (v21)
                CFRelease(v21);
            }
            else
            {
              CFArrayAppendValue(Mutable, v15);
            }
          }
        }
      }
    }
  }
  return Mutable;
}

__CFArray *sub_10001785C(const __CFArray *a1, int a2, int a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const void *ValueAtIndex;
  _WORD *v12;
  const void *v13;
  float v14;
  float v15;
  double v16;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v7 = Mutable;
  if (a1)
  {
    if (Mutable)
    {
      Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        v9 = Count;
        for (i = 0; i != v9; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            v12 = sub_10002B314((uint64_t)kCFAllocatorDefault, ValueAtIndex);
            if (v12)
            {
              v13 = v12;
              if (a2 != a3)
              {
                v14 = (float)(int)sub_100017A54((uint64_t)v12, CFSTR("RSSI")) + 77.5;
                v15 = fabsf(sqrtf((float)(v14 * v14) + 450.0));
                v16 = (float)((float)(v14 / (float)(v15 + v15)) + 0.5);
                sub_1000179E8((uint64_t)v13, CFSTR("ScaledRSSI"), v16);
                sub_1000179E8((uint64_t)v13, CFSTR("ScaledRate"), 1.0);
                sub_1000179E8((uint64_t)v13, CFSTR("Strength"), v16);
              }
              CFArrayAppendValue(v7, v13);
              CFRelease(v13);
            }
          }
        }
      }
    }
  }
  return v7;
}

void sub_1000179E8(uint64_t a1, void *a2, double a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  double valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v5)
  {
    v6 = v5;
    sub_10002C478(a1, a2, v5);
    CFRelease(v6);
  }
}

const __CFNumber *sub_100017A54(uint64_t a1, void *a2)
{
  const __CFNumber *v2;

  v2 = (const __CFNumber *)sub_10002BE64(a1, a2);
  return sub_10001F500(v2);
}

uint64_t sub_100017A68(uint64_t a1, const void *a2, __CFArray *a3)
{
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  uint64_t v9;
  int i;
  uint64_t v11;
  const __CFArray *v13;
  void *v14;
  const __CFArray *MutableCopy;
  CFIndex Count;
  CFIndex v17;
  CFIndex j;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v20;
  void *v21;
  void *v23;
  CFArrayRef theArray;

  theArray = 0;
  if (!a3)
    return 4294963396;
  v6 = sub_10002DEA0(a1, a2);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v8 = CFGetTypeID(v6);
    if (v8 == sub_10002DE64())
    {
      v9 = sub_10015CE30(v7, 254, 0, &theArray);
LABEL_23:
      MutableCopy = theArray;
      if (theArray)
        goto LABEL_24;
    }
    else
    {
      for (i = 6; ; --i)
      {
        v11 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 254, 0, &theArray);
        v9 = v11;
        if ((int)v11 <= 15)
        {
          if ((_DWORD)v11 != -3905)
            break;
        }
        else if ((_DWORD)v11 != 61 && (_DWORD)v11 != 16)
        {
          goto LABEL_17;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v11)
        goto LABEL_23;
LABEL_17:
      v13 = *(const __CFArray **)(a1 + 5656);
      if (v13 && CFArrayGetCount(v13))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed getting HW supported channels, err=%d, returning cached HW channels (count=%ld)", "WiFiDeviceSupportedChannels", v9, CFArrayGetCount(*(CFArrayRef *)(a1 + 5656)));
        objc_autoreleasePoolPop(v14);
        MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, *(CFArrayRef *)(a1 + 5656));
        v9 = 0;
        theArray = MutableCopy;
        if (MutableCopy)
        {
LABEL_24:
          Count = CFArrayGetCount(MutableCopy);
          if (Count >= 1)
          {
            v17 = Count;
            for (j = 0; j != v17; ++j)
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, j);
              if (ValueAtIndex)
              {
                v20 = ValueAtIndex;
                if (CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL")))
                  CFArrayAppendValue(a3, v20);
              }
            }
          }
          if (theArray)
            CFRelease(theArray);
        }
      }
      else
      {
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not read APPLE80211_IOC_HW_SUPPORTED_CHANNELS err=%d", v9);
        objc_autoreleasePoolPop(v21);
      }
    }
  }
  else
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v23);
    return 0;
  }
  return v9;
}

void sub_100017CB0(uint64_t a1)
{
  __int128 v1;
  CFTypeRef v2;
  CFTypeRef cf[2];
  CFTypeRef v4[2];
  __int128 v5;
  __int128 v6;
  unint64_t v7;

  v7 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5 = v1;
  v6 = v1;
  *(_OWORD *)cf = v1;
  *(_OWORD *)v4 = v1;
  if (!sub_100019A60(*(_QWORD *)(a1 + 176), cf, 0x48uLL, 0))
  {
    switch(LODWORD(cf[0]))
    {
      case 0:
      case 3:
      case 5:
      case 9:
      case 0xB:
      case 0xC:
      case 0xE:
        if (cf[1])
        {
          CFRelease(cf[1]);
          cf[1] = 0;
        }
        v2 = v4[0];
        if (v4[0])
          goto LABEL_8;
        break;
      case 1:
        if (cf[1])
        {
          CFRelease(cf[1]);
          cf[1] = 0;
        }
        if (v4[0])
        {
          CFRelease(v4[0]);
          v4[0] = 0;
        }
        v2 = v4[1];
        if (v4[1])
          goto LABEL_8;
        break;
      case 2:
      case 4:
      case 6:
      case 7:
      case 8:
      case 0xD:
      case 0xF:
        v2 = cf[1];
        if (cf[1])
          goto LABEL_8;
        break;
      case 0xA:
        if (cf[1])
        {
          CFRelease(cf[1]);
          cf[1] = 0;
        }
        if (v4[0])
        {
          CFRelease(v4[0]);
          v4[0] = 0;
        }
        v2 = (CFTypeRef)*((_QWORD *)&v5 + 1);
        if (*((_QWORD *)&v5 + 1))
LABEL_8:
          CFRelease(v2);
        break;
      default:
        return;
    }
  }
}

uint64_t sub_100017D98(uint64_t a1, const void *a2, const __CFDictionary *a3, const __CFString *a4, uint64_t a5, uint64_t a6)
{
  _BYTE *v12;
  _BOOL4 v13;
  const __CFNumber *Value;
  int v15;
  void *v16;
  void *v17;
  uint64_t v18;
  _BOOL4 v19;
  char v20;
  int v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  BOOL v25;
  void *v26;
  const __CFNumber *v27;
  void *v28;
  CFNumberRef v29;
  CFNumberRef v30;
  _BOOL4 v31;
  const __CFNumber *v32;
  void *v33;
  void *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  BOOL v37;
  char v38;
  char v39;
  void *v40;
  void *v41;
  _QWORD *v42;
  BOOL v43;
  void *v44;
  const __CFString *v45;
  void (*v46)(uint64_t, const void *, _QWORD, uint64_t, const __CFDictionary *);
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  void *v51;
  void *v52;
  void *v53;
  int v54;
  int valuePtr;
  int v56;

  v12 = (_BYTE *)(a1 + 5496);
  v56 = 0;
  v13 = sub_10010ACE4(a1, a4);
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_TYPE"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    if (valuePtr == 3)
      goto LABEL_3;
  }
  if (sub_100018E70(a1))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue scan request - sensitive action on", "WiFiDeviceManagerScanAsync");
LABEL_7:
    v17 = v16;
LABEL_8:
    objc_autoreleasePoolPop(v17);
    return 16;
  }
  if (sub_100018FE4(a1) && (!sub_10010A010(a1) ? (v19 = v13) : (v19 = 0), !v19)
    || (!*(_BYTE *)(a1 + 3414) ? (v20 = 1) : (v20 = v13), (v20 & 1) == 0 && sub_1000190B8(a3)))
  {
    v21 = v12[1545];
    v22 = objc_autoreleasePoolPush();
    if (v21)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will try to queue scan request on LPSC only", "WiFiDeviceManagerScanAsync");
      objc_autoreleasePoolPop(v22);
      v15 = 1;
LABEL_24:
      v23 = malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
      if (v23)
      {
        v24 = (uint64_t)v23;
        *v23 = a1;
        v23[1] = a5;
        v23[2] = CFDictionaryGetValue(a3, CFSTR("ScanReqClientName"));
        *(_QWORD *)(v24 + 24) = a6;
        if (CFDictionaryContainsKey(a3, CFSTR("SSID_STR")))
          v25 = 1;
        else
          v25 = CFDictionaryContainsKey(a3, CFSTR("SCAN_SSID_LIST")) != 0;
        *(_BYTE *)(v24 + 32) = v25;
        if (v12[1545] && sub_1000186A4(a1, a4, a3, v15))
        {
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting scan throttle to true and isLPSCSupported=%d", "WiFiDeviceManagerScanAsync", v12[1545]);
          objc_autoreleasePoolPop(v26);
          CFDictionarySetValue(a3, CFSTR("SCAN_IS_THROTTLED"), kCFBooleanTrue);
        }
        if (*v12)
        {
          v27 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_DWELL_TIME"));
          if (v27)
          {
            v54 = 0;
            CFNumberGetValue(v27, kCFNumberSInt32Type, &v54);
            if (v54 >= 41)
            {
              v28 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Reducing dwell time from %d to %d", "WiFiDeviceManagerScanAsync", v54, 40);
              objc_autoreleasePoolPop(v28);
              v54 = 40;
              v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v54);
              if (v29)
              {
                v30 = v29;
                CFDictionaryReplaceValue(a3, CFSTR("SCAN_DWELL_TIME"), v29);
                CFRelease(v30);
              }
            }
          }
        }
        if (*(_QWORD *)(v24 + 16))
          v31 = v13;
        else
          v31 = 0;
        if (v31)
        {
          v54 = 0;
          v32 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_LOW_PRIORITY"));
          if (v32)
            CFNumberGetValue(v32, kCFNumberSInt32Type, &v54);
          if (!v54)
          {
            CFDictionarySetValue(a3, CFSTR("SCAN_LOW_LATENCY"), kCFBooleanTrue);
            v33 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting low latency to true for interactive client %@", "WiFiDeviceManagerScanAsync", *(_QWORD *)(v24 + 16));
            objc_autoreleasePoolPop(v33);
            if (CFStringCompare(*(CFStringRef *)(v24 + 16), CFSTR("mobilewifitool"), 0) == kCFCompareEqualTo
              && valuePtr == 9)
            {
              v34 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: This is normal priority, low latency mobilewifitool client with low power scan type", "WiFiDeviceManagerScanAsync");
              objc_autoreleasePoolPop(v34);
            }
          }
        }
        if (*(int *)(a1 + 6208) <= -75)
        {
          v35 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_LOW_LATENCY"));
          if (v35)
            CFNumberGetValue(v35, kCFNumberSInt32Type, &v56);
          v54 = 0;
          v36 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_LOW_PRIORITY"));
          if (v36)
          {
            CFNumberGetValue(v36, kCFNumberSInt32Type, &v54);
            v37 = v54 != 0;
          }
          else
          {
            v37 = 0;
          }
          if (!v56 && !v37)
          {
            v44 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "currentRssi(=%d) <= threshold(=%d), lowering scan priority \n", *(unsigned int *)(a1 + 6208), 4294967221);
            objc_autoreleasePoolPop(v44);
            CFDictionarySetValue(a3, CFSTR("SCAN_LOW_PRIORITY"), kCFBooleanTrue);
            CFDictionarySetValue(a3, CFSTR("SCAN_PRIO_OVERRIDE"), kCFBooleanTrue);
          }
        }
        v45 = *(const __CFString **)(v24 + 16);
        if (v45 && CFStringCompare(v45, CFSTR("Preferences"), 0) == kCFCompareEqualTo)
          CFDictionarySetValue(a3, CFSTR("SCAN_INC_BSS_LIST"), kCFBooleanTrue);
        v46 = *(void (**)(uint64_t, const void *, _QWORD, uint64_t, const __CFDictionary *))(a1 + 4392);
        if (v46)
          v46(a1, a2, *(_QWORD *)(a1 + 4400), 4, a3);
        if (*(_QWORD *)(a1 + 7368) && (v47 = *(const void **)(v24 + 16)) != 0)
        {
          if (CFEqual(v47, CFSTR("Preferences")))
          {
            v48 = 8;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("SpringBoard")))
          {
            v48 = 10;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("WiFiPickerExtens")))
          {
            v48 = 9;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("locationd")))
          {
            v48 = 16;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("pipelined")))
          {
            v48 = 17;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("homed")))
          {
            v48 = 12;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("configd")))
          {
            v48 = 13;
          }
          else if (CFEqual(*(CFTypeRef *)(v24 + 16), CFSTR("milod")))
          {
            v48 = 26;
          }
          else
          {
            v48 = 14;
          }
        }
        else
        {
          v48 = 14;
        }
        v49 = sub_100018C78(a1, a2, a3, 0, (uint64_t)sub_1000191D4, v24, 0, v48);
        goto LABEL_94;
      }
      v52 = objc_autoreleasePoolPush();
      v53 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
      {
LABEL_121:
        objc_autoreleasePoolPop(v52);
        return 12;
      }
LABEL_120:
      objc_msgSend(v53, "WFLog:message:", 4, "%s: null scanData", "WiFiDeviceManagerScanAsync");
      goto LABEL_121;
    }
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue scan request - hosting AWDL session and isLPSCSupported=%d", "WiFiDeviceManagerScanAsync", v12[1545]);
    v17 = v22;
    goto LABEL_8;
  }
  v38 = !sub_100018E14(a1) || v13;
  if ((v38 & 1) == 0)
  {
    v51 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue scan request - MIS discovery state %d MIS Scan Blocked = %d", "WiFiDeviceManagerScanAsync", *(unsigned __int8 *)(a1 + 5221), *(unsigned __int8 *)(a1 + 5328));
    v17 = v51;
    goto LABEL_8;
  }
  if (sub_100018D34(a1))
    v39 = v13;
  else
    v39 = 1;
  if ((v39 & 1) == 0)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue scan request - autojoin is busy", "WiFiDeviceManagerScanAsync");
    goto LABEL_7;
  }
  if (v12[1545] || !sub_1000186A4(a1, a4, a3, 0))
  {
LABEL_3:
    v15 = 0;
    goto LABEL_24;
  }
  v40 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not queue scan request - too frequent location scans and isLPSCSupported=%d", "WiFiDeviceManagerScanAsync", v12[1545]);
  objc_autoreleasePoolPop(v40);
  if (!*(_BYTE *)(a1 + 433))
    return 16;
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Location Scan request rejected due to EBUSY, queueing for scan cache", "WiFiDeviceManagerScanAsync");
  objc_autoreleasePoolPop(v41);
  v42 = malloc_type_malloc(0x28uLL, 0x10E0040573E0799uLL);
  if (!v42)
  {
    v52 = objc_autoreleasePoolPush();
    v53 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_121;
    goto LABEL_120;
  }
  v24 = (uint64_t)v42;
  *v42 = a1;
  v42[1] = a5;
  v42[2] = CFDictionaryGetValue(a3, CFSTR("ScanReqClientName"));
  *(_QWORD *)(v24 + 24) = a6;
  if (CFDictionaryContainsKey(a3, CFSTR("SSID_STR")))
    v43 = 1;
  else
    v43 = CFDictionaryContainsKey(a3, CFSTR("SCAN_SSID_LIST")) != 0;
  *(_BYTE *)(v24 + 32) = v43;
  CFDictionarySetValue(a3, CFSTR("BeaconCacheOnly"), kCFBooleanTrue);
  v49 = sub_100071BF8(*(_QWORD *)(a1 + 64), a2, a3, 0, (uint64_t)sub_1000191D4, v24);
LABEL_94:
  v18 = v49;
  if ((_DWORD)v49)
    free((void *)v24);
  return v18;
}

uint64_t sub_1000186A4(uint64_t a1, CFStringRef theString1, const __CFDictionary *a3, int a4)
{
  const __CFNumber *Value;
  void *v9;
  void *v10;
  double Current;
  double v12;
  const __CFArray *v13;
  CFIndex Count;
  _BYTE *v15;
  CFIndex v16;
  void *v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  unsigned int v24;
  const char *v25;
  int valuePtr;

  valuePtr = 0;
  if (CFStringCompare(theString1, CFSTR("locationd"), 0) == kCFCompareEqualTo
    || CFStringCompare(theString1, CFSTR("loctool"), 0) == kCFCompareEqualTo
    || CFStringCompare(theString1, CFSTR("milod"), 0) == kCFCompareEqualTo)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SCAN_LOW_LATENCY"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Low-latency scan request: shouldBlockScans=%d, no throttling\n", 0);
        objc_autoreleasePoolPop(v9);
        return 0;
      }
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "startCheck: shouldBlockScans=%d numAdmitted %d admittedTS=%f connected=%d\n", 0, *(unsigned int *)(a1 + 404), *(_QWORD *)(a1 + 408), *(unsigned __int8 *)(a1 + 3411));
    objc_autoreleasePoolPop(v10);
    if (!*(_BYTE *)(a1 + 3411))
      return 0;
    if (a4)
    {
      CFDictionarySetValue(a3, CFSTR("SCAN_ONLY_USE_LOW_POWER_CORE"), kCFBooleanTrue);
      CFDictionarySetValue(a3, CFSTR("SCAN_IS_THROTTLED"), kCFBooleanTrue);
    }
    Current = CFAbsoluteTimeGetCurrent();
    v12 = *(double *)(a1 + 408);
    v13 = (const __CFArray *)CFDictionaryGetValue(a3, CFSTR("SCAN_CHANNELS"));
    Count = CFArrayGetCount(v13);
    v15 = (_BYTE *)(a1 + 5497);
    if (*(_BYTE *)(a1 + 5497) == 1 && (v16 = Count, Count >= 4))
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User scan request blocked due to high number of channels (%ld) during FT call", v16);
      v18 = 1;
    }
    else
    {
      v19 = Current - v12;
      if (*(_BYTE *)(a1 + 433) == 1)
      {
        if (*(_BYTE *)(a1 + 416) == 2)
          v20 = 1;
        else
          v20 = 2;
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s CATSPolicy=%d , numAllowedScanPolicy=%d ", "WiFiDeviceManagerIsFrequentLocationScan", *(unsigned __int8 *)(a1 + 416), v20);
        objc_autoreleasePoolPop(v21);
      }
      else
      {
        LODWORD(v20) = 2;
      }
      if (v19 > 6.0)
      {
        *(CFAbsoluteTime *)(a1 + 408) = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)(a1 + 404) = 1;
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Resetting, shouldBlockScans=%d numAdmitted %d delta=%f admittedTS=%f \n", 0, *(unsigned int *)(a1 + 404), *(_QWORD *)&v19, *(_QWORD *)(a1 + 408));
        objc_autoreleasePoolPop(v22);
      }
      if (v19 >= 6.0)
      {
        v18 = 0;
LABEL_45:
        *(_BYTE *)(a1 + 400) = v18;
        return v18;
      }
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "TOO CLOSE: shouldBlockScans=%d delta %f admitted=%d\n", 0, *(_QWORD *)&v19, *(unsigned int *)(a1 + 404));
      objc_autoreleasePoolPop(v23);
      v24 = *(_DWORD *)(a1 + 404);
      if (v24 >= v20 || *v15)
      {
        v18 = 1;
      }
      else
      {
        v18 = 0;
        *(_DWORD *)(a1 + 404) = v24 + 1;
      }
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v25 = "TRUE";
        if (!*v15)
          v25 = "FALSE";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "TOO CLOSE, shouldBlockScans=%d delta %f numAdmitted=%d, facetime=%s\n", v18, *(_QWORD *)&v19, *(unsigned int *)(a1 + 404), v25);
      }
    }
    objc_autoreleasePoolPop(v17);
    goto LABEL_45;
  }
  return 0;
}

void sub_100018A1C(uint64_t a1, int a2, uint64_t a3, int a4, void *value)
{
  __CFDictionary *v8;
  __CFString **v9;
  CFNumberRef v10;
  const __CFString *v11;
  const CFBooleanRef *v12;
  CFBooleanRef v13;
  unsigned int v14;
  CFNumberRef v15;
  __CFDictionary *v16;
  const __CFString *v17;
  void *v18;
  const void *v19;
  int valuePtr;
  uint64_t context;
  CFTypeRef cf;

  if (a3)
  {
    valuePtr = -1431655766;
    switch(a4)
    {
      case 0:
        v8 = *(__CFDictionary **)(a3 + 1864);
        v9 = off_10022FA48;
        goto LABEL_14;
      case 2:
        valuePtr = (int)value;
        v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1864), CFSTR("DiagnosticsBssEnv"), v10);
        if (v10)
          CFRelease(v10);
        break;
      case 3:
        v8 = *(__CFDictionary **)(a3 + 1864);
        v9 = off_10022FA80;
        goto LABEL_14;
      case 4:
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1864), CFSTR("DiagnosticsScan"), value);
        v8 = *(__CFDictionary **)(a3 + 1864);
        v11 = CFSTR("DiagnosticsScanDone");
        v12 = &kCFBooleanFalse;
        goto LABEL_9;
      case 5:
        v8 = *(__CFDictionary **)(a3 + 1864);
        v11 = CFSTR("DiagnosticsScanDone");
        v12 = &kCFBooleanTrue;
LABEL_9:
        v13 = *v12;
        goto LABEL_15;
      case 6:
        v14 = objc_msgSend((id)CFArrayGetValueAtIndex((CFArrayRef)value, 1), "isEqualToString:", CFSTR("www.apple.com"));
        v8 = *(__CFDictionary **)(a3 + 1864);
        if (v14)
          v9 = off_10022FA88;
        else
          v9 = off_10022FA90;
        goto LABEL_14;
      case 7:
        v8 = *(__CFDictionary **)(a3 + 1864);
        v9 = off_10022FA98;
LABEL_14:
        v11 = *v9;
        v13 = (CFBooleanRef)value;
LABEL_15:
        CFDictionarySetValue(v8, v11, v13);
        break;
      default:
        break;
    }
    v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a3 + 1052));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1864), CFSTR("DiagnosticsBluetooth"), v15);
    if (v15)
      CFRelease(v15);
    v16 = *(__CFDictionary **)(a3 + 1864);
    v17 = sub_100024674(*(_DWORD *)(a3 + 1408));
    CFDictionarySetValue(v16, CFSTR("DiagnosticsMotion"), v17);
    if (*(_QWORD *)(a3 + 1888))
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: diagnostics report %@", "__WiFiManagerDiagnosticsStartCallback", *(_QWORD *)(a3 + 1864));
      objc_autoreleasePoolPop(v18);
      v19 = *(const void **)(a3 + 1864);
      context = a1;
      cf = sub_100029868(kCFAllocatorDefault, v19);
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_1000B7A84, &context);
      if (cf)
        CFRelease(cf);
    }
  }
}

uint64_t sub_100018C78(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, uint64_t a8)
{
  uint64_t v11;
  void *v12;
  void *v14;

  v11 = sub_100019D8C(*(_QWORD *)(a1 + 64), a2, a3, a4, a5, a6, a7);
  if ((_DWORD)v11)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error initiating scan request: %d", v11);
    objc_autoreleasePoolPop(v14);
  }
  else
  {
    v12 = *(void **)(a1 + 7368);
    if (v12)
      objc_msgSend(v12, "setScanningState:client:neighborBSS:otherBSS:withChannelInfoList:withRequest:forInterface:", 1, a8, 0, 0, 0, a3, sub_100025C3C(*(_QWORD *)(a1 + 64)));
  }
  return v11;
}

CFIndex sub_100018D34(CFIndex result)
{
  CFIndex v1;
  int v2;
  void *v4;

  if (!result)
    return result;
  v1 = result;
  result = CFArrayGetCount(*(CFArrayRef *)(result + 3528));
  if (!result)
    return result;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if ((CWFIsAutoJoinRetryTrigger(*(_QWORD *)(v1 + 8880)) & 1) == 0 && *(_QWORD *)(v1 + 8872))
    {
      v2 = *(_DWORD *)(v1 + 3280);
      return v2 != 14 && v2 != 17;
    }
    return 0;
  }
  if ((*(_DWORD *)(v1 + 3280) - 5) > 7)
    return 0;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: autojoin is busy %@", "__WiFiDeviceManagerIsAutoJoinBusy", sub_100031FD0(*(_DWORD *)(v1 + 3280)));
  objc_autoreleasePoolPop(v4);
  return 1;
}

BOOL sub_100018E14(uint64_t a1)
{
  _BYTE *v1;

  v1 = (_BYTE *)(a1 + 5221);
  if (*(_BYTE *)(a1 + 5328))
  {
    if (CFAbsoluteTimeGetCurrent() >= *(double *)(a1 + 5336))
    {
      v1[107] = 0;
    }
    else if (v1[107])
    {
      return 1;
    }
  }
  return *v1 != 0;
}

uint64_t sub_100018E70(uint64_t a1)
{
  void *v1;
  uint64_t result;

  if (*(_BYTE *)(a1 + 5504))
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiDeviceManager Link setup - critical phase is ON", "WiFiDeviceManagerIsSensitiveActivityOnGoing");
  }
  else
  {
    result = sub_100018F14(a1);
    if (!(_DWORD)result)
      return result;
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiDeviceManager - in autojoin deferral period", "WiFiDeviceManagerIsSensitiveActivityOnGoing");
  }
  objc_autoreleasePoolPop(v1);
  return 1;
}

uint64_t sub_100018F14(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  if (a1)
  {
    if (!*(_DWORD *)(a1 + 352))
      return 0;
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Auto-join has been deferred for %f seconds with reasons=0x%x", CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 368), *(unsigned int *)(a1 + 352));
    v3 = 1;
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiDeviceManagerIsAutoJoinDeferred");
    v3 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_100018FE4(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  void *v3;
  uint64_t v4;

  if (a1)
  {
    if (!*(_DWORD *)(a1 + 5424))
      return 0;
    v1 = *(_QWORD *)(a1 + 64);
    v2 = (const void *)sub_100068E60(v1);
    if (!sub_100074164(v1, v2, 0))
      return 0;
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifid has started AWDL and it is enabled", "WiFiDeviceManagerIsAwdlStartedAndEnabled");
    v4 = 1;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "WiFiDeviceManagerIsAwdlStartedAndEnabled");
    v4 = 0;
  }
  objc_autoreleasePoolPop(v3);
  return v4;
}

uint64_t sub_1000190B8(const __CFDictionary *a1)
{
  uint64_t result;
  const __CFArray *v2;
  uint64_t v3;
  CFIndex v4;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  void *v7;
  unsigned int valuePtr;

  result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("SCAN_CHANNELS"));
  if (result)
  {
    v2 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result)
    {
      v3 = result;
      if (result < 1)
      {
        return 1;
      }
      else
      {
        v4 = 0;
        valuePtr = -1431655766;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v4);
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL"));
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr <= 0x23)
            break;
          if (v3 == ++v4)
            return 1;
        }
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: 2GHz Scan request because channel %d is requested ", "WiFiDeviceManagerIs5GScanRequest", valuePtr);
        objc_autoreleasePoolPop(v7);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1000191A0(uint64_t a1, __CFArray *a2)
{
  uint64_t v3;
  const void *v4;

  v3 = *(_QWORD *)(a1 + 64);
  v4 = (const void *)sub_100025C3C(v3);
  return sub_100017A68(v3, v4, a2);
}

void sub_1000191D4(uint64_t a1, uint64_t a2, const __CFArray *a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6)
{
  void *v10;
  void *v11;
  uint64_t v12;
  const __CFString *v13;
  _BOOL4 v14;
  _BOOL4 v15;
  uint64_t v16;
  WiFiScanResultsPreparer *v17;
  NSArray *v18;
  id v19;
  const __CFString *v20;
  BOOL v21;
  void *v22;
  void (*v23)(uint64_t, uint64_t, const __CFArray *, uint64_t, _QWORD);
  const __CFArray *v24;
  const __CFArray *MutableCopy;
  void (*v26)(uint64_t, _QWORD, const __CFString *, const CFBooleanRef, _QWORD);
  CFIndex Count;
  CFIndex v28;
  CFIndex v29;
  const void *v30;
  const void *v31;
  const __CFDictionary **ValueAtIndex;
  const __CFDictionary **v33;
  const void *v34;
  uint64_t v35;
  CFTypeID TypeID;
  __CFDictionary *v37;
  CFTypeID v38;
  const void *v39;
  CFNumberRef v40;
  __CFDictionary *Mutable;
  int v42;
  CFNumberRef v43;
  CFNumberRef v44;
  __CFDictionary *v45;
  CFNumberRef v46;
  int v47;
  CFNumberRef v48;
  __CFDictionary *v49;
  const __CFString *v50;
  CFNumberRef v51;
  uint64_t v52;
  __CFString *v53;
  __CFDictionary *v54;
  void (*v55)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD);
  void *v56;
  void *v57;
  void *v58;
  WiFiScanResultsPreparer *v59;
  unsigned int v60;
  CFIndex v61;
  const __CFBoolean *v62;
  CFBooleanRef v63;
  uint64_t v65;
  CFIndex v66;

  v10 = objc_autoreleasePoolPush();
  v11 = (void *)os_transaction_create("com.apple.wifid.WiFiDeviceManagerClientScanCallback");
  if (a6)
  {
    v12 = *(_QWORD *)a6;
    v13 = *(const __CFString **)(a6 + 16);
    if (v13)
    {
      v14 = CFStringCompare(v13, CFSTR("Preferences"), 0) == kCFCompareEqualTo
         || CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("SpringBoard"), 0) == kCFCompareEqualTo
         || CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("WiFiPickerExtens"), 0) == kCFCompareEqualTo;
      v15 = CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("aonsensed"), 0) == kCFCompareEqualTo;
      v16 = *(_QWORD *)(a6 + 16);
      if (a4)
      {
LABEL_9:
        if (!CFDictionaryGetValue(a4, CFSTR("CompletedUsingBeaconCache")))
          goto LABEL_17;
LABEL_13:
        if (a3 && CFArrayGetCount(a3))
          ++*(_BYTE *)(v12 + 417);
        else
          ++*(_BYTE *)(v12 + 418);
LABEL_17:
        if (a3 && !v15)
          objc_msgSend(*(id *)(v12 + 6680), "ingestScanResults:ofType:clientName:directed:", a3, 2, v16, *(_BYTE *)(a6 + 32) != 0);
        v17 = 0;
        v18 = 0;
        if (v14 && v12)
        {
          if (*(_BYTE *)(v12 + 6712))
          {
            v19 = sub_10012E8C8(v12);
            v17 = -[WiFiScanResultsPreparer initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:]([WiFiScanResultsPreparer alloc], "initWithManager:availabilityEngine:scanResults:disableProminentFiltering:blacklistedSSIDs:", v12, *(_QWORD *)(v12 + 6672), a3, 0, v19);
            v18 = -[WiFiScanResultsPreparer preparedScanResults](v17, "preparedScanResults");
            if (v19)
              CFRelease(v19);
          }
          else
          {
            v17 = 0;
            v18 = 0;
          }
        }
        v20 = *(const __CFString **)(a6 + 16);
        v21 = !v20
           || CFStringCompare(v20, CFSTR("Preferences"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("WiFiPickerExtens"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("NanoSettings"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("NanoWiFiViewService"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("WiFiViewService"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("mobilewifitool"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("coreautomationd"), 0)
           && CFStringCompare(*(CFStringRef *)(a6 + 16), CFSTR("SpringBoard"), 0);
        if ((_DWORD)a5 == -536870165 && *(_DWORD *)(v12 + 5520) == 1)
        {
          v22 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: converting error to EBUSY", "WiFiDeviceManagerClientScanCallback");
          objc_autoreleasePoolPop(v22);
          *(_BYTE *)(v12 + 728) = 1;
          a5 = 16;
        }
        v23 = *(void (**)(uint64_t, uint64_t, const __CFArray *, uint64_t, _QWORD))(a6 + 8);
        if (!v23)
          goto LABEL_104;
        if (v18)
          v24 = (const __CFArray *)v18;
        else
          v24 = a3;
        if (v21)
        {
          v23(v12, a2, v24, a5, *(_QWORD *)(a6 + 24));
LABEL_104:
          v55 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))(v12 + 4392);
          if (v55)
            v55(v12, a2, *(_QWORD *)(v12 + 4400), 5, 0);
          free((void *)a6);
          goto LABEL_107;
        }
        v60 = a5;
        if (v24)
        {
          MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v24);
          if (MutableCopy)
          {
            v57 = v11;
            v58 = v10;
            v65 = 0;
            v66 = -1;
            v26 = *(void (**)(uint64_t, _QWORD, const __CFString *, const CFBooleanRef, _QWORD))(v12 + 4744);
            if (v26)
              v26(v12, 0, CFSTR("PrivateMacCheckForMDMOrSupervised"), kCFBooleanTrue, *(_QWORD *)(v12 + 4752));
            Count = CFArrayGetCount(MutableCopy);
            if (Count >= 1)
            {
              v28 = Count;
              v29 = 0;
              v63 = 0;
              v62 = 0;
              v30 = 0;
              v31 = 0;
              v59 = v17;
              v61 = Count;
              while (1)
              {
                ValueAtIndex = (const __CFDictionary **)CFArrayGetValueAtIndex(MutableCopy, v29);
                if (ValueAtIndex)
                  break;
LABEL_97:
                if (v28 == ++v29)
                  goto LABEL_100;
              }
              v33 = ValueAtIndex;
              sub_1000CEBA4((uint64_t)ValueAtIndex);
              sub_10002B7AC(*(const __CFArray **)(v12 + 3704), v33, &v66, &v65);
              if (v66 != -1)
              {
                v34 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 3704), v66);
                if (v34)
                {
                  v35 = (uint64_t)v34;
                  v31 = sub_10002BE64((uint64_t)v34, CFSTR("PRIVATE_MAC_ADDRESS"));
                  sub_10002BE64(v35, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
                  v62 = (const __CFBoolean *)sub_10002BE64(v35, CFSTR("PrivateMacDefaultToOFF"));
                  v30 = sub_10002BE64(v35, CFSTR("PrivateMacFutureMacAddress"));
                  v63 = (CFBooleanRef)sub_10002BE64(v35, CFSTR("PrivateMacControlledDevice"));
                }
                if (!v31)
                  goto LABEL_97;
                TypeID = CFDictionaryGetTypeID();
                if (TypeID != CFGetTypeID(v31))
                  goto LABEL_97;
                v37 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)v31);
                if (v30)
                {
                  v38 = CFDataGetTypeID();
                  if (v38 == CFGetTypeID(v30))
                    CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v30);
                }
                v39 = v30;
                if (!*(_BYTE *)(v12 + 3688))
                {
                  v40 = sub_100064FE0(1);
                  CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v40);
                  CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(v12 + 3712));
                  if (v40)
                    CFRelease(v40);
                }
                sub_10002C478((uint64_t)v33, CFSTR("PRIVATE_MAC_ADDRESS"), v37);
                if (v62 && v62 == kCFBooleanTrue)
                {
                  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  CFDictionarySetValue(Mutable, CFSTR("PrivateMacDefaultToOFF"), kCFBooleanTrue);
                  if (!v63)
                  {
LABEL_82:
                    sub_10002C478((uint64_t)v33, CFSTR("PrivateMacInfoDictionary"), Mutable);
                    if (Mutable)
                      CFRelease(Mutable);
                    goto LABEL_95;
                  }
LABEL_81:
                  CFDictionarySetValue(Mutable, CFSTR("PrivateMacControlledDevice"), v63);
                  goto LABEL_82;
                }
                if (v63 && v63 == kCFBooleanTrue)
                {
                  v45 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  Mutable = v45;
                  if (v62)
                    CFDictionarySetValue(v45, CFSTR("PrivateMacDefaultToOFF"), v62);
                  goto LABEL_81;
                }
                v52 = (uint64_t)v33;
                v53 = CFSTR("PrivateMacInfoDictionary");
                v54 = 0;
LABEL_94:
                sub_10002C478(v52, v53, v54);
LABEL_95:
                v30 = v39;
                v28 = v61;
                if (v37)
                  CFRelease(v37);
                goto LABEL_97;
              }
              v39 = v30;
              v42 = _os_feature_enabled_impl("WiFiManager", "PrivateMacRotation");
              v37 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (*(_BYTE *)(v12 + 3688))
              {
                if (sub_10000BE8C((uint64_t)v33))
                {
                  if ((v42 & 1) == 0)
                  {
                    v48 = sub_100064FE0(1);
                    CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v48);
                    v51 = *(CFNumberRef *)(v12 + 3712);
                    v49 = v37;
                    v50 = CFSTR("PRIVATE_MAC_ADDRESS_VALUE");
                    goto LABEL_91;
                  }
                  v43 = sub_100064FE0(3);
                  CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v43);
                  if (v43)
                    CFRelease(v43);
LABEL_86:
                  if (sub_1000CEC50(v33))
                    v47 = 2;
                  else
                    v47 = 3;
                  v48 = sub_100064FE0(v47);
                  v49 = v37;
                  v50 = CFSTR("PRIVATE_MAC_ADDRESS_TYPE");
                  v51 = v48;
LABEL_91:
                  CFDictionarySetValue(v49, v50, v51);
                  if (v48)
                    CFRelease(v48);
                  goto LABEL_93;
                }
                v46 = sub_100064FE0(2);
                CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v46);
              }
              else
              {
                v44 = sub_100064FE0(1);
                CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v44);
                CFDictionarySetValue(v37, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(v12 + 3712));
                if (v44)
                  CFRelease(v44);
              }
              v17 = v59;
              if (!v42)
              {
LABEL_93:
                v52 = (uint64_t)v33;
                v53 = CFSTR("PRIVATE_MAC_ADDRESS");
                v54 = v37;
                goto LABEL_94;
              }
              goto LABEL_86;
            }
LABEL_100:
            v11 = v57;
            v10 = v58;
          }
        }
        else
        {
          MutableCopy = 0;
        }
        (*(void (**)(uint64_t, uint64_t, const __CFArray *, _QWORD, _QWORD))(a6 + 8))(v12, a2, MutableCopy, v60, *(_QWORD *)(a6 + 24));
        if (MutableCopy)
          CFRelease(MutableCopy);
        goto LABEL_104;
      }
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      if (a4)
        goto LABEL_9;
    }
    if (!kCFBooleanFalse)
      goto LABEL_17;
    goto LABEL_13;
  }
  v56 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "WiFiDeviceManagerClientScanCallback");
  objc_autoreleasePoolPop(v56);
  v17 = 0;
LABEL_107:

  if (v11)
  objc_autoreleasePoolPop(v10);
}

uint64_t sub_100019A60(uint64_t a1, void *a2, size_t a3, _QWORD *a4)
{
  NSObject *v7;
  void **p_src;
  uint64_t result;
  uint64_t v10;
  void *__src;
  size_t __len;

  __src = 0;
  __len = a3;
  v10 = 0;
  if (a1)
  {
    v7 = *(NSObject **)(a1 + 64);
    if (v7)
      dispatch_source_set_timer(v7, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
  if (!sub_10001C904(a1, 0))
  {
    result = 4294963394;
    if (!a4)
      return result;
    goto LABEL_14;
  }
  if (a2)
    p_src = &__src;
  else
    p_src = 0;
  if (!sub_10001E3EC(a1, p_src, (CFIndex *)&__len, &v10) && __src)
    memmove(a2, __src, __len);
  result = sub_10001CA04(a1, 0, v10);
  if (!(_DWORD)result)
  {
    sub_100019C54(a1, 0);
    result = 0;
  }
  if (a4)
LABEL_14:
    *a4 = v10;
  return result;
}

uint64_t sub_100019B38(uint64_t a1, const UInt8 *a2, CFIndex a3, _QWORD *a4)
{
  uint64_t result;
  CFIndex Count;
  CFIndex v10;
  uint64_t v11;
  __CFData *Mutable;
  __CFData *v13;

  result = 4294963394;
  if (a2 && a3)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
    v10 = *(_QWORD *)(a1 + 24);
    if (v10 && Count >= v10)
      return 4294963394;
    v11 = sub_10001C904(a1, 0);
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, a3 + 8);
    if (!Mutable)
    {
      return 4294963394;
    }
    else
    {
      v13 = Mutable;
      ++qword_10026DBC0;
      CFDataAppendBytes(Mutable, (const UInt8 *)&qword_10026DBC0, 8);
      CFDataAppendBytes(v13, a2, a3);
      CFDataSetLength(v13, a3 + 8);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v13);
      if (a4)
        *a4 = qword_10026DBC0;
      if (!v11)
      {
        *(_QWORD *)(a1 + 88) = sub_10001E1C8((uint64_t)"WiFiCommandQueueEnqueue");
        sub_100019C54(a1, 1);
      }
      CFRelease(v13);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100019C54(uint64_t a1, int a2)
{
  CFIndex Count;
  CFIndex v5;
  void *v6;
  void *v7;
  NSObject *v8;
  _QWORD block[5];

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  v5 = Count;
  if (Count < 11)
  {
    if (!Count)
      return 0;
    if (!a2)
    {
LABEL_12:
      sub_10001C868(a1);
      return 0;
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cmdQueue size %ld exceeding recurse limit of %ld. Back to runloop.", "WiFiCommandQueueSignal", v5, 10);
    objc_autoreleasePoolPop(v6);
  }
  if (!*(_QWORD *)(a1 + 48))
    goto LABEL_12;
  if (*(_BYTE *)(a1 + 72))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timer is running. Will not signal cmdQueue", "WiFiCommandQueueSignal");
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    CFRetain((CFTypeRef)a1);
    v8 = *(NSObject **)(a1 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100019E40;
    block[3] = &unk_10022EA38;
    block[4] = a1;
    dispatch_async(v8, block);
  }
  return 0;
}

uint64_t sub_100019D8C(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  CFTypeRef v14;
  CFTypeRef v15;
  uint64_t v16;

  v14 = CFRetain(cf);
  v15 = CFRetain(a3);
  v16 = sub_10001C71C(a1, 0, a4, (uint64_t)v14, (uint64_t)v15, a5, a6, 0, a7);
  if ((_DWORD)v16)
  {
    if (cf)
      CFRelease(cf);
    if (a3)
      CFRelease(a3);
  }
  return v16;
}

void sub_100019E40(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2[6])
  {
    sub_10001C868((uint64_t)v2);
    v2 = *(_QWORD **)(a1 + 32);
  }
  CFRelease(v2);
}

uint64_t sub_100019E70(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  void *v8;
  uint64_t v9;
  void *v11;
  void *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  const __CFDictionary *v18;
  uint64_t v19;
  CFTypeRef *v20;
  void *v21;
  void *v22;
  NSString *v23;
  const char *v24;
  CFTypeID v25;
  const void *v27;
  uint64_t v28;
  const void *v29;
  CFTypeID v30;
  void *v31;
  int i1;
  uint64_t v33;
  const __CFArray *Mutable;
  const void *v36;
  const void *v37;
  void (*v38)(uint64_t, const void *, uint64_t, uint64_t);
  uint64_t v39;
  const void *v40;
  CFTypeID v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  IOPMAssertionID v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  const __CFArray *v52;
  const __CFAllocator *v53;
  __CFArray *v54;
  CFIndex v55;
  const __CFDictionary *v56;
  const __CFDictionary *v57;
  __CFDictionary *v58;
  const __CFNumber *v59;
  void *v60;
  CFNumberRef v61;
  CFNumberRef v62;
  void *v63;
  uint64_t v64;
  double v65;
  int mm;
  uint64_t v67;
  const void *v69;
  const __CFDictionary *v70;
  const void *v71;
  void *v72;
  CFTypeID v73;
  void *v74;
  void *v75;
  const char *v76;
  void *v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  const __CFArray *v81;
  const void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  CFTypeID v88;
  uint64_t v89;
  const void *v90;
  const void *v91;
  CFTypeID v92;
  void *v93;
  void *v94;
  const void *v95;
  uint64_t v96;
  void *v97;
  NSString *v98;
  const char *v99;
  void *v100;
  const void *v101;
  _BOOL4 v102;
  const void *v103;
  unsigned int v104;
  const void *v105;
  void *v106;
  const void *v107;
  uint64_t v108;
  const void *v109;
  CFTypeID v110;
  void *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  const void *v115;
  CFTypeID v116;
  void *v117;
  void (*v118)(uint64_t, const void *, uint64_t, uint64_t);
  uint64_t v119;
  const void *v120;
  CFTypeID v121;
  void *v122;
  const void *v123;
  const void *v124;
  uint64_t v125;
  void (*v126)(uint64_t, const void *, uint64_t, uint64_t);
  const __CFString *v127;
  const void *v128;
  uint64_t v129;
  const void *v130;
  CFTypeRef v131;
  uint64_t v132;
  const void *v133;
  uint64_t v134;
  CFTypeID v135;
  void *v136;
  int j;
  uint64_t v138;
  const __CFNumber *v140;
  const __CFBoolean *v141;
  int v142;
  int i;
  uint64_t v144;
  int m;
  uint64_t v147;
  const __CFNumber *Value;
  double v150;
  double v151;
  const __CFAllocator *v152;
  double v153;
  int nn;
  uint64_t v155;
  int k;
  uint64_t v158;
  int n;
  uint64_t v161;
  const void *v163;
  CFTypeRef v164;
  void *v165;
  const __CFBoolean *v166;
  void *v167;
  uint64_t v168;
  __CFArray *v169;
  NSObject *v170;
  const __CFBoolean *v171;
  const void *v172;
  void *v173;
  const void *v174;
  const void *v175;
  uint64_t v176;
  double v177;
  CFIndex v178;
  uint64_t v179;
  const __CFArray *v180;
  void *v181;
  const void *v182;
  uint64_t v183;
  uint64_t v184;
  const __CFDictionary *v185;
  double v186;
  const void *v187;
  const void *v188;
  __CFArray *v189;
  CFMutableArrayRef v190;
  _BOOL4 v191;
  const __CFArray *v192;
  __CFArray *v193;
  CFIndex v194;
  CFIndex v195;
  CFIndex ii;
  const void *v197;
  const void *v198;
  CFIndex v199;
  CFIndex v200;
  uint64_t v201;
  CFIndex jj;
  const __CFDictionary *v203;
  const __CFDictionary *v204;
  const void *v205;
  const void *v206;
  const void *v207;
  CFIndex v208;
  const void *v209;
  const void *v210;
  const void *v211;
  __CFArray *v212;
  __CFArray *v213;
  const __CFArray *v214;
  const __CFArray *v215;
  void *v217;
  _BOOL4 v218;
  const __CFArray *v219;
  const __CFArray *v220;
  CFMutableDictionaryRef MutableCopy;
  __CFArray *v222;
  __CFArray *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  double v228;
  CFMutableSetRef v229;
  const __CFSet *v230;
  int v231;
  double v232;
  CFIndex Count;
  int v234;
  int v235;
  const void *ValueAtIndex;
  double Current;
  uint64_t v238;
  const __CFDictionary *v239;
  double v240;
  double v241;
  CFMutableArrayRef v242;
  __CFArray *v243;
  CFMutableArrayRef v244;
  __CFArray *v245;
  __CFArray *v246;
  CFMutableArrayRef v247;
  CFIndex v248;
  CFIndex v249;
  const void *v250;
  int v251;
  CFIndex v252;
  CFIndex v253;
  const void *v254;
  const void *v255;
  const __CFArray *v256;
  const __CFArray *v257;
  CFIndex v258;
  const void *v259;
  const void *v260;
  CFIndex v261;
  const void *v262;
  __CFDictionary *v263;
  __CFDictionary *v264;
  const __CFNumber *v265;
  int v266;
  unsigned __int8 v267;
  int v268;
  __CFArray *v269;
  __CFArray *v270;
  uint64_t v271;
  void *v272;
  void *v273;
  CFIndex v274;
  void *v275;
  NSObject *v276;
  void *v277;
  void *v278;
  void *v279;
  CFTypeRef v280;
  CFTypeID v281;
  uint64_t v282;
  const __CFNumber *v283;
  const char *v284;
  const char *v285;
  const char *v286;
  const void *v287;
  const char *v288;
  void *v289;
  CFIndex v290;
  uint64_t v291;
  __CFArray *v292;
  const __CFArray *v293;
  CFIndex kk;
  const __CFDictionary *v295;
  const void *v296;
  const void *v297;
  const void *v298;
  void *v299;
  const void *v300;
  const void *v301;
  void *v302;
  void *v303;
  void *v304;
  const __CFArray *v305;
  const __CFArray *v306;
  NSObject *v307;
  void *v308;
  void *v309;
  const void *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  int v315;
  const void *v316;
  CFTypeRef *v317;
  const __CFDictionary *v318;
  const void *v319;
  int v320;
  CFMutableArrayRef v321;
  __CFArray *v322;
  CFTypeRef cf1;
  const __CFDictionary *cf1a;
  __CFArray *v325;
  CFArrayRef v326;
  __CFArray *v327;
  CFMutableArrayRef v328;
  CFArrayRef theArray[2];
  const __CFArray *theArraya;
  int theArrayb;
  uint64_t v332;
  CFArrayRef v333[2];
  const __CFArray *v334;
  CFIndex FirstIndexOfValue;
  CFAllocatorRef allocator[2];
  const void *allocatora;
  CFAllocatorRef allocatorb[2];
  CFIndex v339;
  unint64_t v340;
  double valuePtr;
  __int128 buf;
  void (*v343)(uint64_t);
  void *v344;
  uint64_t v345;
  CFRange v346;
  CFRange v347;
  CFRange v348;
  CFRange v349;
  CFRange v350;
  CFRange v351;
  CFRange v352;

  v339 = 72;
  if (!a2)
  {
    v279 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "__WiFiDeviceCommandQueueCallback");
    goto LABEL_475;
  }
  if (!a1)
  {
    v279 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null command queue ref ", "__WiFiDeviceCommandQueueCallback");
LABEL_475:
    objc_autoreleasePoolPop(v279);
    return 4294963394;
  }
  v340 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (_QWORD *)(a2 + 184);
  if (sub_10001E3EC(a1, &v340, &v339, (_QWORD *)(a2 + 184)))
    return 4294963394;
  while (1)
  {
    v6 = sub_10001EA60((CFNumberRef)a2, 0, *(_DWORD *)v340);
    if ((uint64_t)v6 <= *(_QWORD *)(v340 + 64))
      break;
    v7 = v6;
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Deferring command type: \"%@\" because its priority (%ld) is less than the minimum allowed priority (%ld) for this command type", sub_10001C840(*(_DWORD *)v340), *(_QWORD *)(v340 + 64), v7);
    objc_autoreleasePoolPop(v8);
    sub_100154AC0(*(_QWORD *)(a2 + 176), *(_QWORD *)(a2 + 184));
    if (sub_10001E3EC(a1, &v340, &v339, v5))
      return 4294963394;
  }
  *(_BYTE *)(v340 + 56) = 1;
  v11 = objc_autoreleasePoolPush();
  v12 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v13 = sub_10001C840(*(_DWORD *)v340);
    objc_msgSend(v12, "WFLog:message:", 3, "Dequeuing command type: \"%@\" pending commands: %ld", v13, sub_10001C860(*(_QWORD *)(a2 + 176)) - 1);
  }
  objc_autoreleasePoolPop(v11);
  v14 = *(_QWORD *)(a2 + 176);
  if (v340)
  {
    if (*(_DWORD *)v340 == 1)
    {
      if (sub_10002DAB4(*(_QWORD *)(v340 + 16)))
        v15 = 40;
      else
        v15 = 30;
    }
    else
    {
      v15 = 30;
    }
  }
  else
  {
    v15 = 0;
  }
  sub_100154C48(v14, v15);
  switch(*(_DWORD *)v340)
  {
    case 0:
      v17 = *(const void **)(v340 + 8);
      v18 = *(const __CFDictionary **)(v340 + 16);
      v19 = *(_QWORD *)(v340 + 24);
      v20 = *(CFTypeRef **)(v340 + 32);
      valuePtr = 0.0;
      v21 = (void *)sub_10002DEA0(a2, v17);
      v22 = objc_autoreleasePoolPush();
      if (!v21)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", v17);
        v77 = v22;
        goto LABEL_96;
      }
      if (qword_10026DD20)
      {
        v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("SCAN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Attempting Apple80211ScanAsync on %@"), v17)), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v24 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v23, "UTF8String")), "UTF8String");
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = v24;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v22);
      v25 = CFGetTypeID(v21);
      if (v25 == sub_10002DE64())
        return sub_10015D988((uint64_t *)v21, (uint64_t)v18, v19, (uint64_t)v20);
      *(_QWORD *)(a2 + 4728) = v19;
      *(_QWORD *)(a2 + 4736) = v20;
      Value = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("SCAN_MAXAGE"));
      if (Value && !CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
        valuePtr = 0.0;
      v150 = valuePtr;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        v151 = 30.0;
      else
        v151 = 14.0;
      v152 = kCFAllocatorDefault;
      if (v150 >= v151)
      {
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          v153 = 30.0;
        else
          v153 = 14.0;
      }
      else
      {
        v153 = valuePtr;
      }
      valuePtr = v153;
      v166 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("BeaconCacheOnly"));
      if (v166 && CFBooleanGetValue(v166))
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        sub_100071C00(a2, (uint64_t)Mutable);
        if (CFArrayGetCount(Mutable))
        {
          v167 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: using scan cache (%ld) to serve scan request", "__WiFiDeviceScanAsyncQueued", CFArrayGetCount(Mutable));
          objc_autoreleasePoolPop(v167);
          v169 = sub_100071D5C(a2, v168, v18, Mutable, 1);
          sub_100079840(a2, v169, 1);
          sub_10001C6DC(a2, v18);
          if (v169)
            CFRelease(v169);
          if (*(_QWORD *)(a2 + 64))
          {
            CFRetain((CFTypeRef)a2);
            v170 = *(NSObject **)(a2 + 64);
            *(_QWORD *)&buf = _NSConcreteStackBlock;
            *((_QWORD *)&buf + 1) = 3221225472;
            v343 = sub_10007989C;
            v344 = &unk_10022EA38;
            v345 = a2;
            dispatch_async(v170, &buf);
          }
          else
          {
            v278 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceScanAsyncQueued");
            objc_autoreleasePoolPop(v278);
          }
          v9 = 0;
        }
        else
        {
          sub_100016A94(a2, *(_QWORD *)(a2 + 112), 0, 0, 0);
          v9 = 4294963396;
        }
LABEL_102:
        if (!Mutable)
          return v9;
LABEL_103:
        v81 = Mutable;
LABEL_157:
        CFRelease(v81);
        return v9;
      }
      v171 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("CacheOnly"));
      if (v171)
        v315 = CFBooleanGetValue(v171);
      else
        v315 = 0;
      v228 = valuePtr;
      if (valuePtr == 0.0)
      {
        v270 = 0;
      }
      else
      {
        v317 = v20;
        v319 = v17;
        v322 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (v322)
        {
          v229 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
          if (!v229)
            goto LABEL_433;
          v230 = v229;
          v231 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
          v232 = 14.0;
          if (v231)
            v232 = 30.0;
          sub_10001740C(*(const __CFArray **)(a2 + 5696), v232);
          Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 5696));
          v234 = sub_100079A24(a2, v18, v230);
          LOBYTE(v235) = 0;
          if (!v234 && Count >= 1)
          {
            v235 = 0;
            cf1a = v18;
            while (1)
            {
              v326 = (CFArrayRef)(Count - 1);
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 5696), Count - 1);
              Current = CFAbsoluteTimeGetCurrent();
              v238 = sub_1000D720C((uint64_t)ValueAtIndex);
              if (!v238
                || (v239 = (const __CFDictionary *)v238, v240 = sub_10015B27C((uint64_t)ValueAtIndex), v240 == 0.0)
                || (v241 = Current - v240, v228 >= 0.0) && v241 > v228
                || (v242 = CFArrayCreateMutable(v152, 0, &kCFTypeArrayCallBacks)) == 0)
              {
                v266 = 0;
                goto LABEL_424;
              }
              v243 = v242;
              v328 = (CFMutableArrayRef)Count;
              theArrayb = v235;
              v244 = CFArrayCreateMutable(v152, 0, &kCFTypeArrayCallBacks);
              if (v244)
                break;
              v266 = 0;
              v247 = v243;
LABEL_423:
              CFRelease(v247);
LABEL_424:
              v235 |= v266;
              v234 = sub_100079A24(a2, v18, v230);
              if (Count >= 2)
              {
                Count = (CFIndex)v326;
                v152 = kCFAllocatorDefault;
                if (!v234)
                  continue;
              }
              goto LABEL_426;
            }
            v245 = v244;
            v246 = CFArrayCreateMutable(v152, 0, &kCFTypeArrayCallBacks);
            if (v246)
            {
              v247 = CFArrayCreateMutable(v152, 0, &kCFTypeArrayCallBacks);
              if (v247)
              {
                sub_100079DD4(v18, v243);
                sub_100079DD4(v239, v245);
                if (CFArrayGetCount(v243) >= 1)
                {
                  v248 = 0;
                  do
                  {
                    v249 = CFArrayGetCount(v245);
                    v250 = CFArrayGetValueAtIndex(v243, v248);
                    v347.location = 0;
                    v347.length = v249;
                    if (CFArrayGetFirstIndexOfValue(v245, v347, v250) == -1)
                      goto LABEL_413;
                  }
                  while (++v248 < CFArrayGetCount(v243));
                }
                v18 = cf1a;
                sub_100079AE8(a2, cf1a, v246);
                sub_100079AE8(a2, v239, v247);
                if (CFArrayGetCount(v246) >= 1)
                {
                  v251 = 0;
                  v252 = 0;
                  do
                  {
                    v253 = CFArrayGetCount(v247);
                    v254 = CFArrayGetValueAtIndex(v246, v252);
                    v348.location = 0;
                    v348.length = v253;
                    if (CFArrayGetFirstIndexOfValue(v247, v348, v254) != -1)
                    {
                      v255 = CFArrayGetValueAtIndex(v246, v252);
                      CFSetAddValue(v230, v255);
                      v251 = 1;
                    }
                    ++v252;
                  }
                  while (v252 < CFArrayGetCount(v246));
                  if (!v251)
                  {
LABEL_413:
                    v266 = 0;
                    goto LABEL_414;
                  }
                  v256 = (const __CFArray *)sub_1000C053C((uint64_t)ValueAtIndex);
                  if (!v256)
                  {
LABEL_412:
                    v266 = 1;
LABEL_414:
                    v18 = cf1a;
                    goto LABEL_420;
                  }
                  v257 = v256;
                  v18 = cf1a;
                  if (CFArrayGetCount(v256))
                  {
                    v349.length = CFArrayGetCount(v243);
                    v349.location = 0;
                    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v243, v349, &stru_100238178);
                    if (CFArrayGetCount(v257) >= 1)
                    {
                      v258 = 0;
                      do
                      {
                        v259 = CFArrayGetValueAtIndex(v257, v258);
                        if (v259)
                        {
                          v260 = v259;
                          if (FirstIndexOfValue != -1
                            || (v261 = CFArrayGetCount(v243),
                                v262 = sub_10002B088(v260),
                                v350.location = 0,
                                v350.length = v261,
                                CFArrayGetFirstIndexOfValue(v243, v350, v262) != -1))
                          {
                            v263 = sub_100079EC8((uint64_t)v260);
                            if (v263)
                            {
                              v264 = v263;
                              v351.length = CFArrayGetCount(v246);
                              v351.location = 0;
                              if (CFArrayGetFirstIndexOfValue(v246, v351, v264) != -1)
                              {
                                v265 = sub_100017A54((uint64_t)v260, CFSTR("ORIG_AGE"));
                                sub_10002B698((uint64_t)v260, CFSTR("AGE"), (uint64_t)v265 + (v241 * 1000.0));
                                CFArrayAppendValue(v322, v260);
                              }
                              CFRelease(v264);
                            }
                          }
                        }
                        ++v258;
                      }
                      while (v258 < CFArrayGetCount(v257));
                      goto LABEL_412;
                    }
                  }
                  v266 = 1;
LABEL_420:
                  CFRelease(v243);
                  CFRelease(v245);
                  if (v246)
                    CFRelease(v246);
                  v235 = theArrayb;
                  Count = (CFIndex)v328;
                  if (!v247)
                    goto LABEL_424;
                  goto LABEL_423;
                }
              }
            }
            else
            {
              v247 = 0;
            }
            v266 = 0;
            goto LABEL_420;
          }
LABEL_426:
          v267 = v228 >= 0.0 ? v234 : v235;
          v268 = v267;
          CFRelease(v230);
          if (v268)
          {
            v20 = v317;
            v17 = v319;
            if (CFArrayGetCount(v322))
            {
              v269 = sub_1000176C4(v322, 0, v18);
              v270 = sub_1000173D8(v269);
              if (v269)
                CFRelease(v269);
            }
            else
            {
              v270 = 0;
            }
          }
          else
          {
LABEL_433:
            v270 = 0;
            v20 = v317;
            v17 = v319;
          }
          CFRelease(v322);
        }
        else
        {
          v270 = 0;
        }
      }
      v272 = objc_autoreleasePoolPush();
      v273 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        if (v270)
          v274 = CFArrayGetCount(v270);
        else
          v274 = 0;
        objc_msgSend(v273, "WFLog:message:", 3, "%s: network records count: %lu ", "__WiFiDeviceCopyPreparedScanResults", v274);
      }
      objc_autoreleasePoolPop(v272);
      if (v270)
      {
        v275 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ScanCache: Successfully Retrieved Scan Results from Scan Cache.");
        objc_autoreleasePoolPop(v275);
        sub_100079840(a2, v270, 1);
        sub_10001C6DC(a2, v18);
        CFRelease(v270);
        if (*(_QWORD *)(a2 + 64))
        {
          CFRetain((CFTypeRef)a2);
          v276 = *(NSObject **)(a2 + 64);
          *(_QWORD *)&buf = _NSConcreteStackBlock;
          *((_QWORD *)&buf + 1) = 3221225472;
          v343 = sub_100079960;
          v344 = &unk_10022EA38;
          v345 = a2;
          dispatch_async(v276, &buf);
        }
        else
        {
          v277 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceScanAsyncQueued");
          objc_autoreleasePoolPop(v277);
        }
        return 0;
      }
      else
      {
        if (v315)
        {
          sub_100016A94(a2, *(_QWORD *)(a2 + 112), 0, 0, 0);
          return 4294963396;
        }
        v9 = Apple80211ScanAsync(*(_QWORD *)(a2 + 16), v18);
        if ((_DWORD)v9)
        {
          if (v20)
          {
            if (*v20)
            {
              CFRetain(*v20);
              v280 = *v20;
              if (*v20)
              {
                v281 = CFGetTypeID(v280);
                v282 = sub_1000E78F0();
                v280 = *v20;
                if (v281 == v282)
                {
                  *(_WORD *)(sub_1001186A4((uint64_t)v280) + 434) = v9;
                  v280 = *v20;
                }
              }
              CFRelease(v280);
              sub_100016A94(a2, (uint64_t)v17, 0, 0, v9);
            }
            else
            {
              v304 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager from scan data", "__WiFiDeviceScanAsyncQueued");
              objc_autoreleasePoolPop(v304);
            }
          }
          else
          {
            v303 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null scanData", "__WiFiDeviceScanAsyncQueued");
            objc_autoreleasePoolPop(v303);
            return 12;
          }
        }
        else
        {
          sub_10001C6DC(a2, v18);
        }
      }
      return v9;
    case 1:
      v94 = *(void **)(v340 + 16);
      allocatora = *(const void **)(v340 + 8);
      v95 = *(const void **)(v340 + 24);
      *(_OWORD *)theArray = *(_OWORD *)(v340 + 32);
      if (sub_10002DAB4((uint64_t)v94))
        v96 = 40;
      else
        v96 = 30;
      *(_OWORD *)(a2 + 4776) = *(_OWORD *)theArray;
      v97 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v98 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Attempting Apple80211AssociateAsync to %@"), sub_10002B088(v94))), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          v99 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v98, "UTF8String")), "UTF8String");
          LODWORD(buf) = 136446210;
          *(_QWORD *)((char *)&buf + 4) = v99;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v97);
      v100 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Starting %d second(s) timer to complete association", "__WiFiDeviceAssociateAsyncQueued", v96);
      objc_autoreleasePoolPop(v100);
      LOBYTE(buf) = 0;
      if (!v94)
      {
        v9 = 4294963396;
        goto LABEL_502;
      }
      v101 = sub_10002B088(v94);
      v102 = sub_1000C5964((uint64_t)v94);
      v103 = allocatora;
      if (sub_10002DAB4((uint64_t)v94))
      {
        if (v102)
        {
          v104 = sub_1000C5BD8(v94);
          v105 = 0;
          if (!v95)
          {
            if (v104)
            {
              v105 = sub_1000C37A0((CFDictionaryRef *)v94);
              if (!v105)
              {
                v106 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No password for one time password network %@ ", sub_10002B088(v94), v311, v312);
LABEL_501:
                objc_autoreleasePoolPop(v106);
                v9 = 4294967196;
LABEL_502:
                v103 = allocatora;
                goto LABEL_445;
              }
            }
          }
        }
        else
        {
          v105 = 0;
        }
        if (v95)
          v172 = v95;
        else
          v172 = v105;
        v173 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join EAP network: %@", sub_10002B088(v94));
        objc_autoreleasePoolPop(v173);
        v174 = sub_10002BF8C(a2, allocatora);
        if (v174)
        {
          v175 = v174;
          if (!CFEqual(v174, v94) || sub_1000D71FC(*(_QWORD *)(a2 + 144)) != 5)
            sub_100072F84(a2, allocatora, v176, *(_DWORD *)(a2 + 5800), "__WiFiDeviceAssociateEAP", 10602);
          CFRelease(v175);
        }
        v9 = sub_100147A9C(*(_QWORD *)(a2 + 144), v94, v172);
        if ((_DWORD)v9 != -3900 || sub_10002BE64((uint64_t)v94, CFSTR("EnterpriseProfile")))
        {
          if (!v105)
            goto LABEL_444;
          goto LABEL_443;
        }
        v225 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: EAP association failed with param error and no configuration. Falling back to non-EAP association...", "__WiFiDeviceAssociate");
        objc_autoreleasePoolPop(v225);
      }
      else
      {
        v105 = 0;
      }
      if (!v102)
        goto LABEL_438;
      if (!v95)
      {
        v105 = (const void *)sub_1000C6348((CFDictionaryRef *)v94, (BOOL *)&buf, 3.0);
        if (!v105)
        {
          v105 = (const void *)sub_1000C64BC(v94, (BOOL *)&buf, 3.0);
          v106 = objc_autoreleasePoolPush();
          v226 = (void *)qword_10026DD20;
          if (!v105)
          {
            if (qword_10026DD20)
            {
              v287 = sub_10002B088(v94);
              if ((_BYTE)buf)
                v288 = ", although keychain fetch did time out";
              else
                v288 = "";
              objc_msgSend(v226, "WFLog:message:", 4, "%s: No password returned for %@%s", "__WiFiDeviceAssociate", v287, v288);
            }
            goto LABEL_501;
          }
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: found password with non-syncable attribute for network %@.", "__WiFiDeviceAssociate", sub_10002B088(v94));
          objc_autoreleasePoolPop(v106);
          v103 = allocatora;
        }
      }
      if (sub_1000C433C((const __CFDictionary *)v94))
      {
        v227 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join SAE (transition mode = %d) network: %@", sub_10003145C((uint64_t)v94), v101, v312, v313, v314);
LABEL_372:
        v103 = allocatora;
        goto LABEL_437;
      }
      if (sub_10003145C((uint64_t)v94))
      {
        v227 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join WPA network: %@", v101);
      }
      else
      {
        if (sub_1000C3B8C((_BOOL8)v94))
        {
          if (sub_10002BE64((uint64_t)v94, CFSTR("WEP_AUTH_Flags")))
          {
            v283 = sub_100017A54((uint64_t)v94, CFSTR("WEP_AUTH_Flags"));
            v227 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              if ((v283 & 1) != 0)
                v284 = "40 Bit";
              else
                v284 = "104 Bit";
              if ((v283 & 4) != 0)
                v285 = "Open";
              else
                v285 = "Shared";
              if ((v283 & 2) != 0)
                v286 = "Hashed";
              else
                v286 = "Unhashed";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join %s %s %s (0x%lx) WEP network: %@", v284, v285, v286, v283, sub_10002B088(v94));
            }
          }
          else
          {
            v227 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join WEP network: %@", sub_10002B088(v94), v311, v312, v313, v314);
          }
          goto LABEL_372;
        }
        v227 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting to join: %@", v101);
      }
LABEL_437:
      objc_autoreleasePoolPop(v227);
LABEL_438:
      if (v95)
        v271 = (uint64_t)v95;
      else
        v271 = (uint64_t)v105;
      v9 = sub_1000723DC(a2, v103, v94, v271, (uint64_t)sub_10007A77C, 0);
      if (v105 && !(_BYTE)buf)
LABEL_443:
        CFRelease(v105);
LABEL_444:
      if (!(_DWORD)v9)
        return v9;
LABEL_445:
      sub_100079FD4(a2, (uint64_t)v103, v94, 0, v9);
      return v9;
    case 2:
      kdebug_trace(731381828, 0, 0, 0, 0);
      v78 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Disassociating.");
      objc_autoreleasePoolPop(v78);
      v80 = sub_100072F84(a2, *(const void **)(v340 + 8), v79, *(_DWORD *)(a2 + 5800), "__WiFiDeviceDisassociateQueued", 10660);
      goto LABEL_151;
    case 3:
      v82 = *(const void **)(v340 + 8);
      v83 = *(_QWORD *)(v340 + 16);
      v85 = *(_QWORD *)(v340 + 24);
      v84 = *(_QWORD *)(v340 + 32);
      v86 = (uint64_t *)sub_10002DEA0(a2, v82);
      if (!v86)
        goto LABEL_524;
      v87 = v86;
      v88 = CFGetTypeID(v86);
      if (v88 != sub_10002DE64())
      {
        *(_QWORD *)(a2 + 4656) = v85;
        *(_QWORD *)(a2 + 4664) = v84;
        for (i = 6; ; --i)
        {
          v144 = Apple80211Set(*(_QWORD *)(a2 + 16), 24, 1, v83, 8);
          v9 = v144;
          if ((int)v144 <= 15)
          {
            if ((_DWORD)v144 != -3905)
              goto LABEL_236;
          }
          else if ((_DWORD)v144 != 61 && (_DWORD)v144 != 16)
          {
            goto LABEL_237;
          }
          if (!i)
          {
LABEL_236:
            if (!(_DWORD)v144)
              return v9;
LABEL_237:
            sub_10007A780(a2, (uint64_t)v82, v144);
            return v9;
          }
          usleep(0x7A120u);
        }
      }
      return sub_10015DBDC(v87, (uint64_t)v82, v83, v85, v84);
    case 4:
      v37 = *(const void **)(v340 + 8);
      v38 = *(void (**)(uint64_t, const void *, uint64_t, uint64_t))(v340 + 16);
      v39 = *(_QWORD *)(v340 + 24);
      v40 = sub_10002DEA0(a2, v37);
      if (v40)
      {
        v41 = CFGetTypeID(v40);
        if (v41 == sub_10002DE64())
          goto LABEL_356;
        v48 = *(_DWORD *)(a2 + 4024);
        if (v48)
          IOPMAssertionRelease(v48);
        v49 = *(_QWORD *)(a2 + 4032);
        if (!v49)
          goto LABEL_356;
        if (_MISStopService)
        {
          v50 = _MISStopService(v49, a2 + 4040, v42, v43, v44, v45, v46, v47);
          if (!v50)
          {
LABEL_356:
            v9 = sub_100072F84(a2, v37, v42, *(_DWORD *)(a2 + 5800), "__WiFiDeviceStopNetworkQueued", 3105);
            if (v38)
              v38(a2, v37, v9, v39);
            goto LABEL_358;
          }
        }
        else
        {
          v50 = -1;
        }
        v224 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unable to shutdown mobile internet sharing: %s\n", strerror(v50));
        objc_autoreleasePoolPop(v224);
        goto LABEL_356;
      }
      v74 = objc_autoreleasePoolPush();
      v75 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_95;
      v310 = v37;
LABEL_534:
      v76 = "Unknown interface %@";
LABEL_94:
      objc_msgSend(v75, "WFLog:message:", 4, v76, v310);
LABEL_95:
      v77 = v74;
LABEL_96:
      objc_autoreleasePoolPop(v77);
      return 4294963396;
    case 5:
      v107 = *(const void **)(v340 + 8);
      v108 = *(_QWORD *)(v340 + 16);
      *(_OWORD *)allocatorb = *(_OWORD *)(v340 + 24);
      v109 = sub_10002DEA0(a2, v107);
      *(_OWORD *)(a2 + 4672) = *(_OWORD *)allocatorb;
      v110 = CFGetTypeID(v109);
      if (v110 != sub_10002DE64())
      {
        for (j = 6; ; --j)
        {
          v138 = Apple80211Set(*(_QWORD *)(a2 + 16), 25, 1, v108, 8);
          v9 = v138;
          if ((int)v138 <= 15)
          {
            if ((_DWORD)v138 != -3905)
              goto LABEL_233;
          }
          else if ((_DWORD)v138 != 61 && (_DWORD)v138 != 16)
          {
            goto LABEL_234;
          }
          if (!j)
          {
LABEL_233:
            if (!(_DWORD)v138)
              return v9;
LABEL_234:
            v112 = a2;
            v113 = (uint64_t)v107;
            v114 = v9;
            goto LABEL_235;
          }
          usleep(0x7A120u);
        }
      }
      v111 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Start WiFi Direct Group is not supported by %@", v107);
      objc_autoreleasePoolPop(v111);
      v9 = 4294963396;
      v112 = a2;
      v113 = (uint64_t)v107;
      v114 = 4294963396;
LABEL_235:
      sub_10006A18C(v112, v113, v114);
      return v9;
    case 6:
      v82 = *(const void **)(v340 + 8);
      v118 = *(void (**)(uint64_t, const void *, uint64_t, uint64_t))(v340 + 16);
      v119 = *(_QWORD *)(v340 + 24);
      v120 = sub_10002DEA0(a2, v82);
      if (!v120)
      {
LABEL_524:
        v74 = objc_autoreleasePoolPush();
        v75 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_95;
        v310 = v82;
        goto LABEL_534;
      }
      v121 = CFGetTypeID(v120);
      if (v121 == sub_10002DE64())
      {
        v122 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Stop WiFi Direct Group is not suported by %@", v82);
        v117 = v122;
        goto LABEL_142;
      }
      for (k = 6; ; --k)
      {
        v158 = Apple80211Set(*(_QWORD *)(a2 + 16), 25, 2, 0, 0);
        v9 = v158;
        if ((_DWORD)v158 != -3905 && (_DWORD)v158 != 61 && (_DWORD)v158 != 16)
          break;
        if (!k)
          break;
        usleep(0x7A120u);
      }
      if (v118)
        v118(a2, v82, v158, v119);
      goto LABEL_358;
    case 7:
      v89 = *(unsigned int *)(v340 + 16);
      v90 = *(const void **)(v340 + 8);
      LODWORD(buf) = *(_QWORD *)(v340 + 24);
      v91 = sub_10002DEA0(a2, v90);
      if (!v91)
        goto LABEL_522;
      v92 = CFGetTypeID(v91);
      if (v92 != sub_10002DE64())
      {
        for (m = 6; ; --m)
        {
          v147 = Apple80211Set(*(_QWORD *)(a2 + 16), v89, 0, &buf, 4);
          v9 = v147;
          if ((_DWORD)v147 != -3905 && (_DWORD)v147 != 61 && (_DWORD)v147 != 16)
            break;
          if (!m)
            break;
          usleep(0x7A120u);
        }
        goto LABEL_358;
      }
      v93 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Set Bluetooth State command is not supported by %@", v90);
      goto LABEL_136;
    case 8:
      v90 = *(const void **)(v340 + 8);
      v132 = *(unsigned int *)(v340 + 16);
      v133 = sub_10002DEA0(a2, v90);
      if (!v133)
        goto LABEL_522;
      v134 = (uint64_t)v133;
      v135 = CFGetTypeID(v133);
      if (v135 == sub_10002DE64())
      {
        v80 = sub_10015D914(v134);
LABEL_151:
        v9 = v80;
      }
      else
      {
        for (n = 6; ; --n)
        {
          v161 = Apple80211SetPowerState(*(_QWORD *)(a2 + 16), v132);
          v9 = v161;
          if ((_DWORD)v161 != -3905 && (_DWORD)v161 != 61 && (_DWORD)v161 != 16)
            break;
          if (!n)
            break;
          usleep(0x7A120u);
        }
      }
      goto LABEL_358;
    case 9:
      v69 = *(const void **)(v340 + 8);
      v70 = *(const __CFDictionary **)(v340 + 16);
      *(_OWORD *)v333 = *(_OWORD *)(v340 + 24);
      v71 = sub_10002DEA0(a2, v69);
      v72 = objc_autoreleasePoolPush();
      if (!v71)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", v69);
        v77 = v72;
        goto LABEL_96;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting Apple80211GasRequest on %@", v69);
      objc_autoreleasePoolPop(v72);
      v73 = CFGetTypeID(v71);
      if (v73 == sub_10002DE64())
      {
        v74 = objc_autoreleasePoolPush();
        v75 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_95;
        v76 = "Gas request is not supported on virtual interfaces.";
        goto LABEL_94;
      }
      *(_OWORD *)(a2 + 5000) = *(_OWORD *)v333;
      valuePtr = -1.0;
      v140 = (const __CFNumber *)CFDictionaryGetValue(v70, CFSTR("SCAN_MAXAGE"));
      if (v140)
        CFNumberGetValue(v140, kCFNumberDoubleType, &valuePtr);
      v141 = (const __CFBoolean *)CFDictionaryGetValue(v70, CFSTR("CacheOnly"));
      if (v141)
        v142 = CFBooleanGetValue(v141);
      else
        v142 = 0;
      if (!v70)
        goto LABEL_342;
      v177 = valuePtr;
      if (valuePtr == 0.0)
        goto LABEL_342;
      sub_10001740C(*(const __CFArray **)(a2 + 5752), 3600.0);
      v178 = CFArrayGetCount(*(CFArrayRef *)(a2 + 5752));
      if (!v178)
        goto LABEL_342;
      v179 = v178;
      v180 = (const __CFArray *)CFDictionaryGetValue(v70, CFSTR("GAS_NETWORKS"));
      v181 = (void *)CFDictionaryGetValue(v70, CFSTR("GAS_QUERY"));
      cf1 = CFDictionaryGetValue(v70, CFSTR("GAS_PROTOCOL"));
      if (v179 < 1 || !v180 || !v181 || !cf1)
        goto LABEL_342;
      while (2)
      {
        v182 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 5752), v179 - 1);
        if (!v182)
          goto LABEL_336;
        v183 = (uint64_t)v182;
        v184 = sub_1000D720C((uint64_t)v182);
        if (!v184)
          goto LABEL_336;
        v185 = (const __CFDictionary *)v184;
        if (v177 > 0.0)
        {
          v186 = CFAbsoluteTimeGetCurrent();
          if (v186 - sub_10015B27C(v183) > v177)
            goto LABEL_336;
        }
        v187 = CFDictionaryGetValue(v185, CFSTR("GAS_PROTOCOL"));
        if (!v187)
          goto LABEL_336;
        if (!CFEqual(cf1, v187))
          goto LABEL_336;
        v188 = CFDictionaryGetValue(v185, CFSTR("GAS_QUERY"));
        if (!v188)
          goto LABEL_336;
        if (!CFEqual(v181, v188))
          goto LABEL_336;
        v334 = (const __CFArray *)sub_1000C053C(v183);
        if (!v334)
          goto LABEL_336;
        v321 = (CFMutableArrayRef)v181;
        theArraya = v180;
        v189 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v190 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v191 = 0;
        v192 = 0;
        v193 = 0;
        if (!v189 || !v190)
          goto LABEL_327;
        v327 = v190;
        v325 = sub_10007AF48(theArraya);
        v193 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (v193)
        {
          v194 = CFArrayGetCount(theArraya);
          if (v194 >= 1)
          {
            v195 = v194;
            for (ii = 0; ii != v195; ++ii)
            {
              v197 = CFArrayGetValueAtIndex(theArraya, ii);
              if (v197)
              {
                v198 = sub_10002BE64((uint64_t)v197, CFSTR("CHANNEL"));
                if (v198)
                  CFArrayAppendValue(v193, v198);
              }
            }
          }
          v320 = v142;
          v191 = (int)v325;
          if (v325)
          {
            v199 = CFArrayGetCount(v334);
            v200 = CFArrayGetCount(v325);
            v191 = 0;
            if (!v200 || (v318 = v70, !v199) || (v201 = v200, v316 = v69, v199 < v200))
            {
              v142 = v320;
              v192 = v325;
              v190 = v327;
              break;
            }
            if (v199 >= 1)
            {
              for (jj = 0; jj != v199; ++jj)
              {
                v203 = (const __CFDictionary *)CFArrayGetValueAtIndex(v334, jj);
                if (v203)
                {
                  v204 = v203;
                  v205 = CFDictionaryGetValue(v203, CFSTR("BSSID"));
                  v206 = CFDictionaryGetValue(v204, CFSTR("CHANNEL"));
                  if (v205)
                  {
                    v207 = v206;
                    if (v206)
                    {
                      CFArrayAppendValue(v189, v205);
                      CFArrayAppendValue(v327, v207);
                    }
                  }
                }
              }
            }
            if (v201 < 1)
            {
              v208 = 0;
              v70 = v318;
            }
            else
            {
              v208 = 0;
              v70 = v318;
              v192 = v325;
              while (1)
              {
                v209 = CFArrayGetValueAtIndex(v192, v208);
                v210 = CFArrayGetValueAtIndex(v193, v208);
                if (v209)
                {
                  v346.length = CFArrayGetCount(v189);
                  v346.location = 0;
                  if (!CFArrayContainsValue(v189, v346, v209))
                    break;
                }
                v211 = CFArrayGetValueAtIndex(v327, v208);
                if (v210)
                {
                  if (v211 && !CFEqual(v210, v211))
                    break;
                }
                ++v208;
                v192 = v325;
                if (v201 == v208)
                {
                  v208 = v201;
                  goto LABEL_325;
                }
              }
            }
            v192 = v325;
LABEL_325:
            v191 = v208 == v201;
            v69 = v316;
          }
          else
          {
            v192 = 0;
          }
          v142 = v320;
          v190 = v327;
LABEL_327:
          if (!v189)
          {
LABEL_329:
            if (v190)
            {
              v215 = v192;
              CFRelease(v190);
              v192 = v215;
            }
            v181 = v321;
            if (v192)
              CFRelease(v192);
            if (v193)
              CFRelease(v193);
            v180 = theArraya;
            if (!v191)
            {
LABEL_336:
              if (v179-- <= 1)
              {
LABEL_342:
                v217 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No matching cache entry found. Will send GAS request.", "__WiFiDeviceCopyCachedGasResponse");
                objc_autoreleasePoolPop(v217);
                Mutable = 0;
                goto LABEL_345;
              }
              continue;
            }
            v289 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found matching request. Using cached result", "__WiFiDeviceCopyCachedGasResponse");
            objc_autoreleasePoolPop(v289);
            v290 = CFArrayGetCount(v334);
            if (v290)
            {
              v291 = v290;
              Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
              if (Mutable)
              {
                v292 = sub_10007AF48(theArraya);
                if (!v292)
                {
                  v218 = 1;
                  goto LABEL_567;
                }
                v293 = v292;
                if (v291 >= 1)
                {
                  for (kk = 0; kk != v291; ++kk)
                  {
                    v295 = (const __CFDictionary *)CFArrayGetValueAtIndex(v334, kk);
                    if (v295)
                    {
                      v296 = CFDictionaryGetValue(v295, CFSTR("BSSID"));
                      if (v296)
                      {
                        v297 = v296;
                        v352.length = CFArrayGetCount(v293);
                        v352.location = 0;
                        if (CFArrayContainsValue(v293, v352, v297))
                        {
                          v298 = CFArrayGetValueAtIndex(v334, kk);
                          CFArrayAppendValue(Mutable, v298);
                        }
                      }
                    }
                  }
                }
                CFRelease(v293);
              }
            }
            else
            {
              Mutable = 0;
            }
LABEL_345:
            v218 = Mutable != 0;
            if (!Mutable && !v142)
            {
              v219 = (const __CFArray *)CFDictionaryGetValue(v70, CFSTR("GAS_NETWORKS"));
              if (!v219)
                return 4294963396;
              v220 = v219;
              MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v70);
              if (!MutableCopy)
                return 4294963396;
              Mutable = MutableCopy;
              v222 = sub_1000173D8(v220);
              if (v222)
              {
                v223 = v222;
                CFDictionaryReplaceValue(Mutable, CFSTR("GAS_NETWORKS"), v222);
                v9 = Apple80211GasRequest(*(_QWORD *)(a2 + 16), Mutable);
                if ((_DWORD)v9)
                  sub_10007AD3C((_QWORD *)a2, (uint64_t)v69, 0, 0, v9);
                else
                  sub_10007AF08(a2, v70);
                CFRelease(v223);
              }
              else
              {
                v9 = 4294963396;
              }
              goto LABEL_103;
            }
LABEL_567:
            v305 = (const __CFArray *)CFDictionaryGetValue(v70, CFSTR("GAS_NETWORKS"));
            if (v305)
            {
              v306 = v305;
              sub_10007AAF8(v305, Mutable);
              sub_10007AC38(a2, v306);
              if (*(_QWORD *)(a2 + 64))
              {
                CFRetain((CFTypeRef)a2);
                v307 = *(NSObject **)(a2 + 64);
                *(_QWORD *)&buf = _NSConcreteStackBlock;
                *((_QWORD *)&buf + 1) = 3221225472;
                v343 = sub_10007AC78;
                v344 = &unk_10022EA38;
                v345 = a2;
                dispatch_async(v307, &buf);
              }
              else
              {
                v309 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceGasStartAsyncQueued");
                objc_autoreleasePoolPop(v309);
              }
              v9 = 0;
            }
            else
            {
              v308 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Oops - no networks in request", "__WiFiDeviceGasStartAsyncQueued");
              objc_autoreleasePoolPop(v308);
              v9 = 4294963396;
              sub_10007AD3C((_QWORD *)a2, (uint64_t)v69, 0, 0, 4294963396);
            }
            if (!v218)
              return v9;
            goto LABEL_103;
          }
        }
        else
        {
          v191 = 0;
          v192 = v325;
          v190 = v327;
        }
        break;
      }
      v212 = v190;
      v213 = v189;
      v214 = v192;
      CFRelease(v213);
      v192 = v214;
      v190 = v212;
      goto LABEL_329;
    case 0xA:
      v124 = *(const void **)(v340 + 8);
      v123 = *(const void **)(v340 + 16);
      v126 = *(void (**)(uint64_t, const void *, uint64_t, uint64_t))(v340 + 24);
      v125 = *(_QWORD *)(v340 + 32);
      v127 = *(const __CFString **)(v340 + 40);
      v128 = sub_100073B3C(a2);
      if (!v128)
      {
        v165 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: not an AWDL interface.", "__WiFiDeviceStartAwdlQueued");
        v9 = 4294963393;
        goto LABEL_545;
      }
      v129 = (uint64_t)v128;
      *(_QWORD *)(a2 + 4688) = v126;
      *(_QWORD *)(a2 + 4696) = v125;
      v130 = *(const void **)(a2 + 4704);
      if (v130)
      {
        CFRelease(v130);
        *(_QWORD *)(a2 + 4704) = 0;
      }
      if (v123)
        v131 = CFRetain(v123);
      else
        v131 = 0;
      *(_QWORD *)(a2 + 4704) = v131;
      v163 = *(const void **)(a2 + 4712);
      if (v163)
      {
        CFRelease(v163);
        *(_QWORD *)(a2 + 4712) = 0;
      }
      if (v127)
        v164 = CFRetain(v127);
      else
        v164 = 0;
      *(_QWORD *)(a2 + 4712) = v164;
      *(CFAbsoluteTime *)(a2 + 4720) = CFAbsoluteTimeGetCurrent();
      v9 = sub_10015E1CC(v129, v124, (const __CFDictionary *)v123, (void (*)(_QWORD, const void *, _QWORD, _QWORD))sub_10007A938, a2, v127);
      if ((_DWORD)v9)
      {
        v165 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiVirtualInterfaceStartAwdl() returned error %d.", "__WiFiDeviceStartAwdlQueued", v9);
LABEL_545:
        objc_autoreleasePoolPop(v165);
        if (v126)
        {
          v126(a2, v124, v9, v125);
          sub_100017CB0(a2);
          *(_QWORD *)(a2 + 4688) = 0;
          *(_QWORD *)(a2 + 4696) = 0;
          v300 = *(const void **)(a2 + 4704);
          if (v300)
          {
            CFRelease(v300);
            *(_QWORD *)(a2 + 4704) = 0;
          }
          v301 = *(const void **)(a2 + 4712);
          if (v301)
          {
            CFRelease(v301);
            *(_QWORD *)(a2 + 4712) = 0;
          }
        }
        return v9;
      }
      return v9;
    case 0xB:
      v36 = *(const void **)(v340 + 8);
      Mutable = *(const __CFArray **)(v340 + 16);
      v9 = sub_10007AA3C(a2, v36, (uint64_t)Mutable, *(void (**)(uint64_t, const void *, uint64_t, uint64_t))(v340 + 24), *(_QWORD *)(v340 + 32));
      sub_100019A60(*(_QWORD *)(a2 + 176), 0, 0, 0);
      if (v36)
        CFRelease(v36);
      goto LABEL_102;
    case 0xC:
      v51 = *(_QWORD *)(v340 + 8);
      v52 = *(const __CFArray **)(v340 + 16);
      LODWORD(v2) = *(_DWORD *)(v340 + 40);
      *(_OWORD *)(a2 + 5144) = *(_OWORD *)(v340 + 24);
      v332 = v51;
      if (!v51)
      {
        v299 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ifName.", "__WiFiDeviceRangingStartAsyncQueued");
        goto LABEL_537;
      }
      v53 = kCFAllocatorDefault;
      if (!v52 || !CFArrayGetCount(v52))
      {
        v299 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: empty peers.", "__WiFiDeviceRangingStartAsyncQueued");
LABEL_537:
        objc_autoreleasePoolPop(v299);
        v54 = 0;
        v9 = 4294963396;
        v64 = v332;
        goto LABEL_154;
      }
      v54 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (CFArrayGetCount(v52) >= 1)
      {
        v55 = 0;
        do
        {
          v56 = (const __CFDictionary *)CFArrayGetValueAtIndex(v52, v55);
          if (v56)
          {
            v57 = CFDictionaryCreateMutableCopy(v53, 0, v56);
            if (v57)
            {
              v58 = v57;
              LOBYTE(buf) = 0;
              v59 = (const __CFNumber *)CFDictionaryGetValue(v57, CFSTR("RANGING_PEER_FLAGS"));
              if (v59)
                CFNumberGetValue(v59, kCFNumberSInt8Type, &buf);
              if (*(_BYTE *)(a2 + 5956))
                LOBYTE(buf) = buf | 2;
              if (_os_feature_enabled_impl("WiFiManager", "RangingPerCoreRSSIFilter"))
                LOBYTE(buf) = buf | 4;
              if (*(_BYTE *)(a2 + 5957))
                LOBYTE(buf) = buf | 8;
              if ((MGGetBoolAnswer(CFSTR("InternalBuild")) & 1) == 0 && sub_10008036C())
              {
                v60 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: debug profile installed, enabling ranging log dump", "__WiFiDeviceRangingStartAsyncQueued");
                objc_autoreleasePoolPop(v60);
                LOBYTE(buf) = buf | 2;
                v53 = kCFAllocatorDefault;
              }
              v61 = CFNumberCreate(v53, kCFNumberSInt8Type, &buf);
              if (v61)
              {
                v62 = v61;
                CFDictionarySetValue(v58, CFSTR("RANGING_PEER_FLAGS"), v61);
                CFRelease(v62);
              }
              CFArrayAppendValue(v54, v58);
              CFRelease(v58);
              v53 = kCFAllocatorDefault;
            }
          }
          ++v55;
        }
        while (v55 < CFArrayGetCount(v52));
      }
      v63 = objc_autoreleasePoolPush();
      v64 = v332;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting APPLE80211_IOC_RANGING_START on %@ to %ld peers", v332, CFArrayGetCount(v54));
      v65 = (double)v2;
      objc_autoreleasePoolPop(v63);
      for (mm = 6; ; --mm)
      {
        v67 = Apple80211RangeAsync(*(_QWORD *)(a2 + 16), v54, v65);
        v9 = v67;
        if ((int)v67 <= 15)
        {
          if ((_DWORD)v67 != -3905)
            break;
        }
        else if ((_DWORD)v67 != 61 && (_DWORD)v67 != 16)
        {
          goto LABEL_154;
        }
        if (!mm)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v67)
        goto LABEL_155;
LABEL_154:
      sub_10006B430((uint64_t *)a2, v64, 0, v9);
LABEL_155:
      if (v54)
      {
        v81 = v54;
        goto LABEL_157;
      }
      return v9;
    case 0xD:
      v90 = *(const void **)(v340 + 8);
      LODWORD(buf) = *(_QWORD *)(v340 + 16);
      v115 = sub_10002DEA0(a2, v90);
      if (v115)
      {
        v116 = CFGetTypeID(v115);
        if (v116 == sub_10002DE64())
        {
          v93 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Set display State command is not supported by %@", v90);
LABEL_136:
          v117 = v93;
LABEL_142:
          objc_autoreleasePoolPop(v117);
          v9 = 4294963396;
        }
        else
        {
          for (nn = 6; ; --nn)
          {
            v155 = Apple80211Set(*(_QWORD *)(a2 + 16), 365, 0, &buf, 4);
            v9 = v155;
            if ((_DWORD)v155 != -3905 && (_DWORD)v155 != 61 && (_DWORD)v155 != 16)
              break;
            if (!nn)
              break;
            usleep(0x7A120u);
          }
        }
LABEL_358:
        sub_100019A60(*(_QWORD *)(a2 + 176), 0, 0, 0);
        return v9;
      }
LABEL_522:
      v74 = objc_autoreleasePoolPush();
      v75 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_95;
      v310 = v90;
      goto LABEL_534;
    case 0xE:
      v27 = *(const void **)(v340 + 8);
      if (v27)
      {
        if ((*(_BYTE *)(a2 + 40) & 2) == 0)
        {
          v9 = 4294963389;
          goto LABEL_162;
        }
        v28 = *(_QWORD *)(v340 + 16);
        *(_OWORD *)allocator = *(_OWORD *)(v340 + 24);
        v29 = sub_10002DEA0(a2, v27);
        if (v29)
        {
          v30 = CFGetTypeID(v29);
          if (v30 != sub_10002DE64())
          {
            *(_OWORD *)(a2 + 5464) = *(_OWORD *)allocator;
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting APPLE80211_IOC_SENSING_ENABLE on %@", v27);
            objc_autoreleasePoolPop(v31);
            for (i1 = 6; ; --i1)
            {
              v33 = Apple80211Set(*(_QWORD *)(a2 + 16), 408, 0, v28, 8);
              v9 = v33;
              if ((int)v33 <= 15)
              {
                if ((_DWORD)v33 != -3905)
                  break;
              }
              else if ((_DWORD)v33 != 61 && (_DWORD)v33 != 16)
              {
                goto LABEL_159;
              }
              if (!i1)
                break;
              usleep(0x7A120u);
            }
            if (!(_DWORD)v33)
              return v9;
LABEL_159:
            v136 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IOC %d returned error %d", "__WiFiDeviceSensingEnableAsyncQueued", 408, v9);
            objc_autoreleasePoolPop(v136);
            if (!(_DWORD)v9)
              return v9;
LABEL_162:
            sub_10007B260(a2, (uint64_t)v27, 0, v9);
            return v9;
          }
          v302 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unsupported interface %@", "__WiFiDeviceSensingEnableAsyncQueued", v27);
        }
        else
        {
          v302 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "__WiFiDeviceSensingEnableAsyncQueued", v27);
        }
        objc_autoreleasePoolPop(v302);
        v9 = 4294963393;
        goto LABEL_162;
      }
      v9 = 4294963396;
      goto LABEL_162;
    case 0xF:
      Mutable = *(const __CFArray **)(v340 + 8);
      v9 = sub_10007326C(a2, v16, *(unsigned int *)(v340 + 16));
      sub_100019A60(*(_QWORD *)(a2 + 176), 0, 0, 0);
      goto LABEL_102;
    default:
      *(_BYTE *)(v340 + 56) = 0;
      return 4294963394;
  }
}

void sub_10001C6DC(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 5672);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5672) = 0;
  }
  if (cf)
    *(_QWORD *)(a1 + 5672) = CFRetain(cf);
}

uint64_t sub_10001C71C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _QWORD *a9)
{
  void *v12;
  void *v13;
  unint64_t v14;
  void *v16;
  _DWORD v17[2];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 48) == 1)
    {
      v17[1] = -1431655766;
      v24 = 0xAAAAAAAAAAAAAA00;
      v17[0] = a2;
      v18 = a4;
      v19 = a5;
      v20 = a6;
      v21 = a7;
      v22 = a8;
      v23 = 0;
      v25 = a3;
      v12 = objc_autoreleasePoolPush();
      v13 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v14 = sub_10001C840(a2);
        objc_msgSend(v13, "WFLog:message:", 3, "Enqueuing command type: \"%@\" priority:%ld pending commands: %ld", v14, a3, sub_10001C860(*(_QWORD *)(a1 + 176)));
      }
      objc_autoreleasePoolPop(v12);
      return sub_100019B38(*(_QWORD *)(a1 + 176), (const UInt8 *)v17, 72, a9);
    }
    else
    {
      return 82;
    }
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceCommandEnqueue");
    objc_autoreleasePoolPop(v16);
    return 4294963396;
  }
}

unint64_t sub_10001C840(unsigned int a1)
{
  if (a1 > 0xF)
    return 0xAAAAAAAAAAAAAAAALL;
  else
    return (unint64_t)*(&off_10022F838 + (int)a1);
}

CFIndex sub_10001C860(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
}

void sub_10001C868(uint64_t a1)
{
  void (*v2)(uint64_t, _QWORD);
  void *v3;

  if (sub_10001C904(a1, 0))
  {
    v2 = *(void (**)(uint64_t, _QWORD))(a1 + 32);
    if (v2)
      v2(a1, *(_QWORD *)(a1 + 40));
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d cmdQueue is EMPTY!!!!", "__WiFiCommandQueueCallback", 506);
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_10001C904(uint64_t a1, uint64_t *a2)
{
  CFIndex Count;
  uint64_t v5;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  const __CFData *ValueAtIndex;
  CFNumberRef v10;
  CFNumberRef v11;
  int v12;
  UInt8 buffer[8];
  CFRange v15;

  *(_QWORD *)buffer = 0;
  if (a1 && (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16)), Count >= 1))
  {
    v7 = Count;
    v5 = 0;
    v8 = 0;
    v6 = -1;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v8);
      if (!ValueAtIndex)
        break;
      v15.location = 0;
      v15.length = 8;
      CFDataGetBytes(ValueAtIndex, v15, buffer);
      v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, buffer);
      if (!v10)
        break;
      v11 = v10;
      v12 = CFSetContainsValue(*(CFSetRef *)(a1 + 80), v10);
      if (!v12)
        ++v5;
      if (v12 == 0 && v6 == -1)
        v6 = v8;
      CFRelease(v11);
      ++v8;
    }
    while (v7 != v8);
  }
  else
  {
    v5 = 0;
    v6 = -1;
  }
  if (a2)
    *a2 = v6;
  return v5;
}

uint64_t sub_10001CA04(uint64_t a1, void *a2, uint64_t a3)
{
  CFIndex Count;
  CFIndex v7;
  const __CFData *ValueAtIndex;
  const __CFData *v9;
  uint64_t v10;
  const UInt8 *v11;
  CFIndex Length;
  const __CFArray *v13;
  CFIndex FirstIndexOfValue;
  CFIndex i;
  const __CFArray *v16;
  UInt8 buffer[8];
  CFRange v19;
  CFRange v20;
  CFRange v21;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  if (Count < 1)
  {
LABEL_6:
    v10 = 4294963394;
    if (!Count)
      return v10;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      *(_QWORD *)buffer = 0xAAAAAAAAAAAAAAAALL;
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v7);
      if (ValueAtIndex)
      {
        v9 = ValueAtIndex;
        v19.location = 0;
        v19.length = 8;
        CFDataGetBytes(ValueAtIndex, v19, buffer);
        if (*(_QWORD *)buffer == a3)
          break;
      }
      if (Count == ++v7)
        goto LABEL_6;
    }
    if (a2)
    {
      v11 = CFDataGetBytePtr(v9) + 8;
      Length = CFDataGetLength(v9);
      memcpy(a2, v11, Length - 8);
    }
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v7, kCFNull);
    v13 = *(const __CFArray **)(a1 + 16);
    v20.length = CFArrayGetCount(v13);
    v20.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v20, kCFNull);
    if (FirstIndexOfValue != -1)
    {
      for (i = FirstIndexOfValue; i != -1; i = CFArrayGetFirstIndexOfValue(v16, v21, kCFNull))
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), i);
        v16 = *(const __CFArray **)(a1 + 16);
        v21.length = CFArrayGetCount(v16);
        v21.location = 0;
      }
    }
    v10 = 0;
  }
  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 16)))

  return v10;
}

uint64_t sub_10001CB74(uint64_t result, int a2)
{
  *(_DWORD *)(result + 176) = a2;
  return result;
}

void sub_10001CB7C(uint64_t a1, uint64_t a2, const void *a3, const __CFArray *a4, int a5)
{
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int Length;
  __CFArray *v12;
  __CFArray *v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *v16;
  int v17;

  if (!a3)
  {
    v9 = 0;
LABEL_6:
    BytePtr = 0;
    Length = 0;
    if (!a4)
      goto LABEL_12;
    goto LABEL_7;
  }
  v8 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a3);
  v9 = v8;
  if (!v8)
    goto LABEL_6;
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v9);
  if (!a4)
  {
LABEL_12:
    sub_10001CCC8(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 0, 0, a5, 0);
    if (v9)
      goto LABEL_13;
    return;
  }
LABEL_7:
  v12 = sub_1000173D8(a4);
  if (!v12)
    goto LABEL_12;
  v13 = v12;
  v14 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v12);
  if (!v14)
  {
    CFRelease(v13);
    goto LABEL_12;
  }
  v15 = v14;
  v16 = CFDataGetBytePtr(v14);
  v17 = CFDataGetLength(v15);
  CFRelease(v13);
  sub_10001CCC8(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, (uint64_t)v16, v17, a5, 0);
  CFRelease(v15);
  if (v9)
LABEL_13:
    CFRelease(v9);
}

uint64_t sub_10001CCC8(int a1, vm_address_t a2, int a3, uint64_t a4, int a5, int a6, mach_msg_timeout_t timeout)
{
  uint64_t v10;
  unint64_t v12;
  int v13;
  __int128 v14;
  vm_address_t v15;
  int v16;
  _DWORD v17[4];
  _DWORD v18[6];

  v15 = a2;
  v16 = 27918592;
  v17[0] = a3;
  *(_QWORD *)&v17[1] = a4;
  v17[3] = 27918592;
  v18[0] = a5;
  *(NDR_record_t *)&v18[1] = NDR_record;
  v18[3] = a3;
  v18[4] = a5;
  v18[5] = a6;
  v12 = 0xAAAAAAAA80000013;
  v13 = a1;
  v14 = xmmword_1001BBED0;
  if (&_voucher_mach_msg_set)
    voucher_mach_msg_set((mach_msg_header_t *)&v12);
  v10 = mach_msg((mach_msg_header_t *)&v12, 2097169, 0x50u, 0, 0, timeout, 0);
  if ((_DWORD)v10 == 268435460)
  {
    if (v15 != a2)
      mig_deallocate(v15, v17[0]);
    if (*(_QWORD *)&v17[1] != a4)
      mig_deallocate(*(vm_address_t *)&v17[1], v18[0]);
  }
  return v10;
}

NSString *sub_10001D2E0(void *a1)
{
  const char *v2;
  const char *v3;
  ether_addr *v4;
  void *v6;
  void *v7;
  void *v8;

  if (a1)
  {
    v2 = (const char *)objc_msgSend(a1, "UTF8String");
    if (v2)
    {
      v3 = v2;
      v4 = ether_aton(v2);
      if (v4)
        return +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%02x:%02x:%02x:%02x:%02x:%02x"), v4->octet[0], v4->octet[1], v4->octet[2], v4->octet[3], v4->octet[4], v4->octet[5]);
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: badly formatted MAC address: %s", "_reformatMacAddress", v3);
      v7 = v8;
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid MAC address: %@", "_reformatMacAddress", a1);
      v7 = v6;
    }
    objc_autoreleasePoolPop(v7);
  }
  return 0;
}

const __CFNumber *sub_10001D3D8(const __CFNumber *result)
{
  const __CFNumber *v1;

  if (result)
  {
    v1 = (const __CFNumber *)sub_10002BE64((uint64_t)result, CFSTR("RSSI"));
    return sub_10001F500(v1);
  }
  return result;
}

const void *sub_10001D3FC(const void *result)
{
  if (result)
    return sub_10002BE64((uint64_t)result, CFSTR("SCAN_BSSID_LIST"));
  return result;
}

uint64_t sub_10001D410(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  uint64_t v16;
  const void *v17;
  const void *v18;
  void *v19;
  CFPropertyListRef v20;
  const __CFString *v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  const void *v24;
  uint64_t v25;
  CFTypeID TypeID;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *context;
  UInt8 *v36;
  unsigned int v37;
  UInt8 *v38;
  int valuePtr;

  v16 = sub_1000167F8();
  v17 = sub_10001674C(a1, v16);
  if (v17)
  {
    v18 = v17;
    v38 = a4;
    if ((sub_100016834((uint64_t)v17) & 1) == 0)
    {
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_coex_parameters(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_1000161D4((uint64_t)v18));
      objc_autoreleasePoolPop(v19);
      *a8 = 1;
LABEL_34:
      CFRelease(v18);
      a4 = v38;
      goto LABEL_35;
    }
    v20 = sub_10001D7D0(a2, a3);
    v21 = (const __CFString *)sub_10001D7D0(a4, a5);
    v37 = a7;
    v22 = (const __CFDictionary *)sub_10001D7D0(a6, a7);
    v23 = v22;
    if (!v20 || !v21 || !v22)
    {
      *a8 = 22;
      if (!v20)
        goto LABEL_30;
      goto LABEL_29;
    }
    v24 = sub_10001683C((uint64_t)v18, v20);
    if (!v24)
    {
      *a8 = 6;
      goto LABEL_29;
    }
    v25 = (uint64_t)v24;
    v36 = a6;
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(v21))
      goto LABEL_17;
    if (CFStringCompare(v21, CFSTR("BSP_Command"), 0) == kCFCompareEqualTo)
    {
      sub_10011F114(v25, v23);
      goto LABEL_28;
    }
    if (CFStringCompare(v21, CFSTR("MWS_BT_A2DP_LLA_TRAFFIC_INDICATION"), 0) == kCFCompareEqualTo)
    {
      valuePtr = 0;
      v31 = objc_autoreleasePoolPush();
      a6 = v36;
      if (qword_10026DD20)
      {
        context = v31;
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client \"%@\" calling APPLE80211KEY_MWS_BT_A2DP_LLA_TRAFFIC_INDICATION", "_wifi_device_set_coex_parameters", sub_1000161D4((uint64_t)v18));
        v31 = context;
      }
      objc_autoreleasePoolPop(v31);
      CFNumberGetValue(v23, kCFNumberIntType, &valuePtr);
      sub_10011EEC8(v25, valuePtr);
      goto LABEL_29;
    }
    if (CFStringCompare(v21, CFSTR("MWS_Blacklisted_Channels"), 0) == kCFCompareEqualTo)
    {
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client \"%@\" calling APPLE80211KEY_MWS_BLACKLISTED_CHANNELS", "_wifi_device_set_coex_parameters", sub_1000161D4((uint64_t)v18));
      objc_autoreleasePoolPop(v32);
      sub_100101E08(v25, v23);
      goto LABEL_28;
    }
    if (CFStringCompare(v21, CFSTR("MWS_BT_CONNECTION_REPORT"), 0) == kCFCompareEqualTo)
    {
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: client \"%@\" calling APPLE80211KEY_MWS_BT_CONNECTION_REPORT", "_wifi_device_set_coex_parameters", sub_1000161D4((uint64_t)v18));
      objc_autoreleasePoolPop(v33);
      sub_100101AA0(v25, v23);
      goto LABEL_28;
    }
    v27 = sub_1000DA9E8(v21);
    if ((_DWORD)v27)
    {
      v28 = v27;
      v29 = sub_1000161D4(v25);
      sub_1000672C0(v29, v20, v28, 0, (uint64_t)v23);
    }
    else
    {
LABEL_17:
      v30 = sub_1000161D4(v25);
      *a8 = sub_10002DC20(v30, v20, v21, (uint64_t)v23);
    }
LABEL_28:
    a6 = v36;
LABEL_29:
    CFRelease(v20);
LABEL_30:
    if (v23)
      CFRelease(v23);
    a7 = v37;
    if (v21)
      CFRelease(v21);
    goto LABEL_34;
  }
LABEL_35:
  sub_10001D7AC((vm_address_t)a2, a3);
  sub_10001D7AC((vm_address_t)a4, a5);
  sub_10001D7AC((vm_address_t)a6, a7);
  return 0;
}

vm_address_t sub_10001D7AC(vm_address_t address, vm_size_t size)
{
  if (address)
  {
    if (size)
      return vm_deallocate(mach_task_self_, address, size);
  }
  return address;
}

CFPropertyListRef sub_10001D7D0(UInt8 *bytes, CFIndex length)
{
  const __CFData *v2;
  const __CFData *v3;
  CFPropertyListRef v4;
  void *v5;
  _BOOL4 v6;
  BOOL v7;
  CFErrorRef error;

  if (!bytes || !length)
  {
    v6 = bytes != 0;
    if (length)
    {
      v6 = 0;
      v7 = bytes == 0;
    }
    else
    {
      v7 = 0;
    }
    if ((v7 || v6) && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      sub_100186A64();
    return 0;
  }
  v2 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, length, kCFAllocatorNull);
  if (!v2)
    return 0;
  v3 = v2;
  error = 0;
  v4 = CFPropertyListCreateWithData(kCFAllocatorDefault, v2, 1uLL, 0, &error);
  if (error)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFPropertyListCreateWithData returned with error %@", "_WiFiCopyUnserialized", error);
    objc_autoreleasePoolPop(v5);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      sub_1001869EC();
    CFRelease(error);
  }
  CFRelease(v3);
  return v4;
}

const __SCPreferences *sub_10001D90C(_QWORD *a1, const __CFString *a2)
{
  const __SCPreferences *result;
  const __SCPreferences *v4;
  void *v5;
  CFPropertyListRef Value;

  result = (const __SCPreferences *)sub_10001D964(a1, a2);
  if (result)
  {
    v4 = result;
    v5 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerGetProperty");
    Value = SCPreferencesGetValue(v4, a2);

    return (const __SCPreferences *)Value;
  }
  return result;
}

_QWORD *sub_10001D964(_QWORD *a1, CFStringRef theString1)
{
  _QWORD *v2;
  void *v4;
  _QWORD *v5;
  const __CFNumber *Value;
  const __CFNumber *v7;
  CFTypeID TypeID;
  CFTypeID v9;
  SInt32 IntValue;
  CFTypeID v11;
  SInt32 valuePtr;

  v2 = a1;
  valuePtr = 0;
  if (a1)
  {
    if (CFStringCompare(theString1, CFSTR("isWiFiPNLMigrationComplete"), 0))
    {
      v4 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerGetWiFiNetworksOrPreferencesRef");
      v5 = v2 + 134;
      Value = (const __CFNumber *)SCPreferencesGetValue((SCPreferencesRef)v2[134], CFSTR("isWiFiPNLMigrationComplete"));
      if (Value)
      {
        v7 = Value;
        TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID(v7))
        {
          CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
          if (!valuePtr)
            goto LABEL_18;
LABEL_13:
          if (CFStringCompare(theString1, CFSTR("List of known networks"), 0))
          {
            if (CFStringCompare(theString1, CFSTR("List of scanned networks with private mac"), 0) == kCFCompareEqualTo)
              v5 = v2 + 137;
          }
          else
          {
            v5 = v2 + 135;
          }
          goto LABEL_18;
        }
        v9 = CFBooleanGetTypeID();
        if (v9 == CFGetTypeID(v7))
        {
          IntValue = CFEqual(v7, kCFBooleanTrue);
        }
        else
        {
          v11 = CFStringGetTypeID();
          if (v11 != CFGetTypeID(v7))
            goto LABEL_18;
          IntValue = CFStringGetIntValue((CFStringRef)v7);
        }
        valuePtr = IntValue;
        if (IntValue)
          goto LABEL_13;
      }
LABEL_18:
      v2 = (_QWORD *)*v5;

      return v2;
    }
    return (_QWORD *)v2[134];
  }
  return v2;
}

void sub_10001DACC(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, uint64_t a5, CFTypeID a6)
{
  void *v11;
  void *v12;
  const void *v13;
  void (*v14)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *);
  uint64_t v15;
  uint64_t v16;
  const __CFDictionary *v17;
  CFTypeID v18;
  void (*v19)(CFTypeID, uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(CFTypeID, _QWORD, const __CFDictionary *, _QWORD, _QWORD);
  void *v23;

  v11 = objc_autoreleasePoolPush();
  if (a6)
  {
    v12 = (void *)sub_10001E1C8((uint64_t)"__WiFiDeviceEventCallback");
    *(_QWORD *)(a6 + 5912) = 0;
    v13 = *(const void **)(a6 + 5920);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a6 + 5920) = 0;
    }
    if (sub_10001E224((uint64_t *)a6, a3))
    {
      if ((int)a3 <= 136)
      {
        switch((int)a3)
        {
          case 1:
            sub_10007C448(a6, *(const void **)(a6 + 112));
            goto LABEL_33;
          case 2:
          case 5:
          case 6:
          case 7:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 33:
          case 34:
            goto LABEL_109;
          case 3:
            sub_10007C3CC(a6, *(_QWORD *)(a6 + 112));
LABEL_33:
            sub_10006F7A4(a6);
            goto LABEL_109;
          case 4:
            sub_10007B4C8(a6, *(const void **)(a6 + 112), a4);
            goto LABEL_109;
          case 8:
            sub_10007A780(a6, *(_QWORD *)(a6 + 112), a1);
            sub_10007C518((_QWORD *)a6, *(_QWORD *)(a6 + 112), a1);
            goto LABEL_109;
          case 9:
            sub_10007B400(a6, *(_QWORD *)(a6 + 112), a4, a1);
            goto LABEL_109;
          case 10:
            sub_100016A94(a6, *(_QWORD *)(a6 + 112), a4, 0, a1);
            goto LABEL_109;
          case 11:
            sub_10007DC3C((_QWORD *)a6, *(_QWORD *)(a6 + 112));
            goto LABEL_109;
          case 12:
            sub_10007C6D0(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            goto LABEL_109;
          case 13:
            sub_10007C7A0(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            goto LABEL_109;
          case 14:
            v19 = *(void (**)(CFTypeID, uint64_t, uint64_t))(a6 + 4368);
            if (!v19)
              goto LABEL_109;
            v20 = *(_QWORD *)(a6 + 112);
            v21 = *(_QWORD *)(a6 + 4376);
            goto LABEL_103;
          case 30:
            sub_10006A18C(a6, *(_QWORD *)(a6 + 112), a1);
            goto LABEL_109;
          case 31:
            sub_10007C5DC(a6, *(_QWORD *)(a6 + 112), a4);
            goto LABEL_109;
          case 32:
            v19 = *(void (**)(CFTypeID, uint64_t, uint64_t))(a6 + 4464);
            if (!v19)
              goto LABEL_109;
            v20 = *(_QWORD *)(a6 + 112);
            v21 = *(_QWORD *)(a6 + 4472);
            goto LABEL_103;
          case 35:
            v19 = *(void (**)(CFTypeID, uint64_t, uint64_t))(a6 + 4480);
            if (!v19)
              goto LABEL_109;
            v20 = *(_QWORD *)(a6 + 112);
            v21 = *(_QWORD *)(a6 + 4488);
            goto LABEL_103;
          case 36:
            v19 = *(void (**)(CFTypeID, uint64_t, uint64_t))(a6 + 4496);
            if (!v19)
              goto LABEL_109;
            v20 = *(_QWORD *)(a6 + 112);
            v21 = *(_QWORD *)(a6 + 4504);
            goto LABEL_103;
          case 37:
            v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4824);
            if (!v14)
              goto LABEL_109;
            v15 = *(_QWORD *)(a6 + 112);
            v17 = *(const __CFDictionary **)(a6 + 4832);
            v18 = a6;
            v16 = 1;
            goto LABEL_55;
          case 38:
            v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4824);
            if (!v14)
              goto LABEL_109;
            v15 = *(_QWORD *)(a6 + 112);
            v17 = *(const __CFDictionary **)(a6 + 4832);
            v18 = a6;
            v16 = 0;
            goto LABEL_55;
          case 39:
            sub_100011C94((_BYTE *)a6, *(_QWORD *)(a6 + 112), a4);
            goto LABEL_109;
          default:
            switch((int)a3)
            {
              case 'K':
                sub_10007DBA8(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
                break;
              case 'L':
                if (a4)
                {
                  v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4592);
                  if (v14)
                  {
                    v15 = *(_QWORD *)(a6 + 112);
                    v16 = *(_QWORD *)(a6 + 4600);
                    goto LABEL_99;
                  }
                }
                break;
              case 'M':
              case 'N':
              case 'R':
              case 'T':
              case 'U':
              case 'V':
              case 'W':
              case 'X':
              case '[':
                goto LABEL_109;
              case 'O':
                if ((_DWORD)a5 == 140 && objc_msgSend((id)qword_10026DD20, "getLogLevelEnable") == (id)1)
                  sub_10016BA00((_BYTE *)a4 + 12);
                break;
              case 'P':
                sub_10007C1C4(a6, *(const void **)(a6 + 112), a4);
                break;
              case 'Q':
                sub_10007D4F4(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
                break;
              case 'S':
                sub_10006B430((uint64_t *)a6, *(_QWORD *)(a6 + 112), a4, a1);
                break;
              case 'Y':
                sub_10007D56C(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
                break;
              case 'Z':
                sub_10007D488(a6, *(_QWORD *)(a6 + 112), a4);
                break;
              case '\\':
                sub_10005B594(*(_BYTE *)a4 != 0);
                break;
              default:
                switch((int)a3)
                {
                  case '7':
                    sub_10007CA1C(a6, *(const void **)(a6 + 112), a4);
                    break;
                  case '9':
                    sub_10007AD3C((_QWORD *)a6, *(_QWORD *)(a6 + 112), a4, 0, a1);
                    break;
                  case '<':
                    sub_10000A5CC((_QWORD *)a6, a4);
                    break;
                  case '?':
                    sub_10007D340(a6, *(_QWORD *)(a6 + 112), a4);
                    break;
                  default:
                    goto LABEL_109;
                }
                break;
            }
            goto LABEL_109;
        }
      }
      if ((int)a3 > 179)
      {
        if ((int)a3 > 216)
        {
          if ((int)a3 <= 237)
          {
            if ((_DWORD)a3 == 217)
            {
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 5560);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v17 = *(const __CFDictionary **)(a6 + 5568);
                v18 = a6;
                v16 = (uint64_t)a4;
LABEL_55:
                v14(v18, v15, v16, v17);
              }
            }
            else if ((_DWORD)a3 == 218)
            {
              sub_10007C990(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            }
          }
          else if ((a3 - 238) >= 2)
          {
            if ((_DWORD)a3 == 240)
              sub_10007E3B0(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
          }
          else
          {
            sub_10007E314(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4, a5, a3);
          }
        }
        else
        {
          switch((int)a3)
          {
            case 180:
              sub_10001E520(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
              break;
            case 181:
            case 182:
            case 183:
            case 184:
            case 185:
            case 186:
            case 187:
            case 188:
            case 194:
            case 195:
            case 197:
            case 198:
              break;
            case 189:
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 5416);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v16 = *(_QWORD *)(a6 + 5424);
LABEL_99:
                v18 = a6;
                v17 = a4;
                goto LABEL_55;
              }
              break;
            case 190:
              sub_10007C878(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
              break;
            case 191:
              v19 = *(void (**)(CFTypeID, uint64_t, uint64_t))(a6 + 4904);
              if (v19)
              {
                v20 = *(_QWORD *)(a6 + 112);
                v21 = *(_QWORD *)(a6 + 4912);
LABEL_103:
                v19(a6, v20, v21);
              }
              break;
            case 192:
              sub_10007C904(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
              break;
            case 193:
              sub_10007B260(a6, *(_QWORD *)(a6 + 112), a4, a1);
              break;
            case 196:
              sub_10007E0F4(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
              break;
            case 199:
              sub_10007E190(a6, *(_QWORD *)(a6 + 112), a4);
              break;
            default:
              if ((_DWORD)a3 == 210)
                sub_10007E28C(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
              break;
          }
        }
      }
      else
      {
        switch((int)a3)
        {
          case 137:
            if (a4)
            {
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4528);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v16 = *(_QWORD *)(a6 + 4536);
                goto LABEL_99;
              }
            }
            break;
          case 138:
            if (a4)
            {
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4544);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v16 = *(_QWORD *)(a6 + 4552);
                goto LABEL_99;
              }
            }
            break;
          case 139:
            if (a4)
            {
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 4560);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v16 = *(_QWORD *)(a6 + 4568);
                goto LABEL_99;
              }
            }
            break;
          case 140:
            sub_10007D5F8(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          case 141:
            v22 = *(void (**)(CFTypeID, _QWORD, const __CFDictionary *, _QWORD, _QWORD))(a6 + 5272);
            if (v22)
              v22(a6, *(_QWORD *)(a6 + 112), a4, 0, *(_QWORD *)(a6 + 5280));
            break;
          case 142:
          case 144:
          case 146:
          case 147:
          case 149:
          case 152:
          case 153:
          case 154:
          case 155:
          case 157:
          case 158:
          case 159:
          case 160:
          case 161:
          case 162:
          case 163:
          case 166:
          case 167:
          case 168:
            break;
          case 143:
            if (a4)
            {
              v14 = *(void (**)(CFTypeID, uint64_t, uint64_t, const __CFDictionary *))(a6 + 5208);
              if (v14)
              {
                v15 = *(_QWORD *)(a6 + 112);
                v16 = *(_QWORD *)(a6 + 5216);
                goto LABEL_99;
              }
            }
            break;
          case 145:
            sub_100030BC8(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          case 148:
            if (a5 > 0x2B)
            {
              sub_10007D698(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            }
            else
            {
              v23 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi Network Info eventdata len mismatch\n");
              objc_autoreleasePoolPop(v23);
            }
            break;
          case 150:
            sub_10007D8EC(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          case 151:
            sub_10007D9A8(a6, *(_QWORD *)(a6 + 112), a4);
            break;
          case 156:
            sub_1000309C0(a6, *(_QWORD *)(a6 + 112), a4);
            break;
          case 164:
            sub_10007DA70(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          case 165:
            sub_10007DB0C(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          case 169:
            sub_100030C54(a6, *(_QWORD *)(a6 + 112), (uint64_t)a4);
            break;
          default:
            if ((_DWORD)a3 == 176)
              sub_10007DF18(a6, (uint64_t)a4);
            break;
        }
      }
    }
LABEL_109:

  }
  objc_autoreleasePoolPop(v11);
}

uint64_t sub_10001E1C8(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = objc_autoreleasePoolPush();
  v3 = os_transaction_create(-[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("com.apple.wifid.%s"), a1), "UTF8String"));
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_10001E224(uint64_t *a1, int a2)
{
  uint64_t result;
  void (*v5)(uint64_t *, _QWORD, uint64_t, uint64_t);
  void *v6;
  void *v7;
  const __CFString *v8;
  uint64_t v9;
  uint64_t v10;
  CFIndex v11;
  unint64_t v12;

  v11 = 72;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v10 = 0;
  if (sub_10001E3EC(a1[22], &v12, &v11, &v10) || *(_BYTE *)(v12 + 56) != 1)
  {
    result = 1;
    if (a2 <= 0x39 && ((1 << a2) & 0x200000040000600) != 0)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Event %@ is not expected while there is no command pending", sub_10006DEAC(a2), v9);
      goto LABEL_14;
    }
    return result;
  }
  result = 1;
  if (a2 > 56)
  {
    if (a2 == 57)
    {
      if (*(_DWORD *)v12 == 9)
        return result;
    }
    else if (a2 == 83)
    {
      if (*(_DWORD *)v12 == 12)
        return result;
    }
    else if (a2 != 193 || *(_DWORD *)v12 == 14)
    {
      return result;
    }
LABEL_28:
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v8 = sub_10006DEAC(a2);
      objc_msgSend(v7, "WFLog:message:", 4, "Event %@ is not expected while command %@ is pending", v8, sub_10001C840(*(_DWORD *)v12));
    }
LABEL_14:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  if (a2 == 9)
  {
    if (*(_DWORD *)v12 == 1)
      return result;
    goto LABEL_28;
  }
  if (a2 == 10)
  {
    if (!*(_DWORD *)v12)
      return result;
    goto LABEL_28;
  }
  if (a2 == 30 && *(_DWORD *)v12 != 5)
  {
    v5 = (void (*)(uint64_t *, _QWORD, uint64_t, uint64_t))a1[623];
    if (v5)
      v5(a1, 0, a1[624], 1);
    goto LABEL_28;
  }
  return result;
}

uint64_t sub_10001E3EC(uint64_t a1, _QWORD *a2, CFIndex *a3, _QWORD *a4)
{
  CFIndex Count;
  CFIndex v9;
  uint64_t v10;
  const __CFData *ValueAtIndex;
  const __CFData *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  int v15;
  CFIndex Length;
  CFIndex v17;
  uint64_t result;
  UInt8 buffer[8];
  CFRange v20;

  *(_QWORD *)buffer = 0;
  if (!a2 || a3)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
    if (Count >= 1)
    {
      v9 = Count;
      v10 = 1;
      do
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v10 - 1);
        if (!ValueAtIndex)
          return 4294963394;
        v12 = ValueAtIndex;
        v20.location = 0;
        v20.length = 8;
        CFDataGetBytes(ValueAtIndex, v20, buffer);
        v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, buffer);
        if (!v13)
          return 4294963394;
        v14 = v13;
        v15 = CFSetContainsValue(*(CFSetRef *)(a1 + 80), v13);
        CFRelease(v14);
        if (v10 >= v9)
          break;
        ++v10;
      }
      while (v15);
      if (v15)
        return 4294963394;
      if (!a2)
      {
LABEL_14:
        result = 0;
        if (a4)
          *a4 = *(_QWORD *)buffer;
        return result;
      }
      Length = CFDataGetLength(v12);
      v17 = Length - 8;
      if (Length != 8 && v17 <= *a3)
      {
        *a3 = v17;
        *a2 = CFDataGetBytePtr(v12) + 8;
        goto LABEL_14;
      }
    }
  }
  return 4294963394;
}

void sub_10001E520(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BeaconCacheUpdatedEvent Received %@", "__WiFiDeviceProcessBeaconCacheUpdatedEvent", a3);
  objc_autoreleasePoolPop(v6);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5384);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5392), a3);
}

void sub_10001E5BC(uint64_t a1, uint64_t a2)
{
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  _QWORD block[7];

  v4 = objc_autoreleasePoolPush();
  v5 = *(_QWORD **)(a1 + 48);
  if (v5[30])
  {
    CFRetain(v5);
    block[0] = _NSConcreteStackBlock;
    block[2] = sub_100009DE0;
    block[3] = &unk_100231C58;
    v6 = *(_QWORD *)(a1 + 48);
    v7 = *(_QWORD *)(a1 + 56);
    v8 = *(NSObject **)(v6 + 240);
    block[1] = 3221225472;
    block[4] = a2;
    block[5] = v7;
    block[6] = v6;
    dispatch_async(v8, block);
    sub_10001E764(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "UUIDString")), 0);
    sub_10001E764(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 64), 9, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "UUIDString")), 0);
    if (*(_QWORD *)(a1 + 56) == 39)
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + 6616) = 0;
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceManagerStartAutoJoinAndReply_block_invoke");
    objc_autoreleasePoolPop(v9);
  }
  objc_autoreleasePoolPop(v4);
  CFRelease(*(CFTypeRef *)(a1 + 48));

}

void sub_10001E764(uint64_t a1, int a2, const void *a3, CFNumberRef a4)
{
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  __CFDictionary *Value;
  CFMutableDictionaryRef Mutable;
  CFNumberRef v13;
  CFNumberRef v14;
  void *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  void *v18;
  CFNumberRef v19;
  void *v20;
  uint64_t v21;
  CFNumberRef v22;
  unsigned int valuePtr;

  valuePtr = a2;
  v22 = a4;
  if (!a1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL device", "WiFiDeviceSetMinimumCommandPriority", v21);
    goto LABEL_31;
  }
  if (!a3)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL UUID", "WiFiDeviceSetMinimumCommandPriority", v21);
    goto LABEL_31;
  }
  if (((unint64_t)a4 & 0x8000000000000000) != 0)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid priority (%ld)", "WiFiDeviceSetMinimumCommandPriority", a4);
LABEL_31:
    objc_autoreleasePoolPop(v20);
    return;
  }
  v7 = sub_10001EA60((CFNumberRef)a1, a3, a2);
  if (v7 != a4)
  {
    v8 = v7;
    v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v9)
    {
      v10 = v9;
      Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 200), a3);
      if (Value)
      {
        Mutable = Value;
        CFRetain(Value);
      }
      else
      {
        Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 200), a3, Mutable);
        if (!Mutable)
        {
          v19 = v10;
LABEL_23:
          CFRelease(v19);
          return;
        }
      }
      v13 = sub_10001EA60((CFNumberRef)a1, 0, valuePtr);
      if (a4)
      {
        v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &v22);
        if (!v14)
        {
LABEL_21:
          CFRelease(Mutable);
          CFRelease(v10);
          if (!v14)
            return;
          v19 = v14;
          goto LABEL_23;
        }
        CFDictionarySetValue(Mutable, v10, v14);
      }
      else
      {
        CFDictionaryRemoveValue(Mutable, v10);
        if (!CFDictionaryGetCount(Mutable))
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 200), a3);
        v14 = 0;
      }
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Updated minimum command queue priority for UUID '%@' (%ld -> %ld, type=%@)", a3, v8, v22, sub_10001C840(valuePtr));
      objc_autoreleasePoolPop(v15);
      v16 = sub_10001EA60((CFNumberRef)a1, 0, valuePtr);
      if (v13 != v16)
      {
        v17 = v16;
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Updated prevailing minimum command queue priority (%ld -> %ld, type=%@)", v13, v17, sub_10001C840(valuePtr));
        objc_autoreleasePoolPop(v18);
        sub_100154B90(*(_QWORD *)(a1 + 176));
      }
      goto LABEL_21;
    }
  }
}

CFNumberRef sub_10001EA60(CFNumberRef result, const void *a2, int a3)
{
  CFNumberRef v4;
  CFNumberRef v5;
  const __CFDictionary *v6;
  const __CFDictionary *Value;
  const __CFNumber *v8;
  CFIndex Count;
  uint64_t v10;
  size_t v11;
  const void **v12;
  uint64_t v13;
  const __CFDictionary *v14;
  const __CFNumber *v15;
  uint64_t v16;
  uint64_t v17;
  int valuePtr;

  valuePtr = a3;
  v17 = 0;
  if (result)
  {
    v4 = result;
    result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (result)
    {
      v5 = result;
      v6 = (const __CFDictionary *)*((_QWORD *)v4 + 25);
      if (a2)
      {
        Value = (const __CFDictionary *)CFDictionaryGetValue(v6, a2);
        if (Value)
        {
          v8 = (const __CFNumber *)CFDictionaryGetValue(Value, v5);
          if (v8)
            CFNumberGetValue(v8, kCFNumberCFIndexType, &v17);
        }
      }
      else
      {
        Count = CFDictionaryGetCount(v6);
        if (Count)
        {
          v10 = Count;
          __chkstk_darwin();
          v12 = (const void **)((char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
          memset(v12, 170, v11);
          CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)v4 + 25), v12, 0);
          if (v10 >= 1)
          {
            v13 = 0;
            do
            {
              v14 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)v4 + 25), *v12);
              if (v14)
              {
                v15 = (const __CFNumber *)CFDictionaryGetValue(v14, v5);
                if (v15)
                {
                  v16 = 0;
                  CFNumberGetValue(v15, kCFNumberCFIndexType, &v16);
                  if (v16 > v13)
                    v13 = v16;
                  v17 = v13;
                }
              }
              ++v12;
              --v10;
            }
            while (v10);
          }
        }
      }
      CFRelease(v5);
      return (CFNumberRef)v17;
    }
  }
  return result;
}

void sub_10001EBD8(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  void (*v10)(_QWORD *, const void *, void *, uint64_t, uint64_t, _QWORD);
  void *v11;
  void *v12;
  const __CFArray *v13;
  void *i;
  void *v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  unsigned __int8 v26;
  void *v27;
  CFMutableArrayRef Mutable;
  CFTypeRef cf;
  uint64_t v30;
  const void *v31;
  _QWORD *v32;
  void *v33;
  id v34;
  id v35;
  const __CFArray *v36;
  const void *v37;
  id obj;
  uint64_t v39;
  id v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[128];

  if (a6)
  {
    v10 = (void (*)(_QWORD *, const void *, void *, uint64_t, uint64_t, _QWORD))a6[519];
    if (v10)
      v10(a6, a2, a3, a4, a5, a6[520]);
    v11 = objc_autoreleasePoolPush();
    if (a6[921])
    {
      if (a3)
        obj = objc_msgSend(a3, "objectForKey:", CFSTR("scanResults"));
      else
        obj = 0;
      v34 = +[NSMutableSet set](NSMutableSet, "set");
      v35 = +[NSMutableSet set](NSMutableSet, "set");
      v12 = sub_10002A21C((uint64_t)a6, a2, 1);
      v32 = a6;
      v33 = v11;
      v30 = a1;
      v31 = a2;
      cf = v12;
      if (v12)
      {
        v13 = (const __CFArray *)v12;
        v37 = sub_10002B088(v12);
        v36 = sub_10001F1E8(v13);
      }
      else
      {
        v36 = 0;
        v37 = 0;
      }
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v40 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v41, v45, 16);
      if (v40)
      {
        v39 = *(_QWORD *)v42;
        do
        {
          for (i = 0; i != v40; i = (char *)i + 1)
          {
            if (*(_QWORD *)v42 != v39)
              objc_enumerationMutation(obj);
            v15 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)i);
            v16 = objc_autoreleasePoolPush();
            v17 = objc_msgSend(v15, "objectForKey:", CFSTR("SSID_STR"));
            v18 = objc_msgSend(v15, "objectForKey:", CFSTR("BSSID"));
            v19 = objc_msgSend(v15, "objectForKey:", CFSTR("CHANNEL_FLAGS"));
            v20 = objc_msgSend(v15, "objectForKey:", CFSTR("CHANNEL"));
            v21 = objc_msgSend(v15, "objectForKey:", CFSTR("RSSI"));
            v22 = objc_msgSend(v15, "objectForKey:", CFSTR("WPS_PROB_RESP_IE"));
            if (v18)
            {
              v23 = v22;
              v24 = +[WiFiUsageBssDetails bssWithIdentifier:channel:channelFlags:rssi:](WiFiUsageBssDetails, "bssWithIdentifier:channel:channelFlags:rssi:", v18, objc_msgSend(v20, "integerValue"), objc_msgSend(v19, "integerValue"), objc_msgSend(v21, "integerValue"));
              if (v24)
              {
                v25 = v24;
                if (!v17
                  || !v37
                  || (v26 = objc_msgSend(v17, "isEqualToString:", v37), v27 = v34, (v26 & 1) == 0))
                {
                  v27 = v35;
                }
                objc_msgSend(v27, "addObject:", v25);
                if (v23 && v36 && objc_msgSend(v18, "isEqual:", v36))
                  -[WiFiUsageMonitor updateWPSInfo:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "updateWPSInfo:", v15);
              }
            }
            objc_autoreleasePoolPop(v16);
          }
          v40 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v41, v45, 16);
        }
        while (v40);
      }
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      sub_10001F264(v30, Mutable);
      objc_msgSend((id)v32[921], "setScanningState:client:neighborBSS:otherBSS:withChannelInfoList:withRequest:forInterface:", 0, 0, v34, v35, Mutable, 0, v31);
      if (cf)
        CFRelease(cf);
      v11 = v33;
      if (Mutable)
        CFRelease(Mutable);
    }
    objc_autoreleasePoolPop(v11);
  }
}

void sub_10001EF38(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  void *i;
  void *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  void *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  void *context;
  _QWORD block[5];
  char v25;
  char v26;
  char v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];

  v3 = *(_QWORD *)(a1 + 32);
  v4 = objc_autoreleasePoolPush();
  v5 = v4;
  if (!a2)
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v19 = "FrontBoard Display Layout is Null!";
      v20 = 4;
LABEL_31:
      objc_msgSend(v18, "WFLog:message:", v20, v19, v21);
      goto LABEL_32;
    }
    goto LABEL_32;
  }
  if (!v3)
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v21 = "__WiFiManagerFrontBoardDisplayCallback";
      v19 = "%s: null manager.";
LABEL_30:
      v20 = 3;
      goto LABEL_31;
    }
LABEL_32:
    objc_autoreleasePoolPop(v17);
    goto LABEL_23;
  }
  if (!*(_QWORD *)(v3 + 32))
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v21 = "__WiFiManagerFrontBoardDisplayCallback";
      v19 = "%s: nil manager queue.";
      goto LABEL_30;
    }
    goto LABEL_32;
  }
  v22 = v3;
  context = v4;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v6 = objc_msgSend(a2, "elements");
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = *(_QWORD *)v29;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v29 != v12)
          objc_enumerationMutation(v6);
        v14 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i);
        if (v14)
        {
          if (objc_msgSend(objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i), "identifier"), "isEqualToString:", CFSTR("com.apple.control-center")))
          {
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Control Center launched");
            objc_autoreleasePoolPop(v15);
            v9 = 1;
          }
          if (objc_msgSend(objc_msgSend(v14, "identifier"), "isEqualToString:", CFSTR("com.apple.springboard.home-screen")))v10 = 1;
          if (objc_msgSend(objc_msgSend(v14, "identifier"), "isEqualToString:", CFSTR("sceneID:com.apple.camera-default")))v11 = 1;
        }
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
    }
    while (v8);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
  }
  v16 = *(NSObject **)(v22 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002FD1C;
  block[3] = &unk_100230A98;
  block[4] = v22;
  v25 = v10;
  v26 = v11;
  v27 = v9;
  dispatch_async(v16, block);
  v5 = context;
LABEL_23:
  objc_autoreleasePoolPop(v5);
}

const __CFArray *sub_10001F1E8(const __CFArray *result)
{
  uint64_t v1;
  const __CFArray *v2;
  CFIndex Count;

  if (result)
  {
    v1 = (uint64_t)result;
    result = (const __CFArray *)sub_10002BE64((uint64_t)result, CFSTR("BSSID"));
    if (!result)
    {
      result = (const __CFArray *)sub_10002BE64(v1, CFSTR("networkKnownBSSListKey"));
      if (result)
      {
        v2 = result;
        result = (const __CFArray *)CFArrayGetCount(result);
        if (result)
        {
          Count = CFArrayGetCount(v2);
          result = (const __CFArray *)CFArrayGetValueAtIndex(v2, Count - 1);
          if (result)
            return (const __CFArray *)CFDictionaryGetValue(result, CFSTR("BSSID"));
        }
      }
    }
  }
  return result;
}

uint64_t sub_10001F264(uint64_t a1, void *a2)
{
  const __CFArray *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  int j;
  uint64_t v10;
  CFIndex Count;
  CFIndex v13;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v16;
  void *v18;
  void *v19;
  CFArrayRef theArray;

  v4 = *(const __CFArray **)(a1 + 5664);
  if (v4 && CFArrayGetCount(v4))
  {
    objc_msgSend(a2, "addObjectsFromArray:", *(_QWORD *)(a1 + 5664));
    return 0;
  }
  v6 = sub_10002DEA0(a1, *(const void **)(a1 + 112));
  if (!v6)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", *(_QWORD *)(a1 + 112));
    objc_autoreleasePoolPop(v18);
    return 0;
  }
  v7 = (uint64_t)v6;
  theArray = 0;
  v8 = CFGetTypeID(v6);
  if (v8 == sub_10002DE64())
  {
    v5 = sub_10015CE30(v7, 207, 0, &theArray);
LABEL_19:
    if (theArray)
    {
      Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        v13 = Count;
        for (i = 0; i != v13; ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
          if (ValueAtIndex)
          {
            v16 = ValueAtIndex;
            if (CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNELINFO_CH_NUM")))
              CFArrayAppendValue((CFMutableArrayRef)a2, v16);
          }
        }
      }
      if (theArray)
        CFRelease(theArray);
    }
  }
  else
  {
    for (j = 6; ; --j)
    {
      v10 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 207, 0, &theArray);
      v5 = v10;
      if ((int)v10 <= 15)
      {
        if ((_DWORD)v10 != -3905)
          break;
      }
      else if ((_DWORD)v10 != 61 && (_DWORD)v10 != 16)
      {
        goto LABEL_32;
      }
      if (!j)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v10)
      goto LABEL_19;
LABEL_32:
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not read APPLE80211_IOC_CHANNELS_INFO err=%d", v5);
    objc_autoreleasePoolPop(v19);
  }
  return v5;
}

uint64_t sub_10001F440(const void *a1)
{
  const __CFNumber *v2;
  unsigned int v3;
  unsigned int v4;
  const __CFNumber *v5;

  v2 = (const __CFNumber *)sub_10002BE64((uint64_t)a1, CFSTR("HIDDEN_NETWORK"));
  v3 = sub_10001F500(v2);
  if (v3)
    goto LABEL_2;
  v5 = (const __CFNumber *)sub_10002BE64((uint64_t)a1, CFSTR("scanWasDirected"));
  if (!sub_10001F500(v5))
  {
    v3 = sub_100007DCC(a1);
LABEL_2:
    v4 = 0;
    goto LABEL_5;
  }
  v3 = 0;
  v4 = 1;
LABEL_5:
  if (v3)
    return 1;
  else
    return v4;
}

uint64_t sub_10001F4AC(uint64_t result)
{
  const __CFDictionary *v1;
  const __CFNumber *Value;
  const __CFNumber *v3;

  if (result)
  {
    v1 = *(const __CFDictionary **)(result + 16);
    Value = (const __CFNumber *)CFDictionaryGetValue(v1, CFSTR("SCAN_RESULT_OWE_MULTI_SSID"));
    LOBYTE(result) = sub_10001F500(Value);
    if (!(_BYTE)result)
    {
      v3 = (const __CFNumber *)CFDictionaryGetValue(v1, CFSTR("ALLOW_OWE_TSN"));
      LOBYTE(result) = sub_10001F500(v3);
    }
  }
  return result;
}

const __CFNumber *sub_10001F500(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  CFTypeID v3;
  uint64_t valuePtr;

  valuePtr = 0;
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberCFIndexType, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFBooleanGetTypeID())
        return (const __CFNumber *)(kCFBooleanTrue == v1);
      else
        return 0;
    }
  }
  return result;
}

void sub_10001FAC8(uint64_t a1)
{
  -[WiFiUserInteractionMonitor setApplicationRunningState:foregroundState:andNetworkingState:forBundleId:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "setApplicationRunningState:foregroundState:andNetworkingState:forBundleId:", *(unsigned __int8 *)(a1 + 52), *(unsigned __int8 *)(a1 + 53), objc_msgSend(*(id *)(a1 + 32), "_appUsesWiFiNetwork:", *(unsigned int *)(a1 + 48)), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));

}

void sub_10002008C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100020CF0()
{
  unsigned int v0;
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  void *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (-[WiFiUserInteractionMonitor isCarPlay](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCarPlay")|| -[WiFiUserInteractionMonitor isMediaPlaying](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isMediaPlaying")|| -[WiFiUserInteractionMonitor isAirplayActiveOverInfra](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAirplayActiveOverInfra"))
  {
    v0 = 1;
  }
  else
  {
    v0 = -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive");
  }
  v1 = -[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen");
  v2 = -[WiFiUserInteractionMonitor isAVConferenceActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isAVConferenceActive");
  if (v0)
    v3 = 0;
  else
    v3 = v1;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v5 = "Foreground";
    if (v3)
      v5 = "Background";
    v6 = "yes";
    if (v1)
      v7 = "no";
    else
      v7 = "yes";
    if (v2)
      v8 = "yes";
    else
      v8 = "no";
    if (!v0)
      v6 = "no";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: app state for DPS action : %s isAnyAppInFG:%s isFTactive:%s isLatencySensitiveAppActive:%s", "WiFiDeviceManagerGetAppState", v5, v7, v8, v6);
  }
  v9 = v1 ^ 1;
  objc_autoreleasePoolPop(v4);
  if (v3)
    v10 = 0;
  else
    v10 = 0x1000000;
  v11 = v10 | (v0 << 16);
  if (v2)
    v12 = 256;
  else
    v12 = 0;
  return v12 | v9 | v11;
}

float sub_100020E40(uint64_t a1, const void *a2, const __CFDictionary *a3, unsigned int a4)
{
  void *v7;
  WiFiUsageMonitor *v8;
  double Current;
  float v10;
  double v11;
  const __CFNumber *v12;
  const __CFString *v13;
  const __CFString *v14;
  const void *v15;
  const void *v16;
  void *v17;
  CFTypeRef v18;
  const void *v19;
  void *v20;
  uint64_t v21;
  const __CFString *v22;
  void *v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const __CFArray *v28;
  CFMutableStringRef Mutable;
  __CFString *v30;
  const void *v31;
  const __CFArray *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const char *v36;
  int Count;
  CFIndex v38;
  uint64_t v39;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  void *v46;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v48;
  CFNumberRef v49;
  int ValueIfPresent;
  void *v51;
  BOOL v52;
  int v54;
  const __CFNumber *v55;
  uint64_t v56;
  const void *v57;
  CFDictionaryRef v58;
  int v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  CFIndex v65;
  const __CFDictionary *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  WiFiUsageMonitor *v70;
  uint64_t v71;
  __int128 v72;
  const __CFNumber *v73;
  _BOOL4 v74;
  int v75;
  __int16 v76;
  __int16 v77;
  int v78;
  unsigned __int8 v79;
  uint64_t v80;
  unint64_t v81;
  unsigned int v82;
  const __CFDictionary *v83;
  BOOL v84;
  const __CFNumber *v85;
  const __CFNumber *v86;
  int v87;
  int v88;
  void *v89;
  int v90;
  uint64_t v91;
  void *v92;
  int v93;
  double v94;
  double v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  const void *v101;
  const __CFString *v102;
  double v103;
  double v104;
  uint64_t v105;
  double v106;
  const void *v107;
  const __CFString *v108;
  double v109;
  const void *v110;
  const __CFString *v111;
  double v112;
  const void *v113;
  const __CFString *v114;
  double v115;
  double v116;
  const char *v117;
  double v118;
  uint64_t v119;
  double v120;
  double v121;
  uint64_t v122;
  double v123;
  double v124;
  const char *v125;
  double v126;
  const char *v127;
  double v128;
  uint64_t v129;
  double v130;
  double v131;
  const char *v132;
  void *v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  id v137;
  id v138;
  id v139;
  id v140;
  uint64_t v141;
  void *i;
  uint64_t v143;
  void *v144;
  id v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  CFIndex v159;
  uint64_t v160;
  void *v161;
  __int128 v162;
  int v163;
  double v164;
  double v165;
  CFIndex v166;
  const __CFDictionary *v167;
  const __CFNumber *v168;
  int v169;
  const __CFDictionary *v170;
  double v171;
  float v172;
  int v173;
  const __CFNumber *v174;
  int v175;
  int v176;
  int v177;
  void *v178;
  int v179;
  void *v180;
  const __CFArray *v181;
  const __CFDictionary *v182;
  const __CFDictionary *v183;
  const void *v184;
  const void *v185;
  const void *v186;
  const void *v187;
  CFNumberRef v188;
  CFNumberRef v189;
  CFDictionaryRef v190;
  int v191;
  int v192;
  int v193;
  uint64_t v194;
  BOOL v195;
  int v196;
  int v197;
  const __CFArray *v198;
  const __CFDictionary *v199;
  int v200;
  const __CFArray *v201;
  const __CFDictionary *v202;
  int v203;
  const __CFDictionary *v204;
  const __CFNumber *v205;
  void *v206;
  void *v207;
  void *v208;
  uint64_t v209;
  const __CFString *v210;
  const __CFArray *v211;
  const __CFDictionary *v212;
  int v213;
  void *v214;
  const __CFNumber *v215;
  uint64_t v216;
  unint64_t v217;
  void *v218;
  void *v219;
  const char *v220;
  uint64_t v221;
  const __CFNumber *v222;
  void *v223;
  uint64_t v224;
  unint64_t v225;
  void *v226;
  void *v227;
  void *v228;
  uint64_t v229;
  const __CFString *v230;
  uint64_t v231;
  unint64_t v232;
  void *v233;
  const void *v234;
  double v235;
  uint64_t v236;
  BOOL v238;
  CFNumberRef v239;
  CFNumberRef v240;
  void *v241;
  void *v242;
  int v243;
  void *v244;
  void *v245;
  void *v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  int v257;
  void *v258;
  unint64_t v259;
  unint64_t v260;
  float v261;
  uint64_t v262;
  const __CFDictionary *v263;
  unsigned int v264;
  int v265;
  void *v266;
  BOOL v267;
  int v268;
  _BOOL4 v269;
  char v270;
  int v271;
  int v272;
  const __CFArray *v273;
  CFIndex v274;
  const __CFDictionary *v275;
  double AbsoluteTime;
  double v277;
  CFIndex v278;
  const __CFDictionary *v279;
  const __CFDictionary *v280;
  BOOL v281;
  uint64_t v282;
  char v283;
  void *v284;
  unsigned int v285;
  unsigned int v286;
  unsigned int v287;
  void *v288;
  void *v289;
  char v290;
  char v291;
  char v292;
  uint64_t v293;
  int v294;
  int v295;
  void *v296;
  void *v297;
  const char *v298;
  int v300;
  void *v301;
  int v302;
  void *v303;
  NSObject *v304;
  int v305;
  CFNumberRef v306;
  void *v307;
  void *v308;
  CFMutableArrayRef v309;
  __CFArray *v310;
  CFNumberRef v311;
  CFNumberRef v312;
  void *v313;
  CFNumberRef v314;
  CFNumberRef v315;
  void *v316;
  void *v317;
  const void *v318;
  unint64_t v319;
  const void *v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  id v330;
  id v331;
  uint64_t v332;
  _BOOL4 v334;
  void *v335;
  int v336;
  void *v337;
  void *v338;
  uint64_t v339;
  CFNumberRef cf;
  WiFiUsageMonitor *v341;
  void *v342;
  __CFDictionary *v343;
  char v344;
  int v345;
  _BOOL4 v346;
  const __CFDictionary *v347;
  uint64_t v348;
  char valuePtr;
  CFAbsoluteTime v350;
  void *value;
  CFNumberRef number[2];
  __int128 v353;
  uint64_t v354;
  CFNumberRef v355[2];
  __int128 v356;
  unint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  void *v362;
  void *v363;
  void *v364;
  void *v365;
  void *v366;
  void *v367;
  void *v368;
  void *v369;
  void *v370;
  void *v371;
  void *v372;
  void *v373;
  void *v374;
  void *v375;
  void *v376;
  void *v377;
  void *v378;
  void *v379;
  void *v380;
  void *v381;
  void *v382;
  unsigned int v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  int v389;
  __int16 v390;
  __int16 v391;
  int v392;
  unsigned int v393;
  void *v394;
  void *v395;
  _OWORD keys[8];
  __int128 values;
  __int128 v398;
  __int128 v399;
  __int128 v400;

  v7 = objc_autoreleasePoolPush();
  valuePtr = 0;
  v8 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
  Current = CFAbsoluteTimeGetCurrent();
  v10 = 0.0;
  if (!a1)
    goto LABEL_499;
  if (!a3)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqmDict is null", "WiFiLQAMgrLQMNotify", v319);
    goto LABEL_198;
  }
  v11 = Current;
  v12 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("LINK_CHANGED_IS_LINKDOWN"));
  if (v12)
  {
    CFNumberGetValue(v12, kCFNumberSInt8Type, &valuePtr);
    if (valuePtr)
      goto LABEL_499;
  }
  v13 = (const __CFString *)sub_100025C3C(*(_QWORD *)(a1 + 32));
  v14 = v13;
  v348 = a1;
  if (v13)
  {
    v15 = *(const void **)(a1 + 40);
    if (v15)
    {
      if (CFEqual(v13, v15))
        goto LABEL_14;
      v16 = *(const void **)(a1 + 40);
      if (v16)
      {
        CFRelease(v16);
        *(_QWORD *)(a1 + 40) = 0;
      }
    }
    *(_QWORD *)(a1 + 40) = CFStringCreateCopy(kCFAllocatorDefault, v14);
  }
  else
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Main Interface is Null", "WiFiLQAMgrLQMNotify");
    objc_autoreleasePoolPop(v17);
    a1 = v348;
  }
LABEL_14:
  if (*(_DWORD *)(a1 + 20))
    goto LABEL_28;
  if (a2)
    v18 = CFRetain(a2);
  else
    v18 = sub_10002BF8C(*(_QWORD *)(a1 + 32), v14);
  v19 = v18;
  if (!v18)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v24 = *(int *)(a1 + 20);
      if (v24 > 4)
        v25 = CFSTR("Bogus");
      else
        v25 = *(&off_10022F1A0 + v24);
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager LQM Event in %@", "WiFiLQAMgrLQMNotify", v25);
    }
LABEL_198:
    objc_autoreleasePoolPop(v23);
    goto LABEL_499;
  }
  sub_100043AE8(a1, v18);
  *(_DWORD *)(a1 + 20) = 1;
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v21 = *(int *)(a1 + 20);
    if (v21 > 4)
      v22 = CFSTR("Bogus");
    else
      v22 = *(&off_10022F1A0 + v21);
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v22);
  }
  objc_autoreleasePoolPop(v20);
  *(CFAbsoluteTime *)(a1 + 64) = CFAbsoluteTimeGetCurrent();
  CFRelease(v19);
LABEL_28:
  v341 = v8;
  v342 = v7;
  -[WiFiPerfPerAssoc ingestLQMUpdate:](+[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance"), "ingestLQMUpdate:", a3);
  v26 = (const __CFDictionary *)CFDictionaryGetValue(a3, CFSTR("ROAM_STATE"));
  v347 = a3;
  if (v26)
  {
    v27 = v26;
    v28 = (const __CFArray *)CFDictionaryGetValue(v26, CFSTR("ROAM_CACHE"));
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    if (Mutable)
    {
      v30 = Mutable;
      v31 = sub_10002B088(*(const void **)(a1 + 48));
      v32 = sub_10001F1E8(*(const __CFArray **)(v348 + 48));
      v33 = CFDictionaryGetValue(v27, CFSTR("RSSI"));
      v34 = CFDictionaryGetValue(v27, CFSTR("ROAM_SCAN_COUNT"));
      v35 = CFDictionaryGetValue(v27, CFSTR("ROAM_SCAN_AGE"));
      v318 = v31;
      a1 = v348;
      CFStringAppendFormat(v30, 0, CFSTR("CurrentBSS {%@ - %@} {%@dbm, %@, %@ms "), v318, v32, v33, v34, v35);
      if (*(_BYTE *)(v348 + 248))
        v36 = "edgeBSS";
      else
        v36 = "";
      CFStringAppendFormat(v30, 0, CFSTR("%s} RoamCache - {"), v36);
      if (v28)
      {
        Count = CFArrayGetCount(v28);
        if (!Count)
        {
LABEL_42:
          CFRelease(v30);
          a3 = v347;
          goto LABEL_43;
        }
        if (Count >= 1)
        {
          v38 = 0;
          v39 = Count;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v28, v38);
            if (!ValueAtIndex)
              goto LABEL_42;
            v41 = ValueAtIndex;
            v42 = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
            v43 = CFDictionaryGetValue(v41, CFSTR("RSSI"));
            v44 = CFDictionaryGetValue(v41, CFSTR("CHANNEL"));
            v45 = CFDictionaryGetValue(v41, CFSTR("CHANNEL_FLAGS"));
            v320 = v43;
            a1 = v348;
            CFStringAppendFormat(v30, 0, CFSTR("{%@, %@, %@, %@}"), v42, v320, v44, v45);
          }
          while (v39 != ++v38);
        }
      }
      CFStringAppend(v30, CFSTR("}"));
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", v30);
      objc_autoreleasePoolPop(v46);
      goto LABEL_42;
    }
  }
LABEL_43:
  value = 0;
  if (*(_QWORD *)(a1 + 24))
  {
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a3);
    if (MutableCopy)
    {
      v48 = MutableCopy;
      v350 = CFAbsoluteTimeGetCurrent();
      v49 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v350);
      if (!v49)
      {
        v248 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: CFNumberCreate for timestamp failed", "__WiFiLQAMgrAddLQMEntry");
        objc_autoreleasePoolPop(v248);
        goto LABEL_380;
      }
      cf = v49;
      CFDictionaryAddValue(v48, CFSTR("kWiFiLqaMgrLqmSampleLocalTimestamp"), v49);
      ValueIfPresent = CFDictionaryGetValueIfPresent(a3, CFSTR("TXRX_STATS_VALID"), (const void **)&value);
      v51 = value;
      if (ValueIfPresent)
        v52 = value == 0;
      else
        v52 = 1;
      v54 = v52 || value == kCFBooleanTrue;
      v345 = v54;
      v392 = 0;
      v393 = 0;
      v391 = 0;
      v390 = 0;
      v389 = 0;
      v387 = 0;
      v388 = 0;
      v385 = 0;
      v386 = 0;
      v384 = 0;
      v383 = 0;
      v394 = 0;
      v395 = 0;
      v381 = 0;
      v382 = 0;
      v379 = 0;
      v380 = 0;
      v377 = 0;
      v378 = 0;
      v375 = 0;
      v376 = 0;
      v373 = 0;
      v374 = 0;
      v371 = 0;
      v372 = 0;
      v369 = 0;
      v370 = 0;
      v367 = 0;
      v368 = 0;
      v365 = 0;
      v366 = 0;
      v363 = 0;
      v364 = 0;
      v361 = 0;
      v362 = 0;
      v360 = 0;
      v359 = 0;
      v358 = 0;
      v55 = (const __CFNumber *)CFDictionaryGetValue(v48, CFSTR("RSSI"));
      if (v55)
      {
        CFNumberGetValue(v55, kCFNumberSInt32Type, &v393);
        v56 = v348;
        *(_DWORD *)(v348 + 2796) = v393;
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("PER_CORE_RSSI"), (const void **)&v369))
        {
          sub_100024E48((const __CFArray *)v369, &v361, &v360);
          v355[0] = 0;
          if (CFDictionaryGetValueIfPresent(v48, CFSTR("PER_CORE_RSSI"), (const void **)v355))
          {
            if (v355[0])
            {
              v57 = CFDictionaryGetValue(v48, CFSTR("LQMTIMESTAMP"));
              if (v57)
              {
                keys[0] = *(_OWORD *)off_10022F128;
                *(_QWORD *)&values = v57;
                *((CFNumberRef *)&values + 1) = v355[0];
                v58 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)&values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(v348 + 264), 0, v58);
                v59 = CFArrayGetCount(*(CFArrayRef *)(v348 + 264));
                if (v59 >= 4)
                {
                  do
                  {
                    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v348 + 264), (v59 - 1));
                    v59 = CFArrayGetCount(*(CFArrayRef *)(v348 + 264));
                  }
                  while (v59 > 3);
                }
                if (v58)
                  CFRelease(v58);
              }
            }
          }
        }
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("SNR"), (const void **)&v382) && v382)
          CFNumberGetValue((CFNumberRef)v382, kCFNumberSInt16Type, (char *)&v392 + 2);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("NOISE"), (const void **)&v381) && v381)
          CFNumberGetValue((CFNumberRef)v381, kCFNumberSInt16Type, &v392);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("PER_CORE_NOISE"), (const void **)&v368)
          && !sub_100024E48((const __CFArray *)v368, &v359, &v358))
        {
          v368 = 0;
        }
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("CCA"), (const void **)&v380) && v380)
          CFNumberGetValue((CFNumberRef)v380, kCFNumberSInt8Type, (char *)&v391 + 1);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("CCA_STATS"), (const void **)&v364) && v364)
        {
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v364, CFSTR("CCA_SELF_TOTAL"), (const void **)&v367)
            && v367)
          {
            CFNumberGetValue((CFNumberRef)v367, kCFNumberSInt8Type, &v391);
          }
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v364, CFSTR("CCA_OTHER_TOTAL"), (const void **)&v365)
            && v365)
          {
            CFNumberGetValue((CFNumberRef)v365, kCFNumberSInt8Type, (char *)&v390 + 1);
          }
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v364, CFSTR("CCA_INTERFERENCE_TOTAL"), (const void **)&v366)&& v366)
          {
            CFNumberGetValue((CFNumberRef)v366, kCFNumberSInt8Type, &v390);
          }
        }
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXFAIL"), (const void **)&v379) && v379)
          CFNumberGetValue((CFNumberRef)v379, kCFNumberIntType, &v389);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXFRAMES"), (const void **)&v377) && v377)
          CFNumberGetValue((CFNumberRef)v377, kCFNumberIntType, (char *)&v388 + 4);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXFWFRAMES"), (const void **)&v395) && v395)
          CFNumberGetValue((CFNumberRef)v395, kCFNumberIntType, &v384);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXFWFAIL"), (const void **)&v394) && v394)
          CFNumberGetValue((CFNumberRef)v394, kCFNumberIntType, &v383);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXRETRANS"), (const void **)&v378) && v378)
          CFNumberGetValue((CFNumberRef)v378, kCFNumberIntType, &v388);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("RXFRAMES"), (const void **)&v376) && v376)
          CFNumberGetValue((CFNumberRef)v376, kCFNumberIntType, (char *)&v387 + 4);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("RXRETRYFRMS"), (const void **)&v375) && v375)
          CFNumberGetValue((CFNumberRef)v375, kCFNumberIntType, &v387);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("RXBEACONFRMS"), (const void **)&v374) && v374)
          CFNumberGetValue((CFNumberRef)v374, kCFNumberIntType, (char *)&v386 + 4);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("RXBEACONSCHED"), (const void **)&v373) && v373)
          CFNumberGetValue((CFNumberRef)v373, kCFNumberIntType, &v386);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("RXRATE"), (const void **)&v371) && v371)
          CFNumberGetValue((CFNumberRef)v371, kCFNumberIntType, &v385);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXRATE"), (const void **)&v372) && v372)
          CFNumberGetValue((CFNumberRef)v372, kCFNumberIntType, (char *)&v385 + 4);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("TXFBRATE"), (const void **)&v370) && v370)
          CFNumberGetValue((CFNumberRef)v370, kCFNumberIntType, (char *)&v384 + 4);
        v357 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v60 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v355 = v60;
        v356 = v60;
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("MLO_OP_STATS"), (const void **)&v363) && v363)
          sub_100046D08(v348, (CFDictionaryRef)v363);
        if (CFDictionaryGetValueIfPresent(v48, CFSTR("MLO_LQM_STATS"), (const void **)&v362))
        {
          if (*(_DWORD *)(v348 + 3044))
          {
            v61 = 0;
            v62 = v348 + 3048;
            do
            {
              v63 = v62 + v61;
              if (*(_BYTE *)(v62 + v61))
              {
                v64 = *(_OWORD *)(v63 + 16);
                *(_OWORD *)v355 = *(_OWORD *)v63;
                v356 = v64;
                v357 = *(_QWORD *)(v63 + 32);
              }
              v61 += 40;
            }
            while (v61 != 120);
          }
          if (v362 && CFArrayGetCount((CFArrayRef)v362) >= 1)
          {
            v65 = 0;
            do
            {
              v66 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v362, v65);
              if (v66)
                sub_100046E74(v348, v66, v65);
              ++v65;
            }
            while (CFArrayGetCount((CFArrayRef)v362) > v65);
          }
          if (*(_DWORD *)(v348 + 3044))
          {
            v67 = 0;
            v68 = 0;
            v69 = v348 + 3048;
            do
            {
              if (*(_BYTE *)(v69 + v67))
                v68 = v69 + v67;
              v67 += 40;
            }
            while (v67 != 120);
            if (v68)
              sub_100104224((uint64_t)v355, v68);
          }
          v70 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
          if (v70)
          {
            v71 = *(_QWORD *)(v348 + 40);
            v72 = *(_OWORD *)(v348 + 3184);
            keys[0] = *(_OWORD *)(v348 + 3168);
            keys[1] = v72;
            -[WiFiUsageMonitor updateWithMLORuntimeConfig:forInterface:](v70, "updateWithMLORuntimeConfig:forInterface:", keys, v71);
          }
        }
        v73 = (const __CFNumber *)sub_1000316E0(*(_QWORD *)(v348 + 48));
        if (v73)
          CFNumberGetValue(v73, kCFNumberSInt16Type, (void *)(v348 + 2848));
        *(_WORD *)(v348 + 2850) = sub_100008CEC(*(_QWORD *)(v348 + 48));
        if ((_DWORD)v386)
          v74 = SHIDWORD(v386) < (int)v386 / 2 && *(_DWORD *)(v348 + 2796) < *(_DWORD *)(v348 + 648)
             || HIDWORD(v386) == 0;
        else
          v74 = 0;
        LOBYTE(values) = 0;
        LOBYTE(number[0]) = 0;
        *(_QWORD *)&keys[0] = 0;
        v75 = CFArrayGetCount(*(CFArrayRef *)(v348 + 264));
        v343 = v48;
        if (v75 > 0)
        {
          v334 = v74;
          v338 = v51;
          v76 = 0;
          v77 = 0;
          v78 = 0;
          v79 = 0;
          if (v75 >= 3)
            v80 = 3;
          else
            v80 = v75;
          v81 = v80 + 1;
          v336 = v80;
          v82 = v80 - 1;
          while (1)
          {
            v83 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v56 + 264), v82);
            if (!v83)
              break;
            if (CFDictionaryGetValueIfPresent(v83, CFSTR("PER_CORE_RSSI"), (const void **)keys))
              v84 = *(_QWORD *)&keys[0] == 0;
            else
              v84 = 1;
            if (!v84 && CFArrayGetCount(*(CFArrayRef *)&keys[0]) == 2)
            {
              v85 = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)&keys[0], 0);
              v86 = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)&keys[0], 1);
              if (v85)
              {
                CFNumberGetValue(v85, kCFNumberSInt8Type, &values);
                if ((char)values >= 0xFFFFFF81)
                {
                  ++v79;
                  v77 += (char)values;
                }
              }
              v56 = v348;
              if (v86)
              {
                CFNumberGetValue(v86, kCFNumberSInt8Type, number);
                if (SLOBYTE(number[0]) >= 0xFFFFFF81)
                {
                  ++v78;
                  v76 += SLOBYTE(number[0]);
                }
              }
            }
            --v81;
            --v82;
            if (v81 <= 1)
            {
              if (v336 < v79)
                sub_100186908();
              if (v336 < v78)
                sub_100186930();
              if (v79)
                v77 /= (__int16)v79;
              if ((_BYTE)v78)
                v76 /= (__int16)v78;
              v87 = v77;
              if (!v79)
                v87 = -1;
              *(_DWORD *)(v56 + 2800) = v87;
              v88 = v76;
              if (!v79)
                v88 = -1;
              *(_DWORD *)(v56 + 2804) = v88;
              if ((v334 & _os_feature_enabled_impl("WiFiManager", "FastTDRssiDecay")) == 1)
              {
                v89 = objc_autoreleasePoolPush();
                v51 = v338;
                v90 = (char)v77;
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Last RSSI:%d Core0 AvgRssi = %d Core1 AvgRssi = %d", *(unsigned int *)(v56 + 2796), (char)v77, (char)v76);
                objc_autoreleasePoolPop(v89);
                if ((_BYTE)v77)
                {
                  a3 = v347;
                  v48 = v343;
                  if (*(_DWORD *)(v56 + 2796) <= v90)
                  {
                    v91 = 0;
                  }
                  else
                  {
                    *(_DWORD *)(v56 + 2796) = v90;
                    v91 = 1;
                  }
                }
                else
                {
                  a3 = v347;
                  if ((_BYTE)v76)
                  {
                    if (*(_DWORD *)(v56 + 2796) <= (char)v76)
                    {
                      v91 = 0;
                    }
                    else
                    {
                      *(_DWORD *)(v56 + 2796) = (char)v76;
                      v91 = 2;
                    }
                  }
                  else
                  {
                    v91 = 0;
                  }
                  v48 = v343;
                }
                goto LABEL_203;
              }
LABEL_202:
              v91 = 0;
              a3 = v347;
              v48 = v343;
              v51 = v338;
              goto LABEL_203;
            }
          }
          v92 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: paramDict is NULL!", "__WiFiLQAMgrAvgValidPerCoreRssiSamples");
          objc_autoreleasePoolPop(v92);
          goto LABEL_202;
        }
        v252 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: perCoreRssiHistory is Empty!", "__WiFiLQAMgrAvgValidPerCoreRssiSamples");
        objc_autoreleasePoolPop(v252);
        v91 = 0;
        a3 = v347;
LABEL_203:
        if (v51)
          v93 = v345;
        else
          v93 = 0;
        if ((v93 & 1) != 0 || CFAbsoluteTimeGetCurrent() - *(double *)(v348 + 88) > *(double *)(v348 + 96))
        {
          v339 = v91;
          *(CFAbsoluteTime *)(v348 + 88) = CFAbsoluteTimeGetCurrent();
          v94 = 0.0;
          v95 = 0.0;
          if (*(double *)(v348 + 2784) != 0.0)
            v95 = CFAbsoluteTimeGetCurrent() - *(double *)(v348 + 2784);
          if (*(double *)(v348 + 64) != 0.0)
            v94 = CFAbsoluteTimeGetCurrent() - *(double *)(v348 + 64);
          if (HIDWORD(v388) && v389)
          {
            kdebug_trace(731381844, 0, 0, 0, 0);
            v96 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Tx failure is observed");
            objc_autoreleasePoolPop(v96);
          }
          v97 = v364;
          v98 = v369;
          v99 = objc_autoreleasePoolPush();
          v100 = (void *)qword_10026DD20;
          if (v97)
          {
            if (v98)
            {
              if (qword_10026DD20)
              {
                v101 = sub_10002B088(*(const void **)(v348 + 48));
                v102 = sub_100024674(*(_DWORD *)(v348 + 2776));
                v103 = 0.0;
                if ((_DWORD)v386 && (int)v386 > SHIDWORD(v386))
                  v103 = (double)((int)v386 - HIDWORD(v386)) / (double)(int)v386 * 100.0;
                if (HIDWORD(v388))
                {
                  v104 = (double)v389 / (double)SHIDWORD(v388) * 100.0;
                  v105 = v388;
                  v106 = (double)(int)v388 / (double)SHIDWORD(v388) * 100.0;
                }
                else
                {
                  v104 = 0.0;
                  v105 = v388;
                  v106 = 0.0;
                }
                if (HIDWORD(v387))
                  v116 = (double)(int)v387 / (double)SHIDWORD(v387) * 100.0;
                else
                  v116 = 0.0;
                if (v93)
                  v117 = "T";
                else
                  v117 = "F";
                objc_msgSend(v100, "WFLog:message:", 3, "%s(%@:%@): InfraUptime:%.1fsecs Channel: %d Bandwidth: %dMhz Rssi: %d {%ld %ld} Cca: %d (S:%d O:%d I:%d) Snr: %hd BcnPer: %.1f%% (%d, %.1f%%) TxFrameCnt: %d TxPer: %.1f%% TxReTrans: %d TxRetryRatio: %0.1f%% RxFrameCnt: %d RxRetryFrames: %d RxRetryRatio: %0.1f%% TxRate: %d RxRate: %d FBRate: %d TxFwFrms: %d TxFwFail: %d Noise: %d {%ld %ld %ld} time: %.1fsecs fgApp: %@ V: %s", "__WiFiLQAMgrLogStats", v101, v102, *(_QWORD *)&v94, *(unsigned __int16 *)(v348 + 2848), *(unsigned __int16 *)(v348 + 2850), v393, v361, v360, SHIBYTE(v391), (char)v391, SHIBYTE(v390),
                  (char)v390,
                  SHIWORD(v392),
                  *(_QWORD *)&v103,
                  v386,
                  (float)(*(float *)(v348 + 1084) * 100.0),
                  HIDWORD(v388),
                  *(_QWORD *)&v104,
                  v105,
                  *(_QWORD *)&v106,
                  HIDWORD(v387),
                  v387,
                  *(_QWORD *)&v116,
                  HIDWORD(v385),
                  v385,
                  HIDWORD(v384),
                  v384,
                  v383,
                  (__int16)v392,
                  v359,
                  v358,
                  v358 - v359,
                  *(_QWORD *)&v95,
                  *(_QWORD *)(v348 + 208),
                  v117);
                a3 = v347;
                v48 = v343;
              }
            }
            else if (qword_10026DD20)
            {
              v110 = sub_10002B088(*(const void **)(v348 + 48));
              v111 = sub_100024674(*(_DWORD *)(v348 + 2776));
              if ((_DWORD)v386)
              {
                v112 = 0.0;
                if ((int)v386 > SHIDWORD(v386))
                  v112 = (double)((int)v386 - HIDWORD(v386)) / (double)(int)v386 * 100.0;
              }
              else
              {
                v112 = 0.0;
              }
              if (HIDWORD(v388))
              {
                v121 = (double)v389 / (double)SHIDWORD(v388) * 100.0;
                v122 = v388;
                v123 = (double)(int)v388 / (double)SHIDWORD(v388) * 100.0;
              }
              else
              {
                v121 = 0.0;
                v122 = v388;
                v123 = 0.0;
              }
              v126 = 0.0;
              if (HIDWORD(v387))
                v126 = (double)(int)v387 / (double)SHIDWORD(v387) * 100.0;
              v127 = "F";
              if (v93)
                v127 = "T";
              objc_msgSend(v100, "WFLog:message:", 3, "%s(%@:%@): InfraUptime:%.1fsecs Channel: %d Bandwidth: %dMhz Rssi: %d Cca: %d (S:%d O:%d I:%d) Snr: %hd BcnPer: %.1f%% (%d, %.1f%%) TxFrameCnt: %d TxPer: %.1f%% TxReTrans: %d TxRetryRatio: %0.1f%% RxFrameCnt: %d RxRetryFrames: %d RxRetryRatio: %0.1f%% TxRate: %d RxRate: %d FBRate: %d TxFwFrms: %d TxFwFail: %d  time: %.1fsecs fgApp: %@ V: %s", *(_QWORD *)(v348 + 208), "__WiFiLQAMgrLogStats", v110, v111, *(_QWORD *)&v94, *(unsigned __int16 *)(v348 + 2848), *(unsigned __int16 *)(v348 + 2850), v393, SHIBYTE(v391), (char)v391, SHIBYTE(v390), (char)v390,
                SHIWORD(v392),
                *(_QWORD *)&v112,
                v386,
                (float)(*(float *)(v348 + 1084) * 100.0),
                HIDWORD(v388),
                *(_QWORD *)&v121,
                v122,
                *(_QWORD *)&v123,
                HIDWORD(v387),
                v387,
                *(_QWORD *)&v126,
                HIDWORD(v385),
                v385,
                HIDWORD(v384),
                v384,
                v383,
                *(_QWORD *)&v95,
                *(_QWORD *)(v348 + 208),
                v127);
            }
          }
          else if (v98)
          {
            if (qword_10026DD20)
            {
              v107 = sub_10002B088(*(const void **)(v348 + 48));
              v108 = sub_100024674(*(_DWORD *)(v348 + 2776));
              if ((_DWORD)v386)
              {
                v109 = 0.0;
                if ((int)v386 > SHIDWORD(v386))
                  v109 = (double)((int)v386 - HIDWORD(v386)) / (double)(int)v386 * 100.0;
              }
              else
              {
                v109 = 0.0;
              }
              if (HIDWORD(v388))
              {
                v118 = (double)v389 / (double)SHIDWORD(v388) * 100.0;
                v119 = v388;
                v120 = (double)(int)v388 / (double)SHIDWORD(v388) * 100.0;
              }
              else
              {
                v118 = 0.0;
                v119 = v388;
                v120 = 0.0;
              }
              v124 = 0.0;
              if (HIDWORD(v387))
                v124 = (double)(int)v387 / (double)SHIDWORD(v387) * 100.0;
              v125 = "F";
              if (v93)
                v125 = "T";
              objc_msgSend(v100, "WFLog:message:", 3, "%s(%@:%@): InfraUptime:%.1fsecs Channel: %d Bandwidth: %dMhz Rssi: %d {%ld %ld} Cca: %d Snr: %hd BcnPer: %.1f%% (%d, %.1f%%) TxFrameCnt: %d TxPer: %.1f%% TxReTrans: %d TxRetryRatio: %0.1f%% RxFrameCnt: %d RxRetryFrames: %d RxRetryRatio: %0.1f%% TxRate: %d RxRate: %d FBRate: %d TxFwFrms: %d TxFwFail: %d Noise: %d {%ld %ld %ld} time: %.1fsecs fgApp: %@ V: %s", "__WiFiLQAMgrLogStats", v107, v108, *(_QWORD *)&v94, *(unsigned __int16 *)(v348 + 2848), *(unsigned __int16 *)(v348 + 2850), v393, v361, v360, SHIBYTE(v391), SHIWORD(v392), *(_QWORD *)&v109,
                v386,
                (float)(*(float *)(v348 + 1084) * 100.0),
                HIDWORD(v388),
                *(_QWORD *)&v118,
                v119,
                *(_QWORD *)&v120,
                HIDWORD(v387),
                v387,
                *(_QWORD *)&v124,
                HIDWORD(v385),
                v385,
                HIDWORD(v384),
                v384,
                v383,
                (__int16)v392,
                v359,
                v358,
                v358 - v359,
                *(_QWORD *)&v95,
                *(_QWORD *)(v348 + 208),
                v125);
              a3 = v347;
              v48 = v343;
            }
          }
          else if (qword_10026DD20)
          {
            v113 = sub_10002B088(*(const void **)(v348 + 48));
            v114 = sub_100024674(*(_DWORD *)(v348 + 2776));
            if ((_DWORD)v386)
            {
              v115 = 0.0;
              if ((int)v386 > SHIDWORD(v386))
                v115 = (double)((int)v386 - HIDWORD(v386)) / (double)(int)v386 * 100.0;
            }
            else
            {
              v115 = 0.0;
            }
            if (HIDWORD(v388))
            {
              v128 = (double)v389 / (double)SHIDWORD(v388) * 100.0;
              v129 = v388;
              v130 = (double)(int)v388 / (double)SHIDWORD(v388) * 100.0;
            }
            else
            {
              v128 = 0.0;
              v129 = v388;
              v130 = 0.0;
            }
            v131 = 0.0;
            if (HIDWORD(v387))
              v131 = (double)(int)v387 / (double)SHIDWORD(v387) * 100.0;
            v132 = "F";
            if (v93)
              v132 = "T";
            objc_msgSend(v100, "WFLog:message:", 3, "%s(%@:%@): InfraUptime:%.1fsecs Channel: %d Bandwidth: %dMhz Rssi: %d Cca: %d Snr: %hd  BcnPer: %.1f%% (%d, %.1f%%) TxFrameCnt: %d TxPer: %.1f%% TxReTrans: %d TxRetryRatio: %0.1f%% RxFrameCnt : %d RxRetryFrames: %d RxRetryRatio: %0.1f%% TxRate: %d RxRate: %d FBRate: %d TxFwFrms: %d TxFwFail: %d time: %.1fsecs fgApp: %@ V: %s", v385, "__WiFiLQAMgrLogStats", v113, v114, *(_QWORD *)&v94, *(unsigned __int16 *)(v348 + 2848), *(unsigned __int16 *)(v348 + 2850), v393, SHIBYTE(v391), SHIWORD(v392), *(_QWORD *)&v115, v386, (float)(*(float *)(v348 + 1084) * 100.0),
              HIDWORD(v388),
              *(_QWORD *)&v128,
              v129,
              *(_QWORD *)&v130,
              HIDWORD(v387),
              v387,
              *(_QWORD *)&v131,
              HIDWORD(v385),
              v385,
              HIDWORD(v384),
              v384,
              v383,
              *(_QWORD *)&v95,
              *(_QWORD *)(v348 + 208),
              v132,
              v321,
              v322,
              v323);
          }
          objc_autoreleasePoolPop(v99);
          v133 = objc_autoreleasePoolPush();
          if (+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"))
          {
            v134 = 0;
            v337 = v133;
            if ((_DWORD)v386)
            {
              v135 = v348;
              if ((int)v386 >= SHIDWORD(v386))
                v134 = (uint64_t)((double)((int)v386 - HIDWORD(v386)) / (double)(int)v386 * 100.0);
            }
            else
            {
              v135 = v348;
            }
            v332 = v134;
            v136 = (void *)sub_1000090DC(*(_QWORD *)(v135 + 32), *(const void **)(v135 + 40));
            v330 = objc_msgSend(v136, "objectForKey:", CFSTR("LQM_SUMMARY_RX_CRS"));
            v137 = objc_msgSend(v136, "objectForKey:", CFSTR("LQM_SUMMARY_RX_PLCP"));
            v331 = objc_msgSend(v136, "objectForKey:", CFSTR("LQM_SUMMARY_RX_GOOD_PLCPS"));
            v335 = v136;
            v138 = objc_msgSend(v136, "objectForKey:", CFSTR("LQM_SUMMARY_DBG_LOG_LIST"));
            values = 0u;
            v398 = 0u;
            v399 = 0u;
            v400 = 0u;
            v139 = objc_msgSend(v138, "countByEnumeratingWithState:objects:count:", &values, keys, 16);
            if (v139)
            {
              v140 = v139;
              v141 = *(_QWORD *)v398;
              do
              {
                for (i = 0; i != v140; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v398 != v141)
                    objc_enumerationMutation(v138);
                  v143 = *(_QWORD *)(*((_QWORD *)&values + 1) + 8 * (_QWORD)i);
                  v144 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "LQM-WiFi: %@\n", v143);
                  objc_autoreleasePoolPop(v144);
                }
                v140 = objc_msgSend(v138, "countByEnumeratingWithState:objects:count:", &values, keys, 16);
              }
              while (v140);
            }
            v145 = objc_msgSend(objc_alloc((Class)WiFiUsageLQMUserSample), "initWithInterfaceName:", *(_QWORD *)(v348 + 40));
            *(_QWORD *)(v348 + 3200) = v145;
            v329 = (int)v393;
            v146 = 0x7FFFFFFFFFFFFFFFLL;
            if (v369)
              v147 = v361;
            else
              v147 = 0x7FFFFFFFFFFFFFFFLL;
            v148 = v360;
            if (!v369)
              v148 = 0x7FFFFFFFFFFFFFFFLL;
            v325 = v148;
            v326 = v147;
            v149 = v359;
            if (!v368)
              v149 = 0x7FFFFFFFFFFFFFFFLL;
            v327 = v149;
            v328 = (__int16)v392;
            v150 = v358;
            if (!v368)
              v150 = 0x7FFFFFFFFFFFFFFFLL;
            v324 = v150;
            v151 = SHIWORD(v392);
            v152 = (char)v391;
            v153 = SHIBYTE(v390);
            v154 = (char)v390;
            v155 = SHIBYTE(v391);
            if (v330)
              v146 = (uint64_t)objc_msgSend(v330, "unsignedIntegerValue");
            if (v137)
              v156 = (uint64_t)objc_msgSend(v137, "unsignedIntegerValue");
            else
              v156 = 0x7FFFFFFFFFFFFFFFLL;
            if (v331)
              v157 = (uint64_t)objc_msgSend(v331, "unsignedIntegerValue");
            else
              v157 = 0x7FFFFFFFFFFFFFFFLL;
            objc_msgSend(v145, "populateWithRssi:rssi0:rssi1:rssiMode:noise:noise0:noise1:snr:selfCca:otherCca:interference:totalReportedCca:beaconPer:rxCrsGlitch:rxBadPLCP:rxStart:rxBphyCrsGlitch:rxBphyBadPLCP:sampleDuration:", v329, v326, v325, v339, v328, v327, v324, v151, v152, v153, v154, v155, v332, v146, v156, v157,
              0x7FFFFFFFFFFFFFFFLL,
              0x7FFFFFFFFFFFFFFFLL,
              (unint64_t)*(double *)(v348 + 96));
            objc_msgSend(*(id *)(v348 + 3200), "populateWithTxFrames:RxFrames:TxFails:TxRetries:RxRetries:TxRate:RxRate:txRTS:txRTSFail:txMpdu:txAMPDU:", SHIDWORD(v388), SHIDWORD(v387), v389, (int)v388, (int)v387, SHIDWORD(v385), (int)v385, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL);
            v158 = sub_100020CF0();
            objc_msgSend(*(id *)(v348 + 3200), "populateWithMotionState:andAppState:", sub_100024674(*(_DWORD *)(v348 + 2776)), v158 & 0xFFFFFF);
            if (v362 && CFArrayGetCount((CFArrayRef)v362) >= 1)
            {
              v159 = 0;
              v160 = v348 + 3048;
              do
              {
                v161 = *(void **)(v348 + 3200);
                v162 = *(_OWORD *)(v160 + 16);
                *(_OWORD *)number = *(_OWORD *)v160;
                v353 = v162;
                v354 = *(_QWORD *)(v160 + 32);
                objc_msgSend(v161, "populateWithPerMLOLinkStats:", number);
                ++v159;
                v160 += 40;
              }
              while (CFArrayGetCount((CFArrayRef)v362) > v159);
            }

            a3 = v347;
            v48 = v343;
            v133 = v337;
          }
          objc_autoreleasePoolPop(v133);
        }
      }
      a1 = v348;
      if (!v345)
      {
LABEL_379:
        CFRelease(cf);
LABEL_380:
        CFRelease(v48);
        goto LABEL_381;
      }
      CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(v348 + 24), 0, v48);
      v163 = CFArrayGetCount(*(CFArrayRef *)(v348 + 24));
      v164 = CFAbsoluteTimeGetCurrent();
      v355[0] = 0;
      if (v163 >= 7)
      {
        v165 = v164;
        while (1)
        {
          v166 = (v163 - 1);
          v167 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v348 + 24), v166);
          if (!v167)
            break;
          v168 = (const __CFNumber *)CFDictionaryGetValue(v167, CFSTR("kWiFiLqaMgrLqmSampleLocalTimestamp"));
          if (!v168)
          {
            v246 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s LqmSampleLocalTimestamp numberRef is NULL at index:%d!", "__WiFiLQAMgrAddLQMEntry", v166);
            goto LABEL_531;
          }
          CFNumberGetValue(v168, kCFNumberDoubleType, v355);
          if (*(double *)v355 == 0.0)
          {
            v246 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s LqmSampleLocalTimestamp Value is NULL at index:%d!", "__WiFiLQAMgrAddLQMEntry", v166);
            goto LABEL_531;
          }
          if (v165 - *(double *)v355 > 30.0)
          {
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v348 + 24), v166);
            v163 = CFArrayGetCount(*(CFArrayRef *)(v348 + 24));
            if (v163 > 6)
              continue;
          }
          goto LABEL_321;
        }
        v246 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM Report at %d index is NULL", "__WiFiLQAMgrAddLQMEntry", v166);
LABEL_531:
        objc_autoreleasePoolPop(v246);
        goto LABEL_379;
      }
LABEL_321:
      LODWORD(number[0]) = 0;
      LODWORD(v395) = 0;
      LODWORD(v394) = 0;
      *(_QWORD *)&keys[0] = 0;
      *(_QWORD *)&values = 0;
      if (*(_QWORD *)(v348 + 24))
      {
        v169 = *(_DWORD *)(v348 + 2776);
        if (CFDictionaryGetValueIfPresent(a3, CFSTR("RXBEACONFRMS"), (const void **)keys) && *(_QWORD *)&keys[0])
          CFNumberGetValue(*(CFNumberRef *)&keys[0], kCFNumberIntType, number);
        if (CFDictionaryGetValueIfPresent(a3, CFSTR("RXBEACONSCHED"), (const void **)&values) && (_QWORD)values)
          CFNumberGetValue((CFNumberRef)values, kCFNumberIntType, &v395);
        v170 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v348 + 24), 0);
        if (v170)
        {
          v171 = 0.0;
          if ((_DWORD)v395 && (int)v395 > SLODWORD(number[0]))
            v171 = (double)((int)v395 - LODWORD(number[0])) / (double)(int)v395 * 100.0;
          v172 = v171;
          if (*(_BYTE *)(v348 + 2832))
          {
            v173 = sub_1000118A8(v348);
            LODWORD(v394) = v173;
          }
          else
          {
            v173 = *(_DWORD *)(v348 + 2796);
            LODWORD(v394) = v173;
            if (!v173)
            {
              v174 = (const __CFNumber *)CFDictionaryGetValue(v170, CFSTR("RSSI"));
              if (!v174)
                goto LABEL_378;
              CFNumberGetValue(v174, kCFNumberSInt32Type, &v394);
              v173 = (int)v394;
            }
          }
          if (v173 > -70 || v169 == 1)
          {
            if (v173 >= -64)
            {
              *(_BYTE *)(v348 + 2986) = 0;
              sub_1000246C0(v348);
            }
          }
          else
          {
            *(_BYTE *)(v348 + 2986) = 1;
            sub_100043EF8(v348);
          }
          if (v172 < 20.0)
          {
            if (dword_10026C920 == -1)
            {
              ++dword_10026D5B8;
            }
            else if (dword_10026C920 < 21)
            {
              v177 = dword_10026D5B8;
              if (dword_10026C920 <= 0x14)
                v177 = ++dword_10026D5B8;
              if (v177 >= 10)
              {
                v178 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI_WIN: Beacon PER is consistenyly below < 20Percent. Switch to default RSSI Window");
                objc_autoreleasePoolPop(v178);
                if (*(_BYTE *)(v348 + 2985) != 8)
                {
                  *(_BYTE *)(v348 + 2985) = 8;
                  sub_10004A824(v348);
                }
                dword_10026D5B8 = 0;
              }
            }
            else
            {
              dword_10026D5B8 = 1;
            }
            goto LABEL_378;
          }
          if (v172 > 20.0 && v172 < 60.0)
          {
            if (dword_10026C920 == -1)
            {
              v175 = dword_10026D5BC + 1;
            }
            else
            {
              if ((dword_10026C920 - 61) > 0xFFFFFFD6)
              {
                v179 = dword_10026D5BC;
                if ((dword_10026C920 - 21) <= 0x26)
                  v179 = ++dword_10026D5BC;
                if (v179 >= 5)
                {
                  if (*(_BYTE *)(v348 + 2985) != 4 && v169 != 1)
                  {
                    v180 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI_WIN: Beacon PER is consistenyly below > 20Percent. Switch to RSSI Win = %d", 4);
                    objc_autoreleasePoolPop(v180);
                    *(_BYTE *)(v348 + 2985) = 4;
                    sub_10004A824(v348);
                  }
                  dword_10026D5BC = 0;
                }
                goto LABEL_377;
              }
              v175 = 1;
            }
            dword_10026D5BC = v175;
LABEL_377:
            a1 = v348;
            goto LABEL_378;
          }
          if (v172 > 60.0)
          {
            if (dword_10026C920 == -1)
            {
              v176 = dword_10026D5C0 + 1;
            }
            else
            {
              if (dword_10026C920 > 59)
              {
                v243 = dword_10026D5C0;
                if (dword_10026C920 != 60)
                  v243 = ++dword_10026D5C0;
                if (v243 >= 5)
                {
                  v244 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI_WIN: Collected more than 5 samples of High Beacon PER > 60 Percent ");
                  objc_autoreleasePoolPop(v244);
                  if (*(_BYTE *)(v348 + 2985) != 2 && v169 != 1)
                  {
                    v245 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI_WIN: Beacon PER is consistenyly below > 60Percent. Switch to RSSI Win = %d", 2);
                    objc_autoreleasePoolPop(v245);
                    *(_BYTE *)(v348 + 2985) = 2;
                    sub_10004A824(v348);
                  }
                  dword_10026D5C0 = 0;
                }
                goto LABEL_377;
              }
              v176 = 1;
            }
            dword_10026D5C0 = v176;
            goto LABEL_377;
          }
LABEL_378:
          dword_10026C920 = (int)v172;
          goto LABEL_379;
        }
        v255 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrMonitorBeaconPER");
      }
      else
      {
        v255 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrMonitorBeaconPER");
      }
      objc_autoreleasePoolPop(v255);
      v172 = 0.0;
      goto LABEL_378;
    }
    v247 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: CFDictionaryCreateMutableCopy failed", "__WiFiLQAMgrAddLQMEntry");
  }
  else
  {
    v247 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrAddLQMEntry");
  }
  objc_autoreleasePoolPop(v247);
LABEL_381:
  v181 = *(const __CFArray **)(a1 + 24);
  if (!v181)
  {
    v249 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrAddRSSIHistory");
    goto LABEL_558;
  }
  if (!CFArrayGetCount(v181))
  {
    v249 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM table is empty", "__WiFiLQAMgrAddRSSIHistory");
    goto LABEL_558;
  }
  v182 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  if (!v182)
  {
    v249 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrAddRSSIHistory");
LABEL_558:
    objc_autoreleasePoolPop(v249);
    goto LABEL_391;
  }
  v183 = v182;
  v184 = CFDictionaryGetValue(v182, CFSTR("RSSI"));
  if (v184)
  {
    v185 = v184;
    v186 = CFDictionaryGetValue(v183, CFSTR("LQMTIMESTAMP"));
    if (v186)
    {
      v187 = v186;
      v188 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 2776));
      if (v188)
      {
        v189 = v188;
        keys[0] = *(_OWORD *)off_10022F110;
        *(_QWORD *)&keys[1] = CFSTR("motion-state");
        *(_QWORD *)&values = v187;
        *((_QWORD *)&values + 1) = v185;
        *(_QWORD *)&v398 = v188;
        v190 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)&values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 256), 0, v190);
        v191 = CFArrayGetCount(*(CFArrayRef *)(a1 + 256));
        if (v191 >= 21)
        {
          do
          {
            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 256), (v191 - 1));
            v191 = CFArrayGetCount(*(CFArrayRef *)(a1 + 256));
          }
          while (v191 > 20);
        }
        CFRelease(v189);
        if (v190)
          CFRelease(v190);
      }
      else
      {
        v253 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: failed to allocate motionStateRef!", "__WiFiLQAMgrAddRSSIHistory");
        objc_autoreleasePoolPop(v253);
        a1 = v348;
      }
    }
  }
LABEL_391:
  if (+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance")
    && -[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
  {
    -[WiFiAIRAgent ingestLQMUpdate:](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "ingestLQMUpdate:", a3);
  }
  *(_BYTE *)(a1 + 508) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_QWORD *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(_QWORD *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 536) = 0;
  *(_DWORD *)(a1 + 2808) = 0;
  *(_BYTE *)(a1 + 2824) = 0;
  if (*(_QWORD *)(a1 + 24))
  {
    if (*(_QWORD *)(a1 + 48))
    {
      v192 = sub_1000118A8(a1);
      v193 = sub_10003153C(0);
      v194 = 0;
      v195 = v192 > -66 && v193 == 2;
      v196 = v192 + 50;
      if (!v195)
        v196 = v192;
      while (v196 < dword_10026C7C8[v194 + 1] || v196 > dword_10026C7C8[v194])
      {
        v194 += 3;
        if (v194 == 18)
          goto LABEL_404;
      }
      v10 = *(float *)&dword_10026C7C8[v194 + 2];
    }
    else
    {
      v251 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Current Network is NULL", "__WiFiLQAMgrComputeLinkScore");
      objc_autoreleasePoolPop(v251);
LABEL_404:
      v10 = 0.0;
    }
  }
  else
  {
    v250 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrComputeLinkScore");
    objc_autoreleasePoolPop(v250);
    v10 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 640))
    goto LABEL_498;
  v197 = *(_DWORD *)(a1 + 20);
  if ((v197 - 2) < 3)
  {
    if (*(double *)(a1 + 2816) == 0.0 && *(_DWORD *)(a1 + 2796) > *(_DWORD *)(a1 + 652))
      *(CFAbsoluteTime *)(a1 + 2816) = CFAbsoluteTimeGetCurrent();
    v198 = *(const __CFArray **)(a1 + 24);
    if (v198)
    {
      if (CFArrayGetCount(v198))
      {
        v199 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
        if (v199)
        {
          if (*(_BYTE *)(a1 + 2832))
          {
            v200 = sub_1000118A8(a1);
            LODWORD(keys[0]) = v200;
          }
          else
          {
            v204 = v199;
            v200 = *(_DWORD *)(a1 + 2796);
            LODWORD(keys[0]) = v200;
            if (!v200)
            {
              v205 = (const __CFNumber *)CFDictionaryGetValue(v204, CFSTR("RSSI"));
              if (!v205)
                goto LABEL_437;
              CFNumberGetValue(v205, kCFNumberSInt32Type, keys);
              v200 = keys[0];
            }
          }
          if (v200 > *(_DWORD *)(a1 + 648)
            || v200 > *(_DWORD *)(a1 + 652)
            && *(double *)(a1 + 2816) != 0.0
            && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 2816) >= 5.0)
          {
            v206 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAManager: GoodLinkRssi %d +veCrossTime %.1f", "__WiFiLQAMgrIsLinkGood", LODWORD(keys[0]), CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 2816) + 5.0);
            objc_autoreleasePoolPop(v206);
            if (!sub_100008DA8(a1))
            {
              v207 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LinkIsGood, ending Evaluation", "WiFiLQAMgrLQMNotify");
              objc_autoreleasePoolPop(v207);
              -[WiFiUsageMonitor setTdLogic_end:evalTime:rssi:roamTime:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setTdLogic_end:evalTime:rssi:roamTime:forInterface:", 0, *(int *)(a1 + 2796), *(_QWORD *)(a1 + 40), CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136), *(double *)(a1 + 192));
              *(_BYTE *)(a1 + 2793) = 0;
              *(_QWORD *)(a1 + 136) = 0;
              *(_BYTE *)(a1 + 392) = 0;
              sub_1000246C0(a1);
              *(_DWORD *)(a1 + 20) = 1;
              v208 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v209 = *(int *)(a1 + 20);
                if (v209 > 4)
                  v210 = CFSTR("Bogus");
                else
                  v210 = *(&off_10022F1A0 + v209);
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v210);
              }
              objc_autoreleasePoolPop(v208);
              dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 336), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
              dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
              if (!*(_BYTE *)(a1 + 288) && &_symptom_create && (*(_DWORD *)(a1 + 16) - 1) <= 1)
              {
                v231 = symptom_create("com.apple.wifimanager.link-quality");
                symptom_set_qualifier(v231, 0, 0);
                v232 = sub_1000463C0(*(_QWORD *)(a1 + 48));
                symptom_set_qualifier(v231, v232, 1);
                symptom_send(v231);
                v233 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Notified Symptoms that Bssid: %llX +ve crossed good link", "WiFiLQAMgrLQMNotify", v232);
                objc_autoreleasePoolPop(v233);
              }
              *(_BYTE *)(a1 + 288) = 0;
              *(_DWORD *)(a1 + 488) = 0;
              *(_BYTE *)(a1 + 356) = 0;
              sub_100046514(a1, *(CFTypeRef *)(a1 + 376));
              v234 = *(const void **)(a1 + 376);
              if (v234)
              {
                CFRelease(v234);
                *(_QWORD *)(a1 + 376) = 0;
              }
              if (sub_1000465D0(a1) && *(_BYTE *)(a1 + 177))
              {
                *(_BYTE *)(a1 + 177) = 0;
                v235 = *(double *)(a1 + 184);
                if (v235 != 0.0)
                  *(double *)(a1 + 192) = v11 - v235;
                *(_QWORD *)(a1 + 184) = 0;
                sub_100066F20(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(const void **)(a1 + 48), *(_DWORD *)(a1 + 224), 0, 1, 0);
              }
              if (sub_1000305C0((_BYTE *)a1))
                goto LABEL_498;
              if (a4)
                v238 = (*(_BYTE *)(a1 + 2948) & 1) == 0;
              else
                v238 = 0;
              if (!sub_100030814(a1) && !v238 && sub_100046118(a1))
              {
                *(_BYTE *)(a1 + 2833) = 1;
                CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE"), kCFBooleanTrue);
                LODWORD(keys[0]) = 3;
                v239 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, keys);
                if (v239)
                {
                  v240 = v239;
                  CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE_REASON"), v239);
                  v241 = objc_autoreleasePoolPush();
                  v242 = (void *)qword_10026DD20;
                  v8 = v341;
                  v7 = v342;
                  if (qword_10026DD20)
LABEL_511:
                    objc_msgSend(v242, "WFLog:message:", 4, "%s wifi-assist override On for high channel congestion", "WiFiLQAMgrLQMNotify");
LABEL_512:
                  objc_autoreleasePoolPop(v241);
LABEL_513:
                  CFRelease(v240);
                  goto LABEL_499;
                }
                goto LABEL_766;
              }
              goto LABEL_752;
            }
          }
LABEL_437:
          sub_100043EF8(a1);
          if (!*(_BYTE *)(a1 + 288))
            goto LABEL_456;
          v211 = *(const __CFArray **)(a1 + 24);
          if (v211)
          {
            if (CFArrayGetCount(v211))
            {
              v212 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
              if (v212)
              {
                if (*(_BYTE *)(a1 + 2832))
                {
                  v213 = sub_1000118A8(a1);
                  LODWORD(keys[0]) = v213;
                }
                else
                {
                  v213 = *(_DWORD *)(a1 + 2796);
                  LODWORD(keys[0]) = v213;
                  if (!v213)
                  {
                    v215 = (const __CFNumber *)CFDictionaryGetValue(v212, CFSTR("RSSI"));
                    if (!v215)
                      goto LABEL_456;
                    CFNumberGetValue(v215, kCFNumberSInt32Type, keys);
                    v213 = keys[0];
                  }
                }
                if (v213 > *(_DWORD *)(a1 + 652) || !&_symptom_create || (*(_DWORD *)(a1 + 16) - 1) > 1)
                {
LABEL_456:
                  *(_DWORD *)(a1 + 2828) = 1;
                  if (sub_100043F7C(a1, 0, 0))
                    sub_1000423C8(a1, 0);
                  goto LABEL_498;
                }
                v216 = symptom_create("com.apple.wifimanager.link-quality");
                symptom_set_qualifier(v216, 1, 0);
                v217 = sub_1000463C0(*(_QWORD *)(a1 + 48));
                symptom_set_qualifier(v216, v217, 1);
                symptom_send(v216);
                *(_BYTE *)(a1 + 288) = 0;
                v218 = objc_autoreleasePoolPush();
                v219 = (void *)qword_10026DD20;
                if (!qword_10026DD20)
                {
LABEL_455:
                  objc_autoreleasePoolPop(v218);
                  goto LABEL_456;
                }
                v319 = v217;
                v220 = "%s: Notified Symptoms that Bssid: %llX -ve crossed poor link";
                v221 = 2;
LABEL_454:
                objc_msgSend(v219, "WFLog:message:", v221, v220, "__WiFiLQAMgrSendPendingSymptomsEventIfLinkBad", v319);
                goto LABEL_455;
              }
              v218 = objc_autoreleasePoolPush();
              v219 = (void *)qword_10026DD20;
              if (!qword_10026DD20)
                goto LABEL_455;
              v220 = "%s, LQAManager: Latest LQM Report is NULL";
            }
            else
            {
              v218 = objc_autoreleasePoolPush();
              v219 = (void *)qword_10026DD20;
              if (!qword_10026DD20)
                goto LABEL_455;
              v220 = "%s: LQM table is empty";
            }
          }
          else
          {
            v218 = objc_autoreleasePoolPush();
            v219 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_455;
            v220 = "%s, LQAManager: LQM table is NULL";
          }
          v221 = 4;
          goto LABEL_454;
        }
        v254 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrIsLinkGood");
      }
      else
      {
        v254 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM table is empty", "__WiFiLQAMgrIsLinkGood");
      }
    }
    else
    {
      v254 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrIsLinkGood");
    }
    objc_autoreleasePoolPop(v254);
    goto LABEL_437;
  }
  if (v197 != 1)
  {
    v214 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Bogus state %d", "WiFiLQAMgrLQMNotify", *(unsigned int *)(a1 + 20));
    objc_autoreleasePoolPop(v214);
    goto LABEL_498;
  }
  *(_QWORD *)(a1 + 2816) = 0;
  v201 = *(const __CFArray **)(a1 + 24);
  if (!v201)
  {
    v256 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrIsLinkBad");
    goto LABEL_589;
  }
  if (!CFArrayGetCount(v201))
  {
    v256 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM table is empty", "__WiFiLQAMgrIsLinkBad");
    goto LABEL_589;
  }
  v202 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  if (!v202)
  {
    v256 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrIsLinkBad");
LABEL_589:
    objc_autoreleasePoolPop(v256);
    goto LABEL_590;
  }
  if (*(_BYTE *)(a1 + 2832))
  {
    v203 = sub_1000118A8(a1);
    LODWORD(keys[0]) = v203;
  }
  else
  {
    v203 = *(_DWORD *)(a1 + 2796);
    LODWORD(keys[0]) = v203;
    if (!v203)
    {
      v222 = (const __CFNumber *)CFDictionaryGetValue(v202, CFSTR("RSSI"));
      if (!v222)
        goto LABEL_590;
      CFNumberGetValue(v222, kCFNumberSInt32Type, keys);
      v203 = keys[0];
    }
  }
  if (v203 <= *(_DWORD *)(a1 + 652))
  {
    v223 = objc_autoreleasePoolPush();
    v8 = v341;
    v7 = v342;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAManager BadLinkRssi %d", "__WiFiLQAMgrIsLinkBad", LODWORD(keys[0]));
    objc_autoreleasePoolPop(v223);
    sub_100008DA8(a1);
    if (&_symptom_create && (*(_DWORD *)(a1 + 16) - 1) <= 1)
    {
      v224 = symptom_create("com.apple.wifimanager.link-quality");
      symptom_set_qualifier(v224, 1, 0);
      v225 = sub_1000463C0(*(_QWORD *)(a1 + 48));
      symptom_set_qualifier(v224, v225, 1);
      symptom_send(v224);
      v226 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Notified Symptoms that Bssid: %llX -ve crossed poor link", "__WiFiLQAMgrIsLinkBad", v225);
      objc_autoreleasePoolPop(v226);
    }
    goto LABEL_471;
  }
  if (sub_100008DA8(a1))
  {
    *(_BYTE *)(a1 + 288) = 1;
    v8 = v341;
    v7 = v342;
LABEL_471:
    v227 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LinkIsBad, starting Evaluation", "WiFiLQAMgrLQMNotify");
    objc_autoreleasePoolPop(v227);
    if (*(double *)(a1 + 136) == 0.0)
      *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
    sub_100043EF8(a1);
    *(_DWORD *)(a1 + 20) = 2;
    v228 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v229 = *(int *)(a1 + 20);
      if (v229 > 4)
        v230 = CFSTR("Bogus");
      else
        v230 = *(&off_10022F1A0 + v229);
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v230);
    }
    objc_autoreleasePoolPop(v228);
    *(_DWORD *)(a1 + 488) = 0;
    *(_DWORD *)(a1 + 2828) = 1;
    if (sub_100043F7C(a1, 0, 0))
      sub_1000423C8(a1, 0);
    goto LABEL_499;
  }
LABEL_590:
  v381 = 0;
  v382 = 0;
  LODWORD(v377) = 0;
  LODWORD(v376) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  sub_1000246C0(a1);
  if (CFDictionaryGetValueIfPresent(a3, CFSTR("RXBEACONFRMS"), (const void **)&v382) && v382)
    CFNumberGetValue((CFNumberRef)v382, kCFNumberIntType, &v377);
  v257 = CFDictionaryGetValueIfPresent(a3, CFSTR("RXBEACONSCHED"), (const void **)&v381);
  v258 = v381;
  if (v257 && v381)
  {
    CFNumberGetValue((CFNumberRef)v381, kCFNumberIntType, &v376);
    v258 = v381;
  }
  if (v382)
  {
    if (v258)
    {
      v259 = *(_QWORD *)(a1 + 240) + (int)v377;
      v260 = *(_QWORD *)(a1 + 232) + (int)v376;
      *(_QWORD *)(a1 + 232) = v260;
      *(_QWORD *)(a1 + 240) = v259;
      if (v260)
      {
        v261 = (float)((float)((float)v259 / (float)v260) * -0.5) + 1.0;
        *(float *)(a1 + 1084) = v261;
        *(float *)(a1 + 1248) = v261;
      }
    }
  }
  v262 = *(unsigned __int8 *)(a1 + 248);
  if (*(_BYTE *)(a1 + 248) && CFArrayGetCount(*(CFArrayRef *)(a1 + 24)))
  {
    v263 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
    v264 = sub_100045800(a1, v263);
    v265 = sub_100045BC4(a1, v263, *(unsigned __int8 *)(a1 + 248));
    if (v265)
    {
      v266 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s PossibleRoam:%d UserWalkOutScenario:%d  EdgeBss:%d", "WiFiLQAMgrLQMNotify", v264, 1, v262);
      objc_autoreleasePoolPop(v266);
      a1 = v348;
    }
    if (v265)
      v267 = v264 == 0;
    else
      v267 = 0;
    v268 = v267;
  }
  else
  {
    v268 = 0;
  }
  if (sub_1000305C0((_BYTE *)a1))
  {
    v269 = 0;
LABEL_615:
    v270 = v268;
    goto LABEL_622;
  }
  if (a4)
    v271 = *(_DWORD *)(a1 + 2948) & 1;
  else
    v271 = 1;
  v272 = sub_100030814(a1);
  v269 = 0;
  if (v272)
    goto LABEL_615;
  v270 = v268;
  if (v271)
  {
    v269 = sub_100046118(a1);
    v270 = v269 + v268;
  }
LABEL_622:
  v346 = v269;
  if (sub_100032154(*(_QWORD *)(a1 + 32)) && sub_100066B88(*(_QWORD *)(a1 + 32)))
  {
    v344 = v270;
    v395 = 0;
    *(_QWORD *)&keys[0] = 0;
    *(_QWORD *)&values = 0;
    v355[0] = 0;
    number[0] = 0;
    LODWORD(v380) = 0;
    LODWORD(v379) = 0;
    LODWORD(v378) = 0;
    LOBYTE(v375) = 0;
    v394 = 0;
    v273 = *(const __CFArray **)(a1 + 24);
    if (v273)
    {
      v274 = CFArrayGetCount(v273);
      if (v274 >= 3)
      {
        v275 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v274 - 1);
        if (v275)
        {
          if (CFDictionaryGetValueIfPresent(v275, CFSTR("LQMTIMESTAMP"), (const void **)&v394))
          {
            if (v394)
            {
              AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v394);
              v277 = CFAbsoluteTimeGetCurrent();
              if (v277 - AbsoluteTime >= *(double *)(a1 + 672))
              {
                v278 = 0;
                while (1)
                {
                  v279 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v348 + 24), v278);
                  if (v279)
                  {
                    v280 = v279;
                    if (CFDictionaryGetValueIfPresent(v279, CFSTR("LQMTIMESTAMP"), (const void **)&v394))
                      v281 = v394 == 0;
                    else
                      v281 = 1;
                    if (v281)
                    {
                      if (v394)
                        goto LABEL_638;
                    }
                    else
                    {
                      AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v394);
                      if (v394)
                      {
LABEL_638:
                        if (v277 - AbsoluteTime <= *(double *)(v348 + 672))
                        {
                          if (CFDictionaryGetValueIfPresent(v280, CFSTR("CCA"), (const void **)number) && number[0])
                            CFNumberGetValue(number[0], kCFNumberSInt8Type, &v375);
                          if (CFDictionaryGetValueIfPresent(v280, CFSTR("CCA_STATS"), (const void **)&v395))
                          {
                            if (v395)
                            {
                              if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v395, CFSTR("CCA_SELF_WAKE"), (const void **)keys)&& *(_QWORD *)&keys[0])
                              {
                                CFNumberGetValue(*(CFNumberRef *)&keys[0], kCFNumberIntType, &v380);
                              }
                              if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v395, CFSTR("CCA_OTHER_WAKE"), (const void **)v355)&& v355[0])
                              {
                                CFNumberGetValue(v355[0], kCFNumberIntType, &v379);
                              }
                              if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v395, CFSTR("CCA_INTERFERENCE_WAKE"), (const void **)&values)&& (_QWORD)values)
                              {
                                CFNumberGetValue((CFNumberRef)values, kCFNumberIntType, &v378);
                              }
                              if (((_DWORD)v378 + (_DWORD)v379) < 0x3D)
                              {
                                v283 = 0;
                                v282 = v348;
                              }
                              else
                              {
                                v282 = v348;
                                v283 = *(_BYTE *)(v348 + 2898) + 1;
                              }
                              *(_BYTE *)(v282 + 2898) = v283;
                              if (v380 < 0x1F)
                                *(_BYTE *)(v282 + 2899) = 0;
                              else
                                ++*(_BYTE *)(v282 + 2899);
                            }
                          }
                          else
                          {
                            v285 = v380;
                            if (!(_DWORD)v380)
                              v285 = v375;
                            LODWORD(v380) = v285;
                            if (v285 >= 0x1F)
                              *(_BYTE *)(v348 + 2897) = 1;
                          }
                        }
                        goto LABEL_659;
                      }
                    }
                    v284 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No Timestamp in LQM Record", "__WiFiLQAMgrCheckCCA");
                    objc_autoreleasePoolPop(v284);
                  }
LABEL_659:
                  if (++v278 == 3)
                  {
                    a1 = v348;
                    v286 = *(unsigned __int8 *)(v348 + 2898);
                    *(_BYTE *)(v348 + 2896) = v286 > 2;
                    v287 = *(unsigned __int8 *)(v348 + 2899);
                    *(_BYTE *)(v348 + 2897) = v287 > 2;
                    if (v286 < 3)
                    {
                      a3 = v347;
                      if (v287 < 3)
                        goto LABEL_678;
                    }
                    else
                    {
                      v288 = objc_autoreleasePoolPush();
                      a3 = v347;
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "CCA is consistently higher than %d since last %d LQM samples", 60, *(unsigned __int8 *)(v348 + 2898));
                      objc_autoreleasePoolPop(v288);
                      if (*(_BYTE *)(v348 + 2897) != 1)
                      {
LABEL_678:
                        v290 = (char)v380;
                        *(_BYTE *)(v348 + 2893) = (_BYTE)v380;
                        v291 = (char)v379;
                        v292 = (char)v378;
                        *(_BYTE *)(v348 + 2892) = (_BYTE)v379 + v290 + (_BYTE)v378;
                        *(_BYTE *)(v348 + 2894) = v291;
                        *(_BYTE *)(v348 + 2895) = v292;
                        break;
                      }
                    }
                    v289 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Self CCA is consistently higher than %d since last %d LQM samples", 30, *(unsigned __int8 *)(v348 + 2899));
                    objc_autoreleasePoolPop(v289);
                    goto LABEL_678;
                  }
                }
              }
            }
          }
        }
      }
    }
    memset(keys, 0, 44);
    if (sub_1000484B0(a1, keys))
    {
      v293 = 0;
      while (!*(_BYTE *)(a1 + v293 + 724)
           || SDWORD1(keys[0]) < *(_DWORD *)(a1 + v293 + 728)
           || (float)(*(float *)(a1 + v293 + 732) * (float)SDWORD1(keys[0])) > (float)SLODWORD(keys[0])
           || SDWORD2(keys[0]) <= *(_DWORD *)(a1 + v293 + 736) * DWORD1(keys[0]))
      {
        v293 += 16;
        if (v293 == 64)
        {
          *(_BYTE *)(a1 + 2902) = 0;
          v294 = 2;
          goto LABEL_687;
        }
      }
      *(_BYTE *)(a1 + 2902) = 1;
      v294 = 4;
LABEL_687:
      if (*(_BYTE *)(a1 + 2896))
        v295 = v294;
      else
        v295 = 1;
      *(_DWORD *)(a1 + 2856) = v295;
      *(_DWORD *)(a1 + 2872) = v295;
    }
    else
    {
      v296 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to extract metrics from Lqm, exiting!", "__WiFiLQAMrgCheckTxPer");
      objc_autoreleasePoolPop(v296);
      v295 = 8;
    }
    v297 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v298 = "Poor";
      if (v295 == 2)
        v298 = "Avg";
      if (v295 == 1)
        v298 = "Good";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Health of the Link is %s with TotalCCA=%d SelfCCA=%d CCAOther=%d CCAInterferece=%d HighTxPER=%d", v298, *(char *)(a1 + 2892), *(char *)(a1 + 2893), *(char *)(a1 + 2894), *(char *)(a1 + 2895), *(unsigned __int8 *)(a1 + 2902));
    }
    objc_autoreleasePoolPop(v297);
    if (v295 == 4 || v295 == 2)
    {
      v270 = v344;
      if (*(_BYTE *)(a1 + 2900))
      {
        if (!*(_BYTE *)(a1 + 2936))
        {
          sub_100078CD0(*(_QWORD *)(a1 + 32), 1);
          *(_BYTE *)(a1 + 2936) = 1;
        }
        v300 = *(unsigned __int8 *)(a1 + 2913);
        if (!*(_BYTE *)(a1 + 2913))
        {
          v301 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Critical Apps are running in congested environment, talk to nearby devices to reduce congestion");
          objc_autoreleasePoolPop(v301);
          dispatch_async_f(*(dispatch_queue_t *)(a1 + 2920), (void *)a1, (dispatch_function_t)sub_10004E7EC);
          v300 = *(unsigned __int8 *)(a1 + 2913);
          v270 = v344;
        }
        if (v300 == 1 && !*(_BYTE *)(a1 + 2912))
          sub_10004A594(a1);
      }
      else if (*(_BYTE *)(a1 + 2936) == 1)
      {
        sub_100078CD0(*(_QWORD *)(a1 + 32), 0);
        *(_BYTE *)(a1 + 2936) = 0;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 2936) = 0;
      v270 = v344;
    }
    if (!*(_BYTE *)(a1 + 2900))
    {
      if (*(_BYTE *)(a1 + 2897) != 1 || *(_BYTE *)(a1 + 2913))
        goto LABEL_731;
      v303 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Non Critical App is consuming significant bandwith, Make way for Critical applications in the ecosystem");
      objc_autoreleasePoolPop(v303);
      dispatch_async_f(*(dispatch_queue_t *)(a1 + 2920), (void *)a1, (dispatch_function_t)sub_10004E7EC);
      v270 = v344;
      if (!*(_BYTE *)(a1 + 2900))
        goto LABEL_731;
    }
    if (*(_BYTE *)(a1 + 2901))
    {
      v302 = *(unsigned __int8 *)(a1 + 2936);
      if (*(_BYTE *)(a1 + 2897) == 1)
      {
        if (!*(_BYTE *)(a1 + 2936))
        {
          sub_100078CD0(*(_QWORD *)(a1 + 32), 1);
          *(_BYTE *)(a1 + 2936) = 1;
        }
LABEL_731:
        if (*(double *)(a1 + 2928) != 0.0 && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 2928) > 60.0)
        {
          sub_100078CD0(*(_QWORD *)(a1 + 32), 0);
          *(_BYTE *)(a1 + 2936) = 0;
          sub_100078C64(*(_QWORD *)(a1 + 32), 1);
          *(_QWORD *)(a1 + 2928) = 0;
        }
        if (!*(_BYTE *)(a1 + 2900) && *(_BYTE *)(a1 + 2912) == 1)
        {
          objc_msgSend(*(id *)(a1 + 2976), "__sendEventToPeers");
          v304 = *(NSObject **)(a1 + 2904);
          if (v304)
            dispatch_source_set_timer(v304, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
          *(_BYTE *)(a1 + 2912) = 0;
          *(_BYTE *)(a1 + 2936) = 0;
          sub_100078CD0(*(_QWORD *)(a1 + 32), 0);
        }
        goto LABEL_739;
      }
    }
    else
    {
      v302 = *(unsigned __int8 *)(a1 + 2936);
    }
    if (v302 == 1)
    {
      sub_100078CD0(*(_QWORD *)(a1 + 32), 0);
      *(_BYTE *)(a1 + 2936) = 0;
    }
    goto LABEL_731;
  }
LABEL_739:
  if (!v270)
  {
LABEL_752:
    v8 = v341;
    v7 = v342;
    if (*(_BYTE *)(a1 + 2833))
    {
      *(_BYTE *)(a1 + 2833) = 0;
      v308 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifi-assist override to auto", "WiFiLQAMgrLQMNotify");
      objc_autoreleasePoolPop(v308);
    }
    CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE"), kCFBooleanFalse);
    goto LABEL_499;
  }
  *(_BYTE *)(a1 + 2833) = 1;
  CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE"), kCFBooleanTrue);
  if (v270 == 1)
  {
    if (v268)
      v305 = 2;
    else
      v305 = 3;
    LODWORD(keys[0]) = v305;
    v306 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, keys);
    if (v306)
    {
      v240 = v306;
      CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE_REASON"), v306);
      v8 = v341;
      v7 = v342;
      if (v268)
      {
        v307 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s wifi-assist override On for edge bss walkout", "WiFiLQAMgrLQMNotify");
        objc_autoreleasePoolPop(v307);
      }
      if (!v346)
        goto LABEL_513;
      v241 = objc_autoreleasePoolPush();
      v242 = (void *)qword_10026DD20;
      if (qword_10026DD20)
        goto LABEL_511;
      goto LABEL_512;
    }
    goto LABEL_766;
  }
  v309 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v309)
  {
    v317 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFArrayCreateMutable failed", "WiFiLQAMgrLQMNotify");
    goto LABEL_768;
  }
  v310 = v309;
  LODWORD(keys[0]) = 2;
  v311 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, keys);
  if (!v311)
    goto LABEL_766;
  v312 = v311;
  CFArrayAppendValue(v310, v311);
  v313 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s wifi-assist override On for edge bss walkout", "WiFiLQAMgrLQMNotify");
  objc_autoreleasePoolPop(v313);
  CFRelease(v312);
  LODWORD(keys[0]) = 3;
  v314 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, keys);
  if (!v314)
  {
LABEL_766:
    v317 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFNumberCreate failed", "WiFiLQAMgrLQMNotify");
LABEL_768:
    objc_autoreleasePoolPop(v317);
    a1 = v348;
LABEL_498:
    v8 = v341;
    v7 = v342;
    goto LABEL_499;
  }
  v315 = v314;
  CFArrayAppendValue(v310, v314);
  v316 = objc_autoreleasePoolPush();
  v8 = v341;
  v7 = v342;
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s wifi-assist override On for high channel congestion", "WiFiLQAMgrLQMNotify");
  objc_autoreleasePoolPop(v316);
  CFRelease(v315);
  CFDictionarySetValue(a3, CFSTR("WIFI_ASSIST_OVERRIDE_REASONS"), v310);
  a1 = v348;
LABEL_499:
  if (v8)
  {
    v236 = *(_QWORD *)(a1 + 3200);
    if (v236)
    {
      -[WiFiUsageMonitor updateLinkQuality:forInterface:supportsLinkRecommendations:](v8, "updateLinkQuality:forInterface:supportsLinkRecommendations:", v236, *(_QWORD *)(a1 + 40), a4, Current);

      *(_QWORD *)(a1 + 3200) = 0;
    }
  }
  objc_autoreleasePoolPop(v7);
  return v10;
}

const __CFString *sub_100024674(int a1)
{
  void *v2;
  const __CFString *v3;

  v2 = objc_autoreleasePoolPush();
  if ((a1 - 1) > 5)
    v3 = CFSTR("Unknown");
  else
    v3 = *(&off_100230E30 + a1 - 1);
  objc_autoreleasePoolPop(v2);
  return v3;
}

void sub_1000246C0(uint64_t a1)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (!*(_BYTE *)(a1 + 2986))
  {
    if (*(_DWORD *)(a1 + 2796))
    {
      v2 = -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive");
      v3 = -[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen");
      if ((v2 & 1) == 0 && ((v3 & 1) != 0 || *(int *)(a1 + 2796) >= -69))
      {
        *(_BYTE *)(a1 + 3208) = 0;
        if (!+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance")
          || !-[WiFiAIRAgent isInterfaceRankingInProgress](+[WiFiAIRAgent sharedInstance](WiFiAIRAgent, "sharedInstance"), "isInterfaceRankingInProgress"))
        {
          v4 = sub_1000247B8(a1, 0, 0);
          if ((_DWORD)v4)
          {
            v5 = v4;
            v6 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: %d Failed to disable rapid LQM", "__WiFiLQAMgrSetDefaultLQMInterval", v5);
            objc_autoreleasePoolPop(v6);
          }
        }
      }
    }
  }
}

uint64_t sub_1000247B8(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  const __CFSet *v6;
  const void *v7;
  uint64_t result;
  __CFSet *v9;
  const void *v10;
  void *v11;
  const __CFSet *v12;
  const void *v13;
  const __CFArray *v14;
  const __CFDictionary *ValueAtIndex;
  BOOL v16;
  _BOOL4 v17;
  void *v18;
  const __CFSet *v19;
  const void *v20;
  __CFSet *v21;
  const void *v22;
  void *v23;
  void *v24;
  const __CFSet *v25;
  const void *v26;
  __CFSet *v27;
  const void *v28;
  void *v29;
  id v30;
  void *v31;
  id v32;
  id v33;
  uint64_t v34;
  void *i;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  __int128 valuePtr;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  void *value[16];

  if (!a1)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrSetLQMInterval", v40);
    goto LABEL_43;
  }
  if (!*(_BYTE *)(a1 + 108))
    return 4294963393;
  if (*(_DWORD *)(a1 + 104) != (_DWORD)a2)
  {
    if ((_DWORD)a2 != 1)
    {
      if (!(_DWORD)a2)
      {
        v12 = *(const __CFSet **)(a1 + 112);
        if (a3)
        {
          v13 = (const void *)sub_1000161D4((uint64_t)a3);
          result = CFSetContainsValue(v12, v13);
          if (!(_DWORD)result)
            goto LABEL_47;
          if (CFSetGetCount(*(CFSetRef *)(a1 + 112)) != 1)
          {
LABEL_46:
            result = 0;
LABEL_47:
            if (!a3)
              return result;
LABEL_48:
            if ((_DWORD)result)
              return result;
            v25 = *(const __CFSet **)(a1 + 112);
            v26 = (const void *)sub_1000161D4((uint64_t)a3);
            result = CFSetContainsValue(v25, v26);
            goto LABEL_50;
          }
        }
        else if (CFSetGetCount(*(CFSetRef *)(a1 + 112)))
        {
          return 0;
        }
        if (!*(_BYTE *)(a1 + 3208))
        {
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disabling Rapid LQM", "WiFiLQAMgrSetLQMInterval");
          objc_autoreleasePoolPop(v37);
          result = sub_100041E4C(a1, 5.0);
          if (!a3)
            return result;
          goto LABEL_48;
        }
        goto LABEL_46;
      }
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: %d is invalid LQM interval", "WiFiLQAMgrSetLQMInterval", a2);
LABEL_43:
      objc_autoreleasePoolPop(v24);
      return 4294963396;
    }
    LODWORD(valuePtr) = 0;
    value[0] = 0;
    v14 = *(const __CFArray **)(a1 + 24);
    if (v14)
    {
      if (CFArrayGetCount(v14))
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
        if (!ValueAtIndex
          || !CFDictionaryGetValueIfPresent(ValueAtIndex, CFSTR("RSSI"), (const void **)value)
          || !value[0])
        {
          goto LABEL_72;
        }
        CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &valuePtr);
        v16 = (int)valuePtr >= -69 || a3 == 0;
        v17 = 1;
        if (v16 && a3)
          v17 = sub_100066658(a3) != 0;
        if (!a3 || !v17 || *(double *)(a1 + 128) == 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 128) > 10.0)
        {
          if (v17)
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Enabling Rapid LQM", "WiFiLQAMgrSetLQMInterval");
            objc_autoreleasePoolPop(v18);
            result = sub_100041E4C(a1, 1.0);
            if (a3 && !(_DWORD)result)
            {
              v19 = *(const __CFSet **)(a1 + 112);
              v20 = (const void *)sub_1000161D4((uint64_t)a3);
              if (!CFSetContainsValue(v19, v20))
              {
                v21 = *(__CFSet **)(a1 + 112);
                v22 = (const void *)sub_1000161D4((uint64_t)a3);
                CFSetAddValue(v21, v22);
                v23 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Added '%@'", "WiFiLQAMgrSetLQMInterval", sub_1000161D4((uint64_t)a3));
                objc_autoreleasePoolPop(v23);
              }
              return 0;
            }
            return result;
          }
LABEL_72:
          v39 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: Interval change not allowed", "WiFiLQAMgrSetLQMInterval");
          objc_autoreleasePoolPop(v39);
          return 4294963390;
        }
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "ERROR: %s: Too frequent LQM interval change not allowed", "__WiFiLQAMgrIsIntervalChangeAllowed");
      }
      else
      {
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "ERROR: %s: LQM table is empty", "__WiFiLQAMgrIsIntervalChangeAllowed");
      }
    }
    else
    {
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "ERROR: %s: LQM table is NULL", "__WiFiLQAMgrIsIntervalChangeAllowed");
    }
    objc_autoreleasePoolPop(v38);
    goto LABEL_72;
  }
  if (!a3)
    return 0;
  v6 = *(const __CFSet **)(a1 + 112);
  v7 = (const void *)sub_1000161D4((uint64_t)a3);
  result = CFSetContainsValue(v6, v7);
  if ((_DWORD)a2)
  {
    if (!(_DWORD)result)
    {
      v9 = *(__CFSet **)(a1 + 112);
      v10 = (const void *)sub_1000161D4((uint64_t)a3);
      CFSetAddValue(v9, v10);
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Added '%@'", "WiFiLQAMgrSetLQMInterval", sub_1000161D4((uint64_t)a3));
LABEL_53:
      objc_autoreleasePoolPop(v11);
      v29 = objc_autoreleasePoolPush();
      v30 = objc_alloc_init((Class)NSMutableString);
      valuePtr = 0u;
      v42 = 0u;
      v43 = 0u;
      v44 = 0u;
      v31 = *(void **)(a1 + 112);
      v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &valuePtr, value, 16);
      if (v32)
      {
        v33 = v32;
        v34 = *(_QWORD *)v42;
        do
        {
          for (i = 0; i != v33; i = (char *)i + 1)
          {
            if (*(_QWORD *)v42 != v34)
              objc_enumerationMutation(v31);
            objc_msgSend(v30, "appendString:", *(_QWORD *)(*((_QWORD *)&valuePtr + 1) + 8 * (_QWORD)i));
            objc_msgSend(v30, "appendString:", CFSTR(" "));
          }
          v33 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &valuePtr, value, 16);
        }
        while (v33);
      }
      objc_autoreleasePoolPop(v29);
      v36 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %ld Rapid LQM clients [%@] \n", "WiFiLQAMgrSetLQMInterval", CFSetGetCount(*(CFSetRef *)(a1 + 112)), v30);
      objc_autoreleasePoolPop(v36);
      if (v30)
        CFRelease(v30);
    }
    return 0;
  }
LABEL_50:
  if ((_DWORD)result)
  {
    v27 = *(__CFSet **)(a1 + 112);
    v28 = (const void *)sub_1000161D4((uint64_t)a3);
    CFSetRemoveValue(v27, v28);
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Removed '%@'", "WiFiLQAMgrSetLQMInterval", sub_1000161D4((uint64_t)a3));
    goto LABEL_53;
  }
  return result;
}

uint64_t sub_100024E48(const __CFArray *a1, void *a2, void *a3)
{
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v7;
  unsigned int v8;

  if (a1 && CFArrayGetCount(a1) == 2)
  {
    ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 0);
    v7 = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 1);
    if (ValueAtIndex)
      CFNumberGetValue(ValueAtIndex, kCFNumberNSIntegerType, a2);
    if (v7)
    {
      CFNumberGetValue(v7, kCFNumberNSIntegerType, a3);
      v8 = 1;
      goto LABEL_9;
    }
  }
  else
  {
    ValueAtIndex = 0;
  }
  v8 = 0;
LABEL_9:
  if (ValueAtIndex)
    return 1;
  else
    return v8;
}

void sub_100024EE4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  unsigned __int8 v13;
  uint64_t v14;
  char v15;
  unint64_t v16;
  unsigned int v17;
  void *v18;
  void *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  char v26;
  void *v27;
  void *v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  void *v32;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v34;
  CFNumberRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  unsigned int v39;
  unint64_t v40;
  void (**v41)(uint64_t, uint64_t, __CFDictionary *, _QWORD);
  void *v42;
  void *v43;
  void *v44;
  _DWORD *v45;
  void *v46;
  const char *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  unsigned __int8 v53;
  char v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  char valuePtr;

  v4 = *(_QWORD *)(a1 + 424);
  v5 = objc_autoreleasePoolPush();
  if (v4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s(): CATS Update %@: Enter deviceManager:%p  source:%d enable:%d appPolicy:%d bitmap:0x%llx\n", "WifiDeviceManagerCatsUpdateEvent", sub_10002570C(a1), a1, a2, *(unsigned __int8 *)(a1 + 433), *(unsigned __int8 *)(a1 + 435), *(_QWORD *)(a1 + 440));
    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a1 + 433))
    {
      v6 = *(_QWORD *)(a1 + 424);
      v7 = *(unsigned __int8 *)(a1 + 435);
      v8 = *(_QWORD *)(a1 + 440);
      v9 = *(unsigned __int8 *)(a1 + 434);
      v57 = v8;
      v58 = v9;
      if ((_DWORD)a2 == 8)
      {
        v10 = 0;
        v11 = 0;
        v12 = (_BYTE *)0xAAAAAAAAAAAAAAAALL;
        v13 = -86;
        v54 = -86;
      }
      else
      {
        if (*(_BYTE *)(a1 + 5496)
          || *(_BYTE *)(a1 + 3410)
          || *(_BYTE *)(a1 + 5498)
          || -[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))
        {
          v14 = sub_10013F644((_BYTE *)a1);
          v10 = v14;
          if (v9)
            v15 = 0;
          else
            v15 = -86;
          v16 = 0xAAAAAAAAAAAAAAAALL;
          if (v9)
            v16 = v14;
          v55 = v16;
          v17 = 1;
        }
        else
        {
          v10 = 0;
          v17 = 0;
          v55 = 0xAAAAAAAAAAAAAAAALL;
          v15 = -86;
        }
        v18 = objc_autoreleasePoolPush();
        v19 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v20 = *(_QWORD *)(a1 + 64);
          if (v20)
            v20 = sub_100029860(v20);
          objc_msgSend(v19, "WFLog:message:", 3, "%s: CATSUpdate %@: fgApp:%@ b=0x%llx rc=%d\n", "WiFiDeviceManagerCatsSetLowLatencyApp", v20, *(_QWORD *)(a1 + 448), v10, v17);
        }
        objc_autoreleasePoolPop(v18);
        if ((v17 & 1) != 0)
        {
          v11 = 2;
          v54 = -86;
          v8 = v57;
          v13 = v15;
        }
        else
        {
          v21 = -[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen");
          v22 = v21;
          v23 = *(unsigned __int8 *)(a1 + 456);
          if (*(_BYTE *)(a1 + 456))
            v24 = v21 ^ 1;
          else
            v24 = 0;
          if (v58)
            v25 = 1;
          else
            v25 = v15;
          v52 = v25;
          if (v58)
            v26 = v21;
          else
            v26 = -86;
          v54 = v26;
          v27 = objc_autoreleasePoolPush();
          v28 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v29 = *(_QWORD *)(a1 + 64);
            if (v29)
              v29 = sub_100029860(v29);
            objc_msgSend(v28, "WFLog:message:", 3, "%s: CATSUpdate %@: fgApp:%@ hs=%d t=%d wl=%d rc=%d\n", "WiFiDeviceManagerCatsSetForegroundApp", v29, *(_QWORD *)(a1 + 448), v22, 1, v23, v24);
          }
          objc_autoreleasePoolPop(v27);
          v10 = 0;
          if ((v24 & 1) != 0)
          {
            v11 = 1;
            v13 = v52;
          }
          else
          {
            v11 = 0;
            if (v58)
              v13 = 2;
            else
              v13 = v15;
            v54 = -86;
          }
          v8 = v57;
        }
        v12 = (_BYTE *)v55;
      }
      v30 = (_DWORD)v7 == (_DWORD)v11 && v8 == v10;
      v31 = !v30;
      v56 = v31;
      if (v30)
      {
LABEL_81:
        if (v58)
        {
          if (a2 >= 9u)
          {
            v44 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATS Stats invalid AppPolicy(%d) or Notify source (%d)\n", "WifiDeviceManagerCatsUpdateStats", v11, a2);
            goto LABEL_100;
          }
          ++*(_DWORD *)(a1 + 652);
          if ((v56 & 1) != 0)
          {
            ++*(_DWORD *)(a1 + 544);
            ++*(_DWORD *)(a1 + 544 + 4 * v11 + 4);
            ++*(_DWORD *)(a1 + 564);
            v45 = (_DWORD *)(a1 + 564 + 4 * a2 + 4);
          }
          else
          {
            v45 = (_DWORD *)(a1 + 656);
          }
          ++*v45;
          if ((_DWORD)v11 == 1)
          {
            if (v13 == 1)
            {
              ++*(_DWORD *)(a1 + 652);
              ++*(_DWORD *)(a1 + 608);
              if (v54)
                ++*(_DWORD *)(a1 + 616);
              ++*(_DWORD *)(a1 + 612);
              goto LABEL_101;
            }
            v44 = objc_autoreleasePoolPush();
            v46 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_100;
            v47 = "WifiDeviceManagerCatsFgAppActivityStats";
            v48 = v13;
            goto LABEL_99;
          }
          if ((_DWORD)v11 == 2)
          {
            if (!v13)
            {
              ++*(_DWORD *)(a1 + 620);
              if ((*v12 & 2) != 0)
              {
                ++*(_DWORD *)(a1 + 628);
              }
              else if ((*v12 & 4) != 0)
              {
                ++*(_DWORD *)(a1 + 632);
              }
              else if ((v12[1] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 640);
              }
              else if ((v12[4] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 644);
              }
              else if ((*v12 & 0x10) != 0 || (v12[2] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 636);
              }
              else
              {
                ++*(_DWORD *)(a1 + 624);
              }
              goto LABEL_101;
            }
            v44 = objc_autoreleasePoolPush();
            v46 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_100;
            v47 = "WifiDeviceManagerCatsLowLatencyEventStats";
            v48 = v13;
LABEL_99:
            objc_msgSend(v46, "WFLog:message:", 4, "%s: CATS Stats Invalid Report type (%d)  \n", v47, v48, v51);
LABEL_100:
            objc_autoreleasePoolPop(v44);
          }
        }
LABEL_101:
        v49 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATSUpdate %@: Exit deviceManager=%p Source:%d stateChange:%d (P:%d-->%d B:0x%llx-->0x%llx)\n", "WifiDeviceManagerCatsUpdateEvent", sub_10002570C(a1), a1, a2, v56, v7, v11, v57, v10);
        objc_autoreleasePoolPop(v49);
        return;
      }
      if (v6)
      {
        if (*(unsigned __int8 *)(a1 + 464) < 4u)
        {
          v53 = v13;
          valuePtr = v11;
          v59 = v10;
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            v34 = Mutable;
            v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
            if (v35)
            {
              v36 = v35;
              v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v59);
              if (v37)
              {
                v38 = v37;
                CFDictionarySetValue(v34, CFSTR("CATS_APP_PRIORITY"), v36);
                CFDictionarySetValue(v34, CFSTR("CATS_APP_BITMAP"), v38);
                CFRelease(v36);
                CFRelease(v38);
                v39 = *(unsigned __int8 *)(a1 + 464);
                if (*(_BYTE *)(a1 + 464))
                {
                  v40 = 0;
                  v41 = (void (**)(uint64_t, uint64_t, __CFDictionary *, _QWORD))(a1 + 488);
                  do
                  {
                    if (*v41)
                    {
                      (*v41)(v6, a1, v34, *(v41 - 2));
                      v39 = *(unsigned __int8 *)(a1 + 464);
                    }
                    ++v40;
                    v41 += 3;
                  }
                  while (v40 < v39);
                }
                CFRelease(v34);
                v13 = v53;
                goto LABEL_80;
              }
              CFRelease(v34);
              CFRelease(v36);
              v43 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate app bitmap CATS dictionary entry", "WifiDeviceManagerCatsCreateDictionary", a1);
            }
            else
            {
              CFRelease(v34);
              v43 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate app policy CATS dictionary entry", "WifiDeviceManagerCatsCreateDictionary", a1);
            }
            objc_autoreleasePoolPop(v43);
          }
          else
          {
            v42 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate CATS dictionary", "WifiDeviceManagerCatsCreateDictionary", a1);
            objc_autoreleasePoolPop(v42);
          }
          v13 = v53;
          v32 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:CATSUpdate deviceManager:%p CATS Update not allocate CATS dictionary", "WifiDeviceManagerCatsUpdateClients", a1, v51);
        }
        else
        {
          v32 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATS Update Clients: Num Clients(%d) > Max Clients(%d)", "WifiDeviceManagerCatsUpdateClients", *(unsigned __int8 *)(a1 + 464), 3);
        }
      }
      else
      {
        v32 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATS Update Clients: Invalid arguments", "WifiDeviceManagerCatsUpdateClients", v50, v51);
      }
      objc_autoreleasePoolPop(v32);
LABEL_80:
      *(_BYTE *)(a1 + 435) = v11;
      *(_QWORD *)(a1 + 440) = v10;
      goto LABEL_81;
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CATS %@: Update Invalid deviceManager args device=%p deviceManager:%p WifiManager:%p Enab:%d\n", "WifiDeviceManagerCatsUpdateEvent", sub_10002570C(a1), *(_QWORD *)(a1 + 64), a1, *(_QWORD *)(a1 + 424), *(unsigned __int8 *)(a1 + 433));
    objc_autoreleasePoolPop(v5);
  }
}

uint64_t sub_10002570C(uint64_t a1)
{
  uint64_t v1;
  void *v3;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 64);
    if (v1)
      return sub_100029860(v1);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate Invalid arguments", "WifiDeviceManagerCatsIfname");
    objc_autoreleasePoolPop(v3);
  }
  return 0;
}

uint64_t sub_100025788(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _BYTE *v4;
  __CFDictionary *Mutable;
  CFBooleanRef v6;
  CFBooleanRef v7;
  CFBooleanRef v8;
  CFBooleanRef v9;
  void *v10;
  uint64_t v11;
  const void *v12;
  void *v14;

  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager", "WiFiDeviceManagerSetAppNetworkUsageState");
    goto LABEL_24;
  }
  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null appWiFiUsageState", "WiFiDeviceManagerSetAppNetworkUsageState");
LABEL_24:
    objc_autoreleasePoolPop(v14);
    return 4294963396;
  }
  if (*(_QWORD *)(a1 + 184) == *a2)
    return 0;
  v4 = (_BYTE *)(a1 + 5496);
  *(_QWORD *)(a1 + 184) = *a2;
  v3 = sub_100025C50(*(_QWORD *)(a1 + 120), *a2);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*v4 || *(_BYTE *)(a1 + 3410) || *(_BYTE *)(a1 + 5498))
  {
    v6 = kCFBooleanTrue;
    v7 = kCFBooleanFalse;
  }
  else
  {
    v6 = kCFBooleanTrue;
    v7 = kCFBooleanFalse;
    v8 = kCFBooleanFalse;
    if (!-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive"))goto LABEL_10;
  }
  v8 = v6;
LABEL_10:
  if (-[WiFiUserInteractionMonitor isInHomeScreen](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInHomeScreen"))
  {
    v9 = v6;
  }
  else
  {
    v9 = v7;
  }
  CFDictionarySetValue(Mutable, CFSTR("IO80211IsInHomeScreen"), v9);
  CFDictionarySetValue(Mutable, CFSTR("IO80211IsLatencySensitiveAppActive"), v8);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "App state params %@", Mutable);
  objc_autoreleasePoolPop(v10);
  v11 = *(_QWORD *)(a1 + 64);
  v12 = (const void *)sub_100025C3C(v11);
  sub_1000672C0(v11, v12, 485, 0, (uint64_t)Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return v3;
}

void sub_1000259A4(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  void *v15;
  const void *v16;
  void *v17;
  const void *v18;

  v2 = *(_QWORD **)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v2[30])
  {
    v3 = a1[5];
    if ((unint64_t)(v3 - 1) <= 1)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: call state changed to %d", "WiFiDeviceManagerScheduleWithQueue_block_invoke_2", -[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress"));
      objc_autoreleasePoolPop(v4);
      v5 = -[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress");
      v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      if (v5)
      {
        *(_BYTE *)(v6 + 3409) = 1;
      }
      else
      {
        *(_BYTE *)(v6 + 3409) = 0;
        v7 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
        v8 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
        if (v7)
          sub_1000285E4(v8, 0x1AuLL);
        else
          sub_1000FA0A0(v8, 5);
      }
      v9 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      v10 = *(void **)(v9 + 7368);
      if (v10)
      {
        if (*(_BYTE *)(v9 + 3409))
          v11 = 1;
        else
          v11 = *(unsigned __int8 *)(v9 + 3408) != 0;
        objc_msgSend(v10, "setCallState:", v11);
        v9 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      }
      sub_1000FA884(v9, 0);
      v12 = a1[6];
      if (v12 && *(_BYTE *)(v12 + 433))
        sub_100024EE4(v12, 5);
      v3 = a1[5];
    }
    if (v3 == 16)
    {
      if (-[WiFiUserInteractionMonitor isGameModeActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isGameModeActive"))
      {
        v13 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
        v14 = (const void *)sub_100029860(*(_QWORD *)(v13 + 64));
        v15 = sub_10002A21C(v13, v14, 1);
        if (v15)
        {
          v16 = v15;
          if (sub_1000CA53C((uint64_t)v15))
          {
            v17 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: in game mode. Inducing roam to try to get to the best AP on %@", "WiFiDeviceManagerScheduleWithQueue_block_invoke_2", v16);
            objc_autoreleasePoolPop(v17);
            objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "roamWithReason:bandPreference:", 5, 0);
          }
          CFRelease(v16);
        }
      }
    }
    v18 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
    if (v18)
    {
      CFRelease(v18);
      *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
    }
  }
  else
  {
    CFRelease(v2);
  }
}

uint64_t sub_100025C3C(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 112);
  return result;
}

uint64_t sub_100025C50(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v4;
  void *v5;

  if (a1)
  {
    result = 0;
    *(_QWORD *)(a1 + 168) = a2;
    if ((a2 & 0x11) != 0 && *(_BYTE *)(a1 + 2793))
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Trigger Disconnecting using Cached decision");
      objc_autoreleasePoolPop(v4);
      *(_DWORD *)(a1 + 2828) = 10;
      sub_1000423C8(a1, 0);
      return 0;
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetAppNetworkUsageState");
    objc_autoreleasePoolPop(v5);
    return 4294963396;
  }
  return result;
}

uint64_t sub_100025E88(const __CFString *a1)
{
  int v1;
  int v2;
  unsigned __int8 v3;
  void *v5;
  void *v6;
  int *v7;
  void *v8;
  char buffer[8];
  uint64_t v10;
  __int128 v11;
  __int128 v12;

  *(_QWORD *)buffer = 0;
  v10 = 0;
  if (!a1)
    return 0;
  CFStringGetCString(a1, buffer, 16, 0);
  if (!buffer[0])
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, interfaceCName is zero length.", "WiFiIsInterfaceExpensive");
    goto LABEL_16;
  }
  v1 = socket(2, 2, 0);
  if (v1 == -1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: socket creation failed", "WiFiIsInterfaceExpensive");
LABEL_16:
    objc_autoreleasePoolPop(v8);
    return 0;
  }
  v2 = v1;
  v11 = 0u;
  v12 = 0u;
  __strlcpy_chk(&v11, buffer, 16, 16);
  if (ioctl(v2, 0xC02069A0uLL, &v11) == -1 && *__error() != 1)
  {
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v7 = __error();
      objc_msgSend(v6, "WFLog:message:", 4, "%s: ioctl(SIOCGIFEXPENSIVE) failed: %s", buffer, strerror(*v7));
    }
    objc_autoreleasePoolPop(v5);
    v3 = 0;
  }
  else
  {
    v3 = v12;
  }
  close(v2);
  return v3;
}

void sub_1000261C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  id v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  uint64_t v20;
  void *i;
  void *v22;
  void (**v23)(_QWORD, _QWORD, _QWORD);
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];

  if ((_DWORD)a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error %d from Managed Event Fetch", "-[WiFiUserInteractionMonitor _handleManagedEventNotification]_block_invoke", a2);
LABEL_4:
    objc_autoreleasePoolPop(v4);
    return;
  }
  if (!a3)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fetched managed event is %@", "-[WiFiUserInteractionMonitor _handleManagedEventNotification]_block_invoke", 0);
    goto LABEL_4;
  }
  v6 = *(id *)(a3 + 48);
  v7 = v6;
  if (v6)
  {
    v8 = objc_msgSend(v6, "copy");
    objc_msgSend(*(id *)(a1 + 32), "setAppAwareDetails:", v8);

    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", kManagedEventKeyBackgroundCombinedFlowProperties));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v9));
    objc_msgSend(*(id *)(a1 + 32), "setSymptomBackgroundFlowProperties:", objc_msgSend(v10, "unsignedLongLongValue"));

    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", kManagedEventKeyForegroundCombinedFlowProperties));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v11));
    objc_msgSend(*(id *)(a1 + 32), "setSymptomForegroundFlowProperties:", objc_msgSend(v12, "unsignedLongLongValue"));

    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", kManagedEventKeyBackgroundSpecificFlowClassifications));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v13));
    objc_msgSend(*(id *)(a1 + 32), "setSymptomBackgroundFlowClassification:", objc_msgSend(v14, "unsignedIntValue"));

    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", kManagedEventKeyForegroundSpecificFlowClassifications));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v15));
    objc_msgSend(*(id *)(a1 + 32), "setSymptomForegroundFlowClassification:", objc_msgSend(v16, "unsignedIntValue"));

    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "clients"));
    v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
    if (v18)
    {
      v19 = v18;
      v20 = *(_QWORD *)v25;
      do
      {
        for (i = 0; i != v19; i = (char *)i + 1)
        {
          if (*(_QWORD *)v25 != v20)
            objc_enumerationMutation(v17);
          v22 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i);
          v23 = (void (**)(_QWORD, _QWORD, _QWORD))objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "callback"));
          ((void (**)(_QWORD, id, uint64_t))v23)[2](v23, objc_msgSend(v22, "context"), 4);

        }
        v19 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
      }
      while (v19);
    }

  }
}

id sub_1000264FC(uint64_t a1)
{
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "initializeWithManager:queue:", *(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32));
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "startMonitoringCarSession");
}

void sub_100026530(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  NSObject *v5;
  void *v6;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  CFTypeRef v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = cf;
  if (cf && *((_QWORD *)cf + 30))
  {
    CFRetain(cf);
    v5 = *(NSObject **)(v9[3] + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000259A4;
    block[3] = &unk_100230A08;
    block[4] = &v8;
    block[5] = a3;
    block[6] = *(_QWORD *)(a1 + 32);
    dispatch_async(v5, block);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceManager or queue", "WiFiDeviceManagerScheduleWithQueue_block_invoke");
    objc_autoreleasePoolPop(v6);
  }
  _Block_object_dispose(&v8, 8);
}

void sub_100026620(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void *sub_100026664(CFDictionaryRef *a1)
{
  id v2;
  unsigned int v3;
  void *v4;
  uint64_t v5;
  void *v6;
  unint64_t v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  const __CFArray *v24;
  const __CFArray *v25;
  void *i;
  void *v27;
  objc_class *v28;
  id v29;
  id v30;
  id v31;
  void *v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  objc_class *v39;
  id v40;
  double v41;
  double v42;
  double v43;
  double v44;
  void *v45;
  void *v46;
  double v47;
  double v48;
  double v49;
  double v50;
  id v51;
  id v52;
  void *v53;
  id v54;
  id v55;
  id v56;
  void *v57;
  id v58;
  id v59;
  id v60;
  id v61;
  uint64_t v62;
  void *j;
  id v64;
  id v65;
  const void *v66;
  uint64_t v67;
  const void *v68;
  uint64_t v69;
  id v70;
  id v71;
  id v72;
  uint64_t v73;
  void *k;
  id v75;
  void *v77;
  void *v78;
  unsigned __int8 v79;
  unsigned __int8 v80;
  void *context;
  void *v82;
  const __CFArray *obj;
  uint64_t v84;
  uint64_t v85;
  id v86;
  id v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  void **v100;
  uint64_t v101;
  Class (*v102)(uint64_t);
  void *v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  void (*v108)(uint64_t, uint64_t);
  void (*v109)(uint64_t);
  uint64_t v110;
  _BYTE v111[128];
  _BYTE v112[128];
  _BYTE v113[128];

  context = objc_autoreleasePoolPush();
  if (!a1 || !sub_100027B80())
  {
    v82 = 0;
    goto LABEL_141;
  }
  v2 = objc_alloc_init((Class)sub_100027B80());
  objc_msgSend(v2, "setSSID:", sub_10003149C(a1), context);
  sub_10002DA5C((_BOOL8)a1);
  objc_msgSend(v2, "setSupportedSecurityTypes:", 0);
  v82 = v2;
  if (!sub_10002DAF0((_BOOL8)a1))
  {
    if (sub_10001F4AC((uint64_t)a1))
    {
      v6 = v2;
      v7 = 768;
    }
    else
    {
      if (!sub_10002CD50(a1[2]))
      {
        if (CFDictionaryGetValue(a1[2], CFSTR("WEP")) == kCFBooleanTrue)
        {
          objc_msgSend(v2, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v2, "supportedSecurityTypes") | 1);
          if (sub_10002DAB4((uint64_t)a1))
          {
            v21 = v2;
            v22 = 5;
          }
          else
          {
            v77 = (void *)sub_10002BE64((uint64_t)a1, CFSTR("WEP_AUTH_Flags"));
            if (!v77)
              goto LABEL_14;
            v78 = v77;
            v79 = objc_msgSend(v77, "intValue");
            objc_msgSend(v78, "intValue");
            v80 = objc_msgSend(v78, "intValue");
            if ((v79 & 1) != 0)
            {
              if ((v80 & 4) == 0)
                goto LABEL_14;
              v21 = v82;
              v22 = 3;
            }
            else
            {
              if ((v80 & 4) == 0)
                goto LABEL_14;
              v21 = v82;
              v22 = 4;
            }
          }
          objc_msgSend(v21, "setWEPSubtype:", v22);
        }
        goto LABEL_14;
      }
      v7 = (unint64_t)objc_msgSend(v2, "supportedSecurityTypes") | 0x100;
      v6 = v2;
    }
    objc_msgSend(v6, "setSupportedSecurityTypes:", v7);
    goto LABEL_14;
  }
  objc_msgSend(v2, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v2, "supportedSecurityTypes") | 2);
  v3 = objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("WAPI")), "intValue");
  if ((~v3 & 0xB) == 0)
  {
    v4 = v2;
    v5 = 2;
LABEL_10:
    objc_msgSend(v4, "setWAPISubtype:", v5);
    goto LABEL_14;
  }
  if ((~v3 & 7) == 0)
  {
    v4 = v2;
    v5 = 1;
    goto LABEL_10;
  }
LABEL_14:
  v8 = (void *)sub_10002BE64((uint64_t)a1, CFSTR("RSN_IE"));
  if (v8)
  {
    v9 = objc_msgSend(v8, "objectForKey:", CFSTR("IE_KEY_RSN_AUTHSELS"));
    if ((objc_msgSend(v9, "containsObject:", &off_100252D80) & 1) != 0
      || objc_msgSend(v9, "containsObject:", &off_100252D98))
    {
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 0x80);
    }
    if ((objc_msgSend(v9, "containsObject:", &off_100252DB0) & 1) != 0
      || (objc_msgSend(v9, "containsObject:", &off_100252DC8) & 1) != 0
      || (objc_msgSend(v9, "containsObject:", &off_100252DE0) & 1) != 0
      || objc_msgSend(v9, "containsObject:", &off_100252DF8))
    {
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 0x20);
    }
    if ((objc_msgSend(v9, "containsObject:", &off_100252E10) & 1) != 0
      || (objc_msgSend(v9, "containsObject:", &off_100252E28) & 1) != 0
      || (objc_msgSend(v9, "containsObject:", &off_100252E40) & 1) != 0
      || objc_msgSend(v9, "containsObject:", &off_100252E58))
    {
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 0x40);
      if (sub_10002CEB0(a1[2]))
        objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 0x10);
    }
    if ((objc_msgSend(v9, "containsObject:", &off_100252E70) & 1) != 0
      || (objc_msgSend(v9, "containsObject:", &off_100252E88) & 1) != 0
      || objc_msgSend(v9, "containsObject:", &off_100252EA0))
    {
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 0x10);
    }
  }
  v10 = (void *)sub_10002BE64((uint64_t)a1, CFSTR("WPA_IE"));
  if (v10)
  {
    v11 = objc_msgSend(v10, "objectForKey:", CFSTR("IE_KEY_WPA_AUTHSELS"));
    if ((objc_msgSend(v11, "containsObject:", &off_100252DB0) & 1) != 0
      || objc_msgSend(v11, "containsObject:", &off_100252DC8))
    {
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 8);
    }
    if (objc_msgSend(v11, "containsObject:", &off_100252E70))
      objc_msgSend(v82, "setSupportedSecurityTypes:", (unint64_t)objc_msgSend(v82, "supportedSecurityTypes") | 4);
  }
  if (!objc_msgSend(v82, "supportedSecurityTypes"))
    objc_msgSend(v82, "setSupportedSecurityTypes:", 512);
  if (&_CNForgetSSID)
  {
    v12 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptiveNetworkProperty), kCNSCaptiveNetworkProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptivePortalAPIProperty), kCNSCaptivePortalAPIProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptivePortalUserPortalURLProperty), kCNSCaptivePortalUserPortalURLProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptivePortalVenueInfoURLProperty), kCNSCaptivePortalVenueInfoURLProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptivePortalCanExtendSessionProperty), kCNSCaptivePortalCanExtendSessionProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptivePortalSessionExpirationProperty), kCNSCaptivePortalSessionExpirationProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSNetworkWasCaptiveProperty), kCNSNetworkWasCaptiveProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSDisabledByCaptiveProperty), kCNSDisabledByCaptiveProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptiveBypassProperty), kCNSCaptiveBypassProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSIsWhitelistedCaptiveNetworkProperty), kCNSIsWhitelistedCaptiveNetworkProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSWhitelistedCaptiveNetworkProbeDateProperty), kCNSWhitelistedCaptiveNetworkProbeDateProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSBrokenBackhaulPromptDateProperty), kCNSBrokenBackhaulPromptDateProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSBrokenBackhaulUseCellularProperty), kCNSBrokenBackhaulUseCellularProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, kCNSCaptiveNetworkWebSheetLoginDateProperty), kCNSCaptiveNetworkWebSheetLoginDateProperty);
    objc_msgSend(v12, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, CFSTR("DisabledByCaptiveReason")), CFSTR("DisabledByCaptiveReason"));
    if (objc_msgSend(v12, "count"))
      v13 = v12;
    else
      v13 = 0;
    objc_msgSend(v82, "setCaptiveProfile:", v13);
  }
  if (sub_100031670(a1))
    v14 = 1;
  else
    v14 = 2;
  objc_msgSend(v82, "setHiddenState:", v14);
  if (sub_100007E20((uint64_t)a1) == 2)
    objc_msgSend(v82, "setPasswordSharingDisabled:", 1);
  objc_msgSend(v82, "setPayloadUUID:", sub_10002BE64((uint64_t)a1, CFSTR("PayloadUUID")));
  objc_msgSend(v82, "setAutoJoinDisabled:", !sub_100007F24((uint64_t)a1));
  v15 = sub_100008280((uint64_t)a1);
  if (v15 == 1)
    v16 = 1;
  else
    v16 = 2 * (v15 == 2);
  objc_msgSend(v82, "setLowDataMode:", v16);
  objc_msgSend(v82, "setBundleID:", sub_10002BE64((uint64_t)a1, CFSTR("BundleIdentifier")));
  objc_msgSend(v82, "setLastJoinedBySystemAt:", sub_10002BE64((uint64_t)a1, CFSTR("lastAutoJoined")));
  objc_msgSend(v82, "setLastJoinedByUserAt:", sub_10002BE64((uint64_t)a1, CFSTR("lastJoined")));
  v17 = objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("WiFiManagerKnownNetworksEventType")), "intValue");
  v18 = objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeSource")), "intValue");
  v19 = objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("NetworkOriginator")), "intValue");
  v20 = 10;
  switch(v19)
  {
    case 0u:
      if (!objc_msgSend(v82, "bundleID", 10))
        goto LABEL_58;
      v20 = 14;
      break;
    case 1u:
    case 6u:
      v20 = 15;
      break;
    case 2u:
      break;
    default:
LABEL_58:
      v20 = 17;
      if (v19 != 3 && v18 != 1)
      {
        if (v19 == 4)
        {
          v20 = 7;
        }
        else if (v19 == 5)
        {
          v20 = 12;
        }
        else if (objc_msgSend(v82, "payloadUUID", 17))
        {
LABEL_69:
          v20 = 9;
        }
        else
        {
          v20 = 16;
          if (v17 != 14 && v18 != 2)
          {
            v20 = 5;
            switch(v17)
            {
              case 1u:
                goto LABEL_70;
              case 2u:
              case 4u:
              case 7u:
              case 8u:
              case 9u:
              case 0xAu:
                goto LABEL_154;
              case 3u:
                v20 = 8;
                break;
              case 5u:
                v20 = 13;
                break;
              case 6u:
                v20 = 6;
                break;
              case 0xBu:
                v20 = 11;
                break;
              default:
                if (v17 == 17)
                  goto LABEL_69;
LABEL_154:
                v20 = 0;
                break;
            }
          }
        }
      }
      break;
  }
LABEL_70:
  objc_msgSend(v82, "setAddReason:", v20);
  objc_msgSend(v82, "setAddedAt:", sub_10002BE64((uint64_t)a1, CFSTR("addedAt")));
  objc_msgSend(v82, "setUpdatedAt:", sub_10002BE64((uint64_t)a1, CFSTR("lastUpdated")));
  objc_msgSend(v82, "setEAPProfile:", objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("EnterpriseProfile")), "objectForKeyedSubscript:", CFSTR("EAPClientConfiguration")));
  objc_msgSend(v82, "setDomainName:", sub_10002BE64((uint64_t)a1, CFSTR("DomainName")));
  objc_msgSend(v82, "setDisplayedOperatorName:", sub_10002BE64((uint64_t)a1, CFSTR("DisplayedOperatorName")));
  objc_msgSend(v82, "setServiceProviderRoamingEnabled:", sub_10002BE64((uint64_t)a1, CFSTR("SPRoaming")) != kCFBooleanFalse);
  objc_msgSend(v82, "setCellularNetworkInfo:", sub_10002BE64((uint64_t)a1, CFSTR("MCCandMNC")));
  objc_msgSend(v82, "setNAIRealmNameList:", sub_10002BE64((uint64_t)a1, CFSTR("NaiRealmName")));
  objc_msgSend(v82, "setRoamingConsortiumList:", sub_10002BE64((uint64_t)a1, CFSTR("RoamingConsortiumOIs")));
  objc_msgSend(v82, "setUserPreferredNetworkNames:", sub_10002BE64((uint64_t)a1, CFSTR("userPreferredNetworkNames")));
  objc_msgSend(v82, "setUserPreferredPasspointDomains:", sub_10002BE64((uint64_t)a1, CFSTR("userPreferredPasspointDomains")));
  objc_msgSend(v82, "setNetworkGroupID:", sub_10002BE64((uint64_t)a1, CFSTR("networkGroupID")));
  objc_msgSend(v82, "setNetworkGroupPriority:", objc_msgSend((id)sub_10002BE64((uint64_t)a1, CFSTR("networkGroupPriority")), "unsignedIntegerValue"));
  objc_msgSend(v82, "setLastDiscoveredAt:", sub_10002BE64((uint64_t)a1, CFSTR("discoveredAt")));
  v23 = (void *)sub_10002BE64((uint64_t)a1, CFSTR("TransitionDisabledFlags"));
  if (v23)
    objc_msgSend(v82, "setTransitionDisabledFlags:", objc_msgSend(v23, "unsignedIntegerValue"));
  objc_msgSend(v82, "setStandalone6G:", sub_10002BE64((uint64_t)a1, CFSTR("Standalone")) == kCFBooleanTrue);
  v24 = (const __CFArray *)sub_10002BE64((uint64_t)a1, CFSTR("networkKnownBSSListKey"));
  if (v24)
  {
    v25 = v24;
    if (CFArrayGetCount(v24))
    {
      v98 = 0u;
      v99 = 0u;
      v96 = 0u;
      v97 = 0u;
      obj = v25;
      v86 = -[__CFArray countByEnumeratingWithState:objects:count:](v25, "countByEnumeratingWithState:objects:count:", &v96, v113, 16);
      if (v86)
      {
        v87 = 0;
        v85 = *(_QWORD *)v97;
        v84 = CWFCoreWiFiSpecificAttributesKey;
        do
        {
          for (i = 0; i != v86; i = (char *)i + 1)
          {
            if (*(_QWORD *)v97 != v85)
              objc_enumerationMutation(obj);
            v27 = *(void **)(*((_QWORD *)&v96 + 1) + 8 * (_QWORD)i);
            v105 = 0;
            v106 = &v105;
            v107 = 0x3052000000;
            v108 = sub_10002FA88;
            v109 = sub_10002F990;
            v28 = (objc_class *)qword_10026D6F0;
            v110 = qword_10026D6F0;
            if (!qword_10026D6F0)
            {
              v100 = _NSConcreteStackBlock;
              v101 = 3221225472;
              v102 = sub_1000D0300;
              v103 = &unk_100230858;
              v104 = &v105;
              sub_1000D0300((uint64_t)&v100);
              v28 = (objc_class *)v106[5];
            }
            _Block_object_dispose(&v105, 8);
            v29 = objc_alloc_init(v28);
            objc_msgSend(v29, "setBSSID:", CWFCorrectEthernetAddressString(objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("BSSID"))));
            v30 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("CHANNEL"));
            v31 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("CHANNEL_FLAGS"));
            if (v30)
            {
              v32 = v31;
              if (v31)
              {
                v33 = objc_alloc_init((Class)sub_100027C48());
                objc_msgSend(v33, "setChannel:", objc_msgSend(v30, "integerValue"));
                objc_msgSend(v33, "setFlags:", objc_msgSend(v32, "unsignedIntegerValue"));
                objc_msgSend(v29, "setChannel:", v33);
              }
            }
            if (objc_msgSend(v29, "BSSID") && objc_msgSend(v29, "channel"))
            {
              objc_msgSend(v29, "setLastAssociatedAt:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("lastRoamed")));
              v34 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("networkLocnLat"));
              v35 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("networkLocnLong"));
              v36 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("networkLocnAccuracy"));
              v37 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("networkLocnTimestamp"));
              if (v34)
              {
                if (v35)
                {
                  if (v36)
                  {
                    v38 = v37;
                    if (v37)
                    {
                      v105 = 0;
                      v106 = &v105;
                      v107 = 0x3052000000;
                      v108 = sub_10002FA88;
                      v109 = sub_10002F990;
                      v39 = (objc_class *)qword_10026D700;
                      v110 = qword_10026D700;
                      if (!qword_10026D700)
                      {
                        v100 = _NSConcreteStackBlock;
                        v101 = 3221225472;
                        v102 = sub_1000D03A8;
                        v103 = &unk_100230858;
                        v104 = &v105;
                        sub_1000D03A8((uint64_t)&v100);
                        v39 = (objc_class *)v106[5];
                      }
                      _Block_object_dispose(&v105, 8);
                      v40 = [v39 alloc];
                      objc_msgSend(v34, "doubleValue");
                      v42 = v41;
                      objc_msgSend(v35, "doubleValue");
                      v44 = v43;
                      v105 = 0;
                      v106 = &v105;
                      v107 = 0x2020000000;
                      v45 = off_10026D710;
                      v108 = (void (*)(uint64_t, uint64_t))off_10026D710;
                      if (!off_10026D710)
                      {
                        v46 = (void *)sub_1000D03FC();
                        v45 = dlsym(v46, "CLLocationCoordinate2DMake");
                        v106[3] = (uint64_t)v45;
                        off_10026D710 = v45;
                      }
                      _Block_object_dispose(&v105, 8);
                      if (!v45)
                        sub_1001871FC();
                      v47 = ((double (*)(double, double))v45)(v42, v44);
                      v49 = v48;
                      objc_msgSend(v36, "doubleValue");
                      objc_msgSend(v29, "setLocation:", objc_msgSend(v40, "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:", v38, v47, v49, 0.0, v50, 0.0));
                    }
                  }
                }
              }
              v51 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("colocated2GHzRNRChannel"));
              v52 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("colocated2GHzRNRChannelFlags"));
              if (v51)
              {
                v53 = v52;
                if (v52)
                {
                  v54 = objc_alloc_init((Class)sub_100027C48());
                  objc_msgSend(v54, "setChannel:", objc_msgSend(v51, "integerValue"));
                  objc_msgSend(v54, "setFlags:", objc_msgSend(v53, "unsignedIntegerValue"));
                  objc_msgSend(v29, "setColocated2GHzRNRChannel:", v54);
                }
              }
              v55 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("colocated5GHzRNRChannel"));
              v56 = objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("colocated5GHzRNRChannelFlags"));
              if (v55)
              {
                v57 = v56;
                if (v56)
                {
                  v58 = objc_alloc_init((Class)sub_100027C48());
                  objc_msgSend(v58, "setChannel:", objc_msgSend(v55, "integerValue"));
                  objc_msgSend(v58, "setFlags:", objc_msgSend(v57, "unsignedIntegerValue"));
                  objc_msgSend(v29, "setColocated5GHzRNRChannel:", v58);
                }
              }
              objc_msgSend(v29, "setAWDLRealTimeModeTimestamp:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("AWDLRealTimeModeTimestamp")));
              objc_msgSend(v29, "setIPv4NetworkSignature:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("IPv4NetworkSignature")));
              objc_msgSend(v29, "setIPv6NetworkSignature:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("IPv6NetworkSignature")));
              objc_msgSend(v29, "setDHCPServerID:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("DHCPServerID")));
              objc_msgSend(v29, "setDHCPv6ServerID:", objc_msgSend(v27, "objectForKeyedSubscript:", CFSTR("DHCPv6ServerID")));
              v59 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
              v94 = 0u;
              v95 = 0u;
              v92 = 0u;
              v93 = 0u;
              v60 = +[CWFBSS supportedOSSpecificKeys](CWFBSS, "supportedOSSpecificKeys");
              v61 = objc_msgSend(v60, "countByEnumeratingWithState:objects:count:", &v92, v112, 16);
              if (v61)
              {
                v62 = *(_QWORD *)v93;
                do
                {
                  for (j = 0; j != v61; j = (char *)j + 1)
                  {
                    if (*(_QWORD *)v93 != v62)
                      objc_enumerationMutation(v60);
                    objc_msgSend(v59, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, *(void **)(*((_QWORD *)&v92 + 1) + 8 * (_QWORD)j)), *(_QWORD *)(*((_QWORD *)&v92 + 1) + 8 * (_QWORD)j));
                  }
                  v61 = objc_msgSend(v60, "countByEnumeratingWithState:objects:count:", &v92, v112, 16);
                }
                while (v61);
              }
              if (objc_msgSend(v59, "count"))
                v64 = v59;
              else
                v64 = 0;
              objc_msgSend(v29, "setOSSpecificAttributes:", v64);
              objc_msgSend(v29, "setCoreWiFiSpecificAttributes:", objc_msgSend(v27, "objectForKeyedSubscript:", v84));
              v65 = v87;
              if (!v87)
                v65 = +[NSMutableSet set](NSMutableSet, "set");
              v87 = v65;
              objc_msgSend(v65, "addObject:", v29);
            }
          }
          v86 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v96, v113, 16);
        }
        while (v86);
      }
      else
      {
        v87 = 0;
      }
      objc_msgSend(v82, "setBSSList:", v87);
    }
  }
  objc_msgSend(v82, "setPrivacyProxyEnabled:", sub_1000081D8((uint64_t)a1));
  objc_msgSend(v82, "setPrivacyProxyBlockedReason:", sub_10002BE64((uint64_t)a1, CFSTR("PrivacyProxyBlockedReason")));
  if (sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsMoving")))
  {
    v66 = sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsMoving"));
    if (CFEqual(v66, kCFBooleanTrue))
      v67 = 1;
    else
      v67 = 2;
  }
  else
  {
    v67 = 0;
  }
  objc_msgSend(v82, "setMovingAttribute:", v67);
  if (sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsPublic")))
  {
    v68 = sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkAttributeIsPublic"));
    if (CFEqual(v68, kCFBooleanTrue))
      v69 = 1;
    else
      v69 = 2;
  }
  else
  {
    v69 = 0;
  }
  objc_msgSend(v82, "setPublicAttribute:", v69);
  objc_msgSend(v82, "setCarplayUUID:", sub_10002BE64((uint64_t)a1, CFSTR("CARPLAY_UUID")));
  objc_msgSend(v82, "setCarplayNetwork:", sub_10000BE8C((uint64_t)a1) != 0);
  objc_msgSend(v82, "setPersonalHotspot:", sub_10001395C((uint64_t)a1) != 0);
  objc_msgSend(v82, "setNANServiceID:", sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkNANServiceID")));
  objc_msgSend(v82, "setPublicAirPlayNetwork:", sub_100007828((uint64_t)a1) != 0);
  objc_msgSend(v82, "setDNSHeuristicsFilteredNetwork:", sub_10002BE64((uint64_t)a1, CFSTR("FilteredNetwork")) == kCFBooleanTrue);
  objc_msgSend(v82, "setDNSHeuristicsFailureStateInfo:", sub_10002BE64((uint64_t)a1, CFSTR("DNSFailures")));
  v70 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v71 = +[CWFNetworkProfile supportedOSSpecificKeys](CWFNetworkProfile, "supportedOSSpecificKeys");
  v72 = objc_msgSend(v71, "countByEnumeratingWithState:objects:count:", &v88, v111, 16);
  if (v72)
  {
    v73 = *(_QWORD *)v89;
    do
    {
      for (k = 0; k != v72; k = (char *)k + 1)
      {
        if (*(_QWORD *)v89 != v73)
          objc_enumerationMutation(v71);
        objc_msgSend(v70, "setObject:forKeyedSubscript:", sub_10002BE64((uint64_t)a1, *(void **)(*((_QWORD *)&v88 + 1) + 8 * (_QWORD)k)), *(_QWORD *)(*((_QWORD *)&v88 + 1) + 8 * (_QWORD)k));
      }
      v72 = objc_msgSend(v71, "countByEnumeratingWithState:objects:count:", &v88, v111, 16);
    }
    while (v72);
  }
  if (objc_msgSend(v70, "count"))
    v75 = v70;
  else
    v75 = 0;
  objc_msgSend(v82, "setOSSpecificAttributes:", v75);
  objc_msgSend(v82, "setCoreWiFiSpecificAttributes:", sub_10002BE64((uint64_t)a1, CWFCoreWiFiSpecificAttributesKey));
LABEL_141:
  objc_autoreleasePoolPop(context);
  return v82;
}

void sub_100027A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100027B80()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = sub_10002FA88;
  v7 = sub_10002F990;
  v0 = qword_10026D6E0;
  v8 = qword_10026D6E0;
  if (!qword_10026D6E0)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_1000D0204;
    v2[3] = &unk_100230858;
    v2[4] = &v3;
    sub_1000D0204((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100027C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100027C48()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = sub_10002FA88;
  v7 = sub_10002F990;
  v0 = qword_10026D6F8;
  v8 = qword_10026D6F8;
  if (!qword_10026D6F8)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_1000D0354;
    v2[3] = &unk_100230858;
    v2[4] = &v3;
    sub_1000D0354((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100027CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100027D10(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  CFDictionaryRef Copy;
  CFDictionaryRef v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  id v14;
  NSArray *v15;
  id v16;
  id v17;
  uint64_t v18;
  void *j;
  id v20;
  void *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];
  _QWORD v33[2];
  _QWORD v34[75];

  v2 = objc_autoreleasePoolPush();
  if (sub_10002851C()
    && (v3 = sub_100028480(), a1)
    && v3
    && (Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a1 + 16))) != 0)
  {
    v5 = Copy;
    v22 = v2;
    v6 = objc_msgSend((id)sub_10002BE64(a1, CFSTR("HS20GasResponse")), "mutableCopy");
    objc_msgSend(v6, "setObject:forKeyedSubscript:", 0, CFSTR("ANQP_STATUS"));
    objc_msgSend(v6, "setObject:forKeyedSubscript:", 0, CFSTR("BSSID"));
    objc_msgSend(v6, "setObject:forKeyedSubscript:", 0, CFSTR("CHANNEL"));
    objc_msgSend(v6, "setObject:forKeyedSubscript:", 0, CFSTR("CHANNEL_FLAGS"));
    v7 = -[__CFDictionary mutableCopy](v5, "mutableCopy");
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v6, CFSTR("ANQP_PARSED"));
    v8 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v9 = +[CWFScanResult supportedOSSpecificKeys](CWFScanResult, "supportedOSSpecificKeys");
    v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
    if (v10)
    {
      v11 = v10;
      v12 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v11; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v12)
            objc_enumerationMutation(v9);
          objc_msgSend(v8, "setObject:forKeyedSubscript:", sub_10002BE64(a1, *(void **)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i)), *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i));
        }
        v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
      }
      while (v11);
    }
    if (objc_msgSend(v8, "count"))
      v14 = v8;
    else
      v14 = 0;
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v14, sub_100028480());
    v34[0] = CFSTR("IsWiFiNetworkShareble");
    v34[1] = CFSTR("NetworkOriginator");
    v34[2] = CFSTR("CaptiveBypass");
    v34[3] = CFSTR("DiagnosticsBssEnv");
    v34[4] = CFSTR("DisableWiFiAutoJoinUntilFirstUserJoin");
    v34[5] = CFSTR("DisplayedOperatorName");
    v34[6] = CFSTR("DomainName");
    v34[7] = CFSTR("HS20GasResponse");
    v34[8] = CFSTR("HS20HomeOperatorNetwork");
    v34[9] = CFSTR("HS20ProvisionedNetwork");
    v34[10] = CFSTR("HS2NetworkBadge");
    v34[11] = CFSTR("HS20AccountName");
    v34[12] = CFSTR("MCCandMNC");
    v34[13] = CFSTR("NaiRealmName");
    v34[14] = CFSTR("NetworkAtLocationOfInterestType");
    v34[15] = CFSTR("WiFiNetworkAttributeHighPopularity");
    v34[16] = CFSTR("WiFiNetworkAttributeHighQuality");
    v34[17] = CFSTR("WiFiNetworkAttributeIsMoving");
    v34[18] = CFSTR("WiFiNetworkAttributeIsPotentiallyCaptive");
    v34[19] = CFSTR("WiFiNetworkAttributeIsPotentiallyMoving");
    v34[20] = CFSTR("WiFiNetworkAttributeIsSuspicious");
    v34[21] = CFSTR("WiFiNetworkAttributeIsTCPGood");
    v34[22] = CFSTR("WiFiNetworkAttributeLowPopularity");
    v34[23] = CFSTR("WiFiNetworkAttributeLowQuality");
    v34[24] = CFSTR("WiFiNetworkAttributePopularityScore");
    v34[25] = CFSTR("WiFiNetworkAttributeProminentDisplay");
    v34[26] = CFSTR("WiFiNetworkAttributeQualityScore");
    v34[27] = CFSTR("WiFiNetworkAttributeSource");
    v34[28] = CFSTR("BundleIdentifier");
    v34[29] = CFSTR("SIMIdentifiers");
    v34[30] = CFSTR("WiFiNetworkDisabledUntilDate");
    v34[31] = CFSTR("EnterpriseProfile");
    v34[32] = CFSTR("WiFiNetworkExpirationDate");
    v34[33] = CFSTR("NetworkForcedHomeFix");
    v34[34] = CFSTR("kWiFiNetworkLastHomeForceFixDateKey");
    v34[35] = CFSTR("NetworkOfInterestHomeState");
    v34[36] = CFSTR("NetworkOfInterestWorkState");
    v34[37] = CFSTR("WiFiNetworkPasswordModificationDate");
    v34[38] = CFSTR("PayloadUUID");
    v34[39] = CFSTR("SaveDataMode");
    v34[40] = CFSTR("NetworkQualityResponsiveness");
    v34[41] = CFSTR("NetworkQualityDate");
    v34[42] = CFSTR("ShareableEAPConfig");
    v34[43] = CFSTR("ShareableEAPTrustExceptions");
    v34[44] = CFSTR("ShareableStatus");
    v34[45] = CFSTR("ShareMode");
    v34[46] = CFSTR("kWiFiNetworkSSIDHarvestStatusKey");
    v34[47] = CFSTR("UserRole");
    v34[48] = CFSTR("WalletIdentifier");
    v34[49] = CFSTR("addedAt");
    v34[50] = CFSTR("knownBSSUpdatedDate");
    v34[51] = CFSTR("lastAutoJoined");
    v34[52] = CFSTR("lastJoined");
    v34[53] = CFSTR("lastRoamed");
    v34[54] = CFSTR("lastUpdated");
    v34[55] = CFSTR("WiFiManagerKnownNetworksEventType");
    v34[56] = CFSTR("networkDisabledClientName");
    v34[57] = CFSTR("networkDisabledReason");
    v34[58] = CFSTR("networkDisabledTimestamp");
    v34[59] = CFSTR("enabled");
    v34[60] = CFSTR("networkKnownBSSListKey");
    v34[61] = CFSTR("scanWasDirected");
    v34[62] = CFSTR("prevJoined");
    v34[63] = CFSTR("UserDirected");
    v34[64] = CFSTR("networkUsage");
    v34[65] = CFSTR("RoamingConsortiumOIs");
    v34[66] = CFSTR("SPRoaming");
    v34[67] = CFSTR("PolicyUUID");
    v34[68] = CFSTR("PrivacyProxyEnabled");
    v34[69] = CFSTR("TransitionDisabledFlags");
    v34[70] = CFSTR("Standalone");
    v34[71] = CFSTR("PublicAirPlayNetwork");
    v34[72] = CFSTR("PrivacyProxyBlockedReason");
    v34[73] = CFSTR("FilteredNetwork");
    v34[74] = CFSTR("DNSFailures");
    v15 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v34, 75);
    if (&_CNForgetSSID)
    {
      v33[0] = kCNSCaptiveNetworkProperty;
      v33[1] = kCNSNetworkWasCaptiveProperty;
      v15 = -[NSArray arrayByAddingObjectsFromArray:](v15, "arrayByAddingObjectsFromArray:", +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v33, 2));
    }
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v16 = -[NSArray countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
    if (v16)
    {
      v17 = v16;
      v18 = *(_QWORD *)v24;
      do
      {
        for (j = 0; j != v17; j = (char *)j + 1)
        {
          if (*(_QWORD *)v24 != v18)
            objc_enumerationMutation(v15);
          objc_msgSend(v7, "setObject:forKeyedSubscript:", 0, *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)j));
        }
        v17 = -[NSArray countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
      }
      while (v17);
    }
    v20 = objc_msgSend(objc_alloc((Class)sub_10002851C()), "initWithScanRecord:includeProperties:", v7, 0);
    objc_autoreleasePoolPop(v22);
    CFRelease(v5);
  }
  else
  {
    objc_autoreleasePoolPop(v2);
    return 0;
  }
  return v20;
}

uint64_t sub_100028480()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)qword_10026D720;
  v6 = qword_10026D720;
  if (!qword_10026D720)
  {
    v1 = (void *)sub_1000D0258();
    v0 = dlsym(v1, "CWFScanResultPropertyOSSpecificAttributesKey");
    v4[3] = (uint64_t)v0;
    qword_10026D720 = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    sub_100187260();
  return *(_QWORD *)v0;
}

void sub_100028504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10002851C()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = sub_10002FA88;
  v7 = sub_10002F990;
  v0 = qword_10026D718;
  v8 = qword_10026D718;
  if (!qword_10026D718)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_1000D04A4;
    v2[3] = &unk_100230858;
    v2[4] = &v3;
    sub_1000D04A4((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1000285CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000285E4(uint64_t a1, unint64_t a2)
{
  void *v4;
  __CFArray *Mutable;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  id v9;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  id v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  _WORD *v17;
  const void *v18;
  void *v19;
  id v20;
  unsigned int v21;
  NSArray *v22;
  id v23;
  NSArray *v24;
  id v25;
  uint64_t v26;
  CFDictionaryRef *v27;
  CFDictionaryRef *v28;
  void *v29;
  const __CFNumber *v30;
  const __CFDate *v31;
  double Current;
  void *v33;
  void *v34;
  const void *v35;
  uint64_t v36;
  double v37;
  NSString *v38;
  _BOOL4 v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *context;
  _QWORD v54[8];
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t);
  void (*v59)(uint64_t);
  uint64_t v60;
  unsigned int valuePtr;
  id v62;
  id v63;
  id v64;
  uint8_t buf[4];
  const char *v66;

  v55 = 0;
  v56 = &v55;
  v57 = 0x3052000000;
  v58 = sub_10002FAA8;
  v59 = sub_10002F9A4;
  v60 = 0;
  context = objc_autoreleasePoolPush();
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AUTO-JOIN: Triggered (trigger=%d)", "WiFiDeviceManagerStartAutoJoinAndReply", a2);
  objc_autoreleasePoolPop(v4);
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    v49 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UAJM feature is disabled", "WiFiDeviceManagerStartAutoJoinAndReply");
    goto LABEL_98;
  }
  if (!a1)
  {
    v49 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "WiFiDeviceManagerStartAutoJoinAndReply");
    goto LABEL_98;
  }
  if (!*(_QWORD *)(a1 + 8824))
  {
    v49 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UAJM is null", "WiFiDeviceManagerStartAutoJoinAndReply");
    goto LABEL_98;
  }
  sub_100025C3C(*(_QWORD *)(a1 + 64));
  if (*(_DWORD *)(a1 + 20) != 1)
  {
    v49 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFi is OFF", "WiFiDeviceManagerStartAutoJoinAndReply");
LABEL_98:
    objc_autoreleasePoolPop(v49);
    Mutable = 0;
    goto LABEL_77;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
    goto LABEL_77;
  v6 = *(_QWORD *)(a1 + 64);
  v7 = (const void *)sub_100025C3C(v6);
  v8 = sub_100017A68(v6, v7, Mutable);
  if ((_DWORD)v8)
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: FAILED to get supported channels (err=%d)", "WiFiDeviceManagerStartAutoJoinAndReply", v8);
    goto LABEL_103;
  }
  if (!CFArrayGetCount(Mutable))
  {
    v50 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Supported channels list is empty", "WiFiDeviceManagerStartAutoJoinAndReply");
LABEL_103:
    objc_autoreleasePoolPop(v50);
    goto LABEL_77;
  }
  v9 = +[NSMutableArray array](NSMutableArray, "array");
  for (i = 0; i < CFArrayGetCount(Mutable); ++i)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, i);
    if (ValueAtIndex)
    {
      v12 = objc_alloc_init((Class)CWFChannel);
      objc_msgSend(v12, "setChannel:", objc_msgSend((id)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL")), "unsignedIntegerValue"));
      objc_msgSend(v12, "setFlags:", objc_msgSend((id)CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL_FLAGS")), "unsignedIntegerValue"));
      objc_msgSend(v9, "addObject:", v12);
    }
  }
  if (objc_msgSend(v9, "count"))
    objc_msgSend(*(id *)(a1 + 8824), "setSupportedChannels:", +[NSMutableSet setWithArray:](NSMutableSet, "setWithArray:", v9));
  v13 = sub_100009ACC(a1);
  v14 = *(void **)(a1 + 8824);
  if (v13)
  {
    objc_msgSend(v14, "setLocation:", v13);

  }
  else
  {
    objc_msgSend(v14, "setLocation:", 0);
  }
  sub_10000C120(a1);
  v15 = objc_alloc_init((Class)CWFAutoJoinParameters);
  objc_msgSend(v15, "setMode:", 1);
  objc_msgSend(v15, "setTrigger:", a2);
  if (*(_DWORD *)(a1 + 5520) != 1 && !*(_BYTE *)(a1 + 5504))
  {
    if (*(_BYTE *)(a1 + 8821) && *(_QWORD *)(a1 + 8800))
    {
      v23 = objc_alloc_init((Class)CWFChannel);
      objc_msgSend(v23, "setChannel:", objc_msgSend(*(id *)(a1 + 8800), "unsignedIntegerValue"));
      objc_msgSend(v23, "setFlags:", objc_msgSend(*(id *)(a1 + 8808), "unsignedIntValue"));
      v63 = v23;
      v24 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v63, 1);
    }
    else
    {
      if (a2 != 55)
      {
LABEL_34:
        v22 = 0;
        goto LABEL_37;
      }
      v25 = objc_alloc_init((Class)CWFChannel);
      objc_msgSend(v25, "setChannel:", *(unsigned int *)(a1 + 3840));
      objc_msgSend(v25, "setFlags:", *(unsigned int *)(a1 + 3844));
      v62 = v25;
      v24 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v62, 1);
    }
    v22 = v24;
    goto LABEL_37;
  }
  v16 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8824), "knownNetworks"), "anyObject");
  if (!objc_msgSend(v16, "isCarPlay"))
    goto LABEL_34;
  v17 = sub_1000CCB10(v16, 0);
  v18 = v17;
  if (!v17)
    goto LABEL_34;
  v19 = (void *)sub_10002BE64((uint64_t)v17, CFSTR("CHANNEL"));
  if (v19)
  {
    v20 = objc_alloc_init((Class)CWFChannel);
    objc_msgSend(v20, "setChannel:", objc_msgSend(v19, "unsignedIntegerValue"));
    v21 = sub_10003153C((uint64_t)v18) - 1;
    if (v21 < 3)
      objc_msgSend(v20, "setFlags:", dword_1001BBD4C[v21]);
    v64 = v20;
    v22 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v64, 1);
  }
  else
  {
    v22 = 0;
  }
  CFRelease(v18);
LABEL_37:
  objc_msgSend(v15, "setPreferredChannels:", v22);
  if (a2 == 7
    || a2 == 2 && ((v26 = *(_QWORD *)(a1 + 3512)) == 0 || !sub_10000BE8C(v26) || !*(_BYTE *)(a1 + 992)))
  {
    v27 = (CFDictionaryRef *)sub_10002B170(a1, *(const void **)(a1 + 3512), 0);
    v28 = v27;
    if (v27)
    {
      v29 = sub_100026664(v27);
      if (v29)
      {
        if (sub_10001395C((uint64_t)v28)
          && (sub_10002BE64((uint64_t)v28, CFSTR("WiFiInstantHotspotJoining")) == kCFBooleanTrue
           || sub_10002BE64((uint64_t)v28, CFSTR("WiFiAutoInstantHotspotJoining")) == kCFBooleanTrue))
        {
          v30 = (const __CFNumber *)sub_10002BE64((uint64_t)v28, CFSTR("lastDisconnectReasonKey"));
          if (v30)
          {
            v31 = (const __CFDate *)sub_10002BE64((uint64_t)v28, CFSTR("lastDisconnectTimestampKey"));
            if (v31)
            {
              valuePtr = -1431655766;
              CFNumberGetValue(v30, kCFNumberIntType, &valuePtr);
              if (valuePtr <= 2)
              {
                Current = CFAbsoluteTimeGetCurrent();
                if (Current - CFDateGetAbsoluteTime(v31) < 300.0)
                {
                  v33 = objc_autoreleasePoolPush();
                  v34 = v33;
                  if (qword_10026DD20)
                  {
                    v52 = v33;
                    v35 = sub_10002B088(v28);
                    v36 = valuePtr;
                    v37 = CFAbsoluteTimeGetCurrent();
                    v38 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("AUTOJOIN"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s Previous Hotspot %@ disconnect reason %d time since linkDown %.1f"), "__WiFiDeviceManagerUnifiedAutoJoinForceDirectedScanForAutoHotspotLinkDownRecovery", v35, v36, v37 - CFDateGetAbsoluteTime(v31))), "UTF8String"));
                    v39 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
                    v34 = v52;
                    if (v39)
                    {
                      v40 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v38, "UTF8String")), "UTF8String");
                      *(_DWORD *)buf = 136446210;
                      v66 = v40;
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                      v34 = v52;
                    }
                  }
                  objc_autoreleasePoolPop(v34);
                  objc_msgSend(v29, "setHiddenState:", 1);
                }
              }
            }
          }
        }
        objc_msgSend(v15, "setTargetNetworkProfile:", v29);

      }
      CFRelease(v28);
    }
  }
  if (*(_BYTE *)(a1 + 3414))
  {
    v41 = 4;
    goto LABEL_59;
  }
  if (a2 > 0x37 || ((1 << a2) & 0xC0000100000084) == 0)
  {
    if (*(_DWORD *)(a1 + 176) != 3
      && (a2 > 0x3A || ((1 << a2) & 0x630048F1C000200) == 0)
      && !CWFIsAutoJoinRetryTrigger(a2))
    {
LABEL_60:
      if (a2 == 39)
        *(_BYTE *)(a1 + 6616) = 1;
      goto LABEL_64;
    }
    v41 = 2;
LABEL_59:
    objc_msgSend(v15, "setMode:", v41);
    goto LABEL_60;
  }
LABEL_64:
  v42 = sub_10001E1C8((uint64_t)"WiFiDeviceManagerStartAutoJoinAndReply");
  CFRetain((CFTypeRef)a1);
  if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EMaxCompatibility"))
  {
    v43 = sub_100031A74(*(_QWORD *)(a1 + 6792));
    v44 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: prefer 6E enabled %d", "WiFiDeviceManagerStartAutoJoinAndReply", v43 == 0);
    objc_autoreleasePoolPop(v44);
    objc_msgSend(*(id *)(a1 + 8824), "setMaxCompatibilityEnabled:", v43 == 0);
  }
  v45 = *(void **)(a1 + 8824);
  v54[0] = _NSConcreteStackBlock;
  v54[1] = 3221225472;
  v54[2] = sub_10001E5BC;
  v54[3] = &unk_100231C80;
  v54[6] = a1;
  v54[7] = a2;
  v54[4] = v42;
  v54[5] = &v55;
  v46 = objc_msgSend(v45, "performAutoJoinWithParameters:reply:", v15, v54);
  v56[5] = (uint64_t)v46;
  if (v46 || (CFRelease((CFTypeRef)a1), v56[5]))
  {
    if (!*(_QWORD *)(a1 + 8872))
    {
      if (-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
      {
        if (a2 <= 0x28 && ((1 << a2) & 0x10000010104) != 0)
        {
          v47 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AUTO-JOIN: Auto-join is running (trigger=%ld), defer user-interactive scans", "__WiFiDeviceManagerUnifiedAutoJoinShouldDeferUserInteractiveScan", a2);
          objc_autoreleasePoolPop(v47);
          sub_10001E764(*(_QWORD *)(a1 + 64), 0, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend((id)v56[5], "UUIDString")), (CFNumberRef)0xA);
          sub_10001E764(*(_QWORD *)(a1 + 64), 9, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), CFSTR("AutoJoin"), objc_msgSend((id)v56[5], "UUIDString")), (CFNumberRef)0xA);
        }
      }
      else
      {
        v51 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AUTO-JOIN: Setup not completed, allow user-interactive scans", "__WiFiDeviceManagerUnifiedAutoJoinShouldDeferUserInteractiveScan");
        objc_autoreleasePoolPop(v51);
      }
    }
  }
LABEL_77:
  if (!v56[5])
  {
    v48 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AUTO-JOIN: FAILED to start auto-join (trigger=%d)", "WiFiDeviceManagerStartAutoJoinAndReply", a2);
    objc_autoreleasePoolPop(v48);
  }
  if (Mutable)
    CFRelease(Mutable);
  objc_autoreleasePoolPop(context);
  _Block_object_dispose(&v55, 8);
}

void sub_100029144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002919C(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  sub_100029264(*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24), *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24), *(const void **)(*(_QWORD *)(a1[6] + 8) + 24), *(const void **)(*(_QWORD *)(a1[7] + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
  }
  v3 = *(const void **)(*(_QWORD *)(a1[5] + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
  }
  v4 = *(const void **)(*(_QWORD *)(a1[6] + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = 0;
  }
  v5 = *(const void **)(*(_QWORD *)(a1[7] + 8) + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = 0;
  }
}

void sub_100029264(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  sub_1000292C4(a1, a2, 6u, a3);
  sub_1000292C4(a1, a2, 7u, a3);
  sub_1000292C4(a1, a2, 8u, a4);
}

void sub_1000292C4(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  const __CFString *v8;
  CFComparisonResult v9;
  unsigned int Value;
  void *v11;
  const __CFData *v12;
  uint64_t v13;
  const void *v14;
  const __CFData *v15;
  const __CFData *v16;
  const UInt8 *v17;
  CFIndex v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  const __CFData *v23;
  const __CFData *v24;
  const UInt8 *BytePtr;
  int Length;
  CFTypeID v27;
  const void *v28;
  int v29;
  const __CFData *v30;
  const __CFData *v31;
  const UInt8 *v32;
  int v33;
  int v34;
  vm_address_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  const UInt8 *v40;
  CFIndex v41;
  const __CFData *v42;
  const UInt8 *v43;
  int v44;
  vm_address_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  dispatch_time_t v49;
  _QWORD block[9];
  int v51;

  if (!a1
    || (v8 = *(const __CFString **)(a1 + 64)) == 0
    || (v9 = CFStringCompare(v8, CFSTR("SpringBoard"), 0), a3 != 1)
    || v9)
  {
    if (a3 <= 0x2C)
    {
      if (((1 << a3) & 0x100000060004) != 0)
      {
        v19 = 1 << a3;
        goto LABEL_21;
      }
      if (((1 << a3) & 0x2200200) != 0)
      {
        v19 = *(_QWORD *)(a1 + 128);
        goto LABEL_21;
      }
    }
LABEL_20:
    v19 = (unint64_t)sub_100029720(a1, a2);
LABEL_21:
    if (((v19 >> a3) & 1) == 0)
      return;
    v20 = a3;
    v21 = sub_1000161D4(a2);
    v22 = (const void *)sub_100029860(v21);
    if (v22)
    {
      v23 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v22);
      v24 = v23;
      if (v23)
      {
        BytePtr = CFDataGetBytePtr(v23);
        Length = CFDataGetLength(v24);
        if (!a4)
          goto LABEL_41;
      }
      else
      {
        Length = 0;
        BytePtr = 0;
        if (!a4)
          goto LABEL_41;
      }
    }
    else
    {
      Length = 0;
      BytePtr = 0;
      v24 = 0;
      if (!a4)
        goto LABEL_41;
    }
    v27 = CFGetTypeID(a4);
    if (v27 == CFDataGetTypeID())
    {
      v28 = CFDataGetBytePtr((CFDataRef)a4);
      v29 = CFDataGetLength((CFDataRef)a4);
LABEL_43:
      v44 = *(_DWORD *)(a1 + 96);
      v45 = (vm_address_t)BytePtr;
      v46 = Length;
      v47 = v20;
      v48 = (uint64_t)v28;
      goto LABEL_44;
    }
    if (a3 == 10)
    {
      v28 = sub_1000173C0((uint64_t)a4);
      if (!v28)
      {
LABEL_42:
        v29 = 0;
        goto LABEL_43;
      }
      v30 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v28);
      if (!v30)
      {
        CFRelease(v28);
        v44 = *(_DWORD *)(a1 + 96);
        v45 = (vm_address_t)BytePtr;
        v46 = Length;
        v47 = v20;
        v48 = 0;
        v29 = 0;
LABEL_44:
        sub_10002996C(v44, v45, v46, v47, v48, v29, 0);
        if (!v24)
          return;
LABEL_45:
        CFRelease(v24);
        return;
      }
      v31 = v30;
      v32 = CFDataGetBytePtr(v30);
      v33 = CFDataGetLength(v31);
      CFRelease(v28);
      v34 = *(_DWORD *)(a1 + 96);
      v35 = (vm_address_t)BytePtr;
      v36 = Length;
      v37 = v20;
      v38 = (uint64_t)v32;
      v39 = v33;
LABEL_39:
      sub_10002996C(v34, v35, v36, v37, v38, v39, 0);
      CFRelease(v31);
      if (!v24)
        return;
      goto LABEL_45;
    }
    v42 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
    if (v42)
    {
      v31 = v42;
      v43 = CFDataGetBytePtr(v42);
      v39 = CFDataGetLength(v31);
      v34 = *(_DWORD *)(a1 + 96);
      v35 = (vm_address_t)BytePtr;
      v36 = Length;
      v37 = v20;
      v38 = (uint64_t)v43;
      goto LABEL_39;
    }
LABEL_41:
    v28 = 0;
    goto LABEL_42;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("LINK_CHANGED_IS_LINKDOWN"));
  if (CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("LINKDOWN_REASON_CODE")) != 7)
  {
    if (!Value && *(_BYTE *)(a1 + 181))
      *(_BYTE *)(a1 + 180) = 1;
    goto LABEL_20;
  }
  *(_WORD *)(a1 + 180) = 256;
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "link recovery started, suppressing transient UI state for %d seconds", 4);
  objc_autoreleasePoolPop(v11);
  v12 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
  v13 = sub_1000161D4(a2);
  v14 = (const void *)sub_100029860(v13);
  if (!v14)
  {
    v18 = 0;
    v17 = 0;
    v16 = 0;
    if (v12)
      goto LABEL_36;
LABEL_47:
    v40 = 0;
    v41 = 0;
    goto LABEL_48;
  }
  v15 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v14);
  v16 = v15;
  if (!v15)
  {
    v18 = 0;
    v17 = 0;
    if (v12)
      goto LABEL_36;
    goto LABEL_47;
  }
  v17 = CFDataGetBytePtr(v15);
  v18 = CFDataGetLength(v16);
  if (!v12)
    goto LABEL_47;
LABEL_36:
  v40 = CFDataGetBytePtr(v12);
  v41 = CFDataGetLength(v12);
LABEL_48:
  v49 = dispatch_time(0, 4000000000);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100066AB8;
  block[3] = &unk_10022F720;
  block[4] = a1;
  block[5] = v17;
  v51 = 1;
  block[6] = v18;
  block[7] = v40;
  block[8] = v41;
  dispatch_after(v49, (dispatch_queue_t)qword_10026DD40, block);
  if (v12)
    CFRelease(v12);
  if (v16)
    CFRelease(v16);
}

const __CFNumber *sub_100029720(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  const __CFNumber *result;
  void *v6;
  uint64_t valuePtr;

  valuePtr = 0;
  if (!a1 || !*(_QWORD *)(a1 + 120))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: invalid wifi client ref", "WiFiClientGetDeviceEventMask");
    goto LABEL_10;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device.", "WiFiClientGetDeviceEventMask");
    goto LABEL_10;
  }
  v3 = sub_1000161D4(a2);
  if (!v3)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceRef.", "WiFiClientGetDeviceEventMask");
    goto LABEL_10;
  }
  v4 = (const void *)sub_100029860(v3);
  if (!v4)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ifName.", "WiFiClientGetDeviceEventMask");
LABEL_10:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), v4);
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

uint64_t sub_100029860(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

CFTypeRef sub_100029868(CFAllocatorRef bufferAllocator, const void *a2)
{
  __CFWriteStream *v3;
  __CFWriteStream *v4;
  void *v5;
  CFTypeRef v6;
  CFErrorRef error;

  v3 = CFWriteStreamCreateWithAllocatedBuffers(bufferAllocator, bufferAllocator);
  if (!v3)
    return 0;
  v4 = v3;
  if (CFWriteStreamOpen(v3))
  {
    error = 0;
    CFPropertyListWrite(a2, v4, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    CFWriteStreamClose(v4);
    if (error)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFPropertyListCreateWithData returned with error %@", "_CFPropertyListCreateBinaryData", error);
      objc_autoreleasePoolPop(v5);
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        sub_100186AE4();
      CFRelease(error);
    }
    v6 = CFWriteStreamCopyProperty(v4, kCFStreamPropertyDataWritten);
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v4);
  return v6;
}

uint64_t sub_10002996C(int a1, vm_address_t a2, int a3, uint64_t a4, uint64_t a5, int a6, mach_msg_timeout_t timeout)
{
  uint64_t v10;
  _BYTE msg[28];
  vm_address_t v13;
  int v14;
  _DWORD v15[4];
  _DWORD v16[4];
  uint64_t v17;
  int v18;

  v13 = a2;
  v14 = 27918592;
  v15[0] = a3;
  *(_QWORD *)&v15[1] = a5;
  v15[3] = 27918592;
  v16[0] = a6;
  *(NDR_record_t *)&v16[1] = NDR_record;
  v16[3] = a3;
  v17 = a4;
  v18 = a6;
  *(_QWORD *)msg = 0xAAAAAAAA80000013;
  *(_DWORD *)&msg[8] = a1;
  *(_OWORD *)&msg[12] = xmmword_1001BBF10;
  if (&_voucher_mach_msg_set)
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  v10 = mach_msg((mach_msg_header_t *)msg, 2097169, 0x54u, 0, 0, timeout, 0);
  if ((_DWORD)v10 == 268435460)
  {
    if (v13 != a2)
      mig_deallocate(v13, v15[0]);
    if (*(_QWORD *)&v15[1] != a5)
      mig_deallocate(*(vm_address_t *)&v15[1], v16[0]);
  }
  return v10;
}

void sub_100029E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void *sub_10002A21C(uint64_t a1, const void *a2, int a3)
{
  const void *v6;
  const void *v7;
  const __CFArray *v8;
  void *v9;
  const __CFString *v10;
  const void *v11;
  const void *v12;
  void *v13;
  CFDataRef ExternalRepresentation;
  CFDataRef v15;
  unsigned int v16;
  const void *v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  CFTypeID TypeID;
  const __CFData *Value;
  const __CFBoolean *v23;
  const __CFBoolean *v24;
  uint64_t v25;
  const __CFBoolean *v26;
  void *v27;
  const void *v28;
  const void *v29;
  void *v30;
  const void **v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  _WORD *v37;
  const void *v38;
  __CFDictionary *Mutable;

  v6 = sub_10002BF8C(*(_QWORD *)(a1 + 64), a2);
  if (v6)
  {
    v7 = v6;
    v8 = sub_10002B170(a1, v6, 1);
    if (v8)
    {
      v9 = v8;
      if (sub_10002DA5C((_BOOL8)v7))
      {
        v10 = (const __CFString *)sub_10002B088(v7);
        v11 = sub_10002B088(v9);
        if (v10)
        {
          v12 = v11;
          if (v11)
          {
            if (!CFEqual(v10, v11))
            {
              v13 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updating known SSID %@ to connected SSID %@", "__WiFiDeviceManagerCopyCurrentNetwork", v12, v10);
              objc_autoreleasePoolPop(v13);
              sub_10002C478((uint64_t)v9, CFSTR("SSID_STR"), v10);
              ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, v10, 0x8000100u, 0);
              if (ExternalRepresentation)
              {
                v15 = ExternalRepresentation;
                sub_10002C478((uint64_t)v9, CFSTR("SSID"), ExternalRepresentation);
                CFRelease(v15);
              }
            }
          }
        }
      }
    }
    else
    {
      v9 = (void *)CFRetain(v7);
      if (!v9)
      {
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentNetworkRef:interfaceName:", 0, a2);
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentKnownNetworkRef:interfaceName:", 0, a2);
        v9 = 0;
LABEL_46:
        CFRelease(v7);
        return v9;
      }
    }
    v16 = sub_10002A724(a1, v9);
    sub_10002B698((uint64_t)v9, CFSTR("DiagnosticsBssEnv"), v16);
    sub_10002B8D8(*(_QWORD *)(a1 + 64), v9);
    v17 = sub_10002B634(*(const __CFArray **)(a1 + 3704), (const __CFDictionary **)v9);
    if (!v17)
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Network <%@> not present in Private MAC Cache", sub_10002B088(v9));
      objc_autoreleasePoolPop(v27);
      goto LABEL_24;
    }
    v18 = (uint64_t)v17;
    v19 = sub_10002BE64((uint64_t)v17, CFSTR("PRIVATE_MAC_ADDRESS"));
    if (v19)
    {
      v20 = v19;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v20))
      {
        sub_10002C478((uint64_t)v9, CFSTR("PRIVATE_MAC_ADDRESS"), v20);
        Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v20, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
        if (!sub_10002B75C(Value))
        {
          if (!sub_10002B704((uint64_t)v9))
          {
            Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            sub_10002BAD4(v18, Mutable);
            sub_10002C478((uint64_t)v9, CFSTR("PrivateMacInfoDictionary"), Mutable);
            if (Mutable)
              CFRelease(Mutable);
          }
          goto LABEL_24;
        }
        sub_10002C478((uint64_t)v9, CFSTR("PrivateMacInfoDictionary"), 0);
        v23 = (const __CFBoolean *)sub_10002BE64(v18, CFSTR("FailureThresholdMet"));
        if (v23 && (v24 = v23, v23 == kCFBooleanTrue))
        {
          if (sub_10002B704((uint64_t)v9))
            goto LABEL_24;
          v25 = (uint64_t)v9;
          v26 = v24;
        }
        else
        {
          v25 = (uint64_t)v9;
          v26 = 0;
        }
        sub_10002C478(v25, CFSTR("FailureThresholdMet"), v26);
      }
    }
LABEL_24:
    v28 = sub_10002B088(v9);
    if (v28
      && (v29 = v28, (v30 = *(void **)(a1 + 3720)) != 0)
      && (objc_msgSend(v30, "containsObject:", v29) & 1) != 0)
    {
      v31 = (const void **)&kCFBooleanTrue;
    }
    else
    {
      v31 = (const void **)&kCFBooleanFalse;
    }
    sub_10002C478((uint64_t)v9, CFSTR("AmbiguousSSIDs"), *v31);
    objc_autoreleasePoolPop(objc_autoreleasePoolPush());
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentKnownNetworkRef:interfaceName:", v9, a2);
    v32 = sub_10002BE64((uint64_t)v9, CFSTR("WPA_IE"));
    v33 = sub_10002BE64((uint64_t)v7, CFSTR("WPA_IE"));
    v34 = sub_10002BE64((uint64_t)v9, CFSTR("RSN_IE"));
    v35 = sub_10002BE64((uint64_t)v7, CFSTR("RSN_IE"));
    v36 = v35;
    if (a3 && v34 && v32 && v35 && !v33)
      sub_10002C478((uint64_t)v9, CFSTR("WPA_IE"), 0);
    v37 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
    if (v37)
    {
      v38 = v37;
      if (sub_10000BE8C((uint64_t)v7))
        sub_10002C478((uint64_t)v38, CFSTR("CARPLAY_NETWORK"), kCFBooleanTrue);
      if (v34 && v32 && v36 && !v33)
        sub_10002C478((uint64_t)v38, CFSTR("WPA_IE"), 0);
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentNetworkRef:interfaceName:", v38, a2);
      CFRelease(v38);
    }
    else
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentNetworkRef:interfaceName:", v9, a2);
    }
    goto LABEL_46;
  }
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentNetworkRef:interfaceName:", 0, a2);
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setCachedCurrentKnownNetworkRef:interfaceName:", 0, a2);
  return 0;
}

uint64_t sub_10002A724(uint64_t a1, const void *a2)
{
  CFAbsoluteTime Current;
  CFDateRef v5;
  const __CFArray *v6;
  uint64_t v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  unsigned int v17;
  const __CFArray *v18;
  const __CFArray *v19;
  uint64_t v20;
  uint64_t v21;
  CFIndex v22;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v24;
  const __CFDate *Value;
  const __CFDate *v26;
  const void *v27;
  const void *v28;
  void *v29;
  __CFArray *Mutable;
  const __CFNumber *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  BOOL v37;
  unsigned int v39;
  const void *v40;
  double v41;
  const __CFDate *v42;
  double v43;
  const __CFDate *v44;
  unsigned int v45;
  void *v46;
  void *v47;
  void *v49;
  void *v50;
  unsigned int v51;
  void *v52;
  void *v53;
  void *v54;
  const __CFString *v55;
  const void *v56;
  unsigned int v57;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const __CFArray *v63;
  const __CFArray *theArray;
  const void *v65;
  const void *v66;
  _DWORD valuePtr[3];

  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(kCFAllocatorDefault, Current);
  v6 = 0;
  v7 = 1;
  if (!a1 || !a2)
    goto LABEL_153;
  v8 = (const __CFString *)sub_10002B088(a2);
  if (*(_BYTE *)(a1 + 3788))
  {
    v9 = v8;
    v10 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)(a1 + 3789), *(unsigned __int8 *)(a1 + 3821), 0x8000100u, 0);
    v11 = v10;
    if (v10)
      v12 = v9 == 0;
    else
      v12 = 1;
    if (v12)
    {
      v13 = 0;
      if (!v10)
        goto LABEL_18;
    }
    else if (CFStringCompare(v9, v10, 0))
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFiRoam : using bssList. Network from scan results : [%@] and network ssid : [%@]", v11, v9);
      objc_autoreleasePoolPop(v14);
      v13 = 0;
    }
    else
    {
      v13 = 1;
    }
    CFRelease(v11);
  }
  else
  {
    v13 = 0;
  }
LABEL_18:
  if (*(_BYTE *)(a1 + 256) && *(_DWORD *)(a1 + 268))
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Roam test mode enabled. AP Environment is forced to type %d", *(unsigned int *)(a1 + 268));
    objc_autoreleasePoolPop(v15);
    if (v5)
      CFRelease(v5);
    return *(unsigned int *)(a1 + 268);
  }
  v16 = 2592000;
  v6 = sub_10002B170(a1, a2, 1);
  if (*(_BYTE *)(a1 + 256))
  {
    v60 = *(unsigned int *)(a1 + 260);
    v17 = *(_DWORD *)(a1 + 264);
    if (v17)
      v16 = v17;
    else
      v16 = 2592000;
  }
  else
  {
    v60 = 259200;
  }
  v66 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
  v18 = (const __CFArray *)sub_10002B750((uint64_t)a2);
  v19 = v18;
  if ((_DWORD)v13 || v18)
  {
    v62 = v13;
    v63 = v6;
    v65 = a2;
    if (v18)
    {
      if (CFArrayGetCount(v18) < 1)
      {
        theArray = 0;
        v21 = 0;
        v61 = 0;
        v20 = 0;
      }
      else
      {
        v20 = 0;
        v61 = 0;
        v21 = 0;
        v22 = 0;
        theArray = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v19, v22);
          if (ValueAtIndex)
          {
            v24 = ValueAtIndex;
            Value = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, CFSTR("lastRoamed"));
            if (Value)
            {
              v26 = Value;
              v27 = CFDictionaryGetValue(v24, CFSTR("BSSID"));
              if (v27)
              {
                if (!v66
                  || (v28 = v27, CFEqual(v66, v27))
                  || CFDateGetTimeIntervalSinceDate(v5, v26) <= (double)v16)
                {
                  v31 = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("CHANNEL_FLAGS"));
                  if (v31)
                  {
                    valuePtr[0] = 0;
                    CFNumberGetValue(v31, kCFNumberIntType, valuePtr);
                    if ((valuePtr[0] & 8) != 0)
                    {
                      v21 = (v21 + 1);
                    }
                    else if ((valuePtr[0] & 0x10) != 0)
                    {
                      v61 = (v61 + 1);
                    }
                    else
                    {
                      v20 = ((valuePtr[0] >> 13) & 1) + v20;
                    }
                  }
                }
                else
                {
                  v29 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BSSID %@ has not been seen for more than %d secs.", "__WiFiDeviceManagerEvaluateAPEnvironment", v28, v16);
                  objc_autoreleasePoolPop(v29);
                  Mutable = theArray;
                  if (theArray
                    || (Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) != 0)
                  {
                    theArray = Mutable;
                    CFArrayAppendValue(Mutable, v28);
                  }
                  else
                  {
                    theArray = 0;
                  }
                }
              }
            }
          }
          ++v22;
        }
        while (v22 < CFArrayGetCount(v19));
      }
      v33 = objc_autoreleasePoolPush();
      v32 = v61;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : BSS List info for network : %@ : chanCount5GHz: [%d] chanCount24GHz: [%d] chanCount6GHz: [%d]", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65), v61, v21, v20);
      objc_autoreleasePoolPop(v33);
      if ((_DWORD)v62)
      {
        if (v21 <= *(unsigned __int8 *)(a1 + 3822))
          v21 = *(unsigned __int8 *)(a1 + 3822);
        else
          v21 = v21;
        if (v61 <= *(unsigned __int8 *)(a1 + 3823))
          v32 = *(unsigned __int8 *)(a1 + 3823);
        else
          v32 = v61;
        if (v20 <= *(unsigned __int8 *)(a1 + 3824))
          v20 = *(unsigned __int8 *)(a1 + 3824);
        else
          v20 = v20;
      }
    }
    else
    {
      theArray = 0;
      v21 = *(unsigned __int8 *)(a1 + 3822);
      v32 = *(unsigned __int8 *)(a1 + 3823);
      v20 = *(unsigned __int8 *)(a1 + 3824);
    }
    v34 = (v32 + v21 + v20);
    if (sub_10002BF80(*(_QWORD *)(a1 + 64)))
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : AP environment for network : %@ : bssCount: [%d] chanCount5GHz: [%d] chanCount24GHz: [%d] chanCount6GHz: [%d]", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65), v34, v32, v21, v20);
      objc_autoreleasePoolPop(v35);
      if (v34 >= 4)
      {
        v36 = 0;
        if ((_DWORD)v20)
          v37 = (_DWORD)v21 == 0;
        else
          v37 = 1;
        if (v37 || (_DWORD)v32 == 0)
          v7 = 4;
        else
          v7 = 6;
        goto LABEL_129;
      }
      if ((_DWORD)v34 == 3 || v32 > 1 || v21 > 1 || v20 >= 2)
      {
        if (v20 <= 1)
          v45 = 5;
        else
          v45 = 6;
        if ((_DWORD)v20)
          v7 = v45;
        else
          v7 = 4;
        v36 = 1;
LABEL_129:
        if ((_DWORD)v20 && _os_feature_enabled_impl("CoreWiFi", "WiFi6E"))
        {
          if ((_DWORD)v7 == 4)
            v51 = 6;
          else
            v51 = v7;
          if (v51 == 3)
            v7 = 5;
          else
            v7 = v51;
        }
        goto LABEL_137;
      }
      if (v63)
      {
        v43 = sub_10002DFE4((uint64_t)v63);
        v44 = (const __CFDate *)sub_10002E000(v63);
        if (v44)
        {
          v43 = v43 + CFDateGetTimeIntervalSinceDate(v5, v44);
LABEL_123:
          if (v43 < (double)v60)
          {
            v53 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : network usage requirement has not been met (%f < %d). Returning learning environment.", "__WiFiDeviceManagerEvaluateAPEnvironment", *(_QWORD *)&v43, v60);
            v7 = 1;
            v40 = v65;
            v6 = v63;
            goto LABEL_150;
          }
          if ((_DWORD)v34 == 2)
          {
            v36 = 0;
            v7 = 3;
          }
          else
          {
            v36 = 0;
            if ((_DWORD)v34 == 1)
              v7 = 2;
            else
              v7 = 1;
          }
          goto LABEL_129;
        }
      }
      else
      {
        v49 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network : %@ is not in known network list", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65));
        objc_autoreleasePoolPop(v49);
        v43 = 0.0;
      }
      v50 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : failed to get last association date for %@.", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65));
      objc_autoreleasePoolPop(v50);
      goto LABEL_123;
    }
    v39 = v32;
    v36 = 0;
    v7 = 4;
    if (v34 > 2)
    {
LABEL_137:
      v40 = v65;
      goto LABEL_138;
    }
    v40 = v65;
    if (v39 > 1 || v21 > 1)
    {
LABEL_138:
      v6 = v63;
      if (v63 && sub_10002DB7C((uint64_t)v63))
      {
        if ((_DWORD)v7 == 5)
        {
          v52 = objc_autoreleasePoolPush();
          v7 = 3;
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : AP environment downgraded from TriBandSingleAP to DualBandSingleAp due to 6Emode", "__WiFiDeviceManagerEvaluateAPEnvironment");
        }
        else
        {
          if ((_DWORD)v7 != 6)
            goto LABEL_148;
          v52 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiRoam : AP environment downgraded from TriBandMultiAP to MultiAp due to 6Emode", "__WiFiDeviceManagerEvaluateAPEnvironment");
          v7 = 4;
        }
        objc_autoreleasePoolPop(v52);
      }
LABEL_148:
      v53 = objc_autoreleasePoolPush();
      v54 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v55 = sub_10002B5A4(v7);
        v56 = sub_10002B088(v40);
        v57 = sub_10002DC14(*(_QWORD *)(a1 + 64));
        objc_msgSend(v54, "WFLog:message:", 3, "%s: WiFiRoam : AP environment is %@ for %@(%@). Last applied environment is %@. Early exit ? : [%hhu]. augmented from scan results ? : [%hhu]", "__WiFiDeviceManagerEvaluateAPEnvironment", v55, v56, v66, sub_10002B5A4(v57), v36, v62);
      }
LABEL_150:
      objc_autoreleasePoolPop(v53);
      goto LABEL_151;
    }
    if (v63)
    {
      v41 = sub_10002DFE4((uint64_t)v63);
      v42 = (const __CFDate *)sub_10002E000(v63);
      if (v42)
      {
        v41 = v41 + CFDateGetTimeIntervalSinceDate(v5, v42);
LABEL_108:
        if (v41 < (double)v60)
        {
          v7 = 1;
          v6 = v63;
LABEL_151:
          if (theArray)
          {
            sub_1000C7018((uint64_t)v40, theArray);
            CFRelease(theArray);
          }
LABEL_153:
          if (!v5)
            goto LABEL_155;
          goto LABEL_154;
        }
        if ((_DWORD)v34 == 1)
        {
          v36 = 0;
          v7 = 2;
        }
        else
        {
          v36 = 0;
          if ((_DWORD)v21 == 1 && v39 == 1)
            v7 = 3;
          else
            v7 = 1;
        }
        goto LABEL_138;
      }
    }
    else
    {
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network : %@ is not in known network list", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65));
      objc_autoreleasePoolPop(v46);
      v41 = 0.0;
    }
    v47 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get last association date for %@.", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_10002B088(v65));
    objc_autoreleasePoolPop(v47);
    goto LABEL_108;
  }
  v59 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no known BSS for this network. Learning environment.", "__WiFiDeviceManagerEvaluateAPEnvironment");
  objc_autoreleasePoolPop(v59);
  v7 = 1;
  if (!v5)
    goto LABEL_155;
LABEL_154:
  CFRelease(v5);
LABEL_155:
  if (v6)
    CFRelease(v6);
  return v7;
}

const void *sub_10002B088(const void *result)
{
  uint64_t v1;
  const __CFData *v2;
  const __CFData *v3;
  CFStringRef v4;

  if (result)
  {
    v1 = (uint64_t)result;
    result = sub_10002BE64((uint64_t)result, CFSTR("SSID_STR"));
    if (!result)
    {
      v2 = (const __CFData *)sub_10002BE64(v1, CFSTR("SSID"));
      if (v2
        && ((v3 = v2, (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v2, 0x8000100u)) != 0)
         || (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v3, 0)) != 0)
        || (v4 = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u)) != 0)
      {
        sub_10002C478(v1, CFSTR("SSID_STR"), v4);
        CFRelease(v4);
      }
      return sub_10002BE64(v1, CFSTR("SSID_STR"));
    }
  }
  return result;
}

const __CFArray *sub_10002B170(uint64_t a1, const void *a2, int a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const __CFArray *v9;
  void *v10;
  CFRange v12;

  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL!", "__WiFiDeviceManagerCopyMatchingMergedNetwork");
    goto LABEL_13;
  }
  if (!a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is NULL!", "__WiFiDeviceManagerCopyMatchingMergedNetwork");
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return 0;
  }
  v5 = (const __CFArray *)sub_1000A4578(*(_QWORD *)(a1 + 6792));
  v6 = v5;
  if (!v5)
    return v6;
  v12.length = CFArrayGetCount(v5);
  v12.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v12, a2);
  if (FirstIndexOfValue == -1)
    return 0;
  ValueAtIndex = CFArrayGetValueAtIndex(v6, FirstIndexOfValue);
  if (!ValueAtIndex)
    return 0;
  v9 = (const __CFArray *)sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
  v6 = v9;
  if (a3 && v9)
    sub_10002B290((uint64_t)v9, (uint64_t)a2);
  return v6;
}

void sub_10002B290(uint64_t a1, uint64_t a2)
{
  int v4;

  if (a2)
  {
    sub_10002D42C((CFMutableDictionaryRef *)a1, *(CFDictionaryRef *)(a2 + 16));
    if (*(__int16 *)(a1 + 24) == -1)
    {
      v4 = *(unsigned __int16 *)(a2 + 24);
      if (v4 != 0xFFFF)
        *(_WORD *)(a1 + 24) = v4;
    }
  }
}

_WORD *sub_10002B2DC(uint64_t a1, uint64_t a2)
{
  _WORD *result;

  result = sub_10002B314((uint64_t)kCFAllocatorDefault, *(CFTypeRef *)(a2 + 16));
  result[12] = *(_WORD *)(a2 + 24);
  return result;
}

_WORD *sub_10002B314(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  const __CFString *Value;
  CFTypeID TypeID;
  const void *v7;
  const void *v8;
  CFTypeID v9;
  uint64_t Instance;
  _WORD *v11;
  CFMutableDictionaryRef *v12;
  const __CFDictionary *MutableCopy;
  CFBooleanRef v14;
  BOOL v15;
  CFBooleanRef v16;
  void *v18;
  uint64_t v19;

  if (!cf)
    goto LABEL_9;
  v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: record is of type %ld!!", "__WiFiNetworkIsRecordValid", CFGetTypeID(cf));
    goto LABEL_29;
  }
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("SSID_STR"));
  if (Value)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(Value))
      return 0;
  }
  if (!sub_10002B550(Value) && !CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DomainName")))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSID not valid length", "__WiFiNetworkIsRecordValid", v19);
LABEL_29:
    objc_autoreleasePoolPop(v18);
    return 0;
  }
  v7 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("SSID"));
  if (v7)
  {
    v8 = v7;
    v9 = CFDataGetTypeID();
    if (v9 != CFGetTypeID(v8))
      return 0;
  }
LABEL_9:
  if (!qword_10026D6C8)
    pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
  Instance = _CFRuntimeCreateInstance(a1);
  v11 = (_WORD *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = 0;
    *(_QWORD *)(Instance + 24) = 0;
    v12 = (CFMutableDictionaryRef *)(Instance + 16);
    if (cf)
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)cf);
    else
      MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *v12 = MutableCopy;
    if (MutableCopy)
    {
      v14 = (CFBooleanRef)CFDictionaryGetValue(MutableCopy, CFSTR("HIDDEN_NETWORK"));
      if (v14)
        v15 = v14 == kCFBooleanTrue;
      else
        v15 = 0;
      if (v15)
      {
        v16 = v14;
        CFDictionaryRemoveValue(*v12, CFSTR("HIDDEN_NETWORK"));
        CFDictionarySetValue(*v12, CFSTR("UserDirected"), v16);
      }
      v11[12] = -1;
      return v11;
    }
    CFRelease(v11);
    return 0;
  }
  return v11;
}

BOOL sub_10002B550(const __CFString *a1)
{
  if (!a1)
    return 1;
  if (CFEqual(a1, CFSTR("_AppleWi-FiInternetTetheringSSID_")))
    return 1;
  return CFStringGetLength(a1) < 33;
}

const __CFString *sub_10002B5A4(unsigned int a1)
{
  if (a1 > 6)
    return CFSTR("Unknown");
  else
    return off_10022F588[a1];
}

void sub_10002B5C8(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

const void *sub_10002B634(const __CFArray *a1, const __CFDictionary **a2)
{
  const void *result;
  uint64_t v4;
  CFIndex idx;

  result = 0;
  v4 = 0;
  idx = -1;
  if (a1 && a2)
  {
    sub_10002B7AC(a1, a2, &idx, &v4);
    if (idx == -1)
      return 0;
    else
      return CFArrayGetValueAtIndex(a1, idx);
  }
  return result;
}

void sub_10002B698(uint64_t a1, void *a2, uint64_t a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (v5)
  {
    v6 = v5;
    sub_10002C478(a1, a2, v5);
    CFRelease(v6);
  }
}

const __CFNumber *sub_10002B704(uint64_t a1)
{
  const __CFNumber *result;
  __int16 valuePtr;

  result = (const __CFNumber *)sub_10002BE64(a1, CFSTR("AP_MODE"));
  if (result)
  {
    valuePtr = -21846;
    result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt16Type, &valuePtr);
    if ((_DWORD)result)
      return (const __CFNumber *)(valuePtr == 1);
  }
  return result;
}

const void *sub_10002B750(uint64_t a1)
{
  return sub_10002BE64(a1, CFSTR("networkKnownBSSListKey"));
}

const __CFData *sub_10002B75C(const __CFData *result)
{
  const __CFData *v1;
  CFTypeID TypeID;

  if (result)
  {
    v1 = result;
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v1))
      return (const __CFData *)((*CFDataGetBytePtr(v1) >> 1) & 1);
    else
      return 0;
  }
  return result;
}

void sub_10002B7AC(const __CFArray *a1, const __CFDictionary **a2, CFIndex *a3, _QWORD *a4)
{
  CFIndex Count;
  uint64_t v9;
  CFTypeID v10;
  uint64_t v11;
  CFIndex v12;
  CFTypeRef *ValueAtIndex;
  void *v14;

  if (!a1)
    goto LABEL_12;
  Count = CFArrayGetCount(a1);
  if (!Count)
    goto LABEL_12;
  if (!a2)
    goto LABEL_18;
  v9 = Count;
  v10 = CFGetTypeID(a2);
  v11 = qword_10026D6C8;
  if (!qword_10026D6C8)
  {
    pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
    v11 = qword_10026D6C8;
  }
  if (v10 != v11)
  {
LABEL_18:
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid network ref", "WiFiGetPrivateMacNetworkIndices");
    objc_autoreleasePoolPop(v14);
    goto LABEL_12;
  }
  if (v9 < 1)
  {
LABEL_12:
    v12 = -1;
    goto LABEL_13;
  }
  v12 = 0;
  while (1)
  {
    ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(a1, v12);
    if (ValueAtIndex)
    {
      if (sub_10002D2A0(ValueAtIndex[2], a2[2], CFSTR("SSID_STR")))
        break;
    }
    if (v9 == ++v12)
      goto LABEL_12;
  }
LABEL_13:
  if (a4)
    *a4 = 0;
  if (a3)
    *a3 = v12;
}

void sub_10002B8D8(uint64_t a1, const void *a2)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const void *v9;
  const void *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  const __CFString *v17;
  const char *v18;
  void *v19;
  const __CFString *v20;

  if (!a1 || !a2)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v18 = "Device";
    if (!a2)
      v18 = "Network";
    v19 = (void *)v18;
    v15 = "%s: %s is NULL";
    goto LABEL_13;
  }
  v4 = (const __CFString *)sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
  if (!v4)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v15 = "%s: bssid is NULL!";
    goto LABEL_27;
  }
  v5 = v4;
  v6 = (const __CFString *)sub_10002B088(a2);
  if (!v6)
  {
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v15 = "%s: ssid is NULL!";
LABEL_27:
    v16 = 4;
    goto LABEL_14;
  }
  v7 = v6;
  v8 = *(const __CFString **)(a1 + 5880);
  if (!v8)
  {
LABEL_9:
    v10 = *(const void **)(a1 + 5888);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 5888) = 0;
    }
    v11 = (const __CFString *)sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    *(_QWORD *)(a1 + 5880) = CFStringCreateCopy(kCFAllocatorDefault, v11);
    v12 = (const __CFString *)sub_10002B088(a2);
    *(_QWORD *)(a1 + 5888) = CFStringCreateCopy(kCFAllocatorDefault, v12);
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v19 = (void *)v7;
    v20 = v5;
    v15 = "%s: LastLinkedBSSInfo updated to: {%@},{%@}";
LABEL_13:
    v16 = 3;
LABEL_14:
    objc_msgSend(v14, "WFLog:message:", v16, v15, "WiFiDeviceRecordLastLinkedBSSInfo", v19, v20);
LABEL_15:
    objc_autoreleasePoolPop(v13);
    return;
  }
  if (CFStringCompare(v8, v5, 1uLL)
    || (v17 = *(const __CFString **)(a1 + 5888)) == 0
    || CFStringCompare(v17, v7, 0))
  {
    v9 = *(const void **)(a1 + 5880);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 5880) = 0;
    }
    goto LABEL_9;
  }
}

void sub_10002BAD4(uint64_t a1, __CFDictionary *a2)
{
  const void *v4;
  const void *v5;
  CFBooleanRef v6;
  const __CFBoolean *v7;
  double v8;
  double v9;
  const void *v10;
  const __CFDictionary *v11;
  const void *v12;
  const __CFNumber *v13;
  unsigned int v14;
  CFBooleanRef v15;
  CFBooleanRef v16;
  BOOL v17;
  CFBooleanRef v18;
  uint64_t v19;
  const __CFBoolean *v25;
  const __CFBoolean *v26;
  const __CFBoolean *v27;
  const __CFBoolean *v28;
  const __CFBoolean *v29;
  const __CFBoolean *value;
  void *v31;
  void *v32;

  if (a1 && a2)
  {
    v29 = kCFBooleanFalse;
    value = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
    v4 = sub_10002BE64(a1, CFSTR("isHs20BasedNetwork"));
    v5 = sub_10002BE64(a1, CFSTR("DomainName"));
    v26 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("isProfileBasedNetwork"));
    v6 = (CFBooleanRef)sub_10002BE64(a1, CFSTR("PrivateMacDefaultToOFF"));
    v31 = (void *)sub_10002BE64(a1, CFSTR("isCarrierBundleBased"));
    v32 = (void *)sub_10002BE64(a1, CFSTR("DisplayedOperatorName"));
    v28 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("FeatureOffBySystemForHome"));
    v27 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("FeatureOFFBySystemForFrequentlyUsedNetworks"));
    v7 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("FeatureOffBySystemForCarplay"));
    objc_msgSend((id)sub_10002BE64(a1, CFSTR("PrivateMacJoinDateAfterUpgrade")), "timeIntervalSinceNow");
    v9 = v8;
    v25 = (const __CFBoolean *)sub_10002BE64(a1, CFSTR("ExperiencedFallback"));
    v10 = sub_10002BE64(a1, CFSTR("PrivateMacControlledDevice"));
    v11 = (const __CFDictionary *)sub_10002BE64(a1, CFSTR("PRIVATE_MAC_ADDRESS"));
    v12 = v4;
    if (v11 && (v13 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"))) != 0)
    {
      v14 = sub_100064F80(v13);
      v15 = (CFBooleanRef)sub_10002BE64(a1, CFSTR("PrivateMacPrefChanged"));
      v16 = value;
      if (v15)
      {
        v17 = v14 == 1 && v15 == kCFBooleanTrue;
        v18 = kCFBooleanFalse;
        if (v17)
          v18 = kCFBooleanTrue;
        v29 = v18;
      }
    }
    else
    {
      v16 = value;
    }
    if (v10)
      CFDictionarySetValue(a2, CFSTR("PrivateMacControlledDevice"), v10);
    if (v6)
      CFDictionarySetValue(a2, CFSTR("PrivateMacDefaultToOFF"), v6);
    if (v5)
      CFDictionarySetValue(a2, CFSTR("DomainName"), v5);
    if (v16)
      CFDictionarySetValue(a2, CFSTR("MacAddressRandomisationTagMigratedNetwork"), v16);
    if (v12)
      CFDictionarySetValue(a2, CFSTR("isHs20BasedNetwork"), v12);
    if (v31)
      CFDictionarySetValue(a2, CFSTR("isCarrierBundleBased"), v31);
    if (v32)
      CFDictionarySetValue(a2, CFSTR("DisplayedOperatorName"), v32);
    if (v7 && v7 == kCFBooleanTrue)
    {
      v19 = 5;
    }
    else if (v28 && v28 == kCFBooleanTrue || v27 && v27 == kCFBooleanTrue)
    {
      v19 = 4;
    }
    else
    {
      if (!v29 || v29 != kCFBooleanTrue)
      {
        if (v26)
        {
          v19 = v26 == kCFBooleanTrue && v6 == kCFBooleanTrue && v6 != 0;
          if (!v16 || (v19 & 1) != 0)
            goto LABEL_35;
        }
        else if (!v16)
        {
          v19 = 0;
          goto LABEL_35;
        }
        if (v25 == kCFBooleanTrue && v25 != 0 && v9 < -86400.0 && v16 == kCFBooleanTrue)
          v19 = 2;
        else
          v19 = 0;
        goto LABEL_35;
      }
      v19 = 3;
    }
LABEL_35:
    sub_10002B5C8(a2, CFSTR("PrivateMacDisbaleReason"), v19);
  }
}

const void *sub_10002BE64(uint64_t a1, void *key)
{
  const __CFDictionary *v3;
  const __CFArray *v5;
  int v6;
  const __CFDictionary *Value;
  void *v9;
  CFRange v10;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetProperty");
    goto LABEL_12;
  }
  v3 = *(const __CFDictionary **)(a1 + 16);
  if (!v3)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network record", "WiFiNetworkGetProperty");
LABEL_12:
    objc_autoreleasePoolPop(v9);
    return 0;
  }
  v5 = (const __CFArray *)qword_10026D6D0;
  if (!qword_10026D6D0)
    return CFDictionaryGetValue(v3, key);
  v10.length = CFArrayGetCount((CFArrayRef)qword_10026D6D0);
  v10.location = 0;
  v6 = CFArrayContainsValue(v5, v10, key);
  v3 = *(const __CFDictionary **)(a1 + 16);
  if (!v6)
    return CFDictionaryGetValue(v3, key);
  Value = (const __CFDictionary *)CFDictionaryGetValue(v3, CFSTR("EnterpriseProfile"));
  if (Value)
  {
    v3 = (const __CFDictionary *)CFDictionaryGetValue(Value, CFSTR("EAPClientConfiguration"));
    if (v3)
      return CFDictionaryGetValue(v3, key);
  }
  return 0;
}

uint64_t sub_10002BF80(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 39) >> 6) & 1;
}

const void *sub_10002BF8C(uint64_t a1, const void *a2)
{
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  CFTypeID v7;
  void *v8;
  const void *v9;
  double Current;
  double v11;
  const __CFDictionary *v12;
  CFAllocatorRef v13;
  const __CFDictionary *Copy;
  int i;
  int v16;
  int v17;
  const void *v19;
  CFDictionaryRef v20;
  double v21;
  _WORD *v22;
  const void **v23;
  void *v24;
  void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const char *v29;
  const void *v30;
  const void *v31;
  uint64_t v32;
  const __CFArray *v33;
  CFIndex v34;
  const void *ValueAtIndex;
  const __CFArray *v36;
  const __CFArray *v37;
  CFIndex v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  const __CFString *Value;
  const __CFString *v42;
  const __CFString *v43;
  const void *v44;
  uint64_t v46;
  uint64_t v47;
  CFDictionaryRef theDict;

  theDict = 0;
  if (!a1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "nil device", v46, v47);
    goto LABEL_10;
  }
  v4 = *(NSObject **)(a1 + 64);
  if (v4)
    dispatch_assert_queue_V2(v4);
  v5 = sub_10002DEA0(a1, a2);
  if (!v5)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2, v47);
    goto LABEL_10;
  }
  v6 = (uint64_t)v5;
  v7 = CFGetTypeID(v5);
  if (v7 == sub_10002DE64())
  {
    if (sub_10015D690(v6, &theDict))
      goto LABEL_11;
    goto LABEL_35;
  }
  Current = CFAbsoluteTimeGetCurrent();
  if (*(_BYTE *)(a1 + 5904))
  {
    v11 = *(double *)(a1 + 5912);
    if (v11 != 0.0 && Current > v11 && Current - v11 < 1.0)
    {
      v12 = *(const __CFDictionary **)(a1 + 5920);
      if (v12)
      {
        v13 = kCFAllocatorDefault;
        Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v12);
        theDict = Copy;
        goto LABEL_36;
      }
      theDict = 0;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Cached current network is NULL on interface %@", "WiFiDeviceCopyCurrentNetwork", a2);
LABEL_10:
      objc_autoreleasePoolPop(v8);
LABEL_11:
      v9 = 0;
      goto LABEL_77;
    }
  }
  for (i = 6; ; --i)
  {
    v16 = Apple80211CopyCurrentNetwork(*(_QWORD *)(a1 + 16), &theDict);
    v17 = v16;
    if (v16 != -3905 && v16 != 61 && v16 != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  v19 = *(const void **)(a1 + 5920);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  if (theDict)
  {
    v20 = CFDictionaryCreateCopy(kCFAllocatorDefault, theDict);
    v21 = 0.0;
    if (theDict)
      v21 = Current;
  }
  else
  {
    v20 = 0;
    v21 = 0.0;
  }
  *(_QWORD *)(a1 + 5920) = v20;
  *(double *)(a1 + 5912) = v21;
  if (v17)
    goto LABEL_11;
LABEL_35:
  v13 = kCFAllocatorDefault;
  Copy = theDict;
LABEL_36:
  v22 = sub_10002B314((uint64_t)v13, Copy);
  v9 = v22;
  if (v22)
  {
    v23 = (const void **)&kCFBooleanTrue;
    if (*(_DWORD *)(a1 + 5936))
      v23 = (const void **)&kCFBooleanFalse;
    sub_10002C478((uint64_t)v22, CFSTR("WiFiNetworkIsAutoJoined"), *v23);
    if (sub_10002DA5C((_BOOL8)v9) && !sub_1000C9A40((uint64_t)v9))
    {
      v24 = objc_autoreleasePoolPush();
      v25 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v26 = sub_10002B088(v9);
        v27 = sub_10002B088(*(const void **)(a1 + 5832));
        v28 = sub_1000C9A40(*(_QWORD *)(a1 + 5832));
        v29 = "present";
        if (!v28)
          v29 = "not present";
        objc_msgSend(v25, "WFLog:message:", 3, "%s: attempting to match current HS2.0 network %@ with last attempted network %@, GAS response is %s", "WiFiDeviceCopyCurrentNetwork", v26, v27, v29);
      }
      objc_autoreleasePoolPop(v24);
      v30 = *(const void **)(a1 + 5832);
      if (v30 && CFEqual(v30, v9) && sub_1000C9A40(*(_QWORD *)(a1 + 5832)))
      {
        v31 = sub_1000C9A40(*(_QWORD *)(a1 + 5832));
        v32 = (uint64_t)v9;
LABEL_66:
        sub_1000C9ACC(v32, v31);
      }
      else
      {
        v33 = *(const __CFArray **)(a1 + 5752);
        if (v33)
        {
          v34 = 0;
          while (v34 < CFArrayGetCount(v33))
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5752), v34);
            if (ValueAtIndex)
            {
              v36 = (const __CFArray *)sub_1000C053C((uint64_t)ValueAtIndex);
              if (v36)
              {
                v37 = v36;
                if (CFArrayGetCount(v36) >= 1)
                {
                  v38 = 0;
                  while (1)
                  {
                    v39 = (const __CFDictionary *)CFArrayGetValueAtIndex(v37, v38);
                    if (v39)
                    {
                      v40 = v39;
                      Value = (const __CFString *)CFDictionaryGetValue(v39, CFSTR("BSSID"));
                      if (Value)
                      {
                        v42 = Value;
                        if (sub_10001F1E8((const __CFArray *)v9))
                        {
                          v43 = (const __CFString *)sub_10001F1E8((const __CFArray *)v9);
                          if (CFStringCompare(v42, v43, 1uLL) == kCFCompareEqualTo)
                            break;
                        }
                      }
                    }
                    if (++v38 >= CFArrayGetCount(v37))
                      goto LABEL_61;
                  }
                  v32 = (uint64_t)v9;
                  v31 = v40;
                  goto LABEL_66;
                }
              }
            }
LABEL_61:
            ++v34;
            v33 = *(const __CFArray **)(a1 + 5752);
            if (!v33)
              break;
          }
        }
      }
    }
    if (!*(_QWORD *)(a1 + 5816))
      sub_100070CD8(a1, v9, 1);
    if (!*(_QWORD *)(a1 + 5824))
    {
      sub_100070DDC(a1, (uint64_t)v9);
      v44 = *(const void **)(a1 + 5832);
      if (v44)
      {
        CFRelease(v44);
        *(_QWORD *)(a1 + 5832) = 0;
      }
      *(_QWORD *)(a1 + 5832) = sub_10002B2DC((uint64_t)v13, (uint64_t)v9);
    }
    sub_10002C478((uint64_t)v9, CFSTR("WiFiNetworkRouterMac"), *(const void **)(a1 + 4328));
    sub_10002C478((uint64_t)v9, CFSTR("WiFiNetworkRouterIP"), *(const void **)(a1 + 4336));
    if (*(_BYTE *)(a1 + 272))
      sub_10002C478((uint64_t)v9, CFSTR("SNR"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 280)));
    if (*(_BYTE *)(a1 + 307))
      sub_10002C478((uint64_t)v9, CFSTR("CCA"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(a1 + 308)));
  }
LABEL_77:
  if (theDict)
    CFRelease(theDict);
  return v9;
}

void sub_10002C478(uint64_t a1, void *key, const void *a3)
{
  const __CFDictionary *v4;
  const __CFArray *v7;
  int v8;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  __CFDictionary *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  __CFDictionary *v19;
  _BOOL4 v20;
  unsigned int v21;
  int v22;
  CFAbsoluteTime Current;
  CFDateRef v24;
  CFDateRef v25;
  char v26;
  void *v27;
  CFRange v28;

  if (!a1)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetProperty");
    goto LABEL_45;
  }
  v4 = *(const __CFDictionary **)(a1 + 16);
  if (!v4)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network record", "WiFiNetworkSetProperty");
LABEL_45:
    objc_autoreleasePoolPop(v27);
    return;
  }
  v7 = (const __CFArray *)qword_10026D6D0;
  if (qword_10026D6D0
    && (v28.length = CFArrayGetCount((CFArrayRef)qword_10026D6D0),
        v28.location = 0,
        v8 = CFArrayContainsValue(v7, v28, key),
        v4 = *(const __CFDictionary **)(a1 + 16),
        v8))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("EnterpriseProfile"));
    if (!Value || (v10 = Value, (MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value)) == 0))
    {
      v20 = 0;
      v17 = 0;
      goto LABEL_28;
    }
    v12 = MutableCopy;
    v13 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("EAPClientConfiguration"));
    if (v13 && (v14 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v13)) != 0)
    {
      v15 = v14;
      v16 = CFDictionaryGetValue(v14, key);
      v17 = v16;
      if (v16)
        CFRetain(v16);
      CFDictionarySetValue(v15, key, a3);
      CFDictionarySetValue(v12, CFSTR("EAPClientConfiguration"), v15);
      CFRelease(v15);
    }
    else
    {
      v17 = 0;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("EnterpriseProfile"), v12);
    CFRelease(v12);
  }
  else
  {
    v18 = CFDictionaryGetValue(v4, key);
    v17 = v18;
    if (v18)
      CFRetain(v18);
    v19 = *(__CFDictionary **)(a1 + 16);
    if (a3)
      CFDictionarySetValue(v19, key, a3);
    else
      CFDictionaryRemoveValue(v19, key);
    if (CFEqual(key, CFSTR("EnterpriseProfile")) && !sub_10002D01C(*(const __CFDictionary **)(a1 + 16)))
    {
      v21 = sub_10002CFA8(*(const __CFDictionary **)(a1 + 16));
      v22 = sub_10003145C(a1);
      if (v21)
        sub_1000C434C(a1, 1, v22);
      else
        sub_1000C44C4(a1, v22);
    }
  }
  v20 = v17 != 0;
  if (!a3 && v17)
  {
LABEL_27:
    v20 = 1;
    goto LABEL_30;
  }
LABEL_28:
  if (!a3 || v17)
  {
    v26 = !v20;
    if (!a3)
      v26 = 1;
    if ((v26 & 1) != 0)
      goto LABEL_38;
    if (CFEqual(a3, v17))
      goto LABEL_39;
    goto LABEL_27;
  }
LABEL_30:
  Current = CFAbsoluteTimeGetCurrent();
  v24 = CFDateCreate(kCFAllocatorDefault, Current);
  if (v24)
  {
    v25 = v24;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("lastUpdated"), v24);
    CFRelease(v25);
    if (!v20)
      return;
LABEL_39:
    CFRelease(v17);
    return;
  }
LABEL_38:
  if (v20)
    goto LABEL_39;
}

const __CFArray *sub_10002C798(uint64_t a1, int a2)
{
  const __CFArray *result;
  const __CFArray *v4;
  const void *v5;
  CFIndex FirstIndexOfValue;
  int valuePtr;
  CFRange v8;

  valuePtr = a2;
  result = (const __CFArray *)sub_10002DAB4(a1);
  if ((_DWORD)result)
  {
    result = (const __CFArray *)sub_10002BE64(a1, CFSTR("AcceptEAPTypes"));
    if (result)
    {
      v4 = result;
      result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (result)
      {
        v5 = result;
        v8.length = CFArrayGetCount(v4);
        v8.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v8, v5);
        CFRelease(v5);
        return (const __CFArray *)(FirstIndexOfValue != -1);
      }
    }
  }
  return result;
}

BOOL sub_10002C830(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  CFTypeID v5;
  uint64_t v6;
  const void *v7;
  CFTypeID v8;
  uint64_t v9;
  const void *v10;
  CFTypeID TypeID;
  uint64_t v12;
  CFTypeID v13;
  uint64_t v14;
  int v15;
  const __CFNumber *v16;
  unsigned int v17;
  const __CFNumber *v18;
  unsigned int v19;
  BOOL v20;
  const __CFString *v21;
  const __CFString *v22;
  void *v23;
  int v25;
  CFBooleanRef Value;
  CFBooleanRef v27;
  CFBooleanRef v28;
  unint64_t v29;
  int v30;
  int v31;
  const __CFBoolean *v32;
  _BOOL4 v33;
  int v34;
  CFBooleanRef v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _BOOL4 v40;
  int v41;
  _BOOL4 v42;
  int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;

  v2 = 0;
  if (a1)
  {
    v3 = a2;
    if (a2)
    {
      v4 = a1;
      v5 = CFGetTypeID(a1);
      v6 = qword_10026D6C8;
      if (!qword_10026D6C8)
      {
        pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
        v6 = qword_10026D6C8;
      }
      if (v5 == v6)
        v7 = v4;
      else
        v7 = 0;
      v8 = CFGetTypeID(v3);
      v9 = qword_10026D6C8;
      if (!qword_10026D6C8)
      {
        pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
        v9 = qword_10026D6C8;
      }
      if (v8 == v9)
        v10 = v3;
      else
        v10 = 0;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(v4))
      {
        v12 = qword_10026D6C8;
        if (!qword_10026D6C8)
        {
          pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
          v12 = qword_10026D6C8;
        }
        if (v12 == CFGetTypeID(v4))
          v4 = (_QWORD *)v4[2];
        else
          v4 = 0;
      }
      v13 = CFDictionaryGetTypeID();
      if (v13 != CFGetTypeID(v3))
      {
        v14 = qword_10026D6C8;
        if (!qword_10026D6C8)
        {
          pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
          v14 = qword_10026D6C8;
        }
        if (v14 != CFGetTypeID(v3))
          return 0;
        v3 = (_QWORD *)v3[2];
      }
      v2 = 0;
      if (v4)
      {
        if (v3)
        {
          if (sub_10002D248(v4, (const __CFDictionary *)v3))
          {
            if (sub_10002DA5C((_BOOL8)v7) && !sub_10002DA5C((_BOOL8)v10)
              || !sub_10002DA5C((_BOOL8)v7) && sub_10002DA5C((_BOOL8)v10))
            {
              v23 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SSIDs match (%@), but networks have different HS20 properties.", "__WiFiNetworkEqual", sub_10002B088(v7));
              objc_autoreleasePoolPop(v23);
              return 0;
            }
            if (!sub_10002D378((const __CFDictionary *)v4, (const __CFDictionary *)v3)
              || !sub_10002D2A0(v4, (const __CFDictionary *)v3, CFSTR("AP_MODE")))
            {
              return 0;
            }
            v44 = sub_10002CDC4((const __CFDictionary *)v4);
            v43 = sub_10002CDC4((const __CFDictionary *)v3);
            v15 = sub_10002CFA8((const __CFDictionary *)v4)
               && !sub_10002CEF4((const __CFDictionary *)v4)
               && sub_10002CEB0((const __CFDictionary *)v4) == 0;
            v25 = sub_10002CFA8((const __CFDictionary *)v3)
               && !sub_10002CEF4((const __CFDictionary *)v3)
               && sub_10002CEB0((const __CFDictionary *)v3) == 0;
            v45 = sub_10002CD50((const __CFDictionary *)v4);
            v46 = sub_10002CD50((const __CFDictionary *)v3);
            Value = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("ALLOW_WPA2_PSK"));
            v27 = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("ALLOW_WPA2_PSK"));
            v28 = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("ALLOW_OWE_TSN"));
            v29 = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("ALLOW_OWE_TSN"));
            v30 = ((unint64_t)Value | (unint64_t)v28) == 0;
            v31 = ((unint64_t)v27 | v29) == 0;
            if (v30 != v31)
            {
              v32 = (const __CFBoolean *)v29;
              if (v15)
                v33 = sub_10003153C((uint64_t)v7) != 3;
              else
                v33 = 0;
              if ((v25 & 1) == 0)
              {
                v35 = kCFBooleanTrue;
                goto LABEL_72;
              }
              v42 = v33;
              v34 = sub_10003153C((uint64_t)v10);
              v20 = Value == kCFBooleanTrue;
              v35 = kCFBooleanTrue;
              if (!v20)
              {
                v33 = v42;
                goto LABEL_72;
              }
              v33 = v42;
              if (v34 == 3)
              {
LABEL_72:
                if (v27 == v35 && v33)
                  return 0;
                if ((v30 & v15) == 1)
                {
                  v36 = sub_10003153C((uint64_t)v7);
                  v37 = v44;
                  if (v36 == 3)
                    v37 = v44 | 2;
                  v44 = v37;
                }
                if ((v31 & v25) == 1)
                {
                  v38 = sub_10003153C((uint64_t)v10);
                  v39 = v43;
                  if (v38 == 3)
                    v39 = v43 | 2;
                  v43 = v39;
                }
                v40 = v45 && sub_10003153C((uint64_t)v7) != 3;
                if (v46)
                {
                  v41 = sub_10003153C((uint64_t)v10);
                  if (v28 == v35 && v41 != 3)
                    return 0;
                }
                if (v32 == v35 && v40)
                  return 0;
LABEL_61:
                if (!v44 || !v43 || (v43 & v44) != 0)
                  return (v44 == 0) ^ (v43 != 0);
              }
              return 0;
            }
            v2 = 0;
            if (v15 == v25 && v45 == v46)
              goto LABEL_61;
          }
          else
          {
            v16 = (const __CFNumber *)sub_10002BE64((uint64_t)v7, CFSTR("networkRole"));
            v17 = sub_10001F500(v16);
            v18 = (const __CFNumber *)sub_10002BE64((uint64_t)v10, CFSTR("networkRole"));
            v19 = sub_10001F500(v18);
            v20 = (v17 & 0xFFFFFFFE) == 2 || v17 == 4;
            if (v20 || v19 - 2 <= 2)
            {
              return v17 == v19;
            }
            else
            {
              v2 = 1;
              if (!sub_1000CFFA4(v7, v10, 1u))
              {
                v21 = (const __CFString *)sub_10002B088(v7);
                if (CFStringGetLength(v21))
                  return 0;
                v22 = (const __CFString *)sub_10002B088(v10);
                if (CFStringGetLength(v22))
                  return 0;
                return sub_1000C6000((uint64_t)v7, (uint64_t)v10) != 0;
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

const __CFDictionary *sub_10002CD50(const __CFDictionary *a1)
{
  const __CFDictionary *result;
  const __CFNumber *Value;
  const __CFNumber *v4;

  result = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("RSN_IE"));
  if (result)
  {
    result = (const __CFDictionary *)sub_10002D11C(result, 18);
    if ((_DWORD)result)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("SCAN_RESULT_OWE_MULTI_SSID"));
      if (sub_10001F500(Value))
      {
        return 0;
      }
      else
      {
        v4 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("ALLOW_OWE_TSN"));
        return (const __CFDictionary *)(sub_10001F500(v4) == 0);
      }
    }
  }
  return result;
}

uint64_t sub_10002CDC4(const __CFDictionary *a1)
{
  int v2;
  unsigned int v3;

  if (sub_10002CEF4(a1))
    v2 = 2;
  else
    v2 = 2 * (sub_10002CEB0(a1) != 0);
  if (sub_10002CE68(a1))
    v2 |= 8u;
  v3 = v2 | (CFDictionaryGetValue(a1, CFSTR("WEP")) == kCFBooleanTrue);
  if (sub_10002CFA8(a1))
    v3 |= 4u;
  if (sub_10002CF48(a1))
    return v3 | 0x10;
  else
    return v3;
}

BOOL sub_10002CE68(const __CFDictionary *a1)
{
  return sub_10002D01C(a1) || CFDictionaryGetValue(a1, CFSTR("EnterpriseProfile")) != 0;
}

uint64_t sub_10002CEB0(const __CFDictionary *a1)
{
  uint64_t result;
  const __CFNumber *Value;

  if (sub_10002D1E0(a1))
  {
    LOBYTE(result) = 1;
  }
  else
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("ALLOW_WPA2_PSK"));
    LOBYTE(result) = sub_10001F500(Value);
  }
  return result;
}

uint64_t sub_10002CEF4(const __CFDictionary *a1)
{
  const __CFDictionary *Value;
  const __CFDictionary *v2;
  CFTypeID TypeID;

  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("WPA_IE"));
  if (Value && (v2 = Value, TypeID = CFDictionaryGetTypeID(), sub_1000648AC(TypeID, v2)))
    return sub_10002D11C(v2, 2);
  else
    return 0;
}

const __CFDictionary *sub_10002CF48(const __CFDictionary *a1)
{
  const __CFDictionary *result;
  const __CFBoolean *Value;

  result = sub_10002CFA8(a1);
  if ((_DWORD)result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("RSN_XE"));
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IE_KEY_RSNXE_CAPS"));
      if (result)
      {
        Value = (const __CFBoolean *)CFDictionaryGetValue(result, CFSTR("RSNXE_SAE_PK"));
        return (const __CFDictionary *)(CFBooleanGetValue(Value) == 1);
      }
    }
  }
  return result;
}

const __CFDictionary *sub_10002CFA8(const __CFDictionary *a1)
{
  const __CFDictionary *result;
  const __CFDictionary *v2;
  int v3;
  int v4;
  int v5;

  result = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("RSN_IE"));
  if (result)
  {
    v2 = result;
    v3 = sub_10002D11C(result, 8);
    v4 = sub_10002D11C(v2, 9) | v3;
    v5 = sub_10002D11C(v2, 24);
    return (const __CFDictionary *)(v4 | v5 | sub_10002D11C(v2, 25));
  }
  return result;
}

BOOL sub_10002D01C(const __CFDictionary *a1)
{
  const __CFDictionary *Value;
  const __CFDictionary *v3;
  CFTypeID TypeID;
  _BOOL8 v5;

  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("WPA_IE"));
  v3 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("RSN_IE"));
  if (Value && (TypeID = CFDictionaryGetTypeID(), sub_1000648AC(TypeID, Value)))
  {
    v5 = 1;
    if (!sub_10002D11C(Value, 1))
      v5 = sub_10002D11C(Value, 0) != 0;
  }
  else
  {
    v5 = 0;
  }
  if (!v5)
  {
    if (v3)
    {
      v5 = 1;
      if (!sub_10002D11C(v3, 1)
        && !sub_10002D11C(v3, 0)
        && !sub_10002D11C(v3, 3)
        && !sub_10002D11C(v3, 5)
        && !sub_10002D11C(v3, 12))
      {
        return sub_10002D11C(v3, 13) != 0;
      }
    }
  }
  return v5;
}

uint64_t sub_10002D11C(const __CFDictionary *a1, int a2)
{
  const __CFArray *Value;
  uint64_t result;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFNumber *ValueAtIndex;
  int valuePtr;

  Value = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("IE_KEY_RSN_AUTHSELS"));
  if (Value
    || (result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("IE_KEY_WPA_AUTHSELS")),
        (Value = (const __CFArray *)result) != 0))
  {
    Count = CFArrayGetCount(Value);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v7 = Count;
      v8 = 0;
      while (1)
      {
        valuePtr = -1431655766;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Value, v8);
        if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr))
        {
          if (valuePtr == a2)
            break;
        }
        if (v7 == ++v8)
          return 0;
      }
      return 1;
    }
  }
  return result;
}

const __CFDictionary *sub_10002D1E0(const __CFDictionary *result)
{
  const __CFDictionary *v1;

  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("RSN_IE"));
    if (result)
    {
      v1 = result;
      if (sub_10002D11C(result, 2) || sub_10002D11C(v1, 4))
        return (const __CFDictionary *)1;
      else
        return (const __CFDictionary *)(sub_10002D11C(v1, 6) != 0);
    }
  }
  return result;
}

uint64_t sub_10002D248(const void *a1, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;
  const __CFString *Value;

  v3 = sub_10002D2A0(a1, a2, CFSTR("SSID_STR"));
  v4 = v3;
  if (a1)
  {
    if ((_DWORD)v3)
    {
      Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("SSID_STR"));
      if (Value)
      {
        if (!CFStringGetLength(Value))
          return 0;
      }
    }
  }
  return v4;
}

uint64_t sub_10002D2A0(CFTypeRef cf, const __CFDictionary *a2, const void *a3)
{
  uint64_t result;
  CFTypeID v7;
  CFTypeID v8;
  const __CFDictionary *v9;
  const __CFDictionary *Value;
  const __CFDictionary *v11;
  const __CFDictionary *v12;

  result = 0;
  if (cf && a2)
  {
    v7 = CFGetTypeID(cf);
    if (v7 == CFGetTypeID(a2))
    {
      v8 = CFGetTypeID(cf);
      if (v8 == CFDictionaryGetTypeID())
      {
        v9 = (const __CFDictionary *)cf;
        if (!a3)
        {
          v12 = a2;
          return CFEqual(v9, v12);
        }
        Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, a3);
        v11 = (const __CFDictionary *)CFDictionaryGetValue(a2, a3);
        if (Value == v11)
          return 1;
        v12 = v11;
        if ((Value != 0) != (v11 == 0))
        {
          v9 = Value;
          return CFEqual(v9, v12);
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_10002D378(const __CFDictionary *a1, const __CFDictionary *a2)
{
  uint64_t result;

  if (CFDictionaryGetValue(a1, CFSTR("forceBGScanParamsCompare")) != kCFBooleanTrue
    && CFDictionaryGetValue(a2, CFSTR("forceBGScanParamsCompare")) != kCFBooleanTrue)
  {
    return 1;
  }
  result = sub_10002D2A0(a1, a2, CFSTR("BSSID"));
  if ((_DWORD)result)
  {
    result = sub_10002D2A0(a1, a2, CFSTR("ENTRY_NETWORK"));
    if ((_DWORD)result)
      return sub_10002D2A0(a1, a2, CFSTR("EXIT_NETWORK"));
  }
  return result;
}

void sub_10002D42C(CFMutableDictionaryRef *a1, CFDictionaryRef theDict)
{
  CFMutableDictionaryRef *v3;
  unsigned int Count;
  uint64_t v5;
  size_t v6;
  const void **v7;
  uint64_t v8;
  int v9;
  void *v10;
  const __CFNumber *v11;
  void *v12;
  const __CFDictionary *v13;
  const __CFDictionary *Mutable;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  void *v18;
  void *v19;
  CFDictionaryRef v20;
  const __CFAllocator *Default;
  __CFDictionary *MutableCopy;
  const __CFArray *v23;
  const __CFArray *v24;
  CFIndex v25;
  CFIndex v26;
  CFMutableArrayRef v27;
  CFIndex v28;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v30;
  __CFArray *v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  CFIndex v35;
  const __CFDictionary *v36;
  void *v37;
  CFMutableDictionaryRef *v38;
  uint64_t v39;
  const void **v40;
  CFIndex v41;
  const __CFArray *theArray;
  char v43;
  void *value;
  const __CFDictionary *valuePtr;

  if (!a1)
    return;
  if (!theDict)
    return;
  v3 = a1;
  Count = CFDictionaryGetCount(theDict);
  v5 = Count;
  if (!Count)
    return;
  v6 = 8 * Count;
  v7 = (const void **)malloc_type_malloc(v6, 0x6004044C4A2DFuLL);
  v40 = (const void **)malloc_type_malloc(v6, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues(theDict, v7, v40);
  v8 = 0;
  v9 = 0;
  v43 = 0;
  v39 = v5;
  do
  {
    if (CFStringCompare(CFSTR("LEAKY_AP_LEARNED_DATA"), (CFStringRef)v7[v8], 0) == kCFCompareEqualTo)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Found APPLE80211KEY_LEAKY_AP_LEARNED_DATA for network %@", "WiFiNetworkMergeProperties", sub_10002B088(v3));
      objc_autoreleasePoolPop(v10);
      v43 = 1;
    }
    if (!sub_10002DA5C((_BOOL8)v3)
      || CFStringCompare(CFSTR("SSID_STR"), (CFStringRef)v7[v8], 0)
      && CFStringCompare(CFSTR("SSID"), (CFStringRef)v7[v8], 0))
    {
      if (CFStringCompare(CFSTR("PRIVATE_MAC_ADDRESS"), (CFStringRef)v7[v8], 0) == kCFCompareEqualTo)
        goto LABEL_68;
      if (CFStringCompare(CFSTR("EnterpriseProfile"), (CFStringRef)v7[v8], 0) == kCFCompareEqualTo)
      {
        v13 = (const __CFDictionary *)sub_10002BE64((uint64_t)v3, CFSTR("EnterpriseProfile"));
        Mutable = v13;
        if (!v13)
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v15 = (const __CFDictionary *)v40[v8];
        v16 = sub_1000C3E64(Mutable, v15);
        valuePtr = 0;
        value = 0;
        CFDictionaryGetValueIfPresent(v15, CFSTR("EAPClientConfiguration"), (const void **)&valuePtr);
        CFDictionaryGetValueIfPresent(Mutable, CFSTR("EAPClientConfiguration"), (const void **)&value);
        v17 = valuePtr;
        if (valuePtr)
        {
          v18 = value;
          v19 = value;
          if (!value)
          {
            v19 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            value = v19;
            v17 = valuePtr;
          }
          v20 = sub_1000C3E64((CFDictionaryRef)v19, v17);
          Default = CFAllocatorGetDefault();
          MutableCopy = CFDictionaryCreateMutableCopy(Default, 0, v16);
          CFDictionarySetValue(MutableCopy, CFSTR("EAPClientConfiguration"), v20);
          sub_10002C478((uint64_t)v3, CFSTR("EnterpriseProfile"), MutableCopy);
          if (MutableCopy)
            CFRelease(MutableCopy);
          if (v20)
            CFRelease(v20);
          if (!v18 && value)
          {
            CFRelease(value);
            value = 0;
          }
          if (v16)
LABEL_40:
            CFRelease(v16);
        }
        else
        {
          sub_10002C478((uint64_t)v3, CFSTR("EnterpriseProfile"), v16);
          if (v16)
            goto LABEL_40;
        }
        if (!v13 && Mutable)
          CFRelease(Mutable);
        v9 = 1;
        v5 = v39;
        goto LABEL_68;
      }
      if (CFStringCompare(CFSTR("HomePropertyFromMobilewifitool"), (CFStringRef)v7[v8], 0)
        && CFStringCompare(CFSTR("COLOCATED_NETWORK_SCOPE_ID"), (CFStringRef)v7[v8], 0))
      {
        if (CFStringCompare(CFSTR("NetworkOfInterestHomeState"), (CFStringRef)v7[v8], 0) == kCFCompareEqualTo)
        {
          v11 = (const __CFNumber *)v40[v8];
          LODWORD(valuePtr) = 0;
          if (sub_1000C3F88((uint64_t)v3))
          {
            if (v11)
              CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
          }
        }
        if (CFStringCompare(CFSTR("networkKnownBSSListKey"), (CFStringRef)v7[v8], 0) == kCFCompareEqualTo
          && (v23 = (const __CFArray *)sub_10002BE64((uint64_t)v3, CFSTR("networkKnownBSSListKey")),
              (theArray = (const __CFArray *)v40[v8]) != 0)
          && (v24 = v23) != 0)
        {
          v25 = CFArrayGetCount(theArray);
          v26 = CFArrayGetCount(v24);
          v27 = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v24);
          v41 = v25;
          if (v25 >= 1)
          {
            v28 = 0;
            v38 = v3;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v28);
              if (ValueAtIndex)
              {
                v30 = ValueAtIndex;
                v31 = v27;
                v32 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
                if (v26 < 1)
                {
LABEL_60:
                  v27 = v31;
                  CFArrayAppendValue(v31, v30);
                }
                else
                {
                  v33 = v32;
                  v34 = 0;
                  v35 = 0;
                  while (1)
                  {
                    v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v24, v35);
                    if (v36)
                      v34 = (const __CFString *)CFDictionaryGetValue(v36, CFSTR("BSSID"));
                    if (v34 && v33 && CFStringCompare(v34, v33, 1uLL) == kCFCompareEqualTo)
                      break;
                    if (v26 == ++v35)
                      goto LABEL_60;
                  }
                  v27 = v31;
                  CFArraySetValueAtIndex(v31, v35, v30);
                }
                v3 = v38;
              }
              ++v28;
            }
            while (v28 != v41);
          }
          sub_10002C478((uint64_t)v3, CFSTR("networkKnownBSSListKey"), v27);
          if (v27)
            CFRelease(v27);
          v9 = 1;
        }
        else if (CFStringCompare(CFSTR("lastUpdated"), (CFStringRef)v7[v8], 0) || v9 != 1)
        {
          CFRetain(v40[v8]);
          CFDictionarySetValue(v3[2], v7[v8], v40[v8]);
          CFRelease(v40[v8]);
        }
        v5 = v39;
      }
    }
    else
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skip %@ merge for hs20 network %@", "WiFiNetworkMergeProperties", v7[v8], sub_10002B088(v3));
      objc_autoreleasePoolPop(v12);
    }
LABEL_68:
    ++v8;
  }
  while (v8 != v5);
  if ((v43 & 1) == 0 && sub_10002BE64((uint64_t)v3, CFSTR("LEAKY_AP_LEARNED_DATA")))
  {
    CFDictionaryRemoveValue(v3[2], CFSTR("LEAKY_AP_LEARNED_DATA"));
    v37 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Removing APPLE80211KEY_LEAKY_AP_LEARNED_DATA for network %@", "WiFiNetworkMergeProperties", sub_10002B088(v3));
    objc_autoreleasePoolPop(v37);
  }
  free(v40);
  free(v7);
}

BOOL sub_10002DA5C(_BOOL8 result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), CFSTR("HOTSPOT20_IE"))
        || CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 16), CFSTR("DomainName")) != 0;
  }
  return result;
}

BOOL sub_10002DAB4(uint64_t a1)
{
  return a1 && !sub_10002DAF0(a1) && sub_10002CE68(*(const __CFDictionary **)(a1 + 16));
}

BOOL sub_10002DAF0(_BOOL8 result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    return (~sub_10002DB40(*(const __CFDictionary **)(result + 16)) & 0xB) == 0
        || (~sub_10002DB40(*(const __CFDictionary **)(v1 + 16)) & 7) == 0;
  }
  return result;
}

const __CFNumber *sub_10002DB40(const __CFDictionary *a1)
{
  const __CFNumber *result;
  unsigned int valuePtr;

  valuePtr = 0;
  result = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("WAPI"));
  if (result)
  {
    CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

void *sub_10002DB7C(uint64_t a1)
{
  void *result;
  void *v2;

  if (a1)
  {
    result = (void *)sub_10002BE64(a1, CWFCoreWiFiSpecificAttributesKey);
    if (result)
      return (void *)(objc_msgSend(objc_msgSend(result, "objectForKey:", CWFNetworkProfilePropertyDisable6EModeKey), "integerValue") == (id)2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIs6EModeOff");
    objc_autoreleasePoolPop(v2);
    return 0;
  }
  return result;
}

uint64_t sub_10002DC14(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 5944);
  return result;
}

uint64_t sub_10002DC20(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  const void *v8;
  uint64_t v9;
  CFTypeID v10;
  uint64_t v11;
  CFTypeID v13;
  int k;
  uint64_t v15;
  CFTypeID v17;
  uint64_t v18;
  int j;
  uint64_t v20;
  int i;
  uint64_t v23;
  void *v25;
  void *v26;
  unsigned int valuePtr;

  v8 = sub_10002DEA0(a1, a2);
  if (!v8)
  {
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v26);
    return 0;
  }
  v9 = (uint64_t)v8;
  v10 = CFGetTypeID(v8);
  if (v10 == sub_10002DE64())
  {
    sub_10015CC8C(v9, a3, a4);
    return 0;
  }
  v13 = CFGetTypeID(a3);
  if (v13 != CFNumberGetTypeID())
  {
    v17 = CFGetTypeID(a3);
    if (v17 != CFStringGetTypeID())
      return 0;
    if (CFEqual(a3, CFSTR("IO80211InterfaceBGScanParams")))
    {
      v18 = 500;
    }
    else
    {
      if (!CFEqual(a3, CFSTR("IO80211InterfaceBGDynamicProfileParams")))
      {
        for (i = 6; ; --i)
        {
          v23 = Apple80211SetProperty(*(_QWORD *)(a1 + 16), a3, a4);
          v11 = v23;
          if ((_DWORD)v23 != -3905 && (_DWORD)v23 != 61 && (_DWORD)v23 != 16)
            break;
          if (!i)
            break;
          usleep(0x7A120u);
        }
LABEL_40:
        if ((_DWORD)v11)
        {
          v25 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WiFiDeviceSetProperty", a3, v11);
          objc_autoreleasePoolPop(v25);
        }
        return v11;
      }
      v18 = 501;
    }
    for (j = 6; ; --j)
    {
      v20 = Apple80211Set(*(_QWORD *)(a1 + 16), v18, 0, a4, 8);
      v11 = v20;
      if ((_DWORD)v20 != -3905 && (_DWORD)v20 != 61 && (_DWORD)v20 != 16)
        break;
      if (!j)
        break;
      usleep(0x7A120u);
    }
    goto LABEL_40;
  }
  valuePtr = 0;
  if (!CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &valuePtr))
    return 0;
  for (k = 6; ; --k)
  {
    v15 = Apple80211Set(*(_QWORD *)(a1 + 16), valuePtr, 0, a4, 8);
    v11 = v15;
    if ((_DWORD)v15 != -3905 && (_DWORD)v15 != 61 && (_DWORD)v15 != 16)
      break;
    if (!k)
      break;
    usleep(0x7A120u);
  }
  return v11;
}

uint64_t sub_10002DE64()
{
  uint64_t result;

  result = qword_10026DC00;
  if (!qword_10026DC00)
  {
    pthread_once(&stru_10026CF00, (void (*)(void))sub_10015BA10);
    return qword_10026DC00;
  }
  return result;
}

const void *sub_10002DEA0(uint64_t a1, const void *a2)
{
  const __CFDictionary *v2;
  void *v4;

  if (a1)
  {
    if (a2)
    {
      v2 = *(const __CFDictionary **)(a1 + 5784);
      if (v2)
        return CFDictionaryGetValue(v2, a2);
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device->interfaces is NULL", "__WiFiDeviceVirtualInterfaceGet");
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: interfaceName is NULL", "__WiFiDeviceVirtualInterfaceGet");
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device is NULL", "__WiFiDeviceVirtualInterfaceGet");
  }
  objc_autoreleasePoolPop(v4);
  return 0;
}

double sub_10002DF80(const void *a1)
{
  double v1;
  CFTypeID v3;
  double valuePtr;

  valuePtr = 0.0;
  v1 = 0.0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

double sub_10002DFE4(uint64_t a1)
{
  const void *v1;

  v1 = sub_10002BE64(a1, CFSTR("networkUsage"));
  return sub_10002DF80(v1);
}

unint64_t sub_10002E000(const void *a1)
{
  unint64_t v2;
  unint64_t result;
  void *v4;
  const __CFDate *v5;

  v2 = (unint64_t)sub_10002BE64((uint64_t)a1, CFSTR("lastJoined"));
  result = (unint64_t)sub_10002BE64((uint64_t)a1, CFSTR("lastAutoJoined"));
  if (v2 | result)
  {
    v5 = (const __CFDate *)result;
    if (!result)
      result = v2;
    if (v2 && v5)
    {
      if (CFDateCompare((CFDateRef)v2, v5, 0) == kCFCompareGreaterThan)
        return v2;
      else
        return (unint64_t)v5;
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Network %@ Both autojoin and user join dates are NULL", sub_10002B088(a1));
    objc_autoreleasePoolPop(v4);
    return 0;
  }
  return result;
}

void sub_10002E0C8(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x28u, a3);
}

void sub_10002E0D4(CFMutableArrayRef *a1, int *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  void *v7;
  void *v8;
  void *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  const char *v16;
  void *v17;
  uint64_t v18;
  const __CFArray *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;

  switch(a2[2])
  {
    case 0:
      if (*(_BYTE *)(*(_QWORD *)a2 + 16))
      {
        *((_QWORD *)a2 + 3) = sub_1000F7004((uint64_t)a1, **((unsigned int **)a2 + 2), *(_QWORD *)(*(_QWORD *)a2 + 32));
        v4 = sub_100108EE4((uint64_t)a1);
        v5 = *(unsigned int *)(*(_QWORD *)a2 + 316);
        if (v4 != (_DWORD)v5)
        {
          v6 = v4;
          if ((MGGetBoolAnswer(CFSTR("3kmXfug8VcxLI5yEmsqQKw")) & 1) == 0
            && !*(_QWORD *)(*(_QWORD *)a2 + 320)
            && !*(_BYTE *)(*(_QWORD *)a2 + 1328))
          {
            v7 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device hasn't been unlocked since boot. Overriding power state to OFF.", "__WiFiManagerDeviceManagerApplier");
            objc_autoreleasePoolPop(v7);
            v5 = 0;
          }
          v8 = objc_autoreleasePoolPush();
          v9 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v10 = sub_1000648F0(v6);
            v11 = sub_1000648F0(*(_DWORD *)(*(_QWORD *)a2 + 316));
            objc_msgSend(v9, "WFLog:message:", 3, "Device power = %s and prefences power = %s.  Setting device power to %s (unlockedSinceBoot=%d)", v10, v11, sub_1000648F0(v5), *(unsigned __int8 *)(*(_QWORD *)a2 + 1328));
          }
          objc_autoreleasePoolPop(v8);
          v12 = sub_100109A80((uint64_t)a1, v5);
          if ((_DWORD)v12)
          {
            v13 = v12;
            v14 = objc_autoreleasePoolPush();
            v15 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v16 = sub_1000648F0(v6);
              objc_msgSend(v15, "WFLog:message:", 4, "Unable to set power state (%s) to %s (err = %d). deviceManager=%p", v16, sub_1000648F0(*(_DWORD *)(*(_QWORD *)a2 + 316)), v13, a1);
            }
            v17 = v14;
            goto LABEL_117;
          }
        }
      }
      return;
    case 2:
      if (*(_BYTE *)(*(_QWORD *)a2 + 16))
        sub_1000F73B0((uint64_t)a1, *(NSObject **)(*(_QWORD *)a2 + 32));
      return;
    case 3:
      v18 = *(_QWORD *)a2;
      if (*(_BYTE *)(*(_QWORD *)a2 + 1560) || *(_BYTE *)(v18 + 1504))
      {
        sub_100006F34((uint64_t)a1, 1);
        v19 = *(const __CFArray **)(*(_QWORD *)a2 + 256);
      }
      else
      {
        v19 = *(const __CFArray **)(v18 + 216);
      }
      sub_1000FCC14((uint64_t)a1, v19);
      return;
    case 4:
      sub_10010020C((uint64_t)a1, *(CFTypeRef *)(*(_QWORD *)a2 + 208));
      return;
    case 5:
      v20 = (int)sub_100115A08((uint64_t)a1, *(_QWORD *)(*(_QWORD *)a2 + 2504));
      goto LABEL_184;
    case 6:
      if (*(_BYTE *)(*(_QWORD *)a2 + 16) && *(_BYTE *)(*(_QWORD *)a2 + 24))
        sub_1000FB2E0((uint64_t)a1);
      return;
    case 7:
      sub_100108508((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1161), *(unsigned __int8 *)(*(_QWORD *)a2 + 1176), *(unsigned __int8 *)(*(_QWORD *)a2 + 1164));
      return;
    case 8:
      sub_10010194C(a1, *((const __CFArray **)a2 + 2), 1);
      return;
    case 9:
      v21 = *(_QWORD *)a2;
      v22 = *(_DWORD *)(*(_QWORD *)a2 + 1468);
      if (v22 == -1)
        v22 = *(_DWORD *)(v21 + 1456);
      v23 = *(_DWORD *)(v21 + 1472);
      if (v23 == -1)
        v23 = *(_DWORD *)(v21 + 1460);
      v24 = *(_DWORD *)(v21 + 1476);
      if (v24 == -1)
        v25 = *(unsigned __int8 *)(v21 + 1464);
      else
        v25 = v24 == 1;
      v37 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: current:builtInReceiver=%d,cellularTxStarted=%d,isShort=%d, overrides:builtInReceiver=%d,cellularTxStarted=%d,isShort=%d", "__WiFiManagerDeviceManagerApplier", *(unsigned int *)(*(_QWORD *)a2 + 1456), *(unsigned int *)(*(_QWORD *)a2 + 1460), *(unsigned __int8 *)(*(_QWORD *)a2 + 1464), *(unsigned int *)(*(_QWORD *)a2 + 1468), *(unsigned int *)(*(_QWORD *)a2 + 1472), *(unsigned int *)(*(_QWORD *)a2 + 1476));
      objc_autoreleasePoolPop(v37);
      sub_100114468((uint64_t)a1, v22, v23, v25);
      return;
    case 10:
      sub_100100624((uint64_t)a1, *(unsigned int *)(*(_QWORD *)a2 + 1312), *(unsigned __int8 *)(*(_QWORD *)a2 + 864));
      if ((*(_DWORD *)(*(_QWORD *)a2 + 1312) - 1) <= 1)
      {
        v26 = sub_1001186A4((uint64_t)a1);
        if (*(double *)(v26 + 424) == 0.0)
          *(double *)(v26 + 424) = sub_100064914();
      }
      return;
    case 11:
      sub_1000FC750((uint64_t)a1);
      return;
    case 12:
      sub_100101A38((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 1060), *(_DWORD *)(*(_QWORD *)a2 + 1056));
      return;
    case 13:
      if (*(_BYTE *)(*(_QWORD *)a2 + 16) && *(_BYTE *)(*(_QWORD *)a2 + 24))
        sub_1000FBA80((uint64_t)a1, **((unsigned int **)a2 + 2), (uint64_t)"__WiFiManagerDeviceManagerApplier");
      return;
    case 14:
      sub_10010A974((uint64_t)a1);
      return;
    case 15:
      sub_1000FB408((uint64_t)a1);
      return;
    case 16:
      sub_1000F8B54((uint64_t)a1, *(_QWORD *)(*(_QWORD *)a2 + 32));
      return;
    case 17:
      sub_1000F8AF4((uint64_t)a1);
      return;
    case 18:
      v27 = *(unsigned int *)(*(_QWORD *)a2 + 316);
      if ((MGGetBoolAnswer(CFSTR("3kmXfug8VcxLI5yEmsqQKw")) & 1) == 0
        && !*(_QWORD *)(*(_QWORD *)a2 + 320)
        && !*(_BYTE *)(*(_QWORD *)a2 + 1328))
      {
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device hasn't been unlocked since boot. Overriding power state to OFF.", "__WiFiManagerDeviceManagerApplier");
        objc_autoreleasePoolPop(v28);
        v27 = 0;
      }
      sub_100109A80((uint64_t)a1, v27);
      return;
    case 19:
      sub_1000FB44C((uint64_t)a1);
      return;
    case 20:
      sub_100006F34((uint64_t)a1, **((_DWORD **)a2 + 2));
      return;
    case 21:
      sub_1001153F0((uint64_t)a1, *(unsigned int *)(*(_QWORD *)a2 + 1904), (unsigned int *)(*(_QWORD *)a2 + 1912), 1u, *(double *)(*(_QWORD *)a2 + 1920), 0);
      sub_1001153F0((uint64_t)a1, *(unsigned int *)(*(_QWORD *)a2 + 1904), (unsigned int *)(*(_QWORD *)a2 + 1912), 1u, *(double *)(*(_QWORD *)a2 + 1920), *(const void **)(*(_QWORD *)a2 + 1896));
      return;
    case 22:
      sub_1000FCA48((uint64_t)a1, *((const void **)a2 + 2));
      return;
    case 23:
      sub_100100530((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 304));
      return;
    case 24:
      sub_100100548((uint64_t)a1, *(unsigned int *)(*(_QWORD *)a2 + 788));
      return;
    case 25:
      sub_100101888((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 300));
      return;
    case 26:
      sub_100100490((uint64_t)a1, a2[4]);
      return;
    case 27:
      sub_1001017F0((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 824));
      return;
    case 28:
      sub_1001002EC((uint64_t)a1, *(CFTypeRef *)(*(_QWORD *)a2 + 264), *(_DWORD *)(*(_QWORD *)a2 + 272));
      return;
    case 29:
      sub_1001017C4((uint64_t)a1, *(_BYTE *)(*(_QWORD *)a2 + 308));
      return;
    case 30:
      sub_1001017DC(a1, *(_BYTE *)(*(_QWORD *)a2 + 309), *(_BYTE *)(*(_QWORD *)a2 + 310), *(_BYTE *)(*(_QWORD *)a2 + 311));
      return;
    case 31:
      if (*(_QWORD *)a2)
        sub_100101880((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 312));
      return;
    case 32:
      sub_100106408((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1208), *((unsigned int **)a2 + 2));
      return;
    case 33:
      sub_1001065B4((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1211), *(unsigned __int8 *)(*(_QWORD *)a2 + 1210), *(unsigned __int8 *)(*(_QWORD *)a2 + 1212), *((unsigned int **)a2 + 2));
      return;
    case 34:
      sub_10010806C((uint64_t)a1, **((unsigned __int8 **)a2 + 2), *(unsigned __int8 *)(*((_QWORD *)a2 + 2) + 1), *(unsigned __int8 *)(*((_QWORD *)a2 + 2) + 2), *(void **)(*((_QWORD *)a2 + 2) + 8));
      return;
    case 35:
      sub_100110230((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 276));
      return;
    case 36:
      sub_10011023C((uint64_t)a1, *(_QWORD *)(*(_QWORD *)a2 + 280), *(double *)(*(_QWORD *)a2 + 288));
      return;
    case 37:
      sub_100101890((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 328));
      return;
    case 38:
      v29 = sub_1001088B4((uint64_t)a1, *(const __CFString **)(*(_QWORD *)a2 + 1216));
      goto LABEL_177;
    case 39:
      sub_100108444((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1232));
      return;
    case 40:
      if (*(_QWORD *)a2)
        sub_1001005B0((uint64_t *)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 808), *(const void **)(*(_QWORD *)a2 + 816));
      return;
    case 41:
      sub_100112CD4((uint64_t)a1, *(_QWORD *)a2 + 1384);
      return;
    case 42:
      sub_100112D80((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1392));
      return;
    case 43:
      sub_100112DF8((uint64_t)a1);
      return;
    case 44:
      sub_100115A20((uint64_t)a1);
      return;
    case 45:
      if (*(_QWORD *)a2)
        sub_100101934((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 2065));
      return;
    case 47:
      v30 = sub_100108EE4((uint64_t)a1);
      goto LABEL_183;
    case 48:
      v30 = sub_1001084C4((uint64_t)a1);
      goto LABEL_183;
    case 49:
      v30 = sub_1001084BC((uint64_t)a1);
      goto LABEL_183;
    case 50:
      v30 = sub_1001087EC((uint64_t)a1);
      goto LABEL_183;
    case 51:
      v30 = sub_1000F9044((uint64_t)a1);
      goto LABEL_183;
    case 52:
      v30 = sub_1001074A4((uint64_t)a1);
      goto LABEL_183;
    case 53:
      sub_100108E5C((uint64_t)a1, (CFStringRef *)(*(_QWORD *)a2 + 1216));
      return;
    case 54:
      if (*(_QWORD *)a2)
        sub_10011203C((uint64_t)a1, *((CFDictionaryRef *)a2 + 2), 1);
      return;
    case 55:
      if (*(_QWORD *)a2)
        sub_1001122B4((uint64_t)a1, **((_DWORD **)a2 + 2));
      return;
    case 56:
      if (*(_QWORD *)a2)
        sub_10011233C((uint64_t)a1, *((const __CFDictionary **)a2 + 2));
      return;
    case 57:
      sub_10010FE60((uint64_t)a1, *((CFArrayRef *)a2 + 2));
      return;
    case 58:
      v31 = *(_QWORD *)a2;
      if (*(_QWORD *)a2)
      {
        v32 = (_DWORD *)*((_QWORD *)a2 + 2);
        if (*v32 == -536870144)
          v33 = v31 + 530;
        else
          v33 = 0;
        sub_100112E64((uint64_t)a1, v32, v33);
      }
      return;
    case 59:
      sub_100025788((uint64_t)a1, *((uint64_t **)a2 + 2));
      return;
    case 60:
      sub_100113B84((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 1408), *(double *)(*(_QWORD *)a2 + 1416));
      return;
    case 61:
      sub_1000072F4((uint64_t)a1);
      return;
    case 62:
      sub_10002FFE0((uint64_t)a1);
      return;
    case 63:
      v30 = sub_1001084FC((uint64_t)a1);
      goto LABEL_183;
    case 64:
      if (*(_QWORD *)a2)
        sub_1001149F4((uint64_t)a1, a2[4]);
      return;
    case 65:
      if (*(_QWORD *)a2)
        sub_100114B4C((uint64_t)a1, *((CFDictionaryRef *)a2 + 2));
      return;
    case 66:
      if (*(_QWORD *)a2)
      {
        sub_100115844((uint64_t)a1, *((unsigned __int8 *)a2 + 12));
        sub_1001158A8((uint64_t)a1, a2[4]);
      }
      return;
    case 67:
      if (*(_QWORD *)a2)
      {
        sub_1001159BC((uint64_t)a1, *((CFArrayRef *)a2 + 2));
        if (*((_QWORD *)a2 + 2))
        {
          v34 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set policies %@", "__WiFiManagerDeviceManagerApplier", *((_QWORD *)a2 + 2));
          v17 = v34;
LABEL_117:
          objc_autoreleasePoolPop(v17);
        }
      }
      return;
    case 68:
      sub_1001109B0((uint64_t)a1, a2[4]);
      return;
    case 69:
      sub_100116B48((uint64_t)a1, *((const void **)a2 + 2), (uint64_t)sub_1000AE260, *(_QWORD *)a2);
      return;
    case 71:
      sub_100118868((uint64_t)a1, *((unsigned __int8 *)a2 + 32), **((unsigned int **)a2 + 2), **((unsigned int **)a2 + 3));
      return;
    case 74:
      sub_100031EB4((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 314));
      return;
    case 77:
      if (*(_QWORD *)a2)
      {
        v35 = *((_QWORD *)a2 + 2);
        if (v35)
          sub_100106C34((uint64_t)a1, v35);
      }
      return;
    case 78:
      sub_100104F88((uint64_t)a1);
      return;
    case 79:
      sub_10011A268((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 80:
      sub_10011A1AC((uint64_t)a1);
      return;
    case 81:
      sub_100100160((uint64_t)a1, *((const void **)a2 + 2));
      return;
    case 82:
      sub_100115C30((uint64_t)a1, *((const void **)a2 + 2));
      return;
    case 83:
      sub_10011ADFC((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 84:
      v29 = sub_10011AEB0((uint64_t)a1);
      goto LABEL_177;
    case 85:
      v29 = sub_10011AEC0((uint64_t)a1);
      goto LABEL_177;
    case 86:
      v29 = sub_10011AED0((uint64_t)a1);
      goto LABEL_177;
    case 88:
      v29 = sub_10011AF24((uint64_t)a1);
      goto LABEL_177;
    case 89:
      sub_100116160((uint64_t)a1, *((void **)a2 + 2));
      return;
    case 90:
      sub_10011B558((uint64_t)a1, **((unsigned int **)a2 + 2));
      return;
    case 91:
      sub_10011B934((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 92:
      sub_100006188((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 93:
      sub_10011B9F4((uint64_t)a1, **((double **)a2 + 2));
      return;
    case 95:
      sub_1000320CC((uint64_t)a1, *((const __CFDictionary **)a2 + 2));
      return;
    case 96:
      sub_10003201C((uint64_t)a1, (const __CFDictionary **)a2 + 2);
      return;
    case 97:
      sub_100031F50((uint64_t)a1);
      return;
    case 98:
      sub_10011BCC0((uint64_t)a1, *((_QWORD *)a2 + 2));
      return;
    case 99:
      sub_10011BEC8(a1, *((_QWORD *)a2 + 2), *((double *)a2 + 3), *((double *)a2 + 4));
      return;
    case 100:
      sub_1000FE5A4((uint64_t)a1, **((const void ***)a2 + 2));
      return;
    case 101:
      sub_10011BFB8((uint64_t)a1, *((const __CFArray **)a2 + 2));
      return;
    case 102:
      sub_100103A50(a1, *(const void **)(*(_QWORD *)a2 + 1240), *(CFTypeRef *)(*(_QWORD *)a2 + 1272));
      return;
    case 103:
      sub_10011C840((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 104:
      sub_100032140((uint64_t)a1, *((const void **)a2 + 2));
      return;
    case 105:
      sub_1001176E8((uint64_t)a1, *((const void **)a2 + 2), (uint64_t)sub_1000AEB34, *(_QWORD *)a2);
      return;
    case 106:
      sub_100011654((uint64_t *)a1, *((CFTypeRef *)a2 + 2));
      return;
    case 107:
      if (!*(_QWORD *)a2)
        return;
      v30 = sub_1001158FC((uint64_t)a1);
      goto LABEL_183;
    case 108:
      sub_10010029C((uint64_t)a1, *((_QWORD *)a2 + 2));
      return;
    case 109:
      sub_10011DCE4((uint64_t)a1, *(_DWORD *)(*(_QWORD *)a2 + 848));
      return;
    case 110:
      sub_10010024C((uint64_t)a1, *(CFTypeRef *)(*(_QWORD *)a2 + 352));
      return;
    case 111:
      sub_10010035C((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 112:
      if (*(_QWORD *)a2)
        sub_10011DD18((uint64_t)a1, *((const __CFDictionary **)a2 + 2));
      return;
    case 113:
      sub_100115F6C((uint64_t)a1, *((const void **)a2 + 2));
      return;
    case 114:
      sub_10011C8F0((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 115:
      sub_10011E028((uint64_t)a1);
      return;
    case 117:
      sub_10011E664((uint64_t)a1, *(_BYTE *)(*(_QWORD *)a2 + 2253));
      return;
    case 118:
      sub_100103BD8((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1280));
      return;
    case 119:
      sub_100103FB4((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 120:
      sub_1001132C4((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)a2 + 1424));
      return;
    case 121:
      sub_100031E44((uint64_t)a1, **((_QWORD **)a2 + 2));
      return;
    case 122:
      sub_10002FD14((uint64_t)a1, **((_QWORD **)a2 + 2));
      return;
    case 123:
      sub_10011EEC0((uint64_t)a1, **((unsigned __int8 **)a2 + 2));
      return;
    case 124:
      sub_100031E48((uint64_t)a1);
      return;
    case 125:
      sub_1001137F0((uint64_t)a1, *((unsigned int **)a2 + 2));
      return;
    case 126:
      sub_1001003D0((uint64_t)a1, *(CFTypeRef *)(*(_QWORD *)a2 + 800));
      return;
    case 127:
      sub_1001133B0((uint64_t)a1, *((_QWORD *)a2 + 2));
      return;
    case 128:
      sub_10011EF5C((uint64_t)a1, *((unsigned __int8 *)a2 + 24));
      return;
    case 129:
      sub_10011F054((uint64_t)a1, *((_QWORD *)a2 + 2));
      return;
    case 130:
      v29 = sub_10011F6BC((uint64_t)a1);
LABEL_177:
      v36 = v29;
      goto LABEL_185;
    case 131:
      v30 = sub_100109AB4((uint64_t)a1);
      goto LABEL_183;
    case 133:
      sub_100120E00((uint64_t)a1, *((const __CFDictionary **)a2 + 2));
      return;
    case 134:
      sub_100121294((uint64_t)a1, *((const __CFDictionary **)a2 + 2));
      return;
    case 135:
      v30 = sub_10012162C((uint64_t)a1);
      goto LABEL_183;
    case 136:
      v30 = sub_100031FC0((uint64_t)a1);
LABEL_183:
      v20 = v30;
LABEL_184:
      v36 = *((_QWORD *)a2 + 3) | v20;
LABEL_185:
      *((_QWORD *)a2 + 3) = v36;
      break;
    case 137:
      sub_100104D6C((uint64_t)a1);
      break;
    case 138:
      sub_100104EC4((uint64_t)a1);
      break;
    case 139:
      sub_10012163C((uint64_t)a1, **((_BYTE **)a2 + 2));
      break;
    case 140:
      if (*(_QWORD *)a2)
        sub_1001087FC((uint64_t)a1, *((_QWORD *)a2 + 2));
      break;
    case 141:
      if (*(_QWORD *)a2)
        sub_10010881C((uint64_t)a1, *((_QWORD *)a2 + 2));
      break;
    default:
      return;
  }
}

void sub_10002F910(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 8))
      sub_10002F934(a1, *(_QWORD *)(a2 + 8), *(const void **)(a2 + 16));
  }
}

void sub_10002F934(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x1Fu, a3);
}

id sub_10002F940(id result)
{
  if (result)
    return objc_msgSend(result, "_handleManagedEventNotification");
  return result;
}

void sub_10002F94C(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F958(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F964(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F970(uint64_t a1)
{

}

void sub_10002F978(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F984(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F990(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F99C(uint64_t a1)
{

}

void sub_10002F9A4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9B0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9BC(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9C8(uint64_t a1)
{

}

void sub_10002F9D0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9DC(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9E8(uint64_t a1)
{

}

void sub_10002F9F0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002F9FC(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002FA08(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002FA14(uint64_t a1)
{

}

void sub_10002FA1C(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_10002FA28(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FA38(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FA48(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t sub_10002FA58(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002FA68(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FA78(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FA88(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t sub_10002FA98(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002FAA8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FAB8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FAC8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t sub_10002FAD8(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002FAE8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FAF8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t sub_10002FB08(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002FB18(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FB28(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_10002FB38(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t sub_10002FB48(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002FB58(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

id sub_10002FB70(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_applicationStateMonitorHandler:", *(_QWORD *)(a1 + 40));
}

id sub_10002FB7C(uint64_t a1)
{
  id v2;
  id v3;
  id result;
  id v5;
  uint64_t v6;
  void *v7;
  const void *v8;
  _WORD *v9;
  void *v10;
  id v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];

  sub_100031A7C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), (uint64_t)objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "UUID"), "UUIDString"));
  v2 = objc_msgSend(*(id *)(a1 + 32), "__peerAssistedDiscoveryNetworksForUUID:", objc_msgSend(*(id *)(a1 + 40), "UUID"));
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v3 = objc_msgSend(v2, "allKeys", 0);
  result = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (result)
  {
    v5 = result;
    v6 = *(_QWORD *)v13;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v13 != v6)
          objc_enumerationMutation(v3);
        v8 = *(const void **)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)v7);
        v9 = sub_10002B314((uint64_t)kCFAllocatorDefault, objc_msgSend(v2, "objectForKeyedSubscript:", v8));
        if (v9)
        {
          v10 = v9;
          v11 = objc_msgSend(*(id *)(a1 + 32), "__deviceManagerWithInterfaceName:", v8);
          if (v11)
            sub_10010FABC((uint64_t)v11, v8, v10, 0, 0);
          CFRelease(v10);
        }
        objc_msgSend(*(id *)(a1 + 32), "__setPeerAssistedDiscoveryNetwork:interfaceName:UUID:", 0, v8, objc_msgSend(*(id *)(a1 + 40), "UUID"));
        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      result = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      v5 = result;
    }
    while (result);
  }
  return result;
}

id sub_10002FD14(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 8888) = a2;
  return sub_100013754(a1);
}

void sub_10002FD1C(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  void *v11;
  const __CFString *v12;
  const __CFString *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  void *v18;
  _QWORD context[4];
  _QWORD v20[2];

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = *(unsigned __int8 *)(a1 + 40);
    v4 = *(_QWORD *)(v2 + 832);
    if (*(unsigned __int8 *)(v2 + 840) != v3)
    {
      *(_BYTE *)(v2 + 840) = v3;
      if (v3)
        v7 = v4 | 4;
      else
        v7 = v4 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_13:
      *(_QWORD *)(v2 + 832) = v7;
      sub_100013B90(v2, v4);
      goto LABEL_14;
    }
    if (*(_BYTE *)(a1 + 40))
      v5 = (*(_QWORD *)(v2 + 832) & 1) == 0;
    else
      v5 = 1;
    if (!v5)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: in home screen, force-unset foreground app mask.", "__WiFiManagerSBHomeScreenStateUpdate");
      objc_autoreleasePoolPop(v6);
      v7 = v4 & 0xFFFFFFFFFFFFFFFELL;
      goto LABEL_13;
    }
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerSBHomeScreenStateUpdate");
    objc_autoreleasePoolPop(v16);
  }
LABEL_14:
  v8 = *(_QWORD *)(a1 + 32);
  if (v8)
  {
    v9 = *(unsigned __int8 *)(a1 + 41);
    if (*(unsigned __int8 *)(v8 + 912) != v9)
      *(_BYTE *)(v8 + 912) = v9;
LABEL_17:
    v10 = *(unsigned __int8 *)(a1 + 42);
    if (*(unsigned __int8 *)(v8 + 841) != v10)
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v12 = CFSTR("visible");
        if (*(_BYTE *)(v8 + 841))
          v13 = CFSTR("visible");
        else
          v13 = CFSTR("non-visible");
        if (!v10)
          v12 = CFSTR("non-visible");
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: control center state changed from '%@' -> '%@'", "__WiFiManagerControlCenterStateChanged", v13, v12);
      }
      objc_autoreleasePoolPop(v11);
      *(_BYTE *)(v8 + 841) = v10;
      if (v10)
      {
        sub_10008D03C(v8, 1);
      }
      else if (*(_QWORD *)(v8 + 1224))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabling MIS discovery due to control center dismissal", "__WiFiManagerControlCenterStateChanged");
        objc_autoreleasePoolPop(v14);
        v15 = sub_1000161D4(*(_QWORD *)(v8 + 1224));
        v20[0] = 0xAAAAAAAAAA000000;
        v20[1] = v15;
        context[0] = v8;
        context[1] = 0xAAAAAAAA00000022;
        context[2] = v20;
        context[3] = 1;
        CFSetApplyFunction(*(CFSetRef *)(v8 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
        sub_1000923EC(v8, *(const __CFString **)(v8 + 1224), 0, 0, 0, 0);
      }
    }
    return;
  }
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "__WiFiManagerCameraStateUpdate");
  objc_autoreleasePoolPop(v17);
  v8 = *(_QWORD *)(a1 + 32);
  if (v8)
    goto LABEL_17;
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "manager is Null");
  objc_autoreleasePoolPop(v18);
}

void sub_10002FFE0(uint64_t a1)
{
  double v2;
  void *v3;

  if (*(_DWORD *)(a1 + 6580))
  {
    if (*(double *)(a1 + 6584) != 0.0)
    {
      v2 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6584);
      if (v2 >= 10.0)
      {
        v3 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Auto Join PM Assertion timeout autoJoinPMAssertionTimestamp:%f timeSincePMAssertion:%f", "WiFiDeviceManagerJoinPMAssertionExpirationHandler", *(_QWORD *)(a1 + 6584), *(_QWORD *)&v2);
        objc_autoreleasePoolPop(v3);
        sub_1001147D4(a1, *(const void **)(a1 + 6592), 1);
      }
    }
  }
}

void sub_1000300A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD context[3];

  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10002F910, context);
    }
  }
}

void sub_1000300E0(uint64_t a1, int a2, int a3)
{
  unsigned int v6;
  int v7;
  int v8;
  void *v9;
  int v10;
  void *v11;
  const char *v12;
  void *v13;
  NSObject *v14;
  dispatch_time_t v15;
  int v16;
  uint64_t context;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v6 = objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isDisableAutoJoinActivityRegistered");
  if (!a2 || (CFSetGetCount(*(CFSetRef *)(a1 + 160)) ? (v7 = 1) : (v7 = v6), v7 == 1))
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 160)))
      v8 = 1;
    else
      v8 = v6;
    if (v8 == 1)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: auto-join disabled by %@ (activity=%d)", "__WiFiManagerSetEnableInternal", *(_QWORD *)(a1 + 160), v6);
      objc_autoreleasePoolPop(v9);
    }
    v10 = 0;
    if (a3)
      goto LABEL_17;
LABEL_16:
    if (*(unsigned __int8 *)(a1 + 26) == v10)
      return;
    goto LABEL_17;
  }
  v10 = 1;
  if (!a3)
    goto LABEL_16;
LABEL_17:
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v12 = "Disabling";
    if (v10)
      v12 = "Enabling";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s automatic association", v12);
  }
  objc_autoreleasePoolPop(v11);
  *(_BYTE *)(a1 + 26) = v10;
  if (v10 && *(_BYTE *)(a1 + 1560))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: start the priority autojoin timer ###START_CAAJ", "__WiFiManagerSetEnableInternal");
    objc_autoreleasePoolPop(v13);
    v14 = *(NSObject **)(a1 + 1576);
    v15 = dispatch_time(0, 30000000000);
    dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
    v10 = *(unsigned __int8 *)(a1 + 26);
  }
  context = a1;
  v18 = 0xAAAAAAAAAAAAAAAALL;
  if (v10)
    v16 = 6;
  else
    v16 = 15;
  LODWORD(v18) = v16;
  v19 = 0;
  v20 = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
}

uint64_t sub_1000302BC(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000088;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100030300(_QWORD *a1, const __CFString *a2, uint64_t a3)
{
  const __SCPreferences *v4;
  const __CFNumber *v5;
  CFTypeID TypeID;
  uint64_t valuePtr;

  v4 = sub_10001D90C(a1, a2);
  valuePtr = a3;
  if (v4)
  {
    v5 = v4;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr);
      return valuePtr;
    }
  }
  return a3;
}

BOOL sub_10003036C(_QWORD *a1, const __CFString *a2, SInt32 a3)
{
  const __SCPreferences *v4;
  const __CFString *v5;
  CFTypeID TypeID;
  CFTypeID v7;
  SInt32 IntValue;
  CFTypeID v9;
  SInt32 valuePtr;

  v4 = sub_10001D90C(a1, a2);
  valuePtr = a3;
  if (v4)
  {
    v5 = (const __CFString *)v4;
    TypeID = CFNumberGetTypeID();
    if (TypeID != CFGetTypeID(v5))
    {
      v7 = CFBooleanGetTypeID();
      if (v7 == CFGetTypeID(v5))
      {
        IntValue = CFEqual(v5, kCFBooleanTrue);
      }
      else
      {
        v9 = CFStringGetTypeID();
        if (v9 != CFGetTypeID(v5))
          return a3 != 0;
        IntValue = CFStringGetIntValue(v5);
      }
      a3 = IntValue;
      return a3 != 0;
    }
    CFNumberGetValue((CFNumberRef)v5, kCFNumberIntType, &valuePtr);
    a3 = valuePtr;
  }
  return a3 != 0;
}

void sub_100030434(uint64_t a1, int a2)
{
  void *v2;
  _QWORD context[4];

  if (a1)
  {
    if (a2 == 14)
    {
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000061;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerEventResetCoalescedUndispatchedEventData");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000304D4(_QWORD *a1)
{
  uint64_t result;
  void *v3;

  if (a1)
  {
    result = _os_feature_enabled_impl("CoreWiFi", "UnifiedKVS");
    if ((_DWORD)result)
      return (int)-[__SCPreferences intValue](sub_10001D90C(a1, CFSTR("Version")), "intValue") > 13;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "__WiFiManagerAllowUnifiedKVS");
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  return result;
}

void sub_100030578(uint64_t a1)
{
  __CFMachPort *v2;
  const void *v3;
  const void *v4;

  v2 = *(__CFMachPort **)(a1 + 56);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    v3 = *(const void **)(a1 + 56);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
}

id sub_1000305C0(_BYTE *cf)
{
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  void *v6;
  unsigned int v7;
  id result;
  void *v9;
  void *v10;

  if (!&_managed_event_fetch)
    return 0;
  if (!cf)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrCheckReassoc");
    goto LABEL_37;
  }
  if (cf[2834])
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: isAwdlRealTimeModeActive", "__WiFiLQAMgrCheckReassoc");
LABEL_37:
    objc_autoreleasePoolPop(v10);
    return 0;
  }
  v2 = *((_DWORD *)cf + 56);
  if (v2 < 3)
    return 0;
  if (cf[640])
  {
    if (cf[2844])
    {
      if ((~*((_DWORD *)cf + 710) & 3) == 0)
      {
        v3 = *((_DWORD *)cf + 699);
        if (v3 > -65)
        {
          v4 = *((_DWORD *)cf + 709);
          v5 = v3 - v4;
          if (v3 - v4 < 0)
            v5 = v4 - v3;
          if (v5 >= 0xA && (v2 == 4 || v2 == 3 && v3 > v4))
          {
            v6 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Attempting host triggered roam to 5GHz band due to RSSI change on 2.4GHz(Env: %d linkUpRssi: %d lastRssi: %d)", "__WiFiLQAMgrCheckPref5GhzReAssoc", *((unsigned int *)cf + 56), *((unsigned int *)cf + 709), *((unsigned int *)cf + 699));
            objc_autoreleasePoolPop(v6);
            v7 = objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "roamWithReason:bandPreference:", 5, 0);
            result = 0;
            if (v7)
            {
              result = 0;
              cf[2844] = 0;
            }
            return result;
          }
        }
      }
    }
  }
  if (*((int *)cf + 699) >= -65 || cf[200])
    return 0;
  if (!cf[2832] && &_managed_event_fetch)
  {
    *((_DWORD *)cf + 123) = 0;
    *((_DWORD *)cf + 707) = 12;
    if (sub_10004A888(cf, 0, 0))
    {
      result = 0;
      cf[200] = 1;
      return result;
    }
    if (cf[200])
      return 0;
  }
  result = (id)sub_10004A964((uint64_t)cf);
  if ((_DWORD)result)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Attempting host triggered roam based on MacStats", "__WiFiLQAMgrCheckReassoc");
    objc_autoreleasePoolPop(v9);
    return objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "roamWithReason:bandPreference:", 4, 0);
  }
  return result;
}

uint64_t sub_100030814(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;
  const void *v7;
  uint64_t (*v8)(uint64_t, _QWORD, id, _QWORD);
  uint64_t v9;
  uint64_t v11;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef null", "__WiFiLQAMgrCheckColocatedScopeTransition", v11);
    goto LABEL_11;
  }
  if (*(_QWORD *)(a1 + 608) < 2uLL || *(_BYTE *)(a1 + 600))
    return 0;
  if (*(double *)(a1 + 64) == 0.0)
  {
    v2 = 0.0;
LABEL_9:
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Wait for atleast 10 seconds before transition (%f)", "__WiFiLQAMgrCheckColocatedScopeTransition", *(_QWORD *)&v2);
LABEL_11:
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  v2 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 64);
  if (v2 <= 10.0)
    goto LABEL_9;
  v3 = *(unsigned int *)(a1 + 2796);
  if (sub_10003153C(*(_QWORD *)(a1 + 48)) == 1)
  {
    v4 = 2;
    v3 = 4294967221;
    goto LABEL_16;
  }
  if (sub_10003153C(*(_QWORD *)(a1 + 48)) == 2)
  {
    if (*(int *)(a1 + 2796) <= -76)
    {
      v4 = 1;
      v3 = 4294967211;
      goto LABEL_16;
    }
    return 0;
  }
  v4 = 0;
LABEL_16:
  v6 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyColocatedScopeTransitionNetwork:minRssi:maxRssi:band:", *(_QWORD *)(a1 + 48), v3, 0xFFFFFFFFLL, v4);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = *(uint64_t (**)(uint64_t, _QWORD, id, _QWORD))(a1 + 584);
  if (v8)
  {
    *(_BYTE *)(a1 + 600) = v8(a1, *(_QWORD *)(a1 + 40), v6, *(_QWORD *)(a1 + 592));
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  CFRelease(v7);
  return v9;
}

void sub_1000309B0(uint64_t a1)
{
  if (a1)
    sub_100005C88(a1, 1);
}

void sub_1000309C0(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  const void *v6;
  const void *v7;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v9;
  const __CFDictionary *Value;
  __CFDictionary *v11;
  __CFDictionary *v12;
  void *v13;
  void (*v14)(uint64_t, uint64_t, _QWORD, __CFDictionary *);
  __CFDictionary *v15;
  void *v16;

  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceRealtimeSessionEvent");
    goto LABEL_26;
  }
  if (!a3)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceRealtimeSessionEvent");
LABEL_26:
    objc_autoreleasePoolPop(v16);
    return;
  }
  if (*(_BYTE *)(a1 + 208)
    && (v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 216), CFSTR("recommendationFlags"))) != 0)
  {
    v7 = v6;
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a3);
    v9 = MutableCopy;
    if (MutableCopy)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("QUAL_SCORE"));
      v11 = Value
          ? CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value)
          : CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v12 = v11;
      if (v11)
      {
        CFDictionarySetValue(v11, CFSTR("LINK_RECOMMENDATION_FLAGS"), v7);
        CFDictionarySetValue(v9, CFSTR("QUAL_SCORE"), v12);
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: hi-jacking real-time session recommendation flags: %@", "__WiFiDeviceRealtimeSessionEvent", v9);
        objc_autoreleasePoolPop(v13);
        CFRelease(v12);
      }
    }
  }
  else
  {
    v9 = 0;
  }
  v14 = *(void (**)(uint64_t, uint64_t, _QWORD, __CFDictionary *))(a1 + 4920);
  if (v14)
  {
    if (v9)
      v15 = v9;
    else
      v15 = a3;
    v14(a1, a2, *(_QWORD *)(a1 + 4928), v15);
  }
  if (v9)
    CFRelease(v9);
}

void sub_100030BC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 4872);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 4880), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceProcessWeightAvgLQMEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_100030C54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 4856);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 4864), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: txStatsRef is null", "__WiFiDeviceProcessLqmTxStatsEvent");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_100030CE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 4248);
    if (v3)
      return v3(a3, a2, *(_QWORD *)(a3 + 4256));
  }
  return result;
}

void sub_100030D00(int a1, int a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3)
    sub_100011244(*(_QWORD *)(a3 + 120), theDict);
}

void sub_100030D14(uint64_t a1, uint64_t a2)
{
  sub_100030D24(a2, *(_QWORD *)(a1 + 32));
}

void sub_100030D24(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2)
  {
    if (!a1)
      return;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATSUpdate P2P Error: %ld device:%p deviceManager:%p manager:%p\n", "__CatsP2PUpdateCallback", a1, *(_QWORD *)(a2 + 64), a2, *(_QWORD *)(a2 + 424));
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CATS P2P callback Invalid argument\n", "__CatsP2PUpdateCallback", v5, v6, v7, v8);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_100030DE8(uint64_t a1)
{
  const void *v2;

  (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56), *(unsigned int *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_100030E3C(uint64_t a1)
{
  const void *v2;

  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 136))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 128), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

uint64_t sub_100030E8C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 72), *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48));
}

BOOL sub_100030EA0(_QWORD *a1)
{
  _BOOL8 result;

  result = sub_1000071A0(*(unsigned int **)(a1[4] + 8), *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40));
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
  return result;
}

uint64_t sub_100030EE0(uint64_t a1)
{
  uint64_t result;

  result = sub_100031A6C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
  if (!(_DWORD)result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  return result;
}

_DWORD *sub_100030F1C(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_1000063FC(result[3], result[8]);
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t sub_100030F7C(uint64_t result, uint64_t a2)
{
  int v3;
  unsigned int *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  __int128 v10[2];

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v3 = -304;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_9;
  }
  if (*(_DWORD *)(result + 56) || *(_DWORD *)(result + 60) <= 0x1Fu)
  {
    v3 = -309;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  v4 = (unsigned int *)(a2 + 28);
  *(_QWORD *)(a2 + 32) = 0x11000000000000;
  v5 = *(_DWORD *)(result + 12);
  v6 = *(_DWORD *)(result + 48);
  v7 = *(unsigned int *)(result + 52);
  v8 = *(_DWORD *)(result + 28);
  v9 = *(_OWORD *)(result + 92);
  v10[0] = *(_OWORD *)(result + 76);
  v10[1] = v9;
  result = sub_100005D74(v5, v6, v7, v8, v4, (_DWORD *)(a2 + 48), v10);
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 40) = NDR_record;
    *(_DWORD *)a2 |= 0x80000000;
    *(_DWORD *)(a2 + 4) = 52;
    *(_DWORD *)(a2 + 24) = 1;
    return result;
  }
  *(_DWORD *)(a2 + 32) = result;
LABEL_10:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100031080(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = (_DWORD *)sub_1000059A0(result[3], (vm_offset_t *)(a2 + 28), (mach_msg_type_number_t *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100031124(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_100006724(result[3]);
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t sub_10003117C(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  NDR_record_t v6;
  int v7;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 3 || *(_DWORD *)(result + 4) != 96)
  {
    v7 = -304;
LABEL_13:
    *(_DWORD *)(a2 + 32) = v7;
    v6 = NDR_record;
    goto LABEL_14;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || *(_BYTE *)(result + 71) != 1
    || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 84))
    || (v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 88))
    || (v5 = *(_DWORD *)(result + 72), v5 != *(_DWORD *)(result + 92)))
  {
    v7 = -300;
    goto LABEL_13;
  }
  result = sub_10001D410(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, *(UInt8 **)(result + 44), v4, *(UInt8 **)(result + 60), v5, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v6 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_14:
  *(NDR_record_t *)(a2 + 24) = v6;
  return result;
}

uint64_t sub_10003126C(uint64_t result, uint64_t a2)
{
  unsigned int v3;
  NDR_record_t v4;
  int v5;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    v4 = NDR_record;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    v5 = -300;
    goto LABEL_9;
  }
  result = sub_10000708C(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), v3, (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  v4 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_10:
  *(NDR_record_t *)(a2 + 24) = v4;
  return result;
}

uint64_t sub_10003131C(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 76)
  {
    v3 = -304;
LABEL_11:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_12;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 68)
    || *(_DWORD *)(result + 56) != *(_DWORD *)(result + 72))
  {
    v3 = -300;
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = sub_10000ABD4(*(_DWORD *)(result + 12), *(UInt8 **)(result + 28), *(_DWORD *)(result + 40), *(UInt8 **)(result + 44), *(_DWORD *)(result + 56), (vm_offset_t *)(a2 + 28), (mach_msg_type_number_t *)(a2 + 52));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_12:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

float sub_100031420(int a1)
{
  float v1;
  float v2;

  v1 = (float)a1 + 77.5;
  v2 = fabsf(sqrtf((float)(v1 * v1) + 450.0));
  return (float)(v1 / (float)(v2 + v2)) + 0.5;
}

uint64_t sub_10003145C(uint64_t result)
{
  const __CFDictionary *v1;

  if (result)
  {
    v1 = *(const __CFDictionary **)(result + 16);
    if (sub_10002CEF4(v1))
      return 1;
    else
      return sub_10002CEB0(v1);
  }
  return result;
}

const __CFString *sub_10003149C(const void *a1)
{
  const __CFString *result;
  const __CFString *v3;

  result = (const __CFString *)sub_10002BE64((uint64_t)a1, CFSTR("SSID"));
  if (!result)
  {
    result = (const __CFString *)sub_10002B088(a1);
    if (result)
    {
      result = (const __CFString *)CFStringCreateExternalRepresentation(kCFAllocatorDefault, result, 0x8000100u, 0);
      if (result)
      {
        v3 = result;
        sub_10002C478((uint64_t)a1, CFSTR("SSID"), result);
        CFRelease(v3);
        return (const __CFString *)sub_10002BE64((uint64_t)a1, CFSTR("SSID"));
      }
    }
  }
  return result;
}

uint64_t sub_10003153C(uint64_t result)
{
  const void *v1;
  CFTypeID v2;
  uint64_t v3;
  const void *v4;
  const __CFNumber *v5;
  CFTypeID v6;
  uint64_t v7;
  int valuePtr;
  int v9;

  v9 = 0;
  if (result)
  {
    v1 = (const void *)result;
    v2 = CFGetTypeID((CFTypeRef)result);
    v3 = qword_10026D6C8;
    if (!qword_10026D6C8)
    {
      pthread_once(&stru_10026CC60, (void (*)(void))sub_1000C3168);
      v3 = qword_10026D6C8;
    }
    if (v2 == v3)
    {
      v4 = sub_10002BE64((uint64_t)v1, CFSTR("CHANNEL"));
      v5 = (const __CFNumber *)sub_10002BE64((uint64_t)v1, CFSTR("CHANNEL_FLAGS"));
      if (v5)
      {
        valuePtr = 0;
        CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
        if ((valuePtr & 8) != 0)
          return 1;
        if ((valuePtr & 0x10) != 0)
          return 2;
        if ((valuePtr & 0x2000) != 0)
          return 3;
      }
      v1 = v4;
      if (!v4)
        return 0;
    }
    else
    {
      v6 = CFGetTypeID(v1);
      if (v6 != CFNumberGetTypeID())
        return 0;
    }
    CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &v9);
    if (v9)
    {
      if (v9 < 15)
        return 1;
      v7 = 0;
      while (v9 != dword_10026CBD8[v7])
      {
        if (++v7 == 33)
          return 0;
      }
      return 2;
    }
    return 0;
  }
  return result;
}

uint64_t sub_100031670(const void *a1)
{
  const __CFNumber *v2;
  uint64_t v3;
  unsigned int v4;

  v2 = (const __CFNumber *)sub_10002BE64((uint64_t)a1, CFSTR("UserDirected"));
  v3 = sub_10001F500(v2);
  if (v3 || !sub_10001F440(a1))
  {
    v4 = 0;
  }
  else
  {
    sub_10002C478((uint64_t)a1, CFSTR("UserDirected"), kCFBooleanTrue);
    v4 = 1;
  }
  if (v3)
    return 1;
  else
    return v4;
}

const void *sub_1000316E0(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_10002BE64(a1, CFSTR("CHANNEL"));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetChannel");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_100031750(uint64_t a1)
{
  void *v1;
  _QWORD context[4];

  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000007CLL;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiManagerTraficEngrAppInfo");
    objc_autoreleasePoolPop(v1);
  }
}

void sub_1000317E8(uint64_t a1)
{
  void *v2;
  void *v3;
  const char *v4;
  void *v5;
  uint64_t context;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!*(_BYTE *)(a1 + 314) || *(_DWORD *)(a1 + 788) == 2)
  {
    context = a1;
    v7 = 0xAAAAAAAA00000030;
    v8 = 0;
    v9 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    if ((_BYTE)v9 || sub_100092B74(a1))
    {
      v2 = objc_autoreleasePoolPush();
      v3 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        context = a1;
        v7 = 0xAAAAAAAA00000030;
        v8 = 0;
        v9 = 0;
        CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
        if ((_BYTE)v9)
          v4 = "WoW";
        else
          v4 = "LPAS";
        objc_msgSend(v3, "WFLog:message:", 3, "%s Enabled, Skip starting Disassocation timer", v4);
      }
      objc_autoreleasePoolPop(v2);
    }
    else if (!*(_DWORD *)(a1 + 952))
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Starting Disassociation Timer");
      objc_autoreleasePoolPop(v5);
      sub_100093A70(a1, 1, *(double *)(a1 + 928));
      *(_DWORD *)(a1 + 952) = 2;
    }
  }
}

void sub_100031928(uint64_t a1, int a2)
{
  _QWORD context[4];
  int v4;

  v4 = a2;
  if (a2)
  {
    if (*(_DWORD *)(a1 + 788) != 2)
      sub_100031B4C(a1);
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000014;
    context[2] = &v4;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

uint64_t sub_100031998(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  void *v6;
  _QWORD context[4];

  v4 = (const __CFArray *)sub_100032320(a2);
  if (v4)
  {
    v5 = v4;
    if (CFArrayGetCount(v4))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing hosted networks for client %@ - %@", "WiFiManagerRemoveHostedNetworks", sub_1000161D4(a2), v5);
      objc_autoreleasePoolPop(v6);
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000039;
      context[2] = v5;
      context[3] = 0;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  return 0;
}

uint64_t sub_100031A60(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t sub_100031A6C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 316);
}

uint64_t sub_100031A74(uint64_t a1)
{
  return *(unsigned int *)(a1 + 336);
}

void sub_100031A7C(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000068;
  v2[2] = a2;
  v2[3] = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
}

void sub_100031ABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD context[3];

  if (a1 && a2 && a3)
  {
    context[0] = a1;
    context[1] = a2;
    context[2] = a3;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000098F8, context);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid arguments", "WiFiManagerCatsUcmUpdate");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_100031B4C(uint64_t a1)
{
  int v2;
  void *v3;
  void *v4;

  v2 = *(_DWORD *)(a1 + 952);
  if ((v2 - 1) < 2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Canceling disassociation timer");
    objc_autoreleasePoolPop(v4);
    sub_100093A70(a1, 1, 315360000.0);
  }
  else
  {
    if (!v2)
      return;
    if (v2 == 3)
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation timer already fired, so no need to cancel");
      objc_autoreleasePoolPop(v3);
      sub_1000094BC(a1, 1);
    }
  }
  *(_DWORD *)(a1 + 952) = 0;
}

uint64_t sub_100031C0C(uint64_t result)
{
  if (result)
  {
    result = *(_QWORD *)(result + 72);
    if (result)
      return dispatch_mach_cancel();
  }
  return result;
}

uint64_t sub_100031C20(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = dispatch_mach_create_f("WiFiManager/base", a2, a1, sub_100011A50);
  *(_QWORD *)(a1 + 72) = result;
  if (result)
    return dispatch_mach_connect(result, *(unsigned int *)(a1 + 16), 0, 0);
  return result;
}

uint64_t sub_100031C74(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 96) = a2;
  *(_QWORD *)(result + 104) = a3;
  return result;
}

_QWORD *sub_100031C7C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _OWORD *Instance;
  _QWORD *v9;
  uint64_t v10;
  CFMachPortContext v12;

  if (a2 < 1)
    return 0;
  if (!qword_10026D6B0)
    pthread_once(&stru_10026CAF8, (void (*)(void))sub_1000BF8B8);
  Instance = (_OWORD *)_CFRuntimeCreateInstance(a1);
  v9 = Instance;
  if (Instance)
  {
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[1] = 0u;
    Instance[2] = 0u;
    *((_DWORD *)Instance + 4) = a3;
    if (!a4
      || ((v12.version = 0, memset(&v12.retain, 0, 24), v12.info = Instance, !a3)
        ? (v10 = (uint64_t)CFMachPortCreate(kCFAllocatorDefault, (CFMachPortCallBack)sub_1000BF900, &v12, 0))
        : (v10 = sub_1000648E4()),
          (v9[7] = v10) != 0))
    {
      v9[3] = a2;
      return v9;
    }
    CFRelease(v9);
    return 0;
  }
  return v9;
}

uint64_t sub_100031D84(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 2792) = a2;
  return result;
}

void sub_100031D90(uint64_t a1)
{
  const void *v2;
  void *v3;

  if (a1)
  {
    v2 = *(const void **)(a1 + 152);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 152) = 0;
    }
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrResetCoalescedUndispatchedLQMEvent");
    objc_autoreleasePoolPop(v3);
  }
}

BOOL sub_100031E10(const __CFString *a1)
{
  return CFStringFind(a1, CFSTR("facetime"), 1uLL).length != 0;
}

uint64_t sub_100031E38(uint64_t result, char a2)
{
  *(_BYTE *)(result + 5959) = a2;
  return result;
}

uint64_t sub_100031E48(uint64_t a1)
{
  void *v2;

  if (a1)
    return 0;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: NULL Device Manager !", "WiFiDeviceManagerSetTrafficEngrAppInfo");
  objc_autoreleasePoolPop(v2);
  return 4294963396;
}

uint64_t sub_100031EB4(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  uint64_t *v6;
  void *v7;

  if (result)
  {
    v3 = result;
    *(_BYTE *)(result + 3464) = a2;
    v4 = *(_QWORD *)(result + 64);
    v5 = (const void *)sub_100025C3C(v4);
    v6 = (uint64_t *)&kCFBooleanTrue;
    if (!a2)
      v6 = (uint64_t *)&kCFBooleanFalse;
    sub_1000672C0(v4, v5, 483, 0, *v6);
    v7 = *(void **)(v3 + 7368);
    if (v7)
      objc_msgSend(v7, "setDeviceChargingState:", *(_BYTE *)(v3 + 3464) != 0);
    sub_100031D84(*(_QWORD *)(v3 + 120), *(_BYTE *)(v3 + 3464));
    return sub_100031E38(*(_QWORD *)(v3 + 64), *(_BYTE *)(v3 + 3464));
  }
  return result;
}

void sub_100031F50(uint64_t a1)
{
  void *v1;

  if (a1)
  {
    sub_100031D90(*(_QWORD *)(a1 + 120));
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: device manager is NULL", "WiFiDeviceManagerResetCoalescedUndispatchedLQMEvent");
    objc_autoreleasePoolPop(v1);
  }
}

uint64_t sub_100031FC0(uint64_t result)
{
  if (result)
    return sub_10002BF80(*(_QWORD *)(result + 64));
  return result;
}

const __CFString *sub_100031FD0(unsigned int a1)
{
  if (a1 > 0x14)
    return CFSTR("Bogus");
  else
    return off_100231EA8[a1];
}

uint64_t sub_100031FF4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

BOOL sub_100031FFC(uint64_t a1, uint64_t a2)
{
  return sub_100032160(*(_QWORD *)(a1 + 64), a2) == 0;
}

void sub_10003201C(uint64_t a1, const __CFDictionary **a2)
{
  void *v2;

  if (a1)
  {
    if (a2)
    {
      *a2 = sub_100010050(*(_QWORD *)(a1 + 120));
      return;
    }
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: dictCopy is NULL", "WiFiDeviceManagerCopyCoalescedUndispatchedLQMEvent");
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: device manager is NULL", "WiFiDeviceManagerCopyCoalescedUndispatchedLQMEvent");
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000320CC(uint64_t a1, const __CFDictionary *a2)
{
  void *v2;

  if (a1 && a2)
  {
    sub_100012660(*(_QWORD *)(a1 + 120), a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error: %s: device manager is NULL", "WiFiDeviceManagerCoalesceUndispatchedLQMEvent");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_100032140(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (a2)
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 7064), a2);
  }
}

uint64_t sub_100032154(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 39) >> 2) & 1;
}

uint64_t sub_100032160(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v9;

  if (!a1)
    return 4294963396;
  for (i = 6; ; --i)
  {
    v5 = Apple80211Get(*(_QWORD *)(a1 + 16), 51, 0, a2, 8);
    v6 = v5;
    if ((int)v5 <= 15)
    {
      if ((_DWORD)v5 != -3905)
        break;
    }
    else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
    {
      goto LABEL_15;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v5)
    return v6;
LABEL_15:
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error copying locale %d", v6);
  objc_autoreleasePoolPop(v9);
  return v6;
}

uint64_t sub_100032234(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v9;

  if (!a1)
    return 4294963396;
  for (i = 6; ; --i)
  {
    v5 = Apple80211Get(*(_QWORD *)(a1 + 16), 423, 0, a2, 4);
    v6 = v5;
    if ((int)v5 <= 15)
    {
      if ((_DWORD)v5 != -3905)
        break;
    }
    else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
    {
      goto LABEL_15;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v5)
    return v6;
LABEL_15:
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WiFiMC : Error getting band support %d", v6);
  objc_autoreleasePoolPop(v9);
  return v6;
}

uint64_t sub_100032308(uint64_t a1, uint64_t a2)
{
  return sub_100031C20(*(_QWORD *)(a1 + 88), a2);
}

uint64_t sub_100032310(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 144) = a2;
  *(_QWORD *)(result + 152) = a3;
  return result;
}

uint64_t sub_100032318(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t sub_100032320(uint64_t a1)
{
  return *(_QWORD *)(a1 + 168);
}

uint64_t sub_100032328(uint64_t a1)
{
  return sub_100005830(*(_QWORD *)(a1 + 88));
}

uint64_t sub_100032330(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t sub_100032338(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

void sub_100032CA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_100032CC0(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(v1 + 32);
  *(_QWORD *)(v1 + 32) = 0;

}

void sub_100032CD0(uint64_t a1)
{
  void *v2;
  double v3;
  double v4;
  double v5;
  uint64_t v6;
  int v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *i;
  void *v15;
  unint64_t v16;
  BOOL v17;
  void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  id v24;
  id v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[128];
  _BYTE v45[128];

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
  objc_msgSend(v2, "timeIntervalSinceDate:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
  v4 = v3;
  v5 = (double)*(unint64_t *)(a1 + 48);

  if (v4 >= v5)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: learning period exceeded max time of %llu seconds", "-[WiFiNWReliabilityMonitor waitForNetworkToBeReliableWithTimeout:withTimeout:withMgrCallback:]_block_invoke_2", *(_QWORD *)(a1 + 48));
LABEL_37:
    objc_autoreleasePoolPop(v32);
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 65) = 0;
    objc_msgSend(*(id *)(a1 + 32), "_evaluationComplete:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(unsigned __int8 *)(v6 + 65);
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v8 = *(id *)(v6 + 16);
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v40, v45, 16);
    if (v9)
    {
      v10 = v9;
      LODWORD(v11) = 0;
      if (v7)
        v12 = 16;
      else
        v12 = 8;
      v13 = *(_QWORD *)v41;
      while (2)
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v41 != v13)
            objc_enumerationMutation(v8);
          v15 = *(void **)(*((_QWORD *)&v40 + 1) + 8 * (_QWORD)i);
          if ((objc_msgSend(v15, "isSessionReliable:", v12) & 1) == 0)
          {
            v20 = objc_autoreleasePoolPush();
            v21 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "description"));
              objc_msgSend(v21, "WFLog:message:", 3, "%s: session:%@ is not yet reliable for atleast %lu samples", "-[WiFiNWReliabilityMonitor waitForNetworkToBeReliableWithTimeout:withTimeout:withMgrCallback:]_block_invoke_2", v22, v12);

            }
            objc_autoreleasePoolPop(v20);

            goto LABEL_25;
          }
          v16 = (unint64_t)objc_msgSend(v15, "getSampleCount:", 1);
          v17 = v12 > v16;
          v12 -= v16;
          if (!v17)
          {

            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
            v31 = objc_autoreleasePoolPush();
            v32 = v31;
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is reliable!", "-[WiFiNWReliabilityMonitor waitForNetworkToBeReliableWithTimeout:withTimeout:withMgrCallback:]_block_invoke_2", v35);
            goto LABEL_37;
          }
          v11 = (v11 + v16);
        }
        v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v40, v45, 16);
        if (v10)
          continue;
        break;
      }
    }
    else
    {
      v11 = 0;
    }

    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v19 = 16;
      if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 65))
        v19 = 8;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Available samples: %d less than threshold: %d!", "-[WiFiNWReliabilityMonitor waitForNetworkToBeReliableWithTimeout:withTimeout:withMgrCallback:]_block_invoke_2", v11, v19);
    }
    objc_autoreleasePoolPop(v18);
LABEL_25:
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 65) = 0;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v23 = *(id *)(*(_QWORD *)(a1 + 32) + 16);
    v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
    if (v24)
    {
      v25 = v24;
      v26 = 0;
      v27 = 0;
      v28 = *(_QWORD *)v37;
      while (2)
      {
        v29 = 0;
        v30 = v27 + (_DWORD)v25;
        do
        {
          if (*(_QWORD *)v37 != v28)
            objc_enumerationMutation(v23);
          v26 += (unint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)v29), "getSampleCount:", 1);
          if (v26 > 0xF)
          {
            v30 = v27 + (_DWORD)v29 + 1;
            goto LABEL_39;
          }
          v29 = (char *)v29 + 1;
        }
        while (v25 != v29);
        v25 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
        v27 = v30;
        if (v25)
          continue;
        break;
      }
    }
    else
    {
      v30 = 0;
    }
LABEL_39:

    v33 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 16), "count") - v30;
    if ((int)v33 >= 1)
    {
      objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 16), "removeObjectsInRange:", v30, v33);
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Discarded %d sessions", "-[WiFiNWReliabilityMonitor waitForNetworkToBeReliableWithTimeout:withTimeout:withMgrCallback:]_block_invoke_2", v33);
      objc_autoreleasePoolPop(v34);
    }
  }
}

void sub_100033790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

id sub_1000337B4(uint64_t a1, void *a2, _BYTE *a3)
{
  id result;

  result = objc_msgSend(a2, "data");
  if ((int)result <= -76)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    *a3 = 1;
  }
  if (++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) >= *(_DWORD *)(a1 + 48))
    *a3 = 1;
  return result;
}

void sub_1000339A0(id a1)
{
  id v1;
  void *v2;

  v1 = -[WiFiAIRAgent _initPrivate]([WiFiAIRAgent alloc], "_initPrivate");
  v2 = (void *)qword_10026D538;
  qword_10026D538 = (uint64_t)v1;

}

void sub_100033AE4(uint64_t a1)
{
  uint64_t v2;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  unsigned __int8 v8;

  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 25))
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v2 == 8 || v2 == 1)
    {
      v4 = objc_autoreleasePoolPush();
      v5 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"));
        objc_msgSend(v5, "WFLog:message:", 3, "%s: realtime app state changed to %d", "-[WiFiAIRAgent _userInteractivityChangedCallback:]_block_invoke", objc_msgSend(v6, "isRealTimeAppActive"));

      }
      objc_autoreleasePoolPop(v4);
      v7 = (void *)objc_claimAutoreleasedReturnValue(+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"));
      v8 = objc_msgSend(v7, "isRealTimeAppActive");

      if ((v8 & 1) == 0)
      {
        objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "terminateNetworkReliabilityEvaluation");
        objc_msgSend(*(id *)(a1 + 32), "_evaluationComplete:", 5);
      }
    }
  }
}

void sub_100033E38(id a1, void *a2, unint64_t a3)
{
  void *v4;
  id v5;

  v5 = a2;
  if (v5)
  {
    objc_msgSend(v5, "_userInteractivityChangedCallback:", a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null agent", "-[WiFiAIRAgent waitForConfirmationWithTimeout:withBssEnvironment:withMgrCallback:]_block_invoke");
    objc_autoreleasePoolPop(v4);
  }

}

id sub_100033EB8(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "_evaluationComplete:", objc_msgSend(*(id *)(a1 + 32), "convertFromNWReliabilityMonitorResult:", a2));
}

void sub_100034144(uint64_t a1)
{
  id v1;
  void *v2;

  v1 = objc_alloc_init(*(Class *)(a1 + 32));
  v2 = (void *)qword_10026D540;
  qword_10026D540 = (uint64_t)v1;

}

void sub_1000341C4(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  NSObject *v8;
  id v9;
  id v10;
  _QWORD block[5];
  id v12;

  v10 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "ambiguousSSIDs"));
  v4 = objc_autoreleasePoolPush();
  v5 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v6 = objc_msgSend(CFSTR("AmbiguousSSIDs"), "UTF8String");
    v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "description")));
    objc_msgSend(v5, "WFLog:message:", 3, "%s: %s\n", v6, objc_msgSend(v7, "UTF8String"));

  }
  objc_autoreleasePoolPop(v4);
  v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000342DC;
  block[3] = &unk_10022EA60;
  block[4] = *(_QWORD *)(a1 + 32);
  v12 = v3;
  v9 = v3;
  dispatch_sync(v8, block);

}

void sub_1000342DC(uint64_t a1)
{
  sub_1000A70B4((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager"), *(const __CFArray **)(a1 + 40));
}

uint64_t sub_1000347C4(uint64_t a1)
{
  id v2;
  uint64_t result;

  v2 = objc_msgSend(*(id *)(a1 + 32), "queryLOITypeAtLatestLocation");
  result = *(_QWORD *)(a1 + 40);
  if (result)
    return (*(uint64_t (**)(uint64_t, id))(result + 16))(result, v2);
  return result;
}

void sub_100034B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 176), 8);
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose((const void *)(v29 - 112), 8);
  _Unwind_Resume(a1);
}

id sub_100034B60(id result, void *a2, uint64_t a3)
{
  id v3;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE v13[128];

  v3 = result;
  if (a2)
  {
    if (!a3)
    {
      v11 = 0u;
      v12 = 0u;
      v9 = 0u;
      v10 = 0u;
      result = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
      if (result)
      {
        v5 = result;
        v6 = *(_QWORD *)v10;
        do
        {
          v7 = 0;
          do
          {
            if (*(_QWORD *)v10 != v6)
              objc_enumerationMutation(a2);
            v8 = *(void **)(*((_QWORD *)&v9 + 1) + 8 * (_QWORD)v7);
            if (!objc_msgSend(v8, "type"))
              *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 8) + 24) = 1;
            if (objc_msgSend(v8, "type") == (id)1)
              *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 6) + 8) + 24) = 1;
            v7 = (char *)v7 + 1;
          }
          while (v5 != v7);
          result = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
          v5 = result;
        }
        while (result);
      }
    }
  }
  if (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 7) + 8) + 24))
    return (id)dispatch_semaphore_signal(*((dispatch_semaphore_t *)v3 + 4));
  return result;
}

id sub_100034CA0(id result, void *a2, uint64_t a3)
{
  id v3;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE v13[128];

  v3 = result;
  if (a2)
  {
    if (!a3)
    {
      v11 = 0u;
      v12 = 0u;
      v9 = 0u;
      v10 = 0u;
      result = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
      if (result)
      {
        v5 = result;
        v6 = *(_QWORD *)v10;
        do
        {
          v7 = 0;
          do
          {
            if (*(_QWORD *)v10 != v6)
              objc_enumerationMutation(a2);
            v8 = *(void **)(*((_QWORD *)&v9 + 1) + 8 * (_QWORD)v7);
            if (!objc_msgSend(v8, "type") || objc_msgSend(v8, "type") == (id)1)
              *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 5) + 8) + 24) = 1;
            v7 = (char *)v7 + 1;
          }
          while (v5 != v7);
          result = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
          v5 = result;
        }
        while (result);
      }
    }
  }
  if (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 6) + 8) + 24))
    return (id)dispatch_semaphore_signal(*((dispatch_semaphore_t *)v3 + 4));
  return result;
}

id sub_100034DD4(uint64_t a1)
{
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setAccuracyOfBestReading:", *(double *)(a1 + 40));
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setBestLatitudeReading:", *(double *)(a1 + 48));
  return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setBestLongitudeReading:", *(double *)(a1 + 56));
}

void sub_100035350(id a1)
{
  qword_10026D558 = objc_alloc_init(WiFiAnalyticsManager);
}

void sub_100035E78(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100035E90(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  NSNumber *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  NSObject *v17;
  uint64_t v18;
  _QWORD v19[6];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  _BYTE v29[128];

  if (objc_msgSend(*(id *)(a1 + 32), "deviceAnalyticsClient"))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "deviceAnalyticsClient"), "neighborChannelsForBSS:ssid:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
    v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    v3 = +[NSMutableArray array](NSMutableArray, "array");
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v25;
      do
      {
        v7 = 0;
        do
        {
          if (*(_QWORD *)v25 != v6)
            objc_enumerationMutation(v2);
          objc_msgSend(v3, "addObject:", *(_QWORD *)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)v7));
          v7 = (char *)v7 + 1;
        }
        while (v5 != v7);
        v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
      }
      while (v5);
    }
    v8 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "deviceAnalyticsClient"), "rssiRoamTriggerForBSS:ssid:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48)));
    v9 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "deviceAnalyticsClient"), "neighborsForBSS:ssid:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
    v10 = +[NSMutableArray array](NSMutableArray, "array");
    if (v9)
    {
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
      if (v11)
      {
        v12 = v11;
        v13 = *(_QWORD *)v21;
        do
        {
          v14 = 0;
          do
          {
            if (*(_QWORD *)v21 != v13)
              objc_enumerationMutation(v9);
            objc_msgSend(v10, "addObject:", *(_QWORD *)(*((_QWORD *)&v20 + 1) + 8 * (_QWORD)v14));
            v14 = (char *)v14 + 1;
          }
          while (v12 != v14);
          v12 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
        }
        while (v12);
      }
    }
    v15 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    v16 = v15;
    if (v3)
      objc_msgSend(v15, "setObject:forKey:", v3, CFSTR("ADAPTIVE_ROAM_CHANNELS_INFO"));
    if (v10)
      objc_msgSend(v16, "setObject:forKey:", v10, CFSTR("SCAN_BSSID_LIST"));
  }
  else
  {
    v16 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
    v8 = (NSNumber *)&off_100252C90;
  }
  objc_msgSend(v16, "setObject:forKey:", v8, CFSTR("ADAPTIVE_ROAM_RSSI_TRIGGER"));
  if (objc_msgSend(*(id *)(a1 + 32), "wifiManager"))
  {
    if (sub_100031A60((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager")))
    {
      v17 = sub_100031A60((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager"));
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_100036168;
      v19[3] = &unk_10022EB70;
      v18 = *(_QWORD *)(a1 + 32);
      v19[4] = v16;
      v19[5] = v18;
      dispatch_sync(v17, v19);
    }
  }
}

id sub_100036168(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: request %@", "-[WiFiAnalyticsManager getAdaptiveRoamParams:ssid:]_block_invoke", *(_QWORD *)(a1 + 32));
  objc_autoreleasePoolPop(v2);
  sub_1000ABE64((uint64_t)objc_msgSend(*(id *)(a1 + 40), "wifiManager"), *(_QWORD *)(a1 + 32));
  return objc_msgSend(*(id *)(a1 + 40), "setRoamParamsQueryPending:", 0);
}

int sub_1000368CC(id a1, unsigned int a2, unsigned int a3)
{
  return sub_1000C5C1C(a2, a3);
}

void sub_100036D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100036D44(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;
  id v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  v3 = objc_msgSend(objc_msgSend(v2, "deviceAnalyticsClient"), "copyAllStoredNetworkSsidsWithTrait:", 0);
  if (v3)
  {
    v4 = v3;
    objc_msgSend(objc_msgSend(v2, "movingNetworkSsidsCache"), "removeAllObjects");
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "addObjectsFromArray:", v4);

  }
  v5 = objc_msgSend(objc_msgSend(v2, "deviceAnalyticsClient"), "copyAllStoredNetworkSsidsWithTrait:", 1);
  if (v5)
  {
    v6 = v5;
    objc_msgSend(objc_msgSend(v2, "omnipresentNetworkSsidsCache"), "removeAllObjects");
    objc_msgSend(objc_msgSend(v2, "omnipresentNetworkSsidsCache"), "addObjectsFromArray:", v6);

  }
  v7 = objc_msgSend(objc_msgSend(v2, "deviceAnalyticsClient"), "copyAllStoredNetworkSsidsWithTrait:", 2);
  if (v7)
  {
    v8 = v7;
    objc_msgSend(objc_msgSend(v2, "historicallyBadLinkQualityNetworkSsidsCache"), "removeAllObjects");
    objc_msgSend(objc_msgSend(v2, "historicallyBadLinkQualityNetworkSsidsCache"), "addObjectsFromArray:", v8);

  }
  objc_msgSend(v2, "setDateTraitCachesUpdated:", +[NSDate date](NSDate, "date"));
  objc_msgSend(v2, "setTraitsCacheUpdateBusy:", 0);
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Network traits caches updated at %@", "-[WiFiAnalyticsManager updateNetworkTraitsCache]_block_invoke", objc_msgSend(v2, "dateTraitCachesUpdated"));
  objc_autoreleasePoolPop(v9);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Moving Networks: %@", "-[WiFiAnalyticsManager updateNetworkTraitsCache]_block_invoke", objc_msgSend(v2, "movingNetworkSsidsCache"));
  objc_autoreleasePoolPop(v10);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Omnipresent Networks: %@", "-[WiFiAnalyticsManager updateNetworkTraitsCache]_block_invoke", objc_msgSend(v2, "omnipresentNetworkSsidsCache"));
  objc_autoreleasePoolPop(v11);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HistoricallyBadQuality networks: %@", "-[WiFiAnalyticsManager updateNetworkTraitsCache]_block_invoke", objc_msgSend(v2, "historicallyBadLinkQualityNetworkSsidsCache"));
  objc_autoreleasePoolPop(v12);
}

void sub_100037C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Unwind_Resume(exception_object);
}

void sub_100037CE0(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v8;
  id v9;
  id v10;
  id v11;
  double v12;
  double v13;
  uint64_t v14;
  void *v15;
  void *v16;

  v8 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("cachedSsid"));
  v9 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("cachedDate"));
  v10 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("cachedUsageDict"));
  if (!v8 || !v9 || (v11 = v10) == 0)
  {
    objc_msgSend(*(id *)(a1 + 32), "addIndex:", a3);
    return;
  }
  objc_msgSend(v9, "timeIntervalSinceNow");
  if (v12 < -43200.0)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will remove object from usageCache for ssid %@", "-[WiFiAnalyticsManager getNetworkUsageDictionary:]_block_invoke", v8);
    objc_autoreleasePoolPop(v16);
    objc_msgSend(*(id *)(a1 + 32), "addIndex:", a3);
    if ((objc_msgSend(v8, "isEqualToString:", *(_QWORD *)(a1 + 40)) & 1) != 0)
      goto LABEL_15;
  }
  else
  {
    v13 = -v12;
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(double *)(v14 + 24) < v13)
    {
      *(double *)(v14 + 24) = v13;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = a3;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40) = v8;
    }
    if ((objc_msgSend(v8, "isEqualToString:", *(_QWORD *)(a1 + 40)) & 1) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = 1;
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Using object from usageCache for ssid %@", "-[WiFiAnalyticsManager getNetworkUsageDictionary:]_block_invoke", *(_QWORD *)(a1 + 40));
      objc_autoreleasePoolPop(v15);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 40) = v11;
LABEL_15:
      *a4 = 1;
    }
  }
}

uint64_t sub_100037F44(void *a1, const void *a2, _QWORD *a3, _QWORD *a4)
{
  id v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v18;

  v7 = a1;
  if (!_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
  {
    v9 = 0;
    v10 = 0;
    goto LABEL_26;
  }
  v18 = 0;
  v8 = sub_100038110(v7, a2, &v18);
  v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  v10 = v18;
  if (!v9)
  {
LABEL_26:
    v11 = 0;
    goto LABEL_24;
  }
  if ((objc_opt_respondsToSelector(v9, "accessoryOptions") & 1) == 0)
  {
    if (objc_msgSend(v9, "state") == (id)25)
      v11 = 1;
    else
      v11 = 2;
    if (a3 && v10)
      goto LABEL_17;
    goto LABEL_18;
  }
  if ((objc_msgSend(v9, "performSelector:", "accessoryOptions") & 2) != 0)
  {
    if (objc_msgSend(v9, "state") == (id)25)
      v11 = 1;
    else
      v11 = 2;
    if (a3 && v10)
LABEL_17:
      *a3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "name"));
LABEL_18:
    if (a4 && v10)
      *a4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "identifier"));
    goto LABEL_21;
  }
  v11 = 3;
LABEL_21:
  v12 = objc_autoreleasePoolPush();
  v13 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v14 = objc_msgSend(v9, "state");
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "name"));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "identifier"));
    objc_msgSend(v13, "WFLog:message:", 3, "%s: info.state=%ld deviceName='%@' deviceIdentifier='%@'", "WiFiDeviceAccessCheckIfAppIsAuthorizedForNetwork", v14, v15, v16);

  }
  objc_autoreleasePoolPop(v12);
LABEL_24:

  return v11;
}

id sub_100038110(void *a1, const void *a2, _QWORD *a3)
{
  const void *v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  unsigned int v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  void *v27;
  _QWORD *v29;
  void *v30;
  id v31;
  id obj;
  id v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  _BYTE v38[128];

  v33 = a1;
  if (objc_opt_class(DASession))
  {
    v5 = sub_10002B088(a2);
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    v7 = objc_alloc_init((Class)DASession);
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[DASession getDevicesWithFlags:session:error:](DASession, "getDevicesWithFlags:session:error:", 8, v7, 0));
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: devices found = '%@'", "__WiFiDeviceAccessGetAppAccessInfoForNetwork", v8);
    objc_autoreleasePoolPop(v9);
    if (v8)
    {
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      obj = v8;
      v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v38, 16);
      if (v10)
      {
        v11 = v10;
        v29 = a3;
        v30 = v8;
        v31 = v7;
        v12 = *(_QWORD *)v35;
        while (2)
        {
          for (i = 0; i != v11; i = (char *)i + 1)
          {
            if (*(_QWORD *)v35 != v12)
              objc_enumerationMutation(obj);
            v14 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)i);
            v15 = objc_autoreleasePoolPush();
            v16 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "SSID"));
              objc_msgSend(v16, "WFLog:message:", 3, "%s: device='%@' SSID='%@'", "__WiFiDeviceAccessGetAppAccessInfoForNetwork", v14, v17);

            }
            objc_autoreleasePoolPop(v15);
            v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "SSID"));
            v19 = objc_msgSend(v18, "isEqualToString:", v6);

            if (v19)
            {
              v20 = objc_autoreleasePoolPush();
              v21 = (void *)qword_10026DD20;
              if (qword_10026DD20)
              {
                v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "appAccessInfoMap"));
                objc_msgSend(v21, "WFLog:message:", 3, "%s: appAccessInfoMap '%@'", "__WiFiDeviceAccessGetAppAccessInfoForNetwork", v22);

              }
              objc_autoreleasePoolPop(v20);
              v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "appAccessInfoMap"));
              v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKey:", v33));

              if (v24)
              {
                v26 = v24;
                v7 = v31;
                if (v29)
                  *v29 = objc_retainAutorelease(v14);
                v27 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: matching device found for '%@' with state = '%ld'", "__WiFiDeviceAccessGetAppAccessInfoForNetwork", v6, objc_msgSend(v26, "state"));
                objc_autoreleasePoolPop(v27);

                goto LABEL_28;
              }
              v25 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: matching device found for '%@' with no access info for bundle = '%@'", "__WiFiDeviceAccessGetAppAccessInfoForNetwork", v6, v33);
              objc_autoreleasePoolPop(v25);
            }
          }
          v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v34, v38, 16);
          if (v11)
            continue;
          break;
        }
        v26 = 0;
        v7 = v31;
LABEL_28:
        v8 = v30;
      }
      else
      {
        v26 = 0;
      }

    }
    else
    {
      v26 = 0;
    }

  }
  else
  {
    v26 = 0;
  }

  return v26;
}

uint64_t sub_100038450(void *a1, const void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  uint64_t v9;
  id v11;

  v3 = a1;
  if (_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
  {
    v11 = 0;
    v4 = sub_100038110(v3, a2, &v11);
    v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    v6 = v11;
    if (v5)
    {
      if (objc_opt_class(DASession))
      {
        v7 = objc_alloc_init((Class)DASession);
        objc_msgSend(v5, "setState:", 0);
        +[DASession setDeviceAppAccessInfo:device:session:error:](DASession, "setDeviceAppAccessInfo:device:session:error:", v5, v6, v7, 0);
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removed device access device = '%@' for network = '%@'", "WiFiDeviceAccessRemoveAccessForNetwork", v6, a2);
        objc_autoreleasePoolPop(v8);

      }
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    v9 = 0;
    v6 = 0;
    v5 = 0;
  }

  return v9;
}

void sub_100038580(void *a1, const void *a2, char a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  id v16;

  v5 = a1;
  if (!_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
  {
    v9 = 0;
    v7 = 0;
    goto LABEL_20;
  }
  v16 = 0;
  v6 = sub_100038110(v5, a2, &v16);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v8 = v16;
  v9 = v8;
  if (v7 && v8 && objc_opt_class(DASession))
  {
    v10 = objc_alloc_init((Class)DASession);
    v11 = (unint64_t)objc_msgSend(v9, "flags");
    v12 = v11 & 0x80;
    if ((a3 & 2) == 0 || (v11 & 0x80) != 0)
    {
      v14 = objc_autoreleasePoolPush();
      if ((a3 & 2) != 0 || (v11 & 0x80) == 0)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no changes to device flags (%lu)", "WiFiDeviceAccessUpdateDeviceFlags", v11, v15);
        goto LABEL_19;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removed unsecured flag", "WiFiDeviceAccessUpdateDeviceFlags");
      objc_autoreleasePoolPop(v14);
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: added unsecured flag", "WiFiDeviceAccessUpdateDeviceFlags");
      objc_autoreleasePoolPop(v13);
      v12 = v11 | 0x80;
    }
    objc_msgSend(v9, "setFlags:", v12);
    +[DASession setDeviceAppAccessInfo:device:session:error:](DASession, "setDeviceAppAccessInfo:device:session:error:", v7, v9, v10, 0);
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updated device flags to = '%lu' for network = '%@'", "WiFiDeviceAccessUpdateDeviceFlags", v12, a2);
LABEL_19:
    objc_autoreleasePoolPop(v14);

  }
LABEL_20:

}

void sub_10003A814(uint64_t a1)
{
  void *v2;
  const void *v3;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Launching TapToRadar:errorType:%u", "-[WiFiSoftErrorManager WiFiSoftErrorReporting:deviceContext:displayString:]_block_invoke", *(unsigned int *)(a1 + 64));
  objc_autoreleasePoolPop(v2);
  objc_msgSend(*(id *)(a1 + 32), "launchTapToRadar:displayString:deviceContext:", *(unsigned int *)(a1 + 64), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_10003A97C(uint64_t a1)
{
  void *v2;
  int v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Perform mitigation action: for Event:%u", *(unsigned int *)(a1 + 48));
  objc_autoreleasePoolPop(v2);
  v3 = *(_DWORD *)(a1 + 48);
  switch(v3)
  {
    case 1:
      v4 = *(void **)(a1 + 32);
      v5 = 1;
      goto LABEL_10;
    case 2:
      sub_1000EE3F4(*(_QWORD *)(a1 + 40), 0);
      v6 = *(void **)(a1 + 32);
      v7 = 2;
      goto LABEL_12;
    case 3:
    case 5:
    case 6:
    case 7:
      return;
    case 4:
      v4 = *(void **)(a1 + 32);
      v5 = 4;
      goto LABEL_10;
    case 8:
      sub_100117EC0(*(_QWORD *)(a1 + 40), 0, 0, 0, 0, 0);
      v6 = *(void **)(a1 + 32);
      v7 = 8;
LABEL_12:
      objc_msgSend(v6, "recordMitigation:", v7);
      break;
    default:
      if (v3 == 16)
      {
        v4 = *(void **)(a1 + 32);
        v5 = 16;
LABEL_10:
        objc_msgSend(v4, "wifiSoftErrorsInProcessStateUnset:", v5);
      }
      break;
  }
}

id sub_10003C39C(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v5;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = objc_msgSend(v1, "getErrorCounters");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:SoftErrorManagerRef is NULL!", "WiFiSoftErrorManagerGetErrorCounters");
    objc_autoreleasePoolPop(v5);
    v3 = 0;
  }

  return v3;
}

void sub_10003E734(id a1)
{
  if (objc_opt_class(MCProfileConnection))
    qword_10026D578 = objc_alloc_init(ManagedConfigWrapper);
}

void sub_10003EA00(uint64_t a1)
{
  sub_1000A6D04(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16), *(unsigned __int8 *)(a1 + 40));
  sub_1000A6E2C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16), *(unsigned __int8 *)(a1 + 41));
  sub_1000A0C4C(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16), *(unsigned __int8 *)(a1 + 42));
}

void sub_10003EB08(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;

  if (a2)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to initialize ManagedConfiguration <%@>", "-[ManagedConfigWrapper MCInitialize]_block_invoke", a2);
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "setMcInitialized:", 1);
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ManagedConfiguration initialized", "-[ManagedConfigWrapper MCInitialize]_block_invoke", v4);
  }
  objc_autoreleasePoolPop(v3);
}

id sub_10003EC34(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 32), "MCInitialize");
  objc_msgSend(*(id *)(a1 + 32), "startMonitoring");
  return objc_msgSend(*(id *)(a1 + 32), "MCSettingsDidChange:", 0);
}

uint64_t sub_10003F2B0()
{
  uint64_t result;

  result = qword_10026D588;
  if (!qword_10026D588)
  {
    pthread_once(&stru_10026C4B8, (void (*)(void))sub_10003F2EC);
    return qword_10026D588;
  }
  return result;
}

uint64_t sub_10003F2EC()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_10022EF08);
  qword_10026D588 = result;
  return result;
}

_QWORD *sub_10003F310(const __CFAllocator *a1, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v5;
  CFTypeID TypeID;
  uint64_t Instance;
  _QWORD *v8;
  CFMutableDictionaryRef v9;

  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("PolicyType"));
    if (Value)
    {
      v5 = Value;
      TypeID = CFNumberGetTypeID();
      if (TypeID != CFGetTypeID(v5))
        return 0;
    }
  }
  if (!qword_10026D588)
    pthread_once(&stru_10026C4B8, (void (*)(void))sub_10003F2EC);
  Instance = _CFRuntimeCreateInstance(a1);
  v8 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = 0;
    v9 = theDict
       ? CFDictionaryCreateMutableCopy(a1, 0, theDict)
       : CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v8[2] = v9;
    if (!v9)
    {
      CFRelease(v8);
      return 0;
    }
  }
  return v8;
}

_QWORD *sub_10003F3FC(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4)
{
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  const __CFUUID *v10;
  CFStringRef v11;
  _QWORD *v12;
  const __CFUUID *v14;

  if (!a2)
    return 0;
  Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v9 = Mutable;
  CFDictionaryAddValue(Mutable, CFSTR("PolicyType"), a2);
  if (a3)
  {
    CFDictionaryAddValue(v9, CFSTR("PolicyUUID"), a3);
    v10 = 0;
    v11 = 0;
    if (!a4)
    {
LABEL_6:
      v12 = sub_10003F310(a1, v9);
      if (v11)
        CFRelease(v11);
      if (v10)
        CFRelease(v10);
      goto LABEL_10;
    }
LABEL_5:
    CFDictionaryAddValue(v9, CFSTR("PolicyProperties"), a4);
    goto LABEL_6;
  }
  v14 = CFUUIDCreate(a1);
  if (v14)
  {
    v10 = v14;
    v11 = CFUUIDCreateString(a1, v14);
    CFDictionaryAddValue(v9, CFSTR("PolicyUUID"), v11);
    if (!a4)
      goto LABEL_6;
    goto LABEL_5;
  }
  v12 = 0;
LABEL_10:
  CFRelease(v9);
  return v12;
}

void sub_10003F520(uint64_t a1, void *value)
{
  if (a1)
  {
    if (value)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("PolicyUUID"), value);
  }
}

const void *sub_10003F540(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyUUID"));
}

void sub_10003F550(uint64_t a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    v4 = v3;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("PolicyType"), v3);
    CFRelease(v4);
  }
}

uint64_t sub_10003F5B4(uint64_t a1)
{
  uint64_t v1;
  const __CFNumber *Value;
  unsigned int valuePtr;

  v1 = 0xFFFFFFFFLL;
  valuePtr = -1;
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyType"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }
  return v1;
}

void sub_10003F604(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *Value;

  Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyProperties"));
  if (Value)
  {
    if (a3)
      CFDictionarySetValue(Value, a2, a3);
    else
      CFDictionaryRemoveValue(Value, a2);
  }
}

const __CFDictionary *sub_10003F65C(uint64_t a1, const void *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyProperties"));
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

__CFArray *sub_10003F69C(const __CFArray *a1)
{
  CFMutableArrayRef Mutable;
  __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  _QWORD *v8;
  const void *v9;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v3 = Mutable;
  if (a1)
  {
    if (Mutable)
    {
      Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        v5 = Count;
        for (i = 0; i != v5; ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            v8 = sub_10003F310(kCFAllocatorDefault, ValueAtIndex);
            if (v8)
            {
              v9 = v8;
              CFArrayAppendValue(v3, v8);
              CFRelease(v9);
            }
          }
        }
      }
    }
  }
  return v3;
}

__CFArray *sub_10003F754(const __CFArray *a1)
{
  CFMutableArrayRef Mutable;
  __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef Copy;
  CFDictionaryRef v9;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v3 = Mutable;
  if (a1)
  {
    if (Mutable)
    {
      Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        v5 = Count;
        for (i = 0; i != v5; ++i)
        {
          ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, ValueAtIndex[2]);
            if (Copy)
            {
              v9 = Copy;
              CFArrayAppendValue(v3, Copy);
              CFRelease(v9);
            }
          }
        }
      }
    }
  }
  return v3;
}

void sub_10003F80C(_QWORD *a1)
{
  CFTypeID v2;
  uint64_t v3;
  const void *v4;

  if (!a1)
    sub_1001868B8();
  v2 = CFGetTypeID(a1);
  v3 = qword_10026D588;
  if (!qword_10026D588)
  {
    pthread_once(&stru_10026C4B8, (void (*)(void))sub_10003F2EC);
    v3 = qword_10026D588;
  }
  if (v2 != v3)
    sub_1001868E0();
  v4 = (const void *)a1[2];
  if (v4)
  {
    CFRelease(v4);
    a1[2] = 0;
  }
}

BOOL sub_10003F880(uint64_t a1, uint64_t a2)
{
  const __CFString *Value;
  const __CFString *v4;
  BOOL v5;

  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyUUID"));
  v4 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("PolicyUUID"));
  if (Value)
    v5 = v4 == 0;
  else
    v5 = 1;
  return !v5 && CFStringCompare(Value, v4, 0) == kCFCompareEqualTo;
}

CFStringRef sub_10003F8F8(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v4;
  const void *Value;

  v4 = sub_10003F5B4(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyUUID"));
  return CFStringCreateWithFormat(kCFAllocatorDefault, a2, CFSTR("%d %@"), v4, Value);
}

CFStringRef sub_10003F964(uint64_t a1)
{
  uint64_t v2;
  const void *Value;

  v2 = sub_10003F5B4(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PolicyUUID"));
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d %@"), v2, Value);
}

void sub_10003FA94(id a1)
{
  qword_10026D590 = objc_alloc_init(WiFiCWFInterface);
}

id sub_10003FEAC(uint64_t a1, uint64_t a2, void *a3, int a4, uint64_t a5)
{
  id v8;
  id v9;

  v8 = objc_alloc_init((Class)CWFSensingResult);
  objc_msgSend(v8, "setData:", objc_msgSend(a3, "copy"));
  v9 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  objc_msgSend(v9, "setObject:forKeyedSubscript:", a5, CFSTR("CWF_ACCESSORY_UUID"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", v8, CFSTR("SensingResult"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("CWFHomeKitErrorDomain"), a4, 0), CFSTR("WiFiInterfaceReturn"));
  return -[NSNotificationCenter postNotificationName:object:userInfo:](+[NSNotificationCenter defaultCenter](NSNotificationCenter, "defaultCenter"), "postNotificationName:object:userInfo:", CFSTR("SensingResult"), 0, v9);
}

void sub_100040204(uint64_t a1, uint64_t a2)
{
  _QWORD v2[6];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100040264;
  v2[3] = &unk_10022EF88;
  v2[4] = a2;
  v2[5] = a1;
  dispatch_async((dispatch_queue_t)qword_10026DD40, v2);
}

void sub_100040264(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  void *v5;
  unsigned int v6;
  unsigned int v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  CFTypeRef cf;

  cf = 0;
  v12 = 1;
  v11 = 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = _CTServerConnectionCopyCellularTransmitState(v2, &cf);
    if (v3)
      v4 = 1;
    else
      v4 = cf == 0;
    if (!v4)
    {
      sub_1000403B8((const __CFDictionary *)cf, &v12, &v11);
      v6 = v12;
      v7 = v11;
      goto LABEL_10;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error getting cellular trnasmit state. error=%d, domain=%d", "WiFiCellularNotificationsUpdateTxState_block_invoke", HIDWORD(v3), v3);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no CTServer reference", "WiFiCellularNotificationsUpdateTxState_block_invoke", v9, v10);
  }
  objc_autoreleasePoolPop(v5);
  v7 = 0;
  v6 = 1;
LABEL_10:
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: update cellularTxStarted %d, isShort %d", "WiFiCellularNotificationsUpdateTxState_block_invoke", v6, v7);
  objc_autoreleasePoolPop(v8);
  sub_10009F104(*(_QWORD *)(a1 + 40), v6, v7);
  if (cf)
    CFRelease(cf);
}

void sub_1000403B8(const __CFDictionary *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  CFTypeID TypeID;
  const __CFString *v7;
  CFTypeID v8;
  const __CFString *v9;
  CFTypeID v10;
  const __CFString *v11;
  CFTypeID v12;
  const __CFString *v13;
  CFTypeID v14;
  const __CFString *v15;
  CFTypeID v16;
  const __CFString *v17;
  const void *v18;
  const __CFString *Value;
  const __CFString *v20;
  CFTypeID v21;
  BOOL v22;
  void *v23;
  const char *v24;
  const char *v25;
  void *v26;
  void *v27;
  const __CFString *v28;
  CFTypeID v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t v33;
  unsigned __int8 *v34;

  TypeID = CFStringGetTypeID();
  v7 = (const __CFString *)kCTCellularTransmitStateConnected;
  if (TypeID != CFGetTypeID(kCTCellularTransmitStateConnected))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularTransmitStateConnected type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v7));
    goto LABEL_58;
  }
  v8 = CFStringGetTypeID();
  v9 = (const __CFString *)kCTCellularTransmitStateIdle;
  if (v8 != CFGetTypeID(kCTCellularTransmitStateIdle))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularTransmitStateIdle type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v9));
    goto LABEL_58;
  }
  v10 = CFStringGetTypeID();
  v11 = (const __CFString *)kCTCellularShortTransmitStart;
  if (v10 != CFGetTypeID(kCTCellularShortTransmitStart))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularShortTransmitStart type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v11));
    goto LABEL_58;
  }
  v12 = CFStringGetTypeID();
  v13 = (const __CFString *)kCTCellularShortTransmitEnd;
  if (v12 != CFGetTypeID(kCTCellularShortTransmitEnd))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularShortTransmitEnd type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v13));
    goto LABEL_58;
  }
  v14 = CFStringGetTypeID();
  v15 = (const __CFString *)kCTCellularLongTransmitEnd;
  if (v14 != CFGetTypeID(kCTCellularLongTransmitEnd))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularLongTransmitEnd type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v15));
    goto LABEL_58;
  }
  v16 = CFStringGetTypeID();
  v17 = (const __CFString *)kCTCellularLongTransmitStart;
  if (v16 != CFGetTypeID(kCTCellularLongTransmitStart))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad kCTCellularLongTransmitStart type %ld", "__WiFiCellularNotificationsGetState", CFGetTypeID(v17));
LABEL_58:
    v27 = v32;
    goto LABEL_44;
  }
  *a2 = 1;
  *a3 = 1;
  v18 = (const void *)kKeyCTCellularTransmitState;
  if (!CFDictionaryContainsKey(a1, kKeyCTCellularTransmitState))
  {
    *a2 = 0;
    *a3 = 0;
    v26 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Baseband appears to be dead. cellularTxStarted %d, isShort %d", "__WiFiCellularNotificationsGetState", *a2, *a3);
    v27 = v26;
    goto LABEL_44;
  }
  Value = (const __CFString *)CFDictionaryGetValue(a1, v18);
  if (!Value)
    goto LABEL_45;
  v20 = Value;
  v34 = a3;
  v21 = CFStringGetTypeID();
  v22 = v21 == CFGetTypeID(v20);
  a3 = v34;
  if (!v22)
    goto LABEL_45;
  if (CFStringCompare(v20, v7, 0) && CFStringCompare(v20, v9, 0))
  {
    if (CFStringCompare(v20, kCTCellularTransmitStopped, 0) == kCFCompareEqualTo)
    {
      *a2 = 0;
      *v34 = 0;
    }
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v24 = "TRUE";
      if (*a2)
        v25 = "TRUE";
      else
        v25 = "FALSE";
      if (!*v34)
        v24 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: old scheme transmitState %@, cellularTxStarted %s, isShort %s", "__WiFiCellularNotificationsGetState", v20, v25, v24, v33);
    }
LABEL_43:
    v27 = v23;
LABEL_44:
    objc_autoreleasePoolPop(v27);
    return;
  }
  if (CFStringCompare(v20, v9, 0))
  {
    v28 = (const __CFString *)CFDictionaryGetValue(a1, kKeyCTCellularTransmitTrigger);
    if (!v28)
      goto LABEL_35;
    v29 = CFStringGetTypeID();
    v22 = v29 == CFGetTypeID(v28);
    a3 = v34;
    if (!v22)
      goto LABEL_35;
    if (CFStringCompare(v28, v11, 0) == kCFCompareEqualTo)
    {
      *a2 = 1;
      *v34 = 1;
    }
    if (CFStringCompare(v28, v13, 0) == kCFCompareEqualTo || CFStringCompare(v28, v15, 0) == kCFCompareEqualTo)
    {
      *a2 = 0;
      *v34 = 1;
    }
    if (CFStringCompare(v28, v17, 0) == kCFCompareEqualTo)
    {
LABEL_35:
      *a2 = 1;
      *a3 = 0;
    }
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v30 = "TRUE";
      if (*a2)
        v31 = "TRUE";
      else
        v31 = "FALSE";
      if (!*a3)
        v30 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: new scheme transmitState %@, transmitTrigger %@, cellularTxStarted %s, isShort %s", "__WiFiCellularNotificationsGetState", v20, v28, v31, v30);
    }
    goto LABEL_43;
  }
LABEL_45:
  *a2 = 0;
  *a3 = 0;
}

void sub_1000408E0(uint64_t a1, uint64_t a2)
{
  _QWORD v2[6];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100040940;
  v2[3] = &unk_10022EF88;
  v2[4] = a2;
  v2[5] = a1;
  dispatch_async((dispatch_queue_t)qword_10026DD40, v2);
}

void sub_100040940(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  void *v5;
  char v6;
  BOOL v8;
  uint64_t v10;
  uint64_t v11;
  void *value;
  CFDictionaryRef theDict;

  value = 0;
  theDict = 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = _CTServerConnectionCopyReliableNetworkFallbackSettings(v2, &theDict);
    if (v3)
      v4 = 1;
    else
      v4 = theDict == 0;
    if (!v4)
    {
      if (CFDictionaryGetValueIfPresent(theDict, kCTReliableNetworkFallbackToCellularUserPreferenceKey, (const void **)&value))
      {
        v8 = value == 0;
      }
      else
      {
        v8 = 1;
      }
      v6 = !v8 && value == kCFBooleanTrue;
      goto LABEL_19;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error getting RNF state. error=%d, domain=%d", "WiFiCellularNotificationsUpdateRNFState_block_invoke", HIDWORD(v3), v3);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no CTServer reference", "WiFiCellularNotificationsUpdateRNFState_block_invoke", v10, v11);
  }
  objc_autoreleasePoolPop(v5);
  v6 = 0;
LABEL_19:
  sub_10009ED34(*(_QWORD *)(a1 + 40), v6);
  if (theDict)
    CFRelease(theDict);
}

void sub_100040A5C(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  void *v14;
  _QWORD v15[5];
  _QWORD v16[5];
  _QWORD v17[5];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: start monitoring", "void WiFiCellularNotificationsStartMonitoring(WiFiManagerRef, CTServerConnectionRef)");
  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    _CTServerConnectionSetTargetQueue(a2, qword_10026DD40);
    v5 = kCTCellularTransmitStateNotification;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_100040CE0;
    v17[3] = &unk_10022EFA8;
    v17[4] = a1;
    v6 = _CTServerConnectionRegisterBlockForNotification(a2, kCTCellularTransmitStateNotification, v17);
    if (v6)
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error subscribing to %@ notification error=%d, domain=%d", "WiFiCellularNotificationsStartMonitoring", v5, HIDWORD(v6), v6);
      objc_autoreleasePoolPop(v7);
    }
    v8 = kCTReliableNetworkFallbackToCellularChangedNotification;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_100040D98;
    v16[3] = &unk_10022EFA8;
    v16[4] = a1;
    v9 = _CTServerConnectionRegisterBlockForNotification(a2, kCTReliableNetworkFallbackToCellularChangedNotification, v16);
    if (v9)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error subscribing to %@ notification error=%d, domain=%d", "WiFiCellularNotificationsStartMonitoring", v8, HIDWORD(v9), v9);
      objc_autoreleasePoolPop(v10);
    }
    v11 = kCTIMSConnectionChangedNotification;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_100040E44;
    v15[3] = &unk_10022EFA8;
    v15[4] = a1;
    v12 = _CTServerConnectionRegisterBlockForNotification(a2, kCTIMSConnectionChangedNotification, v15);
    if (v12)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error subscribing to %@ notification error=%d, domain=%d", "WiFiCellularNotificationsStartMonitoring", v11, HIDWORD(v12), v12);
      objc_autoreleasePoolPop(v13);
    }
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error creating CTServer reference", "WiFiCellularNotificationsStartMonitoring");
    objc_autoreleasePoolPop(v14);
  }
}

void sub_100040CE0(uint64_t a1, const __CFDictionary *a2)
{
  void *v3;
  char v4;
  char v5;
  char v6;
  char v7;

  v7 = 1;
  v6 = 0;
  if (a2)
  {
    sub_1000403B8(a2, (unsigned __int8 *)&v7, (unsigned __int8 *)&v6);
    v3 = objc_autoreleasePoolPush();
    v4 = v7;
    v5 = v6;
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: update cellularTxStarted %d, isShort %d", "WiFiCellularNotificationsStartMonitoring_block_invoke", v7, v6);
    objc_autoreleasePoolPop(v3);
    sub_10009F104(*(_QWORD *)(a1 + 32), v4, v5);
  }
}

void sub_100040D98(uint64_t a1, CFDictionaryRef theDict)
{
  BOOL v3;
  char v5;
  void *v6;
  void *value;

  value = 0;
  if (theDict)
  {
    if (CFDictionaryGetValueIfPresent(theDict, kCTReliableNetworkFallbackToCellularUserPreferenceKey, (const void **)&value))
    {
      v3 = value == 0;
    }
    else
    {
      v3 = 1;
    }
    v5 = !v3 && value == kCFBooleanTrue;
    sub_10009ED34(*(_QWORD *)(a1 + 32), v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No Info from CT for RNF State Change !");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_100040E44(uint64_t a1, CFDictionaryRef theDict)
{
  BOOL v4;
  char v6;
  BOOL v7;
  void *v8;
  char v9;
  CFStringRef theString1;
  void *value;

  theString1 = 0;
  value = 0;
  if (theDict)
  {
    if (CFDictionaryGetValueIfPresent(theDict, kCTIMSIsConnectionUp, (const void **)&value))
      v4 = value == 0;
    else
      v4 = 1;
    v6 = !v4 && value == kCFBooleanTrue;
    if (CFDictionaryGetValueIfPresent(theDict, kCTIMSConnectionType, (const void **)&theString1))
      v7 = theString1 == 0;
    else
      v7 = 1;
    v9 = !v7 && CFStringCompare(theString1, kCTIMSConnectionTypeWifi, 0) == kCFCompareEqualTo;
    sub_10009F1E8(*(_QWORD *)(a1 + 32), v6, v9);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No Info from CT for IMS State Change !");
    objc_autoreleasePoolPop(v8);
  }
}

void sub_100040F50(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing observer", "void WiFiCellularNotificationsStopMonitoring(WiFiManagerRef, CTServerConnectionRef)");
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    _CTServerConnectionUnregisterForNotification(a2, kCTCellularTransmitStateNotification);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error no CTServer reference", "WiFiCellularNotificationsStopMonitoring");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_100041010(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t Instance;
  uint64_t v7;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v9;
  NSObject *v10;
  dispatch_queue_t v11;
  NSObject *v12;
  uint64_t v13;
  const __CFString *v14;
  CFStringEncoding SystemEncoding;
  int v16;
  int v17;
  uint64_t v18;
  void *v19;
  void *v20;
  CFMutableSetRef v21;
  NSObject *v22;
  CFMutableArrayRef v23;
  CFMutableArrayRef v24;
  void *v25;
  void *v26;
  void *v27;
  int v28;
  const char *v29;
  WiFiTrafficEngManager *v30;
  WFTrafficEngManager *v31;
  dispatch_queue_t v32;
  NSObject *v33;
  void *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  void *v44;
  uint64_t v45;
  _QWORD block[5];
  char buffer[16];
  __int128 v48;

  if (!a2)
    goto LABEL_65;
  if (!qword_10026D5B0)
    pthread_once(&stru_10026C910, (void (*)(void))sub_10004A5E8);
  Instance = _CFRuntimeCreateInstance(a1);
  if (!Instance)
    goto LABEL_65;
  v7 = Instance;
  bzero((void *)(Instance + 16), 0xC80uLL);
  *(_QWORD *)(v7 + 32) = a2;
  *(_WORD *)(v7 + 220) = 256;
  *(_DWORD *)(v7 + 224) = 0;
  *(_DWORD *)(v7 + 2760) = 0;
  *(_BYTE *)(v7 + 160) = 1;
  *(CFAbsoluteTime *)(v7 + 80) = CFAbsoluteTimeGetCurrent();
  *(_QWORD *)(v7 + 16) = 1;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v7 + 24) = Mutable;
  if (!Mutable
    || (v9 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks), (*(_QWORD *)(v7 + 320) = v9) == 0)
    || (v10 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM),
        v11 = dispatch_queue_create("WiFiLQAManager", v10),
        (*(_QWORD *)(v7 + 296) = v11) == 0))
  {
LABEL_48:
    v35 = *(NSObject **)(v7 + 296);
    if (v35)
      dispatch_release(v35);
    v36 = *(NSObject **)(v7 + 544);
    if (v36)
    {
      dispatch_release(v36);
      *(_QWORD *)(v7 + 544) = 0;
    }
    v37 = *(NSObject **)(v7 + 336);
    if (v37)
    {
      dispatch_release(v37);
      *(_QWORD *)(v7 + 336) = 0;
    }
    v38 = *(NSObject **)(v7 + 2904);
    if (v38)
    {
      dispatch_release(v38);
      *(_QWORD *)(v7 + 2904) = 0;
    }
    v39 = *(NSObject **)(v7 + 2920);
    if (v39)
      dispatch_release(v39);
    v40 = *(const void **)(v7 + 24);
    if (v40)
    {
      CFRelease(v40);
      *(_QWORD *)(v7 + 24) = 0;
    }
    v41 = *(const void **)(v7 + 320);
    if (v41)
    {
      CFRelease(v41);
      *(_QWORD *)(v7 + 320) = 0;
    }
    v42 = *(const void **)(v7 + 112);
    if (v42)
    {
      CFRelease(v42);
      *(_QWORD *)(v7 + 112) = 0;
    }
    CFRelease((CFTypeRef)v7);
LABEL_65:
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager Create Failed\n", "WiFiLQAMgrCreate");
    v7 = 0;
    goto LABEL_68;
  }
  v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v7 + 336) = v12;
  if (!v12)
  {
    v44 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create activeProbe.timer", "WiFiLQAMgrCreate");
    goto LABEL_73;
  }
  dispatch_set_context(v12, (void *)v7);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v7 + 336), (dispatch_function_t)sub_100041894);
  *(_QWORD *)(v7 + 344) = 0x100000005B8;
  *(_DWORD *)(v7 + 352) = 32;
  v13 = sub_100025C3C(*(_QWORD *)(v7 + 32));
  if (!v13)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IfName is NULL", "__WiFiLQAMgrSetActiveProbeSize");
    goto LABEL_20;
  }
  v14 = (const __CFString *)v13;
  *(_OWORD *)buffer = 0u;
  v48 = 0u;
  SystemEncoding = CFStringGetSystemEncoding();
  CFStringGetCString(v14, buffer, 16, SystemEncoding);
  v16 = socket(2, 2, 0);
  if (v16 == -1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Socket failed to open", "__WiFiLQAMgrSetActiveProbeSize");
LABEL_20:
    objc_autoreleasePoolPop(v20);
    goto LABEL_24;
  }
  v17 = v16;
  if (ioctl(v16, 0xC0206933uLL, buffer) == -1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ioctl(SIOCGIFMTU) failed", "__WiFiLQAMgrSetActiveProbeSize", v45);
  }
  else
  {
    v18 = v48;
    if ((int)v48 >= 37)
    {
      *(int32x2_t *)(v7 + 344) = vmin_s32(vdup_n_s32(v48), (int32x2_t)0x100000005B8);
      *(_DWORD *)(v7 + 352) = 32;
    }
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: MTU Size: %d", "__WiFiLQAMgrSetActiveProbeSize", v18);
  }
  objc_autoreleasePoolPop(v19);
  close(v17);
LABEL_24:
  *(_BYTE *)(v7 + 645) = 0;
  *(_DWORD *)(v7 + 640) = 1;
  *(_QWORD *)(v7 + 648) = 0xFFFFFFB0FFFFFFB5;
  *(_DWORD *)(v7 + 664) = 10;
  *(_OWORD *)(v7 + 672) = xmmword_1001BB220;
  *(_QWORD *)(v7 + 688) = 0x4028000000000000;
  *(_BYTE *)(v7 + 647) = 1;
  *(_BYTE *)(v7 + 724) = 1;
  *(_QWORD *)(v7 + 728) = 0x3F00000000000005;
  *(_DWORD *)(v7 + 736) = 3;
  *(_BYTE *)(v7 + 788) = 1;
  *(_QWORD *)(v7 + 792) = 0x3F4000000000000FLL;
  *(_QWORD *)(v7 + 800) = 0x3F0000000000000FLL;
  *(_BYTE *)(v7 + 868) = 1;
  *(_QWORD *)(v7 + 872) = 0x3F4CCCCD00000005;
  *(_QWORD *)(v7 + 880) = 0x3F0000000000000FLL;
  *(_BYTE *)(v7 + 888) = 1;
  *(_QWORD *)(v7 + 892) = 0x3F00000000000003;
  *(_BYTE *)(v7 + 904) = 1;
  *(_QWORD *)(v7 + 912) = 0x4024000000000000;
  *(_BYTE *)(v7 + 920) = 1;
  *(_DWORD *)(v7 + 924) = 1;
  *(_WORD *)(v7 + 928) = 20481;
  *(_BYTE *)(v7 + 1296) = 0;
  *(_BYTE *)(v7 + 932) = 1;
  *(_QWORD *)(v7 + 936) = 0x3E80000000000005;
  *(_DWORD *)(v7 + 944) = 0;
  *(_QWORD *)(v7 + 712) = 0x3DCCCCCD3E99999ALL;
  *(_BYTE *)(v7 + 996) = 1;
  *(_QWORD *)(v7 + 1000) = 0x3F4000000000000FLL;
  *(_QWORD *)(v7 + 1008) = 0xFFFFFFFFLL;
  *(_BYTE *)(v7 + 1076) = 1;
  *(_QWORD *)(v7 + 1080) = 0x3F4CCCCD00000005;
  *(_QWORD *)(v7 + 1088) = 0xFFFFFFFFLL;
  *(_BYTE *)(v7 + 1096) = 1;
  *(_QWORD *)(v7 + 1100) = 0x3DCCCCCD00000005;
  *(_DWORD *)(v7 + 1108) = 0;
  *(_DWORD *)(v7 + 720) = 1028443341;
  *(_BYTE *)(v7 + 1160) = 1;
  *(_QWORD *)(v7 + 1164) = 0x3F0000000000000FLL;
  *(_QWORD *)(v7 + 1172) = 0xFFFFFFFFLL;
  *(_BYTE *)(v7 + 1240) = 1;
  *(_QWORD *)(v7 + 1244) = 0x3F00000000000005;
  *(_QWORD *)(v7 + 1252) = 0xFFFFFFFFLL;
  *(_QWORD *)(v7 + 656) = 0xFFFFFFA6FFFFFFABLL;
  *(_QWORD *)(v7 + 696) = 0x4024000000000000;
  *(_QWORD *)(v7 + 704) = 0x4014000000000000;
  *(_OWORD *)(v7 + 88) = xmmword_1001BB230;
  *(_DWORD *)(v7 + 104) = 0;
  *(_BYTE *)(v7 + 108) = 1;
  *(_DWORD *)(v7 + 2796) = 0;
  *(_QWORD *)(v7 + 2816) = 0;
  *(_BYTE *)(v7 + 2824) = 0;
  *(_OWORD *)(v7 + 120) = 0u;
  *(_OWORD *)(v7 + 136) = 0u;
  *(_QWORD *)(v7 + 152) = 0;
  v21 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v7 + 112) = v21;
  if (!v21)
    goto LABEL_48;
  v22 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
  *(_QWORD *)(v7 + 544) = v22;
  if (!v22)
  {
    v44 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create roamTimer", "WiFiLQAMgrCreate");
LABEL_73:
    objc_autoreleasePoolPop(v44);
    goto LABEL_48;
  }
  dispatch_set_context(v22, (void *)v7);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v7 + 544), (dispatch_function_t)sub_1000418F4);
  if (!*(_DWORD *)(v7 + 420)
    && notify_register_mach_port("com.apple.symptoms.managed_events.wifi-trigger-disconnect", (mach_port_t *)(v7 + 420), 0, (int *)(v7 + 416)))
  {
    goto LABEL_48;
  }
  if (!*(_DWORD *)(v7 + 444)
    && notify_register_mach_port("com.apple.symptoms.managed_events.dns-failure", (mach_port_t *)(v7 + 444), 0, (int *)(v7 + 440)))
  {
    goto LABEL_48;
  }
  *(_DWORD *)(v7 + 1264) = 0;
  qword_10026D5A0 = v7;
  v23 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v7 + 256) = v23;
  if (!v23)
    goto LABEL_48;
  v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v7 + 264) = v24;
  if (!v24)
    goto LABEL_48;
  *(_QWORD *)(v7 + 528) = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100041ACC;
  block[3] = &unk_10022EA38;
  block[4] = v7;
  *(_QWORD *)(v7 + 528) = tcp_connection_fallback_watcher_create(1, *(_QWORD *)(v7 + 296), block);
  dispatch_async(*(dispatch_queue_t *)(v7 + 296), block);
  if (MGGetSInt32Answer(CFSTR("DeviceClassNumber"), 0) == 7)
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Audio accessory detected\n");
    objc_autoreleasePoolPop(v25);
    *(_BYTE *)(v7 + 2832) = 1;
    *(_QWORD *)(v7 + 648) = 0xFFFFFFABFFFFFFB0;
  }
  *(_BYTE *)(v7 + 2792) = 0;
  *(_WORD *)(v7 + 2833) = 0;
  *(_BYTE *)(v7 + 2844) = 0;
  *(_QWORD *)(v7 + 2836) = 0;
  v26 = objc_autoreleasePoolPush();
  v27 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v28 = _os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition");
    v29 = "disabled";
    if (v28)
      v29 = "enabled";
    objc_msgSend(v27, "WFLog:message:", 3, "%s: ColocatedScopeTransition Feature is %s", "WiFiLQAMgrCreate", v29);
  }
  objc_autoreleasePoolPop(v26);
  v30 = -[WiFiTrafficEngManager initWithArgs:]([WiFiTrafficEngManager alloc], "initWithArgs:", v7);
  *(_QWORD *)(v7 + 2968) = v30;
  if (!v30)
    goto LABEL_48;
  v31 = -[WiFiTrafficEngManager trafficEng](v30, "trafficEng");
  *(_QWORD *)(v7 + 2976) = v31;
  if (!v31)
    goto LABEL_48;
  *(_WORD *)(v7 + 2913) = 0;
  *(_DWORD *)(v7 + 2916) = 1;
  *(_BYTE *)(v7 + 2936) = 0;
  v32 = dispatch_queue_create("TrafficEngineering", 0);
  *(_QWORD *)(v7 + 2920) = v32;
  if (!v32)
    goto LABEL_48;
  if (sub_100032154(*(_QWORD *)(v7 + 32)))
  {
    v33 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a3);
    *(_QWORD *)(v7 + 2904) = v33;
    dispatch_set_context(v33, (void *)v7);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v7 + 2904), (dispatch_function_t)sub_100041BC4);
  }
  *(_BYTE *)(v7 + 2912) = 0;
  *(_QWORD *)(v7 + 2928) = 0;
  *(_WORD *)(v7 + 2985) = 8;
  *(_QWORD *)(v7 + 3200) = 0;
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: LQAManager Created\n", "WiFiLQAMgrCreate");
LABEL_68:
  objc_autoreleasePoolPop(v34);
  return v7;
}

void sub_100041894(uint64_t a1)
{
  void *v1;

  if (a1)
  {
    sub_10004CC50(a1);
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is null", "__WiFiLQAMgrActiveProbeTimerCallback");
    objc_autoreleasePoolPop(v1);
  }
}

void sub_1000418F4(uint64_t a1)
{
  const __CFArray *v2;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  void (*v5)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  void *v6;
  unsigned int valuePtr;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is null", "__WiFiLQAMgrRoamTimerCallback");
    goto LABEL_24;
  }
  if (!*(_BYTE *)(a1 + 640))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is disabled", "__WiFiLQAMgrRoamTimerCallback");
    goto LABEL_24;
  }
  v2 = *(const __CFArray **)(a1 + 24);
  if (!v2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrRoamTimerCallback");
    goto LABEL_24;
  }
  if (!CFArrayGetCount(v2))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM table is empty", "__WiFiLQAMgrRoamTimerCallback");
    goto LABEL_24;
  }
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  if (!ValueAtIndex)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrRoamTimerCallback");
LABEL_24:
    objc_autoreleasePoolPop(v6);
    return;
  }
  valuePtr = *(_DWORD *)(a1 + 2796);
  if (!valuePtr)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RSSI"));
    if (!Value)
      return;
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  }
  if (*(_DWORD *)(a1 + 20) == 4)
  {
    v5 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 552);
    if (v5)
      v5(a1, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 560), valuePtr, 0);
    *(_BYTE *)(a1 + 392) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 336), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

void sub_100041ACC(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const char *v4;
  void *v5;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 528))
  {
    v2 = tcp_fallback_watcher_fallback_inuse();
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v4 = "off";
      if ((_DWORD)v2)
        v4 = "on";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cellular fallback is %s\n", "WiFiLQAMgrCreate_block_invoke", v4);
    }
    objc_autoreleasePoolPop(v3);
    -[WiFiUsageMonitor setCellularFallbackState:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setCellularFallbackState:forInterface:", v2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cellular fallback watcher is NULL !", "WiFiLQAMgrCreate_block_invoke");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_100041BC4(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    objc_msgSend(*(id *)(a1 + 2976), "__sendEventToPeers");
    sub_10004A594(a1);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is null", "__WiFiLQAMgrTrafficEngTimerCallback");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_100041C40(uint64_t a1, char a2, int a3)
{
  _BOOL4 v4;
  uint64_t v5;
  void *v6;
  void *v7;

  if (a1)
  {
    *(_BYTE *)(a1 + 640) = a2;
    *(_BYTE *)(a1 + 645) = a3;
    if (a3)
      v4 = *(_BYTE *)(a1 + 646) != 0;
    else
      v4 = 0;
    sub_100041D84(a1, v4);
    v5 = sub_100041E4C(a1, 5.0);
    if ((_DWORD)v5)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Failed to set default LQM interval", "WiFiLQAMgrSetLQAEnable");
      objc_autoreleasePoolPop(v6);
    }
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAConfigChange En: %d lqaMode: %d fallbackPref %d override %d askToDisc %d AggrTD %d rnfState %d", "WiFiLQAMgrSetLQAEnable", *(unsigned __int8 *)(a1 + 640), *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 221), *(unsigned __int8 *)(a1 + 642), *(unsigned __int8 *)(a1 + 644), *(unsigned __int8 *)(a1 + 645), *(unsigned __int8 *)(a1 + 646));
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetLQAEnable");
    v5 = 4294963396;
  }
  objc_autoreleasePoolPop(v7);
  return v5;
}

void sub_100041D84(uint64_t a1, int a2)
{
  _OWORD *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  void *v12;

  if (a1)
  {
    v2 = (_OWORD *)(a1 + 724);
    if (a2)
    {
      v3 = unk_10026C860;
      *v2 = xmmword_10026C850;
      *(_OWORD *)(a1 + 740) = v3;
      v4 = unk_10026C880;
      *(_OWORD *)(a1 + 756) = xmmword_10026C870;
      *(_OWORD *)(a1 + 772) = v4;
      v5 = unk_10026C8A0;
      *(_OWORD *)(a1 + 932) = xmmword_10026C890;
      *(_OWORD *)(a1 + 948) = v5;
      v6 = unk_10026C8C0;
      *(_OWORD *)(a1 + 964) = xmmword_10026C8B0;
      *(_OWORD *)(a1 + 980) = v6;
      v7 = xmmword_10026C8D0;
      v8 = unk_10026C8E0;
      v9 = unk_10026C900;
      *(_OWORD *)(a1 + 1128) = xmmword_10026C8F0;
      *(_OWORD *)(a1 + 1144) = v9;
      *(_OWORD *)(a1 + 1096) = v7;
      *(_OWORD *)(a1 + 1112) = v8;
    }
    else
    {
      v10 = unk_10026C820;
      *v2 = xmmword_10026C810;
      *(_OWORD *)(a1 + 740) = v10;
      v11 = unk_10026C840;
      *(_OWORD *)(a1 + 756) = xmmword_10026C830;
      *(_OWORD *)(a1 + 772) = v11;
    }
  }
  else
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "manager is NULL!");
    objc_autoreleasePoolPop(v12);
  }
}

uint64_t sub_100041E4C(uint64_t a1, double a2)
{
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v11;
  unsigned int valuePtr;

  valuePtr = 0;
  if (!a1 || !*(_BYTE *)(a1 + 640))
    return 0;
  v4 = sub_100075E1C(*(_QWORD *)(a1 + 32));
  if (!v4)
  {
    v6 = 0;
    MutableCopy = 0;
    goto LABEL_29;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v4);
  if (!MutableCopy)
  {
    v6 = 0;
    goto LABEL_29;
  }
  valuePtr = (a2 * 1000.0);
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (!v6)
  {
LABEL_29:
    v8 = 4294963395;
    goto LABEL_12;
  }
  CFDictionarySetValue(MutableCopy, CFSTR("LQM_UPDATE_INTERVAL"), v6);
  v7 = sub_100075F60(*(_QWORD *)(a1 + 32), (uint64_t)MutableCopy);
  v8 = v7;
  if (a2 >= 1.0 && !(_DWORD)v7)
  {
    *(double *)(a1 + 96) = a2;
    if (a2 == 5.0)
    {
      *(_DWORD *)(a1 + 104) = 0;
      if (*(double *)(a1 + 120) != 0.0)
        *(_QWORD *)(a1 + 120) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 104) = 1;
      *(CFAbsoluteTime *)(a1 + 120) = CFAbsoluteTimeGetCurrent();
    }
    *(CFAbsoluteTime *)(a1 + 128) = CFAbsoluteTimeGetCurrent();
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM interval updated to %2.2f seconds", "__WiFiLQAMgrSetIntervalInSec", *(_QWORD *)&a2);
    objc_autoreleasePoolPop(v11);
    v8 = 0;
    goto LABEL_24;
  }
  if (!(_DWORD)v7)
    goto LABEL_24;
LABEL_12:
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: %d Failed to update LQM interval %2.2f", "__WiFiLQAMgrSetIntervalInSec", v8, *(_QWORD *)&a2);
  objc_autoreleasePoolPop(v9);
  if (!v4)
  {
    if (!MutableCopy)
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_24:
  CFRelease(v4);
  if (MutableCopy)
LABEL_16:
    CFRelease(MutableCopy);
LABEL_17:
  if (v6)
    CFRelease(v6);
  return v8;
}

uint64_t sub_100042048(uint64_t a1, int a2)
{
  uint64_t result;
  void *v4;

  if (a1)
  {
    result = 0;
    *(_BYTE *)(a1 + 647) = a2 == 0;
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetXCTestMode");
    objc_autoreleasePoolPop(v4);
    return 4294963396;
  }
  return result;
}

uint64_t sub_1000420C4(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;

  if (a1)
  {
    *(_BYTE *)(a1 + 642) = *(_BYTE *)(a2 + 4);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)a2;
    *(_BYTE *)(a1 + 645) = *(_BYTE *)(a2 + 6);
    byte_10026D5A8 = *(_BYTE *)(a1 + 644) != 0;
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAConfigChange En: %d lqaMode: %d fallbackPref %d override %d askToDisc %d AggrTD %d rnfState %d", "WiFiLQAMgrSetLQAConfig", *(unsigned __int8 *)(a1 + 640), *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 221), *(unsigned __int8 *)(a1 + 642), *(unsigned __int8 *)(a1 + 644), *(unsigned __int8 *)(a1 + 645), *(unsigned __int8 *)(a1 + 646));
    v4 = 0;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetLQAConfig");
    v4 = 4294963396;
  }
  objc_autoreleasePoolPop(v3);
  return v4;
}

uint64_t sub_1000421C0(uint64_t a1, int a2)
{
  BOOL v3;
  int v4;
  void *v5;
  uint64_t v6;

  if (a1)
  {
    *(_BYTE *)(a1 + 646) = a2;
    if (a2)
      v3 = *(_BYTE *)(a1 + 645) == 0;
    else
      v3 = 1;
    v4 = !v3;
    sub_100041D84(a1, v4);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQAConfigChange En: %d lqaMode: %d fallbackPref %d override %d askToDisc %d AggrTD %d rnfState %d", "WiFiLQAMgrSetRNFState", *(unsigned __int8 *)(a1 + 640), *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 221), *(unsigned __int8 *)(a1 + 642), *(unsigned __int8 *)(a1 + 644), *(unsigned __int8 *)(a1 + 645), *(unsigned __int8 *)(a1 + 646));
    v6 = 0;
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetRNFState");
    v6 = 4294963396;
  }
  objc_autoreleasePoolPop(v5);
  return v6;
}

uint64_t sub_1000422A8(unsigned __int8 *context, uint64_t a2)
{
  uint64_t result;
  void *v5;
  uint64_t v6;

  if (!context)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetSystemWakeState", v6);
    goto LABEL_11;
  }
  if (context[160] == (_DWORD)a2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, systemPowerOn was set to %d", "WiFiLQAMgrSetSystemWakeState", a2);
LABEL_11:
    objc_autoreleasePoolPop(v5);
    return 4294963396;
  }
  context[160] = a2;
  if ((_DWORD)a2)
    *((CFAbsoluteTime *)context + 10) = CFAbsoluteTimeGetCurrent();
  else
    dispatch_async_f(*((dispatch_queue_t *)context + 365), context, (dispatch_function_t)sub_100042388);
  result = 0;
  context[177] = 0;
  *((_QWORD *)context + 23) = 0;
  return result;
}

void sub_100042388(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (*(_BYTE *)(a1 + 2913) == 1)
  {
    objc_msgSend(*(id *)(a1 + 2976), "__invalidateDiscovery");
    *(_BYTE *)(a1 + 2913) = 0;
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000423C8(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  double v7;
  void *v8;
  void (*v9)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t);
  WiFiUsageMonitor *v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  void *v14;
  unsigned int valuePtr;

  if (!a1)
    return;
  if (!*(_BYTE *)(a1 + 640))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA is disabled", "__WiFiLQAMgrTriggerDisconnect");
    goto LABEL_35;
  }
  if (*(_BYTE *)(a1 + 176))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LinkEvent happened, Do not Trigger Disconnect", "__WiFiLQAMgrTriggerDisconnect");
    goto LABEL_35;
  }
  v3 = *(const __CFArray **)(a1 + 24);
  if (!v3)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: LQM table is NULL", "__WiFiLQAMgrTriggerDisconnect");
    goto LABEL_35;
  }
  if (!CFArrayGetCount(v3))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQM table is empty", "__WiFiLQAMgrTriggerDisconnect");
    goto LABEL_35;
  }
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  if (!ValueAtIndex)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager: Latest LQM Report is NULL", "__WiFiLQAMgrTriggerDisconnect");
LABEL_35:
    objc_autoreleasePoolPop(v14);
    return;
  }
  valuePtr = *(_DWORD *)(a1 + 2796);
  if (!valuePtr)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RSSI"));
    if (!Value)
      return;
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  }
  sub_1000246C0(a1);
  if (*(double *)(a1 + 136) == 0.0)
  {
    v7 = 0.0;
  }
  else
  {
    v7 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Trigger disconnect evaluation took %2.2f", "__WiFiLQAMgrTriggerDisconnect", *(_QWORD *)&v7);
    objc_autoreleasePoolPop(v8);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v9 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 552);
  if (v9)
    v9(a1, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 560), valuePtr, a2);
  -[WiFiUsageMonitor addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:", *(_QWORD *)(a1 + 40), 0, 0, 1);
  v10 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
  -[WiFiUsageMonitor setTdLogic_end:evalTime:rssi:roamTime:forInterface:](v10, "setTdLogic_end:evalTime:rssi:roamTime:forInterface:", *(unsigned int *)(a1 + 2828), (int)valuePtr, *(_QWORD *)(a1 + 40), v7, *(double *)(a1 + 192));
  if (&_symptom_create)
  {
    v11 = symptom_create("com.apple.wifimanager.trigger-disconnect");
    symptom_send(v11);
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Notified Symptoms about Trigger Disconnected network", "__WiFiLQAMgrTriggerDisconnect");
    objc_autoreleasePoolPop(v12);
  }
  *(_BYTE *)(a1 + 392) = 0;
  dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 336), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  v13 = *(NSObject **)(a1 + 2904);
  if (v13)
    dispatch_source_set_timer(v13, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  *(_BYTE *)(a1 + 2912) = 0;
}

uint64_t sub_1000426D8(uint64_t a1, uint64_t a2, int a3)
{
  void *v4;
  const char *v5;
  uint64_t v6;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 2760) == a3)
      return 4294963396;
    *(_DWORD *)(a1 + 2760) = a3;
    *(CFAbsoluteTime *)(a1 + 2768) = CFAbsoluteTimeGetCurrent();
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "Alive";
      if (a3 == 1)
        v5 = "Expired";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: GatewayARPState %s", "WiFiLQAMgrSetGatewayARPState", v5);
    }
    v6 = 0;
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetGatewayARPState");
    v6 = 4294963396;
  }
  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t sub_1000427BC(uint64_t result, char a2)
{
  if (result)
  {
    if (*(_BYTE *)(result + 640))
      *(_BYTE *)(result + 220) = a2;
  }
  return result;
}

uint64_t sub_1000427D0(uint64_t result, char a2)
{
  if (result)
  {
    if (*(_BYTE *)(result + 640))
      *(_BYTE *)(result + 221) = a2;
  }
  return result;
}

uint64_t sub_1000427E4(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 216) = a2;
  return result;
}

uint64_t sub_1000427F0(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 208);
  return result;
}

void sub_1000427FC(uint64_t a1, double a2)
{
  double Current;
  double v5;

  Current = CFAbsoluteTimeGetCurrent();
  if (a1 && *(_BYTE *)(a1 + 640))
  {
    v5 = Current - a2;
    if (a2 == 0.0)
      v5 = -1.0;
    *(double *)(a1 + 280) = v5;
  }
}

void sub_100042848(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  __CFDictionary *Mutable;
  CFNumberRef v5;
  __CFArray *v6;
  __CFArray *v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  const void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t valuePtr;

  valuePtr = 32;
  v13 = 3;
  if (a1 && *(_BYTE *)(a1 + 640) && *(_DWORD *)(a1 + 16) == 2)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: initProbeHappened %d lqaState %d", "WiFiLQAMgrSetWiFiPrimaryInterface", *(unsigned __int8 *)(a1 + 357), *(unsigned int *)(a1 + 20));
    objc_autoreleasePoolPop(v2);
    if (*(_DWORD *)(a1 + 20))
    {
      v3 = *(_QWORD *)(a1 + 400);
      if (*(_BYTE *)(a1 + 357))
      {
        if (v3)
          return;
        goto LABEL_24;
      }
      if (!v3)
      {
LABEL_24:
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No Router IP Address", "WiFiLQAMgrSetWiFiPrimaryInterface");
        objc_autoreleasePoolPop(v11);
        return;
      }
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v5 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
      v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      v7 = v6;
      if (v5 && v6)
      {
        CFArrayAppendValue(v6, v5);
        CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeSize"), v7);
        v8 = CFNumberCreate(0, kCFNumberCFIndexType, &v13);
        CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrNumProbes"), v8);
        *(_BYTE *)(a1 + 357) = 1;
        v9 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(a1 + 384) = v9;
        if (sub_100042AB8(a1, Mutable, v9, (uint64_t)sub_1000430BC, a1))
        {
          v10 = *(const void **)(a1 + 384);
          if (v10)
          {
            CFRelease(v10);
            *(_QWORD *)(a1 + 384) = 0;
          }
        }
        if (v8)
          CFRelease(v8);
      }
      else
      {
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, probeSizeRef OR probeSizeArr is NULL", "WiFiLQAMgrSetWiFiPrimaryInterface");
        objc_autoreleasePoolPop(v12);
        if (!v5)
          goto LABEL_19;
      }
      CFRelease(v5);
LABEL_19:
      if (Mutable)
        CFRelease(Mutable);
      if (v7)
        CFRelease(v7);
    }
  }
}

uint64_t sub_100042AB8(uint64_t a1, const __CFDictionary *a2, __CFDictionary *a3, uint64_t a4, uint64_t a5)
{
  __CFDictionary *v7;
  CFMutableDictionaryRef Mutable;
  CFTypeID TypeID;
  const void *Value;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  CFNumberRef v17;
  CFNumberRef v18;
  __CFArray *v19;
  const void *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  void *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  void *v30;
  uint64_t v31;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  __CFDictionary *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t valuePtr;
  uint64_t v41;

  valuePtr = *(unsigned int *)(a1 + 352);
  v41 = 0;
  v38 = 0;
  v39 = 1;
  if (*(_DWORD *)(a1 + 20))
  {
    v7 = a3;
    Mutable = a3;
    if (!a3
      && (Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) == 0|| (TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(Mutable)))
    {
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeHandle is NULL or incorrect type", "WiFiLQAMgrEnqueueDiagnosticProbe");
      objc_autoreleasePoolPop(v33);
      v31 = 4294963394;
      goto LABEL_44;
    }
    v37 = v7;
    if (a2)
    {
      Value = CFDictionaryGetValue(a2, CFSTR("kWiFiLqaMgrNumProbes"));
      v13 = CFDictionaryGetValue(a2, CFSTR("kWiFiLqaMgrProbeSize"));
      v14 = CFDictionaryGetValue(a2, CFSTR("kWiFiLqaMgrProbeTimeoutSecs"));
      v15 = CFDictionaryGetValue(a2, CFSTR("kWiFiLqaMgrIpv4Addr"));
      v16 = CFDictionaryGetValue(a2, CFSTR("kWiFiLqaMgrProbeTrafficClass"));
      v41 = *(unsigned int *)(a1 + 892);
      if (Value)
      {
        CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrNumProbes"), Value);
        if (!v13)
          goto LABEL_8;
        goto LABEL_14;
      }
    }
    else
    {
      v16 = 0;
      v15 = 0;
      v14 = 0;
      v13 = 0;
      v41 = *(unsigned int *)(a1 + 892);
    }
    v21 = CFNumberCreate(0, kCFNumberCFIndexType, &v41);
    if (!v21)
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numProbesDefRef is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
      goto LABEL_62;
    }
    v22 = v21;
    CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrNumProbes"), v21);
    CFRelease(v22);
    if (!v13)
    {
LABEL_8:
      v17 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
      if (v17)
      {
        v18 = v17;
        v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (!v19)
        {
          v36 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeSizeArr is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
          objc_autoreleasePoolPop(v36);
          v20 = 0;
          v31 = 4294963394;
          v7 = v37;
          goto LABEL_41;
        }
        v13 = v19;
        CFArrayAppendValue(v19, v18);
        v20 = v13;
LABEL_15:
        CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeSize"), v13);
        if (v14)
        {
          CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeTimeoutSecs"), v14);
          if (v15)
            goto LABEL_21;
        }
        else
        {
          v23 = CFNumberCreate(0, kCFNumberCFIndexType, &v39);
          if (!v23)
          {
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeTimeoutSecsDefRef is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
            goto LABEL_39;
          }
          v24 = v23;
          CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeTimeoutSecs"), v23);
          CFRelease(v24);
          if (v15)
            goto LABEL_21;
        }
        v15 = *(const void **)(a1 + 400);
        if (v15)
        {
LABEL_21:
          CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrIpv4Addr"), v15);
          if (v16)
            CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeTrafficClass"), v16);
          CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrIgnoreProbe"), kCFBooleanFalse);
          if (a4)
          {
            v38 = a4;
            v25 = CFNumberCreate(0, kCFNumberCFIndexType, &v38);
            v7 = v37;
            if (!v25)
            {
              v30 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeCallback is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
              goto LABEL_40;
            }
            v26 = v25;
            CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrDiagCallback"), v25);
            CFRelease(v26);
            if (!a5)
              goto LABEL_32;
          }
          else
          {
            v27 = objc_autoreleasePoolPush();
            v7 = v37;
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Callback is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
            objc_autoreleasePoolPop(v27);
            if (!a5)
              goto LABEL_32;
          }
          v38 = a5;
          v28 = CFNumberCreate(0, kCFNumberCFIndexType, &v38);
          if (v28)
          {
            v29 = v28;
            CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrDiagCbContext"), v28);
            CFRelease(v29);
LABEL_32:
            if (sub_10004772C((_QWORD *)a1, Mutable))
            {
              v30 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Scheduling Probe Failed", "WiFiLQAMgrEnqueueDiagnosticProbe");
              goto LABEL_40;
            }
            v31 = 0;
            if (!v18)
            {
LABEL_42:
              if (v20)
                CFRelease(v20);
              goto LABEL_44;
            }
LABEL_41:
            CFRelease(v18);
            goto LABEL_42;
          }
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: callbackCtxt is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
LABEL_40:
          objc_autoreleasePoolPop(v30);
          v31 = 4294963394;
          if (!v18)
            goto LABEL_42;
          goto LABEL_41;
        }
        v30 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: DiagProbe ipv4Addr is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
LABEL_39:
        v7 = v37;
        goto LABEL_40;
      }
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeSizeDefRef is NULL", "WiFiLQAMgrEnqueueDiagnosticProbe");
LABEL_62:
      objc_autoreleasePoolPop(v35);
      v31 = 4294963394;
      v7 = v37;
LABEL_44:
      if (!v7 && Mutable)
        CFRelease(Mutable);
      return v31;
    }
LABEL_14:
    v18 = 0;
    v20 = 0;
    goto LABEL_15;
  }
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Ignoring diagnostic probe in unassociated state and submitting empty metric", "WiFiLQAMgrEnqueueDiagnosticProbe");
  objc_autoreleasePoolPop(v34);
  return 4294963394;
}

void sub_1000430BC(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
  const void *v7;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFNumber *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t valuePtr;

  v16 = 0;
  valuePtr = 0;
  if (a4)
  {
    v7 = *(const void **)(a4 + 384);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a4 + 384) = 0;
    }
    if (*(_BYTE *)(a4 + 640))
    {
      if (a3)
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Init Probe gave an error %ld", "__WiFiLQAMgrInitProbeResultCallBack", a3);
      }
      else if (theArray)
      {
        if (CFArrayGetCount(theArray))
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesSent"));
          if (Value)
            CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
          v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesFail"));
          if (v10)
          {
            CFNumberGetValue(v10, kCFNumberCFIndexType, &v16);
            v11 = v16;
          }
          else
          {
            v11 = 0;
          }
          v12 = valuePtr;
          v13 = objc_autoreleasePoolPush();
          if (v12 && v11 == v12)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Gateway NOT pingeable", "__WiFiLQAMgrInitProbeResultCallBack");
            objc_autoreleasePoolPop(v13);
            *(_BYTE *)(a4 + 358) = 0;
          }
          else
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Gateway pingeable", "__WiFiLQAMgrInitProbeResultCallBack");
            objc_autoreleasePoolPop(v13);
            *(_BYTE *)(a4 + 358) = 1;
          }
          return;
        }
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: zero elements in probeResultRef", "__WiFiLQAMgrInitProbeResultCallBack", v15);
      }
      else
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeResultRef is null", "__WiFiLQAMgrInitProbeResultCallBack", v15);
      }
      objc_autoreleasePoolPop(v14);
    }
  }
}

void sub_1000432AC(uint64_t a1, const __CFString *a2, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v6;
  const void *v7;
  const void *v8;
  void *v9;

  if (a1 && *(_BYTE *)(a1 + 640))
  {
    Value = (const __CFString *)CFDictionaryGetValue(theDict, kSCPropNetIPv4ARPResolvedIPAddress);
    if (Value)
    {
      v6 = Value;
      *(_DWORD *)(a1 + 2840) |= 2u;
      if (+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"))
        objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "setIpAddrAssigned:", 1);
      v7 = *(const void **)(a1 + 400);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a1 + 400) = 0;
      }
      v8 = *(const void **)(a1 + 40);
      if (v8)
      {
        CFRelease(v8);
        *(_QWORD *)(a1 + 40) = 0;
      }
      *(_QWORD *)(a1 + 400) = CFStringCreateCopy(kCFAllocatorDefault, v6);
      *(_QWORD *)(a1 + 40) = CFStringCreateCopy(kCFAllocatorDefault, a2);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManager IPAddr is NULL", "WiFiLQAMgrSetRouterIpv4Addr");
      objc_autoreleasePoolPop(v9);
    }
  }
}

uint64_t sub_1000433C8(uint64_t result, int a2, double a3)
{
  if (result && *(_BYTE *)(result + 640) && *(_DWORD *)(result + 2776) != a2)
  {
    *(_DWORD *)(result + 2776) = a2;
    *(double *)(result + 2784) = a3;
  }
  return result;
}

void sub_1000433EC(uint64_t a1, uint64_t a2)
{
  uint64_t f;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  const char *v10;

  if (a1 && a2)
  {
    *(_QWORD *)(a1 + 1280) = a2;
    f = dispatch_mach_create_f("com.apple.wifimanager.link-quality", a2, a1, sub_100043524);
    *(_QWORD *)(a1 + 424) = f;
    if (f)
      dispatch_mach_connect(f, *(unsigned int *)(a1 + 420), 0, 0);
    v5 = dispatch_mach_create_f("com.apple.wifimanager.link-quality-dns-fail", a2, a1, sub_100043698);
    *(_QWORD *)(a1 + 448) = v5;
    if (v5)
      dispatch_mach_connect(v5, *(unsigned int *)(a1 + 444), 0, 0);
    v6 = *(NSObject **)(a1 + 336);
    if (v6)
      dispatch_activate(v6);
    v7 = *(NSObject **)(a1 + 544);
    if (v7)
      dispatch_activate(v7);
    if (sub_100032154(*(_QWORD *)(a1 + 32)))
    {
      v8 = *(NSObject **)(a1 + 2904);
      if (v8)
        dispatch_activate(v8);
    }
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v10 = "manager";
      if (a1)
        v10 = "queue";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA %s is null", "WiFiLQAMgrScheduleWithQueue", v10);
    }
    objc_autoreleasePoolPop(v9);
  }
}

void sub_100043524(uint64_t a1, unint64_t a2)
{
  uint64_t state;
  uint64_t v4;
  void *v5;
  void *v6;
  _QWORD v7[5];
  uint64_t state64;

  state64 = 0;
  if (!&_managed_event_fetch)
    return;
  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is null", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback");
    goto LABEL_16;
  }
  if (a2 <= 8 && ((1 << a2) & 0x182) != 0)
    return;
  if (!*(_BYTE *)(a1 + 640))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is disabled", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback");
LABEL_16:
    objc_autoreleasePoolPop(v6);
    return;
  }
  state = notify_get_state(*(_DWORD *)(a1 + 416), &state64);
  if ((_DWORD)state)
  {
    v4 = state;
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Unable to get Symptoms Event ID Error %d", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback", v4);
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    CFRetain((CFTypeRef)a1);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_10004E12C;
    v7[3] = &unk_10022F180;
    v7[4] = a1;
    managed_event_fetch_series(state64, 7, v7);
  }
}

void sub_100043698(uint64_t a1, unint64_t a2)
{
  uint64_t state;
  void *v4;
  void *v5;
  uint64_t state64;

  state64 = 0;
  if (&_managed_event_fetch && (a2 > 8 || ((1 << a2) & 0x182) == 0))
  {
    if (a1)
    {
      state = notify_get_state(*(_DWORD *)(a1 + 440), &state64);
      v4 = objc_autoreleasePoolPush();
      if ((_DWORD)state)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Unable to get Symptoms Event ID Error %d", "__WiFiLQAMgrDNSFailureSymptomsCallback", state);
        objc_autoreleasePoolPop(v4);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s called at %f", "__WiFiLQAMgrDNSFailureSymptomsCallback", CFAbsoluteTimeGetCurrent());
        objc_autoreleasePoolPop(v4);
        *(_DWORD *)(a1 + 2828) = 8;
        sub_10004A888((CFTypeRef)a1, 0, 1);
        -[WiFiUsageMonitor addFaultEvent:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addFaultEvent:forInterface:", 18, *(_QWORD *)(a1 + 40));
      }
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is null", "__WiFiLQAMgrDNSFailureSymptomsCallback");
      objc_autoreleasePoolPop(v5);
    }
  }
}

void sub_100043800(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  __CFRunLoop *Main;
  void *v7;
  const char *v8;

  if (a1 && a2)
  {
    *(_BYTE *)(a1 + 2984) = 1;
    v3 = *(NSObject **)(a1 + 544);
    if (v3)
      dispatch_source_cancel(v3);
    v4 = *(NSObject **)(a1 + 336);
    if (v4)
      dispatch_source_cancel(v4);
    v5 = *(NSObject **)(a1 + 2904);
    if (v5)
      dispatch_source_cancel(v5);
    *(_BYTE *)(a1 + 2912) = 0;
    if (*(_QWORD *)(a1 + 424))
    {
      dispatch_mach_cancel();
      dispatch_release(*(dispatch_object_t *)(a1 + 424));
      *(_QWORD *)(a1 + 424) = 0;
    }
    if (*(_QWORD *)(a1 + 448))
    {
      dispatch_mach_cancel();
      dispatch_release(*(dispatch_object_t *)(a1 + 448));
      *(_QWORD *)(a1 + 448) = 0;
    }
    if (*(_QWORD *)(a1 + 1272))
    {
      Main = CFRunLoopGetMain();
      CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 1272), kCFRunLoopDefaultMode);
    }
    *(_QWORD *)(a1 + 1280) = 0;
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v8 = "manager";
      if (a1)
        v8 = "queue";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA %s is null", "WiFiLQAMgrUnscheduleFromQueue", v8);
    }
    objc_autoreleasePoolPop(v7);
  }
}

void sub_100043910(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;

  if (a1)
  {
    if (a2)
    {
      *(_QWORD *)(a1 + 552) = a2;
      *(_QWORD *)(a1 + 560) = a3;
      return;
    }
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, Triggered Disconnect Callback is NULL", "WiFiLQAMgrRegisterTriggerDisconnectCallback");
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrRegisterTriggerDisconnectCallback");
  }
  objc_autoreleasePoolPop(v3);
}

void sub_1000439B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;

  if (a1)
  {
    if (a2)
    {
      *(_QWORD *)(a1 + 568) = a2;
      *(_QWORD *)(a1 + 576) = a3;
      return;
    }
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, GetApEnvironment Callback is NULL", "WiFiLQAMgrRegisterGetAPEnvironmentCallback");
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrRegisterGetAPEnvironmentCallback");
  }
  objc_autoreleasePoolPop(v3);
}

uint64_t sub_100043A60(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 584) = a2;
  *(_QWORD *)(result + 592) = a3;
  return result;
}

id sub_100043A6C(uint64_t a1)
{
  void *v1;
  void *v3;

  if (a1)
  {
    v1 = *(void **)(a1 + 616);
    if (v1)
      return objc_msgSend(v1, "copy");
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqaMgr null", "WiFiLQAMgrCopyColocatedScopeSsids");
    objc_autoreleasePoolPop(v3);
  }
  return 0;
}

void sub_100043AE8(uint64_t a1, const void *a2)
{
  id v4;
  void *v5;
  const void *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, const void *, _QWORD);
  int v10;
  const void *v11;
  const __CFNumber *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  const void *v18;
  const void *v19;
  id v20;
  void *v21;
  const void *v22;
  id v23;
  void *v24;
  __CFString *v25;
  __CFString *Mutable;
  void *v27;
  void *v28;
  const char *v29;
  const void *v30;
  const void *v31;
  const __CFNumber *v32;
  uint64_t v33;
  const __CFString *v34;
  const __CFString *v35;
  unsigned int valuePtr;

  valuePtr = 0;
  v4 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
  if (a1)
  {
    v5 = v4;
    v6 = *(const void **)(a1 + 48);
    if (a2)
      v7 = v6 == 0;
    else
      v7 = 1;
    v8 = !v7;
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 48) = 0;
    }
    *(_BYTE *)(a1 + 600) = 0;
    if (a2)
    {
      *(_QWORD *)(a1 + 48) = CFRetain(a2);
      v9 = *(uint64_t (**)(uint64_t, const void *, _QWORD))(a1 + 568);
      if (v9)
        v10 = v9(a1, a2, *(_QWORD *)(a1 + 576));
      else
        v10 = 0;
      *(_DWORD *)(a1 + 224) = v10;
      v12 = (const __CFNumber *)sub_1000316E0((uint64_t)a2);
      if (v12)
        CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
      v13 = sub_10003153C((uint64_t)a2);
      v14 = v13;
      if (v5)
        objc_msgSend(v5, "setLinkUpWithBSSEnvironment:band:roam:inCharging:motionState:", *(int *)(a1 + 224), v13, v8, *(_BYTE *)(a1 + 2792) != 0, *(unsigned int *)(a1 + 2776));
      if ((_DWORD)v14 == 1 && *(_DWORD *)(a1 + 224) > 2u)
      {
        *(_BYTE *)(a1 + 2844) = 1;
        *(_DWORD *)(a1 + 2840) |= 1u;
        *(_DWORD *)(a1 + 2836) = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Reassoc Needed. linkUpRssi (%d) Current band (%d) Env (%d) ", *(unsigned int *)(a1 + 2836), v14, *(unsigned int *)(a1 + 224));
        objc_autoreleasePoolPop(v15);
      }
      else
      {
        *(_BYTE *)(a1 + 2844) = 0;
      }
      v16 = objc_autoreleasePoolPush();
      *(_DWORD *)(a1 + 56) = 0;
      v17 = *(_QWORD *)(a1 + 48);
      if (v17)
      {
        v18 = sub_10002BE64(v17, CFSTR("BSSID"));
        v19 = sub_10002B088(*(const void **)(a1 + 48));
        if (+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager")&& objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"))
        {
          *(_DWORD *)(a1 + 56) = objc_msgSend(objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"), "autoLeaveRssiForBSS:ssid:", v18, v19);
        }
        if ((v8 & 1) == 0)
        {
          if (_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
          {
            v20 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyColocatedScopeIdForNetwork:", *(_QWORD *)(a1 + 48));
            if (v20)
            {
              v21 = v20;
              v22 = *(const void **)(a1 + 616);
              if (v22)
              {
                CFRelease(v22);
                *(_QWORD *)(a1 + 616) = 0;
              }
              v23 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "copyAllStoredNetworkSsidsWithColocatedScopeId:", v21);
              if (v23)
              {
                v24 = v23;
                if ((unint64_t)objc_msgSend(v23, "count") >= 2
                  && objc_msgSend(v24, "containsObject:", v19))
                {
                  *(_QWORD *)(a1 + 608) = objc_msgSend(v24, "count");
                  *(_QWORD *)(a1 + 616) = v24;
                }
                else
                {
                  CFRelease(v24);
                }
              }

            }
          }
        }
        Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
        v25 = Mutable;
        if (Mutable)
        {
          if (*(_DWORD *)(a1 + 56))
            CFStringAppendFormat(Mutable, 0, CFSTR(" AutoLeaveRssi %d "), *(unsigned int *)(a1 + 56));
          if (*(_QWORD *)(a1 + 608))
            CFStringAppendFormat(v25, 0, CFSTR(" colocatedScope networks %lu "), *(_QWORD *)(a1 + 608));
        }
      }
      else
      {
        v25 = 0;
      }
      objc_autoreleasePoolPop(v16);
      v27 = objc_autoreleasePoolPush();
      v28 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        if ((_DWORD)v8)
          v29 = "Roamed";
        else
          v29 = "Joined";
        v30 = sub_10002B088(a2);
        v31 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
        v32 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
        v33 = valuePtr;
        v34 = sub_10002B5A4(*(_DWORD *)(a1 + 224));
        v35 = &stru_100238178;
        if (v25)
          v35 = v25;
        objc_msgSend(v28, "WFLog:message:", 3, "%s: %s SSID: %@ BSSID: %@ RSSI: %ld Chan: %d ApEnv: %@(%d) %@", "__WiFiLQAMgrSetCurrentNetwork", v29, v30, v31, v32, v33, v34, *(unsigned int *)(a1 + 224), v35);
      }
      objc_autoreleasePoolPop(v27);
      if (v25)
        CFRelease(v25);
    }
    else
    {
      *(_QWORD *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 224) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      *(_BYTE *)(a1 + 2844) = 0;
      *(_QWORD *)(a1 + 2836) = 0;
      if (v5)
      {
        objc_msgSend(v5, "setIpAddrAssigned:", 0);
        objc_msgSend(v5, "setLinkDown");
      }
      *(_QWORD *)(a1 + 608) = 0;
      v11 = *(const void **)(a1 + 616);
      if (v11)
      {
        CFRelease(v11);
        *(_QWORD *)(a1 + 616) = 0;
      }
    }
    *(_DWORD *)(a1 + 1084) = 1061997773;
    *(_DWORD *)(a1 + 1248) = 1061997773;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 240) = 0;
  }
}

void sub_100043EF8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  *(_BYTE *)(a1 + 3208) = 1;
  v1 = sub_1000247B8(a1, 1, 0);
  if ((_DWORD)v1)
  {
    v2 = v1;
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ERROR: %d Failed to enable rapid LQM", "__WiFiLQAMgrSetRapidLQMInterval", v2);
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_100043F7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v7;
  int v8;
  double Current;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int v21;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v23;
  int v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  double v28;
  double v29;
  int v30;
  void *v31;
  int v32;
  void *v33;
  float v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  char v39;
  float v40;
  int v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  _BOOL4 v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  double v55;
  const __CFArray *v56;
  const __CFDictionary *v57;
  int v58;
  const __CFDictionary *v59;
  const __CFNumber *Value;
  int v61;
  void *v62;
  void *v63;
  _BOOL4 v64;
  unsigned int v65;
  int v66;
  int v67;
  BOOL v68;
  int v69;
  BOOL v70;
  BOOL v71;
  BOOL v72;
  WiFiUsageMonitor *v73;
  uint64_t v74;
  int v75;
  void (*v76)(_QWORD, _QWORD);
  int v77;
  char v78;
  char v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  unsigned __int8 *v89;
  unsigned int v90;
  void *v91;
  int v92;
  uint64_t v93;
  __int128 v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  _UNKNOWN **v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  id v105;
  int v106;
  int v107;
  void *v108;
  int v109;
  void *v110;
  int v111;
  void *v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  double v122;
  int v123;
  void *v124;
  void *v125;
  char v126;
  double v127;
  void *v128;
  void *v129;
  void *v130;
  double v131;
  int v132;
  char v133;
  char v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  unsigned int v145;
  int v146;
  void *v147;
  int v148;
  uint64_t v149;
  int v150;
  int valuePtr;
  char v152;
  char v153;
  char v154;
  char v155;
  int v156;
  char v157;
  BOOL v158;
  char v159;
  BOOL v160;
  BOOL v161;
  BOOL v162;
  int v163;
  __int16 v164;
  uint64_t v165;
  _BYTE v166[44];
  __int16 v167;
  int v168;
  __int16 v169;

  v169 = 0;
  v168 = 0;
  v167 = 0;
  if (!a1)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: LQAMgrRef is null";
    goto LABEL_64;
  }
  if (!*(_BYTE *)(a1 + 640))
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: LQA is disabled", "__WiFiLQAMgrCheckTriggerDisconnect", *(_QWORD *)&v131);
    goto LABEL_11;
  }
  v4 = *(_DWORD *)(a1 + 20);
  if (v4 == 1)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: Trigger Disconnect check in GoodLinkState";
    goto LABEL_64;
  }
  if (!v4)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: Trigger Disconnect check in UnassociatedState";
    goto LABEL_64;
  }
  v7 = *(_DWORD *)(a1 + 16);
  v8 = *(unsigned __int8 *)(a1 + 641);
  *(_BYTE *)(a1 + 2793) = 0;
  if (!*(_BYTE *)(a1 + 2832) && *(_BYTE *)(a1 + 221) && !(*(unsigned __int8 *)(a1 + 642) | v8))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: Better inf not available";
    goto LABEL_9;
  }
  Current = CFAbsoluteTimeGetCurrent();
  if (*(_BYTE *)(a1 + 161))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_11:
      objc_autoreleasePoolPop(v10);
      goto LABEL_12;
    }
    v12 = "%s Wait for callback";
    goto LABEL_9;
  }
  v16 = Current;
  -[WiFiUsageMonitor addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:", *(_QWORD *)(a1 + 40), 1, 0, 0);
  -[WiFiUsageMonitor setTdLogic_alertedBy:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setTdLogic_alertedBy:forInterface:", *(unsigned int *)(a1 + 2828), *(_QWORD *)(a1 + 40));
  *(_BYTE *)(a1 + 176) = 0;
  v17 = *(double *)(a1 + 64);
  if (v17 == 0.0)
    v18 = 0.0;
  else
    v18 = v16 - v17;
  if (!sub_100008DA8(a1) && *(double *)(a1 + 64) != 0.0 && v18 <= *(double *)(a1 + 688))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v131 = v18;
    v12 = "%s: Bypassed, Link established just before %2.2f secs";
    goto LABEL_9;
  }
  v19 = *(double *)(a1 + 80);
  if (v19 == 0.0)
    v20 = 0.0;
  else
    v20 = v16 - v19;
  if (!sub_100008DA8(a1) && *(double *)(a1 + 80) != 0.0 && v20 <= *(double *)(a1 + 680))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v131 = v20;
    v12 = "%s: Bypassed, System woke up before %2.2f secs";
LABEL_9:
    v13 = 3;
LABEL_10:
    objc_msgSend(v11, "WFLog:message:", v13, v12, "__WiFiLQAMgrCheckTriggerDisconnect", *(_QWORD *)&v131);
    goto LABEL_11;
  }
  v21 = sub_1000465D0(a1);
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 24)))
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
    if (ValueAtIndex)
    {
      v23 = ValueAtIndex;
      LOBYTE(v167) = sub_100045800(a1, ValueAtIndex);
      HIBYTE(v167) = sub_100045BC4(a1, v23, *(unsigned __int8 *)(a1 + 248));
    }
  }
  memset(v166, 0, sizeof(v166));
  if (!sub_1000484B0(a1, v166))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: Failed to extract metrics from Lqm, exiting!";
    goto LABEL_64;
  }
  v24 = 0;
  v25 = *(unsigned __int8 *)(a1 + 646);
  if (*(_BYTE *)(a1 + 645))
    v26 = v25 == 0;
  else
    v26 = 1;
  v27 = !v26;
  v28 = *(double *)(a1 + 2784);
  if (v28 == 0.0)
    v29 = 0.0;
  else
    v29 = v16 - v28;
  v30 = *(_DWORD *)(a1 + 2776);
  if (v30 == 2 && (_DWORD)v27)
  {
    if (v29 <= *(double *)(a1 + 696))
    {
      v24 = 0;
      goto LABEL_66;
    }
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Usr walking for %.2f secs, using aggressive TD checks", "__WiFiLQAMgrCheckTriggerDisconnect", *(_QWORD *)&v29);
    objc_autoreleasePoolPop(v31);
    v30 = *(_DWORD *)(a1 + 2776);
    v24 = 1;
  }
  if (v30 == 4)
    v32 = v27;
  else
    v32 = 0;
  if (v32 == 1)
  {
    if (v29 > *(double *)(a1 + 704))
    {
      v33 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Usr in Automotive for %.2f secs, using aggressive TD checks", "__WiFiLQAMgrCheckTriggerDisconnect", *(_QWORD *)&v29);
      objc_autoreleasePoolPop(v33);
      v24 = 1;
    }
    v34 = *(float *)(a1 + 712);
    goto LABEL_67;
  }
LABEL_66:
  v34 = *(float *)(a1 + 712);
  if ((v27 & 1) != 0)
  {
LABEL_67:
    v35 = *(_DWORD *)(a1 + 2796);
    if (v35 <= *(_DWORD *)(a1 + 660))
    {
      v34 = *(float *)(a1 + 720);
    }
    else if (v35 <= *(_DWORD *)(a1 + 656))
    {
      v34 = *(float *)(a1 + 716);
    }
    if (*(_BYTE *)(a1 + 740)
      && *(int *)&v166[4] >= *(_DWORD *)(a1 + 744)
      && (float)(*(float *)(a1 + 748) * (float)*(int *)&v166[4]) <= (float)*(int *)v166
      && *(int *)&v166[8] > *(_DWORD *)(a1 + 752) * *(_DWORD *)&v166[4])
    {
      v142 = 1;
      *(_BYTE *)(a1 + 2824) = 1;
    }
    else
    {
      v142 = 0;
    }
    goto LABEL_78;
  }
  v142 = 0;
  v35 = *(_DWORD *)(a1 + 2796);
LABEL_78:
  v36 = 0;
  v37 = v27 ^ 1;
  v38 = *(_DWORD *)(a1 + 656);
  if (v35 <= v38)
    v39 = v27;
  else
    v39 = 0;
  v40 = (float)*(int *)v166;
  v41 = *(_DWORD *)&v166[4];
  v42 = (float)*(int *)&v166[4];
  v43 = -64;
  do
  {
    if ((v39 & 1) != 0)
    {
      v44 = a1 + 16 * v36;
      v45 = v44 + 1096;
      v46 = v44 + 932;
      if (v35 <= *(_DWORD *)(a1 + 660))
        v46 = v45;
    }
    else
    {
      v46 = a1 + v43 + 788;
    }
    v47 = a1 + v43 + 1160;
    if (v35 > v38)
      v47 = v46;
    if (v24)
      v46 = v47;
    if (*(_BYTE *)v46
      && *(int *)&v166[4] >= *(_DWORD *)(v46 + 4)
      && (float)(*(float *)(v46 + 8) * v42) <= v40
      && *(int *)&v166[8] > *(_DWORD *)(v46 + 12) * *(_DWORD *)&v166[4])
    {
      v142 = 1;
      if ((v27 & 1) != 0)
        goto LABEL_97;
      goto LABEL_110;
    }
    ++v36;
    v43 += 16;
  }
  while (v43);
  if ((v27 & 1) == 0)
  {
LABEL_110:
    v141 = 0;
    v49 = v35 > v38;
LABEL_111:
    v50 = a1 + 868;
    v51 = 1;
    goto LABEL_112;
  }
LABEL_97:
  if (*(_BYTE *)(a1 + 868)
    && *(int *)&v166[28] > *(_DWORD *)(a1 + 872)
    && (float)((float)(1.0 - *(float *)(a1 + 876)) * (float)*(int *)&v166[28]) > (float)*(int *)&v166[32]
    && (*(int *)&v166[4] < *(_DWORD *)(a1 + 880) || (float)(*(float *)(a1 + 884) * v42) <= v40))
  {
    v141 = 1;
    *(_BYTE *)(a1 + 2824) = 1;
  }
  else
  {
    v141 = 0;
  }
  v48 = v35 <= v38;
  v49 = v35 > v38;
  if (!v48)
    v37 = 1;
  if (v37 == 1)
    goto LABEL_111;
  v50 = a1 + 1240;
  v51 = 0;
  v49 = 0;
  if (v35 > *(_DWORD *)(a1 + 660))
    v50 = a1 + 1076;
LABEL_112:
  if (!v24)
    v49 = 1;
  if (!v49)
    v50 = a1 + 1240;
  if (*(_BYTE *)v50
    && *(int *)&v166[28] > *(_DWORD *)(v50 + 4)
    && (float)((float)(1.0 - *(float *)(v50 + 8)) * (float)*(int *)&v166[28]) > (float)*(int *)&v166[32]
    && (v41 < *(_DWORD *)(v50 + 12) || (float)(*(float *)(v50 + 16) * v42) <= v40))
  {
    v141 = 1;
  }
  if ((_DWORD)v27
    && *(_BYTE *)(a1 + 788)
    && *(int *)&v166[20] >= *(_DWORD *)(a1 + 792)
    && (float)(*(float *)(a1 + 796) * (float)*(int *)&v166[20]) <= (float)*(int *)&v166[16]
    && (v41 < *(_DWORD *)(a1 + 800) || (float)(*(float *)(a1 + 804) * v42) <= v40))
  {
    v143 = 1;
    *(_BYTE *)(a1 + 2824) = 1;
  }
  else
  {
    v143 = 0;
  }
  v52 = 0;
  v53 = -80;
  while (1)
  {
    if (v51)
    {
      v54 = a1 + v53 + 868;
    }
    else
    {
      v54 = a1 + 20 * v52 + 1160;
      if (v35 > *(_DWORD *)(a1 + 660))
        v54 = a1 + 20 * v52 + 996;
    }
    if (!v49)
      v54 = a1 + v53 + 1240;
    if (*(_BYTE *)v54
      && *(int *)&v166[20] >= *(_DWORD *)(v54 + 4)
      && (float)(*(float *)(v54 + 8) * (float)*(int *)&v166[20]) <= (float)*(int *)&v166[16]
      && (v41 < *(_DWORD *)(v54 + 12) || (float)(*(float *)(v54 + 16) * v42) <= v40))
    {
      break;
    }
    ++v52;
    v53 += 20;
    if (!v53)
      goto LABEL_144;
  }
  v143 = 1;
LABEL_144:
  v55 = 0.0;
  if (*(_DWORD *)(a1 + 2760) == 1)
    v55 = v16 - *(double *)(a1 + 2768);
  if (*(_BYTE *)(a1 + 904) && v55 >= *(double *)(a1 + 912))
  {
    v148 = 1;
    *(_BYTE *)(a1 + 2824) = 1;
  }
  else
  {
    v148 = 0;
  }
  if (*(_BYTE *)(a1 + 920) && *(_DWORD *)(a1 + 488) >= *(_DWORD *)(a1 + 924))
  {
    v144 = 1;
    *(_BYTE *)(a1 + 2824) = 1;
  }
  else
  {
    v144 = 0;
  }
  v136 = v27;
  v137 = *(int *)(a1 + 56);
  if (!(_DWORD)v137)
  {
    if (!*(_BYTE *)(a1 + 888))
    {
      v145 = 0;
      goto LABEL_174;
    }
    goto LABEL_169;
  }
  valuePtr = 0;
  v56 = *(const __CFArray **)(a1 + 24);
  if (!v56)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s, LQAManager: LQM table is NULL";
    goto LABEL_64;
  }
  if (!CFArrayGetCount(v56))
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s: LQM table is empty";
    goto LABEL_64;
  }
  v57 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  if (!v57)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_11;
    v12 = "%s, LQAManager: Latest LQM Report is NULL";
LABEL_64:
    v13 = 4;
    goto LABEL_10;
  }
  if (*(_BYTE *)(a1 + 2832))
  {
    v58 = sub_1000118A8(a1);
    goto LABEL_165;
  }
  v59 = v57;
  v58 = *(_DWORD *)(a1 + 2796);
  valuePtr = v58;
  if (v58)
  {
LABEL_165:
    v61 = *(_DWORD *)(a1 + 56);
    if (!*(_BYTE *)(a1 + 888))
    {
      v145 = v61 >= v58;
      goto LABEL_174;
    }
    if (v61 >= v58)
    {
      v145 = 1;
      if (!a2)
      {
        v146 = 0;
        goto LABEL_182;
      }
LABEL_171:
      if ((float)(*(float *)(a1 + 896) * (float)a2) < (float)a3)
        goto LABEL_179;
      goto LABEL_174;
    }
LABEL_169:
    v145 = 0;
    if (a2 && *(_BYTE *)(a1 + 358))
      goto LABEL_171;
LABEL_174:
    v146 = 0;
    if (!a2 || !*(_BYTE *)(a1 + 643))
      goto LABEL_182;
    v62 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Simulating probe failure decision", "__WiFiLQAMgrCheckTriggerDisconnect");
    objc_autoreleasePoolPop(v62);
LABEL_179:
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s autoLeaveDecision:%d probesSent:%ld probesFailed:%ld", "__WiFiLQAMgrCheckTriggerDisconnect", v145, a2, a3);
    objc_autoreleasePoolPop(v63);
    v146 = 1;
LABEL_182:
    v64 = sub_10004BD44(a1, &v167, (_BYTE *)&v167 + 1);
    v65 = v141 | v142 | v143 | v148;
    if (v145)
      v65 = 1;
    v138 = v7;
    v140 = v64;
    if (v64)
      v14 = 1;
    else
      v14 = v65;
    v66 = *(_DWORD *)(a1 + 16);
    v135 = v25;
    v132 = v21;
    v133 = a2;
    v134 = a3;
    if (v66)
    {
      if (v66 == 2)
      {
        if ((v146 & 1) != 0)
        {
          v14 = 1;
        }
        else if (*(_BYTE *)(a1 + 358))
        {
          v14 = 0;
        }
        else
        {
          v14 = v14;
        }
      }
      else if (v66 == 1)
      {
        v14 = v144 | v14;
      }
      else
      {
        v14 = v64 || v145 != 0;
      }
    }
    v67 = HIBYTE(v167);
    v68 = HIBYTE(v167) != 0;
    if ((_BYTE)v167)
      v69 = v14;
    else
      v69 = 0;
    v70 = *(_BYTE *)(a1 + 248) != 0;
    v71 = (*(_QWORD *)(a1 + 168) & 0x11) != 0;
    v72 = *(_BYTE *)(a1 + 641) != 0;
    -[WiFiUsageMonitor addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addTriggerDisconnectEvent:isAlerted:isConfirmed:isExecuted:", *(_QWORD *)(a1 + 40), 0, v14, 0);
    v73 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
    v74 = *(_QWORD *)(a1 + 40);
    LOBYTE(valuePtr) = v142;
    BYTE1(valuePtr) = v141;
    BYTE2(valuePtr) = v143;
    HIBYTE(valuePtr) = v148;
    v152 = v144;
    v153 = v145;
    v154 = v146;
    v75 = v140;
    v155 = v140;
    v156 = v138;
    v157 = v24;
    v158 = v68;
    v139 = v69;
    v159 = v69;
    v160 = v70;
    v161 = v71;
    v162 = v72;
    v163 = v168;
    v164 = v169;
    v165 = v137;
    -[WiFiUsageMonitor setTdLogic_decisionState:forInterface:](v73, "setTdLogic_decisionState:forInterface:", &valuePtr, v74);
    if ((_DWORD)v14)
    {
      v76 = *(void (**)(_QWORD, _QWORD))(a1 + 624);
      if (v76)
        v76(*(_QWORD *)(a1 + 632), 0);
    }
    v77 = v67;
    v78 = HIBYTE(v167);
    *(_BYTE *)(a1 + 273) = HIBYTE(v167);
    v79 = v167;
    *(_BYTE *)(a1 + 272) = v167;
    if (v144)
      v80 = 16;
    else
      v80 = 0;
    if (v146)
      v81 = 32;
    else
      v81 = 0;
    if (v148)
      v82 = 64;
    else
      v82 = 0;
    v83 = v145;
    v84 = v80 | v82 | v81 | (2 * v142) | (8 * v141) | (4 * v143) | v14 | (v145 << 22) | (v140 << 23);
    if (v139)
      v85 = 0;
    else
      v85 = 1024;
    v86 = *(unsigned __int8 *)(a1 + 248);
    v87 = (v24 << 7) | ((v67 != 0) << 8) | v85 | v84 | (v86 << 9) | (*(unsigned __int8 *)(a1 + 2824) << 21) | (((*(_BYTE *)(a1 + 168) & 0x11) != 0) << 14);
    v88 = *(unsigned __int8 *)(a1 + 2752);
    if (v88 >= 0xA)
    {
      v130 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid curRecord %d", "__WiFiLQAMgrGetNextLQAMetricsRecordIdx", *(unsigned __int8 *)(a1 + 2752));
    }
    else if (*(_BYTE *)(a1 + 2753))
    {
      v130 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: curRecord %d is busy", "__WiFiLQAMgrGetNextLQAMetricsRecordIdx", *(unsigned __int8 *)(a1 + 2752));
    }
    else
    {
      v89 = (unsigned __int8 *)(a1 + 1304);
      v90 = *(unsigned __int8 *)(a1 + 1304);
      if (v90 < 0xB)
      {
        if (v90 == 10)
        {
          v91 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: submittotalRecords %d", "__WiFiLQAMgrGetNextLQAMetricsRecordIdx", *v89);
          objc_autoreleasePoolPop(v91);
          sub_100059250((_BYTE *)(a1 + 1304));
          v88 = 0;
          *(_BYTE *)(a1 + 1304) = 0;
          *(_BYTE *)(a1 + 2752) = 0;
          v78 = HIBYTE(v167);
          v79 = v167;
          LOBYTE(v86) = *(_BYTE *)(a1 + 248);
        }
        v92 = 1;
        *(_BYTE *)(a1 + 2753) = 1;
        v93 = a1 + 144 * v88;
        *(int32x2_t *)&v94 = vrev64_s32(*(int32x2_t *)v166);
        *((_QWORD *)&v94 + 1) = __PAIR64__(*(unsigned int *)&v166[28], *(unsigned int *)&v166[8]);
        *(_OWORD *)(v93 + 1312) = v94;
        v95 = v166[36];
        *(_DWORD *)(v93 + 1328) = *(_DWORD *)&v166[32];
        *(int32x4_t *)(v93 + 1332) = vzip2q_s32(*(int32x4_t *)&v166[12], vzip1q_s32(*(int32x4_t *)&v166[12], vdupq_lane_s32(*(int32x2_t *)&v166[12], 0)));
        *(_BYTE *)(v93 + 1349) = v14;
        *(_BYTE *)(v93 + 1348) = v95;
        *(_BYTE *)(v93 + 1350) = v148;
        *(_BYTE *)(v93 + 1352) = v78;
        *(_BYTE *)(v93 + 1353) = v79;
        *(_BYTE *)(v93 + 1354) = v86;
        *(_BYTE *)(v93 + 1355) = v144;
        *(double *)(v93 + 1384) = v29;
        *(_BYTE *)(v93 + 1351) = *(_DWORD *)(a1 + 2776);
        *(_QWORD *)(v93 + 1408) = *(_QWORD *)(a1 + 280);
        *(_BYTE *)(v93 + 1448) = v145;
        *(_BYTE *)(v93 + 1449) = *(_DWORD *)(a1 + 56);
        *(_BYTE *)(v93 + 1450) = v146;
        *(_BYTE *)(v93 + 1451) = v133;
        *(_BYTE *)(v93 + 1452) = v134;
LABEL_225:
        if (*(_BYTE *)(a1 + 641))
        {
          v96 = v87;
          v97 = v136;
          goto LABEL_227;
        }
        if (((v14 ^ 1) & 1) == 0 && v83 && !v75)
        {
          if (!*(_BYTE *)(a1 + 357))
          {
            v149 = v87;
            v112 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Overriding AutoLeave (User Preference Adaptive) TriggerDisconnect decision for Probes", "__WiFiLQAMgrCheckTriggerDisconnect");
            objc_autoreleasePoolPop(v112);
            *(_BYTE *)(a1 + 357) = 1;
            *(_BYTE *)(a1 + 392) = 1;
            sub_10004CC50(a1);
            v102 = 0;
            v104 = 0;
            v14 = 0;
            v103 = 0x1000000;
            v99 = WiFiSoftError_ptr;
            goto LABEL_262;
          }
          if (v146)
          {
            v149 = v87;
            v101 = objc_autoreleasePoolPush();
            v99 = WiFiSoftError_ptr;
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Proceeding with AutoLeave (User Preference Adaptive) TriggerDisconnect", "__WiFiLQAMgrCheckTriggerDisconnect");
            objc_autoreleasePoolPop(v101);
            v102 = 0;
            v103 = 0;
            v104 = 0;
LABEL_262:
            v97 = v136;
LABEL_335:
            v126 = v92 ^ 1;
            if (*(_BYTE *)(a1 + 161))
              v126 = 1;
            if ((v126 & 1) == 0)
            {
              *(_BYTE *)(a1 + 144 * v88 + 1349) = v14;
              if ((_DWORD)v14)
              {
                if (*(double *)(a1 + 136) != 0.0)
                  *(_QWORD *)(a1 + 144 * v88 + 1432) = (unint64_t)(CFAbsoluteTimeGetCurrent()
                                                                          - *(double *)(a1 + 136));
                if (*(double *)(a1 + 120) != 0.0)
                  *(_QWORD *)(a1 + 144 * v88 + 1424) = (unint64_t)(CFAbsoluteTimeGetCurrent()
                                                                          - *(double *)(a1 + 120));
              }
              sub_10004C800((_BYTE *)a1, v88);
            }
LABEL_344:
            v127 = *(double *)(a1 + 184);
            if (v127 != 0.0)
              *(double *)(a1 + 192) = v16 - v127;
            objc_msgSend(objc_msgSend(v99[5], "sharedInstance"), "setTdLogic_execState:forInterface:", v97 | ((unint64_t)(v135 != 0) << 8) | v102, v103, *(_QWORD *)(a1 + 40));
            if (*(_BYTE *)(a1 + 161))
              goto LABEL_13;
            if (v104)
            {
              v128 = objc_autoreleasePoolPush();
              v129 = (void *)qword_10026DD20;
              if (qword_10026DD20)
              {
LABEL_352:
                v147 = v128;
                objc_msgSend(v129, "WFLog:message:", 3, "%s: TrgDiscStatus %u [Rssi %d TxFrms %d TxFail %d TxRet %d fwFrms %d fwFail %d fwRtry %d RxFrms %d BcnSch %d BcnRx %d walkout %d possibleRoam %d Awd %d initPr %ld UnGw %f FgApp %ld SympScore %ld UsrInput %ld]", "__WiFiLQAMgrCheckTriggerDisconnect", v149, *(unsigned int *)&v166[36], *(unsigned int *)&v166[4], *(unsigned int *)v166, *(unsigned int *)&v166[8], *(unsigned int *)&v166[20], *(unsigned int *)&v166[16], *(unsigned int *)&v166[24], *(unsigned int *)&v166[12], *(unsigned int *)&v166[28], *(unsigned int *)&v166[32], HIBYTE(v167), v167,
                  0,
                  *(unsigned __int8 *)(a1 + 358),
                  *(_QWORD *)&v55,
                  sub_100048130(a1),
                  0,
                  *(unsigned __int8 *)(a1 + 1296));
                v128 = v147;
              }
            }
            else
            {
              if (byte_10026D5A8 != 1)
                goto LABEL_13;
              v128 = objc_autoreleasePoolPush();
              v129 = (void *)qword_10026DD20;
              if (qword_10026DD20)
                goto LABEL_352;
            }
            objc_autoreleasePoolPop(v128);
            goto LABEL_13;
          }
        }
        v96 = v87;
        v97 = v136;
        if (v132)
        {
          v150 = v87;
          v105 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
          if ((v136 & v14 & 1) != 0)
          {
            v106 = v139 ^ 1;
            if (v77)
              v106 = 1;
            v107 = v140;
            if (*(_DWORD *)(a1 + 2796) <= *(_DWORD *)(a1 + 656) && v106)
            {
              v108 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Not Triggering Roaming - userWalkout %d, possibleRoam %d\n", "__WiFiLQAMgrCheckTriggerDisconnect", HIBYTE(v167), v167);
              objc_autoreleasePoolPop(v108);
              v100 = v150 | 0xC0000u;
              goto LABEL_312;
            }
          }
          else
          {
            v107 = v140;
            v106 = v139 ^ 1;
            if (v77)
              v106 = 1;
          }
          if (v107)
            v109 = v106;
          else
            v109 = 0;
          if (v109 == 1)
          {
            v110 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Use Reduced Roam time for fast disconnect - userWalkout %d, possibleRoam %d\n", "__WiFiLQAMgrCheckTriggerDisconnect", HIBYTE(v167), v167);
            objc_autoreleasePoolPop(v110);
          }
          if (*(_BYTE *)(a1 + 177))
          {
            if (_os_feature_enabled_impl("WiFiManager", "LinkRecommendationTD"))
              v111 = (*(unsigned __int8 *)(a1 + 2948) >> 1) & 1;
            else
              LOBYTE(v111) = 0;
            if (*(int *)&v166[4] >= 5)
            {
              if ((float)(v34 * (float)*(int *)&v166[4]) <= (float)*(int *)v166)
                LOBYTE(v111) = 1;
              if ((v111 & 1) == 0)
              {
                sub_100066F20(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(const void **)(a1 + 48), *(_DWORD *)(a1 + 224), 0, 1, 0);
                *(_BYTE *)(a1 + 177) = 0;
                v121 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Improved PER, TxFrms %d TxFail %d", "__WiFiLQAMgrCheckTriggerDisconnect", *(unsigned int *)&v166[4], *(unsigned int *)v166);
                objc_autoreleasePoolPop(v121);
                v102 = 0;
                v104 = 0;
                v14 = 0;
                v149 = v150 | 0x60000u;
                v103 = 0x10000;
                v99 = WiFiSoftError_ptr;
                goto LABEL_335;
              }
            }
          }
          if ((_DWORD)v14 && !*(_BYTE *)(a1 + 177))
          {
            *(double *)(a1 + 184) = v16;
            *(_QWORD *)(a1 + 192) = 0;
            sub_100066F20(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(const void **)(a1 + 48), *(_DWORD *)(a1 + 224), 1, 0, 0);
            v99 = WiFiSoftError_ptr;
            if (sub_100077880(*(_QWORD *)(a1 + 32)) && v105)
            {
              v119 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Attempting host triggered roam based on TdCheck", "__WiFiLQAMgrCheckTriggerDisconnect");
              objc_autoreleasePoolPop(v119);
              objc_msgSend(v105, "setLastRoamStatusFailedNoCandidateTs:", 0.0);
              objc_msgSend(+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager"), "roamWithReason:bandPreference:", 6, 0);
            }
            *(_BYTE *)(a1 + 177) = 1;
            v120 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Overriding TriggerDisconnect decision for Roam", "__WiFiLQAMgrCheckTriggerDisconnect");
            objc_autoreleasePoolPop(v120);
            v102 = 0;
            v14 = 0;
            v149 = v150 | 0x50000u;
LABEL_299:
            v104 = 1;
            v103 = (uint64_t)&_mh_execute_header;
            goto LABEL_335;
          }
          v96 = v150 | 0x40000u;
          v113 = *(double *)(a1 + 184);
          if (v113 == 0.0)
            v114 = 0.0;
          else
            v114 = v16 - v113;
          if (!v105
            || ((objc_msgSend(v105, "lastRoamStatusFailedNoCandidateTs"), v115 == 0.0)
              ? (v116 = 0.0)
              : (v116 = v16 - v115),
                v114 == 0.0 || v116 == 0.0))
          {
            if (!(_DWORD)v14)
              goto LABEL_227;
          }
          else
          {
            if (v114 > v116)
            {
              if ((v92 & 1) != 0)
              {
                objc_msgSend(v105, "lastRoamStatusFailedNoCandidateTs");
                v98 = v88;
                *(_QWORD *)(a1 + 144 * v88 + 1440) = (unint64_t)(v16 - v117);
                *(_DWORD *)(a1 + 2808) = v96;
                goto LABEL_229;
              }
              *(_DWORD *)(a1 + 2808) = v96;
              goto LABEL_311;
            }
            v122 = v16 - *(double *)(a1 + 184);
            if (v122 > 10.0)
              goto LABEL_227;
            v123 = v122 > 5.0 ? v109 : 0;
            if (((v123 | v14 ^ 1) & 1) != 0)
              goto LABEL_227;
          }
          if (*(_BYTE *)(a1 + 177) && v114 <= 10.0)
          {
            v118 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not Roamed for %2.2f secs", "__WiFiLQAMgrCheckTriggerDisconnect", *(_QWORD *)&v114);
            objc_autoreleasePoolPop(v118);
            v149 = v150 | 0x140000u;
            v99 = WiFiSoftError_ptr;
            if (!v92)
            {
              v14 = 0;
              v102 = 0;
              v103 = (uint64_t)&_mh_execute_header;
              v104 = 1;
              goto LABEL_344;
            }
            v102 = 0;
            v14 = 0;
            *(_QWORD *)(a1 + 144 * v88 + 1440) = 10;
            goto LABEL_299;
          }
        }
LABEL_227:
        *(_DWORD *)(a1 + 2808) = v96;
        if (v92)
        {
          v98 = v88;
LABEL_229:
          v99 = WiFiSoftError_ptr;
          *(_DWORD *)(a1 + 144 * v98 + 1392) = v96;
          v100 = v96;
          goto LABEL_313;
        }
LABEL_311:
        v100 = v96;
LABEL_312:
        v99 = WiFiSoftError_ptr;
LABEL_313:
        v149 = v100;
        if (!(_DWORD)v14)
        {
          v102 = 0;
          v103 = 0;
          v104 = 0;
          goto LABEL_335;
        }
        if (!*(_BYTE *)(a1 + 2832))
        {
          if (&_managed_event_fetch)
          {
            *(_DWORD *)(a1 + 492) = 0;
            if (sub_10004A888((CFTypeRef)a1, 1, 0))
            {
              v102 = 0;
              v103 = 0;
              v104 = 0;
              v14 = 0;
              *(_BYTE *)(a1 + 161) = 1;
              goto LABEL_335;
            }
          }
        }
        if (!sub_100048130(a1))
        {
          *(_BYTE *)(a1 + 161) = 0;
          v124 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s Foreground Networking App not present. Cache TrgDisc decision", "__WiFiLQAMgrCheckTriggerDisconnect");
          objc_autoreleasePoolPop(v124);
          v103 = 0;
          v14 = 0;
          v104 = 1;
          *(_BYTE *)(a1 + 2793) = 1;
          v102 = 0x100000000000000;
          goto LABEL_335;
        }
        if (*(_BYTE *)(a1 + 641))
        {
          v102 = 0;
          v103 = 0;
          v14 = 0;
          *(_BYTE *)(a1 + 161) = 0;
LABEL_322:
          v104 = 1;
          goto LABEL_335;
        }
        if (*(_BYTE *)(a1 + 644))
        {
          if (*(_BYTE *)(a1 + 1296))
          {
            v125 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s Suppress TrgDisc decision with User's previous input", "__WiFiLQAMgrCheckTriggerDisconnect");
            objc_autoreleasePoolPop(v125);
            v102 = 0;
            v14 = 0;
            *(_BYTE *)(a1 + 161) = 0;
            v103 = 1;
            goto LABEL_322;
          }
          if (*(_QWORD *)(a1 + 1288) || !sub_10004C520(a1))
          {
            v102 = 0;
            v104 = 0;
            v14 = 0;
            *(_BYTE *)(a1 + 161) = 1;
            v103 = 256;
            goto LABEL_335;
          }
        }
        v102 = 0;
        v103 = 0;
        v104 = 0;
        v14 = 1;
        goto LABEL_335;
      }
      v130 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Err total records %d", "__WiFiLQAMgrGetNextLQAMetricsRecordIdx", *v89);
    }
    objc_autoreleasePoolPop(v130);
    v92 = 0;
    v88 = 255;
    v75 = v140;
    v83 = v145;
    goto LABEL_225;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v59, CFSTR("RSSI"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v58 = valuePtr;
    goto LABEL_165;
  }
LABEL_12:
  v14 = 0;
LABEL_13:
  *(_DWORD *)(a1 + 488) = 0;
  return v14;
}

uint64_t sub_100045800(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  id v5;
  void *v6;
  double v7;
  void *v9;
  const __CFDictionary *v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  uint64_t v13;
  const __CFNumber *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  int Count;
  CFIndex v19;
  CFIndex v20;
  uint64_t v21;
  BOOL v22;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v24;
  double v25;
  CFAbsoluteTime Current;
  double v27;
  void *v28;
  void *v29;
  double valuePtr;
  uint64_t v31;
  uint64_t v32;

  v31 = 0;
  v32 = 0;
  valuePtr = 0.0;
  if (!a1 || !*(_BYTE *)(a1 + 645) || !*(_BYTE *)(a1 + 646))
    return 1;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kWiFiLqaMgrLqmSampleLocalTimestamp"));
  if (!Value)
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s LqmSampleLocalTimestamp numberRef is NULL!", "__WiFiLQAMgrCheckForPossibleRoam");
    goto LABEL_57;
  }
  CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
  if (valuePtr == 0.0)
  {
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s sampleTimestamp is NULL!", "__WiFiLQAMgrCheckForPossibleRoam");
LABEL_57:
    objc_autoreleasePoolPop(v29);
    return 1;
  }
  v5 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager", valuePtr);
  v6 = v5;
  if (!v5)
    goto LABEL_60;
  objc_msgSend(v5, "roamScanEndTimestamp");
  if (v7 == 0.0 || v7 < valuePtr)
    goto LABEL_60;
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Using roam state from WiFiRoamManager", "__WiFiLQAMgrCheckForPossibleRoam");
  objc_autoreleasePoolPop(v9);
  v10 = (const __CFDictionary *)objc_msgSend(v6, "roamState");
  if (!v10)
  {
LABEL_60:
    v10 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("ROAM_STATE"));
    if (!v10)
      return 1;
  }
  v11 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("ROAM_SCAN_COUNT"));
  if (!v11)
    return 1;
  CFNumberGetValue(v11, kCFNumberIntType, &v32);
  if (!(_DWORD)v32)
    return 1;
  v12 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("ROAM_SCAN_AGE"));
  if (!v12)
    return 1;
  CFNumberGetValue(v12, kCFNumberIntType, (char *)&v32 + 4);
  if ((_DWORD)v32 && SHIDWORD(v32) < 2000)
    return 0;
  if ((_DWORD)v32 && SHIDWORD(v32) > 10000)
    return 1;
  v15 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("RSSI"));
  if (!v15)
    return 1;
  CFNumberGetValue(v15, kCFNumberIntType, (char *)&v31 + 4);
  v16 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("ROAM_CACHE"));
  if (!v16 || (v17 = v16, Count = CFArrayGetCount(v16), Count < 1))
  {
LABEL_41:
    v13 = 0;
    if (!v6)
      return v13;
LABEL_42:
    if (!objc_msgSend(v6, "isLastRoamDueToBeaconLost"))
      return v13;
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: latest roam was due to beacon lost, skip waiting for roam for trigger disconnect", "__WiFiLQAMgrCheckForPossibleRoam");
    objc_autoreleasePoolPop(v28);
    return 0;
  }
  v19 = 0;
  v20 = Count;
  v21 = Count;
  v22 = 1;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v19);
    if (!ValueAtIndex)
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: roamCandidateDictRef is NULL!", "__WiFiLQAMgrCheckForPossibleRoam");
      goto LABEL_57;
    }
    v24 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RSSI"));
    if (!v24)
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: roamCandidateRssi is NULL!", "__WiFiLQAMgrCheckForPossibleRoam");
      goto LABEL_57;
    }
    CFNumberGetValue(v24, kCFNumberIntType, &v31);
    if ((int)v31 >= -89)
    {
      if ((int)v31 > -76)
        goto LABEL_47;
      if ((int)v31 - HIDWORD(v31) >= 5)
      {
        v25 = *(double *)(a1 + 184);
        if (v25 == 0.0)
        {
          v27 = 0.0;
        }
        else
        {
          Current = CFAbsoluteTimeGetCurrent();
          v25 = *(double *)(a1 + 184);
          v27 = Current - v25;
        }
        if (v25 == 0.0)
          goto LABEL_47;
        if (*(_BYTE *)(a1 + 177) && v27 < 5.0)
          break;
      }
    }
    v22 = ++v19 < v20;
    if (v21 == v19)
      goto LABEL_41;
  }
  if (!v22)
    goto LABEL_41;
LABEL_47:
  v13 = 1;
  if (v6)
    goto LABEL_42;
  return v13;
}

uint64_t sub_100045BC4(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t result;
  int Count;
  const __CFNumber *Value;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  CFIndex v19;
  double v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  double v29;
  BOOL v30;
  int v31;
  _BOOL4 v32;
  BOOL v33;
  _BOOL4 v34;
  _BOOL4 v35;
  void *v36;
  const char *v37;
  void *v38;
  BOOL v39;
  unsigned int v41;
  void *v42;
  void *v43;
  const char *v44;
  uint64_t v45;
  const char *v46;
  __CFDictionary *v47;
  unsigned int v49;
  uint64_t valuePtr;
  _QWORD v51[2];

  result = 0;
  valuePtr = 0;
  v51[0] = 0;
  v49 = 0;
  if (!a1 || !a2)
    return result;
  if (!*(_BYTE *)(a1 + 645) || !*(_BYTE *)(a1 + 646))
    return 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 256));
  if (Count <= 3)
  {
    v42 = objc_autoreleasePoolPush();
    v43 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v44 = "Insufficient samples for walk out detection";
      v45 = 2;
LABEL_93:
      objc_msgSend(v43, "WFLog:message:", v45, v44, v46);
      goto LABEL_94;
    }
    goto LABEL_94;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("RSSI"));
  if (!Value)
  {
    v42 = objc_autoreleasePoolPush();
    v43 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_94;
    v46 = "__WiFiLQAMgrDetectWalkOut";
    v44 = "%s: LQAManager: rssiNumRef from lqmDict is NULL!";
LABEL_92:
    v45 = 4;
    goto LABEL_93;
  }
  CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), Count - 1);
  if (!ValueAtIndex)
  {
    v42 = objc_autoreleasePoolPush();
    v43 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_94;
    v46 = "__WiFiLQAMgrDetectWalkOut";
    v44 = "%s: LQAManager: paramDict is NULL!";
    goto LABEL_92;
  }
  v9 = ValueAtIndex;
  v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RSSI"));
  if (!v10)
  {
    v42 = objc_autoreleasePoolPush();
    v43 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_94;
    v46 = "__WiFiLQAMgrDetectWalkOut";
    v44 = "%s: LQAManager: rssiNumRef is NULL!";
    goto LABEL_92;
  }
  CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr);
  v11 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("motion-state"));
  if (!v11)
  {
    v42 = objc_autoreleasePoolPush();
    v43 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v46 = "__WiFiLQAMgrDetectWalkOut";
      v44 = "%s: LQAManager: motionStateRef is NULL!";
      goto LABEL_92;
    }
LABEL_94:
    objc_autoreleasePoolPop(v42);
    return 0;
  }
  v47 = a2;
  CFNumberGetValue(v11, kCFNumberIntType, (char *)v51 + 4);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = (Count - 2);
  v20 = 0.0;
  do
  {
    v21 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), v19);
    if (!v21)
    {
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: paramDict is NULL!", "__WiFiLQAMgrDetectWalkOut");
      goto LABEL_63;
    }
    v22 = v21;
    v23 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("RSSI"));
    if (!v23)
    {
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: rssiNumRef is NULL!", "__WiFiLQAMgrDetectWalkOut");
      goto LABEL_63;
    }
    CFNumberGetValue(v23, kCFNumberSInt32Type, &v49);
    v24 = (const __CFNumber *)CFDictionaryGetValue(v22, CFSTR("motion-state"));
    if (!v24)
    {
      v38 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: motionStateRef is NULL!", "__WiFiLQAMgrDetectWalkOut");
      goto LABEL_63;
    }
    CFNumberGetValue(v24, kCFNumberIntType, v51);
    v25 = v51[0];
    v26 = v49;
    if (v51[0] == 0x200000002)
    {
      if ((int)v49 <= (int)valuePtr)
      {
        v16 = 0;
        v13 = 0;
        v12 = 0;
        v17 = (v17 + 1);
        if ((_DWORD)v15)
          v15 = v15;
        else
          v15 = valuePtr;
        v14 = v49;
      }
      else if ((int)(v49 - valuePtr) >= 2)
      {
        v17 = 0;
        v15 = 0;
        v14 = 0;
        v27 = 0;
        v16 = (v16 + 1);
        if ((_DWORD)v12)
          v12 = v12;
        else
          v12 = valuePtr;
        v13 = v49;
        goto LABEL_31;
      }
      v27 = v15 - v14;
      if ((int)v17 > 2 && v27 > 11)
      {
        v28 = 1;
        v29 = 0.9;
        goto LABEL_43;
      }
      if ((int)v17 >= 3 && v27 > 7)
      {
        v29 = 0.75;
        v28 = 1;
        goto LABEL_43;
      }
LABEL_31:
      v30 = (_DWORD)v17 == 3 && (int)v15 < -80;
      v31 = v30;
      v32 = v27 > 4;
      v33 = (v31 & v32) == 0;
      if ((v31 & v32) != 0)
        v28 = 1;
      else
        v28 = v18;
      if (v33)
        v29 = v20;
      else
        v29 = 0.5;
LABEL_43:
      v34 = (int)v16 > 2;
      v35 = (int)v13 - (int)v12 > 5;
      if (v34 && v35)
        v18 = 0;
      else
        v18 = v28;
      if (v34 && v35)
        v20 = 0.0;
      else
        v20 = v29;
      v25 = 2;
      if ((_DWORD)a3 && SHIDWORD(valuePtr) <= -70)
      {
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v37 = "YES";
          if (!v18)
            v37 = "NO";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Walkout(%d %d): %s (%f) +veSlope{ %d %d %d } -veSlope { %d %d %d }", a3, valuePtr, v37, *(_QWORD *)&v20, v16, v13, v12, v17, v15, v14);
        }
        objc_autoreleasePoolPop(v36);
        v26 = v49;
        v25 = v51[0];
      }
    }
    LODWORD(valuePtr) = v26;
    HIDWORD(v51[0]) = v25;
    v30 = v19-- <= 0;
  }
  while (!v30);
  if ((_DWORD)a3 && v18 && SHIDWORD(valuePtr) <= -70)
  {
    v18 = 1;
    sub_10002B5C8(v47, CFSTR("userCoverageWalkout"), 1);
    sub_100064840(v47, CFSTR("userCoverageWalkoutConfidenceScore"), v20);
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "User Walkout detected with score %f", *(_QWORD *)&v20);
      v18 = 1;
    }
LABEL_63:
    objc_autoreleasePoolPop(v38);
  }
  if ((_DWORD)a3)
    v39 = v18 == 0;
  else
    v39 = 1;
  v41 = !v39 && (int)v14 < -70;
  if (v20 >= 0.5)
    return v41;
  else
    return 0;
}

BOOL sub_100046118(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  const __CFDictionary *ValueAtIndex;
  double AbsoluteTime;
  double Current;
  unsigned __int8 v9;
  int v10;
  CFIndex v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  int ValueIfPresent;
  void *v15;
  BOOL v16;
  void *v17;
  void *v20;
  void *value;
  int v22;
  uint64_t valuePtr;
  CFDictionaryRef theDict;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef number;

  v26 = 0;
  number = 0;
  theDict = 0;
  v25 = 0;
  valuePtr = 0;
  v22 = 0;
  value = 0;
  if (a1)
  {
    v2 = *(const __CFArray **)(a1 + 24);
    if (v2)
    {
      Count = CFArrayGetCount(v2);
      if (Count >= 3)
      {
        v4 = Count;
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), Count - 1);
        if (ValueAtIndex)
        {
          if (CFDictionaryGetValueIfPresent(ValueAtIndex, CFSTR("LQMTIMESTAMP"), (const void **)&value) && value != 0)
          {
            AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)value);
            Current = CFAbsoluteTimeGetCurrent();
            if (Current - AbsoluteTime >= *(double *)(a1 + 672))
            {
              v11 = 0;
              v10 = 0;
              v9 = 0;
              while (1)
              {
                v12 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v11);
                if (v12)
                {
                  v13 = v12;
                  ValueIfPresent = CFDictionaryGetValueIfPresent(v12, CFSTR("LQMTIMESTAMP"), (const void **)&value);
                  v15 = value;
                  if (ValueIfPresent)
                    v16 = value == 0;
                  else
                    v16 = 1;
                  if (!v16)
                  {
                    AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)value);
                    v15 = value;
                  }
                  if (v15)
                  {
                    if (Current - AbsoluteTime <= *(double *)(a1 + 672))
                    {
                      if (CFDictionaryGetValueIfPresent(v13, CFSTR("CCA_STATS"), (const void **)&theDict) && theDict)
                      {
                        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_SELF_WAKE"), (const void **)&number)
                          && number)
                        {
                          CFNumberGetValue(number, kCFNumberIntType, (char *)&valuePtr + 4);
                        }
                        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_OTHER_WAKE"), (const void **)&v25) && v25)
                          CFNumberGetValue(v25, kCFNumberIntType, &valuePtr);
                        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_INTERFERENCE_WAKE"), (const void **)&v26)
                          && v26)
                        {
                          CFNumberGetValue(v26, kCFNumberIntType, &v22);
                        }
                        if ((v22 + valuePtr) > 0x50)
                          ++v9;
                      }
                      if (v11 + 1 != v9)
                        goto LABEL_11;
                      v10 = 1;
                    }
                  }
                  else
                  {
                    v17 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No Timestamp in LQM Record", "__WiFiLQAMgrCheckCcaWiFiAssist");
                    objc_autoreleasePoolPop(v17);
                  }
                }
                if (v4 == ++v11)
                  return v10 && v9 > 2u;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "__WiFiLQAMgrCheckCcaWiFiAssist");
    objc_autoreleasePoolPop(v20);
  }
  v9 = 0;
LABEL_11:
  v10 = 0;
  return v10 && v9 > 2u;
}

unint64_t sub_1000463C0(uint64_t a1)
{
  const __CFString *v1;
  unint64_t result;
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned int v5;
  void *v6;
  char buffer[24];

  memset(buffer, 170, 19);
  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: curNetwork is NULL", "__WiFiLQAMgrGetCurBssid");
    goto LABEL_12;
  }
  v1 = (const __CFString *)sub_10002BE64(a1, CFSTR("BSSID"));
  if (!v1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: curNetwork BSSID is NULL", "__WiFiLQAMgrGetCurBssid");
    goto LABEL_12;
  }
  if (!CFStringGetCString(v1, buffer, 19, 0))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CString conversion failure", "__WiFiLQAMgrGetCurBssid");
LABEL_12:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  result = (unint64_t)ether_aton(buffer);
  if (result)
  {
    v3 = (unsigned __int8 *)result;
    v4 = 0;
    result = 0;
    do
    {
      v5 = *v3++;
      result |= (unint64_t)v5 << v4;
      v4 += 8;
    }
    while (v4 != 48);
  }
  return result;
}

void sub_100046514(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  void *v5;
  _QWORD block[6];

  if (a1)
  {
    if (cf)
    {
      CFRetain(cf);
      v4 = *(NSObject **)(a1 + 296);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004783C;
      block[3] = &unk_10022EF88;
      block[4] = a1;
      block[5] = cf;
      dispatch_async(v4, block);
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "WiFiLQAMgrIgnoreDiagnosticProbe");
    objc_autoreleasePoolPop(v5);
  }
}

uint64_t sub_1000465D0(uint64_t a1)
{
  uint64_t v2;
  _BOOL4 v3;
  unsigned int v4;
  BOOL v5;
  int v6;

  if (!a1)
    return 1;
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
    v3 = sub_10003153C(v2) != 1;
  else
    v3 = 1;
  if (!*(_BYTE *)(a1 + 645) || !*(_BYTE *)(a1 + 646))
    return (*(_DWORD *)(a1 + 224) - 3) < 4;
  v4 = *(_DWORD *)(a1 + 224);
  if (v4 != 3)
    v3 = 0;
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x52;
  return !v5 && v6 != 0 || v3;
}

void sub_100046660(uint64_t a1, const void *a2, uint64_t a3, char a4)
{
  double Current;
  double v9;
  void *v10;
  void *v11;
  uint64_t v12;
  const __CFString *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  const __CFString *v17;
  WiFiUsageMonitor *v18;
  double v19;
  NSObject *v20;
  const void *v21;
  const void *v22;
  double v23;
  void *v24;
  void *v25;
  uint64_t v26;
  const __CFString *v27;
  void *v28;
  WiFiUsageMonitor *v29;
  double v30;
  void *v31;
  const void *v32;
  double v33;
  uint64_t v34;
  unint64_t v35;
  void *v36;

  Current = CFAbsoluteTimeGetCurrent();
  if (a1)
  {
    v9 = Current;
    if ((_DWORD)a3 != 2)
    {
      if ((_DWORD)a3 == 1)
      {
        if (*(_BYTE *)(a1 + 1304))
        {
          sub_100059250((_BYTE *)(a1 + 1304));
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: submittotalRecords %d", "WiFiLQAMgrLinkStateNotify", *(unsigned __int8 *)(a1 + 1304));
          objc_autoreleasePoolPop(v10);
        }
        *(_BYTE *)(a1 + 1304) = 0;
        *(_BYTE *)(a1 + 2752) = 0;
        *(_BYTE *)(a1 + 161) = 0;
        *(_BYTE *)(a1 + 200) = 0;
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 24));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 256));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 264));
        *(_DWORD *)(a1 + 2796) = 0;
        *(_BYTE *)(a1 + 288) = 0;
        *(_DWORD *)(a1 + 20) = 0;
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v12 = *(int *)(a1 + 20);
          if (v12 > 4)
            v13 = CFSTR("Bogus");
          else
            v13 = *(&off_10022F1A0 + v12);
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v13);
        }
        objc_autoreleasePoolPop(v11);
        if (*(double *)(a1 + 136) != 0.0)
        {
          v18 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
          if (*(double *)(a1 + 136) == 0.0)
            v19 = 0.0;
          else
            v19 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
          -[WiFiUsageMonitor setTdLogic_end:evalTime:rssi:roamTime:forInterface:](v18, "setTdLogic_end:evalTime:rssi:roamTime:forInterface:", 13, *(int *)(a1 + 2796), *(_QWORD *)(a1 + 40), v19, *(double *)(a1 + 192));
        }
        *(_BYTE *)(a1 + 392) = 0;
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 336), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        v20 = *(NSObject **)(a1 + 2904);
        if (v20)
          dispatch_source_set_timer(v20, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(_BYTE *)(a1 + 2912) = 0;
        *(_BYTE *)(a1 + 356) = 0;
        sub_100046514(a1, *(CFTypeRef *)(a1 + 376));
        v21 = *(const void **)(a1 + 376);
        if (v21)
        {
          CFRelease(v21);
          *(_QWORD *)(a1 + 376) = 0;
        }
        *(_WORD *)(a1 + 357) = 0;
        sub_100046514(a1, *(CFTypeRef *)(a1 + 384));
        v22 = *(const void **)(a1 + 384);
        if (v22)
        {
          CFRelease(v22);
          *(_QWORD *)(a1 + 384) = 0;
        }
        *(_QWORD *)(a1 + 360) = 0;
        *(_DWORD *)(a1 + 2760) = 0;
        sub_100043AE8(a1, 0);
        *(_BYTE *)(a1 + 1296) = 0;
        *(_WORD *)(a1 + 176) = 1;
        v23 = *(double *)(a1 + 184);
        if (v23 != 0.0)
          *(double *)(a1 + 192) = v9 - v23;
        *(_QWORD *)(a1 + 184) = 0;
        dispatch_async_f(*(dispatch_queue_t *)(a1 + 2920), (void *)a1, (dispatch_function_t)sub_100042388);
        *(_OWORD *)(a1 + 2944) = 0u;
        goto LABEL_72;
      }
      if ((_DWORD)a3)
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unknown Link State Notification %d", "WiFiLQAMgrLinkStateNotify", a3);
        objc_autoreleasePoolPop(v14);
        goto LABEL_72;
      }
    }
    if (a2)
    {
      if ((_DWORD)a3)
      {
        if (*(_DWORD *)(a1 + 20))
        {
LABEL_42:
          if ((_DWORD)a3 == 2 && *(_BYTE *)(a1 + 1304))
          {
            sub_100059250((_BYTE *)(a1 + 1304));
            v24 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: submittotalRecords %d", "WiFiLQAMgrLinkStateNotify", *(unsigned __int8 *)(a1 + 1304));
            objc_autoreleasePoolPop(v24);
          }
          goto LABEL_47;
        }
      }
      else if (!*(_DWORD *)(a1 + 20))
      {
LABEL_47:
        *(_BYTE *)(a1 + 1304) = 0;
        *(_BYTE *)(a1 + 2752) = 0;
        *(_BYTE *)(a1 + 161) = 0;
        *(_BYTE *)(a1 + 200) = 0;
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 24));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 256));
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 264));
        *(_BYTE *)(a1 + 248) = a4;
        sub_100043AE8(a1, a2);
        *(_BYTE *)(a1 + 288) = 0;
        *(_DWORD *)(a1 + 20) = 1;
        v25 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          v26 = *(int *)(a1 + 20);
          if (v26 > 4)
            v27 = CFSTR("Bogus");
          else
            v27 = *(&off_10022F1A0 + v26);
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v27);
        }
        objc_autoreleasePoolPop(v25);
        if ((_DWORD)a3)
        {
          v28 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Roam: ending Evaluation", "WiFiLQAMgrLinkStateNotify");
          objc_autoreleasePoolPop(v28);
          if (*(double *)(a1 + 136) != 0.0)
          {
            v29 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
            if (*(double *)(a1 + 136) == 0.0)
              v30 = 0.0;
            else
              v30 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
            -[WiFiUsageMonitor setTdLogic_end:evalTime:rssi:roamTime:forInterface:](v29, "setTdLogic_end:evalTime:rssi:roamTime:forInterface:", 14, *(int *)(a1 + 2796), *(_QWORD *)(a1 + 40), v30, *(double *)(a1 + 192));
          }
        }
        else
        {
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LinkUp: ending Evaluation", "WiFiLQAMgrLinkStateNotify");
          objc_autoreleasePoolPop(v31);
        }
        *(_BYTE *)(a1 + 392) = 0;
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 336), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
        *(_BYTE *)(a1 + 356) = 0;
        sub_100046514(a1, *(CFTypeRef *)(a1 + 376));
        v32 = *(const void **)(a1 + 376);
        if (v32)
        {
          CFRelease(v32);
          *(_QWORD *)(a1 + 376) = 0;
        }
        *(_QWORD *)(a1 + 360) = 0;
        *(_BYTE *)(a1 + 1296) = 0;
        if (!(_DWORD)a3)
          *(CFAbsoluteTime *)(a1 + 64) = CFAbsoluteTimeGetCurrent();
        *(_WORD *)(a1 + 176) = 1;
        v33 = *(double *)(a1 + 184);
        if (v33 != 0.0)
          *(double *)(a1 + 192) = v9 - v33;
        *(_QWORD *)(a1 + 184) = 0;
        if (&_symptom_create)
        {
          if ((*(_DWORD *)(a1 + 16) - 1) <= 1)
          {
            v34 = symptom_create("com.apple.wifimanager.link-quality");
            symptom_set_qualifier(v34, 0, 0);
            v35 = sub_1000463C0(*(_QWORD *)(a1 + 48));
            symptom_set_qualifier(v34, v35, 1);
            symptom_send(v34);
          }
        }
LABEL_72:
        *(_QWORD *)(a1 + 2816) = 0;
        *(_BYTE *)(a1 + 2824) = 0;
        return;
      }
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v16 = *(int *)(a1 + 20);
        if (v16 > 4)
          v17 = CFSTR("Bogus");
        else
          v17 = *(&off_10022F1A0 + v16);
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unexpected Event %d currState %@", "WiFiLQAMgrLinkStateNotify", a3, v17);
      }
      objc_autoreleasePoolPop(v15);
      goto LABEL_42;
    }
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: curNetwork is NULL in Event %d", "WiFiLQAMgrLinkStateNotify", a3);
    objc_autoreleasePoolPop(v36);
  }
}

void sub_100046CB0(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 2904);
  if (v2)
    dispatch_source_set_timer(v2, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  *(_BYTE *)(a1 + 2912) = 0;
}

uint64_t sub_100046CE8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 2944);
}

__n128 sub_100046CF0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a1 + 2988);
  v3 = *(_OWORD *)(a1 + 3004);
  *(_OWORD *)(a2 + 28) = *(_OWORD *)(a1 + 3016);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_100046D08(uint64_t result, CFDictionaryRef theDict)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  __int16 valuePtr;
  void *value;

  value = 0;
  valuePtr = 0;
  v8 = 0;
  v7 = 0;
  if (result && theDict)
  {
    v3 = result;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_NUM_LINKS"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, (char *)&valuePtr + 1);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_TRAF_SWITCH_ENABLED"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, &valuePtr);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_ADD_CNT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v8);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_DELETE_CNT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, (char *)&v7 + 4);
    result = CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_PREF_BAND_CHANGE_CNT"), (const void **)&value);
    v4 = 0;
    if ((_DWORD)result)
    {
      result = (uint64_t)value;
      if (value)
      {
        result = CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v7);
        v4 = v7;
      }
    }
    v5 = HIBYTE(valuePtr);
    *(_BYTE *)(v3 + 3032) = HIBYTE(valuePtr);
    v6 = valuePtr;
    *(_BYTE *)(v3 + 3033) = valuePtr;
    *(_DWORD *)(v3 + 3040) = v8;
    *(_DWORD *)(v3 + 3036) = HIDWORD(v7);
    *(_DWORD *)(v3 + 3044) = v4;
    *(_QWORD *)(v3 + 3168) = v5;
    *(_WORD *)(v3 + 3176) = 771;
    *(_BYTE *)(v3 + 3178) = 3;
    *(_DWORD *)(v3 + 3188) = 3;
    *(_BYTE *)(v3 + 3192) = v6 != 0;
  }
  return result;
}

uint64_t sub_100046E74(uint64_t result, CFDictionaryRef theDict, unsigned int a3)
{
  uint64_t v5;
  CFIndex v6;
  void *ValueAtIndex;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __int16 v21;
  char valuePtr;
  CFStringRef theString;
  CFArrayRef theArray;
  void *value;
  char buffer[24];

  theArray = 0;
  value = 0;
  theString = 0;
  valuePtr = 0;
  v20 = 0;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  memset(buffer, 170, 19);
  if (result && theDict)
  {
    v5 = result;
    v21 = -21846;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_IS_PREF_LINK"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, &valuePtr);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_PRI_CHANNEL"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt16Type, (char *)&v16 + 2);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_FREQ_BAND"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt16Type, &v16);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_BW"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt16Type, &v15);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_TX_CNT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, (char *)&v19 + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_RX_CNT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, (char *)&v18 + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_TX_RATE"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, (char *)&v17 + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_RX_RATE"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v17);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_TX_FAIL"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v19);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_TX_EX_RETRY"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v18);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("MLO_LINK_IDLE_TIME"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v20);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("PER_CORE_RSSI"), (const void **)&theArray)
      && theArray
      && CFArrayGetCount(theArray) >= 1)
    {
      v6 = 0;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, v6);
        value = ValueAtIndex;
        if (ValueAtIndex)
          CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberSInt8Type, (char *)&v21 + v6);
        ++v6;
      }
      while (CFArrayGetCount(theArray) > v6);
    }
    result = CFDictionaryGetValueIfPresent(theDict, CFSTR("BSSID"), (const void **)&theString);
    if ((_DWORD)result)
    {
      result = (uint64_t)theString;
      if (theString)
      {
        CFStringGetCString(theString, buffer, 19, 0);
        result = (uint64_t)ether_aton(buffer);
        if (result)
        {
          v8 = *(_DWORD *)result;
          v9 = v5 + 40 * a3 + 3048;
          *(_WORD *)(v9 + 7) = *(_WORD *)(result + 4);
          *(_DWORD *)(v9 + 3) = v8;
        }
      }
    }
    v10 = v5 + 40 * a3;
    *(_BYTE *)(v10 + 3048) = valuePtr;
    v11 = v16;
    *(_WORD *)(v10 + 3049) = *(_WORD *)(v10 + 3049) & 0x700 | BYTE2(v16) | ((_WORD)v16 << 14) | ((v15 & 7) << 11);
    *(_DWORD *)(v10 + 3060) = v20;
    *(_DWORD *)(v10 + 3084) = v17;
    *(_DWORD *)(v10 + 3080) = HIDWORD(v17);
    *(_DWORD *)(v10 + 3072) = HIDWORD(v18);
    *(_DWORD *)(v10 + 3064) = HIDWORD(v19);
    *(_DWORD *)(v10 + 3068) = v19;
    *(_DWORD *)(v10 + 3076) = v18;
    *(_WORD *)(v10 + 3057) = v21;
    if ((v11 & 3) << 14)
    {
      v13 = v11 & 3;
      if (v13 == 1)
      {
        v14 = v5 + 4 * a3;
        v12 = 2;
      }
      else
      {
        if (v13 != 3)
          return result;
        v14 = v5 + 4 * a3;
        v12 = 1;
      }
      *(_DWORD *)(v14 + 3176) = v12;
    }
    else
    {
      v12 = 0;
      *(_DWORD *)(v5 + 4 * a3 + 3176) = 0;
    }
    if (*(_BYTE *)(v10 + 3048))
      *(_DWORD *)(v5 + 3188) = v12;
  }
  return result;
}

void sub_100047288(uint64_t a1, CFDictionaryRef theDict)
{
  CFIndex v4;
  void *ValueAtIndex;
  CFIndex v6;
  void *v7;
  CFIndex v8;
  void *v9;
  void *v10;
  void *v11;
  unint64_t v12;
  __int16 v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  __int16 v17;
  __int16 v18;
  unsigned int valuePtr;
  void *v20;
  void *value;
  unint64_t v22;
  unint64_t v23;

  v20 = 0;
  value = 0;
  valuePtr = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v22 = 0xAAAAAAAAAAAAAAAALL;
  v23 = 0xAAAAAAAAAAAAAAAALL;
  if (a1 && theDict)
  {
    v13 = -21846;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("LAST_OBSS_STATS_TIME"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("SHOULD_APPLY_OBSS_MIT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, (char *)&v18 + 1);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("IS_OBSS_MIT_APPLIED"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, &v18);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CURRENT_OP_BW"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, (char *)&v17 + 1);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("RECOMM_OBSS_MIT_BW"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, &v17);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_RX_PLCP_ERR"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v16);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_RX_BAD_FCS_ERR"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v15);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_RX_FRAMES"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (char *)&v14 + 4);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_RX_PER_PCT"), (const void **)&value) && value)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v14);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_PWREST_CORE0"), (const void **)&v20)
      && v20
      && CFArrayGetCount((CFArrayRef)v20) >= 1)
    {
      v4 = 0;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex((CFArrayRef)v20, v4);
        value = ValueAtIndex;
        if (ValueAtIndex)
          CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberSInt8Type, (char *)&v23 + v4);
        ++v4;
      }
      while (v4 < CFArrayGetCount((CFArrayRef)v20));
    }
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_PWREST_CORE1"), (const void **)&v20)
      && v20
      && CFArrayGetCount((CFArrayRef)v20) >= 1)
    {
      v6 = 0;
      do
      {
        v7 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v20, v6);
        value = v7;
        if (v7)
          CFNumberGetValue((CFNumberRef)v7, kCFNumberSInt8Type, (char *)&v22 + v6);
        ++v6;
      }
      while (v6 < CFArrayGetCount((CFArrayRef)v20));
    }
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("OBSS_MIT_SOI"), (const void **)&v20)
      && v20
      && CFArrayGetCount((CFArrayRef)v20) >= 1)
    {
      v8 = 0;
      do
      {
        v9 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v20, v8);
        value = v9;
        if (v9)
          CFNumberGetValue((CFNumberRef)v9, kCFNumberSInt8Type, (char *)&v13 + v8);
        ++v8;
      }
      while (v8 < CFArrayGetCount((CFArrayRef)v20));
      if (!(_BYTE)v13)
      {
        LOBYTE(v13) = *(_DWORD *)(a1 + 2800);
        HIBYTE(v13) = *(_DWORD *)(a1 + 2804);
      }
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s OBSS MIT -> time = %u sec, shouldApply = %u, IsApplied = %u, currBw = %u, mitBw = %u, plcp %u, fcs %u, rxframes %u rxPer %u%%\n", "WiFiLQAMgrObssMitInfoNotify", valuePtr, HIBYTE(v18), v18, HIBYTE(v17), v17, v16, v15, HIDWORD(v14), v14);
    objc_autoreleasePoolPop(v10);
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s OBSS MIT -> soi (%d, %d), pwr0 (%d, %d, %d, %d, %d, %d, %d, %d)\n", "WiFiLQAMgrObssMitInfoNotify", (char)v13, SHIBYTE(v13), (char)v23, SBYTE1(v23), SBYTE2(v23), SBYTE3(v23), SBYTE4(v23), SBYTE5(v23), SBYTE6(v23), SHIBYTE(v23));
    objc_autoreleasePoolPop(v11);
    *(_BYTE *)(a1 + 2990) = HIBYTE(v17);
    *(_BYTE *)(a1 + 2989) = v18;
    *(_DWORD *)(a1 + 3008) = valuePtr;
    *(_BYTE *)(a1 + 2991) = v17;
    *(_DWORD *)(a1 + 2996) = v15;
    *(_DWORD *)(a1 + 3000) = HIDWORD(v14);
    *(_DWORD *)(a1 + 3004) = v14;
    *(_DWORD *)(a1 + 2992) = v16;
    *(_BYTE *)(a1 + 2988) = HIBYTE(v18);
    *(_WORD *)(a1 + 3028) = v13;
    v12 = v22;
    *(_QWORD *)(a1 + 3012) = v23;
    *(_QWORD *)(a1 + 3020) = v12;
  }
}

uint64_t sub_10004772C(_QWORD *a1, CFTypeRef cf)
{
  CFTypeRef v3;
  void *v4;
  NSObject *v6;
  _QWORD block[6];
  _QWORD v8[3];
  unint64_t v9;

  if (a1)
  {
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    v9 = 0xAAAAAAAAAAAAAAAALL;
    if (cf)
      v3 = CFRetain(cf);
    else
      v3 = 0;
    v9 = (unint64_t)v3;
    CFRetain(a1);
    v6 = a1[37];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004D4A4;
    block[3] = &unk_10022F160;
    block[4] = v8;
    block[5] = a1;
    dispatch_async(v6, block);
    _Block_object_dispose(v8, 8);
    return 0;
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrScheduleProbe");
    objc_autoreleasePoolPop(v4);
    return 4294963365;
  }
}

void sub_100047824(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_10004783C(uint64_t a1)
{
  const __CFArray *v2;
  int v3;
  __CFDictionary *v4;
  void *v5;
  CFRange v6;

  v2 = *(const __CFArray **)(*(_QWORD *)(a1 + 32) + 320);
  v6.length = CFArrayGetCount(v2);
  v6.location = 0;
  v3 = CFArrayContainsValue(v2, v6, *(const void **)(a1 + 40));
  v4 = *(__CFDictionary **)(a1 + 40);
  if (v3 || *(__CFDictionary **)(*(_QWORD *)(a1 + 32) + 312) == v4)
  {
    CFDictionarySetValue(v4, CFSTR("kWiFiLqaMgrIgnoreProbe"), kCFBooleanTrue);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid Handle", "WiFiLQAMgrIgnoreDiagnosticProbe_block_invoke");
    objc_autoreleasePoolPop(v5);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t sub_1000478FC(uint64_t a1)
{
  void *v2;

  if (a1)
    return (*(_DWORD *)(a1 + 652) + *(_DWORD *)(a1 + 664));
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "WiFiLQAMgrTrgDiscPnoRssiThres");
  objc_autoreleasePoolPop(v2);
  return 0;
}

uint64_t sub_100047970(_DWORD *a1, const void *a2, int a3, double a4)
{
  double v8;
  double v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  double v12;
  int v13;
  int v14;
  int v15;
  void *v16;
  void *v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  void *v26;
  const void *v27;
  uint64_t v28;

  -[NSDate timeIntervalSince1970](+[NSDate date](NSDate, "date"), "timeIntervalSince1970");
  if (!a1)
  {
    v22 = objc_autoreleasePoolPush();
    v23 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v24 = "%s: LQAMgr is NULL";
    goto LABEL_34;
  }
  if (!a2)
  {
    v22 = objc_autoreleasePoolPush();
    v23 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v24 = "%s: network is NULL";
    goto LABEL_34;
  }
  v9 = v8;
  v10 = sub_100017A54((uint64_t)a2, CFSTR("RSSI"));
  v11 = v10;
  if (!(_DWORD)v10)
  {
    v22 = objc_autoreleasePoolPush();
    v23 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v24 = "%s: rssi is 0";
LABEL_34:
    v25 = 4;
    goto LABEL_15;
  }
  v12 = v9 - a4;
  v13 = a1[166];
  v14 = v13 + a1[163];
  v15 = v13 + a3;
  if ((v13 + a3 <= (int)v10 || v14 <= (int)v10) && (v12 >= 60.0 || a1[694] == 1 || a1[162] + 5 <= (int)v10))
  {
    v22 = objc_autoreleasePoolPush();
    v26 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v27 = sub_10002B088(a2);
      if (v15 >= v14)
        v28 = v14;
      else
        v28 = v15;
      objc_msgSend(v26, "WFLog:message:", 4, "%s: Allowed TriggerDisconnected network %@ for auto-join, RSSI: %d, Thres: %d timeFromLastTD:%2.2f seconds", "WiFiLQAMgrAllowNetworkForAutoJoin", v27, v11, v28, *(_QWORD *)&v12);
    }
    v20 = 1;
    goto LABEL_26;
  }
  v16 = objc_autoreleasePoolPush();
  v17 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v18 = sub_10002B088(a2);
    if (v15 >= v14)
      v19 = v14;
    else
      v19 = v15;
    objc_msgSend(v17, "WFLog:message:", 4, "%s: Skipping TriggerDisconnected network %@ for auto-join, RSSI: %d, Thres: %d timeFromLastTD:%2.2f seconds", "WiFiLQAMgrAllowNetworkForAutoJoin", v18, v11, v19, *(_QWORD *)&v12);
  }
  objc_autoreleasePoolPop(v16);
  v20 = 0;
  if ((int)v11 >= -89 && &_symptom_create)
  {
    v21 = symptom_create("com.apple.wifimanager.auto-join-scan");
    symptom_send(v21);
    v22 = objc_autoreleasePoolPush();
    v23 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_16:
      v20 = 0;
LABEL_26:
      objc_autoreleasePoolPop(v22);
      return v20;
    }
    v24 = "%s: Notified Symptoms about found Trigger Disconnected network";
    v25 = 2;
LABEL_15:
    objc_msgSend(v23, "WFLog:message:", v25, v24, "WiFiLQAMgrAllowNetworkForAutoJoin");
    goto LABEL_16;
  }
  return v20;
}

uint64_t sub_100047BF0(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  const char *v3;

  if (a1)
    v1 = *(unsigned __int8 *)(a1 + 2900);
  else
    v1 = 0;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v3 = "TRUE";
    if (!(_DWORD)v1)
      v3 = "FALSE";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: criticalAppState:%s", "WiFiLQAMgrIsCriticalAppState", v3);
  }
  objc_autoreleasePoolPop(v2);
  return v1;
}

BOOL sub_100047C78(_BOOL8 result)
{
  unsigned int *v1;
  uint64_t state;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t state64;

  if (result)
  {
    v1 = (unsigned int *)result;
    state64 = 0;
    state = notify_get_state(*(_DWORD *)(result + 440), &state64);
    if ((_DWORD)state)
    {
      v3 = state;
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unable to get Symptoms Event ID Error %d", "__WiFiLQAMgrForceSymptomsScoreFetch", v3);
      objc_autoreleasePoolPop(v4);
    }
    else
    {
      v1[707] = 7;
      sub_10004A888(v1, 0, 1);
    }
    v5 = v1[126];
    v6 = v1[131];
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DNS Symptoms netscore:%d datastallscore:%d", "WiFiLQAMgrIsSymptomsScorePoor", v5, v6);
    objc_autoreleasePoolPop(v7);
    return (v5 < 0x1A || v6 <= 0x19) && v1[129] == v1[130];
  }
  return result;
}

void sub_100047D88(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: DNS Symptoms reseting scores", "WiFiLQAMgrResetDNSFailureSymptomsScores");
    objc_autoreleasePoolPop(v2);
    *(_DWORD *)(a1 + 504) = 50;
    *(_DWORD *)(a1 + 524) = 0xFFFF;
    sub_100047E10(a1);
    sub_100048084(a1, 0);
  }
}

void sub_100047E10(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  void *v12;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return;
  v3 = Mutable;
  v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 512));
  if (!v4)
  {
    v10 = v3;
LABEL_23:
    CFRelease(v10);
    return;
  }
  v5 = v4;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 516));
  if (!v6)
  {
    v7 = 0;
    goto LABEL_27;
  }
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 520));
  if (!v7)
  {
LABEL_27:
    v8 = 0;
    goto LABEL_28;
  }
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 492));
  if (!v8)
  {
LABEL_28:
    v9 = 0;
    goto LABEL_29;
  }
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 524));
  if (!v9)
  {
LABEL_29:
    v10 = 0;
    goto LABEL_30;
  }
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 500));
  if (!v10)
  {
LABEL_30:
    v11 = 0;
    goto LABEL_12;
  }
  v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 504));
  if (v11)
  {
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputARPFail"), v5);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputDNSServersTotal"), v6);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputDNSServersImpacted"), v7);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputUserImpactFlags"), v8);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputDataStallScore"), v9);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputAppPolicyScore"), v10);
    CFDictionarySetValue(v3, CFSTR("IO80211DPSSymptomsInputNetScore"), v11);
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "DNS Symptoms: updating APPLE80211_IOC_DPS_SYMPTOMS_INPUT");
    objc_autoreleasePoolPop(v12);
    sub_1000672C0(*(_QWORD *)(a1 + 32), *(const void **)(a1 + 40), 487, 0, (uint64_t)v3);
  }
LABEL_12:
  CFRelease(v3);
  CFRelease(v5);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
  if (v10)
    goto LABEL_23;
}

void sub_100048084(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "true";
      if (!a2)
        v5 = "false";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting dnsFailureHandled to %s", "WiFiLQAMgrSetDNSFailureTriggerStatus", v5);
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 539) = a2;
  }
}

uint64_t sub_100048110(uint64_t a1)
{
  if (a1)
    return *(int *)(a1 + 652);
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t sub_100048130(uint64_t a1)
{
  BOOL v1;
  uint64_t v3;
  void *v6;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrDoesForegroundAppUseWiFi");
    v3 = 0;
LABEL_17:
    objc_autoreleasePoolPop(v6);
    return v3;
  }
  if (!*(_BYTE *)(a1 + 2832))
  {
    v1 = (~*(_DWORD *)(a1 + 492) & 5) != 0 && (*(_DWORD *)(a1 + 492) & 0x20) == 0;
    if (v1 && (*(_DWORD *)(a1 + 492) & 0xB) != 9)
    {
      if (!-[WiFiUserInteractionMonitor isNetworkingAppInForeground](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isNetworkingAppInForeground"))return 0;
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user interaction monitor indicates FG networking app active", "__WiFiLQAMgrDoesForegroundAppUseWiFi");
      v3 = 1;
      goto LABEL_17;
    }
  }
  return 1;
}

BOOL sub_100048228(uint64_t a1)
{
  void *v2;

  if (a1)
    return sub_100048130(a1) != 0;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "WiFiLQAMgrForegroundAppUsesWiFi");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_10004829C(uint64_t a1)
{
  const __CFArray *v2;
  const void *v3;
  int v4;
  void *v5;
  CFDataRef v6;
  void *v7;
  void *v8;
  void *v9;
  UInt8 bytes[16];
  _DWORD v11[7];

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting");
    goto LABEL_24;
  }
  v2 = *(const __CFArray **)(a1 + 24);
  if (!v2)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: LQM table is NULL", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting");
    goto LABEL_24;
  }
  if (!CFArrayGetCount(v2))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager: LQM table is empty", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting");
LABEL_24:
    objc_autoreleasePoolPop(v9);
    return;
  }
  v3 = *(const void **)(a1 + 144);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 144) = 0;
  }
  *(_OWORD *)bytes = 0u;
  memset(v11, 0, sizeof(v11));
  v4 = sub_1000484B0(a1, bytes);
  v5 = objc_autoreleasePoolPush();
  if (!v4)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to extract metrics from Lqm, exiting!", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting");
    v8 = v5;
    goto LABEL_16;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: TxFail:%d TxFrames:%d TxReTrans:%d rxFrames:%d FwTxFail:%d FwTxFrames:%d FwTxReTrans:%d beaconSched:%d beaconRecv:%d rssi:%d ccaTotal:%d ccaSelf:%d ccaOther:%d ccaInterference:%d", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting", *(unsigned int *)bytes, *(unsigned int *)&bytes[4], *(unsigned int *)&bytes[8], *(unsigned int *)&bytes[12], v11[0], v11[1], v11[2], v11[3], v11[4], v11[5], SLOBYTE(v11[6]), SBYTE1(v11[6]), SBYTE2(v11[6]),
      SHIBYTE(v11[6]));
  objc_autoreleasePoolPop(v5);
  v6 = CFDataCreate(kCFAllocatorDefault, bytes, 44);
  *(_QWORD *)(a1 + 144) = v6;
  if (!v6)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to create CFData", "WiFiLQAMgrCaptureInstantaneousLQForMetricsReporting");
    v8 = v7;
LABEL_16:
    objc_autoreleasePoolPop(v8);
  }
}

uint64_t sub_1000484B0(uint64_t a1, _DWORD *a2)
{
  double Current;
  CFIndex Count;
  CFIndex v6;
  uint64_t v7;
  CFIndex v8;
  double AbsoluteTime;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  int ValueIfPresent;
  void *v13;
  BOOL v14;
  int v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  const void *ValueAtIndex;
  void *value;
  CFDictionaryRef theDict;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef number;
  CFNumberRef v36;
  CFNumberRef v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD valuePtr[2];

  v39 = 0;
  valuePtr[0] = 0;
  v38 = 0;
  v36 = 0;
  v37 = 0;
  v34 = 0;
  number = 0;
  v32 = 0;
  v33 = 0;
  v30 = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  value = 0;
  theDict = 0;
  if (!a1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "__WiFiLQAMgrExtractFromLqm");
    goto LABEL_73;
  }
  if (!a2)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metrics is NULL", "__WiFiLQAMgrExtractFromLqm");
LABEL_73:
    objc_autoreleasePoolPop(v19);
    return 0;
  }
  if (*(_QWORD *)(a1 + 24))
  {
    Current = CFAbsoluteTimeGetCurrent();
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    if (Count < 1)
    {
LABEL_71:
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAManager No LQMDicts", "__WiFiLQAMgrExtractFromLqm");
    }
    else
    {
      v6 = Count;
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
      v7 = 0;
      v8 = 0;
      AbsoluteTime = 0.0;
      do
      {
        v10 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v8);
        v11 = v10;
        if (v10)
        {
          ValueIfPresent = CFDictionaryGetValueIfPresent(v10, CFSTR("LQMTIMESTAMP"), (const void **)&value);
          v13 = value;
          if (ValueIfPresent)
            v14 = value == 0;
          else
            v14 = 1;
          if (!v14)
          {
            AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)value);
            v13 = value;
          }
          if (v13)
          {
            if (Current - AbsoluteTime <= *(double *)(a1 + 672))
            {
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXFAIL"), (const void **)&number) && number)
                CFNumberGetValue(number, kCFNumberIntType, (char *)valuePtr + 4);
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXFRAMES"), (const void **)&v33) && v33)
                CFNumberGetValue(v33, kCFNumberIntType, valuePtr);
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXRETRANS"), (const void **)&v34) && v34)
                CFNumberGetValue(v34, kCFNumberIntType, (char *)&v39 + 4);
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXFWFAIL"), (const void **)&v32) && v32)
              {
                CFNumberGetValue(v32, kCFNumberIntType, &v39);
                a2[4] += v39;
              }
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXFWFRAMES"), (const void **)&v30) && v30)
              {
                CFNumberGetValue(v30, kCFNumberIntType, (char *)&v38 + 4);
                a2[5] += HIDWORD(v38);
              }
              if (CFDictionaryGetValueIfPresent(v11, CFSTR("TXFWRETRANS"), (const void **)&v31) && v31)
              {
                CFNumberGetValue(v31, kCFNumberIntType, &v38);
                a2[6] += v38;
              }
              if (!number || !v34 || !v33)
              {
                v19 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: txFailRef / txReTransRef / txFramesRef NULL", "__WiFiLQAMgrExtractFromLqm");
                goto LABEL_73;
              }
              ++v7;
              v15 = a2[1] + LODWORD(valuePtr[0]);
              *a2 += HIDWORD(valuePtr[0]);
              a2[1] = v15;
              a2[2] += HIDWORD(v39);
            }
          }
          else
          {
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: No Timestamp in LQM Record", "__WiFiLQAMgrExtractFromLqm");
            objc_autoreleasePoolPop(v16);
          }
        }
        ++v8;
      }
      while (v6 != v8);
      if (!v7 || !ValueAtIndex)
        goto LABEL_71;
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 24)))
        v11 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
      if (v11)
      {
        if (CFDictionaryGetValueIfPresent(v11, CFSTR("RXBEACONFRMS"), (const void **)&v28) && v28)
          CFNumberGetValue(v28, kCFNumberIntType, a2 + 8);
        if (CFDictionaryGetValueIfPresent(v11, CFSTR("RXBEACONSCHED"), (const void **)&v29) && v29)
          CFNumberGetValue(v29, kCFNumberIntType, a2 + 7);
        if (CFDictionaryGetValueIfPresent(v11, CFSTR("RXFRAMES"), (const void **)&v36) && v36)
          CFNumberGetValue(v36, kCFNumberIntType, a2 + 3);
        if (CFDictionaryGetValueIfPresent(v11, CFSTR("RSSI"), (const void **)&v37) && v37)
          CFNumberGetValue(v37, kCFNumberIntType, a2 + 9);
        if (CFDictionaryGetValueIfPresent(v11, CFSTR("CCA"), (const void **)&v24) && v24)
          CFNumberGetValue(v24, kCFNumberSInt8Type, a2 + 10);
        v17 = CFDictionaryGetValueIfPresent(v11, CFSTR("CCA_STATS"), (const void **)&theDict);
        v18 = 1;
        if (v17 && theDict)
        {
          if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_SELF_TOTAL"), (const void **)&v27) && v27)
            CFNumberGetValue(v27, kCFNumberSInt8Type, (char *)a2 + 41);
          if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_OTHER_TOTAL"), (const void **)&v25) && v25)
            CFNumberGetValue(v25, kCFNumberSInt8Type, (char *)a2 + 42);
          v18 = 1;
          if (CFDictionaryGetValueIfPresent(theDict, CFSTR("CCA_INTERFERENCE_TOTAL"), (const void **)&v26) && v26)
          {
            v18 = 1;
            CFNumberGetValue(v26, kCFNumberSInt8Type, (char *)a2 + 43);
          }
        }
        return v18;
      }
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: lqmDict is NULL!", "__WiFiLQAMgrExtractFromLqm");
    }
    goto LABEL_73;
  }
  return 0;
}

void sub_100048A40(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 144);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 144) = 0;
  }
}

void sub_100048A6C(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, unint64_t *a6, unint64_t *a7, unint64_t *a8)
{
  const __CFData *v8;
  const UInt8 *BytePtr;
  void *v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  void *v27;

  if (!a1)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrGetInstantaneousLQForMetricsReporting");
    goto LABEL_34;
  }
  v8 = *(const __CFData **)(a1 + 144);
  if (!v8)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CFData not allocated", "WiFiLQAMgrGetInstantaneousLQForMetricsReporting");
LABEL_34:
    objc_autoreleasePoolPop(v27);
    return;
  }
  BytePtr = CFDataGetBytePtr(v8);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: TxFail:%d TxFrames:%d TxReTrans:%d rxFrames:%d FwTxFail:%d FwTxFrames:%d FwTxReTrans:%d beaconSched:%d beaconRecv:%d rssi:%d ccaTotal:%d ccaSelf:%d ccaOther:%d ccaInterference:%d", "WiFiLQAMgrGetInstantaneousLQForMetricsReporting", *(unsigned int *)BytePtr, *((unsigned int *)BytePtr + 1), *((unsigned int *)BytePtr + 2), *((unsigned int *)BytePtr + 3), *((unsigned int *)BytePtr + 4), *((unsigned int *)BytePtr + 5), *((unsigned int *)BytePtr + 6), *((unsigned int *)BytePtr + 7), *((unsigned int *)BytePtr + 8), *((unsigned int *)BytePtr + 9), *((char *)BytePtr + 40), *((char *)BytePtr + 41), *((char *)BytePtr + 42),
      *((char *)BytePtr + 43));
  objc_autoreleasePoolPop(v17);
  if (a2)
    *a2 = *((char *)BytePtr + 40);
  if (a3)
    *a3 = *((char *)BytePtr + 41);
  if (a4)
    *a4 = *((char *)BytePtr + 42);
  if (a5)
    *a5 = *((char *)BytePtr + 43);
  if (a6)
  {
    v18 = *((_DWORD *)BytePtr + 1);
    if (v18)
      v19 = (unint64_t)((double)*(int *)BytePtr / (double)v18 * 100.0);
    else
      v19 = 0;
    *a6 = v19;
  }
  if (a7)
  {
    v20 = *((_DWORD *)BytePtr + 7);
    if (!v20
      || (v21 = *((_DWORD *)BytePtr + 8), v22 = __OFSUB__(v20, v21), v23 = v20 - v21, (v23 < 0) ^ v22 | (v23 == 0)))
    {
      v24 = 0;
    }
    else
    {
      v24 = (unint64_t)((double)v23 / (double)v20 * 100.0);
    }
    *a7 = v24;
  }
  if (a8)
  {
    v25 = *((_DWORD *)BytePtr + 5);
    if (v25)
      v26 = (unint64_t)((double)*((int *)BytePtr + 4) / (double)v25 * 100.0);
    else
      v26 = 0;
    *a8 = v26;
  }
}

void sub_100048CC0(uint64_t a1, char a2)
{
  void *v2;

  if (a1)
  {
    *(_BYTE *)(a1 + 2834) = a2;
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFiLQAMgrRef is NULL", "WiFiLQAMgrAwdlRealTimeModeStatus");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_100048D30(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t result;
  float v5;
  Boolean v6;
  float v7;
  float v8;
  float v9;
  Boolean v10;
  float v11;
  float v12;
  void *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  Boolean v18;
  int v19;
  float v20;
  float v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFNumberRef number;
  CFNumberRef v50;
  int v51;
  void *v52;
  void *v53;
  void *v54;
  int valuePtr;
  void *value;
  void *v57;

  value = 0;
  v57 = 0;
  result = 4294963396;
  valuePtr = 0;
  if (!a1 || !theDict)
    return result;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscEnable"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 640) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMonitorOnlyMode"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 641) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscPoorRssiThres"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 652) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscRssiHysterisis"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 648) = valuePtr + *(_DWORD *)(a1 + 652);
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscAjoinRssiHysterisis"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 664) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscNumActiveProbes"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 892) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscActiveProbePer"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    v5 = (double)valuePtr * 0.01;
    *(float *)(a1 + 896) = v5;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscCcaSigEnable"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 928) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscCcaThres"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_BYTE *)(a1 + 929) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscRapidLqmEnable"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_BYTE *)(a1 + 108) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscGwArpSigEnable"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 904) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscActProbeSigEnable"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 888) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscSympSigEnable"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 920) = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscSympFailCreditThres"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 924) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMode"), (const void **)&v57) && v57)
  {
    CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    *(_DWORD *)(a1 + 16) = valuePtr;
  }
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscLoggingEnable"), (const void **)&value) && value)
    byte_10026D5A8 = CFEqual(value, kCFBooleanTrue) != 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTxPerSigEnable"), (const void **)&value) && value)
  {
    v6 = CFEqual(value, kCFBooleanTrue);
    v53 = 0;
    v54 = 0;
    v52 = 0;
    LODWORD(v50) = 0;
    LODWORD(number) = 0;
    v51 = 0;
    if (!CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTblIndex"), (const void **)&v54)
      || !CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTxPerThres"), (const void **)&v53)
      || !CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMinTxFrames"), (const void **)&v52)
      || !v54
      || !v53
      || !v52)
    {
      goto LABEL_162;
    }
    CFNumberGetValue((CFNumberRef)v54, kCFNumberIntType, &v50);
    CFNumberGetValue((CFNumberRef)v53, kCFNumberIntType, &number);
    CFNumberGetValue((CFNumberRef)v52, kCFNumberIntType, &v51);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscRetryFactor"), (const void **)&v57) && v57)
      CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
    if ((_DWORD)v50 == 2)
    {
      *(_BYTE *)(a1 + 1096) = v6;
      *(_DWORD *)(a1 + 1100) = v51;
      v8 = (double)(int)number * 0.01;
      *(float *)(a1 + 1104) = v8;
      if (v57)
        *(_DWORD *)(a1 + 1108) = valuePtr;
    }
    else if ((_DWORD)v50 == 1)
    {
      *(_BYTE *)(a1 + 932) = v6;
      *(_DWORD *)(a1 + 936) = v51;
      v9 = (double)(int)number * 0.01;
      *(float *)(a1 + 940) = v9;
      if (v57)
        *(_DWORD *)(a1 + 944) = valuePtr;
    }
    else
    {
      if ((_DWORD)v50)
        goto LABEL_92;
      *(_BYTE *)(a1 + 724) = v6;
      *(_DWORD *)(a1 + 728) = v51;
      v7 = (double)(int)number * 0.01;
      *(float *)(a1 + 732) = v7;
      if (v57)
        *(_DWORD *)(a1 + 736) = valuePtr;
    }
  }
  if (!CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscFwTxPerSigEnable"), (const void **)&value) || !value)
    goto LABEL_102;
  v10 = CFEqual(value, kCFBooleanTrue);
  v53 = 0;
  v54 = 0;
  v52 = 0;
  number = 0;
  v50 = 0;
  v51 = 0;
  v47 = 0;
  v48 = 0;
  if (!CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTblIndex"), (const void **)&v54)
    || !CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscFwTxPerThres"), (const void **)&v53)
    || !CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMinFwTxFrames"), (const void **)&v52)
    || !v54
    || !v53
    || !v52)
  {
LABEL_162:
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscTxPerThres - Missing Params\n", "WiFiLQAMgrSetTrgDiscParams", v46);
LABEL_164:
    objc_autoreleasePoolPop(v13);
    return 0;
  }
  CFNumberGetValue((CFNumberRef)v54, kCFNumberIntType, &v51);
  CFNumberGetValue((CFNumberRef)v53, kCFNumberIntType, (char *)&v48 + 4);
  CFNumberGetValue((CFNumberRef)v52, kCFNumberIntType, &v48);
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTxPerThres"), (const void **)&number) && number)
    CFNumberGetValue(number, kCFNumberIntType, (char *)&v47 + 4);
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMinTxFrames"), (const void **)&v50) && v50)
    CFNumberGetValue(v50, kCFNumberIntType, &v47);
  switch(v51)
  {
    case 2:
      *(_BYTE *)(a1 + 1160) = v10;
      *(_DWORD *)(a1 + 1164) = v48;
      v14 = (double)SHIDWORD(v48) * 0.01;
      *(float *)(a1 + 1168) = v14;
      if (number)
      {
        v15 = (double)SHIDWORD(v47) * 0.01;
        *(float *)(a1 + 1176) = v15;
      }
      if (v50)
        *(_DWORD *)(a1 + 1172) = v47;
      break;
    case 1:
      *(_BYTE *)(a1 + 996) = v10;
      *(_DWORD *)(a1 + 1000) = v48;
      v16 = (double)SHIDWORD(v48) * 0.01;
      *(float *)(a1 + 1004) = v16;
      if (number)
      {
        v17 = (double)SHIDWORD(v47) * 0.01;
        *(float *)(a1 + 1012) = v17;
      }
      if (v50)
        *(_DWORD *)(a1 + 1008) = v47;
      break;
    case 0:
      *(_BYTE *)(a1 + 788) = v10;
      *(_DWORD *)(a1 + 792) = v48;
      v11 = (double)SHIDWORD(v48) * 0.01;
      *(float *)(a1 + 796) = v11;
      if (number)
      {
        v12 = (double)SHIDWORD(v47) * 0.01;
        *(float *)(a1 + 804) = v12;
      }
      if (v50)
        *(_DWORD *)(a1 + 800) = v47;
      break;
    default:
LABEL_92:
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscTxPerThres - Invalid TblIndex <0, %d>\n", "WiFiLQAMgrSetTrgDiscParams", 3);
      goto LABEL_164;
  }
LABEL_102:
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscBcnPerSigEnable"), (const void **)&value))
  {
    if (value)
    {
      v18 = CFEqual(value, kCFBooleanTrue);
      v53 = 0;
      v54 = 0;
      LODWORD(v52) = 0;
      LODWORD(v50) = 0;
      if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscBcnPerThres"), (const void **)&v54))
      {
        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMinBcnSched"), (const void **)&v53))
        {
          if (v54 && v53)
          {
            CFNumberGetValue((CFNumberRef)v54, kCFNumberIntType, &v52);
            CFNumberGetValue((CFNumberRef)v53, kCFNumberIntType, &v50);
            *(_BYTE *)(a1 + 868) = v18;
            v19 = (int)v52;
            *(_DWORD *)(a1 + 872) = (_DWORD)v50;
            v20 = (double)v19 * 0.01;
            *(float *)(a1 + 876) = v20;
            if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscTxPerThres"), (const void **)&v57) && v57)
            {
              CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
              v21 = (double)valuePtr * 0.01;
              *(float *)(a1 + 884) = v21;
            }
            if (CFDictionaryGetValueIfPresent(theDict, CFSTR("trgDiscMinTxFrames"), (const void **)&v57) && v57)
            {
              CFNumberGetValue((CFNumberRef)v57, kCFNumberIntType, &valuePtr);
              *(_DWORD *)(a1 + 880) = valuePtr;
            }
          }
          goto LABEL_114;
        }
      }
    }
    goto LABEL_162;
  }
LABEL_114:
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("simulateProbeFailureState"), (const void **)&value) && value)
    *(_BYTE *)(a1 + 643) = CFEqual(value, kCFBooleanTrue) != 0;
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscConfig - RSSI Configs\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v22);
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v23);
  v24 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: RssiBrcks: {%2d %2d %2d} GoodRssi: %3d ajRssi: %3d lqaEnable: %1d monitorOnly: %1d wifiFallPref: %1d lqaMode: %1d askToTD: %1d rnf: %d atd: %d\n", "WiFiLQAMgrSetTrgDiscParams", *(unsigned int *)(a1 + 652), *(unsigned int *)(a1 + 656), *(unsigned int *)(a1 + 660), *(unsigned int *)(a1 + 648), *(unsigned int *)(a1 + 664), *(unsigned __int8 *)(a1 + 640), *(unsigned __int8 *)(a1 + 641), *(unsigned __int8 *)(a1 + 642), *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 644), *(unsigned __int8 *)(a1 + 646), *(unsigned __int8 *)(a1 + 645));
  objc_autoreleasePoolPop(v24);
  v25 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v25);
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscConfig - Tx PER Sig\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v26);
  v27 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v27);
  v28 = 0;
  v29 = 0;
  do
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:Indx: %1d Enable: %1d TxPer: {%2.1f %2.1f %2.1f} MinTxFrms: {%2u %2u %2u} RetryFactor: {%2u %2u %2u}\n", "WiFiLQAMgrSetTrgDiscParams", v29, *(unsigned __int8 *)(a1 + v28 + 724), (float)(*(float *)(a1 + v28 + 732) * 100.0), (float)(*(float *)(a1 + v28 + 940) * 100.0), (float)(*(float *)(a1 + v28 + 1104) * 100.0), *(unsigned int *)(a1 + v28 + 728), *(unsigned int *)(a1 + v28 + 936), *(unsigned int *)(a1 + v28 + 1100), *(unsigned int *)(a1 + v28 + 736), *(unsigned int *)(a1 + v28 + 944), *(unsigned int *)(a1 + v28 + 1108));
    objc_autoreleasePoolPop(v30);
    v29 = (v29 + 1);
    v28 += 16;
  }
  while (v28 != 64);
  v31 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v31);
  v32 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscConfig - FW Tx PER Sig\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v32);
  v33 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v33);
  v34 = 0;
  v35 = 0;
  do
  {
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:Indx: %1d Enable: %1d FwTxPer: {%2.1f %2.1f %2.1f} FwMinTxFrms: {%2u %2u %2u} TxPer: {%02.1f %02.1f %02.1f} minHostFrames: {%2u %2u %2u}\n", "WiFiLQAMgrSetTrgDiscParams", v35, *(unsigned __int8 *)(a1 + v34 + 788), (float)(*(float *)(a1 + v34 + 796) * 100.0), (float)(*(float *)(a1 + v34 + 1004) * 100.0), (float)(*(float *)(a1 + v34 + 1168) * 100.0), *(unsigned int *)(a1 + v34 + 792), *(unsigned int *)(a1 + v34 + 1000), *(unsigned int *)(a1 + v34 + 1164), (float)(*(float *)(a1 + v34 + 804) * 100.0), (float)(*(float *)(a1 + v34 + 1012) * 100.0), (float)(*(float *)(a1 + v34 + 1176) * 100.0), *(unsigned int *)(a1 + v34 + 800), *(unsigned int *)(a1 + v34 + 1008),
        *(unsigned int *)(a1 + v34 + 1172));
    objc_autoreleasePoolPop(v36);
    v35 = (v35 + 1);
    v34 += 20;
  }
  while (v34 != 80);
  v37 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v37);
  v38 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscConfig - BCN PER Sig\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v38);
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v39);
  v40 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Enable: %1d BcnTxPer: {%2.1f %2.1f %2.1f} MinBcnSched: {%2d %2d %2d} TxPer: {%2.1f %2.1f %2.1f} minHostFrames: {%2u %2u %2u}\n", "WiFiLQAMgrSetTrgDiscParams", *(unsigned __int8 *)(a1 + 868), (float)(*(float *)(a1 + 876) * 100.0), (float)(*(float *)(a1 + 1084) * 100.0), (float)(*(float *)(a1 + 1248) * 100.0), *(unsigned int *)(a1 + 872), *(unsigned int *)(a1 + 1080), *(unsigned int *)(a1 + 1244), (float)(*(float *)(a1 + 884) * 100.0), (float)(*(float *)(a1 + 1092) * 100.0), (float)(*(float *)(a1 + 1256) * 100.0), *(unsigned int *)(a1 + 880), *(unsigned int *)(a1 + 1088), *(unsigned int *)(a1 + 1252));
  objc_autoreleasePoolPop(v40);
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v41);
  v42 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscConfig - Misc Sig\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v42);
  v43 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v43);
  v44 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActPrEnable: %1d NumActProbes: %3d ActPrTxPer: %2.1f simulateProbeFailureState: %1d sympSigEnable: %1d sympThres: %3d GwArpSigEnable: %1d gwArpTime: %f ccaSigEnable: %1d ccaThres: %3d\n", "WiFiLQAMgrSetTrgDiscParams", *(unsigned __int8 *)(a1 + 888), *(unsigned int *)(a1 + 892), (float)(*(float *)(a1 + 896) * 100.0), *(unsigned __int8 *)(a1 + 643), *(unsigned __int8 *)(a1 + 920), *(unsigned int *)(a1 + 924), *(unsigned __int8 *)(a1 + 904), *(_QWORD *)(a1 + 912), *(unsigned __int8 *)(a1 + 928), *(unsigned __int8 *)(a1 + 929));
  objc_autoreleasePoolPop(v44);
  v45 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:--------------------------------------------------\n", "WiFiLQAMgrSetTrgDiscParams");
  objc_autoreleasePoolPop(v45);
  return 4294963396;
}

uint64_t sub_100049D30(uint64_t a1, __int16 a2)
{
  void *v3;
  uint64_t v4;

  if (a1)
  {
    *(_WORD *)(a1 + 2900) = a2;
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Critical AppState = %d NonCritical AppState = %d", a2, HIBYTE(a2));
    v4 = 0;
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s, LQAManagerRef is NULL", "WiFiLQAMgrSetLQATrafficConfig");
    v4 = 4294963396;
  }
  objc_autoreleasePoolPop(v3);
  return v4;
}

__CFDictionary *sub_100049DDC(const UInt8 *a1)
{
  __CFDictionary *Mutable;
  CFDataRef v3;
  CFDataRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  int v20;
  const char *v21;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v3 = CFDataCreate(kCFAllocatorDefault, a1 + 2864, 8);
    if (v3)
    {
      v4 = v3;
      CFDictionaryAddValue(Mutable, CFSTR("BSSID"), v3);
      CFRelease(v4);
      v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a1 + 2872);
      if (!v5)
        goto LABEL_12;
      v6 = v5;
      CFDictionarySetValue(Mutable, CFSTR("LINK_HEALTH"), v5);
      CFRelease(v6);
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a1 + 2880);
      if (!v7)
        goto LABEL_12;
      v8 = v7;
      CFDictionarySetValue(Mutable, CFSTR("CHANNEL"), v7);
      CFRelease(v8);
      v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, a1 + 2884);
      if (!v9)
        goto LABEL_12;
      v10 = v9;
      CFDictionarySetValue(Mutable, CFSTR("CHANNEL_WIDTH"), v9);
      CFRelease(v10);
      v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, a1 + 2893);
      if (!v11)
        goto LABEL_12;
      v12 = v11;
      CFDictionarySetValue(Mutable, CFSTR("CCA_SELF_TOTAL"), v11);
      CFRelease(v12);
      v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, a1 + 2894);
      if (!v13)
        goto LABEL_12;
      v14 = v13;
      CFDictionarySetValue(Mutable, CFSTR("CCA_OTHER_TOTAL"), v13);
      CFRelease(v14);
      v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, a1 + 2895);
      if (!v15)
        goto LABEL_12;
      v16 = v15;
      CFDictionarySetValue(Mutable, CFSTR("CCA_INTERFERENCE_TOTAL"), v15);
      CFRelease(v16);
      v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a1 + 2888);
      if (v17)
      {
        v18 = v17;
        CFDictionarySetValue(Mutable, CFSTR("RSSI"), v17);
        CFRelease(v18);
      }
      else
      {
LABEL_12:
        CFRelease(Mutable);
        return 0;
      }
    }
    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 136315138;
      v21 = "WiFiLQAMgrGetCurLinkHealthDictionary";
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: bssid allocation Failed!\n", (uint8_t *)&v20, 0xCu);
    }
  }
  return Mutable;
}

uint64_t sub_10004A070(uint64_t a1, void *a2)
{
  uint64_t result;
  void *v5;
  unsigned int v6;
  id v7;
  id v8;
  id v9;
  id v10;
  const void *v11;
  id v12;
  unsigned __int16 v13;
  unsigned int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  void *v17;
  void *v18;
  const char *v19;

  result = sub_100032154(*(_QWORD *)(a1 + 32));
  if ((_DWORD)result != 1)
    return result;
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[TrafficEngineering]: Critical App Event %@", a2);
  objc_autoreleasePoolPop(v5);
  v6 = *(_DWORD *)(a1 + 2916);
  ++dword_10026D5AC;
  v7 = objc_msgSend(a2, "objectForKey:", CFSTR("CHANNEL"));
  v8 = objc_msgSend(a2, "objectForKey:", CFSTR("RSSI"));
  v9 = objc_msgSend(a2, "objectForKey:", CFSTR("BSSID"));
  v10 = objc_msgSend(a2, "objectForKey:", CFSTR("LINK_HEALTH"));
  v11 = sub_10002BE64(*(_QWORD *)(a1 + 48), CFSTR("BSSID"));
  v12 = objc_msgSend(a2, "objectForKey:", CFSTR("CRITICAL_TRAFFIC_STATE"));
  v13 = (unsigned __int16)objc_msgSend(v7, "intValue");
  v14 = objc_msgSend(v8, "intValue");
  v15 = (unsigned __int16)objc_msgSend(v10, "intValue");
  v16 = (unsigned __int16)objc_msgSend(v12, "intValue");
  *(CFAbsoluteTime *)(a1 + 2928) = CFAbsoluteTimeGetCurrent();
  if (*(unsigned __int16 *)(a1 + 2848) != v13
    || (result = (uint64_t)objc_msgSend(v9, "isEqual:", v11), (result & 1) == 0))
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_12:
      objc_autoreleasePoolPop(v17);
      v6 = 1;
      goto LABEL_13;
    }
    v19 = "[TrafficEngineering]: Peer on different BSS, Switch/Continue default behavior";
LABEL_11:
    objc_msgSend(v18, "WFLog:message:", 3, v19);
    goto LABEL_12;
  }
  if (!v16)
  {
    v17 = objc_autoreleasePoolPush();
    v18 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v19 = "[TrafficEngineering]: Critical App terminated, Revert to default behavior";
    goto LABEL_11;
  }
  switch(v15)
  {
    case 1u:
    case 8u:
      v6 = 1;
      break;
    case 2u:
      v6 = 2;
      break;
    case 4u:
      if ((int)(v14 << 16) < -4915200)
        v6 = 1;
      else
        v6 = 4;
      break;
    default:
      break;
  }
  if (*(_DWORD *)(a1 + 2916) != v6)
  {
    if (*(_BYTE *)(a1 + 2897) == 1)
    {
      if (v6 > 4 || ((1 << v6) & 0x16) == 0)
        goto LABEL_14;
    }
    else if (v6 != 1)
    {
      goto LABEL_14;
    }
LABEL_13:
    result = sub_100078C64(*(_QWORD *)(a1 + 32), v6);
LABEL_14:
    dword_10026D5AC = 0;
  }
  return result;
}

__CFDictionary *sub_10004A2E0(uint64_t *a1)
{
  __CFDictionary *Mutable;
  const void *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  const void *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  void *v21;
  unsigned int v23;
  unsigned int valuePtr;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v3 = sub_10002BE64(a1[6], CFSTR("BSSID"));
    CFDictionaryAddValue(Mutable, CFSTR("BSSID"), v3);
    v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a1 + 359);
    if (!v4)
      goto LABEL_14;
    v5 = v4;
    CFDictionarySetValue(Mutable, CFSTR("LINK_HEALTH"), v4);
    CFRelease(v5);
    v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (char *)a1 + 2900);
    if (!v6)
      goto LABEL_14;
    v7 = v6;
    CFDictionarySetValue(Mutable, CFSTR("CRITICAL_TRAFFIC_STATE"), v6);
    CFRelease(v7);
    v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (char *)a1 + 2901);
    if (!v8)
      goto LABEL_14;
    v9 = v8;
    CFDictionarySetValue(Mutable, CFSTR("NON_CRITICAL_TRAFFIC_STATE"), v8);
    CFRelease(v9);
    valuePtr = sub_100017A54(a1[6], CFSTR("CHANNEL"));
    v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    if (!v10)
      goto LABEL_14;
    v11 = v10;
    CFDictionarySetValue(Mutable, CFSTR("CHANNEL"), v10);
    CFRelease(v11);
    v12 = sub_10002BE64(a1[6], CFSTR("CHANNEL_WIDTH"));
    CFDictionarySetValue(Mutable, CFSTR("CHANNEL_WIDTH"), v12);
    v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (char *)a1 + 2893);
    if (!v13)
      goto LABEL_14;
    v14 = v13;
    CFDictionarySetValue(Mutable, CFSTR("CCA_SELF_TOTAL"), v13);
    CFRelease(v14);
    v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (char *)a1 + 2894);
    if (!v15)
      goto LABEL_14;
    v16 = v15;
    CFDictionarySetValue(Mutable, CFSTR("CCA_OTHER_TOTAL"), v15);
    CFRelease(v16);
    v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (char *)a1 + 2895);
    if (!v17)
      goto LABEL_14;
    v18 = v17;
    CFDictionarySetValue(Mutable, CFSTR("CCA_INTERFERENCE_TOTAL"), v17);
    CFRelease(v18);
    v23 = sub_100017A54(a1[6], CFSTR("RSSI"));
    v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v23);
    if (v19)
    {
      v20 = v19;
      CFDictionarySetValue(Mutable, CFSTR("RSSI"), v19);
      CFRelease(v20);
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Link Health: %@", Mutable);
      objc_autoreleasePoolPop(v21);
    }
    else
    {
LABEL_14:
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

void sub_10004A594(uint64_t a1)
{
  NSObject *v2;
  dispatch_time_t v3;

  v2 = *(NSObject **)(a1 + 2904);
  if (v2)
  {
    v3 = dispatch_time(0, 30000000000);
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
  *(_BYTE *)(a1 + 2912) = 1;
}

uint64_t sub_10004A5E8()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_10022F0B0);
  qword_10026D5B0 = result;
  return result;
}

void sub_10004A60C(uint64_t a1)
{
  void *v2;
  CFTypeID v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  void *v23;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "enter:%s: \n", "__WiFiLQAMgrRelease");
  objc_autoreleasePoolPop(v2);
  if (!a1)
    sub_100186958();
  v3 = CFGetTypeID((CFTypeRef)a1);
  v4 = qword_10026D5B0;
  if (!qword_10026D5B0)
  {
    pthread_once(&stru_10026C910, (void (*)(void))sub_10004A5E8);
    v4 = qword_10026D5B0;
  }
  if (v3 != v4)
    sub_100186980();
  qword_10026D5A0 = 0;
  if (*(_QWORD *)(a1 + 528))
    tcp_connection_fallback_watcher_destroy();
  *(_QWORD *)(a1 + 528) = 0;
  v5 = *(const void **)(a1 + 40);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v6 = *(const void **)(a1 + 400);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 400) = 0;
  }
  v7 = *(NSObject **)(a1 + 544);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(a1 + 544) = 0;
  }
  v8 = *(NSObject **)(a1 + 336);
  if (v8)
  {
    dispatch_release(v8);
    *(_QWORD *)(a1 + 336) = 0;
  }
  v9 = *(NSObject **)(a1 + 2904);
  if (v9)
  {
    dispatch_release(v9);
    *(_QWORD *)(a1 + 2904) = 0;
  }
  *(_BYTE *)(a1 + 2912) = 0;
  v10 = *(NSObject **)(a1 + 296);
  if (v10)
    dispatch_release(v10);
  v11 = *(NSObject **)(a1 + 2920);
  if (v11)
    dispatch_release(v11);
  v12 = *(void **)(a1 + 2968);
  if (v12)

  v13 = *(const void **)(a1 + 24);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v14 = *(const void **)(a1 + 320);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 320) = 0;
  }
  v15 = *(const void **)(a1 + 1288);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 1288) = 0;
  }
  v16 = *(const void **)(a1 + 1272);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 1272) = 0;
  }
  v17 = *(const void **)(a1 + 256);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 256) = 0;
  }
  v18 = *(const void **)(a1 + 264);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 264) = 0;
  }
  v19 = *(const void **)(a1 + 144);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v20 = *(const void **)(a1 + 152);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v21 = *(const void **)(a1 + 112);
  if (v21)
  {
    CFRelease(v21);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v22 = *(const void **)(a1 + 208);
  if (v22)
    CFRelease(v22);
  bzero((void *)(a1 + 16), 0xC80uLL);
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "exit: %s: \n", "__WiFiLQAMgrRelease");
  objc_autoreleasePoolPop(v23);
}

void sub_10004A824(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RSSI_WIN: Configure Dynamic RSSI Window = %u", *(unsigned __int8 *)(a1 + 2985));
  objc_autoreleasePoolPop(v2);
  sub_100079330(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 2985));
}

uint64_t sub_10004A888(CFTypeRef cf, char a2, char a3)
{
  void *v7;
  _QWORD v8[5];
  char v9;
  char v10;

  if (!&_managed_event_fetch)
    return 0;
  if (cf)
  {
    CFRetain(cf);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_10004ACA4;
    v8[3] = &unk_10022F138;
    v8[4] = cf;
    v9 = a2;
    v10 = a3;
    return managed_event_fetch(1, v8);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrFetchSymptomsViewOfLink");
    objc_autoreleasePoolPop(v7);
    return 0;
  }
}

uint64_t sub_10004A964(uint64_t a1)
{
  double Current;
  uint64_t v3;
  unint64_t v4;
  float v5;
  int v6;
  float v7;
  _DWORD *v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  float *v13;
  _BOOL4 v14;
  uint64_t v15;
  void *v16;
  double v17;
  _BOOL8 v18;
  void *v20;
  _OWORD v21[3];

  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrCheckReassocRequiredMacStatsBased");
    goto LABEL_31;
  }
  Current = CFAbsoluteTimeGetCurrent();
  memset(v21, 0, 44);
  if (!sub_1000484B0(a1, v21))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to extract metrics from Lqm, exiting!", "__WiFiLQAMgrCheckReassocRequiredMacStatsBased");
    goto LABEL_31;
  }
  if (*(int *)(a1 + 2796) > -66)
    return 0;
  if (*(_BYTE *)(a1 + 2834))
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: isAwdlRealTimeModeActive", "__WiFiLQAMgrCheckReassocRequiredMacStatsBased");
LABEL_31:
    objc_autoreleasePoolPop(v16);
    return 0;
  }
  if (SBYTE8(v21[2]) <= SBYTE9(v21[2]))
    return 0;
  if (!*(_BYTE *)(a1 + 928))
    return 0;
  v3 = (BYTE8(v21[2]) - BYTE9(v21[2]));
  if (v3 < *(unsigned __int8 *)(a1 + 929))
    return 0;
  v4 = 0;
  v5 = (float)SLODWORD(v21[0]);
  v6 = DWORD1(v21[0]);
  v7 = (float)SDWORD1(v21[0]);
  v8 = (_DWORD *)(a1 + 736);
  v9 = 1;
  while (!*((_BYTE *)v8 - 12)
       || SDWORD1(v21[0]) < *(v8 - 2)
       || (float)(*((float *)v8 - 1) * v7) > v5
       || SDWORD2(v21[0]) <= *v8 * DWORD1(v21[0]))
  {
    v8 += 4;
    v9 = v4++ < 3;
    if (v4 == 4)
    {
      v10 = 0;
      goto LABEL_15;
    }
  }
  v10 = 1;
LABEL_15:
  if (*(_BYTE *)(a1 + 868)
    && SHIDWORD(v21[1]) > *(_DWORD *)(a1 + 872)
    && (float)((float)(1.0 - *(float *)(a1 + 876)) * (float)SHIDWORD(v21[1])) > (float)SLODWORD(v21[2])
    && (SDWORD1(v21[0]) < *(_DWORD *)(a1 + 880) || (float)(*(float *)(a1 + 884) * v7) <= v5))
  {
    v11 = 1;
    *(_BYTE *)(a1 + 2824) = 1;
  }
  else
  {
    v11 = 0;
  }
  v12 = 0;
  v13 = (float *)(a1 + 804);
  v14 = 1;
  while (!*((_BYTE *)v13 - 16)
       || SDWORD1(v21[1]) < *((_DWORD *)v13 - 3)
       || (float)(*(v13 - 2) * (float)SDWORD1(v21[1])) > (float)SLODWORD(v21[1])
       || v6 >= *((_DWORD *)v13 - 1) && (float)(*v13 * v7) > v5)
  {
    v13 += 5;
    v14 = v12++ < 3;
    if (v12 == 4)
    {
      v15 = 0;
      goto LABEL_33;
    }
  }
  v15 = 1;
LABEL_33:
  v17 = 0.0;
  if (*(_DWORD *)(a1 + 2760) == 1)
    v17 = Current - *(double *)(a1 + 2768);
  v18 = *(_BYTE *)(a1 + 904) && (unint64_t)(v17 >= *(double *)(a1 + 912));
  if (((v9 | v11 | v14) & 1) == 0 && !v18)
    return 0;
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: isReassocRequired:%d cca:%d txPerDecision:%d bcnPerDecision:%d fwPerDecision:%d gwArpDecision:%d", "__WiFiLQAMgrCheckReassocRequiredMacStatsBased", 1, v3, v10, v11, v15, v18);
  objc_autoreleasePoolPop(v20);
  return 1;
}

void sub_10004ACA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  const __CFDictionary *v8;
  char v9;
  uint64_t v10;
  int v11;
  void *v12;
  void *v13;
  uint64_t v14;
  int v15;
  void *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFNumberRef number;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  void *v28;
  void *v29;
  void *v30;
  int valuePtr;
  void *value;

  value = 0;
  valuePtr = 0;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v26 = 0;
  v27 = 0;
  number = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  pthread_mutex_lock(&stru_10026CB48);
  v6 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v6 + 2984))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s LQA manager is in closing \n", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke");
    objc_autoreleasePoolPop(v7);
    pthread_mutex_unlock(&stru_10026CB48);
    CFRelease(*(CFTypeRef *)(a1 + 32));
    return;
  }
  *(_QWORD *)(v6 + 496) = 0x400000000000FFFFLL;
  *(_DWORD *)(v6 + 520) = 0;
  *(_QWORD *)(v6 + 512) = 0;
  *(_BYTE *)(v6 + 536) = *(_BYTE *)(a1 + 40);
  *(_BYTE *)(v6 + 537) = *(_BYTE *)(a1 + 41);
  if ((_DWORD)a2 || !a3)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error %d from Managed Event Fetch", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke", a2);
  }
  else
  {
    v8 = *(const __CFDictionary **)(a3 + 48);
    if (v8)
    {
      if (CFDictionaryGetValueIfPresent(v8, CFSTR("impact-flags"), (const void **)&value) && value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
        *(_DWORD *)(*(_QWORD *)(a1 + 32) + 492) = valuePtr;
      }
      v9 = 0;
      if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a3 + 48), CFSTR("net-score"), (const void **)&number)
        && number)
      {
        CFNumberGetValue(number, kCFNumberIntType, &v21);
        v10 = *(_QWORD *)(a1 + 32);
        v11 = *(_DWORD *)(v10 + 504);
        if (v11 == (_DWORD)v21)
        {
          v9 = 0;
        }
        else
        {
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Change in netscore observed from %d to %d", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 504), v21);
          objc_autoreleasePoolPop(v13);
          v11 = v21;
          v10 = *(_QWORD *)(a1 + 32);
          v9 = 1;
        }
        *(_DWORD *)(v10 + 504) = v11;
      }
      if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a3 + 48), CFSTR("AWD-info"), (const void **)&v30) && v30)
      {
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v30, CFSTR("ARP-failures"), (const void **)&v29) && v29)
        {
          CFNumberGetValue((CFNumberRef)v29, kCFNumberIntType, (char *)&v23 + 4);
          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 512) = HIDWORD(v23);
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v30, CFSTR("dns-total"), (const void **)&v27) && v27)
        {
          CFNumberGetValue(v27, kCFNumberIntType, (char *)&v22 + 4);
          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 516) = HIDWORD(v22);
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v30, CFSTR("dns-impacted"), (const void **)&v28) && v28)
        {
          CFNumberGetValue((CFNumberRef)v28, kCFNumberIntType, &v23);
          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 520) = v23;
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v30, CFSTR("data-stalls-score"), (const void **)&v26) && v26)
        {
          CFNumberGetValue(v26, kCFNumberIntType, &v22);
          v14 = *(_QWORD *)(a1 + 32);
          v15 = *(_DWORD *)(v14 + 524);
          if (v15 != (_DWORD)v22)
          {
            v16 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Change in datastallscore observed from %d to %d", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 524), v22);
            objc_autoreleasePoolPop(v16);
            v15 = v22;
            v14 = *(_QWORD *)(a1 + 32);
            *(_DWORD *)(v14 + 524) = v22;
            v9 = 1;
          }
          *(_DWORD *)(v14 + 496) = v15;
        }
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v30, CFSTR("rnf-denials-score"), (const void **)&v25) && v25)
        {
          CFNumberGetValue(v25, kCFNumberFloatType, (char *)&v21 + 4);
          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 500) = HIDWORD(v21);
        }
      }
      if (*(_BYTE *)(a1 + 40))
      {
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Symptoms Input: %@", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke", *(_QWORD *)(a3 + 48));
        objc_autoreleasePoolPop(v17);
      }
      goto LABEL_49;
    }
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: additional_info NULL from Managed Event Fetch", "__WiFiLQAMgrFetchSymptomsViewOfLink_block_invoke", v20);
  }
  objc_autoreleasePoolPop(v12);
  v9 = 0;
LABEL_49:
  v18 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v18 + 538) = v9;
  v19 = *(NSObject **)(v18 + 1280);
  if (v19)
    dispatch_async_f(v19, (void *)v18, (dispatch_function_t)sub_10004B108);
  pthread_mutex_unlock(&stru_10026CB48);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void sub_10004B108(uint64_t a1)
{
  int v2;
  _BOOL8 v3;
  _BOOL8 v4;
  unsigned int v5;
  double v6;
  int v7;
  char v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  double v19;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  char v24;
  void *v25;
  void *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int *v34;
  const float *v35;
  float32x2_t v36;
  unsigned int *v37;
  uint64_t v38;
  double Current;
  double v40;
  CFMutableStringRef Mutable;
  uint64_t v42;
  const void *v43;
  __CFString *v44;
  __CFString *v45;
  void *v46;
  void *v47;
  uint64_t v48;
  _BOOL4 v49;
  _BOOL4 v50;
  uint64_t v51;
  WiFiUsageMonitor *v52;
  uint64_t v53;
  char v54;
  void *v55;
  id v56;
  uint64_t v57;
  int v58;
  void *v59;
  const char *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  unsigned int v66;
  _BOOL8 v67;
  uint64_t v68;
  _BOOL4 v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;

  if (!a1)
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrSymptomsInputCallBack");
    goto LABEL_174;
  }
  if (*(_BYTE *)(a1 + 537) && (*(_BYTE *)(a1 + 538) || !*(_BYTE *)(a1 + 539)))
    sub_100047E10(a1);
  if (*(_BYTE *)(a1 + 200) != 1)
  {
    if (!*(_BYTE *)(a1 + 536))
    {
LABEL_175:
      Mutable = 0;
      v49 = 0;
      v50 = 0;
      LODWORD(v4) = 0;
      v5 = 0;
      v42 = 0;
      v23 = 0;
      v72 = 0;
      v73 = 0;
      v51 = 0;
LABEL_114:
      v28 = 1;
LABEL_115:
      v52 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
      v53 = 256;
      if (!v50)
        v53 = 0;
      -[WiFiUsageMonitor setTdLogic_execState:forInterface:](v52, "setTdLogic_execState:forInterface:", (v73 << 48) | (v72 << 56) | (v23 << 40) | (v42 << 32) | ((unint64_t)v5 << 24) | ((unint64_t)v4 << 16) | v53 | v49, v51, *(_QWORD *)(a1 + 40));
      if (Mutable)
        CFRelease(Mutable);
      v54 = v28 ^ 1;
      if (!a1)
        v54 = 1;
      if ((v54 & 1) == 0)
        *(_BYTE *)(a1 + 161) = 0;
      goto LABEL_123;
    }
    v2 = *(_DWORD *)(a1 + 20);
    if (v2 == 1)
    {
      v63 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Trigger Disconnect in GoodLinkState", "__WiFiLQAMgrSymptomsInputCallBack");
    }
    else
    {
      if (v2)
      {
        v3 = sub_10004BD44(a1, 0, 0);
        v4 = v3;
        if (!*(_BYTE *)(a1 + 645))
        {
          v9 = 0;
          v5 = 0;
          v8 = 0;
          v7 = 1;
          goto LABEL_31;
        }
        if (!*(_BYTE *)(a1 + 646) || *(_DWORD *)(a1 + 2796) <= *(_DWORD *)(a1 + 660))
        {
          v8 = 0;
          v5 = 0;
          v9 = 0;
          v7 = 1;
          goto LABEL_29;
        }
        if (*(_BYTE *)(a1 + 2824) || (v11 = *(_DWORD *)(a1 + 496), v11 < 0x1A) || v11 == 0xFFFF || v3)
        {
          v5 = 0;
          v6 = *(float *)(a1 + 500);
          v7 = 1;
          if (v6 < 0.01)
          {
            v8 = 1;
            v9 = 0;
LABEL_29:
            if (*(_BYTE *)(a1 + 645))
            {
              v12 = *(unsigned __int8 *)(a1 + 646);
              v69 = *(_BYTE *)(a1 + 646) != 0;
              goto LABEL_32;
            }
LABEL_31:
            v69 = 0;
            v12 = *(unsigned __int8 *)(a1 + 646);
LABEL_32:
            v70 = v12 != 0;
            v13 = *(_DWORD *)(a1 + 2808);
            v14 = sub_100048130(a1) << 14;
            v15 = *(unsigned __int8 *)(a1 + 645);
            v71 = v9;
            if (*(_BYTE *)(a1 + 645))
              v15 = (*(_BYTE *)(a1 + 646) != 0) << 13;
            v16 = v13 | (v4 << 23) | v14 | v15 | 0x9800;
            v17 = *(_DWORD *)(a1 + 496);
            if (v17 != 0xFFFF && v17 >= 0x1A)
              v16 &= ~0x800u;
            v19 = *(float *)(a1 + 500);
            if (v19 > 1.01 || v19 < 0.01)
              v21 = v16;
            else
              v21 = v16 & 0xFFFFEFFF;
            if (-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
            {
              v22 = v21;
            }
            else
            {
              v22 = v21 & 0xFFFF7FFE;
            }
            if (*(_BYTE *)(a1 + 647)
              && *(_BYTE *)(a1 + 645)
              && *(_BYTE *)(a1 + 646)
              && !-[WiFiUserInteractionMonitor isCellularDataUsable](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularDataUsable"))
            {
              v62 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s CellData setting overriding TrgDisc decision", "__WiFiLQAMgrSymptomsInputCallBack");
              objc_autoreleasePoolPop(v62);
              v7 = 0;
              v23 = 1;
            }
            else
            {
              v23 = 0;
            }
            if (sub_100077738(*(_QWORD *)(a1 + 32)) == 1
              && (*(_DWORD *)(a1 + 216) == 1 || !*(_BYTE *)(a1 + 645) || !*(_BYTE *)(a1 + 646)))
            {
              v26 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Manual Join: User Interactive or RNF disabled, overriding TrgDisc decision", "__WiFiLQAMgrSymptomsInputCallBack");
              v27 = 0;
              v72 = 0;
              goto LABEL_80;
            }
            v24 = v8 ^ 1;
            if (!v7)
              v24 = 1;
            if ((v24 & 1) != 0)
            {
              if (v4 || !v7)
              {
                if (!v7)
                {
LABEL_76:
                  v68 = 0;
                  v72 = 0;
LABEL_81:
                  v73 = 0;
                  v28 = 1;
                  goto LABEL_82;
                }
              }
              else if (*(_DWORD *)(a1 + 2796) > *(_DWORD *)(a1 + 656) - 2)
              {
                v7 = 0;
                v68 = 0;
                v72 = 0;
                v28 = 1;
                v29 = 1;
                goto LABEL_71;
              }
            }
            else
            {
              v25 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Proceeding with Trigger Discconect - DataStallScore %d AppPolicyScore %f", "__WiFiLQAMgrSymptomsInputCallBack", *(unsigned int *)(a1 + 496), *(float *)(a1 + 500));
              objc_autoreleasePoolPop(v25);
            }
            if (!sub_100048130(a1))
            {
              v26 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Foreground Networking App not present. Overriding TrgDisc decision", "__WiFiLQAMgrSymptomsInputCallBack");
              v27 = 0;
              v72 = 1;
              goto LABEL_80;
            }
            if (*(_BYTE *)(a1 + 641))
            {
              v7 = 0;
              goto LABEL_76;
            }
            if (!*(_BYTE *)(a1 + 644))
            {
              v28 = 0;
              v68 = 0;
              v72 = 0;
              v73 = 0;
              v7 = 1;
LABEL_82:
              v30 = sub_10004C740(a1);
              if (v30 == 255)
              {
                Mutable = 0;
                v42 = v71;
LABEL_112:
                v49 = v69;
                v50 = v70;
                v51 = v68;
                if ((v28 & 1) == 0)
                  sub_1000423C8(a1, (uint64_t)Mutable);
                goto LABEL_114;
              }
              v31 = v30;
              v66 = v5;
              v67 = v4;
              v32 = v30;
              v33 = a1 + 144 * v30;
              v34 = (unsigned int *)(v33 + 1312);
              *(_BYTE *)(v33 + 1349) = v7;
              v35 = (const float *)(a1 + 492);
              *(_DWORD *)(v33 + 1368) = *(_DWORD *)(a1 + 512);
              *(int32x2_t *)(v33 + 1372) = vrev64_s32(*(int32x2_t *)(a1 + 516));
              *(double *)(v33 + 1400) = *(float *)(a1 + 500);
              *(_DWORD *)(v33 + 1416) = *(_DWORD *)(a1 + 496);
              v36 = vld1_dup_f32(v35);
              *(float32x2_t *)(v33 + 1356) = v36;
              v37 = (unsigned int *)(v33 + 1356);
              v38 = v7 | v22 & 0xFFFFFFFE;
              *(_DWORD *)(v33 + 1392) = v38;
              Current = CFAbsoluteTimeGetCurrent();
              v40 = 0.0;
              if (*(_DWORD *)(a1 + 2760) == 1)
                v40 = Current - *(double *)(a1 + 2768);
              v65 = v23;
              if ((v28 & 1) != 0)
              {
                Mutable = 0;
LABEL_109:
                v47 = objc_autoreleasePoolPush();
                v42 = v71;
                if (qword_10026DD20)
                {
                  v48 = a1 + 144 * v32;
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TrgDiscStatus %u [Rssi %d TxFrms %ld TxFail %ld TxRet %ld fwFrms %ld fwFail %ld fwRtry %ld RxFrms %ld BcnSch %ld BcnRx %ld Awd %ld UnGw %f FgApp %ld Walkout %d possibleRoam %d DataStallScore %ld DeltaTime %fsecs TD1 %d FastDisconnect %d]", "__WiFiLQAMgrSymptomsInputCallBack", v38, *(char *)(v48 + 1348), *v34, *(unsigned int *)(v48 + 1316), *(unsigned int *)(v48 + 1320), *(unsigned int *)(v48 + 1332), *(unsigned int *)(v48 + 1336), *(unsigned int *)(v48 + 1340), *(unsigned int *)(v48 + 1344), *(unsigned int *)(v48 + 1324), *(unsigned int *)(v48 + 1328), *(unsigned __int8 *)(v48 + 1364),
                    *(_QWORD *)&v40,
                    *v37,
                    *(unsigned __int8 *)(a1 + 273),
                    *(unsigned __int8 *)(a1 + 272),
                    *(unsigned int *)(a1 + 496),
                    *(_QWORD *)(a1 + 280),
                    *(unsigned __int8 *)(a1 + 2824),
                    v67);
                }
                objc_autoreleasePoolPop(v47);
                sub_10004C800((_BYTE *)a1, v31);
                LODWORD(v4) = v67;
                v5 = v66;
                v23 = v65;
                goto LABEL_112;
              }
              if (*(double *)(a1 + 136) != 0.0)
                *(_QWORD *)(a1 + 144 * v32 + 1432) = (unint64_t)(CFAbsoluteTimeGetCurrent()
                                                                        - *(double *)(a1 + 136));
              if (*(double *)(a1 + 120) != 0.0)
                *(_QWORD *)(a1 + 144 * v32 + 1424) = (unint64_t)(CFAbsoluteTimeGetCurrent()
                                                                        - *(double *)(a1 + 120));
              Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
              v43 = sub_10002B088(*(const void **)(a1 + 48));
              CFStringAppendFormat(Mutable, 0, CFSTR("Your WiFi %@ was automatically disconnected due to poor connectivity\n"), v43);
              v44 = CFStringCreateMutable(kCFAllocatorDefault, 0);
              if (!v44)
                goto LABEL_109;
              v45 = v44;
              CFStringAppendFormat(v44, 0, CFSTR("Trigger Disconnect with signatures - "));
              if ((v22 & 2) != 0)
              {
                CFStringAppendFormat(v45, 0, CFSTR("TxPER, "));
                if ((v22 & 4) == 0)
                {
LABEL_95:
                  if ((v22 & 8) == 0)
                    goto LABEL_96;
                  goto LABEL_143;
                }
              }
              else if ((v22 & 4) == 0)
              {
                goto LABEL_95;
              }
              CFStringAppendFormat(v45, 0, CFSTR("FwTxPER, "));
              if ((v22 & 8) == 0)
              {
LABEL_96:
                if ((v22 & 0x10) == 0)
                  goto LABEL_97;
                goto LABEL_144;
              }
LABEL_143:
              CFStringAppendFormat(v45, 0, CFSTR("BeaconPER, "));
              if ((v22 & 0x10) == 0)
              {
LABEL_97:
                if ((v22 & 0x40) == 0)
                  goto LABEL_98;
                goto LABEL_145;
              }
LABEL_144:
              CFStringAppendFormat(v45, 0, CFSTR("Symptoms, "));
              if ((v22 & 0x40) == 0)
              {
LABEL_98:
                if ((v22 & 0x80) == 0)
                  goto LABEL_99;
                goto LABEL_146;
              }
LABEL_145:
              CFStringAppendFormat(v45, 0, CFSTR("ARP, "));
              if ((v22 & 0x80) == 0)
              {
LABEL_99:
                if ((v22 & 0x100) == 0)
                  goto LABEL_100;
                goto LABEL_147;
              }
LABEL_146:
              CFStringAppendFormat(v45, 0, CFSTR("MotionAggr, "));
              if ((v22 & 0x100) == 0)
              {
LABEL_100:
                if ((v22 & 0x200) == 0)
                  goto LABEL_101;
                goto LABEL_148;
              }
LABEL_147:
              CFStringAppendFormat(v45, 0, CFSTR("UsrWalkout, "));
              if ((v22 & 0x200) == 0)
              {
LABEL_101:
                if ((v22 & 0x400) == 0)
                  goto LABEL_102;
                goto LABEL_149;
              }
LABEL_148:
              CFStringAppendFormat(v45, 0, CFSTR("EdgeBss, "));
              if ((v22 & 0x400) == 0)
              {
LABEL_102:
                if ((v22 & 0x20) == 0)
                  goto LABEL_103;
                goto LABEL_150;
              }
LABEL_149:
              CFStringAppendFormat(v45, 0, CFSTR("RoamCache, "));
              if ((v22 & 0x20) == 0)
              {
LABEL_103:
                if ((v22 & 0x200000) == 0)
                  goto LABEL_104;
                goto LABEL_151;
              }
LABEL_150:
              CFStringAppendFormat(v45, 0, CFSTR("Probe, "));
              if ((v22 & 0x200000) == 0)
              {
LABEL_104:
                if ((v22 & 0x800000) == 0)
                {
LABEL_106:
                  v46 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", v45);
                  objc_autoreleasePoolPop(v46);
                  CFRelease(v45);
                  goto LABEL_109;
                }
LABEL_105:
                CFStringAppendFormat(v45, 0, CFSTR("Recommendation, "));
                goto LABEL_106;
              }
LABEL_151:
              CFStringAppendFormat(v45, 0, CFSTR("TD1.0, "));
              if ((v22 & 0x800000) == 0)
                goto LABEL_106;
              goto LABEL_105;
            }
            if (*(_BYTE *)(a1 + 1296))
            {
              v26 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Suppress TrgDisc decision with User's previous input", "__WiFiLQAMgrSymptomsInputCallBack");
              v72 = 0;
              v27 = 1;
LABEL_80:
              v68 = v27;
              objc_autoreleasePoolPop(v26);
              v7 = 0;
              goto LABEL_81;
            }
            if (*(_QWORD *)(a1 + 1288))
            {
              v28 = 0;
              Mutable = 0;
              v72 = 0;
              v73 = 0;
              v51 = 0;
LABEL_164:
              v42 = v71;
              v49 = v69;
              v50 = v70;
              goto LABEL_115;
            }
            v28 = 0;
            if (!sub_10004C520(a1))
            {
              Mutable = 0;
              v51 = 0;
              v72 = 0;
              v73 = 0;
              goto LABEL_164;
            }
            v68 = 0;
            v7 = 1;
            v29 = 0;
            v72 = 0;
LABEL_71:
            v73 = v29;
            goto LABEL_82;
          }
          v8 = 1;
          v9 = 0;
          if (v6 > 1.01)
            goto LABEL_29;
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Symptoms overriding TrgDisc decision - AppPolicyScore %f", "__WiFiLQAMgrSymptomsInputCallBack", *(float *)(a1 + 500));
          v5 = 0;
          v9 = 1;
        }
        else
        {
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Symptoms overriding TrgDisc decision - DataStallScore %d", "__WiFiLQAMgrSymptomsInputCallBack", *(unsigned int *)(a1 + 496));
          v9 = 0;
          v5 = 1;
        }
        objc_autoreleasePoolPop(v10);
        v7 = 0;
        v8 = 1;
        goto LABEL_29;
      }
      v63 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Trigger Disconnect in UnassociatedState", "__WiFiLQAMgrSymptomsInputCallBack");
    }
LABEL_174:
    objc_autoreleasePoolPop(v63);
    goto LABEL_175;
  }
LABEL_123:
  if (*(_BYTE *)(a1 + 200))
  {
    *(_BYTE *)(a1 + 200) = 0;
    if (*(int *)(a1 + 2796) <= -66)
    {
      if (*(_BYTE *)(a1 + 2834))
      {
        v64 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: isAwdlRealTimeModeActive", "__WiFiLQAMgrCheckReassocRequiredSymptomsScoreBased");
        objc_autoreleasePoolPop(v64);
      }
      else
      {
        if (!*(_DWORD *)(a1 + 496))
        {
          v58 = sub_100048130(a1);
          v59 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v60 = "Yes";
            if (!v58)
              v60 = "No";
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SymptomsScore indicates WiFi data stall. FG app:%s", "__WiFiLQAMgrCheckReassocRequiredSymptomsScoreBased", v60);
          }
          objc_autoreleasePoolPop(v59);
          if (v58)
          {
            v61 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Attempting host triggered roam based on SymptomsScore", "__WiFiLQAMgrCheckReassocRequiredSymptomsScoreBased");
            objc_autoreleasePoolPop(v61);
            v56 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
            v57 = 3;
            goto LABEL_140;
          }
        }
        if (sub_10004A964(a1))
        {
          v55 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Attempting host triggered roam based on MacStats", "__WiFiLQAMgrCheckReassocRequiredSymptomsScoreBased");
          objc_autoreleasePoolPop(v55);
          v56 = +[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager");
          v57 = 4;
LABEL_140:
          objc_msgSend(v56, "roamWithReason:bandPreference:", v57, 0);
        }
      }
    }
  }
}

BOOL sub_10004BD44(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  int v6;
  int v7;
  _BOOL4 v8;
  const mach_header_64 *v9;
  char v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  void *v26;
  const char *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  double v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  const char *v45;
  double v46;
  const char *v47;
  const char *v48;
  const char *v49;
  const char *v50;
  double v51;
  double v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  double v56;
  const char *v57;
  double v58;
  const char *v59;
  const char *v60;
  const char *v61;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _BOOL4 v69;
  _OWORD v70[4];

  v6 = _os_feature_enabled_impl("WiFiManager", "LinkRecommendationTD");
  v7 = _os_feature_enabled_impl("WiFiManager", "RealTimeRoamSuppression");
  if (!a1)
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgrRef is null", "__WiFiLQAMgrShouldPerformFastDisconnect");
    goto LABEL_148;
  }
  v8 = v7;
  if (((_os_feature_enabled_impl("WiFiManager", "RealTimeFastTD") | v6) & 1) == 0)
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fast Disconnect not enabled", "__WiFiLQAMgrShouldPerformFastDisconnect");
    goto LABEL_148;
  }
  if (sub_10000BE8C(*(_QWORD *)(a1 + 48)) || sub_10001395C(*(_QWORD *)(a1 + 48)))
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fast Disconnect not supported on CarPlay/Personal Hotspot networks", "__WiFiLQAMgrShouldPerformFastDisconnect");
    goto LABEL_148;
  }
  if (*(_DWORD *)(a1 + 2796) >= *(_DWORD *)(a1 + 648))
  {
    v64 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fast Disconnect not triggered - Last RSSI: %d >= Good Link RSSI: %d", "__WiFiLQAMgrShouldPerformFastDisconnect", *(unsigned int *)(a1 + 2796), *(unsigned int *)(a1 + 648));
    v65 = v64;
    goto LABEL_149;
  }
  if (*(_BYTE *)(a1 + 220))
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fast Disconnect not triggered - FaceTime call active", "__WiFiLQAMgrShouldPerformFastDisconnect");
    goto LABEL_148;
  }
  if (*(_BYTE *)(a1 + 645))
    v69 = *(_BYTE *)(a1 + 646) != 0;
  else
    v69 = 0;
  if (-[WiFiUserInteractionMonitor isRealTimeAppActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isRealTimeAppActive")|| *(_BYTE *)(a1 + 2952))
  {
    v9 = &_mh_execute_header;
    v10 = 1;
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  v11 = -[WiFiUserInteractionMonitor isCellularInexpensive5G](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCellularInexpensive5G");
  v12 = 0x10000000000;
  if (!v11)
    v12 = 0;
  if ((v10 & 1) == 0 && (v6 & v11 & 1) == 0)
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fast Disconnect not triggered - neither realtime app active nor cheap 5g available", "__WiFiLQAMgrShouldPerformFastDisconnect");
    goto LABEL_148;
  }
  v13 = v12 | (unint64_t)v9;
  if (v6)
  {
    v14 = (*(_DWORD *)(a1 + 2948) >> 1) & 1;
    v13 |= v14;
  }
  else
  {
    v14 = 0;
  }
  memset(v70, 0, 44);
  if (!sub_1000484B0(a1, v70))
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to extract metrics from LQM, exiting!", "__WiFiLQAMgrShouldPerformFastDisconnect");
LABEL_148:
    v65 = v63;
LABEL_149:
    objc_autoreleasePoolPop(v65);
    return 0;
  }
  if (v8)
    v8 = (*(_BYTE *)(a1 + 2948) & 1) == 0;
  v15 = *(_DWORD *)(a1 + 2796);
  v16 = *(_DWORD *)(a1 + 656);
  v17 = (float)SLODWORD(v70[0]);
  v18 = (float)SDWORD1(v70[0]);
  v19 = -64;
  while (1)
  {
    v20 = a1 + v19 + 996;
    if (v15 <= v16)
      v20 = a1 + v19 + 1160;
    if (*(_BYTE *)v20
      && SDWORD1(v70[0]) >= *(_DWORD *)(v20 + 4)
      && (float)(*(float *)(v20 + 8) * v18) <= v17
      && SDWORD2(v70[0]) > *(_DWORD *)(v20 + 12) * DWORD1(v70[0]))
    {
      break;
    }
    v19 += 16;
    if (!v19)
      goto LABEL_31;
  }
  v13 |= 0x100uLL;
  ++v14;
LABEL_31:
  v21 = a1 + 1240;
  v22 = 1240;
  if (v15 > v16)
  {
    v22 = 1076;
    v21 = a1 + 1076;
  }
  if (*(_BYTE *)(a1 + v22)
    && SHIDWORD(v70[1]) > *(_DWORD *)(v21 + 4)
    && (float)((float)(1.0 - *(float *)(v21 + 8)) * (float)SHIDWORD(v70[1])) > (float)SLODWORD(v70[2]))
  {
    v13 = v13 & 0xFFFFFFFFFF00FFFFLL | 0x10000;
    ++v14;
  }
  v23 = -80;
  while (1)
  {
    v24 = a1 + v23 + 1076;
    if (v15 <= v16)
      v24 = a1 + v23 + 1240;
    if (*(_BYTE *)v24
      && SDWORD1(v70[1]) >= *(_DWORD *)(v24 + 4)
      && (float)(*(float *)(v24 + 8) * (float)SDWORD1(v70[1])) <= (float)SLODWORD(v70[1])
      && (SDWORD1(v70[0]) < *(_DWORD *)(v24 + 12) || (float)(*(float *)(v24 + 16) * v18) <= v17))
    {
      break;
    }
    v23 += 20;
    if (!v23)
      goto LABEL_48;
  }
  v13 = v13 & 0xFFFFFFFF00FFFFFFLL | 0x1000000;
  ++v14;
LABEL_48:
  if (a2)
  {
    if (v14 >= 2)
    {
      v25 = *(_DWORD *)(a1 + 56);
      if (v25)
      {
        if (v15 < v25)
          *a2 = 0;
      }
    }
  }
  if (a3
    && v14 >= 2
    && (-[WiFiUserInteractionMonitor isCarModeActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCarModeActive")|| (*(_DWORD *)(a1 + 2776) | 2) == 6))
  {
    *a3 = 1;
    if (a2)
      *a2 = 0;
  }
  -[WiFiUsageMonitor setTdLogic_fastTdState:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setTdLogic_fastTdState:forInterface:", v14, v13, *(_QWORD *)(a1 + 40));
  v26 = objc_autoreleasePoolPush();
  if (v15 <= v16)
  {
    if (qword_10026DD20)
    {
      v31 = "NO";
      v32 = "YES";
      if (v14 <= 1)
        v33 = "NO";
      else
        v33 = "YES";
      if (a2 && *a2)
        v31 = "YES";
      if (a3)
      {
        if (*a3)
          v34 = "YES";
        else
          v34 = "NO";
      }
      else
      {
        v34 = "NO";
      }
      if ((v13 & 0x100) != 0)
        v50 = "YES";
      else
        v50 = "NO";
      v51 = 0.0;
      v52 = 0.0;
      if (DWORD1(v70[0]))
        v52 = (double)SLODWORD(v70[0]) / (double)SDWORD1(v70[0]) * 100.0;
      v53 = *(unsigned int *)(a1 + 2796);
      v54 = *(unsigned int *)(a1 + 1100);
      v55 = *(unsigned int *)(a1 + 1108);
      v56 = (float)(*(float *)(a1 + 1104) * 100.0);
      if ((v13 & 0x10000) != 0)
        v57 = "YES";
      else
        v57 = "NO";
      if (HIDWORD(v70[1]) && SHIDWORD(v70[1]) > SLODWORD(v70[2]))
        v51 = (double)(HIDWORD(v70[1]) - LODWORD(v70[2])) / (double)SHIDWORD(v70[1]) * 100.0;
      v58 = (float)(*(float *)(a1 + 1248) * 100.0);
      if ((v13 & 0x1000000) != 0)
        v59 = "YES";
      else
        v59 = "NO";
      if ((v13 & 1) != 0)
        v60 = "YES";
      else
        v60 = "NO";
      if (v8)
        v61 = "YES";
      else
        v61 = "NO";
      if (!v69)
        v32 = "NO";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LastRSSI:%d FastDisconnect:%s WaitForRoam:%s UserWalkout:%s TxPerMet:%s [TxPer: %.1f%%, %d, %d, %d, (%d, %d, %.1f%%)] BeaconPerMet:%s [BcnPer: %.1f%% (%d, %d, %.1f%%)] FwTxPerMet:%s [%d, %d] TDRecommended:%s RoamSuppressed:%s aggressiveTD:%s", "__WiFiLQAMgrShouldPerformFastDisconnect", v53, v33, v31, v34, v50, *(_QWORD *)&v52, DWORD1(v70[0]), LODWORD(v70[0]), DWORD2(v70[0]), v54, v55, *(_QWORD *)&v56,
        v57,
        *(_QWORD *)&v51,
        HIDWORD(v70[1]),
        LODWORD(v70[2]),
        *(_QWORD *)&v58,
        v59,
        DWORD1(v70[1]),
        LODWORD(v70[1]),
        v60,
        v61,
        v32,
        v66,
        v67,
        v68);
    }
  }
  else if (qword_10026DD20)
  {
    v27 = "NO";
    v28 = "YES";
    if (v14 <= 1)
      v29 = "NO";
    else
      v29 = "YES";
    if (a2 && *a2)
      v27 = "YES";
    if (a3)
    {
      if (*a3)
        v30 = "YES";
      else
        v30 = "NO";
    }
    else
    {
      v30 = "NO";
    }
    if ((v13 & 0x100) != 0)
      v35 = "YES";
    else
      v35 = "NO";
    v36 = 0.0;
    v37 = 0.0;
    if (DWORD1(v70[0]))
      v37 = (double)SLODWORD(v70[0]) / (double)SDWORD1(v70[0]) * 100.0;
    v38 = *(unsigned int *)(a1 + 2796);
    v39 = *(unsigned int *)(a1 + 936);
    v40 = *(unsigned int *)(a1 + 944);
    v41 = (float)(*(float *)(a1 + 940) * 100.0);
    v42 = *(unsigned int *)(a1 + 952);
    v43 = *(unsigned int *)(a1 + 960);
    v44 = (float)(*(float *)(a1 + 956) * 100.0);
    if ((v13 & 0x10000) != 0)
      v45 = "YES";
    else
      v45 = "NO";
    if (HIDWORD(v70[1]) && SHIDWORD(v70[1]) > SLODWORD(v70[2]))
      v36 = (double)(HIDWORD(v70[1]) - LODWORD(v70[2])) / (double)SHIDWORD(v70[1]) * 100.0;
    v46 = (float)(*(float *)(a1 + 1084) * 100.0);
    if ((v13 & 0x1000000) != 0)
      v47 = "YES";
    else
      v47 = "NO";
    if ((v13 & 1) != 0)
      v48 = "YES";
    else
      v48 = "NO";
    if (v8)
      v49 = "YES";
    else
      v49 = "NO";
    if (!v69)
      v28 = "NO";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LastRSSI:%d FastDisconnect:%s WaitForRoam:%s UserWalkout:%s TxPerMet:%s [TxPer: %.1f%%, %d, %d, %d, (%d, %d, %.1f%%), (%d, %d, %.1f%%)] BeaconPerMet:%s [BcnPer: %.1f%% (%d, %d, %.1f%%)] FwTxPerMet:%s [%d, %d] TDRecommended:%s RoamSuppressed:%s aggressiveTD:%s", "__WiFiLQAMgrShouldPerformFastDisconnect", v38, v29, v27, v30, v35, *(_QWORD *)&v37, DWORD1(v70[0]), LODWORD(v70[0]), DWORD2(v70[0]), v39, v40, *(_QWORD *)&v41,
      v42,
      v43,
      *(_QWORD *)&v44,
      v45,
      *(_QWORD *)&v36,
      HIDWORD(v70[1]),
      LODWORD(v70[2]),
      *(_QWORD *)&v46,
      v47,
      DWORD1(v70[1]),
      LODWORD(v70[1]),
      v48,
      v49,
      v28);
  }
  objc_autoreleasePoolPop(v26);
  return v14 > 1;
}

uint64_t sub_10004C520(uint64_t a1)
{
  void *v2;
  __CFDictionary *v3;
  uint64_t v4;
  __CFDictionary *Mutable;
  __CFUserNotification *v6;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoop *Main;
  void *v9;
  const void *v10;
  SInt32 error;

  if (!a1)
    return 1;
  error = -1431655766;
  if (*(_QWORD *)(a1 + 1288))
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Notification already pending. Ignoring it", "__WiFiLQAMgrCheckUsrInput");
    objc_autoreleasePoolPop(v2);
    v3 = 0;
    goto LABEL_6;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v3 = Mutable;
  if (!Mutable)
  {
LABEL_6:
    v4 = 1;
    goto LABEL_16;
  }
  CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, CFSTR("WiFi Trigger Disconnect"));
  CFDictionarySetValue(v3, kCFUserNotificationDefaultButtonTitleKey, CFSTR("Accept"));
  CFDictionarySetValue(v3, kCFUserNotificationAlternateButtonTitleKey, CFSTR("Tap To Radar"));
  if (SBUserNotificationDismissOnLock)
  {
    CFDictionarySetValue(v3, SBUserNotificationDismissOnLock, kCFBooleanTrue);
    CFDictionarySetValue(v3, SBUserNotificationAlertMessageDelimiterKey, &stru_100238178);
  }
  v6 = CFUserNotificationCreate(kCFAllocatorDefault, 10.0, 0, &error, v3);
  *(_QWORD *)(a1 + 1288) = v6;
  v4 = 1;
  if (!error && v6)
  {
    RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v6, (CFUserNotificationCallBack)sub_10004C8F0, 0);
    *(_QWORD *)(a1 + 1272) = RunLoopSource;
    if (!RunLoopSource)
      goto LABEL_17;
    Main = CFRunLoopGetMain();
    CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(a1 + 1272), kCFRunLoopDefaultMode);
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Notification created", "__WiFiLQAMgrCheckUsrInput");
    objc_autoreleasePoolPop(v9);
    v4 = 0;
  }
LABEL_16:
  if (!*(_QWORD *)(a1 + 1272))
  {
LABEL_17:
    v10 = *(const void **)(a1 + 1288);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 1288) = 0;
    }
  }
  if (v3)
    CFRelease(v3);
  return v4;
}

uint64_t sub_10004C740(uint64_t a1)
{
  uint64_t result;
  void *v3;

  if (!a1)
    return 255;
  result = *(unsigned __int8 *)(a1 + 2752);
  if (result >= 0xA)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid curRecord %d", "__WiFiLQAMgrGetCurrentLQAMetricsRecordIdx", *(unsigned __int8 *)(a1 + 2752));
    goto LABEL_10;
  }
  if (!*(_BYTE *)(a1 + 2753))
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: curRecord %d is not busy", "__WiFiLQAMgrGetCurrentLQAMetricsRecordIdx", *(unsigned __int8 *)(a1 + 2752));
LABEL_10:
    objc_autoreleasePoolPop(v3);
    return 255;
  }
  return result;
}

void sub_10004C800(_BYTE *a1, int a2)
{
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    if (a1[2753])
    {
      if (a2 != 255)
      {
        a1[2752] = a1[2752] + 1 - 10 * ((6554 * (a1[2752] + 1)) >> 16);
        ++a1[1304];
        a1[2753] = 0;
        return;
      }
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: recordIdx invalid", "__WiFiLQAMgrFinishCurLQAMetricsRecord");
      v4 = v5;
    }
    else
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: curRecord %d is not busy", "__WiFiLQAMgrFinishCurLQAMetricsRecord", a1[2752]);
      v4 = v3;
    }
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10004C8F0(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  if (qword_10026D5A0)
  {
    v2 = *(NSObject **)(qword_10026D5A0 + 1280);
    if (v2)
    {
      v3[0] = _NSConcreteStackBlock;
      v3[1] = 3221225472;
      v3[2] = sub_10004C954;
      v3[3] = &unk_10022EF88;
      v3[4] = qword_10026D5A0;
      v3[5] = a2;
      dispatch_async(v2, v3);
    }
  }
}

void sub_10004C954(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  double Current;
  uint64_t v13;
  double v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  __CFRunLoop *Main;
  const void *v25;
  const void *v26;
  void *v27;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_10004C740(v2);
  if (v3 != 255)
  {
    v4 = v3;
    sub_10004C800(*(_BYTE **)(a1 + 32), v3);
    v5 = v2 + 144 * v4;
    v6 = *(unsigned __int8 *)(v5 + 1349);
    v7 = *(unsigned __int8 *)(v5 + 1352);
    v8 = *(unsigned __int8 *)(v5 + 1353);
    v9 = *(unsigned __int8 *)(v5 + 1354);
    v10 = *(unsigned __int8 *)(v5 + 1355);
    v11 = *(unsigned __int8 *)(v5 + 1350);
    Current = CFAbsoluteTimeGetCurrent();
    v13 = *(_QWORD *)(a1 + 32);
    v14 = 0.0;
    if (*(_DWORD *)(v13 + 2760) == 1)
      v14 = Current - *(double *)(v13 + 2768);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v16 = v2 + 144 * v4;
      v17 = v6 | (2 * v7) | (4 * v8) | (8 * v9) | (16 * v10) | (v11 << 6);
      v18 = v15;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: TrgDiscStatus %u [Rssi %d TxFrms %ld TxFail %ld TxRet %ld fwFrms %ld fwFail %ld fwRtry %ld RxFrms %ld BcnSch %ld BcnRx %ld PrSent %ld PrFail %ld Awd %ld initPr %ld UnGw %f FgApp %ld SympScore %ld UsrInput %ld]", "__WiFiLQAMgrTrgDiscUsrNotificationCallback_block_invoke", v17, *(char *)(v16 + 1348), *(unsigned int *)(v5 + 1312), *(unsigned int *)(v16 + 1316), *(unsigned int *)(v16 + 1320), *(unsigned int *)(v16 + 1332), *(unsigned int *)(v16 + 1336), *(unsigned int *)(v16 + 1340), *(unsigned int *)(v16 + 1344), *(unsigned int *)(v16 + 1324), *(unsigned int *)(v16 + 1328), 0, 0,
        *(unsigned __int8 *)(v16 + 1364),
        0,
        *(_QWORD *)&v14,
        *(unsigned int *)(v16 + 1356),
        *(unsigned int *)(v16 + 1360),
        *(unsigned __int8 *)(v16 + 1351));
      v15 = v18;
    }
    objc_autoreleasePoolPop(v15);
  }
  v19 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v19 + 1288))
  {
    if (*(_DWORD *)(v19 + 20))
    {
      if (*(_BYTE *)(v19 + 644))
      {
        v20 = *(_QWORD *)(a1 + 40) & 3;
        v21 = objc_autoreleasePoolPush();
        if (v20 == 1)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UserCancelled Trigger Disconnect", "__WiFiLQAMgrTrgDiscUsrNotificationCallback_block_invoke");
          objc_autoreleasePoolPop(v21);
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 1296) = 1;
        }
        else
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: User Response %d", "__WiFiLQAMgrTrgDiscUsrNotificationCallback_block_invoke", *(_DWORD *)(a1 + 40) & 3);
          objc_autoreleasePoolPop(v21);
          v22 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)(v22 + 2828) = 11;
          sub_1000423C8(v22, 0);
        }
        goto LABEL_17;
      }
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: AskTo TrigDisc is FALSE", "__WiFiLQAMgrTrgDiscUsrNotificationCallback_block_invoke");
    }
    else
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: TDUsr Callback in UnassociatedState", "__WiFiLQAMgrTrgDiscUsrNotificationCallback_block_invoke");
    }
    objc_autoreleasePoolPop(v27);
  }
LABEL_17:
  v23 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v23 + 1272))
  {
    Main = CFRunLoopGetMain();
    CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(*(_QWORD *)(a1 + 32) + 1272), kCFRunLoopDefaultMode);
    v23 = *(_QWORD *)(a1 + 32);
  }
  v25 = *(const void **)(v23 + 1288);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1288) = 0;
    v23 = *(_QWORD *)(a1 + 32);
  }
  v26 = *(const void **)(v23 + 1272);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1272) = 0;
    v23 = *(_QWORD *)(a1 + 32);
  }
  *(_BYTE *)(v23 + 161) = 0;
}

void sub_10004CC50(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  const __CFString *v5;
  __CFDictionary *v6;
  CFAbsoluteTime Current;
  double v8;
  double v9;
  double v10;
  double v11;
  void *v12;
  NSObject *v13;
  dispatch_time_t v14;
  __CFDictionary *Mutable;
  CFNumberRef v17;
  CFNumberRef v18;
  __CFArray *v19;
  void *v20;
  uint64_t v21;
  const __CFString *v22;
  NSObject *v23;
  void *v24;
  uint64_t v25;
  const __CFString *v26;
  void *v27;
  const char *v28;
  void *v29;
  NSObject *v30;
  dispatch_time_t v31;
  void *v32;
  void *v33;
  uint64_t valuePtr;

  if (!*(_BYTE *)(a1 + 640))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr is disabled", "__WiFiLQAMgrDoActiveProbe");
    goto LABEL_65;
  }
  v2 = *(_DWORD *)(a1 + 20);
  switch(v2)
  {
    case 0:
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActProbe Callback in UnassociatedState", "__WiFiLQAMgrDoActiveProbe");
      goto LABEL_65;
    case 1:
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActProbe Callback in GoodLinkState", "__WiFiLQAMgrDoActiveProbe");
      goto LABEL_65;
    case 3:
      v32 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActProbe ongoing", "__WiFiLQAMgrDoActiveProbe");
LABEL_65:
      objc_autoreleasePoolPop(v32);
      return;
  }
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = *(int *)(a1 + 20);
    if (v4 > 4)
      v5 = CFSTR("Bogus");
    else
      v5 = *(&off_10022F1A0 + v4);
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: ActProbeTimer Credits: %d lqaState: %@", "__WiFiLQAMgrDoActiveProbe", *(unsigned int *)(a1 + 488), v5);
  }
  objc_autoreleasePoolPop(v3);
  v6 = *(__CFDictionary **)(a1 + 376);
  Current = CFAbsoluteTimeGetCurrent();
  v8 = *(double *)(a1 + 368);
  v9 = Current - v8;
  if (v8 == 0.0)
    v10 = 0.0;
  else
    v10 = v9;
  if (*(_BYTE *)(a1 + 392))
    v11 = 3.0;
  else
    v11 = 10.0;
  if (*(_DWORD *)(a1 + 20) > 2u)
  {
    v13 = *(NSObject **)(a1 + 544);
    v14 = -1;
LABEL_32:
    dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);
    return;
  }
  if (*(_BYTE *)(a1 + 356))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActProbe ongoing for %f many seconds", "__WiFiLQAMgrDoActiveProbe", *(_QWORD *)&v10);
    objc_autoreleasePoolPop(v12);
LABEL_31:
    v23 = *(NSObject **)(a1 + 336);
    v14 = dispatch_time(0, (uint64_t)(v11 * 1000000000.0));
    v13 = v23;
    goto LABEL_32;
  }
  if (v10 != 0.0 && v11 > v10)
    goto LABEL_31;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  valuePtr = *(unsigned int *)(a1 + 344);
  v17 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  v18 = v17;
  if (valuePtr && v17)
  {
    v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v19, v18);
    CFDictionarySetValue(Mutable, CFSTR("kWiFiLqaMgrProbeSize"), v19);
    *(_DWORD *)(a1 + 20) = 3;
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v21 = *(int *)(a1 + 20);
      if (v21 > 4)
        v22 = CFSTR("Bogus");
      else
        v22 = *(&off_10022F1A0 + v21);
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v22);
    }
    objc_autoreleasePoolPop(v20);
    if (sub_100042AB8(a1, Mutable, v6, (uint64_t)sub_10004D188, a1))
    {
      *(_DWORD *)(a1 + 20) = 2;
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v25 = *(int *)(a1 + 20);
        if (v25 > 4)
          v26 = CFSTR("Bogus");
        else
          v26 = *(&off_10022F1A0 + v25);
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v26);
      }
      objc_autoreleasePoolPop(v24);
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ActProbeEnqueue Failed, reverting to BadLinkState", "__WiFiLQAMgrDoActiveProbe");
      objc_autoreleasePoolPop(v29);
      v30 = *(NSObject **)(a1 + 336);
      v31 = dispatch_time(0, (uint64_t)(v11 * 1000000000.0));
      dispatch_source_set_timer(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0);
      if (!Mutable)
        goto LABEL_52;
    }
    else
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (*(_BYTE *)(a1 + 392))
          v28 = " for auto leave evaluation.";
        else
          v28 = ".";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ActProbeEnqueue Enqueued%s", "__WiFiLQAMgrDoActiveProbe", v28);
      }
      objc_autoreleasePoolPop(v27);
      *(_BYTE *)(a1 + 356) = 1;
      *(_DWORD *)(a1 + 488) = 0;
      *(CFAbsoluteTime *)(a1 + 368) = CFAbsoluteTimeGetCurrent();
      *(_OWORD *)(a1 + 456) = 0u;
      *(_OWORD *)(a1 + 472) = 0u;
      if (!Mutable)
        goto LABEL_52;
    }
  }
  else
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Null probe size or Null probeSizeRef", "__WiFiLQAMgrDoActiveProbe");
    objc_autoreleasePoolPop(v33);
    v19 = 0;
    if (!Mutable)
      goto LABEL_52;
  }
  CFRelease(Mutable);
LABEL_52:
  if (v18)
    CFRelease(v18);
  if (v19)
    CFRelease(v19);
}

void sub_10004D188(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFNumber *v9;
  int64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  const __CFString *v14;
  void *v15;
  NSObject *v16;
  dispatch_time_t v17;
  void *v18;
  NSObject *v19;
  dispatch_time_t v20;
  uint64_t v21;
  const __CFString *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t valuePtr;

  v25 = 0;
  valuePtr = 0;
  if (a4 && *(_BYTE *)(a4 + 640))
  {
    *(_BYTE *)(a4 + 356) = 0;
    ++*(_QWORD *)(a4 + 360);
    if (a3)
    {
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Active Probe gave an error %ld", "__WiFiLQAMgrActiveProbeResultCallBack", a3);
    }
    else if (theArray)
    {
      if (CFArrayGetCount(theArray))
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesSent"));
        if (Value)
          CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
        v9 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesFail"));
        if (v9)
          CFNumberGetValue(v9, kCFNumberCFIndexType, &v25);
        if (*(_BYTE *)(a4 + 392))
          v10 = 3000000000;
        else
          v10 = 10000000000;
        if (*(_DWORD *)(a4 + 20) != 3)
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v13 = *(int *)(a4 + 20);
            if (v13 > 4)
              v14 = CFSTR("Bogus");
            else
              v14 = *(&off_10022F1A0 + v13);
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Called from lqaState: %@", "__WiFiLQAMgrActiveProbeResultCallBack", v14);
          }
          goto LABEL_31;
        }
        v11 = valuePtr;
        if (valuePtr)
        {
          *(_DWORD *)(a4 + 2828) = 9;
          if (sub_100043F7C(a4, v11, v25))
          {
            sub_1000423C8(a4, 0);
            return;
          }
          v19 = *(NSObject **)(a4 + 336);
          v20 = dispatch_time(0, v10);
          dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0);
          *(_DWORD *)(a4 + 20) = 2;
          v12 = objc_autoreleasePoolPush();
          v18 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_31;
        }
        else
        {
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQA mgr No Probes sent\n", "__WiFiLQAMgrActiveProbeResultCallBack");
          objc_autoreleasePoolPop(v15);
          v16 = *(NSObject **)(a4 + 336);
          v17 = dispatch_time(0, v10);
          dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
          *(_DWORD *)(a4 + 20) = 2;
          v12 = objc_autoreleasePoolPush();
          v18 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_31;
        }
        v21 = *(int *)(a4 + 20);
        if (v21 > 4)
          v22 = CFSTR("Bogus");
        else
          v22 = *(&off_10022F1A0 + v21);
        objc_msgSend(v18, "WFLog:message:", 3, "%s: %@", "__WiFiLQAMgrSetState", v22);
LABEL_31:
        objc_autoreleasePoolPop(v12);
        return;
      }
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: zero elements in probeResultRef", "__WiFiLQAMgrActiveProbeResultCallBack", v24);
    }
    else
    {
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeResultRef is null", "__WiFiLQAMgrActiveProbeResultCallBack", v24);
    }
    objc_autoreleasePoolPop(v23);
  }
}

void sub_10004D4A4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  const void *v5;
  CFAbsoluteTime Current;
  void *v7;
  const __CFDictionary *v8;
  const __CFNumber *v9;
  const __CFArray *v10;
  const void *v11;
  void *v12;
  CFMutableArrayRef Mutable;
  __CFArray *v14;
  CFMutableDictionaryRef v15;
  __CFDictionary *v16;
  CFNumberRef v17;
  CFIndex v18;
  const void *ValueAtIndex;
  void *v20;
  double v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  const __CFBoolean *v26;
  double v27;
  int v28;
  double v29;
  double v30;
  double v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  CFMutableDictionaryRef v35;
  __CFDictionary *v36;
  CFNumberRef v37;
  CFNumberRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  void *v45;
  NSObject *v46;
  void *v47;
  void *v48;
  void *v49;
  CFNumberRef v50;
  void *context;
  uint64_t v52;
  void *value;
  const __CFArray *v54;
  __CFArray *theArray;
  void *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  CFTypeRef cf;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t valuePtr;

  v1 = a1;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
    || (v2 = *(_QWORD *)(a1 + 40),
        ++*(_DWORD *)(v2 + 328),
        CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 320), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)), !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24)))
  {
    v3 = *(const void **)(*(_QWORD *)(v1 + 40) + 312);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(*(_QWORD *)(v1 + 40) + 312) = 0;
    }
  }
  v4 = *(_QWORD *)(v1 + 40);
  if (!*(_QWORD *)(v4 + 312) && CFArrayGetCount(*(CFArrayRef *)(v4 + 320)))
  {
    *(_QWORD *)(*(_QWORD *)(v1 + 40) + 312) = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)(v1 + 40) + 320), 0);
    CFRetain(*(CFTypeRef *)(*(_QWORD *)(v1 + 40) + 312));
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(_QWORD *)(v1 + 40) + 320), 0);
    Current = CFAbsoluteTimeGetCurrent();
    v7 = *(void **)(v1 + 40);
    *((CFAbsoluteTime *)v7 + 38) = Current;
    v66 = 0;
    valuePtr = 0;
    v64 = 0;
    v65 = 0;
    cf = 0;
    v63 = 1;
    v60 = 0;
    v61 = 0;
    v59 = 0;
    v8 = (const __CFDictionary *)*((_QWORD *)v7 + 39);
    if (v8)
    {
      v9 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)v7 + 39), CFSTR("kWiFiLqaMgrNumProbes"));
      v10 = (const __CFArray *)CFDictionaryGetValue(v8, CFSTR("kWiFiLqaMgrProbeSize"));
      value = (void *)CFDictionaryGetValue(v8, CFSTR("kWiFiLqaMgrProbeTimeoutSecs"));
      v11 = CFDictionaryGetValue(v8, CFSTR("kWiFiLqaMgrIpv4Addr"));
      v12 = (void *)CFDictionaryGetValue(v8, CFSTR("kWiFiLqaMgrProbeTrafficClass"));
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        v14 = Mutable;
        if (v9 && v10 && CFArrayGetCount(v10) && value && v11)
        {
          v56 = v12;
          CFNumberGetValue(v9, kCFNumberCFIndexType, &valuePtr);
          v15 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v15)
          {
            v16 = v15;
            v17 = CFNumberCreate(0, kCFNumberCFIndexType, &v63);
            if (v17)
            {
              theArray = v14;
              context = v7;
              v52 = v1;
              v50 = v17;
              CFDictionaryAddValue(v16, CFSTR("kCFNetDiagnosticPingOptionPacketCount"), v17);
              CFDictionaryAddValue(v16, CFSTR("kCFNetDiagnosticPingOptionTimeout"), value);
              if (v56)
                CFDictionaryAddValue(v16, CFSTR("kCFNetDiagnosticPingOptionTrafficClass"), v56);
              v57 = 0;
              v18 = 0;
              v54 = v10;
              do
              {
                if (v18 >= CFArrayGetCount(v10))
                  break;
                ValueAtIndex = CFArrayGetValueAtIndex(v10, v18);
                CFDictionarySetValue(v16, CFSTR("kCFNetDiagnosticPingOptionDataLength"), ValueAtIndex);
                v20 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "Triggered probe to %@ with %@ bytes and %ld tries with timeout as %@ secs", v11, ValueAtIndex, valuePtr, value);
                v58 = (void *)ValueAtIndex;
                objc_autoreleasePoolPop(v20);
                v65 = 0;
                v66 = 0;
                v21 = 0.0;
                if (valuePtr < 1)
                {
                  v33 = 0;
                  v25 = 0.0;
                  v24 = 0.0;
                  v23 = 0.0;
                }
                else
                {
                  v22 = 0;
                  v23 = 0.0;
                  v24 = 0.0;
                  v25 = 0.0;
                  while (1)
                  {
                    v26 = (const __CFBoolean *)CFDictionaryGetValue(v8, CFSTR("kWiFiLqaMgrIgnoreProbe"));
                    if (v26)
                    {
                      if (CFBooleanGetValue(v26))
                        break;
                    }
                    v27 = CFAbsoluteTimeGetCurrent();
                    v28 = CFNetDiagnosticPingWithOptions(v11, v16, &cf);
                    v29 = CFAbsoluteTimeGetCurrent();
                    if (v28)
                    {
                      v30 = v29 - v27;
                      if (v25 > v30)
                        v31 = v30;
                      else
                        v31 = v25;
                      if (v25 == 0.0)
                        v25 = v30;
                      else
                        v25 = v31;
                      v32 = v30;
                      if (v24 != 0.0)
                      {
                        v32 = v24;
                        if (v24 < v30)
                          v32 = v30;
                      }
                      v23 = v23 + v30;
                      v24 = v32;
                    }
                    if (cf)
                    {
                      CFRelease(cf);
                      cf = 0;
                    }
                    v33 = ++v66;
                    if (!v28)
                      ++v65;
                    if (++v22 >= valuePtr)
                      goto LABEL_48;
                  }
                  v64 = 2;
                  v33 = v66;
                  v57 = 2;
                }
LABEL_48:
                v34 = v33 - v65;
                if (v34)
                  v21 = v23 / (double)v34;
                v35 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (!v35)
                {
                  v47 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeResult is null", "__WiFiLQAMgrDoDiagnosticProbe");
                  goto LABEL_95;
                }
                v36 = v35;
                v37 = CFNumberCreate(0, kCFNumberCFIndexType, &v66);
                v38 = CFNumberCreate(0, kCFNumberCFIndexType, &v65);
                v61 = (uint64_t)(v25 * 1000.0);
                v59 = (uint64_t)(v21 * 1000.0);
                v60 = (uint64_t)(v24 * 1000.0);
                v39 = CFNumberCreate(0, kCFNumberCFIndexType, &v59);
                v40 = CFNumberCreate(0, kCFNumberCFIndexType, &v61);
                v41 = CFNumberCreate(0, kCFNumberCFIndexType, &v60);
                if (v37)
                  CFDictionarySetValue(v36, CFSTR("kWiFiLqaMgrNumProbesSent"), v37);
                if (v38)
                  CFDictionarySetValue(v36, CFSTR("kWiFiLqaMgrNumProbesFail"), v38);
                if (v39)
                  CFDictionarySetValue(v36, CFSTR("kWiFiLqaMgrAverageRTT"), v39);
                if (v40)
                  CFDictionarySetValue(v36, CFSTR("kWiFiLqaMgrMinimumRTT"), v40);
                if (v41)
                  CFDictionarySetValue(v36, CFSTR("kWiFiLqaMgrMaximumRTT"), v41);
                if (v56)
                  CFDictionaryAddValue(v36, CFSTR("kWiFiLqaMgrProbeTrafficClass"), v56);
                if (v58)
                  CFDictionaryAddValue(v36, CFSTR("kWiFiLqaMgrProbeSize"), v58);
                CFArrayAppendValue(theArray, v36);
                if (v37)
                  CFRelease(v37);
                if (v38)
                  CFRelease(v38);
                if (v39)
                  CFRelease(v39);
                v10 = v54;
                if (v40)
                  CFRelease(v40);
                if (v41)
                  CFRelease(v41);
                CFRelease(v36);
                ++v18;
              }
              while (v57 != 2);
              v14 = theArray;
              CFDictionaryAddValue(v8, CFSTR("kWiFiLqaMgrProbeStats"), theArray);
              v42 = CFNumberCreate(0, kCFNumberCFIndexType, &v64);
              v1 = v52;
              if (v42)
              {
                v43 = v42;
                CFDictionaryAddValue(v8, CFSTR("kWiFiLqaMgrError"), v42);
                v7 = context;
                goto LABEL_78;
              }
              v47 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: errRef is null", "__WiFiLQAMgrDoDiagnosticProbe");
LABEL_95:
              objc_autoreleasePoolPop(v47);
              v43 = 0;
              v7 = context;
              v1 = v52;
              v14 = theArray;
LABEL_78:
              v44 = v50;
            }
            else
            {
              v49 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: numProbes is null", "__WiFiLQAMgrDoDiagnosticProbe");
              objc_autoreleasePoolPop(v49);
              v44 = 0;
              v43 = 0;
            }
            goto LABEL_83;
          }
          v45 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Probe Options is null", "__WiFiLQAMgrDoDiagnosticProbe");
        }
        else
        {
          v64 = 1;
          v45 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Probe failed due to missing params", "__WiFiLQAMgrDoDiagnosticProbe");
        }
        objc_autoreleasePoolPop(v45);
LABEL_82:
        v44 = 0;
        v43 = 0;
        v16 = 0;
LABEL_83:
        v46 = *((_QWORD *)v7 + 160);
        if (v46)
          dispatch_async_f(v46, v7, (dispatch_function_t)sub_10004DCFC);
        if (v16)
          CFRelease(v16);
        if (v44)
          CFRelease(v44);
        if (v43)
          CFRelease(v43);
        if (v14)
          CFRelease(v14);
        goto LABEL_6;
      }
      v48 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: resultArrRef is null", "__WiFiLQAMgrDoDiagnosticProbe");
    }
    else
    {
      v48 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Probe Context is null", "__WiFiLQAMgrDoDiagnosticProbe");
    }
    objc_autoreleasePoolPop(v48);
    v14 = 0;
    goto LABEL_82;
  }
LABEL_6:
  v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = 0;
  }
  CFRelease(*(CFTypeRef *)(v1 + 40));
}

void sub_10004DCFC(uint64_t a1)
{
  double Current;
  double v2;
  NSObject *v3;
  const __CFDictionary *v4;
  const __CFNumber *Value;
  double v6;
  double v7;
  const __CFArray *v8;
  void *v9;
  const char *v10;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  void *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  const void *v21;
  const void *v22;
  _QWORD block[6];
  uint64_t valuePtr;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(const void *, const __CFArray *, uint64_t, uint64_t);
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;

  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 0;
  v32 = 0;
  v30 = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  v26 = 0;
  v27 = 0;
  valuePtr = 0;
  Current = CFAbsoluteTimeGetCurrent();
  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrDiagProbeResultCallBack");
    goto LABEL_45;
  }
  v2 = Current;
  v3 = *(NSObject **)(a1 + 296);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004E104;
  block[3] = &unk_10022F160;
  block[4] = &v33;
  block[5] = a1;
  dispatch_sync(v3, block);
  v4 = (const __CFDictionary *)v34[3];
  if (!v4)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: CurrentProbe is NULL", "__WiFiLQAMgrDiagProbeResultCallBack");
    goto LABEL_45;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("kWiFiLqaMgrError"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
  v6 = *(double *)(a1 + 304);
  if (v6 == 0.0)
    v7 = 0.0;
  else
    v7 = v2 - v6;
  v8 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v34[3], CFSTR("kWiFiLqaMgrProbeStats"));
  v9 = objc_autoreleasePoolPush();
  if (!v8)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: probeResultsRef is NULL", "__WiFiLQAMgrDiagProbeResultCallBack");
LABEL_45:
    objc_autoreleasePoolPop(v9);
    goto LABEL_36;
  }
  if (qword_10026DD20)
  {
    v10 = "";
    if (!valuePtr)
      v10 = "no ";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "-------- DiagProbe finished in %f secs with %serror (%ld) ---------", *(_QWORD *)&v7, v10, valuePtr);
  }
  objc_autoreleasePoolPop(v9);
  for (i = 0; i < CFArrayGetCount(v8); ++i)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, i);
    v13 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesSent"));
    if (v13)
      CFNumberGetValue(v13, kCFNumberCFIndexType, &v30);
    v14 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrNumProbesFail"));
    if (v14)
      CFNumberGetValue(v14, kCFNumberCFIndexType, &v29);
    v15 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrAverageRTT"));
    if (v15)
      CFNumberGetValue(v15, kCFNumberCFIndexType, &v28);
    v16 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrMinimumRTT"));
    if (v16)
      CFNumberGetValue(v16, kCFNumberCFIndexType, &v27);
    v17 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kWiFiLqaMgrMaximumRTT"));
    if (v17)
      CFNumberGetValue(v17, kCFNumberCFIndexType, &v26);
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "Probes Sent %ld, Fail %ld Error %ld avgRtt %ld minRtt %ld maxRtt %ld", v30, v29, valuePtr, v28, v27, v26);
    objc_autoreleasePoolPop(v18);
  }
  v19 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v34[3], CFSTR("kWiFiLqaMgrDiagCallback"));
  if (v19)
    CFNumberGetValue(v19, kCFNumberCFIndexType, &v32);
  v20 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v34[3], CFSTR("kWiFiLqaMgrDiagCbContext"));
  if (v20)
    CFNumberGetValue(v20, kCFNumberCFIndexType, &v31);
  if (v32 && valuePtr != 2)
  {
    v21 = CFDictionaryGetValue((CFDictionaryRef)v34[3], CFSTR("kWiFiLqaMgrIpv4Addr"));
    v32(v21, v8, valuePtr, v31);
  }
  sub_10004772C(a1, 0);
LABEL_36:
  v22 = (const void *)v34[3];
  if (v22)
  {
    CFRelease(v22);
    v34[3] = 0;
  }
  _Block_object_dispose(&v33, 8);
}

void sub_10004E0E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

CFTypeRef sub_10004E104(uint64_t a1)
{
  CFTypeRef result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 312);
  result = *(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

void sub_10004E12C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8;
  void *v9;
  void *v10;
  const char *v11;
  WiFiUsageMonitor *v12;
  WiFiUsageMonitor *v13;
  CFAbsoluteTime *v14;
  const __CFDate *v15;
  const __CFLocale *v16;
  __CFDateFormatter *v17;
  CFStringRef StringWithDate;
  void *v19;
  void *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  unsigned int v24;
  char v25;
  uint64_t v26;
  int v27;
  NSObject *v28;
  void *v29;
  void *v30;
  const char *v31;

  pthread_mutex_lock(&stru_10026CB48);
  v8 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 2984);
  v9 = objc_autoreleasePoolPush();
  if (v8)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s LQA manager is in closing\n", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke");
    v10 = v9;
    goto LABEL_5;
  }
  if (qword_10026DD20)
  {
    v11 = "failure";
    if (!a2)
      v11 = "success";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s Symptom Fetch Result %s", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke", v11);
  }
  objc_autoreleasePoolPop(v9);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 508) = 0;
  v12 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
  if (!a2)
  {
    if (a3)
    {
      v13 = v12;
      v14 = (CFAbsoluteTime *)(a4 + 48);
      do
      {
        v15 = CFDateCreate(0, *(v14 - 3));
        v16 = CFLocaleCreate(0, CFSTR("en_US"));
        v17 = CFDateFormatterCreate(0, v16, kCFDateFormatterShortStyle, kCFDateFormatterShortStyle);
        StringWithDate = CFDateFormatterCreateStringWithDate(0, v17, v15);
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Symptoms Event (id/class/time/reason/code): %lld %s %@ %s %lld", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke", *((_QWORD *)v14 - 5), *((_QWORD *)v14 - 4), StringWithDate, *((_QWORD *)v14 - 1), *((_QWORD *)v14 - 2));
        objc_autoreleasePoolPop(v19);
        if (*(_QWORD *)v14)
        {
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Symptoms Event Details: %@", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke", *(_QWORD *)v14);
          objc_autoreleasePoolPop(v20);
        }
        switch(*((_QWORD *)v14 - 2))
        {
          case 1:
            v21 = *(_QWORD *)(a1 + 32);
            ++*(_DWORD *)(v21 + 472);
            *(_DWORD *)(v21 + 2828) = 4;
            v22 = 1;
            v23 = 4;
            break;
          case 2:
            v21 = *(_QWORD *)(a1 + 32);
            *(_DWORD *)(v21 + 2828) = 2;
            v22 = 1;
            v23 = 2;
            break;
          case 3:
            v21 = *(_QWORD *)(a1 + 32);
            ++*(_DWORD *)(v21 + 456);
            v22 = 1;
            *(_BYTE *)(v21 + 508) = 1;
            *(_DWORD *)(v21 + 2828) = 3;
            v23 = 1;
            break;
          case 4:
            v21 = *(_QWORD *)(a1 + 32);
            ++*(_DWORD *)(v21 + 476);
            *(_DWORD *)(v21 + 2828) = 5;
            v22 = 1;
            v23 = 5;
            break;
          case 7:
            v21 = *(_QWORD *)(a1 + 32);
            ++*(_DWORD *)(v21 + 484);
            *(_DWORD *)(v21 + 2828) = 6;
            v22 = 1;
            v23 = 3;
            break;
          default:
            v22 = 0;
            v23 = 0;
            v21 = *(_QWORD *)(a1 + 32);
            ++*(_DWORD *)(v21 + 480);
            break;
        }
        v24 = sub_10004C740(v21);
        if (v24 != 255)
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 144 * v24 + 1364) = *((_QWORD *)v14 - 2);
        v25 = v22 ^ 1;
        if (!v13)
          v25 = 1;
        if ((v25 & 1) == 0)
          -[WiFiUsageMonitor addFaultEvent:forInterface:](v13, "addFaultEvent:forInterface:", v23, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
        CFRelease(v15);
        CFRelease(v16);
        CFRelease(v17);
        CFRelease(StringWithDate);
        v14 += 7;
        --a3;
      }
      while (a3);
    }
    v26 = *(_QWORD *)(a1 + 32);
    if (!*(_DWORD *)(v26 + 16))
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 2, "%s: Ignore SymptomFmwk Event in MacStatsBased Mode", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke");
      goto LABEL_56;
    }
    v27 = *(_DWORD *)(v26 + 20);
    switch(v27)
    {
      case 1:
        v29 = objc_autoreleasePoolPush();
        v30 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_56;
        v31 = "%s: Ignore SymptomFmwk Event in GoodLinkState";
        break;
      case 0:
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SymptomFmwk Event in UnassociatedState", "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke");
        goto LABEL_56;
      case 4:
        v29 = objc_autoreleasePoolPush();
        v30 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_56;
        v31 = "%s: Ignore SymptomFmwk Event in RoamwaitState";
        break;
      default:
        if (*(_BYTE *)(v26 + 508))
        {
          if (!*(_BYTE *)(v26 + 645) || !*(_BYTE *)(v26 + 646))
          {
            v28 = *(NSObject **)(v26 + 1280);
            if (v28)
              dispatch_async_f(v28, (void *)v26, (dispatch_function_t)sub_10004E600);
            goto LABEL_6;
          }
          v29 = objc_autoreleasePoolPush();
          v30 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_56;
          v31 = "%s: Ignore SymptomFmwk Event when WiFi-Assist enabled ";
          break;
        }
        v29 = objc_autoreleasePoolPush();
        v30 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v31 = "%s: Ignore SymptomFmwk Event ";
          break;
        }
LABEL_56:
        v10 = v29;
LABEL_5:
        objc_autoreleasePoolPop(v10);
LABEL_6:
        pthread_mutex_unlock(&stru_10026CB48);
        CFRelease(*(CFTypeRef *)(a1 + 32));
        return;
    }
    objc_msgSend(v30, "WFLog:message:", 3, v31, "__WiFiLQAMgrTriggetDisconnectSymptomsCallback_block_invoke");
    goto LABEL_56;
  }
}

void sub_10004E600(uint64_t a1)
{
  int v2;
  void *v3;
  int v4;
  void *v5;
  void *v6;
  void *v7;

  if (!&_managed_event_fetch)
    return;
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQAMgr is NULL", "__WiFiLQAMgrSymptomsDNSFailureInputCallBack");
    goto LABEL_23;
  }
  v2 = *(_DWORD *)(a1 + 20);
  if (v2 == 1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Trigger Disconnect in GoodLinkState", "__WiFiLQAMgrSymptomsDNSFailureInputCallBack");
    goto LABEL_23;
  }
  if (!v2)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Trigger Disconnect in UnassociatedState", "__WiFiLQAMgrSymptomsDNSFailureInputCallBack");
LABEL_23:
    v6 = v5;
LABEL_27:
    objc_autoreleasePoolPop(v6);
    return;
  }
  if (*(int *)(a1 + 2796) >= -84)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Discarding DNS symptom in rssi %d", "__WiFiLQAMgrSymptomsDNSFailureInputCallBack", *(unsigned int *)(a1 + 2796));
    v6 = v7;
    goto LABEL_27;
  }
  ++*(_DWORD *)(a1 + 488);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Symptoms Notification, failcredits %d", "__WiFiLQAMgrSymptomsDNSFailureInputCallBack", *(unsigned int *)(a1 + 488));
  objc_autoreleasePoolPop(v3);
  v4 = *(_DWORD *)(a1 + 16);
  if (v4 == 1)
  {
    if (sub_100043F7C(a1, 0, 0))
      sub_1000423C8(a1, 0);
    v4 = *(_DWORD *)(a1 + 16);
  }
  if (v4 == 2)
    sub_10004CC50(a1);
  if (*(_DWORD *)(a1 + 516) == *(_DWORD *)(a1 + 520))
    sub_1000771D8(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 3);
}

void sub_10004E7EC(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (!*(_BYTE *)(a1 + 2913))
    *(_BYTE *)(a1 + 2913) = objc_msgSend(*(id *)(a1 + 2976), "__configureRapportDiscoveryClient");
  objc_autoreleasePoolPop(v2);
}

void sub_10004E868(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: creating WiFiMaintenanceTaskManager", "+[WiFiMaintenanceTaskManager sharedWiFiMaintenanceTaskManager]_block_invoke");
  objc_autoreleasePoolPop(v1);
  qword_10026D5C8 = objc_alloc_init(WiFiMaintenanceTaskManager);
}

void sub_10004EC7C(uint64_t a1, _xpc_activity_s *a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[5];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager scheduleOrphanedSetsCleanUp]_block_invoke", xpc_activity_get_state(a2));
  objc_autoreleasePoolPop(v4);
  if (objc_msgSend(*(id *)(a1 + 32), "wifiManager"))
  {
    if (objc_msgSend(*(id *)(a1 + 32), "queue"))
    {
      v5 = objc_msgSend(*(id *)(a1 + 32), "queue");
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004EDC8;
      block[3] = &unk_10022EEE8;
      block[4] = *(_QWORD *)(a1 + 32);
      dispatch_async(v5, block);
      return;
    }
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Nil queue", "-[WiFiMaintenanceTaskManager scheduleOrphanedSetsCleanUp]_block_invoke");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null wifi manager ref", "-[WiFiMaintenanceTaskManager scheduleOrphanedSetsCleanUp]_block_invoke");
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10004EDC8(uint64_t a1)
{
  sub_1000A298C((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager"));
}

void sub_10004EFC0(uint64_t a1, _xpc_activity_s *a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[5];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager scheduleOutdatedListEntriesCleanUp]_block_invoke", xpc_activity_get_state(a2));
  objc_autoreleasePoolPop(v4);
  if (objc_msgSend(*(id *)(a1 + 32), "wifiManager"))
  {
    if (objc_msgSend(*(id *)(a1 + 32), "queue"))
    {
      v5 = objc_msgSend(*(id *)(a1 + 32), "queue");
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004F10C;
      block[3] = &unk_10022EEE8;
      block[4] = *(_QWORD *)(a1 + 32);
      dispatch_async(v5, block);
      return;
    }
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Nil queue", "-[WiFiMaintenanceTaskManager scheduleOutdatedListEntriesCleanUp]_block_invoke");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null wifi manager ref", "-[WiFiMaintenanceTaskManager scheduleOutdatedListEntriesCleanUp]_block_invoke");
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10004F10C(uint64_t a1)
{
  sub_1000A33AC((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager"));
  sub_1000A30DC(objc_msgSend(*(id *)(a1 + 32), "wifiManager"));
}

void sub_10004F2E8(uint64_t a1, xpc_activity_t activity)
{
  xpc_activity_state_t state;
  void *v5;
  _BOOL4 v6;
  void *v7;
  id v8;
  id v9;
  _QWORD v10[5];

  state = xpc_activity_get_state(activity);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager schedule3BarsObserver]_block_invoke", state);
  objc_autoreleasePoolPop(v5);
  if (xpc_activity_should_defer(activity))
  {
    v6 = xpc_activity_set_state(activity, 3);
    v7 = objc_autoreleasePoolPush();
    if (v6)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Deferring 3Bars activity", "-[WiFiMaintenanceTaskManager schedule3BarsObserver]_block_invoke");
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to defer the periodic 3Bars xpc activity", "-[WiFiMaintenanceTaskManager schedule3BarsObserver]_block_invoke");
    }
    objc_autoreleasePoolPop(v7);
  }
  else if (state == 2 && xpc_activity_set_state(activity, 4))
  {
    v8 = +[WiFi3BarsObserver sharedWiFi3BarsObserver](WiFi3BarsObserver, "sharedWiFi3BarsObserver");
    v9 = objc_msgSend(*(id *)(a1 + 32), "wifiManager");
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10004F464;
    v10[3] = &unk_10022EEC0;
    v10[4] = activity;
    objc_msgSend(v8, "run3BarsObserver:withActivity:withCompletion:", v9, activity, v10);
  }
}

BOOL sub_10004F464(uint64_t a1)
{
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5);
}

void sub_10004F6B4(uint64_t a1, _xpc_activity_s *a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[5];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager schedulePNLMigration]_block_invoke", xpc_activity_get_state(a2));
  objc_autoreleasePoolPop(v4);
  if (objc_msgSend(*(id *)(a1 + 32), "wifiManager"))
  {
    if (objc_msgSend(*(id *)(a1 + 32), "queue"))
    {
      v5 = objc_msgSend(*(id *)(a1 + 32), "queue");
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004F800;
      block[3] = &unk_10022EEE8;
      block[4] = *(_QWORD *)(a1 + 32);
      dispatch_async(v5, block);
      return;
    }
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Nil queue", "-[WiFiMaintenanceTaskManager schedulePNLMigration]_block_invoke");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null wifi manager ref", "-[WiFiMaintenanceTaskManager schedulePNLMigration]_block_invoke");
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10004F800(uint64_t a1)
{
  sub_1000A380C((uint64_t)objc_msgSend(*(id *)(a1 + 32), "wifiManager"));
}

id sub_10004FA10(uint64_t a1, _xpc_activity_s *a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager scheduleHistoricNetworkPerformanceFeedSync]_block_invoke", xpc_activity_get_state(a2));
  objc_autoreleasePoolPop(v4);
  return objc_msgSend(*(id *)(a1 + 32), "networkPerformanceFeedSync");
}

intptr_t sub_10004FD44(uint64_t a1, void *a2, uint64_t a3)
{
  id v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  int v12;
  int v13;
  uint64_t v14;
  void *i;
  void *v16;
  id v17;
  void *v18;
  unsigned int v19;
  void *v20;
  id v22;
  void *v23;
  const __CFString *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];

  if (!a2 || a3)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed (error = %@ data = %@)", "-[WiFiMaintenanceTaskManager networkPerformanceFeedSync]_block_invoke", a3, a2);
    objc_autoreleasePoolPop(v20);
  }
  else
  {
    v6 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("historical"));
    if (v6)
    {
      v7 = v6;
      v8 = objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", kSymptomAnalyticsServiceNetworkAttachmentHistorical);
      if (v8)
      {
        v9 = v8;
        v27 = 0u;
        v28 = 0u;
        v25 = 0u;
        v26 = 0u;
        v10 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
        if (v10)
        {
          v11 = v10;
          v12 = 0;
          v13 = 0;
          v14 = *(_QWORD *)v26;
          do
          {
            for (i = 0; i != v11; i = (char *)i + 1)
            {
              if (*(_QWORD *)v26 != v14)
                objc_enumerationMutation(v7);
              v16 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * (_QWORD)i);
              if (objc_msgSend(objc_msgSend(v16, "commonPrefixWithString:options:", v9, 0), "isEqualToString:", v9))
              {
                v17 = objc_msgSend(v7, "objectForKey:", v16);
                if (v17)
                {
                  v18 = v17;
                  if (objc_msgSend(v17, "objectForKeyedSubscript:", CFSTR("isKnownGood")))
                  {
                    v19 = objc_msgSend(objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("isKnownGood")), "BOOLValue");
                    v12 += v19;
                    v13 += v19 ^ 1;
                  }
                }
              }
            }
            v11 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
          }
          while (v11);
        }
        else
        {
          v12 = 0;
          v13 = 0;
        }
        if (v12 | v13)
        {
          v22 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
          objc_msgSend(v22, "setObject:forKey:", *(_QWORD *)(a1 + 40), CFSTR("ssid"));
          objc_msgSend(v22, "setObject:forKey:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v12 >= v13), CFSTR("isTCPGood"));
          v23 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
          {
            v24 = CFSTR("bad");
            if (v12 >= v13)
              v24 = CFSTR("good");
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: step 2 - %@ is known %@", "-[WiFiMaintenanceTaskManager networkPerformanceFeedSync]_block_invoke", v9, v24);
          }
          objc_autoreleasePoolPop(v23);
          objc_msgSend(*(id *)(a1 + 48), "addObject:", v22);
        }
      }
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
}

void sub_1000500F0(id a1, OS_xpc_object *a2)
{
  xpc_activity_state_t state;
  void *v4;
  _BOOL4 v5;
  void *v6;
  _QWORD block[5];

  state = xpc_activity_get_state(a2);
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: state %ld", "-[WiFiMaintenanceTaskManager scheduleWCADownloadObserver]_block_invoke", state);
  objc_autoreleasePoolPop(v4);
  if (xpc_activity_should_defer(a2))
  {
    v5 = xpc_activity_set_state(a2, 3);
    v6 = objc_autoreleasePoolPush();
    if (v5)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Deferring WCA download activity", "-[WiFiMaintenanceTaskManager scheduleWCADownloadObserver]_block_invoke");
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to defer the periodic WCA download xpc activity", "-[WiFiMaintenanceTaskManager scheduleWCADownloadObserver]_block_invoke");
    }
    objc_autoreleasePoolPop(v6);
  }
  else if (state == 2 && xpc_activity_set_state(a2, 4))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100050244;
    block[3] = &unk_10022EEE8;
    block[4] = a2;
    dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  }
}

BOOL sub_100050244(uint64_t a1)
{
  objc_msgSend(+[WCAClient sharedClient](WCAClient, "sharedClient"), "fetchWiFiAssetsFromServer");
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5);
}

void sub_10005032C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  void *v4;
  _OWORD v5[4];
  void (*v6)(uint64_t);

  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiCloudSyncInitSyncEngine");
    goto LABEL_10;
  }
  if (!a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null syncEngine", "WiFiCloudSyncInitSyncEngine");
LABEL_10:
    objc_autoreleasePoolPop(v4);
    return;
  }
  v5[2] = *(_OWORD *)&off_10022F298;
  v5[3] = *(_OWORD *)&off_10022F2A8;
  v6 = sub_1000508EC;
  v5[0] = unk_10022F278;
  v5[1] = *(_OWORD *)&off_10022F288;
  WiFiCloudSyncEngineRegisterCallbacksWithQueue(a2, v5, a1, CFSTR("com.apple.wifid"), a3);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiCloudSyncInitSyncEngine");
  objc_autoreleasePoolPop(v3);
}

void sub_100050448(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[6];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "__WiFiCloudSyncAddNetworkToPlist");
  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    v5 = sub_100031A60(a2);
    if (v5)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100050B10;
      block[3] = &unk_10022EF88;
      block[4] = a1;
      block[5] = a2;
      dispatch_sync(v5, block);
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null queue", "__WiFiCloudSyncAddNetworkToPlist");
      objc_autoreleasePoolPop(v6);
    }
  }
}

void sub_100050540(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[6];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "__WiFiCloudSyncRemoveNetworkFromPlist");
  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    v5 = sub_100031A60(a2);
    if (v5)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100050B1C;
      block[3] = &unk_10022EF88;
      block[4] = a1;
      block[5] = a2;
      dispatch_sync(v5, block);
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null queue", "__WiFiCloudSyncRemoveNetworkFromPlist");
      objc_autoreleasePoolPop(v6);
    }
  }
}

CFStringRef sub_100050638(void *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - for network %@", "__WiFiCloudSyncIsPasswordPresent", sub_10002B088(a1));
    objc_autoreleasePoolPop(v2);
    return sub_1000C66B0((CFDictionaryRef *)a1);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networkRef", "__WiFiCloudSyncIsPasswordPresent");
    objc_autoreleasePoolPop(v2);
    return 0;
  }
}

void sub_1000506F8(const void *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - for network %@", "__WiFiCloudSyncSetPasswordSyncState", sub_10002B088(a1));
    objc_autoreleasePoolPop(v2);
    sub_1000C6754();
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networkRef", "__WiFiCloudSyncSetPasswordSyncState");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_1000507B8(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  uint64_t v4;
  void *v6;
  _QWORD block[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "__WiFiCloudSyncCopyAllNetworks");
  objc_autoreleasePoolPop(v2);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  if (a1)
  {
    v3 = sub_100031A60(a1);
    if (v3)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100050B28;
      block[3] = &unk_10022F160;
      block[4] = &v8;
      block[5] = a1;
      dispatch_sync(v3, block);
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null queue", "__WiFiCloudSyncCopyAllNetworks");
      objc_autoreleasePoolPop(v6);
    }
  }
  v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1000508D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000508EC(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@", a1);
  objc_autoreleasePoolPop(v2);
}

void sub_100050940(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null syncEngine", "WiFiCloudSyncAddNetworkToCloud");
    goto LABEL_11;
  }
  v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiCloudSyncAddNetworkToCloud");
LABEL_11:
    objc_autoreleasePoolPop(v5);
    goto LABEL_6;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiCloudSyncAddNetworkToCloud");
  objc_autoreleasePoolPop(v5);
  WiFiCloudSyncEngineAddNetworkToCloud(a1, a2);
LABEL_6:
  objc_autoreleasePoolPop(v4);
}

void sub_100050A28(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null syncEngine", "WiFiCloudSyncRemoveNetworkFromCloud");
    goto LABEL_11;
  }
  v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiCloudSyncRemoveNetworkFromCloud");
LABEL_11:
    objc_autoreleasePoolPop(v5);
    goto LABEL_6;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiCloudSyncRemoveNetworkFromCloud");
  objc_autoreleasePoolPop(v5);
  WiFiCloudSyncEngineRemoveNetworkFromCloud(a1, a2);
LABEL_6:
  objc_autoreleasePoolPop(v4);
}

void sub_100050B10(uint64_t a1)
{
  sub_1001785DC(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void sub_100050B1C(uint64_t a1)
{
  sub_100178774(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

__CFArray *sub_100050B28(uint64_t a1)
{
  __CFArray *result;

  result = sub_100090DF0(*(_QWORD *)(a1 + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_100050B58(const void *a1)
{
  char *v2;
  char *v3;
  void *v4;
  uint64_t v5;

  if (a1)
  {
    if (qword_10026D5D8)
    {
      if (*(_QWORD *)(qword_10026D5D8 + 32))
      {
        v2 = (char *)malloc_type_malloc(0x570uLL, 0x10300402A4F60A2uLL);
        if (!v2)
          return;
        v3 = v2;
        bzero(v2, 0x570uLL);
        *((CFAbsoluteTime *)v3 + 1) = CFAbsoluteTimeGetCurrent();
        *(_QWORD *)v3 = a1;
        CFRetain(a1);
        *((_QWORD *)v3 + 88) = sub_1000C0430((uint64_t)kCFAllocatorDefault, 10, 216);
        *(_OWORD *)(v3 + 488) = 0u;
        *(_OWORD *)(v3 + 504) = 0u;
        *(_OWORD *)(v3 + 520) = 0u;
        *(_OWORD *)(v3 + 536) = 0u;
        *(_OWORD *)(v3 + 552) = 0u;
        *(_OWORD *)(v3 + 568) = 0u;
        *(_OWORD *)(v3 + 584) = 0u;
        *(_OWORD *)(v3 + 600) = 0u;
        *(_OWORD *)(v3 + 616) = 0u;
        *(_OWORD *)(v3 + 632) = 0u;
        *(_OWORD *)(v3 + 648) = 0u;
        *(_OWORD *)(v3 + 664) = 0u;
        *(_OWORD *)(v3 + 680) = 0u;
        *((_QWORD *)v3 + 87) = 0;
        *((_QWORD *)v3 + 89) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
        CFArrayAppendValue(*(CFMutableArrayRef *)(qword_10026D5D8 + 32), v3);
        v4 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s # %ld", "WiFiMetricsManagerRegisterDevice", CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)));
      }
      else
      {
        v4 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceMetricsArray !!", "WiFiMetricsManagerRegisterDevice", v5);
      }
    }
    else
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics !!", "WiFiMetricsManagerRegisterDevice", v5);
    }
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device !!", "WiFiMetricsManagerRegisterDevice", v5);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_100050D34(const void *a1)
{
  const __CFArray *v2;
  _QWORD *ValueAtIndex;
  _QWORD *v4;
  const void *v5;
  const void *v6;
  void *v7;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device !!", "WiFiMetricsManagerUnRegisterDevice");
    goto LABEL_20;
  }
  if (!qword_10026D5D8)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics !!", "WiFiMetricsManagerUnRegisterDevice");
    goto LABEL_20;
  }
  v2 = *(const __CFArray **)(qword_10026D5D8 + 32);
  if (!v2)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceMetricsArray !!", "WiFiMetricsManagerUnRegisterDevice");
LABEL_20:
    objc_autoreleasePoolPop(v7);
    return;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v2, 0);
  if (ValueAtIndex)
  {
    v4 = ValueAtIndex;
    if (*ValueAtIndex)
    {
      if ((const void *)*ValueAtIndex == a1)
        CFRelease(a1);
      v5 = (const void *)v4[88];
      if (v5)
      {
        CFRelease(v5);
        v4[88] = 0;
      }
      v6 = (const void *)v4[89];
      if (v6)
      {
        CFRelease(v6);
        v4[89] = 0;
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(qword_10026D5D8 + 32), 0);
      free(v4);
    }
  }
}

uint64_t sub_100050E94(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  _OWORD *Instance;
  CFAbsoluteTime Current;
  _QWORD *v8;
  char v9;
  uint64_t v10;
  CFMutableArrayRef v11;
  uint64_t v12;
  uint64_t v13;
  void *v15;
  CFArrayCallBacks callBacks;

  v4 = objc_autoreleasePoolPush();
  if (a2 && objc_opt_class(WAClient))
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiMetricsManagerCreate");
    objc_autoreleasePoolPop(v5);
    if (!qword_10026D5E8)
      pthread_once(&stru_10026C928, (void (*)(void))sub_100063794);
    Instance = (_OWORD *)_CFRuntimeCreateInstance(a1);
    qword_10026D5D8 = (uint64_t)Instance;
    if (Instance)
    {
      Instance[4] = 0u;
      Instance[5] = 0u;
      Instance[2] = 0u;
      Instance[3] = 0u;
      Instance[1] = 0u;
      Current = CFAbsoluteTimeGetCurrent();
      v8 = (_QWORD *)qword_10026D5D8;
      *(CFAbsoluteTime *)(qword_10026D5D8 + 24) = Current;
      v8[2] = a2;
      v8[10] = 0;
      v8[11] = 0;
      v9 = MGGetBoolAnswer(CFSTR("cellular-data"));
      v10 = qword_10026D5D8;
      *(_BYTE *)(qword_10026D5D8 + 40) = v9;
      *(_QWORD *)(v10 + 48) = 0;
      dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_10022F2C0);
      memset(&callBacks, 0, sizeof(callBacks));
      v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &callBacks);
      v12 = qword_10026D5D8;
      *(_QWORD *)(qword_10026D5D8 + 32) = v11;
      if (v11)
      {
        *(_QWORD *)(v12 + 72) = qword_10026DD40;
      }
      else
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics->deviceMetricsArray !!", "WiFiMetricsManagerCreate");
        objc_autoreleasePoolPop(v15);
      }
    }
  }
  v13 = qword_10026D5D8;
  objc_autoreleasePoolPop(v4);
  return v13;
}

void sub_100051038(id a1)
{
  sub_1000A5CF4(*(_QWORD *)(qword_10026D5D8 + 16), (_QWORD *)(qword_10026D5D8 + 48), (uint64_t)"WiFiMetricsManagerCreate_block_invoke");
}

void sub_100051054(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4)
{
  void *v8;
  void *v9;
  const char *v10;
  unsigned int v11;
  const __CFString *v12;
  const __CFNumber *v13;
  CFAllocatorRef v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const __CFString *v18;
  const __CFString *v19;
  char *v20;
  size_t v21;
  char v22;
  int v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  void *v28;
  const __CFString *v29;
  const char *v30;
  _BOOL4 v31;
  const char *v32;
  CFIndex Length;
  unsigned int *v34;
  unsigned int *v35;
  const void *v36;
  const __CFDictionary *v37;
  const __CFDictionary *v38;
  const __CFString *Value;
  const __CFString *v40;
  size_t v41;
  char *v42;
  char *v43;
  ether_addr *v44;
  __int16 v45;
  const __CFNumber *v46;
  size_t v47;
  char *v48;
  char *v49;
  ether_addr *v50;
  __int16 v51;
  void *v52;
  void *v53;
  id v54;
  id v55;
  void *v56;
  void *v57;
  uint64_t v58;
  void *v59;
  unsigned int v60;
  const __CFString *theString;
  unsigned int v62;
  const __CFString *cf;
  char v64;
  const char *v65;
  const __CFAllocator *v66;
  char *v67;

  if (!a1)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v10 = "%s: Invalid device!";
LABEL_11:
      objc_msgSend(v9, "WFLog:message:", 4, v10, "WiFiMetricsManagerSubmitAssociationFailure");
    }
LABEL_12:
    objc_autoreleasePoolPop(v8);
    return;
  }
  if (!a3)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v10 = "%s: no Network object!";
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  if (!qword_10026D5D8)
    return;
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitAssociationFailure");
    goto LABEL_12;
  }
  v11 = sub_100017A54((uint64_t)a3, CFSTR("CHANNEL"));
  v62 = sub_100017A54((uint64_t)a3, CFSTR("RSSI"));
  v12 = (const __CFString *)sub_10002BE64((uint64_t)a3, CFSTR("BSSID"));
  if (!sub_1000C3B8C((_BOOL8)a3))
  {
    v60 = v11;
    theString = v12;
    v19 = 0;
    v20 = 0;
    v66 = kCFAllocatorDefault;
LABEL_28:
    v22 = 1;
LABEL_29:
    v23 = sub_100031670(a3);
    v24 = "Hidden ";
    if (!v23)
      v24 = "";
    v65 = v24;
    if (sub_10002DAB4((uint64_t)a3))
      v25 = "EAP ";
    else
      v25 = "";
    if (sub_1000C433C((const __CFDictionary *)a3))
      v26 = "SAE ";
    else
      v26 = "";
    cf = v19;
    v64 = v22;
    if (sub_1000C433C((const __CFDictionary *)a3))
    {
      v27 = "WPA3 ";
    }
    else if (sub_1000C5104((uint64_t)a3))
    {
      v27 = "WPA2 ";
    }
    else if (sub_1000C50F4((uint64_t)a3))
    {
      v27 = "WPA ";
    }
    else
    {
      v27 = "";
    }
    v67 = v20;
    if (!v20)
      v20 = "";
    if (sub_1000C5294((_BOOL8)a3))
      v30 = "WAPI PSK ";
    else
      v30 = "";
    v31 = sub_1000C52BC((_BOOL8)a3);
    v32 = "WAPI CERT ";
    if (!v31)
      v32 = "";
    v29 = CFStringCreateWithFormat(v66, 0, CFSTR("%s%s%s%s%s%s%s"), v65, v25, v26, v27, v20, v30, v32);
    Length = CFStringGetLength(v29);
    v34 = (unsigned int *)malloc_type_malloc((int)Length + 27, 0x5E5F08B7uLL);
    if (v34)
    {
      v35 = v34;
      bzero(v34, (int)Length + 27);
      if ((_DWORD)Length)
        CFStringGetCString(v29, (char *)v35 + 26, ((uint64_t)&_mh_execute_header + (Length << 32)) >> 32, 0);
      *v35 = a2;
      *(unsigned int *)((char *)v35 + 11) = v60;
      *(unsigned int *)((char *)v35 + 15) = v62;
      *(unsigned int *)((char *)v35 + 19) = a4;
      v36 = (const void *)sub_100025C3C(a1);
      v37 = sub_100069A5C(a1, v36);
      if (v37)
      {
        v38 = v37;
        Value = (const __CFString *)CFDictionaryGetValue(v37, CFSTR("DEAUTH_EA"));
        if (Value)
        {
          v40 = Value;
          v41 = (int)(CFStringGetLength(Value) + 1);
          v42 = (char *)malloc_type_malloc(v41, 0xE0AABCE6uLL);
          if (v42)
          {
            v43 = v42;
            bzero(v42, v41);
            if (CFStringGetCString(v40, v43, v41, 0))
            {
              v44 = ether_aton(v43);
              if (v44)
              {
                v45 = *(_WORD *)v44->octet;
                *((_BYTE *)v35 + 10) = v44->octet[2];
                *((_WORD *)v35 + 4) = v45;
              }
            }
            free(v43);
          }
        }
        v46 = (const __CFNumber *)CFDictionaryGetValue(v38, CFSTR("DEAUTH_REASON"));
        if (v46)
          CFNumberGetValue(v46, kCFNumberIntType, v35 + 1);
        CFRelease(v38);
      }
      if (theString)
      {
        v47 = (int)(CFStringGetLength(theString) + 1);
        v48 = (char *)malloc_type_malloc(v47, 0xB0AA74B1uLL);
        if (v48)
        {
          v49 = v48;
          bzero(v48, v47);
          if (CFStringGetCString(theString, v49, v47, 0))
          {
            v50 = ether_aton(v49);
            if (v50)
            {
              v51 = *(_WORD *)v50->octet;
              *((_BYTE *)v35 + 25) = v50->octet[2];
              *(_WORD *)((char *)v35 + 23) = v51;
            }
          }
          free(v49);
        }
      }
      v52 = objc_autoreleasePoolPush();
      v53 = objc_autoreleasePoolPush();
      v54 = objc_alloc((Class)WAMessage);
      v55 = objc_msgSend(v54, "initWithMetricName:options:", kWAMessageMetricNameAssociationFailure, 7);
      if (v55)
      {
        v56 = v55;
        objc_msgSend(v55, "addFieldForKey:value:options:", kWAMessageKeyError, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *v35), 7);
        objc_msgSend(v56, "addFieldForKey:value:options:", kWAMessageKeyDeauthReason, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v35[1]), 7);
        sub_100063954(v56, kWAMessageKeyDeauthSourceOUI, (uint64_t)(v35 + 2), 3u, 1);
        objc_msgSend(v56, "addFieldForKey:value:options:", kWAMessageKeyChannel, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)((char *)v35 + 11)), 7);
        objc_msgSend(v56, "addFieldForKey:value:options:", kWAMessageKeyRSSI, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)((char *)v35 + 15)), 7);
        sub_100063954(v56, kWAMessageKeyBSSIDOUI, (uint64_t)v35 + 23, 3u, 1);
        objc_msgSend(v56, "addFieldForKey:value:options:", kWAMessageKeySecurityString, +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", (char *)v35 + 26, 1), 7);
        if (!sub_100060C54(v56, a3, 6))
        {
          v57 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to WAMessage", "__WiFiMetricsManagerWAMessageSubmitAssociationFailure");
          objc_autoreleasePoolPop(v57);
        }
        v58 = kWAMessageKeyMetricDate;
        -[NSDate timeIntervalSinceReferenceDate](+[NSDate date](NSDate, "date"), "timeIntervalSinceReferenceDate");
        objc_msgSend(v56, "addFieldForKey:value:options:", v58, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
        sub_100052064(v56);

      }
      else
      {
        v59 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for AssociationFailure", "__WiFiMetricsManagerWAMessageSubmitAssociationFailure");
        objc_autoreleasePoolPop(v59);
      }
      objc_autoreleasePoolPop(v53);
      free(v35);
      objc_autoreleasePoolPop(v52);
    }
    if ((v64 & 1) != 0)
      goto LABEL_82;
    goto LABEL_81;
  }
  if (sub_10002BE64((uint64_t)a3, CFSTR("WEP_AUTH_Flags")))
  {
    v13 = sub_100017A54((uint64_t)a3, CFSTR("WEP_AUTH_Flags"));
    v14 = kCFAllocatorDefault;
    v15 = "40 Bit";
    if ((v13 & 1) == 0)
      v15 = "104 Bit";
    v16 = "Open";
    if ((v13 & 4) == 0)
      v16 = "Shared";
    v17 = "Hashed";
    if ((v13 & 2) == 0)
      v17 = "Unhashed";
    v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WEP network: %s %s %s (0x%lx)"), v15, v16, v17, v13);
  }
  else
  {
    v14 = kCFAllocatorDefault;
    v18 = CFStringCreateWithCString(kCFAllocatorDefault, "WEP network", 0);
  }
  v19 = v18;
  if (!v18)
  {
    v66 = v14;
    v60 = v11;
    theString = v12;
    v20 = 0;
    goto LABEL_28;
  }
  v21 = (int)(CFStringGetLength(v18) + 1);
  v20 = (char *)malloc_type_malloc(v21, 0x6D532889uLL);
  bzero(v20, v21);
  if (CFStringGetCString(v19, v20, v21, 0))
  {
    v22 = 0;
    v66 = v14;
    v60 = v11;
    theString = v12;
    goto LABEL_29;
  }
  v67 = v20;
  cf = v19;
  v28 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to retrieve WEP security string!", "WiFiMetricsManagerSubmitAssociationFailure");
  objc_autoreleasePoolPop(v28);
  v29 = 0;
LABEL_81:
  CFRelease(cf);
LABEL_82:
  if (v29)
    CFRelease(v29);
  if (v67)
    free(v67);
}

void sub_100051888(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;

  if (a1)
  {
    v2 = (unsigned __int8 *)malloc_type_malloc(3uLL, 0x100004033FC2DF1uLL);
    if (v2)
    {
      v3 = v2;
      *(_WORD *)v2 = *(_WORD *)a1;
      v2[2] = *(_BYTE *)(a1 + 2);
      v4 = objc_autoreleasePoolPush();
      v5 = objc_autoreleasePoolPush();
      v6 = objc_alloc((Class)WAMessage);
      v7 = objc_msgSend(v6, "initWithMetricName:options:", kWAMessageMetricNameHotspotTransportUsed, 5);
      if (v7)
      {
        v8 = v7;
        objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyWiFiHotspotCount, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *v3), 5);
        objc_msgSend(v8, "addFieldForKey:value:options:", kWAMessageKeyBTHotspotCount, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v3[1]), 5);
        objc_msgSend(v8, "addFieldForKey:value:options:", kWAMessageKeyUSBHotspotCount, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v3[2]), 5);
        sub_100052064(v8);

      }
      else
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for HotspotTransportType", "__WiFiMetricsManagerWAMessageSubmitHotspotTransportType");
        objc_autoreleasePoolPop(v9);
      }
      objc_autoreleasePoolPop(v5);
      objc_autoreleasePoolPop(v4);
      free(v3);
    }
  }
}

void sub_100051A28(uint64_t a1, int a2, unsigned int a3, unsigned int a4, void *a5, char a6)
{
  const void *v12;
  const void *v13;
  const void *v14;
  double Current;
  double v16;
  double v17;
  double v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int *v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  id v28;
  id v29;
  id v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  if (!a1)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerSubmitIPv4DHCPLatency");
    goto LABEL_33;
  }
  if (!qword_10026D5D8)
    return;
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitIPv4DHCPLatency");
LABEL_33:
    objc_autoreleasePoolPop(v33);
    return;
  }
  v12 = (const void *)sub_100025C3C(a1);
  v13 = sub_10002BF8C(a1, v12);
  if (v13)
  {
    v14 = v13;
    if (a2)
    {
      Current = CFAbsoluteTimeGetCurrent();
      if (Current == 0.0 || (v16 = Current, v17 = sub_1000734F0(a1), v17 == 0.0) || (v18 = v17, v16 <= v17))
      {
LABEL_27:
        CFRelease(v14);
        return;
      }
      sub_100073504(a1, 0.0);
      v19 = ((v16 - v18) * 1000.0);
    }
    else
    {
      v19 = -1;
    }
    v20 = (unsigned int *)malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
    if (v20)
    {
      v21 = v20;
      *v20 = v19;
      v20[1] = sub_1000C5C14((uint64_t)v14);
      v21[2] = a3;
      v21[3] = a4;
      v22 = objc_autoreleasePoolPush();
      if ((a6 & 1) == 0)
      {
        v23 = objc_autoreleasePoolPush();
        v24 = objc_alloc((Class)WAMessage);
        v25 = objc_msgSend(v24, "initWithMetricName:options:", kWAMessageMetricNameIpv4Latency, 7);
        if (v25)
        {
          v26 = v25;
          objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyDHCPLatencyMilliSec, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *v21), 7);
          objc_msgSend(v26, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v21[1]), 7);
          objc_msgSend(v26, "addFieldForKey:value:options:", kWAMessageKeyDHCPLeaseMins, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v21[2]), 7);
          objc_msgSend(v26, "addFieldForKey:value:options:", kWAMessageKeyDHCPSuccess, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a2 != 0), 6);
          if (a5)
          {
            v35 = v23;
            v27 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
            v28 = objc_msgSend(a5, "valueForKey:", CFSTR("IO80211InterfaceIPV4Address"));
            v29 = objc_msgSend(a5, "valueForKey:", CFSTR("IO80211InterfaceIPV4RouterAddress"));
            v30 = objc_msgSend(a5, "valueForKey:", CFSTR("IO80211InterfaceRouterMACAddress"));
            objc_msgSend(v27, "setValue:forKey:", v28, CFSTR("IO80211InterfaceIPV4Address"));
            objc_msgSend(v27, "setValue:forKey:", v29, CFSTR("IO80211InterfaceIPV4RouterAddress"));
            if (v30)
              objc_msgSend(v27, "setValue:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", ether_ntoa((const ether_addr *)objc_msgSend(v30, "bytes"))), CFSTR("IO80211InterfaceRouterMACAddress"));
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiMetricsManagerWAMessageSubmitIpv4Latency", v27);
            objc_autoreleasePoolPop(v31);
            objc_msgSend(v26, "addFieldForKey:value:options:", kWAMessageKeyDHCPAddresses, v27, 6);
            v23 = v35;
          }
          if (!sub_100060C54(v26, v14, 6))
          {
            v32 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to to WAMessage", "__WiFiMetricsManagerWAMessageSubmitIpv4Latency");
            objc_autoreleasePoolPop(v32);
          }
          sub_100052064(v26);

        }
        else
        {
          v34 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for Ipv4Latency", "__WiFiMetricsManagerWAMessageSubmitIpv4Latency");
          objc_autoreleasePoolPop(v34);
        }
        objc_autoreleasePoolPop(v23);
      }
      objc_autoreleasePoolPop(v22);
      free(v21);
    }
    goto LABEL_27;
  }
}

uint64_t sub_100051EBC(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  void *v5;

  if ((int)a1 > 255)
  {
    if ((int)a1 >= 0x2000)
    {
      if ((int)a1 < 0x8000)
      {
        if ((_DWORD)a1 != 0x2000)
        {
          if ((_DWORD)a1 == 0x4000)
            return 15;
          goto LABEL_40;
        }
      }
      else
      {
        if ((_DWORD)a1 == 0x8000)
          return 16;
        if ((_DWORD)a1 != 0x10000 && (_DWORD)a1 != 0x20000)
          goto LABEL_40;
      }
    }
    else
    {
      if ((int)a1 <= 1023)
      {
        if ((_DWORD)a1 == 256)
          return 18;
        if ((_DWORD)a1 == 512)
          return 20;
        goto LABEL_40;
      }
      if ((_DWORD)a1 == 1024)
        return 9;
      if ((_DWORD)a1 == 2048)
        return 8;
      if ((_DWORD)a1 != 4096)
      {
LABEL_40:
        v5 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknownt auth type (%d)", "WiFiMetricEnhancedSecurityTypeFromAuthType", a1);
        objc_autoreleasePoolPop(v5);
        return 111;
      }
    }
    goto LABEL_26;
  }
  if ((int)a1 > 15)
  {
    if ((int)a1 > 63)
    {
      if ((_DWORD)a1 == 64)
        return 17;
      if ((_DWORD)a1 == 128)
        return 6;
      goto LABEL_40;
    }
    if ((_DWORD)a1 != 16)
    {
      if ((_DWORD)a1 == 32)
        return 19;
      goto LABEL_40;
    }
LABEL_26:
    if (a3)
      return 11;
    else
      return 5;
  }
  result = 2;
  switch((int)a1)
  {
    case 0:
      result = a2 != 0;
      break;
    case 1:
      return result;
    case 2:
      result = 3;
      break;
    case 4:
      result = 4;
      break;
    case 8:
      goto LABEL_26;
    default:
      goto LABEL_40;
  }
  return result;
}

void sub_100052064(void *a1)
{
  void *v2;
  void *v3;
  void *v4;

  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) != 1)
    {
      if (a1)
      {
        -[WiFiManagerAnalytics submitWiFiAnalyticsMessage:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "submitWiFiAnalyticsMessage:", a1);
      }
      else
      {
        v4 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "__WiFiMetricsManagerSubmitWAMessage");
        objc_autoreleasePoolPop(v4);
      }
      return;
    }
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "__WiFiMetricsManagerSubmitWAMessage");
    objc_autoreleasePoolPop(v2);
  }
  if (a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to submit message: %@", "__WiFiMetricsManagerSubmitWAMessage", objc_msgSend(a1, "metricName"));
    objc_autoreleasePoolPop(v3);
  }
}

void sub_1000521A8(uint64_t a1, int a2, int a3, int a4, int a5, int a6, const void *a7, int a8)
{
  void *v16;
  void *v17;
  uint64_t v18;
  const void *v19;
  double v20;
  _WORD *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  void *v35;
  void *v36;
  unsigned int v37;

  v16 = objc_autoreleasePoolPush();
  v37 = 0;
  if (!a1 || !qword_10026D5D8)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device or metrics", "WiFiMetricsManagerSubmitWiFiLinkChangeData");
    goto LABEL_48;
  }
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitWiFiLinkChangeData");
    goto LABEL_48;
  }
  v17 = malloc_type_malloc(0x430uLL, 0x1060040CDC2EB47uLL);
  if (!v17)
  {
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null wifiLinkChangeDataMetric", "WiFiMetricsManagerSubmitWiFiLinkChangeData");
LABEL_48:
    objc_autoreleasePoolPop(v35);
    goto LABEL_41;
  }
  v18 = (uint64_t)v17;
  bzero(v17, 0x430uLL);
  *(_BYTE *)(v18 + 844) = a2 != 0;
  *(_BYTE *)(v18 + 845) = a3 != 0;
  *(_DWORD *)(v18 + 848) = a4;
  *(_DWORD *)(v18 + 852) = a5;
  *(_DWORD *)(v18 + 856) = a6;
  *(_DWORD *)(v18 + 1064) = a8;
  if (!sub_100052538(a1, v18))
  {
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lqm history preparation failed", "WiFiMetricsManagerSubmitWiFiLinkChangeData");
LABEL_53:
    objc_autoreleasePoolPop(v36);
    goto LABEL_16;
  }
  v19 = (const void *)sub_100068E60(a1);
  if (sub_100074164(a1, v19, &v37))
  {
    *(_DWORD *)(v18 + 884) = 16;
    *(_BYTE *)(v18 + 881) = v37;
  }
  if (!a7)
  {
    if (!a2)
    {
      if (*(double *)&qword_10026D5E0 == 0.0)
        v20 = 0.0;
      else
        v20 = CFAbsoluteTimeGetCurrent() - *(double *)&qword_10026D5E0;
      *(double *)(v18 + 952) = v20;
      v21 = sub_1000764F8(a1);
      if (v21)
      {
        v22 = v21;
        sub_10005277C(a1, v18, v21);
        sub_100053990(a1, v22, v18);
        CFRelease(v22);
      }
      goto LABEL_16;
    }
    v36 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: QFALOG Link up event but there is no valid network. Nothing to submit here.", "WiFiMetricsManagerSubmitWiFiLinkChangeData");
    goto LABEL_53;
  }
  qword_10026D5E0 = CFAbsoluteTimeGetCurrent();
  *(_QWORD *)(v18 + 952) = 0;
  sub_10005277C(a1, v18, a7);
  sub_100053990(a1, a7, v18);
LABEL_16:
  v23 = *(const void **)(v18 + 960);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(v18 + 960) = 0;
  }
  v24 = *(const void **)(v18 + 968);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(v18 + 968) = 0;
  }
  v25 = *(const void **)(v18 + 976);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(v18 + 976) = 0;
  }
  v26 = *(const void **)(v18 + 984);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(v18 + 984) = 0;
  }
  v27 = *(const void **)(v18 + 992);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(v18 + 992) = 0;
  }
  v28 = *(const void **)(v18 + 1000);
  if (v28)
  {
    CFRelease(v28);
    *(_QWORD *)(v18 + 1000) = 0;
  }
  v29 = *(const void **)(v18 + 1008);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(v18 + 1008) = 0;
  }
  v30 = *(const void **)(v18 + 1016);
  if (v30)
  {
    CFRelease(v30);
    *(_QWORD *)(v18 + 1016) = 0;
  }
  v31 = *(const void **)(v18 + 1024);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(v18 + 1024) = 0;
  }
  v32 = *(const void **)(v18 + 1032);
  if (v32)
  {
    CFRelease(v32);
    *(_QWORD *)(v18 + 1032) = 0;
  }
  v33 = *(const void **)(v18 + 1040);
  if (v33)
  {
    CFRelease(v33);
    *(_QWORD *)(v18 + 1040) = 0;
  }
  v34 = *(const void **)(v18 + 1048);
  if (v34)
    CFRelease(v34);
  free((void *)v18);
LABEL_41:
  objc_autoreleasePoolPop(v16);
}

uint64_t sub_100052538(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v6;
  _OWORD v7[7];
  uint64_t v8;
  _OWORD v9[7];
  uint64_t v10;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device is NULL", "__WiFiMetricsManagerPrepareLqmHistoryArray");
    goto LABEL_23;
  }
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (!sub_10006E5B4(a1, (uint64_t)v9, 0))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: cca history preparation failed", "__WiFiMetricsManagerPrepareLqmHistoryArray");
    goto LABEL_23;
  }
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  if (!sub_10006E5B4(a1, (uint64_t)v7, 1))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: rssi history preparation failed", "__WiFiMetricsManagerPrepareLqmHistoryArray");
    goto LABEL_23;
  }
  for (i = 0; i != 120; i += 4)
    *(_DWORD *)(a2 + i) = *(_DWORD *)((char *)v7 + i) | (*(_DWORD *)((char *)v9 + i) << 24);
  if (!sub_10006E710(a1, a2))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: tx rx history preparation failed", "__WiFiMetricsManagerPrepareLqmHistoryArray");
    goto LABEL_23;
  }
  if (!sub_10006E894(a1, a2))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Encoding PerCore Rssi failed", "__WiFiMetricsManagerPrepareLqmHistoryArray");
    goto LABEL_23;
  }
  if (!sub_10006E9EC(a1, a2))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: GateWay ARP history preparation failed", "__WiFiMetricsManagerPrepareLqmHistoryArray");
LABEL_23:
    objc_autoreleasePoolPop(v6);
    return 0;
  }
  return 1;
}

void sub_10005277C(uint64_t a1, uint64_t a2, const void *a3)
{
  const __CFString *v6;
  void *v7;
  const __CFDictionary *v8;
  void *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  uint64_t Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  uint64_t v15;
  const __CFString *v16;
  const __CFString *Mutable;
  unsigned int v18;
  const __CFData *v19;
  const __CFData *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  int v23;
  const __CFNumber *v24;
  int v25;
  int v26;
  const void *v27;
  int v28;
  const __CFDictionary *v29;
  void *v30;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;
  _BOOL4 v37;
  unint64_t v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  const __CFNumber *Value;
  const __CFArray *v42;
  const __CFArray *v43;
  const __CFDictionary *v44;
  CFIndex v45;
  const __CFNumber *v46;
  CFIndex v47;
  const __CFNumber *v48;
  int v49;
  const __CFBoolean *v50;
  const __CFBoolean *v51;
  CFTypeID TypeID;
  const __CFDictionary *v53;
  const __CFDictionary *v54;
  const __CFNumber *v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  const __CFNumber *v58;
  const __CFNumber *v59;
  const __CFData *v60;
  const __CFDictionary *v61;
  const __CFNumber *v62;
  const __CFNumber *v63;
  CFTypeID v64;
  CFStringRef v65;
  void *v66;
  const __CFString *v67;
  const __CFString *v68;
  CFTypeID v69;
  CFStringRef Copy;
  void *v71;
  const __CFString *v72;
  const __CFString *v73;
  CFTypeID v74;
  CFStringRef v75;
  void *v76;
  const __CFString *v77;
  const __CFString *v78;
  CFTypeID v79;
  CFStringRef v80;
  void *v81;
  const __CFString *v82;
  const __CFString *v83;
  CFTypeID v84;
  CFStringRef v85;
  void *v86;
  const void *v87;
  const void *v88;
  CFTypeID v89;
  CFIndex Length;
  UInt8 *v91;
  CFStringEncoding SystemEncoding;
  UInt8 *v93;
  void *v94;
  const __CFNumber *v95;
  const __CFNumber *v96;
  CFTypeID v97;
  CFStringRef v98;
  void *v99;
  const __CFNumber *v100;
  const __CFNumber *v101;
  CFTypeID v102;
  CFStringRef v103;
  void *v104;
  const __CFNumber *v105;
  const __CFNumber *v106;
  CFTypeID v107;
  CFStringRef v108;
  void *v109;
  const __CFNumber *v110;
  const __CFNumber *v111;
  CFTypeID v112;
  CFStringRef v113;
  void *v114;
  const __CFString *v115;
  const __CFString *v116;
  CFTypeID v117;
  CFStringRef v118;
  void *v119;
  const __CFDictionary *v120;
  const __CFDictionary *v121;
  const __CFNumber *v122;
  const __CFData *v123;
  void *v124;
  void *v125;
  __CFDictionary *v126;
  __CFDictionary *v127;
  const void *v128;
  const void *v129;
  const void *v130;
  const void *v131;
  const void *v132;
  CFIndex v133;
  void *v134;
  void *v135;
  void *v136;
  uint64_t v137;
  const __CFDictionary *v138;
  const __CFDictionary *v139;
  unint64_t v140;
  unint64_t v141;
  unsigned __int16 v142;
  unsigned __int16 v143;
  unsigned __int16 valuePtr[6];
  CFRange v145;
  CFRange v146;
  CFRange v147;
  CFRange v148;
  CFRange v149;

  v6 = (const __CFString *)sub_10002BE64((uint64_t)a3, CFSTR("BSSID"));
  v7 = (void *)sub_10001E1C8((uint64_t)"__WiFiMetricsManagerCopyLinkChangeNetworkParams");
  if (!qword_10026D5D8)
  {
    v136 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    goto LABEL_234;
  }
  if (!v6)
  {
    v136 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networkBSSID", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
LABEL_234:
    objc_autoreleasePoolPop(v136);
    goto LABEL_226;
  }
  v8 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("WPS_PROB_RESP_IE"));
  v139 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("APPLE_IE"));
  v138 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("80211D_IE"));
  if (v8)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s QFA WPS PROBE RESPONSE IE found in link change metric", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
LABEL_6:
    objc_autoreleasePoolPop(v9);
    goto LABEL_14;
  }
  v10 = (const __CFArray *)sub_10008674C(*(_QWORD *)(qword_10026D5D8 + 16));
  if (!v10)
    goto LABEL_13;
  v11 = v10;
  Count = CFArrayGetCount(v10);
  if (Count < 1)
    goto LABEL_13;
  v145.length = Count;
  v145.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11, v145, a3);
  if ((FirstIndexOfValue & 0x8000000000000000) == 0
    && (ValueAtIndex = CFArrayGetValueAtIndex(v11, FirstIndexOfValue)) != 0
    && (v15 = (uint64_t)ValueAtIndex,
        (v16 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID"))) != 0)
    && CFStringCompare(v6, v16, 1uLL) == kCFCompareEqualTo)
  {
    v8 = (const __CFDictionary *)sub_10002BE64(v15, CFSTR("WPS_PROB_RESP_IE"));
    if (v8)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s QFA WPS PROBE RESPONSE IE found in Known networks cache", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
      goto LABEL_6;
    }
  }
  else
  {
LABEL_13:
    v8 = 0;
  }
LABEL_14:
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (sub_1000071A0(*(unsigned int **)(qword_10026D5D8 + 16), (uint64_t)Mutable))
    *(_QWORD *)(a2 + 960) = CFStringCreateCopy(kCFAllocatorDefault, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  v18 = sub_10009C634(*(_QWORD *)(qword_10026D5D8 + 16));
  *(_QWORD *)(a2 + 968) = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v18);
  v19 = sub_1000C4110((uint64_t)a3);
  if (v19)
  {
    v20 = v19;
    v146.location = 0;
    v146.length = 3;
    CFDataGetBytes(v19, v146, (UInt8 *)(a2 + 888));
    CFRelease(v20);
  }
  v21 = (const __CFNumber *)sub_1000316E0((uint64_t)a3);
  if (v21)
    CFNumberGetValue(v21, kCFNumberSInt32Type, (void *)(a2 + 864));
  v22 = (const __CFNumber *)sub_1000C6AE4((uint64_t)a3);
  if (v22)
    CFNumberGetValue(v22, kCFNumberSInt32Type, (void *)(a2 + 868));
  *(_DWORD *)(a2 + 872) = sub_100008CEC((uint64_t)a3);
  *(_DWORD *)(a2 + 876) = sub_1000C6B54((uint64_t)a3);
  v23 = sub_1000C4700(a3);
  if (sub_10002DA5C((_BOOL8)a3))
    v23 |= 0x20u;
  if (sub_1000C46C8((uint64_t)a3))
    v23 |= 0x40u;
  if (sub_10002BE64((uint64_t)a3, CFSTR("80211D_IE")))
    v23 |= 8u;
  if (sub_10009CCDC(*(_QWORD *)(qword_10026D5D8 + 16)))
    v23 |= 0x80u;
  if (sub_10000BE8C((uint64_t)a3))
    v23 |= 0x100u;
  if (sub_1000CB480((uint64_t)a3))
    v23 |= 0x800u;
  if (sub_1000CAB28((uint64_t)a3))
    v23 |= 0x400u;
  v24 = (const __CFNumber *)sub_10002BE64((uint64_t)a3, CFSTR("NetworkAtLocationOfInterestType"));
  if (v24)
  {
    *(_DWORD *)valuePtr = 0;
    CFNumberGetValue(v24, kCFNumberSInt32Type, valuePtr);
    v25 = v23 | 0x1000;
    if (*(_DWORD *)valuePtr != 2)
      v25 = v23;
    if (*(_DWORD *)valuePtr == 5)
      v23 = v25 | 0x2000;
    else
      v23 = v25;
  }
  if (sub_1000CC464(a3))
    v23 |= 0x4000u;
  if (sub_1000C8B54((uint64_t)a3))
    v23 |= 2u;
  if (sub_1000C475C((uint64_t)a3))
    v23 |= 4u;
  if (sub_10001395C((uint64_t)a3))
    v23 |= 0x20000u;
  if (sub_10002BE64((uint64_t)a3, CFSTR("WiFiInstantHotspotJoining")) == kCFBooleanTrue)
    v23 |= 0x40000u;
  if (sub_10002BE64((uint64_t)a3, CFSTR("WiFiAutoInstantHotspotJoining")) == kCFBooleanTrue)
  {
    if (sub_1000A5A54(*(_QWORD *)(qword_10026D5D8 + 16)) == 2)
      v26 = 0x100000;
    else
      v26 = 0x80000;
    v23 |= v26;
  }
  if (sub_10002BE64((uint64_t)a3, CFSTR("WiFiNetworkAttributeIsPublic")))
    v23 |= 0x200000u;
  if (sub_10002BE64((uint64_t)a3, CFSTR("WiFiNetworkAttributeIsMoving")))
    v23 |= 0x400000u;
  v27 = sub_10002BE64((uint64_t)a3, CFSTR("WiFiNetworkAttributeIsLowQuality"));
  v28 = v23 | 0x800000;
  if (!v27)
    v28 = v23;
  *(_DWORD *)(a2 + 884) = v28;
  v29 = v138;
  if (v8)
  {
    *(_DWORD *)(a2 + 884) = v28 | 0x8000;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s QFALOG : wps in probe response present ", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v30);
  }
  if (v139)
    *(_DWORD *)(a2 + 884) |= 0x10000u;
  if (v138)
    *(_DWORD *)(a2 + 884) |= 8u;
  *(_BYTE *)(a2 + 892) = sub_1000C5C14((uint64_t)a3);
  if (sub_10007785C(a1))
    v31 = sub_1000C433C((const __CFDictionary *)a3) != 0;
  else
    v31 = 0;
  *(_DWORD *)valuePtr = -1431655766;
  v32 = sub_100077F20(a1, valuePtr);
  v137 = a1;
  if ((_DWORD)v32)
  {
    v33 = v32;
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: fail to get auth type (%d)", "__WiFiGetAuthType", v33);
    objc_autoreleasePoolPop(v34);
    v35 = 111;
  }
  else
  {
    v36 = *(unsigned int *)valuePtr;
    v37 = sub_1000C3B8C((_BOOL8)a3);
    v35 = sub_100051EBC(v36, v37, v31);
  }
  *(_DWORD *)(a2 + 908) = v35;
  if (sub_1000C50A0((_BOOL8)a3) || sub_10002DAB4((uint64_t)a3))
  {
    v38 = (unint64_t)sub_10002BE64((uint64_t)a3, CFSTR("WPA_IE"));
    v39 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("RSN_IE"));
    if ((unint64_t)v39 | v38)
    {
      v40 = v39;
      if (v39)
      {
        *(_WORD *)(a2 + 894) = 2;
        Value = (const __CFNumber *)CFDictionaryGetValue(v39, CFSTR("IE_KEY_RSN_MCIPHER"));
        v42 = (const __CFArray *)CFDictionaryGetValue(v40, CFSTR("IE_KEY_RSN_UCIPHERS"));
        v43 = (const __CFArray *)CFDictionaryGetValue(v40, CFSTR("IE_KEY_RSN_AUTHSELS"));
        v44 = (const __CFDictionary *)CFDictionaryGetValue(v40, CFSTR("IE_KEY_RSN_CAPS"));
        if (!Value)
          goto LABEL_87;
      }
      else
      {
        if (!v38)
          goto LABEL_111;
        TypeID = CFDictionaryGetTypeID();
        if (!sub_1000648AC(TypeID, (CFTypeRef)v38))
          goto LABEL_111;
        *(_WORD *)(a2 + 894) = 1;
        Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("IE_KEY_WPA_MCIPHER"));
        v42 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("IE_KEY_WPA_UCIPHERS"));
        v43 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("IE_KEY_WPA_AUTHSELS"));
        v44 = 0;
        if (!Value)
          goto LABEL_87;
      }
      *(_WORD *)(a2 + 896) = (unsigned __int16)sub_1000638FC(Value);
LABEL_87:
      if (v42)
      {
        *(_WORD *)(a2 + 898) = 0;
        if (CFArrayGetCount(v42) >= 1)
        {
          v45 = 0;
          do
          {
            v46 = (const __CFNumber *)CFArrayGetValueAtIndex(v42, v45);
            *(_WORD *)(a2 + 898) |= (unsigned __int16)sub_1000638FC(v46);
            ++v45;
          }
          while (v45 < CFArrayGetCount(v42));
        }
      }
      if (v43)
      {
        *(_DWORD *)(a2 + 900) = 0;
        if (CFArrayGetCount(v43) >= 1)
        {
          v47 = 0;
          do
          {
            v48 = (const __CFNumber *)CFArrayGetValueAtIndex(v43, v47);
            if (v48
              && (*(_DWORD *)valuePtr = -1431655766, CFNumberGetValue(v48, kCFNumberSInt32Type, valuePtr))
              && (*(_DWORD *)valuePtr - 1) <= 0x18)
            {
              v49 = dword_1001BB26C[*(_DWORD *)valuePtr - 1];
            }
            else
            {
              v49 = 0;
            }
            *(_DWORD *)(a2 + 900) |= v49;
            ++v47;
          }
          while (v47 < CFArrayGetCount(v43));
        }
      }
      v29 = v138;
      if (v44)
      {
        *(_DWORD *)(a2 + 904) = 0;
        v50 = (const __CFBoolean *)CFDictionaryGetValue(v44, CFSTR("PRE_AUTH"));
        if (v50 && CFBooleanGetValue(v50))
          *(_DWORD *)(a2 + 904) |= 1u;
        v51 = (const __CFBoolean *)CFDictionaryGetValue(v44, CFSTR("NO_PAIRWISE"));
        if (v51 && CFBooleanGetValue(v51))
          *(_DWORD *)(a2 + 904) |= 2u;
      }
    }
  }
LABEL_111:
  v53 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("HT_CAPS_IE"));
  if (v53)
  {
    v54 = v53;
    v55 = (const __CFNumber *)CFDictionaryGetValue(v53, CFSTR("CAPS"));
    if (v55)
      CFNumberGetValue(v55, kCFNumberSInt16Type, (void *)(a2 + 912));
    v56 = (const __CFNumber *)CFDictionaryGetValue(v54, CFSTR("AMPDU_PARAMS"));
    if (v56)
      CFNumberGetValue(v56, kCFNumberSInt8Type, (void *)(a2 + 921));
    v57 = (const __CFNumber *)CFDictionaryGetValue(v54, CFSTR("TXBF_CAPS"));
    if (v57)
      CFNumberGetValue(v57, kCFNumberSInt32Type, (void *)(a2 + 916));
    v58 = (const __CFNumber *)CFDictionaryGetValue(v54, CFSTR("EXT_CAPS"));
    if (v58)
      CFNumberGetValue(v58, kCFNumberSInt16Type, (void *)(a2 + 914));
    v59 = (const __CFNumber *)CFDictionaryGetValue(v54, CFSTR("ASEL_CAPS"));
    if (v59)
      CFNumberGetValue(v59, kCFNumberSInt8Type, (void *)(a2 + 920));
    v60 = (const __CFData *)CFDictionaryGetValue(v54, CFSTR("MCS_SET"));
    if (v60)
    {
      v147.location = 0;
      v147.length = 16;
      CFDataGetBytes(v60, v147, (UInt8 *)(a2 + 922));
    }
  }
  if (!v8)
    goto LABEL_182;
  v61 = (const __CFDictionary *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_PRIMARY_DEV_TYPE"));
  valuePtr[0] = -21846;
  v62 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_CFG_METHODS"));
  if (v62 && (v63 = v62, v64 = CFNumberGetTypeID(), v64 == CFGetTypeID(v63)))
  {
    CFNumberGetValue(v63, kCFNumberSInt16Type, valuePtr);
    v65 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), valuePtr[0]);
  }
  else
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsConfigMethods. Not a CFNumber or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v66);
    v65 = 0;
  }
  *(_QWORD *)(a2 + 1048) = v65;
  v67 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MODEL_NAME"));
  if (v67 && (v68 = v67, v69 = CFStringGetTypeID(), v69 == CFGetTypeID(v68)))
  {
    Copy = CFStringCreateCopy(kCFAllocatorDefault, v68);
  }
  else
  {
    v71 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelName. Not a CFString or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v71);
    Copy = 0;
  }
  *(_QWORD *)(a2 + 1000) = Copy;
  v72 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MODEL_NUM"));
  if (v72 && (v73 = v72, v74 = CFStringGetTypeID(), v74 == CFGetTypeID(v73)))
  {
    v75 = CFStringCreateCopy(kCFAllocatorDefault, v73);
  }
  else
  {
    v76 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelNumber. Not a CFString or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v76);
    v75 = 0;
  }
  *(_QWORD *)(a2 + 1008) = v75;
  v77 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MANUFACTURER"));
  if (v77 && (v78 = v77, v79 = CFStringGetTypeID(), v79 == CFGetTypeID(v78)))
  {
    v80 = CFStringCreateCopy(kCFAllocatorDefault, v78);
  }
  else
  {
    v81 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsManufacturerElement. Not a CFString or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v81);
    v80 = 0;
  }
  *(_QWORD *)(a2 + 992) = v80;
  v82 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_DEV_NAME"));
  if (v82 && (v83 = v82, v84 = CFStringGetTypeID(), v84 == CFGetTypeID(v83)))
  {
    v85 = CFStringCreateCopy(kCFAllocatorDefault, v83);
  }
  else
  {
    v86 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsDeviceNameElement. Not a CFString or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v86);
    v85 = 0;
  }
  *(_QWORD *)(a2 + 1032) = v85;
  v87 = CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_DEV_NAME_DATA"));
  if (!v87 || (v88 = v87, v89 = CFDataGetTypeID(), v89 != CFGetTypeID(v88)))
  {
    v94 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wpsDeviceNameData value is NULL or bad type for wpsDeviceNameData. Not a CFDataType ", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v94);
    *(_QWORD *)(a2 + 1040) = 0;
    if (!v61)
      goto LABEL_175;
    goto LABEL_162;
  }
  Length = CFDataGetLength((CFDataRef)v88);
  v91 = (UInt8 *)malloc_type_malloc(Length, 0x100004077774924uLL);
  v148.location = 0;
  v148.length = Length;
  CFDataGetBytes((CFDataRef)v88, v148, v91);
  SystemEncoding = CFStringGetSystemEncoding();
  *(_QWORD *)(a2 + 1040) = CFStringCreateWithBytes(kCFAllocatorDefault, v91, Length, SystemEncoding, 0);
  v93 = v91;
  v29 = v138;
  free(v93);
  if (v61)
  {
LABEL_162:
    v143 = -21846;
    v142 = -21846;
    v95 = (const __CFNumber *)CFDictionaryGetValue(v61, CFSTR("WPS_DEV_TYPE_CAT"));
    if (v95 && (v96 = v95, v97 = CFNumberGetTypeID(), v97 == CFGetTypeID(v96)))
    {
      CFNumberGetValue(v96, kCFNumberSInt16Type, &v143);
      v98 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v143);
    }
    else
    {
      v99 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsPrimaryDeviceTypeCategory. Not a CFNumberType or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
      objc_autoreleasePoolPop(v99);
      v98 = 0;
    }
    *(_QWORD *)(a2 + 1016) = v98;
    v100 = (const __CFNumber *)CFDictionaryGetValue(v61, CFSTR("WPS_DEV_TYPE_SUB_CAT"));
    if (v100 && (v101 = v100, v102 = CFNumberGetTypeID(), v102 == CFGetTypeID(v101)))
    {
      CFNumberGetValue(v101, kCFNumberSInt16Type, &v142);
      v103 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v142);
    }
    else
    {
      v104 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsPrimaryDeviceTypeSubCategory. Not a CFNumberType or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
      objc_autoreleasePoolPop(v104);
      v103 = 0;
    }
    *(_QWORD *)(a2 + 1024) = v103;
  }
LABEL_175:
  LOBYTE(v143) = -86;
  v105 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_RESP_TYPE"));
  if (v105 && (v106 = v105, v107 = CFNumberGetTypeID(), v107 == CFGetTypeID(v106)))
  {
    CFNumberGetValue(v106, kCFNumberSInt8Type, &v143);
    v108 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v143);
  }
  else
  {
    v109 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsResponseType. Not a CFNumberType or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
    objc_autoreleasePoolPop(v109);
    v108 = 0;
  }
  *(_QWORD *)(a2 + 984) = v108;
LABEL_182:
  if (v139)
  {
    LOBYTE(valuePtr[0]) = -86;
    v110 = (const __CFNumber *)CFDictionaryGetValue(v139, CFSTR("APPLE_IE_PRODUCT_ID"));
    if (v110 && (v111 = v110, v112 = CFNumberGetTypeID(), v112 == CFGetTypeID(v111)))
    {
      CFNumberGetValue(v111, kCFNumberSInt8Type, valuePtr);
      v113 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), LOBYTE(valuePtr[0]));
    }
    else
    {
      v114 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsResponseType. Not a CFNumberType or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
      objc_autoreleasePoolPop(v114);
      v113 = 0;
    }
    *(_QWORD *)(a2 + 1008) = v113;
  }
  if (v29)
  {
    v115 = (const __CFString *)CFDictionaryGetValue(v29, CFSTR("IE_KEY_80211D_COUNTRY_CODE"));
    if (v115 && (v116 = v115, v117 = CFStringGetTypeID(), v117 == CFGetTypeID(v116)))
    {
      v118 = CFStringCreateCopy(kCFAllocatorDefault, v116);
    }
    else
    {
      v119 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for countryCode. Not a CFString or NULL", "__WiFiMetricsManagerCopyLinkChangeNetworkParams");
      objc_autoreleasePoolPop(v119);
      v118 = 0;
    }
    *(_QWORD *)(a2 + 976) = v118;
  }
  v120 = (const __CFDictionary *)sub_10002BE64((uint64_t)a3, CFSTR("VHT_CAPS_IE"));
  if (v120)
  {
    v121 = v120;
    v122 = (const __CFNumber *)CFDictionaryGetValue(v120, CFSTR("VHT_CAPS"));
    if (v122)
      CFNumberGetValue(v122, kCFNumberSInt32Type, (void *)(a2 + 940));
    v123 = (const __CFData *)CFDictionaryGetValue(v121, CFSTR("VHT_SUPPORTED_MCS_SET"));
    if (v123)
    {
      v149.location = 0;
      v149.length = 8;
      CFDataGetBytes(v123, v149, (UInt8 *)(a2 + 944));
    }
  }
  v124 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: OUI:%02x:%02x:%02x Channel:%d(%dMHz) Flags:0x%x PhyMode:0x%x Security:0x%x WPA:[Prot:0x%x McastCipher:0x%x UcastCipher:0x%x AKM:0x%x Caps:0x%x] HT:[Info:0x%x AMPDU:0x%x TXBF:0x%x Ext:0x%x ASEL:0x%x] VHT:[Info:0x%x]", "__WiFiMetricsManagerCopyLinkChangeNetworkParams", *(unsigned __int8 *)(a2 + 888), *(unsigned __int8 *)(a2 + 889), *(unsigned __int8 *)(a2 + 890), *(unsigned int *)(a2 + 864), *(unsigned int *)(a2 + 872), *(unsigned int *)(a2 + 884), *(unsigned int *)(a2 + 876), *(unsigned __int8 *)(a2 + 892), *(unsigned __int16 *)(a2 + 894), *(unsigned __int16 *)(a2 + 896), *(unsigned __int16 *)(a2 + 898), *(unsigned int *)(a2 + 900), *(unsigned int *)(a2 + 904),
      *(unsigned __int16 *)(a2 + 912),
      *(unsigned __int8 *)(a2 + 921),
      *(unsigned int *)(a2 + 916),
      *(unsigned __int16 *)(a2 + 914),
      *(unsigned __int8 *)(a2 + 920),
      *(unsigned int *)(a2 + 940));
  objc_autoreleasePoolPop(v124);
  v125 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: QFALOG Metrics in link change metric: Metric Container has: Locale: %@ LocaleSource: %@ CountryCode: %@ wpsDeviceNameElement: %@ wpsManufacturerElement: %@ wpsModelName: %@ wpsModelNumber: %@ ", "__WiFiMetricsManagerCopyLinkChangeNetworkParams", *(_QWORD *)(a2 + 960), *(_QWORD *)(a2 + 968), *(_QWORD *)(a2 + 976), *(_QWORD *)(a2 + 1032), *(_QWORD *)(a2 + 992), *(_QWORD *)(a2 + 1000), *(_QWORD *)(a2 + 1008));
  objc_autoreleasePoolPop(v125);
  v126 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v127 = v126;
  v128 = *(const void **)(a2 + 992);
  if (v128)
    CFDictionaryAddValue(v126, CFSTR("ManufacturerElement"), v128);
  v129 = *(const void **)(a2 + 1000);
  if (v129)
    CFDictionaryAddValue(v127, CFSTR("ModelName"), v129);
  v130 = *(const void **)(a2 + 1008);
  if (v130)
    CFDictionaryAddValue(v127, CFSTR("ModelNumber"), v130);
  v131 = *(const void **)(a2 + 1032);
  if (v131)
    CFDictionaryAddValue(v127, CFSTR("DeviceNameElement"), v131);
  v132 = *(const void **)(a2 + 1040);
  if (v132)
    CFDictionaryAddValue(v127, CFSTR("DeviceNameData"), v132);
  v133 = CFDictionaryGetCount(v127);
  if (v137 && v133)
  {
    v134 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updating AccessPointInfo: %@", "__WiFiMetricsManagerCopyLinkChangeNetworkParams", v127);
    objc_autoreleasePoolPop(v134);
    sub_100078828(v137, v127);
  }
  v140 = 0xAAAAAAAAAAAAAAAALL;
  v141 = 0xAAAAAAAAAAAAAAAALL;
  sub_1000C4250((uint64_t)a3, &v141, &v140);
  *(_DWORD *)(a2 + 1056) = v141;
  *(_DWORD *)(a2 + 1060) = v140;
  v135 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: minSupportDataRate %d, maxSupportDataRate %d", "__WiFiMetricsManagerCopyLinkChangeNetworkParams", *(unsigned int *)(a2 + 1056), *(unsigned int *)(a2 + 1060));
  objc_autoreleasePoolPop(v135);
  if (v127)
    CFRelease(v127);
LABEL_226:

}

void sub_100053990(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  id v7;
  id v8;
  void *v9;
  const void *v10;
  const void *v11;
  id v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  unsigned int v24;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiMetricsManagerWAMessageUpdateDBWithLinkChange");
    goto LABEL_53;
  }
  if (!a3)
  {
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v22 = "%s: wifiLinkChangeDataMetric null";
LABEL_52:
      objc_msgSend(v21, "WFLog:message:", 4, v22, "__WiFiMetricsManagerWAMessageUpdateDBWithLinkChange");
    }
LABEL_53:
    objc_autoreleasePoolPop(v20);
    goto LABEL_45;
  }
  v7 = objc_alloc((Class)WAMessage);
  v8 = objc_msgSend(v7, "initWithMetricName:options:", kWAMessageMetricNameLinkChange, 6);
  if (!v8)
  {
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v22 = "%s: Failed to alloc WAMessage for LinkChange";
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  v9 = v8;
  objc_msgSend(v8, "addFieldForKey:value:options:", kWAMessageKeyIsLinkUp, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a3 + 844)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyIsInVoluntary, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a3 + 845)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 848)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeySubReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 852)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyCachedRSSI, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a3 + 856)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a3 + 892)), 7);
  if (!*(_BYTE *)(a3 + 844))
  {
    sub_100063AA8(v9, a1, 1, a3);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyChannelWidth, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 872)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyPhyMode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 876)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyReserved, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a3 + 880)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyAwdlState, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a3 + 881)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyNetworkFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 884)), 7);
    sub_100063954(v9, kWAMessageKeyOUI, a3 + 888, 3u, 1);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPAProtocol, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 894)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyMCastCipher, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 896)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyUCastCiphers, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 898)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyAKMSuites, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 900)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyCapabilities, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 904)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyEnhancedSecurityType, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 908)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyHTInfo, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 912)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyHTCapExt, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 914)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyHTCapTxBF, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a3 + 916)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyHTCapASel, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a3 + 920)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyAMPDUParams, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a3 + 921)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyVHTInfo, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 940)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyAssociationDuration, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a3 + 952)), 7);
    if (*(_QWORD *)(a3 + 960))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyLocale, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 968))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyLocaleSource, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 976))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyCountryCode, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 984))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSResponseType, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 992))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSMfgElement, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1000))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSModelName, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1008))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSModelNum, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1016))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryDeviceTypeCategory, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1024))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryDeviceTypeSubCategory, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1032))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryDeviceNameElement, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1040))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryDeviceNameData, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
    if (*(_QWORD *)(a3 + 1048))
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryConfigMethods, +[NSString stringWithString:](NSString, "stringWithString:"), 7);
  }
  v10 = sub_10002B088(a2);
  v11 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
  if (v10)
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeySSID, +[NSString stringWithString:](NSString, "stringWithString:", v10), 6);
  if (v11)
  {
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyBSSID, +[NSString stringWithString:](NSString, "stringWithString:", v11), 6);
    v12 = +[WiFiUsageAccessPointProfile profileForBSSID:](WiFiUsageAccessPointProfile, "profileForBSSID:", v11);
    if (v12)
      objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyApProfile, v12, 6);
  }
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyChannel, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 864)), 7);
  objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyChannelFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a3 + 868)), 7);
  if (*(_BYTE *)(a3 + 844))
  {
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyNetworkUsageRank, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", sub_1000CBD04((uint64_t)a2)), 6);
    v13 = kWAMessageKeyNOIHomeType;
    v14 = sub_1000C3F88((uint64_t)a2);
    if (v14 >= 3)
      v15 = 3;
    else
      v15 = v14;
    objc_msgSend(v9, "addFieldForKey:value:options:", v13, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", v15), 6);
    v16 = kWAMessageKeyNOIWorkType;
    v17 = sub_1000CBE60((uint64_t)a2);
    if (v17 >= 3)
      v18 = 3;
    else
      v18 = v17;
    objc_msgSend(v9, "addFieldForKey:value:options:", v16, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", v18), 6);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyLOIType, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", (unsigned __int16)sub_1000CC270((uint64_t)a2)), 6);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyMinSupportDataRate, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a3 + 1056)), 7);
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyMaxSupportDataRate, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a3 + 1060)), 7);
  }
  v24 = -1431655766;
  v23 = 0;
  if (!sub_1000A2190(*(_QWORD *)(qword_10026D5D8 + 16), &v24, &v23))
    objc_msgSend(v9, "addFieldForKey:value:options:", kWAMessageKeyMotionState, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v24), 6);
  v19 = kWAMessageKeyMetricDate;
  -[NSDate timeIntervalSinceReferenceDate](+[NSDate date](NSDate, "date"), "timeIntervalSinceReferenceDate");
  objc_msgSend(v9, "addFieldForKey:value:options:", v19, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
  sub_100052064(v9);

LABEL_45:
  objc_autoreleasePoolPop(v6);
}

void sub_100054454(uint64_t a1)
{
  uint64_t v1;
  int64_t v2;
  const void *v3;
  CFIndex v4;
  uint64_t *ValueAtIndex;
  uint64_t *v6;
  uint64_t v7;
  const void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  const void *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFNumber *Value;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  const __CFNumber *v38;
  const __CFNumber *v39;
  const __CFNumber *v40;
  const __CFNumber *v41;
  const __CFNumber *v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  const __CFNumber *v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  const __CFBoolean *v48;
  const __CFBoolean *v49;
  const __CFBoolean *v50;
  const __CFBoolean *v51;
  const __CFBoolean *v52;
  const __CFBoolean *v53;
  const __CFBoolean *v54;
  const __CFBoolean *v55;
  const __CFBoolean *v56;
  const __CFBoolean *v57;
  const __CFBoolean *v58;
  const __CFBoolean *v59;
  const __CFBoolean *v60;
  const __CFBoolean *v61;
  const __CFBoolean *v62;
  const __CFBoolean *v63;
  const __CFBoolean *v64;
  const __CFBoolean *v65;
  const __CFData *v66;
  const __CFData *v67;
  const __CFArray *v68;
  const __CFArray *v69;
  int64_t Count;
  int64_t v71;
  void *v72;
  uint64_t v73;
  CFIndex v74;
  const __CFDictionary *v75;
  const __CFDictionary *v76;
  const __CFNumber *v77;
  const __CFNumber *v78;
  const __CFArray *v79;
  const __CFArray *v80;
  int64_t v81;
  int64_t v82;
  void *v83;
  uint64_t v84;
  CFIndex v85;
  const __CFDictionary *v86;
  const __CFDictionary *v87;
  const __CFNumber *v88;
  const __CFNumber *v89;
  const __CFNumber *v90;
  const __CFNumber *v91;
  const __CFData *v92;
  const __CFData *v93;
  CFIndex Length;
  CFRange v95;
  const __CFArray *v96;
  const __CFArray *v97;
  int64_t v98;
  int64_t v99;
  void *v100;
  uint64_t v101;
  CFIndex v102;
  const __CFDictionary *v103;
  const __CFDictionary *v104;
  const __CFNumber *v105;
  const __CFNumber *v106;
  const __CFNumber *v107;
  const __CFArray *v108;
  const __CFArray *v109;
  int64_t v110;
  int64_t v111;
  void *v112;
  uint64_t v113;
  CFIndex v114;
  const __CFDictionary *v115;
  const __CFDictionary *v116;
  const __CFNumber *v117;
  const __CFNumber *v118;
  const __CFNumber *v119;
  const __CFNumber *v120;
  const __CFNumber *v121;
  const __CFNumber *v122;
  const __CFNumber *v123;
  const __CFNumber *v124;
  const __CFNumber *v125;
  const __CFNumber *v126;
  const __CFNumber *v127;
  const __CFNumber *v128;
  const __CFNumber *v129;
  const __CFNumber *v130;
  const __CFNumber *v131;
  const __CFDictionary *v132;
  const __CFDictionary *v133;
  void *v134;
  const __CFNumber *v135;
  const __CFNumber *v136;
  const __CFNumber *v137;
  const __CFNumber *v138;
  const __CFNumber *v139;
  const __CFNumber *v140;
  const __CFNumber *v141;
  const __CFNumber *v142;
  const __CFNumber *v143;
  const __CFNumber *v144;
  const __CFNumber *v145;
  const __CFNumber *v146;
  const __CFNumber *v147;
  const __CFArray *v148;
  const __CFArray *v149;
  int64_t v150;
  int64_t v151;
  void *v152;
  uint64_t v153;
  CFIndex v154;
  const __CFNumber *v155;
  void *v156;
  uint64_t v157;
  CFRange v158;

  if (!a1)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerCollectAwdlUsageAsync");
    goto LABEL_14;
  }
  if (!qword_10026D5D8 || !*(_QWORD *)(qword_10026D5D8 + 16))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics manager", "WiFiMetricsManagerCollectAwdlUsageAsync");
    goto LABEL_14;
  }
  v1 = a1;
  v2 = sub_100068E60(a1);
  if (!v2)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null awdlIfName", "WiFiMetricsManagerCollectAwdlUsageAsync");
    goto LABEL_14;
  }
  v3 = (const void *)v2;
  if (CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)) < 1)
  {
LABEL_12:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL interface not found in deviceMetricsArray.", "WiFiMetricsManagerCollectAwdlUsageAsync");
LABEL_14:
    objc_autoreleasePoolPop(v9);
    return;
  }
  v4 = 0;
  while (1)
  {
    ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(qword_10026D5D8 + 32), v4);
    if (ValueAtIndex)
    {
      v6 = ValueAtIndex;
      v7 = *ValueAtIndex;
      if (v7)
      {
        if (sub_100068E60(v7))
        {
          v8 = (const void *)sub_100068E60(*v6);
          if (CFEqual(v3, v8))
            break;
        }
      }
    }
    if (++v4 >= CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)))
      goto LABEL_12;
  }
  v10 = (void *)v6[30];
  if (v10)
  {
    free(v10);
    v6[30] = 0;
  }
  v11 = (void *)v6[32];
  if (v11)
  {
    free(v11);
    v6[32] = 0;
  }
  v12 = (void *)v6[39];
  if (v12)
  {
    free(v12);
    v6[39] = 0;
  }
  v13 = (void *)v6[41];
  if (v13)
  {
    free(v13);
    v6[41] = 0;
  }
  v14 = (void *)v6[43];
  if (v14)
  {
    free(v14);
    v6[43] = 0;
  }
  v15 = (void *)v6[47];
  if (v15)
  {
    free(v15);
    v6[47] = 0;
  }
  v6[58] = 0;
  *((_OWORD *)v6 + 27) = 0u;
  *((_OWORD *)v6 + 28) = 0u;
  *((_OWORD *)v6 + 25) = 0u;
  *((_OWORD *)v6 + 26) = 0u;
  *((_OWORD *)v6 + 23) = 0u;
  *((_OWORD *)v6 + 24) = 0u;
  *((_OWORD *)v6 + 21) = 0u;
  *((_OWORD *)v6 + 22) = 0u;
  *((_OWORD *)v6 + 19) = 0u;
  *((_OWORD *)v6 + 20) = 0u;
  *((_OWORD *)v6 + 17) = 0u;
  *((_OWORD *)v6 + 18) = 0u;
  *((_OWORD *)v6 + 15) = 0u;
  *((_OWORD *)v6 + 16) = 0u;
  *((_OWORD *)v6 + 13) = 0u;
  *((_OWORD *)v6 + 14) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  *((_OWORD *)v6 + 12) = 0u;
  v16 = (const void *)sub_100068E60(v1);
  v17 = (const __CFDictionary *)sub_100070C2C(v1, v16);
  if (!v17)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null stats", "WiFiMetricsManagerCollectAwdlUsageAsync");
    goto LABEL_14;
  }
  v18 = v17;
  Value = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("AWDL_STATS_FLAGS"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt32Type, v6 + 24);
  v20 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_RXBYTES"));
  if (v20)
    CFNumberGetValue(v20, kCFNumberSInt32Type, v6 + 25);
  v21 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_TXBYTES"));
  if (v21)
    CFNumberGetValue(v21, kCFNumberSInt32Type, (char *)v6 + 204);
  v22 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PACKET_FAILURES"));
  if (v22)
    CFNumberGetValue(v22, kCFNumberSInt32Type, (char *)v6 + 196);
  v23 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SELF_INFRA_CHANNEL"));
  if (v23)
    CFNumberGetValue(v23, kCFNumberSInt32Type, v6 + 22);
  v24 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SELF_INFRA_CHANNEL_FLAGS"));
  if (v24)
    CFNumberGetValue(v24, kCFNumberSInt32Type, v6 + 44);
  v25 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_INFRA_CHANNEL"));
  if (v25)
    CFNumberGetValue(v25, kCFNumberSInt8Type, (char *)v6 + 180);
  v26 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_INFRA_CHANNEL_FLAGS"));
  if (v26)
    CFNumberGetValue(v26, kCFNumberSInt32Type, (char *)v6 + 356);
  v27 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_PEERS"));
  if (v27)
    CFNumberGetValue(v27, kCFNumberSInt8Type, (char *)v6 + 181);
  v28 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS"));
  if (v28)
    CFNumberGetValue(v28, kCFNumberSInt8Type, (char *)v6 + 182);
  v29 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_2GHZ"));
  if (v29)
    CFNumberGetValue(v29, kCFNumberSInt8Type, (char *)v6 + 183);
  v30 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_5GHZ"));
  if (v30)
    CFNumberGetValue(v30, kCFNumberSInt8Type, v6 + 23);
  v31 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_DFS"));
  if (v31)
    CFNumberGetValue(v31, kCFNumberSInt8Type, (char *)v6 + 185);
  v32 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_UNASSOC"));
  if (v32)
    CFNumberGetValue(v32, kCFNumberSInt8Type, (char *)v6 + 186);
  v33 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_DIFF_INFRA"));
  if (v33)
    CFNumberGetValue(v33, kCFNumberSInt8Type, (char *)v6 + 187);
  v34 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_SAME_INFRA"));
  if (v34)
    CFNumberGetValue(v34, kCFNumberSInt8Type, (char *)v6 + 188);
  v35 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NO_SERVICE_IDLE_TIME"));
  if (v35)
    CFNumberGetValue(v35, kCFNumberSInt32Type, v6 + 28);
  v36 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_CHANNEL_STEER_BEFORE"));
  if (v36)
    CFNumberGetValue(v36, kCFNumberSInt32Type, v6 + 49);
  v37 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_CHANNEL_STEER_AFTER"));
  if (v37)
    CFNumberGetValue(v37, kCFNumberSInt32Type, (char *)v6 + 396);
  v38 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_STATS_DWELL_SESSION_COUNT"));
  if (v38)
    CFNumberGetValue(v38, kCFNumberSInt32Type, v6 + 50);
  v39 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_AWDL_STATS_SERVICE_COUNT"));
  if (v39)
    CFNumberGetValue(v39, kCFNumberSInt32Type, v6 + 31);
  v40 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_TOTAL_DURATION"));
  if (v40)
    CFNumberGetValue(v40, kCFNumberSInt32Type, (char *)v6 + 404);
  v41 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_STATS_INACTIVITY_DURATION"));
  if (v41)
    CFNumberGetValue(v41, kCFNumberSInt32Type, v6 + 51);
  v42 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_STATS_ACTIVITY_DURATION"));
  if (v42)
    CFNumberGetValue(v42, kCFNumberSInt32Type, (char *)v6 + 412);
  v43 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PERCENTAGE_INACTIVITY"));
  if (v43)
    CFNumberGetValue(v43, kCFNumberSInt32Type, v6 + 52);
  v44 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_TIME_TO_SERVICE"));
  if (v44)
    CFNumberGetValue(v44, kCFNumberSInt32Type, (char *)v6 + 420);
  v45 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PERCENTAGE_INFRA_IDLE"));
  if (v45)
    CFNumberGetValue(v45, kCFNumberSInt32Type, v6 + 53);
  v46 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PERCENTAGE_INFRA_REAL"));
  if (v46)
    CFNumberGetValue(v46, kCFNumberSInt32Type, (char *)v6 + 428);
  v47 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PERCENTAGE_INFRA_NONREAL"));
  if (v47)
    CFNumberGetValue(v47, kCFNumberSInt32Type, v6 + 54);
  v48 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_AIRPLAY_ACTIVE"));
  if (v48)
    *((_BYTE *)v6 + 448) = CFBooleanGetValue(v48);
  v49 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_REMOTECAMERA_ACTIVE"));
  if (v49)
    *((_BYTE *)v6 + 449) = CFBooleanGetValue(v49);
  v50 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_REMOTESCREEN_ACTIVE"));
  if (v50)
    *((_BYTE *)v6 + 450) = CFBooleanGetValue(v50);
  v51 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SIDECAR_ACTIVE"));
  if (v51)
    *((_BYTE *)v6 + 451) = CFBooleanGetValue(v51);
  v52 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_TVREMOTECAMERA_ACTIVE"));
  if (v52)
    *((_BYTE *)v6 + 452) = CFBooleanGetValue(v52);
  v53 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_UNIVERSALCONTROL_ACTIVE"));
  if (v53)
    *((_BYTE *)v6 + 453) = CFBooleanGetValue(v53);
  v54 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_STEREOPAIR_ACTIVE "));
  if (v54)
    *((_BYTE *)v6 + 454) = CFBooleanGetValue(v54);
  v55 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_AIRDROP"));
  if (v55)
    *((_BYTE *)v6 + 455) = CFBooleanGetValue(v55);
  v56 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_AIRPLAY-P2P"));
  if (v56)
    *((_BYTE *)v6 + 456) = CFBooleanGetValue(v56);
  v57 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_AIRPLAY"));
  if (v57)
    *((_BYTE *)v6 + 457) = CFBooleanGetValue(v57);
  v58 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_ATP"));
  if (v58)
    *((_BYTE *)v6 + 458) = CFBooleanGetValue(v58);
  v59 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_COMPANION-LINK"));
  if (v59)
    *((_BYTE *)v6 + 459) = CFBooleanGetValue(v59);
  v60 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_IEEE1588"));
  if (v60)
    *((_BYTE *)v6 + 460) = CFBooleanGetValue(v60);
  v61 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_RAOP"));
  if (v61)
    *((_BYTE *)v6 + 461) = CFBooleanGetValue(v61);
  v62 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_RDLINK"));
  if (v62)
    *((_BYTE *)v6 + 462) = CFBooleanGetValue(v62);
  v63 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSMON"));
  if (v63)
    *((_BYTE *)v6 + 463) = CFBooleanGetValue(v63);
  v64 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_WIFID"));
  if (v64)
    *((_BYTE *)v6 + 464) = CFBooleanGetValue(v64);
  v65 = (const __CFBoolean *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_TEST"));
  if (v65)
    *((_BYTE *)v6 + 465) = CFBooleanGetValue(v65);
  v66 = (const __CFData *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_OUI"));
  if (v66)
  {
    v67 = v66;
    v158.length = CFDataGetLength(v66);
    v158.location = 0;
    CFDataGetBytes(v67, v158, (UInt8 *)v6 + 466);
  }
  v68 = (const __CFArray *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_STATES"));
  if (v68)
  {
    v69 = v68;
    Count = CFArrayGetCount(v68);
    v71 = Count;
    if (Count >= 1)
    {
      v72 = malloc_type_calloc(Count, 0x10uLL, 0x1000040F7F8B94BuLL);
      v6[30] = (uint64_t)v72;
      if (!v72)
      {
        v156 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null states", "WiFiMetricsManagerCollectAwdlUsageAsync");
        goto LABEL_262;
      }
      v73 = 0;
      v74 = 0;
      do
      {
        v75 = (const __CFDictionary *)CFArrayGetValueAtIndex(v69, v74);
        if (v75)
        {
          v76 = v75;
          v77 = (const __CFNumber *)CFDictionaryGetValue(v75, CFSTR("AWDL_STATS_STATE_COUNT"));
          if (v77)
            CFNumberGetValue(v77, kCFNumberSInt32Type, (void *)(v6[30] + v73));
          v78 = (const __CFNumber *)CFDictionaryGetValue(v76, CFSTR("AWDL_STATS_STATE_DURATION"));
          if (v78)
            CFNumberGetValue(v78, kCFNumberSInt64Type, (void *)(v6[30] + v73 + 8));
        }
        ++v74;
        v73 += 16;
      }
      while (v71 != v74);
    }
    *((_DWORD *)v6 + 58) = v71;
  }
  v79 = (const __CFArray *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SERVICES"));
  v157 = v1;
  if (v79)
  {
    v80 = v79;
    v81 = CFArrayGetCount(v79);
    v82 = v81;
    if (v81 >= 1)
    {
      v83 = malloc_type_calloc(v81, 0x30uLL, 0x1000040634EFA27uLL);
      v6[32] = (uint64_t)v83;
      if (!v83)
      {
        v156 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null services", "WiFiMetricsManagerCollectAwdlUsageAsync");
        goto LABEL_262;
      }
      v84 = 0;
      v85 = 0;
      do
      {
        v86 = (const __CFDictionary *)CFArrayGetValueAtIndex(v80, v85);
        if (v86)
        {
          v87 = v86;
          v88 = (const __CFNumber *)CFDictionaryGetValue(v86, CFSTR("AWDL_STATS_SERVICE_DURATION"));
          if (v88)
            CFNumberGetValue(v88, kCFNumberSInt64Type, (void *)(v6[32] + v84 + 8));
          v89 = (const __CFNumber *)CFDictionaryGetValue(v87, CFSTR("AWDL_STATS_SERVICE_ID"));
          if (v89)
            CFNumberGetValue(v89, kCFNumberSInt32Type, (void *)(v6[32] + v84 + 4));
          v90 = (const __CFNumber *)CFDictionaryGetValue(v87, CFSTR("AWDL_STATS_SERVICE_TYPE"));
          if (v90)
            CFNumberGetValue(v90, kCFNumberSInt8Type, (void *)(v6[32] + v84 + 1));
          v91 = (const __CFNumber *)CFDictionaryGetValue(v87, CFSTR("AWDL_STATS_SERVICE_OPCODE"));
          if (v91)
            CFNumberGetValue(v91, kCFNumberSInt8Type, (void *)(v6[32] + v84));
          v92 = (const __CFData *)CFDictionaryGetValue(v87, CFSTR("AWDL_STATS_SERVICE_KEY"));
          if (v92)
          {
            v93 = v92;
            Length = CFDataGetLength(v92);
            v95.length = Length >= 32 ? 32 : Length;
            if (v95.length)
            {
              v95.location = 0;
              CFDataGetBytes(v93, v95, (UInt8 *)(v6[32] + v84 + 16));
            }
          }
        }
        ++v85;
        v84 += 48;
      }
      while (v82 != v85);
    }
    *((_DWORD *)v6 + 62) = v82;
  }
  v96 = (const __CFArray *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_HOPCOUNT"));
  if (v96)
  {
    v97 = v96;
    v98 = CFArrayGetCount(v96);
    v99 = v98;
    if (v98 >= 1)
    {
      v100 = malloc_type_calloc(v98, 0x18uLL, 0x1000040504FFAC1uLL);
      v6[39] = (uint64_t)v100;
      if (!v100)
        goto LABEL_252;
      v101 = 0;
      v102 = 0;
      do
      {
        v103 = (const __CFDictionary *)CFArrayGetValueAtIndex(v97, v102);
        if (v103)
        {
          v104 = v103;
          v105 = (const __CFNumber *)CFDictionaryGetValue(v103, CFSTR("AWDL_STATS_HISTOGRAM_BIN_START"));
          if (v105)
            CFNumberGetValue(v105, kCFNumberDoubleType, (void *)(v6[39] + v101));
          v106 = (const __CFNumber *)CFDictionaryGetValue(v104, CFSTR("AWDL_STATS_HISTOGRAM_BIN_END"));
          if (v106)
            CFNumberGetValue(v106, kCFNumberDoubleType, (void *)(v6[39] + v101 + 8));
          v107 = (const __CFNumber *)CFDictionaryGetValue(v104, CFSTR("AWDL_STATS_HISTOGRAM_BIN_VALUE"));
          if (v107)
            CFNumberGetValue(v107, kCFNumberDoubleType, (void *)(v6[39] + v101 + 16));
        }
        ++v102;
        v101 += 24;
      }
      while (v99 != v102);
    }
    *((_DWORD *)v6 + 80) = v99;
    v1 = v157;
  }
  v108 = (const __CFArray *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PARENTRSSI"));
  if (!v108)
    goto LABEL_182;
  v109 = v108;
  v110 = CFArrayGetCount(v108);
  v111 = v110;
  if (v110 >= 1)
  {
    v112 = malloc_type_calloc(v110, 0x18uLL, 0x1000040504FFAC1uLL);
    v6[41] = (uint64_t)v112;
    if (v112)
    {
      v113 = 0;
      v114 = 0;
      do
      {
        v115 = (const __CFDictionary *)CFArrayGetValueAtIndex(v109, v114);
        if (v115)
        {
          v116 = v115;
          v117 = (const __CFNumber *)CFDictionaryGetValue(v115, CFSTR("AWDL_STATS_HISTOGRAM_BIN_START"));
          if (v117)
            CFNumberGetValue(v117, kCFNumberDoubleType, (void *)(v6[41] + v113));
          v118 = (const __CFNumber *)CFDictionaryGetValue(v116, CFSTR("AWDL_STATS_HISTOGRAM_BIN_END"));
          if (v118)
            CFNumberGetValue(v118, kCFNumberDoubleType, (void *)(v6[41] + v113 + 8));
          v119 = (const __CFNumber *)CFDictionaryGetValue(v116, CFSTR("AWDL_STATS_HISTOGRAM_BIN_VALUE"));
          if (v119)
            CFNumberGetValue(v119, kCFNumberDoubleType, (void *)(v6[41] + v113 + 16));
        }
        ++v114;
        v113 += 24;
      }
      while (v111 != v114);
      goto LABEL_181;
    }
LABEL_252:
    v156 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null hop count histogram container", "WiFiMetricsManagerCollectAwdlUsageAsync");
    goto LABEL_262;
  }
LABEL_181:
  *((_DWORD *)v6 + 84) = v111;
  v1 = v157;
LABEL_182:
  v120 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SUSPEND_DURATION"));
  if (v120)
    CFNumberGetValue(v120, kCFNumberSInt32Type, v6 + 55);
  v121 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_SUSPEND_COUNT"));
  if (v121)
    CFNumberGetValue(v121, kCFNumberSInt32Type, (char *)v6 + 364);
  v122 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSP_CSA_PEER"));
  if (v122)
    CFNumberGetValue(v122, kCFNumberSInt32Type, v6 + 33);
  v123 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSP_CSA_AP"));
  if (v123)
    CFNumberGetValue(v123, kCFNumberSInt32Type, (char *)v6 + 268);
  v124 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSP_CSA_SUSPECT"));
  if (v124)
    CFNumberGetValue(v124, kCFNumberSInt32Type, v6 + 34);
  v125 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSP_CSA_RESUME"));
  if (v125)
    CFNumberGetValue(v125, kCFNumberSInt32Type, (char *)v6 + 276);
  v126 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_RT_SESSION"));
  if (v126)
    CFNumberGetValue(v126, kCFNumberSInt32Type, v6 + 38);
  v127 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSPAIRPLAY_CONNECTED"));
  if (v127)
    CFNumberGetValue(v127, kCFNumberSInt32Type, v6 + 35);
  v128 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_DFSPAIRPLAY_FAILED"));
  if (v128)
    CFNumberGetValue(v128, kCFNumberSInt32Type, v6 + 35);
  v129 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_SYNC_CHANGES"));
  if (v129)
    CFNumberGetValue(v129, kCFNumberSInt64Type, v6 + 36);
  v130 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("APPLE80211KEY_AWDL_STATS_NUM_INPUT_PKTS_DROPPED"));
  if (v130)
    CFNumberGetValue(v130, kCFNumberSInt32Type, v6 + 37);
  v131 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("APPLE80211KEY_AWDL_STATS_NUM_PEERS_ZERO_EXT_LEN"));
  if (v131)
    CFNumberGetValue(v131, kCFNumberSInt32Type, (char *)v6 + 300);
  v132 = (const __CFDictionary *)CFDictionaryGetValue(v18, CFSTR("AWDL_D2D_MIGRATION_STATS"));
  if (v132)
  {
    v133 = v132;
    v134 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
    v6[43] = (uint64_t)v134;
    if (!v134)
    {
      v156 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null D2D migration statistics container", "WiFiMetricsManagerCollectAwdlUsageAsync");
      goto LABEL_262;
    }
    v135 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_SESSION_DURATION"));
    if (v135)
      CFNumberGetValue(v135, kCFNumberSInt64Type, (void *)v6[43]);
    v136 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_TOTAL_TX_BYTES"));
    if (v136)
      CFNumberGetValue(v136, kCFNumberSInt64Type, (void *)(v6[43] + 8));
    v137 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_TOTAL_RX_BYTES"));
    if (v137)
      CFNumberGetValue(v137, kCFNumberSInt64Type, (void *)(v6[43] + 16));
    v138 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_AVG_RSSI"));
    if (v138)
      CFNumberGetValue(v138, kCFNumberSInt32Type, (void *)(v6[43] + 24));
    v139 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_ROLE"));
    if (v139)
      CFNumberGetValue(v139, kCFNumberSInt8Type, (void *)(v6[43] + 30));
    v140 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_ACTIVE_CHANNEL"));
    if (v140)
      CFNumberGetValue(v140, kCFNumberSInt8Type, (void *)(v6[43] + 28));
    v141 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_AVG_CCA"));
    if (v141)
      CFNumberGetValue(v141, kCFNumberSInt8Type, (void *)(v6[43] + 31));
    v142 = (const __CFNumber *)CFDictionaryGetValue(v133, CFSTR("D2D_MIGRATION_TX_FAILURE_COUNT"));
    if (v142)
      CFNumberGetValue(v142, kCFNumberSInt8Type, (void *)(v6[43] + 29));
  }
  v143 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_CHANNEL_STEER_COUNT_2G"));
  if (v143)
    CFNumberGetValue(v143, kCFNumberSInt32Type, v6 + 48);
  v144 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_PEER_CHANNEL_STEER_COUNT_5G"));
  if (v144)
    CFNumberGetValue(v144, kCFNumberSInt32Type, (char *)v6 + 388);
  v145 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("AWDL_STATS_NUM_CACHED_PEERS_6GHZ"));
  if (v145)
    CFNumberGetValue(v145, kCFNumberSInt8Type, v6 + 45);
  v146 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("APPLE80211KEY_AWDL_STATS_SELF_6E_CAPABLE"));
  if (v146)
    CFNumberGetValue(v146, kCFNumberSInt8Type, (char *)v6 + 361);
  v147 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("APPLE80211KEY_AWDL_STATS_PEER_6E_CAP_COUNT"));
  if (v147)
    CFNumberGetValue(v147, kCFNumberSInt8Type, (char *)v6 + 362);
  v148 = (const __CFArray *)CFDictionaryGetValue(v18, CFSTR("APPLE80211KEY_AWDL_STATS_LTE_RESTRICTED_CHANNELS"));
  if (!v148)
    goto LABEL_242;
  v149 = v148;
  v150 = CFArrayGetCount(v148);
  v151 = v150;
  if (v150 >= 1)
  {
    v152 = malloc_type_calloc(v150, 2uLL, 0x1000040BDFB0063uLL);
    v6[47] = (uint64_t)v152;
    if (v152)
    {
      v153 = 0;
      v154 = 0;
      do
      {
        v155 = (const __CFNumber *)CFArrayGetValueAtIndex(v149, v154);
        if (v155)
          CFNumberGetValue(v155, kCFNumberSInt16Type, (void *)(v6[47] + v153));
        ++v154;
        v153 += 2;
      }
      while (v151 != v154);
      goto LABEL_241;
    }
    v156 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null LTE restricted channels used list", "WiFiMetricsManagerCollectAwdlUsageAsync");
LABEL_262:
    objc_autoreleasePoolPop(v156);
    goto LABEL_243;
  }
LABEL_241:
  *((_DWORD *)v6 + 92) = v151;
LABEL_242:
  sub_1000555F8(v1, 0.0, 0.0);
LABEL_243:
  CFRelease(v18);
}

void sub_1000555F8(uint64_t a1, float64_t a2, float64_t a3)
{
  int64_t v4;
  const __CFString *v5;
  const __CFArray *v6;
  CFIndex v7;
  uint64_t *ValueAtIndex;
  uint64_t *v9;
  uint64_t v10;
  const __CFString *v11;
  void *v12;
  double Current;
  double v14;
  unsigned int v15;
  float64x2_t v16;
  uint32x2_t v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  unsigned int *v52;
  size_t v53;
  void *v54;
  size_t v55;
  void *v56;
  size_t v57;
  void *v58;
  size_t v59;
  void *v60;
  _OWORD *v61;
  _OWORD *v62;
  __int128 v63;
  void *v64;
  void *v65;
  id v66;
  id v67;
  void *v68;
  uint64_t v69;
  unint64_t v70;
  double *v71;
  uint64_t v72;
  unint64_t v73;
  double *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  unsigned int v87;
  unsigned int v88;
  void *v89;
  uint32x2_t v92;

  v4 = sub_100068E60(a1);
  if (!a1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  if (!qword_10026D5D8)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  v5 = (const __CFString *)v4;
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  v6 = *(const __CFArray **)(qword_10026D5D8 + 32);
  if (!v6)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceMetricsArray !!", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  if (!v5)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null awdlIfName", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  if (CFArrayGetCount(v6) < 1)
  {
LABEL_13:
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL interface not found in deviceMetricsArray.", "WiFiMetricsManagerProcessAwdlUsageData");
LABEL_15:
    objc_autoreleasePoolPop(v12);
    return;
  }
  v7 = 0;
  while (1)
  {
    ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(qword_10026D5D8 + 32), v7);
    if (ValueAtIndex)
    {
      v9 = ValueAtIndex;
      v10 = *ValueAtIndex;
      if (*ValueAtIndex)
      {
        if (sub_100068E60(*ValueAtIndex))
        {
          v11 = (const __CFString *)sub_100068E60(v10);
          if (CFStringCompare(v5, v11, 0) == kCFCompareEqualTo)
            break;
        }
      }
    }
    if (++v7 >= CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)))
      goto LABEL_13;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v14 = *((double *)v9 + 21);
  if (v14 == 0.0)
  {
    v89 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: initializing AWDL metrics collection: timestamp:%f rx:%f bytes tx:%f bytes", "WiFiMetricsManagerProcessAwdlUsageData", *(_QWORD *)&Current, *(_QWORD *)&a2, *(_QWORD *)&a3);
    objc_autoreleasePoolPop(v89);
    v87 = a2;
    v88 = a3;
    goto LABEL_138;
  }
  if (Current <= v14)
  {
    *((_DWORD *)v9 + 54) = 0;
LABEL_140:
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not submitting zero duration AWDL metrics.", "WiFiMetricsManagerProcessAwdlUsageData");
    goto LABEL_15;
  }
  v15 = ((Current - v14) / 60.0);
  *((_DWORD *)v9 + 54) = v15;
  if (!v15)
    goto LABEL_140;
  v16.f64[0] = a2;
  v16.f64[1] = a3;
  v92 = (uint32x2_t)vmovn_s64((int64x2_t)vcvtq_u64_f64(v16));
  v17 = vqsub_u32(v92, (uint32x2_t)v9[20]);
  v9[26] = (uint64_t)vsra_n_u32((uint32x2_t)vand_s8((int8x8_t)vshr_n_u32(v17, 9uLL), (int8x8_t)0x100000001), v17, 0xAuLL);
  v18 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: submitting AWDL metrics: duration:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 54));
  objc_autoreleasePoolPop(v18);
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL peerChannelsteerAttemptCount_2G:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 96));
  objc_autoreleasePoolPop(v19);
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL peerChannelsteerAttemptCount_5G:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 97));
  objc_autoreleasePoolPop(v20);
  v21 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL peerChannelsteerBefore:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 98));
  objc_autoreleasePoolPop(v21);
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL peerChannelsteerAfter:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 99));
  objc_autoreleasePoolPop(v22);
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL psfDwellSessionCount:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 100));
  objc_autoreleasePoolPop(v23);
  v24 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL serviceCount:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 62));
  objc_autoreleasePoolPop(v24);
  v25 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL totalDuration:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 101));
  objc_autoreleasePoolPop(v25);
  v26 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL inActiveDuration:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 102));
  objc_autoreleasePoolPop(v26);
  v27 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL activeDuration:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 103));
  objc_autoreleasePoolPop(v27);
  v28 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL percentageInactiveTime:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 104));
  objc_autoreleasePoolPop(v28);
  v29 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL timeToService:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 105));
  objc_autoreleasePoolPop(v29);
  v30 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL percentageInfraIdleTime:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 106));
  objc_autoreleasePoolPop(v30);
  v31 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL percentageInfraRealTime:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 107));
  objc_autoreleasePoolPop(v31);
  v32 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL percentageInfraNonRealTime:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned int *)v9 + 108));
  objc_autoreleasePoolPop(v32);
  v33 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isAirPlayActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 448));
  objc_autoreleasePoolPop(v33);
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isRemoteCameraActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 449));
  objc_autoreleasePoolPop(v34);
  v35 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isRemoteScreenActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 450));
  objc_autoreleasePoolPop(v35);
  v36 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isSideCarActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 451));
  objc_autoreleasePoolPop(v36);
  v37 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isTvRemoteCameraActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 452));
  objc_autoreleasePoolPop(v37);
  v38 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isUniversalControlActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 453));
  objc_autoreleasePoolPop(v38);
  v39 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isStereoPairActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 454));
  objc_autoreleasePoolPop(v39);
  v40 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isAirDropServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 455));
  objc_autoreleasePoolPop(v40);
  v41 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isAirplayP2PServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 456));
  objc_autoreleasePoolPop(v41);
  v42 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isAirplayServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 457));
  objc_autoreleasePoolPop(v42);
  v43 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isATPServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 458));
  objc_autoreleasePoolPop(v43);
  v44 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isCompanionLinkServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 459));
  objc_autoreleasePoolPop(v44);
  v45 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isIEEE1588ServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 460));
  objc_autoreleasePoolPop(v45);
  v46 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isRaopServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 461));
  objc_autoreleasePoolPop(v46);
  v47 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isRDLinkServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 462));
  objc_autoreleasePoolPop(v47);
  v48 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isDFSMonServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 463));
  objc_autoreleasePoolPop(v48);
  v49 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isWiFidServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 464));
  objc_autoreleasePoolPop(v49);
  v50 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL isTestServiceActive:%d", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 465));
  objc_autoreleasePoolPop(v50);
  v51 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL peerChannelOui:%x:%x:%x", "WiFiMetricsManagerProcessAwdlUsageData", *((unsigned __int8 *)v9 + 466), *((unsigned __int8 *)v9 + 467), *((unsigned __int8 *)v9 + 468));
  objc_autoreleasePoolPop(v51);
  v52 = (unsigned int *)malloc_type_malloc(0x128uLL, 0x1030040B7FBC384uLL);
  memcpy(v52, v9 + 22, 0x128uLL);
  *((_QWORD *)v52 + 8) = 0;
  *((_QWORD *)v52 + 10) = 0;
  *((_QWORD *)v52 + 17) = 0;
  *((_QWORD *)v52 + 19) = 0;
  if (v9[30])
  {
    v53 = *((unsigned int *)v9 + 58);
    if ((_DWORD)v53)
    {
      v54 = malloc_type_calloc(v53, 0x10uLL, 0x1000040F7F8B94BuLL);
      *((_QWORD *)v52 + 8) = v54;
      memcpy(v54, (const void *)v9[30], 16 * *((unsigned int *)v9 + 58));
    }
  }
  if (v9[32])
  {
    v55 = *((unsigned int *)v9 + 62);
    if ((_DWORD)v55)
    {
      v56 = malloc_type_calloc(v55, 0x30uLL, 0x1000040634EFA27uLL);
      *((_QWORD *)v52 + 10) = v56;
      memcpy(v56, (const void *)v9[32], 48 * *((unsigned int *)v9 + 62));
    }
  }
  if (v9[39])
  {
    v57 = *((unsigned int *)v9 + 80);
    if ((_DWORD)v57)
    {
      v58 = malloc_type_calloc(v57, 0x18uLL, 0x1000040504FFAC1uLL);
      *((_QWORD *)v52 + 17) = v58;
      memcpy(v58, (const void *)v9[39], 24 * *((unsigned int *)v9 + 80));
    }
  }
  if (v9[41])
  {
    v59 = *((unsigned int *)v9 + 84);
    if ((_DWORD)v59)
    {
      v60 = malloc_type_calloc(v59, 0x18uLL, 0x1000040504FFAC1uLL);
      *((_QWORD *)v52 + 19) = v60;
      memcpy(v60, (const void *)v9[41], 24 * *((unsigned int *)v9 + 84));
    }
  }
  if (v9[43])
  {
    v61 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
    *((_QWORD *)v52 + 21) = v61;
    v62 = (_OWORD *)v9[43];
    v63 = v62[1];
    *v61 = *v62;
    v61[1] = v63;
  }
  if (v9[47])
  {
    v64 = malloc_type_calloc(*((unsigned int *)v9 + 92), 2uLL, 0x1000040BDFB0063uLL);
    *((_QWORD *)v52 + 25) = v64;
    memcpy(v64, (const void *)v9[47], 2 * *((unsigned int *)v9 + 92));
  }
  v65 = objc_autoreleasePoolPush();
  v66 = objc_alloc((Class)WAMessage);
  v67 = objc_msgSend(v66, "initWithMetricName:options:", kWAMessageMetricNameAwdlUsage, 7);
  if (v67)
  {
    v68 = v67;
    objc_msgSend(v67, "addFieldForKey:value:options:", CFSTR("periodInMinutes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[10]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("flags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[4]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersOn24G"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 7)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("appTxBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[9]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("appRxBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[8]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("ifTxBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[7]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("ifRxBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[6]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("noServiceIdleTime"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[12]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("suspendedDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[66]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("suspendCount"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[47]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspCSAReceivedFromPeer"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[22]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersNotAssociated"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 10)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspSuspect"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[24]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspResume"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[25]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numRTSessions"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[32]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspAirplayFailed"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[27]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerInfraChannel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 4)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerInfraChannelFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[45]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspCSAReceivedFromAP"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[23]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersDiffInfra"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 11)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersSameInfra"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 12)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersOn5G"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 8)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numOfPeers"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 5)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("dfspAirplayConnected"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[26]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numSyncChanges"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[28]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersOnDFS"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 9)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("ifPacketFailures"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[5]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("selfInfraChannel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *v52), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("selfInfraChannelFlags"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[44]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numOfCachedPeers"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 6)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numInputPacketsDropped"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[30]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("numPeersWithZeroExtLen"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[31]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerChannelsteerBefore"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[54]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerChannelsteerAfter"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[55]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("psfDwellSessionCount"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[56]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("serviceCount"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[18]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("totalDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[57]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("inActiveDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[58]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("activeDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[59]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("percentageInactiveTime"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[60]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("timeToService"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[61]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("percentageInfraIdleTime"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[62]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("percentageInfraRealTime"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[63]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("percentageInfraNonRealTime"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[64]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isAirPlayActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 272) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isRemoteCameraActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 273) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isRemoteScreenActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 274) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isSideCarActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 275) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isTvRemoteCameraActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 276) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isUniversalControlActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 277) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isStereoPairActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 278) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isAirDropServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 279) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isAirplayP2PServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 280) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isAirplayServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 281) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isATPServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 282) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isCompanionLinkServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 283) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isIEEE1588ServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 284) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isRaopServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 285) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isRDLinkServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 286) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isDFSMonServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 287) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isWiFidServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 288) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("isTestServiceActive"), +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)v52 + 289) != 0), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerChannelsteerOUI"), +[NSString stringWithString:](NSString, "stringWithString:", sub_1000572CC((uint64_t)v52 + 290, 3u)), 7);
    if (v52[36])
    {
      v69 = 0;
      v70 = 0;
      do
      {
        v71 = (double *)(*((_QWORD *)v52 + 17) + v69);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("hopCountHistogramBins_%u_binStart"), v70), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *v71), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("hopCountHistogramBins_%u_value"), v70), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v71[2]), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("hopCountHistogramBins_%u_binEnd"), v70++), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v71[1]), 7);
        v69 += 24;
      }
      while (v70 < v52[36]);
    }
    if (v52[40])
    {
      v72 = 0;
      v73 = 0;
      do
      {
        v74 = (double *)(*((_QWORD *)v52 + 19) + v72);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("parentRSSIHistogramBins_%u_binStart"), v73), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *v74), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("parentRSSIHistogramBins_%u_value"), v73), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v74[2]), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("parentRSSIHistogramBins_%u_binEnd"), v73++), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v74[1]), 7);
        v72 += 24;
      }
      while (v73 < v52[40]);
    }
    if (v52[18])
    {
      v75 = 0;
      v76 = 0;
      do
      {
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("services_%u_serviceKey"), v76), objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", *((_QWORD *)v52 + 10) + v75 + 16, 32), 1), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("services_%u_serviceId"), v76), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 10) + v75 + 4)), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("services_%u_opCode"), v76), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 10) + v75)), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("services_%u_type"), v76), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 10) + v75 + 1)), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("services_%u_duration"), v76++), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 10) + v75 + 8)), 7);
        v75 += 48;
      }
      while (v76 < v52[18]);
    }
    if (v52[14])
    {
      v77 = 0;
      v78 = 0;
      do
      {
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("states_%u_count"), v78), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 8) + v77)), 7);
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("states_%u_duration"), v78++), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 8) + v77 + 8)), 7);
        v77 += 16;
      }
      while (v78 < v52[14]);
    }
    v79 = *((_QWORD *)v52 + 21);
    if (v79)
    {
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_peerRssi"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v79 + 24)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_rxBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 21) + 16)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_txBytes"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(*((_QWORD *)v52 + 21) + 8)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_avgCCA"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 21) + 31)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_channel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 21) + 28)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_txFailureCount"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 21) + 29)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_sessionDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", **((unsigned int **)v52 + 21)), 7);
      objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("d2dMigrationStats_migrationRole"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(*((_QWORD *)v52 + 21) + 30)), 7);
    }
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeersOn6G"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 184)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("self6ECapable"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 185)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("cachedPeers6ECapable"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)v52 + 186)), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerChannelsteerAttemptCount_2G"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[52]), 7);
    objc_msgSend(v68, "addFieldForKey:value:options:", CFSTR("peerChannelsteerAttemptCount_5G"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v52[53]), 7);
    if (v52[48])
    {
      v80 = 0;
      do
      {
        objc_msgSend(v68, "addFieldForKey:value:options:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("lteRestrictedChannelsUsed_%u"), v80), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int16 *)(*((_QWORD *)v52 + 25) + 2 * v80)), 7);
        ++v80;
      }
      while (v80 < v52[48]);
    }
    sub_100052064(v68);

    v81 = (void *)*((_QWORD *)v52 + 10);
    if (v81)
      free(v81);
    v82 = (void *)*((_QWORD *)v52 + 8);
    if (v82)
      free(v82);
    v83 = (void *)*((_QWORD *)v52 + 19);
    if (v83)
      free(v83);
    v84 = (void *)*((_QWORD *)v52 + 17);
    if (v84)
      free(v84);
    v85 = (void *)*((_QWORD *)v52 + 21);
    if (v85)
      free(v85);
    v86 = (void *)*((_QWORD *)v52 + 25);
    if (v86)
      free(v86);
    free(v52);
  }
  objc_autoreleasePoolPop(v65);
  v87 = v92.i32[0];
  v88 = v92.u32[1];
LABEL_138:
  *((double *)v9 + 21) = Current;
  *((_DWORD *)v9 + 40) = v87;
  *((_DWORD *)v9 + 41) = v88;
}

id sub_1000572CC(uint64_t a1, unsigned int a2)
{
  id v4;
  uint64_t v5;
  void *v6;

  if (a1)
  {
    v4 = +[NSMutableString string](NSMutableString, "string");
    if (a2)
    {
      v5 = 0;
      do
      {
        objc_msgSend(v4, "appendFormat:", CFSTR("%02x"), *(unsigned __int8 *)(a1 + v5));
        if (v5 < a2 - 1)
          objc_msgSend(v4, "appendFormat:", CFSTR(":"));
        ++v5;
      }
      while (a2 != v5);
    }
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: returning %@", "__WiFiMetricsManagerGetColonHexdecFormat", v4);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: addr is NULL", "__WiFiMetricsManagerGetColonHexdecFormat");
    v4 = 0;
  }
  objc_autoreleasePoolPop(v6);
  return v4;
}

uint64_t sub_1000573F0()
{
  const __CFDictionary *v0;
  io_service_t MatchingService;
  io_registry_entry_t v2;
  CFTypeRef v3;
  void *v4;
  CFTypeID TypeID;
  void *v6;
  void *v7;
  CFTypeRef v9;
  const void *v10;
  CFTypeID v11;
  double v12;
  void *v13;
  void *v14;
  unsigned int valuePtr;

  valuePtr = 0;
  if (!qword_10026D5D8)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "__WiFiMetricsManagerGetDeviceInitFailureReason");
    goto LABEL_19;
  }
  v0 = IOServiceNameMatching("wlan");
  if (!v0)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Class  \"wlan\" NOT found ", "__WiFiMetricsManagerGetDeviceInitFailureReason");
    goto LABEL_19;
  }
  MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (!MatchingService)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: service for Class \"wlan\" NOT found ", "__WiFiMetricsManagerGetDeviceInitFailureReason");
LABEL_19:
    objc_autoreleasePoolPop(v7);
    return 0;
  }
  v2 = MatchingService;
  v3 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("com.apple.wlan.init_failure"), kCFAllocatorDefault, 3u);
  v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: data for com.apple.wlan.init_failure found", "__WiFiMetricsManagerGetDeviceInitFailureReason");
    objc_autoreleasePoolPop(v4);
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v3) && CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt32Type, &valuePtr))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceInitFailureReason:0x%0x ", "__WiFiMetricsManagerGetDeviceInitFailureReason", valuePtr);
      objc_autoreleasePoolPop(v6);
    }
    CFRelease(v3);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFi: \"com.apple.wlan.init_failure\" property not found.", "__WiFiMetricsManagerGetDeviceInitFailureReason");
    objc_autoreleasePoolPop(v4);
  }
  v9 = IORegistryEntrySearchCFProperty(v2, "IOService", CFSTR("com.apple.wlan.init_failure_string"), kCFAllocatorDefault, 3u);
  if (v9)
  {
    v10 = v9;
    v11 = CFStringGetTypeID();
    if (v11 == CFGetTypeID(v10))
    {
      v12 = CFAbsoluteTimeGetCurrent() - *(double *)(qword_10026D5D8 + 24);
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceInitFailureReason:%@ ", "__WiFiMetricsManagerGetDeviceInitFailureReason", v10);
      objc_autoreleasePoolPop(v13);
      -[WiFiUsageMonitor setDeviceInitializationFailureReason:timeSinceBoot:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setDeviceInitializationFailureReason:timeSinceBoot:", v10, v12);
    }
    CFRelease(v10);
  }
  else
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFi: \"com.apple.wlan.init_failure\" property not found.", "__WiFiMetricsManagerGetDeviceInitFailureReason");
    objc_autoreleasePoolPop(v14);
  }
  IOObjectRelease(v2);
  return valuePtr;
}

void sub_1000576F4(uint64_t a1, const __CFDictionary *a2)
{
  const void *v4;
  void *v5;
  uint64_t v6;
  const __CFString *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  void *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  uint64_t Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  uint64_t v16;
  const __CFString *v17;
  char *v18;
  char *v19;
  _WORD *v20;
  const void *v21;
  CFDataRef v22;
  const __CFData *v23;
  const __CFString *v24;
  const __CFBoolean *v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFString *v34;
  const __CFString *v35;
  CFTypeID v36;
  void *v37;
  const char *v38;
  const __CFString *v39;
  const __CFString *v40;
  CFTypeID v41;
  void *v42;
  const char *v43;
  void *v44;
  const __CFString *v45;
  const __CFString *v46;
  CFTypeID v47;
  void *v48;
  const char *v49;
  const __CFString *v50;
  const __CFString *v51;
  CFTypeID v52;
  void *v53;
  const char *v54;
  const __CFDictionary *v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  CFTypeID v58;
  CFStringRef v59;
  void *v60;
  const __CFString *v61;
  const __CFString *v62;
  CFTypeID v63;
  CFStringRef Copy;
  void *v65;
  const __CFString *v66;
  const __CFString *v67;
  CFTypeID v68;
  CFStringRef v69;
  void *v70;
  const __CFString *v71;
  const __CFString *v72;
  CFTypeID v73;
  CFStringRef v74;
  void *v75;
  const __CFString *v76;
  const __CFString *v77;
  CFTypeID v78;
  CFStringRef v79;
  void *v80;
  const __CFData *v81;
  const __CFData *v82;
  CFTypeID v83;
  CFIndex Length;
  UInt8 *v85;
  CFStringEncoding SystemEncoding;
  void *v87;
  const __CFNumber *v88;
  const __CFNumber *v89;
  CFTypeID v90;
  CFStringRef v91;
  void *v92;
  const __CFNumber *v93;
  const __CFNumber *v94;
  CFTypeID v95;
  CFStringRef v96;
  void *v97;
  const __CFNumber *v98;
  const __CFNumber *v99;
  CFTypeID v100;
  CFStringRef v101;
  void *v102;
  const __CFNumber *v103;
  const __CFNumber *v104;
  CFTypeID TypeID;
  CFStringRef v106;
  void *v107;
  void *v108;
  id v109;
  id v110;
  void *v111;
  _BYTE *v112;
  _BYTE *v113;
  uint64_t v114;
  unsigned int v115;
  id v116;
  void *v117;
  void *v118;
  const char *v119;
  const char *v120;
  void *v121;
  const char *v122;
  const char *v123;
  void *v124;
  void *v125;
  const void *v126;
  const void *v127;
  const void *v128;
  const void *v129;
  const void *v130;
  const void *v131;
  const void *v132;
  const void *v133;
  const void *v134;
  const void *v135;
  const void *v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  void *value;
  unsigned __int8 v142;
  unsigned __int8 v143;
  unsigned __int16 v144;
  unsigned __int16 v145;
  unsigned __int16 valuePtr;
  CFRange v147;
  CFRange v148;
  CFRange v149;

  if (!qword_10026D5D8)
    return;
  v4 = (const void *)sub_100025C3C(a1);
  v5 = (void *)sub_10002BF8C(a1, v4);
  value = v5;
  if (!v5)
  {
    v9 = 0;
    v8 = 0;
LABEL_16:
    if (!a1)
      goto LABEL_220;
    goto LABEL_17;
  }
  v6 = (uint64_t)v5;
  v7 = (const __CFString *)sub_10002BE64((uint64_t)v5, CFSTR("BSSID"));
  v8 = (const __CFDictionary *)sub_10002BE64(v6, CFSTR("WPS_PROB_RESP_IE"));
  v9 = (const __CFDictionary *)sub_10002BE64(v6, CFSTR("APPLE_IE"));
  if (v8)
    goto LABEL_16;
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s QFA Watchdog metric WPS PROBE RESPONSE IE not found in driverAvailableEventDict. Looking in cache...", "WiFiMetricsManagerSubmitWatchdogEvent");
  objc_autoreleasePoolPop(v10);
  v11 = (const __CFArray *)sub_10008674C(*(_QWORD *)(qword_10026D5D8 + 16));
  if (!v11)
    goto LABEL_12;
  v12 = v11;
  Count = CFArrayGetCount(v11);
  if (Count < 1)
    goto LABEL_12;
  v147.length = Count;
  v147.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v12, v147, value);
  if ((FirstIndexOfValue & 0x8000000000000000) == 0
    && (ValueAtIndex = CFArrayGetValueAtIndex(v12, FirstIndexOfValue)) != 0
    && (v16 = (uint64_t)ValueAtIndex,
        (v17 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID"))) != 0)
    && CFStringCompare(v7, v17, 1uLL) == kCFCompareEqualTo)
  {
    v8 = (const __CFDictionary *)sub_10002BE64(v16, CFSTR("WPS_PROB_RESP_IE"));
    if (v8)
    {
      v137 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s QFA Watchdog metricWPS PROBE RESPONSE IE found in Known networks cache", "WiFiMetricsManagerSubmitWatchdogEvent");
      objc_autoreleasePoolPop(v137);
      if (!a1)
        goto LABEL_220;
      goto LABEL_17;
    }
  }
  else
  {
LABEL_12:
    v8 = 0;
  }
  if (!a1)
  {
LABEL_220:
    v138 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerSubmitWatchdogEvent");
    goto LABEL_226;
  }
LABEL_17:
  if (!a2)
  {
    v138 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null driverAvailableEventDict", "WiFiMetricsManagerSubmitWatchdogEvent");
LABEL_226:
    objc_autoreleasePoolPop(v138);
    v126 = value;
    if (!value)
      return;
LABEL_214:
    CFRelease(v126);
    return;
  }
  v18 = (char *)malloc_type_malloc(0x1310uLL, 0x10600406BF74C50uLL);
  if (!v18)
  {
    v138 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null watchdogEventMetric", "WiFiMetricsManagerSubmitWatchdogEvent");
    goto LABEL_226;
  }
  v19 = v18;
  bzero(v18, 0x1310uLL);
  v20 = sub_1000764F8(a1);
  if (v20)
  {
    v21 = v20;
    v22 = sub_1000C4110((uint64_t)v20);
    if (v22)
    {
      v23 = v22;
      v24 = (const __CFString *)sub_10002BE64((uint64_t)v21, CFSTR("BSSID"));
      *((_QWORD *)v19 + 608) = CFStringCreateCopy(kCFAllocatorDefault, v24);
      v148.location = 0;
      v148.length = 3;
      CFDataGetBytes(v23, v148, (UInt8 *)v19 + 4876);
      CFRelease(v23);
    }
    CFRelease(v21);
  }
  v25 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE"));
  if (v25)
  {
    *((_DWORD *)v19 + 2) = CFBooleanGetValue(v25);
    v26 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_FLAGS"));
    if (v26)
    {
      CFNumberGetValue(v26, kCFNumberSInt32Type, v19 + 4);
      if (!*((_DWORD *)v19 + 2)
        || *(double *)(qword_10026D5D8 + 80) != 0.0
        && (*((_DWORD *)v19 + 1218) = ((CFAbsoluteTimeGetCurrent() - *(double *)(qword_10026D5D8 + 80))
                                                   * 1000.0),
            !*((_DWORD *)v19 + 2)))
      {
        if ((v19[4] & 2) != 0)
        {
          *(_QWORD *)(qword_10026D5D8 + 88) = 0;
        }
        else
        {
          if (*(double *)(qword_10026D5D8 + 80) != 0.0)
            *(_QWORD *)(qword_10026D5D8 + 88) = (unint64_t)((CFAbsoluteTimeGetCurrent()
                                                                  - *(double *)(qword_10026D5D8 + 80))
                                                                 * 1000.0);
          *(CFAbsoluteTime *)(qword_10026D5D8 + 80) = CFAbsoluteTimeGetCurrent();
        }
      }
      v27 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_REASON"));
      if (v27)
      {
        CFNumberGetValue(v27, kCFNumberSInt32Type, v19 + 12);
        v28 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_SUBREASON"));
        if (v28)
        {
          CFNumberGetValue(v28, kCFNumberSInt32Type, v19 + 16);
          v29 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_VERSION"));
          if (v29)
          {
            CFNumberGetValue(v29, kCFNumberSInt32Type, v19);
            v30 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_PROGRAM_COUNTER"));
            if (v30)
              CFNumberGetValue(v30, kCFNumberSInt64Type, v19 + 160);
            v31 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_LINK_REGISTER"));
            if (v31)
              CFNumberGetValue(v31, kCFNumberSInt64Type, v19 + 168);
            v32 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_LINENUMBER"));
            if (v32)
              CFNumberGetValue(v32, kCFNumberSInt32Type, v19 + 208);
            if (CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_HAVE_EXT_TRAP")) == kCFBooleanTrue)
            {
              v19[244] = 1;
              v33 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_TRAP_SEQUENCE"));
              if (v33)
                CFNumberGetValue(v33, kCFNumberSInt32Type, v19 + 248);
              sub_100058CF4(v19 + 252, (_DWORD *)v19 + 143, a2, CFSTR("DRIVER_AVAILABLE_TRAP_SIGNATURE"));
              sub_100058CF4(v19 + 576, (_DWORD *)v19 + 224, a2, CFSTR("DRIVER_AVAILABLE_TRAP_STACK"));
              sub_100058CF4(v19 + 900, (_DWORD *)v19 + 305, a2, CFSTR("DRIVER_AVAILABLE_TRAP_MEMORY"));
              sub_100058CF4(v19 + 1224, (_DWORD *)v19 + 386, a2, CFSTR("DRIVER_AVAILABLE_TRAP_UCODE"));
              sub_100058CF4(v19 + 1548, (_DWORD *)v19 + 467, a2, CFSTR("DRIVER_AVAILABLE_TRAP_DEEP_SLEEP"));
              sub_100058CF4(v19 + 1872, (_DWORD *)v19 + 548, a2, CFSTR("DRIVER_AVAILABLE_TRAP_PSM_WD"));
              sub_100058CF4(v19 + 2196, (_DWORD *)v19 + 629, a2, CFSTR("DRIVER_AVAILABLE_TRAP_PHY"));
              sub_100058CF4(v19 + 2520, (_DWORD *)v19 + 710, a2, CFSTR("DRIVER_AVAILABLE_TRAP_BUS"));
              sub_100058CF4(v19 + 2844, (_DWORD *)v19 + 791, a2, CFSTR("DRIVER_AVAILABLE_TRAP_MAC"));
              sub_100058CF4(v19 + 3168, (_DWORD *)v19 + 872, a2, CFSTR("DRIVER_AVAILABLE_TRAP_BACKPLANE"));
              sub_100058CF4(v19 + 3492, (_DWORD *)v19 + 953, a2, CFSTR("DRIVER_AVAILABLE_KEY_PCIE_QUEUE"));
              sub_100058CF4(v19 + 3816, (_DWORD *)v19 + 1034, a2, CFSTR("DRIVER_AVAILABLE_KEY_WLAN_STATE"));
              sub_100058CF4(v19 + 4140, (_DWORD *)v19 + 1115, a2, CFSTR("DRIVER_AVAILABLE_KEY_MAC_ENAB"));
              sub_100058CF4(v19 + 4464, (_DWORD *)v19 + 1196, a2, CFSTR("DRIVER_AVAILABLE_KEY_TX_ERR_THRESH"));
            }
            v34 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
            v35 = v34;
            if (v34 && (v36 = CFGetTypeID(v34), v36 == CFStringGetTypeID()))
            {
              CFStringGetCString(v35, v19 + 28, 63, 0);
            }
            else
            {
              v37 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v38 = "Not a string";
                if (!v35)
                  v38 = "is Null or Key-not-present";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: reasonString :%s", "WiFiMetricsManagerSubmitWatchdogEvent", v38);
              }
              objc_autoreleasePoolPop(v37);
            }
            v39 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_KEY_SUBREASON_STRING"));
            v40 = v39;
            if (v39 && (v41 = CFGetTypeID(v39), v41 == CFStringGetTypeID()))
            {
              CFStringGetCString(v40, v19 + 92, 63, 0);
            }
            else
            {
              v42 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v43 = "Not a string";
                if (!v40)
                  v43 = "is Null or Key-not-present";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: subReasonString :%s", "WiFiMetricsManagerSubmitWatchdogEvent", v43);
              }
              objc_autoreleasePoolPop(v42);
            }
            v44 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: reason:%s(0x%8x or %d), subreason:%s(0x%8x or %u) flag: %u", "WiFiMetricsManagerSubmitWatchdogEvent", v19 + 28, *((unsigned int *)v19 + 3), *((unsigned int *)v19 + 3), v19 + 92, *((unsigned int *)v19 + 4), *((unsigned int *)v19 + 4), *((unsigned int *)v19 + 1));
            objc_autoreleasePoolPop(v44);
            v45 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_FILENAME"));
            v46 = v45;
            if (v45 && (v47 = CFGetTypeID(v45), v47 == CFStringGetTypeID()))
            {
              CFStringGetCString(v46, v19 + 176, 31, 0);
            }
            else
            {
              v48 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v49 = "Not a string";
                if (!v46)
                  v49 = "is Null or Key-not-present";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Filename :%s", "WiFiMetricsManagerSubmitWatchdogEvent", v49);
              }
              objc_autoreleasePoolPop(v48);
            }
            v50 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DRIVER_AVAILABLE_FUNCTION "));
            v51 = v50;
            if (v50 && (v52 = CFGetTypeID(v50), v52 == CFStringGetTypeID()))
            {
              CFStringGetCString(v51, v19 + 212, 31, 0);
              if (!v8)
                goto LABEL_138;
            }
            else
            {
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v54 = "Not a string";
                if (!v51)
                  v54 = "is Null or Key-not-present";
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Function name :%s", "WiFiMetricsManagerSubmitWatchdogEvent", v54);
              }
              objc_autoreleasePoolPop(v53);
              if (!v8)
              {
LABEL_138:
                if (v9)
                {
                  v142 = -86;
                  v103 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("APPLE_IE_PRODUCT_ID"));
                  if (v103 && (v104 = v103, TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(v104)))
                  {
                    CFNumberGetValue(v104, kCFNumberSInt8Type, &v142);
                    v106 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v142);
                  }
                  else
                  {
                    v107 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsResponseType. Not a CFNumberType or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
                    objc_autoreleasePoolPop(v107);
                    v106 = 0;
                  }
                  *((_QWORD *)v19 + 602) = v106;
                }
                v108 = objc_autoreleasePoolPush();
                if (!*((_DWORD *)v19 + 2))
                  goto LABEL_192;
                if (qword_10026D5D8)
                {
                  v109 = objc_alloc((Class)WAMessage);
                  v110 = objc_msgSend(v109, "initWithMetricName:options:", kWAMessageMetricNameWatchdogEvent, 5);
                  if (v110)
                  {
                    v111 = v110;
                    objc_msgSend(v110, "addFieldForKey:value:options:", kWAMessageKeyReason, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)v19 + 3)), 5);
                    objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeySubReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned int *)v19 + 4)), 5);
                    v112 = v19 + 28;
                    objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyReasonString, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v19 + 28), 5);
                    v113 = v19 + 92;
                    objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeySubReasonString, +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), v19 + 92), 5);
                    if (*((_QWORD *)v19 + 600))
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyWPSMfgElement, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
                    if (*((_QWORD *)v19 + 601))
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyWPSModelName, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
                    if (*((_QWORD *)v19 + 602))
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyWPSModelNum, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
                    if (*((_QWORD *)v19 + 605))
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyWPSPrimaryDeviceNameElement, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
                    if (*((_QWORD *)v19 + 606))
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyWPSDeviceNameData, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
                    objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyForegroundActivity, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1000AA26C(*(_QWORD *)(qword_10026D5D8 + 16)) != 0), 5);
                    v114 = qword_10026D5D8;
                    if (*(_QWORD *)(qword_10026D5D8 + 88))
                    {
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyTimeBetweenFailure, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), 5);
                      v114 = qword_10026D5D8;
                    }
                    if (*(double *)(v114 + 80) != 0.0)
                      objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyRecoveryLatency, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned int *)v19 + 1218)), 5);
                    v115 = *((_DWORD *)v19 + 1);
                    objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyIsDriverAvailabilityNonFatal, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", (v115 >> 1) & 1), 5);
                    sub_100063954(v111, kWAMessageKeyOUI, (uint64_t)(v19 + 4876), 3u, 1);
                    if (*((_QWORD *)v19 + 608))
                    {
                      v116 = +[WiFiUsageAccessPointProfile profileForBSSID:](WiFiUsageAccessPointProfile, "profileForBSSID:");
                      if (v116)
                        objc_msgSend(v111, "addFieldForKey:value:options:", kWAMessageKeyApProfile, v116, 5);
                    }
                    sub_100052064(v111);
                    if ((v115 & 2) == 0 && MGGetBoolAnswer(CFSTR("InternalBuild")) && (!*v112 || !*v113))
                    {
                      v117 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Fatal chip watchdog with missing reason or subreason", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent");
                      objc_autoreleasePoolPop(v117);
                      v118 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                      {
                        if (*v112)
                          v119 = v19 + 28;
                        else
                          v119 = "zeroLen";
                        if (*v113)
                          v120 = v19 + 92;
                        else
                          v120 = "zeroLen";
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: reason: 0x%x reasonString: %s subreason: 0x%x subreasonString: %s", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent", *((unsigned int *)v19 + 3), v119, *((unsigned int *)v19 + 4), v120);
                      }
                      objc_autoreleasePoolPop(v118);
                      v121 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                      {
                        if (v19[176])
                          v122 = v19 + 176;
                        else
                          v122 = "zeroLen";
                        v123 = v19 + 212;
                        if (!v19[212])
                          v123 = "zeroLen";
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: flags: 0x%x available: 0x%x minor_reason: 0x%x filename: %s function: %s", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent", *((unsigned int *)v19 + 1), *((unsigned int *)v19 + 2), *((unsigned int *)v19 + 6), v122, v123);
                      }
                      objc_autoreleasePoolPop(v121);
                      v124 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: hasExtTrapInfo: 0x%x sequenceNum: %d signatureCount: %d stackTraceCount: %d recoveryLatency: %d", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent", v19[244], *((unsigned int *)v19 + 62), *((unsigned int *)v19 + 143), *((unsigned int *)v19 + 224), *((unsigned int *)v19 + 1218));
                      objc_autoreleasePoolPop(v124);
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
                        sub_1001869A8();
                    }

                    goto LABEL_192;
                  }
                  v140 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for WatchdogEvent", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent");
                }
                else
                {
                  v140 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: metrics null", "__WiFiMetricsManagerWAMessageSubmitWatchdogEvent");
                }
                objc_autoreleasePoolPop(v140);
LABEL_192:
                v125 = v108;
                goto LABEL_193;
              }
            }
            v55 = (const __CFDictionary *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_PRIMARY_DEV_TYPE"));
            valuePtr = -21846;
            v56 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_CFG_METHODS"));
            if (v56 && (v57 = v56, v58 = CFNumberGetTypeID(), v58 == CFGetTypeID(v57)))
            {
              CFNumberGetValue(v57, kCFNumberSInt16Type, &valuePtr);
              v59 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), valuePtr);
            }
            else
            {
              v60 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsConfigMethods. Not a CFNumber or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v60);
              v59 = 0;
            }
            *((_QWORD *)v19 + 607) = v59;
            v61 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MODEL_NAME"));
            if (v61 && (v62 = v61, v63 = CFStringGetTypeID(), v63 == CFGetTypeID(v62)))
            {
              Copy = CFStringCreateCopy(kCFAllocatorDefault, v62);
            }
            else
            {
              v65 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelName. Not a CFString or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v65);
              Copy = 0;
            }
            *((_QWORD *)v19 + 601) = Copy;
            v66 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MODEL_NUM"));
            if (v66 && (v67 = v66, v68 = CFStringGetTypeID(), v68 == CFGetTypeID(v67)))
            {
              v69 = CFStringCreateCopy(kCFAllocatorDefault, v67);
            }
            else
            {
              v70 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsModelNumber. Not a CFString or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v70);
              v69 = 0;
            }
            *((_QWORD *)v19 + 602) = v69;
            v71 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_MANUFACTURER"));
            if (v71 && (v72 = v71, v73 = CFStringGetTypeID(), v73 == CFGetTypeID(v72)))
            {
              v74 = CFStringCreateCopy(kCFAllocatorDefault, v72);
            }
            else
            {
              v75 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsManufacturerElement. Not a CFString or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v75);
              v74 = 0;
            }
            *((_QWORD *)v19 + 600) = v74;
            v76 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_DEV_NAME"));
            if (v76 && (v77 = v76, v78 = CFStringGetTypeID(), v78 == CFGetTypeID(v77)))
            {
              v79 = CFStringCreateCopy(kCFAllocatorDefault, v77);
            }
            else
            {
              v80 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsDeviceNameElement. Not a CFString or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v80);
              v79 = 0;
            }
            *((_QWORD *)v19 + 605) = v79;
            v81 = (const __CFData *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_DEV_NAME_DATA"));
            if (v81 && (v82 = v81, v83 = CFDataGetTypeID(), v83 == CFGetTypeID(v82)))
            {
              Length = CFDataGetLength(v82);
              v85 = (UInt8 *)malloc_type_malloc(Length, 0x100004077774924uLL);
              v149.location = 0;
              v149.length = Length;
              CFDataGetBytes(v82, v149, v85);
              SystemEncoding = CFStringGetSystemEncoding();
              *((_QWORD *)v19 + 606) = CFStringCreateWithBytes(kCFAllocatorDefault, v85, Length, SystemEncoding, 0);
              free(v85);
              if (!v55)
              {
LABEL_131:
                v143 = -86;
                v98 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("IE_KEY_WPS_RESP_TYPE"));
                if (v98 && (v99 = v98, v100 = CFNumberGetTypeID(), v100 == CFGetTypeID(v99)))
                {
                  CFNumberGetValue(v99, kCFNumberSInt8Type, &v143);
                  v101 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v143);
                }
                else
                {
                  v102 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsResponseType. Not a CFNumberType or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
                  objc_autoreleasePoolPop(v102);
                  v101 = 0;
                }
                *((_QWORD *)v19 + 599) = v101;
                goto LABEL_138;
              }
            }
            else
            {
              v87 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wpsDeviceNameData value is NULL or bad type for wpsDeviceNameData. Not a CFDataType ", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v87);
              *((_QWORD *)v19 + 606) = 0;
              if (!v55)
                goto LABEL_131;
            }
            v145 = -21846;
            v144 = -21846;
            v88 = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("WPS_DEV_TYPE_CAT"));
            if (v88 && (v89 = v88, v90 = CFNumberGetTypeID(), v90 == CFGetTypeID(v89)))
            {
              CFNumberGetValue(v89, kCFNumberSInt16Type, &v145);
              v91 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v145);
            }
            else
            {
              v92 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsPrimaryDeviceTypeCategory. Not a CFNumberType or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v92);
              v91 = 0;
            }
            *((_QWORD *)v19 + 603) = v91;
            v93 = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("WPS_DEV_TYPE_SUB_CAT"));
            if (v93 && (v94 = v93, v95 = CFNumberGetTypeID(), v95 == CFGetTypeID(v94)))
            {
              CFNumberGetValue(v94, kCFNumberSInt16Type, &v144);
              v96 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v144);
            }
            else
            {
              v97 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bad type for wpsPrimaryDeviceTypeSubCategory. Not a CFNumberType or NULL", "WiFiMetricsManagerSubmitWatchdogEvent");
              objc_autoreleasePoolPop(v97);
              v96 = 0;
            }
            *((_QWORD *)v19 + 604) = v96;
            goto LABEL_131;
          }
          v139 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null version", "WiFiMetricsManagerSubmitWatchdogEvent");
        }
        else
        {
          v139 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null subreason", "WiFiMetricsManagerSubmitWatchdogEvent");
        }
      }
      else
      {
        v139 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null reason", "WiFiMetricsManagerSubmitWatchdogEvent");
      }
    }
    else
    {
      v139 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null flags", "WiFiMetricsManagerSubmitWatchdogEvent");
    }
  }
  else
  {
    v139 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null available BOOLRef", "WiFiMetricsManagerSubmitWatchdogEvent");
  }
  v125 = v139;
LABEL_193:
  objc_autoreleasePoolPop(v125);
  v126 = value;
  v127 = (const void *)*((_QWORD *)v19 + 599);
  if (v127)
  {
    CFRelease(v127);
    *((_QWORD *)v19 + 599) = 0;
  }
  v128 = (const void *)*((_QWORD *)v19 + 600);
  if (v128)
  {
    CFRelease(v128);
    *((_QWORD *)v19 + 600) = 0;
  }
  v129 = (const void *)*((_QWORD *)v19 + 601);
  if (v129)
  {
    CFRelease(v129);
    *((_QWORD *)v19 + 601) = 0;
  }
  v130 = (const void *)*((_QWORD *)v19 + 602);
  if (v130)
  {
    CFRelease(v130);
    *((_QWORD *)v19 + 602) = 0;
  }
  v131 = (const void *)*((_QWORD *)v19 + 603);
  if (v131)
  {
    CFRelease(v131);
    *((_QWORD *)v19 + 603) = 0;
  }
  v132 = (const void *)*((_QWORD *)v19 + 604);
  if (v132)
  {
    CFRelease(v132);
    *((_QWORD *)v19 + 604) = 0;
  }
  v133 = (const void *)*((_QWORD *)v19 + 605);
  if (v133)
  {
    CFRelease(v133);
    *((_QWORD *)v19 + 605) = 0;
  }
  v134 = (const void *)*((_QWORD *)v19 + 606);
  if (v134)
  {
    CFRelease(v134);
    *((_QWORD *)v19 + 606) = 0;
  }
  v135 = (const void *)*((_QWORD *)v19 + 607);
  if (v135)
  {
    CFRelease(v135);
    *((_QWORD *)v19 + 607) = 0;
  }
  v136 = (const void *)*((_QWORD *)v19 + 608);
  if (v136)
    CFRelease(v136);
  free(v19);
  if (value)
    goto LABEL_214;
}

void sub_100058CF4(void *a1, _DWORD *a2, CFDictionaryRef theDict, void *key)
{
  const __CFArray *Value;
  const __CFArray *v9;
  CFIndex Count;
  int v11;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  int v14;
  int valuePtr;

  if (CFDictionaryContainsKey(theDict, key))
  {
    Value = (const __CFArray *)CFDictionaryGetValue(theDict, key);
    if (Value)
    {
      v9 = Value;
      Count = CFArrayGetCount(Value);
      v11 = 4 * Count;
      if (4 * (int)Count >= 80)
        v11 = 80;
      bzero(a1, v11);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v9, i);
          valuePtr = 0;
          if (ValueAtIndex)
          {
            CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
            v14 = valuePtr;
          }
          else
          {
            v14 = 0;
          }
          *((_DWORD *)a1 + i) = v14;
        }
      }
      *a2 = Count;
    }
  }
}

void sub_100058DC8(_QWORD *a1, int a2, const void *a3)
{
  uint64_t v4;
  UInt8 *v7;
  UInt8 *v8;
  const __CFData *v9;
  const __CFData *v10;
  const void *v11;
  const __CFDictionary *v12;
  const __CFDictionary *Copy;
  const __CFDictionary *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  void *v24;
  CFRange v25;

  if (!qword_10026D5D8 || (v4 = *(_QWORD *)(qword_10026D5D8 + 16)) == 0)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerSubmitWiFiKnownNetworksEvent");
    goto LABEL_37;
  }
  if (sub_100093FDC(v4) == 1)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitWiFiKnownNetworksEvent");
    goto LABEL_37;
  }
  v7 = (UInt8 *)malloc_type_malloc(0x10uLL, 0x1000040A0FC927FuLL);
  if (!v7)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null knownNetworksEventMetric", "WiFiMetricsManagerSubmitWiFiKnownNetworksEvent");
LABEL_37:
    objc_autoreleasePoolPop(v23);
    return;
  }
  v8 = v7;
  *(_QWORD *)v7 = 0;
  *((_QWORD *)v7 + 1) = 0;
  v9 = sub_1000C4110((uint64_t)a3);
  if (v9)
  {
    v10 = v9;
    v25.location = 0;
    v25.length = 3;
    CFDataGetBytes(v9, v25, v8 + 12);
    CFRelease(v10);
  }
  *(_DWORD *)v8 = a2;
  *((_DWORD *)v8 + 2) = sub_1000C5C14((uint64_t)a3);
  *((_DWORD *)v8 + 1) |= 16 * (sub_100031670(a3) != 0);
  *((_DWORD *)v8 + 1) |= 8 * (sub_10002B704((uint64_t)a3) != 0);
  *((_DWORD *)v8 + 1) |= 4 * sub_1000C475C((uint64_t)a3);
  *((_DWORD *)v8 + 1) |= 32 * (sub_1000C9410((uint64_t)a3) != 0);
  *((_DWORD *)v8 + 1) |= (sub_1000C3F88((uint64_t)a3) == 1) << 6;
  if (sub_1000C5378((uint64_t)a3))
    *((_DWORD *)v8 + 1) |= 2u;
  v11 = sub_10002B088(a3);
  v12 = sub_1000A60FC(a1);
  if (v12)
  {
    Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v12);
    v14 = Copy;
    if (v11 && Copy && CFDictionaryContainsKey(Copy, v11))
      *((_DWORD *)v8 + 1) |= 1u;
  }
  else
  {
    v14 = 0;
  }
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: eventType %d, networkSecurity %d, networkTypeBitMap 0x%X, oui %X:%X:%X", "WiFiMetricsManagerSubmitWiFiKnownNetworksEvent", *(unsigned int *)v8, *((unsigned int *)v8 + 2), *((unsigned int *)v8 + 1), v8[12], v8[13], v8[14]);
  objc_autoreleasePoolPop(v15);
  v16 = objc_autoreleasePoolPush();
  v17 = objc_autoreleasePoolPush();
  v18 = objc_alloc((Class)WAMessage);
  v19 = objc_msgSend(v18, "initWithMetricName:options:", kWAMessageMetricNameKnownNetworkEvent, 6);
  if (v19)
  {
    v20 = v19;
    if ((*(_DWORD *)v8 - 1) >= 0xF)
      v21 = 16;
    else
      v21 = *(unsigned int *)v8;
    objc_msgSend(v19, "addFieldForKey:value:options:", kWAMessageKeyKnownNetworkEventType, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v21), 7);
    objc_msgSend(v20, "addFieldForKey:value:options:", kWAMessageKeyKnownNetworkTypeBitmap, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned int *)v8 + 1)), 7);
    objc_msgSend(v20, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned int *)v8 + 2)), 7);
    sub_100063954(v20, kWAMessageKeyOUI, (uint64_t)(v8 + 12), 3u, 1);
    if (!sub_100060C54(v20, a3, 6))
    {
      v22 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to WAMessage", "__WiFiMetricsManagerWAMessageUpdateKnownNetworkEvent");
      objc_autoreleasePoolPop(v22);
    }
    sub_100052064(v20);

  }
  else
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for KnownNetworksEvent", "__WiFiMetricsManagerWAMessageUpdateKnownNetworkEvent");
    objc_autoreleasePoolPop(v24);
  }
  objc_autoreleasePoolPop(v17);
  objc_autoreleasePoolPop(v16);
  if (v12)
    CFRelease(v12);
  if (v14)
    CFRelease(v14);
  free(v8);
}

void sub_100059250(_BYTE *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  void *v15;
  void *context;
  void *v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  id v39;
  id v40;
  id v41;
  id v42;
  id v43;
  id v44;
  id v45;
  id v46;
  id v47;
  id v48;
  id v49;
  id v50;
  id v51;
  id v52;
  id v53;

  if (a1)
  {
    v2 = malloc_type_malloc(0x5A8uLL, 0x1000040C09493A1uLL);
    if (v2)
    {
      v3 = v2;
      bzero(v2, 0x5A8uLL);
      memmove(v3, a1, 0x5A8uLL);
      v4 = objc_autoreleasePoolPush();
      v5 = objc_autoreleasePoolPush();
      if (*a1)
      {
        v6 = objc_alloc((Class)WAMessage);
        v7 = objc_msgSend(v6, "initWithMetricName:options:", kWAMessageMetricNameLinkQualityStats, 5);
        if (v7)
        {
          v15 = v7;
          context = v5;
          v17 = v4;
          v19 = +[NSMutableString string](NSMutableString, "string");
          v20 = +[NSMutableString string](NSMutableString, "string");
          v21 = +[NSMutableString string](NSMutableString, "string");
          v22 = +[NSMutableString string](NSMutableString, "string");
          v23 = +[NSMutableString string](NSMutableString, "string");
          v24 = +[NSMutableString string](NSMutableString, "string");
          v32 = +[NSMutableString string](NSMutableString, "string");
          v18 = +[NSMutableString string](NSMutableString, "string");
          v25 = +[NSMutableString string](NSMutableString, "string");
          v26 = +[NSMutableString string](NSMutableString, "string");
          v27 = +[NSMutableString string](NSMutableString, "string");
          v28 = +[NSMutableString string](NSMutableString, "string");
          v29 = +[NSMutableString string](NSMutableString, "string");
          v30 = +[NSMutableString string](NSMutableString, "string");
          v31 = +[NSMutableString string](NSMutableString, "string");
          v33 = +[NSMutableString string](NSMutableString, "string");
          v34 = +[NSMutableString string](NSMutableString, "string");
          v35 = +[NSMutableString string](NSMutableString, "string");
          v36 = +[NSMutableString string](NSMutableString, "string");
          v37 = +[NSMutableString string](NSMutableString, "string");
          v38 = +[NSMutableString string](NSMutableString, "string");
          v39 = +[NSMutableString string](NSMutableString, "string");
          v40 = +[NSMutableString string](NSMutableString, "string");
          v41 = +[NSMutableString string](NSMutableString, "string");
          v42 = +[NSMutableString string](NSMutableString, "string");
          v43 = +[NSMutableString string](NSMutableString, "string");
          v44 = +[NSMutableString string](NSMutableString, "string");
          v45 = +[NSMutableString string](NSMutableString, "string");
          v46 = +[NSMutableString string](NSMutableString, "string");
          v47 = +[NSMutableString string](NSMutableString, "string");
          v48 = +[NSMutableString string](NSMutableString, "string");
          v49 = +[NSMutableString string](NSMutableString, "string");
          v50 = +[NSMutableString string](NSMutableString, "string");
          v51 = +[NSMutableString string](NSMutableString, "string");
          v52 = +[NSMutableString string](NSMutableString, "string");
          v53 = +[NSMutableString string](NSMutableString, "string");
          v8 = +[NSMutableString string](NSMutableString, "string");
          LODWORD(v9) = *a1;
          if (*a1)
          {
            v10 = 0;
            v11 = 0;
            do
            {
              if (v11 >= (v9 - 1))
                v12 = &stru_100238178;
              else
                v12 = CFSTR(":");
              objc_msgSend(v19, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 8]), "stringValue"), v12);
              objc_msgSend(v20, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 12]), "stringValue"), v12);
              objc_msgSend(v21, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 16]), "stringValue"), v12);
              objc_msgSend(v22, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 20]), "stringValue"), v12);
              objc_msgSend(v23, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 24]), "stringValue"), v12);
              objc_msgSend(v24, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 28]), "stringValue"), v12);
              objc_msgSend(v18, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 32]), "stringValue"), v12);
              objc_msgSend(v32, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 36]), "stringValue"), v12);
              objc_msgSend(v25, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 40]), "stringValue"), v12);
              objc_msgSend(v26, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithChar:](NSNumber, "numberWithChar:", (char)a1[v10 + 44]), "stringValue"), v12);
              objc_msgSend(v27, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 45]), "stringValue"), v12);
              objc_msgSend(v28, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 46]), "stringValue"), v12);
              objc_msgSend(v29, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 47]), "stringValue"), v12);
              objc_msgSend(v30, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 48]), "stringValue"), v12);
              objc_msgSend(v31, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 49]), "stringValue"), v12);
              objc_msgSend(v33, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 50]), "stringValue"), v12);
              objc_msgSend(v34, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 51]), "stringValue"), v12);
              objc_msgSend(v35, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 52]), "stringValue"), v12);
              objc_msgSend(v36, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 56]), "stringValue"), v12);
              objc_msgSend(v37, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 60]), "stringValue"), v12);
              objc_msgSend(v38, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 64]), "stringValue"), v12);
              objc_msgSend(v39, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 68]), "stringValue"), v12);
              objc_msgSend(v40, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 72]), "stringValue"), v12);
              objc_msgSend(v41, "appendFormat:", CFSTR("%@%@"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2f"), *(_QWORD *)&a1[v10 + 80]), v12);
              objc_msgSend(v42, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 88]), "stringValue"), v12);
              objc_msgSend(v43, "appendFormat:", CFSTR("%@%@"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2f"), *(_QWORD *)&a1[v10 + 96]), v12);
              objc_msgSend(v44, "appendFormat:", CFSTR("%@%@"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.2f"), *(_QWORD *)&a1[v10 + 104]), v12);
              objc_msgSend(v45, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 112]), "stringValue"), v12);
              objc_msgSend(v46, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&a1[v10 + 116]), "stringValue"), v12);
              objc_msgSend(v47, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)&a1[v10 + 120]), "stringValue"), v12);
              objc_msgSend(v48, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)&a1[v10 + 128]), "stringValue"), v12);
              objc_msgSend(v49, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)&a1[v10 + 136]), "stringValue"), v12);
              objc_msgSend(v50, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 144]), "stringValue"), v12);
              objc_msgSend(v51, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithChar:](NSNumber, "numberWithChar:", (char)a1[v10 + 145]), "stringValue"), v12);
              objc_msgSend(v52, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 146]), "stringValue"), v12);
              objc_msgSend(v53, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 147]), "stringValue"), v12);
              objc_msgSend(v8, "appendFormat:", CFSTR("%@%@"), -[NSNumber stringValue](+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1[v10 + 148]), "stringValue"), v12);
              ++v11;
              v9 = *a1;
              v10 += 144;
            }
            while (v11 < v9);
          }
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("txFrames"), v19, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("txFail"), v20, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("txRetrans"), v21, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("bcnSched"), v22, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("bcnRcvs"), v23, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("fwTxFrames"), v24, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("fwTxFail"), v18, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("fwTxRetrans"), v32, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("rxFrames"), v25, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("rssi"), v26, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("trgDisc"), v27, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("gwArpExpiry"), v28, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("usrInput"), v29, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("txPerSign"), v30, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("fwTxPerSign"), v31, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("bcnPerSign"), v33, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("sympSign"), v34, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("fgAppNetUsage"), v35, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("sympUsrImpact"), v36, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("sympAwdCode"), v37, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("arpFailureCount"), v38, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("dnsServersImpacted"), v39, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("dnsServersTotal"), v40, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("gateOpenTime"), v41, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("trafficWatchRx"), v42, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("trafficWatchDuration"), v43, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("trafficWatchTime"), v44, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("validState"), v45, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("metricReason"), v46, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("rapidLqmDuration"), v47, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("tdEvalDuration"), v48, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("roamWaitTime"), v49, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("autoLeaveSign"), v50, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("autoLeaveRssi"), v51, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("actProbeSign"), v52, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("probesSent"), v53, 5);
          objc_msgSend(v15, "addFieldForKey:value:options:", CFSTR("probesFailed"), v8, 5);
          sub_100052064(v15);

          v4 = v17;
          v5 = context;
          goto LABEL_12;
        }
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for TriggerDisconnectData", "__WiFiMetricsManagerWAMessageSubmitTriggerDisconnectData");
      }
      else
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No records in data.. bailing", "__WiFiMetricsManagerWAMessageSubmitTriggerDisconnectData");
      }
      objc_autoreleasePoolPop(v14);
LABEL_12:
      objc_autoreleasePoolPop(v5);
      objc_autoreleasePoolPop(v4);
      free(v3);
      return;
    }
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null linkStatsMetric", "WiFiMetricsManagerSubmitTriggerDisconnectData");
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null stats", "WiFiMetricsManagerSubmitTriggerDisconnectData");
  }
  objc_autoreleasePoolPop(v13);
}

void sub_100059E78(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  uint64_t v13;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  void *i;
  void *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  BOOL v24;
  id v27;
  id v28;
  id v29;
  void *v30;
  void *v31;
  uint64_t v32;
  id v33;
  id v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE v50[128];

  if (!a2 || !qword_10026D5D8)
    return;
  v7 = sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16));
  v8 = objc_autoreleasePoolPush();
  if (!v7)
  {
    v9 = objc_autoreleasePoolPush();
    if (a3)
    {
      v10 = objc_alloc((Class)WAMessage);
      v11 = objc_msgSend(v10, "initWithMetricName:options:", kWAMessageMetricNameRoamStatus, 7);
      if (v11)
      {
        v12 = v11;
        objc_msgSend(v11, "addFieldForKey:value:options:", kWAMessageKeyTimeStarted, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)a2), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTimeEnded, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 8)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 16)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyRoamFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 20)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyStatus, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 24)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyReason, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 28)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyStatusString, +[WiFiRoamManager stringRepresentationWithStatus:](WiFiRoamManager, "stringRepresentationWithStatus:", *(unsigned int *)(a2 + 24)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyReasonString, +[WiFiRoamManager stringRepresentationWithReason:](WiFiRoamManager, "stringRepresentationWithReason:", *(unsigned int *)(a2 + 28)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyProfileType, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 32)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginRSSI, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 36)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetRSSI, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 40)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginChannel, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 44)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetChannel, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 48)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginChannelFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 52)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetChannelFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 56)), 7);
        sub_100063954(v12, kWAMessageKeyOriginOUI, a2 + 60, 3u, 1);
        sub_100063954(v12, kWAMessageKeyTargetOUI, a2 + 63, 3u, 1);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyCCATotal, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 68)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyCCAOthers, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 76)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyCCAInt, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 80)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginTxPER, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 88)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOffChannelDwellTime, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 96)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyRoamScanDuration, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 100)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyAssociationDuration, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 104)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyHostReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 112)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyHostReasonString, +[WiFiRoamManager stringRepresentationWithHostReason:](WiFiRoamManager, "stringRepresentationWithHostReason:", *(unsigned int *)(a2 + 112)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyMotionState, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 116)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyVoipActive, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a2 + 120)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyLateRoam, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a2 + 121)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginBcnPER, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 128)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginFWTxPER, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 136)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginEnhancedSecurityType, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 144)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetEnhancedSecurityType, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 148)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginAKMs, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 152)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetAKMs, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 156)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyOriginPhyMode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 160)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyTargetPhyMode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a2 + 164)), 7);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyScannedChannelCount, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int16 *)(a2 + 180)), 7);
        sub_100063954(v12, kWAMessageKeyOriginAddr, a2 + 168, 6u, 0);
        v13 = a2 + 174;
        sub_100063954(v12, kWAMessageKeyTargetAddr, a2 + 174, 6u, 0);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeySSID, +[NSString stringWithString:](NSString, "stringWithString:", a3), 6);
        if (a4 && objc_msgSend(a4, "count"))
        {
          v37 = a1;
          v38 = v12;
          v39 = v8;
          v44 = +[NSMutableArray array](NSMutableArray, "array");
          v46 = 0u;
          v47 = 0u;
          v48 = 0u;
          v49 = 0u;
          v14 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v46, v50, 16);
          if (v14)
          {
            v15 = v14;
            v16 = a4;
            v17 = *(_QWORD *)v47;
            v43 = kWAMessageKeyChannel;
            v42 = kWAMessageKeyChannelFlags;
            v41 = kWAMessageKeyRSSI;
            v40 = kWAMessageKeyBSSID;
            do
            {
              for (i = 0; i != v15; i = (char *)i + 1)
              {
                if (*(_QWORD *)v47 != v17)
                  objc_enumerationMutation(v16);
                v19 = *(void **)(*((_QWORD *)&v46 + 1) + 8 * (_QWORD)i);
                v20 = objc_msgSend(v19, "objectForKey:", CFSTR("CHANNEL"));
                v21 = objc_msgSend(v19, "objectForKey:", CFSTR("CHANNEL_FLAGS"));
                v22 = objc_msgSend(v19, "objectForKey:", CFSTR("RSSI"));
                v23 = objc_msgSend(v19, "objectForKey:", CFSTR("BSSID"));
                if (v20)
                  v24 = v22 == 0;
                else
                  v24 = 1;
                if (!v24 && v23 != 0 && v21 != 0)
                {
                  v27 = v23;
                  v28 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
                  objc_msgSend(v28, "setObject:forKey:", v20, v43);
                  objc_msgSend(v28, "setObject:forKey:", v21, v42);
                  objc_msgSend(v28, "setObject:forKey:", v22, v41);
                  objc_msgSend(v28, "setObject:forKey:", v27, v40);
                  v29 = v28;
                  v16 = a4;
                  objc_msgSend(v44, "addObject:", v29);
                }
              }
              v15 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v46, v50, 16);
            }
            while (v15);
          }
          v12 = v38;
          objc_msgSend(v38, "addFieldForKey:value:options:", kWAMessageKeyRoamCache, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v44), 6);
          v8 = v39;
          a1 = v37;
          v13 = a2 + 174;
        }
        if (a1)
        {
          v30 = malloc_type_malloc(0x34CuLL, 0x1000040503055D5uLL);
          if (!v30)
          {
            v36 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null lqmHistoryMetric", "__WiFiMetricsManagerWAMessageSubmitRoamStatus");
            objc_autoreleasePoolPop(v36);
            goto LABEL_37;
          }
          v31 = v30;
          bzero(v30, 0x34CuLL);
          if (sub_100052538(a1, (uint64_t)v31))
            sub_100063AA8(v12, a1, 0, (uint64_t)v31);
          free(v31);
        }
        v32 = kWAMessageKeyMetricDate;
        -[NSDate timeIntervalSinceReferenceDate](+[NSDate date](NSDate, "date"), "timeIntervalSinceReferenceDate");
        objc_msgSend(v12, "addFieldForKey:value:options:", v32, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
        if (!*(_DWORD *)(a2 + 24))
        {
          v33 = sub_1000572CC(v13, 6u);
          if (v33)
          {
            v34 = +[WiFiUsageAccessPointProfile profileForBSSID:](WiFiUsageAccessPointProfile, "profileForBSSID:", v33);
            if (v34)
              objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyApProfile, v34, 6);
          }
        }
        sub_100052064(v12);
LABEL_37:

LABEL_38:
        objc_autoreleasePoolPop(v9);
        objc_autoreleasePoolPop(v8);
        return;
      }
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for RoamStatus", "__WiFiMetricsManagerWAMessageSubmitRoamStatus");
    }
    else
    {
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ssid null", "__WiFiMetricsManagerWAMessageSubmitRoamStatus");
    }
    objc_autoreleasePoolPop(v35);
    goto LABEL_38;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitRoamStatus");
  objc_autoreleasePoolPop(v8);
}

void sub_10005AA48(__int128 *a1)
{
  _QWORD *v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  const __CFString *v7;
  const __CFString *v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  const void *v14;
  const void *v15;
  void *v16;

  if (a1)
  {
    v2 = malloc_type_malloc(0x38uLL, 0x10600406BF8FC03uLL);
    if (v2)
    {
      v3 = (uint64_t)v2;
      v2[6] = 0;
      *((_OWORD *)v2 + 1) = 0u;
      *((_OWORD *)v2 + 2) = 0u;
      *(_OWORD *)v2 = 0u;
      v4 = *a1;
      v5 = a1[1];
      v6 = a1[2];
      v2[6] = *((_QWORD *)a1 + 6);
      *((_OWORD *)v2 + 1) = v5;
      *((_OWORD *)v2 + 2) = v6;
      *(_OWORD *)v2 = v4;
      v7 = (const __CFString *)*((_QWORD *)a1 + 5);
      if (v7)
        v2[5] = CFStringCreateCopy(kCFAllocatorDefault, v7);
      v8 = (const __CFString *)*((_QWORD *)a1 + 6);
      if (v8)
        *(_QWORD *)(v3 + 48) = CFStringCreateCopy(kCFAllocatorDefault, v8);
      v9 = objc_autoreleasePoolPush();
      v10 = objc_autoreleasePoolPush();
      v11 = objc_alloc((Class)WAMessage);
      v12 = objc_msgSend(v11, "initWithMetricName:options:", kWAMessageMetricNameActionFrameEvent, 5);
      if (v12)
      {
        v13 = v12;
        sub_100063954(v12, kWAMessageKeyOUI, v3, 3u, 1);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyEnvironmentType, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 4)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyCategoryCode, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 8)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyActionCode, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 9)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyDialogToken, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 10)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyStatus, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 11)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyFrameType, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 12)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmDisassociationTimeout, +[NSNumber numberWithShort:](NSNumber, "numberWithShort:", *(__int16 *)(v3 + 14)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmValidityInterval, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 16)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmTerminationDuration, +[NSNumber numberWithChar:](NSNumber, "numberWithChar:", *(char *)(v3 + 17)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmHasPreferredCandidateList, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(_BYTE *)(v3 + 18) != 0), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmAbridged, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(_BYTE *)(v3 + 19) != 0), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmDisassociationImminent, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(_BYTE *)(v3 + 20) != 0), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmBssTerminationIncluded, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(_BYTE *)(v3 + 21) != 0), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyBtmEssTerminationIncluded, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(_BYTE *)(v3 + 22) != 0), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyChannel, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 24)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyChannelWidth, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 28)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyChannelFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 36)), 5);
        objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyPhyMode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 32)), 5);
        if (*(_QWORD *)(v3 + 40))
          objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyWPSModelName, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
        if (*(_QWORD *)(v3 + 48))
          objc_msgSend(v13, "addFieldForKey:value:options:", kWAMessageKeyWPSModelNum, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
        sub_100052064(v13);

      }
      else
      {
        v16 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for ActionFrameEvent", "__WiFiMetricsManagerWAMessageSubmitActionFrameEvent");
        objc_autoreleasePoolPop(v16);
      }
      objc_autoreleasePoolPop(v10);
      v14 = *(const void **)(v3 + 48);
      if (v14)
      {
        CFRelease(v14);
        *(_QWORD *)(v3 + 48) = 0;
      }
      v15 = *(const void **)(v3 + 40);
      if (v15)
        CFRelease(v15);
      free((void *)v3);
    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null afMetricCopy", "WiFiMetricsManagerSubmitActionFrameEvent");
    }
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null afMetric", "WiFiMetricsManagerSubmitActionFrameEvent");
  }
  objc_autoreleasePoolPop(v9);
}

uint64_t sub_10005AFD8(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  const __CFNumber *v6;
  const void *v7;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v9;
  CFNumberRef v10;
  void *v11;
  int i;
  uint64_t v13;
  uint64_t v14;
  CFNumberRef v15;
  CFNumberRef v16;
  const void *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  const void *v20;
  CFBooleanRef v21;
  const __CFString *v22;
  CFNumberRef v23;
  CFNumberRef v24;
  const void *v25;
  void *v26;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int j;
  unsigned int v34;
  unsigned int v35;
  uint64_t valuePtr;
  void *value;

  valuePtr = 0;
  value = 0;
  v35 = 0;
  if (!(_DWORD)a1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s received invalid type (%d)", "WiFiMetricsManagerCheckQueryableWatchdogInfo", 0);
    objc_autoreleasePoolPop(v28);
    return 0;
  }
  v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DRIVER_AVAILABLE_FLAGS"));
  if (!v6)
    return 0;
  v7 = v6;
  CFNumberGetValue(v6, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v9 = Mutable;
  v34 = a1 - 1;
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v34);
  if (v10)
    CFDictionarySetValue(v9, CFSTR("APPLE80211KEY_AWD_TRAP_TYPE"), v10);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s requesting info type (%d) - trap dict: %@", "WiFiMetricsManagerCheckQueryableWatchdogInfo", v34, v9);
  objc_autoreleasePoolPop(v11);
  for (i = 6; ; --i)
  {
    v13 = Apple80211Get(a3, 257, 0, v9, 8);
    v14 = v13;
    if ((int)v13 <= 15)
    {
      if ((_DWORD)v13 != -3905)
        break;
    }
    else if ((_DWORD)v13 != 61 && (_DWORD)v13 != 16)
    {
      goto LABEL_74;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v13)
  {
    CFDictionaryGetValueIfPresent(v9, CFSTR("TRAP_SEQUENECE_NUM"), (const void **)&value);
    if (value)
    {
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v35);
      CFDictionaryGetValueIfPresent(theDict, CFSTR("DRIVER_AVAILABLE_TRAP_SEQUENCE"), (const void **)&value);
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        if (v35 == (_DWORD)valuePtr)
        {
          if ((_DWORD)a1 == 2)
          {
            for (j = 10; j < 0xF; ++j)
            {
              v23 = CFNumberCreate(0, kCFNumberIntType, &j);
              if (v23)
              {
                v24 = v23;
                if (CFDictionaryContainsKey(v9, v23))
                {
                  v25 = CFDictionaryGetValue(v9, v24);
                  if (v25)
                  {
                    if (j - 10 <= 4)
                      CFDictionaryAddValue(theDict, off_10022F448[j - 10], v25);
                  }
                }
                CFRelease(v24);
              }
            }
            if (CFDictionaryContainsKey(v9, CFSTR("TRAP_SEQUENECE_NUM")))
              v7 = CFDictionaryGetValue(v9, CFSTR("TRAP_SEQUENECE_NUM"));
            if (v7)
              CFDictionaryAddValue(theDict, CFSTR("DRIVER_AVAILABLE_JOIN_TIMEOUT_SEQUENCE"), v7);
            v21 = kCFBooleanTrue;
            v22 = CFSTR("DRIVER_AVAILABLE_HAVE_JOIN_TIMEOUT_INFO");
            goto LABEL_56;
          }
          if ((_DWORD)a1 == 1)
          {
            for (j = 1; j < 0xA; ++j)
            {
              v15 = CFNumberCreate(0, kCFNumberIntType, &j);
              if (v15)
              {
                v16 = v15;
                if (CFDictionaryContainsKey(v9, v15))
                {
                  v17 = CFDictionaryGetValue(v9, v16);
                  if (v17)
                  {
                    if (j - 1 <= 8)
                      CFDictionaryAddValue(theDict, off_10022F3E0[j - 1], v17);
                  }
                }
                CFRelease(v16);
              }
            }
            for (j = 15; j < 0x13; ++j)
            {
              v18 = CFNumberCreate(0, kCFNumberIntType, &j);
              if (v18)
              {
                v19 = v18;
                if (CFDictionaryContainsKey(v9, v18))
                {
                  v20 = CFDictionaryGetValue(v9, v19);
                  if (v20)
                  {
                    if (j - 15 <= 3)
                      CFDictionaryAddValue(theDict, off_10022F428[j - 15], v20);
                  }
                }
                CFRelease(v19);
              }
            }
            if (CFDictionaryContainsKey(v9, CFSTR("TRAP_SEQUENECE_NUM")))
              v7 = CFDictionaryGetValue(v9, CFSTR("TRAP_SEQUENECE_NUM"));
            if (v7)
              CFDictionaryAddValue(theDict, CFSTR("DRIVER_AVAILABLE_TRAP_SEQUENCE"), v7);
            v21 = kCFBooleanTrue;
            v22 = CFSTR("DRIVER_AVAILABLE_HAVE_EXT_TRAP");
LABEL_56:
            CFDictionaryAddValue(theDict, v22, v21);
LABEL_60:
            v14 = 0;
            goto LABEL_61;
          }
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s unrecognized kWiFiMetricsManagerExtWatchDogInfoType (%d)", "WiFiMetricsManagerCheckQueryableWatchdogInfo", a1, v32);
        }
        else
        {
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s driver availability sequence (%u) vs trap dict sequence (%u) mismatch", "WiFiMetricsManagerCheckQueryableWatchdogInfo", valuePtr, v35);
        }
      }
      else
      {
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s driver availability didn't contain a sequence number", "WiFiMetricsManagerCheckQueryableWatchdogInfo", v31, v32);
      }
    }
    else
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s trap dict didn't contain a sequence number", "WiFiMetricsManagerCheckQueryableWatchdogInfo", v31, v32);
    }
    objc_autoreleasePoolPop(v26);
    goto LABEL_60;
  }
LABEL_74:
  v29 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Apple80211Get(APPLE80211_IOC_TRAP_INFO) failed: %d", "WiFiMetricsManagerCheckQueryableWatchdogInfo", v14);
  objc_autoreleasePoolPop(v29);
  if ((_DWORD)v14)
  {
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s WiFiMetricsManagerCheckQueryableWatchdogInfo() finished with error: %d", "WiFiMetricsManagerCheckQueryableWatchdogInfo", v14);
    objc_autoreleasePoolPop(v30);
  }
LABEL_61:
  CFRelease(v9);
  if (v10)
    CFRelease(v10);
  return v14;
}

void sub_10005B594(unsigned __int8 a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;

  v2 = (unsigned __int8 *)malloc_type_malloc(1uLL, 0x100004077774924uLL);
  if (v2)
  {
    v3 = v2;
    *v2 = a1;
    v4 = objc_autoreleasePoolPush();
    v5 = objc_autoreleasePoolPush();
    v6 = objc_alloc((Class)WAMessage);
    v7 = objc_msgSend(v6, "initWithMetricName:options:", kWAMessageMetricNameTxInhibit, 5);
    if (v7)
    {
      v8 = v7;
      objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyTxInhibitState, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *v3), 5);
      sub_100052064(v8);

    }
    else
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for TxInhibit", "__WiFiMetricsManagerWAMessageSubmitTxInhibitState");
      objc_autoreleasePoolPop(v9);
    }
    objc_autoreleasePoolPop(v5);
    objc_autoreleasePoolPop(v4);
    free(v3);
  }
}

void sub_10005B6CC(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFIndex v5;
  uint64_t *ValueAtIndex;
  uint64_t *v7;
  uint64_t v8;
  const __CFString *v9;
  void *v10;
  void *v11;
  const char *v12;
  void *v13;
  __CFSet *v14;

  if (a1 && a2)
  {
    if (qword_10026D5D8 && CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)) >= 1)
    {
      v5 = 0;
      while (1)
      {
        ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(qword_10026D5D8 + 32), v5);
        if (!ValueAtIndex)
        {
          v10 = objc_autoreleasePoolPush();
          v11 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v12 = "WiFiMetricsManagerGetDeviceMetricsFromInterfaceName: Couldn't get WiFiMetricsDeviceMetricsRef";
            goto LABEL_18;
          }
          goto LABEL_19;
        }
        v7 = ValueAtIndex;
        v8 = *ValueAtIndex;
        if (!v8)
          break;
        v9 = (const __CFString *)sub_100025C3C(v8);
        if (!v9)
        {
          v10 = objc_autoreleasePoolPush();
          v11 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v12 = "WiFiMetricsManagerGetDeviceMetricsFromInterfaceName: Couldn't get WiFiDevice ifname";
LABEL_18:
            objc_msgSend(v11, "WFLog:message:", 3, v12);
          }
          goto LABEL_19;
        }
        if (CFStringCompare(v9, a2, 0) == kCFCompareEqualTo)
        {
          v14 = (__CFSet *)v7[89];
          if (a3)
            CFSetAddValue(v14, a3);
          else
            CFSetRemoveAllValues(v14);
          return;
        }
LABEL_10:
        if (++v5 >= CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)))
          goto LABEL_20;
      }
      v10 = objc_autoreleasePoolPush();
      v11 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v12 = "WiFiMetricsManagerGetDeviceMetricsFromInterfaceName: Couldn't get WiFiDeviceRef";
        goto LABEL_18;
      }
LABEL_19:
      objc_autoreleasePoolPop(v10);
      goto LABEL_10;
    }
LABEL_20:
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiMetricsManagerRecordColocatedSSIDData: Failed to find WiFiMetricsDeviceMetricsRef for event", "WiFiMetricsManagerRecordColocatedSSIDData");
    objc_autoreleasePoolPop(v13);
  }
}

BOOL sub_10005B8AC()
{
  double v0;
  _BOOL8 v1;
  void *v2;
  void *v4;
  size_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8[2];

  *(_QWORD *)v8 = 0x1500000001;
  v6 = 0xAAAAAAAAAAAAAAAALL;
  v7 = 0xAAAAAAAAAAAAAAAALL;
  v5 = 16;
  if (!qword_10026D5D8)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerIsFirstBoot");
    goto LABEL_11;
  }
  if (sysctl(v8, 2u, &v6, &v5, 0, 0) == -1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unable to get boot timestamp", "WiFiMetricsManagerIsFirstBoot");
LABEL_11:
    objc_autoreleasePoolPop(v4);
    return 0;
  }
  v0 = *(double *)(qword_10026D5D8 + 24) - ((double)(int)v7 / 1000000.0 + (double)v6 - kCFAbsoluteTimeIntervalSince1970);
  v1 = v0 < 30.0;
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: managerBootTime %fsecs, firstBoot %d", "WiFiMetricsManagerIsFirstBoot", *(_QWORD *)&v0, v0 < 30.0, v5);
  objc_autoreleasePoolPop(v2);
  return v1;
}

double sub_10005BA58(double *a1)
{
  void *v2;
  void *v3;
  id v4;
  id v5;
  void *v6;
  double v7;
  double v8;
  double v9;
  float v10;
  float v11;
  double v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  double result;
  void *v19;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_autoreleasePoolPush();
  v4 = objc_alloc((Class)WAMessage);
  v5 = objc_msgSend(v4, "initWithMetricName:options:", kWAMessageMetricNameSoftAP, 5);
  if (v5)
  {
    v6 = v5;
    objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyBringUpMethod, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)a1), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyBringUpEndState, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)a1 + 1)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyTeardownReason, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)a1 + 2)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyMisStartTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1[2]), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeySoftAPUpTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1[3]), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeySessionEndTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1[4]), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyAppleDeviceConnectCount, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)a1 + 20)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyAppleDeviceConnectionFlags, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)a1 + 21)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNonAppleDeviceConnectCount, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)a1 + 22)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyDeviceDisconnectCount, +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)a1 + 23)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyLowPowerModeDuration, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *((_QWORD *)a1 + 6)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherFailure, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 72)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhNanStationCount, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 88)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhNanSessionStartTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1[12]), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhNanSessionEndTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1[13]), 5);
    v7 = (a1[13] - a1[12]) / 1000000.0;
    v8 = a1[4] - a1[2];
    v9 = v8 / 1000000.0;
    if (v8 / 1000000.0 == 0.0)
    {
      v12 = 0.0;
    }
    else
    {
      *(float *)&v8 = v7;
      v10 = v9;
      *(float *)&v8 = *(float *)&v8 / v10;
      v11 = *(float *)&v8;
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhNanSessionOverSoftApSessionTime, +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v8), 5);
      v12 = v11;
    }
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhNanSessionTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v7), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTeardownReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned int *)a1 + 28)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNANPhPublisherAwdlStartedWhileInSession, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 160) != 0), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTerminateP2pReasonCode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 128)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherDataSessionTerminateP2pReasonCode, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 144)), 5);
    if (*((_QWORD *)a1 + 19))
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherDataSessionTerminateP2pReasonCodeString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
      v13 = (const void *)*((_QWORD *)a1 + 19);
      if (v13)
      {
        CFRelease(v13);
        a1[19] = 0.0;
      }
    }
    else
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherDataSessionTerminateP2pReasonCodeString, CFSTR("N/A"), 5);
    }
    if (*((_QWORD *)a1 + 17))
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTerminateP2pReasonCodeString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
      v14 = (const void *)*((_QWORD *)a1 + 17);
      if (v14)
      {
        CFRelease(v14);
        a1[17] = 0.0;
      }
    }
    else
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTerminateP2pReasonCodeString, CFSTR("N/A"), 5);
    }
    if (*((_QWORD *)a1 + 15))
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTeardownReasonString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
      v15 = (const void *)*((_QWORD *)a1 + 15);
      if (v15)
      {
        CFRelease(v15);
        a1[15] = 0.0;
      }
    }
    else
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherTeardownReasonString, CFSTR("N/A"), 5);
    }
    if (*((_QWORD *)a1 + 10))
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherFailureString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
      v16 = (const void *)*((_QWORD *)a1 + 10);
      if (v16)
      {
        CFRelease(v16);
        a1[10] = 0.0;
      }
    }
    else
    {
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyNanPhPublisherFailureString, CFSTR("N/A"), 5);
    }
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s nanPhPublisherFailureReason=%d nanPhNanStationCount=%d nanPhNanSessionStartTime=%f nanPhNanSessionEndTime=%f nanSessionTime=%f softapSessionTime=%f kWAMessageKeyNanPhNanSessionOverSoftApSessionTime=%f nanPhPublisherTeardownReason=%d awdlStartedWhileInSession=%d nanPhPublisherTerminateP2pReasonCode=%d nanPhPublisherDataSessionTerminateP2pReasonCode=%d", "__WiFiMetricsManagerWAMessageSubmitPHSessionMetric", *((unsigned __int8 *)a1 + 72), *((unsigned __int8 *)a1 + 88), *((_QWORD *)a1 + 12), *((_QWORD *)a1 + 13), *(_QWORD *)&v7, *(_QWORD *)&v9, *(_QWORD *)&v12, *((unsigned int *)a1 + 28), *((unsigned __int8 *)a1 + 160), *((unsigned __int8 *)a1 + 128), *((unsigned __int8 *)a1 + 144));
    objc_autoreleasePoolPop(v17);
    if (*((_DWORD *)a1 + 14))
      objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyChannel, +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:"), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeySSIDChanged, +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *((unsigned int *)a1 + 15)), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyIsPendingSubmission, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 64) != 0), 5);
    objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeySecurityTypes, +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *((unsigned int *)a1 + 17)), 5);
    sub_100052064(v6);

  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for SoftAPEvent", "__WiFiMetricsManagerWAMessageSubmitPHSessionMetric");
    objc_autoreleasePoolPop(v19);
  }
  objc_autoreleasePoolPop(v3);
  objc_autoreleasePoolPop(v2);
  a1[20] = 0.0;
  result = 0.0;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return result;
}

double sub_10005C1E0(unsigned int *a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  void *v7;
  double v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  void *v13;
  double result;
  void *v15;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: PHClientMetric: failureReason=%d rssi=%d isFamily=%d isAutoJoin=%d switchedToAnotherNetwork=%d enhancedSecurityType 0x%X nanPhClientSessionTime=%f nanPhSubscriberEndState=%d nanPhSubscriberDatapathEndState=%d  wifip2pdCrashWhileInNanPhSession=%d", "WiFiMetricsManagerSubmitPHClientMetric", *a1, a1[1], *((unsigned __int8 *)a1 + 8), *((unsigned __int8 *)a1 + 9), *((unsigned __int8 *)a1 + 10), a1[3], *((_QWORD *)a1 + 3), a1[18], a1[10], *((unsigned __int8 *)a1 + 16));
  objc_autoreleasePoolPop(v2);
  v3 = objc_autoreleasePoolPush();
  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: pHClientMetric null", "__WiFiMetricsManagerWAMessageSubmitPHClientMetric");
    goto LABEL_29;
  }
  v5 = objc_alloc((Class)WAMessage);
  v6 = objc_msgSend(v5, "initWithMetricName:options:", kWAMessageMetricNameSoftAPClient, 5);
  if (!v6)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for SoftAPClient", "__WiFiMetricsManagerWAMessageSubmitPHClientMetric");
LABEL_29:
    objc_autoreleasePoolPop(v15);
    goto LABEL_24;
  }
  v7 = v6;
  objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyFailureReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyRSSI, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[1]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyIsFamilyHotspot, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 8) != 0), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyIsAutoJoined, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 9) != 0), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeySwitchedtoAnotherNetwork, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 10) != 0), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyEnhancedSecurityType, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[3]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhClientSessionStartTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *((double *)a1 + 3)), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhClientSessionEndTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *((double *)a1 + 4)), 5);
  v8 = (*((double *)a1 + 4) - *((double *)a1 + 3)) / 1000000.0;
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhClientSessionTime, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v8), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberEndState, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[18]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberDatapathEndState, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[10]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberWifip2pdCrashWhileInSession, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 16) != 0), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberCopresenceStartedDuringSession, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 104) != 0), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberTeardownReason, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[22]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberStartError, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[14]), 5);
  objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberAwdlStartedDuringSession, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *((_BYTE *)a1 + 105) != 0), 5);
  if (*((_QWORD *)a1 + 12))
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberTeardownReasonString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
    v9 = (const void *)*((_QWORD *)a1 + 12);
    if (v9)
    {
      CFRelease(v9);
      *((_QWORD *)a1 + 12) = 0;
    }
  }
  else
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberTeardownReasonString, CFSTR("N/A"), 5);
  }
  if (*((_QWORD *)a1 + 10))
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberEndStateString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
    v10 = (const void *)*((_QWORD *)a1 + 10);
    if (v10)
    {
      CFRelease(v10);
      *((_QWORD *)a1 + 10) = 0;
    }
  }
  else
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberEndStateString, CFSTR("N/A"), 5);
  }
  if (*((_QWORD *)a1 + 8))
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberStartErrorString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
    v11 = (const void *)*((_QWORD *)a1 + 8);
    if (v11)
    {
      CFRelease(v11);
      *((_QWORD *)a1 + 8) = 0;
    }
  }
  else
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberStartErrorString, CFSTR("SUCCESS"), 5);
  }
  if (*((_QWORD *)a1 + 6))
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberDatapathEndStateString, +[NSString stringWithString:](NSString, "stringWithString:"), 5);
    v12 = (const void *)*((_QWORD *)a1 + 6);
    if (v12)
    {
      CFRelease(v12);
      *((_QWORD *)a1 + 6) = 0;
    }
  }
  else
  {
    objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyNanPhSubscriberDatapathEndStateString, CFSTR("N/A"), 5);
  }
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s kWAMessageKeyNanPhClientSessionStartTime=%f kWAMessageKeyNanPhClientSessionEndTime=%f kWAMessageKeyNanPhClientSessionTime=%f kWAMessageKeyNanPhSubscriberEndState=%d nanPhSubscriberDatapathEndState=%d wifip2pdCrashWhileInNanPhSession=%d copresenceStartedDuringSession=%d nanPhClientTeardownReason=%d nanPhSubscriberStartError=%d awdlStartedDuringSession=%d", "__WiFiMetricsManagerWAMessageSubmitPHClientMetric", *((_QWORD *)a1 + 3), *((_QWORD *)a1 + 4), *(_QWORD *)&v8, a1[18], a1[10], *((unsigned __int8 *)a1 + 16), *((unsigned __int8 *)a1 + 104), a1[22], a1[14], *((unsigned __int8 *)a1 + 105));
  objc_autoreleasePoolPop(v13);
  sub_100052064(v7);

LABEL_24:
  objc_autoreleasePoolPop(v4);
  objc_autoreleasePoolPop(v3);
  result = 0.0;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

void sub_10005C850(void *a1)
{
  int v2;
  void *v3;
  int v4;
  int v5;
  void *v6;
  id v7;
  uint64_t v8;
  void *v9;
  NSMutableArray *v10;
  __CFArray *v11;
  unint64_t i;
  unint64_t v13;
  id v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  void *context;
  _QWORD block[8];
  BOOL v20;
  BOOL v21;
  _QWORD v22[4];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  void (*v27)(uint64_t);
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  void (*v32)(uint64_t, uint64_t);
  void (*v33)(uint64_t);
  id v34;
  CFRange v35;

  if (!qword_10026D5D8)
    return;
  v2 = sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16));
  v3 = objc_autoreleasePoolPush();
  if (!v2)
  {
    v29 = 0;
    v30 = &v29;
    v31 = 0x3052000000;
    v32 = sub_10002FA48;
    v33 = sub_10002F964;
    v34 = (id)0xAAAAAAAAAAAAAAAALL;
    v34 = objc_msgSend(a1, "copy");
    v23 = 0;
    v24 = &v23;
    v25 = 0x3052000000;
    v26 = sub_10002FA48;
    v27 = sub_10002F964;
    v28 = 0;
    v22[0] = 0;
    v22[1] = v22;
    v22[2] = 0x2020000000;
    v22[3] = 0;
    v4 = sub_1000A4174(*(_QWORD *)(qword_10026D5D8 + 16));
    v5 = sub_1000A4A30(*(_QWORD *)(qword_10026D5D8 + 16));
    if (+[WiFiPerfPerAssoc sharedInstance](WiFiPerfPerAssoc, "sharedInstance"))
    {
      v6 = objc_autoreleasePoolPush();
      v7 = objc_alloc_init((Class)NSMutableArray);
      v8 = *(_QWORD *)(qword_10026D5D8 + 16);
      if (v8)
      {
        v9 = (void *)sub_10008674C(v8);
        if (v9)
        {
          v10 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", v9);
          v11 = (__CFArray *)v10;
          if (v10)
          {
            if (-[NSMutableArray count](v10, "count"))
            {
              v35.length = (CFIndex)objc_msgSend(v9, "count");
              v35.location = 0;
              CFArraySortValues(v11, v35, (CFComparatorFunction)sub_1000C88A0, 0);
              for (i = 0; ; ++i)
              {
                if ((unint64_t)-[__CFArray count](v11, "count") > 1)
                  v13 = 2;
                else
                  v13 = (unint64_t)-[__CFArray count](v11, "count");
                if (i >= v13)
                  goto LABEL_26;
                v14 = -[__CFArray objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", i);
                if (v14)
                {
                  v15 = sub_10002BE64((uint64_t)v14, CFSTR("BSSID"));
                  if (v15)
                  {
                    objc_msgSend(v7, "addObject:", v15);
                    continue;
                  }
                  context = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s failed to get BSSID of network from sorted list", "__WiFiMetricsManagerCopyBSSIDsOfTwoMostUsedNetworks", context);
                }
                else
                {
                  context = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s failed to get WiFiNetworkRef from sorted list", "__WiFiMetricsManagerCopyBSSIDsOfTwoMostUsedNetworks", context);
                }
                objc_autoreleasePoolPop(context);
              }
            }
          }
        }
      }

      v7 = 0;
LABEL_26:
      objc_autoreleasePoolPop(v6);
      v24[5] = (uint64_t)v7;
      v16 = *(NSObject **)(qword_10026D5D8 + 72);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10005CC30;
      block[3] = &unk_10022F338;
      v20 = v5 != 0;
      block[6] = v22;
      block[7] = &v23;
      block[4] = a1;
      block[5] = &v29;
      v21 = v4 != 0;
      dispatch_async(v16, block);
    }
    else
    {

      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiConnectionQuality doesn't seem to be tasked", "WiFiMetricsManagerSubmitConnectionQualityForAssociation");
      objc_autoreleasePoolPop(v17);
    }
    _Block_object_dispose(v22, 8);
    _Block_object_dispose(&v23, 8);
    _Block_object_dispose(&v29, 8);
    objc_autoreleasePoolPop(v3);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitConnectionQualityForAssociation");
  objc_autoreleasePoolPop(v3);
}

void sub_10005CBF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  uint64_t v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v12 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_10005CC30(uint64_t a1)
{
  id v2;
  BOOL v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  WiFiManagerAnalytics *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  const __CFString *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v22[6];
  char v23;

  v2 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("ppaBSSIDConnected"));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = objc_msgSend(+[WiFiLOIManager sharedWiFiLOIManager](WiFiLOIManager, "sharedWiFiLOIManager"), "queryLOITypeAtLastLocation");
  if (*(_BYTE *)(a1 + 64))
    goto LABEL_18;
  if (objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("ppaIsNoMap")), "BOOLValue"))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as current SSID has the _nomap suffix", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v20, v21);
    goto LABEL_27;
  }
  if (objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("ppaIsApplePH")), "BOOLValue"))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as this association was to an Apple device (IE check)", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v20, v21);
    goto LABEL_27;
  }
  if ((unint64_t)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) - 4) >= 0xFFFFFFFFFFFFFFFELL)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as CoreRoutine feels this device is likely at home or work", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v20, v21);
    goto LABEL_27;
  }
  if (!v2
    || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40)
    || objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "containsObject:", v2))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v18 = *(const __CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40);
      if (!v18)
        v18 = CFSTR("NULL");
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as BSSID for network described (%@) in scorecard matches a BSSID of the top two most used networks (%@)", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v2, v18);
    }
    goto LABEL_27;
  }
  v3 = (unint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("bytesIn")), "unsignedIntegerValue") > 5|| (unint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("packetsIn")), "unsignedIntegerValue") > 0xD05;
  if ((unint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "objectForKeyedSubscript:", CFSTR("ppaAssociatedTime")), "unsignedIntegerValue") > 1|| v3)
  {
    v10 = arc4random_uniform(0x63u);
    if (v10 >= 0x32)
    {
      v19 = v10;
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as this sample didn't win the coin toss (%u > %d)", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v19, 49);
      goto LABEL_27;
    }
LABEL_18:

    v11 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_10005D060;
    v22[3] = &unk_10022F310;
    v23 = *(_BYTE *)(a1 + 65);
    v12 = *(_QWORD *)(a1 + 32);
    v13 = *(_QWORD *)(a1 + 40);
    v22[4] = v2;
    v22[5] = v13;
    -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v11, "prepareMessageForSubmission:withData:andReply:", 10027009, v12, v22);
    return;
  }
  v4 = objc_autoreleasePoolPush();
  v5 = (void *)qword_10026DD20;
  if (!qword_10026DD20)
    goto LABEL_22;
  v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  if (!v6)
  {
    v7 = 99;
    goto LABEL_20;
  }
  v7 = (uint64_t)objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("bytesIn")), "unsignedIntegerValue");
  v8 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  if (!v8)
  {
LABEL_20:
    v9 = 99;
    goto LABEL_21;
  }
  v9 = (uint64_t)objc_msgSend(objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("packetsIn")), "unsignedIntegerValue");
LABEL_21:
  objc_msgSend(v5, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as scorecard lacks Rx value (scorecard bytesIn value: %lu packetsIn value %lu)", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v7, v9);
LABEL_22:
  objc_autoreleasePoolPop(v4);
  v14 = objc_autoreleasePoolPush();
  v15 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v16 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    if (v16)
      v17 = (uint64_t)objc_msgSend(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("ppaAssociatedTime")), "unsignedIntegerValue");
    else
      v17 = 99;
    objc_msgSend(v15, "WFLog:message:", 3, "%s not submitting GEOWiFiConnectionQuality as scorecard lacks associated time value, or (likely) we weren't associated long enough (scorecard assoc time value: %lu)", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke", v17, v21);
  }
LABEL_27:
  objc_autoreleasePoolPop(v14);

}

void sub_10005D060(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  _QWORD block[7];

  if (!a2 || a3)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing WiFiConnectionQuality for submission: %@, or null WAMessageAWD", "WiFiMetricsManagerSubmitConnectionQualityForAssociation_block_invoke_2", a3);
    objc_autoreleasePoolPop(v9);
  }
  else
  {
    -[WiFiManagerAnalytics submitGeoServicesMessage:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "submitGeoServicesMessage:", a2);
    if (*(_BYTE *)(a1 + 48))
    {
      block[0] = _NSConcreteStackBlock;
      block[2] = sub_10005D154;
      block[3] = &unk_10022F2E8;
      v7 = *(_QWORD *)(a1 + 32);
      v6 = *(_QWORD *)(a1 + 40);
      block[5] = a2;
      block[6] = v6;
      v8 = *(NSObject **)(qword_10026D5D8 + 72);
      block[1] = 3221225472;
      block[4] = v7;
      dispatch_async(v8, block);
    }
  }

}

void sub_10005D154(uint64_t a1)
{
  id v2;

  v2 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "objectForKey:", CFSTR("identifier"));
  if (!v2)
    v2 = *(id *)(a1 + 32);
  sub_10005D1AC(*(void **)(a1 + 40), (uint64_t)objc_msgSend(v2, "stringByReplacingOccurrencesOfString:withString:", CFSTR(":"), &stru_100238178));
}

void sub_10005D1AC(void *a1, uint64_t a2)
{
  void *v4;
  NSURL *v5;
  NSURL *v6;
  id v7;
  id v8;
  NSURL *v9;
  void *v10;
  id v11;
  void *v12;
  NSData *v13;
  id v14;
  void *v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *i;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE v37[128];

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v18 = "%s: nil message";
    goto LABEL_23;
  }
  v36 = 0;
  v5 = -[NSFileManager URLForDirectory:inDomain:appropriateForURL:create:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "URLForDirectory:inDomain:appropriateForURL:create:error:", 14, 1, 0, 1, &v36);
  if (v36)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v28 = v36;
    v18 = "%s: failed to create application support directory with error %@";
    goto LABEL_20;
  }
  v6 = -[NSURL URLByAppendingPathComponent:](v5, "URLByAppendingPathComponent:", CFSTR("com.apple.wifid"));
  if (!-[NSFileManager fileExistsAtPath:isDirectory:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:isDirectory:", -[NSURL path](v6, "path"), 0))-[NSFileManager createDirectoryAtURL:withIntermediateDirectories:attributes:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "createDirectoryAtURL:withIntermediateDirectories:attributes:error:", v6, 1, 0, &v36);
  if (v36)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v28 = v36;
    v18 = "%s: failed to create wifid support directory with error %@";
    goto LABEL_20;
  }
  if (!v6)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v28 = 0;
    v18 = "%s: failed to create wifid support directory (path %@)";
LABEL_20:
    v19 = 4;
LABEL_24:
    objc_msgSend(v17, "WFLog:message:", v19, v18, "__WiFiMetircsManagerWriteConnectionQualityMessageToFile", v28);
    goto LABEL_25;
  }
  v7 = objc_alloc_init((Class)NSDateFormatter);
  objc_msgSend(v7, "setDateFormat:", CFSTR("yyyy'-'MM'-'dd-HHmmss"));
  v8 = objc_msgSend(v7, "stringFromDate:", +[NSDate date](NSDate, "date"));

  v9 = -[NSURL URLByAppendingPathComponent:isDirectory:](v6, "URLByAppendingPathComponent:isDirectory:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@_%@.json"), a2, v8), 0);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: path %@", "__WiFiMetircsManagerWriteConnectionQualityMessageToFile", v9);
  objc_autoreleasePoolPop(v10);
  v11 = objc_msgSend(a1, "dictionaryRepresentation");
  if (!v11)
  {
    v16 = objc_autoreleasePoolPush();
    v17 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v18 = "%s: missing instant scorecard";
LABEL_23:
      v19 = 3;
      goto LABEL_24;
    }
LABEL_25:
    objc_autoreleasePoolPop(v16);
    goto LABEL_38;
  }
  v12 = v11;
  v35 = 0;
  v30 = v4;
  if (+[NSJSONSerialization isValidJSONObject:](NSJSONSerialization, "isValidJSONObject:", v11))
  {
    v13 = +[NSJSONSerialization dataWithJSONObject:options:error:](NSJSONSerialization, "dataWithJSONObject:options:error:", v12, 3, &v35);
    if (v35)
      goto LABEL_15;
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v13, 4);
    objc_msgSend(v14, "writeToURL:atomically:encoding:error:", v9, 1, 4, &v35);
    if (v14)
      CFRelease(v14);
    if (v35)
    {
LABEL_15:
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to write to path %@ error %@", "__WiFiMetircsManagerWriteConnectionQualityMessageToFile", v9, v35);
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: local collection is enabled, writing to filesystem path %@", "__WiFiMetircsManagerWriteConnectionQualityMessageToFile", v9, v29);
    }
    objc_autoreleasePoolPop(v15);
  }
  else
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Invalid data passed to JSON serialization. Dumping data...", "__WiFiMetircsManagerWriteConnectionQualityMessageToFile");
    objc_autoreleasePoolPop(v20);
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v21 = objc_msgSend(v12, "allKeys");
    v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v31, v37, 16);
    if (v22)
    {
      v23 = v22;
      v24 = *(_QWORD *)v32;
      do
      {
        for (i = 0; i != v23; i = (char *)i + 1)
        {
          if (*(_QWORD *)v32 != v24)
            objc_enumerationMutation(v21);
          v26 = *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)i);
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ Key: %@ Value: ", v26, objc_msgSend(v12, "objectForKey:", v26));
          objc_autoreleasePoolPop(v27);
        }
        v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v31, v37, 16);
      }
      while (v23);
    }
  }
  v4 = v30;
LABEL_38:
  objc_autoreleasePoolPop(v4);
}

void sub_10005D65C(uint64_t a1, const __CFDictionary *a2, unsigned int a3, int a4)
{
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  void *v10;
  CFBooleanRef v11;
  void *v12;
  const char *v13;
  void *v14;
  WiFiManagerAnalytics *v15;
  uint64_t v16;
  void *v17;
  __CFDictionary *v18;
  void *v19;
  void *v20;
  _QWORD v21[5];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  CFTypeRef v25;
  unsigned int valuePtr;

  valuePtr = a3;
  if (!a1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerTriggerDPSNotification");
    goto LABEL_35;
  }
  if (!qword_10026D5D8)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerTriggerDPSNotification");
    goto LABEL_35;
  }
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerTriggerDPSNotification");
    goto LABEL_35;
  }
  if (!*(_QWORD *)(qword_10026D5D8 + 32))
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceMetricsArray !!", "WiFiMetricsManagerTriggerDPSNotification");
    goto LABEL_35;
  }
  if (a2)
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
  else
    MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = MutableCopy;
  if (!MutableCopy)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null symptomDict", "WiFiMetricsManagerTriggerDPSNotification");
LABEL_35:
    objc_autoreleasePoolPop(v19);
    return;
  }
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v8)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null symptomRef", "WiFiMetricsManagerTriggerDPSNotification");
    objc_autoreleasePoolPop(v20);
    v18 = v7;
    goto LABEL_23;
  }
  v9 = v8;
  CFDictionaryAddValue(v7, CFSTR("symptom"), v8);
  v10 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending DPSNotification with symptom=%d!!", "WiFiMetricsManagerTriggerDPSNotification", valuePtr);
  objc_autoreleasePoolPop(v10);
  if (a4)
    v11 = kCFBooleanTrue;
  else
    v11 = kCFBooleanFalse;
  CFDictionaryAddValue(v7, CFSTR("facetimeCallInProgress"), v11);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v13 = "false";
    if (v11 == kCFBooleanTrue)
      v13 = "true";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending DPSNotification with facetimeStatus: %s!!", "WiFiMetricsManagerTriggerDPSNotification", v13);
  }
  objc_autoreleasePoolPop(v12);
  v14 = objc_autoreleasePoolPush();
  v22 = 0;
  v23 = &v22;
  v24 = 0x2020000000;
  v25 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v25 = CFRetain(v7);
  v15 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
  v16 = v23[3];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_10005DA44;
  v21[3] = &unk_10022F360;
  v21[4] = &v22;
  -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v15, "prepareMessageForSubmission:withData:andReply:", 11075584, v16, v21);
  _Block_object_dispose(&v22, 8);
  objc_autoreleasePoolPop(v14);
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Done DPSNotification !!", "WiFiMetricsManagerTriggerDPSNotification");
  objc_autoreleasePoolPop(v17);
  CFRelease(v7);
  CFRelease(v9);
  if (v11)
  {
    v18 = v11;
LABEL_23:
    CFRelease(v18);
  }
}

void sub_10005DA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DA44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;
  const void *v8;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:  DPSNotification !!", "WiFiMetricsManagerTriggerDPSNotification_block_invoke");
  objc_autoreleasePoolPop(v6);
  if (!a2 || a3)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing DPSNotification for submission: %@, or null WAMessageAWD", "WiFiMetricsManagerTriggerDPSNotification_block_invoke", a3);
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    -[WiFiManagerAnalytics triggerDatapathDiagnosticsNoReply:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDatapathDiagnosticsNoReply:", a2);
  }
  v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_10005DB30(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  CFMutableDictionaryRef MutableCopy;
  CFBooleanRef v6;
  void *v7;
  const char *v8;
  void *v9;
  WiFiManagerAnalytics *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  _QWORD v14[5];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending SlowWiFi Notification !!", "WiFiMetricsManagerTriggerSlowWiFiNotification");
  objc_autoreleasePoolPop(v4);
  v15 = 0;
  v16 = &v15;
  v17 = 0x2020000000;
  v18 = 0;
  if (!a1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiMetricsManagerTriggerSlowWiFiNotification");
    goto LABEL_33;
  }
  if (!qword_10026D5D8)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerTriggerSlowWiFiNotification");
    goto LABEL_33;
  }
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerTriggerSlowWiFiNotification");
    goto LABEL_33;
  }
  if (!*(_QWORD *)(qword_10026D5D8 + 32))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null deviceMetricsArray !!", "WiFiMetricsManagerTriggerSlowWiFiNotification");
    goto LABEL_33;
  }
  if ((+[WiFiUsagePrivacyFilter canPerformActionWithSampleRate:](WiFiUsagePrivacyFilter, "canPerformActionWithSampleRate:", 3) & 1) == 0)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping this metric submission", "WiFiMetricsManagerTriggerSlowWiFiNotification");
    goto LABEL_33;
  }
  if (!a2)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no dict", "WiFiMetricsManagerTriggerSlowWiFiNotification");
LABEL_33:
    objc_autoreleasePoolPop(v13);
    goto LABEL_20;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
  v16[3] = (uint64_t)MutableCopy;
  if (sub_1000789D4(a1))
    v6 = kCFBooleanTrue;
  else
    v6 = kCFBooleanFalse;
  CFDictionaryAddValue((CFMutableDictionaryRef)v16[3], CFSTR("facetimeCallInProgress"), v6);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v8 = "false";
    if (v6 == kCFBooleanTrue)
      v8 = "true";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Sending SlowWiFiNotification with facetimeStatus: %s!!", "WiFiMetricsManagerTriggerSlowWiFiNotification", v8);
  }
  objc_autoreleasePoolPop(v7);
  v9 = objc_autoreleasePoolPush();
  v10 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
  v11 = v16[3];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10005DE60;
  v14[3] = &unk_10022F360;
  v14[4] = &v15;
  -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v10, "prepareMessageForSubmission:withData:andReply:", 11075588, v11, v14);
  objc_autoreleasePoolPop(v9);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Done SlowWiFi Notification !!", "WiFiMetricsManagerTriggerSlowWiFiNotification");
  objc_autoreleasePoolPop(v12);
  if (v6)
    CFRelease(v6);
LABEL_20:
  _Block_object_dispose(&v15, 8);
}

void sub_10005DE48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DE60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;
  const void *v8;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:  SlowWiFi Notification !!", "WiFiMetricsManagerTriggerSlowWiFiNotification_block_invoke");
  objc_autoreleasePoolPop(v6);
  if (!a2 || a3)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing SlowWiFi Notification for submission: %@, or null WAMessageAWD", "WiFiMetricsManagerTriggerSlowWiFiNotification_block_invoke", a3);
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    -[WiFiManagerAnalytics triggerDatapathDiagnosticsNoReply:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDatapathDiagnosticsNoReply:", a2);
  }
  v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_10005DF4C(uint64_t a1, const void *a2, const void *a3)
{
  int v5;
  void *v6;
  void *v7;
  const char *v8;
  uint64_t v9;
  id v10;
  id v11;
  void *v12;
  void *v13;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v8 = "%s: deviceManager null ";
    goto LABEL_17;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v8 = "%s: network null ";
LABEL_17:
    v9 = 4;
    goto LABEL_7;
  }
  if (qword_10026D5D8)
  {
    v5 = sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16));
    v6 = objc_autoreleasePoolPush();
    if (!v5)
    {
      v10 = objc_alloc((Class)WAMessage);
      v11 = objc_msgSend(v10, "initWithMetricName:options:", kWAMessageMetricNameClientAssociation, 6);
      if (v11)
      {
        v12 = v11;
        objc_msgSend(v11, "addFieldForKey:value:options:", kWAMessageKeySSID, +[NSString stringWithString:](NSString, "stringWithString:", sub_10002B088(a2)), 6);
        objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000C5C14((uint64_t)a2)), 6);
        if (a3)
        {
          objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeyMetricProcessImmediately, +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1), 6);
          objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeySwitchedFromNetworkSSID, +[NSString stringWithString:](NSString, "stringWithString:", sub_10002B088(a3)), 6);
          objc_msgSend(v12, "addFieldForKey:value:options:", kWAMessageKeySwitchedFromNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000C5C14((uint64_t)a3)), 6);
        }
        sub_100052064(v12);

      }
      else
      {
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for RoamStatus", "__WiFiMetricsManagerWAMessageUpdateClientAssociationData");
        objc_autoreleasePoolPop(v13);
      }
      goto LABEL_12;
    }
    v7 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_12:
      objc_autoreleasePoolPop(v6);
      return;
    }
    v8 = "%s: Camera is in Foreground";
    v9 = 3;
LABEL_7:
    objc_msgSend(v7, "WFLog:message:", v9, v8, "__WiFiMetricsManagerWAMessageUpdateClientAssociationData");
    goto LABEL_12;
  }
}

void sub_10005E1F8(const void *a1, void *a2)
{
  int v4;
  void *v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  id v16;
  uint64_t v17;
  void *v18;

  if (!+[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", a2, 1, 60.0))return;
  if (!a2)
  {
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v7 = "%s: location null ";
    goto LABEL_21;
  }
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_16;
    v7 = "%s: network null ";
LABEL_21:
    v8 = 4;
    goto LABEL_8;
  }
  if (qword_10026D5D8)
  {
    v4 = sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16));
    v5 = objc_autoreleasePoolPush();
    if (!v4)
    {
      v9 = objc_alloc((Class)WAMessage);
      v10 = objc_msgSend(v9, "initWithMetricName:options:", kWAMessageMetricNameNetworkGeotag, 6);
      if (v10)
      {
        v11 = v10;
        if (!sub_100060C54(v10, a1, 6))
        {
          v12 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to WAMessage", "__WiFiMetricsManagerWAMessageUpdateNetworkGeoTag");
          objc_autoreleasePoolPop(v12);
        }
        objc_msgSend(v11, "addFieldForKey:value:options:", kWAMessageKeyNetworkAuthFlags, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000C5C14((uint64_t)a1)), 6);
        v13 = kWAMessageKeyLatitude;
        objc_msgSend(a2, "coordinate");
        objc_msgSend(v11, "addFieldForKey:value:options:", v13, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
        v14 = kWAMessageKeyLongitude;
        objc_msgSend(a2, "coordinate");
        objc_msgSend(v11, "addFieldForKey:value:options:", v14, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v15), 6);
        v16 = objc_msgSend(a2, "timestamp");
        v17 = kWAMessageKeyMetricDate;
        objc_msgSend(v16, "timeIntervalSinceReferenceDate");
        objc_msgSend(v11, "addFieldForKey:value:options:", v17, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
        sub_100052064(v11);

      }
      else
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for RoamStatus", "__WiFiMetricsManagerWAMessageUpdateNetworkGeoTag");
        objc_autoreleasePoolPop(v18);
      }
      goto LABEL_16;
    }
    v6 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
    {
LABEL_16:
      objc_autoreleasePoolPop(v5);
      return;
    }
    v7 = "%s: Camera is in Foreground";
    v8 = 3;
LABEL_8:
    objc_msgSend(v6, "WFLog:message:", v8, v7, "__WiFiMetricsManagerWAMessageUpdateNetworkGeoTag");
    goto LABEL_16;
  }
}

void sub_10005E4D8(uint64_t a1, const void *a2, int a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  id v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  const void *v16;
  const void *v17;
  const char *v18;
  const void *v19;
  const void *v20;
  void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  void *v25;
  const void *v26;
  const void *v27;
  void *v28;
  void *v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  void *v36;
  void *v37;
  void *v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  const __CFDictionary *v41;
  const __CFDictionary *v42;
  const __CFDictionary *v43;
  const __CFDictionary *v44;
  const __CFDictionary *v45;
  const __CFDictionary *v46;
  const __CFDictionary *v47;
  const __CFDictionary *v48;
  const __CFDictionary *v49;
  const __CFDictionary *v50;
  const __CFDictionary *v51;
  const __CFDictionary *v52;
  const __CFDictionary *v53;
  const __CFDictionary *v54;
  const __CFDictionary *v55;
  const __CFDictionary *v56;
  const __CFDictionary *v57;
  const __CFDictionary *v58;
  const __CFDictionary *v59;
  const __CFDictionary *v60;
  const __CFDictionary *v61;
  const __CFDictionary *v62;
  const __CFDictionary *v63;
  const __CFDictionary *v64;
  const __CFDictionary *v65;
  const __CFDictionary *v66;
  const __CFDictionary *v67;
  const __CFDictionary *v68;
  const __CFDictionary *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  const __CFDictionary *v74;
  const __CFDictionary *v75;
  const __CFDictionary *v76;
  const __CFDictionary *v77;
  const __CFDictionary *v78;
  const __CFDictionary *v79;
  const __CFDictionary *v80;
  const __CFDictionary *v81;
  const __CFDictionary *v82;
  const __CFDictionary *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  void *value;

  v6 = objc_autoreleasePoolPush();
  v90 = 0;
  value = 0;
  v89 = 0;
  if (a3)
    v7 = 7;
  else
    v7 = 6;
  if (!qword_10026D5D8)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    goto LABEL_428;
  }
  v8 = *(_QWORD *)(qword_10026D5D8 + 16);
  if (!v8)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null metrics manager", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    goto LABEL_428;
  }
  if (sub_100093FDC(v8) == 1)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    goto LABEL_428;
  }
  if (!a1)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null WiFiManagerRef", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    goto LABEL_428;
  }
  if (!a2)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null WiFiNetworkRef", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    goto LABEL_428;
  }
  v9 = objc_alloc((Class)WAMessage);
  v10 = objc_msgSend(v9, "initWithMetricName:options:", kWAMessageMetricNameParsedBeaconInfo, v7);
  if (!v10)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null waMsg", "WiFiMetricsManagerUpdateParsedBeaconInfo");
LABEL_428:
    objc_autoreleasePoolPop(v87);
    goto LABEL_415;
  }
  v11 = v10;
  if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
    v12 = 7;
  else
    v12 = 6;
  if (!sub_100060C54(v11, a2, v12))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to WAMessage", "WiFiMetricsManagerUpdateParsedBeaconInfo");
    objc_autoreleasePoolPop(v13);
  }
  v14 = objc_autoreleasePoolPush();
  v15 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v16 = sub_10002B088(a2);
    v17 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    v18 = "Remote";
    if (!a3)
      v18 = "Local";
    objc_msgSend(v15, "WFLog:message:", 3, "%s: Submitting ParsedBeaconInfo waMsg for ssid:%@ bssid:%@ with %s opts.", "WiFiMetricsManagerUpdateParsedBeaconInfo", v16, v17, v18);
  }
  objc_autoreleasePoolPop(v14);
  v19 = sub_10002BE64((uint64_t)a2, CFSTR("CHANNEL"));
  if (v19)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("channel"), v19, v7);
  v20 = sub_10002BE64((uint64_t)a2, CFSTR("CHANNEL_FLAGS"));
  if (v20)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("channelFlags"), v20, v7);
  v21 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("NOISE"));
  value = v21;
  if (v21)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("noise"), v21, v7);
  v22 = sub_10002BE64((uint64_t)a2, CFSTR("SNR"));
  if (v22)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("snr"), v22, v7);
  v23 = sub_10002BE64((uint64_t)a2, CFSTR("RSSI"));
  if (v23)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rssi"), v23, v7);
  v24 = sub_10002BE64((uint64_t)a2, CFSTR("BEACON_INT"));
  if (v24)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("beaconInt"), v24, v7);
  v25 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("AP_MODE"));
  value = v25;
  if (v25)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("apMode"), v25, v7);
  v26 = sub_10002BE64((uint64_t)a2, CFSTR("PHY_MODE"));
  if (v26)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("phyMode"), v26, v7);
  v27 = sub_10002BE64((uint64_t)a2, CFSTR("CAPABILITIES"));
  if (v27)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("capabilities"), v27, v7);
  v28 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("RATES"));
  v88 = v28;
  if (v28)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rates"), objc_msgSend(v28, "componentsJoinedByString:", CFSTR(":")), v7);
  v29 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("AGE"));
  value = v29;
  if (v29)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("age"), v29, v7);
  v30 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("WPA_IE"));
  if (v30)
  {
    v31 = v30;
    if (CFDictionaryGetValueIfPresent(v30, CFSTR("IE_KEY_WPA_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpaIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v31, CFSTR("IE_KEY_WPA_MCIPHER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpaIEMCipher"), value, v7);
    if (CFDictionaryGetValueIfPresent(v31, CFSTR("IE_KEY_WPA_UCIPHERS"), (const void **)&v88))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpaIEUCiphers"), objc_msgSend(v88, "componentsJoinedByString:", CFSTR(":")), v7);
    if (CFDictionaryGetValueIfPresent(v31, CFSTR("IE_KEY_WPA_AUTHSELS"), (const void **)&v88))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpaIEAuthSels"), objc_msgSend(v88, "componentsJoinedByString:", CFSTR(":")), v7);
  }
  v32 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("RSN_IE"));
  if (v32)
  {
    v33 = v32;
    if (CFDictionaryGetValueIfPresent(v32, CFSTR("IE_KEY_RSN_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v33, CFSTR("IE_KEY_RSN_MCIPHER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIEMCipher"), value, v7);
    if (CFDictionaryGetValueIfPresent(v33, CFSTR("IE_KEY_RSN_UCIPHERS"), (const void **)&v88))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIEUCiphers"), objc_msgSend(v88, "componentsJoinedByString:", CFSTR(":")), v7);
    if (CFDictionaryGetValueIfPresent(v33, CFSTR("IE_KEY_RSN_AUTHSELS"), (const void **)&v88))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIEAuthSels"), objc_msgSend(v88, "componentsJoinedByString:", CFSTR(":")), v7);
    if (CFDictionaryGetValueIfPresent(v33, CFSTR("IE_KEY_RSN_BCIPHER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIEBCipher"), value, v7);
    v34 = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("IE_KEY_RSN_CAPS"));
    if (v34)
    {
      v35 = v34;
      if (CFDictionaryGetValueIfPresent(v34, CFSTR("PRE_AUTH"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsPreAuth"), value, v7);
      if (CFDictionaryGetValueIfPresent(v35, CFSTR("NO_PAIRWISE"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsNoPairwise"), value, v7);
      if (CFDictionaryGetValueIfPresent(v35, CFSTR("MFP_REQUIRED"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsMfpRequired"), value, v7);
      if (CFDictionaryGetValueIfPresent(v35, CFSTR("MFP_CAPABLE"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsMfpCapable"), value, v7);
      if (CFDictionaryGetValueIfPresent(v33, CFSTR("PTKSA_REPLAY_COUNTERS"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsPTKSAReplayCounters"), value, v7);
      if (CFDictionaryGetValueIfPresent(v33, CFSTR("GTKSA_REPLAY_COUNTERS"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsGTKSAReplayCounters"), value, v7);
      if (CFDictionaryGetValueIfPresent(v33, CFSTR("RSN_CAPABILITIES"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("rsnIERSNCapsCapabilities"), value, v7);
    }
  }
  v36 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("WAPI"));
  value = v36;
  if (v36)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wapiPolicy"), v36, v7);
  v37 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("WEP"));
  value = v37;
  if (v37)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wep"), v37, v7);
  v38 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("SCAN_RESULT_FROM_PROBE_RSP"));
  value = v38;
  if (v38)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("scanResultFromProbeRSP"), v38, v7);
  v39 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("APPLE_IE"));
  if (v39)
  {
    v40 = v39;
    if (CFDictionaryGetValueIfPresent(v39, CFSTR("APPLE_IE_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_PRODUCT_ID"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEProdId"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_INT_MIT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEIntMit"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_UNCONFIGURED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEUnConfigured"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_FOUND_PPPOE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEFoundPPPOE"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_GUEST_NETWORK"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEGuestNetwork"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_LEGACY_WDS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIELegacyWDS"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_WSC_CAP"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEWSCCap"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_WSC_ACTIVE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEWSCActive"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_WSC_SOLICITABLE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEWSCSolicitable"), value, v7);
    if (CFDictionaryGetValueIfPresent(v40, CFSTR("APPLE_IE_WOW_SUPPORTED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("appleIEWowSupported"), value, v7);
  }
  v41 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("IOS_IE"));
  if (v41)
  {
    v42 = v41;
    if (CFDictionaryGetValueIfPresent(v41, CFSTR("IOS_IE_FEATURE_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("iosIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v42, CFSTR("IOS_IE_FEATURES"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("iosIEFeatures"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v42, CFSTR("IOS_IE_FEATURE_WOW_DISALLOWED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("iosIEWowDisabled"), value, v7);
    if (CFDictionaryGetValueIfPresent(v42, CFSTR("IOS_IE_BTMAC_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("iosIEBtMacVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v42, CFSTR("IOS_IE_BTMAC"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("iosIEBtMac"), v89, v7);
  }
  v43 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("APPLE_DEVICE_IE"));
  if (v43)
  {
    v44 = v43;
    if (CFDictionaryGetValueIfPresent(v43, CFSTR("APPLE_DEVICE_IE_FEATURE_FLAGS"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEFlags"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_AIRPLAY"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsAirplay"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_UNCONFIGURED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEFeatureUnConfigured"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_MFI_CONFIG_V1"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsMFIConfigV1"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_WOW"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsWow"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_INTERFERENCE_ROBUSTNESS"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEInterferenceRobustness"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_REMOTE_PPPOE_SERVER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIERemotePPOEServer"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_WPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsWPS"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_WPS_ACTIVE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEWpsActive"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_AIRPRINT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsAirPrint"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_IAP_OVER_WIFI"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsIAPOverWiFi"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_CARPLAY"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsCarplay"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_PROVIDES_INTERNET_ACCESS"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEProvidesInternetAccess"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_ACP_CONFIG_V1"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsACPConfigV1"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_RECENT_PHYSICAL_CONTACT"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIERecentPhysicalContact"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_24GHZ_WIFI_NETWORKS"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupports24GHzWiFi"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_5GHZ_WIFI_NETWORKS"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupports5GHzWiFi"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_HOMEKIT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsHomeKit"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_HOMEKIT_V2"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsHomeKitV2"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_BUFFERED_AIRPLAY"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsBufferedAirPlay"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_SECURE_WAC"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsSecureWAC"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_MFI_HARDWARE_AUTH"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsMFIHardwareAuth"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_SOFTWARE_TOKEN_AUTH"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsSoftwareTokenAuth"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FEATURE_SUPPORTS_SOFTWARE_CERT_AUTH"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIESupportsCertAuth"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_FRIENDLY_NAME"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEFriendlyName"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_MANUFACTURER_NAME"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEManufacturerName"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_MODEL_NAME"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEModelName"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_OUI"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEOUI"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_DWDS_ROLE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEDWDSRole"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_DWDS_FLAGS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEDWDSFlags"), value, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_BLUETOOTH_MAC"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEBtMac"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v44, CFSTR("APPLE_DEVICE_IE_DEVICE_ID"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("deviceIEDeviceID"), v89, v7);
  }
  v45 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("APPLE_SWAP_IE"));
  if (v45)
  {
    v46 = v45;
    if (CFDictionaryGetValueIfPresent(v45, CFSTR("SWAP_IE_FEATURE_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("swapIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v46, CFSTR("SWAP_IE_FEATURES"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("swapIEFeatures"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v46, CFSTR("SWAP_IE_FEATURE_INTERNET_CONNECTION_SHARING_ENABLED"), (const void **)&value))
    {
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("swapIEInternetConnectionSharingEnabled"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v46, CFSTR("SWAP_IE_MODEL_IDENTIFIER_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("swapIEModelIdentifierVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v46, CFSTR("SWAP_IE_MODEL_IDENTIFIER"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("swapIEModelIdentifier"), v90, v7);
  }
  v47 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("80211D_IE"));
  if (v47)
  {
    v48 = v47;
    if (CFDictionaryGetValueIfPresent(v47, CFSTR("IE_KEY_80211D_COUNTRY_CODE"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11DIECountryCode"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v48, CFSTR("IE_KEY_80211D_CHAN_INFO_ARRAY"), (const void **)&v88))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11DIEChannelInfoArray"), objc_msgSend(v88, "componentsJoinedByString:", CFSTR(":")), v7);
    if (CFDictionaryGetValueIfPresent(v48, CFSTR("IE_KEY_80211D_FIRST_CHANNEL"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11DIEFirstChannel"), value, v7);
    if (CFDictionaryGetValueIfPresent(v48, CFSTR("IE_KEY_80211D_NUM_CHANNELS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11DIENumChannels"), value, v7);
    if (CFDictionaryGetValueIfPresent(v48, CFSTR("IE_KEY_80211D_MAX_POWER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11DIEMaxPower"), value, v7);
  }
  v49 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("SES_IE"));
  if (v49)
  {
    v50 = v49;
    if (CFDictionaryGetValueIfPresent(v49, CFSTR("IE_KEY_SES_VERSION"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("SESIEVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v50, CFSTR("IE_KEY_SES_RWO"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("SESIERWO"), value, v7);
    if (CFDictionaryGetValueIfPresent(v50, CFSTR("IE_KEY_SES_WDS_RWO"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("SESIEWDSRWO"), value, v7);
  }
  v51 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("HT_CAPS_IE"));
  if (v51)
  {
    v52 = v51;
    if (CFDictionaryGetValueIfPresent(v51, CFSTR("CAPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIEcapabilities"), value, v7);
    if (CFDictionaryGetValueIfPresent(v52, CFSTR("AMPDU_PARAMS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIEAMPDUCaps"), value, v7);
    if (CFDictionaryGetValueIfPresent(v52, CFSTR("MCS_SET"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIEMCSSet"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v52, CFSTR("EXT_CAPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIEExtCaps"), value, v7);
    if (CFDictionaryGetValueIfPresent(v52, CFSTR("TXBF_CAPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIETxBfCaps"), value, v7);
    if (CFDictionaryGetValueIfPresent(v52, CFSTR("ASEL_CAPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htCapsIEAselCaps"), value, v7);
  }
  v53 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("HT_IE"));
  if (v53)
  {
    v54 = v53;
    if (CFDictionaryGetValueIfPresent(v53, CFSTR("HT_PRIMARY_CHAN"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEPrimaryChannel"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_SECONDARY_CHAN_OFFSET"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIESecondaryChannelOffset"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_STA_CHAN_WIDTH"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIESTAChannelWidth"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_RIFS_MODE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIERIFSMode"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_PSMP_STAS_ONLY"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEPSMPSTASOnly"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_SERVICE_INT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEServiceInt"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_OP_MODE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEOpMode"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_NON_GF_STAS_PRESENT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIENonGFSTAsPresent"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_TX_BURST_LIMIT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIETXBurstLimit"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_OBSS_NON_HT_STAS_PRESENT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEOBSSNonHTSTAsPresent"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_DUAL_BEACON"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEDualVersion"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_DUAL_CTS_PROT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEDualCTSProt"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_SECONDARY_BEACON"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIESecondaryBeacon"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_LSIG_TXOP_PROT_FULL"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIELSIGTXOPProtFull"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_PCO_ACTIVE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEPCOActive"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_PCO_PHASE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEPCOPhase"), value, v7);
    if (CFDictionaryGetValueIfPresent(v54, CFSTR("HT_BASIC_MCS_SET"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("htIEBasicMCSSet"), v89, v7);
  }
  v55 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("VHT_CAPS_IE"));
  if (v55)
  {
    v56 = v55;
    if (CFDictionaryGetValueIfPresent(v55, CFSTR("VHT_CAPS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtCapsIECapsInfo"), value, v7);
    if (CFDictionaryGetValueIfPresent(v56, CFSTR("VHT_SUPPORTED_MCS_SET"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtCapsIESupportedMCSSet"), v89, v7);
  }
  v57 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("VHT_IE"));
  if (v57)
  {
    v58 = v57;
    if (CFDictionaryGetValueIfPresent(v57, CFSTR("VHT_CHAN_WIDTH"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtIEChanWidth"), value, v7);
    if (CFDictionaryGetValueIfPresent(v58, CFSTR("VHT_CENTER_CHAN_SEGMENT0"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtIEChanSeg0"), value, v7);
    if (CFDictionaryGetValueIfPresent(v58, CFSTR("VHT_CENTER_CHAN_SEGMENT1"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtIEChanSeg1"), value, v7);
    if (CFDictionaryGetValueIfPresent(v58, CFSTR("VHT_BASIC_MCS_SET"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("vhtIEBasicMcsSet"), value, v7);
  }
  v59 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("11U_INTERWORKING_IE"));
  if (v59)
  {
    v60 = v59;
    if (CFDictionaryGetValueIfPresent(v59, CFSTR("INTERWORKING_ACCESS_NETWORK_TYPE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIENetworkType"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_INTERNET"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEInternet"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_ASRA"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEASRA"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_ESR"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEESR"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_UESA"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEUESA"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_VENTURE_GRP"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEVentureGrp"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_VENTURE_TYPE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEVentureType"), value, v7);
    if (CFDictionaryGetValueIfPresent(v60, CFSTR("INTERWORKING_ACCESS_HESSID"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("dot11uInternetworkingIEHeSSID"), v90, v7);
  }
  v61 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("HOTSPOT20_IE"));
  if (v61)
  {
    v62 = v61;
    if (CFDictionaryGetValueIfPresent(v61, CFSTR("DGAF_DISABLED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("hotspotIEConfigDgafDisabled"), value, v7);
    if (CFDictionaryGetValueIfPresent(v62, CFSTR("RELEASE_NUMBER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("hotspotIEConfigReleaseNumber"), value, v7);
    if (CFDictionaryGetValueIfPresent(v62, CFSTR("PPS_MO_ID"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("hotspotIEConfigPPSMoId"), value, v7);
    if (CFDictionaryGetValueIfPresent(v62, CFSTR("ANQP_DOMAIN_ID"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("hotspotIEConfigAnqpSomainId"), value, v7);
  }
  v63 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("QBSS_LOAD_IE"));
  if (v63)
  {
    v64 = v63;
    if (CFDictionaryGetValueIfPresent(v63, CFSTR("QBSS_STA_COUNT"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("qBSSLoadIESTACount"), value, v7);
    if (CFDictionaryGetValueIfPresent(v64, CFSTR("QBSS_CHAN_UTIL"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("qBSSLoadIEChanUtilization"), value, v7);
    if (CFDictionaryGetValueIfPresent(v64, CFSTR("QBSS_AAC"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("qBSSLoadIEAAC"), value, v7);
  }
  v65 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("MOBILITY_DOMAIN_IE"));
  if (v65)
  {
    v66 = v65;
    if (CFDictionaryGetValueIfPresent(v65, CFSTR("MOBILITY_DOMAIN_IDENTIFIER"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("mobilityDomainIEIdentifier"), value, v7);
    if (CFDictionaryGetValueIfPresent(v66, CFSTR("MOBILITY_DOMAIN_FT_OVER_DS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("mobilityDomainIEFTOverDS"), value, v7);
    if (CFDictionaryGetValueIfPresent(v66, CFSTR("MOBILITY_DOMAIN_RESOURCE_REQ_PROTO"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("mobilityDomainIEReqProto"), value, v7);
  }
  v67 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("EXT_CAPS"));
  if (v67 && CFDictionaryGetValueIfPresent(v67, CFSTR("BSS_TRANS_MGMT"), (const void **)&value))
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("extendedCapabilityBSSTransMgmt"), value, v7);
  v68 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("FAST_ENTERPRISE_NETWORK"));
  if (v68)
  {
    v69 = v68;
    if (CFDictionaryGetValueIfPresent(v68, CFSTR("FT_STATE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("ftEnterpriseState"), value, v7);
    if (CFDictionaryGetValueIfPresent(v69, CFSTR("FASTLANE_STATE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("ftEnterpriseFastlaneState"), value, v7);
  }
  v70 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("HE_CAP"));
  v89 = v70;
  if (v70)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("heCap"), v70, v7);
  v71 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("HE_OP"));
  v89 = v71;
  if (v71)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("heOp"), v71, v7);
  v72 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("HE_MU_EDCA"));
  v89 = v72;
  if (v72)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("heMuEdca"), v72, v7);
  v73 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("HE_QBSS_LOAD"));
  v89 = v73;
  if (v73)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("heQBSSLoad"), v73, v7);
  v74 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("WPS_BEACON_IE"));
  if (v74)
  {
    v75 = v74;
    if (CFDictionaryGetValueIfPresent(v74, CFSTR("IE_KEY_WPS_SC_STATE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIESCState"), value, v7);
    if (CFDictionaryGetValueIfPresent(v75, CFSTR("IE_KEY_WPS_AP_SETUP_LOCKED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIEAPSetupLocked"), value, v7);
    if (CFDictionaryGetValueIfPresent(v75, CFSTR("IE_KEY_WPS_SEL_REG"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIESelReg"), value, v7);
    if (CFDictionaryGetValueIfPresent(v75, CFSTR("IE_KEY_WPS_DEV_PW_ID"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIEDevPWId"), value, v7);
    if (CFDictionaryGetValueIfPresent(v75, CFSTR("IE_KEY_WPS_REG_CFG_METHODS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIERegCfgMethods"), value, v7);
    v76 = (const __CFDictionary *)CFDictionaryGetValue(v75, CFSTR("WPS_PROB_RESP_IE"));
    if (v76)
    {
      v77 = v76;
      if (CFDictionaryGetValueIfPresent(v76, CFSTR("IE_KEY_WPS_RESP_TYPE"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEType"), value, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_UUID_E"), (const void **)&v89))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIETypeUUIDE"), v89, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_MANUFACTURER"), (const void **)&v90))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEManufacturer"), v90, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_MODEL_NAME"), (const void **)&v90))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEModelName"), v90, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_MODEL_NUM"), (const void **)&v90))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEModelNum"), v90, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_SERIAL_NUM"), (const void **)&v90))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIESerialNum"), v90, v7);
      v78 = (const __CFDictionary *)CFDictionaryGetValue(v77, CFSTR("IE_KEY_WPS_PRIMARY_DEV_TYPE"));
      if (v78)
      {
        v79 = v78;
        if (CFDictionaryGetValueIfPresent(v78, CFSTR("WPS_DEV_TYPE_CAT"), (const void **)&value))
          objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeCat"), value, v7);
        if (CFDictionaryGetValueIfPresent(v79, CFSTR("WPS_DEV_TYPE_OUI"), (const void **)&v89))
          objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeOUI"), v89, v7);
        if (CFDictionaryGetValueIfPresent(v79, CFSTR("WPS_DEV_TYPE_SUB_CAT"), (const void **)&value))
          objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeSubCat"), value, v7);
      }
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_DEV_NAME"), (const void **)&v90))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEDevName"), v90, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_DEV_NAME_DATA"), (const void **)&v89))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEDevNameData"), v89, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_CFG_METHODS"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIECfgMethods"), value, v7);
      if (CFDictionaryGetValueIfPresent(v77, CFSTR("IE_KEY_WPS_RF_BANDS"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIERFBands"), value, v7);
    }
  }
  v80 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("WPS_PROB_RESP_IE"));
  if (v80)
  {
    v81 = v80;
    if (CFDictionaryGetValueIfPresent(v80, CFSTR("IE_KEY_WPS_RESP_TYPE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEType"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_UUID_E"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIETypeUUIDE"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_UUID_R"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIETypeUUIDR"), v89, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_SC_STATE"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEScState"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_MANUFACTURER"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEManufacturer"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_MODEL_NAME"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEModelName"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_MODEL_NUM"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEModelNum"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_SERIAL_NUM"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIESerialNum"), v90, v7);
    v82 = (const __CFDictionary *)CFDictionaryGetValue(v81, CFSTR("IE_KEY_WPS_PRIMARY_DEV_TYPE"));
    v83 = v82;
    if (v82)
    {
      if (CFDictionaryGetValueIfPresent(v82, CFSTR("WPS_DEV_TYPE_CAT"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeCat"), value, v7);
      if (CFDictionaryGetValueIfPresent(v83, CFSTR("WPS_DEV_TYPE_OUI"), (const void **)&v89))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeOUI"), v89, v7);
      if (CFDictionaryGetValueIfPresent(v83, CFSTR("WPS_DEV_TYPE_SUB_CAT"), (const void **)&value))
        objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEPrimaryDevTypeSubCat"), value, v7);
    }
    if (CFDictionaryGetValueIfPresent(v83, CFSTR("IE_KEY_WPS_DEV_NAME"), (const void **)&v90))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEDevName"), v90, v7);
    if (CFDictionaryGetValueIfPresent(v83, CFSTR("IE_KEY_WPS_CFG_METHODS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIECfgMethods"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_SEL_REG"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIESelReg"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_AP_SETUP_LOCKED"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIEAPSetupLocked"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_REG_CFG_METHODS"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIERegCfgMethods"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_DEV_PW_ID"), (const void **)&value))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsBeaconIEDevPWId"), value, v7);
    if (CFDictionaryGetValueIfPresent(v81, CFSTR("IE_KEY_WPS_ENRL_NONCE"), (const void **)&v89))
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("wpsProbRespIEEnrlNonce"), v89, v7);
  }
  v84 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("CHANNEL_WIDTH"));
  value = v84;
  if (v84)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("channelWidth"), v84, v7);
  v85 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("SCAN_DIRECTED"));
  value = v85;
  if (v85)
    objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("scanDirected"), v85, v7);
  if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
  {
    v86 = (void *)sub_10002BE64((uint64_t)a2, CFSTR("SCAN_BSSID_LIST"));
    v88 = v86;
    if (v86)
      objc_msgSend(v11, "addFieldForKey:value:options:", CFSTR("scanBssidList"), objc_msgSend(v86, "componentsJoinedByString:", CFSTR(":")), v7);
  }
  sub_100052064(v11);

LABEL_415:
  objc_autoreleasePoolPop(v6);
}

uint64_t sub_100060C54(void *a1, const void *a2, uint64_t a3)
{
  void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  void *v12;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: waMsg is NULL", "__WiFiMetricsManagerWAMessageAppendSSIDandBSSID");
    goto LABEL_17;
  }
  v6 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is NULL", "__WiFiMetricsManagerWAMessageAppendSSIDandBSSID");
    goto LABEL_17;
  }
  v7 = sub_10002B088(a2);
  v8 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
  if (!v7)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ssid is NULL", "__WiFiMetricsManagerWAMessageAppendSSIDandBSSID");
    goto LABEL_16;
  }
  v9 = v8;
  if (!v8)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssid is NULL", "__WiFiMetricsManagerWAMessageAppendSSIDandBSSID");
LABEL_16:
    objc_autoreleasePoolPop(v12);
LABEL_17:
    v10 = 0;
    goto LABEL_6;
  }
  objc_msgSend(a1, "addFieldForKey:value:options:", kWAMessageKeySSID, +[NSString stringWithString:](NSString, "stringWithString:", v7), a3);
  objc_msgSend(a1, "addFieldForKey:value:options:", kWAMessageKeyBSSID, +[NSString stringWithString:](NSString, "stringWithString:", v9), a3);
  v10 = 1;
LABEL_6:
  objc_autoreleasePoolPop(v6);
  return v10;
}

void sub_100060E10(_OWORD *a1)
{
  _OWORD *v2;
  __int128 v3;
  void *v4;
  WiFiManagerAnalytics *v5;
  uint64_t v6;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null stats", "WiFiMetricsManagerSubmitDpsProbeStats");
    goto LABEL_5;
  }
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
    {
      v4 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitDpsProbeStats");
    }
    else
    {
      v2 = malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
      v9[3] = (uint64_t)v2;
      v3 = a1[1];
      *v2 = *a1;
      v2[1] = v3;
      v4 = objc_autoreleasePoolPush();
      v5 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
      v6 = v9[3];
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472;
      v7[2] = sub_100060F90;
      v7[3] = &unk_10022F360;
      v7[4] = &v8;
      -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v5, "prepareMessageForSubmission:withData:andReply:", 11075585, v6, v7);
    }
LABEL_5:
    objc_autoreleasePoolPop(v4);
  }
  _Block_object_dispose(&v8, 8);
}

void sub_100060F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100060F90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  void *v7;

  if (!a2 || a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing DPSActiveProbeStats for submission: %@, or null WAMessage", "WiFiMetricsManagerSubmitDpsProbeStats_block_invoke", a3);
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    -[WiFiManagerAnalytics triggerDatapathDiagnosticsNoReply:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDatapathDiagnosticsNoReply:", a2);
  }
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(void **)(v6 + 24);
  if (v7)
  {
    free(v7);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  *(_QWORD *)(v6 + 24) = 0;
}

void sub_100061040(_OWORD *a1)
{
  _OWORD *v2;
  void *v3;
  WiFiManagerAnalytics *v4;
  uint64_t v5;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null stats", "WiFiMetricsManagerSubmitDpsLinkStateChangeEvent");
    goto LABEL_5;
  }
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitDpsLinkStateChangeEvent");
    }
    else
    {
      v2 = malloc_type_malloc(0x10uLL, 0x1000040A517B1A3uLL);
      v8[3] = (uint64_t)v2;
      *v2 = *a1;
      v3 = objc_autoreleasePoolPush();
      v4 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
      v5 = v8[3];
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472;
      v6[2] = sub_1000611C0;
      v6[3] = &unk_10022F360;
      v6[4] = &v7;
      -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v4, "prepareMessageForSubmission:withData:andReply:", 11075586, v5, v6);
    }
LABEL_5:
    objc_autoreleasePoolPop(v3);
  }
  _Block_object_dispose(&v7, 8);
}

void sub_1000611A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000611C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  void *v7;

  if (!a2 || a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing DPSLinkStateChangeEvent for submission: %@, or null WAMessage", "WiFiMetricsManagerSubmitDpsLinkStateChangeEvent_block_invoke", a3);
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    -[WiFiManagerAnalytics triggerDatapathDiagnosticsNoReply:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDatapathDiagnosticsNoReply:", a2);
  }
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(void **)(v6 + 24);
  if (v7)
  {
    free(v7);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  *(_QWORD *)(v6 + 24) = 0;
}

void sub_100061270(const __CFDictionary *a1)
{
  CFDictionaryRef Copy;
  void *v3;
  WiFiManagerAnalytics *v4;
  uint64_t v5;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null info", "WiFiMetricsManagerSubmitDpsAccessPointInfo");
    goto LABEL_5;
  }
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitDpsAccessPointInfo");
    }
    else
    {
      Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, a1);
      v8[3] = (uint64_t)Copy;
      v3 = objc_autoreleasePoolPush();
      v4 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
      v5 = v8[3];
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472;
      v6[2] = sub_1000613E4;
      v6[3] = &unk_10022F360;
      v6[4] = &v7;
      -[WiFiManagerAnalytics prepareMessageForSubmission:withData:andReply:](v4, "prepareMessageForSubmission:withData:andReply:", 11075587, v5, v6);
    }
LABEL_5:
    objc_autoreleasePoolPop(v3);
  }
  _Block_object_dispose(&v7, 8);
}

void sub_1000613CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000613E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const void *v6;

  if (!a2 || a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Error back preparing DpsAccessPointInfo for submission: %@, or null WAMessage", "WiFiMetricsManagerSubmitDpsAccessPointInfo_block_invoke", a3);
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    -[WiFiManagerAnalytics triggerDatapathDiagnosticsNoReply:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDatapathDiagnosticsNoReply:", a2);
  }
  v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_100061494(unsigned int *a1)
{
  int v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  const __CFString *v9;
  uint64_t v10;
  const __CFString *v11;
  void *v12;

  if (a1 && qword_10026D5D8)
  {
    v2 = sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16));
    v3 = objc_autoreleasePoolPush();
    if (v2 == 1)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitPrivateMacStats");
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Submitting PrivateMacStats for WA. event type <%u>, private mac type <%u>, toggled? <%d>, underClassification? <%d>, disabledByProfile? <%d>", "WiFiMetricsManagerSubmitPrivateMacStats", *a1, a1[1], *((unsigned __int8 *)a1 + 8), *((unsigned __int8 *)a1 + 9), *((unsigned __int8 *)a1 + 10));
      objc_autoreleasePoolPop(v3);
      v3 = objc_autoreleasePoolPush();
      v4 = objc_autoreleasePoolPush();
      v5 = objc_alloc((Class)WAMessage);
      v6 = objc_msgSend(v5, "initWithMetricName:options:", kWAMessageMetricNamePrivateMacStats, 5);
      if (v6)
      {
        v7 = v6;
        v8 = (int)*a1;
        if (v8 > 7)
          v9 = CFSTR("UnknownEvent");
        else
          v9 = off_10022F470[v8];
        objc_msgSend(v6, "addFieldForKey:value:options:", kWAMessageKeyPrivateMacEvent, +[NSString stringWithString:](NSString, "stringWithString:", v9), 5);
        v10 = (int)a1[1];
        if (v10 > 2)
          v11 = CFSTR("UnknownAddr");
        else
          v11 = off_10022F4B0[v10];
        objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyPrivateMacType, +[NSString stringWithString:](NSString, "stringWithString:", v11), 5);
        objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyPrivateMacToggled, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *((unsigned __int8 *)a1 + 8)), 5);
        objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyPrivateMacUnderClassification, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *((unsigned __int8 *)a1 + 9)), 5);
        objc_msgSend(v7, "addFieldForKey:value:options:", kWAMessageKeyPrivateMacDisabledByProfile, +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *((unsigned __int8 *)a1 + 10)), 5);
        sub_100052064(v7);

      }
      else
      {
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for PrivateMacStats", "__WiFiMetricsManagerWAMessageSubmitPrivateMacStats");
        objc_autoreleasePoolPop(v12);
      }
      objc_autoreleasePoolPop(v4);
    }
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_100061728(uint64_t result, uint64_t a2)
{
  const void *v3;
  const void *v4;
  CFTypeID TypeID;
  const __CFNumber *Value;
  unsigned int v7;
  int v8;
  void *v9;
  CFBooleanRef v10;
  CFBooleanRef v11;
  BOOL v12;
  char v13;
  CFBooleanRef v14;
  BOOL v15;
  char v16;
  BOOL v17;

  if (!result)
    return result;
  if (!a2)
    return result;
  v3 = (const void *)result;
  *(_QWORD *)(a2 + 4) = 1;
  result = (uint64_t)sub_10002BE64(result, CFSTR("PRIVATE_MAC_ADDRESS"));
  if (!result)
    return result;
  v4 = (const void *)result;
  TypeID = CFDictionaryGetTypeID();
  result = CFGetTypeID(v4);
  if (TypeID != result)
    return result;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
  v7 = sub_100064F80(Value);
  if (v7 == 3)
  {
    *(_DWORD *)(a2 + 4) = 0;
  }
  else
  {
    if (v7 == 2)
    {
      v8 = 2;
    }
    else
    {
      if (v7 != 1)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Unknow private MAC type for network [%@]", sub_10002B088(v3));
        objc_autoreleasePoolPop(v9);
        goto LABEL_15;
      }
      v8 = 1;
    }
    *(_DWORD *)(a2 + 4) = v8;
  }
LABEL_15:
  v10 = (CFBooleanRef)sub_10002BE64((uint64_t)v3, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
  if (v10)
    *(_BYTE *)(a2 + 9) = v10 == kCFBooleanTrue;
  v11 = (CFBooleanRef)sub_10002BE64((uint64_t)v3, CFSTR("PrivateMacFeatureToggled"));
  if (v11)
    v12 = v11 == kCFBooleanTrue;
  else
    v12 = 0;
  v13 = v12;
  *(_BYTE *)(a2 + 8) = v13;
  v14 = (CFBooleanRef)sub_10002BE64((uint64_t)v3, CFSTR("PrivateMacDefaultToOFF"));
  if (v14)
    v15 = v14 == kCFBooleanTrue;
  else
    v15 = 0;
  v16 = v15;
  *(_BYTE *)(a2 + 10) = v16;
  result = (uint64_t)sub_1000C3F88((uint64_t)v3);
  if ((_DWORD)result == 1)
  {
    v17 = 1;
  }
  else
  {
    result = sub_1000CC270((uint64_t)v3);
    v17 = (_DWORD)result == 2;
  }
  *(_BYTE *)(a2 + 11) = v17;
  return result;
}

void sub_1000618C4(uint64_t a1, const void *a2)
{
  void *v4;
  id v5;
  id v6;
  void *v7;
  const __CFString *v8;
  uint64_t v9;
  _BOOL8 v10;
  uint64_t v11;
  const __CFNumber *v12;
  int v13;
  void *v14;
  void *v15;
  CFStringRef v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  void *v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  int valuePtr;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v22 = "%s: null Companion Info";
LABEL_21:
    v23 = 3;
LABEL_24:
    objc_msgSend(v21, "WFLog:message:", v23, v22, "__WiFiMetricsManagerWAMessageSubmitCompanionAssistedAJInfo");
    goto LABEL_25;
  }
  if (!qword_10026D5D8)
    goto LABEL_16;
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_25;
    v22 = "%s: Camera is in Foreground";
    goto LABEL_21;
  }
  v5 = objc_alloc((Class)WAMessage);
  v6 = objc_msgSend(v5, "initWithMetricName:options:", kWAMessageMetricNameCompanionAssistedAJ, 7);
  if (!v6)
  {
    v20 = objc_autoreleasePoolPush();
    v21 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v22 = "%s: Failed to alloc WAMessage for Companion Assisted AJ";
      v23 = 4;
      goto LABEL_24;
    }
LABEL_25:
    objc_autoreleasePoolPop(v20);
    goto LABEL_16;
  }
  v7 = v6;
  objc_msgSend(v6, "addFieldForKey:value:options:", CFSTR("CompanionRSSI"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 8)), 7);
  objc_msgSend(v7, "addFieldForKey:value:options:", CFSTR("CompanionChannel"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 12)), 7);
  if (a2)
  {
    v8 = (const __CFString *)sub_10002B088(a2);
    if (CFStringCompare(v8, *(CFStringRef *)a1, 0))
    {
      v9 = 0;
      v10 = 0;
      v11 = 1;
    }
    else
    {
      valuePtr = 0;
      v12 = (const __CFNumber *)sub_1000316E0((uint64_t)a2);
      if (v12)
      {
        CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
        v13 = valuePtr;
      }
      else
      {
        v13 = 0;
      }
      v10 = v13 == *(_DWORD *)(a1 + 12);
      v11 = 1;
      v9 = 1;
    }
  }
  else
  {
    v11 = 0;
    v9 = 0;
    v10 = 0;
  }
  objc_msgSend(v7, "addFieldForKey:value:options:", CFSTR("GizmoConnected"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11), 7);
  objc_msgSend(v7, "addFieldForKey:value:options:", CFSTR("GizmoConnectedToSameSSID"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v9), 7);
  objc_msgSend(v7, "addFieldForKey:value:options:", CFSTR("GizmoConnectedToSameChannel"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v10), 7);
  v14 = objc_autoreleasePoolPush();
  v15 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v16 = *(CFStringRef *)a1;
    v17 = *(unsigned int *)(a1 + 8);
    v18 = *(unsigned int *)(a1 + 12);
    v19 = sub_10002B088(a2);
    objc_msgSend(v15, "WFLog:message:", 3, "%s: CompanionSSID %@, CompanionRSSI %d, CompanionChannel %d, GizmoSSID %@, GizmoChannel %@", "__WiFiMetricsManagerWAMessageSubmitCompanionAssistedAJInfo", v16, v17, v18, v19, sub_1000316E0((uint64_t)a2));
  }
  objc_autoreleasePoolPop(v14);
  sub_100052064(v7);

LABEL_16:
  objc_autoreleasePoolPop(v4);
}

void sub_100061BA4(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  const char *v8;
  uint64_t v9;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v8 = "%s: null ssidAndQualityArr";
    goto LABEL_11;
  }
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) != 1)
    {
      v3 = objc_alloc((Class)WAMessage);
      v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameHistoricalKnownNetworkQuality, 6);
      if (v4)
      {
        v5 = v4;
        objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKeyNetworkHistoricalQuality, a1, 6);
        sub_100052064(v5);

        goto LABEL_6;
      }
      v6 = objc_autoreleasePoolPush();
      v7 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v8 = "%s: Failed to alloc WAMessage for HistoricalKnownNetworkQuality";
        v9 = 4;
        goto LABEL_14;
      }
LABEL_15:
      objc_autoreleasePoolPop(v6);
      goto LABEL_6;
    }
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_15;
    v8 = "%s: Camera is in Foreground";
LABEL_11:
    v9 = 3;
LABEL_14:
    objc_msgSend(v7, "WFLog:message:", v9, v8, "__WiFiMetricsManagerWAMessageUpdateHistoricalKnownNetworkQuality");
    goto LABEL_15;
  }
LABEL_6:
  objc_autoreleasePoolPop(v2);
}

void sub_100061CEC(double a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricName11axAsrDuration, 5);
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKey11axAsrDuration, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1), 5);
    sub_100052064(v5);
    CFRelease(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmit11axAsrDuration");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_100061DD4(const __CFDictionary *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  const __CFNumber *Value;
  const __CFNumber *v7;
  void *v8;
  unsigned int v9;
  unsigned int valuePtr;

  v2 = objc_autoreleasePoolPush();
  if (!qword_10026D5D8)
    goto LABEL_9;
  if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitCatsScanManagerMetrics");
    goto LABEL_14;
  }
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameCatsScanMetrics, 5);
  if (!v4)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitCatsScanManagerMetrics");
LABEL_14:
    objc_autoreleasePoolPop(v8);
    goto LABEL_9;
  }
  v5 = v4;
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("CATS_SCAN_METRIC_CACHE_HITS"));
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  v9 = 0;
  v7 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("CATS_SCAN_METRIC_CACHE_MISS"));
  if (v7)
    CFNumberGetValue(v7, kCFNumberSInt32Type, &v9);
  objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyCatsScanCacheHit, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", valuePtr), 5);
  objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyCatsScanCacheMiss, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v9), 5);
  sub_100052064(v5);
  CFRelease(v5);
LABEL_9:
  objc_autoreleasePoolPop(v2);
}

void sub_100061F78(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameCarPlayLinkQualityMetrics, 5);
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v4, "addFieldForKey:value:options:", CFSTR("txRateMax"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 36)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("txRateMin"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 32)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("txRateAvg"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 40)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("txRateLast"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 44)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rxRateMax"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 52)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rxRateMin"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 48)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rxRateAvg"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 56)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rxRateLast"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 60)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("ccaMax"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 100)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("ccaMin"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 96)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("ccaAvg"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 104)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("ccaLast"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 108)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("snrMax"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 68)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("snrMin"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 64)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("snrAvg"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 72)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("snrLast"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 76)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rssiMax"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 84)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rssiMin"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 80)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rssiAvg"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 88)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("rssiLast"), +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 92)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 24)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("roamedCount"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 28)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("channel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(__int16 *)(a1 + 112)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("bandWidth"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int16 *)(a1 + 114)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("numberOfTxErrorEvents"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 116)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lqmInterval"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 120)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDownSubReason"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 136)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDownReason"), +[NSString stringWithString:](NSString, "stringWithString:", *(_QWORD *)(a1 + 128)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("phyMode"), +[NSString stringWithString:](NSString, "stringWithString:", *(_QWORD *)(a1 + 144)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleModelName"), +[NSString stringWithString:](NSString, "stringWithString:", *(_QWORD *)a1), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleManufacturer"), +[NSString stringWithString:](NSString, "stringWithString:", *(_QWORD *)(a1 + 8)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("hardwareVersion"), +[NSString stringWithString:](NSString, "stringWithString:", *(_QWORD *)(a1 + 16)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("isLpcValid"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned __int8 *)(a1 + 152)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lpcMinOffset"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(double *)(a1 + 160)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lpcTxOffset0"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 168)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lpcTxOffset1"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 172)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lpcTxOffset2"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("lpcTxOffset3"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 180)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("estimatedPowerReduction"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(double *)(a1 + 192)), 5);
    sub_100052064(v5);
    CFRelease(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitCarPlayLinkQualityMetrics");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000625BC(unsigned int *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameCarPlayConnectMetrics, 5);
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKeyCarPlayTimeBasicAssocTaken, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyCarPlayTime4WayHSTaken, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[1]), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyCarPlayTimeDhcpTaken, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[2]), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyCarPlayWasScanCanceledBeforeJoin, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 12)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("Channel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int16 *)a1 + 7)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleModelName"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 2)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleManufacturer"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 3)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("hardwareVersion"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 4)), 5);
    sub_100052064(v5);
    CFRelease(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitCarPlayConnectMetrics");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000627BC(unsigned int *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) == 1)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Camera is in Foreground", "WiFiMetricsManagerSubmitInfraConnectionMetrics");
    }
    else
    {
      v3 = objc_alloc((Class)WAMessage);
      v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameInfraConnectionMetrics, 5);
      if (v4)
      {
        v5 = v4;
        objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKeyInfraConnectionTime4WayHSTaken, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
        objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("Channel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int16 *)a1 + 2)), 5);
        objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("Band"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int16 *)a1 + 3)), 5);
        sub_100052064(v5);
        CFRelease(v5);
        goto LABEL_5;
      }
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitInfraConnectionMetrics");
    }
    objc_autoreleasePoolPop(v6);
  }
LABEL_5:
  objc_autoreleasePoolPop(v2);
}

void sub_100062938(unsigned int *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026D5D8)
  {
    v3 = objc_alloc((Class)WAMessage);
    v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameDetailedInfraConnectionMetrics, 5);
    if (v4)
    {
      v5 = v4;
      objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionEapolStartM1Dur, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionM1M2Dur, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[1]), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionM2M3Dur, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[2]), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionM3M4Dur, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[3]), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionTotal4WayHSDur, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[4]), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("Channel"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int16 *)a1 + 10)), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("Band"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int16 *)a1 + 11)), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionA2DPActive, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 24)), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionSCOActive, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 25)), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionRSSI, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a1[7]), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionAPProfile, +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 4)), 5);
      objc_msgSend(v5, "addFieldForKey:value:options:", kWAMessageKeyDetailedInfraConnectionAutoJoinHandshake, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 40)), 5);
      sub_100052064(v5);
      CFRelease(v5);
    }
    else
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitDetailedInfraConnectionMetrics");
      objc_autoreleasePoolPop(v6);
    }
  }
  objc_autoreleasePoolPop(v2);
}

void sub_100062C04(unsigned int *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameCarPlayLinkDownSuppressionMetrics, 5);
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v4, "addFieldForKey:value:options:", CFSTR("linkDownDuration"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDownSubReason"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1[4]), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("timedOut"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 20)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDebounceSucceeded"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 21)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("SessionDownSuppressionSucceeded"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *((unsigned __int8 *)a1 + 22)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("linkDownReason"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 1)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleModelName"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 3)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("vehicleManufacturer"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 4)), 5);
    objc_msgSend(v5, "addFieldForKey:value:options:", CFSTR("hardwareVersion"), +[NSString stringWithString:](NSString, "stringWithString:", *((_QWORD *)a1 + 5)), 5);
    sub_100052064(v5);
    CFRelease(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitCarPlayLinkDownSuppressionMetrics");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_100062E00(unsigned int *a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = objc_alloc((Class)WAMessage);
  v4 = objc_msgSend(v3, "initWithMetricName:options:", kWAMessageMetricNameSidekickMetrics, 5);
  if (v4)
  {
    v5 = v4;
    objc_msgSend(v4, "addFieldForKey:value:options:", kWAMessageKeyWiFiCriticalDuration, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *a1), 5);
    sub_100052064(v5);
    CFRelease(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null message", "WiFiMetricsManagerSubmitSidekickMetrics");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_100062EE0(const void *a1, void *a2, void *a3)
{
  void *v6;
  id v7;
  id v8;
  uint64_t v9;
  __CFString *v10;
  void *v11;
  uint64_t v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  BOOL v17;
  BOOL v18;
  const void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  __CFString *v24;
  id v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  const char *v34;
  uint64_t v35;
  void *v36;
  const void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  id v43;
  id v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[128];

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v32 = objc_autoreleasePoolPush();
    v33 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_43;
    v34 = "%s: null network";
LABEL_39:
    v35 = 4;
LABEL_42:
    objc_msgSend(v33, "WFLog:message:", v35, v34, "WiFiMetricsManagerUpdateBeaconCacheResults");
    goto LABEL_43;
  }
  if (!a2)
  {
    v32 = objc_autoreleasePoolPush();
    v33 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_43;
    v34 = "%s: null beaconCacheResults";
    goto LABEL_39;
  }
  if (qword_10026D5D8)
  {
    if (sub_100093FDC(*(_QWORD *)(qword_10026D5D8 + 16)) != 1)
    {
      v37 = a1;
      v38 = v6;
      v43 = +[NSMutableArray array](NSMutableArray, "array");
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      v48 = 0u;
      v7 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
      if (v7)
      {
        v8 = v7;
        v9 = *(_QWORD *)v46;
        v42 = kWAMessageKeyRSSI;
        v41 = kWAMessageKeySSID;
        v40 = kWAMessageKeyChannel;
        v10 = CFSTR("RSSI");
        v39 = kWAMessageKeyBSSID;
        do
        {
          v11 = 0;
          v44 = v8;
          do
          {
            if (*(_QWORD *)v46 != v9)
              objc_enumerationMutation(a2);
            v12 = *(_QWORD *)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)v11);
            if (v12)
            {
              v13 = sub_10002B088(*(const void **)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)v11));
              if (!a3 || objc_msgSend(a3, "containsObject:", v13))
              {
                v14 = sub_10002BE64(v12, v10);
                v15 = sub_10002BE64(v12, CFSTR("CHANNEL"));
                v16 = sub_10002BE64(v12, CFSTR("BSSID"));
                v17 = !v14 || v13 == 0;
                v18 = v17 || v15 == 0;
                if (!v18 && v16 != 0)
                {
                  v20 = v16;
                  v21 = v9;
                  v22 = a3;
                  v23 = a2;
                  v24 = v10;
                  v25 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
                  objc_msgSend(v25, "setObject:forKey:", v14, v42);
                  objc_msgSend(v25, "setObject:forKey:", v13, v41);
                  objc_msgSend(v25, "setObject:forKey:", v15, v40);
                  objc_msgSend(v25, "setObject:forKey:", v20, v39);
                  v26 = v25;
                  v10 = v24;
                  a2 = v23;
                  a3 = v22;
                  v9 = v21;
                  v8 = v44;
                  objc_msgSend(v43, "addObject:", v26);
                }
              }
            }
            v11 = (char *)v11 + 1;
          }
          while (v8 != v11);
          v8 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
        }
        while (v8);
      }
      if ((unint64_t)objc_msgSend(v43, "count") <= 1)
      {
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Not enough trimmedResults", "WiFiMetricsManagerUpdateBeaconCacheResults");
      }
      else
      {
        v27 = objc_alloc((Class)WAMessage);
        v28 = objc_msgSend(v27, "initWithMetricName:options:", kWAMessageMetricNameBeaconCache, 6);
        if (v28)
        {
          v29 = v28;
          objc_msgSend(v28, "addFieldForKey:value:options:", kWAMessageKeyBeaconCacheResults, v43, 6);
          v30 = kWAMessageKeyMetricDate;
          -[NSDate timeIntervalSinceReferenceDate](+[NSDate date](NSDate, "date"), "timeIntervalSinceReferenceDate");
          objc_msgSend(v29, "addFieldForKey:value:options:", v30, +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), 6);
          if (!sub_100060C54(v29, v37, 6))
          {
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to append SSID/BSSID to WAMessage", "WiFiMetricsManagerUpdateBeaconCacheResults");
            objc_autoreleasePoolPop(v31);
          }
          objc_msgSend(v29, "addFieldForKey:value:options:", kWAMessageKeyChannel, sub_10002BE64((uint64_t)v37, CFSTR("CHANNEL")), 6);
          sub_100052064(v29);

          goto LABEL_33;
        }
        v36 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Failed to alloc WAMessage for kWAMessageMetricNameBeaconCache", "WiFiMetricsManagerUpdateBeaconCacheResults");
      }
      objc_autoreleasePoolPop(v36);
LABEL_33:
      v6 = v38;
      goto LABEL_34;
    }
    v32 = objc_autoreleasePoolPush();
    v33 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v34 = "%s: Camera is in Foreground";
      v35 = 3;
      goto LABEL_42;
    }
LABEL_43:
    objc_autoreleasePoolPop(v32);
  }
LABEL_34:
  objc_autoreleasePoolPop(v6);
}

void sub_100063388(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;
  void *v6;
  void *v7;

  v4 = objc_autoreleasePoolPush();
  if (a1 && a2)
  {
    v5 = objc_msgSend(objc_alloc((Class)WAMessage), "initWithMetricName:options:", a1, 5);
    if (v5)
    {
      v6 = v5;
      objc_msgSend(v5, "addFieldsFromDictionary:options:", a2, 5);
      sub_100052064(v6);

    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for %@", "__WiFiMetricsManagerWAMessageSubmitFromDictionary", a1);
      objc_autoreleasePoolPop(v7);
    }
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null param (name:%@ dict:%@)", "__WiFiMetricsManagerWAMessageSubmitFromDictionary", a1, a2);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_100063478(void *a1)
{
  void *v2;
  uint64_t v3;
  int v4;
  void *v5;
  void *v6;
  const char *v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  unsigned int v12;
  void *v13;
  const char *v14;
  id v15;
  id v16;
  void *v17;
  void *v18;

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    v3 = kWAMessageKeyFaultName;
    if (objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", kWAMessageKeyFaultName), "isEqual:", WiFiUsageFaultReasonStringMap(30)))
    {
      if (!qword_10026D5D8)
        goto LABEL_35;
      v4 = sub_100093FE8(*(_QWORD *)(qword_10026D5D8 + 16));
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Got kWiFiUsageFaultReasonAirplayConnectionStall, checking audio state", "WiFiMetricsManagerSubmitFaultDictionary");
      objc_autoreleasePoolPop(v5);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v4)
          v7 = "%s: linkRecoveryDisabled == TRUE implies Audio Playing, setting WiFiAnalyticsMessageTypeManagedFault";
        else
          v7 = "%s: linkRecoveryDisabled == FALSE implies No Audio Playing, removing WiFiAnalyticsMessageTypeManagedFault";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v7, "WiFiMetricsManagerSubmitFaultDictionary");
      }
      objc_autoreleasePoolPop(v6);
      if (-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("ManagedFaultConnectionStallOverrideAllow")))
      {
        v8 = objc_msgSend(-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("ManagedFaultConnectionStallOverrideAllow")), "BOOLValue");
        v9 = objc_autoreleasePoolPush();
        if (v8)
          v10 = 16;
        else
          v10 = 0;
        if (qword_10026DD20)
        {
          if (v8)
            v11 = "%s: Found NSUserDefaults kManagedFaultConnectionStallOverrideAllow TRUE, setting WiFiAnalyticsMessageT"
                  "ypeManagedFault for %@";
          else
            v11 = "%s: Found NSUserDefaults kManagedFaultConnectionStallOverrideAllow FALSE, removing WiFiAnalyticsMessag"
                  "eTypeManagedFault for %@";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v11, "WiFiMetricsManagerSubmitFaultDictionary", WiFiUsageFaultReasonStringMap(objc_msgSend(a1, "objectForKeyedSubscript:", v3)));
        }
        objc_autoreleasePoolPop(v9);
      }
      else
      {
        v10 = 16 * (v4 != 0);
      }
    }
    else
    {
      v10 = 16;
    }
    if (-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("ManagedFaultOverrideAll")))
    {
      v12 = objc_msgSend(-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("ManagedFaultOverrideAll")), "BOOLValue");
      v13 = objc_autoreleasePoolPush();
      if (v12)
        v10 = 16;
      else
        v10 = 0;
      if (qword_10026DD20)
      {
        if (v12)
          v14 = "%s: Found NSUserDefaults kManagedFaultOverrideAll TRUE, setting WiFiAnalyticsMessageTypeManagedFault for %@";
        else
          v14 = "%s: Found NSUserDefaults kManagedFaultOverrideAll FALSE, removing WiFiAnalyticsMessageTypeManagedFault for %@";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v14, "WiFiMetricsManagerSubmitFaultDictionary", WiFiUsageFaultReasonStringMap(objc_msgSend(a1, "objectForKeyedSubscript:", v3)));
      }
      objc_autoreleasePoolPop(v13);
    }
    v15 = objc_alloc((Class)WAMessage);
    v16 = objc_msgSend(v15, "initWithMetricName:options:", kWAMessageMetricNameFault, v10);
    if (v16)
    {
      v17 = v16;
      objc_msgSend(v16, "addFieldsFromDictionary:options:", a1, v10);
      sub_100052064(v17);

    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Failed to alloc WAMessage for kWAMessageMetricNameFault", "WiFiMetricsManagerSubmitFaultDictionary");
      objc_autoreleasePoolPop(v18);
    }
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null param (dict:%@)", "WiFiMetricsManagerSubmitFaultDictionary", 0);
  }
LABEL_35:
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_100063794()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_10022F380);
  qword_10026D5E8 = result;
  return result;
}

void sub_1000637B8()
{
  uint64_t v0;
  const __CFArray *v1;
  CFIndex v2;
  CFTypeRef *ValueAtIndex;
  CFTypeRef v4;
  CFTypeRef v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  v0 = qword_10026D5D8;
  if (qword_10026D5D8)
  {
    v1 = *(const __CFArray **)(qword_10026D5D8 + 32);
    if (v1)
    {
      if (CFArrayGetCount(v1) >= 1)
      {
        v2 = 0;
        do
        {
          ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(qword_10026D5D8 + 32), v2);
          v4 = ValueAtIndex[88];
          if (v4)
          {
            CFRelease(v4);
            ValueAtIndex[88] = 0;
          }
          v5 = ValueAtIndex[89];
          if (v5)
          {
            CFRelease(v5);
            ValueAtIndex[89] = 0;
          }
          if (*ValueAtIndex)
          {
            CFRelease(*ValueAtIndex);
            *ValueAtIndex = 0;
          }
          v6 = (void *)ValueAtIndex[30];
          if (v6)
          {
            free(v6);
            ValueAtIndex[30] = 0;
          }
          v7 = (void *)ValueAtIndex[32];
          if (v7)
          {
            free(v7);
            ValueAtIndex[32] = 0;
          }
          v8 = (void *)ValueAtIndex[39];
          if (v8)
          {
            free(v8);
            ValueAtIndex[39] = 0;
          }
          v9 = (void *)ValueAtIndex[41];
          if (v9)
          {
            free(v9);
            ValueAtIndex[41] = 0;
          }
          v10 = (void *)ValueAtIndex[43];
          if (v10)
          {
            free(v10);
            ValueAtIndex[43] = 0;
          }
          v11 = (void *)ValueAtIndex[47];
          if (v11)
            free(v11);
          free(ValueAtIndex);
          ++v2;
        }
        while (v2 < CFArrayGetCount(*(CFArrayRef *)(qword_10026D5D8 + 32)));
      }
      v0 = qword_10026D5D8;
      v12 = *(const void **)(qword_10026D5D8 + 32);
      if (v12)
      {
        CFRelease(v12);
        v0 = qword_10026D5D8;
        *(_QWORD *)(qword_10026D5D8 + 32) = 0;
      }
    }
    v13 = *(const void **)(v0 + 56);
    if (v13)
    {
      CFRelease(v13);
      v0 = qword_10026D5D8;
      *(_QWORD *)(qword_10026D5D8 + 56) = 0;
    }
    v14 = *(const void **)(v0 + 48);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(qword_10026D5D8 + 48) = 0;
    }
  }
}

const __CFNumber *sub_1000638FC(const __CFNumber *result)
{
  int valuePtr;

  if (result)
  {
    valuePtr = -1431655766;
    result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
    if ((_DWORD)result)
    {
      if ((valuePtr - 1) > 8)
        return 0;
      else
        return (const __CFNumber *)dword_1001BB2D0[valuePtr - 1];
    }
  }
  return result;
}

void sub_100063954(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  void *context;

  if (a1)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = v10;
    if (a3)
    {
      context = v10;
      if (a5)
        v12 = 7;
      else
        v12 = 6;
      v13 = +[NSMutableString string](NSMutableString, "string");
      if (a4)
      {
        v14 = 0;
        do
        {
          objc_msgSend(v13, "appendFormat:", CFSTR("%02x"), *(unsigned __int8 *)(a3 + v14));
          if (v14 < a4 - 1)
            objc_msgSend(v13, "appendFormat:", CFSTR(":"));
          ++v14;
        }
        while (a4 != v14);
      }
      objc_msgSend(a1, "addFieldForKey:value:options:", a2, v13, v12);
      v11 = context;
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: addr is NULL", "__WiFiMetricsManagerWAMessageAppendFieldInColonHexdecFormat");
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: waMsg is NULL", "__WiFiMetricsManagerWAMessageAppendFieldInColonHexdecFormat");
  }
  objc_autoreleasePoolPop(v11);
}

void sub_100063AA8(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  id v10;
  unsigned int *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  int v22;
  void *context;
  unsigned int *v24;
  void *v25;

  if (!a1)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: waMsg is NULL", "__WiFiMetricsManagerWAMessageAppendLQM");
    goto LABEL_21;
  }
  if (!a2)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device is NULL", "__WiFiMetricsManagerWAMessageAppendLQM");
    goto LABEL_21;
  }
  v8 = a4;
  if (!a4)
  {
    v9 = malloc_type_malloc(0x34CuLL, 0x1000040503055D5uLL);
    if (v9)
    {
      v8 = (uint64_t)v9;
      bzero(v9, 0x34CuLL);
      if (!sub_100052538(a2, v8))
      {
        v20 = (void *)v8;
        goto LABEL_14;
      }
      goto LABEL_6;
    }
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null lqmHistoryMetric", "__WiFiMetricsManagerWAMessageAppendLQM");
LABEL_21:
    objc_autoreleasePoolPop(v21);
    return;
  }
LABEL_6:
  v22 = a3;
  v25 = a1;
  context = objc_autoreleasePoolPush();
  v10 = +[NSMutableArray array](NSMutableArray, "array");
  v11 = (unsigned int *)v8;
  v12 = +[NSMutableArray array](NSMutableArray, "array");
  v13 = +[NSMutableArray array](NSMutableArray, "array");
  v14 = +[NSMutableArray array](NSMutableArray, "array");
  v15 = +[NSMutableArray array](NSMutableArray, "array");
  v16 = +[NSMutableArray array](NSMutableArray, "array");
  v17 = +[NSMutableArray array](NSMutableArray, "array");
  v18 = 0;
  v24 = v11;
  do
  {
    objc_msgSend(v10, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *v11), v18);
    objc_msgSend(v12, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[30]), v18);
    objc_msgSend(v13, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[60]), v18);
    objc_msgSend(v14, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[90]), v18);
    objc_msgSend(v15, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[120]), v18);
    objc_msgSend(v16, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[150]), v18);
    objc_msgSend(v17, "insertObject:atIndex:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v11[180]), v18++);
    ++v11;
  }
  while (v18 != 30);
  if (v22)
    v19 = 7;
  else
    v19 = 6;
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyRSSI, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v10), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyTxPER, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v12), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyTxFrameCount, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v13), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyFwTxPER, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v14), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyFwTxFrameCount, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v15), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyBeaconsSched, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v16), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyBeaconsPer, +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v17), v19);
  objc_msgSend(v25, "addFieldForKey:value:options:", kWAMessageKeyGatewayARPHistory, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v24[210]), v19);
  objc_autoreleasePoolPop(context);
  if (!a4)
  {
    v20 = v24;
LABEL_14:
    free(v20);
  }
}

void sub_100063F78(uint64_t a1)
{
  id v1;
  void *v2;

  v1 = objc_alloc_init(*(Class *)(a1 + 32));
  v2 = (void *)qword_10026D5F0;
  qword_10026D5F0 = (uint64_t)v1;

}

id sub_100064034(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_updateDNDStatus");
}

void sub_100064274(id *a1)
{
  sub_10009060C((uint64_t)objc_msgSend(a1[4], "manager"), a1[5], a1[6], a1[7], 1);
}

void sub_100064368(uint64_t a1)
{
  sub_10009060C((uint64_t)objc_msgSend(*(id *)(a1 + 32), "manager"), 0, 0, 0, 0);
}

void sub_100064444(uint64_t a1)
{
  void *v2;
  _QWORD v3[5];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "dndStatus"));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000644B8;
  v3[3] = &unk_10022F4F8;
  v3[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend(v2, "fetchAutomaticDNDAssertionWithReply:", v3);

}

void sub_1000644B8(uint64_t a1, uint64_t a2, void *a3)
{
  void *v5;
  void *v6;
  id v7;

  v7 = a3;
  objc_msgSend(*(id *)(a1 + 32), "setCarDNDActive:", a2);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updated DND status: %i", "-[WiFiManagerCarSessionMonitor _updateDNDStatus]_block_invoke_2", a2);
  objc_autoreleasePoolPop(v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"));
  objc_msgSend(v6, "setCarModeActive:", objc_msgSend(*(id *)(a1 + 32), "isCarDNDActive"));

}

uint64_t sub_1000645FC(uint64_t result)
{
  qword_10026D600 = result;
  return result;
}

__CFArray *sub_100064608(const __CFArray *a1)
{
  return sub_10001785C(a1, 0, 0);
}

__CFArray *sub_100064614(const __CFArray *a1)
{
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v7;

  if (!a1)
    return 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v4 = Count;
      for (i = 0; i != v4; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
        if (ValueAtIndex)
        {
          v7 = ValueAtIndex;
          if (sub_100007F24((uint64_t)ValueAtIndex))
            CFArrayAppendValue(Mutable, v7);
        }
      }
    }
    if (!CFArrayGetCount(Mutable))
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

CFMutableArrayRef sub_1000646D0(const __CFDictionary *a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100064728, Mutable);
  return Mutable;
}

void sub_100064728(int a1, const void *a2, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, a2);
}

CFMutableArrayRef sub_100064730(const __CFSet *a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
    CFSetApplyFunction(a1, (CFSetApplierFunction)sub_100064788, Mutable);
  return Mutable;
}

void sub_100064788(void *value, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, value);
}

CFMutableSetRef sub_100064798(const __CFArray *a1)
{
  CFMutableSetRef Mutable;
  CFRange v4;

  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  if (Mutable)
  {
    v4.length = CFArrayGetCount(a1);
    v4.location = 0;
    CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)sub_100064800, Mutable);
  }
  return Mutable;
}

void sub_100064800(void *value, CFMutableSetRef theSet)
{
  CFSetAddValue(theSet, value);
}

float sub_100064810(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float result;

  result = (float)(a1 - a2) / (float)(a3 - a2);
  if (result > 1.0)
    result = 1.0;
  if (result < 0.0)
    return 0.0;
  return result;
}

void sub_100064840(__CFDictionary *a1, const void *a2, double a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  double valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

BOOL sub_1000648AC(uint64_t a1, CFTypeRef cf)
{
  return cf && CFGetTypeID(cf) == a1;
}

uint64_t sub_1000648E4()
{
  return _SC_CFMachPortCreateWithPort("WiFiManager/base");
}

const char *sub_1000648F0(unsigned int a1)
{
  if (a1 > 4)
    return "UNKNOWN";
  else
    return off_10022F518[a1];
}

double sub_100064914()
{
  timeval v1;

  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v1.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v1, 0);
  return (double)v1.tv_usec + (double)v1.tv_sec * 1000000.0;
}

uint64_t sub_10006495C(unsigned __int16 *a1)
{
  uint64_t v1;

  v1 = 0;
  while (*(unsigned __int16 *)&algn_1001BB323[v1] != *a1 || algn_1001BB323[v1 + 2] != *((_BYTE *)a1 + 2))
  {
    v1 += 3;
    if (v1 == 33)
      return 0;
  }
  return 1;
}

NSDate *sub_1000649A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  id v9;
  NSDateComponents *v10;
  NSDate *v11;
  NSDate *v12;
  NSDate *v13;

  v8 = objc_autoreleasePoolPush();
  v9 = objc_alloc_init((Class)NSAutoreleasePool);
  v10 = objc_opt_new(NSDateComponents);
  -[NSDateComponents setHour:](v10, "setHour:", a2);
  -[NSDateComponents setMinute:](v10, "setMinute:", a3);
  -[NSDateComponents setSecond:](v10, "setSecond:", a4);
  v11 = -[NSCalendar nextDateAfterDate:matchingComponents:options:](+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"), "nextDateAfterDate:matchingComponents:options:", a1, v10, 1024);
  v12 = v11;
  if (v11)
    v13 = v11;

  objc_msgSend(v9, "drain");
  objc_autoreleasePoolPop(v8);
  return v12;
}

void *sub_100064A6C(void *a1, unint64_t a2, unint64_t a3)
{
  if (is_mul_ok(a2, a3))
    return malloc_type_realloc(a1, a2 * a3, 0x939E6BCFuLL);
  *__error() = 12;
  return 0;
}

const __CFString *sub_100064AA8(int a1)
{
  const __CFString *result;
  int v2;

  switch(a1)
  {
    case 1000:
      result = CFSTR("Trigger Disconnect");
      break;
    case 1001:
      result = CFSTR("Client Disconnect");
      break;
    case 1002:
      result = CFSTR("Temporarily Disabled");
      break;
    case 1003:
      result = CFSTR("Network Changed");
      break;
    case 1004:
      result = CFSTR("Decryption Failure");
      break;
    case 1005:
      result = CFSTR("Not Primary Interface");
      break;
    case 1006:
      result = CFSTR("CLTM");
      break;
    case 1007:
      result = CFSTR("Internet Sharing");
      break;
    case 1008:
      result = CFSTR("User Preference");
      break;
    case 1009:
      result = CFSTR("Misc.");
      break;
    case 1010:
      result = CFSTR("EAP Restart");
      break;
    case 1011:
      result = CFSTR("Control Center/3rd Party Client");
      break;
    case 1012:
      result = CFSTR("802.1X Failure");
      break;
    case 1013:
      result = CFSTR("Network Transition");
      break;
    case 1014:
      result = CFSTR("Auto Unlock");
      break;
    case 1015:
      result = CFSTR("Captive");
      break;
    case 1016:
      result = CFSTR("Banner Association");
      break;
    case 1017:
      result = CFSTR("BSS Steering");
      break;
    case 1018:
      result = CFSTR("Auto Hotspot Association");
      break;
    case 1019:
      result = CFSTR("Auto Hotspot Transition");
      break;
    case 1020:
      result = CFSTR("Perf Roam");
      break;
    case 1021:
      result = CFSTR("CarPlay Disabled");
      break;
    case 1022:
      result = CFSTR("Battery Save Mode Enabled");
      break;
    case 1023:
      result = CFSTR("AirPlay Started");
      break;
    case 1024:
      result = CFSTR("Prefer 6E Off");
      break;
    case 1025:
      result = CFSTR("Prefer 6E On");
      break;
    default:
      v2 = a1 - 1;
      result = CFSTR("Deauth");
      switch(v2)
      {
        case 0:
          return result;
        case 1:
          result = CFSTR("Beacon Lost");
          break;
        case 2:
          result = CFSTR("Internal Error");
          break;
        case 3:
          result = CFSTR("System Sleep");
          break;
        case 4:
          result = CFSTR("Powered Off");
          break;
        case 5:
          result = CFSTR("Join Failure");
          break;
        case 6:
          result = CFSTR("Colocated scope transition");
          break;
        case 7:
          result = CFSTR("Disassociate");
          break;
        case 8:
          result = CFSTR("Invalid SSID");
          break;
        default:
          result = CFSTR("Unknown");
          break;
      }
      break;
  }
  return result;
}

const __CFString *sub_100064C9C(unsigned int a1)
{
  const __CFString *v1;

  if (a1 < 9 && ((0x117u >> a1) & 1) != 0)
    return off_10022F540[a1];
  v1 = CFSTR("Unknown");
  if ((~a1 & 3) == 0)
    v1 = CFSTR("STA + AWDL");
  if ((~a1 & 5) == 0)
    v1 = CFSTR("STA + SoftAP");
  if ((~a1 & 6) == 0)
    v1 = CFSTR("AWDL + SoftAP");
  if ((~a1 & 7) == 0)
    v1 = CFSTR("STA + AWDL + SoftAP");
  if ((~a1 & 0xC) == 0)
    v1 = CFSTR("SoftAp + NanPh");
  if ((~a1 & 0xE) != 0)
    return v1;
  else
    return CFSTR("AWDL + SoftAp + NanPh");
}

const __CFString *sub_100064D44(unsigned int a1)
{
  if (a1 > 3)
    return CFSTR("Unknown");
  else
    return off_10022F5C0[a1];
}

const __CFString *sub_100064D68(int a1)
{
  const __CFString *v1;

  v1 = CFSTR("Unknown");
  if (a1 == 2)
    v1 = CFSTR("Not Home");
  if (a1 == 1)
    return CFSTR("Home");
  else
    return v1;
}

const __CFString *sub_100064D94(int a1)
{
  const __CFString *v1;

  v1 = CFSTR("Unknown");
  if (a1 == 2)
    v1 = CFSTR("Not Work");
  if (a1 == 1)
    return CFSTR("Work");
  else
    return v1;
}

const __CFString *sub_100064DC0(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_10022F5E0[a1];
}

const __CFString *sub_100064DE4(int a1)
{
  if ((a1 - 1) > 4)
    return CFSTR("Unknown");
  else
    return off_10022F5F8[a1 - 1];
}

const __CFString *sub_100064E0C(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_10022F620[a1];
}

const __CFString *sub_100064E30(int a1)
{
  const __CFString *v1;

  v1 = CFSTR("Unknown");
  if (a1 == 2)
    v1 = CFSTR("Captive");
  if (a1 == 1)
    return CFSTR("Control Center");
  else
    return v1;
}

const __CFString *sub_100064E5C(unsigned int a1)
{
  if (a1 > 0xD)
    return CFSTR("Unknown");
  else
    return off_10022F638[a1];
}

const __CFString *sub_100064E80(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_10022F6A8[a1];
}

BOOL sub_100064EA4()
{
  size_t v1;
  char __big[16];
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v4 = 0u;
  v5 = 0u;
  *(_OWORD *)__big = 0u;
  v3 = 0u;
  v1 = 255;
  sysctlbyname("kern.wakereason", __big, &v1, 0, 0);
  if (!__big[0])
    return 0;
  if (strcasestr(__big, "wlan"))
    return 1;
  return strcasestr(__big, "wifibt") != 0;
}

const __CFNumber *sub_100064F80(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID TypeID;
  unsigned int valuePtr;

  if (result)
  {
    v1 = result;
    valuePtr = 0;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef sub_100064FE0(int a1)
{
  int valuePtr;

  valuePtr = a1;
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
}

void sub_100065014(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

uint64_t sub_100065040()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_10022F6C0);
  qword_10026D608 = result;
  return result;
}

uint64_t sub_100065064(uint64_t result, int a2)
{
  *(_DWORD *)(result + 136) = a2;
  return result;
}

void sub_10006506C(uint64_t a1, uint64_t a2)
{
  sub_100006544(a2);
}

uint64_t sub_100065074(uint64_t a1)
{
  return sub_100031C0C(*(_QWORD *)(a1 + 88));
}

uint64_t sub_10006507C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

void sub_100065084(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *v3;

  v3 = *(__CFDictionary **)(a1 + 112);
  if (v3)
    CFDictionaryAddValue(v3, a2, a3);
}

void sub_100065094(uint64_t a1, const void *a2)
{
  __CFDictionary *v2;

  v2 = *(__CFDictionary **)(a1 + 112);
  if (v2)
    CFDictionaryRemoveValue(v2, a2);
}

void sub_1000650A4(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), a2, a3);
}

void sub_1000650AC(uint64_t a1, const void *a2)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 104), a2);
}

uint64_t sub_1000650B4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 176);
}

uint64_t sub_1000650BC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

void sub_1000650C4(uint64_t a1, const __CFArray *a2)
{
  __CFArray *v4;
  CFRange v5;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 160)))
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 160));
  if (a2)
  {
    if (CFArrayGetCount(a2))
    {
      v4 = *(__CFArray **)(a1 + 160);
      v5.length = CFArrayGetCount(a2);
      v5.location = 0;
      CFArrayAppendArray(v4, a2, v5);
    }
  }
}

void sub_100065130(uint64_t a1, const __CFArray *a2)
{
  __CFArray *v4;
  CFRange v5;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 168)))
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 168));
  if (a2)
  {
    if (CFArrayGetCount(a2))
    {
      v4 = *(__CFArray **)(a1 + 168);
      v5.length = CFArrayGetCount(a2);
      v5.location = 0;
      CFArrayAppendArray(v4, a2, v5);
    }
  }
}

uint64_t sub_10006519C(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  const __CFData *v8;
  const __CFData *v9;
  uint64_t v10;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  const __CFData *v13;
  const __CFData *v14;
  const UInt8 *v15;
  int v16;
  const void *v17;
  const __CFData *v18;
  const __CFData *v19;
  const UInt8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  int Length;
  const UInt8 *BytePtr;

  if ((*(_BYTE *)(a1 + 128) & 0x20) == 0)
    return 4294963393;
  if (!a2)
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null notification.", "WiFiClientDispatchNotification");
    goto LABEL_33;
  }
  if (!sub_1000D720C(a2))
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device manager.", "WiFiClientDispatchNotification");
LABEL_33:
    objc_autoreleasePoolPop(v25);
    return 4294963396;
  }
  v5 = sub_1000D720C(a2);
  v6 = sub_1000161D4(v5);
  v7 = (const void *)sub_100029860(v6);
  if (!v7)
  {
    v9 = 0;
    goto LABEL_9;
  }
  v8 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v7);
  v9 = v8;
  if (!v8)
  {
LABEL_9:
    Length = 0;
    BytePtr = 0;
    goto LABEL_10;
  }
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v9);
LABEL_10:
  v10 = sub_1000C053C(a2);
  if (v10 && (v11 = sub_1000173C0(v10)) != 0)
  {
    v12 = v11;
    v13 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v11);
    v14 = v13;
    if (v13)
    {
      v15 = CFDataGetBytePtr(v13);
      v16 = CFDataGetLength(v14);
    }
    else
    {
      v15 = 0;
      v16 = 0;
    }
    CFRelease(v12);
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
  }
  v17 = (const void *)sub_100029860(a2);
  if (!v17)
  {
    v19 = 0;
    goto LABEL_21;
  }
  v18 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v17);
  v19 = v18;
  if (!v18)
  {
LABEL_21:
    v20 = 0;
    v21 = 0;
    goto LABEL_22;
  }
  v20 = CFDataGetBytePtr(v18);
  v21 = CFDataGetLength(v19);
LABEL_22:
  v22 = *(_DWORD *)(a1 + 96);
  v23 = sub_1000D7204(a2);
  v24 = sub_1000D71EC(a2);
  sub_10017E9E4(v22, (vm_address_t)BytePtr, Length, v23, v24, (uint64_t)v15, v16, (uint64_t)v20, v21, 0);
  if (v19)
    CFRelease(v19);
  if (v14)
    CFRelease(v14);
  if (v9)
    CFRelease(v9);
  return 0;
}

uint64_t sub_1000653E0(uint64_t a1, int a2)
{
  return sub_10017EE28(*(_DWORD *)(a1 + 96), a2, 0);
}

void sub_1000653EC(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *value, const __CFData *a5, int a6)
{
  const __CFData *v8;
  __CFDictionary *v11;
  const __CFData *v12;
  const UInt8 *BytePtr;
  int v14;
  CFDictionaryRef v15;
  CFDictionaryRef v16;
  const __CFData *v17;
  const UInt8 *v18;
  int v19;
  const __CFData *v20;
  const UInt8 *v21;
  int v22;
  int Length;

  v8 = value;
  v11 = *(__CFDictionary **)(a1 + 104);
  if (value && a6 == -369033213)
    CFDictionarySetValue(v11, a2, value);
  else
    CFDictionaryRemoveValue(v11, a2);
  if (a3 && (v12 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a3), (a3 = v12) != 0))
  {
    BytePtr = CFDataGetBytePtr(v12);
    Length = CFDataGetLength(a3);
    if (!v8)
    {
LABEL_8:
      v14 = a6;
      goto LABEL_14;
    }
  }
  else
  {
    BytePtr = 0;
    Length = 0;
    if (!v8)
      goto LABEL_8;
  }
  v15 = sub_1000173C0((uint64_t)v8);
  if (!v15)
  {
    v14 = a6;
    v8 = 0;
LABEL_14:
    v18 = 0;
    v19 = 0;
    if (!a5)
      goto LABEL_20;
    goto LABEL_18;
  }
  v16 = v15;
  v14 = a6;
  v17 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v15);
  v8 = v17;
  if (v17)
  {
    v18 = CFDataGetBytePtr(v17);
    v19 = CFDataGetLength(v8);
  }
  else
  {
    v18 = 0;
    v19 = 0;
  }
  CFRelease(v16);
  if (!a5)
    goto LABEL_20;
LABEL_18:
  v20 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a5);
  a5 = v20;
  if (v20)
  {
    v21 = CFDataGetBytePtr(v20);
    v22 = CFDataGetLength(a5);
    goto LABEL_21;
  }
LABEL_20:
  v21 = 0;
  v22 = 0;
LABEL_21:
  sub_10017EB00(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, (uint64_t)v18, v19, (uint64_t)v21, v22, v14, 0);
  if (v8)
    CFRelease(v8);
  if (a5)
    CFRelease(a5);
  if (a3)
    CFRelease(a3);
}

void sub_1000655D0(uint64_t a1, uint64_t a2, const void *a3, int a4, uint64_t a5, const __CFData *a6)
{
  CFTypeRef v10;
  const void *v11;
  CFDictionaryRef v12;
  CFDictionaryRef v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *BytePtr;
  const __CFData *v17;
  int v18;
  const UInt8 *v19;
  int Length;
  int v21;
  const UInt8 *v22;
  int v23;
  const __CFDictionary *v24;

  if (a3)
  {
    v10 = sub_100029868(kCFAllocatorDefault, a3);
    if (v10)
    {
      v11 = v10;
      if (a5)
      {
        v12 = sub_1000173C0(a5);
        if (!v12)
        {
LABEL_18:
          CFRelease(v11);
          return;
        }
        v13 = v12;
        v14 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v12);
        if (!v14)
        {
LABEL_17:
          CFRelease(v13);
          goto LABEL_18;
        }
        v15 = v14;
        BytePtr = CFDataGetBytePtr(v14);
        LODWORD(a5) = CFDataGetLength(v15);
      }
      else
      {
        v13 = 0;
        v15 = 0;
        BytePtr = 0;
      }
      v24 = v13;
      if (a6)
      {
        v17 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a6);
        if (!v17)
          goto LABEL_14;
        a6 = v17;
        v18 = a4;
        v19 = CFDataGetBytePtr(v17);
        Length = CFDataGetLength(a6);
      }
      else
      {
        v18 = a4;
        v19 = 0;
        Length = 0;
      }
      v21 = *(_DWORD *)(a1 + 96);
      v22 = CFDataGetBytePtr((CFDataRef)v11);
      v23 = CFDataGetLength((CFDataRef)v11);
      sub_10017EC18(v21, (vm_address_t)v22, v23, v18, (uint64_t)BytePtr, a5, (uint64_t)v19, Length, 0);
      v13 = v24;
      if (a6)
        CFRelease(a6);
LABEL_14:
      if (v15)
        CFRelease(v15);
      if (!v13)
        goto LABEL_18;
      goto LABEL_17;
    }
  }
}

void sub_100065760(uint64_t a1, uint64_t a2, const void *a3, int a4, const __CFData *a5)
{
  CFTypeRef v8;
  const void *v9;
  const __CFData *v10;
  const UInt8 *BytePtr;
  int Length;
  int v13;
  const UInt8 *v14;
  int v15;

  if (a3)
  {
    v8 = sub_100029868(kCFAllocatorDefault, a3);
    if (v8)
    {
      v9 = v8;
      if (a5)
      {
        v10 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a5);
        if (!v10)
        {
LABEL_9:
          CFRelease(v9);
          return;
        }
        a5 = v10;
        BytePtr = CFDataGetBytePtr(v10);
        Length = CFDataGetLength(a5);
      }
      else
      {
        BytePtr = 0;
        Length = 0;
      }
      v13 = *(_DWORD *)(a1 + 96);
      v14 = CFDataGetBytePtr((CFDataRef)v9);
      v15 = CFDataGetLength((CFDataRef)v9);
      sub_10017ED30(v13, (vm_address_t)v14, v15, a4, (uint64_t)BytePtr, Length, 0);
      if (a5)
        CFRelease(a5);
      goto LABEL_9;
    }
  }
}

void sub_100065858(uint64_t a1, uint64_t a2, const void *a3, const __CFArray *a4, int a5)
{
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int Length;
  __CFArray *v12;
  __CFArray *v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *v16;
  int v17;

  if (!a3)
  {
    v9 = 0;
LABEL_6:
    BytePtr = 0;
    Length = 0;
    if (!a4)
      goto LABEL_12;
    goto LABEL_7;
  }
  v8 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a3);
  v9 = v8;
  if (!v8)
    goto LABEL_6;
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v9);
  if (!a4)
  {
LABEL_12:
    sub_10017EEB4(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 0, 0, a5, 0);
    if (v9)
      goto LABEL_13;
    return;
  }
LABEL_7:
  v12 = sub_1000173D8(a4);
  if (!v12)
    goto LABEL_12;
  v13 = v12;
  v14 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v12);
  if (!v14)
  {
    CFRelease(v13);
    goto LABEL_12;
  }
  v15 = v14;
  v16 = CFDataGetBytePtr(v14);
  v17 = CFDataGetLength(v15);
  CFRelease(v13);
  sub_10017EEB4(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, (uint64_t)v16, v17, a5, 0);
  CFRelease(v15);
  if (v9)
LABEL_13:
    CFRelease(v9);
}

void sub_1000659A4(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  __CFArray *v7;
  void *v8;
  void *v9;
  const char *v10;

  v4 = *(const __CFArray **)(a1 + 80);
  if (!v4)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v10 = "Error gettitng manager";
LABEL_11:
      objc_msgSend(v9, "WFLog:message:", 4, v10);
    }
LABEL_12:
    objc_autoreleasePoolPop(v8);
    goto LABEL_6;
  }
  v5 = sub_10000B29C(v4);
  if (!v5)
  {
    v8 = objc_autoreleasePoolPush();
    v9 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v10 = "Error copying devices";
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  v6 = v5;
  v7 = sub_10000BF9C(a1, v5);
  if (v7)
    CFRelease(v7);
  CFRelease(v6);
LABEL_6:
  sub_1000292C4(a1, a2, 2u, 0);
}

void sub_100065A64(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  __CFArray *v6;
  void *v7;
  void *v8;
  const char *v9;

  sub_1000292C4(a1, a2, 3u, 0);
  v3 = *(const __CFArray **)(a1 + 80);
  if (!v3)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v9 = "Error gettitng manager";
LABEL_10:
      objc_msgSend(v8, "WFLog:message:", 4, v9);
    }
LABEL_11:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v4 = sub_10000B29C(v3);
  if (!v4)
  {
    v7 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v9 = "Error copying devices";
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  v5 = v4;
  v6 = sub_10000BF9C(a1, v4);
  if (v6)
    CFRelease(v6);
  CFRelease(v5);
}

void sub_100065B14(uint64_t a1, uint64_t a2, const void *a3)
{
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  __CFArray *v9;
  void *v10;
  void *v11;
  const char *v12;

  v6 = *(const __CFArray **)(a1 + 80);
  if (!v6)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v12 = "Error getting manager";
LABEL_11:
      objc_msgSend(v11, "WFLog:message:", 4, v12);
    }
LABEL_12:
    objc_autoreleasePoolPop(v10);
    goto LABEL_6;
  }
  v7 = sub_10000B29C(v6);
  if (!v7)
  {
    v10 = objc_autoreleasePoolPush();
    v11 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v12 = "Error copying devices";
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  v8 = v7;
  v9 = sub_10000BF9C(a1, v7);
  if (v9)
    CFRelease(v9);
  CFRelease(v8);
LABEL_6:
  sub_1000292C4(a1, a2, 0x11u, a3);
}

void sub_100065BD8(uint64_t a1, uint64_t a2, const void *a3)
{
  unsigned int v6;
  const __CFArray *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  __CFArray *v10;
  void *v11;
  void *v12;
  const char *v13;

  if (sub_1000F6FF8(a2))
    v6 = 44;
  else
    v6 = 18;
  sub_1000292C4(a1, a2, v6, a3);
  v7 = *(const __CFArray **)(a1 + 80);
  if (!v7)
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v13 = "Error getting manager";
LABEL_13:
      objc_msgSend(v12, "WFLog:message:", 4, v13);
    }
LABEL_14:
    objc_autoreleasePoolPop(v11);
    return;
  }
  v8 = sub_10000B29C(v7);
  if (!v8)
  {
    v11 = objc_autoreleasePoolPush();
    v12 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v13 = "Error copying devices";
      goto LABEL_13;
    }
    goto LABEL_14;
  }
  v9 = v8;
  v10 = sub_10000BF9C(a1, v8);
  if (v10)
    CFRelease(v10);
  CFRelease(v9);
}

void sub_100065CB8(uint64_t a1, uint64_t a2, const void *a3, const void *a4, int a5)
{
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int Length;
  const __CFData *v12;
  const __CFData *v13;
  const UInt8 *v14;
  int v15;

  if (!a3)
  {
    v9 = 0;
LABEL_6:
    BytePtr = 0;
    Length = 0;
    if (!a4)
      goto LABEL_10;
    goto LABEL_7;
  }
  v8 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a3);
  v9 = v8;
  if (!v8)
    goto LABEL_6;
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v9);
  if (!a4)
  {
LABEL_10:
    sub_10017EFAC(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 0, 0, a5, 0);
    if (v9)
      goto LABEL_11;
    return;
  }
LABEL_7:
  v12 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
  if (!v12)
    goto LABEL_10;
  v13 = v12;
  v14 = CFDataGetBytePtr(v12);
  v15 = CFDataGetLength(v13);
  sub_10017EFAC(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, (uint64_t)v14, v15, a5, 0);
  CFRelease(v13);
  if (v9)
LABEL_11:
    CFRelease(v9);
}

void sub_100065DD4(uint64_t a1, uint64_t a2, void *key, const void *a4)
{
  const __CFDictionary *v6;
  const __CFNumber *Value;
  const __CFData *v9;
  const __CFData *v10;
  const UInt8 *BytePtr;
  int Length;
  void *v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *v16;
  int v17;
  void *v18;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1 && a2 && key)
  {
    v6 = *(const __CFDictionary **)(a1 + 120);
    if (v6)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v6, key);
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        if ((valuePtr & 0x1000000) != 0)
        {
          if ((*(_BYTE *)(a1 + 52) & 0x10) == 0)
          {
            v9 = (const __CFData *)sub_100029868(kCFAllocatorDefault, key);
            v10 = v9;
            if (v9)
            {
              BytePtr = CFDataGetBytePtr(v9);
              Length = CFDataGetLength(v10);
              if (!a4)
                goto LABEL_18;
            }
            else
            {
              BytePtr = 0;
              Length = 0;
              if (!a4)
                goto LABEL_18;
            }
            v14 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
            if (v14)
            {
              v15 = v14;
              v16 = CFDataGetBytePtr(v14);
              v17 = CFDataGetLength(v15);
              sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 24, (uint64_t)v16, v17, 0);
              CFRelease(v15);
              if (!v10)
                return;
LABEL_19:
              CFRelease(v10);
              return;
            }
LABEL_18:
            sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 24, 0, 0, 0);
            if (!v10)
              return;
            goto LABEL_19;
          }
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Already ranging, will not dispatch report.");
          objc_autoreleasePoolPop(v13);
        }
      }
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null deviceEventMasks", "WiFiClientDispatchRangingReportEvent", valuePtr);
      objc_autoreleasePoolPop(v18);
    }
  }
}

void sub_100065FA0(uint64_t a1, uint64_t a2, void *key, const void *a4)
{
  const __CFDictionary *v6;
  const __CFNumber *Value;
  const __CFData *v9;
  const __CFData *v10;
  const UInt8 *BytePtr;
  int Length;
  const __CFData *v13;
  const __CFData *v14;
  const UInt8 *v15;
  int v16;
  void *v17;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1 && a2 && key)
  {
    v6 = *(const __CFDictionary **)(a1 + 120);
    if (v6)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v6, key);
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        if ((valuePtr & 0x400000000000) != 0)
        {
          v9 = (const __CFData *)sub_100029868(kCFAllocatorDefault, key);
          v10 = v9;
          if (v9)
          {
            BytePtr = CFDataGetBytePtr(v9);
            Length = CFDataGetLength(v10);
            if (!a4)
              goto LABEL_14;
          }
          else
          {
            BytePtr = 0;
            Length = 0;
            if (!a4)
              goto LABEL_14;
          }
          v13 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
          if (v13)
          {
            v14 = v13;
            v15 = CFDataGetBytePtr(v13);
            v16 = CFDataGetLength(v14);
            sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 46, (uint64_t)v15, v16, 0);
            CFRelease(v14);
            if (!v10)
              return;
LABEL_15:
            CFRelease(v10);
            return;
          }
LABEL_14:
          sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 46, 0, 0, 0);
          if (!v10)
            return;
          goto LABEL_15;
        }
      }
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null deviceEventMasks", "WiFiClientDispatchTdConfirmedEvent", valuePtr);
      objc_autoreleasePoolPop(v17);
    }
  }
}

void sub_100066130(uint64_t a1, uint64_t a2, void *key, const void *a4)
{
  const __CFDictionary *v6;
  const __CFNumber *Value;
  const __CFData *v9;
  const __CFData *v10;
  const UInt8 *BytePtr;
  int Length;
  const __CFData *v13;
  const __CFData *v14;
  const UInt8 *v15;
  int v16;
  void *v17;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1 && a2 && key)
  {
    v6 = *(const __CFDictionary **)(a1 + 120);
    if (v6)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v6, key);
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        if ((valuePtr & 0x400000) != 0)
        {
          v9 = (const __CFData *)sub_100029868(kCFAllocatorDefault, key);
          v10 = v9;
          if (v9)
          {
            BytePtr = CFDataGetBytePtr(v9);
            Length = CFDataGetLength(v10);
            if (!a4)
              goto LABEL_14;
          }
          else
          {
            BytePtr = 0;
            Length = 0;
            if (!a4)
              goto LABEL_14;
          }
          v13 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a4);
          if (v13)
          {
            v14 = v13;
            v15 = CFDataGetBytePtr(v13);
            v16 = CFDataGetLength(v14);
            sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 22, (uint64_t)v15, v16, 0);
            CFRelease(v14);
            if (!v10)
              return;
LABEL_15:
            CFRelease(v10);
            return;
          }
LABEL_14:
          sub_10002996C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 22, 0, 0, 0);
          if (!v10)
            return;
          goto LABEL_15;
        }
      }
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null deviceEventMasks", "WiFiClientDispatchVirtInterfaceStateChangeEvent", valuePtr);
      objc_autoreleasePoolPop(v17);
    }
  }
}

void sub_1000662C0(uint64_t a1, uint64_t a2)
{
  sub_1000292C4(a1, a2, 0, 0);
}

void sub_1000662CC(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 1u, a3);
}

void sub_1000662D8(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x17u, a3);
}

void sub_1000662E4(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x22u, a3);
}

void sub_1000662F0(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x13u, a3);
}

void sub_1000662FC(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0xAu, a3);
}

void sub_100066308(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 9u, a3);
}

void sub_100066314(uint64_t a1, uint64_t a2)
{
  sub_1000292C4(a1, a2, 0xBu, 0);
}

void sub_100066320(uint64_t a1, int a2, uint64_t a3)
{
  CFNumberRef v5;
  _BOOL8 valuePtr;

  valuePtr = a2 != 0;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  sub_1000292C4(a1, a3, 0xCu, v5);
  if (v5)
    CFRelease(v5);
}

void sub_100066398(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x2Au, a3);
}

void sub_1000663A4(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x2Bu, a3);
}

void sub_1000663B0(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x2Du, a3);
}

void sub_1000663BC(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x23u, a3);
}

void sub_1000663C8(uint64_t a1, uint64_t a2, int a3)
{
  const void **v3;

  v3 = (const void **)&kCFBooleanTrue;
  if (!a3)
    v3 = (const void **)&kCFBooleanFalse;
  sub_1000292C4(a1, a2, 0x26u, *v3);
}

void sub_1000663EC(uint64_t a1, uint64_t a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  void *v7;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    sub_1000292C4(a1, a2, 0x27u, v5);
    CFRelease(v6);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Could not allocate M1M4Handshake24GHzCountRef", "WiFiClientDispatchM1M4Handshake24GHzCountEvent");
    objc_autoreleasePoolPop(v7);
  }
}

void sub_10006649C(uint64_t a1, uint64_t a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  void *v7;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    sub_1000292C4(a1, a2, 0x25u, v5);
    CFRelease(v6);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Could not allocate numRef", "WiFiClientDispatchCarPlayNetworkTypeChangeEvent");
    objc_autoreleasePoolPop(v7);
  }
}

void sub_10006654C(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0xFu, a3);
}

void sub_100066558(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x14u, a3);
}

void sub_100066564(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int Length;

  if (a3)
  {
    v6 = sub_1000173C0(a3);
    if (v6)
    {
      v7 = v6;
      v8 = (const __CFData *)sub_100029868(kCFAllocatorDefault, v6);
      if (v8)
      {
        v9 = v8;
        BytePtr = CFDataGetBytePtr(v8);
        Length = CFDataGetLength(v9);
        sub_10017F0A4(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, a4, 0);
        CFRelease(v9);
      }
      CFRelease(v7);
    }
  }
}

void sub_10006660C(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x15u, a3);
}

void sub_100066618(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x19u, a3);
}

const __CFString *sub_100066624(const __CFString *result)
{
  if (result)
  {
    result = (const __CFString *)result[2].isa;
    if (result)
      return (const __CFString *)(CFStringCompare(result, CFSTR("SpringBoard"), 0) == kCFCompareEqualTo);
  }
  return result;
}

const __CFString *sub_100066658(const __CFString *result)
{
  if (result)
  {
    result = (const __CFString *)result[2].isa;
    if (result)
      return (const __CFString *)(CFStringCompare(result, CFSTR("Preferences"), 1uLL) == kCFCompareEqualTo);
  }
  return result;
}

const __CFString *sub_10006668C(const __CFString *result)
{
  if (result)
  {
    result = (const __CFString *)result[2].isa;
    if (result)
      return (const __CFString *)(CFStringCompare(result, CFSTR("mobilewifitool"), 1uLL) == kCFCompareEqualTo);
  }
  return result;
}

const __CFString *sub_1000666C0(const __CFString *result)
{
  if (result)
  {
    result = (const __CFString *)result[2].isa;
    if (result)
      return (const __CFString *)(CFStringCompare(result, CFSTR("sharingd"), 1uLL) == kCFCompareEqualTo);
  }
  return result;
}

const __CFString *sub_1000666F4(const __CFString *result)
{
  if (result)
  {
    result = (const __CFString *)result[2].isa;
    if (result)
      return (const __CFString *)(CFStringCompare(result, CFSTR("PersonalHotspotControlExtension"), 1uLL) == kCFCompareEqualTo);
  }
  return result;
}

void sub_100066728(uint64_t a1, int a2, const void *a3)
{
  const __CFData *v5;
  const __CFData *v6;
  const UInt8 *BytePtr;
  int Length;

  if ((*(_BYTE *)(a1 + 131) & 4) != 0)
  {
    if (a3)
    {
      v5 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a3);
      v6 = v5;
      if (v5)
      {
        BytePtr = CFDataGetBytePtr(v5);
        Length = CFDataGetLength(v6);
      }
      else
      {
        BytePtr = 0;
        Length = 0;
      }
    }
    else
    {
      BytePtr = 0;
      Length = 0;
      v6 = 0;
    }
    sub_10017F170(*(_DWORD *)(a1 + 96), a2, (vm_address_t)BytePtr, Length, 0);
    if (v6)
      CFRelease(v6);
  }
}

uint64_t sub_1000667D8(uint64_t a1, int a2)
{
  return sub_10017F308(*(_DWORD *)(a1 + 96), a2, 0);
}

void sub_1000667E4(uint64_t a1, const void *a2)
{
  const __CFData *v3;
  const __CFData *v4;
  const UInt8 *BytePtr;
  int Length;

  if ((*(_BYTE *)(a1 + 131) & 0x20) != 0)
  {
    if (a2 && (v3 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a2)) != 0)
    {
      v4 = v3;
      BytePtr = CFDataGetBytePtr(v3);
      Length = CFDataGetLength(v4);
      sub_10017F23C(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 0);
      CFRelease(v4);
    }
    else
    {
      sub_10017F23C(*(_DWORD *)(a1 + 96), 0, 0, 0);
    }
  }
}

void sub_100066884(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x1Eu, a3);
}

void sub_100066890(uint64_t a1, const void *a2)
{
  const __CFData *v3;
  const __CFData *v4;
  const UInt8 *BytePtr;
  int Length;

  if ((*(_BYTE *)(a1 + 132) & 2) != 0)
  {
    v3 = (const __CFData *)sub_100029868(kCFAllocatorDefault, a2);
    if (v3)
    {
      v4 = v3;
      BytePtr = CFDataGetBytePtr(v3);
      Length = CFDataGetLength(v4);
      sub_10017F394(*(_DWORD *)(a1 + 96), (vm_address_t)BytePtr, Length, 0);
      CFRelease(v4);
    }
    else
    {
      sub_10017F394(*(_DWORD *)(a1 + 96), 0, 0, 0);
    }
  }
}

void sub_10006692C(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1000292C4(a1, a2, 0x29u, a3);
}

BOOL sub_100066938(uint64_t a1, const __CFString *a2)
{
  __int128 v3;
  __SecTask *v4;
  __SecTask *v5;
  __SecTask *v6;
  __SecTask *v7;
  CFTypeID TypeID;
  _BOOL8 v9;
  audit_token_t v11;
  CFErrorRef error;

  error = 0;
  v3 = *(_OWORD *)(a1 + 36);
  *(_OWORD *)v11.val = *(_OWORD *)(a1 + 20);
  *(_OWORD *)&v11.val[4] = v3;
  v4 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &v11);
  if (v4)
  {
    v5 = v4;
    v6 = (__SecTask *)SecTaskCopyValueForEntitlement(v4, a2, &error);
    if (v6)
    {
      v7 = v6;
      TypeID = CFBooleanGetTypeID();
      v9 = TypeID == CFGetTypeID(v7) && CFEqual(v7, kCFBooleanTrue) != 0;
      CFRelease(v5);
    }
    else
    {
      v9 = 0;
      v7 = v5;
    }
    CFRelease(v7);
  }
  else
  {
    v9 = 0;
  }
  if (error)
    CFRelease(error);
  return v9;
}

CFStringRef sub_100066A18(_QWORD *cf)
{
  uint64_t v2;

  if (!cf)
    return CFSTR("Invalid client ref");
  v2 = qword_10026D608;
  if (!qword_10026D608)
  {
    pthread_once(&stru_10026C998, (void (*)(void))sub_100065040);
    v2 = qword_10026D608;
  }
  if (v2 == CFGetTypeID(cf))
    return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@: pid=%d uuid=%@ type=%d"), cf[8], *((unsigned int *)cf + 14), cf[9], *((unsigned int *)cf + 4));
  else
    return CFSTR("Invalid client ref");
}

void sub_100066AB8(uint64_t a1)
{
  int v2;
  void *v3;
  vm_address_t v4;
  uint64_t v5;

  v2 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 180);
  v3 = objc_autoreleasePoolPush();
  if (v2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "link recovery from SSID transition did finish within %d seconds ", 4);
    objc_autoreleasePoolPop(v3);
    *(_WORD *)(*(_QWORD *)(a1 + 32) + 180) = 0;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "link recovery did not complete within %d seconds, dispatching link down event to SpringBoard", 4);
    objc_autoreleasePoolPop(v3);
    v5 = *(_QWORD *)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
    *(_BYTE *)(v5 + 181) = 0;
    sub_10002996C(*(_DWORD *)(v5 + 96), v4, *(_DWORD *)(a1 + 48), *(unsigned int *)(a1 + 72), *(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 64), 0);
  }
}

uint64_t sub_100066B88(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const void *Value;
  uint64_t v6;
  const void *v7;
  void *v8;
  NSString *v9;
  uint8_t buf[4];
  const char *v12;

  if (qword_10026D610)
  {
    CFRelease((CFTypeRef)qword_10026D610);
    qword_10026D610 = 0;
  }
  if (qword_10026D618)
  {
    CFRelease((CFTypeRef)qword_10026D618);
    qword_10026D618 = 0;
  }
  v2 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), (CFStringRef)qword_10026D620);
  v3 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), (CFStringRef)qword_10026D628);
  v4 = v3;
  if (!v2)
  {
    v6 = 0;
    qword_10026D610 = 0;
    if (v3)
      goto LABEL_10;
    goto LABEL_16;
  }
  Value = CFDictionaryGetValue(v2, kSCDynamicStorePropNetPrimaryInterface);
  qword_10026D610 = (uint64_t)Value;
  if (!Value)
  {
    v6 = 0;
    if (v4)
      goto LABEL_10;
LABEL_16:
    qword_10026D618 = 0;
    goto LABEL_17;
  }
  v6 = CFEqual(Value, *(CFTypeRef *)(a1 + 112)) != 0;
  CFRetain((CFTypeRef)qword_10026D610);
  if (!v4)
    goto LABEL_16;
LABEL_10:
  v7 = CFDictionaryGetValue(v4, kSCDynamicStorePropNetPrimaryInterface);
  qword_10026D618 = (uint64_t)v7;
  if (v7)
  {
    if (CFEqual(v7, *(CFTypeRef *)(a1 + 112)))
      v6 = 1;
    else
      v6 = v6;
    CFRetain((CFTypeRef)qword_10026D618);
  }
LABEL_17:
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IPv4 Primary interface is %@ and IPv6 Primary Interface is %@"), qword_10026D610, qword_10026D618)), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v8);
  if (v2)
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  return v6;
}

const void *sub_100066DD4(int a1, CFDictionaryRef theDict)
{
  if (theDict)
    return CFDictionaryGetValue(theDict, kSCDynamicStorePropNetPrimaryInterface);
  else
    return 0;
}

BOOL sub_100066DF8(uint64_t a1)
{
  BOOL v2;
  int v3;
  void *v4;
  const char *v5;
  _BYTE *v6;
  void *v7;

  if (*(_DWORD *)(a1 + 4296))
    v2 = (unsigned __int16)*(_DWORD *)(a1 + 4296) == 65193;
  else
    v2 = 1;
  v3 = v2;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (v3)
      v5 = "%s: interface is IPv4 not routable";
    else
      v5 = "%s: interface is IPv4 routable";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v5, "WiFiDeviceIsInterfaceRoutable");
  }
  objc_autoreleasePoolPop(v4);
  v6 = (_BYTE *)(a1 + 4300);
  if (*(_BYTE *)(a1 + 4300))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: interface is IPv6 routable", "WiFiDeviceIsInterfaceRoutable");
    objc_autoreleasePoolPop(v7);
  }
  return !v3 || *v6 != 0;
}

BOOL sub_100066EE4(uint64_t a1)
{
  BOOL v1;

  if (*(_DWORD *)(a1 + 4296))
    v1 = (unsigned __int16)*(_DWORD *)(a1 + 4296) == 65193;
  else
    v1 = 1;
  return !v1;
}

uint64_t sub_100066F00(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4300);
}

BOOL sub_100066F0C(uint64_t a1)
{
  return *(_BYTE *)(a1 + 4312) == 0;
}

void sub_100066F20(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7)
{
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v14;
  int v15;
  int v16;
  void *v17;
  void *v18;
  const __CFString *v19;
  void *v20;
  void *v21;
  const __CFString *v22;
  CFNumberRef v23;
  CFNumberRef v24;
  int v25;
  CFNumberRef v26;
  void *v27;
  void *v28;
  const void *v29;
  const __CFString *v30;
  void *v31;
  unsigned int valuePtr;
  __int16 v34;

  v34 = a7;
  if (a1)
  {
    v12 = kCFAllocatorDefault;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v14 = Mutable;
      switch(a4)
      {
        case 2u:
          v15 = 1;
          goto LABEL_12;
        case 3u:
          v15 = 2;
          goto LABEL_12;
        case 4u:
          v15 = 3;
          goto LABEL_12;
        case 5u:
          v15 = 5;
          goto LABEL_12;
        case 6u:
          v15 = 6;
          goto LABEL_12;
        case 7u:
          v15 = 7;
          goto LABEL_12;
        case 8u:
          v15 = 8;
LABEL_12:
          valuePtr = v15;
          break;
        default:
          valuePtr = 0;
          break;
      }
      v16 = *(_DWORD *)(a1 + 5940);
      if ((v16 & a6) != 0)
      {
        v17 = objc_autoreleasePoolPush();
        v18 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v19 = sub_100064D44(a6);
          objc_msgSend(v18, "WFLog:message:", 4, "%s: Clearing roam offset %@(%d) for %@", "WiFiDeviceSetRoamParams", v19, a6, sub_10002B088(a3));
        }
        objc_autoreleasePoolPop(v17);
        v16 = *(_DWORD *)(a1 + 5940);
      }
      if ((v16 & a5) != 0)
      {
        v20 = objc_autoreleasePoolPush();
        v21 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v22 = sub_100064D44(a5);
          objc_msgSend(v21, "WFLog:message:", 4, "%s: Setting roam offset %@(%d) for %@", "WiFiDeviceSetRoamParams", v22, a5, sub_10002B088(a3));
        }
        objc_autoreleasePoolPop(v20);
        v16 = *(_DWORD *)(a1 + 5940);
        v12 = kCFAllocatorDefault;
      }
      *(_DWORD *)(a1 + 5940) = v16 & ~(_DWORD)a6 | a5;
      v23 = CFNumberCreate(v12, kCFNumberIntType, &valuePtr);
      if (!v23)
      {
LABEL_36:
        CFRelease(v14);
        return;
      }
      v24 = v23;
      CFDictionarySetValue(v14, CFSTR("IO80211InterfaceRoamProfile"), v23);
      v25 = *(_DWORD *)(a1 + 5940);
      if ((v25 & 1) != 0)
      {
        CFDictionarySetValue(v14, CFSTR("IO80211InterfaceRoamProfilePoorLinkQuality"), kCFBooleanTrue);
        v25 = *(_DWORD *)(a1 + 5940);
      }
      if ((v25 & 2) != 0)
      {
        if (!a7)
        {
          v31 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: motionRssiDelta is 0. Exiting!", "WiFiDeviceSetRoamParams");
          objc_autoreleasePoolPop(v31);
          v26 = 0;
LABEL_35:
          CFRelease(v24);
          CFRelease(v14);
          v14 = v26;
          if (!v26)
            return;
          goto LABEL_36;
        }
        CFDictionarySetValue(v14, CFSTR("IO80211InterfaceRoamProfileMotion"), kCFBooleanTrue);
        v26 = CFNumberCreate(v12, kCFNumberIntType, &v34);
        if (!v26)
          goto LABEL_35;
        CFDictionarySetValue(v14, CFSTR("IO80211InterfaceRoamProfileMotionRssiDelta"), v26);
      }
      else
      {
        v26 = 0;
      }
      if (a4 <= 8 && ((1 << a4) & 0x150) != 0)
        CFDictionarySetValue(v14, CFSTR("IO80211InterfaceRoamMultiAP"), kCFBooleanTrue);
      v27 = objc_autoreleasePoolPush();
      v28 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v29 = sub_10002B088(a3);
        v30 = sub_10002B5A4(a4);
        objc_msgSend(v28, "WFLog:message:", 3, "%s: setting roam profile for %@ to type %@(%d) with offsets %@(0x%x)", "WiFiDeviceSetRoamParams", v29, v30, valuePtr, sub_100064D44(*(_DWORD *)(a1 + 5940)), *(unsigned int *)(a1 + 5940));
      }
      objc_autoreleasePoolPop(v27);
      sub_1000672C0(a1, *(const void **)(a1 + 112), 531, 0, (uint64_t)v14);
      *(_DWORD *)(a1 + 5944) = a4;
      goto LABEL_35;
    }
  }
}

uint64_t sub_1000672C0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const void *v10;
  uint64_t v11;
  CFTypeID v12;
  uint64_t result;
  int i;
  void *v16;

  v10 = sub_10002DEA0(a1, a2);
  if (!v10)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v16);
    return 0;
  }
  v11 = (uint64_t)v10;
  v12 = CFGetTypeID(v10);
  if (v12 == sub_10002DE64())
  {
    sub_10015F698(v11, a3, a4, a5);
    return 0;
  }
  for (i = 6; ; --i)
  {
    result = Apple80211Set(*(_QWORD *)(a1 + 16), a3, 0, a5, 8);
    if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  return result;
}

void sub_1000673BC(uint64_t a1, const __CFString *a2)
{
  void *v4;
  const __CFAllocator *v5;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  const void *v8;
  const __CFString *NetworkServiceEntity;
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  const void *Value;
  void *v14;
  NSString *const **v15;
  NSString *v16;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v18;
  _BYTE *v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  const __CFString *v24;
  const __CFString *v25;
  void *v26;
  NSString *v27;
  const char *v28;
  int v30;
  void *v31;
  NSString *v32;
  const char *v33;
  const __CFBoolean *v34;
  void *v35;
  id v36;
  id v37;
  const __CFString *v38;
  void *v39;
  NSString *v40;
  const char *v41;
  id v42;
  id v43;
  const __CFString *v44;
  void *v45;
  NSString *v46;
  const char *v47;
  NSString *v48;
  const char *v49;
  in_addr_t s_addr;
  int v51;
  const __CFString *v52;
  void *v53;
  _BOOL8 v54;
  int v55;
  uint64_t v56;
  void *v57;
  const void **v58;
  CFNumberRef v59;
  __CFDictionary *v60;
  __CFDictionary *v61;
  void *v62;
  CFNumberRef v63;
  const __CFString *v64;
  const __CFDictionary *v65;
  const __CFDictionary *v66;
  const __CFString *v67;
  const __CFString *v68;
  char v69;
  const __CFDictionary *v70;
  const __CFDictionary *v71;
  const __CFDate *LeaseStartTime;
  CFDateRef LeaseExpirationTime;
  const __CFDate *v74;
  double AbsoluteTime;
  double v76;
  const __CFDictionary *v77;
  double v78;
  unint64_t v79;
  void *v80;
  NSString *v81;
  const char *v82;
  const __CFString *v83;
  void *v84;
  NSString *v85;
  const char *v86;
  CFTypeID TypeID;
  __int128 v88;
  ether_addr *v89;
  __int16 v90;
  NSString *v91;
  const char *v92;
  const __CFArray *v93;
  const __CFArray *v94;
  const void *v95;
  const void *v96;
  void *v97;
  NSString *v98;
  const char *v99;
  NSString *v100;
  const char *v101;
  void (*v102)(uint64_t, const void *, const __CFDictionary *, _QWORD);
  CFNumberRef v103;
  CFNumberRef v104;
  CFNumberRef v105;
  CFNumberRef v106;
  CFDataRef v107;
  CFDataRef v108;
  int i;
  uint64_t v110;
  uint64_t v111;
  void *v113;
  unint64_t v114;
  WiFiUsageMonitor *v115;
  _BOOL8 v116;
  const __CFString *v117;
  const void *v118;
  const __CFString *v119;
  unint64_t v120;
  const __CFString *v121;
  const __CFString *v122;
  const __CFArray *v123;
  void *v124;
  const __CFDictionary *cf;
  const __CFDictionary *v126;
  const __CFDictionary *v127;
  const __CFString *v128;
  in_addr v129;
  uint64_t valuePtr;
  UInt8 bytes[4];
  __int16 v132;
  uint64_t v133;
  uint8_t buf[16];
  __int128 v135;
  __int128 v136;
  __int128 v137;

  v4 = objc_autoreleasePoolPush();
  valuePtr = 0;
  v133 = 0;
  *(_DWORD *)bytes = 0;
  v132 = 0;
  v5 = kCFAllocatorDefault;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a2, CFSTR("/"));
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 3);
    if (!ValueAtIndex)
      goto LABEL_184;
    v8 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 4);
    if (v8)
    {
      if (CFEqual(v8, kSCEntNetIPv4))
      {
        NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, ValueAtIndex, kSCEntNetInterface);
        if (NetworkServiceEntity)
        {
          v10 = NetworkServiceEntity;
          v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), NetworkServiceEntity);
          if (!v11)
          {
            ValueAtIndex = 0;
            v63 = 0;
            v126 = 0;
            v127 = 0;
            v117 = 0;
LABEL_167:
            CFRelease(v10);
            if (!ArrayBySeparatingStrings)
              goto LABEL_169;
            goto LABEL_168;
          }
          v12 = v11;
          Value = CFDictionaryGetValue(v11, kSCPropNetInterfaceDeviceName);
          cf = v12;
          if (!Value || (v118 = Value, !CFEqual(*(CFTypeRef *)(a1 + 112), Value)))
          {
            v117 = 0;
            v126 = 0;
            v127 = 0;
            v63 = 0;
            ValueAtIndex = 0;
            goto LABEL_166;
          }
          v122 = v10;
          v123 = ArrayBySeparatingStrings;
          v124 = v4;
          v14 = objc_autoreleasePoolPush();
          v15 = &ACAccountStoreDidChangeNotification_ptr;
          if (qword_10026DD20)
          {
            v16 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IPV4 State change for %@"), *(_QWORD *)(a1 + 112))), "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v16, "UTF8String")), "UTF8String");
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
          }
          objc_autoreleasePoolPop(v14);
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (!Mutable)
          {
            v117 = 0;
            v126 = 0;
            v127 = 0;
            v63 = 0;
            ValueAtIndex = 0;
            v10 = v122;
            goto LABEL_166;
          }
          v18 = Mutable;
          v19 = (_BYTE *)(a1 + 4300);
          v20 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), a2);
          v21 = v20;
          if (!v20)
          {
            v127 = 0;
            v128 = 0;
            v63 = 0;
            v120 = 0;
            v121 = 0;
            v126 = 0;
LABEL_133:
            v103 = CFNumberCreate(v5, kCFNumberIntType, (char *)&v133 + 4);
            if (v103)
            {
              v104 = v103;
              CFDictionaryAddValue(v18, CFSTR("IO80211InterfaceIPV4Address"), v103);
              CFRelease(v104);
            }
            if ((_DWORD)valuePtr != *(_DWORD *)(a1 + 4316))
              *(_DWORD *)(a1 + 4316) = valuePtr;
            v105 = CFNumberCreate(v5, kCFNumberIntType, &v133);
            if (v105)
            {
              v106 = v105;
              CFDictionaryAddValue(v18, CFSTR("IO80211InterfaceIPV4RouterAddress"), v105);
              CFRelease(v106);
            }
            v107 = CFDataCreate(v5, bytes, 6);
            if (v107)
            {
              v108 = v107;
              CFDictionaryAddValue(v18, CFSTR("IO80211InterfaceRouterMACAddress"), v107);
              CFRelease(v108);
            }
            for (i = 6; ; --i)
            {
              v110 = Apple80211Set(*(_QWORD *)(a1 + 16), 489, 0, v18, 8);
              v111 = v110;
              if ((int)v110 <= 15)
              {
                if ((_DWORD)v110 != -3905)
                  break;
              }
              else if ((_DWORD)v110 != 61 && (_DWORD)v110 != 16)
              {
                goto LABEL_152;
              }
              if (!i)
                break;
              usleep(0x7A120u);
            }
            if (!(_DWORD)v110)
              goto LABEL_155;
LABEL_152:
            v113 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceCheckForIPV4ParamsChange", v111);
            objc_autoreleasePoolPop(v113);
LABEL_155:
            if (sub_100066DF8(a1))
            {
              v114 = v120;
              if (a1)
              {
                if (v19[20])
                  sub_100051A28(a1, 1, v120, *(_DWORD *)(a1 + 5872), v18, 0);
                v115 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
                goto LABEL_161;
              }
              v115 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
            }
            else
            {
              v115 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
              v114 = v120;
              if (a1)
              {
LABEL_161:
                v116 = v19[20] != 0;
                goto LABEL_164;
              }
            }
            v116 = 0;
LABEL_164:
            -[WiFiUsageMonitor notifyIpConfigurationStateWithMethod:dhcpLeaseDuration:hasRoutableIpV4:hasRoutableIpV6:](v115, "notifyIpConfigurationStateWithMethod:dhcpLeaseDuration:hasRoutableIpV4:hasRoutableIpV6:", v116, *(_DWORD *)(a1 + 4316) == 2, *v19 != 0, (double)v114);
            -[WiFiUsageMonitor notifyIPv4Changes:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "notifyIPv4Changes:", -[__CFDictionary copy](v21, "copy"));
            v19[44] = 0;
            CFRelease(v18);
            ArrayBySeparatingStrings = v123;
            v4 = v124;
            v117 = v121;
            v10 = v122;
            ValueAtIndex = v128;
            if (!v21)
            {
LABEL_166:
              CFRelease(cf);
              goto LABEL_167;
            }
LABEL_165:
            CFRelease(v21);
            goto LABEL_166;
          }
          v22 = (const __CFArray *)CFDictionaryGetValue(v20, kSCPropNetIPv4Addresses);
          if (v22 && (v23 = v22, CFArrayGetCount(v22) >= 1))
          {
            v24 = (const __CFString *)CFArrayGetValueAtIndex(v23, 0);
            if (v24)
            {
              v25 = v24;
              v26 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v27 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IP Address: %@"), v25)), "UTF8String"));
                if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                {
                  v28 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v27, "UTF8String")), "UTF8String");
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = v28;
                  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                }
              }
              objc_autoreleasePoolPop(v26);
              sub_100068A0C(v25, (in_addr *)&v133 + 1);
              if (BYTE5(v133) == 254 && BYTE4(v133) == 169)
                v30 = 1;
              else
                v30 = 2;
              LODWORD(valuePtr) = v30;
              v15 = &ACAccountStoreDidChangeNotification_ptr;
            }
          }
          else
          {
            v31 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v32 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No IP address\n"))), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v33 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v32, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v33;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v31);
          }
          *(_DWORD *)(a1 + 4296) = HIDWORD(v133);
          v34 = (const __CFBoolean *)CFDictionaryGetValue(v21, kSCPropNetIPv4CLAT46);
          if (v34 && CFBooleanGetValue(v34) == 1)
          {
            v35 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v36 = objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("%s"), objc_msgSend(objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("IPv4CLAT46 network - not propagating IPv4 information to device\n"))), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v37 = objc_msgSend(objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), objc_msgSend(v36, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v37;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v35);
            HIDWORD(v133) = 0;
          }
          v38 = (const __CFString *)CFDictionaryGetValue(v21, kSCPropNetIPv4ARPResolvedIPAddress);
          v39 = objc_autoreleasePoolPush();
          if (v38)
          {
            if (qword_10026DD20)
            {
              v40 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Router IP Address: %@"), v38)), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v41 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v40, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v41;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v39);
            sub_100068A0C(v38, (in_addr *)&v133);
          }
          else
          {
            if (qword_10026DD20)
            {
              v42 = objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("%s"), objc_msgSend(objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("No Router IP Address"))), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v43 = objc_msgSend(objc_msgSend((id)v15[449], "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), objc_msgSend(v42, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v43;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v39);
          }
          v129.s_addr = 0;
          v44 = (const __CFString *)CFDictionaryGetValue(v21, kSCPropNetIPv4Router);
          v45 = objc_autoreleasePoolPush();
          if (v44)
          {
            if (qword_10026DD20)
            {
              v46 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Default Gateway IP Address: %@"), v44)), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v47 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v46, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v47;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v45);
            sub_100068A0C(v44, &v129);
          }
          else
          {
            if (qword_10026DD20)
            {
              v48 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No Default Gateway IP Address"))), "UTF8String"));
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
              {
                v49 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v48, "UTF8String")), "UTF8String");
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = v49;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
              }
            }
            objc_autoreleasePoolPop(v45);
          }
          s_addr = v129.s_addr;
          v51 = v129.s_addr == 0;
          v52 = (const __CFString *)sub_10002BF8C(a1, *(const void **)(a1 + 112));
          v128 = v52;
          if (v52 && sub_10000BE8C((uint64_t)v52))
          {
            if (s_addr)
            {
              HIDWORD(valuePtr) = 2;
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting power mode to kA11PowerProfileCarPlayWithInternet", "__WiFiDeviceCheckForIPV4ParamsChange");
            }
            else
            {
              HIDWORD(valuePtr) = 1;
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting power mode to kA11PowerProfileCarPlayOnly", "__WiFiDeviceCheckForIPV4ParamsChange");
            }
          }
          else
          {
            v53 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting power mode to kA11PowerProfileDefault", "__WiFiDeviceCheckForIPV4ParamsChange");
          }
          v54 = s_addr == 0;
          objc_autoreleasePoolPop(v53);
          v55 = valuePtr;
          if (*(unsigned __int8 *)(a1 + 4312) == v51 && (_DWORD)valuePtr == *(_DWORD *)(a1 + 4316))
          {
LABEL_85:
            v63 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&valuePtr + 4);
            if (!v63)
            {
              CFRelease(v18);
              v126 = 0;
              v127 = 0;
              v117 = 0;
              ArrayBySeparatingStrings = v123;
              v4 = v124;
              v10 = v122;
              ValueAtIndex = v128;
              goto LABEL_165;
            }
            v119 = v44;
            sub_1000672C0(a1, *(const void **)(a1 + 112), 479, 0, (uint64_t)v63);
            sub_100068B8C(a1);
            v64 = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, ValueAtIndex, kSCEntNetIPv4);
            v121 = v64;
            if (v64)
            {
              v65 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), v64);
              v66 = v65;
              v19 = (_BYTE *)(a1 + 4300);
              if (v65)
              {
                v67 = (const __CFString *)CFDictionaryGetValue(v65, kSCPropNetIPv4ConfigMethod);
                v68 = v67;
                if (v67 && CFStringCompare(v67, kSCValNetIPv4ConfigMethodDHCP, 0) == kCFCompareEqualTo)
                {
                  v69 = 1;
                  goto LABEL_94;
                }
              }
              else
              {
                v68 = 0;
              }
            }
            else
            {
              v68 = 0;
              v66 = 0;
              v19 = (_BYTE *)(a1 + 4300);
            }
            v69 = 0;
LABEL_94:
            v19[20] = v69;
            v127 = v66;
            if (!sub_100066DF8(a1))
            {
              v79 = 0;
              v126 = 0;
              goto LABEL_108;
            }
            dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 80), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
            v70 = SCDynamicStoreCopyDHCPInfo(0, ValueAtIndex);
            v126 = v70;
            if (v70)
            {
              v71 = v70;
              LeaseStartTime = DHCPInfoGetLeaseStartTime(v70);
              LeaseExpirationTime = DHCPInfoGetLeaseExpirationTime(v71);
              if (LeaseStartTime)
              {
                v74 = LeaseExpirationTime;
                if (!LeaseExpirationTime)
                {
                  v77 = v21;
                  v79 = 0xFFFFFFFFLL;
LABEL_103:
                  v80 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v81 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: configMethod %@, leaseExpiryDuration %llu mins on %@"), "__WiFiDeviceCheckForIPV4ParamsChange", v68, v79, sub_10002B088(v128))), "UTF8String"));
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                    {
                      v82 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v81, "UTF8String")), "UTF8String");
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = v82;
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                    }
                  }
                  objc_autoreleasePoolPop(v80);
                  v21 = v77;
LABEL_108:
                  v120 = v79;
                  *(_DWORD *)(a1 + 4324) = v79;
                  v83 = (const __CFString *)CFDictionaryGetValue(v21, kSCPropNetIPv4ARPResolvedHardwareAddress);
                  v84 = objc_autoreleasePoolPush();
                  if (v83)
                  {
                    if (qword_10026DD20)
                    {
                      v85 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Router MAC Address: %@"), v83)), "UTF8String"));
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                      {
                        v19 = (_BYTE *)(a1 + 4300);
                        v86 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v85, "UTF8String")), "UTF8String");
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = v86;
                        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                      }
                    }
                    objc_autoreleasePoolPop(v84);
                    *(_DWORD *)bytes = 0;
                    v132 = 0;
                    TypeID = CFStringGetTypeID();
                    if (CFGetTypeID(v83) == TypeID)
                    {
                      *(_QWORD *)&v88 = 0xAAAAAAAAAAAAAAAALL;
                      *((_QWORD *)&v88 + 1) = 0xAAAAAAAAAAAAAAAALL;
                      v136 = v88;
                      v137 = v88;
                      *(_OWORD *)buf = v88;
                      v135 = v88;
                      if (CFStringGetCString(v83, (char *)buf, 64, 0x600u))
                      {
                        v89 = ether_aton((const char *)buf);
                        v90 = *(_WORD *)&v89->octet[4];
                        *(_DWORD *)bytes = *(_DWORD *)v89->octet;
                        v132 = v90;
                      }
                    }
                  }
                  else
                  {
                    if (qword_10026DD20)
                    {
                      v91 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No Router MAC Address"))), "UTF8String"));
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                      {
                        v19 = (_BYTE *)(a1 + 4300);
                        v92 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v91, "UTF8String")), "UTF8String");
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = v92;
                        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                      }
                    }
                    objc_autoreleasePoolPop(v84);
                  }
                  sub_100068C8C(a1, v83, v119);
                  v93 = (const __CFArray *)CFDictionaryGetValue(v21, kSCPropNetIPv4SubnetMasks);
                  if (v93 && (v94 = v93, CFArrayGetCount(v93) >= 1))
                  {
                    v95 = CFArrayGetValueAtIndex(v94, 0);
                    v5 = kCFAllocatorDefault;
                    if (!v95)
                      goto LABEL_131;
                    v96 = v95;
                    v97 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                    {
                      v98 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IP subnet mask: %@"), v96)), "UTF8String"));
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                      {
                        v99 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v98, "UTF8String")), "UTF8String");
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = v99;
                        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                      }
                    }
                  }
                  else
                  {
                    v97 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                    {
                      v100 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("No IP subnet mask\n"))), "UTF8String"));
                      v5 = kCFAllocatorDefault;
                      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                      {
                        v101 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v100, "UTF8String")), "UTF8String");
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = v101;
                        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                      }
                    }
                    else
                    {
                      v5 = kCFAllocatorDefault;
                    }
                  }
                  objc_autoreleasePoolPop(v97);
LABEL_131:
                  v102 = *(void (**)(uint64_t, const void *, const __CFDictionary *, _QWORD))(a1 + 5032);
                  if (v102)
                    v102(a1, v118, v21, *(_QWORD *)(a1 + 5040));
                  goto LABEL_133;
                }
                AbsoluteTime = CFDateGetAbsoluteTime(LeaseStartTime);
                v76 = CFDateGetAbsoluteTime(v74);
                if (v76 > AbsoluteTime)
                {
                  v77 = v21;
                  v78 = (v76 - AbsoluteTime) / 60.0;
                  if ((unint64_t)v78 >= 0xFFFFFFFE)
                    v79 = 4294967294;
                  else
                    v79 = (unint64_t)v78;
                  goto LABEL_103;
                }
              }
            }
            v77 = v21;
            v79 = 0;
            goto LABEL_103;
          }
          v56 = a1 + 4300;
          if ((_DWORD)valuePtr == 1)
          {
            if (*(_DWORD *)(a1 + 4316) == 2)
            {
              v57 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device lost a valid IP address. Resetting routability.", "__WiFiDeviceCheckForIPV4ParamsChange");
              objc_autoreleasePoolPop(v57);
              v56 = a1 + 4300;
              *(_BYTE *)(a1 + 4300) = 0;
              v55 = valuePtr;
            }
            else
            {
              v55 = 1;
            }
          }
          *(_BYTE *)(v56 + 12) = v51;
          *(_DWORD *)(a1 + 4316) = v55;
          if (s_addr)
            v58 = (const void **)&kCFBooleanFalse;
          else
            v58 = (const void **)&kCFBooleanTrue;
          v59 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
          v60 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v61 = v60;
          if (v59 && *v58 && v60)
          {
            CFDictionarySetValue(v60, CFSTR("WiFiHasNoGatewayIP"), *v58);
            CFDictionarySetValue(v61, CFSTR("WiFiIPState"), v59);
          }
          else if (!v59)
          {
            goto LABEL_79;
          }
          CFRelease(v59);
LABEL_79:
          if (v61)
          {
            if (*(_QWORD *)(a1 + 4840))
            {
              v62 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Dispatch LQM with hasNoGatewayIP %d, wifiIPState %d", "__WiFiDeviceCheckForIPV4ParamsChange", v54, valuePtr);
              objc_autoreleasePoolPop(v62);
              (*(void (**)(uint64_t, const void *, _QWORD, __CFDictionary *))(a1 + 4840))(a1, v118, *(_QWORD *)(a1 + 4848), v61);
            }
            CFRelease(v61);
          }
          goto LABEL_85;
        }
      }
    }
  }
  ValueAtIndex = 0;
LABEL_184:
  v63 = 0;
  v126 = 0;
  v127 = 0;
  v117 = 0;
  if (ArrayBySeparatingStrings)
LABEL_168:
    CFRelease(ArrayBySeparatingStrings);
LABEL_169:
  if (v117)
    CFRelease(v117);
  if (v127)
    CFRelease(v127);
  if (v126)
    CFRelease(v126);
  if (v63)
    CFRelease(v63);
  if (ValueAtIndex)
    CFRelease(ValueAtIndex);
  objc_autoreleasePoolPop(v4);
}

void sub_100068A0C(const __CFString *a1, in_addr *a2)
{
  CFTypeID TypeID;
  void *v5;
  void *v6;
  char buffer[16];

  memset(buffer, 170, sizeof(buffer));
  a2->s_addr = 0;
  TypeID = CFStringGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    if (CFStringGetCString(a1, buffer, 16, 0x600u))
    {
      if (inet_aton(buffer, a2) == 1)
        return;
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error converting IPv4 address %@ to network type", "__WiFiDeviceConvertStrToIPv4Addr", a1);
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error converting IPv4 address %@ to ASCII", "__WiFiDeviceConvertStrToIPv4Addr", a1);
    }
    objc_autoreleasePoolPop(v5);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not a valid CFString", "__WiFiDeviceConvertStrToIPv4Addr");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_100068B8C(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  unsigned int IsQoSMarkingProfileInstalled;
  void *v5;
  uint64_t *v6;
  const void *v7;

  v2 = _SCNetworkInterfaceCreateWithBSDName(0, *(_QWORD *)(a1 + 112), 0);
  if (!v2)
    goto LABEL_6;
  v3 = (const void *)v2;
  IsQoSMarkingProfileInstalled = _SCNetworkInterfaceIsQoSMarkingProfileInstalled();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "FASTLANE Profile installed: %d\n", IsQoSMarkingProfileInstalled);
  objc_autoreleasePoolPop(v5);
  CFRelease(v3);
  if (IsQoSMarkingProfileInstalled)
    v6 = (uint64_t *)&kCFBooleanTrue;
  else
LABEL_6:
    v6 = (uint64_t *)&kCFBooleanFalse;
  v7 = (const void *)*v6;
  sub_1000672C0(a1, *(const void **)(a1 + 112), 480, 0, *v6);
  if (v7)
    CFRelease(v7);
}

uint64_t sub_100068C68(uint64_t result, char a2)
{
  if (result)
  {
    *(_BYTE *)(result + 4320) = a2;
    return 1;
  }
  return result;
}

uint64_t sub_100068C7C(uint64_t result, int a2)
{
  if (result)
  {
    *(_DWORD *)(result + 4324) = a2;
    return 1;
  }
  return result;
}

uint64_t sub_100068C8C(uint64_t result, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v5;
  const void *v6;
  const void *v7;

  if (result)
  {
    v5 = result;
    v6 = *(const void **)(result + 4328);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(v5 + 4328) = 0;
    }
    v7 = *(const void **)(v5 + 4336);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(v5 + 4336) = 0;
    }
    if (cf)
      *(_QWORD *)(v5 + 4328) = CFRetain(cf);
    if (a3)
      *(_QWORD *)(v5 + 4336) = CFRetain(a3);
    return 1;
  }
  return result;
}

uint64_t sub_100068D00(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 4320);
  return result;
}

void sub_100068D10(uint64_t a1)
{
  const void *v2;
  __CFDictionary *v3;
  void (*v4)(uint64_t, int64_t, __CFDictionary *, _QWORD, _QWORD);
  int64_t v5;

  if (a1)
  {
    v2 = (const void *)sub_100068E60(a1);
    v3 = sub_100068D8C(a1, v2);
    v4 = *(void (**)(uint64_t, int64_t, __CFDictionary *, _QWORD, _QWORD))(a1 + 5080);
    if (v4)
    {
      v5 = sub_100068E60(a1);
      v4(a1, v5, v3, 0, *(_QWORD *)(a1 + 5088));
    }
    if (v3)
      CFRelease(v3);
  }
}

__CFDictionary *sub_100068D8C(uint64_t a1, const void *a2)
{
  const void *v3;
  uint64_t v4;
  CFTypeID v5;
  uint64_t v6;
  void *v7;
  __CFDictionary *v9;

  v9 = 0;
  v3 = sub_10002DEA0(a1, a2);
  if (v3)
  {
    v4 = (uint64_t)v3;
    v5 = CFGetTypeID(v3);
    if (v5 == sub_10002DE64())
    {
      v6 = sub_10015CF9C(v4, &v9);
      if (!(_DWORD)v6)
        return v9;
    }
    else
    {
      v6 = 4294963393;
    }
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error %d", "WiFiDeviceCopyInterfaceStateInfo", v6);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "WiFiDeviceCopyInterfaceStateInfo", a2);
  }
  objc_autoreleasePoolPop(v7);
  return v9;
}

int64_t sub_100068E60(uint64_t a1)
{
  CFIndex Count;
  int64_t v3;
  CFNumberRef v4;
  CFNumberRef v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void **v9;
  CFTypeRef *v10;
  int64_t *v11;
  CFTypeID v12;
  const void *v13;
  void *v15;
  uint64_t valuePtr;

  valuePtr = 6;
  if (!a1)
    return 0;
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  if (!Count)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no virtual interfaces found.", "WiFiDeviceGetAwdlInterfaceName", valuePtr);
    objc_autoreleasePoolPop(v15);
    return 0;
  }
  v3 = Count;
  v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = (const void **)sub_100064A6C(0, v3, 8uLL);
  if (v6)
  {
    v7 = v6;
    v8 = (const void **)sub_100064A6C(0, v3, 8uLL);
    if (v8)
    {
      v9 = v8;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v7, v8);
      if (v3 < 1)
      {
        v3 = 0;
      }
      else
      {
        v10 = v9;
        v11 = (int64_t *)v7;
        while (1)
        {
          v12 = CFGetTypeID(*v10);
          if (v12 == sub_10002DE64())
          {
            v13 = sub_10000E178((uint64_t)*v10);
            if (CFEqual(v13, v5))
              break;
          }
          ++v11;
          ++v10;
          if (!--v3)
            goto LABEL_14;
        }
        v3 = *v11;
      }
LABEL_14:
      free(v9);
    }
    else
    {
      v3 = 0;
    }
    free(v7);
  }
  else
  {
    v3 = 0;
  }
  CFRelease(v5);
  return v3;
}

uint64_t sub_100068FE4()
{
  uint64_t result;

  result = qword_10026D630;
  if (!qword_10026D630)
  {
    pthread_once(&stru_10026C9A8, (void (*)(void))sub_100069020);
    return qword_10026D630;
  }
  return result;
}

CFStringRef sub_100069020()
{
  CFStringRef result;

  qword_10026D630 = _CFRuntimeRegisterClass(&unk_10022F758);
  IOMasterPort(0, (mach_port_t *)&dword_10026D638);
  qword_10026D620 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCEntNetIPv4);
  result = SCDynamicStoreKeyCreateNetworkGlobalEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCEntNetIPv6);
  qword_10026D628 = (uint64_t)result;
  return result;
}

uint64_t sub_1000690B4(const __CFAllocator *a1, io_registry_entry_t a2)
{
  void *v4;
  uint64_t Instance;
  uint64_t v6;
  _BYTE *v7;
  unsigned int v8;
  CFTypeRef CFProperty;
  uint64_t v10;
  BOOL v11;
  CFTypeRef v12;
  CFTypeRef v13;
  const void *v14;
  CFTypeID v15;
  CFTypeID v16;
  void *v17;
  void *v18;
  CFMutableDictionaryRef Mutable;
  IONotificationPortRef v20;
  uint64_t v21;
  CFMutableDictionaryRef v22;
  CFMutableArrayRef v23;
  CFMutableArrayRef v24;
  CFMutableArrayRef v25;
  CFMutableArrayRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  __CFDictionary *v29;
  CFMutableArrayRef v30;
  void *v31;
  void *v33;
  void *v34;
  void *v35;
  const char *v36;
  uint64_t v37;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceCreate");
  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    if (!qword_10026D630)
      pthread_once(&stru_10026C9A8, (void (*)(void))sub_100069020);
    Instance = _CFRuntimeCreateInstance(a1);
    if (Instance)
    {
      v6 = Instance;
      v7 = (_BYTE *)(Instance + 4300);
      bzero((void *)(Instance + 16), 0x1758uLL);
      v8 = 0;
      *(_WORD *)(v6 + 54) = 0;
      *(_OWORD *)(v6 + 240) = xmmword_1001BB550;
      *(_QWORD *)(v6 + 256) = 7;
      *(_QWORD *)(v6 + 264) = 4294967277;
      do
      {
        CFProperty = IORegistryEntryCreateCFProperty(a2, CFSTR("IOInterfaceName"), a1, 0);
        *(_QWORD *)(v6 + 112) = CFProperty;
        if (CFProperty)
          goto LABEL_29;
        usleep(0x2710u);
        v10 = *(_QWORD *)(v6 + 112);
        if (v10)
          v11 = 1;
        else
          v11 = v8 >= 0x1F;
        ++v8;
      }
      while (!v11);
      if (v10)
      {
LABEL_28:
        if (*(_QWORD *)(v6 + 112))
        {
LABEL_29:
          IORegistryEntryGetParentEntry(a2, "IOService", (io_registry_entry_t *)(v6 + 24));
          if (!*(_DWORD *)(v6 + 24))
          {
            v34 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No Matching Parent Service Found for interface %@", "WiFiDeviceCreate", *(_QWORD *)(v6 + 112));
            goto LABEL_61;
          }
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(_QWORD *)(v6 + 120) = Mutable;
          if (!Mutable)
            goto LABEL_62;
          v20 = IONotificationPortCreate(dword_10026D638);
          *(_QWORD *)(v6 + 96) = v20;
          if (v20)
          {
            *(_QWORD *)(v6 + 144) = sub_1001476BC((uint64_t)a1, v6);
            v21 = sub_1001547BC(a1, 0);
            *(_QWORD *)(v6 + 176) = v21;
            if (v21)
            {
              v22 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              *(_QWORD *)(v6 + 200) = v22;
              if (v22)
              {
                v23 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                *(_QWORD *)(v6 + 5696) = v23;
                if (v23)
                {
                  v7[1404] = 1;
                  v7[1420] = 0;
                  v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                  *(_QWORD *)(v6 + 5752) = v24;
                  if (v24)
                  {
                    v7[1460] = 1;
                    v7[1476] = 0;
                    v25 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                    *(_QWORD *)(v6 + 5656) = v25;
                    if (v25)
                    {
                      v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                      *(_QWORD *)(v6 + 5664) = v26;
                      if (v26)
                      {
                        sub_10015488C(*(_QWORD *)(v6 + 176), (uint64_t)sub_100019E70, v6);
                        v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, (const void *)(v6 + 256));
                        if (v27)
                        {
                          v28 = v27;
                          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 120), CFSTR("SignalStrengthThreshold"), v27);
                          CFRelease(v28);
                        }
                        v29 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                        *(_QWORD *)(v6 + 5784) = v29;
                        if (v29)
                        {
                          CFDictionaryAddValue(v29, *(const void **)(v6 + 112), (const void *)v6);
                          sub_100050B58((const void *)v6);
                          *(_DWORD *)(v6 + 4296) = 0;
                          *v7 = 0;
                          sub_100069690(v6);
                          *(_BYTE *)(v6 + 208) = 0;
                          *(_QWORD *)(v6 + 216) = 0;
                          *(_QWORD *)(v6 + 5920) = 0;
                          *(_QWORD *)(v6 + 5928) = 0x6400000064;
                          *(_DWORD *)(v6 + 5936) = 0;
                          *(_WORD *)(v6 + 224) = 257;
                          if (byte_10026DD62)
                            *(_WORD *)(v6 + 224) = 0;
                          *(_QWORD *)(v6 + 232) = MGCopyAnswer(CFSTR("WifiAddressData"), 0);
                          *(_DWORD *)(v6 + 5944) = 0;
                          v30 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                          *(_QWORD *)(v6 + 5968) = v30;
                          if (v30)
                          {
                            v31 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceCreate");
                            goto LABEL_46;
                          }
                        }
                      }
                    }
                  }
                }
              }
LABEL_62:
              CFRelease((CFTypeRef)v6);
              goto LABEL_63;
            }
            v34 = objc_autoreleasePoolPush();
            v35 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v36 = "%s: Error: WiFiCommandQueueCreate failed";
              goto LABEL_60;
            }
          }
          else
          {
            v34 = objc_autoreleasePoolPush();
            v35 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v36 = "%s: Error: IONotificationPortCreate failed";
LABEL_60:
              objc_msgSend(v35, "WFLog:message:", 4, v36, "WiFiDeviceCreate", v37);
            }
          }
        }
        else
        {
          v34 = objc_autoreleasePoolPush();
          v35 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v36 = "%s: Error: Could not obtain IO80211Interface bsd name";
            goto LABEL_60;
          }
        }
LABEL_61:
        objc_autoreleasePoolPop(v34);
        goto LABEL_62;
      }
      v12 = IORegistryEntryCreateCFProperty(a2, CFSTR("IOInterfaceNamePrefix"), a1, 0);
      v13 = IORegistryEntryCreateCFProperty(a2, CFSTR("IOInterfaceUnit"), a1, 0);
      v14 = v13;
      if (v12
        && v13
        && (v15 = CFGetTypeID(v12), v15 == CFStringGetTypeID())
        && (v16 = CFGetTypeID(v14), v16 == CFNumberGetTypeID()))
      {
        *(_QWORD *)(v6 + 112) = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), v12, v14);
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device->ifName : %@ ", "WiFiDeviceCreate", *(_QWORD *)(v6 + 112));
        objc_autoreleasePoolPop(v17);
      }
      else
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Could not obtain ifPrefix and ifUnit", "WiFiDeviceCreate");
        objc_autoreleasePoolPop(v18);
        if (!v12)
          goto LABEL_26;
      }
      CFRelease(v12);
LABEL_26:
      if (v14)
        CFRelease(v14);
      goto LABEL_28;
    }
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: no device", "WiFiDeviceCreate");
  }
  else
  {
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: no interface", "WiFiDeviceCreate");
  }
  objc_autoreleasePoolPop(v33);
LABEL_63:
  v31 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: Failed to create device ref", "WiFiDeviceCreate");
  v6 = 0;
LABEL_46:
  objc_autoreleasePoolPop(v31);
  return v6;
}

void sub_100069690(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  if (a1)
  {
    *(_OWORD *)(a1 + 2264) = 0u;
    *(_OWORD *)(a1 + 2280) = 0u;
    *(_OWORD *)(a1 + 2232) = 0u;
    *(_OWORD *)(a1 + 2248) = 0u;
    *(_OWORD *)(a1 + 2200) = 0u;
    *(_OWORD *)(a1 + 2216) = 0u;
    *(_OWORD *)(a1 + 2168) = 0u;
    *(_OWORD *)(a1 + 2184) = 0u;
    *(_OWORD *)(a1 + 2136) = 0u;
    *(_OWORD *)(a1 + 2152) = 0u;
    *(_OWORD *)(a1 + 2104) = 0u;
    *(_OWORD *)(a1 + 2120) = 0u;
    *(_OWORD *)(a1 + 2072) = 0u;
    *(_OWORD *)(a1 + 2088) = 0u;
    *(_OWORD *)(a1 + 2040) = 0u;
    *(_OWORD *)(a1 + 2056) = 0u;
    *(_OWORD *)(a1 + 2008) = 0u;
    *(_OWORD *)(a1 + 2024) = 0u;
    *(_OWORD *)(a1 + 1976) = 0u;
    *(_OWORD *)(a1 + 1992) = 0u;
    *(_OWORD *)(a1 + 1944) = 0u;
    *(_OWORD *)(a1 + 1960) = 0u;
    *(_OWORD *)(a1 + 1912) = 0u;
    *(_OWORD *)(a1 + 1928) = 0u;
    *(_OWORD *)(a1 + 1880) = 0u;
    *(_OWORD *)(a1 + 1896) = 0u;
    *(_OWORD *)(a1 + 1848) = 0u;
    *(_OWORD *)(a1 + 1864) = 0u;
    *(_OWORD *)(a1 + 1816) = 0u;
    *(_OWORD *)(a1 + 1832) = 0u;
    *(_OWORD *)(a1 + 1800) = 0u;
    *(_QWORD *)(a1 + 2296) = 0;
    bzero((void *)(a1 + 312), 0x3D8uLL);
    *(_QWORD *)(a1 + 1792) = 0;
    *(_OWORD *)(a1 + 1776) = 0u;
    *(_OWORD *)(a1 + 1760) = 0u;
    *(_OWORD *)(a1 + 1744) = 0u;
    *(_OWORD *)(a1 + 1728) = 0u;
    *(_OWORD *)(a1 + 1712) = 0u;
    *(_OWORD *)(a1 + 1696) = 0u;
    *(_OWORD *)(a1 + 1680) = 0u;
    *(_OWORD *)(a1 + 1664) = 0u;
    *(_OWORD *)(a1 + 1648) = 0u;
    *(_OWORD *)(a1 + 1632) = 0u;
    *(_OWORD *)(a1 + 1616) = 0u;
    *(_OWORD *)(a1 + 1600) = 0u;
    *(_OWORD *)(a1 + 1584) = 0u;
    *(_OWORD *)(a1 + 1568) = 0u;
    *(_OWORD *)(a1 + 1552) = 0u;
    *(_OWORD *)(a1 + 1536) = 0u;
    *(_OWORD *)(a1 + 1520) = 0u;
    *(_OWORD *)(a1 + 1504) = 0u;
    *(_OWORD *)(a1 + 1488) = 0u;
    *(_OWORD *)(a1 + 1472) = 0u;
    *(_OWORD *)(a1 + 1456) = 0u;
    *(_OWORD *)(a1 + 1440) = 0u;
    *(_OWORD *)(a1 + 1424) = 0u;
    *(_OWORD *)(a1 + 1408) = 0u;
    *(_OWORD *)(a1 + 1392) = 0u;
    *(_OWORD *)(a1 + 1376) = 0u;
    *(_OWORD *)(a1 + 1360) = 0u;
    *(_OWORD *)(a1 + 1344) = 0u;
    *(_OWORD *)(a1 + 1328) = 0u;
    *(_OWORD *)(a1 + 1312) = 0u;
    *(_OWORD *)(a1 + 1296) = 0u;
    bzero((void *)(a1 + 2304), 0x6A0uLL);
    *(_QWORD *)(a1 + 4016) = 0;
    *(_OWORD *)(a1 + 4000) = 0u;
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceResetCCAHistory");
    objc_autoreleasePoolPop(v2);
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceResetRssiHistory");
    objc_autoreleasePoolPop(v3);
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceResetPerCoreRssiHistory");
    objc_autoreleasePoolPop(v4);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceResetTxRxHistory");
    objc_autoreleasePoolPop(v5);
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceResetGatewayARPHistory");
    objc_autoreleasePoolPop(v6);
  }
}

uint64_t sub_1000698C4(uint64_t a1)
{
  CFIndex Count;
  uint64_t v3;
  CFNumberRef v4;
  CFNumberRef v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void **v9;
  CFTypeRef *v10;
  uint64_t *v11;
  CFTypeID v12;
  const void *v13;
  void *v15;
  uint64_t valuePtr;

  valuePtr = 7;
  if (!a1)
    return 0;
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  if (!Count)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no virtual interfaces found.", "WiFiDeviceGetHostApInterfaceName", valuePtr);
    objc_autoreleasePoolPop(v15);
    return 0;
  }
  v3 = Count;
  v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = (const void **)malloc_type_malloc(8 * v3, 0x6004044C4A2DFuLL);
  if (v6)
  {
    v7 = v6;
    v8 = (const void **)malloc_type_malloc(8 * v3, 0x2004093837F09uLL);
    if (v8)
    {
      v9 = v8;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v7, v8);
      if (v3 < 1)
      {
        v3 = 0;
      }
      else
      {
        v10 = v9;
        v11 = (uint64_t *)v7;
        while (1)
        {
          v12 = CFGetTypeID(*v10);
          if (v12 == sub_10002DE64())
          {
            v13 = sub_10000E178((uint64_t)*v10);
            if (CFEqual(v13, v5))
              break;
          }
          ++v11;
          ++v10;
          if (!--v3)
            goto LABEL_14;
        }
        v3 = *v11;
      }
LABEL_14:
      free(v9);
    }
    else
    {
      v3 = 0;
    }
    free(v7);
  }
  else
  {
    v3 = 0;
  }
  CFRelease(v5);
  return v3;
}

CFDictionaryRef sub_100069A5C(uint64_t a1, const void *a2)
{
  const void *v4;
  uint64_t v5;
  CFTypeID v6;
  int i;
  int v9;
  void *v11;
  CFDictionaryRef v12;

  v12 = 0;
  v4 = sub_10002DEA0(a1, a2);
  if (v4)
  {
    v5 = (uint64_t)v4;
    v6 = CFGetTypeID(v4);
    if (v6 == sub_10002DE64())
    {
      sub_10015CE30(v5, 29, 0, &v12);
    }
    else
    {
      for (i = 6; ; --i)
      {
        v9 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 29, 0, &v12);
        if (v9 != -3905 && v9 != 61 && v9 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v11);
  }
  return v12;
}

uint64_t sub_100069B44(uint64_t a1, CFStringRef theString, const char *a3, const char *a4, int a5, void *a6, unsigned int a7)
{
  __int128 v14;
  CFIndex Length;
  char *v16;
  char *v17;
  CFIndex v18;
  size_t v19;
  size_t v20;
  int v21;
  uint64_t v22;
  void *v23;
  void *v25;
  __int128 v26;
  __int128 v27;
  unint64_t v28;

  v28 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26 = v14;
  v27 = v14;
  Length = CFStringGetLength(theString);
  v16 = (char *)malloc_type_malloc(Length + 1, 0x75BE8482uLL);
  if (v16)
  {
    v17 = v16;
    v18 = CFStringGetLength(theString);
    CFStringGetCString(theString, v17, v18 + 1, 0);
    bzero(a6, a7);
    strcat((char *)a6, a3);
    *((_BYTE *)a6 + strlen(a3)) = 0;
    v19 = strlen(a3);
    strcat((char *)a6 + v19 + 1, a4);
    v20 = strlen(a3);
    *((_BYTE *)a6 + v20 + strlen(a4) + 1) = 32;
    v26 = 0u;
    v27 = 0u;
    v28 = 0;
    __strlcpy_chk(&v26, v17, 16, 16);
    if (a5)
      v21 = 263;
    else
      v21 = 262;
    LODWORD(v27) = -1;
    *(_QWORD *)((char *)&v27 + 4) = __PAIR64__(a7, v21);
    v28 = (unint64_t)a6;
    v22 = Apple80211RawGet(*(_QWORD *)(a1 + 16), &v26);
    free(v17);
    if (!(_DWORD)v22)
      return v22;
  }
  else
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to alloc interfaceName", "WiFiDeviceGetSetWLDump");
    objc_autoreleasePoolPop(v25);
    v22 = 4294963395;
  }
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error %d", "WiFiDeviceGetSetWLDump", v22);
  objc_autoreleasePoolPop(v23);
  return v22;
}

uint64_t sub_100069D4C(uint64_t a1, const void *a2, __CFArray *a3)
{
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  uint64_t v9;
  int j;
  uint64_t v11;
  CFIndex Count;
  CFIndex v14;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v17;
  void *v19;
  void *v20;
  CFArrayRef theArray;

  theArray = 0;
  if (!a3)
    return 4294963396;
  v6 = sub_10002DEA0(a1, a2);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v8 = CFGetTypeID(v6);
    if (v8 == sub_10002DE64())
    {
      v9 = sub_10015CE30(v7, 27, 0, &theArray);
LABEL_17:
      if (theArray)
      {
        Count = CFArrayGetCount(theArray);
        if (Count >= 1)
        {
          v14 = Count;
          for (i = 0; i != v14; ++i)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
            if (ValueAtIndex)
            {
              v17 = ValueAtIndex;
              if (CFDictionaryGetValue(ValueAtIndex, CFSTR("SUP_CHANNEL")))
                CFArrayAppendValue(a3, v17);
            }
          }
        }
        if (theArray)
          CFRelease(theArray);
      }
    }
    else
    {
      for (j = 6; ; --j)
      {
        v11 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 27, 0, &theArray);
        v9 = v11;
        if ((int)v11 <= 15)
        {
          if ((_DWORD)v11 != -3905)
            break;
        }
        else if ((_DWORD)v11 != 61 && (_DWORD)v11 != 16)
        {
          goto LABEL_30;
        }
        if (!j)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v11)
        goto LABEL_17;
LABEL_30:
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not read APPLE80211_IOC_SUPPORTED_CHANNELS err=%d", v9);
      objc_autoreleasePoolPop(v20);
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v19);
    return 0;
  }
  return v9;
}

uint64_t sub_100069F0C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 31) >> 5) & 1;
}

uint64_t sub_100069F18(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef v10;
  CFTypeRef v11;
  uint64_t v12;

  v10 = CFRetain(cf);
  v11 = CFRetain(a3);
  v12 = sub_10001C71C(a1, 3u, 0, (uint64_t)v10, (uint64_t)v11, a4, a5, 0, 0);
  if ((_DWORD)v12)
  {
    if (a3)
      CFRelease(a3);
    if (cf)
      CFRelease(cf);
  }
  return v12;
}

uint64_t sub_100069FBC(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  CFTypeRef v7;

  v7 = CFRetain(cf);
  return sub_10001C71C(a1, 4u, 0, (uint64_t)v7, a3, a4, 0, 0, 0);
}

uint64_t sub_10006A020(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef v10;
  CFTypeRef v11;
  uint64_t v12;

  v10 = CFRetain(cf);
  v11 = CFRetain(a3);
  v12 = sub_10001C71C(a1, 5u, 0, (uint64_t)v10, (uint64_t)v11, a4, a5, 0, 0);
  if ((_DWORD)v12)
  {
    if (a3)
      CFRelease(a3);
    if (cf)
      CFRelease(cf);
  }
  return v12;
}

uint64_t sub_10006A0C4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  void *v8;
  CFTypeRef v9;

  if (a1 && *(_QWORD *)(a1 + 4672))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: hostap never started. Invoking error callback.", "WiFiDeviceStopWiFiDirectGroup");
    objc_autoreleasePoolPop(v8);
    sub_10006A18C(a1, (uint64_t)cf, 4294963391);
  }
  v9 = CFRetain(cf);
  return sub_10001C71C(a1, 6u, 0, (uint64_t)v9, a3, a4, 0, 0, 0);
}

void sub_10006A18C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v8;
  void *v9;
  int i;
  int v11;
  void (*v13)(uint64_t, _QWORD, _QWORD, _QWORD);

  v6 = (_QWORD *)(a1 + 4672);
  v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 4672);
  v8 = *(_QWORD *)(a1 + 4680);
  v9 = objc_autoreleasePoolPush();
  if ((_DWORD)a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Error %d starting WiFi Direct Group, requesting stop...", a3);
    objc_autoreleasePoolPop(v9);
    for (i = 6; ; --i)
    {
      v11 = Apple80211Set(*(_QWORD *)(a1 + 16), 25, 2, 0, 0);
      if (v11 != -3905 && v11 != 61 && v11 != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Successfully started WiFi Direct Group");
    objc_autoreleasePoolPop(v9);
    *(_BYTE *)(a1 + 56) = 1;
  }
  *v6 = 0;
  v6[1] = 0;
  if (v7)
    v7(a1, a2, a3, v8);
  sub_100017CB0(a1);
  v13 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 4984);
  if (v13)
    v13(a1, 0, *(_QWORD *)(a1 + 4992), *(unsigned __int8 *)(a1 + 56));
}

void sub_10006A2DC(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;
  int i;
  uint64_t v7;
  uint64_t v8;
  void *v10;
  const char *v11;
  int v12;

  v12 = a2;
  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "hidden";
      if (!a2)
        v5 = "broadcast";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting host ap to %s mode", "WiFiDeviceSetMISHiddenOrBroadcastState", v5);
    }
    objc_autoreleasePoolPop(v4);
    for (i = 6; ; --i)
    {
      v7 = Apple80211Set(*(_QWORD *)(a1 + 16), 336, 0, &v12, 4);
      v8 = v7;
      if ((int)v7 <= 15)
      {
        if ((_DWORD)v7 != -3905)
          break;
      }
      else if ((_DWORD)v7 != 61 && (_DWORD)v7 != 16)
      {
        goto LABEL_18;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v7)
      return;
LABEL_18:
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (v12)
        v11 = "hidden";
      else
        v11 = "broadcast";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error setting host ap to %s mode, %d", v11, v8);
    }
    objc_autoreleasePoolPop(v10);
  }
}

void sub_10006A410(uint64_t a1, int a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v4;
  int i;
  uint64_t v6;
  uint64_t v7;
  CFNumberRef v9;
  CFNumberRef v10;
  int j;
  uint64_t v12;
  uint64_t v13;
  void *v15;
  void *v16;
  _BOOL4 valuePtr;

  valuePtr = a2 != 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v4 = Mutable;
    for (i = 6; ; --i)
    {
      v6 = Apple80211Get(*(_QWORD *)(a1 + 16), 347, 0, v4, 8);
      v7 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_29;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if ((_DWORD)v6)
    {
LABEL_29:
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to get SoftAP LowPower config: err %d", "WiFiDeviceSetLowPowerMISActive", v7);
      goto LABEL_33;
    }
    v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (!v9)
      goto LABEL_25;
    v10 = v9;
    CFDictionaryReplaceValue(v4, CFSTR("SOFTAP_LOWPOWER_PS_STATE"), v9);
    CFRelease(v10);
    for (j = 6; ; --j)
    {
      v12 = Apple80211Set(*(_QWORD *)(a1 + 16), 347, 0, v4, 8);
      v13 = v12;
      if ((int)v12 <= 15)
      {
        if ((_DWORD)v12 != -3905)
          break;
      }
      else if ((_DWORD)v12 != 61 && (_DWORD)v12 != 16)
      {
        goto LABEL_31;
      }
      if (!j)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v12)
      goto LABEL_25;
LABEL_31:
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set SoftAP LowPower config: err %d", "WiFiDeviceSetLowPowerMISActive", v13);
LABEL_33:
    objc_autoreleasePoolPop(v16);
LABEL_25:
    CFRelease(v4);
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceSetLowPowerMISActive");
    objc_autoreleasePoolPop(v15);
  }
}

CFMutableDictionaryRef sub_10006A634(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  int i;
  uint64_t v4;
  uint64_t v5;
  void *v8;
  uint64_t v9;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    for (i = 6; ; --i)
    {
      v4 = Apple80211Get(*(_QWORD *)(a1 + 16), 350, 0, Mutable, 8);
      v5 = v4;
      if ((int)v4 <= 15)
      {
        if ((_DWORD)v4 != -3905)
          break;
      }
      else if ((_DWORD)v4 != 61 && (_DWORD)v4 != 16)
      {
        goto LABEL_16;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v4)
      return Mutable;
LABEL_16:
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to get SoftAP LowPower Stats: err %d", "WiFiDeviceCopyHotspotLowPowerStats", v5);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceCopyHotspotLowPowerStats", v9);
  }
  objc_autoreleasePoolPop(v8);
  return Mutable;
}

void sub_10006A75C(uint64_t a1, char a2, __int16 a3, const void *a4)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  int i;
  uint64_t v13;
  uint64_t v14;
  void *v16;
  void *v17;
  __int16 v18;
  char valuePtr;

  valuePtr = a2;
  v18 = a3;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v7 = Mutable;
    v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &valuePtr);
    if (v8)
    {
      v9 = v8;
      CFDictionarySetValue(v7, CFSTR("HostApBatteryLevel"), v8);
      CFRelease(v9);
      if (!a4)
        goto LABEL_6;
      v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v18);
      if (v10)
      {
        v11 = v10;
        CFDictionarySetValue(v7, CFSTR("HostApWiFiNetworkFlag"), v10);
        CFRelease(v11);
        CFDictionarySetValue(v7, CFSTR("SSID_STR"), a4);
LABEL_6:
        for (i = 6; ; --i)
        {
          v13 = Apple80211Set(*(_QWORD *)(a1 + 16), 352, 0, v7, 8);
          v14 = v13;
          if ((int)v13 <= 15)
          {
            if ((_DWORD)v13 != -3905)
              break;
          }
          else if ((_DWORD)v13 != 61 && (_DWORD)v13 != 16)
          {
            goto LABEL_21;
          }
          if (!i)
            break;
          usleep(0x7A120u);
        }
        if (!(_DWORD)v13)
          goto LABEL_17;
LABEL_21:
        v17 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set SoftAP IE config: err %d", "WiFiDeviceSetWiFiNetworkInHotspotIe", v14);
        objc_autoreleasePoolPop(v17);
      }
    }
LABEL_17:
    CFRelease(v7);
    return;
  }
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceSetWiFiNetworkInHotspotIe");
  objc_autoreleasePoolPop(v16);
}

void sub_10006A940(uint64_t a1, char a2, const void *a3)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  int i;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  void *v14;
  char valuePtr;

  valuePtr = a2;
  if (a3)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v6 = Mutable;
      v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
      if (v7)
      {
        v8 = v7;
        CFDictionarySetValue(v6, CFSTR("HostSoftapNanCapabilityFlag"), v7);
        CFRelease(v8);
        CFDictionarySetValue(v6, CFSTR("HostSoftapNanServiceName"), a3);
        for (i = 6; ; --i)
        {
          v10 = Apple80211Set(*(_QWORD *)(a1 + 16), 403, 0, v6, 8);
          v11 = v10;
          if ((int)v10 <= 15)
          {
            if ((_DWORD)v10 != -3905)
              break;
          }
          else if ((_DWORD)v10 != 61 && (_DWORD)v10 != 16)
          {
            goto LABEL_20;
          }
          if (!i)
            break;
          usleep(0x7A120u);
        }
        if (!(_DWORD)v10)
          goto LABEL_15;
LABEL_20:
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set SoftAP NAN IE config: err %d", "WiFiDeviceSetNanCapabilityInHotspotIe", v11);
        objc_autoreleasePoolPop(v14);
      }
LABEL_15:
      CFRelease(v6);
    }
    else
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceSetNanCapabilityInHotspotIe");
      objc_autoreleasePoolPop(v13);
    }
  }
}

void sub_10006AAE0(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t v6;
  int i;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  char valuePtr;

  valuePtr = 1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v3 = Mutable;
    v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &valuePtr);
    if (v4)
    {
      v5 = v4;
      CFDictionarySetValue(v3, CFSTR("HostApEnabled"), v4);
      CFRelease(v5);
      v6 = *(_QWORD *)(a1 + 16);
      if (v6)
      {
        for (i = 6; ; --i)
        {
          v8 = Apple80211Set(v6, 420, 0, v3, 8);
          v9 = v8;
          if ((int)v8 <= 15)
          {
            if ((_DWORD)v8 != -3905)
              break;
          }
          else if ((_DWORD)v8 != 61 && (_DWORD)v8 != 16)
          {
            goto LABEL_17;
          }
          if (!i)
            break;
          usleep(0x7A120u);
          v6 = *(_QWORD *)(a1 + 16);
        }
        if (!(_DWORD)v8)
          goto LABEL_13;
LABEL_17:
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set SoftAP CSA config: err %d", "WiFiDeviceSetSoftApCsaNanPh", v9);
        objc_autoreleasePoolPop(v11);
      }
    }
LABEL_13:
    CFRelease(v3);
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceSetSoftApCsaNanPh");
    objc_autoreleasePoolPop(v10);
  }
}

void sub_10006AC74(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9, unsigned int a10)
{
  unsigned int v16;
  void (*v18)(uint64_t, const void *, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, unsigned int);
  void *v19;
  uint64_t v20;
  CFNumberRef v21;
  CFNumberRef v22;
  __CFDictionary *Mutable;
  __CFDictionary *v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t valuePtr;
  const void *v34;

  v16 = a10;
  v18 = *(void (**)(uint64_t, const void *, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, unsigned int))(a6 + 5496);
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s for ssid [%@] bssid [%@] rssi [%ld] ifname [%@] linkEvent %d", "WiFiDeviceSetNanNetworkAssociation", a2, a1, a3, a4, a10);
  objc_autoreleasePoolPop(v19);
  v20 = a8;
  if (a10 == 1)
  {
    valuePtr = 10;
    v34 = a4;
    if (sub_100073E14(a6))
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Internet Relay Interface Already Exists %@", "__WiFiDeviceCreateInternetRelayInterface", a4);
    }
    else
    {
      v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
      if (v21)
      {
        v22 = v21;
        Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          v24 = Mutable;
          CFDictionaryAddValue(Mutable, CFSTR("VIRT_IF_ROLE"), v22);
          v25 = a4;
          CFDictionaryAddValue(v24, CFSTR("VIRT_IF_NAME"), a4);
          v27 = sub_100073520(a6, v26, v24, &v34);
          v28 = objc_autoreleasePoolPush();
          if ((_DWORD)v27)
          {
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error creating %@  interface %d", v34, v27);
          }
          else if (qword_10026DD20)
          {
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Created %@ interface", "__WiFiDeviceCreateInternetRelayInterface", v34);
          }
          objc_autoreleasePoolPop(v28);
          CFRelease(v22);
          CFRelease(v24);
          v20 = a8;
          a4 = v25;
          v16 = a10;
        }
        else
        {
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null intfDict.", "__WiFiDeviceCreateInternetRelayInterface");
          objc_autoreleasePoolPop(v30);
          CFRelease(v22);
        }
        goto LABEL_13;
      }
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null role.", "__WiFiDeviceCreateInternetRelayInterface", v31);
    }
    objc_autoreleasePoolPop(v29);
  }
LABEL_13:
  if (v18)
    v18(a6, a4, a3, a5, *(_QWORD *)(a6 + 5504), a7, v20, a9, v16);
}

void sub_10006AF48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  void *v11;

  v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a6 + 5512);
  if (v10)
    v10(a6, a4, a3, a5, *(_QWORD *)(a6 + 5520));
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s for ssid [%@] bssid [%@] rssi [%ld] ifname [%@]", "WiFiDeviceSetNanNetworkTerminated", a2, a1, a3, a4);
  objc_autoreleasePoolPop(v11);
}

uint64_t sub_10006AFEC(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, const void *a6)
{
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  uint64_t v15;

  v12 = CFRetain(cf);
  if (a3)
  {
    v13 = CFRetain(a3);
    if (a6)
    {
LABEL_3:
      v14 = CFRetain(a6);
      goto LABEL_6;
    }
  }
  else
  {
    v13 = 0;
    if (a6)
      goto LABEL_3;
  }
  v14 = 0;
LABEL_6:
  v15 = sub_10001C71C(a1, 0xAu, 0, (uint64_t)v12, (uint64_t)v13, a4, a5, (uint64_t)v14, 0);
  if ((_DWORD)v15)
  {
    if (cf)
      CFRelease(cf);
    if (a3)
      CFRelease(a3);
    if (a6)
      CFRelease(a6);
  }
  return v15;
}

uint64_t sub_10006B0CC(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  void *v11;
  int v12;
  id v13;
  const __CFDictionary *v14;
  const void *Value;
  id v16;
  id v17;
  id v18;
  double Current;
  double v20;
  NSString *v21;
  const __CFString *v22;
  NSString *v23;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  const void *v26;
  const void *v27;
  CFTypeRef v28;
  CFTypeRef v29;
  uint64_t v30;
  id v32;
  id v33;
  uint64_t v34;
  CFIndex v35;
  unint64_t v36;

  v35 = 72;
  v36 = 0xAAAAAAAAAAAAAAAALL;
  v34 = 0;
  if (!sub_10001E3EC(*(_QWORD *)(a1 + 176), &v36, &v35, &v34)
    && *(_BYTE *)(v36 + 56) == 1
    && *(_DWORD *)v36 == 12)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Flushing out pending ranging request...", "WiFiDeviceStopAwdl");
    objc_autoreleasePoolPop(v10);
    sub_10006B430((uint64_t *)a1, (uint64_t)a2, 0, 4294963365);
    sub_10006BC88(a1, (uint64_t)a2, 0);
  }
  v11 = objc_autoreleasePoolPush();
  v12 = MGGetBoolAnswer(CFSTR("InternalBuild"));
  v13 = -[WiFiUsageMonitor lastRangingSessionMetric](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "lastRangingSessionMetric");
  v14 = *(const __CFDictionary **)(a1 + 4704);
  if (v14)
  {
    Value = CFDictionaryGetValue(v14, CFSTR("AWDL_INFO_ASSISTED_DISCOVERY_METRIC"));
    if (v12)
    {
      if (v13 && Value)
      {
        v33 = objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("LinkLatency"));
        v16 = objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("RangingLatency"));
        v17 = objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("MeasurementStatus"));
        v18 = objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("MeasurementFlags"));
        Current = CFAbsoluteTimeGetCurrent();
        v20 = *(double *)(a1 + 4720);
        if ((objc_msgSend(v18, "unsignedIntegerValue") & 0x8000) != 0)
          v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Ranging Failure (Corrupted Sample)"));
        else
          v21 = 0;
        if (objc_msgSend(v17, "integerValue"))
        {
          v32 = objc_msgSend(v17, "integerValue");
          v22 = CFSTR("Ranging Failure (%d)");
        }
        else
        {
          if ((unint64_t)objc_msgSend(v16, "unsignedIntegerValue") < 0x3E9)
          {
            if ((unint64_t)objc_msgSend(v33, "unsignedIntegerValue") < 0x3E9)
            {
              if (*(double *)(a1 + 4720) == 0.0 || Current - v20 <= 4.0)
              {
LABEL_20:
                if (v21)
                {
                  v24 = (const __CFDictionary *)+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
                  if (v24)
                  {
                    v25 = v24;
                    -[__CFDictionary setObject:forKey:](v24, "setObject:forKey:", v21, CFSTR("CHIP_RESET_TRIGGER"));
                    sub_10006BD58(a1, v25);
                  }
                }
                goto LABEL_23;
              }
              v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Slow PAU Attempt (%ds)"), (int)(Current - v20));
            }
            else
            {
              v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Slow PAU Bringup (%dms)"), objc_msgSend(v33, "unsignedIntegerValue"));
            }
LABEL_19:
            v21 = v23;
            goto LABEL_20;
          }
          v32 = objc_msgSend(v16, "unsignedIntegerValue");
          v22 = CFSTR("Slow PAU Ranging (%dms)");
        }
        v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", v22, v32);
        goto LABEL_19;
      }
    }
  }
LABEL_23:
  objc_autoreleasePoolPop(v11);
  v26 = *(const void **)(a1 + 4704);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 4704) = 0;
  }
  v27 = *(const void **)(a1 + 4712);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a1 + 4712) = 0;
  }
  *(_QWORD *)(a1 + 4720) = 0;
  v28 = CFRetain(a2);
  if (a3)
    v29 = CFRetain(a3);
  else
    v29 = 0;
  v30 = sub_10001C71C(a1, 0xBu, 0, (uint64_t)v28, (uint64_t)v29, a4, a5, 0, 0);
  if ((_DWORD)v30)
  {
    if (a2)
      CFRelease(a2);
    if (a3)
      CFRelease(a3);
  }
  return v30;
}

void sub_10006B430(uint64_t *a1, uint64_t a2, const __CFArray *a3, uint64_t a4)
{
  uint64_t *v7;
  void *v8;
  void *v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  __CFArray *v13;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v15;
  const void *Value;
  const void *v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  void *v21;
  const __CFArray *v22;
  __CFDictionary *MutableCopy;
  __CFArray *Mutable;
  CFIndex v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  const __CFNumber *v38;
  const __CFNumber *v39;
  const __CFNumber *v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  WiFiUsageMonitor *v44;
  CFIndex Count;
  __int16 v46;
  CFNumberRef v47;
  const __CFDictionary *v48;
  const __CFNumber *v49;
  CFNumberRef v50;
  CFNumberRef v51;
  void *v52;
  WiFiUsageMonitor *v53;
  void (*v54)(uint64_t *, uint64_t, __CFArray *, uint64_t);
  uint64_t v55;
  _QWORD *v56;
  void (*v57)(uint64_t *, uint64_t, __CFArray *, uint64_t, uint64_t);
  uint64_t v58;
  const __CFArray *v59;
  uint64_t *v60;
  CFIndex v61;
  __CFArray *v62;
  unsigned __int16 v63;
  unsigned int v64;
  int v65;
  int v66;
  unsigned int v67;
  __int16 v68;
  __int16 v69;
  unsigned int v70;
  __int16 v71;
  __int16 v72;
  __int16 v73;
  char valuePtr;
  uint64_t v75;
  CFIndex v76;
  unint64_t v77;
  _OWORD v78[4];
  _DWORD v79[18];

  v7 = a1;
  v57 = (void (*)(uint64_t *, uint64_t, __CFArray *, uint64_t, uint64_t))a1[643];
  v55 = a1[644];
  v75 = 0;
  v76 = 72;
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Completed APPLE80211_IOC_RANGING_START on %@ (%d)", a2, a4);
  objc_autoreleasePoolPop(v8);
  if ((a4 + 3933) <= 1 && !v7[588])
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: ranging error while AWDL session not requested. Overriding error code to %d", "__WiFiDeviceProcessRangingDoneEvent", 4294963368);
    objc_autoreleasePoolPop(v9);
    a4 = 4294963368;
  }
  v58 = a4;
  v56 = v7 + 643;
  v77 = 0xAAAAAAAAAAAAAAAALL;
  if (a3 && (CFArrayGetCount(a3) > 4 ? (v10 = 4) : (v10 = CFArrayGetCount(a3)), v10 >= 1))
  {
    v11 = v10;
    v12 = 0;
    v13 = 0;
    v59 = a3;
    v60 = v7;
    v61 = v10;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v12);
      if (ValueAtIndex)
      {
        v15 = ValueAtIndex;
        v62 = v13;
        Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("STATION_MAC"));
        v17 = CFDictionaryGetValue(v15, CFSTR("RANGING_DISTANCE"));
        valuePtr = 0;
        v73 = 0;
        v72 = 0;
        v18 = (const __CFNumber *)CFDictionaryGetValue(v15, CFSTR("RANGING_VALID_COUNT"));
        if (v18)
          CFNumberGetValue(v18, kCFNumberSInt8Type, &valuePtr);
        v19 = (const __CFNumber *)CFDictionaryGetValue(v15, CFSTR("RANGING_STATUS"));
        if (v19)
          CFNumberGetValue(v19, kCFNumberSInt16Type, &v72);
        v20 = (const __CFNumber *)CFDictionaryGetValue(v15, CFSTR("RANGING_FLAGS"));
        if (v20)
          CFNumberGetValue(v20, kCFNumberSInt16Type, &v73);
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: peer %@ status %d flags 0x%x distance %@m validSamples %d", "__WiFiDeviceProcessRangingDoneEvent", Value, v72, v73, v17, valuePtr);
        objc_autoreleasePoolPop(v21);
        v22 = (const __CFArray *)CFDictionaryGetValue(v15, CFSTR("RANGING_RESULTS"));
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v15);
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (v22 && CFArrayGetCount(v22) >= 1)
        {
          v25 = 0;
          do
          {
            v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v25);
            if (v26)
            {
              v27 = v26;
              v71 = 0;
              v70 = 0;
              v69 = 0;
              v68 = 0;
              v66 = 0;
              v67 = 0;
              v64 = 0;
              v65 = 0;
              v63 = 0;
              v28 = (const __CFNumber *)CFDictionaryGetValue(v26, CFSTR("RANGING_RTT_STATUS"));
              if (v28)
                CFNumberGetValue(v28, kCFNumberSInt16Type, &v66);
              v29 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_RSSI"));
              if (v29)
                CFNumberGetValue(v29, kCFNumberSInt16Type, (char *)&v65 + 2);
              v30 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_RTT_FLAGS"));
              if (v30)
                CFNumberGetValue(v30, kCFNumberSInt16Type, &v65);
              v31 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_RTT"));
              if (v31)
                CFNumberGetValue(v31, kCFNumberSInt32Type, &v64);
              v32 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_CHANNEL"));
              if (v32)
                CFNumberGetValue(v32, kCFNumberSInt16Type, &v63);
              v33 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_PHY_ERROR"));
              if (v33)
                CFNumberGetValue(v33, kCFNumberSInt32Type, &v70);
              v34 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_CORE_ID"));
              if (v34)
                CFNumberGetValue(v34, kCFNumberSInt8Type, (char *)&v71 + 1);
              v35 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_BER"));
              if (v35)
                CFNumberGetValue(v35, kCFNumberSInt8Type, &v71);
              v36 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_SNR"));
              if (v36)
                CFNumberGetValue(v36, kCFNumberSInt16Type, &v69);
              v37 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_PEER_CORE_ID"));
              if (v37)
                CFNumberGetValue(v37, kCFNumberSInt8Type, (char *)&v68 + 1);
              v38 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_PEER_PHY_ERROR"));
              if (v38)
                CFNumberGetValue(v38, kCFNumberSInt32Type, &v67);
              v39 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_PEER_BER"));
              if (v39)
                CFNumberGetValue(v39, kCFNumberSInt8Type, &v68);
              v40 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("RANGING_PEER_SNR"));
              if (v40)
                CFNumberGetValue(v40, kCFNumberSInt16Type, (char *)&v66 + 2);
              memset(v79, 0, 64);
              memset(v78, 0, sizeof(v78));
              Apple80211GetRangingPhyErrorString(v70, v79, 64);
              Apple80211GetRangingPhyErrorString(v67, v78, 64);
              v41 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "RTT[%ld]: Status=%d, RTT=%d RSSI=%d SNR=%d Core=%d BitFlip=%d PHYErr=%d(%s) Peer-SNR=%d Peer-BitFlip=%d Peer-PHYErr=%d(%s)", v25, (__int16)v66, v64, SHIWORD(v65), v69, SHIBYTE(v71), (char)v71, v70, v79, SHIWORD(v66), (char)v68, v67, v78);
              objc_autoreleasePoolPop(v41);
              v42 = v67;
              v43 = v67 & 0xFFFFFD13;
              v67 &= 0xFFFFFD13;
              if ((char)v68 < 0)
              {
                v43 = v42 & 0xFFFFFD03;
                v67 = v42 & 0xFFFFFD03;
              }
              if (!(_WORD)v66
                && !v43
                && (v63 - 1 > 0xC || (char)v71 <= 10)
                && (v63 - 36 >= 0x1D && v63 - 100 >= 0x2D && v63 - 142 > 0x17
                 || (char)v71 <= 40))
              {
                CFArrayAppendValue(Mutable, v27);
              }
              v44 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
              -[WiFiUsageMonitor addRangingRttSampleWithRssi:rtt:snr:flags:channel:coreId:bitErrorRate:phyError:andPeerSnr:andPeerCoreId:andPeerBitErrorRate:andPeerPhyError:](v44, "addRangingRttSampleWithRssi:rtt:snr:flags:channel:coreId:bitErrorRate:phyError:andPeerSnr:andPeerCoreId:andPeerBitErrorRate:andPeerPhyError:", SHIWORD(v65), (int)v64, v69, (__int16)v65, (__int16)v63, SHIBYTE(v71), (char)v71, (int)v70, SHIWORD(v66), SHIBYTE(v68), (char)v68, (int)v67);
            }
            Count = CFArrayGetCount(v22);
            if ((unint64_t)v25 > 7)
              break;
            ++v25;
          }
          while (v25 < Count);
        }
        LOWORD(v70) = -21846;
        if (Mutable)
          v46 = CFArrayGetCount(Mutable);
        else
          v46 = 0;
        v7 = v60;
        LOWORD(v70) = v46;
        v13 = v62;
        v47 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v70);
        CFDictionarySetValue(MutableCopy, CFSTR("RANGING_VALID_COUNT"), v47);
        if (v47)
          CFRelease(v47);
        v48 = (const __CFDictionary *)v60[588];
        v11 = v61;
        if (v48)
        {
          v79[0] = 0;
          v49 = (const __CFNumber *)CFDictionaryGetValue(v48, CFSTR("AWDL_INFO_SUPPORTED_CHANNEL_FLAGS"));
          if (v49)
            CFNumberGetValue(v49, kCFNumberSInt32Type, v79);
          if (v79[0])
          {
            LODWORD(v78[0]) = HIWORD(v79[0]);
            v50 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v78);
            if (v50)
            {
              v51 = v50;
              v52 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting ranging feature flag to %@", "__WiFiDeviceProcessRangingDoneEvent", v51);
              objc_autoreleasePoolPop(v52);
              CFDictionarySetValue(MutableCopy, CFSTR("RANGING_FEATURES"), v51);
              CFRelease(v51);
              v13 = v62;
            }
            v11 = v61;
          }
        }
        CFDictionarySetValue(MutableCopy, CFSTR("RANGING_RESULTS"), Mutable);
        if (v13 || (v13 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) != 0)
          CFArrayAppendValue(v13, MutableCopy);
        v53 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
        -[WiFiUsageMonitor rangingCompletedWithValidCount:resultStatus:resultFlags:](v53, "rangingCompletedWithValidCount:resultStatus:resultFlags:", valuePtr, (int)v58, v73);
        if (MutableCopy)
          CFRelease(MutableCopy);
        if (Mutable)
          CFRelease(Mutable);
        a3 = v59;
      }
      ++v12;
    }
    while (v12 < v11);
  }
  else
  {
    v13 = 0;
  }
  v54 = (void (*)(uint64_t *, uint64_t, __CFArray *, uint64_t))v7[645];
  if (v54)
    v54(v7, a2, v13, v7[646]);
  *v56 = 0;
  v56[1] = 0;
  if (v57)
    v57(v7, a2, v13, v58, v55);
  if (!sub_10001E3EC(v7[22], &v77, &v76, &v75) && *(_BYTE *)(v77 + 56) == 1 && *(_DWORD *)v77 == 12)
    sub_100017CB0((uint64_t)v7);
  if (v13)
    CFRelease(v13);
}

uint64_t sub_10006BC88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int i;
  uint64_t v8;
  void *v10;

  v3 = 4294963396;
  if (a1 && a2)
  {
    for (i = 6; ; --i)
    {
      v8 = Apple80211RangingStopAsync(*(_QWORD *)(a1 + 16), a3, 0.0);
      v3 = v8;
      if ((_DWORD)v8 != -3905 && (_DWORD)v8 != 61 && (_DWORD)v8 != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, error %d", "WiFiDeviceAbortRanging", a2, v3);
    objc_autoreleasePoolPop(v10);
  }
  return v3;
}

void sub_10006BD58(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  int i;
  uint64_t v6;
  uint64_t v7;
  id v9;
  const __CFString *Value;
  id v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  _QWORD v16[4];

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (a2)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Calling ChipREset", "WiFiDeviceChipReset");
      objc_autoreleasePoolPop(v4);
      for (i = 6; ; --i)
      {
        v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 239, 0, a2, 8);
        v7 = v6;
        if ((_DWORD)v6 != -3905 && (_DWORD)v6 != 61 && (_DWORD)v6 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (_os_feature_enabled_impl("WiFiPolicy", "HND_AnalyticsProcessor"))
      {
        v9 = objc_alloc_init((Class)NSMutableDictionary);
        if (CFDictionaryGetValue(a2, CFSTR("CHIP_RESET_TRIGGER")))
          Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("CHIP_RESET_TRIGGER"));
        else
          Value = CFSTR("UnknownReason");
        v13 = *((_QWORD *)&WADeviceAnalyticsRecoveryInfo + 1);
        v16[0] = +[NSDate date](NSDate, "date");
        v16[1] = CFSTR("APPLE80211_IOC_RESET_CHIP");
        v14 = *((_OWORD *)&WADeviceAnalyticsRecoveryInfo + 2);
        v16[2] = Value;
        v15 = *((_QWORD *)&WADeviceAnalyticsRecoveryInfo + 6);
        v16[3] = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v7);
        objc_msgSend(v9, "addEntriesFromDictionary:", +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v16, &v13, 4));
        v11 = +[AnalyticsProcessor sharedAnalyticsProcessor](AnalyticsProcessor, "sharedAnalyticsProcessor");
        objc_msgSend(v11, "processWAMessageMetric:data:", WADeviceAnalyticsRecoveryInfo, v9);

      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: triggerReasonInfo is NULL!", "WiFiDeviceChipReset");
      objc_autoreleasePoolPop(v4);
    }
  }
  else
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceRef is NULL!", "WiFiDeviceChipReset");
    objc_autoreleasePoolPop(v12);
  }
}

uint64_t sub_10006BFD4(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int i;
  int PowerState;
  void *v13;
  int j;
  int v15;
  const __CFNumber *v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  void *v21;
  int k;
  int v23;
  const __CFArray *v25;
  const void **v26;
  NSObject *v27;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  void *value;
  CFDictionaryRef theDict;
  CFRange v35;

  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceOpen");
  objc_autoreleasePoolPop(v5);
  if (*((_BYTE *)a1 + 52))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: already open", "WiFiDeviceOpen");
LABEL_59:
    objc_autoreleasePoolPop(v6);
    return 1;
  }
  *((_BYTE *)a1 + 52) = 1;
  v7 = a1 + 2;
  v8 = Apple80211Open(a1 + 2);
  if ((_DWORD)v8)
  {
    v29 = v8;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Apple80211Open failed, %d", "WiFiDeviceOpen", v29);
  }
  else
  {
    v9 = Apple80211BindToInterfaceWithParams(a1[2], a1[14], sub_10006C3E8, a1, a3);
    if (!(_DWORD)v9)
    {
      for (i = 6; ; --i)
      {
        PowerState = Apple80211GetPowerState(*v7, a1 + 6);
        if (PowerState != -3905 && PowerState != 61 && PowerState != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device power state = %s", sub_1000648F0(*((_DWORD *)a1 + 12)));
      objc_autoreleasePoolPop(v13);
      theDict = 0;
      for (j = 6; ; --j)
      {
        v15 = Apple80211CopyValue(*v7, 106, 0, &theDict);
        if (v15 != -3905 && v15 != 61 && v15 != 16)
          break;
        if (!j)
          break;
        usleep(0x7A120u);
      }
      if (theDict)
      {
        v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RSSI_MIN"));
        if (v17)
          CFNumberGetValue(v17, kCFNumberCFIndexType, a1 + 30);
        v18 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RSSI_MAX"));
        if (v18)
          CFNumberGetValue(v18, kCFNumberCFIndexType, a1 + 31);
        v19 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RSSI_THRESHOLD"));
        if (v19)
        {
          v20 = v19;
          CFNumberGetValue(v19, kCFNumberCFIndexType, a1 + 32);
          CFDictionarySetValue((CFMutableDictionaryRef)a1[15], CFSTR("SignalStrengthThreshold"), v20);
        }
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device RSSI bounds (%ld, %ld) with treshold (%ld)", a1[30], a1[31], a1[32]);
        objc_autoreleasePoolPop(v21);
        if (theDict)
        {
          CFRelease(theDict);
          theDict = 0;
        }
      }
      value = 0;
      for (k = 6; ; --k)
      {
        v23 = Apple80211CopyValue(*v7, 12, 0, &value);
        if (v23 != -3905 && v23 != 61 && v23 != 16)
          break;
        if (!k)
          break;
        usleep(0x7A120u);
      }
      if (value)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)a1[15], CFSTR("deviceCapabilities"), value);
        v25 = (const __CFArray *)value;
        v35.length = CFArrayGetCount((CFArrayRef)value);
        v35.location = 0;
        CFArrayApplyFunction(v25, v35, (CFArrayApplierFunction)sub_10006C4CC, (char *)a1 + 28);
        if (value)
        {
          CFRelease(value);
          value = 0;
        }
        if ((*((_BYTE *)a1 + 30) & 0x10) != 0)
          v26 = (const void **)&kCFBooleanTrue;
        else
          v26 = (const void **)&kCFBooleanFalse;
        CFDictionarySetValue((CFMutableDictionaryRef)a1[15], CFSTR("deviceSupportsWoW"), *v26);
      }
      sub_100017A68((uint64_t)a1, (const void *)a1[14], (__CFArray *)a1[707]);
      sub_10006C53C(a1);
      v27 = a1[8];
      if (v27)
        sub_10006C7AC((uint64_t)a1, v27);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceOpen");
      goto LABEL_59;
    }
    v31 = v9;
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Apple80211BindToInterface failed, %d", "WiFiDeviceOpen", v31);
  }
  objc_autoreleasePoolPop(v30);
  v32 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: found", "WiFiDeviceOpen");
  objc_autoreleasePoolPop(v32);
  return 0;
}

void sub_10006C3E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  void *v6;
  void (*v7)(_QWORD *, _QWORD, _QWORD);
  void *v8;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s:%d\n", "__WiFiDeviceServiceNotificationCallback", 4108);
  objc_autoreleasePoolPop(v6);
  if (a5)
  {
    sub_10006FE54((uint64_t)a5, 0);
    v7 = (void (*)(_QWORD *, _QWORD, _QWORD))a5[544];
    if (v7)
      v7(a5, a5[14], a5[545]);
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Exit: %s:%d\n", "__WiFiDeviceServiceNotificationCallback", 4121);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d\n", "__WiFiDeviceServiceNotificationCallback", 4111);
  }
  objc_autoreleasePoolPop(v8);
}

const __CFNumber *sub_10006C4CC(const __CFNumber *result, uint64_t a2)
{
  unsigned int valuePtr;

  if (result)
  {
    valuePtr = -1431655766;
    result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
    if (valuePtr <= 0x92)
      *(_BYTE *)(a2 + ((unint64_t)valuePtr >> 3)) |= 1 << (valuePtr & 7);
  }
  return result;
}

uint64_t sub_10006C530(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 30) >> 4) & 1;
}

CFMutableArrayRef sub_10006C53C(_QWORD *a1)
{
  const void *v2;
  CFMutableArrayRef result;
  __CFArray *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  uint64_t v9;
  int j;
  uint64_t v11;
  CFIndex Count;
  CFIndex v14;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  CFArrayRef theArray;

  v2 = (const void *)a1[708];
  if (v2)
  {
    CFRelease(v2);
    a1[708] = 0;
  }
  result = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  a1[708] = result;
  if (result)
  {
    v4 = result;
    v5 = (const void *)a1[14];
    theArray = 0;
    v6 = sub_10002DEA0((uint64_t)a1, v5);
    if (v6)
    {
      v7 = (uint64_t)v6;
      v8 = CFGetTypeID(v6);
      if (v8 == sub_10002DE64())
      {
        v9 = sub_10015CE30(v7, 207, 0, &theArray);
LABEL_18:
        if (theArray)
        {
          Count = CFArrayGetCount(theArray);
          if (Count >= 1)
          {
            v14 = Count;
            for (i = 0; i != v14; ++i)
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
              if (ValueAtIndex)
              {
                v17 = ValueAtIndex;
                if (CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNELINFO_CH_NUM")))
                  CFArrayAppendValue(v4, v17);
              }
            }
          }
          if (theArray)
          {
            CFRelease(theArray);
            theArray = 0;
          }
        }
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: APPLE80211_IOC_CHANNELS_INFO returned %ld channels in list", "WiFiDeviceCopyChannelInfo", CFArrayGetCount(v4));
      }
      else
      {
        for (j = 6; ; --j)
        {
          v11 = Apple80211CopyValue(a1[2], 207, 0, &theArray);
          v9 = v11;
          if ((int)v11 <= 15)
          {
            if ((_DWORD)v11 != -3905)
              break;
          }
          else if ((_DWORD)v11 != 61 && (_DWORD)v11 != 16)
          {
            goto LABEL_38;
          }
          if (!j)
            break;
          usleep(0x7A120u);
        }
        if (!(_DWORD)v11)
          goto LABEL_18;
LABEL_38:
        v18 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not read APPLE80211_IOC_CHANNELS_INFO err=%d", v9, v21);
      }
      objc_autoreleasePoolPop(v18);
      if ((_DWORD)v9)
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device return error %d for supported channels\n", "WiFiDeviceUpdateChannelInfo", v9);
        objc_autoreleasePoolPop(v19);
        return 0;
      }
    }
    else
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", v5);
      objc_autoreleasePoolPop(v20);
    }
    return (CFMutableArrayRef)1;
  }
  return result;
}

void sub_10006C7AC(uint64_t a1, NSObject *a2)
{
  void *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  SCDynamicStoreRef v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  __CFDictionary *Mutable;
  const __CFDictionary *v19;
  const void *v20;
  const __CFDictionary *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  __CFDictionary *v24;
  __CFDictionary *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  __CFDictionary *v29;
  unsigned int (*v30)(uint64_t, _QWORD);
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  SCDynamicStoreContext context;
  uint64_t valuePtr;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceScheduleWithQueue");
  objc_autoreleasePoolPop(v4);
  *(_QWORD *)(a1 + 64) = a2;
  if (!*(_BYTE *)(a1 + 52))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: already open", "WiFiDeviceScheduleWithQueue");
    goto LABEL_98;
  }
  v5 = *(NSObject **)(a1 + 72);
  if (v5
    || (v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2),
        (*(_QWORD *)(a1 + 72) = v5) != 0))
  {
    dispatch_set_context(v5, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 72), (dispatch_function_t)sub_10006EC30);
    dispatch_activate(*(dispatch_object_t *)(a1 + 72));
  }
  v6 = *(NSObject **)(a1 + 80);
  if (v6
    || (v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2),
        (*(_QWORD *)(a1 + 80) = v6) != 0))
  {
    dispatch_set_context(v6, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 80), (dispatch_function_t)sub_10006ECDC);
    dispatch_activate(*(dispatch_object_t *)(a1 + 80));
  }
  v7 = *(NSObject **)(a1 + 88);
  if (v7
    || (v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2),
        (*(_QWORD *)(a1 + 88) = v7) != 0))
  {
    dispatch_set_context(v7, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 88), (dispatch_function_t)sub_10006EDA8);
    dispatch_activate(*(dispatch_object_t *)(a1 + 88));
  }
  v8 = *(NSObject **)(a1 + 5712);
  if (v8
    || (v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2),
        (*(_QWORD *)(a1 + 5712) = v8) != 0))
  {
    dispatch_set_context(v8, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 5712), (dispatch_function_t)sub_1000309B0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 5712));
  }
  v9 = *(NSObject **)(a1 + 5768);
  if (v9
    || (v9 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2),
        (*(_QWORD *)(a1 + 5768) = v9) != 0))
  {
    dispatch_set_context(v9, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 5768), (dispatch_function_t)sub_10006EDE8);
    dispatch_activate(*(dispatch_object_t *)(a1 + 5768));
  }
  if (!*(_DWORD *)(a1 + 104)
    && IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 96), *(_DWORD *)(a1 + 24), "IOGeneralInterest", (IOServiceInterestCallback)nullsub_4, (void *)a1, (io_object_t *)(a1 + 104)))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: IOServiceAddInterestNotification failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 96), *(dispatch_queue_t *)(a1 + 64));
  if (Apple80211EventMonitoringInit2(*(_QWORD *)(a1 + 16), sub_10001DACC, a1, *(_QWORD *)(a1 + 64)))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Unable to init event monitoring", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 9))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ASSOC_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 10))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SCAN_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 1))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_POWER_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 2))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SSID_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 3))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BSSID_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 32))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ROAMED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 80))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ROAM_STATUS failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 76))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SUPPLICANT_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 137))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ROAM_SCAN_START failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 138))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ROAM_SCAN_END failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 139))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ROAM_PREP failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 4))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_LINK_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 5))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_MIC_ERROR_UCAST failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 6))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_MIC_ERROR_MCAST failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 7))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_INT_MIT_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 8))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_MODE_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 14))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_DECRYPTION_FAILURE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 31))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BGSCAN_NET_DISCOVERED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 30))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_WIFI_DIRECT_GROUP_STARTED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 12))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_STA_ARRIVE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 13))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_STA_LEAVE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 35))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BLACKLIST_NETWORK failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 36))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_RESUME_SCAN failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 37))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BGSCAN_SUSPENDED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 38))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BGSCAN_RESUMED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 39))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_RSSI_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 169))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_LQM_TX_STATS failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 60))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_HOMECHAN_QUAL_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 145))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_WEIGHT_AVG_LQM_UPDATE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 190))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BT_COEX_MODE_STATS_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 192))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SIB_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 191))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_LINK_DOWN_DEBOUNCE_FAILED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 156))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_REALTIME_SESSION_NOTIFICATION failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 218))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_OBSS_MIT_NOTIFICATION failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 55))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_DRIVER_AVAILABLE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 57))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_GAS_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 63))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BGSCAN_CACHED_NETWORK_AVAILABLE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 90))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SCAN_BACKOFF_REPORT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 79))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_DUMP_LOGS failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 83))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_RANGING_MEASUREMENT_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 89))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_TX_FAIL_HISTORY_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 92))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_TX_INHIBIT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 93))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_LOCAL_THERMAL_MITIGATION failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 140))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BSS_STEERING_REQUEST_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 141))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SOFTAP_LPM failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 148))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_WIFI_NETWORK_INFO_UPDATE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 143))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ACTION_FRAME_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 150))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_DPS failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 151))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SLOW_WIFI failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 75))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_PRUNE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 164))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SLOWWIFI_PROBE_TRIGGER failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 165))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SLOWWIFI_USERINPUT_TRIGGER failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 11))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_COUNTRY_CODE_CHANGED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 176))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_LQM_CRASHTRACER failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 189))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_TE_CRITICAL_TRAFFIC_IND failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 180))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_BEACON_CACHE_UPDATED failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 196))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_TRIGGER_TTR failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (_os_feature_enabled_impl("WiFiManager", "Sensing")
    && Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 193))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SENSING_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 199))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_COLOCATED_CACHE_EVENT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 210))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_P2P_PEER_COUNTRY_CODE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 217))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_ENV_BSS_INFO failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 239))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_NDD_REPORT failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 238))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_NDD_DONE failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_267;
  }
  if (Apple80211StartMonitoringEvent(*(_QWORD *)(a1 + 16), 240))
  {
    v32 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: monitoring APPLE80211_M_SCAN_FWD_STATS_EVENT failed", "WiFiDeviceScheduleWithQueue");
LABEL_267:
    objc_autoreleasePoolPop(v32);
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: found", "WiFiDeviceScheduleWithQueue");
LABEL_98:
    objc_autoreleasePoolPop(v13);
    return;
  }
  sub_100147764(*(_QWORD *)(a1 + 144), (uint64_t)sub_10006EDF8, a1);
  sub_100147770(*(_QWORD *)(a1 + 144), *(NSObject **)(a1 + 64));
  if (*(_QWORD *)(a1 + 152))
    goto LABEL_102;
  context.version = 0;
  memset(&context.retain, 0, 24);
  context.info = (void *)a1;
  v10 = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("WiFiDevice"), (SCDynamicStoreCallBack)sub_10006EE40, &context);
  *(_QWORD *)(a1 + 152) = v10;
  if (!v10)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SCDynamicStoreCreate failed", "WiFiDeviceScheduleWithQueue");
    goto LABEL_101;
  }
  sub_10006F24C(a1);
  if (!SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 152), *(dispatch_queue_t *)(a1 + 64)))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error setting dynamic store queue.", "WiFiDeviceScheduleWithQueue");
    objc_autoreleasePoolPop(v11);
  }
  if (!SCDynamicStoreSetDisconnectCallBack(*(_QWORD *)(a1 + 152), sub_10006F580))
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error subscribing to the dynamic store disconnect event.", "WiFiDeviceScheduleWithQueue");
LABEL_101:
    objc_autoreleasePoolPop(v12);
  }
LABEL_102:
  v14 = *(void **)(a1 + 176);
  if (v14)
    sub_10015493C(v14, *(dispatch_queue_t *)(a1 + 64), (void (__cdecl *)(void *))sub_10006F5E4, (void *)a1);
  sub_10006F7A4(a1);
  if ((*(_BYTE *)(a1 + 32) & 1) != 0)
  {
    context.version = 6;
    v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &context);
    if (v16)
    {
      v17 = v16;
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v19 = Mutable;
        CFDictionaryAddValue(Mutable, CFSTR("VIRT_IF_ROLE"), v17);
        v20 = *(const void **)(a1 + 5976);
        if (v20)
        {
          CFRelease(v20);
          *(_QWORD *)(a1 + 5976) = 0;
        }
        *(_QWORD *)(a1 + 5976) = sub_10015BA3C(a1, (uint64_t)kCFAllocatorDefault, v19, *(_QWORD *)(a1 + 64), (void (*)(uint64_t, _OWORD *))sub_10007F624);
        CFRelease(v17);
        v21 = v19;
      }
      else
      {
        v33 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null intfDict.", "__WiFiDeviceCreateAwdlInterface");
        objc_autoreleasePoolPop(v33);
        v21 = v17;
      }
      CFRelease(v21);
      goto LABEL_114;
    }
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null role.", "__WiFiDeviceCreateAwdlInterface");
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL is not supported", "WiFiDeviceScheduleWithQueue");
  }
  objc_autoreleasePoolPop(v15);
LABEL_114:
  if (*(char *)(a1 + 28) < 0)
  {
    context.version = (CFIndex)CFSTR("ap1");
    valuePtr = 7;
    v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
    if (v22)
    {
      v23 = v22;
      v24 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v24)
      {
        v25 = v24;
        CFDictionaryAddValue(v24, CFSTR("VIRT_IF_ROLE"), v23);
        CFDictionaryAddValue(v25, CFSTR("VIRT_IF_NAME"), CFSTR("ap1"));
        v27 = sub_100073520(a1, v26, v25, &context);
        v28 = objc_autoreleasePoolPush();
        if ((_DWORD)v27)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error creating %@  interface %d", context.version, v27);
        }
        else if (qword_10026DD20)
        {
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Created %@ interface", "__WiFiDeviceCreateHostApInterface", context.version);
        }
        objc_autoreleasePoolPop(v28);
        CFRelease(v23);
        v29 = v25;
      }
      else
      {
        v35 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null intfDict.", "__WiFiDeviceCreateHostApInterface");
        objc_autoreleasePoolPop(v35);
        v29 = v23;
      }
      CFRelease(v29);
    }
    else
    {
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null role.", "__WiFiDeviceCreateHostApInterface");
      objc_autoreleasePoolPop(v34);
    }
  }
  sub_10006FA40(a1);
  *(_BYTE *)(a1 + 5904) = 1;
  v30 = *(unsigned int (**)(uint64_t, _QWORD))(a1 + 4968);
  if (v30 && v30(a1, *(_QWORD *)(a1 + 4976)))
    sub_10006FE54(a1, 1);
  v31 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceScheduleWithQueue");
  objc_autoreleasePoolPop(v31);
}

void sub_10006DB04(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (*(_QWORD *)(a1 + 64))
    sub_10006DB74(a1);
  if (*(_QWORD *)(a1 + 16))
  {
    Apple80211Close();
    *(_QWORD *)(a1 + 16) = 0;
  }
  v2 = *(const void **)(a1 + 5920);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  v3 = *(const void **)(a1 + 128);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 128) = 0;
  }
  *(_BYTE *)(a1 + 52) = 0;
  sub_100050D34((const void *)a1);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 5784), *(const void **)(a1 + 112));
}

void sub_10006DB74(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  void (*v14)(uint64_t, const void *, _QWORD, _QWORD);
  char v15;
  void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  void (*v21)(uint64_t, const void *, _QWORD, _QWORD);
  void *v22;
  uint64_t v23;
  uint64_t v24;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiDeviceUnscheduleFromQueue");
  objc_autoreleasePoolPop(v2);
  SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 152), 0);
  sub_100147764(*(_QWORD *)(a1 + 144), 0, 0);
  sub_100147A64(*(_QWORD *)(a1 + 144));
  v3 = *(NSObject **)(a1 + 72);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(a1 + 72));
    *(_QWORD *)(a1 + 72) = 0;
  }
  v4 = *(NSObject **)(a1 + 80);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 80));
    *(_QWORD *)(a1 + 80) = 0;
  }
  v5 = *(NSObject **)(a1 + 88);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*(dispatch_object_t *)(a1 + 88));
    *(_QWORD *)(a1 + 88) = 0;
  }
  v6 = *(NSObject **)(a1 + 5712);
  if (v6)
  {
    dispatch_source_cancel(v6);
    dispatch_release(*(dispatch_object_t *)(a1 + 5712));
    *(_QWORD *)(a1 + 5712) = 0;
  }
  v7 = *(NSObject **)(a1 + 5768);
  if (v7)
  {
    dispatch_source_cancel(v7);
    dispatch_release(*(dispatch_object_t *)(a1 + 5768));
    *(_QWORD *)(a1 + 5768) = 0;
  }
  IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 96), 0);
  Apple80211EventMonitoringHalt(*(_QWORD *)(a1 + 16));
  v8 = *(_QWORD *)(a1 + 176);
  if (v8)
    sub_100154A70(v8);
  v9 = *(char *)(a1 + 28);
  v10 = objc_autoreleasePoolPush();
  if (v9 < 0)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s:%d %ld \n", "__WiFiDeviceDeleteHostApInterface", 12056, CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784)));
    objc_autoreleasePoolPop(v10);
    v11 = sub_100073CA8(a1);
    if (v11)
    {
      v12 = sub_10015C354((uint64_t)v11);
      if (v12)
      {
        v13 = v12;
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 5784), v12);
        v14 = *(void (**)(uint64_t, const void *, _QWORD, _QWORD))(a1 + 5096);
        if (v14)
          v14(a1, v13, *(_QWORD *)(a1 + 5104), 0);
      }
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Exit: %s:%d %ld \n", "__WiFiDeviceDeleteHostApInterface", 12071, CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784)));
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HostAP is not supported", "WiFiDeviceUnscheduleFromQueue", v23, v24);
  }
  objc_autoreleasePoolPop(v10);
  v15 = *(_BYTE *)(a1 + 32);
  v16 = objc_autoreleasePoolPush();
  if ((v15 & 1) != 0)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s:%d %ld \n", "__WiFiDeviceDeleteAwdlInterface", 12033, CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784)));
    objc_autoreleasePoolPop(v16);
    v17 = *(const void **)(a1 + 5976);
    if (v17)
    {
      CFRelease(v17);
      *(_QWORD *)(a1 + 5976) = 0;
    }
    v18 = sub_100073B3C(a1);
    if (v18)
    {
      v19 = sub_10015C354((uint64_t)v18);
      if (v19)
      {
        v20 = v19;
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 5784), v19);
        v21 = *(void (**)(uint64_t, const void *, _QWORD, _QWORD))(a1 + 5096);
        if (v21)
          v21(a1, v20, *(_QWORD *)(a1 + 5104), 0);
      }
    }
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Exit: %s:%d %ld \n", "__WiFiDeviceDeleteAwdlInterface", 12051, CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784)));
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AWDL is not supported", "WiFiDeviceUnscheduleFromQueue", v23, v24);
  }
  objc_autoreleasePoolPop(v16);
  *(_QWORD *)(a1 + 64) = 0;
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceUnscheduleFromQueue");
  objc_autoreleasePoolPop(v22);
}

const __CFString *sub_10006DEAC(int a1)
{
  const __CFString *result;
  int v2;

  if (a1 <= 130)
  {
    v2 = a1 - 1;
    result = CFSTR("APPLE80211_M_ASSOC_DONE");
    switch(v2)
    {
      case 0:
        result = CFSTR("APPLE80211_M_POWER_CHANGED");
        break;
      case 1:
      case 4:
      case 5:
      case 6:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 32:
      case 33:
        return CFSTR("Unknown");
      case 2:
        result = CFSTR("APPLE80211_M_BSSID_CHANGED");
        break;
      case 3:
        result = CFSTR("APPLE80211_M_LINK_CHANGED");
        break;
      case 7:
        result = CFSTR("APPLE80211_M_MODE_CHANGED");
        break;
      case 8:
        return result;
      case 9:
        result = CFSTR("APPLE80211_M_SCAN_DONE");
        break;
      case 10:
        result = CFSTR("APPLE80211_M_COUNTRY_CODE_CHANGED");
        break;
      case 11:
        result = CFSTR("APPLE80211_M_STA_ARRIVE");
        break;
      case 12:
        result = CFSTR("APPLE80211_M_STA_LEAVE");
        break;
      case 13:
        result = CFSTR("APPLE80211_M_DECRYPTION_FAILURE");
        break;
      case 29:
        result = CFSTR("APPLE80211_M_WIFI_DIRECT_GROUP_STARTED");
        break;
      case 30:
        result = CFSTR("APPLE80211_M_BGSCAN_NET_DISCOVERED");
        break;
      case 31:
        result = CFSTR("APPLE80211_M_ROAMED");
        break;
      case 34:
        result = CFSTR("APPLE80211_M_BLACKLIST_NETWORK");
        break;
      case 35:
        result = CFSTR("APPLE80211_M_RESUME_SCAN");
        break;
      case 36:
        result = CFSTR("APPLE80211_M_BGSCAN_SUSPENDED");
        break;
      case 37:
        result = CFSTR("APPLE80211_M_BGSCAN_RESUMED");
        break;
      case 38:
        result = CFSTR("APPLE80211_M_RSSI_CHANGED");
        break;
      default:
        switch(CFSTR("APPLE80211_M_ASSOC_DONE"))
        {
          case 'K':
            result = CFSTR("APPLE80211_M_PRUNE");
            break;
          case 'L':
            result = CFSTR("APPLE80211_M_SUPPLICANT_EVENT");
            break;
          case 'M':
          case 'N':
          case 'R':
          case 'T':
          case 'U':
          case 'V':
          case 'W':
          case 'X':
            return CFSTR("Unknown");
          case 'O':
            result = CFSTR("APPLE80211_M_DUMP_LOGS");
            break;
          case 'P':
            result = CFSTR("APPLE80211_M_ROAM_STATUS");
            break;
          case 'Q':
            result = CFSTR("APPLE80211_M_LEAKY_AP_STATS");
            break;
          case 'S':
            result = CFSTR("APPLE80211_M_RANGING_MEASUREMENT_DONE");
            break;
          case 'Y':
            result = CFSTR("APPLE80211_M_TX_FAIL_HISTORY_EVENT");
            break;
          case 'Z':
            result = CFSTR("APPLE80211_M_SCAN_BACKOFF_REPORT");
            break;
          default:
            switch(CFSTR("APPLE80211_M_ASSOC_DONE"))
            {
              case '7':
                result = CFSTR("APPLE80211_M_DRIVER_AVAILABLE");
                break;
              case '9':
                result = CFSTR("APPLE80211_M_GAS_DONE");
                break;
              case '<':
                result = CFSTR("APPLE80211_M_HOMECHAN_QUAL_CHANGED");
                break;
              case '=':
                result = CFSTR("APPLE80211_M_POWER_STATS_UPDATE");
                break;
              case '?':
                result = CFSTR("APPLE80211_M_BGSCAN_CACHED_NETWORK_AVAILABLE");
                break;
              default:
                return CFSTR("Unknown");
            }
            break;
        }
        break;
    }
  }
  else if (a1 > 179)
  {
    if (a1 > 209)
    {
      if (a1 > 237)
      {
        switch(a1)
        {
          case 238:
            return CFSTR("APPLE80211_M_NDD_DONE");
          case 239:
            return CFSTR("APPLE80211_M_NDD_REPORT");
          case 240:
            return CFSTR("APPLE80211_M_SCAN_FWD_STATS_EVENT");
        }
      }
      else
      {
        switch(a1)
        {
          case 210:
            return CFSTR("APPLE80211_M_P2P_PEER_COUNTRY_CODE");
          case 217:
            return CFSTR("APPLE80211_M_ENV_BSS_INFO");
          case 218:
            return CFSTR("APPLE80211_M_OBSS_MIT_NOTIFICATION");
        }
      }
      return CFSTR("Unknown");
    }
    else
    {
      switch(a1)
      {
        case 180:
          result = CFSTR("APPLE80211_M_BEACON_CACHE_UPDATED");
          break;
        case 189:
          result = CFSTR("APPLE80211_M_TE_CRITICAL_TRAFFIC_IND");
          break;
        case 190:
          result = CFSTR("APPLE80211_M_BT_COEX_MODE_STATS_EVENT");
          break;
        case 191:
          result = CFSTR("APPLE80211_M_LINK_DOWN_DEBOUNCE_FAILED");
          break;
        case 192:
          result = CFSTR("APPLE80211_M_SIB_EVENT");
          break;
        case 193:
          result = CFSTR("APPLE80211_M_SENSING_DONE");
          break;
        case 196:
          result = CFSTR("APPLE80211_M_TRIGGER_TTR");
          break;
        case 199:
          result = CFSTR("APPLE80211_M_COLOCATED_CACHE_EVENT");
          break;
        default:
          return CFSTR("Unknown");
      }
    }
  }
  else
  {
    switch(a1)
    {
      case 131:
        result = CFSTR("APPLE80211_M_LSM_UPDATE");
        break;
      case 132:
        result = CFSTR("APPLE80211_M_LOW_POWER_MODE");
        break;
      case 133:
        result = CFSTR("APPLE80211_M_LPAS_STATE");
        break;
      case 134:
        result = CFSTR("APPLE80211_M_TEMP_DISABLE_NETWORK");
        break;
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 142:
      case 144:
      case 146:
      case 147:
      case 149:
      case 152:
      case 153:
      case 154:
      case 155:
      case 157:
      case 158:
      case 159:
      case 160:
      case 161:
      case 162:
      case 163:
      case 168:
        return CFSTR("Unknown");
      case 140:
        result = CFSTR("APPLE80211_M_BSS_STEERING_REQUEST_EVENT");
        break;
      case 141:
        result = CFSTR("APPLE80211_M_SOFTAP_LPM");
        break;
      case 143:
        result = CFSTR("APPLE80211_M_ACTION_FRAME_EVENT");
        break;
      case 145:
        result = CFSTR("APPLE80211_M_WEIGHT_AVG_LQM_UPDATE");
        break;
      case 148:
        result = CFSTR("APPLE80211_M_WIFI_NETWORK_INFO_UPDATE");
        break;
      case 150:
        result = CFSTR("APPLE80211_M_DPS");
        break;
      case 151:
        result = CFSTR("APPLE80211_M_SLOW_WIFI");
        break;
      case 156:
        result = CFSTR("APPLE80211_M_REALTIME_SESSION_NOTIFICATION");
        break;
      case 164:
        result = CFSTR("APPLE80211_M_SLOWWIFI_PROBE_TRIGGER");
        break;
      case 165:
        result = CFSTR("APPLE80211_M_SLOWWIFI_USERINPUT_TRIGGER");
        break;
      case 166:
        result = CFSTR("APPLE80211_M_SLOWWIFI_PROBE_RESULT");
        break;
      case 167:
        result = CFSTR("APPLE80211_M_SLOWWIFI_USERINPUT_RESULT");
        break;
      case 169:
        result = CFSTR("APPLE80211_M_LQM_TX_STATS");
        break;
      default:
        if (a1 != 176)
          return CFSTR("Unknown");
        result = CFSTR("APPLE80211_M_LQM_CRASHTRACER");
        break;
    }
  }
  return result;
}

CFMutableArrayRef sub_10006E2B4(uint64_t a1, int a2)
{
  const __CFArray *v4;
  CFMutableArrayRef result;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFDictionary *v11;
  int valuePtr;

  v4 = *(const __CFArray **)(a1 + 5664);
  if (v4 && CFArrayGetCount(v4) || (result = sub_10006C53C((_QWORD *)a1), (_DWORD)result))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5664));
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v7 = Count;
      v8 = 0;
      while (1)
      {
        valuePtr = -1431655766;
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v8);
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNELINFO_CH_NUM"));
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr == a2)
          {
            v11 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v8);
            if (kCFBooleanTrue == CFDictionaryGetValue(v11, CFSTR("CHANNELINFO_DFS")))
              break;
          }
        }
        if (v7 == ++v8)
          return 0;
      }
      return (CFMutableArrayRef)1;
    }
  }
  return result;
}

CFMutableArrayRef sub_10006E3B0(uint64_t a1, int a2)
{
  const __CFArray *v4;
  CFMutableArrayRef result;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  int valuePtr;

  v4 = *(const __CFArray **)(a1 + 5664);
  if (v4 && CFArrayGetCount(v4) || (result = sub_10006C53C((_QWORD *)a1), (_DWORD)result))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5664));
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v7 = Count;
      v8 = 0;
      while (1)
      {
        valuePtr = -1431655766;
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v8);
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNELINFO_CH_NUM"));
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr == a2)
            break;
        }
        if (v7 == ++v8)
          return 0;
      }
      return (CFMutableArrayRef)1;
    }
  }
  return result;
}

uint64_t sub_10006E474(uint64_t a1, int a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  uint64_t v8;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  int v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  int valuePtr;

  v4 = *(const __CFArray **)(a1 + 5664);
  if ((!v4 || !CFArrayGetCount(v4)) && !sub_10006C53C((_QWORD *)a1))
    return 1;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5664));
  if (Count < 1)
    return 1;
  v6 = Count;
  v7 = 0;
  v8 = 1;
  do
  {
    valuePtr = -1431655766;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v7);
    Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNELINFO_CH_NUM"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      v11 = valuePtr;
      if (valuePtr == a2)
      {
        v12 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v7);
        if (kCFBooleanTrue == CFDictionaryGetValue(v12, CFSTR("CHANNELINFO_40MHZ")))
          v8 = v8 | 2;
        else
          v8 = v8;
        v11 = valuePtr;
      }
      if (v11 == a2)
      {
        v13 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5664), v7);
        if (kCFBooleanTrue == CFDictionaryGetValue(v13, CFSTR("CHANNELINFO_80MHZ")))
          v8 = v8 | 4;
        else
          v8 = v8;
      }
    }
    ++v7;
  }
  while (v6 != v7);
  return v8;
}

uint64_t sub_10006E5B4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t result;
  double *v13;
  double *v14;
  void *v16;

  if (a1)
  {
    v3 = 1280;
    if (!a3)
      v3 = 2288;
    v4 = *(_DWORD *)(a1 + v3);
    if (v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 1288;
      if (!a3)
        v7 = 2296;
      v8 = *(_QWORD *)(a1 + v7) - 1;
      v9 = a1 + 312;
      v10 = a1 + 1800;
      v11 = 0.0;
      result = 1;
      while (1)
      {
        if (v8 < 0)
          v8 = 29;
        v13 = (double *)(v9 + 32 * v8 + 24);
        if (v11 == 0.0
          || (a3 ? (v14 = (double *)(v9 + 32 * v8 + 24)) : (v14 = (double *)(v10 + 16 * v8 + 8)), v11 - *v14 <= 1.0))
        {
          if (a3)
          {
            v6 = *(unsigned __int8 *)(v9 + 32 * v8) | (unsigned __int16)(*(_DWORD *)(v9 + 32 * v8 + 8) << 8) | (*(_DWORD *)(v9 + 32 * v8 + 16) << 16);
          }
          else
          {
            v6 = *(char *)(v10 + 16 * v8);
            v13 = (double *)(v10 + 16 * v8 + 8);
          }
          v11 = *v13;
          *(_DWORD *)(a2 + 4 * v5) = v6;
          --v4;
          --v8;
          if (!v4)
            return result;
        }
        else
        {
          *(_DWORD *)(a2 + 4 * v5) = v6;
          v11 = v11 + -1.0;
        }
        if (v5++ >= 0x1D)
          return result;
      }
    }
    return 1;
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDevicePrepareLqmHistoryArray");
    objc_autoreleasePoolPop(v16);
    return 0;
  }
}

uint64_t sub_10006E710(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  double v12;
  double v13;
  int *v14;
  uint64_t result;
  void *v17;

  if (!a1)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDevicePrepareTxRxHistoryArray");
    goto LABEL_21;
  }
  if (!a2)
  {
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lqm null", "WiFiDevicePrepareTxRxHistoryArray");
LABEL_21:
    objc_autoreleasePoolPop(v17);
    return 0;
  }
  v2 = *(_DWORD *)(a1 + 3984);
  if (!v2)
    return 1;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = a1 + 2304;
  v10 = *(_QWORD *)(a1 + 3992) - 1;
  v11 = (_DWORD *)(a2 + 360);
  v12 = 0.0;
  do
  {
    if (v10 < 0)
      v10 = 29;
    v13 = *(double *)(v9 + 56 * v10 + 48);
    if (v12 == 0.0 || v12 - v13 <= 1.0)
    {
      v14 = (int *)(v9 + 56 * v10);
      v8 = *v14;
      *(v11 - 30) = *v14;
      v6 = *((char *)v14 + 8);
      *(v11 - 60) = v6;
      v7 = v14[4];
      v11[30] = v7;
      *v11 = v6;
      v5 = v14[8];
      v11[60] = v5;
      v4 = *((char *)v14 + 40);
      v11[90] = v4;
      --v2;
      --v10;
    }
    else
    {
      *(v11 - 30) = v8;
      *(v11 - 60) = v6;
      v11[30] = v7;
      *v11 = v6;
      v11[60] = v5;
      v13 = v12 + -1.0;
      v11[90] = v4;
    }
    result = 1;
    if (!v2)
      break;
    ++v11;
    v12 = v13;
  }
  while (v3++ < 0x1D);
  return result;
}

uint64_t sub_10006E894(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  uint64_t result;
  double *v11;
  double v12;
  void *v14;

  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDevicePrepareEncodedPerCoreRssiHistoryArray");
    goto LABEL_20;
  }
  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lqm null", "WiFiDevicePrepareEncodedPerCoreRssiHistoryArray");
LABEL_20:
    objc_autoreleasePoolPop(v14);
    return 0;
  }
  v2 = *(_DWORD *)(a1 + 1784);
  if (!v2)
    return 1;
  v3 = 0;
  LOBYTE(v4) = 0;
  LOBYTE(v5) = 0;
  v6 = a1 + 1296;
  v7 = *(_QWORD *)(a1 + 1792) - 1;
  v8 = a2 + 720;
  v9 = 0.0;
  result = 1;
  do
  {
    if (v7 < 0)
      v7 = 29;
    v11 = (double *)(v6 + 16 * v7);
    v12 = v11[1];
    if (v9 == 0.0 || v9 - v12 <= 1.0)
    {
      v5 = *(unsigned __int8 *)v11;
      v4 = *((unsigned __int8 *)v11 + 1);
      *(_DWORD *)(v8 + 4 * v3) |= (v5 << 8) | (v4 << 16);
      --v2;
      --v7;
      if (!v2)
        return result;
    }
    else
    {
      *(_DWORD *)(v8 + 4 * v3) |= (unsigned __int16)(v5 << 8) | (v4 << 16);
      v12 = v9 + -1.0;
    }
    v9 = v12;
  }
  while (v3++ < 0x1D);
  return result;
}

uint64_t sub_10006E9EC(uint64_t a1, uint64_t a2)
{
  void *v5;

  if (a1)
  {
    if (a2)
    {
      sub_10006EAA4(a1, *(_DWORD *)(a1 + 4016));
      *(_DWORD *)(a2 + 840) = *(_DWORD *)(a1 + 4000);
      return 1;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lqm null", "WiFiDevicePrepareGatewayARPHistory");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDevicePrepareGatewayARPHistory");
  }
  objc_autoreleasePoolPop(v5);
  return 0;
}

void sub_10006EAA4(uint64_t a1, int a2)
{
  double Current;
  double v5;
  double v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint32x4_t v11;
  int8x16_t v12;
  int32x4_t v13;
  uint32x4_t v14;
  int32x4_t v15;
  int8x16_t v16;
  uint32x4_t v17;
  int8x16_t v18;
  void *v19;

  Current = CFAbsoluteTimeGetCurrent();
  if (a1)
  {
    v5 = Current;
    v6 = *(double *)(a1 + 4008);
    if (v6 == 0.0)
    {
      *(_DWORD *)(a1 + 4016) = a2;
      *(double *)(a1 + 4008) = v5;
      *(_DWORD *)(a1 + 4000) = 0;
    }
    else
    {
      v7 = (v5 - v6);
      if (*(_DWORD *)(a1 + 4016) == 1)
      {
        if (!*(_DWORD *)(a1 + 4000))
          -[WiFiUsageMonitor addFaultEvent:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addFaultEvent:forInterface:", 17, *(_QWORD *)(a1 + 112));
        if (v7 <= 1)
          v8 = 1;
        else
          v8 = v7;
        if (v8 <= 0x1F)
        {
          v10 = (v8 + 3) & 0xFFFFFFFC;
          v11 = (uint32x4_t)vdupq_n_s32(v8 - 1);
          v12 = (int8x16_t)(*(_DWORD *)(a1 + 4000) << v8);
          v13 = (int32x4_t)xmmword_1001BB560;
          v14.i64[0] = 0x100000001;
          v14.i64[1] = 0x100000001;
          v15.i64[0] = 0x400000004;
          v15.i64[1] = 0x400000004;
          do
          {
            v16 = v12;
            v17 = (uint32x4_t)v13;
            v12 = vorrq_s8(v12, (int8x16_t)vshlq_u32(v14, (uint32x4_t)v13));
            v13 = vaddq_s32(v13, v15);
            v10 -= 4;
          }
          while (v10);
          v18 = vbslq_s8((int8x16_t)vcgtq_u32(v17, v11), v16, v12);
          *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
          v9 = v18.i32[0] | v18.i32[1];
        }
        else
        {
          v9 = -1;
        }
      }
      else if (v7 <= 0x1F)
      {
        v9 = *(_DWORD *)(a1 + 4000) << v7;
      }
      else
      {
        v9 = 0;
      }
      *(_DWORD *)(a1 + 4000) = v9;
      *(_DWORD *)(a1 + 4016) = a2;
      *(double *)(a1 + 4008) = v5;
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "__WiFiDeviceUpdateGatewayARPHistory");
    objc_autoreleasePoolPop(v19);
  }
}

void sub_10006EC30(uint64_t a1)
{
  void *v2;
  const __CFString *v3;
  void (*v4)(uint64_t, _QWORD, _QWORD);

  if (a1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v3 = *(const __CFString **)(a1 + 5840);
      if (!v3)
        v3 = CFSTR("Unknown");
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : id mac address private : <%d> for network ? <%@>", "__WiFiDevicePrimaryTimerCallback", *(unsigned __int8 *)(a1 + 5864), v3);
    }
    objc_autoreleasePoolPop(v2);
    v4 = *(void (**)(uint64_t, _QWORD, _QWORD))(a1 + 4400);
    if (v4)
      v4(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 4408));
  }
}

void sub_10006ECDC(uint64_t a1)
{
  void *v2;
  const __CFString *v3;
  void (*v4)(uint64_t, _QWORD, _QWORD);

  if (!sub_100066DF8(a1))
  {
    sub_100051A28(a1, 0, 0, *(_DWORD *)(a1 + 5872), 0, 0);
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v3 = *(const __CFString **)(a1 + 5840);
      if (!v3)
        v3 = CFSTR("Unknown");
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : is mac address private : <%d> for network ? <%@>", "__WiFiDeviceRoutableTimerCallback", *(unsigned __int8 *)(a1 + 5864), v3);
    }
    objc_autoreleasePoolPop(v2);
    v4 = *(void (**)(uint64_t, _QWORD, _QWORD))(a1 + 4416);
    if (v4)
      v4(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 4424));
  }
}

CFMutableArrayRef sub_10006EDA8(_QWORD *a1)
{
  CFMutableArrayRef result;
  uint64_t (*v3)(_QWORD *, _QWORD, _QWORD);

  result = sub_10006C53C(a1);
  v3 = (uint64_t (*)(_QWORD *, _QWORD, _QWORD))a1[679];
  if (v3)
    return (CFMutableArrayRef)v3(a1, a1[14], a1[680]);
  return result;
}

void sub_10006EDE8(uint64_t a1)
{
  if (a1)
    sub_100073470(a1);
}

void sub_10006EDF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  const void *v8;

  v7 = *(_QWORD *)(a4 + 112);
  v8 = (const void *)sub_100032318(a1);
  sub_100079FD4(a4, v7, v8, a3, a2);
}

void sub_10006EE40(uint64_t a1, const __CFArray *a2, uint64_t a3)
{
  void *v3;
  void *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  const void *v8;
  WiFiUsageMonitor *v9;
  BOOL v10;
  unsigned int v11;
  CFRange v12;
  CFRange v13;
  CFRange v14;
  CFRange v15;
  CFTypeRef cf1;
  int v17;
  CFIndex i;
  uint64_t v19;
  CFIndex Count;
  uint64_t v21;
  CFArrayRef v22;
  uint64_t v23;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  if (a2)
  {
    Count = CFArrayGetCount(v22);
    v19 = v21;
    if (v21)
    {
      for (i = 0; i < Count; ++i)
      {
        cf1 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        cf1 = CFArrayGetValueAtIndex(v22, i);
        if (sub_10007E654(cf1))
        {
          if (CFEqual(cf1, (CFTypeRef)qword_10026D620) || CFEqual(cf1, (CFTypeRef)qword_10026D628))
          {
            if (sub_100066B88(v19) == 1)
            {
              dispatch_source_set_timer(*(dispatch_source_t *)(v19 + 72), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
              v5 = v19;
              v6 = (const void *)sub_100025C3C(v19);
              sub_1000672C0(v5, v6, 482, 0, (uint64_t)kCFBooleanTrue);
              if (*(_QWORD *)(v19 + 5048))
                (*(void (**)(uint64_t, _QWORD, _QWORD))(v19 + 5048))(v19, *(_QWORD *)(v19 + 112), *(_QWORD *)(v19 + 5056));
            }
            else
            {
              v7 = v19;
              v8 = (const void *)sub_100025C3C(v19);
              sub_1000672C0(v7, v8, 482, 0, (uint64_t)kCFBooleanFalse);
            }
            v9 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
            v10 = sub_100066B88(v19) != 0;
            -[WiFiUsageMonitor notifyInterfaceRankingState:forInterface:](v9, "notifyInterfaceRankingState:forInterface:", v10, sub_100025C3C(v19));
          }
          else
          {
            v15 = CFStringFind((CFStringRef)cf1, kSCEntNetInterfaceActiveDuringSleepSupported, 0);
            if (v15.location == -1)
            {
              v14 = CFStringFind((CFStringRef)cf1, CFSTR("IPConfigurationBusy"), 0);
              if (v14.location == -1)
              {
                v13 = CFStringFind((CFStringRef)cf1, kSCEntNetIPv4RouterARPAlive, 0);
                if (v13.location == -1
                  && (v12 = CFStringFind((CFStringRef)cf1, kSCEntNetIPv4RouterARPFailure, 0), v12.location == -1))
                {
                  sub_1000673BC(v19, (const __CFString *)cf1);
                  sub_10007EBB4(v19, (const __CFString *)cf1);
                }
                else
                {
                  v11 = -1431655766;
                  if (sub_10007EB30((const __CFString *)cf1, (int *)&v11))
                  {
                    sub_10006EAA4(v19, v11);
                    if (*(_QWORD *)(v19 + 5064))
                      (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v19 + 5064))(v19, *(_QWORD *)(v19 + 112), *(_QWORD *)(v19 + 5072), v11);
                  }
                }
              }
              else
              {
                sub_10007E8F8(v19, (CFStringRef)cf1);
              }
            }
            else
            {
              sub_10007E694(v19, (CFStringRef)cf1);
            }
          }
          v17 = 0;
        }
        else
        {
          v4 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not a valid CFString", "__WiFiDeviceDynamicStoreCallback");
          objc_autoreleasePoolPop(v4);
          v17 = 7;
        }
      }
      v17 = 5;
    }
    else
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceDynamicStoreCallback: device reference is NULL");
      objc_autoreleasePoolPop(v3);
    }
  }
}

void sub_10006F24C(uint64_t a1)
{
  CFStringRef NetworkServiceEntity;
  CFStringRef v3;
  CFStringRef NetworkInterfaceEntity;
  CFStringRef v5;
  CFStringRef v6;
  CFStringRef v7;
  __CFArray *Mutable;
  __CFArray *v9;
  __CFArray *v10;
  __CFArray *v11;
  const void *v12;
  const void *v13;
  CFStringRef value;

  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4);
  v3 = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv6);
  value = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), kSCEntNetIPv6);
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetInterfaceActiveDuringSleepSupported);
  v5 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4RouterARPAlive);
  v6 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4RouterARPFailure);
  v7 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), CFSTR("IPConfigurationBusy"));
  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v9 = Mutable;
  if (Mutable)
  {
    if (qword_10026D620)
      CFArrayAppendValue(Mutable, (const void *)qword_10026D620);
    if (qword_10026D628)
      CFArrayAppendValue(v9, (const void *)qword_10026D628);
    v10 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    v11 = v10;
    if (v10)
    {
      if (NetworkServiceEntity)
        CFArrayAppendValue(v10, NetworkServiceEntity);
      if (v3)
        CFArrayAppendValue(v11, v3);
      if (NetworkInterfaceEntity)
      {
        CFArrayAppendValue(v11, NetworkInterfaceEntity);
        sub_10007E694(a1, 0);
      }
      if (v7)
      {
        CFArrayAppendValue(v11, v7);
        sub_10007E8F8(a1, 0);
      }
      if (v5)
        CFArrayAppendValue(v11, v5);
      if (v6)
        CFArrayAppendValue(v11, v6);
      if (value)
        CFArrayAppendValue(v11, value);
      if (CFArrayGetCount(v9) >= 1 && CFArrayGetCount(v11) >= 1)
      {
        SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 152), v9, v11);
        v12 = *(const void **)(a1 + 160);
        if (v12)
        {
          CFRelease(v12);
          *(_QWORD *)(a1 + 160) = 0;
        }
        v13 = *(const void **)(a1 + 168);
        if (v13)
        {
          CFRelease(v13);
          *(_QWORD *)(a1 + 168) = 0;
        }
        *(_QWORD *)(a1 + 160) = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v9);
        *(_QWORD *)(a1 + 168) = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v11);
      }
    }
    if (NetworkServiceEntity)
      goto LABEL_29;
  }
  else
  {
    v11 = 0;
    if (NetworkServiceEntity)
LABEL_29:
      CFRelease(NetworkServiceEntity);
  }
  if (v3)
    CFRelease(v3);
  if (NetworkInterfaceEntity)
    CFRelease(NetworkInterfaceEntity);
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
  if (value)
    CFRelease(value);
  if (v7)
    CFRelease(v7);
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
}

void sub_10006F580(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (a2)
  {
    sub_10006F24C(a2);
    sub_10006F7A4(a2);
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Cannot reconnect to the dynamic store - info is NULL");
    objc_autoreleasePoolPop(v3);
  }
}

void sub_10006F5E4(uint64_t *a1)
{
  void *v2;
  void (*v3)(uint64_t *, uint64_t, uint64_t, uint64_t);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFIndex v7;
  unint64_t v8;

  v7 = 72;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v6 = 0;
  if (!sub_10001E3EC(a1[22], &v8, &v7, &v6) && *(_BYTE *)(v8 + 56) == 1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Flushing out pending command %@", "__WiFiDeviceCommandAbortTimerCallback", sub_10001C840(*(_DWORD *)v8));
    objc_autoreleasePoolPop(v2);
    switch(*(_DWORD *)v8)
    {
      case 0:
        sub_100016A94((uint64_t)a1, a1[14], 0, 0, 4294963391);
        return;
      case 1:
        sub_10007B400((uint64_t)a1, a1[14], 0, 4294963391);
        sub_1001487B4(a1[18]);
        return;
      case 2:
      case 7:
      case 8:
      case 0xD:
      case 0xF:
        goto LABEL_11;
      case 3:
        sub_10007A780((uint64_t)a1, *(_QWORD *)(v8 + 8), 4294963391);
        return;
      case 4:
      case 6:
        v3 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v8 + 16);
        if (!v3)
          goto LABEL_11;
        v4 = *(_QWORD *)(v8 + 8);
        v5 = *(_QWORD *)(v8 + 24);
        break;
      case 5:
        sub_10006A18C((uint64_t)a1, *(_QWORD *)(v8 + 8), 4294963391);
        return;
      case 9:
        sub_10007AD3C(a1, *(_QWORD *)(v8 + 8), 0, 0, 4294963391);
        return;
      case 0xA:
      case 0xB:
        v3 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v8 + 24);
        if (!v3)
          goto LABEL_11;
        v4 = *(_QWORD *)(v8 + 8);
        v5 = *(_QWORD *)(v8 + 32);
        break;
      case 0xC:
        sub_10006B430(a1, *(_QWORD *)(v8 + 8), 0, 4294963391);
        return;
      case 0xE:
        sub_10007B260((uint64_t)a1, *(_QWORD *)(v8 + 8), 0, 4294963391);
        return;
      default:
        return;
    }
    v3(a1, v4, 4294963391, v5);
LABEL_11:
    sub_100017CB0((uint64_t)a1);
  }
}

void sub_10006F7A4(uint64_t a1)
{
  int i;
  int InfoCopy;
  CFDictionaryRef theDict;

  theDict = 0;
  if (a1 && *(_QWORD *)(a1 + 16) && *(_QWORD *)(a1 + 112))
  {
    for (i = 6; ; --i)
    {
      InfoCopy = Apple80211GetInfoCopy();
      if (InfoCopy != -3905 && InfoCopy != 61 && InfoCopy != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
}

uint64_t sub_10006FA28(uint64_t a1)
{
  return *(_BYTE *)(a1 + 32) & 1;
}

uint64_t sub_10006FA34(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 28) >> 7;
}

void sub_10006FA40(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  const __SCPreferences *v6;
  const __SCPreferences *v7;
  const __SCNetworkSet *v8;
  const __SCNetworkSet *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  void *v14;
  CFIndex v15;
  const __SCNetworkService *ValueAtIndex;
  const __SCNetworkInterface *Interface;
  const __CFString *InterfaceType;
  const __SCNetworkService *v19;
  const __CFString *BSDName;
  const __CFString *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  CFStringRef ServiceID;
  const __CFString *v28;
  void *v29;
  const void *v30;

  if (a1)
    v2 = *(const void **)(a1 + 112);
  else
    v2 = 0;
  v3 = sub_10002BF8C(a1, v2);
  if (v3)
  {
    v4 = v3;
    v5 = (void *)sub_10001E1C8((uint64_t)"__copyAirPortService");
    v6 = SCPreferencesCreate(0, CFSTR("WIFID-DEVICE"), 0);
    if (v6)
    {
      v7 = v6;
      if (sub_100007620(v6))
      {
        v8 = SCNetworkSetCopyCurrent(v7);
        v9 = v8;
        if (v8)
        {
          v10 = SCNetworkSetCopyServices(v8);
          if (v10)
          {
            v11 = v10;
            Count = CFArrayGetCount(v10);
            if (Count >= 1)
            {
              v13 = Count;
              v30 = v4;
              v14 = v5;
              v15 = 0;
              while (1)
              {
                ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v11, v15);
                Interface = SCNetworkServiceGetInterface(ValueAtIndex);
                InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
                if (InterfaceType)
                {
                  if (CFStringCompare(InterfaceType, kSCNetworkInterfaceTypeIEEE80211, 0) == kCFCompareEqualTo)
                    break;
                }
                if (v13 == ++v15)
                  goto LABEL_14;
              }
              BSDName = SCNetworkInterfaceGetBSDName(Interface);
              if (!a1)
              {
LABEL_14:
                v19 = 0;
                v5 = v14;
                v4 = v30;
                goto LABEL_41;
              }
              v19 = 0;
              if (BSDName)
              {
                v21 = *(const __CFString **)(a1 + 112);
                if (v21)
                {
                  if (CFStringCompare(BSDName, v21, 0))
                  {
                    v19 = 0;
                  }
                  else
                  {
                    CFRetain(ValueAtIndex);
                    v19 = ValueAtIndex;
                  }
                }
              }
              v5 = v14;
              v4 = v30;
LABEL_41:
              sub_1000076D4(v7, 0);
              CFRelease(v7);
              if (v11)
                CFRelease(v11);
              if (v9)
                CFRelease(v9);

              if (v19)
              {
                ServiceID = SCNetworkServiceGetServiceID(v19);
                v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@/%@/%@/%@/%@"), kSCDynamicStoreDomainState, kSCCompNetwork, kSCCompService, ServiceID, kSCEntNetIPv4);
                v29 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - ipv4 state key: %@", "__WiFiDeviceInitializeIPParams", v28);
                objc_autoreleasePoolPop(v29);
                sub_1000673BC(a1, v28);
                CFRelease(v4);
                CFRelease(v19);
                if (v28)
                  CFRelease(v28);
                return;
              }
              goto LABEL_32;
            }
LABEL_40:
            v19 = 0;
            goto LABEL_41;
          }
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get services", "__copyAirPortService");
        }
        else
        {
          v26 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get currentSet", "__copyAirPortService");
        }
        objc_autoreleasePoolPop(v26);
        v11 = 0;
        goto LABEL_40;
      }
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get prefs lock", "__copyAirPortService");
      objc_autoreleasePoolPop(v24);
      CFRelease(v7);
    }
    else
    {
      v23 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Unable to create preferences %d", SCError());
      objc_autoreleasePoolPop(v23);
    }

LABEL_32:
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No airportService", "__WiFiDeviceInitializeIPParams");
    objc_autoreleasePoolPop(v25);
    CFRelease(v4);
    return;
  }
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not associated", "__WiFiDeviceInitializeIPParams");
  objc_autoreleasePoolPop(v22);
}

void sub_10006FE54(uint64_t a1, int a2)
{
  void *v4;
  __CFDictionary *Mutable;
  __CFDictionary *v6;
  const void **v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFStringRef v20;
  CFStringRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFStringRef v26;
  CFStringRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFStringRef v30;
  CFStringRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  uint64_t v34;
  void *v35;
  __int128 valuePtr;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: entering \n", "__WiFiDevicePrepareAndSendDriverAvailableEvent");
  objc_autoreleasePoolPop(v4);
  valuePtr = 0u;
  v37 = 0u;
  v47 = 0;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v38 = 0u;
  LODWORD(valuePtr) = 3;
  DWORD2(valuePtr) = a2;
  LODWORD(v37) = -528340989;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = Mutable;
  if (!Mutable)
    goto LABEL_25;
  v7 = (const void **)&kCFBooleanFalse;
  if (a2)
    v7 = (const void **)&kCFBooleanTrue;
  CFDictionarySetValue(Mutable, CFSTR("DRIVER_AVAILABLE"), *v7);
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v37);
  if (!v8)
    goto LABEL_25;
  v9 = v8;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_REASON"), v8);
  CFRelease(v9);
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v37 + 4);
  if (!v10)
    goto LABEL_25;
  v11 = v10;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_SUBREASON"), v10);
  CFRelease(v11);
  v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v37 + 8);
  if (!v12)
    goto LABEL_25;
  v13 = v12;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_MINORREASON"), v12);
  CFRelease(v13);
  v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v14)
    goto LABEL_25;
  v15 = v14;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_VERSION"), v14);
  CFRelease(v15);
  v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  if (!v16)
    goto LABEL_25;
  v17 = v16;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_FLAGS"), v16);
  CFRelease(v17);
  v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (const void *)((unint64_t)&valuePtr | 0xC));
  if (!v18)
    goto LABEL_25;
  v19 = v18;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_EVENTID"), v18);
  CFRelease(v19);
  v20 = CFStringCreateWithCString(kCFAllocatorDefault, "DextCrashed", 0x8000100u);
  if (!v20)
    goto LABEL_25;
  v21 = v20;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_REASON_STRING"), v20);
  CFRelease(v21);
  v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v42);
  if (!v22)
    goto LABEL_25;
  v23 = v22;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_PROGRAM_COUNTER"), v22);
  CFRelease(v23);
  v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, (char *)&v42 + 8);
  if (!v24)
    goto LABEL_25;
  v25 = v24;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_LINK_REGISTER"), v24);
  CFRelease(v25);
  v26 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v43, 0x8000100u);
  if (!v26)
    goto LABEL_25;
  v27 = v26;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_FILENAME"), v26);
  CFRelease(v27);
  v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v45);
  if (!v28)
    goto LABEL_25;
  v29 = v28;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_LINENUMBER"), v28);
  CFRelease(v29);
  v30 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v45 + 4, 0x8000100u);
  if (!v30)
    goto LABEL_25;
  v31 = v30;
  CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_FUNCTION "), v30);
  CFRelease(v31);
  v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v47 + 4);
  if (v32)
  {
    v33 = v32;
    CFDictionarySetValue(v6, CFSTR("DRIVER_AVAILABLE_TRAP_SEQUENCE"), v32);
    CFRelease(v33);
    sub_10007CA1C(a1, *(const void **)(a1 + 112), v6);
    v34 = 0;
  }
  else
  {
LABEL_25:
    v34 = 4294963395;
  }
  v35 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: exiting, err:0x%x \n", "__WiFiDevicePrepareAndSendDriverAvailableEvent", v34, valuePtr, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
  objc_autoreleasePoolPop(v35);
  if (v6)
    CFRelease(v6);
}

BOOL sub_1000702B8(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFNumber *Value;
  const char *v3;
  _BOOL8 v4;
  void *v5;
  void *v7;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "WiFiDeviceIsMultipleChannelRangingSupported");
    objc_autoreleasePoolPop(v7);
    goto LABEL_14;
  }
  v1 = *(const __CFDictionary **)(a1 + 128);
  if (!v1)
  {
LABEL_14:
    v4 = 1;
    v3 = "supported";
    goto LABEL_8;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v1, CFSTR("RANGING_FEATURES"));
  v3 = "supported";
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v4 = (valuePtr & 1) == 0;
    if ((valuePtr & 1) != 0)
      v3 = "not supported";
  }
  else
  {
    v4 = 1;
  }
LABEL_8:
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: multiple channel ranging is %s", "WiFiDeviceIsMultipleChannelRangingSupported", v3);
  objc_autoreleasePoolPop(v5);
  return v4;
}

uint64_t sub_1000703B8(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFNumber *Value;
  const char *v3;
  int v4;
  void *v5;
  void *v7;
  int valuePtr;

  valuePtr = 0;
  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "WiFiDeviceIsSWCorrectionRequiredForRanging");
    objc_autoreleasePoolPop(v7);
    goto LABEL_14;
  }
  v1 = *(const __CFDictionary **)(a1 + 128);
  if (!v1)
  {
LABEL_14:
    LOBYTE(v4) = 0;
    v3 = "not needed";
    goto LABEL_8;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v1, CFSTR("RANGING_FEATURES"));
  v3 = "not needed";
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    if ((valuePtr & 2) != 0)
      v3 = "needed";
    v4 = (valuePtr & 2) >> 1;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
LABEL_8:
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SW correction is %s for ranging on this device", "WiFiDeviceIsSWCorrectionRequiredForRanging", v3);
  objc_autoreleasePoolPop(v5);
  return v4;
}

uint64_t sub_1000704B8(uint64_t a1, unsigned __int16 a2, _WORD *a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  const __CFArray *Value;
  const __CFArray *v8;
  CFIndex v9;
  int v10;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v12;
  const __CFNumber *v13;
  _BOOL4 v14;
  _BOOL4 v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  unsigned __int16 valuePtr;

  valuePtr = a2;
  if (!a1)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "WiFiDeviceIsChannelSupportedForRanging");
    goto LABEL_29;
  }
  if (!*(_QWORD *)(a1 + 128))
  {
LABEL_30:
    v6 = 0;
    goto LABEL_31;
  }
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (!v5)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null numRef", "WiFiDeviceIsChannelSupportedForRanging");
LABEL_29:
    objc_autoreleasePoolPop(v18);
    goto LABEL_30;
  }
  v6 = v5;
  Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 128), CFSTR("RANGING_SUPP_CHANNELS"));
  if (!Value)
  {
LABEL_31:
    v14 = 0;
    v15 = a3 != 0;
    LOBYTE(v10) = 1;
    goto LABEL_32;
  }
  v8 = Value;
  if (CFArrayGetCount(Value) < 1)
  {
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v10 = 1;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v9);
      if (ValueAtIndex)
      {
        v12 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("RANGING_CHANNEL"));
        if (v12)
        {
          v13 = v12;
          if (CFEqual(v12, v6))
            goto LABEL_31;
          if (a3 && !*a3)
            CFNumberGetValue(v13, kCFNumberSInt16Type, a3);
          v10 = 0;
        }
      }
      ++v9;
    }
    while (v9 < CFArrayGetCount(v8));
  }
  v14 = v10 == 0;
  v15 = a3 != 0;
  if (a3 && !v10)
  {
    v16 = (unsigned __int16)*a3;
    if ((v16 - 12) > 0xFFFFFFF4)
    {
      LOBYTE(v10) = 0;
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: over-writing suggested channel from %d to fallback %d", "WiFiDeviceIsChannelSupportedForRanging", v16, 6);
      objc_autoreleasePoolPop(v17);
      LOBYTE(v10) = 0;
      *a3 = 6;
    }
    v15 = 1;
    v14 = 1;
  }
LABEL_32:
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v20 = "supported";
    if (v14)
      v20 = "not supported";
    if (v15)
      v21 = (unsigned __int16)*a3;
    else
      v21 = 0;
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: channel %d is %s for ranging, suggested channel %d", "WiFiDeviceIsChannelSupportedForRanging", valuePtr, v20, v21);
  }
  objc_autoreleasePoolPop(v19);
  if (v6)
    CFRelease(v6);
  return v10;
}

BOOL sub_100070734(uint64_t a1)
{
  return sub_1000D71FC(*(_QWORD *)(a1 + 144)) == 0;
}

uint64_t sub_100070754(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4352) = a2;
  *(_QWORD *)(result + 4360) = a3;
  return result;
}

uint64_t sub_100070760(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4384) = a2;
  *(_QWORD *)(result + 4392) = a3;
  return result;
}

uint64_t sub_10007076C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4952) = a2;
  *(_QWORD *)(result + 4960) = a3;
  return result;
}

uint64_t sub_100070778(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4968) = a2;
  *(_QWORD *)(result + 4976) = a3;
  return result;
}

uint64_t sub_100070784(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4984) = a2;
  *(_QWORD *)(result + 4992) = a3;
  return result;
}

uint64_t sub_100070790(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5096) = a2;
  *(_QWORD *)(result + 5104) = a3;
  return result;
}

uint64_t sub_10007079C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4744) = a2;
  *(_QWORD *)(result + 4752) = a3;
  return result;
}

uint64_t sub_1000707A8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4432) = a2;
  *(_QWORD *)(result + 4440) = a3;
  return result;
}

uint64_t sub_1000707B4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4448) = a2;
  *(_QWORD *)(result + 4456) = a3;
  return result;
}

uint64_t sub_1000707C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4464) = a2;
  *(_QWORD *)(result + 4472) = a3;
  return result;
}

uint64_t sub_1000707CC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4528) = a2;
  *(_QWORD *)(result + 4536) = a3;
  return result;
}

uint64_t sub_1000707D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4592) = a2;
  *(_QWORD *)(result + 4600) = a3;
  return result;
}

uint64_t sub_1000707E4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4544) = a2;
  *(_QWORD *)(result + 4552) = a3;
  return result;
}

uint64_t sub_1000707F0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4560) = a2;
  *(_QWORD *)(result + 4568) = a3;
  return result;
}

uint64_t sub_1000707FC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4368) = a2;
  *(_QWORD *)(result + 4376) = a3;
  return result;
}

uint64_t sub_100070808(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4400) = a2;
  *(_QWORD *)(result + 4408) = a3;
  return result;
}

uint64_t sub_100070814(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4416) = a2;
  *(_QWORD *)(result + 4424) = a3;
  return result;
}

uint64_t sub_100070820(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4608) = a2;
  *(_QWORD *)(result + 4616) = a3;
  return result;
}

uint64_t sub_10007082C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4624) = a2;
  *(_QWORD *)(result + 4632) = a3;
  return result;
}

uint64_t sub_100070838(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4640) = a2;
  *(_QWORD *)(result + 4648) = a3;
  return result;
}

uint64_t sub_100070844(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4792) = a2;
  *(_QWORD *)(result + 4800) = a3;
  return result;
}

uint64_t sub_100070850(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4808) = a2;
  *(_QWORD *)(result + 4816) = a3;
  return result;
}

uint64_t sub_10007085C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4480) = a2;
  *(_QWORD *)(result + 4488) = a3;
  return result;
}

uint64_t sub_100070868(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4496) = a2;
  *(_QWORD *)(result + 4504) = a3;
  return result;
}

uint64_t sub_100070874(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4824) = a2;
  *(_QWORD *)(result + 4832) = a3;
  return result;
}

uint64_t sub_100070880(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4840) = a2;
  *(_QWORD *)(result + 4848) = a3;
  return result;
}

uint64_t sub_10007088C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4872) = a2;
  *(_QWORD *)(result + 4880) = a3;
  return result;
}

uint64_t sub_100070898(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4888) = a2;
  *(_QWORD *)(result + 4896) = a3;
  return result;
}

uint64_t sub_1000708A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5448) = a2;
  *(_QWORD *)(result + 5456) = a3;
  return result;
}

uint64_t sub_1000708B0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5480) = a2;
  *(_QWORD *)(result + 5488) = a3;
  return result;
}

uint64_t sub_1000708BC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4904) = a2;
  *(_QWORD *)(result + 4912) = a3;
  return result;
}

uint64_t sub_1000708C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4856) = a2;
  *(_QWORD *)(result + 4864) = a3;
  return result;
}

uint64_t sub_1000708D4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4920) = a2;
  *(_QWORD *)(result + 4928) = a3;
  return result;
}

uint64_t sub_1000708E0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4936) = a2;
  *(_QWORD *)(result + 4944) = a3;
  return result;
}

uint64_t sub_1000708EC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5016) = a2;
  *(_QWORD *)(result + 5024) = a3;
  return result;
}

uint64_t sub_1000708F8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5032) = a2;
  *(_QWORD *)(result + 5040) = a3;
  return result;
}

uint64_t sub_100070904(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5048) = a2;
  *(_QWORD *)(result + 5056) = a3;
  return result;
}

uint64_t sub_100070910(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5064) = a2;
  *(_QWORD *)(result + 5072) = a3;
  return result;
}

uint64_t sub_10007091C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5112) = a2;
  *(_QWORD *)(result + 5120) = a3;
  return result;
}

uint64_t sub_100070928(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5128) = a2;
  *(_QWORD *)(result + 5136) = a3;
  return result;
}

uint64_t sub_100070934(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5160) = a2;
  *(_QWORD *)(result + 5168) = a3;
  return result;
}

uint64_t sub_100070940(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5176) = a2;
  *(_QWORD *)(result + 5184) = a3;
  return result;
}

uint64_t sub_10007094C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5192) = a2;
  *(_QWORD *)(result + 5200) = a3;
  return result;
}

uint64_t sub_100070958(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 4576) = a2;
  *(_QWORD *)(result + 4584) = a3;
  return result;
}

uint64_t sub_100070964(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5208) = a2;
  *(_QWORD *)(result + 5216) = a3;
  return result;
}

uint64_t sub_100070970(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5224) = a2;
  *(_QWORD *)(result + 5232) = a3;
  return result;
}

uint64_t sub_10007097C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5240) = a2;
  *(_QWORD *)(result + 5248) = a3;
  return result;
}

uint64_t sub_100070988(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5256) = a2;
  *(_QWORD *)(result + 5264) = a3;
  return result;
}

uint64_t sub_100070994(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v6;

  v6 = sub_10002DEA0(a1, a2);
  return sub_10015DE90((uint64_t)v6, a3, a4);
}

uint64_t sub_1000709C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5272) = a2;
  *(_QWORD *)(result + 5280) = a3;
  return result;
}

uint64_t sub_1000709CC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5288) = a2;
  *(_QWORD *)(result + 5296) = a3;
  return result;
}

uint64_t sub_1000709D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5624) = a2;
  *(_QWORD *)(result + 5632) = a3;
  return result;
}

uint64_t sub_1000709E4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5304) = a2;
  *(_QWORD *)(result + 5312) = a3;
  return result;
}

uint64_t sub_1000709F0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5320) = a2;
  *(_QWORD *)(result + 5328) = a3;
  return result;
}

uint64_t sub_1000709FC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5336) = a2;
  *(_QWORD *)(result + 5344) = a3;
  return result;
}

uint64_t sub_100070A08(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5352) = a2;
  *(_QWORD *)(result + 5360) = a3;
  return result;
}

uint64_t sub_100070A14(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5368) = a2;
  *(_QWORD *)(result + 5376) = a3;
  return result;
}

uint64_t sub_100070A20(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5384) = a2;
  *(_QWORD *)(result + 5392) = a3;
  return result;
}

uint64_t sub_100070A2C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5400) = a2;
  *(_QWORD *)(result + 5408) = a3;
  return result;
}

uint64_t sub_100070A38(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5416) = a2;
  *(_QWORD *)(result + 5424) = a3;
  return result;
}

uint64_t sub_100070A44(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5432) = a2;
  *(_QWORD *)(result + 5440) = a3;
  return result;
}

uint64_t sub_100070A50(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5496) = a2;
  *(_QWORD *)(result + 5504) = a3;
  return result;
}

uint64_t sub_100070A5C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5512) = a2;
  *(_QWORD *)(result + 5520) = a3;
  return result;
}

uint64_t sub_100070A68(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5528) = a2;
  *(_QWORD *)(result + 5536) = a3;
  return result;
}

uint64_t sub_100070A74(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5560) = a2;
  *(_QWORD *)(result + 5568) = a3;
  return result;
}

uint64_t sub_100070A80(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5544) = a2;
  *(_QWORD *)(result + 5552) = a3;
  return result;
}

uint64_t sub_100070A8C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5576) = a2;
  *(_QWORD *)(result + 5584) = a3;
  return result;
}

uint64_t sub_100070A98(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5592) = a2;
  *(_QWORD *)(result + 5600) = a3;
  return result;
}

uint64_t sub_100070AA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5608) = a2;
  *(_QWORD *)(result + 5616) = a3;
  return result;
}

uint64_t sub_100070AB0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5640) = a2;
  *(_QWORD *)(result + 5648) = a3;
  return result;
}

uint64_t sub_100070ABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *);
  uint64_t v5;

  v5 = 0;
  v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(a1 + 5640);
  if (!v3)
    return 0;
  v3(a1, a2, *(_QWORD *)(a1 + 5648), a3, &v5);
  return v5;
}

uint64_t sub_100070AFC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 184);
}

void sub_100070B04(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4;
  void **v5;
  CFTypeRef v6[2];
  CFTypeRef cf[2];
  void *v8[2];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  unint64_t v13;

  v12 = 72;
  v13 = 0xAAAAAAAAAAAAAAAALL;
  v11 = 0;
  if (!sub_10001E3EC(*(_QWORD *)(a1 + 176), &v13, &v12, &v11))
  {
    v10 = 0;
    *(_OWORD *)v8 = 0u;
    v9 = 0u;
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)cf = 0u;
    if (v11 != a2 && !sub_10001CA04(*(_QWORD *)(a1 + 176), v6, a2))
    {
      switch(LODWORD(v6[0]))
      {
        case 0:
          if (cf[0])
          {
            CFRelease(cf[0]);
            cf[0] = 0;
          }
          if (v8[0])
          {
            v5 = v8;
            free(v8[0]);
            goto LABEL_8;
          }
          goto LABEL_9;
        case 1:
          if (cf[1])
          {
            CFRelease(cf[1]);
            cf[1] = 0;
          }
          goto LABEL_5;
        case 3:
        case 5:
        case 9:
        case 0xC:
        case 0xE:
LABEL_5:
          v4 = cf[0];
          if (!cf[0])
            goto LABEL_9;
          v5 = (void **)cf;
          break;
        case 0xA:
          if (cf[0])
          {
            CFRelease(cf[0]);
            cf[0] = 0;
          }
          v4 = v8[1];
          if (!v8[1])
            goto LABEL_9;
          v5 = &v8[1];
          break;
        default:
          goto LABEL_9;
      }
      CFRelease(v4);
LABEL_8:
      *v5 = 0;
LABEL_9:
      if (v6[1])
        CFRelease(v6[1]);
    }
  }
}

CFTypeRef sub_100070C2C(uint64_t a1, const void *a2)
{
  const void *v3;
  uint64_t v4;
  CFTypeID v5;
  int v6;
  CFTypeRef result;
  void *v8;
  CFTypeRef cf;

  cf = 0;
  v3 = sub_10002DEA0(a1, a2);
  if (!v3)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "WiFiDeviceCopyInterfaceStats", a2);
    objc_autoreleasePoolPop(v8);
    return 0;
  }
  v4 = (uint64_t)v3;
  v5 = CFGetTypeID(v3);
  if (v5 != sub_10002DE64())
    return 0;
  v6 = sub_10015F640(v4, &cf);
  result = cf;
  if (v6 && cf)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

void sub_100070CD8(uint64_t a1, const void *a2, int a3)
{
  const __CFString *v6;
  const void *v7;
  const void *v8;
  void *v9;
  const char *v10;

  if (a1 && a2)
  {
    v6 = sub_10003149C(a2);
    v7 = *(const void **)(a1 + 5808);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 5808) = 0;
    }
    *(_QWORD *)(a1 + 5808) = CFDataCreateCopy(kCFAllocatorDefault, (CFDataRef)v6);
    if (v6)
    {
      v8 = *(const void **)(a1 + 5816);
      if (v8)
      {
        CFRelease(v8);
        *(_QWORD *)(a1 + 5816) = 0;
      }
    }
    if (a3 == 1)
      *(_QWORD *)(a1 + 5816) = CFDataCreateCopy(kCFAllocatorDefault, (CFDataRef)v6);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v10 = "Device";
      if (!a2)
        v10 = "Network";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s is NULL", "__WiFiDeviceRecordLastSSIDInfo", v10);
    }
    objc_autoreleasePoolPop(v9);
  }
}

void sub_100070DDC(uint64_t a1, uint64_t a2)
{
  const void *v4;
  void *v5;
  const char *v6;

  if (a1 && a2)
  {
    v4 = *(const void **)(a1 + 5824);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 5824) = 0;
    }
    *(_QWORD *)(a1 + 5824) = sub_10002B2DC((uint64_t)kCFAllocatorDefault, a2);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v6 = "Device";
      if (!a2)
        v6 = "Network";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s is NULL", "__WiFiDeviceRecordLastNetworkInfo", v6);
    }
    objc_autoreleasePoolPop(v5);
  }
}

const __CFString *sub_100070E94()
{
  return CFSTR("ap1");
}

uint64_t sub_100070EA0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 256);
}

uint64_t sub_100070EA8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 264);
}

uint64_t sub_100070EB0(uint64_t a1, const void *a2)
{
  const void *v4;
  uint64_t v5;
  CFTypeID v6;
  int i;
  int PowerState;
  void *v11;
  unsigned int v12;

  v12 = *(_DWORD *)(a1 + 48);
  v4 = sub_10002DEA0(a1, a2);
  if (v4)
  {
    v5 = (uint64_t)v4;
    v6 = CFGetTypeID(v4);
    if (v6 == sub_10002DE64())
    {
      sub_10015D888(v5);
    }
    else
    {
      for (i = 6; ; --i)
      {
        PowerState = Apple80211GetPowerState(*(_QWORD *)(a1 + 16), &v12);
        if (PowerState <= 15)
        {
          if (PowerState != -3905)
            break;
        }
        else if (PowerState != 61 && PowerState != 16)
        {
          return v12;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!PowerState)
        *(_DWORD *)(a1 + 48) = v12;
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v11);
  }
  return v12;
}

uint64_t sub_100070FA8(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  const void *v7;
  void *v8;
  CFTypeID v9;
  uint64_t v10;
  const void *v11;
  int i;
  uint64_t v13;
  void *v16;

  v6 = objc_autoreleasePoolPush();
  v7 = sub_10002DEA0(a1, a2);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting power to %s on interface %@", "WiFiDeviceSetPower", sub_1000648F0(a3), a2);
  objc_autoreleasePoolPop(v8);
  if (v7)
  {
    v9 = CFGetTypeID(v7);
    if (v9 == sub_10002DE64())
    {
      v10 = sub_10015D914((uint64_t)v7);
    }
    else if (*(_DWORD *)(a1 + 48) == (_DWORD)a3)
    {
      v10 = 0;
    }
    else
    {
      if (!(_DWORD)a3)
      {
        *(_QWORD *)(a1 + 5912) = 0;
        v11 = *(const void **)(a1 + 5920);
        if (v11)
        {
          CFRelease(v11);
          *(_QWORD *)(a1 + 5920) = 0;
        }
      }
      sub_10007114C((uint64_t *)a1);
      for (i = 6; ; --i)
      {
        v13 = Apple80211SetPowerState(*(_QWORD *)(a1 + 16), a3);
        v10 = v13;
        if ((int)v13 <= 15)
        {
          if ((_DWORD)v13 != -3905)
            break;
        }
        else if ((_DWORD)v13 != 61 && (_DWORD)v13 != 16)
        {
          goto LABEL_23;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v13)
      {
        v10 = 0;
        *(_DWORD *)(a1 + 48) = a3;
      }
    }
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v16);
    v10 = 4294963396;
  }
LABEL_23:
  objc_autoreleasePoolPop(v6);
  return v10;
}

void sub_10007114C(uint64_t *a1)
{
  __int128 v2;
  void *v3;
  void *v4;
  CFTypeRef v5;
  void *v6;
  CFTypeRef v7[2];
  CFTypeRef cf[2];
  CFTypeRef v9[2];
  __int128 v10;
  unint64_t v11;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "__WiFiDeviceCommandFlush");
    goto LABEL_67;
  }
  if (!a1[22])
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null cmdqueue ref", "__WiFiDeviceCommandFlush");
LABEL_67:
    objc_autoreleasePoolPop(v6);
    goto LABEL_7;
  }
  v11 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v9 = v2;
  v10 = v2;
  *(_OWORD *)v7 = v2;
  *(_OWORD *)cf = v2;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Beginning command queue flush with error %d", 82);
  objc_autoreleasePoolPop(v3);
  sub_100154904(a1[22]);
  sub_10015488C(a1[22], 0, 0);
  while (!sub_100019A60(a1[22], v7, 0x48uLL, a1 + 23))
  {
    switch(LODWORD(v7[0]))
    {
      case 0:
        if (BYTE8(v10))
        {
          a1[591] = 0;
          a1[592] = 0;
        }
        goto LABEL_29;
      case 1:
        if (BYTE8(v10))
        {
          a1[597] = 0;
          a1[598] = 0;
        }
        v5 = cf[0];
        if (v9[0])
          ((void (*)(uint64_t *, CFTypeRef, CFTypeRef, _QWORD, uint64_t, CFTypeRef))v9[0])(a1, v7[1], cf[0], 0, 82, v9[1]);
        if (cf[1])
        {
          CFRelease(cf[1]);
          cf[1] = 0;
        }
        goto LABEL_49;
      case 3:
        if (BYTE8(v10))
        {
          a1[582] = 0;
          a1[583] = 0;
        }
        goto LABEL_25;
      case 4:
      case 6:
        if (cf[0])
          ((void (*)(uint64_t *, CFTypeRef, uint64_t, CFTypeRef))cf[0])(a1, v7[1], 82, cf[1]);
        break;
      case 5:
        if (BYTE8(v10))
        {
          a1[584] = 0;
          a1[585] = 0;
        }
LABEL_25:
        v5 = cf[0];
        if (cf[1])
          ((void (*)(uint64_t *, CFTypeRef, uint64_t, CFTypeRef))cf[1])(a1, v7[1], 82, v9[0]);
        goto LABEL_51;
      case 9:
        if (BYTE8(v10))
        {
          a1[625] = 0;
          a1[626] = 0;
        }
LABEL_29:
        v5 = cf[0];
        if (cf[1])
          ((void (*)(uint64_t *, CFTypeRef, _QWORD, _QWORD, uint64_t, CFTypeRef))cf[1])(a1, v7[1], 0, 0, 82, v9[0]);
        goto LABEL_49;
      case 0xA:
        if (BYTE8(v10))
        {
          a1[586] = 0;
          a1[587] = 0;
        }
        if (cf[1])
          ((void (*)(uint64_t *, CFTypeRef, uint64_t, CFTypeRef))cf[1])(a1, v7[1], 82, v9[0]);
        if (v7[1])
        {
          CFRelease(v7[1]);
          v7[1] = 0;
        }
        if (cf[0])
        {
          CFRelease(cf[0]);
          cf[0] = 0;
        }
        if (v9[1])
        {
          CFRelease(v9[1]);
          v9[1] = 0;
        }
        break;
      case 0xB:
        sub_10007AA3C((uint64_t)a1, v7[1], (uint64_t)cf[0], (void (*)(uint64_t, const void *, uint64_t, uint64_t))cf[1], (uint64_t)v9[0]);
        if (cf[0])
        {
          CFRelease(cf[0]);
          cf[0] = 0;
        }
        if (v7[1])
        {
          CFRelease(v7[1]);
          v7[1] = 0;
        }
        break;
      case 0xC:
        if (BYTE8(v10))
        {
          a1[643] = 0;
          a1[644] = 0;
        }
        v5 = cf[0];
        if (cf[1])
          ((void (*)(uint64_t *, CFTypeRef, _QWORD, uint64_t, CFTypeRef))cf[1])(a1, v7[1], 0, 82, v9[0]);
LABEL_49:
        if (v7[1])
        {
          CFRelease(v7[1]);
          v7[1] = 0;
        }
LABEL_51:
        if (v5)
          CFRelease(v5);
        break;
      case 0xE:
        if (BYTE8(v10))
        {
          a1[683] = 0;
          a1[684] = 0;
        }
        if (cf[1])
          ((void (*)(uint64_t *, CFTypeRef, uint64_t, CFTypeRef))cf[1])(a1, v7[1], 82, v9[0]);
        if (v7[1])
        {
          CFRelease(v7[1]);
          v7[1] = 0;
        }
        if (cf[0])
        {
          CFRelease(cf[0]);
          cf[0] = 0;
        }
        break;
      default:
        break;
    }
  }
  sub_10015488C(a1[22], (uint64_t)sub_100019E70, (uint64_t)a1);
LABEL_7:
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Finished command queue flush with error %d", 82);
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_100071564()
{
  return 4294963396;
}

uint64_t sub_10007156C(uint64_t a1, CFTypeRef cf, unsigned int a3, unsigned int a4)
{
  unint64_t v5;
  unint64_t v6;
  CFTypeRef v7;

  v5 = a3 | 0xAAAAAAAA00000000;
  v6 = a4 | 0xAAAAAAAA00000000;
  v7 = CFRetain(cf);
  return sub_10001C71C(a1, 7u, 0, (uint64_t)v7, v5, v6, 0, 0, 0);
}

uint64_t sub_1000715E0(uint64_t a1, CFTypeRef cf, unsigned int a3)
{
  unint64_t v4;
  CFTypeRef v5;

  v4 = a3 | 0xAAAAAAAA00000000;
  v5 = CFRetain(cf);
  return sub_10001C71C(a1, 0xDu, 0, (uint64_t)v5, v4, 0, 0, 0, 0);
}

uint64_t sub_100071644(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 32) >> 1) & 1;
}

uint64_t sub_100071650(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 34) >> 4) & 1;
}

uint64_t sub_10007165C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 35) >> 3) & 1;
}

uint64_t sub_100071668(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 46) >> 1) & 1;
}

uint64_t sub_100071674(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 44) >> 7;
}

uint64_t sub_100071680(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 36) >> 2) & 1;
}

uint64_t sub_10007168C(uint64_t a1, BOOL *a2)
{
  uint64_t v2;

  if ((*(_BYTE *)(a1 + 34) & 0x20) == 0)
  {
    v2 = (*(unsigned __int8 *)(a1 + 36) >> 1) & 1;
    if (!a2)
      return v2;
    goto LABEL_5;
  }
  v2 = 1;
  if (a2)
LABEL_5:
    *a2 = (*(_BYTE *)(a1 + 36) & 2) != 0;
  return v2;
}

uint64_t sub_1000716C0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 33) >> 5) & 1;
}

uint64_t sub_1000716CC(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 34) >> 6) & 1;
}

BOOL sub_1000716D8(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 35) & 0x44) != 0;
}

uint64_t sub_1000716EC(const __CFString *a1)
{
  return CFStringHasSuffix(a1, CFSTR("Device14,1"));
}

uint64_t sub_1000716F8(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 37) >> 6) & 1;
}

uint64_t sub_100071704(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 38) >> 7;
}

uint64_t sub_100071710(uint64_t a1)
{
  return *(_BYTE *)(a1 + 39) & 1;
}

uint64_t sub_10007171C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 44) >> 3) & 1;
}

uint64_t sub_100071728(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 41) >> 1) & 1;
}

uint64_t sub_100071734(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 41) >> 2) & 1;
}

uint64_t sub_100071740(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 41) >> 3) & 1;
}

uint64_t sub_10007174C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 41) >> 5) & 1;
}

uint64_t sub_100071758(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 54);
}

uint64_t sub_100071760(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 55);
}

uint64_t sub_100071768(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 42) >> 1) & 1;
}

uint64_t sub_100071774(uint64_t a1, const void *a2, uint64_t a3)
{
  const void *v6;
  CFTypeID v7;
  void *v8;
  uint64_t result;
  int i;

  v6 = sub_10002DEA0(a1, a2);
  if (!v6)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    goto LABEL_5;
  }
  v7 = CFGetTypeID(v6);
  if (v7 == sub_10002DE64())
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Set Background Scan is not supported by %@", a2);
LABEL_5:
    objc_autoreleasePoolPop(v8);
    return 4294963396;
  }
  for (i = 6; ; --i)
  {
    result = Apple80211Set(*(_QWORD *)(a1 + 16), 47, 0, a3, 8);
    if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  return result;
}

uint64_t sub_10007186C(uint64_t a1, const void *a2, unsigned int a3)
{
  const void *v5;
  const void *v6;
  CFTypeID v7;
  void *v8;
  void *v9;
  uint64_t v10;
  int i;
  uint64_t v12;
  void *v14;
  void *v16;
  unsigned int v17;

  v17 = a3;
  v5 = sub_10002DEA0(a1, a2);
  if (!v5)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    goto LABEL_6;
  }
  v6 = v5;
  if ((MGGetBoolAnswer(CFSTR("apple-internal-install")) & 1) == 0)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Scan backoff reporting blocked on customer builds");
    v9 = v16;
    goto LABEL_7;
  }
  v7 = CFGetTypeID(v6);
  if (v7 == sub_10002DE64())
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Set scan backoff report is not supported by %@", a2);
LABEL_6:
    v9 = v8;
LABEL_7:
    objc_autoreleasePoolPop(v9);
    return 4294963396;
  }
  for (i = 6; ; --i)
  {
    v12 = Apple80211Set(*(_QWORD *)(a1 + 16), 264, 0, &v17, 4);
    v10 = v12;
    if ((_DWORD)v12 != -3905 && (_DWORD)v12 != 61 && (_DWORD)v12 != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  v14 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, state 0x%x, error %d", "WiFiDeviceSetScanBackoffReport", a2, v17, v10);
  objc_autoreleasePoolPop(v14);
  return v10;
}

uint64_t sub_1000719FC(uint64_t a1, int a2)
{
  CFStringRef NetworkInterfaceEntity;
  const __CFString *v5;
  const __SCDynamicStore *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFMutableDictionaryRef Mutable;
  int v10;
  void *v11;
  const char *v12;
  void *v14;
  void *v15;

  if (a1)
  {
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), kSCEntNetInterfaceActiveDuringSleepRequested);
    if (NetworkInterfaceEntity)
    {
      v5 = NetworkInterfaceEntity;
      v6 = *(const __SCDynamicStore **)(a1 + 152);
      if (v6)
      {
        v7 = (const __CFString *)SCDynamicStoreCopyValue(v6, v5);
        v8 = v7;
        if (!a2 || v7)
        {
          if (a2 || !v7)
          {
            v11 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v12 = "removed";
              if (a2)
                v12 = "set";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ActiveDuringSleepRequested is already %s (%@).", "WiFiDeviceRequestAssociatedSleep", v12, v8);
            }
            objc_autoreleasePoolPop(v11);
            CFRelease(v5);
            if (!v8)
              return 0;
            v10 = 1;
          }
          else
          {
            v10 = SCDynamicStoreRemoveValue(*(SCDynamicStoreRef *)(a1 + 152), v5);
            CFRelease(v5);
          }
          v5 = v8;
        }
        else
        {
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v10 = SCDynamicStoreSetValue(*(SCDynamicStoreRef *)(a1 + 152), v5, Mutable);
          if (Mutable)
            CFRelease(Mutable);
        }
      }
      else
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: dynamicStoreRef is NULL", "WiFiDeviceRequestAssociatedSleep");
        objc_autoreleasePoolPop(v15);
        v10 = 0;
      }
      CFRelease(v5);
      if (v10)
        return 0;
    }
    else
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: stateKey is NULL", "WiFiDeviceRequestAssociatedSleep");
      objc_autoreleasePoolPop(v14);
    }
  }
  return 4294963396;
}

uint64_t sub_100071BF8(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_100019D8C(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t sub_100071C00(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t result;

  for (i = 6; ; --i)
  {
    result = Apple80211Get(*(_QWORD *)(a1 + 16), 390, 0, a2, 2264);
    if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  return result;
}

CFMutableArrayRef sub_100071C70(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v3;
  void *v4;
  void *v5;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s beaconScanCache alloc cache failed", "WiFiDeviceCopyScanCache");
    objc_autoreleasePoolPop(v5);
    return 0;
  }
  v3 = Mutable;
  sub_100071C00(a1, (uint64_t)Mutable);
  if (!CFArrayGetCount(v3))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - beaconScanCache not available", "WiFiDeviceCopyScanCache");
    objc_autoreleasePoolPop(v4);
    CFRelease(v3);
    return 0;
  }
  return v3;
}

__CFArray *sub_100071D5C(uint64_t a1, uint64_t a2, const __CFDictionary *a3, const __CFArray *a4, int a5)
{
  __CFArray *Mutable;
  __CFArray *v10;
  const __CFArray *v11;
  BOOL v12;
  void *v13;
  CFMutableArrayRef v14;
  __CFArray *v15;
  CFIndex v16;
  const void *ValueAtIndex;
  const void *v18;
  void *v19;
  int v20;
  CFMutableArrayRef v21;
  CFMutableArrayRef v22;
  CFMutableArrayRef v23;
  __CFArray *v24;
  CFIndex FirstIndexOfValue;
  CFIndex v26;
  const void *v27;
  const void *v28;
  CFIndex Count;
  const void *v30;
  __CFDictionary *v31;
  __CFDictionary *v32;
  const __CFNumber *v33;
  CFIndex v34;
  __CFArray *v35;
  __CFArray *v36;
  const __CFDictionary *v38;
  CFRange v39;
  CFRange v40;
  CFRange v41;
  CFRange v42;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
    return Mutable;
  v10 = sub_10001785C(a4, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248));
  v11 = v10;
  if (*(_BYTE *)(a1 + 5896))
    v12 = 1;
  else
    v12 = v10 == 0;
  if (v12)
    goto LABEL_20;
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Filtering WAPI networks", "__processScanBeaconCacheEntry");
  objc_autoreleasePoolPop(v13);
  v14 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v14)
  {
LABEL_20:
    v15 = v11;
    if (!a3)
      goto LABEL_16;
  }
  else
  {
    v15 = v14;
    if (CFArrayGetCount(v11) >= 1)
    {
      v16 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v11, v16);
        v18 = ValueAtIndex;
        if (!ValueAtIndex || !sub_10002DAF0((_BOOL8)ValueAtIndex))
          CFArrayAppendValue(v15, v18);
        ++v16;
      }
      while (v16 < CFArrayGetCount(v11));
    }
    CFRelease(v11);
    if (!a3)
    {
LABEL_16:
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: scanRequest is NULL. Not filtering based on SSID/Channel matching.", "__processScanBeaconCacheEntry");
      objc_autoreleasePoolPop(v19);
      v42.length = CFArrayGetCount(v15);
      v42.location = 0;
      CFArrayAppendArray(Mutable, v15, v42);
      v20 = 1;
      if (!v15)
        goto LABEL_37;
      goto LABEL_36;
    }
  }
  v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v21)
  {
LABEL_45:
    v20 = 0;
    if (!v15)
      goto LABEL_37;
    goto LABEL_36;
  }
  v22 = v21;
  v23 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v23)
  {
    CFRelease(v22);
    goto LABEL_45;
  }
  v24 = v23;
  sub_100079DD4(a3, v22);
  v38 = a3;
  sub_100079AE8(a1, a3, v24);
  v39.length = CFArrayGetCount(v22);
  v39.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v22, v39, &stru_100238178);
  if (CFArrayGetCount(v15) < 1)
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v26 = 0;
    do
    {
      v27 = CFArrayGetValueAtIndex(v15, v26);
      if (v27)
      {
        v28 = v27;
        if (FirstIndexOfValue != -1
          || (Count = CFArrayGetCount(v22),
              v30 = sub_10002B088(v28),
              v40.location = 0,
              v40.length = Count,
              CFArrayGetFirstIndexOfValue(v22, v40, v30) != -1))
        {
          v31 = sub_100079EC8((uint64_t)v28);
          if (v31)
          {
            v32 = v31;
            v41.length = CFArrayGetCount(v24);
            v41.location = 0;
            if (CFArrayGetFirstIndexOfValue(v24, v41, v32) != -1)
            {
              v33 = sub_100017A54((uint64_t)v28, CFSTR("ORIG_AGE"));
              sub_10002B698((uint64_t)v28, CFSTR("AGE"), (uint64_t)v33);
              CFArrayAppendValue(Mutable, v28);
              v20 = 1;
            }
            CFRelease(v32);
          }
        }
      }
      ++v26;
    }
    while (v26 < CFArrayGetCount(v15));
  }
  CFRelease(v22);
  CFRelease(v24);
  a3 = v38;
  if (!v15)
    goto LABEL_37;
LABEL_36:
  CFRelease(v15);
LABEL_37:
  if (v20)
  {
    v34 = CFArrayGetCount(Mutable);
    if (a5)
    {
      if (v34)
      {
        v35 = sub_1000176C4(Mutable, 0, a3);
        v36 = sub_1000173D8(v35);
        if (v35)
          CFRelease(v35);
        CFRelease(Mutable);
        return v36;
      }
    }
  }
  return Mutable;
}

void sub_100072118(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  CFIndex v4;
  unsigned int *v5;

  v5 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  v3 = 0;
  v4 = 72;
  if (!sub_10001E3EC(*(_QWORD *)(a1 + 176), &v5, &v4, &v3) && *((_BYTE *)v5 + 56) == 1 && *v5 <= 1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Starting %d second(s) timer to clear pending command type %d", "WiFiDeviceClearPendingCommand", 1, *v5);
    objc_autoreleasePoolPop(v2);
    sub_100154C48(*(_QWORD *)(a1 + 176), 1);
  }
}

uint64_t sub_1000721D8(uint64_t a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6, int a7)
{
  void *v8;

  if (a1)
  {
    *(_DWORD *)(a1 + 5936) = a7;
    return sub_100072264(a1, a2, a3, a4, a7, a5, a6, 0);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDeviceAssociateAsync");
    objc_autoreleasePoolPop(v8);
    return 4294963396;
  }
}

uint64_t sub_100072264(uint64_t a1, const void *a2, const void *a3, const void *a4, int a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  if (a1)
  {
    *(_DWORD *)(a1 + 5936) = a5;
    if (sub_10002DAF0((_BOOL8)a3) && !*(_BYTE *)(a1 + 5896))
    {
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WAPI support is disabled. Error connecting to %@ ", "WiFiDeviceAssociateAsyncWithCommand", sub_10002B088(a3));
      objc_autoreleasePoolPop(v21);
      return 4294963393;
    }
    else
    {
      v15 = CFRetain(a2);
      v16 = CFRetain(a3);
      if (a4)
        v17 = CFRetain(a4);
      else
        v17 = 0;
      v20 = sub_10001C71C(a1, 1u, 0, (uint64_t)v15, (uint64_t)v16, (uint64_t)v17, a6, a7, a8);
      v19 = v20;
      if (a3 && (_DWORD)v20)
        CFRelease(a3);
    }
  }
  else
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDeviceAssociateAsyncWithCommand");
    objc_autoreleasePoolPop(v18);
    return 4294963396;
  }
  return v19;
}

uint64_t sub_1000723DC(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const __CFDictionary *v13;
  __CFDictionary *v14;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const __CFNumber *v17;
  unsigned int v18;
  __CFDictionary *MutableCopy;
  void *v20;
  const void **v21;
  void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const __CFString *v26;
  const __CFString *v27;
  CFTypeID v28;
  const void *v29;
  _BYTE *v30;
  CFTypeID v31;
  const __CFData *v32;
  CFTypeID v33;
  const __CFBoolean *v34;
  void *v35;
  const __CFString *v36;
  CFDataRef v37;
  NSObject *v38;
  void *v39;
  const void **v40;
  const void **v41;
  const void **v42;
  const __CFBoolean *v43;
  CFBooleanRef v44;
  CFBooleanRef v45;
  void *v46;
  CFNumberRef v47;
  _BOOL4 v48;
  _QWORD *v49;
  _QWORD *v50;
  CFTypeID v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  int v55;
  const void *v58;
  void *v59;
  void *v61;
  void *v62;
  __CFDictionary *v63;
  void *v64;
  void *v65;
  void *v66;
  const __CFData *v67;
  id v68;
  void *context;
  _BOOL4 v73;
  unint64_t valuePtr;
  _QWORD block[6];
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t v79;

  context = objc_autoreleasePoolPush();
  v9 = sub_10002B088(a3);
  v76 = 0;
  v77 = &v76;
  v78 = 0x2020000000;
  v79 = 0;
  v10 = sub_100026664((CFDictionaryRef *)a3);
  v68 = sub_100027D10((uint64_t)a3);
  v11 = *(unsigned int *)(a1 + 5948);
  if ((_DWORD)v11)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "(Simulated) Failed to associate with %@: %d", sub_10002B088(a3), v11);
    objc_autoreleasePoolPop(v12);
    goto LABEL_99;
  }
  v13 = sub_1000C33B4((uint64_t)a3);
  v14 = v13;
  if (!v13)
  {
    v11 = 4294963396;
    goto LABEL_99;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("PRIVATE_MAC_ADDRESS"));
  if (Value && (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(Value)))
  {
    v67 = (const __CFData *)CFDictionaryGetValue(Value, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
    v17 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
    v18 = sub_10002B75C(v67);
    if (*(_BYTE *)(a1 + 224))
    {
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
      if (v18)
      {
        if (v17 && sub_100064F80(v17) == 2)
        {
          v20 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Attempting association for network <%@>. Using Private Mac:  %@", "__WiFiDeviceAssociateLowLevel", v9, v67);
          objc_autoreleasePoolPop(v20);
          v21 = (const void **)&kCFBooleanTrue;
        }
        else
        {
          v64 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Attempting association for network <%@>. Using Static Private Mac:  %@", "__WiFiDeviceAssociateLowLevel", v9, v67);
          objc_autoreleasePoolPop(v64);
          v21 = (const void **)&kCFBooleanFalse;
        }
        CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), *v21);
      }
      else
      {
        v65 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Attempting association for network <%@>. Not using Private Mac", "__WiFiDeviceAssociateLowLevel", v9);
        objc_autoreleasePoolPop(v65);
        CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), kCFBooleanFalse);
        v67 = *(const __CFData **)(a1 + 232);
      }
      CFDictionarySetValue(v14, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
      if (MutableCopy)
        CFRelease(MutableCopy);
      goto LABEL_19;
    }
    v61 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Global Feature is disabled for this type of network <%@>", "__WiFiDeviceAssociateLowLevel", v9);
    objc_autoreleasePoolPop(v61);
    if (v18)
    {
      v62 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation : Randomisation Global Feature is disabled. Private Mac is is being used for the network");
      objc_autoreleasePoolPop(v62);
      v63 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
      CFDictionarySetValue(v63, CFSTR("PRIVATE_MAC_ADDRESS_VALID"), kCFBooleanFalse);
      CFDictionarySetValue(v63, CFSTR("PRIVATE_MAC_ADDRESS"), *(const void **)(a1 + 232));
      CFDictionarySetValue(v14, CFSTR("PRIVATE_MAC_ADDRESS"), v63);
      if (v63)
        CFRelease(v63);
    }
  }
  else
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Using HW mac address. Network : %@", "__WiFiDeviceAssociateLowLevel", sub_10002B088(a3));
    objc_autoreleasePoolPop(v22);
  }
  v67 = *(const __CFData **)(a1 + 232);
LABEL_19:
  if (a3)
  {
    v23 = *(const void **)(a1 + 5840);
    if (v23)
    {
      CFRelease(v23);
      *(_QWORD *)(a1 + 5840) = 0;
    }
    v24 = *(const void **)(a1 + 5848);
    if (v24)
    {
      CFRelease(v24);
      *(_QWORD *)(a1 + 5848) = 0;
    }
    v25 = *(const void **)(a1 + 5856);
    if (v25)
    {
      CFRelease(v25);
      *(_QWORD *)(a1 + 5856) = 0;
    }
    v26 = (const __CFString *)sub_10002B088(a3);
    *(_QWORD *)(a1 + 5840) = CFStringCreateCopy(kCFAllocatorDefault, v26);
    v27 = (const __CFString *)sub_10002BE64((uint64_t)a3, CFSTR("BSSID"));
    if (v27)
    {
      v28 = CFStringGetTypeID();
      if (v28 == CFGetTypeID(v27))
        *(_QWORD *)(a1 + 5848) = CFStringCreateCopy(kCFAllocatorDefault, v27);
    }
    v29 = sub_10002BE64((uint64_t)a3, CFSTR("PRIVATE_MAC_ADDRESS"));
    v30 = (_BYTE *)(a1 + 5864);
    if (v29
      && (v31 = CFDictionaryGetTypeID(), v31 == CFGetTypeID(v29))
      && (v32 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v29, CFSTR("PRIVATE_MAC_ADDRESS_VALUE")),
          sub_10002B75C(v32)))
    {
      *v30 = 1;
      if (v32)
      {
        v33 = CFDataGetTypeID();
        if (v33 == CFGetTypeID(v32))
          *(_QWORD *)(a1 + 5856) = CFDataCreateCopy(kCFAllocatorDefault, v32);
      }
    }
    else
    {
      *v30 = 0;
    }
    v34 = (const __CFBoolean *)sub_10002BE64((uint64_t)a3, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
    if (v34 && v34 == kCFBooleanTrue)
    {
      *(_BYTE *)(a1 + 5865) = 1;
      v35 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Network <%@> we are associating to is a migrated network", "__WiFiDeviceRecordLastAttemptedMacInfo", sub_10002B088(a3));
      objc_autoreleasePoolPop(v35);
    }
    else
    {
      *(_BYTE *)(a1 + 5865) = 0;
    }
    sub_100061728((uint64_t)a3, a1 + 5868);
  }
  if (*(_QWORD *)(a1 + 64))
  {
    v36 = (const __CFString *)sub_10002B088(a3);
    v37 = sub_1000CEA08(v67, v36);
    v77[3] = (uint64_t)v37;
    CFRetain((CFTypeRef)a1);
    v38 = *(NSObject **)(a1 + 64);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10007F3BC;
    block[3] = &unk_10022F160;
    block[4] = &v76;
    block[5] = a1;
    dispatch_async(v38, block);
  }
  else
  {
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceAssociateLowLevel");
    objc_autoreleasePoolPop(v39);
  }
  v40 = (const void **)&kCFBooleanFalse;
  if ((*(_BYTE *)(a1 + 32) & 2) != 0)
    v40 = (const void **)&kCFBooleanTrue;
  CFDictionarySetValue(v14, CFSTR("FT_ENABLED"), *v40);
  v41 = (const void **)&kCFBooleanFalse;
  if ((*(_BYTE *)(a1 + 34) & 0x10) != 0)
    v41 = (const void **)&kCFBooleanTrue;
  CFDictionarySetValue(v14, CFSTR("80211W_ENABLED"), *v41);
  v42 = (const void **)&kCFBooleanFalse;
  if ((*(_BYTE *)(a1 + 35) & 8) != 0)
    v42 = (const void **)&kCFBooleanTrue;
  CFDictionarySetValue(v14, CFSTR("FAST_ENTERPRISE_NETWORK_SUPPORTED_DEVICE"), *v42);
  v43 = (const __CFBoolean *)sub_10002BE64((uint64_t)a3, CFSTR("WiFiInstantHotspotJoining"));
  if (v43 == kCFBooleanTrue)
    v44 = v43;
  else
    v44 = kCFBooleanFalse;
  CFDictionarySetValue(v14, CFSTR("INSTANT_HOTSPOT_ASSOC"), v44);
  if (sub_10002BE64((uint64_t)a3, CFSTR("WiFiAutoInstantHotspotJoining")) == kCFBooleanTrue)
    v45 = kCFBooleanTrue;
  else
    v45 = kCFBooleanFalse;
  CFDictionarySetValue(v14, CFSTR("AUTO_INSTANT_HOTSPOT_ASSOC"), v45);
  valuePtr = (unint64_t)sub_100017A54((uint64_t)a3, CFSTR("TransitionDisabledFlags"));
  if (byte_10026DD61 && (!*(_DWORD *)(a1 + 5936) || objc_msgSend(v68, "isAllowedInLockdownMode")))
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Applying APPLE80211_TRANS_DISABLED_TKIP because lockdown mode is enabled while joining secure network (%@)", "__WiFiDeviceAssociateLowLevel", v68);
    objc_autoreleasePoolPop(v46);
    valuePtr |= 0x10uLL;
  }
  v47 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  if (v47)
  {
    CFDictionarySetValue(v14, CFSTR("TRANS_DISABLED_FLAGS_ASSOC"), v47);
    CFRelease(v47);
  }
  if ((_os_feature_enabled_impl("CoreWiFi", "Figaro5GTDD") & 1) == 0)
  {
    v48 = a3 && sub_10000BE8C((uint64_t)a3);
    sub_1000773CC(a1, v48);
  }
  sub_100070CD8(a1, a3, 0);
  v49 = sub_10002DEA0(a1, a2);
  v50 = v49;
  if (v49)
  {
    v51 = CFGetTypeID(v49);
    if (v51 == sub_10002DE64())
    {
      v52 = sub_10015DB18(v50, (uint64_t)a2, (uint64_t)v14, a4, 1, a5, a6);
    }
    else
    {
      v53 = 0;
      v11 = 3766617154;
      *(_QWORD *)(a1 + 4760) = a5;
      *(_QWORD *)(a1 + 4768) = a6;
      while (1)
      {
        v73 = objc_msgSend(v10, "disable6EMode") == (id)2;
        v54 = 7;
        while (1)
        {
          v55 = Apple80211Set(*(_QWORD *)(a1 + 16), 422, 0, &v73, 4);
          if (v55 != -3905 && v55 != 61 && v55 != 16)
            break;
          if (!--v54)
            break;
          usleep(0x7A120u);
        }
        v52 = Apple80211AssociateAsync(*(_QWORD *)(a1 + 16), v14, a4);
        if ((_DWORD)v52 != -528350142)
          break;
        usleep(0xC8u);
        if (v53++ >= 5)
          goto LABEL_92;
      }
    }
    v11 = v52;
LABEL_92:
    v58 = *(const void **)(a1 + 5832);
    if (v58)
    {
      CFRelease(v58);
      *(_QWORD *)(a1 + 5832) = 0;
    }
    *(_QWORD *)(a1 + 5832) = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)a3);
    if ((_DWORD)v11)
    {
      v59 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to associate with %@: %d", sub_10002B088(a3), v11);
      objc_autoreleasePoolPop(v59);
      sub_100051054(a1, v11, a3, *(_DWORD *)(a1 + 5872));
    }
  }
  else
  {
    v66 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v66);
    v11 = 0;
  }
  CFRelease(v14);
LABEL_99:
  _Block_object_dispose(&v76, 8);
  objc_autoreleasePoolPop(context);
  return v11;
}

void sub_100072E20(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_100072E44(uint64_t a1, const void *a2, int a3)
{
  sub_10014862C(*(_QWORD *)(a1 + 144), a2, a3);
}

void sub_100072E4C(uint64_t a1)
{
  sub_1001487B4(*(_QWORD *)(a1 + 144));
}

uint64_t sub_100072E54(uint64_t a1, CFTypeRef cf, unsigned int a3, int a4)
{
  const void *v8;
  void *v9;
  uint64_t v10;
  CFTypeRef v12;

  *(_DWORD *)(a1 + 5800) = a4;
  *(_QWORD *)(a1 + 5912) = 0;
  v8 = *(const void **)(a1 + 5920);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  if ((a4 - 1000) <= 0xB && ((1 << (a4 + 24)) & 0x80B) != 0)
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user-initiated disconnect or Trigger Disconnect (reason=%@)", "WiFiDeviceDisassociate", sub_100064AA8(a4));
    objc_autoreleasePoolPop(v9);
    return sub_100072F84(a1, cf, v10, *(_DWORD *)(a1 + 5800), "WiFiDeviceDisassociate", 10627);
  }
  else
  {
    v12 = CFRetain(cf);
    return sub_10001C71C(a1, 2u, 0, (uint64_t)v12, a3 | 0xAAAAAAAA00000000, 0, 0, 0, 0);
  }
}

uint64_t sub_100072F84(uint64_t a1, const void *a2, uint64_t a3, int a4, const char *a5, uint64_t a6)
{
  void *v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  int i;
  uint64_t v24;
  void *v27;
  int valuePtr;

  v11 = objc_autoreleasePoolPush();
  v12 = sub_10002DEA0(a1, a2);
  *(_QWORD *)(a1 + 5912) = 0;
  v13 = *(const void **)(a1 + 5920);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  if (!v12)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v27);
    goto LABEL_39;
  }
  v14 = CFGetTypeID(v12);
  if (v14 == sub_10002DE64())
  {
    v15 = sub_10015DCCC((uint64_t)v12);
    goto LABEL_34;
  }
  v16 = 9;
  switch(a4)
  {
    case 1000:
    case 1003:
    case 1009:
    case 1010:
      break;
    case 1001:
    case 1008:
    case 1013:
      v16 = 8;
      break;
    case 1002:
      v16 = 5;
      break;
    case 1004:
      v16 = 6;
      break;
    case 1005:
      v16 = 1;
      break;
    case 1006:
    case 1007:
      v16 = 7;
      break;
    case 1011:
      goto LABEL_10;
    case 1012:
      v16 = 3;
      break;
    default:
      if (a4)
LABEL_10:
        v16 = 10;
      break;
  }
  valuePtr = v16;
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v18 = "";
    if (a5)
      v18 = a5;
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "asked to Disassociate by <%s:%d> reason =<%d> \n", v18, a6, v16);
  }
  objc_autoreleasePoolPop(v17);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
LABEL_39:
    v15 = 4294963396;
    goto LABEL_34;
  }
  v20 = Mutable;
  v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v21)
  {
    CFRelease(v20);
    goto LABEL_39;
  }
  v22 = v21;
  if (a4 && !*(_DWORD *)(a1 + 5800))
    *(_DWORD *)(a1 + 5800) = a4;
  CFDictionaryAddValue(v20, CFSTR("DISASSOC_REASON"), v21);
  for (i = 6; ; --i)
  {
    v24 = Apple80211DisassociateExt(*(_QWORD *)(a1 + 16), v20);
    v15 = v24;
    if ((_DWORD)v24 != -3905 && (_DWORD)v24 != 61 && (_DWORD)v24 != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  CFRelease(v20);
  CFRelease(v22);
LABEL_34:
  objc_autoreleasePoolPop(v11);
  return v15;
}

uint64_t sub_1000731E4(uint64_t a1, CFTypeRef cf, unsigned int a3)
{
  unint64_t v5;
  CFTypeRef v6;
  uint64_t v7;
  uint64_t v8;

  v5 = a3 | 0xAAAAAAAA00000000;
  v6 = CFRetain(cf);
  v7 = sub_10001C71C(a1, 0xFu, 0, (uint64_t)v6, v5, 0, 0, 0, 0);
  v8 = v7;
  if (cf && (_DWORD)v7)
    CFRelease(cf);
  return v8;
}

uint64_t sub_10007326C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  int i;
  uint64_t v8;
  uint64_t v9;
  int v12;

  v12 = a3;
  v5 = objc_autoreleasePoolPush();
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s, mode: %d", "_WiFiDeviceSet6GDisableMode", a3);
  objc_autoreleasePoolPop(v6);
  for (i = 6; ; --i)
  {
    v8 = Apple80211Set(*(_QWORD *)(a1 + 16), 422, 0, &v12, 4);
    v9 = v8;
    if ((_DWORD)v8 != -3905 && (_DWORD)v8 != 61 && (_DWORD)v8 != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  objc_autoreleasePoolPop(v5);
  return v9;
}

CFTypeRef sub_10007333C(uint64_t a1)
{
  CFTypeRef result;
  int i;
  uint64_t v4;
  uint64_t v5;
  void *v7;
  void *v8;
  CFTypeRef cf;

  cf = 0;
  if (a1)
  {
    result = *(CFTypeRef *)(a1 + 5792);
    if (!result)
    {
      for (i = 6; ; --i)
      {
        v4 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 44, 0, &cf);
        v5 = v4;
        if ((int)v4 <= 15)
        {
          if ((_DWORD)v4 != -3905)
            break;
        }
        else if ((_DWORD)v4 != 61 && (_DWORD)v4 != 16)
        {
          goto LABEL_14;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v4)
      {
        result = cf;
        *(_QWORD *)(a1 + 5792) = cf;
        return result;
      }
LABEL_14:
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error copying hardware version %d", "WiFiDeviceGetHardwareVersion", v5);
      objc_autoreleasePoolPop(v7);
      return cf;
    }
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDeviceGetHardwareVersion");
    objc_autoreleasePoolPop(v8);
    return 0;
  }
  return result;
}

void sub_100073470(uint64_t a1)
{
  void *v2;
  const void *v3;
  const void *v4;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "gasCache: Purging GAS cache");
  objc_autoreleasePoolPop(v2);
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 5752)))
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 5752));
  v3 = *(const void **)(a1 + 5728);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 5728) = 0;
  }
  v4 = *(const void **)(a1 + 5736);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5736) = 0;
  }
}

double sub_1000734F0(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 4304);
  else
    return 0.0;
}

uint64_t sub_100073504(uint64_t result, double a2)
{
  if (result)
  {
    *(double *)(result + 4304) = a2;
    return 1;
  }
  return result;
}

uint64_t sub_100073514(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 4324);
  return result;
}

uint64_t sub_100073520(uint64_t a1, uint64_t a2, const __CFDictionary *a3, _QWORD *a4)
{
  _OWORD *v6;
  const void *v7;
  const void *v8;
  void *v9;
  CFTypeRef v10;
  NSObject *v11;
  void *v12;
  uint64_t v13;
  void *v15;
  _QWORD block[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  *a4 = 0;
  v6 = sub_10015BA34(a1, (uint64_t)kCFAllocatorDefault, a3, *(_QWORD *)(a1 + 64));
  v7 = v6;
  if (v6)
  {
    v8 = sub_10015C354((uint64_t)v6);
    *a4 = v8;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 5784), v8, v7);
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Created Virtual Interface %@ with role %@", "WiFiDeviceVirtualInterfaceCreate", *a4, sub_10000E178((uint64_t)v7));
    objc_autoreleasePoolPop(v9);
    if (*(_QWORD *)(a1 + 64))
    {
      v10 = (CFTypeRef)*a4;
      if (*a4)
        v10 = CFRetain(v10);
      v18[3] = (uint64_t)v10;
      CFRetain((CFTypeRef)a1);
      v11 = *(NSObject **)(a1 + 64);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10007370C;
      block[3] = &unk_10022F160;
      block[4] = &v17;
      block[5] = a1;
      dispatch_async(v11, block);
    }
    else
    {
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceVirtualInterfaceCreate");
      objc_autoreleasePoolPop(v12);
    }
    CFRelease(v7);
    v13 = 0;
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error creating virtual interface instance");
    objc_autoreleasePoolPop(v15);
    v13 = 4294963394;
  }
  _Block_object_dispose(&v17, 8);
  return v13;
}

void sub_1000736F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007370C(uint64_t a1)
{
  _QWORD *v2;
  void (*v3)(_QWORD *, uint64_t, _QWORD, uint64_t);
  uint64_t v4;
  const void *v5;
  const void *v6;

  v2 = *(_QWORD **)(a1 + 40);
  if (v2[8])
  {
    v3 = (void (*)(_QWORD *, uint64_t, _QWORD, uint64_t))v2[637];
    if (v3)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v4)
      {
        v3(v2, v4, v2[638], 1);
        v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  else
  {
    CFRelease(v2);
    v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

uint64_t sub_1000737AC(_QWORD *a1, const void *a2)
{
  const void *v4;
  uint64_t v5;
  CFTypeID v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __CFDictionary *v12;
  const void *v13;
  void *v14;
  void *v15;
  const void *v16;
  CFTypeRef v17;
  void *v18;
  NSObject *v19;
  void *v21;
  _QWORD block[6];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;

  v4 = sub_10002DEA0((uint64_t)a1, a2);
  v23 = 0;
  v24 = &v23;
  v25 = 0x2020000000;
  v26 = 0;
  if (!v4)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    goto LABEL_31;
  }
  v5 = (uint64_t)v4;
  v6 = CFGetTypeID(v4);
  if (v6 != sub_10002DE64())
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%@ is not a virtual interface", a2);
LABEL_31:
    objc_autoreleasePoolPop(v21);
    goto LABEL_32;
  }
  v7 = sub_100031A60(v5);
  if (!v7)
  {
LABEL_32:
    v10 = 4294963396;
    goto LABEL_26;
  }
  v8 = 7;
  while (1)
  {
    v9 = Apple80211Set(a1[2], 95, 0, v7, 8);
    v10 = v9;
    if ((int)v9 <= 15)
    {
      if ((_DWORD)v9 != -3905)
        break;
    }
    else if ((_DWORD)v9 != 61 && (_DWORD)v9 != 16)
    {
      goto LABEL_26;
    }
    if (!--v8)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v9)
  {
    v12 = (__CFDictionary *)a1[723];
    v13 = sub_10015C354(v5);
    CFDictionaryRemoveValue(v12, v13);
    v14 = objc_autoreleasePoolPush();
    v15 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v16 = sub_10015C354(v5);
      objc_msgSend(v15, "WFLog:message:", 3, "WiFiDeviceDeleteWiFiDirectInterface: Deleting Virtual Interface %@ with role %@", v16, sub_10000E178(v5));
    }
    objc_autoreleasePoolPop(v14);
    if (a1[8])
    {
      if (a2)
        v17 = CFRetain(a2);
      else
        v17 = 0;
      v24[3] = (uint64_t)v17;
      CFRetain(a1);
      v19 = a1[8];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100073A34;
      block[3] = &unk_10022F160;
      block[4] = &v23;
      block[5] = a1;
      dispatch_async(v19, block);
    }
    else
    {
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "WiFiDeviceVirtualInterfaceDelete");
      objc_autoreleasePoolPop(v18);
    }
    v10 = 0;
  }
LABEL_26:
  _Block_object_dispose(&v23, 8);
  return v10;
}

void sub_100073A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100073A34(uint64_t a1)
{
  _QWORD *v2;
  void (*v3)(_QWORD *, uint64_t, _QWORD, _QWORD);
  uint64_t v4;
  const void *v5;
  const void *v6;

  v2 = *(_QWORD **)(a1 + 40);
  if (v2[8])
  {
    v3 = (void (*)(_QWORD *, uint64_t, _QWORD, _QWORD))v2[637];
    if (v3)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v4)
      {
        v3(v2, v4, v2[638], 0);
        v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  else
  {
    CFRelease(v2);
    v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

uint64_t sub_100073AD4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)(result + 5080) = a3;
  *(_QWORD *)(result + 5088) = a4;
  return result;
}

uint64_t sub_100073AE0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v6;

  v6 = sub_10002DEA0(a1, a2);
  return sub_10015DE80((uint64_t)v6, a3, a4);
}

uint64_t sub_100073B0C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v6;

  v6 = sub_10002DEA0(a1, a2);
  return sub_10015DE88((uint64_t)v6, a3, a4);
}

const void *sub_100073B3C(uint64_t a1)
{
  CFNumberRef v2;
  unsigned int Count;
  uint64_t v4;
  size_t v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void **v9;
  unint64_t v10;
  uint64_t v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  void *v16;
  uint64_t valuePtr;

  valuePtr = 6;
  v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  v4 = Count;
  if (!Count)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No virtual interfaces found");
    objc_autoreleasePoolPop(v16);
LABEL_17:
    v14 = 0;
    if (!v2)
      return v14;
    goto LABEL_12;
  }
  v5 = 8 * Count;
  v6 = (const void **)malloc_type_malloc(v5, 0x6004044C4A2DFuLL);
  if (!v6)
    goto LABEL_17;
  v7 = v6;
  v8 = (const void **)malloc_type_malloc(v5, 0x2004093837F09uLL);
  if (v8)
  {
    v9 = v8;
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v7, v8);
    v10 = 0;
    v11 = 8 * v4;
    while (1)
    {
      v12 = CFGetTypeID(v9[v10 / 8]);
      if (v12 == sub_10002DE64())
      {
        v13 = sub_10000E178((uint64_t)v9[v10 / 8]);
        if (CFEqual(v13, v2))
          break;
      }
      v10 += 8;
      if (v11 == v10)
      {
        v14 = 0;
        goto LABEL_10;
      }
    }
    v14 = v9[v10 / 8];
LABEL_10:
    free(v9);
  }
  else
  {
    v14 = 0;
  }
  free(v7);
  if (v2)
LABEL_12:
    CFRelease(v2);
  return v14;
}

const void *sub_100073CA8(uint64_t a1)
{
  CFNumberRef v2;
  unsigned int Count;
  uint64_t v4;
  size_t v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void **v9;
  unint64_t v10;
  uint64_t v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  void *v16;
  uint64_t valuePtr;

  valuePtr = 7;
  v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  v4 = Count;
  if (!Count)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No virtual interfaces found");
    objc_autoreleasePoolPop(v16);
LABEL_17:
    v14 = 0;
    if (!v2)
      return v14;
    goto LABEL_12;
  }
  v5 = 8 * Count;
  v6 = (const void **)malloc_type_malloc(v5, 0x6004044C4A2DFuLL);
  if (!v6)
    goto LABEL_17;
  v7 = v6;
  v8 = (const void **)malloc_type_malloc(v5, 0x2004093837F09uLL);
  if (v8)
  {
    v9 = v8;
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v7, v8);
    v10 = 0;
    v11 = 8 * v4;
    while (1)
    {
      v12 = CFGetTypeID(v9[v10 / 8]);
      if (v12 == sub_10002DE64())
      {
        v13 = sub_10000E178((uint64_t)v9[v10 / 8]);
        if (CFEqual(v13, v2))
          break;
      }
      v10 += 8;
      if (v11 == v10)
      {
        v14 = 0;
        goto LABEL_10;
      }
    }
    v14 = v9[v10 / 8];
LABEL_10:
    free(v9);
  }
  else
  {
    v14 = 0;
  }
  free(v7);
  if (v2)
LABEL_12:
    CFRelease(v2);
  return v14;
}

const void *sub_100073E14(uint64_t a1)
{
  CFNumberRef v2;
  unsigned int Count;
  uint64_t v4;
  size_t v5;
  const void **v6;
  const void **v7;
  const void **v8;
  const void **v9;
  unint64_t v10;
  uint64_t v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  void *v16;
  uint64_t valuePtr;

  valuePtr = 10;
  v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 5784));
  v4 = Count;
  if (!Count)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No virtual interfaces found");
    objc_autoreleasePoolPop(v16);
LABEL_17:
    v14 = 0;
    if (!v2)
      return v14;
    goto LABEL_12;
  }
  v5 = 8 * Count;
  v6 = (const void **)malloc_type_malloc(v5, 0x6004044C4A2DFuLL);
  if (!v6)
    goto LABEL_17;
  v7 = v6;
  v8 = (const void **)malloc_type_malloc(v5, 0x2004093837F09uLL);
  if (v8)
  {
    v9 = v8;
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 5784), v7, v8);
    v10 = 0;
    v11 = 8 * v4;
    while (1)
    {
      v12 = CFGetTypeID(v9[v10 / 8]);
      if (v12 == sub_10002DE64())
      {
        v13 = sub_10000E178((uint64_t)v9[v10 / 8]);
        if (CFEqual(v13, v2))
          break;
      }
      v10 += 8;
      if (v11 == v10)
      {
        v14 = 0;
        goto LABEL_10;
      }
    }
    v14 = v9[v10 / 8];
LABEL_10:
    free(v9);
  }
  else
  {
    v14 = 0;
  }
  free(v7);
  if (v2)
LABEL_12:
    CFRelease(v2);
  return v14;
}

uint64_t sub_100073F80(uint64_t a1, const void *a2, const void *a3)
{
  const void *v5;
  void *v7;

  v5 = sub_100073B3C(a1);
  if (v5)
    return sub_10015DE98((int)v5, a2, a3);
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No AWDL interface found.");
  objc_autoreleasePoolPop(v7);
  return 4294963393;
}

uint64_t sub_100073FF0(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;
  const void *v5;
  const __CFString *NetworkInterfaceEntity;
  const __CFString *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  void *v12;
  void *v13;

  v2 = 0;
  if (a1 && a2)
  {
    if (sub_100068E60(a1)
      && (v5 = (const void *)sub_100068E60(a1), CFEqual(a2, v5))
      && (NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, a2, kSCEntNetLink)) != 0)
    {
      v7 = NetworkInterfaceEntity;
      v8 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), NetworkInterfaceEntity);
      if (v8)
      {
        v9 = v8;
        Value = CFDictionaryGetValue(v8, kSCPropNetLinkActive);
        if (Value)
        {
          v2 = CFEqual(Value, kCFBooleanTrue);
        }
        else
        {
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null availabilityRef.", "WiFiDeviceGetAwdlAvailability");
          objc_autoreleasePoolPop(v13);
          v2 = 0;
        }
        CFRelease(v7);
        v7 = (const __CFString *)v9;
      }
      else
      {
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null state dictRef.", "WiFiDeviceGetAwdlAvailability");
        objc_autoreleasePoolPop(v12);
        v2 = 0;
      }
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_100074164(uint64_t a1, const void *a2, unsigned int *a3)
{
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  int i;
  int v11;
  void *v13;
  unsigned __int8 v14;

  v14 = 0;
  v6 = sub_10002DEA0(a1, a2);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v8 = CFGetTypeID(v6);
    if (v8 == sub_10002DE64())
    {
      return sub_10015D2CC(v7, a3);
    }
    else
    {
      for (i = 6; ; --i)
      {
        v11 = Apple80211Get(*(_QWORD *)(a1 + 16), 117, 0, &v14, 1);
        if (v11 != -3905 && v11 != 61 && v11 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      return v14;
    }
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
    objc_autoreleasePoolPop(v13);
    return 0;
  }
}

uint64_t sub_100074260(uint64_t a1, const void *a2, const __CFArray *a3)
{
  uint64_t v3;
  const void *v6;
  uint64_t v7;
  CFTypeID v8;
  void *v9;

  v3 = 4294963396;
  if (a1 && a3)
  {
    v6 = sub_10002DEA0(a1, a2);
    if (!v6)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown interface %@", a2);
      v3 = 4294963396;
      goto LABEL_13;
    }
    v7 = (uint64_t)v6;
    v8 = CFGetTypeID(v6);
    if (v8 == sub_10002DE64())
    {
      v3 = sub_10015E07C(v7, a3);
      if ((_DWORD)v3)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error setting LTE restricted channels %d", v3);
LABEL_13:
        objc_autoreleasePoolPop(v9);
      }
    }
    else
    {
      return 4294963396;
    }
  }
  return v3;
}

uint64_t sub_100074344(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int i;
  uint64_t v6;
  void *v9;

  LOBYTE(v2) = -60;
  if (a1 && a2)
  {
    for (i = 6; ; --i)
    {
      v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 363, 0, a2, 8);
      v2 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_15;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v6)
      return v2;
LABEL_15:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error setting Usb Host Notification %d", v2);
    objc_autoreleasePoolPop(v9);
  }
  return v2;
}

uint64_t sub_100074418(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int i;
  uint64_t v6;
  void *v9;

  v2 = 4294963396;
  if (a1 && a2)
  {
    for (i = 6; ; --i)
    {
      v6 = Apple80211Get(*(_QWORD *)(a1 + 16), 515, 0, a2, 8);
      v2 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_15;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v6)
      return v2;
LABEL_15:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Could not read APPLE80211_IOC_WIFI_NOISE_PER_ANT err=%d", v2);
    objc_autoreleasePoolPop(v9);
  }
  return v2;
}

uint64_t sub_1000744EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int i;
  uint64_t v6;
  void *v9;

  v2 = 4294963396;
  if (a1 && a2)
  {
    for (i = 6; ; --i)
    {
      v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 51, 0, a2, 8);
      v2 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_15;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v6)
      return v2;
LABEL_15:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error setting locale %d", v2);
    objc_autoreleasePoolPop(v9);
  }
  return v2;
}

uint64_t sub_1000745C0(uint64_t a1, uint64_t a2)
{
  int v4;
  int i;
  uint64_t v6;
  uint64_t v7;
  void *v9;

  v4 = _os_feature_enabled_impl("WiFiManager", "PrivateMacRotation");
  if (!a1)
    return 4294963396;
  if (v4)
  {
    for (i = 6; ; --i)
    {
      v6 = Apple80211Get(*(_QWORD *)(a1 + 16), 552, 0, a2, 4);
      v7 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_20;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v6)
      return v7;
LABEL_20:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WiFiMC : Error getting APPLE80211_IOC_DEVICE_TYPE_IN_DHCP_ALLOW %d", v7);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation Rotation disabled ");
    v7 = 4294963396;
  }
  objc_autoreleasePoolPop(v9);
  return v7;
}

uint64_t sub_1000746DC(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_1000746E4(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t sub_1000746E4(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  CFTypeRef v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t v16;

  v13 = CFRetain(cf);
  v14 = CFRetain(a3);
  v15 = sub_10001C71C(a1, 9u, a4, (uint64_t)v13, (uint64_t)v14, a5, a6, 0, a7);
  v16 = v15;
  if (a3 && (_DWORD)v15)
    CFRelease(a3);
  return v16;
}

uint64_t sub_100074788(uint64_t a1, uint64_t a2, uint64_t a3, CFArrayRef theArray)
{
  uint64_t v4;
  const __CFArray *v7;
  __CFArray *Mutable;
  const __CFDictionary *v10;
  const __CFNumber *Value;
  CFIndex v12;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  CFTypeID v15;
  __CFDictionary *MutableCopy;
  CFNumberRef v17;
  void *v18;
  __CFDictionary *v19;
  int i;
  uint64_t v21;
  CFIndex v22;
  uint64_t v23;
  void *v25;
  char v27;
  int valuePtr;

  v4 = 4294963396;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a1 + 35) & 0x44) != 0)
    {
      v7 = theArray;
      Mutable = 0;
      if ((_DWORD)a3 && theArray)
      {
        if (CFArrayGetCount(theArray)
          && (v10 = *(const __CFDictionary **)(a1 + 4704)) != 0
          && (valuePtr = 0,
              (Value = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("AWDL_INFO_ASSISTED_DISCOVERY_METRIC"))) != 0)
          && (CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr), valuePtr == 2))
        {
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (Mutable)
          {
            if (CFArrayGetCount(v7) < 1)
            {
              v7 = Mutable;
            }
            else
            {
              v12 = 0;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v12);
                if (ValueAtIndex)
                {
                  v14 = ValueAtIndex;
                  v15 = CFGetTypeID(ValueAtIndex);
                  if (v15 == CFDictionaryGetTypeID())
                  {
                    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v14);
                    if (!CFDictionaryGetValue(MutableCopy, CFSTR("RANGING_PEER_FLAGS")))
                    {
                      v27 = 1;
                      v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v27);
                      CFDictionarySetValue(MutableCopy, CFSTR("RANGING_PEER_FLAGS"), v17);
                      if (v17)
                        CFRelease(v17);
                      v18 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting peer flag to indicate Phone Auto Unlock", "WiFiDeviceSetRangeable");
                      objc_autoreleasePoolPop(v18);
                    }
                    if (MutableCopy)
                      v19 = MutableCopy;
                    else
                      v19 = v14;
                    CFArrayAppendValue(Mutable, v19);
                    if (MutableCopy)
                      CFRelease(MutableCopy);
                  }
                  else
                  {
                    CFArrayAppendValue(Mutable, v14);
                  }
                }
                ++v12;
              }
              while (v12 < CFArrayGetCount(v7));
              v7 = Mutable;
            }
          }
        }
        else
        {
          Mutable = 0;
        }
      }
      for (i = 6; ; --i)
      {
        v21 = *(_QWORD *)(a1 + 16);
        v22 = v7 ? CFArrayGetCount(v7) : 0;
        v23 = Apple80211Set(v21, 241, (_DWORD)a3 != 0, v7, v22);
        v4 = v23;
        if ((_DWORD)v23 != -3905 && (_DWORD)v23 != 61 && (_DWORD)v23 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, set %d, error %d", "WiFiDeviceSetRangeable", a2, a3, v4);
      objc_autoreleasePoolPop(v25);
      if (Mutable)
        CFRelease(Mutable);
    }
    else
    {
      return 4294963389;
    }
  }
  return v4;
}

uint64_t sub_100074A5C(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t result;

  result = 4294963396;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a1 + 35) & 0x44) != 0)
      return sub_100074A8C(a1, a2, a3, a4, a5, 0, a6);
    else
      return 4294963389;
  }
  return result;
}

uint64_t sub_100074A8C(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, _QWORD *a6, double a7)
{
  unint64_t v12;
  CFTypeRef v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t v16;

  v12 = a7 | 0xAAAAAAAA00000000;
  v13 = CFRetain(cf);
  v14 = CFRetain(a3);
  v15 = sub_10001C71C(a1, 0xCu, 0, (uint64_t)v13, (uint64_t)v14, a4, a5, v12, a6);
  v16 = v15;
  if (a3 && (_DWORD)v15)
    CFRelease(a3);
  return v16;
}

uint64_t sub_100074B3C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  _BOOL8 v9;
  int i;
  uint64_t v11;
  void *v13;
  const char *v14;

  v4 = 4294963396;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a1 + 35) & 0x44) != 0)
    {
      v9 = a3 != 0;
      for (i = 6; ; --i)
      {
        v11 = Apple80211Set(*(_QWORD *)(a1 + 16), 380, v9, a4, 8);
        v4 = v11;
        if ((_DWORD)v11 != -3905 && (_DWORD)v11 != 61 && (_DWORD)v11 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v14 = "Removed";
        if (a3)
          v14 = " Added";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Identifier %s on ifName %@: %@, error %d", "WiFiDeviceSetRangingIdentifier", v14, a2, a4, v4);
      }
      objc_autoreleasePoolPop(v13);
    }
    else
    {
      return 4294963389;
    }
  }
  return v4;
}

uint64_t sub_100074C58(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t result;

  if (!a1)
    return 4294963396;
  for (i = 6; ; --i)
  {
    result = Apple80211Set(*(_QWORD *)(a1 + 16), 381, 0, a2, 8);
    if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  return result;
}

uint64_t sub_100074CD4(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v4;
  int i;
  uint64_t v6;
  void *v8;
  unsigned int v10;

  v10 = a2;
  v2 = 4294963396;
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 112);
    if (v4)
    {
      for (i = 6; ; --i)
      {
        v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 258, 0, &v10, 4);
        v2 = v6;
        if ((_DWORD)v6 != -3905 && (_DWORD)v6 != 61 && (_DWORD)v6 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, set %d, error %d", "WiFiDeviceSetThermalIndex", v4, v10, v2);
      objc_autoreleasePoolPop(v8);
      *(_DWORD *)(a1 + 5932) = v10;
      -[WiFiUsageMonitor setPowerBudget:andThermalIndex:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setPowerBudget:andThermalIndex:forInterface:", *(int *)(a1 + 5928), *(int *)(a1 + 5932), *(_QWORD *)(a1 + 112));
    }
  }
  return v2;
}

uint64_t sub_100074DCC(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int i;

  result = 4294963396;
  if (a1 && *(_QWORD *)(a1 + 112))
  {
    for (i = 6; ; --i)
    {
      result = Apple80211Get(*(_QWORD *)(a1 + 16), 258, 0, a2, 4);
      if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (a2)
      *(_DWORD *)(a1 + 5932) = *a2;
  }
  return result;
}

uint64_t sub_100074E58(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int i;

  result = 4294963396;
  if (a1 && *(_QWORD *)(a1 + 112))
  {
    for (i = 6; ; --i)
    {
      result = Apple80211Get(*(_QWORD *)(a1 + 16), 346, 0, a2, 2056);
      if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
  return result;
}

uint64_t sub_100074ED8(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  int i;
  uint64_t v6;
  void *v8;
  int v10;

  v10 = a2;
  v2 = 4294963396;
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 112);
    if (v4)
    {
      for (i = 6; ; --i)
      {
        v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 392, 0, &v10, 4);
        v2 = v6;
        if ((_DWORD)v6 != -3905 && (_DWORD)v6 != 61 && (_DWORD)v6 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, error %d", "WiFiDeviceSetPmMode", v4, v2);
      objc_autoreleasePoolPop(v8);
    }
  }
  return v2;
}

uint64_t sub_100074FA8(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v4;
  int i;
  uint64_t v6;
  void *v8;
  unsigned int v10;

  v10 = a2;
  v2 = 4294963396;
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 112);
    if (v4)
    {
      for (i = 6; ; --i)
      {
        v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 261, 0, &v10, 4);
        v2 = v6;
        if ((_DWORD)v6 != -3905 && (_DWORD)v6 != 61 && (_DWORD)v6 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, set %d, error %d", "WiFiDeviceSetPowerBudget", v4, v10, v2);
      objc_autoreleasePoolPop(v8);
      *(_DWORD *)(a1 + 5928) = v10;
      -[WiFiUsageMonitor setPowerBudget:andThermalIndex:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setPowerBudget:andThermalIndex:forInterface:", *(int *)(a1 + 5928), *(int *)(a1 + 5932), *(_QWORD *)(a1 + 112));
    }
  }
  return v2;
}

uint64_t sub_1000750A0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  int i;
  uint64_t v5;
  void *v7;

  v1 = 4294963396;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 112);
    if (v3)
    {
      for (i = 6; ; --i)
      {
        v5 = Apple80211Set(*(_QWORD *)(a1 + 16), 382, 0, 0, 0);
        v1 = v5;
        if ((_DWORD)v5 != -3905 && (_DWORD)v5 != 61 && (_DWORD)v5 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@, error %d", "WiFiDeviceAbortScan", v3, v1);
      objc_autoreleasePoolPop(v7);
    }
  }
  return v1;
}

uint64_t sub_10007516C(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int i;

  result = 4294963396;
  if (a1 && *(_QWORD *)(a1 + 112))
  {
    for (i = 6; ; --i)
    {
      result = Apple80211Get(*(_QWORD *)(a1 + 16), 348, 0, a2, 52);
      if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
  return result;
}

uint64_t sub_1000751EC(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int i;

  result = 4294963396;
  if (a1 && *(_QWORD *)(a1 + 112))
  {
    for (i = 6; ; --i)
    {
      result = Apple80211Get(*(_QWORD *)(a1 + 16), 261, 0, a2, 4);
      if ((_DWORD)result != -3905 && (_DWORD)result != 61 && (_DWORD)result != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
  return result;
}

uint64_t sub_10007526C(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 5928);
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_100075280(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 38) >> 4) & 1;
}

uint64_t sub_10007528C(uint64_t a1, int a2, CFDictionaryRef theDict, CFMutableDictionaryRef *a4)
{
  const __CFNumber *Value;
  _BYTE *v8;
  const __CFDictionary *v9;
  const __CFNumber *v10;
  void *v11;
  uint64_t v12;
  const __CFNumber *v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  id v20;
  id v21;
  void *v22;
  NSNumber *v23;
  const __CFString *v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v29;
  NSMutableArray *v30;
  const __CFString *v31;
  void *v32;
  NSMutableArray *v33;
  const __CFNumber *v34;
  CFIndex Count;
  CFIndex v36;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  void *v44;
  void *v45;
  const void *v46;
  void *v47;
  const void *v48;
  void *v49;
  void *v50;
  const char *v51;
  const __CFString *v52;
  void *v53;
  void *v54;
  const char *v55;
  void *v56;
  const char *v57;
  void *v58;
  const char *v59;
  void *v60;
  int valuePtr;
  unsigned int v63;

  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugModule"));
  if (!Value)
    return 4294963396;
  v8 = (_BYTE *)(a1 + 5760);
  valuePtr = -1431655766;
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  if (valuePtr > 8)
  {
    switch(valuePtr)
    {
      case 9:
        v63 = 0;
        if (a1)
        {
          if (theDict)
          {
            v9 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
            if (v9)
            {
              v10 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("errorCode"));
              if (v10)
              {
                CFNumberGetValue(v10, kCFNumberIntType, &v63);
                v11 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: received request to simulate join failure with error code %d", "__WiFiDeviceSimulateJoinFailure", v63);
                objc_autoreleasePoolPop(v11);
                v12 = 0;
                *(_DWORD *)(a1 + 5948) = v63;
                return v12;
              }
              v14 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: errorCodeRef is NULL", "__WiFiDeviceSimulateJoinFailure");
            }
            else
            {
              v14 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: joinFailureDict is NULL", "__WiFiDeviceSimulateJoinFailure");
            }
          }
          else
          {
            v14 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: request is NULL", "__WiFiDeviceSimulateJoinFailure");
          }
        }
        else
        {
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device is NULL", "__WiFiDeviceSimulateJoinFailure");
        }
        goto LABEL_77;
      case 10:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
        goto LABEL_23;
      case 11:
        v15 = objc_autoreleasePoolPush();
        v16 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
        if (!theDict)
        {
          v53 = objc_autoreleasePoolPush();
          v56 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_141;
          v57 = "__WiFiDeviceSimulateJoinOrRoamStatusSubState";
          goto LABEL_122;
        }
        v17 = v16;
        v18 = -[__CFDictionary objectForKey:](theDict, "objectForKey:", CFSTR("DebugCommandValueDict"));
        if (!v18)
        {
          v53 = objc_autoreleasePoolPush();
          v58 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_141;
          v59 = "__WiFiDeviceSimulateJoinOrRoamStatusSubState";
          goto LABEL_125;
        }
        v19 = v18;
        v20 = objc_msgSend(v18, "objectForKey:", CFSTR("mode"));
        v21 = objc_msgSend(v19, "objectForKey:", CFSTR("type"));
        if (v21)
        {
          v22 = v21;
          if ((objc_msgSend(v20, "isEqualToString:", CFSTR("clear")) & 1) != 0)
          {
            v23 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1);
            v24 = CFSTR("IO80211InterfaceSimulateSubStateClear");
LABEL_61:
            objc_msgSend(v17, "setObject:forKey:", v23, v24);
            v45 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiDeviceSimulateJoinOrRoamStatusSubState", v17);
            objc_autoreleasePoolPop(v45);
            if (objc_msgSend(v22, "isEqualToString:", CFSTR("join")))
            {
              if (a1)
                v46 = *(const void **)(a1 + 112);
              else
                v46 = 0;
              v52 = CFSTR("IO80211InterfaceSimulateJoinStatusSubStateParams");
            }
            else
            {
              if (!objc_msgSend(v22, "isEqualToString:", CFSTR("roam")))
                goto LABEL_142;
              if (a1)
                v46 = *(const void **)(a1 + 112);
              else
                v46 = 0;
              v52 = CFSTR("IO80211InterfaceSimulateRoamStatusSubStateParams");
            }
            sub_10002DC20(a1, v46, v52, (uint64_t)v17);
            goto LABEL_91;
          }
          if (objc_msgSend(v19, "objectForKey:", CFSTR("type")))
          {
            if (!objc_msgSend(v19, "objectForKey:", CFSTR("subState")))
            {
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: subState is nil", "__WiFiDeviceSimulateJoinOrRoamStatusSubState");
              goto LABEL_141;
            }
            if (!objc_msgSend(v19, "objectForKey:", CFSTR("idx")))
            {
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: idx is nil", "__WiFiDeviceSimulateJoinOrRoamStatusSubState");
              goto LABEL_141;
            }
            if (!objc_msgSend(v19, "objectForKey:", CFSTR("status")))
            {
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: status is nil", "__WiFiDeviceSimulateJoinOrRoamStatusSubState");
              goto LABEL_141;
            }
            if (!objc_msgSend(v19, "objectForKey:", CFSTR("reason")))
            {
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: reason is nil", "__WiFiDeviceSimulateJoinOrRoamStatusSubState");
              goto LABEL_141;
            }
            objc_msgSend(v17, "setObject:forKey:", objc_msgSend(v19, "objectForKey:", CFSTR("subState")), CFSTR("IO80211InterfaceSimulateSubStateType"));
            objc_msgSend(v17, "setObject:forKey:", objc_msgSend(v19, "objectForKey:", CFSTR("idx")), CFSTR("IO80211InterfaceSimulateSubStateIdx"));
            objc_msgSend(v17, "setObject:forKey:", objc_msgSend(v19, "objectForKey:", CFSTR("status")), CFSTR("IO80211InterfaceSimulateSubStateStatus"));
            v23 = (NSNumber *)objc_msgSend(v19, "objectForKey:", CFSTR("reason"));
            v24 = CFSTR("IO80211InterfaceSimulateSubStateReason");
            goto LABEL_61;
          }
        }
        v53 = objc_autoreleasePoolPush();
        v54 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_141;
        v55 = "__WiFiDeviceSimulateJoinOrRoamStatusSubState";
        goto LABEL_128;
      case 12:
        v15 = objc_autoreleasePoolPush();
        v25 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
        if ((*(_BYTE *)(a1 + 38) & 0x10) == 0)
        {
          v60 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BssBlacklist not supported.. Bailing!", "__WiFiDeviceConfigBssBlacklist");
          objc_autoreleasePoolPop(v60);
          v12 = 4294963393;
LABEL_143:
          objc_autoreleasePoolPop(v15);
          return v12;
        }
        if (theDict)
        {
          v26 = v25;
          v27 = -[__CFDictionary objectForKey:](theDict, "objectForKey:", CFSTR("DebugCommandValueDict"));
          if (v27)
          {
            v28 = v27;
            if (objc_msgSend(v27, "objectForKey:", CFSTR("type")))
            {
              v29 = objc_msgSend(v28, "objectForKey:", CFSTR("type"));
              if (objc_msgSend(v29, "isEqualToString:", CFSTR("set")))
              {
                if (objc_msgSend(v28, "objectForKey:", CFSTR("mode")))
                {
                  if (!objc_msgSend(v28, "objectForKey:", CFSTR("bssids")))
                  {
                    v53 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: bssids nil", "__WiFiDeviceConfigBssBlacklist");
                    goto LABEL_141;
                  }
                  v30 = +[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", objc_msgSend(v28, "objectForKey:", CFSTR("bssids")));
                  objc_msgSend(v26, "setObject:forKey:", objc_msgSend(v28, "objectForKey:", CFSTR("mode")), CFSTR("IO80211InterfaceBssidBlacklistMode"));
                  v31 = CFSTR("IO80211InterfaceBssidBlacklistBssids");
                  v32 = v26;
                  v33 = v30;
                  goto LABEL_69;
                }
              }
              else
              {
                if (!objc_msgSend(v29, "isEqualToString:", CFSTR("clear")))
                  goto LABEL_142;
                if (objc_msgSend(v28, "objectForKey:", CFSTR("mode")))
                {
                  v33 = (NSMutableArray *)objc_msgSend(v28, "objectForKey:", CFSTR("mode"));
                  v31 = CFSTR("IO80211InterfaceBssidBlacklistMode");
                  v32 = v26;
LABEL_69:
                  objc_msgSend(v32, "setObject:forKey:", v33, v31);
                  v47 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiDeviceConfigBssBlacklist", v26);
                  objc_autoreleasePoolPop(v47);
                  sub_1000672C0(a1, *(const void **)(a1 + 112), 372, 0, (uint64_t)v26);
LABEL_91:
                  v12 = 0;
                  goto LABEL_143;
                }
              }
              v53 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: mode is nil", "__WiFiDeviceConfigBssBlacklist");
              goto LABEL_141;
            }
            v53 = objc_autoreleasePoolPush();
            v54 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_141;
            v55 = "__WiFiDeviceConfigBssBlacklist";
LABEL_128:
            objc_msgSend(v54, "WFLog:message:", 4, "%s: type is nil", v55);
          }
          else
          {
            v53 = objc_autoreleasePoolPush();
            v58 = (void *)qword_10026DD20;
            if (!qword_10026DD20)
              goto LABEL_141;
            v59 = "__WiFiDeviceConfigBssBlacklist";
LABEL_125:
            objc_msgSend(v58, "WFLog:message:", 4, "%s: valuesDict is nil", v59);
          }
        }
        else
        {
          v53 = objc_autoreleasePoolPush();
          v56 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_141;
          v57 = "__WiFiDeviceConfigBssBlacklist";
LABEL_122:
          objc_msgSend(v56, "WFLog:message:", 4, "%s: request is nil", v57);
        }
LABEL_141:
        objc_autoreleasePoolPop(v53);
LABEL_142:
        v12 = 4294963396;
        goto LABEL_143;
      case 18:
        v12 = 0;
        *(_BYTE *)(a1 + 5952) = 1;
        return v12;
      default:
        if (valuePtr != 23)
          goto LABEL_23;
        -[WiFiUsageMonitor addFaultEvent:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addFaultEvent:forInterface:", objc_msgSend(-[__CFDictionary objectForKeyedSubscript:](theDict, "objectForKeyedSubscript:", CFSTR("faultReason")), "unsignedIntegerValue"), *(_QWORD *)(a1 + 112));
        return 0;
    }
  }
  if (valuePtr)
  {
    if (valuePtr == 4)
    {
      if (a1)
      {
        if (!theDict)
        {
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s request is NULL", "__WiFiDeviceDebugLqmConfig");
          goto LABEL_77;
        }
        v13 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
        if (!v13)
          return 4294963396;
        v63 = -1431655766;
        if (!CFNumberGetValue(v13, kCFNumberIntType, &v63))
          return 4294963396;
        if (v63 == 1)
        {
          v48 = CFDictionaryGetValue(theDict, CFSTR("DebugCommandValueDict"));
          if (v48)
            return sub_100075F60(a1, (uint64_t)v48);
          return 4294963396;
        }
        if (v63)
        {
LABEL_75:
          v14 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown debug command %d", v63);
          goto LABEL_77;
        }
        if (a4)
        {
          *a4 = sub_100075E1C(a1);
          return 4294963396;
        }
      }
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Device is NULL", "__WiFiDeviceDebugLqmConfig");
    }
    else
    {
LABEL_23:
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Unknown debug module %d", valuePtr);
    }
LABEL_77:
    objc_autoreleasePoolPop(v14);
    return 4294963396;
  }
  v34 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("DebugCommand"));
  if (!v34)
    return 4294963396;
  v63 = -1431655766;
  CFNumberGetValue(v34, kCFNumberIntType, &v63);
  switch(v63)
  {
    case 0u:
      if (!*v8)
      {
        v49 = objc_autoreleasePoolPush();
        v50 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v51 = "GAS cache is disabled";
LABEL_96:
          objc_msgSend(v50, "WFLog:message:", 3, v51);
        }
LABEL_97:
        objc_autoreleasePoolPop(v49);
        return 0;
      }
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5752));
      if (!Count)
      {
        v49 = objc_autoreleasePoolPush();
        v50 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v51 = "GAS cache is empty";
          goto LABEL_96;
        }
        goto LABEL_97;
      }
      v36 = Count;
      if (Count >= 1)
      {
        for (i = 0; i != v36; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5752), i);
          if (ValueAtIndex)
          {
            v39 = (uint64_t)ValueAtIndex;
            v40 = sub_1000D720C((uint64_t)ValueAtIndex);
            v41 = sub_1000C053C(v39);
            if (v40 && v41 != 0)
            {
              v43 = v41;
              v44 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ %@", v40, v43);
              objc_autoreleasePoolPop(v44);
            }
          }
        }
      }
      return 0;
    case 1u:
      sub_100073470(a1);
      return 0;
    case 2u:
      *v8 = 0;
      sub_100073470(a1);
      v49 = objc_autoreleasePoolPush();
      v50 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_97;
      v51 = "Disabled GAS cache";
      goto LABEL_96;
    case 3u:
      *v8 = 1;
      v49 = objc_autoreleasePoolPush();
      v50 = (void *)qword_10026DD20;
      if (!qword_10026DD20)
        goto LABEL_97;
      v51 = "Enabled GAS cache";
      goto LABEL_96;
    default:
      goto LABEL_75;
  }
}

CFMutableDictionaryRef sub_100075E1C(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v3;
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v9;
  void *v10;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v3 = Mutable;
    for (i = 6; ; --i)
    {
      v5 = Apple80211Get(*(_QWORD *)(a1 + 16), 337, 0, v3, 8);
      v6 = v5;
      if ((int)v5 <= 15)
      {
        if ((_DWORD)v5 != -3905)
          break;
      }
      else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
      {
        goto LABEL_17;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v5)
      return v3;
LABEL_17:
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to get LQM config: err %d", "WiFiDeviceCopyCurrentLqmConfig", v6);
    objc_autoreleasePoolPop(v10);
    CFRelease(v3);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to create dict", "WiFiDeviceCopyCurrentLqmConfig");
    objc_autoreleasePoolPop(v9);
  }
  return 0;
}

uint64_t sub_100075F60(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v9;

  for (i = 6; ; --i)
  {
    v5 = Apple80211Set(*(_QWORD *)(a1 + 16), 337, 0, a2, 8);
    v6 = v5;
    if ((int)v5 <= 15)
    {
      if ((_DWORD)v5 != -3905)
        break;
    }
    else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
    {
      goto LABEL_13;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v5)
    return v6;
LABEL_13:
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set LQM config: err %d", "WiFiDeviceSetLqmConfig", v6);
  objc_autoreleasePoolPop(v9);
  return v6;
}

uint64_t sub_100076030(uint64_t a1, uint64_t a2, int a3)
{
  void **v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  int i;
  uint64_t v8;
  uint64_t v9;
  void *values;
  void *keys;

  keys = CFSTR("LEAKY_AP_LEARNING_MODE");
  v4 = (void **)&kCFBooleanTrue;
  if (!a3)
    v4 = (void **)&kCFBooleanFalse;
  values = *v4;
  v5 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v5)
    return 4294963395;
  v6 = v5;
  for (i = 6; ; --i)
  {
    v8 = Apple80211Set(*(_QWORD *)(a1 + 16), 234, 0, v6, 0);
    v9 = v8;
    if ((_DWORD)v8 != -3905 && (_DWORD)v8 != 61 && (_DWORD)v8 != 16)
      break;
    if (!i)
      break;
    usleep(0x7A120u);
  }
  CFRelease(v6);
  return v9;
}

void sub_100076148(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v8;

  for (i = 6; ; --i)
  {
    v5 = Apple80211Set(*(_QWORD *)(a1 + 16), 245, 0, a2, 8);
    v6 = v5;
    if ((int)v5 <= 15)
    {
      if ((_DWORD)v5 != -3905)
        break;
    }
    else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
    {
      goto LABEL_12;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v5)
    return;
LABEL_12:
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Failed to set leaky ap SSID stats: err %d", "WiFiDeviceSetLeakyAPInfo", v6);
  objc_autoreleasePoolPop(v8);
}

uint64_t sub_100076220(uint64_t a1)
{
  int i;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  BOOL v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v10 = 0;
  if (a1)
  {
    for (i = 6; ; --i)
    {
      v3 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 248, 0, &v10);
      v4 = v3;
      if ((_DWORD)v3 != -3905 && (_DWORD)v3 != 61 && (_DWORD)v3 != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
    result = v10;
    if ((_DWORD)v4)
      v7 = 1;
    else
      v7 = v10 == 0;
    if (v7)
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: AssocHistory is Not Valid! Error:0x%0x. AssocHistoryString:%p", "WiFiDeviceCopyAssociationHistory", v4, v10);
      objc_autoreleasePoolPop(v9);
      return v10;
    }
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device NULL", "WiFiDeviceCopyAssociationHistory");
    objc_autoreleasePoolPop(v8);
    return 0;
  }
  return result;
}

uint64_t sub_10007633C(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(_QWORD *)(a1 + 5880);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device is NULL!", "WiFiDeviceGetLastLinkedBSSID");
  objc_autoreleasePoolPop(v2);
  return 0;
}

uint64_t sub_1000763A8(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(_QWORD *)(a1 + 5888);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device is NULL!", "WiFiDeviceGetLastLinkedSSID");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_100076414(uint64_t a1, CFDataRef *a2)
{
  const __CFData *v4;
  const __CFData *v5;
  void *v6;

  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device is NULL!", "WiFiDeviceCopyLastSSIDInfo");
    goto LABEL_12;
  }
  if (!a2)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lastSSIDInfo is NULL!", "WiFiDeviceCopyLastSSIDInfo");
LABEL_12:
    objc_autoreleasePoolPop(v6);
    return;
  }
  v4 = *(const __CFData **)(a1 + 5808);
  if (v4)
    *a2 = CFDataCreateCopy(kCFAllocatorDefault, v4);
  v5 = *(const __CFData **)(a1 + 5816);
  if (v5)
    a2[1] = CFDataCreateCopy(kCFAllocatorDefault, v5);
}

_WORD *sub_1000764F8(uint64_t a1)
{
  uint64_t v1;
  void *v3;

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device is NULL!", "WiFiDeviceCopyLastNetworkInfo");
    goto LABEL_10;
  }
  v1 = *(_QWORD *)(a1 + 5832);
  if (!v1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lastAttemptedNetworkInfo", "WiFiDeviceCopyLastNetworkInfo");
LABEL_10:
    objc_autoreleasePoolPop(v3);
    return 0;
  }
  if (*(_QWORD *)(a1 + 5824))
    v1 = *(_QWORD *)(a1 + 5824);
  return sub_10002B2DC((uint64_t)kCFAllocatorDefault, v1);
}

void sub_1000765BC(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a1)
  {
    if (a2)
    {
      sub_100070DDC(a1, a2);
      return;
    }
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is null.", "WiFiDeviceUpdateLastNetworkInfo");
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Device is NULL!", "WiFiDeviceUpdateLastNetworkInfo");
  }
  objc_autoreleasePoolPop(v2);
}

void sub_10007665C(uint64_t a1, int a2)
{
  void *v3;
  const char *v4;

  *(_BYTE *)(a1 + 5896) = a2;
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v4 = "ENABLED";
    if (!a2)
      v4 = "DISABLED";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Set WAPI %s", "WiFiDeviceSetWapiEnabled", v4);
  }
  objc_autoreleasePoolPop(v3);
}

void sub_1000766D8(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (*(unsigned __int8 *)(a1 + 224) != (_DWORD)a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Toggled. Old = %d and New = %d", "WiFiDeviceConfigureMacRadomisationFeature", *(unsigned __int8 *)(a1 + 224), a2);
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 224) = a2;
  }
}

void sub_10007675C(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (*(unsigned __int8 *)(a1 + 225) != (_DWORD)a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : for Secure Networks Toggled. Old = %d and New = %d", "WiFiDeviceConfigureMacRadomisationFeatureSecureNetworks", *(unsigned __int8 *)(a1 + 225), a2);
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 225) = a2;
  }
}

void sub_1000767E0(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *v4;
  const __CFString *Value;
  const __CFNumber *v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  _BOOL8 v9;
  void (*v10)(uint64_t, _QWORD, _QWORD, _QWORD, _BOOL8);
  const void *v11;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  CFMutableDictionaryRef v14;
  __CFDictionary *v15;
  const void *v16;
  const __CFNumber *v17;
  CFMutableArrayRef v18;
  __CFArray *v19;
  _UNKNOWN **v20;
  _UNKNOWN **v21;
  _UNKNOWN **v22;
  _UNKNOWN **v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  __CFDictionary *v42;
  __CFDictionary *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  CFMutableArrayRef v50;
  __CFArray *v51;
  __CFDictionary *v52;
  __CFDictionary *v53;
  const void *v54;
  const void *v55;
  __CFDictionary *v56;
  __CFDictionary *v57;
  const void *v58;
  const void *v59;
  __CFDictionary *v60;
  __CFDictionary *v61;
  const void *v62;
  char v63;
  void *v64;
  const __CFDictionary *v65;
  void *v66;
  const char *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  int valuePtr;
  int v73;
  int v74;

  valuePtr = 0;
  if (!a1)
  {
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "WiFiDeviceSetTestParams", v70, v71);
    goto LABEL_111;
  }
  if (!theDict)
  {
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null testParams", "WiFiDeviceSetTestParams", v70, v71);
    goto LABEL_111;
  }
  v4 = *(const __CFString **)(a1 + 112);
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("WiFiTestCommandInterfaceName"));
  if (CFStringCompare(Value, v4, 0))
  {
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ignore this device %@, test interface %@", "WiFiDeviceSetTestParams", v4, Value);
    goto LABEL_111;
  }
  v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("WiFiTestCommandType"));
  if (!v6)
  {
    v68 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null cmdNum", "WiFiDeviceSetTestParams", v70, v71);
LABEL_111:
    objc_autoreleasePoolPop(v68);
    return;
  }
  CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
  CFDictionaryRemoveValue(theDict, CFSTR("WiFiTestCommandType"));
  if (valuePtr != 201)
    return;
  v74 = 0;
  v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("enable"));
  if (v7)
  {
    CFNumberGetValue(v7, kCFNumberCFIndexType, &v74);
    *(_BYTE *)(a1 + 208) = v74;
  }
  v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("doNotDownsampleAnalytics"));
  if (v8)
  {
    CFNumberGetValue(v8, kCFNumberCFIndexType, &v74);
    v9 = v74 != 0;
  }
  else
  {
    v9 = 0;
  }
  v10 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _BOOL8))(a1 + 5576);
  if (v10)
    v10(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 5584), *(unsigned __int8 *)(a1 + 208), v9);
  v11 = *(const void **)(a1 + 216);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 216) = 0;
  }
  if (!*(_BYTE *)(a1 + 208))
  {
    v13 = 0;
    v15 = 0;
    goto LABEL_88;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v69 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s lqmDict is NULL!", "__WiFiDeviceSetSimulateLinkTestParams");
    goto LABEL_116;
  }
  v13 = Mutable;
  v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v14)
  {
    v69 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s ccaStatsDict is NULL!", "__WiFiDeviceSetSimulateLinkTestParams");
LABEL_116:
    objc_autoreleasePoolPop(v69);
    goto LABEL_96;
  }
  v15 = v14;
  v16 = CFDictionaryGetValue(theDict, CFSTR("rssi"));
  if (v16)
    CFDictionarySetValue(v13, CFSTR("RSSI"), v16);
  v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("hasPerCoreRssi"));
  if (v17)
  {
    v73 = 0;
    CFNumberGetValue(v17, kCFNumberIntType, &v73);
    if (v73)
    {
      v18 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v18)
      {
        v19 = v18;
        v20 = (_UNKNOWN **)CFDictionaryGetValue(theDict, CFSTR("rssicore0"));
        if (v20)
          v21 = v20;
        else
          v21 = &off_100252CC0;
        CFArrayAppendValue(v19, v21);
        v22 = (_UNKNOWN **)CFDictionaryGetValue(theDict, CFSTR("rssicore1"));
        if (v22)
          v23 = v22;
        else
          v23 = &off_100252CC0;
        CFArrayAppendValue(v19, v23);
        CFDictionarySetValue(v13, CFSTR("PER_CORE_RSSI"), v19);
        CFRelease(v19);
      }
    }
  }
  v24 = CFDictionaryGetValue(theDict, CFSTR("snr"));
  if (v24)
    CFDictionarySetValue(v13, CFSTR("SNR"), v24);
  v25 = CFDictionaryGetValue(theDict, CFSTR("cca"));
  if (v25)
    CFDictionarySetValue(v13, CFSTR("CCA"), v25);
  v26 = CFDictionaryGetValue(theDict, CFSTR("ccaSelfTotal"));
  if (v26)
    CFDictionarySetValue(v15, CFSTR("CCA_SELF_TOTAL"), v26);
  v27 = CFDictionaryGetValue(theDict, CFSTR("ccaOtherWake"));
  if (v27)
    CFDictionarySetValue(v15, CFSTR("CCA_OTHER_WAKE"), v27);
  v28 = CFDictionaryGetValue(theDict, CFSTR("ccaIntfWake"));
  if (v28)
    CFDictionarySetValue(v15, CFSTR("CCA_INTERFERENCE_WAKE"), v28);
  if (CFDictionaryGetCount(v15))
    CFDictionarySetValue(v13, CFSTR("CCA_STATS"), v15);
  v29 = CFDictionaryGetValue(theDict, CFSTR("noise"));
  if (v29)
    CFDictionarySetValue(v13, CFSTR("NOISE"), v29);
  v30 = CFDictionaryGetValue(theDict, CFSTR("txFail"));
  if (v30)
    CFDictionarySetValue(v13, CFSTR("TXFAIL"), v30);
  v31 = CFDictionaryGetValue(theDict, CFSTR("txFrames"));
  if (v31)
    CFDictionarySetValue(v13, CFSTR("TXFRAMES"), v31);
  v32 = CFDictionaryGetValue(theDict, CFSTR("txRetries"));
  if (v32)
    CFDictionarySetValue(v13, CFSTR("TXRETRANS"), v32);
  v33 = CFDictionaryGetValue(theDict, CFSTR("rxFrames"));
  if (v33)
    CFDictionarySetValue(v13, CFSTR("RXFRAMES"), v33);
  v34 = CFDictionaryGetValue(theDict, CFSTR("rxRetries"));
  if (v34)
    CFDictionarySetValue(v13, CFSTR("RXRETRYFRMS"), v34);
  v35 = CFDictionaryGetValue(theDict, CFSTR("bcnRecv"));
  if (v35)
    CFDictionarySetValue(v13, CFSTR("RXBEACONFRMS"), v35);
  v36 = CFDictionaryGetValue(theDict, CFSTR("bcnSched"));
  if (v36)
    CFDictionarySetValue(v13, CFSTR("RXBEACONSCHED"), v36);
  v37 = CFDictionaryGetValue(theDict, CFSTR("fwFrames"));
  if (v37)
    CFDictionarySetValue(v13, CFSTR("TXFWFRAMES"), v37);
  v38 = CFDictionaryGetValue(theDict, CFSTR("fwFail"));
  if (v38)
    CFDictionarySetValue(v13, CFSTR("TXFWFAIL"), v38);
  v39 = CFDictionaryGetValue(theDict, CFSTR("fwRetries"));
  if (v39)
    CFDictionarySetValue(v13, CFSTR("TXFWRETRANS"), v39);
  v40 = CFDictionaryGetValue(theDict, CFSTR("curBssRssi"));
  if (!v40)
  {
LABEL_85:
    v62 = CFDictionaryGetValue(theDict, CFSTR("recommendationFlags"));
    if (v62)
    {
      CFDictionarySetValue(v13, CFSTR("recommendationFlags"), v62);
      v63 = 0;
      goto LABEL_89;
    }
LABEL_88:
    v63 = 1;
LABEL_89:
    *(_QWORD *)(a1 + 216) = v13;
    v64 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Simulated LQM Dict: %@", *(_QWORD *)(a1 + 216));
    objc_autoreleasePoolPop(v64);
    if ((v63 & 1) == 0)
    {
      v65 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      sub_1000309C0(a1, *(_QWORD *)(a1 + 112), v65);
      if (v65)
        CFRelease(v65);
    }
    if (!v15)
      goto LABEL_96;
    goto LABEL_95;
  }
  v41 = v40;
  v42 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v42)
  {
    v43 = v42;
    CFDictionaryAddValue(v42, CFSTR("RSSI"), v41);
    v44 = CFDictionaryGetValue(theDict, CFSTR("roamReason"));
    if (v44)
      CFDictionarySetValue(v43, CFSTR("ROAM_SCAN_REASON"), v44);
    v45 = CFDictionaryGetValue(theDict, CFSTR("roamScanAge"));
    if (v45)
      CFDictionarySetValue(v43, CFSTR("ROAM_SCAN_AGE"), v45);
    v46 = CFDictionaryGetValue(theDict, CFSTR("roamStatus"));
    if (v46)
      CFDictionarySetValue(v43, CFSTR("ROAM_LAST_STATUS"), v46);
    v47 = CFDictionaryGetValue(theDict, CFSTR("roamScanCount"));
    if (v47)
      CFDictionarySetValue(v43, CFSTR("ROAM_SCAN_COUNT"), v47);
    v48 = CFDictionaryGetValue(theDict, CFSTR("roamCand1Rssi"));
    if (!v48)
      goto LABEL_84;
    v49 = v48;
    v50 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (!v50)
      goto LABEL_118;
    v51 = v50;
    v52 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v52)
    {
      v53 = v52;
      CFDictionaryAddValue(v52, CFSTR("RSSI"), v49);
      CFArrayAppendValue(v51, v53);
      CFRelease(v53);
      v54 = CFDictionaryGetValue(theDict, CFSTR("roamCand2Rssi"));
      if (!v54)
      {
LABEL_80:
        v58 = CFDictionaryGetValue(theDict, CFSTR("roamCand3Rssi"));
        if (!v58)
        {
LABEL_83:
          CFDictionaryAddValue(v43, CFSTR("ROAM_CACHE"), v51);
          CFRelease(v51);
LABEL_84:
          CFDictionaryAddValue(v13, CFSTR("ROAM_STATE"), v43);
          CFRelease(v43);
          goto LABEL_85;
        }
        v59 = v58;
        v60 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v60)
        {
          v61 = v60;
          CFDictionaryAddValue(v60, CFSTR("RSSI"), v59);
          CFArrayAppendValue(v51, v61);
          CFRelease(v61);
          goto LABEL_83;
        }
        goto LABEL_117;
      }
      v55 = v54;
      v56 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v56)
      {
        v57 = v56;
        CFDictionaryAddValue(v56, CFSTR("RSSI"), v55);
        CFArrayAppendValue(v51, v57);
        CFRelease(v57);
        goto LABEL_80;
      }
    }
LABEL_117:
    CFRelease(v51);
LABEL_118:
    CFRelease(v43);
  }
LABEL_95:
  CFRelease(v15);
LABEL_96:
  v66 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 208))
      v67 = "ENABLED";
    else
      v67 = "DISABLED";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Simulate Link Conditions is %s", v67);
  }
  objc_autoreleasePoolPop(v66);
}

void sub_1000771D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Reporting Symptoms Event:failureCode:%llu", "WiFiDeviceReportSymptomsEvent", a3);
    objc_autoreleasePoolPop(v6);
    v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5176);
    if (v7)
      v7(a1, a2, *(_QWORD *)(a1 + 5184), a3);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceRef is NULL!", "WiFiDeviceReportSymptomsEvent");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_1000772B0(uint64_t a1, uint64_t a2)
{
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v8;
  uint64_t v9;

  if (a1)
  {
    if (a2)
    {
      for (i = 6; ; --i)
      {
        v5 = Apple80211Set(*(_QWORD *)(a1 + 16), 107, 0, a2, 8);
        v6 = v5;
        if ((_DWORD)v5 != -3905 && (_DWORD)v5 != 61 && (_DWORD)v5 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s SetRoam status:%u\n", "WiFiDeviceSetRoam", v6);
    }
    else
    {
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bssidInfo is NULL!", "WiFiDeviceSetRoam", v9);
    }
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceRef is NULL!", "WiFiDeviceSetRoam", v9);
  }
  objc_autoreleasePoolPop(v8);
}

void sub_1000773CC(uint64_t a1, int a2)
{
  uint64_t v3;
  int i;
  uint64_t v6;
  uint64_t v7;
  void *v9;
  const char *v10;
  _BOOL4 v11;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 112);
    if (v3)
    {
      v11 = a2 != 0;
      for (i = 6; ; --i)
      {
        v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 459, 0, &v11, 4);
        v7 = v6;
        if ((_DWORD)v6 != -3905 && (_DWORD)v6 != 61 && (_DWORD)v6 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v10 = "no delay / TDD";
        if (a2 == 1)
          v10 = "delay";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@ WiFiBT5GPolicy %s error %d", "WiFiDeviceSetWiFiBT5GPolicy", v3, v10, v7);
      }
      objc_autoreleasePoolPop(v9);
    }
  }
}

__CFArray *sub_1000774C0(uint64_t a1)
{
  __CFArray *Mutable;
  CFIndex v3;
  const void *ValueAtIndex;
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex v7;
  const void *v8;
  CFMutableDictionaryRef v9;

  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)))
    return 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable && CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)) >= 1)
  {
    v3 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5696), v3);
      if (ValueAtIndex)
      {
        v5 = (const __CFArray *)sub_1000C053C((uint64_t)ValueAtIndex);
        if (v5)
        {
          v6 = v5;
          if (CFArrayGetCount(v5) >= 1)
          {
            v7 = 0;
            do
            {
              v8 = CFArrayGetValueAtIndex(v6, v7);
              v9 = sub_1000C33B4((uint64_t)v8);
              CFArrayAppendValue(Mutable, v9);
              if (v9)
                CFRelease(v9);
              ++v7;
            }
            while (v7 < CFArrayGetCount(v6));
          }
        }
      }
      ++v3;
    }
    while (v3 < CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)));
  }
  return Mutable;
}

__CFArray *sub_1000775BC(uint64_t a1, unsigned int a2)
{
  __CFArray *Mutable;
  CFIndex v5;
  const void *ValueAtIndex;
  uint64_t v7;
  double v8;
  double Current;
  double v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex v13;
  const void *v14;
  const void *v15;
  uint64_t v16;

  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)))
    return 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable && CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)) >= 1)
  {
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5696), v5);
      if (ValueAtIndex)
      {
        v7 = (uint64_t)ValueAtIndex;
        v8 = sub_10015B27C((uint64_t)ValueAtIndex);
        Current = CFAbsoluteTimeGetCurrent();
        v10 = Current <= v8 ? 0.0 : (Current - v8) * 1000.0;
        v11 = (const __CFArray *)sub_1000C053C(v7);
        if (v11)
        {
          v12 = v11;
          if (CFArrayGetCount(v11) >= 1)
          {
            v13 = 0;
            do
            {
              v14 = CFArrayGetValueAtIndex(v12, v13);
              if (v14)
              {
                v15 = v14;
                v16 = sub_100017A54((uint64_t)v14, CFSTR("ORIG_AGE")) + v10;
                if (!a2 || v16 <= a2)
                {
                  sub_10002B698((uint64_t)v15, CFSTR("AGE"), v16);
                  CFArrayAppendValue(Mutable, v15);
                }
              }
              ++v13;
            }
            while (v13 < CFArrayGetCount(v12));
          }
        }
      }
      ++v5;
    }
    while (v5 < CFArrayGetCount(*(CFArrayRef *)(a1 + 5696)));
  }
  return Mutable;
}

uint64_t sub_100077738(uint64_t a1)
{
  return *(unsigned int *)(a1 + 5936);
}

uint64_t sub_100077740(uint64_t a1)
{
  return *(unsigned int *)(a1 + 5800);
}

void sub_100077748(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;
  int i;
  int v7;
  _BOOL4 v9;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
    {
      v5 = "enabled";
      if (!a2)
        v5 = "disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %s power save mode", "WiFiDeviceAllowPowerSaveMode", v5);
    }
    objc_autoreleasePoolPop(v4);
    v9 = a2 != 0;
    for (i = 6; ; --i)
    {
      v7 = Apple80211Set(*(_QWORD *)(a1 + 16), 5, 0, &v9, 4);
      if (v7 != -3905 && v7 != 61 && v7 != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceRef is NULL!", "WiFiDeviceAllowPowerSaveMode");
    objc_autoreleasePoolPop(v4);
  }
}

uint64_t sub_10007785C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 37) >> 3) & 1;
}

uint64_t sub_100077868(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 37) >> 4) & 1;
}

uint64_t sub_100077874(uint64_t a1)
{
  return *(_BYTE *)(a1 + 38) & 1;
}

uint64_t sub_100077880(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 37) >> 7;
}

uint64_t sub_10007788C(uint64_t a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const void *Value;
  uint64_t v6;
  const void *v7;
  void *v8;
  NSString *v9;
  uint8_t buf[4];
  const char *v12;

  if (qword_10026D610)
  {
    CFRelease((CFTypeRef)qword_10026D610);
    qword_10026D610 = 0;
  }
  if (qword_10026D618)
  {
    CFRelease((CFTypeRef)qword_10026D618);
    qword_10026D618 = 0;
  }
  v2 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), (CFStringRef)qword_10026D620);
  v3 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), (CFStringRef)qword_10026D628);
  v4 = v3;
  if (!v2)
  {
    v6 = 0;
    qword_10026D610 = 0;
    if (v3)
      goto LABEL_10;
    goto LABEL_13;
  }
  Value = CFDictionaryGetValue(v2, kSCDynamicStorePropNetPrimaryInterface);
  qword_10026D610 = (uint64_t)Value;
  if (!Value)
  {
    v6 = 0;
    if (v4)
      goto LABEL_10;
LABEL_13:
    qword_10026D618 = 0;
    goto LABEL_14;
  }
  CFRetain(Value);
  v6 = 1;
  if (!v4)
    goto LABEL_13;
LABEL_10:
  v7 = CFDictionaryGetValue(v4, kSCDynamicStorePropNetPrimaryInterface);
  qword_10026D618 = (uint64_t)v7;
  if (v7)
  {
    CFRetain(v7);
    v6 = 1;
  }
LABEL_14:
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IPv4 Primary interface is %@ and IPv6 Primary Interface is %@"), qword_10026D610, qword_10026D618)), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v8);
  if (v2)
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  return v6;
}

__CFDictionary *sub_100077AB8(uint64_t a1, const void *a2)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  CFIndex v10;
  __CFArray *Mutable;
  const __CFDictionary *ValueAtIndex;
  CFDictionaryRef *MutableCopy;
  CFTypeID v14;
  __CFDictionary *v15;
  const void *v16;
  const __CFNumber *v17;
  const char *v18;
  const __CFNumber *v19;
  CFNumberRef v20;
  void *v21;
  int j;
  uint64_t v23;
  int i;
  int v26;
  __CFDictionary *v28;
  void *v29;
  void *v31;
  void *value;
  uint64_t v33;
  uint64_t valuePtr;
  CFArrayRef theArray;

  theArray = 0;
  v4 = sub_10002DEA0(a1, a2);
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 == sub_10002DE64())
    {
      LODWORD(v7) = sub_10015CE30((uint64_t)v5, 42, 0, &theArray);
    }
    else
    {
      for (i = 6; ; --i)
      {
        v26 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 42, 0, &theArray);
        LODWORD(v7) = v26;
        if (v26 != -3905 && v26 != 61 && v26 != 16)
          break;
        if (!i)
          break;
        usleep(0x7A120u);
      }
    }
    if (!theArray)
      return 0;
    v8 = objc_autoreleasePoolPush();
    v9 = "WiFiDeviceCopyInterfaceDataUsage";
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: station list %@", "WiFiDeviceCopyInterfaceDataUsage", theArray);
    value = (void *)a2;
    objc_autoreleasePoolPop(v8);
    if (CFArrayGetCount(theArray) < 1)
    {
      Mutable = 0;
    }
    else
    {
      v10 = 0;
      Mutable = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v10);
        if (ValueAtIndex)
        {
          MutableCopy = (CFDictionaryRef *)CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, ValueAtIndex);
          v14 = CFGetTypeID(v5);
          if (v14 == sub_10002DE64())
          {
            v7 = sub_10015CE30((uint64_t)v5, 79, 0, MutableCopy);
          }
          else
          {
            for (j = 6; ; --j)
            {
              v23 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 79, 0, MutableCopy);
              v7 = v23;
              if ((_DWORD)v23 != -3905 && (_DWORD)v23 != 61 && (_DWORD)v23 != 16)
                break;
              if (!j)
                break;
              usleep(0x7A120u);
            }
          }
          if (!(_DWORD)v7)
          {
            if (!Mutable)
              Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            v15 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            v16 = CFDictionaryGetValue((CFDictionaryRef)MutableCopy, CFSTR("STATION_MAC"));
            CFDictionarySetValue(v15, CFSTR("DataUsageInterfacePeerAddr"), v16);
            v33 = 0;
            valuePtr = 0;
            v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)MutableCopy, CFSTR("STA_RXBYTES"));
            if (v17)
              CFNumberGetValue(v17, kCFNumberSInt32Type, (char *)&valuePtr + 4);
            v18 = v9;
            v19 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)MutableCopy, CFSTR("STA_TXBYTES"));
            if (v19)
              CFNumberGetValue(v19, kCFNumberSInt32Type, &valuePtr);
            v33 = (valuePtr + HIDWORD(valuePtr));
            v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v33);
            CFDictionarySetValue(v15, CFSTR("DataUsageInterfacePeerLastBytes"), v20);
            if (v20)
              CFRelease(v20);
            CFArrayAppendValue(Mutable, v15);
            if (v15)
              CFRelease(v15);
            v9 = v18;
          }
          v21 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: err=%d, client stats %@", v9, v7, MutableCopy);
          objc_autoreleasePoolPop(v21);
          if (MutableCopy)
            CFRelease(MutableCopy);
        }
        ++v10;
      }
      while (v10 < CFArrayGetCount(theArray));
    }
    v28 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(v28, CFSTR("DataUsageInterfaceName"), value);
    if (Mutable && CFArrayGetCount(Mutable))
      CFDictionarySetValue(v28, CFSTR("DataUsageInterfacePeerList"), Mutable);
    v29 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: interface data usage %@", v9, v28);
    objc_autoreleasePoolPop(v29);
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "WiFiDeviceCopyInterfaceDataUsage", a2);
    objc_autoreleasePoolPop(v31);
    v28 = 0;
    LODWORD(v7) = 0;
  }
  if (theArray)
  {
    CFRelease(theArray);
    theArray = 0;
  }
  if (v28 && (_DWORD)v7)
  {
    CFRelease(v28);
    return 0;
  }
  return v28;
}

uint64_t sub_100077F20(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v6;
  int i;
  uint64_t v8;
  void *v11;
  void *value;

  value = 0;
  if (!a2)
    return 4294963396;
  v3 = 4294963396;
  if (!a1 || !*(_QWORD *)(a1 + 112))
    return v3;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 4294963396;
  v6 = Mutable;
  *a2 = 0;
  for (i = 6; ; --i)
  {
    v8 = Apple80211Get(*(_QWORD *)(a1 + 16), 2, 0, v6, 8);
    v3 = v8;
    if ((int)v8 <= 15)
    {
      if ((_DWORD)v8 != -3905)
        break;
    }
    else if ((_DWORD)v8 != 61 && (_DWORD)v8 != 16)
    {
      goto LABEL_21;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if ((_DWORD)v8)
  {
LABEL_21:
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Apple80211Get(APPLE80211_IOC_AUTH_TYPE) failed: %d", "WiFiDeviceGetAuthType", v3);
    objc_autoreleasePoolPop(v11);
    goto LABEL_18;
  }
  CFDictionaryGetValueIfPresent(v6, CFSTR("AUTH_UPPER"), (const void **)&value);
  if (value)
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, a2);
LABEL_18:
  CFRelease(v6);
  return v3;
}

uint64_t sub_100078078(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v6;

  v6 = sub_10002DEA0(a1, a2);
  return sub_10015F688((uint64_t)v6, a3, a4);
}

uint64_t sub_1000780A4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 38) >> 5) & 1;
}

uint64_t sub_1000780B0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 39) >> 5) & 1;
}

void sub_1000780BC(uint64_t a1)
{
  void *v2;
  void *v3;
  const char *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  const char *v8;
  void *v9;
  void *v10;
  const char *v11;
  void *v12;
  void *v13;
  const char *v14;
  void *v15;
  void *v16;
  const char *v17;
  void *v18;
  void *v19;
  const char *v20;
  void *v21;
  void *v22;
  const char *v23;
  void *v24;
  void *v25;
  const char *v26;
  CFNumberRef v27;
  CFNumberRef v28;
  void *v29;
  void *v30;
  uint64_t valuePtr;

  valuePtr = 0;
  v2 = objc_autoreleasePoolPush();
  v3 = (void *)qword_10026DD20;
  if (a1)
  {
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "ListenBeforeTalk"))
        v4 = "enabled";
      else
        v4 = "disabled";
      objc_msgSend(v3, "WFLog:message:", 3, "%s: LBT is %s", "WiFiDeviceApplyFeatureFlags", v4);
    }
    objc_autoreleasePoolPop(v2);
    if (_os_feature_enabled_impl("WiFiManager", "ListenBeforeTalk"))
    {
      v5 = 1;
      valuePtr = 1;
    }
    else
    {
      v5 = 0;
    }
    v6 = objc_autoreleasePoolPush();
    v7 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "WiFiLQMCrashTracer"))
        v8 = "enabled";
      else
        v8 = "disabled";
      objc_msgSend(v7, "WFLog:message:", 3, "%s: WiFi LQM CrashTracer is %s", "WiFiDeviceApplyFeatureFlags", v8);
    }
    objc_autoreleasePoolPop(v6);
    if (_os_feature_enabled_impl("WiFiManager", "WiFiLQMCrashTracer"))
    {
      v5 |= 2uLL;
      valuePtr = v5;
    }
    v9 = objc_autoreleasePoolPush();
    v10 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "DNSSymptoms"))
        v11 = "enabled";
      else
        v11 = "disabled";
      objc_msgSend(v10, "WFLog:message:", 3, "%s: WiFi DNSSymptoms is %s", "WiFiDeviceApplyFeatureFlags", v11);
    }
    objc_autoreleasePoolPop(v9);
    if (_os_feature_enabled_impl("WiFiManager", "DNSSymptoms"))
    {
      v5 |= 0x200uLL;
      valuePtr = v5;
    }
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "ViVoDatapathTuning"))
        v14 = "enabled";
      else
        v14 = "disabled";
      objc_msgSend(v13, "WFLog:message:", 3, "%s: WiFi ViVoDatapathTuning is %s", "WiFiDeviceApplyFeatureFlags", v14);
    }
    objc_autoreleasePoolPop(v12);
    if (_os_feature_enabled_impl("WiFiManager", "ViVoDatapathTuning"))
    {
      v5 |= 0x100uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("CoreWiFi", "AWDL6E"))
    {
      v5 |= 0x1000uLL;
      valuePtr = v5;
    }
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "OneCoreTx"))
        v17 = "enabled";
      else
        v17 = "disabled";
      objc_msgSend(v16, "WFLog:message:", 3, "%s: WiFi One Core Tx is %s", "WiFiDeviceApplyFeatureFlags", v17);
    }
    objc_autoreleasePoolPop(v15);
    if (_os_feature_enabled_impl("WiFiManager", "OneCoreTx"))
    {
      v5 |= 0x800uLL;
      valuePtr = v5;
    }
    v18 = objc_autoreleasePoolPush();
    v19 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "Sensing"))
        v20 = "enabled";
      else
        v20 = "disabled";
      objc_msgSend(v19, "WFLog:message:", 3, "%s: WiFi Sensing is %s", "WiFiDeviceApplyFeatureFlags", v20);
    }
    objc_autoreleasePoolPop(v18);
    if (_os_feature_enabled_impl("WiFiManager", "Sensing"))
    {
      v5 |= 0x4000uLL;
      valuePtr = v5;
    }
    v21 = objc_autoreleasePoolPush();
    v22 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("WiFiManager", "QoS_MSCS"))
        v23 = "enabled";
      else
        v23 = "disabled";
      objc_msgSend(v22, "WFLog:message:", 3, "%s: WiFi QoS MSCS is %s", "WiFiDeviceApplyFeatureFlags", v23);
    }
    objc_autoreleasePoolPop(v21);
    if (_os_feature_enabled_impl("WiFiManager", "QoS_MSCS"))
    {
      v5 |= 0x2000uLL;
      valuePtr = v5;
    }
    v24 = objc_autoreleasePoolPush();
    v25 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (_os_feature_enabled_impl("CoreWiFi", "P2PForULLRTInfra"))
        v26 = "enabled";
      else
        v26 = "disabled";
      objc_msgSend(v25, "WFLog:message:", 3, "%s: P2P Optimization for Ultra Low Latency Realtime Infra is %s", "WiFiDeviceApplyFeatureFlags", v26);
    }
    objc_autoreleasePoolPop(v24);
    if (_os_feature_enabled_impl("CoreWiFi", "P2PForULLRTInfra"))
    {
      v5 |= 0x8000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS"))
    {
      v5 |= 0x10000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("CoreWiFi", "SSIDTransition"))
    {
      v5 |= 0x80000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "WPA3BcnProt"))
    {
      v5 |= 0x20000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "WPA3SoftAPBcnProt"))
    {
      v5 |= 0x40000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "WPA3OCV"))
    {
      v5 |= 0x100000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "WPA3SoftAPOCV"))
    {
      v5 |= 0x200000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "WPA3SAEPK"))
    {
      v5 |= 0x400000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "RealtimeDynamicRTS"))
    {
      v5 |= 0x800000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "ObssMitigation"))
    {
      v5 |= 0x1000000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("WiFiManager", "ScanForwardToAOP"))
    {
      v5 |= 0x2000000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("CoreWiFi", "Figaro5GTDD"))
    {
      v5 |= 0x4000000uLL;
      valuePtr = v5;
    }
    if (_os_feature_enabled_impl("CoreWiFi", "P2P24GHzDwell"))
      valuePtr = v5 | 0x8000000;
    v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
    if (v27)
    {
      v28 = v27;
      sub_1000672C0(a1, *(const void **)(a1 + 112), 469, 0, (uint64_t)v27);
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ifName %@ FeatureFlags 0x%llx error %d\n", "WiFiDeviceApplyFeatureFlags", *(_QWORD *)(a1 + 112), valuePtr, 4294963396);
      objc_autoreleasePoolPop(v29);
      CFRelease(v28);
    }
    else
    {
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate valueRef", "WiFiDeviceApplyFeatureFlags");
      objc_autoreleasePoolPop(v30);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device", "WiFiDeviceApplyFeatureFlags");
    objc_autoreleasePoolPop(v2);
  }
}

const void *sub_100078718(uint64_t a1, const void *a2)
{
  const void *result;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;

  result = 0;
  if (a1 && a2)
  {
    if (!*(_QWORD *)(a1 + 5840) || !*(_QWORD *)(a1 + 5848))
      return 0;
    result = sub_10002B088(a2);
    if (result)
    {
      result = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
      if (result)
      {
        v5 = *(const __CFString **)(a1 + 5840);
        v6 = (const __CFString *)sub_10002B088(a2);
        if (CFStringCompare(v5, v6, 0) == kCFCompareEqualTo)
        {
          v7 = *(const __CFString **)(a1 + 5848);
          v8 = (const __CFString *)sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
          if (CFStringCompare(v7, v8, 0) == kCFCompareEqualTo)
          {
            if (*(_BYTE *)(a1 + 5864))
              return (const void *)(*(_BYTE *)(a1 + 5865) != 0);
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1000787E8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *v6;

  v6 = sub_10002DEA0(a1, a2);
  return sub_10015F690((uint64_t)v6, a3, a4);
}

uint64_t sub_100078814(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 5872);
  else
    return 4294967274;
}

void sub_100078828(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  void *v5;

  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "WiFiDeviceSetAPInfo");
    goto LABEL_11;
  }
  if (!*(_QWORD *)(a1 + 120))
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null properties.", "WiFiDeviceSetAPInfo");
LABEL_11:
    objc_autoreleasePoolPop(v5);
    return;
  }
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), CFSTR("ApInfoParams"), cf);
  }
}

const void *sub_100078920(uint64_t a1)
{
  const __CFDictionary *v1;
  void *v3;

  if (a1)
  {
    v1 = *(const __CFDictionary **)(a1 + 120);
    if (v1)
      return CFDictionaryGetValue(v1, CFSTR("ApInfoParams"));
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null properties.", "WiFiDeviceGetAPInfo");
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null device.", "WiFiDeviceGetAPInfo");
  }
  objc_autoreleasePoolPop(v3);
  return 0;
}

BOOL sub_1000789D4(uint64_t a1)
{
  CFBooleanRef Value;

  Value = (CFBooleanRef)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 120), CFSTR("facetimeCallInProgress"));
  return Value && Value == kCFBooleanTrue;
}

void sub_100078A0C(uint64_t a1, const void *a2)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v5;
  void *v6;
  void *v7;

  if (!a1)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device is NULL", "WiFiDeviceTriggerCoreCapture");
    goto LABEL_10;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CoreCaptureTriggerInfo allocation failed!", "WiFiDeviceTriggerCoreCapture");
LABEL_10:
    objc_autoreleasePoolPop(v7);
    return;
  }
  v5 = Mutable;
  CFDictionaryAddValue(Mutable, CFSTR("CHIP_RESET_TRIGGER"), a2);
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Trigger CoreCapture at driver:%@", "WiFiDeviceTriggerCoreCapture", a2);
  objc_autoreleasePoolPop(v6);
  sub_10006BD58(a1, v5);
  CFRelease(v5);
}

void sub_100078B44(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "enabled";
      if (!a2)
        v5 = "disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ranging log dump is %s", "WiFiDeviceSetEnableRangingLogDump", v5);
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 5956) = a2;
  }
}

void sub_100078BD4(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "Enabled";
      if (!a2)
        v5 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: BT A2DP LLA Traffic Status = %s", "WiFiDeviceUpdateBTA2DPLLATrafficStatus", v5);
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 5957) = a2;
  }
}

uint64_t sub_100078C64(uint64_t a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    v4 = v3;
    sub_1000672C0(a1, *(const void **)(a1 + 112), 514, 0, (uint64_t)v3);
    CFRelease(v4);
  }
  return 1;
}

uint64_t sub_100078CD0(uint64_t a1, int a2)
{
  const void *v2;
  uint64_t *v3;

  if (a1)
    v2 = *(const void **)(a1 + 112);
  else
    v2 = 0;
  v3 = (uint64_t *)&kCFBooleanTrue;
  if (a2 != 1)
    v3 = (uint64_t *)&kCFBooleanFalse;
  return sub_1000672C0(a1, v2, 507, 0, *v3);
}

void sub_100078D0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;

  if (a1)
  {
    if (a3 > 2 || *(_DWORD *)(a1 + 5936) > 2u)
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: association type changed from %d to %d", "WiFiDeviceOverrideAssociationType", *(unsigned int *)(a1 + 5936), a3);
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: association type changed from %@ to %@", "WiFiDeviceOverrideAssociationType", off_10022F740[*(unsigned int *)(a1 + 5936)], off_10022F740[a3]);
    }
    objc_autoreleasePoolPop(v5);
    *(_DWORD *)(a1 + 5936) = a3;
  }
}

uint64_t sub_100078DE8(uint64_t a1)
{
  return *(_BYTE *)(a1 + 46) & 1;
}

uint64_t sub_100078DF4(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t v3;
  void *v7;
  int i;
  uint64_t v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v12;
  void *v14;

  v3 = 4294963396;
  if (a1 && a2 && a3)
  {
    if ((*(_BYTE *)(a1 + 46) & 1) != 0)
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting APPLE80211_IOC_NDD_REQ on %@", a2);
      objc_autoreleasePoolPop(v7);
      for (i = 6; ; --i)
      {
        v9 = *(_QWORD *)(a1 + 16);
        BytePtr = CFDataGetBytePtr(a3);
        Length = CFDataGetLength(a3);
        v12 = Apple80211Set(v9, 551, 0, BytePtr, Length);
        v3 = v12;
        if ((int)v12 <= 15)
        {
          if ((_DWORD)v12 != -3905)
            break;
        }
        else if ((_DWORD)v12 != 61 && (_DWORD)v12 != 16)
        {
          goto LABEL_18;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v12)
        return v3;
LABEL_18:
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IOC %d returned error %d", "WiFiDevicePerformNDD", 551, v3);
      objc_autoreleasePoolPop(v14);
    }
    else
    {
      return 4294963389;
    }
  }
  return v3;
}

uint64_t sub_100078F38(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 40) >> 1) & 1;
}

uint64_t sub_100078F44(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  id v11;
  uint64_t v12;
  uint64_t i;
  id v14;
  CFTypeRef v15;
  void *v16;
  id v18;
  CFTypeRef v19;

  v5 = 4294963396;
  if (a1 && a2 && a3)
  {
    if ((*(_BYTE *)(a1 + 40) & 2) != 0)
    {
      v11 = objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("SENSING_PARAMS_MATCH_MAC_ADDRESS"));
      v12 = objc_msgSend(v11, "count");
      if (v12)
      {
        for (i = 0; i != v12; ++i)
        {
          v14 = objc_msgSend(a3, "mutableCopy");
          objc_msgSend(v14, "setObject:forKeyedSubscript:", objc_msgSend(v11, "objectAtIndexedSubscript:", i), CFSTR("SENSING_PARAMS_MATCH_MAC_ADDRESS"));
          ++*(_DWORD *)(a1 + 5964);
          v15 = CFRetain(a2);
          v5 = sub_10001C71C(a1, 0xEu, 0, (uint64_t)v15, (uint64_t)v14, a4, a5, 0, 0);
          if ((_DWORD)v5)
          {
            --*(_DWORD *)(a1 + 5964);
            CFRelease(a2);
            if (v14)
              CFRelease(v14);
          }
        }
      }
      else
      {
        v18 = objc_msgSend(a3, "mutableCopy");
        objc_msgSend(v18, "setObject:forKeyedSubscript:", CFSTR("00:00:00:00:00:00"), CFSTR("SENSING_PARAMS_MATCH_MAC_ADDRESS"));
        ++*(_DWORD *)(a1 + 5964);
        v19 = CFRetain(a2);
        v5 = sub_10001C71C(a1, 0xEu, 0, (uint64_t)v19, (uint64_t)v18, a4, a5, 0, 0);
        if ((_DWORD)v5)
        {
          --*(_DWORD *)(a1 + 5964);
          CFRelease(a2);
          if (v18)
            CFRelease(v18);
        }
      }
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Sending kWiFiDeviceCommandTypeSensing on %@ (%d), expected result[%d]", a2, v5, *(unsigned int *)(a1 + 5964));
      objc_autoreleasePoolPop(v16);
    }
    else
    {
      return 4294963389;
    }
  }
  return v5;
}

uint64_t sub_100079140(uint64_t a1, const void *a2)
{
  uint64_t v2;
  const void *v5;
  CFTypeID v6;
  uint64_t v7;
  void *v8;
  int i;
  uint64_t v10;

  v2 = 4294963396;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a1 + 40) & 2) == 0)
      return 4294963389;
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 5968));
    *(_DWORD *)(a1 + 5960) = 0;
    v5 = sub_10002DEA0(a1, a2);
    if (v5)
    {
      v6 = CFGetTypeID(v5);
      v7 = sub_10002DE64();
      v8 = objc_autoreleasePoolPush();
      if (v6 != v7)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting APPLE80211_IOC_SENSING_DISABLE on %@", a2);
        objc_autoreleasePoolPop(v8);
        for (i = 6; ; --i)
        {
          v10 = Apple80211Set(*(_QWORD *)(a1 + 16), 409, 0, 0, 0);
          v2 = v10;
          if ((int)v10 <= 15)
          {
            if ((_DWORD)v10 != -3905)
              break;
          }
          else if ((_DWORD)v10 != 61 && (_DWORD)v10 != 16)
          {
            goto LABEL_19;
          }
          if (!i)
            break;
          usleep(0x7A120u);
        }
        if (!(_DWORD)v10)
          return v2;
LABEL_19:
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IOC %d returned error %d", "WiFiDeviceSensingDisable", 409, v2);
        goto LABEL_21;
      }
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unsupported interface %@", "WiFiDeviceSensingDisable", a2);
    }
    else
    {
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown interface %@", "WiFiDeviceSensingDisable", a2);
    }
    v2 = 4294963393;
LABEL_21:
    objc_autoreleasePoolPop(v8);
  }
  return v2;
}

void sub_1000792F0(uint64_t a1)
{
  if (a1)
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 5968));
}

uint64_t sub_100079300(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 5960) = a2;
  return result;
}

uint64_t sub_10007930C(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 5960);
  return result;
}

uint64_t sub_100079318(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 5964);
  return result;
}

uint64_t sub_100079324(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 5968);
  return result;
}

void sub_100079330(uint64_t a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    v4 = v3;
    sub_1000672C0(a1, *(const void **)(a1 + 112), 345, 0, (uint64_t)v3);
    CFRelease(v4);
  }
}

uint64_t sub_100079398(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int i;
  uint64_t v6;
  void *v9;

  v2 = 6;
  if (a1 && a2)
  {
    for (i = 6; ; --i)
    {
      v6 = Apple80211Set(*(_QWORD *)(a1 + 16), 516, 0, a2, 0);
      v2 = v6;
      if ((int)v6 <= 15)
      {
        if ((_DWORD)v6 != -3905)
          break;
      }
      else if ((_DWORD)v6 != 61 && (_DWORD)v6 != 16)
      {
        goto LABEL_15;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if (!(_DWORD)v6)
      return v2;
LABEL_15:
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error %d setting blocked bands %@", v2, a2);
    objc_autoreleasePoolPop(v9);
  }
  return v2;
}

uint64_t sub_10007946C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 40) >> 4) & 1;
}

uint64_t sub_100079478(uint64_t result, char a2)
{
  *(_BYTE *)(result + 5958) = a2;
  return result;
}

uint64_t sub_100079484(uint64_t result, char a2, char a3)
{
  *(_BYTE *)(result + 54) = a2;
  *(_BYTE *)(result + 55) = a3;
  return result;
}

uint64_t sub_100079490(uint64_t a1, int a2)
{
  int v3;
  int i;
  uint64_t v5;
  uint64_t v6;
  void *v9;
  uint64_t v10;

  if (!a1)
    return 4294963396;
  v10 = 0;
  if (a2)
    v3 = 2;
  else
    v3 = 1;
  LODWORD(v10) = v3;
  for (i = 6; ; --i)
  {
    v5 = Apple80211Set(*(_QWORD *)(a1 + 16), 518, 0, &v10, 8);
    v6 = v5;
    if ((int)v5 <= 15)
    {
      if ((_DWORD)v5 != -3905)
        break;
    }
    else if ((_DWORD)v5 != 61 && (_DWORD)v5 != 16)
    {
      goto LABEL_18;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if (!(_DWORD)v5)
    return v6;
LABEL_18:
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Error sending sleep state notification %d", v6, v10);
  objc_autoreleasePoolPop(v9);
  return v6;
}

uint64_t sub_100079574(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v5;
  CFTypeID v6;
  const void *Value;

  v5 = sub_1000672C0(a1, a2, 488, 0, (uint64_t)a3);
  if (a3)
  {
    v6 = CFGetTypeID(a3);
    if (v6 == CFDictionaryGetTypeID())
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("IO80211InterfaceCallStatus"));
      if (Value)
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 120), CFSTR("facetimeCallInProgress"), Value);
    }
  }
  return v5;
}

void sub_1000795F8(uint64_t a1)
{
  void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  io_object_t v7;
  const void *v8;
  const void *v9;
  IONotificationPort *v10;
  io_object_t v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  void *v30;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Enter: %s:%d\n", "__WiFiDeviceRelease", 2234);
  objc_autoreleasePoolPop(v2);
  v3 = *(const void **)(a1 + 5784);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 5784) = 0;
  }
  v4 = *(const void **)(a1 + 176);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v5 = *(const void **)(a1 + 200);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v6 = *(const void **)(a1 + 144);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v7 = *(_DWORD *)(a1 + 104);
  if (v7)
  {
    IOObjectRelease(v7);
    *(_DWORD *)(a1 + 104) = 0;
  }
  v8 = *(const void **)(a1 + 112);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v10 = *(IONotificationPort **)(a1 + 96);
  if (v10)
  {
    IONotificationPortDestroy(v10);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v11 = *(_DWORD *)(a1 + 24);
  if (v11)
  {
    IOObjectRelease(v11);
    *(_DWORD *)(a1 + 24) = 0;
  }
  v12 = *(const void **)(a1 + 152);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v13 = *(const void **)(a1 + 5696);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 5696) = 0;
  }
  v14 = *(const void **)(a1 + 5752);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 5752) = 0;
  }
  v15 = *(const void **)(a1 + 5656);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 5656) = 0;
  }
  v16 = *(const void **)(a1 + 5664);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 5664) = 0;
  }
  v17 = *(const void **)(a1 + 5792);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 5792) = 0;
  }
  v18 = *(const void **)(a1 + 216);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v19 = *(const void **)(a1 + 5840);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 5840) = 0;
  }
  v20 = *(const void **)(a1 + 5848);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(a1 + 5848) = 0;
  }
  v21 = *(const void **)(a1 + 232);
  if (v21)
  {
    CFRelease(v21);
    *(_QWORD *)(a1 + 232) = 0;
  }
  v22 = *(const void **)(a1 + 5968);
  if (v22)
  {
    CFRelease(v22);
    *(_QWORD *)(a1 + 5968) = 0;
  }
  v23 = *(const void **)(a1 + 160);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v24 = *(const void **)(a1 + 168);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v25 = *(const void **)(a1 + 5824);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a1 + 5824) = 0;
  }
  v26 = *(const void **)(a1 + 5832);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 5832) = 0;
  }
  v27 = *(const void **)(a1 + 5920);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  v28 = *(const void **)(a1 + 4336);
  if (v28)
  {
    CFRelease(v28);
    *(_QWORD *)(a1 + 4336) = 0;
  }
  v29 = *(const void **)(a1 + 4328);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(a1 + 4328) = 0;
  }
  v30 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Exit : %s:%d\n", "__WiFiDeviceRelease", 2294);
  objc_autoreleasePoolPop(v30);
}

void sub_100079840(uint64_t a1, CFTypeRef cf, char a3)
{
  const void *v6;

  v6 = *(const void **)(a1 + 5680);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 5680) = 0;
  }
  *(_BYTE *)(a1 + 5688) = 0;
  if (cf)
  {
    *(_QWORD *)(a1 + 5680) = CFRetain(cf);
    *(_BYTE *)(a1 + 5688) = a3;
  }
}

void sub_10007989C(uint64_t a1)
{
  uint64_t v1;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  const void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 64))
  {
    if (*(_QWORD *)(v1 + 5680))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v4 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("CompletedUsingBeaconCache"), kCFBooleanTrue);
        sub_100016A94(v1, *(_QWORD *)(v1 + 112), *(CFTypeRef *)(v1 + 5680), (uint64_t)v4, 0);
        CFRelease(v4);
      }
      else
      {
        sub_100016A94(v1, *(_QWORD *)(v1 + 112), *(CFTypeRef *)(v1 + 5680), 0, 0);
      }
    }
    v5 = *(const void **)(a1 + 32);
  }
  else
  {
    v5 = *(const void **)(a1 + 32);
  }
  CFRelease(v5);
}

void sub_100079960(uint64_t a1)
{
  uint64_t v1;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  const void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 64))
  {
    if (*(_QWORD *)(v1 + 5680))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v4 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("CompletedUsingCache"), kCFBooleanTrue);
        sub_100016A94(v1, *(_QWORD *)(v1 + 112), *(CFTypeRef *)(v1 + 5680), (uint64_t)v4, 0);
        CFRelease(v4);
      }
      else
      {
        sub_100016A94(v1, *(_QWORD *)(v1 + 112), *(CFTypeRef *)(v1 + 5680), 0, 0);
      }
    }
    v5 = *(const void **)(a1 + 32);
  }
  else
  {
    v5 = *(const void **)(a1 + 32);
  }
  CFRelease(v5);
}

uint64_t sub_100079A24(uint64_t a1, const __CFDictionary *a2, const __CFSet *a3)
{
  __CFArray *Mutable;
  const __CFArray *v7;
  CFIndex v8;
  const void *ValueAtIndex;
  uint64_t v10;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
    return 1;
  v7 = Mutable;
  sub_100079AE8(a1, a2, Mutable);
  if (CFArrayGetCount(v7) < 1)
  {
LABEL_6:
    v10 = 1;
  }
  else
  {
    v8 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v7, v8);
      if (!CFSetContainsValue(a3, ValueAtIndex))
        break;
      if (++v8 >= CFArrayGetCount(v7))
        goto LABEL_6;
    }
    v10 = 0;
  }
  CFRelease(v7);
  return v10;
}

void sub_100079AE8(uint64_t a1, CFDictionaryRef theDict, __CFArray *a3)
{
  const __CFArray *Value;
  const __CFArray *v6;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v9;
  const __CFNumber *v10;
  CFNumberRef v11;
  CFDictionaryRef v12;
  CFIndex Count;
  CFIndex i;
  const __CFDictionary *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  CFNumberRef v18;
  CFDictionaryRef v19;
  int v20;
  uint64_t valuePtr;
  void *values;
  CFNumberRef v23;
  void *keys[2];

  valuePtr = 0;
  v20 = 0;
  if (a3 && theDict && *(_QWORD *)(a1 + 5656))
  {
    Value = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("SCAN_CHANNELS"));
    if (Value)
    {
      v6 = Value;
      if (CFArrayGetCount(Value) >= 1 && CFArrayGetCount(v6) >= 1)
      {
        v7 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v7);
          v9 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL"));
          CFNumberGetValue(v9, kCFNumberCFIndexType, &valuePtr);
          v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("CHANNEL_FLAGS"));
          CFNumberGetValue(v10, kCFNumberSInt32Type, &v20);
          v20 &= 0x2018u;
          v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v20);
          *(_OWORD *)keys = *(_OWORD *)&off_10022F7C8;
          values = v9;
          v23 = v11;
          v12 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)&values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFRelease(v11);
          CFArrayAppendValue(a3, v12);
          CFRelease(v12);
          ++v7;
        }
        while (v7 < CFArrayGetCount(v6));
      }
    }
    if (!CFArrayGetCount(a3))
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5656));
      if (!Count)
      {
        sub_100017A68(a1, *(const void **)(a1 + 112), *(__CFArray **)(a1 + 5656));
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 5656));
      }
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          v15 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5656), i);
          v16 = (const __CFNumber *)CFDictionaryGetValue(v15, CFSTR("SUP_CHANNEL"));
          CFNumberGetValue(v16, kCFNumberCFIndexType, &valuePtr);
          v17 = (const __CFNumber *)CFDictionaryGetValue(v15, CFSTR("SUP_CHANNEL_FLAGS"));
          CFNumberGetValue(v17, kCFNumberSInt32Type, &v20);
          v20 &= 0x2018u;
          v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v20);
          *(_OWORD *)keys = *(_OWORD *)&off_10022F7C8;
          values = v16;
          v23 = v18;
          v19 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)&values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFRelease(v18);
          CFArrayAppendValue(a3, v19);
          CFRelease(v19);
        }
      }
    }
  }
}

void sub_100079DD4(const __CFDictionary *a1, __CFArray *a2)
{
  const __CFArray *Value;
  const __CFArray *v5;
  CFIndex v6;
  const __CFDictionary *ValueAtIndex;
  const void *v8;
  const void *v9;

  if (a1 && a2)
  {
    Value = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("SCAN_SSID_LIST"));
    if (Value && (v5 = Value, CFArrayGetCount(Value) >= 1))
    {
      if (CFArrayGetCount(v5) >= 1)
      {
        v6 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v6);
          if (ValueAtIndex)
          {
            v8 = CFDictionaryGetValue(ValueAtIndex, CFSTR("SSID_STR"));
            if (v8)
              CFArrayAppendValue(a2, v8);
          }
          ++v6;
        }
        while (v6 < CFArrayGetCount(v5));
      }
    }
    else
    {
      v9 = CFDictionaryGetValue(a1, CFSTR("SSID_STR"));
      if (v9)
        CFArrayAppendValue(a2, v9);
    }
    if (!CFArrayGetCount(a2))
      CFArrayAppendValue(a2, &stru_100238178);
  }
}

__CFDictionary *sub_100079EC8(uint64_t a1)
{
  const __CFNumber *v2;
  const __CFNumber *v3;
  const __CFNumber *v4;
  uint64_t v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  uint64_t v11;
  uint64_t valuePtr;

  v11 = 0;
  valuePtr = 0;
  v2 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("CHANNEL"));
  if (!v2)
    return 0;
  v3 = v2;
  CFNumberGetValue(v2, kCFNumberSInt64Type, &v11);
  v4 = (const __CFNumber *)sub_10002BE64(a1, CFSTR("CHANNEL_FLAGS"));
  if (v4)
  {
    CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr);
    v5 = valuePtr & 0x2018;
  }
  else
  {
    v5 = 0;
  }
  valuePtr = v5;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  if (!v6)
    return 0;
  v7 = v6;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, CFSTR("CHANNEL"), v3);
    CFDictionarySetValue(v9, CFSTR("CHANNEL_FLAGS"), v7);
  }
  CFRelease(v7);
  return v9;
}

void sub_100079FD4(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  void (*v10)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v11;
  void *v12;
  NSString *v13;
  void *v14;
  uint64_t v15;
  char *v16;
  NSString *v17;
  const char *v18;
  const void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  NSString *v23;
  const char *v24;
  NSString *v25;
  const char *v26;
  void *v27;
  NSString *v28;
  const char *v29;
  void *v30;
  NSString *v31;
  const char *v32;
  int v34;
  char *v35;
  _QWORD *v36;
  void (*v37)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint8_t buf[4];
  const char *v40;

  v9 = (_QWORD *)(a1 + 4776);
  v10 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 4776);
  v11 = *(_QWORD *)(a1 + 4784);
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v13 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Completed Apple80211AssociateAsync (%d - 0x%X) to %@"), a5, a5, sub_10002B088(a3))), "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v40 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v13, "UTF8String")), "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
  objc_autoreleasePoolPop(v12);
  if (a3 && !(_DWORD)a5)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v15 = a4;
      v16 = *(_DWORD *)(a1 + 5936) ? "Manually" : "Auto";
      v35 = v16;
      a4 = v15;
      v17 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s Joined: %@"), v35, sub_10002B088(a3))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v18 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v17, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v40 = v18;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v14);
    a5 = 0;
    goto LABEL_42;
  }
  *(_QWORD *)(a1 + 5912) = 0;
  v19 = *(const void **)(a1 + 5920);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 5920) = 0;
  }
  v20 = objc_autoreleasePoolPush();
  v37 = v10;
  if (a3)
  {
    v21 = (void *)sub_10002BE64((uint64_t)a3, CFSTR("JOIN_EXTENDED_STATUS"));
    v36 = v9;
    if (v21)
      v22 = (uint64_t)objc_msgSend(v21, "intValue");
    else
      v22 = 4294963393;
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v28 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to join(%d - 0x%X)/(%d): %@"), a5, a5, v22, sub_10002B088(a3))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        v29 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v28, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v40 = v29;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v27);
    v30 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v31 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("TRACER:%s %d/%d: %@"), "__WiFiDeviceDispatchQueuedAssociationEvent", a5, v22, sub_10002B088(a3))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        v32 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v31, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v40 = v32;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v30);
    v9 = v36;
  }
  else
  {
    if (qword_10026DD20)
    {
      v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to join(%d - 0x%X)/(%d)"), a5, a5, 4294963394)), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        v24 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v23, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v40 = v24;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v20);
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      LODWORD(v22) = -3902;
      v25 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("ASSOC"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("TRACER:%s %d/%d"), "__WiFiDeviceDispatchQueuedAssociationEvent", a5, 4294963394)), "UTF8String"));
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        goto LABEL_34;
      v26 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v25, "UTF8String")), "UTF8String");
      *(_DWORD *)buf = 136446210;
      v40 = v26;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
    }
    LODWORD(v22) = -3902;
  }
LABEL_34:
  objc_autoreleasePoolPop(v20);
  if ((v22 + 3901) < 0xFFFFFFFE && (a5 & 0xFFFFFFFE) == -3906)
    a5 = v22;
  else
    a5 = a5;
  v10 = v37;
  if ((_DWORD)a5)
  {
    sub_100051054(a1, a5, a3, *(_DWORD *)(a1 + 5872));
    v34 = 0;
    goto LABEL_43;
  }
LABEL_42:
  v34 = 1;
LABEL_43:
  *v9 = 0;
  v9[1] = 0;
  if (v10)
    v10(a1, a2, a3, a4, a5, v11);
  sub_100070CD8(a1, a3, v34);
  sub_100017CB0(a1);
}

void sub_10007A780(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v8;
  int i;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  void *v14;
  int valuePtr;
  CFNumberRef number;

  v6 = (_QWORD *)(a1 + 4656);
  v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 4656);
  v8 = *(_QWORD *)(a1 + 4664);
  if (!(_DWORD)a3 && v7)
  {
    sub_100017CB0(a1);
    *v6 = 0;
    v6[1] = 0;
LABEL_4:
    v7(a1, a2, a3, v8);
    goto LABEL_5;
  }
  *v6 = 0;
  *(_QWORD *)(a1 + 4664) = 0;
  if (v7)
    goto LABEL_4;
LABEL_5:
  number = 0;
  valuePtr = 0;
  if (*(_QWORD *)(a1 + 4984))
  {
    for (i = 6; ; --i)
    {
      v10 = Apple80211CopyValue(*(_QWORD *)(a1 + 16), 15, 0, &number);
      v11 = v10;
      if ((int)v10 <= 15)
      {
        if ((_DWORD)v10 != -3905)
          break;
      }
      else if ((_DWORD)v10 != 61 && (_DWORD)v10 != 16)
      {
        goto LABEL_27;
      }
      if (!i)
        break;
      usleep(0x7A120u);
    }
    if ((_DWORD)v10)
    {
LABEL_27:
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiError: %d ", "__WiFiDeviceProcessHostApStateChange", v11);
      objc_autoreleasePoolPop(v14);
      return;
    }
    if (CFNumberGetValue(number, kCFNumberIntType, &valuePtr) && (valuePtr & 8) == 0 && *(_BYTE *)(a1 + 56))
    {
      *(_BYTE *)(a1 + 56) = 0;
      (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 4984))(a1, 0, *(_QWORD *)(a1 + 4960), 0);
    }
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error: null callback", "__WiFiDeviceProcessHostApStateChange");
    objc_autoreleasePoolPop(v13);
  }
}

void sub_10007A938(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  void (*v7)(_QWORD *, uint64_t, uint64_t, uint64_t);
  uint64_t v8;
  void *v9;
  const void *v10;
  const void *v11;

  v6 = a1 + 586;
  v7 = (void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))a1[586];
  v8 = a1[587];
  v9 = objc_autoreleasePoolPush();
  if ((_DWORD)a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %d bringing AWDL up", "__WiFiDeviceProcessAwdlStartedEvent", a3);
    objc_autoreleasePoolPop(v9);
    v10 = (const void *)a1[588];
    if (v10)
    {
      CFRelease(v10);
      a1[588] = 0;
    }
    v11 = (const void *)a1[589];
    if (v11)
    {
      CFRelease(v11);
      a1[589] = 0;
    }
    a1[590] = 0;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: successfully started AWDL", "__WiFiDeviceProcessAwdlStartedEvent");
    objc_autoreleasePoolPop(v9);
  }
  *v6 = 0;
  v6[1] = 0;
  if (v7)
    v7(a1, a2, a3, v8);
  sub_100017CB0((uint64_t)a1);
}

uint64_t sub_10007AA3C(uint64_t a1, const void *a2, uint64_t a3, void (*a4)(uint64_t, const void *, uint64_t, uint64_t), uint64_t a5)
{
  const void *v10;
  uint64_t v11;
  void *v13;

  v10 = sub_100073B3C(a1);
  if (v10)
  {
    v11 = sub_10015F3FC((uint64_t)v10, a2, a3);
    if (a4)
      a4(a1, a2, v11, a5);
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: not an AWDL interface.", "__WiFiDeviceStopAwdl");
    objc_autoreleasePoolPop(v13);
    return 4294963393;
  }
  return v11;
}

void sub_10007AAF8(const __CFArray *a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  const void *Value;
  const void *v10;
  CFIndex v11;
  const void *v12;
  uint64_t v13;
  const void *v14;
  void *v15;

  Count = CFArrayGetCount(theArray);
  if (Count)
  {
    v5 = Count;
    if (Count >= 1)
    {
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
        if (ValueAtIndex)
        {
          v8 = ValueAtIndex;
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
          if (Value)
          {
            v10 = Value;
            if (CFArrayGetCount(a1) >= 1)
            {
              v11 = 0;
              while (1)
              {
                v12 = CFArrayGetValueAtIndex(a1, v11);
                if (v12)
                {
                  v13 = (uint64_t)v12;
                  v14 = sub_10002BE64((uint64_t)v12, CFSTR("BSSID"));
                  if (CFEqual(v10, v14))
                    break;
                }
                if (++v11 >= CFArrayGetCount(a1))
                  goto LABEL_13;
              }
              sub_1000C9ACC(v13, v8);
            }
          }
        }
LABEL_13:
        ;
      }
    }
  }
  else
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "No GAS responses found");
    objc_autoreleasePoolPop(v15);
  }
}

void sub_10007AC38(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 5736);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5736) = 0;
  }
  if (cf)
    *(_QWORD *)(a1 + 5736) = CFRetain(cf);
}

void sub_10007AC78(uint64_t a1)
{
  uint64_t v1;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  const void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 64))
  {
    if (*(_QWORD *)(v1 + 5736))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v4 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("CompletedUsingCache"), kCFBooleanTrue);
        sub_10007AD3C((_QWORD *)v1, *(_QWORD *)(v1 + 112), *(const __CFArray **)(v1 + 5736), (uint64_t)v4, 0);
        CFRelease(v4);
      }
      else
      {
        sub_10007AD3C((_QWORD *)v1, *(_QWORD *)(v1 + 112), *(const __CFArray **)(v1 + 5736), 0, 0);
      }
    }
    v5 = *(const void **)(a1 + 32);
  }
  else
  {
    v5 = *(const void **)(a1 + 32);
  }
  CFRelease(v5);
}

void sub_10007AD3C(_QWORD *a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  void (*v11)(_QWORD *, uint64_t, const __CFArray *, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  void *v13;
  CFTypeID v14;
  const __CFDictionary *v15;
  const __CFArray *Value;
  const __CFArray *v17;
  const void *v18;
  void *v19;
  const void *v20;

  v10 = a1 + 625;
  v11 = (void (*)(_QWORD *, uint64_t, const __CFArray *, uint64_t, uint64_t, uint64_t))a1[625];
  v12 = a1[626];
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Completed Apple80211GasRequest on %@ (%d)", a2, a5);
  objc_autoreleasePoolPop(v13);
  *v10 = 0;
  v10[1] = 0;
  if (a3 && (v14 = CFGetTypeID(a3), v14 == CFArrayGetTypeID()))
  {
    if (!(_DWORD)a5 && a1[716] && !a1[717] && CFArrayGetCount(a3))
      sub_10007AFF0((uint64_t)a1, a3);
    if (v11)
    {
      v15 = (const __CFDictionary *)a1[716];
      if (v15)
      {
        Value = (const __CFArray *)CFDictionaryGetValue(v15, CFSTR("GAS_NETWORKS"));
        v17 = Value;
        if (Value)
          sub_10007AAF8(Value, a3);
        v11(a1, a2, v17, a4, a5, v12);
        v18 = (const void *)a1[716];
        if (v18)
        {
          CFRelease(v18);
          a1[716] = 0;
        }
      }
      else
      {
        v19 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: calling CB with cached GAS response", "__WiFiDeviceProcessGasDoneEvent");
        objc_autoreleasePoolPop(v19);
        v11(a1, a2, (const __CFArray *)a1[717], a4, a5, v12);
      }
    }
    v20 = (const void *)a1[717];
    if (v20)
    {
      CFRelease(v20);
      a1[717] = 0;
    }
  }
  else if (v11)
  {
    v11(a1, a2, 0, a4, a5, v12);
  }
  sub_100017CB0((uint64_t)a1);
}

void sub_10007AF08(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 5728);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 5728) = 0;
  }
  if (cf)
    *(_QWORD *)(a1 + 5728) = CFRetain(cf);
}

__CFArray *sub_10007AF48(const __CFArray *a1)
{
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v7;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v4 = Count;
      for (i = 0; i != v4; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
        if (ValueAtIndex)
        {
          v7 = sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("BSSID"));
          if (v7)
            CFArrayAppendValue(Mutable, v7);
        }
      }
    }
  }
  return Mutable;
}

void sub_10007AFF0(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  char v7;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v9;
  const __CFNumber *Value;
  const __CFNumber *v11;
  const void *v12;
  const void *v13;
  void *v14;
  void *v15;
  __CFArray *v16;
  const void *v17;
  _QWORD *v18;
  const void *v19;
  NSObject *v20;
  dispatch_time_t v21;
  void *v22;
  unsigned __int16 v23;
  unsigned __int16 valuePtr;

  if (*(_BYTE *)(a1 + 5760))
  {
    Count = CFArrayGetCount(theArray);
    if (Count)
    {
      v5 = Count;
      valuePtr = -21846;
      v23 = -21846;
      if (Count < 1)
        goto LABEL_16;
      v6 = 0;
      v7 = 1;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v6);
        if (ValueAtIndex)
        {
          v9 = ValueAtIndex;
          Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("ANQP_STATUS"));
          if (Value)
          {
            CFNumberGetValue(Value, kCFNumberSInt16Type, &valuePtr);
            if (valuePtr)
              v7 = 0;
            v11 = (const __CFNumber *)CFDictionaryGetValue(v9, CFSTR("CHANNEL"));
            if (v11)
            {
              CFNumberGetValue(v11, kCFNumberSInt16Type, &v23);
              v12 = CFDictionaryGetValue(v9, CFSTR("BSSID"));
              if (v12)
              {
                v13 = v12;
                v14 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "GAS response from %@ ch %3d status %d", v13, v23, valuePtr);
                objc_autoreleasePoolPop(v14);
              }
            }
          }
        }
        ++v6;
      }
      while (v5 != v6);
      if (v7)
      {
LABEL_16:
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Adding GAS cache entry", "__WiFiDeviceUpdateGasCache");
        objc_autoreleasePoolPop(v15);
        v16 = *(__CFArray **)(a1 + 5752);
        if (v16)
        {
          v17 = *(const void **)(a1 + 5728);
          if (v17)
          {
            v18 = sub_10015B190((uint64_t)kCFAllocatorDefault);
            if (v18)
            {
              v19 = v18;
              if (sub_10015B1F0((uint64_t)v18, v17)
                && sub_10015B250((uint64_t)v19)
                && sub_10015B220((uint64_t)v19, theArray))
              {
                CFArrayAppendValue(v16, v19);
              }
              CFRelease(v19);
            }
          }
        }
        sub_10001740C(*(const __CFArray **)(a1 + 5752), 3600.0);
        v20 = *(NSObject **)(a1 + 5768);
        v21 = dispatch_time(0, 3600000000000);
        dispatch_source_set_timer(v20, v21, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
      else
      {
        v22 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: One or more GAS results status is not OK.", "__WiFiDeviceUpdateGasCache");
        objc_autoreleasePoolPop(v22);
      }
    }
  }
}

void sub_10007B260(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  int v5;
  _QWORD *v9;
  void (*v10)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  void *v12;
  __CFDictionary *MutableCopy;
  __CFDictionary *v14;
  CFBooleanRef v15;
  CFBooleanRef v16;
  void *v17;

  v5 = *(_DWORD *)(a1 + 5964);
  if (!v5)
    goto LABEL_17;
  v9 = (_QWORD *)(a1 + 5464);
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 5464);
  v11 = *(_QWORD *)(a1 + 5472);
  *(_DWORD *)(a1 + 5964) = v5 - 1;
  v12 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received APPLE80211_M_SENSING_DONE on %@ (%d), expected remaing result[%d]", a2, a4, *(unsigned int *)(a1 + 5964));
  objc_autoreleasePoolPop(v12);
  *v9 = 0;
  *(_QWORD *)(a1 + 5472) = 0;
  if (!a3 || (_DWORD)a4 || !CFDictionaryGetCount(a3))
    goto LABEL_15;
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a3);
  if (MutableCopy)
  {
    v14 = MutableCopy;
    if (*(_BYTE *)(a1 + 5958))
      v15 = kCFBooleanTrue;
    else
      v15 = kCFBooleanFalse;
    CFDictionaryAddValue(MutableCopy, CFSTR("SENSING_RESULTS_DATA_DEVICE_MOTION_STATE"), v15);
    if (*(_BYTE *)(a1 + 5959))
      v16 = kCFBooleanTrue;
    else
      v16 = kCFBooleanFalse;
    CFDictionaryAddValue(v14, CFSTR("SENSING_RESULTS_DATA_DEVICE_CHARGING_STATE"), v16);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 5968), v14);
    CFRelease(v14);
LABEL_15:
    if (v10)
      v10(a1, a2, a4, v11);
    goto LABEL_17;
  }
  v17 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null sensingUpdateResult", "__WiFiDeviceProcessSensingDoneEvent");
  objc_autoreleasePoolPop(v17);
LABEL_17:
  sub_100017CB0(a1);
}

void sub_10007B400(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  void *v8;
  void (*v9)(uint64_t, uint64_t, _WORD *, _QWORD, uint64_t, uint64_t);
  uint64_t v10;
  CFTypeID v11;

  v8 = objc_autoreleasePoolPush();
  v9 = *(void (**)(uint64_t, uint64_t, _WORD *, _QWORD, uint64_t, uint64_t))(a1 + 4760);
  v10 = *(_QWORD *)(a1 + 4768);
  *(_QWORD *)(a1 + 4768) = 0;
  *(_QWORD *)(a1 + 4760) = 0;
  if (!a3)
  {
LABEL_4:
    if (!v9)
      goto LABEL_6;
    goto LABEL_5;
  }
  v11 = CFGetTypeID(a3);
  if (v11 == CFDictionaryGetTypeID())
  {
    a3 = sub_10002B314((uint64_t)kCFAllocatorDefault, a3);
    goto LABEL_4;
  }
  a3 = 0;
  if (v9)
LABEL_5:
    v9(a1, a2, a3, 0, a4, v10);
LABEL_6:
  if (a3)
    CFRelease(a3);
  objc_autoreleasePoolPop(v8);
}

void sub_10007B4C8(uint64_t a1, const void *a2, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  const __CFNumber *v10;
  const void *v11;
  const __CFNumber *v12;
  _DWORD *v13;
  const __CFAllocator *v14;
  int v15;
  CFNumberRef v16;
  int v17;
  void *v18;
  const void *v19;
  void *v20;
  NSString *v21;
  const char *v22;
  const __CFString *Mutable;
  int i;
  uint64_t v25;
  uint64_t v26;
  void *v28;
  CFNumberRef v29;
  void (*v30)(uint64_t, const void *, _QWORD, CFDictionaryRef);
  const __CFNumber *v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  _WORD *v35;
  const void *v36;
  const __CFString *v37;
  CFStringRef Copy;
  void *v39;
  NSString *v40;
  const char *v41;
  int64_t v42;
  int64_t v43;
  void *v44;
  NSObject *v45;
  dispatch_time_t v46;
  NSObject *v47;
  dispatch_time_t v48;
  const __CFData *v49;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFData *v52;
  const UInt8 *v53;
  CFIndex v54;
  const char *v55;
  CFStringRef v56;
  void *v57;
  NSString *v58;
  const char *v59;
  void *v60;
  NSString *v61;
  const char *v62;
  void *v63;
  void *v64;
  void *v65;
  const char *v66;
  void *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  int v71;
  char v72;
  int v73;
  char valuePtr;
  unsigned int v75;
  unsigned int v76;
  char v77;
  uint8_t buf[4];
  const char *v79;

  valuePtr = 0;
  v73 = 0;
  v72 = 0;
  v71 = 0;
  if (!theDict)
  {
    v64 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: linkChangedEventDataDict is NULL", "__WiFiDeviceProcessLinkEvent");
    goto LABEL_100;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINK_CHANGED_IS_LINKDOWN"));
  v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("RSSI"));
  if (!Value)
  {
    v64 = objc_autoreleasePoolPush();
    v65 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v66 = "%s: isLinkDownNumRef is null";
LABEL_99:
      objc_msgSend(v65, "WFLog:message:", 4, v66, "__WiFiDeviceProcessLinkEvent");
    }
LABEL_100:
    objc_autoreleasePoolPop(v64);
    return;
  }
  v8 = v7;
  if (!v7)
  {
    v64 = objc_autoreleasePoolPush();
    v65 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v66 = "%s: rssiNumRef is null";
      goto LABEL_99;
    }
    goto LABEL_100;
  }
  CFNumberGetValue(Value, kCFNumberSInt8Type, &valuePtr);
  CFNumberGetValue(v8, kCFNumberSInt32Type, &v73);
  if (valuePtr)
  {
    *(_DWORD *)(a1 + 5944) = 0;
    v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_IS_INVOL"));
    v10 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_REASON_CODE"));
    v11 = 0;
    if (v9)
    {
      v12 = v10;
      if (v10)
      {
        CFNumberGetValue(v9, kCFNumberSInt8Type, &v72);
        CFNumberGetValue(v12, kCFNumberIntType, &v71);
        v13 = (_DWORD *)(a1 + 5800);
        if (v72)
        {
          v14 = kCFAllocatorDefault;
        }
        else
        {
          v14 = kCFAllocatorDefault;
          if (*v13)
          {
            if ((v71 & 0xFFFFFFF7) == 0)
            {
              v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 5800));
              CFDictionarySetValue(theDict, CFSTR("LINKDOWN_REASON_CODE"), v29);
              if (v29)
                CFRelease(v29);
            }
          }
        }
        if (*v13 == 1015)
          v15 = 2;
        else
          v15 = *v13 == 1011;
        *(_DWORD *)buf = v15;
        v16 = CFNumberCreate(v14, kCFNumberIntType, buf);
        CFDictionarySetValue(theDict, CFSTR("CLIENT_REASON"), v16);
        if (v16)
          CFRelease(v16);
        v11 = 0;
      }
    }
  }
  else
  {
    v76 = 0;
    v17 = sub_1000745C0(a1, (uint64_t)&v76);
    v18 = objc_autoreleasePoolPush();
    if (v17)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s WFMacRandomisation : Cannot read APPLE80211_IOC_DEVICE_TYPE_IN_DHCP_ALLOW.", "__WiFiDeviceProcessLinkEvent", v70);
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Device Type allowed in DHCP request ? [%d]", "__WiFiDeviceProcessLinkEvent", v76);
    }
    objc_autoreleasePoolPop(v18);
    v19 = sub_10002BF8C(a1, a2);
    if (!v19)
    {
      v68 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Link up event with no current network detected. Dropping.");
      objc_autoreleasePoolPop(v68);
      return;
    }
    v11 = v19;
    CFDictionaryAddValue(theDict, CFSTR("LINK_CHANGED_NETWORK"), v19);
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("LINK"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: link up to %@"), "__WiFiDeviceProcessLinkEvent", sub_10002B088(v11))), "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v22 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v21, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v79 = v22;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    objc_autoreleasePoolPop(v20);
    if (_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
    {
      Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
      for (i = 6; ; --i)
      {
        v25 = Apple80211Get(*(_QWORD *)(a1 + 16), 387, 0, Mutable, 8);
        v26 = v25;
        if ((int)v25 <= 15)
        {
          if ((_DWORD)v25 != -3905)
            break;
        }
        else if ((_DWORD)v25 != 61 && (_DWORD)v25 != 16)
        {
          goto LABEL_36;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if ((_DWORD)v25)
      {
LABEL_36:
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed APPLE80211_IOC_COLOCATED_NETWORK_SCOPE_ID - %d", v26, v70);
        goto LABEL_45;
      }
      if (!CFStringGetLength(Mutable))
        goto LABEL_46;
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "ColocatedScopeId for %@ - '%@'", sub_10002B088(v11), Mutable);
LABEL_45:
      objc_autoreleasePoolPop(v28);
LABEL_46:
      if (Mutable)
        CFRelease(Mutable);
    }
  }
  if (!valuePtr && *(_BYTE *)(a1 + 5952) && MGGetBoolAnswer(CFSTR("InternalBuild")))
  {
    v69 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: 3 2 1 crashing because of debug command", "__WiFiDeviceProcessLinkEvent");
    objc_autoreleasePoolPop(v69);
    exit(14);
  }
  v30 = *(void (**)(uint64_t, const void *, _QWORD, CFDictionaryRef))(a1 + 4952);
  if (v30)
    v30(a1, a2, *(_QWORD *)(a1 + 4960), theDict);
  if (!valuePtr)
  {
    sub_100069690(a1);
    sub_100011C94((_BYTE *)a1, (uint64_t)a2, theDict);
    v39 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v40 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("LINK"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: %@ - Initializing lqm value: rawRssi %d, scaledRssi %f, noise %ld, snr %ld"), "__WiFiDeviceProcessLinkEvent", sub_10002B088(v11), *(unsigned int *)(a1 + 264), *(float *)(a1 + 268), *(_QWORD *)(a1 + 296), *(_QWORD *)(a1 + 280))),
                "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        v41 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v40, "UTF8String")), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v79 = v41;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
      }
    }
    v42 = 300000000000;
    v43 = 60000000000;
    objc_autoreleasePoolPop(v39);
    if (v11 && sub_100078718(a1, v11))
    {
      v44 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Using aggressive timeouts for primary <%d seconds> and routable <%d seconds> timeouts for classification", "__WiFiDeviceProcessLinkEvent", 120, 30);
      objc_autoreleasePoolPop(v44);
      v43 = 30000000000;
      v42 = 120000000000;
    }
    v45 = *(NSObject **)(a1 + 72);
    v46 = dispatch_time(0, v42);
    dispatch_source_set_timer(v45, v46, 0xFFFFFFFFFFFFFFFFLL, 0);
    v47 = *(NSObject **)(a1 + 80);
    v48 = dispatch_time(0, v43);
    dispatch_source_set_timer(v47, v48, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(CFAbsoluteTime *)(a1 + 4304) = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(a1 + 5800) = 0;
    if (v11)
      goto LABEL_91;
    return;
  }
  sub_100011C94((_BYTE *)a1, (uint64_t)a2, theDict);
  dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 72), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 80), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  v31 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_IS_INVOL"));
  v32 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_REASON_CODE"));
  v33 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("LINKDOWN_SUBREASON_CODE"));
  if (v31)
  {
    if (v32)
    {
      v34 = v33;
      if (v33)
      {
        v77 = -86;
        v75 = -1431655766;
        v76 = -1431655766;
        CFNumberGetValue(v31, kCFNumberSInt8Type, &v77);
        CFNumberGetValue(v32, kCFNumberIntType, &v76);
        CFNumberGetValue(v34, kCFNumberIntType, &v75);
        sub_1000521A8(a1, 0, v77, v76, v75, *(_DWORD *)(a1 + 264), 0, *(_DWORD *)(a1 + 5872));
        if (v76 == 7)
        {
          v35 = sub_1000764F8(a1);
          if (v35)
          {
            v36 = v35;
            v37 = (const __CFString *)sub_10002B088(v35);
            Copy = CFStringCreateCopy(kCFAllocatorDefault, v37);
            CFRelease(v36);
LABEL_75:
            v55 = "went down";
            goto LABEL_76;
          }
        }
        else
        {
          v49 = *(const __CFData **)(a1 + 5816);
          if (v49)
          {
            BytePtr = CFDataGetBytePtr(v49);
            Length = CFDataGetLength(*(CFDataRef *)(a1 + 5816));
            Copy = CFStringCreateWithBytes(kCFAllocatorDefault, BytePtr, Length, 0x8000100u, 0);
            goto LABEL_75;
          }
          v52 = *(const __CFData **)(a1 + 5808);
          if (v52)
          {
            v53 = CFDataGetBytePtr(v52);
            v54 = CFDataGetLength(*(CFDataRef *)(a1 + 5808));
            Copy = CFStringCreateWithBytes(kCFAllocatorDefault, v53, v54, 0x8000100u, 0);
            v55 = "up failed";
LABEL_76:
            if (v76 == 3)
            {
              v56 = sub_10007E438(*(_QWORD *)(a1 + 16), v75);
              v57 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v58 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("LINK"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Link %s: %@ - isInVoluntary %d, reason %@(0x%x), subreason %@(0x%x), rssi %d"), v55, Copy, v77, sub_100064AA8(v76), v76, v56,
                              v75,
                              *(unsigned int *)(a1 + 264))),
                          "UTF8String"));
                if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
                {
                  v59 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v58, "UTF8String")), "UTF8String");
                  *(_DWORD *)buf = 136446210;
                  v79 = v59;
                  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
                }
              }
              objc_autoreleasePoolPop(v57);
              if (v56)
                CFRelease(v56);
            }
            else
            {
              v60 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
              {
                v61 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@-} %@"), CFSTR("LINK"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Link %s: %@ - isInVoluntary %d, reason %@(%d), subreason %d, rssi %d"), v55, Copy, v77, sub_100064AA8(v76), v76, v75,
                              *(unsigned int *)(a1 + 264))),
                          "UTF8String"));
                if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
                {
                  v62 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v61, "UTF8String")), "UTF8String");
                  *(_DWORD *)buf = 136446210;
                  v79 = v62;
                  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
                }
              }
              objc_autoreleasePoolPop(v60);
            }
            if (Copy)
              CFRelease(Copy);
            goto LABEL_88;
          }
        }
        Copy = 0;
        goto LABEL_75;
      }
    }
  }
  v67 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: linkChangedEventDataDict has null key values", "__WiFiDeviceProcessLinkDownData");
  objc_autoreleasePoolPop(v67);
LABEL_88:
  kdebug_trace(731381832, 0, 0, 0, 0);
  v63 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Disassociated.");
  objc_autoreleasePoolPop(v63);
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_DWORD *)(a1 + 264) = *(_QWORD *)(a1 + 240);
  sub_100069690(a1);
  if (v11)
LABEL_91:
    CFRelease(v11);
}

void sub_10007C1C4(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  const void *v6;
  const void *v7;
  void *v8;
  NSString *v9;
  void *v10;
  void (*v11)(uint64_t, const void *, _QWORD, const __CFDictionary *);
  const __CFNumber *Value;
  uint8_t buf[4];
  const char *v14;

  if (a3)
  {
    v6 = sub_10002BF8C(a1, a2);
    if (v6)
    {
      v7 = v6;
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("LINK, ROAM"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: received roam status event for network %@"), "__WiFiDeviceProcessRoamStatusEvent", sub_10002B088(v7))), "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v14 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v9, "UTF8String")), "UTF8String");
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
        }
      }
      objc_autoreleasePoolPop(v8);
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Reporting RoamStatus Event", "__WiFiDeviceReportRoamStatusEvent");
      objc_autoreleasePoolPop(v10);
      v11 = *(void (**)(uint64_t, const void *, _QWORD, const __CFDictionary *))(a1 + 4576);
      if (v11)
        v11(a1, a2, *(_QWORD *)(a1 + 4584), a3);
      Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ROAMEDEVENT_STATUS"));
      *(_DWORD *)buf = 0;
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt32Type, buf);
        if (!*(_DWORD *)buf)
          sub_100068B8C(a1);
      }
      CFRelease(v7);
    }
  }
}

void sub_10007C3CC(uint64_t a1, uint64_t a2)
{
  void (*v3)(uint64_t, uint64_t, _QWORD);
  NSObject *v4;
  dispatch_time_t v5;

  v3 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 4432);
  if (v3)
    v3(a1, a2, *(_QWORD *)(a1 + 4440));
  if (*(_DWORD *)(a1 + 4316) == 2 || *(_BYTE *)(a1 + 4300))
  {
    v4 = *(NSObject **)(a1 + 80);
    v5 = dispatch_time(0, 30000000000);
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

void sub_10007C448(uint64_t a1, const void *a2)
{
  int v4;
  void (*v5)(uint64_t, const void *, _QWORD);

  v4 = sub_100070EB0(a1, a2);
  *(_DWORD *)(a1 + 48) = v4;
  if (v4 != 1)
  {
    sub_10007114C((uint64_t *)a1);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 72), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 80), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 88), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 5712), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    sub_100005C88(a1, 0);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 5768), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    sub_100073470(a1);
  }
  v5 = *(void (**)(uint64_t, const void *, _QWORD))(a1 + 4384);
  if (v5)
    v5(a1, a2, *(_QWORD *)(a1 + 4392));
}

void sub_10007C518(_QWORD *a1, uint64_t a2, int a3)
{
  void (*v4)(_QWORD *, uint64_t, _QWORD, _QWORD, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  unsigned int v10;

  if (!a3)
  {
    v4 = (void (*)(_QWORD *, uint64_t, _QWORD, _QWORD, uint64_t))a1[703];
    if (v4)
    {
      v6 = a1[704];
      v10 = -1431655766;
      v7 = Apple80211Get(a1[2], 15, 0, &v10, 4);
      if ((_DWORD)v7)
      {
        v8 = v7;
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Apple80211Get(..., APPLE80211_IOC_OP_MODE) failed. error = %i\n", v8);
        objc_autoreleasePoolPop(v9);
      }
      else
      {
        v4(a1, a2, (v10 >> 4) & 1, 0, v6);
      }
    }
  }
}

void sub_10007C5DC(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  CFTypeRef v5;
  CFTypeID v6;
  void *v7;
  void (*v8)(uint64_t, uint64_t, CFTypeRef, _QWORD);

  if (cf && (v5 = cf, v6 = CFGetTypeID(cf), v6 == CFArrayGetTypeID()))
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Discovered networks=%@", "__WiFiDeviceProcessBGScanNetworkDiscoveredEvent", v5);
  }
  else
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL evendata", "__WiFiDeviceProcessBGScanNetworkDiscoveredEvent");
    v5 = 0;
  }
  objc_autoreleasePoolPop(v7);
  v8 = *(void (**)(uint64_t, uint64_t, CFTypeRef, _QWORD))(a1 + 4608);
  if (v8)
    v8(a1, a2, v5, *(_QWORD *)(a1 + 4616));
}

void sub_10007C6D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int16 *, _QWORD);
  __int16 *v10;
  __int16 v11;
  char v12;

  if (a3)
  {
    v6 = *(unsigned __int8 *)(a3 + 8);
    v7 = *(unsigned int *)(a3 + 12);
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: staNum %d", "__WiFiDeviceProcessSTAArriveEvent", v6);
    objc_autoreleasePoolPop(v8);
  }
  else
  {
    v7 = 0;
    v6 = 1;
  }
  v9 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int16 *, _QWORD))(a1 + 4792);
  if (v9)
  {
    v11 = -21846;
    v12 = -86;
    if (a3)
      v10 = &v11;
    else
      v10 = 0;
    v9(a1, a2, v6, v7, a3, v10, *(_QWORD *)(a1 + 4800));
  }
}

void sub_10007C7A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  void (*v8)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, __int16 *, _QWORD);
  __int16 *v9;
  __int16 v10;
  char v11;

  v10 = -21846;
  v11 = -86;
  if (a3)
  {
    v6 = *(unsigned __int8 *)(a3 + 8);
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: staNum %d", "__WiFiDeviceProcessSTALeaveEvent", v6);
    objc_autoreleasePoolPop(v7);
    v10 = *(_WORD *)a3;
    v11 = *(_BYTE *)(a3 + 2);
  }
  else
  {
    v6 = 1;
  }
  v8 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, __int16 *, _QWORD))(a1 + 4808);
  if (v8)
  {
    if (a3)
      v9 = &v10;
    else
      v9 = 0;
    v8(a1, a2, v6, 0, a3, v9, *(_QWORD *)(a1 + 4816));
  }
}

void sub_10007C878(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 4888);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 4896), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceProcessBTCoexStatsEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007C904(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5448);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 5456), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceProcessBSPEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007C990(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 4936);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 4944), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceObssMitEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007CA1C(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  void *v5;
  const void *v6;
  int v7;
  int v8;
  int v9;
  CFNumberRef v10;
  const void *v11;
  const __CFNumber *Value;
  const __CFNumber *v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  CFStringRef v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFString *v20;
  void *v21;
  const __CFString *v22;
  int v23;
  uint64_t v24;
  void *v25;
  const __CFString *v26;
  WiFiUsageMonitor *v27;
  void *v28;
  void *v29;
  const void *v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  const void *v34;
  CFTypeID TypeID;
  const void *v36;
  const void *v37;
  const void *v38;
  CFTypeID v39;
  const void *v40;
  int i;
  uint64_t v42;
  uint64_t v43;
  void *v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  CFDictionaryRef v51;
  CFDictionaryRef v52;
  void *v53;
  void (*v54)(uint64_t, const void *, const __CFDictionary *, _QWORD);
  void *v55;
  const void *v56;
  void *context;
  const __CFBoolean *BOOLean;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int valuePtr;
  int v65;

  v5 = objc_autoreleasePoolPush();
  v65 = 0;
  if (!a1)
  {
    v55 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device", "__WiFiDeviceProcessDriverAvailableEvent");
    goto LABEL_133;
  }
  if (!a3)
  {
    v55 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null eventData", "__WiFiDeviceProcessDriverAvailableEvent");
    goto LABEL_133;
  }
  BOOLean = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE"));
  if (!BOOLean)
  {
    v55 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: available key missing", "__WiFiDeviceProcessDriverAvailableEvent");
LABEL_133:
    objc_autoreleasePoolPop(v55);
    goto LABEL_126;
  }
  v6 = *(const void **)(a1 + 5840);
  if (v6)
    CFDictionarySetValue(a3, CFSTR("SSID_STR"), v6);
  if (*(_BYTE *)(a1 + 5864))
  {
    v7 = *(_DWORD *)(a1 + 5872);
    v8 = v7 == 1 ? 1 : 2;
    v9 = v7 ? v8 : 3;
    v10 = sub_100064FE0(v9);
    CFDictionarySetValue(a3, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v10);
    if (v10)
      CFRelease(v10);
  }
  v11 = *(const void **)(a1 + 5856);
  if (v11)
    CFDictionarySetValue(a3, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v11);
  Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_REASON"));
  v13 = Value;
  valuePtr = 0;
  if (Value)
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  v14 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_SUBREASON"));
  v15 = v14;
  v63 = 0;
  if (v14)
    CFNumberGetValue(v14, kCFNumberSInt32Type, &v63);
  v16 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_FLAGS"));
  if (v16)
    CFNumberGetValue(v16, kCFNumberSInt32Type, &v65);
  if (v63)
  {
    v17 = sub_10007E438(*(_QWORD *)(a1 + 16), v63);
    if (v17)
      CFDictionarySetValue(a3, CFSTR("DRIVER_AVAILABLE_KEY_SUBREASON_STRING"), v17);
  }
  else
  {
    v17 = 0;
  }
  v62 = 0;
  if (CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_PROGRAM_COUNTER")))
    CFNumberGetValue(v15, kCFNumberSInt32Type, &v62);
  v18 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_LINK_REGISTER"));
  v61 = 0;
  if (v18)
    CFNumberGetValue(v18, kCFNumberSInt32Type, &v61);
  v19 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_LINENUMBER"));
  v60 = 0;
  if (v19)
    CFNumberGetValue(v19, kCFNumberSInt32Type, &v60);
  v20 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
  v21 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: driver reason string: %@ \n", "__WiFiDeviceProcessDriverAvailableEvent", v20);
  objc_autoreleasePoolPop(v21);
  context = v5;
  if (v20 && CFStringCompare(v20, &stru_100238178, 0))
  {
    if (!v63)
    {
      CFDictionarySetValue(a3, CFSTR("DRIVER_AVAILABLE_SUBREASON"), v13);
      v17 = sub_10007E438(*(_QWORD *)(a1 + 16), valuePtr);
      if (v17)
        CFDictionarySetValue(a3, CFSTR("DRIVER_AVAILABLE_KEY_SUBREASON_STRING"), v17);
    }
    v22 = 0;
  }
  else
  {
    if ((int)valuePtr <= -528340991)
    {
      switch(valuePtr)
      {
        case 0xE0821801:
          v22 = CFSTR("ShutdownPending");
          break;
        case 0xE0821802:
          v22 = CFSTR("UnInited");
          break;
        case 0xE0821803:
          v22 = CFSTR("Initializing");
          break;
        case 0xE0821804:
          v22 = CFSTR("PowerOff");
          break;
        case 0xE0821805:
          v22 = CFSTR("PoweringOff");
          break;
        default:
          if (valuePtr == -528340991)
            v22 = CFSTR("OnThread");
          else
LABEL_51:
            v22 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Unknown=%d"), valuePtr);
          break;
      }
    }
    else
    {
      switch(valuePtr)
      {
        case 0xE0823801:
          v22 = CFSTR("Watchdog");
          break;
        case 0xE0823802:
          v22 = CFSTR("WDRunning");
          break;
        case 0xE0823803:
          v22 = CFSTR("WDTriggered");
          break;
        case 0xE0823804:
          v22 = CFSTR("WDFailed");
          break;
        case 0xE0823805:
          goto LABEL_51;
        case 0xE0823806:
          v22 = CFSTR("FWTrap");
          break;
        default:
          if (valuePtr == -528340989)
          {
            v22 = CFSTR("BootedImage");
          }
          else
          {
            if (valuePtr != -528340990)
              goto LABEL_51;
            v22 = CFSTR("NotInGate");
          }
          break;
      }
    }
    CFDictionarySetValue(a3, CFSTR("DRIVER_AVAILABLE_REASON_STRING"), v22);
  }
  v23 = CFBooleanGetValue(BOOLean);
  if (!v23)
  {
    if (valuePtr == -528336895)
    {
      v24 = 7;
    }
    else
    {
      if (valuePtr != -528336890)
        goto LABEL_68;
      v24 = 21;
    }
    -[WiFiUsageMonitor addFaultEvent:forInterface:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "addFaultEvent:forInterface:", v24, a2);
LABEL_68:
    if (*(_QWORD *)(a1 + 4672))
    {
      v25 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: hostap never started. Invoking error callback on watchdog.", "__WiFiDeviceProcessDriverAvailableEvent");
      objc_autoreleasePoolPop(v25);
      sub_10006A18C(a1, (uint64_t)a2, 4294963390);
    }
  }
  if (!v17 || (v26 = v17, !CFStringGetLength(v17)))
  {
    if (!v22 || (v26 = v22, !CFStringGetLength(v22)))
      v26 = v20;
  }
  v27 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
  -[WiFiUsageMonitor notifyDriverAvailability:available:version:flags:eventID:reason:subReason:minorReason:reasonString:](v27, "notifyDriverAvailability:available:version:flags:eventID:reason:subReason:minorReason:reasonString:", a2, v23 != 0, 0, 0, 0, valuePtr, (int)v63, 0, v26);
  v28 = objc_autoreleasePoolPush();
  v29 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v56 = CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE"));
    v30 = CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_REASON_STRING"));
    v31 = valuePtr;
    v32 = CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_KEY_SUBREASON_STRING"));
    objc_msgSend(v29, "WFLog:message:", 3, "%s: driver availability:%@, reason:%@(0x%x), subreason:%@(0x%x) flag: %@ \n", "__WiFiDeviceProcessDriverAvailableEvent", v56, v30, v31, v32, v63, CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_FLAGS")));
  }
  objc_autoreleasePoolPop(v28);
  if (valuePtr == -528345084)
    goto LABEL_122;
  v33 = CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_FUNCTION "));
  if (v33)
  {
    v34 = v33;
    TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v34))
      v36 = v34;
    else
      v36 = 0;
  }
  else
  {
    v36 = 0;
  }
  v37 = CFDictionaryGetValue(a3, CFSTR("DRIVER_AVAILABLE_FILENAME"));
  if (v37)
  {
    v38 = v37;
    v39 = CFStringGetTypeID();
    if (v39 == CFGetTypeID(v38))
      v40 = v38;
    else
      v40 = 0;
  }
  else
  {
    v40 = 0;
  }
  if (CFBooleanGetValue(BOOLean) == 1)
  {
    for (i = 6; ; --i)
    {
      v42 = Apple80211SetPowerState(*(_QWORD *)(a1 + 16), *(unsigned int *)(a1 + 48));
      v43 = v42;
      if ((_DWORD)v42 != -3905 && (_DWORD)v42 != 61 && (_DWORD)v42 != 16)
        break;
      if (!i)
        break;
      usleep(0x7A120u);
    }
    v45 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting power to %s[%d]", "__WiFiDeviceProcessDriverAvailableEvent", sub_1000648F0(*(_DWORD *)(a1 + 48)), v43);
    objc_autoreleasePoolPop(v45);
    v46 = v65;
    if ((v65 & 0x10) != 0)
    {
      objc_msgSend(+[WAClient sharedClientWithIdentifier:](WAClient, "sharedClientWithIdentifier:", CFSTR("wifid")), "trapCrashMiniTracerDumpReadyForInterfaceWithName:andReply:", *(_QWORD *)(a1 + 112), &stru_10022F7F8);
      v46 = v65;
    }
    if ((v46 & 8) != 0)
    {
      v47 = 2;
LABEL_108:
      v48 = sub_10005AFD8(v47, a3, *(_QWORD *)(a1 + 16));
      if ((_DWORD)v48)
      {
        v49 = v48;
        v50 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiMetricsManagerCheckQueryableWatchdogInfo() returned error %d", "__WiFiDeviceProcessDriverAvailableEvent", v49);
        objc_autoreleasePoolPop(v50);
      }
      goto LABEL_112;
    }
    if ((v46 & 4) != 0)
    {
      v47 = 1;
      goto LABEL_108;
    }
  }
LABEL_112:
  if (valuePtr != -528345085 || v62 || v61)
  {
    v53 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: driver programCounter:(0x%0x),  linkRegister:(0x%x), fileName:%@ lineNumber:(%u) functionName:%@ \n", "__WiFiDeviceProcessDriverAvailableEvent", v62, v61, v40, v60, v36);
    objc_autoreleasePoolPop(v53);
    sub_1000576F4(a1, a3);
  }
  else if (CFBooleanGetValue(BOOLean))
  {
    if (sub_100064EA4())
    {
      v51 = sub_100008514(a1, a2, CFSTR("IO80211InterfaceWoWWakeUpParams"));
      if (v51)
      {
        v52 = v51;
        CFDictionarySetValue(a3, CFSTR("IO80211InterfaceWoWWakeUpParams"), v51);
        CFRelease(v52);
      }
    }
  }
LABEL_122:
  v54 = *(void (**)(uint64_t, const void *, const __CFDictionary *, _QWORD))(a1 + 5016);
  v5 = context;
  if (v54)
    v54(a1, a2, a3, *(_QWORD *)(a1 + 5024));
  if (v17)
    CFRelease(v17);
LABEL_126:
  objc_autoreleasePoolPop(v5);
}

void sub_10007D340(uint64_t a1, uint64_t a2, const __CFArray *a3)
{
  CFMutableStringRef Mutable;
  __CFString *v7;
  CFTypeID v8;
  CFIndex Count;
  void *v10;
  void (*v11)(uint64_t, uint64_t, const __CFArray *, _QWORD);
  CFRange v12;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
  {
    v7 = Mutable;
    if (a3 && (v8 = CFGetTypeID(a3), v8 == CFArrayGetTypeID()))
    {
      Count = CFArrayGetCount(a3);
      CFStringAppendFormat(v7, 0, CFSTR("network count=%ld, "), Count);
      v12.length = CFArrayGetCount(a3);
      v12.location = 0;
      CFArrayApplyFunction(a3, v12, (CFArrayApplierFunction)sub_10007E550, v7);
    }
    else
    {
      CFStringAppendFormat(v7, 0, CFSTR("NULL eventData"));
      a3 = 0;
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiDeviceProcessBGScanCachedNetworkEvent", v7);
    objc_autoreleasePoolPop(v10);
    v11 = *(void (**)(uint64_t, uint64_t, const __CFArray *, _QWORD))(a1 + 4624);
    if (v11)
      v11(a1, a2, a3, *(_QWORD *)(a1 + 4632));
    CFRelease(v7);
  }
}

CFTypeID sub_10007D488(CFTypeID result, uint64_t a2, CFTypeRef cf)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  uint64_t (*v7)(uint64_t, uint64_t, CFTypeRef, _QWORD);

  v4 = result;
  if (cf)
  {
    v5 = cf;
    v6 = CFGetTypeID(cf);
    result = CFDictionaryGetTypeID();
    if (v6 == result)
      cf = v5;
    else
      cf = 0;
  }
  v7 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef, _QWORD))(v4 + 4640);
  if (v7)
    return v7(v4, a2, cf, *(_QWORD *)(v4 + 4648));
  return result;
}

void sub_10007D4F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5112);
  if (v3)
  {
    v3(a1, a2, *(_QWORD *)(a1 + 5120), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s Callback not registered", "__WiFiDeviceProcessLeakyAPStatsEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007D56C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5192);
    if (v3)
      v3(a1, a2, *(_QWORD *)(a1 + 5200), a3);
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: eventData is NULL!", "__WiFiDeviceProcessTxFailEvent");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007D5F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);

  v7 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 5256);
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "BSS steer event: %@\n", a3);
  objc_autoreleasePoolPop(v6);
  if (v7)
    v7(a1, a2, a3, 0, *(_QWORD *)(a1 + 5264));
}

void sub_10007D698(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFStringRef v12;
  CFStringRef v13;
  int v14;
  const void **v15;
  const void **v16;
  void (*v17)(uint64_t, uint64_t, __CFDictionary *, _QWORD, _QWORD);
  void *v18;
  void *v19;
  const char *v20;

  if (!a3)
    return;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = Mutable;
  if (!*(_BYTE *)(a3 + 40))
    goto LABEL_8;
  CFDictionaryAddValue(Mutable, CFSTR("kWiFiHostApWiFiNetworkIeValidKey"), kCFBooleanTrue);
  v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a3 + 2));
  if (!v8)
  {
    v18 = objc_autoreleasePoolPush();
    v19 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_29;
    v20 = "Failed to get Battery Info from Event data";
    goto LABEL_28;
  }
  v9 = v8;
  CFDictionarySetValue(v7, CFSTR("WiFiHostApWiFiNetworkIeBatteryKey"), v8);
  CFRelease(v9);
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, (const void *)a3);
  if (!v10)
  {
    v18 = objc_autoreleasePoolPush();
    v19 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_29;
    v20 = "Failed to get Flag Info from Event data";
    goto LABEL_28;
  }
  v11 = v10;
  CFDictionarySetValue(v7, CFSTR("WiFiHostApWiFiNetworkIeFlagKey"), v10);
  CFRelease(v11);
  if (!*(_BYTE *)(a3 + 3))
    goto LABEL_8;
  v12 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)(a3 + 4), 0x8000100u);
  if (v12)
  {
    v13 = v12;
    CFDictionarySetValue(v7, CFSTR("WiFiHostApWiFiNetworkIeSsidKey"), v12);
    CFRelease(v13);
LABEL_8:
    v14 = *(_DWORD *)(a3 + 36);
    if ((v14 & 1) != 0)
    {
      if ((v14 & 2) != 0)
        v15 = (const void **)&kCFBooleanTrue;
      else
        v15 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(v7, CFSTR("DIRECTED_NETWORK"), *v15);
      v14 = *(_DWORD *)(a3 + 36);
    }
    if ((v14 & 4) != 0)
    {
      if ((v14 & 8) != 0)
        v16 = (const void **)&kCFBooleanTrue;
      else
        v16 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(v7, CFSTR("INTERNET_ACCESS"), *v16);
    }
    v17 = *(void (**)(uint64_t, uint64_t, __CFDictionary *, _QWORD, _QWORD))(a1 + 5288);
    if (v17)
      v17(a1, a2, v7, 0, *(_QWORD *)(a1 + 5296));
    if (v7)
      goto LABEL_21;
    return;
  }
  v18 = objc_autoreleasePoolPush();
  v19 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v20 = "Failed to get SSID Info from Event data";
LABEL_28:
    objc_msgSend(v19, "WFLog:message:", 3, v20);
  }
LABEL_29:
  objc_autoreleasePoolPop(v18);
  if (v7)
LABEL_21:
    CFRelease(v7);
}

void sub_10007D8EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v8;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: DPS Received on AC ", "__WiFiDeviceProcessDPSEvent");
  objc_autoreleasePoolPop(v6);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5304);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5312), a3);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Sent DPS Notification ", "__WiFiDeviceProcessDPSEvent");
  objc_autoreleasePoolPop(v8);
}

void sub_10007D9A8(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, const __CFDictionary *);
  void *v8;

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SlowWiFi Received %@", "__WiFiDeviceProcessSlowWiFiEvent", a3);
  objc_autoreleasePoolPop(v6);
  sub_10005DB30(a1, a3);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, const __CFDictionary *))(a1 + 5320);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5328), a3);
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Sent SlowWiFi Notification ", "__WiFiDeviceProcessSlowWiFiEvent");
  objc_autoreleasePoolPop(v8);
}

void sub_10007DA70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SlowWiFiLinkProbeTrigger Received %@", "__WiFiDeviceProcessSlowWiFiLinkProbeTrigger", a3);
  objc_autoreleasePoolPop(v6);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5336);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5344), a3);
}

void sub_10007DB0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SlowWiFiUserInputTrigger Received %@", "__WiFiDeviceProcessSlowWiFiUserInputTrigger", a3);
  objc_autoreleasePoolPop(v6);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5352);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5360), a3);
}

void sub_10007DBA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v4)(uint64_t, uint64_t, _QWORD, uint64_t);
  void *v5;
  uint64_t v6;

  v4 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5368);
  if (v4)
    v4(a1, a2, *(_QWORD *)(a1 + 5376), a3);
  v5 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Prune Event Notification %@ ", "__WiFiDeviceProcessPruneEvent", a3);
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Prune Event Notification with nil ", "__WiFiDeviceProcessPruneEvent", v6);
  }
  objc_autoreleasePoolPop(v5);
}

void sub_10007DC3C(_QWORD *a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;
  dispatch_time_t v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  __CFDictionary *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  void (*v14)(_QWORD *, uint64_t, _QWORD, __CFDictionary *);
  __CFDictionary *v15;
  void *v16;
  void (*v17)(_QWORD *, uint64_t, _QWORD);
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  int valuePtr;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ", "__WiFiDeviceProcessCountryCodeChangedEvent");
  objc_autoreleasePoolPop(v4);
  v5 = a1[11];
  v6 = dispatch_time(0, 1000000000);
  dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0);
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate dictRef", "__WiFiDeviceSendBSPCountryCodeChangeEvent");
    objc_autoreleasePoolPop(v18);
    goto LABEL_14;
  }
  v8 = Mutable;
  valuePtr = 10;
  v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (!v9)
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate eventTypeRef", "__WiFiDeviceSendBSPCountryCodeChangeEvent");
    objc_autoreleasePoolPop(v19);
    v15 = v8;
    goto LABEL_13;
  }
  v10 = v9;
  CFDictionarySetValue(v8, CFSTR("BSP_EventType"), v9);
  v11 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v11)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate eventParamsRef", "__WiFiDeviceSendBSPCountryCodeChangeEvent");
    goto LABEL_29;
  }
  v21 = 0;
  v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v21);
  if (!v12)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:cannot allocate dummyRef", "__WiFiDeviceSendBSPCountryCodeChangeEvent");
LABEL_29:
    objc_autoreleasePoolPop(v20);
    v13 = 0;
    goto LABEL_9;
  }
  v13 = v12;
  CFDictionarySetValue(v11, CFSTR("dummy"), v12);
  CFDictionarySetValue(v8, CFSTR("BSP_EventParams"), v11);
  v14 = (void (*)(_QWORD *, uint64_t, _QWORD, __CFDictionary *))a1[681];
  if (v14)
    v14(a1, a2, a1[682], v8);
LABEL_9:
  CFRelease(v8);
  CFRelease(v10);
  if (v11)
    CFRelease(v11);
  if (v13)
  {
    v15 = v13;
LABEL_13:
    CFRelease(v15);
  }
LABEL_14:
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Country code changed, purging scan cache\n", "__WiFiDeviceProcessCountryCodeChangedEvent");
  objc_autoreleasePoolPop(v16);
  sub_100005C88((uint64_t)a1, 1);
  v17 = (void (*)(_QWORD *, uint64_t, _QWORD))a1[556];
  if (v17)
    v17(a1, a2, a1[557]);
}

void sub_10007DF18(uint64_t a1, uint64_t a2)
{
  void *v4;
  const __CFDictionary *Mutable;
  int i;
  uint64_t v7;
  uint64_t v8;
  id v10;
  WiFiUsageMonitor *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *value;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LQMCrashTracerEvent Received %@", "__WiFiDeviceProcessLQMCrashTracerEvent", a2);
  objc_autoreleasePoolPop(v4);
  value = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  for (i = 6; ; --i)
  {
    v7 = Apple80211Get(*(_QWORD *)(a1 + 16), 384, 0, Mutable, 8);
    v8 = v7;
    if ((int)v7 <= 15)
    {
      if ((_DWORD)v7 != -3905)
        break;
    }
    else if ((_DWORD)v7 != 61 && (_DWORD)v7 != 16)
    {
      goto LABEL_21;
    }
    if (!i)
      break;
    usleep(0x7A120u);
  }
  if ((_DWORD)v7)
  {
LABEL_21:
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Apple80211Get(APPLE80211_IOC_LQM_METRICS_CRASHTRACER_DATA) failed: %d (%s)", "__WiFiDeviceProcessLQMCrashTracerEvent", v8, strerror(v8));
  }
  else
  {
    if (CFDictionaryGetValueIfPresent(Mutable, &off_100252CA8, (const void **)&value) && value)
    {
      v10 = +[WAClient sharedClientWithIdentifier:](WAClient, "sharedClientWithIdentifier:", CFSTR("wifid"));
      objc_msgSend(v10, "lqmCrashTracerReceiveBlock:forInterfaceWithName:andReply:", value, *(_QWORD *)(a1 + 112), &stru_10022F818);
      v11 = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
      -[WiFiUsageMonitor receiveKernelLQMRollingWindow:ForInterface:](v11, "receiveKernelLQMRollingWindow:ForInterface:", value, *(_QWORD *)(a1 + 112));
      if (!Mutable)
        return;
      goto LABEL_17;
    }
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - No LQM binary tag represented in APPLE80211_IOC_LQM_METRICS_CRASHTRACER_DATA dictionary, skipping.", "__WiFiDeviceProcessLQMCrashTracerEvent", v13, v14);
  }
  objc_autoreleasePoolPop(v12);
  if (Mutable)
LABEL_17:
    CFRelease(Mutable);
}

void sub_10007E0F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, uint64_t);

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiTTRProcessEvent Received %@", "__WiFiDeviceProcessTTREvent", a3);
  objc_autoreleasePoolPop(v6);
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 5400);
  if (v7)
    v7(a1, a2, *(_QWORD *)(a1 + 5408), a3);
}

void sub_10007E190(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  CFTypeRef v3;
  CFTypeID v6;
  void *v7;
  void (*v8)(uint64_t, uint64_t, CFTypeRef, _QWORD);

  if ((*(_BYTE *)(a1 + 40) & 0x10) != 0)
  {
    v3 = cf;
    if (cf && (v6 = CFGetTypeID(cf), v6 == CFArrayGetTypeID()))
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "[NWTRANSIT]: %s: Colocated networks=%@", "__WiFiDeviceProcessColocatedCacheEvent", v3);
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL evendata", "__WiFiDeviceProcessColocatedCacheEvent");
      v3 = 0;
    }
    objc_autoreleasePoolPop(v7);
    v8 = *(void (**)(uint64_t, uint64_t, CFTypeRef, _QWORD))(a1 + 5528);
    if (v8)
      v8(a1, a2, v3, *(_QWORD *)(a1 + 5536));
  }
}

void sub_10007E28C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(void);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(void))(a1 + 5544);
    if (v3)
      v3();
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s : NULL event data or null device", "__WiFiDeviceProcessPeerCountryCode");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10007E314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  void *v6;

  if (a3)
  {
    v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 5592);
    if (v5)
      v5(a1, a3, a5, a2, a4, *(_QWORD *)(a1 + 5600));
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NULL event data", "__WiFiDeviceProcessNDDEvent");
    objc_autoreleasePoolPop(v6);
  }
}

void sub_10007E3B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(void);
  void *v4;

  if (a3)
  {
    v3 = *(void (**)(void))(a1 + 5608);
    if (v3)
      v3();
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s : NULL event data or null device", "__WiFiDeviceProcessScanForwardStats");
    objc_autoreleasePoolPop(v4);
  }
}

CFStringRef sub_10007E438(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  CFStringEncoding SystemEncoding;
  char cStr;
  __int128 v6;
  __int128 v7;
  _BYTE v8[31];

  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v8[15] = v2;
  *(_OWORD *)v8 = v2;
  v7 = v2;
  v6 = v2;
  cStr = 0;
  if (Apple80211ReturnToString(a1, a2, &cStr, 64))
    return 0;
  SystemEncoding = CFStringGetSystemEncoding();
  return CFStringCreateWithCString(kCFAllocatorDefault, &cStr, SystemEncoding);
}

void sub_10007E4D4(id a1, id a2, NSError *a3)
{
  void *v4;
  uint64_t v5;

  v4 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Error received after alerting wifianalyticsd to the availability of trap mini dump: %@", "__WiFiDeviceProcessDriverAvailableEvent_block_invoke", a3);
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Alerted wifianalyticsd to the availability of trap mini dump, no error was returned", "__WiFiDeviceProcessDriverAvailableEvent_block_invoke", v5);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_10007E550(const __CFDictionary *a1, __CFString *a2)
{
  const void *Value;
  const void *v5;
  const void *v6;

  if (a1)
  {
    if (a2)
    {
      Value = CFDictionaryGetValue(a1, CFSTR("BSSID"));
      v5 = CFDictionaryGetValue(a1, CFSTR("TIMESTAMP"));
      v6 = CFDictionaryGetValue(a1, CFSTR("AGE"));
      CFStringAppendFormat(a2, 0, CFSTR(" %@/%@/%@s"), Value, v5, v6);
    }
  }
}

void sub_10007E5D8(id a1, id a2, NSError *a3)
{
  void *v4;
  uint64_t v5;

  v4 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Error received after sending LQM CrashTracer block to wifianalyticsd: %@", "__WiFiDeviceProcessLQMCrashTracerEvent_block_invoke", a3);
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Successfully sent LQM CrashTracer block to wifianalyticsd", "__WiFiDeviceProcessLQMCrashTracerEvent_block_invoke", v5);
  }
  objc_autoreleasePoolPop(v4);
}

const void *sub_10007E654(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

void sub_10007E694(uint64_t a1, CFStringRef key)
{
  const __CFString *NetworkInterfaceEntity;
  void *v5;
  CFPropertyListRef v6;
  void *v7;
  const char *v8;
  const CFBooleanRef *v9;
  CFBooleanRef v10;
  int i;
  uint64_t v12;
  uint64_t v13;
  void *v15;
  const char *v16;
  void *v17;

  if (a1)
  {
    NetworkInterfaceEntity = key;
    if (key)
      goto LABEL_6;
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), kSCEntNetInterfaceActiveDuringSleepSupported);
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: using default key %@", "__WiFiDeviceCheckForIPRenewalWakeupSupport", NetworkInterfaceEntity);
    objc_autoreleasePoolPop(v5);
    if (NetworkInterfaceEntity)
    {
LABEL_6:
      v6 = SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), NetworkInterfaceEntity);
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v8 = "TRUE";
        if (!v6)
          v8 = "FALSE";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ = %s", "__WiFiDeviceCheckForIPRenewalWakeupSupport", NetworkInterfaceEntity, v8);
      }
      objc_autoreleasePoolPop(v7);
      v9 = &kCFBooleanTrue;
      if (!v6)
        v9 = &kCFBooleanFalse;
      v10 = *v9;
      for (i = 6; ; --i)
      {
        v12 = Apple80211Set(*(_QWORD *)(a1 + 16), 470, 0, v10, 8);
        v13 = v12;
        if ((int)v12 <= 15)
        {
          if ((_DWORD)v12 != -3905)
            break;
        }
        else if ((_DWORD)v12 != 61 && (_DWORD)v12 != 16)
        {
          goto LABEL_23;
        }
        if (!i)
          break;
        usleep(0x7A120u);
      }
      if (!(_DWORD)v12)
        goto LABEL_28;
LABEL_23:
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v16 = "scheduled";
        if (!v6)
          v16 = "un-scheduled";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceCheckForIPRenewalWakeupSupport", v16, v13);
      }
      objc_autoreleasePoolPop(v15);
LABEL_28:
      if (v10)
        CFRelease(v10);
      if (v6)
        CFRelease(v6);
      if (!key)
      {
        if (NetworkInterfaceEntity)
          CFRelease(NetworkInterfaceEntity);
      }
    }
    else
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null serviceKey", "__WiFiDeviceCheckForIPRenewalWakeupSupport");
      objc_autoreleasePoolPop(v17);
    }
  }
}

void sub_10007E8F8(uint64_t a1, CFStringRef key)
{
  const __CFString *NetworkInterfaceEntity;
  void *v5;
  CFPropertyListRef v6;
  void *v7;
  const char *v8;
  void *v9;
  char v10;
  _BYTE *v11;
  void *v12;
  void *v13;

  if (!a1)
    return;
  NetworkInterfaceEntity = key;
  if (key)
    goto LABEL_6;
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), CFSTR("IPConfigurationBusy"));
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: using default key %@", "__WiFiDeviceCheckForIPConfigurationBusy", NetworkInterfaceEntity);
  objc_autoreleasePoolPop(v5);
  if (NetworkInterfaceEntity)
  {
LABEL_6:
    v6 = SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), NetworkInterfaceEntity);
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v8 = "TRUE";
      if (!v6)
        v8 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ = %s", "__WiFiDeviceCheckForIPConfigurationBusy", NetworkInterfaceEntity, v8);
    }
    objc_autoreleasePoolPop(v7);
    if (v6)
    {
      if (*(_DWORD *)(a1 + 4316) == 2)
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: waiting for IP configuration update", "__WiFiDeviceCheckForIPConfigurationBusy");
        objc_autoreleasePoolPop(v9);
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      *(_BYTE *)(a1 + 4344) = v10;
      CFRelease(v6);
      if (key)
        return;
LABEL_24:
      CFRelease(NetworkInterfaceEntity);
      return;
    }
    v11 = (_BYTE *)(a1 + 4344);
    if (!*(_BYTE *)(a1 + 4344))
    {
      *v11 = 0;
      if (key)
        return;
      goto LABEL_24;
    }
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: checking for IP configuration update", "__WiFiDeviceCheckForIPConfigurationBusy");
    objc_autoreleasePoolPop(v12);
    *v11 = 0;
    sub_10006FA40(a1);
    if (!key)
      goto LABEL_24;
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null serviceKey", "__WiFiDeviceCheckForIPConfigurationBusy");
    objc_autoreleasePoolPop(v13);
  }
}

uint64_t sub_10007EB30(const __CFString *a1, int *a2)
{
  CFIndex location;
  int v5;

  if (!a2)
    return 0;
  *a2 = 0;
  location = CFStringFind(a1, kSCEntNetIPv4RouterARPAlive, 0).location;
  v5 = 0;
  if (location != -1)
  {
LABEL_5:
    *a2 = v5;
    return 1;
  }
  if (CFStringFind(a1, kSCEntNetIPv4RouterARPFailure, 0).location != -1)
  {
    v5 = 1;
    goto LABEL_5;
  }
  return 0;
}

void sub_10007EBB4(uint64_t a1, const __CFString *a2)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  const __CFString *v5;
  const void *v6;
  const void *v7;
  CFStringRef NetworkServiceEntity;
  const __CFString *v9;
  const void *v10;
  const void *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const void *Value;
  void *v15;
  NSString *v16;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v18;
  const __CFString *NetworkInterfaceEntity;
  const __CFDictionary *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  const void *v23;
  void *v24;
  CFIndex Count;
  const __CFAllocator *v26;
  unsigned __int8 v27;
  CFIndex v28;
  const __CFString *v29;
  const __CFString *v30;
  void *v31;
  NSString *v32;
  const char *v33;
  CFTypeID TypeID;
  __int128 v35;
  void *v36;
  void *v37;
  CFDataRef v38;
  CFDataRef v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  void *v44;
  __CFDictionary *v45;
  void *v46;
  uint64_t v47;
  const __CFString *v48;
  const void *v49;
  const __CFArray *v50;
  const __CFDictionary *cf;
  const __CFString *v52;
  const __CFDictionary *v53;
  __CFArray *theArray;
  UInt8 bytes[16];
  uint8_t buf[16];
  _BYTE v57[30];

  memset(bytes, 170, sizeof(bytes));
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a2, CFSTR("/"));
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    if (CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2))
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 3);
      if (ValueAtIndex)
      {
        v5 = ValueAtIndex;
        v6 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 4);
        if (v6)
        {
          if (CFEqual(v6, kSCEntNetIPv6))
          {
            v7 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
            if (CFEqual(v7, CFSTR("Service")))
              *(_BYTE *)(a1 + 4300) = 0;
            NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, v5, kSCEntNetInterface);
            if (NetworkServiceEntity)
            {
              v9 = NetworkServiceEntity;
              v10 = sub_10002BF8C(a1, *(const void **)(a1 + 112));
              v11 = v10;
              if (v10 && sub_10000BE8C((uint64_t)v10))
              {
                if (CFEqual(v5, *(CFTypeRef *)(a1 + 112)))
                {
                  v53 = 0;
                  goto LABEL_17;
                }
              }
              else
              {
                v12 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), v9);
                if (v12)
                {
                  v13 = v12;
                  Value = CFDictionaryGetValue(v12, kSCPropNetInterfaceDeviceName);
                  if (!Value || !CFEqual(*(CFTypeRef *)(a1 + 112), Value))
                  {
                    NetworkInterfaceEntity = 0;
                    goto LABEL_71;
                  }
                  v53 = v13;
LABEL_17:
                  v15 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                  {
                    v16 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@+} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IPV6 State change for %@"), *(_QWORD *)(a1 + 112))), "UTF8String"));
                    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v16, "UTF8String")), "UTF8String");
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                    }
                  }
                  objc_autoreleasePoolPop(v15);
                  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  if (Mutable)
                  {
                    v18 = Mutable;
                    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)(a1 + 112), kSCEntNetIPv6);
                    if (NetworkInterfaceEntity)
                    {
                      v20 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 152), NetworkInterfaceEntity);
                      if (v20)
                      {
                        v52 = NetworkInterfaceEntity;
                        cf = v20;
                        v21 = (const __CFArray *)CFDictionaryGetValue(v20, kSCPropNetIPv6Addresses);
                        if (!v21)
                          goto LABEL_81;
                        v22 = v21;
                        v23 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
                        if (CFEqual(v23, CFSTR("Service")) && CFArrayGetCount(v22))
                        {
                          *(_BYTE *)(a1 + 4300) = 1;
                          v24 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s : IPv6 address is routable", "__WiFiDeviceCheckForIPV6ParamsChange");
                          objc_autoreleasePoolPop(v24);
                        }
                        Count = CFArrayGetCount(v22);
                        theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                        if (theArray)
                        {
                          v48 = v9;
                          v49 = v11;
                          v50 = ArrayBySeparatingStrings;
                          v26 = kCFAllocatorDefault;
                          if (Count >= 1)
                          {
                            v27 = 0;
                            v28 = Count + 1;
                            while (1)
                            {
                              v29 = (const __CFString *)CFArrayGetValueAtIndex(v22, v27);
                              if (v29)
                                break;
LABEL_53:
                              ++v27;
                              if (--v28 <= 1)
                                goto LABEL_54;
                            }
                            v30 = v29;
                            v31 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                            {
                              v32 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s"), -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("{%@*} %@"), CFSTR("IP"), +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("IP Address: %@"), v30)), "UTF8String"));
                              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
                              {
                                v26 = kCFAllocatorDefault;
                                v33 = -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[WiFiPolicy] %s"), -[NSString UTF8String](v32, "UTF8String")), "UTF8String");
                                *(_DWORD *)buf = 136446210;
                                *(_QWORD *)&buf[4] = v33;
                                _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
                              }
                            }
                            objc_autoreleasePoolPop(v31);
                            memset(bytes, 0, sizeof(bytes));
                            TypeID = CFStringGetTypeID();
                            if (CFGetTypeID(v30) == TypeID)
                            {
                              *(_QWORD *)&v35 = 0xAAAAAAAAAAAAAAAALL;
                              *((_QWORD *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
                              *(_OWORD *)&v57[14] = v35;
                              *(_OWORD *)buf = v35;
                              *(_OWORD *)v57 = v35;
                              if (CFStringGetCString(v30, (char *)buf, 46, 0x600u))
                              {
                                if (inet_pton(30, (const char *)buf, bytes) == 1)
                                  goto LABEL_46;
                                v36 = objc_autoreleasePoolPush();
                                if (qword_10026DD20)
                                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error converting IPv6 address %@ to network type", "__WiFiDeviceConvertStrToIPv6Addr", v30);
                              }
                              else
                              {
                                v36 = objc_autoreleasePoolPush();
                                if (qword_10026DD20)
                                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Error converting IPv6 address %@ to ASCII", "__WiFiDeviceConvertStrToIPv6Addr", v30);
                              }
                            }
                            else
                            {
                              v36 = objc_autoreleasePoolPush();
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Not a valid CFString", "__WiFiDeviceConvertStrToIPv6Addr", v47);
                            }
                            objc_autoreleasePoolPop(v36);
LABEL_46:
                            if (bytes[0] == 254 && bytes[1] == 128)
                            {
                              kdebug_trace(731381840, 0, 0, 0, 0);
                              v37 = objc_autoreleasePoolPush();
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "IPv6 address is assigned");
                              objc_autoreleasePoolPop(v37);
                            }
                            v38 = CFDataCreate(v26, bytes, 16);
                            if (v38)
                            {
                              v39 = v38;
                              CFArrayAppendValue(theArray, v38);
                              CFRelease(v39);
                            }
                            goto LABEL_53;
                          }
LABEL_54:
                          CFDictionaryAddValue(v18, CFSTR("IO80211InterfaceIPV6Address"), theArray);
                          v40 = 6;
                          v11 = v49;
                          ArrayBySeparatingStrings = v50;
                          v9 = v48;
                          NetworkInterfaceEntity = v52;
                          v13 = v53;
                          while (1)
                          {
                            v41 = Apple80211Set(*(_QWORD *)(a1 + 16), 510, 0, v18, 8);
                            v42 = v41;
                            if ((int)v41 <= 15)
                            {
                              if ((_DWORD)v41 != -3905)
                                break;
                            }
                            else if ((_DWORD)v41 != 61 && (_DWORD)v41 != 16)
                            {
                              goto LABEL_65;
                            }
                            if (!v40)
                              break;
                            usleep(0x7A120u);
                            --v40;
                          }
                          if (!(_DWORD)v41)
                            goto LABEL_68;
LABEL_65:
                          v44 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "__WiFiDeviceCheckForIPV6ParamsChange", "APPLE80211_IOC_IPV6_PARAMS", v42);
                          objc_autoreleasePoolPop(v44);
LABEL_68:
                          -[WiFiUsageMonitor notifyIPv6Changes:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "notifyIPv6Changes:", -[__CFDictionary copy](v18, "copy"));
                          CFRelease(theArray);
                          CFRelease(v18);
                        }
                        else
                        {
LABEL_81:
                          CFRelease(v18);
                          NetworkInterfaceEntity = v52;
                          v13 = v53;
                        }
                        v45 = cf;
LABEL_70:
                        CFRelease(v45);
                        if (!v13)
                          goto LABEL_72;
                        goto LABEL_71;
                      }
                    }
                    else
                    {
                      v46 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: interface_key is NULL.", "__WiFiDeviceCheckForIPV6ParamsChange");
                      objc_autoreleasePoolPop(v46);
                    }
                    v45 = v18;
                    v13 = v53;
                    goto LABEL_70;
                  }
                  NetworkInterfaceEntity = 0;
                  v13 = v53;
                  if (!v53)
                  {
LABEL_72:
                    CFRelease(v9);
                    v9 = NetworkInterfaceEntity;
                    if (!NetworkInterfaceEntity)
                      goto LABEL_74;
                    goto LABEL_73;
                  }
LABEL_71:
                  CFRelease(v13);
                  goto LABEL_72;
                }
              }
LABEL_73:
              CFRelease(v9);
LABEL_74:
              if (!ArrayBySeparatingStrings)
                goto LABEL_76;
              goto LABEL_75;
            }
          }
        }
      }
    }
  }
  v11 = 0;
  if (ArrayBySeparatingStrings)
LABEL_75:
    CFRelease(ArrayBySeparatingStrings);
LABEL_76:
  if (v11)
    CFRelease(v11);
}

void sub_10007F3BC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFData *v4;
  CFTypeID TypeID;
  const UInt8 *BytePtr;
  const __CFString *v7;
  const UInt8 *v8;
  int v9;
  int v10;
  CFStringEncoding SystemEncoding;
  __int128 v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  void *v18;
  uint64_t v19;
  char buffer[16];
  _BYTE v21[33];

  v2 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(v2 + 64))
  {
    CFRelease(*(CFTypeRef *)(a1 + 40));
    v15 = *(_QWORD *)(a1 + 32);
    v14 = a1 + 32;
    v16 = *(const void **)(*(_QWORD *)(v15 + 8) + 24);
    if (!v16)
      return;
    CFRelease(v16);
    v3 = v14;
    goto LABEL_18;
  }
  v3 = a1 + 32;
  v4 = *(const __CFData **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v4)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      BytePtr = CFDataGetBytePtr(v4);
      v7 = *(const __CFString **)(v2 + 112);
      if (v7)
      {
        v8 = BytePtr;
        v9 = socket(2, 2, 0);
        if (v9 == -1)
        {
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation Socket open failed", "__WiFiDeviceSetNetworkIDForAssociation", v19, *(_QWORD *)buffer, *(_QWORD *)&buffer[8]);
        }
        else
        {
          v10 = v9;
          memset(v21, 0, sizeof(v21));
          *(_OWORD *)buffer = 0u;
          SystemEncoding = CFStringGetSystemEncoding();
          CFStringGetCString(v7, buffer, 16, SystemEncoding);
          v21[0] = 32;
          v12 = *((_OWORD *)v8 + 1);
          *(_OWORD *)&v21[1] = *(_OWORD *)v8;
          *(_OWORD *)&v21[17] = v12;
          if (ioctl(v10, 0xC03169D2uLL, buffer) == -1)
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation ioctl(SIOCSIFNETWORKID) failed", "__WiFiDeviceSetNetworkIDForAssociation");
            objc_autoreleasePoolPop(v18);
            close(v10);
            goto LABEL_16;
          }
          close(v10);
          v13 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Successfully set network ID <%@> ", "__WiFiDeviceAssociateLowLevel_block_invoke", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24), *(_QWORD *)buffer, *(_QWORD *)&buffer[8]);
        }
      }
      else
      {
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation IfName is NULL", "__WiFiDeviceSetNetworkIDForAssociation", v19, *(_QWORD *)buffer, *(_QWORD *)&buffer[8]);
      }
      objc_autoreleasePoolPop(v13);
    }
  }
LABEL_16:
  CFRelease(*(CFTypeRef *)(a1 + 40));
  v17 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!v17)
    return;
  CFRelease(v17);
LABEL_18:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v3 + 8) + 24) = 0;
}

void sub_10007F624(uint64_t a1, const void *a2)
{
  const void *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  void *v8;
  _QWORD block[6];
  _QWORD v10[3];
  CFTypeRef v11;

  v4 = sub_10015C354((uint64_t)a2);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Created AWDL interface %@", "__WiFiDeviceAWDLInterfaceCreationCompleted", v4);
  objc_autoreleasePoolPop(v5);
  sub_10015F3FC((uint64_t)a2, v4, 0);
  sub_100054454(a1);
  Apple80211CopyRangingCapabilities(*(_QWORD *)(a1 + 16), a1 + 128);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 5784), v4, a2);
  v6 = *(const void **)(a1 + 5976);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 5976) = 0;
  }
  if (*(_QWORD *)(a1 + 64))
  {
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2020000000;
    v11 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
    v11 = CFRetain(v4);
    CFRetain((CFTypeRef)a1);
    v7 = *(NSObject **)(a1 + 64);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10007F7C8;
    block[3] = &unk_10022F160;
    block[4] = v10;
    block[5] = a1;
    dispatch_async(v7, block);
    _Block_object_dispose(v10, 8);
  }
  else
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null queue.", "__WiFiDeviceAWDLInterfaceCreationCompleted");
    objc_autoreleasePoolPop(v8);
  }
}

void sub_10007F7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007F7C8(uint64_t a1)
{
  _QWORD *v2;
  void (*v3)(_QWORD *, uint64_t, _QWORD, uint64_t);
  uint64_t v4;
  const void *v5;
  const void *v6;

  v2 = *(_QWORD **)(a1 + 40);
  if (v2[8])
  {
    v3 = (void (*)(_QWORD *, uint64_t, _QWORD, uint64_t))v2[637];
    if (v3)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v4)
      {
        v3(v2, v4, v2[638], 1);
        v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  else
  {
    CFRelease(v2);
    v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void sub_10007F8A8(id a1)
{
  if (objc_opt_class(ACAccount))
  {
    if (objc_opt_class(ACAccountType))
      qword_10026D640 = objc_alloc_init(WiFiAccountStoreManager);
  }
}

void sub_10007FBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10007FBB8(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_BYTE *)(*(_QWORD *)(result + 32) + 8);
  return result;
}

void sub_10007FC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007FC90(uint64_t a1)
{
  uint64_t v2;
  int v3;
  void *v4;
  const char *v5;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (*(unsigned __int8 *)(v2 + 8) == v3)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
        v5 = "Managed";
      else
        v5 = "Non-Managed";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No change Current (%s Account)", "-[WiFiAccountStoreManager _updateIsManagedAppleIDAndNotify:]_block_invoke", v5);
    }
    objc_autoreleasePoolPop(v4);
  }
  else
  {
    *(_BYTE *)(v2 + 8) = v3;
    if (*(_BYTE *)(a1 + 48) && objc_msgSend(*(id *)(a1 + 32), "callback"))
    {
      if (objc_msgSend(*(id *)(a1 + 32), "context"))
        ((void (*)(id, _QWORD))objc_msgSend(*(id *)(a1 + 32), "callback"))(objc_msgSend(*(id *)(a1 + 32), "context"), *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    }
  }
}

void sub_10007FDD8(_QWORD *a1)
{
  const __CFURL *v2;
  __CFReadStream *v3;
  __CFReadStream *v4;
  int v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  void *v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  CFTypeID v12;
  const __CFString *Value;
  CFComparisonResult v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  const __CFURL *v19;
  void *v20;
  void *v21;
  const char *v22;
  CFErrorRef v23;
  CFErrorRef error;

  v2 = CFURLCreateWithString(kCFAllocatorDefault, CFSTR("file:///private/var/Managed%20Preferences/mobile/com.apple.MobileWiFi.debug.plist"), 0);
  error = 0;
  qword_10026DD30 = (uint64_t)a1;
  qword_10026DD38 = (uint64_t)CFRunLoopGetCurrent();
  if (v2)
  {
    v3 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v2);
    if (!v3)
    {
      v21 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null fileStreamRef", "WiFiLoggingLoadDebugSettings");
      objc_autoreleasePoolPop(v21);
      v19 = v2;
LABEL_37:
      CFRelease(v19);
      goto LABEL_38;
    }
    v4 = v3;
    v5 = CFReadStreamOpen(v3);
    if (v5)
    {
      v6 = (const __CFDictionary *)CFPropertyListCreateWithStream(kCFAllocatorDefault, v4, 0, 0, 0, &error);
      v7 = v6;
      if (error)
      {
        v8 = objc_autoreleasePoolPush();
        v9 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
        {
LABEL_9:
          objc_autoreleasePoolPop(v8);
LABEL_34:
          CFReadStreamClose(v4);
LABEL_35:
          CFRelease(v4);
          CFRelease(v2);
          if (!v7)
            goto LABEL_38;
          v19 = v7;
          goto LABEL_37;
        }
        v22 = "WiFiLoggingLoadDebugSettings";
        v23 = error;
        v10 = "%s: plist creation returned error %@";
        goto LABEL_7;
      }
      if (v6)
      {
        v12 = CFGetTypeID(v6);
        if (v12 == CFDictionaryGetTypeID())
        {
          if (byte_10026D650 != 1)
          {
            if (CFDictionaryGetCount(v7))
            {
              Value = (const __CFString *)CFDictionaryGetValue(v7, CFSTR("WiFiManagerLoggingEnabled"));
              v14 = CFStringCompare(Value, CFSTR("true"), 0);
              v15 = objc_autoreleasePoolPush();
              if (v14 == kCFCompareEqualTo)
              {
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFi Diagnostic Profile enabled", "WiFiLoggingLoadDebugSettings");
                objc_autoreleasePoolPop(v15);
                byte_10026D650 = 1;
                if (qword_10026DD30)
                {
                  sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("LoggingFileClassC"), kCFBooleanFalse);
                  sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("LoggingFileEnabled"), kCFBooleanTrue);
                  sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("WiFiSettingsLogging"), kCFBooleanTrue);
                  sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("WiFiATJPickerLogging"), kCFBooleanTrue);
                  sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("DiagnosticsEnabled"), kCFBooleanTrue);
                  goto LABEL_34;
                }
                v8 = objc_autoreleasePoolPush();
                v9 = (void *)qword_10026DD20;
                if (!qword_10026DD20)
                  goto LABEL_9;
                v22 = "__WiFiLoggingTurnOnWiFiLogging";
                v10 = "%s: wifimanager is NULL";
LABEL_7:
                v11 = 4;
LABEL_8:
                objc_msgSend(v9, "WFLog:message:", v11, v10, v22, v23);
                goto LABEL_9;
              }
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: WiFi Diagnostic Profile disabled", "WiFiLoggingLoadDebugSettings");
              objc_autoreleasePoolPop(v15);
              byte_10026D650 = 0;
            }
            else
            {
              v18 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: plist does not even have a single entry in Dictionary", "WiFiLoggingLoadDebugSettings");
              objc_autoreleasePoolPop(v18);
              byte_10026D650 = 0;
              sub_100093FA0(a1, CFSTR("DiagnosticsEnabled"), kCFBooleanFalse);
            }
            sub_100080254();
            goto LABEL_34;
          }
          v8 = objc_autoreleasePoolPush();
          v9 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_9;
          v10 = "wifi debug profile is already installed";
        }
        else
        {
          v8 = objc_autoreleasePoolPush();
          v9 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_9;
          v22 = "WiFiLoggingLoadDebugSettings";
          v10 = "%s: unknown property format";
        }
        v11 = 3;
        goto LABEL_8;
      }
    }
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi debug profile is not installed");
    objc_autoreleasePoolPop(v16);
    if (byte_10026D650 == 1)
    {
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Uninstalling logging profile");
      objc_autoreleasePoolPop(v17);
      byte_10026D650 = 0;
      sub_100093FA0(a1, CFSTR("DiagnosticsEnabled"), kCFBooleanFalse);
      sub_100080254();
    }
    v7 = 0;
    if (!v5)
      goto LABEL_35;
    goto LABEL_34;
  }
  v20 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null url", "WiFiLoggingLoadDebugSettings");
  objc_autoreleasePoolPop(v20);
LABEL_38:
  if (error)
    CFRelease(error);
}

void sub_100080254()
{
  CFBooleanRef v0;
  CFBooleanRef v1;
  void *v2;

  if (qword_10026DD30)
  {
    if (byte_10026DD19)
      v0 = kCFBooleanTrue;
    else
      v0 = kCFBooleanFalse;
    sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("LoggingFileClassC"), v0);
    if (byte_10026DD18)
      v1 = kCFBooleanTrue;
    else
      v1 = kCFBooleanFalse;
    sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("LoggingFileEnabled"), v1);
    sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("WiFiSettingsLogging"), kCFBooleanFalse);
    sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("WiFiATJPickerLogging"), kCFBooleanFalse);
    sub_100093FA0((_QWORD *)qword_10026DD30, CFSTR("DiagnosticsEnabled"), kCFBooleanFalse);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wifimanager is NULL", "__WiFiLoggingTurnOffWiFiLogging");
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t sub_10008036C()
{
  return byte_10026D650;
}

id sub_100080378()
{
  NSFileManager *v0;
  NSEnumerator *v1;
  id result;
  id v3;
  uint64_t v4;
  void *v5;
  void *v6;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _BYTE v13[128];

  v0 = +[NSFileManager defaultManager](NSFileManager, "defaultManager");
  v12 = 0;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v1 = -[NSArray objectEnumerator](-[NSFileManager contentsOfDirectoryAtPath:error:](v0, "contentsOfDirectoryAtPath:error:", CFSTR("/var/mobile/Library/Logs/CrashReporter/WiFi/WiFiManager"), &v12), "objectEnumerator");
  result = -[NSEnumerator countByEnumeratingWithState:objects:count:](v1, "countByEnumeratingWithState:objects:count:", &v8, v13, 16);
  if (result)
  {
    v3 = result;
    v4 = *(_QWORD *)v9;
    do
    {
      v5 = 0;
      do
      {
        if (*(_QWORD *)v9 != v4)
          objc_enumerationMutation(v1);
        v6 = *(void **)(*((_QWORD *)&v8 + 1) + 8 * (_QWORD)v5);
        if (objc_msgSend(v6, "hasPrefix:", CFSTR("wifi-buf-"))
          && objc_msgSend(v6, "hasSuffix:", CFSTR(".log")))
        {
          if (-[NSFileManager removeItemAtPath:error:](v0, "removeItemAtPath:error:", objc_msgSend(CFSTR("/var/mobile/Library/Logs/CrashReporter/WiFi/WiFiManager"), "stringByAppendingPathComponent:", v6), &v12))
          {
            v7 = v12 == 0;
          }
          else
          {
            v7 = 0;
          }
          if (!v7)
            NSLog(CFSTR("Error removing %@: %@"), v6, v12);
        }
        v5 = (char *)v5 + 1;
      }
      while (v3 != v5);
      result = -[NSEnumerator countByEnumeratingWithState:objects:count:](v1, "countByEnumeratingWithState:objects:count:", &v8, v13, 16);
      v3 = result;
    }
    while (result);
  }
  return result;
}

void sub_100080500(uint64_t a1, int a2, uint64_t a3, const __CFString **a4)
{
  void *v8;
  const __CFString *v9;
  uint64_t v10;
  unsigned int IntValue;
  const __CFString *v12;
  uint64_t v13;
  SInt32 v14;
  int v15;
  const __CFString *v16;
  uint64_t v17;
  SInt32 v18;
  int v19;
  const __CFString *v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  const __CFString *v24;

  v8 = objc_autoreleasePoolPush();
  qword_10026DD30 = a1;
  qword_10026DD38 = (uint64_t)CFRunLoopGetCurrent();
  if (!qword_10026DD20)
    qword_10026DD20 = sub_1000A42AC(qword_10026DD30);
  byte_10026DD28 = a2;
  v9 = a4[1];
  v10 = 5;
  if (v9)
  {
    IntValue = CFStringGetIntValue(v9);
    if (IntValue >= 5)
      v10 = 5;
    else
      v10 = IntValue;
  }
  v12 = a4[2];
  v13 = 3;
  if (v12)
  {
    v14 = CFStringGetIntValue(v12);
    if ((v14 - 6) >= 0xFFFFFFFB)
      v15 = v14;
    else
      v15 = 3;
    v13 = v15;
  }
  v16 = a4[4];
  v17 = 2;
  if (v16)
  {
    v18 = CFStringGetIntValue(v16);
    if ((v18 - 3) >= 0xFFFFFFFE)
      v19 = v18;
    else
      v19 = 2;
    v17 = v19;
  }
  v20 = a4[3];
  v21 = 7;
  if (v20)
  {
    v22 = CFStringGetIntValue(v20);
    if (v22 <= 0x1E)
      v23 = v22;
    else
      v23 = 7;
    v21 = v23;
  }
  if (a2)
  {
    if (byte_10026D650 == 1)
    {
      objc_msgSend((id)qword_10026DD20, "setDestinationFileLocation:fileNamePrefix:runLoopRef:runLoopMode:classC:dateFormatter:maxFileSizeInMB:logLifespanInDays:", CFSTR("/var/mobile/Library/Logs/CrashReporter/WiFi"), CFSTR("wifimanager"), qword_10026DD38, kCFRunLoopDefaultMode, a3, qword_10026DD58, v10, v21);
    }
    else
    {
      if (*a4)
        v24 = *a4;
      else
        v24 = CFSTR("/Library/Logs/wifimanager.log");
      objc_msgSend((id)qword_10026DD20, "setDestinationFile:runLoopRef:runLoopMode:classC:dateFormatter:maxFileSizeInMB:logLifespanInDays:", v24, qword_10026DD38, kCFRunLoopDefaultMode, a3, qword_10026DD58, v10, v21);
    }
  }
  else
  {
    objc_msgSend((id)qword_10026DD20, "setDestinationOsLog:category:logLifespanInDays:logLevel:logPrivacy:", CFSTR("com.apple.WiFiManager"), &stru_100238178, v21, v13, v17);
  }
  objc_autoreleasePoolPop(v8);
}

id sub_1000827EC(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void sub_100082938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_10008295C(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 v5;
  id obj;

  v2 = *(void **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  obj = *(id *)(v4 + 40);
  v5 = objc_msgSend(v2, "_runFindAndJoinOnInterface:outError:", v3, &obj);
  objc_storeStrong((id *)(v4 + 40), obj);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v5;
  if (*(_QWORD *)(a1 + 64))
    **(_QWORD **)(a1 + 64) = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "copy");
}

void sub_100082AF8(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  unsigned __int8 v4;
  id v5;
  void *v6;
  NSObject *v7;
  _QWORD v8[4];
  id v9;
  id v10;
  unsigned __int8 v11;
  id v12;

  v2 = (void *)a1[4];
  v3 = a1[5];
  v12 = 0;
  v4 = objc_msgSend(v2, "_runFindAndJoinOnInterface:outError:", v3, &v12);
  v5 = v12;
  v6 = (void *)a1[7];
  if (v6)
  {
    v7 = a1[6];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100082BB4;
    v8[3] = &unk_100230620;
    v10 = v6;
    v11 = v4;
    v9 = v5;
    dispatch_sync(v7, v8);

  }
}

uint64_t sub_100082BB4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(_QWORD *)(a1 + 32));
}

void sub_100082DB0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_100082DC0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

BOOL sub_100083038()
{
  const __CFString *v0;
  const __CFString *v1;
  CFTypeID v2;
  _BOOL8 v3;

  v0 = (const __CFString *)MGCopyAnswer(CFSTR("ReleaseType"), 0);
  if (!v0)
    return 0;
  v1 = v0;
  v2 = CFGetTypeID(v0);
  v3 = v2 == CFStringGetTypeID() && CFStringCompare(v1, CFSTR("NonUI"), 0) == kCFCompareEqualTo;
  CFRelease(v1);
  return v3;
}

uint64_t sub_1000830B4()
{
  uint64_t result;

  result = qword_10026D658;
  if (!qword_10026D658)
  {
    pthread_once(&stru_10026C9C0, (void (*)(void))sub_1000830F0);
    return qword_10026D658;
  }
  return result;
}

__CFArray *sub_1000830F0()
{
  __CFArray *result;
  __int128 v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  qword_10026D658 = _CFRuntimeRegisterClass(&unk_100230910);
  IOMasterPort(0, (mach_port_t *)&dword_10026D688);
  v9 = xmmword_1001BB8C8;
  v10 = unk_1001BB8D8;
  v11 = xmmword_1001BB8E8;
  v5 = xmmword_1001BB888;
  v6 = unk_1001BB898;
  v7 = xmmword_1001BB8A8;
  v8 = unk_1001BB8B8;
  v1 = xmmword_1001BB848;
  v2 = unk_1001BB858;
  v3 = xmmword_1001BB868;
  v4 = unk_1001BB878;
  qword_10026D660 = (uint64_t)sub_1000ADC18((char *)&v1, 22);
  v3 = xmmword_1001BB918;
  v4 = unk_1001BB928;
  v5 = xmmword_1001BB938;
  v6 = unk_1001BB948;
  v1 = xmmword_1001BB8F8;
  v2 = unk_1001BB908;
  qword_10026D668 = (uint64_t)sub_1000ADC18((char *)&v1, 12);
  *(_QWORD *)&v4 = 0;
  v1 = xmmword_1001BB590;
  v2 = xmmword_1001BB5A0;
  v3 = xmmword_1001BB5B0;
  qword_10026D670 = (uint64_t)sub_1000ADC18((char *)&v1, 7);
  *(_QWORD *)&v4 = 0;
  v1 = xmmword_1001BB590;
  v2 = xmmword_1001BB5A0;
  v3 = xmmword_1001BB5B0;
  result = sub_1000ADC18((char *)&v1, 7);
  qword_10026D678 = (uint64_t)result;
  return result;
}

uint64_t sub_10008324C(uint64_t a1, NSObject *a2)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t Instance;
  uint64_t v8;
  id v9;
  CFMutableSetRef Mutable;
  CFMutableSetRef v11;
  CFMutableSetRef v12;
  CFMutableSetRef v13;
  CFMutableSetRef v14;
  CFMutableSetRef v15;
  CFMutableSetRef v16;
  CFMutableSetRef v17;
  CFMutableArrayRef v18;
  CFMutableSetRef v19;
  CFArrayRef ArrayBySeparatingStrings;
  uint64_t v21;
  void *v22;
  WiFiCloudAssetsClient *v23;
  int v24;
  uint64_t v25;
  id v26;
  void *v27;
  SCPreferencesRef v28;
  const __SCPreferences *v29;
  __CFDictionary *v30;
  __CFDictionary *v31;
  uint64_t v32;
  uint64_t v33;
  const __SCPreferences *v34;
  id v35;
  id v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *global_queue;
  char v40;
  void *v41;
  const char *v42;
  void *v43;
  const char *v44;
  void *v45;
  const char *v46;
  uint64_t v47;
  const __CFData *v48;
  const __CFData *v49;
  CFDataRef Copy;
  __int128 v51;
  void *v52;
  void *v53;
  const __CFData *v54;
  const __CFData *v55;
  CFDataRef v56;
  __int128 v57;
  void *v58;
  __CFString *v59;
  void *v60;
  CFAbsoluteTime Current;
  CFDateRef v62;
  void *v63;
  const void *v64;
  const UInt8 *BytePtr;
  __int16 v66;
  void *v67;
  const void **v68;
  void *v69;
  NSObject *v70;
  NSObject *v71;
  dispatch_time_t v72;
  NSObject *v73;
  uint64_t v74;
  NSObject *v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  dispatch_time_t v79;
  ManagedConfigWrapper *v80;
  NSObject *v81;
  NSObject *v82;
  dispatch_time_t v83;
  NSObject *v84;
  NSObject *v85;
  NSObject *v86;
  _BOOL4 v87;
  int v88;
  int v89;
  void *v90;
  CFMutableDictionaryRef v91;
  void *v93;
  _QWORD v94[5];
  _QWORD v95[6];
  SCPreferencesContext v96;
  SCPreferencesContext context;
  _QWORD block[5];
  __int128 bytes;
  __int128 v100;

  v4 = objc_autoreleasePoolPush();
  v5 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerCreate");
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiManagerCreate");
  objc_autoreleasePoolPop(v6);
  NSLog(CFSTR("%s: entering"), "WiFiManagerCreate");
  if (!qword_10026D658)
    pthread_once(&stru_10026C9C0, (void (*)(void))sub_1000830F0);
  Instance = _CFRuntimeCreateInstance(a1);
  if (!Instance)
    goto LABEL_81;
  v8 = Instance;
  bzero((void *)(Instance + 16), 0x9F0uLL);
  *(_DWORD *)(v8 + 316) = 1;
  *(_QWORD *)(v8 + 792) = 0;
  *(_QWORD *)(v8 + 1216) = 0;
  *(_QWORD *)(v8 + 1992) = MGCopyAnswer(CFSTR("BuildVersion"), 0);
  v9 = objc_alloc_init((Class)WFLogger);
  *(_QWORD *)(v8 + 2048) = v9;
  objc_msgSend(v9, "setDestinationOsLog:category:logLifespanInDays:logLevel:logPrivacy:", CFSTR("com.apple.WiFiManager"), &stru_100238178, 7, 3, 2);
  *(_QWORD *)(v8 + 2056) = 0;
  if (&_ct_green_tea_logger_create && !byte_10026DD60)
    *(_QWORD *)(v8 + 2056) = ct_green_tea_logger_create("com.apple.wifi.manager");
  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 96) = Mutable;
  if (!Mutable)
    goto LABEL_80;
  v11 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 104) = v11;
  if (!v11)
    goto LABEL_80;
  *(_DWORD *)(v8 + 112) = MGGetSInt32Answer(CFSTR("DeviceClassNumber"), 0);
  *(_BYTE *)(v8 + 129) = MGGetBoolAnswer(CFSTR("wapi"));
  *(_QWORD *)(v8 + 120) = MGGetProductType();
  *(_BYTE *)(v8 + 128) = MGGetBoolAnswer(CFSTR("cellular-data"));
  v12 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 136) = v12;
  if (!v12)
    goto LABEL_80;
  v13 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 144) = v13;
  if (!v13)
    goto LABEL_80;
  v14 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 152) = v14;
  if (!v14)
    goto LABEL_80;
  v15 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 160) = v15;
  if (!v15)
    goto LABEL_80;
  v16 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 1168) = v16;
  if (!v16)
    goto LABEL_80;
  v17 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 1192) = v17;
  if (!v17)
    goto LABEL_80;
  v18 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(v8 + 1976) = v18;
  if (!v18)
    goto LABEL_80;
  v19 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  *(_QWORD *)(v8 + 168) = v19;
  if (!v19)
    goto LABEL_80;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, CFSTR("Preferences SpringBoard Carousel WiFiPickerExtens Setup budd sharingd demod BundledIntentHandler SiriViewService assistantd assistant_service Siri SettingsIntentExtension NanoSettings PineBoard TVSettings SoundBoard RealityControlCenter MuseBuddyApp mobilewifitool WirelessStress coreautomationd wifiutil NanoWiFiViewService ATKWiFiFramework WiFiViewService hQT XCTestInternalAngel HPSetup AirPlaySenderUIApp TVSetup deviceaccessd AccessorySetupUI"), CFSTR(" "));
  *(_QWORD *)(v8 + 176) = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
    goto LABEL_80;
  *(_QWORD *)(v8 + 1696) = +[WiFiLocationManager sharedWiFiLocationManager](WiFiLocationManager, "sharedWiFiLocationManager");
  *(_QWORD *)(v8 + 192) = -[WiFiLocaleManagerUser initWithContext:]([WiFiLocaleManagerUser alloc], "initWithContext:", v8);
  *(_BYTE *)(v8 + 2012) = 0;
  v21 = sub_100050E94((uint64_t)kCFAllocatorDefault, v8);
  *(_QWORD *)(v8 + 200) = v21;
  if (!v21)
  {
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Disabling WiFiMetricsManager", "WiFiManagerCreate");
    objc_autoreleasePoolPop(v22);
  }
  *(_OWORD *)(v8 + 2032) = 0u;
  v23 = +[WiFiCloudAssetsClient sharedInstance](WiFiCloudAssetsClient, "sharedInstance");
  *(_QWORD *)(v8 + 1624) = v23;
  -[WiFiCloudAssetsClient initializeWithManager:queue:](v23, "initializeWithManager:queue:", v8, a2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100084880;
  block[3] = &unk_10022EA38;
  block[4] = v8;
  dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  if (&_WiFiCloudSyncEngineCreate)
  {
    v24 = *(_DWORD *)(v8 + 112);
    if (v24 != 4 && v24 != 7)
    {
      v25 = WiFiCloudSyncEngineCreate(kCFAllocatorDefault);
      *(_QWORD *)(v8 + 1304) = v25;
      sub_10005032C(v8, v25, qword_10026DD48);
    }
  }
  +[WiFiPerfPerAssoc initWithWiFiManager:queue:](WiFiPerfPerAssoc, "initWithWiFiManager:queue:", v8, a2);
  if (!byte_10026DD60)
  {
    v26 = +[WiFiMaintenanceTaskManager sharedWiFiMaintenanceTaskManager](WiFiMaintenanceTaskManager, "sharedWiFiMaintenanceTaskManager");
    *(_QWORD *)(v8 + 2000) = v26;
    if (v26)
    {
      objc_msgSend(v26, "setWifiManager:", v8);
    }
    else
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create maintenance task manager", "WiFiManagerCreate");
      objc_autoreleasePoolPop(v27);
    }
  }
  v28 = SCPreferencesCreate(kCFAllocatorDefault, CFSTR("com.apple.wifi.manager"), 0);
  *(_QWORD *)(v8 + 1064) = v28;
  if (!v28)
  {
    v93 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesCreate preferences.system failed", "WiFiManagerCreate");
    goto LABEL_140;
  }
  v29 = SCPreferencesCreate(kCFAllocatorDefault, CFSTR("com.apple.wifi.manager"), CFSTR("com.apple.wifi.plist"));
  *(_QWORD *)(v8 + 1072) = v29;
  if (!v29)
  {
    v93 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesCreate preferences.wifi failed", "WiFiManagerCreate");
    goto LABEL_140;
  }
  context.version = 0;
  memset(&context.retain, 0, 24);
  context.info = (void *)v8;
  if (!SCPreferencesSetCallback(v29, (SCPreferencesCallBack)sub_10008488C, &context))
  {
    v93 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesSetCallback preferences.wifi failed", "WiFiManagerCreate");
LABEL_140:
    objc_autoreleasePoolPop(v93);
    goto LABEL_80;
  }
  v30 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v30)
  {
    v31 = v30;
    CFDictionarySetValue(v30, CFSTR("ProtectionClass"), CFSTR("C"));
    v32 = SCPreferencesCreateWithOptions(kCFAllocatorDefault, CFSTR("com.apple.wifi.manager"), CFSTR("com.apple.wifi-networks.plist"), 0, v31);
    *(_QWORD *)(v8 + 1080) = v32;
    if (!v32)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesCreateWithOptions preferences.wifiNetworks failed", "WiFiManagerCreate");
      goto LABEL_78;
    }
    v33 = SCPreferencesCreateWithOptions(kCFAllocatorDefault, CFSTR("com.apple.wifi.manager"), CFSTR("com.apple.wifi-private-mac-networks.plist"), 0, v31);
    *(_QWORD *)(v8 + 1096) = v33;
    if (!v33)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesCreateWithOptions preferences.wifiPrivateMacNetworks failed", "WiFiManagerCreate");
      goto LABEL_78;
    }
    v34 = SCPreferencesCreate(kCFAllocatorDefault, CFSTR("com.apple.wifi.manager"), CFSTR("com.apple.radios.plist"));
    *(_QWORD *)(v8 + 1088) = v34;
    if (!v34)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesCreate preferences.radios failed", "WiFiManagerCreate");
      goto LABEL_78;
    }
    v96.version = 0;
    memset(&v96.retain, 0, 24);
    v96.info = (void *)v8;
    if (!SCPreferencesSetCallback(v34, (SCPreferencesCallBack)sub_1000858CC, &v96))
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesSetCallback preferences.radios failed", "WiFiManagerCreate");
      goto LABEL_78;
    }
    v35 = objc_alloc((Class)CWFKeyValueStore);
    v36 = objc_msgSend(v35, "initWithType:identifier:", 4, CWFKnownNetworksStoreIdentifier);
    *(_QWORD *)(v8 + 1104) = v36;
    if (!v36)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: CWFKeyValueStore alloc failed", "WiFiManagerCreate");
      goto LABEL_78;
    }
    *(_QWORD *)(v8 + 1120) = objc_msgSend((id)CWFBootArgs(), "copy");
    v37 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
    *(_QWORD *)(v8 + 1360) = v37;
    if (!v37)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create networkExpiry.timer", "WiFiManagerCreate");
      goto LABEL_78;
    }
    dispatch_set_context(v37, (void *)v8);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1360), (dispatch_function_t)sub_100085F68);
    *(_QWORD *)(v8 + 1368) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v38 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
    *(_QWORD *)(v8 + 2352) = v38;
    if (!v38)
    {
      v52 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create carPlayLinkDownSuppressionMetrics.timer", "WiFiManagerCreate");
      goto LABEL_78;
    }
    dispatch_set_context(v38, (void *)v8);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 2352), (dispatch_function_t)sub_100086378);
    global_queue = dispatch_get_global_queue(0, 0);
    v95[0] = _NSConcreteStackBlock;
    v95[1] = 3221225472;
    v95[2] = sub_1000863DC;
    v95[3] = &unk_1002306C8;
    v95[4] = a2;
    v95[5] = v8;
    dispatch_async(global_queue, v95);
    *(_DWORD *)(v8 + 824) = 0;
    if (byte_10026DD60)
      v40 = 1;
    else
      v40 = MKBUserUnlockedSinceBoot(0);
    *(_BYTE *)(v8 + 1328) = v40;
    v41 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (byte_10026DD60)
        v42 = "Running";
      else
        v42 = "Not running";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: %s in darwinOS mode", "WiFiManagerCreate", v42);
    }
    objc_autoreleasePoolPop(v41);
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (byte_10026DD61)
        v44 = "Running";
      else
        v44 = "Not running";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: %s in Lockdown mode", "WiFiManagerCreate", v44);
    }
    objc_autoreleasePoolPop(v43);
    v45 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (byte_10026DD62)
        v46 = "Running";
      else
        v46 = "Not running";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: %s in store demo mode", "WiFiManagerCreate", v46);
    }
    objc_autoreleasePoolPop(v45);
    sub_10008488C(v47, 2, v8);
    sub_10008674C(v8);
    sub_100086B84(v8, *(const __CFArray **)(v8 + 224));
    sub_10001D90C((_QWORD *)v8, CFSTR("deviceSoftwareVer"));
    sub_100087390(v8);
    *(_BYTE *)(v8 + 361) = 1;
    *(_BYTE *)(v8 + 529) = 1;
    *(_BYTE *)(v8 + 362) = sub_10003036C((_QWORD *)v8, CFSTR("PrivateMacForcedDisassocPending"), 0);
    v48 = sub_10001D90C((_QWORD *)v8, CFSTR("deviceSpecificKeyMacRandomisation"));
    if (v48 && (v49 = v48, CFDataGetLength(v48)))
    {
      Copy = CFDataCreateCopy(kCFAllocatorDefault, v49);
      *(_QWORD *)(v8 + 416) = Copy;
    }
    else
    {
      *(_QWORD *)&v51 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v51 + 1) = 0xAAAAAAAAAAAAAAAALL;
      bytes = v51;
      v100 = v51;
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, &bytes))
      {
        v52 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Failed to generate device Specific Key for mac randomisation", "WiFiManagerCreate");
        goto LABEL_78;
      }
      Copy = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)&bytes, 32);
      *(_QWORD *)(v8 + 416) = Copy;
    }
    sub_100087488((_QWORD *)v8, CFSTR("deviceSpecificKeyMacRandomisation"), Copy, 0);
    v53 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : INIT : device specific key used : %@", "WiFiManagerCreate", *(_QWORD *)(v8 + 416));
    objc_autoreleasePoolPop(v53);
    v54 = sub_10001D90C((_QWORD *)v8, CFSTR("RotationKeyMacRandomisation"));
    if (v54 && (v55 = v54, CFDataGetLength(v54)))
    {
      v56 = CFDataCreateCopy(kCFAllocatorDefault, v55);
    }
    else
    {
      *(_QWORD *)&v57 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
      bytes = v57;
      v100 = v57;
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, &bytes))
      {
        v52 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Failed to generate rotation Key for mac randomisation", "WiFiManagerCreate");
        goto LABEL_78;
      }
      v56 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)&bytes, 32);
    }
    *(_QWORD *)(v8 + 408) = v56;
    sub_100087488((_QWORD *)v8, CFSTR("RotationKeyMacRandomisation"), v56, 0);
    v60 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : INIT : rotation key used : %@", "WiFiManagerCreate", *(_QWORD *)(v8 + 408));
    objc_autoreleasePoolPop(v60);
    if (!sub_10001D90C((_QWORD *)v8, CFSTR("RotationKeyDateMacRandomisation")))
    {
      Current = CFAbsoluteTimeGetCurrent();
      v62 = CFDateCreate(kCFAllocatorDefault, Current);
      sub_100087488((_QWORD *)v8, CFSTR("RotationKeyDateMacRandomisation"), v62, 0);
      if (v62)
        CFRelease(v62);
    }
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : INIT : rotation key date : %@", "WiFiManagerCreate", sub_10001D90C((_QWORD *)v8, CFSTR("RotationKeyDateMacRandomisation")));
    objc_autoreleasePoolPop(v63);
    v64 = (const void *)MGCopyAnswer(CFSTR("WifiAddressData"), 0);
    *(_QWORD *)(v8 + 488) = v64;
    if (v64)
    {
      sub_100087488((_QWORD *)v8, CFSTR("hwMacAddressMacRandomisation"), v64, 1);
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v8 + 488));
      v66 = *((_WORD *)BytePtr + 2);
      *(_DWORD *)(v8 + 480) = *(_DWORD *)BytePtr;
      *(_WORD *)(v8 + 484) = v66;
      v67 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : INIT : device mac HW address read: %s", ether_ntoa((const ether_addr *)(v8 + 480)));
      objc_autoreleasePoolPop(v67);
    }
    sub_1000875B0(v8);
    sub_100087FE4(v8);
    *(_BYTE *)(v8 + 528) = 0;
    if (byte_10026DD62)
    {
      *(_BYTE *)(v8 + 376) = 0;
    }
    else if (*(_BYTE *)(v8 + 376))
    {
      v68 = (const void **)&kCFBooleanTrue;
LABEL_101:
      sub_100087488((_QWORD *)v8, CFSTR("WiFiMacRandomizationInternalUI"), *v68, 1);
      v69 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : INIT : Initializing Private mac with feature enable [%d]\n", "WiFiManagerCreate", *(unsigned __int8 *)(v8 + 376));
      objc_autoreleasePoolPop(v69);
      *(_BYTE *)(v8 + 377) = sub_10003036C((_QWORD *)v8, CFSTR("enableForceCarPlayMACRandomization"), 0);
      v70 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
      *(_QWORD *)(v8 + 496) = v70;
      if (v70)
      {
        dispatch_set_context(v70, (void *)v8);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 496), (dispatch_function_t)sub_10008802C);
        v71 = *(NSObject **)(v8 + 496);
        v72 = dispatch_time(0, 1800000000000);
        dispatch_source_set_timer(v71, v72, 0x1A3185C5000uLL, 0);
        v73 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
        *(_QWORD *)(v8 + 432) = v73;
        if (v73)
        {
          dispatch_set_context(v73, (void *)v8);
          dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 432), (dispatch_function_t)sub_100088F84);
          sub_1000DA8AC((uint64_t)kCFAllocatorDefault, (uint64_t)"com.apple.wifi.manager", v8);
          *(_QWORD *)(v8 + 80) = v74;
          if (v74)
          {
            *(_QWORD *)(v8 + 1128) = qword_10026D660;
            *(_QWORD *)(v8 + 1136) = qword_10026D668;
            *(_QWORD *)(v8 + 1144) = qword_10026D670;
            *(_QWORD *)(v8 + 1152) = qword_10026D678;
            if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
              sub_100014478(v8);
            sub_1000069C0(v8, *(const void **)(v8 + 1136), 1);
            v75 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
            *(_QWORD *)(v8 + 920) = v75;
            if (v75)
            {
              dispatch_set_context(v75, (void *)v8);
              dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 920), (dispatch_function_t)sub_100089178);
              *(_QWORD *)(v8 + 1888) = 0;
              v76 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
              *(_QWORD *)(v8 + 1872) = v76;
              if (v76)
              {
                dispatch_set_context(v76, (void *)v8);
                dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1872), (dispatch_function_t)sub_1000892BC);
                *(_QWORD *)(v8 + 864) = MKBGetDeviceLockState(0) == 1;
                v77 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
                *(_QWORD *)(v8 + 1336) = v77;
                if (v77)
                {
                  dispatch_set_context(v77, (void *)v8);
                  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1336), (dispatch_function_t)sub_10008937C);
                  v78 = *(NSObject **)(v8 + 1336);
                  v79 = dispatch_time(0, 60000000000);
                  dispatch_source_set_timer(v78, v79, 0xFFFFFFFFFFFFFFFFLL, 0);
                  if (!sub_100083038() && *(_DWORD *)(v8 + 112) != 7)
                    *(_QWORD *)(v8 + 1432) = sub_100176A7C(v8, (uint64_t)a2);
                  *(_BYTE *)(v8 + 1440) = 0;
                  *(_QWORD *)(v8 + 1400) = 0;
                  *(_BYTE *)(v8 + 1329) = 0;
                  *(_QWORD *)(v8 + 1448) = sub_100166F4C((uint64_t)kCFAllocatorDefault);
                  *(_QWORD *)(v8 + 1456) = -1;
                  *(_DWORD *)(v8 + 1468) = -1;
                  *(_QWORD *)(v8 + 1472) = -1;
                  v80 = +[ManagedConfigWrapper sharedInstance](ManagedConfigWrapper, "sharedInstance");
                  *(_QWORD *)(v8 + 1480) = v80;
                  -[ManagedConfigWrapper initializeWithHandler:](v80, "initializeWithHandler:", v8);
                  v81 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
                  *(_QWORD *)(v8 + 1488) = v81;
                  if (v81)
                  {
                    dispatch_set_context(v81, (void *)v8);
                    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1488), (dispatch_function_t)sub_1000102D0);
                    v82 = *(NSObject **)(v8 + 1488);
                    v83 = dispatch_time(0, 5000000000);
                    dispatch_source_set_timer(v82, v83, 0x12A05F200uLL, 0);
                    v84 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
                    *(_QWORD *)(v8 + 1536) = v84;
                    if (v84)
                    {
                      dispatch_set_context(v84, (void *)v8);
                      dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1536), (dispatch_function_t)sub_100089454);
                      v85 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
                      *(_QWORD *)(v8 + 1576) = v85;
                      if (v85)
                      {
                        dispatch_set_context(v85, (void *)v8);
                        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1576), (dispatch_function_t)sub_1000894DC);
                        *(_BYTE *)(v8 + 1672) = 0;
                        v86 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a2);
                        *(_QWORD *)(v8 + 1680) = v86;
                        if (v86)
                        {
                          dispatch_set_context(v86, (void *)v8);
                          dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v8 + 1680), (dispatch_function_t)sub_100089750);
                          *(_DWORD *)(v8 + 1552) = 100;
                          *(_QWORD *)(v8 + 1688) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                          qword_10026D680 = v8;
                          v87 = sub_10005B8AC();
                          v88 = sub_10000AF8C(v8);
                          if (!v87 || v88)
                          {
                            if (!v88)
                              sub_10008A2B8(v8, "WiFiManagerCreate", 3998);
                          }
                          else
                          {
                            v89 = *(unsigned __int8 *)(v8 + 1328);
                            v90 = objc_autoreleasePoolPush();
                            if (v89)
                            {
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s reseting user auto join due to restart", "WiFiManagerCreate");
                              objc_autoreleasePoolPop(v90);
                              sub_1000898A0(v8, 1, 3, 0);
                            }
                            else
                            {
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s user auto join needs reset", "WiFiManagerCreate");
                              objc_autoreleasePoolPop(v90);
                              *(_BYTE *)(v8 + 2254) = 1;
                            }
                          }
                          *(_WORD *)(v8 + 2088) = 257;
                          *(CFAbsoluteTime *)(v8 + 2096) = CFAbsoluteTimeGetCurrent();
                          *(_BYTE *)(v8 + 2104) = 0;
                          *(_BYTE *)(v8 + 2105) = *(_DWORD *)(v8 + 112) == 7;
                          *(_WORD *)(v8 + 2176) = 0;
                          *(_WORD *)(v8 + 2202) = 1;
                          *(_BYTE *)(v8 + 2217) = 0;
                          *(_QWORD *)(v8 + 2152) = 0x40AC200000000000;
                          v91 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                          *(_QWORD *)(v8 + 2128) = v91;
                          if (v91)
                          {
                            *(_QWORD *)(v8 + 2136) = 0;
                            *(_BYTE *)(v8 + 2232) = 0;
                            *(_QWORD *)(v8 + 2240) = 0;
                            *(_QWORD *)(v8 + 440) = 0x4008000000000000;
                            *(_QWORD *)(v8 + 456) = 0x1400000002;
                            *(_DWORD *)(v8 + 464) = 2;
                            *(_OWORD *)(v8 + 380) = xmmword_1001BB5C0;
                            *(_QWORD *)(v8 + 396) = 0x1518000127500;
                            *(_BYTE *)(v8 + 2276) = 0;
                            *(_QWORD *)(v8 + 2280) = 0;
                            *(_WORD *)(v8 + 2288) = 0;
                            *(_BYTE *)(v8 + 2409) = 0;
                            *(_BYTE *)(v8 + 1232) = 1;
                            v94[0] = _NSConcreteStackBlock;
                            v94[1] = 3221225472;
                            v94[2] = sub_10008A35C;
                            v94[3] = &unk_10022EA38;
                            v94[4] = v8;
                            dispatch_async((dispatch_queue_t)qword_10026DD40, v94);
                            *(_QWORD *)(v8 + 2416) = +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance");
                            sub_1000BCE24((_QWORD *)(v8 + 1800), qword_10026DD40);
                            *(_BYTE *)(v8 + 2448) = 1;
                            *(_DWORD *)(v8 + 2452) = 1;
                            *(_QWORD *)(v8 + 2456) = 2;
                            *(_BYTE *)(v8 + 2464) = 0;
                            *(_QWORD *)(v8 + 2480) = 0;
                            *(_QWORD *)(v8 + 2488) = objc_alloc_init((Class)NSMutableArray);
                            *(_QWORD *)(v8 + 2496) = objc_alloc_init((Class)NSMutableDictionary);
                            *(_QWORD *)(v8 + 2520) = +[WiFiTelephonyClient sharedInstance](WiFiTelephonyClient, "sharedInstance");
                            *(_QWORD *)(v8 + 2528) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                            *(_WORD *)(v8 + 2552) = 0;
                            CFRelease(v31);

                            v58 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiManagerCreate");
                            v59 = CFSTR("%s: exiting");
                            goto LABEL_133;
                          }
                          goto LABEL_79;
                        }
                        v52 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create sessionBasedAddAsync.disassocTimer", "WiFiManagerCreate");
                      }
                      else
                      {
                        v52 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create autojoinAssist timer", "WiFiManagerCreate");
                      }
                    }
                    else
                    {
                      v52 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create CarPlay timer", "WiFiManagerCreate");
                    }
                  }
                  else
                  {
                    v52 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create heartBeatTimer", "WiFiManagerCreate");
                  }
                }
                else
                {
                  v52 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create metricDelayedSubmissionTimer", "WiFiManagerCreate");
                }
              }
              else
              {
                v52 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create diagnostics timer", "WiFiManagerCreate");
              }
            }
            else
            {
              v52 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create disassociation timer", "WiFiManagerCreate");
            }
          }
          else
          {
            v52 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: WiFiServerCreate failed", "WiFiManagerCreate");
          }
        }
        else
        {
          v52 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create backhaulLinkCheckTimer timer", "WiFiManagerCreate");
        }
      }
      else
      {
        v52 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: failed to create privateMacScanDataCleanup timer", "WiFiManagerCreate");
      }
LABEL_78:
      objc_autoreleasePoolPop(v52);
LABEL_79:
      CFRelease(v31);
      goto LABEL_80;
    }
    v68 = (const void **)&kCFBooleanFalse;
    goto LABEL_101;
  }
LABEL_80:
  CFRelease((CFTypeRef)v8);
LABEL_81:

  v58 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: failed to create manager ref", "WiFiManagerCreate");
  v8 = 0;
  v59 = CFSTR("%s: exiting, Error: failed to create manager ref");
LABEL_133:
  objc_autoreleasePoolPop(v58);
  NSLog(&v59->isa, "WiFiManagerCreate");
  objc_autoreleasePoolPop(v4);
  return v8;
}

id sub_100084880(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 1624), "runAssetQuery");
}

void sub_10008488C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  int v7;
  const __CFUUID *v8;
  const __CFUUID *v9;
  CFStringRef v10;
  CFStringRef v11;
  _BOOL4 v12;
  const __SCPreferences *v13;
  const __SCPreferences *v14;
  CFTypeID TypeID;
  int v16;
  const void **v17;
  BOOL v18;
  _BOOL4 v19;
  _BOOL4 v20;
  int v21;
  const __SCPreferences *v22;
  const void **v23;
  const __SCPreferences *v24;
  int v25;
  int v26;
  unsigned int v27;
  double v28;
  CFDictionaryRef v29;
  const __CFArray *v30;
  _BOOL4 v31;
  const __SCPreferences *v32;
  const __SCPreferences *v33;
  int v34;
  int v35;
  const __SCPreferences *v36;
  unsigned int v37;
  uint64_t v38;
  SInt32 v39;
  double v40;
  uint64_t v41;
  double v42;
  unsigned int v43;
  const __SCPreferences *v44;
  const __CFDictionary *v45;
  CFTypeID v46;
  CFDictionaryRef Copy;
  CFTypeID v48;
  CFTypeID v49;
  BOOL v50;
  __CFArray *v51;
  unsigned int v52;
  const __CFString *v53;
  void *v54;
  int v55;
  int v56;
  void *v57;
  void *v58;
  void *v59;
  int v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  _BOOL4 v65;
  unsigned int v66;
  _BOOL4 v67;
  unsigned int v68;
  const __SCPreferences *v69;
  _BOOL4 v70;
  _BOOL4 v71;
  const __SCPreferences *cf;
  _BOOL4 v73;
  _BOOL4 v74;
  _BOOL4 v75;
  _BOOL4 v76;
  _BOOL4 v77;
  _BOOL4 v78;
  const __CFBoolean *BOOLean;
  int v80;
  _BOOL4 v81;
  _BOOL4 v82;
  int v83;
  _BOOL4 v84;
  unsigned int v85;
  int v86;
  unsigned int v87;
  const __CFBoolean *v88;
  _BOOL4 v89;
  void *v90;
  CFDictionaryRef v91;
  _BOOL4 v92;
  _BOOL4 v93;
  int v94;
  _BOOL8 v95;
  const __CFDictionary *v96;
  BOOL v97;
  CFDictionaryRef v98;
  uint64_t context;
  unint64_t context_8;
  unint64_t v101;
  uint64_t v102;
  double v103;
  _QWORD v104[2];

  if (a3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: notification %d", "__WiFiManagerPreferencesCallback", a2);
    objc_autoreleasePoolPop(v5);
    if ((a2 & 2) != 0)
    {
      sub_100007620(*(const __SCPreferences **)(a3 + 1072));
      v6 = sub_10001E1C8((uint64_t)"__WiFiManagerPreferencesCallback");
      if (sub_10001D90C((_QWORD *)a3, CFSTR("DeviceUUID")) || (v8 = CFUUIDCreate(kCFAllocatorDefault)) == 0)
      {
        v7 = 0;
      }
      else
      {
        v9 = v8;
        v10 = CFUUIDCreateString(kCFAllocatorDefault, v8);
        if (v10)
        {
          v11 = v10;
          v7 = 1;
          sub_100087488((_QWORD *)a3, CFSTR("DeviceUUID"), v10, 1);
          CFRelease(v11);
        }
        else
        {
          v7 = 0;
        }
        CFRelease(v9);
      }
      sub_1000B906C((_QWORD *)a3, 1);
      *(_BYTE *)(a3 + 296) = sub_10003036C((_QWORD *)a3, CFSTR("AllowDisassociation"), 1);
      *(_BYTE *)(a3 + 313) = sub_10003036C((_QWORD *)a3, CFSTR("alwaysScan"), 0);
      *(_DWORD *)(a3 + 788) = sub_100030300((_QWORD *)a3, CFSTR("WakeMode"), 1);
      v12 = sub_10003036C((_QWORD *)a3, CFSTR("lpasEnable"), 1);
      *(_BYTE *)(a3 + 312) = -1;
      v13 = sub_10001D90C((_QWORD *)a3, CFSTR("WAPIEnabled"));
      v86 = v13
         && (v14 = v13, TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v14))
         && CFEqual(v14, kCFBooleanTrue) != 0;
      if (!sub_10001D90C((_QWORD *)a3, CFSTR("DiagnosticsEnabled")))
      {
        v16 = sub_10008036C();
        v17 = (const void **)&kCFBooleanFalse;
        if (v16)
          v17 = (const void **)&kCFBooleanTrue;
        sub_100087488((_QWORD *)a3, CFSTR("DiagnosticsEnabled"), *v17, 1);
      }
      v18 = sub_10003036C((_QWORD *)a3, CFSTR("EnableRangingLogDump"), 0);
      v19 = sub_10008F890((_QWORD *)a3);
      v20 = sub_100083038();
      v21 = !v20;
      v22 = sub_10001D90C((_QWORD *)a3, kSCPropNetAirPortJoinMode);
      v23 = (const void **)&kSCValNetAirPortJoinModeAutomatic;
      v94 = v12;
      v90 = (void *)v6;
      v82 = v19;
      if (!v22)
      {
        v67 = !v20;
        if (!v20)
          v23 = (const void **)&kSCValNetAirPortJoinModePreferred;
        v25 = 1;
        sub_100087488((_QWORD *)a3, kSCPropNetAirPortJoinMode, *v23, 1);
LABEL_34:
        v27 = sub_100030300((_QWORD *)a3, CFSTR("Fallback Preference"), 2);
        v28 = sub_10008EF8C((_QWORD *)a3, CFSTR("DisassociationInterval"), 1800.0);
        v29 = sub_10009DA68((_QWORD *)a3, 1);
        v73 = sub_10003036C((_QWORD *)a3, CFSTR("mStageAutoJoin"), 1);
        v76 = sub_10003036C((_QWORD *)a3, CFSTR("DisableBlackList"), byte_10026DD60 != 0);
        v75 = sub_10003036C((_QWORD *)a3, CFSTR("isWiFiPowerModificationDisabled"), 0);
        v74 = sub_10003036C((_QWORD *)a3, CFSTR("isPersonalHotspotModificationDisabled"), 0);
        v65 = sub_10003036C((_QWORD *)a3, CFSTR("ATJTestModeEnabled"), 0);
        v81 = sub_10003036C((_QWORD *)a3, CFSTR("OverrideWiFiFallBackPrefMode"), 0);
        v80 = sub_100030300((_QWORD *)a3, CFSTR("LinkQualityAssessmentMode"), 1);
        v78 = sub_10003036C((_QWORD *)a3, CFSTR("TrgDiscAskIfAppropriateDisconnect"), 1);
        v77 = sub_10003036C((_QWORD *)a3, CFSTR("EnableAggressiveTrgDisc"), 1);
        v30 = sub_10001D90C((_QWORD *)a3, CFSTR("List of policies"));
        v71 = sub_10003036C((_QWORD *)a3, CFSTR("optimizedAutoJoin"), 1);
        v70 = sub_10003036C((_QWORD *)a3, CFSTR("Enable5GhzAutoJoinScan"), 0);
        v69 = sub_10001D90C((_QWORD *)a3, CFSTR("deviceUpdatedDate"));
        BOOLean = sub_10001D90C((_QWORD *)a3, CFSTR("IsOrphanedSCCleanUpRequired"));
        v88 = sub_10001D90C((_QWORD *)a3, CFSTR("isWiFiPNLMigrationComplete"));
        v31 = sub_10003036C((_QWORD *)a3, CFSTR("ConnectionQualityLocalCollectionEnabled"), 0);
        v32 = sub_10001D90C((_QWORD *)a3, CFSTR("JoinRecommendationMode"));
        v97 = v18;
        v96 = v29;
        v92 = v31;
        v85 = v27;
        if (v32)
        {
          v33 = v32;
          if (CFEqual(CFSTR("None"), v32))
          {
            v66 = 0;
            goto LABEL_42;
          }
          if (CFEqual(CFSTR("Captive"), v33))
          {
            v34 = 2;
LABEL_41:
            v66 = v34;
LABEL_42:
            v35 = v25 | v7;
            cf = sub_10001D90C((_QWORD *)a3, CFSTR("JoinRecommendationDisabledUntil"));
            v89 = sub_10003036C((_QWORD *)a3, CFSTR("ConnectionQualityPrivacyRestrictionsDisabled"), 0);
            v93 = sub_10003036C((_QWORD *)a3, CFSTR("WiFiMacRandomizationInternalUI"), 1);
            v95 = sub_10003036C((_QWORD *)a3, CFSTR("enableForceCarPlayMACRandomization"), 0);
            *(_BYTE *)(a3 + 362) = sub_10003036C((_QWORD *)a3, CFSTR("PrivateMacForcedDisassocPending"), 0);
            v36 = sub_10001D90C((_QWORD *)a3, CFSTR("ATJTestNetworkSSID"));
            v37 = sub_100030300((_QWORD *)a3, CFSTR("ATJPreference"), 1);
            v38 = sub_100030300((_QWORD *)a3, CFSTR("Compatibility"), 0);
            v39 = 0;
            if (!byte_10026DD60)
              v39 = (*(_DWORD *)(a3 + 112) - 1) < 3;
            v84 = sub_10003036C((_QWORD *)a3, CFSTR("AvailabilityEngineV2Enabled"), v39);
            v83 = sub_1000A5A54(a3);
            v40 = sub_10008EF8C((_QWORD *)a3, CFSTR("AutoInstantHotspotTriggerInterval"), 120.0);
            v68 = sub_100030300((_QWORD *)a3, CFSTR("UserPreferenceJoinAlertMode"), 1);
            v41 = sub_100030300((_QWORD *)a3, CFSTR("JoinAlertDistanceThreshold"), 7776000);
            v42 = sub_10008EF8C((_QWORD *)a3, CFSTR("JoinAlertDistanceThreshold"), 30000.0);
            v43 = sub_10003036C((_QWORD *)a3, CFSTR("DebugCoreCaptureEnabled"), 1);
            v87 = sub_10003036C((_QWORD *)a3, CFSTR("CoreCaptureOnAssistedAJFailure"), 0);
            v91 = sub_1000A6EF8((_QWORD *)a3, 1);
            v44 = sub_10001D90C((_QWORD *)a3, CFSTR("SessionBasedNetworkList"));
            if (v44)
            {
              v45 = v44;
              v46 = CFGetTypeID(v44);
              if (v46 == CFDictionaryGetTypeID())
              {
                Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v45);
LABEL_51:
                v98 = Copy;
                goto LABEL_53;
              }
              v48 = CFGetTypeID(v45);
              if (v48 == CFSetGetTypeID())
              {
                Copy = CFSetCreateCopy(kCFAllocatorDefault, v45);
                goto LABEL_51;
              }
              v49 = CFGetTypeID(v45);
              if (v49 == CFArrayGetTypeID())
              {
                Copy = CFArrayCreateCopy(kCFAllocatorDefault, v45);
                goto LABEL_51;
              }
            }
            v98 = 0;
LABEL_53:
            sub_10003036C((_QWORD *)a3, CFSTR("StandALoneLPASTestModeEnabled"), 0);
            v50 = sub_100030300((_QWORD *)a3, CFSTR("phBandPreference"), 0) == 1;
            sub_1000076D4(*(SCPreferencesRef *)(a3 + 1072), v35);

            if (v30)
            {
              v51 = sub_10003F69C(v30);
              sub_1000A0774(a3, v51);
              if (v51)
                CFRelease(v51);
            }
            else
            {
              sub_1000A0774(a3, 0);
            }
            sub_100091ED4(a3, v73);
            sub_100091F6C(a3, v71, v70, v69);
            if (*(unsigned __int8 *)(a3 + 312) != v86)
            {
              *(_BYTE *)(a3 + 312) = v86;
              context = a3;
              context_8 = 0xAAAAAAAA0000001FLL;
              v101 = 0;
              v102 = 1;
              CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
            }
            if (*(_BYTE *)(a3 + 2404))
              v52 = 0;
            else
              v52 = v82;
            if (*(_BYTE *)(a3 + 2404))
              v53 = CFSTR("LPEM");
            else
              v53 = 0;
            sub_10008F33C(a3, v52, v53);
            sub_100093798(a3, v76);
            sub_1000A6D04(a3, v75);
            sub_1000A6E2C(a3, v74);
            if (sub_10009836C(a3))
            {
              v54 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Overwriting ATJ to false due to active restriction policy", "__WiFiManagerPreferencesCallback");
              objc_autoreleasePoolPop(v54);
              v55 = 0;
            }
            else
            {
              v55 = v65;
            }
            sub_100093880(a3, v55, v36);
            sub_100091C3C(a3, v37, 0);
            sub_100091D6C(a3, v38, 0);
            sub_1000910C8(a3, v96);
            if (*(double *)(a3 + 928) != v28)
            {
              *(double *)(a3 + 928) = v28;
              sub_1000932C4((_QWORD *)a3, CFSTR("DisassociationInterval"), v28);
            }
            if (*(double *)(a3 + 1880) != 7.0)
            {
              *(_QWORD *)(a3 + 1880) = 0x401C000000000000;
              sub_1000932C4((_QWORD *)a3, CFSTR("DiagnosticsInterval"), 7.0);
            }
            sub_100091214(a3, v67, 0);
            sub_1000931B0(a3, v85);
            sub_1000939D8(a3, v94);
            sub_10009ED7C(a3, v80, v81, v78, v77);
            *(_QWORD *)(a3 + 280) = 0;
            *(_QWORD *)(a3 + 288) = 0;
            context = a3;
            context_8 = 0xAAAAAAAA00000024;
            v101 = 0;
            v102 = 1;
            CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
            sub_100090934(a3, v66, cf, 0);
            context = a3;
            context_8 = 0xAAAAAAAA00000063;
            v101 = v68;
            v102 = *(_QWORD *)&v42;
            v103 = (double)v41;
            CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
            if (BOOLean)
            {
              if (CFBooleanGetValue(BOOLean))
              {
                v56 = *(unsigned __int8 *)(a3 + 2008);
                v57 = objc_autoreleasePoolPush();
                if (v56)
                {
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already Scheduled", "__WiFiManagerCheckSCCleanUpScheduling");
LABEL_79:
                  objc_autoreleasePoolPop(v57);
                  goto LABEL_87;
                }
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Schedule", "__WiFiManagerCheckSCCleanUpScheduling");
                objc_autoreleasePoolPop(v57);
                *(_WORD *)(a3 + 2008) = 1;
                objc_msgSend(*(id *)(a3 + 2000), "scheduleOrphanedSetsCleanUp");
              }
              else if (!*(_BYTE *)(a3 + 2009))
              {
                *(_WORD *)(a3 + 2008) = 256;
                v58 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unschedule", "__WiFiManagerCheckSCCleanUpScheduling");
                objc_autoreleasePoolPop(v58);
                objc_msgSend(*(id *)(a3 + 2000), "unScheduleOrphanedSetsCleanUp");
              }
LABEL_87:
              if (v88)
              {
                if (CFBooleanGetValue(v88))
                {
                  if (!*(_BYTE *)(a3 + 2011))
                  {
                    v59 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unschedule", "__WiFiManagerCheckPNLMigrationScheduling");
                    objc_autoreleasePoolPop(v59);
                    *(_WORD *)(a3 + 2010) = 256;
                    objc_msgSend(*(id *)(a3 + 2000), "unSchedulePNLMigration");
                  }
                  goto LABEL_100;
                }
                v60 = *(unsigned __int8 *)(a3 + 2010);
                v61 = objc_autoreleasePoolPush();
                if (!v60)
                {
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Schedule", "__WiFiManagerCheckPNLMigrationScheduling");
                  objc_autoreleasePoolPop(v61);
                  *(_WORD *)(a3 + 2010) = 1;
                  objc_msgSend(*(id *)(a3 + 2000), "schedulePNLMigration");
                  goto LABEL_100;
                }
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already Scheduled", "__WiFiManagerCheckPNLMigrationScheduling");
              }
              else
              {
                v61 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null isWiFiPNLMigrationNeededRef", "__WiFiManagerCheckPNLMigrationScheduling");
              }
              objc_autoreleasePoolPop(v61);
LABEL_100:
              sub_1000A41E0(a3, v92);
              sub_1000A4A9C(a3, v89);
              sub_1000A101C(a3, v84);
              LODWORD(v104[0]) = v83;
              context = a3;
              context_8 = 0xAAAAAAAA0000005BLL;
              v101 = (unint64_t)v104;
              v102 = 1;
              CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              *(double *)v104 = v40;
              context = a3;
              context_8 = 0xAAAAAAAA0000005DLL;
              v101 = (unint64_t)v104;
              v102 = 1;
              CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              LOBYTE(v104[0]) = v43;
              if (*(unsigned __int8 *)(a3 + 2202) != v43)
              {
                v62 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Debug CoreCapture %d", "__WiFiManagerSetDebugCoreCapture", v43);
                objc_autoreleasePoolPop(v62);
                *(_BYTE *)(a3 + 2202) = v43;
                context = a3;
                context_8 = 0xAAAAAAAA00000067;
                v101 = (unint64_t)v104;
                v102 = 1;
                CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              }
              LOBYTE(v104[0]) = v87;
              if (*(unsigned __int8 *)(a3 + 2203) != v87)
              {
                v63 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CoreCapture On Assisted AJ Failure %d", "__WiFiManagerSetCoreCaptureOnAssistedAJFailure", v87);
                objc_autoreleasePoolPop(v63);
                *(_BYTE *)(a3 + 2203) = v87;
                context = a3;
                context_8 = 0xAAAAAAAA00000072;
                v101 = (unint64_t)v104;
                v102 = 1;
                CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              }
              sub_1000A6FC8(a3, v93);
              if (*(_BYTE *)(a3 + 377) != v95)
              {
                v64 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation: Mac Randomisation CarPlay test mode toggled. Old state : %hhu, new state : %hhu", "__WiFiManagerSetMacRandomisationCarPlayTestMode", *(unsigned __int8 *)(a3 + 377), v95);
                objc_autoreleasePoolPop(v64);
                *(_BYTE *)(a3 + 377) = v95;
              }
              sub_1000A371C(a3, v91);
              sub_1000A3300(a3, v98);
              if (v98)
                CFRelease(v98);
              LOBYTE(v104[0]) = v50;
              context = a3;
              context_8 = 0xAAAAAAAA00000077;
              v101 = (unint64_t)v104;
              v102 = 1;
              CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              LOBYTE(v104[0]) = v97;
              context = a3;
              context_8 = 0xAAAAAAAA0000007BLL;
              v101 = (unint64_t)v104;
              v102 = 1;
              CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
              sub_1000AD704();
              if (v96)
                CFRelease(v96);
              if (v91)
                CFRelease(v91);
              return;
            }
            v57 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null isOrphanedSCCleanUpRequiredRef", "__WiFiManagerCheckSCCleanUpScheduling");
            goto LABEL_79;
          }
          if (!CFEqual(CFSTR("Quality"), v33))
          {
            if (CFEqual(CFSTR("Public"), v33))
            {
              v34 = 252;
            }
            else if (CFEqual(CFSTR("NewLocation"), v33))
            {
              v34 = 253;
            }
            else if (CFEqual(CFSTR("InfrequentNetwork"), v33))
            {
              v34 = 254;
            }
            else if (CFEqual(CFSTR("All"), v33))
            {
              v34 = 255;
            }
            else
            {
              v34 = 1;
            }
            goto LABEL_41;
          }
        }
        v34 = 1;
        goto LABEL_41;
      }
      v24 = v22;
      if (CFEqual(kSCValNetAirPortJoinModeAutomatic, v22))
      {
        v67 = 0;
      }
      else
      {
        if (CFEqual(kSCValNetAirPortJoinModePreferred, v24))
        {
          v26 = 1;
        }
        else if (CFEqual(kSCValNetAirPortJoinModeRecent, v24))
        {
          v26 = 2;
        }
        else
        {
          if (!CFEqual(kSCValNetAirPortJoinModeStrongest, v24))
          {
            if (CFEqual(kSCValNetAirPortJoinModeRanked, v24))
              v21 = 4;
            v67 = v21;
            goto LABEL_33;
          }
          v26 = 3;
        }
        v67 = v26;
      }
LABEL_33:
      v25 = v7;
      goto LABEL_34;
    }
  }
}

void sub_1000858CC(const __SCPreferences *a1, char a2, uint64_t a3)
{
  void *v4;
  const __CFBoolean *Value;
  const __CFBoolean *v7;
  const __CFBoolean *v8;
  CFBooleanRef v9;
  const __CFBoolean *v10;
  const __CFBoolean *v11;
  const __CFBoolean *v12;
  CFBooleanRef v13;
  void *v14;
  const char *v15;
  void *v16;
  const char *v17;
  _BOOL4 v18;
  _BOOL4 v19;
  uint64_t v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const __CFNumber *v23;
  void *v24;
  __CFDictionary *v25;
  CFMutableDictionaryRef Mutable;
  CFNumberRef v27;
  CFNumberRef v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  const char *v33;
  void *v34;
  void *v35;
  const char *v36;
  BOOL v37;
  int v38;
  void *v39;
  uint64_t valuePtr;

  if ((a2 & 2) == 0 || !a3)
    return;
  if (*(_BYTE *)(a3 + 2201))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFi Power Modification disabled", "__WiFiManagerRadioPreferencesCallback");
    objc_autoreleasePoolPop(v4);
    return;
  }
  SCPreferencesSynchronize(a1);
  CFPreferencesAppSynchronize(CFSTR("com.apple.preferences.network"));
  Value = (const __CFBoolean *)SCPreferencesGetValue(a1, CFSTR("AirplaneMode"));
  if (Value)
    v7 = Value;
  else
    v7 = kCFBooleanFalse;
  v8 = (const __CFBoolean *)CFPreferencesCopyAppValue(CFSTR("AirplaneModeEnabled"), CFSTR("com.apple.preferences.network"));
  if (v8)
    v9 = v8;
  else
    v9 = kCFBooleanFalse;
  v10 = (const __CFBoolean *)SCPreferencesGetValue(a1, CFSTR("LowPowerMode"));
  if (v10)
    v11 = v10;
  else
    v11 = kCFBooleanFalse;
  v12 = (const __CFBoolean *)CFPreferencesCopyAppValue(CFSTR("LowPowerMode"), CFSTR("com.apple.preferences.network"));
  if (v12)
    v13 = v12;
  else
    v13 = kCFBooleanFalse;
  if (!CFEqual(v7, v9))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (v7 == kCFBooleanTrue)
        v15 = "Enabled";
      else
        v15 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Airplane mode %s", v15);
    }
    objc_autoreleasePoolPop(v14);
    CFPreferencesSetAppValue(CFSTR("AirplaneModeEnabled"), v7, CFSTR("com.apple.preferences.network"));
    objc_msgSend(*(id *)(a3 + 2416), "setCellularDataStatus:inAirplaneMode:", *(_QWORD *)(a3 + 1288), sub_1000B8F2C() != 0);
    if (CFEqual(v11, v13))
    {
LABEL_34:
      v18 = sub_10003036C((_QWORD *)a3, CFSTR("KeepWiFiPoweredAirplaneMode"), 0);
      v19 = sub_10003036C((_QWORD *)a3, CFSTR("KeepWiFiPoweredAirplaneModeEnabled"), 1);
      v20 = *(unsigned int *)(a3 + 316);
      if (v7 != kCFBooleanTrue && v11 != kCFBooleanTrue)
      {
        valuePtr = 0;
        v21 = (const __CFDictionary *)CFPreferencesCopyAppValue(CFSTR("original-network-state"), CFSTR("com.apple.preferences.network"));
        v22 = v21;
        if (v21 && (v23 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("wifi-network"))) != 0)
        {
          CFNumberGetValue(v23, kCFNumberCFIndexType, &valuePtr);
        }
        else
        {
          v30 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: original radio setting state missing. Assuming enabled.", "__WiFiManagerRadioPreferencesCallback");
          objc_autoreleasePoolPop(v30);
          valuePtr = 1;
        }
        v31 = objc_autoreleasePoolPush();
        if (v19)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: airplane mode stickiness is enabled", "__WiFiManagerRadioPreferencesCallback");
          objc_autoreleasePoolPop(v31);
          if (sub_10003036C((_QWORD *)a3, CFSTR("KeepWiFiPoweredAirplaneMode"), 0) != ((_DWORD)v20 == 1))
          {
            v32 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
            {
              v33 = "OFF";
              if ((_DWORD)v20 == 1)
                v33 = "ON";
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting airplane mode stickiness preference to %s", "__WiFiManagerRadioPreferencesCallback", v33);
            }
            objc_autoreleasePoolPop(v32);
            sub_1000B91CC((_QWORD *)a3, v20 == 1);
          }
        }
        else
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: airplane mode stickiness is disabled", "__WiFiManagerRadioPreferencesCallback");
          objc_autoreleasePoolPop(v31);
        }
        if (valuePtr != v20)
        {
          v34 = objc_autoreleasePoolPush();
          v35 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v36 = sub_1000648F0(valuePtr);
            objc_msgSend(v35, "WFLog:message:", 3, "WiFi previous state: %s current state: %s", v36, sub_1000648F0(v20));
          }
          objc_autoreleasePoolPop(v34);
          if (valuePtr == 4 && !(_DWORD)v20
            || ((_DWORD)v20 != 4 ? (v37 = (_DWORD)v20 == 0) : (v37 = 1),
                !v37 ? (v38 = 0) : (v38 = 1),
                valuePtr == 1 && v38))
          {
            sub_100093358(a3, valuePtr == 1, 0);
          }
        }
        sub_1000898A0(a3, 1, 8, 0);
        CFPreferencesSetAppValue(CFSTR("original-network-state"), 0, CFSTR("com.apple.preferences.network"));
        CFPreferencesAppSynchronize(CFSTR("com.apple.preferences.network"));
        if (v22)
          CFRelease(v22);
        goto LABEL_88;
      }
      v24 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi current state: %s", sub_1000648F0(v20));
      objc_autoreleasePoolPop(v24);
      v25 = (__CFDictionary *)CFPreferencesCopyAppValue(CFSTR("original-network-state"), CFSTR("com.apple.preferences.network"));
      if (!v25)
      {
        Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (!Mutable)
        {
          CFPreferencesAppSynchronize(CFSTR("com.apple.preferences.network"));
          if (!v18)
            goto LABEL_83;
          goto LABEL_47;
        }
        v25 = Mutable;
        valuePtr = v20;
        v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
        if (v27)
        {
          v28 = v27;
          CFDictionarySetValue(v25, CFSTR("wifi-network"), v27);
          CFPreferencesSetAppValue(CFSTR("original-network-state"), v25, CFSTR("com.apple.preferences.network"));
          CFRelease(v28);
        }
        CFPreferencesAppSynchronize(CFSTR("com.apple.preferences.network"));
      }
      CFRelease(v25);
      if (!v18)
        goto LABEL_83;
LABEL_47:
      if (!v19)
      {
        v29 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: User preference is to leave WiFi powered, but power stickiness is disabled.", "__WiFiManagerRadioPreferencesCallback");
        objc_autoreleasePoolPop(v29);
LABEL_87:
        sub_100093358(a3, 0, 0);
        goto LABEL_88;
      }
LABEL_83:
      if (v18)
      {
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Leaving WiFi powered due to user preference", "__WiFiManagerRadioPreferencesCallback");
        objc_autoreleasePoolPop(v39);
        goto LABEL_88;
      }
      goto LABEL_87;
    }
LABEL_28:
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (v11 == kCFBooleanTrue)
        v17 = "Enabled";
      else
        v17 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Low Power Mode %s", v17);
    }
    objc_autoreleasePoolPop(v16);
    CFPreferencesSetAppValue(CFSTR("LowPowerMode"), v11, CFSTR("com.apple.preferences.network"));
    goto LABEL_34;
  }
  if (!CFEqual(v11, v13))
    goto LABEL_28;
LABEL_88:
  if (v13)
    CFRelease(v13);
  if (v9)
    CFRelease(v9);
}

void sub_100085F68(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  void *v4;
  CFIndex v5;
  double v6;
  const void *ValueAtIndex;
  const void *v8;
  double v9;
  double v10;
  void *v11;
  void *v13;
  double v14;
  void *v15;
  double v16;
  CFStringRef StringWithAbsoluteTime;
  void *v18;
  NSObject *v19;
  dispatch_time_t v20;
  __CFNotificationCenter *v21;
  __CFNotificationCenter *DarwinNotifyCenter;
  const __CFArray *v23;
  int v24;
  CFIndex v25;
  uint64_t v26;
  void *v27;
  void *v28;

  if (!a1)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerCheckNetworkExpiry");
    goto LABEL_47;
  }
  v2 = *(const __CFArray **)(a1 + 216);
  if (!v2)
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null networks", "__WiFiManagerCheckNetworkExpiry");
LABEL_47:
    objc_autoreleasePoolPop(v28);
    return;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 216));
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network count %d", "__WiFiManagerCheckNetworkExpiry", Count);
  objc_autoreleasePoolPop(v4);
  if ((int)Count < 1)
  {
    v6 = 0.0;
  }
  else
  {
    v5 = 0;
    v6 = 0.0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, v5);
      if (ValueAtIndex)
      {
        v8 = ValueAtIndex;
        if (sub_1000C55BC((uint64_t)ValueAtIndex))
        {
          sub_1000C5440((uint64_t)v8);
          v10 = v9;
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@, Texpire %f", "__WiFiManagerCheckNetworkExpiry", sub_10002B088(v8), *(_QWORD *)&v10);
          objc_autoreleasePoolPop(v11);
          if ((int)v10 <= 0)
          {
            v13 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Network %@ has expired. Removing it from known networks list", sub_10002B088(v8));
            objc_autoreleasePoolPop(v13);
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1368), v8);
          }
          else if (v10 < v6 || v6 == 0.0)
          {
            v6 = v10;
          }
        }
      }
      ++v5;
    }
    while (Count != v5);
  }
  v14 = vabdd_f64(*(double *)(a1 + 1376) - CFAbsoluteTimeGetCurrent(), v6);
  v15 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: minTexpire %f, deltaTexpire %f", "__WiFiManagerCheckNetworkExpiry", *(_QWORD *)&v6, *(_QWORD *)&v14);
  objc_autoreleasePoolPop(v15);
  if (v6 == 0.0 || v14 <= 60.0)
  {
    if (!(int)v6 && *(double *)(a1 + 1344) != 0.0)
    {
      *(_QWORD *)(a1 + 1344) = 0;
      *(_QWORD *)(a1 + 1352) = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1360), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterRemoveObserver(DarwinNotifyCenter, 0, CFSTR("SignificantTimeChangeNotification"), 0);
    }
    StringWithAbsoluteTime = 0;
  }
  else
  {
    v16 = v6 + CFAbsoluteTimeGetCurrent();
    StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, (CFDateFormatterRef)qword_10026DD58, v16);
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: starting expiry timer:: set next fire date %@", "__WiFiManagerCheckNetworkExpiry", StringWithAbsoluteTime);
    objc_autoreleasePoolPop(v18);
    v19 = *(NSObject **)(a1 + 1360);
    v20 = dispatch_time(0, (uint64_t)(v6 * 1000000000.0));
    dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0);
    *(double *)(a1 + 1376) = v16;
    *(double *)(a1 + 1344) = v6;
    v21 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v21, (const void *)a1, (CFNotificationCallback)nullsub_6, CFSTR("SignificantTimeChangeNotification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  v23 = *(const __CFArray **)(a1 + 1368);
  if (v23)
  {
    v24 = CFArrayGetCount(v23);
    if (v24 >= 1)
    {
      v25 = 0;
      v26 = v24;
      do
      {
        v27 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1368), v25);
        sub_100098DBC(a1, v27, 0);
        sub_1000C65D8(v27);
        ++v25;
      }
      while (v26 != v25);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1368));
  }
  if (StringWithAbsoluteTime)
    CFRelease(StringWithAbsoluteTime);
}

void sub_100086378(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timed out", "__WiFiManagerCarPlaySessionDownWaitTimerCallback");
  objc_autoreleasePoolPop(v2);
  sub_1000B74BC(a1);
}

void sub_1000863DC(uint64_t a1)
{
  void *v2;
  id v3;
  uint64_t v4;
  unsigned __int8 v5;
  NSObject *v6;
  void *v7;
  _QWORD v8[5];
  unsigned __int8 v9;

  v2 = objc_autoreleasePoolPush();
  v3 = +[WiFiAccountStoreManager sharedWiFiAccountStoreManager](WiFiAccountStoreManager, "sharedWiFiAccountStoreManager");
  v4 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v4 + 2208) = v3;
  v5 = sub_100086488(v4);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100086514;
  v8[3] = &unk_1002306A0;
  v6 = *(NSObject **)(a1 + 32);
  v8[4] = *(_QWORD *)(a1 + 40);
  v9 = v5;
  dispatch_async(v6, v8);
  v7 = *(void **)(*(_QWORD *)(a1 + 40) + 2208);
  if (v7)
    objc_msgSend(v7, "registerCallback:withContext:", sub_100086654);
  objc_autoreleasePoolPop(v2);
}

id sub_100086488(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v6;

  v2 = objc_autoreleasePoolPush();
  v3 = *(void **)(a1 + 2208);
  if (v3)
  {
    v4 = objc_msgSend(v3, "isManagedAppleID");
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null accountStoreManager", "__WiFiManagerIsManagedAppleID");
    objc_autoreleasePoolPop(v6);
    v4 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v4;
}

void sub_100086514(uint64_t a1)
{
  sub_100086528(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 1);
}

void sub_100086528(uint64_t a1, int a2, int a3)
{
  void *v6;
  int v7;
  void *v8;
  void *v9;
  void *v10;
  const char *v11;
  char context;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "__WiFiManagerSetManagedAppleID");
    v9 = v8;
    goto LABEL_18;
  }
  if (*(unsigned __int8 *)(a1 + 2216) == a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v11 = "Managed";
      if (!a2)
        v11 = "Non-Managed";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No change Current (%s Account)", "__WiFiManagerSetManagedAppleID", v11);
    }
    v9 = v10;
LABEL_18:
    objc_autoreleasePoolPop(v9);
    goto LABEL_8;
  }
  *(_BYTE *)(a1 + 2216) = a2;
  if (a2)
  {
    v7 = 0;
  }
  else
  {
    if (a3)
      goto LABEL_7;
    v7 = 1;
  }
  sub_1000A5978((_DWORD *)a1, v7, 0);
LABEL_7:
  context = a2;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B9AC8, &context);
LABEL_8:
  objc_autoreleasePoolPop(v6);
}

void sub_100086654(uint64_t a1, char a2)
{
  void *v4;
  NSObject *v5;
  void *v6;
  _QWORD block[5];
  char v8;

  v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiManagerHandleAccountStoreChangesForManagedID");
    goto LABEL_9;
  }
  v5 = *(NSObject **)(a1 + 32);
  if (!v5)
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null queue.", "__WiFiManagerHandleAccountStoreChangesForManagedID");
LABEL_9:
    objc_autoreleasePoolPop(v6);
    goto LABEL_4;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B9AB4;
  block[3] = &unk_1002306A0;
  block[4] = a1;
  v8 = a2;
  dispatch_async(v5, block);
LABEL_4:
  objc_autoreleasePoolPop(v4);
}

uint64_t sub_10008674C(uint64_t a1)
{
  void *v2;
  const __CFArray *v3;
  void *v4;
  const void *v5;
  __CFArray *v6;
  void *v7;
  const char *v8;
  const __CFArray *v9;
  const void *v10;
  __CFArray *v11;
  const char *v12;
  void *v13;
  uint64_t v14;
  _QWORD v16[6];
  _QWORD block[5];
  _QWORD v18[6];

  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x3052000000;
  v18[3] = sub_10002FA68;
  v18[4] = sub_10002F978;
  v18[5] = 0;
  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerGetKnownNetworksCache");
    goto LABEL_18;
  }
  if (!*(_BYTE *)(a1 + 1328))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device not yet unlocked. Not fetching network list.", "WiFiManagerGetKnownNetworksCache");
    goto LABEL_18;
  }
  v3 = *(const __CFArray **)(a1 + 224);
  if (v3 && CFArrayGetCount(v3))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fetched %ld known networks from the cache", "WiFiManagerGetKnownNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
LABEL_18:
    objc_autoreleasePoolPop(v4);
    goto LABEL_41;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000A45E4;
  block[3] = &unk_100230858;
  block[4] = v18;
  if (qword_10026D698 != -1)
    dispatch_once(&qword_10026D698, block);
  if (sub_1000304D4((_QWORD *)a1))
  {
    v5 = *(const void **)(a1 + 224);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 224) = 0;
    }
    v6 = sub_10009C2F0(objc_msgSend(*(id *)(a1 + 1104), "dictionaryRepresentation"));
    *(_QWORD *)(a1 + 224) = v6;
    if (v6 && CFArrayGetCount(v6) >= 1)
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unified KVS returned %d networks", "WiFiManagerGetKnownNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (*(_QWORD *)(a1 + 224))
          v8 = "empty list";
        else
          v8 = "nil";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: unified KVS returned %s", "WiFiManagerGetKnownNetworksCache", v8);
      }
    }
  }
  else
  {
    SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 1080));
    v9 = sub_10001D90C((_QWORD *)a1, CFSTR("List of known networks"));
    v10 = *(const void **)(a1 + 224);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 224) = 0;
    }
    v11 = sub_100064608(v9);
    *(_QWORD *)(a1 + 224) = v11;
    if (v11 && CFArrayGetCount(v11) >= 1)
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: legacy KVS returned %d networks", "WiFiManagerGetKnownNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
    }
    else
    {
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (*(_QWORD *)(a1 + 224))
          v12 = "empty list";
        else
          v12 = "nil";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: legacy KVS returned %s", "WiFiManagerGetKnownNetworksCache", v12);
      }
    }
  }
  objc_autoreleasePoolPop(v7);
  if (*(_QWORD *)(a1 + 224))
  {
    *(CFAbsoluteTime *)(a1 + 232) = CFAbsoluteTimeGetCurrent();
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Fetched %ld known networks from the plist", "WiFiManagerGetKnownNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
    objc_autoreleasePoolPop(v13);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_1000A4618;
    v16[3] = &unk_10022F160;
    v16[4] = v18;
    v16[5] = a1;
    if (qword_10026D6A0 != -1)
      dispatch_once(&qword_10026D6A0, v16);
  }
LABEL_41:
  v14 = *(_QWORD *)(a1 + 224);
  objc_autoreleasePoolPop(v2);
  _Block_object_dispose(v18, 8);
  return v14;
}

void sub_100086B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100086B84(uint64_t a1, const __CFArray *a2)
{
  const __CFArray *v2;
  const __CFArray *v4;
  CFIndex Count;
  const __CFAllocator *v6;
  uint64_t v7;
  __CFSet *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v11;
  const void *v12;
  __CFArray *MutableCopy;
  CFIndex v14;
  CFIndex v15;
  CFIndex j;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  void *v21;
  CFIndex v22;
  CFIndex v23;
  CFIndex k;
  const void *v25;
  const void *v26;
  const void *v27;
  CFIndex v28;
  const __SCPreferences *v29;
  const __CFBoolean *v30;
  CFIndex m;
  void *v32;
  void *v33;
  const __CFString *v34;
  const __CFString *v35;
  CFAbsoluteTime Current;
  CFDateRef v37;
  CFDateRef v38;
  void *v39;
  const void *v40;
  _BOOL4 v41;
  unsigned int v42;
  const void *v43;
  void *v44;
  void *v45;
  const void *v46;
  __CFArray *v47;
  CFIndex v48;
  CFIndex v49;
  CFIndex v50;
  const void *v51;
  const void *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  void *v57;
  const void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  const __CFAllocator *allocator;
  __CFArray *theArray;
  uint64_t context;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;

  v2 = a2;
  if (!a2)
    goto LABEL_100;
  v4 = *(const __CFArray **)(a1 + 1608);
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    v6 = kCFAllocatorDefault;
    if (Count)
    {
      v7 = Count;
      Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
      if (v7 >= 1)
      {
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1608), i);
          if (ValueAtIndex)
          {
            v11 = (uint64_t)ValueAtIndex;
            if (sub_10003F5B4((uint64_t)ValueAtIndex) == 1)
            {
              v12 = sub_10003F540(v11);
              CFSetAddValue(Mutable, v12);
            }
          }
        }
      }
      if (Mutable)
      {
        if (CFSetGetCount(Mutable) && CFArrayGetCount(v2))
        {
          MutableCopy = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (MutableCopy)
          {
            v14 = CFArrayGetCount(v2);
            if (v14 >= 1)
            {
              v15 = v14;
              for (j = 0; j != v15; ++j)
              {
                v17 = CFArrayGetValueAtIndex(v2, j);
                if (v17)
                {
                  v18 = v17;
                  v19 = sub_10002BE64((uint64_t)v17, CFSTR("PolicyUUID"));
                  if (v19)
                  {
                    v20 = v19;
                    if (CFSetContainsValue(Mutable, v19))
                    {
                      if (!sub_1000CB480((uint64_t)v18))
                      {
                        v21 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@ allowed. Restriction UUID %@", "__WiFiManagerCreateRestrictedList", sub_10002B088(v18), v20);
                        objc_autoreleasePoolPop(v21);
                        CFArrayAppendValue(MutableCopy, v18);
                        v6 = kCFAllocatorDefault;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v2);
        }
        CFRelease(Mutable);
        goto LABEL_29;
      }
    }
  }
  else
  {
    v6 = kCFAllocatorDefault;
  }
  MutableCopy = CFArrayCreateMutableCopy(v6, 0, v2);
LABEL_29:
  if (*(_BYTE *)(a1 + 312))
  {
    v2 = MutableCopy;
  }
  else
  {
    v2 = CFArrayCreateMutable(v6, 0, &kCFTypeArrayCallBacks);
    v22 = CFArrayGetCount(MutableCopy);
    if (v22 >= 1 && v2)
    {
      v23 = v22;
      for (k = 0; k != v23; ++k)
      {
        v25 = CFArrayGetValueAtIndex(MutableCopy, k);
        if (v25)
        {
          v26 = v25;
          if (!sub_10002DAF0((_BOOL8)v25))
            CFArrayAppendValue(v2, v26);
        }
      }
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
  }
  v27 = *(const void **)(a1 + 216);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a1 + 216) = 0;
  }
  allocator = v6;
  theArray = CFArrayCreateMutable(v6, 0, &kCFTypeArrayCallBacks);
  v28 = CFArrayGetCount(v2);
  v29 = sub_10001D90C((_QWORD *)a1, CFSTR("IsNewInstall"));
  if (v28 >= 1)
  {
    v30 = v29;
    for (m = 0; m != v28; ++m)
    {
      v32 = (void *)CFArrayGetValueAtIndex(v2, m);
      if (v32)
      {
        v33 = v32;
        if (*(_BYTE *)(a1 + 1560))
        {
          v34 = (const __CFString *)sub_10002B088(v32);
          if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
          {
            if (v34)
            {
              v35 = *(const __CFString **)(a1 + 1568);
              if (v35)
              {
                if (CFStringCompare(v34, v35, 0) == kCFCompareEqualTo)
                {
                  Current = CFAbsoluteTimeGetCurrent();
                  v37 = CFDateCreate(allocator, Current);
                  if (v37)
                  {
                    v38 = v37;
                    sub_1000C69F0(v33, 1, v37);
                    CFRelease(v38);
                  }
                  v39 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CompanionAssisted: adjusted autojoin date of network for ssid %@", "__WiFiManagerCopyAdjustedNetworks", sub_10002B088(v33));
                  objc_autoreleasePoolPop(v39);
                }
              }
            }
          }
        }
        v40 = sub_1000C6A58((uint64_t)v33, 1);
        v41 = sub_1000CB480((uint64_t)v33);
        if (sub_10002DAB4((uint64_t)v33))
          v42 = sub_1000CB584(v33);
        else
          v42 = 0;
        v43 = sub_10002BE64((uint64_t)v33, CFSTR("DisableWiFiAutoJoinUntilFirstUserJoin"));
        if (v30 != kCFBooleanFalse && !v40 && v41 && v42 && !v43)
        {
          v44 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: carrier network %@ can expose IMSI. Disabling until first join.", "__WiFiManagerCopyAdjustedNetworks", sub_10002B088(v33));
          objc_autoreleasePoolPop(v44);
          sub_10002C478((uint64_t)v33, CFSTR("DisableWiFiAutoJoinUntilFirstUserJoin"), kCFBooleanTrue);
        }
        if (sub_1000CAF9C((const __CFDictionary **)v33))
        {
          v45 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is infrequently joined public network, skipping.", "__WiFiManagerCopyAdjustedNetworks", sub_10002B088(v33));
          objc_autoreleasePoolPop(v45);
        }
        else
        {
          CFArrayAppendValue(theArray, v33);
        }
      }
    }
  }
  *(_QWORD *)(a1 + 216) = theArray;
  sub_100090EFC(a1);
  v46 = *(const void **)(a1 + 256);
  if (v46)
  {
    CFRelease(v46);
    *(_QWORD *)(a1 + 256) = 0;
  }
  v47 = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
  v48 = CFArrayGetCount(v2);
  if (v48 < 1)
    goto LABEL_87;
  v49 = v48;
  v50 = 0;
  while (1)
  {
    v51 = CFArrayGetValueAtIndex(v2, v50);
    if (!v51)
      goto LABEL_86;
    v52 = v51;
    if (!*(_BYTE *)(a1 + 1504))
      break;
    v53 = (const __CFString *)sub_10002BE64((uint64_t)v51, CFSTR("CARPLAY_UUID"));
    if (v53)
    {
      v54 = *(const __CFString **)(a1 + 1512);
      if (v54)
      {
        if (CFStringCompare(v53, v54, 0) == kCFCompareEqualTo)
        {
          CFArrayAppendValue(v47, v52);
          v60 = objc_autoreleasePoolPush();
          v61 = v60;
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CarPlay: found matching UUID %@ network for ssid %@", "__WiFiManagerCopyPriorityNetworks", *(_QWORD *)(a1 + 1512), sub_10002B088(v52));
          goto LABEL_107;
        }
      }
    }
LABEL_86:
    if (v49 == ++v50)
      goto LABEL_87;
  }
  if (!*(_BYTE *)(a1 + 1560))
    goto LABEL_86;
  v55 = (const __CFString *)sub_10002B088(v51);
  if (!v55)
    goto LABEL_86;
  v56 = *(const __CFString **)(a1 + 1568);
  if (!v56 || CFStringCompare(v55, v56, 0))
    goto LABEL_86;
  CFArrayAppendValue(v47, v52);
  v61 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: CompanionAssisted: found matching SSID network %@", "__WiFiManagerCopyPriorityNetworks", sub_10002B088(v52), v62);
LABEL_107:
  objc_autoreleasePoolPop(v61);
LABEL_87:
  if (!CFArrayGetCount(v47))
  {
    if (*(_BYTE *)(a1 + 1504))
    {
      v57 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matching Carplay network found for UUID %@. Reverting to normal mode.", "__WiFiManagerCopyPriorityNetworks", *(_QWORD *)(a1 + 1512));
      objc_autoreleasePoolPop(v57);
      *(_BYTE *)(a1 + 1504) = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1536), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      context = a1;
      v66 = 0xAAAAAA0000000042;
      v67 = 0xAAAAAAAA00000000;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
      v58 = *(const void **)(a1 + 1512);
      if (v58)
      {
        CFRelease(v58);
        *(_QWORD *)(a1 + 1512) = 0;
      }
    }
    else if (*(_BYTE *)(a1 + 1560))
    {
      v59 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matching autojoin assist network found for SSID %@. Reverting to normal mode. ###STOP_CAAJ", "__WiFiManagerCopyPriorityNetworks", *(_QWORD *)(a1 + 1568));
      objc_autoreleasePoolPop(v59);
      *(_BYTE *)(a1 + 1560) = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1576), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      context = *(_QWORD *)(a1 + 1568);
      v66 = *(_QWORD *)(a1 + 1584);
      sub_1000618C4((uint64_t)&context, 0);
    }
    if (v47)
    {
      CFRelease(v47);
      v47 = 0;
    }
  }
  *(_QWORD *)(a1 + 256) = v47;
LABEL_100:
  context = a1;
  v66 = 0xAAAAAAAA00000003;
  v67 = 0;
  v68 = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  if (v2)
    CFRelease(v2);
}

void sub_100087390(uint64_t a1)
{
  void *v2;

  *(_BYTE *)(a1 + 360) = 0;
  if (sub_10001D90C((_QWORD *)a1, CFSTR("IsNewInstall")) == kCFBooleanFalse
    || (objc_msgSend(-[NSUserDefaults objectForKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "objectForKey:", CFSTR("PrivateMacListCloudRestoreSanitized")), "BOOLValue") & 1) != 0)
  {
    if (!*(_BYTE *)(a1 + 360))
    {
      *(_BYTE *)(a1 + 360) = 1;
      v2 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : private MAC networks need to be sanitized due to device reboot [%hhu]", "WiFiManagerPrivateMacNetworksEvaluateSanitizeRequired", *(unsigned __int8 *)(a1 + 360));
      goto LABEL_9;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 360) = 1;
  }
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : private MAC networks need to be sanitized due to iCloud restore on a new device [%hhu]", "WiFiManagerPrivateMacNetworksEvaluateSanitizeRequired", *(unsigned __int8 *)(a1 + 360));
LABEL_9:
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_100087488(_QWORD *a1, const __CFString *a2, const void *a3, int a4)
{
  const __SCPreferences *v7;
  const __SCPreferences *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  int v14;

  if (!a2)
    return 0;
  v7 = (const __SCPreferences *)sub_10001D964(a1, a2);
  if (!v7)
    return 0;
  v8 = v7;
  if (!a4)
  {
    if (sub_100007620(v7))
    {
      v9 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerSetProperty");
      goto LABEL_7;
    }
    return 0;
  }
  v9 = 0;
LABEL_7:
  if (a3)
  {
    v10 = SCPreferencesSetValue(v8, a2, a3);
  }
  else
  {
    if (!SCPreferencesGetValue(v8, a2))
    {
      v11 = 1;
      if (a4)
        return v11;
      goto LABEL_17;
    }
    v10 = SCPreferencesRemoveValue(v8, a2);
  }
  v11 = v10;
  if (!(_DWORD)v10)
  {
    v12 = objc_autoreleasePoolPush();
    v13 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v14 = SCError();
      objc_msgSend(v13, "WFLog:message:", 4, "SCPreferencesSetValue() %s key=%@ value=%@", SCErrorString(v14), a2, a3);
    }
    objc_autoreleasePoolPop(v12);
    v11 = 0;
  }
  if (!a4)
  {
LABEL_17:
    v11 = sub_1000076D4(v8, v11);

  }
  return v11;
}

uint64_t sub_1000875B0(uint64_t a1)
{
  void *v2;
  const __CFArray *v3;
  void *v4;
  uint64_t v5;
  const char *v6;
  const __CFArray *v7;
  const void *v8;
  __CFArray *v9;
  void *v10;
  CFMutableArrayRef Mutable;
  const __CFArray *v12;
  NSUserDefaults *v13;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  const void *ValueAtIndex;
  const void *v19;
  const __CFData *v20;
  const __CFData *v21;
  const __CFData *v22;
  const __CFString *v23;
  const __CFData *v24;
  const __CFData *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  CFTypeID TypeID;
  const void *Value;
  const __CFData *v30;
  const void *v31;
  unsigned int v32;
  __CFDictionary *v33;
  void *v34;
  void *v35;
  const __CFData *v36;
  void *v37;
  void *v38;
  void *v39;
  const __CFArray *v40;
  const __CFArray *v41;
  CFIndex v42;
  uint64_t v43;
  uint64_t v44;
  const __CFArray *v45;
  int v46;
  int v47;
  CFIndex v48;
  const __CFDictionary **v49;
  const __CFDictionary **v50;
  const void *v51;
  uint64_t v52;
  const __CFArray *v53;
  const __CFData *v54;
  const __CFData *v55;
  const __CFString *v56;
  CFDataRef v57;
  const __CFDictionary *v58;
  const __CFDictionary *v59;
  CFTypeID v60;
  const __CFNumber *v61;
  const __CFNumber *v62;
  __CFDictionary *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  CFIndex Count;
  uint64_t v69;
  void *context;
  NSUserDefaults *v71;
  int v72;
  NSUserDefaults *v73;
  void *v74;
  void *v75;

  v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerGetPrivateMacNetworksCache", Count);
    goto LABEL_20;
  }
  if (!*(_BYTE *)(a1 + 1328))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device not yet unlocked. Not fetching network list.", "WiFiManagerGetPrivateMacNetworksCache", Count);
    goto LABEL_20;
  }
  v3 = *(const __CFArray **)(a1 + 352);
  if (v3 && CFArrayGetCount(v3))
  {
    v4 = objc_autoreleasePoolPush();
    v5 = qword_10026DD20;
    if (qword_10026DD20)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 352));
      v6 = "%s:  WFMacRandomisation : Fetched %ld known networks from the cache";
LABEL_13:
      v10 = (void *)v5;
LABEL_19:
      objc_msgSend(v10, "WFLog:message:", 3, v6, "WiFiManagerGetPrivateMacNetworksCache", Count);
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 1096));
  v7 = sub_10001D90C((_QWORD *)a1, CFSTR("List of scanned networks with private mac"));
  v8 = *(const void **)(a1 + 352);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 352) = 0;
  }
  if (v7)
  {
    v9 = sub_100064608(v7);
    *(_QWORD *)(a1 + 352) = v9;
    if (v9)
    {
      *(CFAbsoluteTime *)(a1 + 368) = CFAbsoluteTimeGetCurrent();
      v4 = objc_autoreleasePoolPush();
      v5 = qword_10026DD20;
      if (qword_10026DD20)
      {
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 352));
        v6 = "%s: WFMacRandomisation : Fetched %ld known networks from the plist";
        goto LABEL_13;
      }
LABEL_20:
      objc_autoreleasePoolPop(v4);
    }
  }
  else
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(a1 + 352) = Mutable;
    if (Mutable)
    {
      v4 = objc_autoreleasePoolPush();
      v10 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v6 = "%s: WFMacRandomisation : No networks present in plist. Create empty array";
        goto LABEL_19;
      }
      goto LABEL_20;
    }
  }
  if (*(_BYTE *)(a1 + 360))
  {
    v12 = *(const __CFArray **)(a1 + 352);
    if (v12)
    {
      if (CFArrayGetCount(v12))
      {
        v13 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
        v14 = *(const __CFArray **)(a1 + 352);
        if (v14)
        {
          v71 = v13;
          v15 = CFArrayGetCount(v14);
          v16 = v15;
          if (v15)
          {
            v74 = v2;
            if (v15 < 1)
            {
              v72 = 0;
            }
            else
            {
              v17 = 0;
              v72 = 0;
              do
              {
                ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 352), v17);
                if (ValueAtIndex)
                {
                  v19 = ValueAtIndex;
                  v20 = (const __CFData *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("RotationKeyUsed"));
                  v21 = *(const __CFData **)(a1 + 416);
                  v22 = *(const __CFData **)(a1 + 488);
                  v23 = (const __CFString *)sub_10002B088(v19);
                  if (v20)
                    v24 = v20;
                  else
                    v24 = 0;
                  v25 = sub_1000CE52C(v21, v24, v22, v23);
                  if (v25)
                  {
                    v26 = (const __CFDictionary *)sub_10002BE64((uint64_t)v19, CFSTR("PRIVATE_MAC_ADDRESS"));
                    if (v26)
                    {
                      v27 = v26;
                      TypeID = CFDictionaryGetTypeID();
                      if (TypeID == CFGetTypeID(v27))
                      {
                        Value = CFDictionaryGetValue(v27, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
                        v30 = (const __CFData *)CFDictionaryGetValue(v27, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"));
                        v31 = CFDictionaryGetValue(v27, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"));
                        v32 = sub_10002B75C(v30);
                        if (Value)
                        {
                          if (v32)
                          {
                            v33 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                            if (v30 && !sub_1000BB3E4(v30, v25))
                            {
                              sub_10002C478((uint64_t)v19, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
                              v72 = 1;
                            }
                            else if (v31)
                            {
                              CFDictionarySetValue(v33, CFSTR("PRIVATE_MAC_ADDRESS_IN_USE"), v31);
                              v34 = objc_autoreleasePoolPush();
                              if (qword_10026DD20)
                                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Sanitized network <%@> updated in use address %@", "__WiFiManagerSanitizePrivateMacNetworks", sub_10002B088(v19), v31);
                              objc_autoreleasePoolPop(v34);
                            }
                            CFDictionarySetValue(v33, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), Value);
                            CFDictionarySetValue(v33, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v25);
                            sub_10002C478((uint64_t)v19, CFSTR("PRIVATE_MAC_ADDRESS"), v33);
                            v37 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Sanitized network <%@> to use static MAC [%@]", "__WiFiManagerSanitizePrivateMacNetworks", sub_10002B088(v19), v25);
                          }
                          else
                          {
                            if (v30)
                            {
                              v36 = *(const __CFData **)(a1 + 488);
                              if (v36)
                              {
                                if (!sub_1000BB3E4(v30, v36))
                                {
                                  sub_10002C478((uint64_t)v19, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
                                  v72 = 1;
                                }
                              }
                            }
                            v33 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                            CFDictionarySetValue(v33, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), Value);
                            CFDictionarySetValue(v33, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), *(const void **)(a1 + 488));
                            sub_10002C478((uint64_t)v19, CFSTR("PRIVATE_MAC_ADDRESS"), v33);
                            v37 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Sanitized network <%@> to make sure correct physical MAC is used", "__WiFiManagerSanitizePrivateMacNetworks", sub_10002B088(v19), v69);
                          }
                          objc_autoreleasePoolPop(v37);
                          if (v33)
                            CFRelease(v33);
                        }
                        if (sub_10002BE64((uint64_t)v19, CFSTR("PrivateMacFutureMacAddress")))
                          sub_10002C478((uint64_t)v19, CFSTR("PrivateMacFutureMacAddress"), v25);
                      }
                    }
                    CFRelease(v25);
                  }
                  else
                  {
                    v35 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "WFMacRandomisation :%s: Unable to generate a static MAC. Will fail sanitization", "__WiFiManagerSanitizePrivateMacNetworks");
                    objc_autoreleasePoolPop(v35);
                  }
                }
                ++v17;
              }
              while (v16 != v17);
            }
            sub_1000A46A8(a1, *(const __CFArray **)(a1 + 352));
            sub_1000A485C(a1, 1, 0);
            v2 = v74;
            v13 = v71;
            LODWORD(v16) = v72;
          }
          else
          {
            v13 = v71;
          }
        }
        else
        {
          LODWORD(v16) = 0;
        }
        *(_BYTE *)(a1 + 360) = 0;
        if (v13)
          -[NSUserDefaults setValue:forKey:](v13, "setValue:forKey:", &__kCFBooleanTrue, CFSTR("PrivateMacListCloudRestoreSanitized"));
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Sanitized Private Mac plist", "WiFiManagerGetPrivateMacNetworksCache");
        objc_autoreleasePoolPop(v38);
        if ((_DWORD)v16)
        {
          *(_BYTE *)(a1 + 362) = 1;
          sub_100087488((_QWORD *)a1, CFSTR("PrivateMacForcedDisassocPending"), kCFBooleanTrue, 0);
          v39 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : This private MAC sanitization is because of private MAC data migration from a different device", "WiFiManagerGetPrivateMacNetworksCache");
          objc_autoreleasePoolPop(v39);
        }
      }
    }
  }
  if (*(_BYTE *)(a1 + 361))
  {
    v40 = *(const __CFArray **)(a1 + 352);
    if (v40)
    {
      if (CFArrayGetCount(v40))
      {
        v41 = *(const __CFArray **)(a1 + 352);
        if (v41)
        {
          v42 = CFArrayGetCount(v41);
          if (v42)
          {
            v43 = v42;
            v73 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
            v44 = sub_10008674C(a1);
            if (v43 >= 1)
            {
              v45 = (const __CFArray *)v44;
              v46 = 0;
              v47 = 0;
              v48 = 0;
              v75 = (void *)v43;
              do
              {
                v49 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 352), v48);
                if (v49)
                {
                  v50 = v49;
                  if (v45)
                  {
                    v51 = sub_10002B634(v45, v49);
                    if (v51)
                    {
                      v52 = (uint64_t)v51;
                      if ((_os_feature_enabled_impl("WiFiManager", "PrivateMacAirPlayNetwork") & 1) != 0
                        || -[NSUserDefaults BOOLForKey:](v73, "BOOLForKey:", CFSTR("PrivateMACAirplayNetworkEnabled")))
                      {
                        v47 = sub_100007828(v52);
                      }
                      if (sub_1000CEDAC(v52))
                        v46 = 1;
                    }
                  }
                  if (v47 | v46)
                  {
                    v53 = v45;
                    v54 = *(const __CFData **)(a1 + 416);
                    v55 = *(const __CFData **)(a1 + 488);
                    v56 = (const __CFString *)sub_10002B088(v50);
                    v57 = sub_1000CE7A0(v54, v55, v56);
                    CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                    v58 = (const __CFDictionary *)sub_10002BE64((uint64_t)v50, CFSTR("PRIVATE_MAC_ADDRESS"));
                    if (v58)
                    {
                      v59 = v58;
                      v60 = CFDictionaryGetTypeID();
                      if (v60 == CFGetTypeID(v59))
                      {
                        v61 = (const __CFNumber *)CFDictionaryGetValue(v59, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
                        if (v61)
                        {
                          v62 = v61;
                          if (sub_100064F80(v61) == 2)
                          {
                            v63 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                            CFDictionarySetValue(v63, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v62);
                            CFDictionarySetValue(v63, CFSTR("PRIVATE_MAC_ADDRESS_VALUE"), v57);
                            sub_10002C478((uint64_t)v50, CFSTR("PRIVATE_MAC_ADDRESS"), v63);
                            v64 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                            {
                              context = v64;
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation :%s: Temp network <%@> gets new mac address: %@", "__WiFiManagerPrivateMacUpdateTempNetworks", sub_10002B088(v50), v57);
                              v64 = context;
                            }
                            objc_autoreleasePoolPop(v64);
                            if (v63)
                              CFRelease(v63);
                            if (sub_10002BE64((uint64_t)v50, CFSTR("PrivateMacFutureMacAddress")))
                              sub_10002C478((uint64_t)v50, CFSTR("PrivateMacFutureMacAddress"), v57);
                            sub_10002C478((uint64_t)v50, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
                          }
                        }
                      }
                    }
                    v45 = v53;
                    if (v57)
                      CFRelease(v57);
                    v43 = (uint64_t)v75;
                  }
                  else
                  {
                    v47 = 0;
                    v46 = 0;
                  }
                }
                ++v48;
              }
              while (v43 != v48);
            }
            sub_1000A46A8(a1, *(const __CFArray **)(a1 + 352));
            sub_1000A485C(a1, 1, 0);
          }
        }
        *(_BYTE *)(a1 + 361) = 0;
        v65 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Temp networks updated with new MAC address", "WiFiManagerGetPrivateMacNetworksCache");
        objc_autoreleasePoolPop(v65);
      }
    }
  }
  v66 = *(_QWORD *)(a1 + 352);
  objc_autoreleasePoolPop(v2);
  return v66;
}

void sub_100087FE4(uint64_t a1)
{
  _QWORD v1[4];

  if (a1)
  {
    v1[0] = a1;
    v1[1] = 0xAAAAAAAA0000006ELL;
    v1[2] = 0;
    v1[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v1);
  }
}

void sub_10008802C(uint64_t a1)
{
  double v2;
  double Current;
  double v4;
  const __CFDate *v5;
  NSUserDefaults *v6;
  __int128 v7;
  const __SCPreferences *v8;
  const __CFDate *v9;
  double AbsoluteTime;
  CFTypeID v11;
  double v12;
  void *v13;
  void *v14;
  const void *v15;
  CFDataRef v16;
  const __CFArray *v17;
  void *v18;
  double v19;
  const __CFArray *v20;
  CFIndex Count;
  CFIndex v22;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v25;
  CFTypeID v26;
  const void *v27;
  const __CFBoolean *v28;
  const __CFBoolean *v29;
  const __CFBoolean *v30;
  const __CFDate *v31;
  const __CFDate *v32;
  const __CFNumber *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  CFTypeID TypeID;
  const __CFNumber *v37;
  double v38;
  unint64_t v39;
  _BOOL4 v40;
  void *v41;
  const __CFData *v42;
  const __CFData *v43;
  const __CFData *v44;
  const __CFString *v45;
  CFDataRef v46;
  __CFDictionary *MutableCopy;
  CFNumberRef v48;
  void *v49;
  void *v50;
  void *v51;
  const void *v52;
  CFIndex v53;
  const __CFDictionary **v54;
  const __CFDictionary **v55;
  CFTypeID v56;
  const __CFDate *v57;
  const __CFDate *v58;
  const __CFBoolean *v59;
  const void *v60;
  const __CFBoolean *v61;
  _BOOL4 v62;
  double v63;
  const __CFBoolean *v64;
  const __CFDate *v66;
  double v67;
  const __CFDictionary *v68;
  const __CFData *v69;
  const __CFNumber *Value;
  unsigned int v71;
  const __CFData *v72;
  const __CFString *v73;
  CFDataRef v74;
  void *v75;
  void *v76;
  double v77;
  const __CFData *v78;
  const __CFData *v79;
  const __CFString *v80;
  const __CFData *v81;
  const __CFString *v82;
  void *v83;
  const __CFString *v84;
  const __CFData *v85;
  const __CFData *v86;
  const __CFString *v87;
  CFMutableDictionaryRef v88;
  void *v89;
  unsigned int v90;
  void *v91;
  double v92;
  const void *v93;
  void *v94;
  CFDateRef v95;
  CFDateRef v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  _BOOL4 v100;
  CFDataRef v101;
  const void *v102;
  char v103;
  const __CFDate *v104;
  CFDateRef cf;
  int v106;
  uint64_t v107;
  const __CFArray *v108;
  unsigned int v109;
  const __CFArray *theArray;
  CFIndex v111;
  _OWORD bytes[2];

  v2 = *(double *)(a1 + 504);
  Current = CFAbsoluteTimeGetCurrent();
  v4 = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(kCFAllocatorDefault, v4);
  v6 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  if ((_os_feature_enabled_impl("WiFiManager", "PrivateMacAirPlayNetwork") & 1) != 0)
    v109 = 1;
  else
    v109 = -[NSUserDefaults BOOLForKey:](v6, "BOOLForKey:", CFSTR("PrivateMACAirplayNetworkEnabled"));
  v103 = _os_feature_enabled_impl("WiFiManager", "PrivateMacRotation");
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v7;
  bytes[1] = v7;
  if (v5)
  {
    v8 = sub_10001D90C((_QWORD *)a1, CFSTR("RotationKeyDateMacRandomisation"));
    v9 = v8;
    AbsoluteTime = 0.0;
    if (v8)
    {
      v11 = CFGetTypeID(v8);
      if (v11 == CFDateGetTypeID())
        AbsoluteTime = CFDateGetAbsoluteTime(v9);
    }
    v12 = CFDateGetAbsoluteTime(v5);
    if (v12 > 0.0 && AbsoluteTime > 0.0 && v12 - AbsoluteTime >= (double)*(int *)(a1 + 392))
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : rotation Key being updated. Last generated time : <%@>", "__WiFiManagerPrivateMacProcessRotationKey", v9);
      objc_autoreleasePoolPop(v13);
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
      {
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: Failed to generate rotation Key for mac randomisation", "__WiFiManagerPrivateMacProcessRotationKey", v98);
      }
      else
      {
        v15 = *(const void **)(a1 + 408);
        if (v15)
        {
          CFRelease(v15);
          *(_QWORD *)(a1 + 408) = 0;
        }
        v16 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)bytes, 32);
        *(_QWORD *)(a1 + 408) = v16;
        sub_100087488((_QWORD *)a1, CFSTR("RotationKeyMacRandomisation"), v16, 0);
        sub_100087488((_QWORD *)a1, CFSTR("RotationKeyDateMacRandomisation"), v5, 0);
        v14 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : rotation : new rotation key  : %@", "__WiFiManagerPrivateMacProcessRotationKey", *(_QWORD *)(a1 + 408));
      }
      objc_autoreleasePoolPop(v14);
    }
  }
  if (*(_QWORD *)(a1 + 352)
    && (v17 = (const __CFArray *)sub_1000875B0(a1)) != 0
    && (theArray = v17, (v111 = CFArrayGetCount(v17)) != 0))
  {
    v108 = (const __CFArray *)sub_10008674C(a1);
    v18 = sub_10009FEE0((const __CFArray *)a1);
    v19 = CFAbsoluteTimeGetCurrent();
    v104 = v5;
    cf = CFDateCreate(kCFAllocatorDefault, v19);
    v107 = a1;
    v102 = v18;
    v100 = *(_BYTE *)(a1 + 528)
        && -[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted");
    v20 = theArray;
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v22 = Count;
      for (i = 0; v22 != i; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v20, i);
        if (ValueAtIndex)
        {
          v25 = ValueAtIndex;
          v26 = CFGetTypeID(ValueAtIndex);
          if (v26 == sub_1000C312C())
          {
            sub_10002BE64((uint64_t)v25, CFSTR("IsOpenNetwork"));
            if (*(_BYTE *)(v107 + 376))
            {
              v27 = sub_10002B088(v25);
              v28 = (const __CFBoolean *)sub_10002BE64((uint64_t)v25, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
              v29 = (const __CFBoolean *)sub_10002BE64((uint64_t)v25, CFSTR("NetworkUsedForSWUpgrade"));
              if (v28)
              {
                if (v28 == kCFBooleanTrue)
                {
                  v30 = v29;
                  v31 = (const __CFDate *)sub_10002BE64((uint64_t)v25, CFSTR("PrivateMacJoinDateAfterUpgrade"));
                  if (v31)
                  {
                    v32 = v31;
                    v33 = sub_100017A54((uint64_t)v25, CFSTR("MacAddressRandomisationClassificationAttempts"));
                    if (!(_DWORD)v33)
                    {
                      v50 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated Network <%@> ran out of assoc attempts", "__WiFiManagerPrivateMacProcessMigratedNetworks", v27);
                      objc_autoreleasePoolPop(v50);
                      v51 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated Network <%@> no more tagged as migrated ", "__WiFiManagerPrivateMacProcessMigratedNetworks", v27);
                      objc_autoreleasePoolPop(v51);
                      sub_10002C478((uint64_t)v25, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
                      sub_10002C478((uint64_t)v25, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
                      sub_10002C478((uint64_t)v25, CFSTR("PrivateMacClassifyInterval"), 0);
                      sub_10002C478((uint64_t)v25, CFSTR("PrivateMacJoinDateAfterUpgrade"), 0);
                      continue;
                    }
                    v34 = (const __CFDictionary *)sub_10002BE64((uint64_t)v25, CFSTR("PRIVATE_MAC_ADDRESS"));
                    if (v34 && (v35 = v34, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v35)))
                    {
                      v37 = sub_100017A54((uint64_t)v25, CFSTR("PrivateMacClassifyInterval"));
                      v38 = CFDateGetAbsoluteTime(v32);
                      if (sub_10002BE64((uint64_t)v25, CFSTR("PrivateMacFutureMacAddress")))
                        continue;
                      v39 = 86400;
                      if (v37)
                        v39 = (unint64_t)v37;
                      if (v19 - v38 <= (double)v39)
                      {
                        v40 = v100;
                        if (!v30)
                          v40 = 0;
                        if (!v40 || v30 != kCFBooleanTrue)
                          continue;
                      }
                      v41 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Classification : Elapsed an Interval or early attempt for setup network. Generating private MAC. Migrated Network <%@> associated at : <%@> after upgrading. Num assoc attempts pending = <%d>", "__WiFiManagerPrivateMacProcessMigratedNetworks", v27, v32, v33);
                      objc_autoreleasePoolPop(v41);
                      v42 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(v107 + 480), 6);
                      v44 = *(const __CFData **)(v107 + 408);
                      v43 = *(const __CFData **)(v107 + 416);
                      v45 = (const __CFString *)sub_10002B088(v25);
                      v46 = sub_1000CE52C(v43, v44, v42, v45);
                      sub_10002C478((uint64_t)v25, CFSTR("RotationKeyUsed"), *(const void **)(v107 + 408));
                      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v35);
                      v48 = sub_100064FE0(1);
                      CFDictionarySetValue(MutableCopy, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"), v48);
                      if (v48)
                        CFRelease(v48);
                      sub_10002C478((uint64_t)v25, CFSTR("PrivateMacFutureMacAddress"), v46);
                      sub_10002C478((uint64_t)v25, CFSTR("NetworkUsedForSWUpgrade"), 0);
                      if (v46)
                        CFRelease(v46);
                      v20 = theArray;
                      if (v42)
                        CFRelease(v42);
                      sub_10002C478((uint64_t)v25, CFSTR("PRIVATE_MAC_ADDRESS"), MutableCopy);
                      if (MutableCopy)
                        CFRelease(MutableCopy);
                      sub_10002C478((uint64_t)v25, CFSTR("MacGenerationTimeStamp"), cf);
                      sub_10002C478((uint64_t)v25, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
                      sub_10002C478((uint64_t)v25, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
                      v49 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated Network <%@> retrying private mac address", "__WiFiManagerPrivateMacProcessMigratedNetworks", v27, v99);
                    }
                    else
                    {
                      v49 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : Migrated Network <%@> associated at : <%@> after upgrading. Private Mac Dict not present", "__WiFiManagerPrivateMacProcessMigratedNetworks", v27, v32);
                    }
                    objc_autoreleasePoolPop(v49);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (cf)
      CFRelease(cf);
    if (v111 >= 1)
    {
      v106 = 0;
      v52 = 0;
      v53 = 0;
      while (1)
      {
        v54 = (const __CFDictionary **)CFArrayGetValueAtIndex(v20, v53);
        if (!v54 || (v55 = v54, v56 = CFGetTypeID(v54), v56 != sub_1000C312C()))
        {
          v5 = v104;
          v93 = v102;
          goto LABEL_145;
        }
        if (v108)
          v52 = sub_10002B634(v108, v55);
        v57 = (const __CFDate *)sub_10002BE64((uint64_t)v55, CFSTR("LinkDownTimestamp"));
        v58 = (const __CFDate *)sub_10002BE64((uint64_t)v55, CFSTR("lastUpdated"));
        v59 = (const __CFBoolean *)sub_10002BE64((uint64_t)v55, CFSTR("MacAddressRandomisationTagMigratedNetwork"));
        v60 = sub_10002BE64((uint64_t)v55, CFSTR("BlockRotation"));
        v61 = (const __CFBoolean *)sub_10002BE64((uint64_t)v55, CFSTR("PresentInKnownNetworks"));
        if (v109)
          v106 = sub_100007828((uint64_t)v52);
        v62 = sub_1000CEDAC((uint64_t)v52);
        if (v57)
        {
          v63 = v4 - CFDateGetAbsoluteTime(v57);
          if (!v61)
            goto LABEL_98;
        }
        else
        {
          v63 = 0.0;
          if (!v61)
            goto LABEL_98;
        }
        if (v61 != kCFBooleanTrue)
        {
LABEL_98:
          if (v58)
          {
            v20 = theArray;
            if (v4 - CFDateGetAbsoluteTime(v58) > (double)*(int *)(v107 + 380))
            {
              v76 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Removing a scanned network <%@> from cache", sub_10002B088(v55));
              objc_autoreleasePoolPop(v76);
              CFArrayRemoveValueAtIndex(theArray, v53);
              v111 = CFArrayGetCount(theArray);
              --v53;
            }
            goto LABEL_130;
          }
LABEL_103:
          v20 = theArray;
          goto LABEL_130;
        }
        v64 = (const __CFBoolean *)sub_10002BE64((uint64_t)v55, CFSTR("NoAssociationWithNewMac"));
        if (v59 == kCFBooleanTrue && v59 != 0)
          goto LABEL_103;
        v20 = theArray;
        if (!v64 || v64 == kCFBooleanTrue || v60 || v64 != kCFBooleanFalse)
          goto LABEL_130;
        v66 = (const __CFDate *)sub_10002BE64((uint64_t)v55, CFSTR("FirstJoinWithNewMacTimestamp"));
        v67 = CFDateGetAbsoluteTime(v66);
        v68 = (const __CFDictionary *)sub_10002BE64((uint64_t)v55, CFSTR("PRIVATE_MAC_ADDRESS"));
        v69 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(v107 + 480), 6);
        Value = (const __CFNumber *)CFDictionaryGetValue(v68, CFSTR("PRIVATE_MAC_ADDRESS_TYPE"));
        v71 = sub_100064F80(Value);
        if (!(v106 | v62) || v71 != 2)
          break;
        if (v63 < (double)*(int *)(v107 + 400))
        {
          if (v4 - CFDateGetAbsoluteTime(v66) < (double)(7 * *(_DWORD *)(v107 + 392)))
            goto LABEL_128;
          v72 = *(const __CFData **)(v107 + 416);
          v73 = (const __CFString *)sub_10002B088(v55);
          v74 = sub_1000CE7A0(v72, v69, v73);
          sub_10002C478((uint64_t)v55, CFSTR("RotationKeyUsed"), 0);
          v75 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : public airplay/Accessory network <%@> gets new macaddress", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55));
          goto LABEL_117;
        }
        v81 = *(const __CFData **)(v107 + 416);
        v82 = (const __CFString *)sub_10002B088(v55);
        v101 = sub_1000CE7A0(v81, v69, v82);
        sub_10002C478((uint64_t)v55, CFSTR("RotationKeyUsed"), 0);
        v83 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : public airplay/Accessory network <%@> gets new macaddress after inactive [%d] period", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55), *(unsigned int *)(v107 + 400));
        objc_autoreleasePoolPop(v83);
        if (&_CNForgetSSID)
        {
          v84 = sub_10003149C(v52);
          sub_10009AA18(v84);
          v75 = objc_autoreleasePoolPush();
          v74 = v101;
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : forgetSSID called for network <%@>", sub_10002B088(v52), v98);
          goto LABEL_117;
        }
        v74 = v101;
        if (!v101)
          goto LABEL_126;
LABEL_120:
        if (!v68)
        {
LABEL_126:
          if (!v74)
            goto LABEL_128;
          goto LABEL_127;
        }
        v88 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v68);
        sub_10002C478((uint64_t)v55, CFSTR("PrivateMacFutureMacAddress"), v74);
        sub_10002C478((uint64_t)v55, CFSTR("PRIVATE_MAC_ADDRESS"), v88);
        if (v88)
          CFRelease(v88);
        sub_10002C478((uint64_t)v55, CFSTR("MacGenerationTimeStamp"), v104);
        sub_10002C478((uint64_t)v55, CFSTR("ResetCaptiveProbe"), kCFBooleanTrue);
        sub_10002C478((uint64_t)v55, CFSTR("NoAssociationWithNewMac"), kCFBooleanTrue);
        v89 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : rotation Mac Address rotated for network <%@> at <%@> New address : <%@>", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55), v104, v74);
        objc_autoreleasePoolPop(v89);
        v90 = sub_100017A54((uint64_t)v55, CFSTR("TotalRotationsThisBuild"));
        sub_10002B698((uint64_t)v55, CFSTR("TotalRotationsThisBuild"), v90 + 1);
LABEL_127:
        CFRelease(v74);
LABEL_128:
        if (v69)
          goto LABEL_129;
LABEL_130:
        if (++v53 >= v111)
          goto LABEL_136;
      }
      v77 = (double)*(int *)(v107 + 396);
      if ((v103 & 1) != 0)
      {
        if (v4 - v67 < v77)
          goto LABEL_128;
        if (v71 != 2)
        {
          v91 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Mac address rotation for network <%@> not allowed.", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55));
          objc_autoreleasePoolPop(v91);
          if (!v69)
            goto LABEL_130;
LABEL_129:
          CFRelease(v69);
          goto LABEL_130;
        }
        v79 = *(const __CFData **)(v107 + 408);
        v78 = *(const __CFData **)(v107 + 416);
        v80 = (const __CFString *)sub_10002B088(v55);
        v74 = sub_1000CE52C(v78, v79, v69, v80);
        sub_10002C478((uint64_t)v55, CFSTR("RotationKeyUsed"), *(const void **)(v107 + 408));
        v75 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : network <%@> gets new macaddress", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55));
      }
      else
      {
        if (v63 < v77)
          goto LABEL_128;
        v86 = *(const __CFData **)(v107 + 408);
        v85 = *(const __CFData **)(v107 + 416);
        v87 = (const __CFString *)sub_10002B088(v55);
        v74 = sub_1000CE52C(v85, v86, v69, v87);
        sub_10002C478((uint64_t)v55, CFSTR("RotationKeyUsed"), *(const void **)(v107 + 408));
        v75 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Inactive network <%@> gets new macaddress", "__WiFiManagerPrivateMacScanDataCleanupTimerCallback", sub_10002B088(v55));
      }
LABEL_117:
      objc_autoreleasePoolPop(v75);
      if (!v74)
        goto LABEL_126;
      goto LABEL_120;
    }
LABEL_136:
    v92 = v2 + Current;
    v5 = v104;
    v93 = v102;
    if (sub_1000A46A8(v107, v20) && !sub_1000A485C(v107, 1, 0))
    {
      v94 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Scheduled cleanup complete but unable to flush private mac networks to cache %@", v104);
      objc_autoreleasePoolPop(v94);
    }
    v95 = CFDateCreate(kCFAllocatorDefault, v92);
    if (v95)
    {
      v96 = v95;
      v97 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : Private Mac scan database cleanup complete. Next scheduled cleanup check at %@", v96);
      objc_autoreleasePoolPop(v97);
      CFRelease(v96);
    }
  }
  else
  {
    v93 = 0;
  }
LABEL_145:
  if (v5)
    CFRelease(v5);
  if (v93)
    CFRelease(v93);
}

void sub_100088F84(uint64_t a1)
{
  void *v2;
  const void *v3;
  void *v4;
  _BOOL4 v5;
  const void *v6;
  const __CFString *v7;
  NSURL *v8;
  NSURLRequest *v9;
  NSURLSession *v10;
  NSURLSessionConfiguration *v11;
  NSURLSessionConfiguration *v12;
  const void *v13;
  _QWORD v14[6];
  _QWORD v15[3];
  char v16;

  v2 = objc_autoreleasePoolPush();
  v3 = *(const void **)(a1 + 472);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 472) = 0;
  }
  v4 = sub_10009FEE0((const __CFArray *)a1);
  *(_QWORD *)(a1 + 472) = v4;
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x2020000000;
  v16 = 0;
  if (v4)
  {
    v5 = sub_1000C475C((uint64_t)v4);
    v6 = *(const void **)(a1 + 472);
    if (v6)
    {
      if (*(_QWORD *)(a1 + 448))
      {
        v7 = (const __CFString *)sub_10002B088(v6);
        if (CFStringCompare(v7, *(CFStringRef *)(a1 + 448), 0) == kCFCompareEqualTo && !v5)
        {
          v8 = +[NSURL URLWithString:](NSURL, "URLWithString:", CFSTR("https://captive.apple.com"));
          if (v8)
          {
            v9 = +[NSURLRequest requestWithURL:cachePolicy:timeoutInterval:](NSURLRequest, "requestWithURL:cachePolicy:timeoutInterval:", v8, 1, 1.6);
            if (v9)
            {
              v10 = *(NSURLSession **)(a1 + 520);
              if (v10)
                goto LABEL_13;
              v11 = +[NSURLSessionConfiguration ephemeralSessionConfiguration](NSURLSessionConfiguration, "ephemeralSessionConfiguration");
              v12 = v11;
              if (v11)
              {
                -[NSURLSessionConfiguration setRequestCachePolicy:](v11, "setRequestCachePolicy:", 1);
                -[NSURLSessionConfiguration setTimeoutIntervalForRequest:](v12, "setTimeoutIntervalForRequest:", 1.6);
                -[NSURLSessionConfiguration setTimeoutIntervalForResource:](v12, "setTimeoutIntervalForResource:", 1.6);
                -[NSURLSessionConfiguration setHTTPMaximumConnectionsPerHost:](v12, "setHTTPMaximumConnectionsPerHost:", 1);
                -[NSURLSessionConfiguration setAllowsCellularAccess:](v12, "setAllowsCellularAccess:", 0);
                v10 = +[NSURLSession sessionWithConfiguration:](NSURLSession, "sessionWithConfiguration:", v12);
                *(_QWORD *)(a1 + 520) = v10;
                if (v10)
                {
LABEL_13:
                  v14[0] = _NSConcreteStackBlock;
                  v14[1] = 3221225472;
                  v14[2] = sub_1000BB2F8;
                  v14[3] = &unk_100230C10;
                  v14[4] = v15;
                  v14[5] = a1;
                  -[NSURLSessionDataTask resume](-[NSURLSession dataTaskWithRequest:completionHandler:](v10, "dataTaskWithRequest:completionHandler:", v9, v14), "resume");
                  objc_msgSend(*(id *)(a1 + 520), "resetWithCompletionHandler:", &stru_100230C30);
                }
              }
            }
          }
        }
      }
    }
  }
  v13 = *(const void **)(a1 + 448);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 448) = 0;
  }
  _Block_object_dispose(v15, 8);
  objc_autoreleasePoolPop(v2);
}

void sub_100089154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100089178(uint64_t a1)
{
  void *v2;
  void *v3;
  const char *v4;
  void *v5;
  uint64_t context;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_DWORD *)(a1 + 952) == 2)
  {
    context = a1;
    v7 = 0xAAAAAAAA00000030;
    v8 = 0;
    v9 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    if ((_BYTE)v9 || sub_100092B74(a1))
    {
      v2 = objc_autoreleasePoolPush();
      v3 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        context = a1;
        v7 = 0xAAAAAAAA00000030;
        v8 = 0;
        v9 = 0;
        CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
        if ((_BYTE)v9)
          v4 = "WoW";
        else
          v4 = "LPAS";
        objc_msgSend(v3, "WFLog:message:", 3, "%s Enabled, Skip Disassocation", v4);
      }
      objc_autoreleasePoolPop(v2);
      *(_DWORD *)(a1 + 952) = 0;
    }
    else
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation timer fired.  Disassociating.");
      objc_autoreleasePoolPop(v5);
      *(_DWORD *)(a1 + 952) = 3;
      sub_1000094BC(a1, 0);
      sub_10008A2B8(a1, "__WiFiManagerDisassociationTimerCallback", 12788);
    }
  }
}

void sub_1000892BC(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  dispatch_time_t v4;
  _QWORD v5[4];

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Diagnostics timer fired. Diagnosing.");
  objc_autoreleasePoolPop(v2);
  if (*(uint64_t *)(a1 + 1888) >= 1)
  {
    v3 = *(NSObject **)(a1 + 1872);
    v4 = dispatch_time(0, (uint64_t)(*(double *)(a1 + 1880) * 1000000000.0));
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
  v5[0] = a1;
  v5[1] = 0xAAAAAAAA00000015;
  v5[2] = 0;
  v5[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v5);
}

void sub_10008937C(uint64_t a1)
{
  void *v2;
  void *v3;
  _QWORD v4[5];

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (objc_opt_class(FBSDisplayLayoutMonitor))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 3221225472;
      v4[2] = sub_10001EF38;
      v4[3] = &unk_100230A78;
      v4[4] = a1;
      *(_QWORD *)(a1 + 1936) = objc_msgSend(objc_alloc((Class)FBSDisplayLayoutMonitor), "initWithDisplayType:handler:", 0, v4);
    }
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is Null!", "__WiFiManagerTrackFrontBoardDisplayState");
    objc_autoreleasePoolPop(v3);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_100089454(uint64_t a1)
{
  void *v2;

  kdebug_trace(731381780, 0, 0, 0, 0);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: did not connect to Carplay network. Reverting to regular mode", "__WiFiManagerCarplayTimeout");
  objc_autoreleasePoolPop(v2);
  sub_10009FB18(a1, 0, 0);
}

void sub_1000894DC(uint64_t a1)
{
  void *v2;
  int v3;
  const __CFArray *v4;
  const __CFArray *v5;
  const void *ValueAtIndex;
  void *v7;
  void *v8;
  const void *v9;
  void *v10;
  _QWORD v11[2];
  _QWORD context[3];
  uint64_t v13;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: did not connect to companion network in time. Reverting to regular mode, companion RSSI %d, Channel %d", "__WiFiManagerCompanionAssistedAJTimeout", *(unsigned int *)(a1 + 1584), *(unsigned int *)(a1 + 1588));
  objc_autoreleasePoolPop(v2);
  v11[0] = *(_QWORD *)(a1 + 1568);
  v11[1] = *(_QWORD *)(a1 + 1584);
  sub_1000618C4((uint64_t)v11, 0);
  if (*(_BYTE *)(a1 + 2203))
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000032;
    context[2] = 0;
    v13 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    v3 = *(_DWORD *)(a1 + 1584);
    if ((_BYTE)v13)
    {
      if (v3 <= -56)
        goto LABEL_23;
    }
    else if (v3 < -55 || *(int *)(a1 + 1588) > 14)
    {
      goto LABEL_23;
    }
    v4 = sub_10000B29C((CFArrayRef)a1);
    v5 = v4;
    if (v4 && CFArrayGetCount(v4))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v5, 0);
      v7 = objc_autoreleasePoolPush();
      if (ValueAtIndex)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Gizmo didn't join Companion's network, triggering CoreCapture", "__WiFiManagerCompanionAssistedAJTimeout");
        objc_autoreleasePoolPop(v7);
        sub_10011835C((uint64_t)ValueAtIndex, CFSTR("TriggerCoreCapture"));
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: device manager is null", "__WiFiManagerCompanionAssistedAJTimeout");
        objc_autoreleasePoolPop(v7);
      }
LABEL_22:
      CFRelease(v5);
      goto LABEL_23;
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid device managers info", "__WiFiManagerCompanionAssistedAJTimeout");
    objc_autoreleasePoolPop(v8);
    if (v5)
      goto LABEL_22;
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: corecaptureOnAssistedAJFailure not enabled", "__WiFiManagerCompanionAssistedAJTimeout");
    objc_autoreleasePoolPop(v10);
  }
LABEL_23:
  if (*(_BYTE *)(a1 + 2104) == 1)
  {
    sub_1000094BC(a1, 1);
  }
  else
  {
    *(_BYTE *)(a1 + 1560) = 0;
    sub_10009F7C8(a1, 0, 0);
    v9 = *(const void **)(a1 + 1568);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 1568) = 0;
    }
    sub_10008488C((uint64_t)v9, 2, a1);
    sub_10008674C(a1);
    sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
  }
}

void sub_100089750(const void **a1)
{
  void *v2;
  const void *v3;
  int v4;
  void *v5;
  uint64_t v6;
  const char *v7;
  void *v8;
  const void *v9;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disassociation timer fired", "__WiFiManagerSessionBasedDisassociationTimerCallback");
  objc_autoreleasePoolPop(v2);
  if (!a1)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager is null", "__WiFiManagerSessionBasedDisassociationTimerCallback", v9);
    goto LABEL_12;
  }
  v3 = a1[207];
  if (!v3)
  {
    v5 = objc_autoreleasePoolPush();
    v8 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_12;
    v7 = "%s: session based network is null";
    goto LABEL_11;
  }
  v4 = sub_1000954F8((const __CFArray *)a1, v3);
  v5 = objc_autoreleasePoolPush();
  v6 = qword_10026DD20;
  if (!v4)
  {
    if (!qword_10026DD20)
    {
LABEL_12:
      objc_autoreleasePoolPop(v5);
      goto LABEL_13;
    }
    v9 = sub_10002B088(a1[207]);
    v7 = "%s: no longer associated to %@, not disassociating";
    v8 = (void *)v6;
LABEL_11:
    objc_msgSend(v8, "WFLog:message:", 3, v7, "__WiFiManagerSessionBasedDisassociationTimerCallback", v9);
    goto LABEL_12;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: diassociating to %@ application is no longer active", "__WiFiManagerSessionBasedDisassociationTimerCallback", sub_10002B088(a1[207]));
  objc_autoreleasePoolPop(v5);
  sub_10008A2B8((uint64_t)a1, "__WiFiManagerSessionBasedDisassociationTimerCallback", 16774);
LABEL_13:
  sub_1000B6A48((uint64_t)a1);
}

void sub_1000898A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  int v10;
  void *v11;
  unsigned int v12;
  _BOOL4 v14;
  void *v15;
  const __CFString *v16;
  const __CFString *v17;
  void *v18;
  NSObject *CTGreenTeaOsLogHandle;
  NSObject *v20;
  const char *v21;
  const void **v22;
  __CFDictionary *Mutable;
  CFNumberRef v24;
  const void *v25;
  const void *v26;
  void *v27;
  id v28;
  unsigned int v29;
  void *v30;
  void *v31;
  NSData *v32;
  NSData *v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  NSDate *v38;
  const void *v39;
  void *v40;
  void *v41;
  const __CFArray *v42;
  CFIndex Count;
  CFIndex v44;
  CFTypeID v45;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  const __CFArray *v48;
  CFIndex v49;
  CFIndex v50;
  CFIndex i;
  CFMutableDictionaryRef *v52;
  unsigned int v53;
  unsigned int v54;
  void *v55;
  void *v56;
  void *v57;
  id v58;
  void *v59;
  _QWORD context[5];
  unsigned int v61;
  int valuePtr;
  _BYTE buf[22];
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  CFRange v70;

  valuePtr = a3;
  v8 = objc_autoreleasePoolPush();
  v9 = sub_10009FEE0((const __CFArray *)a1);
  if (!a1)
  {
    v27 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifiManagerRef is NULL!", "WiFiManagerSetUserAutoJoinState");
    goto LABEL_52;
  }
  v61 = 0;
  v10 = *(unsigned __int8 *)(a1 + 1954);
  v11 = objc_autoreleasePoolPush();
  if (v10 == (_DWORD)a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: current state is already %d", "WiFiManagerSetUserAutoJoinState", a2);
    objc_autoreleasePoolPop(v11);
    v12 = a3 - 1;
    v14 = (_DWORD)a3 == 8 || v12 < 3;
    if ((_DWORD)a2 && v14)
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v12 > 7)
          v16 = CFSTR("Unknown");
        else
          v16 = off_100230C50[v12];
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: checking for networks disabled due to trigger %@ (%d)", "WiFiManagerSetUserAutoJoinState", v16, a3);
      }
      objc_autoreleasePoolPop(v15);
      sub_100090EFC(a1);
      sub_100091914(a1, 1u);
      goto LABEL_109;
    }
    if ((_DWORD)a2 || !v9)
      goto LABEL_109;
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: state is disabled while connected to network %@", "WiFiManagerSetUserAutoJoinState", v9);
    objc_autoreleasePoolPop(v18);
    sub_10008A2B8(a1, "WiFiManagerSetUserAutoJoinState", 22827);
LABEL_49:
    if (sub_10003036C((_QWORD *)a1, CFSTR("UserAutoJoinAutomaticEnablingDisabled"), 0))
    {
      v27 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: automatic re-enabling is disabled", "WiFiManagerSetUserAutoJoinState");
LABEL_52:
      objc_autoreleasePoolPop(v27);
      goto LABEL_109;
    }
    if (objc_msgSend(*(id *)(a1 + 1696), "isAuthorized"))
    {
      v28 = objc_msgSend(*(id *)(a1 + 1696), "latestLocation");
      v29 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v28, 1, 60.0);
      v30 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: location update %@ isValid %d", "WiFiManagerSetUserAutoJoinState", v28, v29 != 0);
      objc_autoreleasePoolPop(v30);
      if (v29)
      {
        v31 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabled location for user auto join", "WiFiManagerSetUserAutoJoinState");
        objc_autoreleasePoolPop(v31);
        *(_QWORD *)(a1 + 1960) = objc_msgSend(v28, "copy");
        *(_WORD *)(a1 + 1952) = 0;
        v32 = +[NSKeyedArchiver archivedDataWithRootObject:](NSKeyedArchiver, "archivedDataWithRootObject:", v28);
        if (v32)
        {
          v33 = v32;
          sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisabledLoc"), v32, 0);
          sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinLocationMetric"), v33, 0);
        }
        else
        {
          v36 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to create archive of location", "WiFiManagerSetUserAutoJoinState");
          objc_autoreleasePoolPop(v36);
        }
      }
      else
      {
        v61 = 1;
        v35 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: requesting high accuracy location", "WiFiManagerSetUserAutoJoinState");
        objc_autoreleasePoolPop(v35);
        *(_BYTE *)(a1 + 1952) = 1;
        objc_msgSend(*(id *)(a1 + 1696), "requestHighAccuracyLocationUpdate");
      }
    }
    else
    {
      v34 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifi not authroized for location services", "WiFiManagerSetUserAutoJoinState");
      objc_autoreleasePoolPop(v34);
      *(_BYTE *)(a1 + 1953) = 1;
      v61 = 2;
    }
    v37 = objc_alloc_init((Class)NSDate);
    v38 = sub_1000649A4((uint64_t)v37, 5, 0, 0);
    sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisableTimestamp"), v38, 0);
    v39 = *(const void **)(a1 + 1968);
    if (v39)
      CFRelease(v39);
    *(_QWORD *)(a1 + 1968) = v38;
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: date to enable user auto join: %@", "WiFiManagerSetUserAutoJoinState", v38);
    objc_autoreleasePoolPop(v40);
    if (!v9)
      goto LABEL_107;
    v41 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: connected to %@, disabling network from auto join until %@", "WiFiManagerSetUserAutoJoinState", sub_10002B088(v9), v38);
    objc_autoreleasePoolPop(v41);
    v42 = *(const __CFArray **)(a1 + 216);
    if (v42)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 216));
      if (Count)
      {
        v44 = Count;
        v45 = CFGetTypeID(v9);
        if (v45 == sub_1000C312C())
        {
          v70.location = 0;
          v70.length = v44;
          FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v42, v70, v9);
          if (FirstIndexOfValue != -1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), FirstIndexOfValue);
            if (sub_100007F24((uint64_t)ValueAtIndex))
            {
              v58 = v37;
              v59 = v8;
              sub_1000C682C((uint64_t)v9, v38);
              sub_1000C68E8((CFMutableDictionaryRef *)v9, 0, CFSTR("UserAutoJoin"));
              sub_100099EA4(a1, v9, 1u);
              v48 = *(const __CFArray **)(a1 + 224);
              v49 = CFArrayGetCount(v48);
              if (v49 >= 1)
              {
                v50 = v49;
                for (i = 0; i != v50; ++i)
                {
                  v52 = (CFMutableDictionaryRef *)CFArrayGetValueAtIndex(v48, i);
                  v53 = sub_1000C3F88((uint64_t)v52);
                  v54 = sub_1000CBE60((uint64_t)v52);
                  if (sub_10002BE64((uint64_t)v52, CFSTR("WiFiNetworkAttributeIsPublic"))
                    && (objc_msgSend(v9, "isEqual:", v52) & 1) == 0
                    && !sub_1000C5C14((uint64_t)v52)
                    && v53 != 1
                    && v54 != 1)
                  {
                    v55 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: disabling network %@ from auto join until %@", "WiFiManagerSetUserAutoJoinState", v52, v38);
                    objc_autoreleasePoolPop(v55);
                    sub_1000C682C((uint64_t)v52, v38);
                    sub_1000C68E8(v52, 0, CFSTR("UserAutoJoin"));
                    sub_100099EA4(a1, v52, 1u);
                  }
                }
              }
              sub_100090EFC(a1);
              v37 = v58;
              v8 = v59;
              goto LABEL_107;
            }
            v56 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s network has auto join disabled, skipping disabled until date", "WiFiManagerSetUserAutoJoinState");
LABEL_106:
            objc_autoreleasePoolPop(v56);
LABEL_107:
            if (v37)
              CFRelease(v37);
            goto LABEL_109;
          }
        }
        else
        {
          v57 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid network ref", "__GetNetworkIndices");
          objc_autoreleasePoolPop(v57);
        }
      }
    }
    v56 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: couldn't find matching known network", "WiFiManagerSetUserAutoJoinState");
    goto LABEL_106;
  }
  if (qword_10026DD20)
  {
    if ((a3 + 1) > 9)
      v17 = CFSTR("Unknown");
    else
      v17 = off_100230C90[(int)a3 + 1];
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join state %d trigger %@ (%d)", "WiFiManagerSetUserAutoJoinState", a2, v17, a3);
  }
  objc_autoreleasePoolPop(v11);
  if (a4)
  {
    if (*(_QWORD *)(a1 + 2056))
    {
      CTGreenTeaOsLogHandle = getCTGreenTeaOsLogHandle();
      if (CTGreenTeaOsLogHandle)
      {
        v20 = CTGreenTeaOsLogHandle;
        if (os_log_type_enabled(CTGreenTeaOsLogHandle, OS_LOG_TYPE_INFO))
        {
          v21 = "yes";
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = a4;
          *(_QWORD *)&buf[14] = "com.apple.wifi.manager";
          *(_WORD *)&buf[12] = 2080;
          if (!(_DWORD)a2)
            v21 = "no";
          v64 = 2080;
          v65 = "wifid";
          v66 = 2080;
          v67 = "WiFiManagerSetUserAutoJoinState";
          v68 = 2080;
          v69 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "<%@>[%s][%s]:[%s]WLAN enabled..%s", buf, 0x34u);
        }
      }
    }
  }
  v22 = (const void **)&kCFBooleanFalse;
  if ((_DWORD)a2)
    v22 = (const void **)&kCFBooleanTrue;
  sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinState"), *v22, 0);
  *(_BYTE *)(a1 + 1954) = a2;
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000047;
  context[2] = &valuePtr;
  context[3] = &v61;
  context[4] = a2;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, CFSTR("trigger"), v24);
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&buf[8] = Mutable;
  buf[0] = a2;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000BAB08, buf);
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendUserAutoJoinStateDidChangeEvent");
  if (v24)
    CFRelease(v24);
  if (Mutable)
    CFRelease(Mutable);
  if (!(_DWORD)a2)
    goto LABEL_49;
  sub_100030300((_QWORD *)a1, CFSTR("UserAutoJoinLocStateMetric"), v61);
  if (!objc_msgSend(*(id *)(a1 + 1696), "isAuthorized"))
    v61 = 2;
  *(_WORD *)(a1 + 1952) = 0;
  v25 = *(const void **)(a1 + 1960);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a1 + 1960) = 0;
  }
  v26 = *(const void **)(a1 + 1968);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 1968) = 0;
  }
  sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisableTimestamp"), 0, 0);
  sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisabledLoc"), 0, 0);
  if (valuePtr != 4)
    sub_100091914(a1, 1u);
  sub_100030300((_QWORD *)a1, CFSTR("UserAutoJoinSecurityTypeMetric"), 0);
LABEL_109:
  if (v9)
    CFRelease(v9);
  objc_autoreleasePoolPop(v8);
}

void sub_10008A2B8(uint64_t a1, const char *a2, uint64_t a3)
{
  void *v6;
  const char *v7;
  _QWORD context[4];

  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v7 = "";
    if (a2)
      v7 = a2;
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "asked to Disassociate by <%s:%d> \n", v7, a3);
  }
  objc_autoreleasePoolPop(v6);
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000000ELL;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
}

void sub_10008A35C(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Posting hardware failure status in WiFiManagerCreate");
  objc_autoreleasePoolPop(v2);
  sub_10008A3AC(*(_QWORD **)(a1 + 32));
}

void sub_10008A3AC(_QWORD *a1)
{
  unsigned int v1;
  id v2;
  _QWORD v3[4];
  unsigned int v4;

  v1 = sub_100092CE0(a1);
  if (objc_opt_class(SystemHealthManager))
  {
    v2 = objc_alloc_init((Class)SystemHealthManager);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100092D6C;
    v3[3] = &unk_1002307C8;
    v4 = v1;
    objc_msgSend(v2, "postComponentStatusEventFor:status:withReply:", 3, v1, v3);
    if (v2)
      CFRelease(v2);
  }
}

uint64_t sub_10008A43C(uint64_t a1, int a2)
{
  void *v4;
  unsigned __int8 v5;
  uint64_t v6;
  void *v7;
  _QWORD context[3];
  uint64_t v10;
  int v11;

  v11 = a2;
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiManagerOpen");
  objc_autoreleasePoolPop(v4);
  if (a1)
  {
    v5 = 1;
    if (!*(_BYTE *)(a1 + 16))
    {
      *(_BYTE *)(a1 + 16) = 1;
      *(_DWORD *)(a1 + 20) = a2;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000000;
      context[2] = &v11;
      v10 = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
      v6 = *(_QWORD *)(a1 + 32);
      if (v6)
        sub_10008A540(a1, v6);
      v7 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiManagerOpen");
      objc_autoreleasePoolPop(v7);
      return v10;
    }
  }
  else
  {
    return 0;
  }
  return v5;
}

void sub_10008A540(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v9;
  _BOOL8 v10;
  void *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  WiFiBatteryManager *v17;
  void *v18;
  const char *v19;
  SCDynamicStoreRef v20;
  IONotificationPortRef v21;
  IONotificationPort *v22;
  const __CFDictionary *v23;
  IONotificationPort *v24;
  const __CFDictionary *v25;
  IONotificationPort *v26;
  const __CFDictionary *v27;
  uint64_t v28;
  IONotificationPort *v29;
  const __CFDictionary *v30;
  CFMutableDictionaryRef v31;
  void *v32;
  CFMutableDictionaryRef v33;
  void *v34;
  IONotificationPort *v35;
  const __CFDictionary *v36;
  uint64_t v37;
  io_connect_t v38;
  void *v39;
  NSObject *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  NSObject *v54;
  NSObject *v55;
  NSObject *v56;
  NSObject *v57;
  double v58;
  uint64_t v59;
  uint64_t v60;
  NSNumber *v61;
  const __SCPreferences *v62;
  NSObject *v63;
  id v64;
  void *v65;
  void *v66;
  const char *v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[5];
  _QWORD v73[5];
  _QWORD v74[5];
  _QWORD v75[5];
  _QWORD v76[5];
  _QWORD v77[5];
  _QWORD v78[4];
  _QWORD v79[5];
  _QWORD v80[5];
  _QWORD v81[5];
  _QWORD v82[5];
  _QWORD v83[5];
  _QWORD v84[5];
  _QWORD handler[5];
  _QWORD block[5];
  SCDynamicStoreContext context;
  _QWORD v88[4];

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiManagerScheduleWithQueue");
  objc_autoreleasePoolPop(v5);
  if (a1)
  {
    *(_QWORD *)(a1 + 32) = a2;
    sub_1000645FC(a2);
    if (*(_BYTE *)(a1 + 16))
    {
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "setWiFiManager:", a1);
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "activate");
      objc_msgSend(*(id *)(a1 + 1104), "activate");
      sub_10008674C(a1);
      sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
      *(_BYTE *)(a1 + 88) = sub_1000DA92C(*(_QWORD *)(a1 + 80), a2);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : DEBUG buddy completed check is done. result is : <%hhu>", "WiFiManagerScheduleWithQueue", -[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"));
      objc_autoreleasePoolPop(v6);
      if (-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted")&& !*(_BYTE *)(a1 + 528)&& MKBUserUnlockedSinceBoot(0) == 1)
      {
        *(_BYTE *)(a1 + 528) = 1;
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : kWiFiPrivateMacFirstUnlockAfterSWUpgrade is : <%hhu>", "WiFiManagerScheduleWithQueue", *(unsigned __int8 *)(a1 + 528));
        objc_autoreleasePoolPop(v7);
      }
      objc_msgSend(*(id *)(a1 + 1696), "registerCallbackFunctionPtr:withContext:", sub_10008BF4C, a1);
      if (*(_DWORD *)(a1 + 112) != 7)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10008C108;
        block[3] = &unk_10022EA38;
        block[4] = a1;
        dispatch_async((dispatch_queue_t)qword_10026DD40, block);
      }
      -[WiFiManagerAnalytics setWiFiManagerQueue:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "setWiFiManagerQueue:", *(_QWORD *)(a1 + 32));
      objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "setWiFiManager:", a1);
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(DarwinNotifyCenter, (const void *)a1, (CFNotificationCallback)sub_10008C5A4, CFSTR("com.apple.mobile.keybagd.lock_status"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      sub_10008C6C0(a1);
      if (objc_opt_class(FAFamilyCircle))
      {
        v9 = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterAddObserver(v9, (const void *)a1, (CFNotificationCallback)sub_10008C824, FAFamilyUpdateNotification, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      }
      if (MKBUserUnlockedSinceBoot(0))
        v10 = MKBGetDeviceLockState(0) == 1;
      else
        v10 = 1;
      sub_10008C888(a1, v10, 1);
      sub_10007FDD8((_QWORD *)a1);
      v12 = *(NSObject **)(a1 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_10008D018;
      handler[3] = &unk_1002306E8;
      handler[4] = a1;
      notify_register_dispatch("com.apple.MCX._managementStatusChangedForDomains", (int *)(a1 + 904), v12, handler);
      sub_10015B5B8();
      v13 = *(NSObject **)(a1 + 32);
      v84[0] = _NSConcreteStackBlock;
      v84[1] = 3221225472;
      v84[2] = sub_10008D028;
      v84[3] = &unk_1002306E8;
      v84[4] = a1;
      notify_register_dispatch("com.apple.iokit.hid.displayStatus", (int *)(a1 + 856), v13, v84);
      sub_10008D03C(a1, 1);
      v14 = *(NSObject **)(a1 + 32);
      v83[0] = _NSConcreteStackBlock;
      v83[1] = 3221225472;
      v83[2] = sub_10008D2F0;
      v83[3] = &unk_1002306E8;
      v83[4] = a1;
      notify_register_dispatch("com.apple.symptoms.celloutrankrecommendation", (int *)(a1 + 2304), v14, v83);
      if (!notify_is_valid_token(*(_DWORD *)(a1 + 2304)))
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to notify_register_dispatch com.apple.symptoms.celloutrankrecommendation");
        objc_autoreleasePoolPop(v15);
      }
      sub_10008D2FC(a1, 1);
      v16 = objc_autoreleasePoolPush();
      v17 = -[WiFiBatteryManager initWithContext:]([WiFiBatteryManager alloc], "initWithContext:", a1);
      *(_QWORD *)(a1 + 2312) = v17;
      v18 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v17)
          v19 = "%s: WiFiBatteryMgmt batteryManager alloced and inited ";
        else
          v19 = "%s: WiFiBatteryMgmt No Battery Power Manager support from CoreOS. WiFi will default to full throttle.";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, v19, "WiFiManagerScheduleWithQueue");
      }
      objc_autoreleasePoolPop(v18);
      objc_autoreleasePoolPop(v16);
      context.version = 0;
      memset(&context.retain, 0, 24);
      context.info = (void *)a1;
      v20 = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("WiFiManager"), (SCDynamicStoreCallBack)sub_1000AF380, &context);
      *(_QWORD *)(a1 + 72) = v20;
      if (v20)
      {
        sub_1000AF618(a1);
        if (SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 72), *(dispatch_queue_t *)(a1 + 32)))
        {
          if (SCDynamicStoreSetDisconnectCallBack(*(_QWORD *)(a1 + 72), sub_1000AF6C4))
          {
            sub_1000AF380(*(const __SCDynamicStore **)(a1 + 72), 0, (const __CFArray *)a1);
            if (!*(_QWORD *)(a1 + 960))
            {
              v21 = IONotificationPortCreate(dword_10026D688);
              *(_QWORD *)(a1 + 960) = v21;
              if (!v21)
              {
                v68 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: IONotificationPortCreate failed", "WiFiManagerScheduleWithQueue", v71);
                goto LABEL_141;
              }
              v22 = v21;
              v23 = (const __CFDictionary *)CFRetain(&off_100253F58);
              if (IOServiceAddMatchingNotification(v22, "IOServiceMatched", v23, (IOServiceMatchingCallback)sub_10008D46C, (void *)a1, (io_iterator_t *)(a1 + 968)))
              {
                v68 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: IOServiceAddMatchingNotification IO80211SkywalkInterface failed", "WiFiManagerScheduleWithQueue", v71);
                goto LABEL_141;
              }
              sub_10008D46C(a1, *(_DWORD *)(a1 + 968));
              v24 = *(IONotificationPort **)(a1 + 960);
              v25 = IOServiceMatching("IOPMPowerSource");
              if (IOServiceAddMatchingNotification(v24, "IOServiceFirstMatch", v25, (IOServiceMatchingCallback)sub_10008D554, (void *)a1, (io_iterator_t *)(a1 + 976)))
              {
                v68 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: IOServiceAddMatchingNotification IOPMPowerSource failed", "WiFiManagerScheduleWithQueue", v71);
                goto LABEL_141;
              }
              sub_10008D554(a1, *(_DWORD *)(a1 + 976));
              if (sub_10008D5F4(a1))
              {
                v26 = *(IONotificationPort **)(a1 + 960);
                v27 = IOServiceMatching("IOUSBDevice");
                v28 = IOServiceAddMatchingNotification(v26, "IOServiceFirstPublish", v27, (IOServiceMatchingCallback)sub_10008D664, (void *)a1, (io_iterator_t *)(a1 + 1000));
                if ((_DWORD)v28
                  || (sub_10008D664(a1, *(_DWORD *)(a1 + 1000)),
                      v29 = *(IONotificationPort **)(a1 + 960),
                      v30 = IOServiceMatching("IOUSBDevice"),
                      v28 = IOServiceAddMatchingNotification(v29, "IOServiceTerminate", v30, (IOServiceMatchingCallback)sub_10008D9BC, (void *)a1, (io_iterator_t *)(a1 + 1004)), (_DWORD)v28))
                {
                  v69 = v28;
                  v68 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Usb Host Notification IOServiceAddMatchingNotification for device insertion failed (0x%x)\n", "WiFiManagerScheduleWithQueue", v69);
                  goto LABEL_141;
                }
                sub_10008D9BC(a1, *(_DWORD *)(a1 + 1004));
                v31 = IOServiceMatching("IOPortTransportState");
                v32 = (id)CFMakeCollectable(v31);
                objc_msgSend(v32, "setObject:forKey:", &off_100254070, CFSTR("IOPropertyMatch"));
                v33 = IOServiceMatching("IOPort");
                v34 = (id)CFMakeCollectable(v33);
                objc_msgSend(v34, "setObject:forKey:", &off_100253FF8, CFSTR("IOPropertyMatch"));
                objc_msgSend(v32, "setObject:forKey:", v34, CFSTR("IOParentMatch"));
                v35 = *(IONotificationPort **)(a1 + 960);
                if (v32)
                  v36 = (const __CFDictionary *)CFRetain(v32);
                else
                  v36 = 0;
                v37 = IOServiceAddMatchingNotification(v35, "IOServiceMatched", v36, (IOServiceMatchingCallback)sub_10008DE80, (void *)a1, (io_iterator_t *)(a1 + 1008));
                if ((_DWORD)v37)
                {
                  v70 = v37;
                  v68 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IOServiceAddMatchingNotification failed: %08x", "WiFiManagerScheduleWithQueue", v70);
                  goto LABEL_141;
                }
                sub_10008DE80(a1, *(_DWORD *)(a1 + 1008));
              }
            }
            if (!*(_QWORD *)(a1 + 1016))
            {
              v38 = IORegisterForSystemPower((void *)a1, (IONotificationPortRef *)(a1 + 1016), (IOServiceInterestCallback)sub_10008E240, (io_object_t *)(a1 + 1024));
              *(_DWORD *)(a1 + 1028) = v38;
              if (!v38)
              {
                v39 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: IORegisterForSystemPower failed", "WiFiManagerScheduleWithQueue");
                objc_autoreleasePoolPop(v39);
              }
            }
            if (*(_DWORD *)(a1 + 1028) && *(_QWORD *)(a1 + 1016))
            {
              IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 960), *(dispatch_queue_t *)(a1 + 32));
              IONotificationPortSetDispatchQueue(*(IONotificationPortRef *)(a1 + 1016), *(dispatch_queue_t *)(a1 + 32));
            }
            v40 = *(NSObject **)(a1 + 920);
            if (v40)
              dispatch_activate(v40);
            v41 = *(NSObject **)(a1 + 1872);
            if (v41)
              dispatch_activate(v41);
            *(_QWORD *)(a1 + 1864) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            *(_QWORD *)(a1 + 1896) = CFStringCreateWithCString(kCFAllocatorDefault, "www.apple.com", 1u);
            *(_OWORD *)(a1 + 1904) = xmmword_1001BB5D0;
            *(_QWORD *)(a1 + 1920) = 0x4008000000000000;
            if (SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1072), *(dispatch_queue_t *)(a1 + 32)))
            {
              if (SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1080), *(dispatch_queue_t *)(a1 + 32)))
              {
                if (SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1096), *(dispatch_queue_t *)(a1 + 32)))
                {
                  if (SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1088), *(dispatch_queue_t *)(a1 + 32)))
                  {
                    if (&_BTSessionAttachWithQueue)
                    {
                      context.version = (CFIndex)sub_10008E708;
                      v42 = BTSessionAttachWithQueue("com.apple.wifi.manager", &context, a1, qword_10026DD40);
                      if ((_DWORD)v42)
                      {
                        v43 = v42;
                        v44 = objc_autoreleasePoolPush();
                        if (qword_10026DD20)
                          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Unable to attach to Mobile Bluetooth result=0x%X", "WiFiManagerScheduleWithQueue", v43);
                        objc_autoreleasePoolPop(v44);
                      }
                    }
                    v45 = *(void **)(a1 + 2520);
                    if (v45)
                    {
                      v82[0] = _NSConcreteStackBlock;
                      v82[1] = 3221225472;
                      v82[2] = sub_10008EA88;
                      v82[3] = &unk_10022EA38;
                      v82[4] = a1;
                      objc_msgSend(v45, "setImsRegistrationStatusChangedHandler:", v82);
                      v46 = *(void **)(a1 + 2520);
                      v81[0] = _NSConcreteStackBlock;
                      v81[1] = 3221225472;
                      v81[2] = sub_10008EB4C;
                      v81[3] = &unk_10022EA38;
                      v81[4] = a1;
                      objc_msgSend(v46, "setCellularDataStatusChangedHandler:", v81);
                      v47 = *(void **)(a1 + 2520);
                      v80[0] = _NSConcreteStackBlock;
                      v80[1] = 3221225472;
                      v80[2] = sub_10008EB54;
                      v80[3] = &unk_10022EA38;
                      v80[4] = a1;
                      objc_msgSend(v47, "setCellularFallbackStatusChangedHandler:", v80);
                    }
                    else if (&CTTelephonyCenterGetDefault)
                    {
                      v79[0] = _NSConcreteStackBlock;
                      v79[1] = 3221225472;
                      v79[2] = sub_10008EB5C;
                      v79[3] = &unk_10022EA38;
                      v79[4] = a1;
                      dispatch_async((dispatch_queue_t)qword_10026DD40, v79);
                    }
                    v78[0] = a1;
                    v78[1] = 0xAAAAAAAA00000002;
                    v78[2] = 0;
                    v78[3] = 1;
                    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v78);
                    if (*(_DWORD *)(a1 + 316) == 1)
                    {
                      v48 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: registering with coex manager", "WiFiManagerScheduleWithQueue");
                      objc_autoreleasePoolPop(v48);
                      sub_100178D40(a1);
                    }
                    v49 = *(NSObject **)(a1 + 1336);
                    if (v49)
                      dispatch_activate(v49);
                    v50 = *(NSObject **)(a1 + 1360);
                    if (v50)
                      dispatch_activate(v50);
                    v51 = *(NSObject **)(a1 + 2352);
                    if (v51)
                      dispatch_activate(v51);
                    if (&CTTelephonyCenterGetDefault)
                    {
                      sub_100040A5C(a1, (uint64_t)-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"));
                      sub_100040204(a1, (uint64_t)-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"));
                      sub_1000408E0(a1, (uint64_t)-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"));
                    }
                    sub_100167264(*(_QWORD *)(a1 + 1448), (uint64_t)sub_10008ECAC, a1);
                    sub_100166FF8(*(_QWORD *)(a1 + 1448), *(_QWORD *)(a1 + 32));
                    objc_msgSend(*(id *)(a1 + 1480), "scheduleWithQueue:", *(_QWORD *)(a1 + 32));
                    sub_10008ED74(a1);
                    v52 = *(NSObject **)(a1 + 1488);
                    if (v52)
                      dispatch_activate(v52);
                    v53 = *(NSObject **)(a1 + 1536);
                    if (v53)
                      dispatch_activate(v53);
                    v54 = *(NSObject **)(a1 + 1576);
                    if (v54)
                      dispatch_activate(v54);
                    v55 = *(NSObject **)(a1 + 496);
                    if (v55)
                      dispatch_activate(v55);
                    v56 = *(NSObject **)(a1 + 1680);
                    if (v56)
                      dispatch_activate(v56);
                    v57 = *(NSObject **)(a1 + 432);
                    if (v57)
                      dispatch_activate(v57);
                    *(_QWORD *)(a1 + 1728) = -[WiFiSoftErrorManager initWithWiFiManager:queue:]([WiFiSoftErrorManager alloc], "initWithWiFiManager:queue:", a1, *(_QWORD *)(a1 + 32));
                    *(_QWORD *)(a1 + 1736) = sub_10008EE78((_QWORD *)a1, (uint64_t)CFSTR("SlowWiFi"));
                    *(_QWORD *)(a1 + 1744) = sub_10008EE78((_QWORD *)a1, (uint64_t)CFSTR("Dps"));
                    *(_QWORD *)(a1 + 1760) = sub_10008EE78((_QWORD *)a1, (uint64_t)CFSTR("CountryCode"));
                    *(_QWORD *)(a1 + 1768) = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithString:", &stru_100238178);
                    v58 = sub_10008EF8C((_QWORD *)a1, CFSTR("SoftErrorUIReportingTimeout"), 86400.0);
                    if (sub_10016737C()
                      || objc_msgSend(*(id *)(a1 + 1120), "containsObject:", CFSTR("wlan.dk=1")))
                    {
                      v59 = 200;
                      v60 = 12;
                    }
                    else
                    {
                      v59 = 100;
                      v60 = 2;
                    }
                    if (v58 < 0.0)
                      v58 = 86400.0;
                    v88[0] = CFSTR("maxUIActions");
                    context.version = (CFIndex)+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v60);
                    v88[1] = CFSTR("intervalForMaxUIActions");
                    context.info = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v58);
                    v88[2] = CFSTR("maxOccurrences");
                    v61 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v59);
                    v88[3] = CFSTR("metricSubmissionSamplingRate");
                    context.retain = (const void *(__cdecl *)(const void *))v61;
                    context.release = (void (__cdecl *)(const void *))&off_100252D38;
                    *(_QWORD *)(a1 + 1840) = objc_msgSend(objc_alloc((Class)WiFiSoftError), "initWithName:andParams:", CFSTR("Dext Crashed"), +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &context, v88, 4));
                    *(_QWORD *)(a1 + 2544) = sub_10008EE78((_QWORD *)a1, (uint64_t)CFSTR("Missing Password"));
                    *(_QWORD *)(a1 + 1776) = +[WiFiDriverTriggeredTTR sharedWiFiDriverTriggeredTTRManagerwithStringRef:withInterval:](WiFiDriverTriggeredTTR, "sharedWiFiDriverTriggeredTTRManagerwithStringRef:withInterval:", CFSTR("Driver triggered TTR"), sub_10008EF8C((_QWORD *)a1, CFSTR("SoftErrorUIReportingTimeout"), 86400.0));
                    objc_msgSend(*(id *)(a1 + 2000), "scheduleWithQueue:", *(_QWORD *)(a1 + 32));
                    objc_msgSend(*(id *)(a1 + 2000), "scheduleHistoricNetworkPerformanceFeedSync");
                    objc_msgSend(*(id *)(a1 + 2000), "schedule3BarsObserver");
                    objc_msgSend(*(id *)(a1 + 2000), "scheduleOutdatedListEntriesCleanUp");
                    objc_msgSend(*(id *)(a1 + 2000), "scheduleWCADownloadObserver");
                    v77[0] = _NSConcreteStackBlock;
                    v77[1] = 3221225472;
                    v77[2] = sub_10008EFF8;
                    v77[3] = &unk_10022EA38;
                    v77[4] = a1;
                    dispatch_async((dispatch_queue_t)qword_10026DD40, v77);
                    *(_QWORD *)(a1 + 56) = sub_1000D4BD0(a1, *(_QWORD *)(a1 + 32), (uint64_t)sub_10008F15C);
                    if (*(_DWORD *)(a1 + 112) == 1)
                    {
                      *(_QWORD *)(a1 + 64) = +[WiFiManagerCarSessionMonitor sharedInstance](WiFiManagerCarSessionMonitor, "sharedInstance");
                      v76[0] = _NSConcreteStackBlock;
                      v76[1] = 3221225472;
                      v76[2] = sub_1000264FC;
                      v76[3] = &unk_10022EA38;
                      v76[4] = a1;
                      dispatch_async((dispatch_queue_t)qword_10026DD40, v76);
                    }
                    v62 = sub_10001D90C((_QWORD *)a1, CFSTR("LocaleTestParams"));
                    sub_10008F28C(a1, v62);
                    *(_BYTE *)(a1 + 2404) = 0;
                    *(_DWORD *)(a1 + 2400) = -1;
                    *(_QWORD *)(a1 + 2424) = 0;
                    *(_QWORD *)(a1 + 2440) = 0;
                    *(_BYTE *)(a1 + 2432) = 0;
                    v63 = *(NSObject **)(a1 + 32);
                    v75[0] = _NSConcreteStackBlock;
                    v75[1] = 3221225472;
                    v75[2] = sub_10000BAB8;
                    v75[3] = &unk_1002306E8;
                    v75[4] = a1;
                    notify_register_dispatch("com.apple.bluetooth.low-power-mode", (int *)(a1 + 2400), v63, v75);
                    if (!byte_10026DD60 && objc_opt_class(WiFiSmartCoverStateObserver))
                    {
                      v74[0] = _NSConcreteStackBlock;
                      v74[1] = 3221225472;
                      v74[2] = sub_10008FB58;
                      v74[3] = &unk_10022EA38;
                      v74[4] = a1;
                      dispatch_async((dispatch_queue_t)qword_10026DD40, v74);
                    }
                    -[WiFiUserInteractionMonitor registerStateChangeCallback:withCallbackContext:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "registerStateChangeCallback:withCallbackContext:", &stru_100230708, a1);
                    objc_msgSend(*(id *)(a1 + 192), "determineAndSetLocale:", 0);
                    if (_os_feature_enabled_impl("CoreWiFi", "NDD"))
                    {
                      v64 = objc_alloc_init((Class)CWFNearbyDeviceDiscoveryManager);
                      *(_QWORD *)(a1 + 1792) = v64;
                      if (v64)
                      {
                        v73[0] = _NSConcreteStackBlock;
                        v73[1] = 3221225472;
                        v73[2] = sub_100090348;
                        v73[3] = &unk_100230728;
                        v73[4] = a1;
                        objc_msgSend(v64, "setIsNDDAllowed:", v73);
                        v72[0] = _NSConcreteStackBlock;
                        v72[1] = 3221225472;
                        v72[2] = sub_100090404;
                        v72[3] = &unk_100230748;
                        v72[4] = a1;
                        objc_msgSend(*(id *)(a1 + 1792), "setSendNDDRequest:", v72);
                        objc_msgSend(*(id *)(a1 + 1792), "setSendNDDXPCEvent:", &stru_100230788);
                      }
                    }
                    goto LABEL_111;
                  }
                  v68 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesSetDispatchQueue preferences.radios failed", "WiFiManagerScheduleWithQueue", v71);
                }
                else
                {
                  v68 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SCPreferencesSetDispatchQueue preferences.wifiPrivateMacNetworks failed", "WiFiManagerScheduleWithQueue", v71);
                }
              }
              else
              {
                v68 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesSetDispatchQueue preferences.wifiNetworks failed", "WiFiManagerScheduleWithQueue", v71);
              }
            }
            else
            {
              v68 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: SCPreferencesSetDispatchQueue preferences.wifi failed", "WiFiManagerScheduleWithQueue", v71);
            }
LABEL_141:
            objc_autoreleasePoolPop(v68);
LABEL_111:
            v11 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiManagerScheduleWithQueue");
            goto LABEL_113;
          }
          v65 = objc_autoreleasePoolPush();
          v66 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
          {
LABEL_121:
            objc_autoreleasePoolPop(v65);
            sub_100090708(a1);
            v68 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Error: __WiFiManagerRegisterDynamicStore failed", "WiFiManagerScheduleWithQueue", v71);
            goto LABEL_141;
          }
          v67 = "Error subscribing to the dynamic store disconnect event.";
        }
        else
        {
          v65 = objc_autoreleasePoolPush();
          v66 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_121;
          v67 = "Error setting dynamic store queue.";
        }
      }
      else
      {
        v65 = objc_autoreleasePoolPush();
        v66 = (void *)qword_10026DD20;
        if (!qword_10026DD20)
          goto LABEL_121;
        v67 = "Error creating dynamic store.";
      }
      objc_msgSend(v66, "WFLog:message:", 4, v67);
      goto LABEL_121;
    }
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: not open", "WiFiManagerScheduleWithQueue");
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: manager NULL", "WiFiManagerScheduleWithQueue");
  }
LABEL_113:
  objc_autoreleasePoolPop(v11);
  objc_autoreleasePoolPop(v4);
}

void sub_10008B628(uint64_t a1, int a2)
{
  const void *v3;
  _QWORD context[4];
  int v5;

  v5 = a2;
  if (a1)
  {
    v3 = *(const void **)(a1 + 32);
    if (v3)
      sub_10008B698(a1, v3);
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000011;
    context[2] = &v5;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    *(_BYTE *)(a1 + 16) = 0;
  }
}

void sub_10008B698(uint64_t a1, const void *a2)
{
  void *v4;
  void *v5;
  const void *v6;
  __CTServerConnection *v7;
  __CTServerConnection *v8;
  __CTServerConnection *v9;
  void *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  int v22;
  int v23;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v25;
  __CFNotificationCenter *v26;
  const void *v27;
  void *v28;
  _QWORD block[5];
  _QWORD context[4];

  v4 = objc_autoreleasePoolPush();
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: entering", "WiFiManagerUnscheduleFromQueue");
  objc_autoreleasePoolPop(v5);
  if (a1)
  {
    if (a2 && (v6 = *(const void **)(a1 + 32)) != 0)
    {
      if (CFEqual(v6, a2))
      {
        sub_1000DA9E0(*(_QWORD *)(a1 + 80));
        objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "invalidate");
        objc_msgSend(*(id *)(a1 + 1104), "invalidate");
        context[0] = a1;
        context[1] = 0xAAAAAAAA00000010;
        context[2] = 0;
        context[3] = 1;
        CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
        if (-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection")&& &CTTelephonyCenterGetDefault)
        {
          v7 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
          _CTServerConnectionUnregisterForNotification(v7, kCTRegistrationDataStatusChangedNotification);
          v8 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
          _CTServerConnectionUnregisterForNotification(v8, kCTRegistrationDisplayStatusChangedNotification);
          v9 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
          _CTServerConnectionUnregisterForNotification(v9, kCTCarrierSettingsNewCarrierNotification);
        }
        v10 = *(void **)(a1 + 2520);
        if (v10)
        {
          objc_msgSend(v10, "setImsRegistrationStatusChangedHandler:", 0);
          objc_msgSend(*(id *)(a1 + 2520), "setCellularDataStatusChangedHandler:", 0);
          objc_msgSend(*(id *)(a1 + 2520), "setCellularFallbackStatusChangedHandler:", 0);
        }
        SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1088), 0);
        SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1080), 0);
        SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1096), 0);
        SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 1072), 0);
        *(_QWORD *)(a1 + 1032) = 0;
        sub_10015B8E0();
        v11 = *(NSObject **)(a1 + 1680);
        if (v11)
          dispatch_source_cancel(v11);
        v12 = *(NSObject **)(a1 + 496);
        if (v12)
          dispatch_source_cancel(v12);
        v13 = *(NSObject **)(a1 + 432);
        if (v13)
          dispatch_source_cancel(v13);
        objc_msgSend(*(id *)(a1 + 520), "invalidateAndCancel");

        v14 = *(NSObject **)(a1 + 1576);
        if (v14)
          dispatch_source_cancel(v14);
        v15 = *(NSObject **)(a1 + 1536);
        if (v15)
          dispatch_source_cancel(v15);
        v16 = *(NSObject **)(a1 + 1488);
        if (v16)
          dispatch_source_cancel(v16);
        v17 = *(NSObject **)(a1 + 1336);
        if (v17)
          dispatch_source_cancel(v17);
        v18 = *(NSObject **)(a1 + 1872);
        if (v18)
          dispatch_source_cancel(v18);
        v19 = *(NSObject **)(a1 + 920);
        if (v19)
          dispatch_source_cancel(v19);
        v20 = *(NSObject **)(a1 + 1360);
        if (v20)
          dispatch_source_cancel(v20);
        v21 = *(NSObject **)(a1 + 2352);
        if (v21)
          dispatch_source_cancel(v21);
        v22 = *(_DWORD *)(a1 + 856);
        if (v22)
          notify_cancel(v22);
        v23 = *(_DWORD *)(a1 + 904);
        if (v23)
          notify_cancel(v23);
        sub_100090708(a1);
        if (*(_DWORD *)(a1 + 1028))
        {
          IODeregisterForSystemPower((io_object_t *)(a1 + 1028));
          IOServiceClose(*(_DWORD *)(a1 + 1028));
          *(_DWORD *)(a1 + 1028) = 0;
        }
        DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterRemoveObserver(DarwinNotifyCenter, 0, CFSTR("SignificantTimeChangeNotification"), 0);
        v25 = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterRemoveObserver(v25, 0, CFSTR("com.apple.mobile.keybagd.lock_status"), 0);
        if (objc_opt_class(FAFamilyCircle))
        {
          v26 = CFNotificationCenterGetDarwinNotifyCenter();
          CFNotificationCenterRemoveObserver(v26, 0, FAFamilyUpdateNotification, 0);
        }
        sub_1001790CC((xpc_object_t *)(a1 + 1320));
        if (&_WiFiCloudSyncEngineCreate)
          WiFiCloudSyncEngineUnScheduleWithQueue(*(_QWORD *)(a1 + 1304), qword_10026DD48);
        sub_1000BCDA4(*(void **)(a1 + 40));
        sub_1000D4D8C(*(void **)(a1 + 56));
        if (*(_DWORD *)(a1 + 112) == 1)
        {
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100090744;
          block[3] = &unk_10022EA38;
          block[4] = a1;
          dispatch_async((dispatch_queue_t)qword_10026DD40, block);
        }
        sub_100090780(a1);
        sub_100040F50(a1, (uint64_t)-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"));
        sub_10016722C(*(_QWORD *)(a1 + 1448));
        if (notify_is_valid_token(*(_DWORD *)(a1 + 1984)))
        {
          notify_cancel(*(_DWORD *)(a1 + 1984));
          *(_DWORD *)(a1 + 1984) = -1;
        }
        objc_msgSend(*(id *)(a1 + 1480), "unscheduleFromQueue:", *(_QWORD *)(a1 + 32));
        objc_msgSend(*(id *)(a1 + 2000), "unScheduleHistoricNetworkPerformanceFeedSync");
        objc_msgSend(*(id *)(a1 + 2000), "unSchedule3BarsObserver");
        objc_msgSend(*(id *)(a1 + 2000), "unScheduleWCADownloadObserver");
        objc_msgSend(*(id *)(a1 + 2000), "unscheduleFromQueue:", *(_QWORD *)(a1 + 32));
        objc_msgSend(*(id *)(a1 + 2112), "unscheduleFromQueue:", *(_QWORD *)(a1 + 32));
        v27 = *(const void **)(a1 + 1896);
        if (v27)
        {
          CFRelease(v27);
          *(_QWORD *)(a1 + 1896) = 0;
        }
        -[WiFiUserInteractionMonitor unregisterStateChangeCallback:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "unregisterStateChangeCallback:", a1);
        *(_QWORD *)(a1 + 32) = 0;
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting", "WiFiManagerUnscheduleFromQueue");
      }
      else
      {
        v28 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: queue mismatch", "WiFiManagerUnscheduleFromQueue");
      }
    }
    else
    {
      v28 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: no queue", "WiFiManagerUnscheduleFromQueue");
    }
  }
  else
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: exiting, Error: manager NULL", "WiFiManagerUnscheduleFromQueue");
  }
  objc_autoreleasePoolPop(v28);
  objc_autoreleasePoolPop(v4);
}

void sub_10008BB68(uint64_t a1)
{
  int v2;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  const char *v15;
  _BOOL4 v16;
  int v17;
  unsigned int valuePtr;
  _QWORD context[4];

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 2456);
    if (v2 != 2 && (v2 != 1 || *(int *)(a1 + 2460) >= 1))
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v4 = Mutable;
        valuePtr = *(_DWORD *)(a1 + 2452);
        v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        if (v5)
        {
          v6 = v5;
          CFDictionaryAddValue(v4, CFSTR("USB_HOST_NOTIFICATION_SEQUENCE_NUM"), v5);
          CFRelease(v6);
          v17 = *(_DWORD *)(a1 + 2456);
          v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v17);
          if (v7)
          {
            v8 = v7;
            CFDictionaryAddValue(v4, CFSTR("USB_HOST_NOTIFICATION_USB_CHANGE"), v7);
            CFRelease(v8);
            v16 = *(_DWORD *)(a1 + 2460) != 0;
            v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v16);
            if (v9)
            {
              v10 = v9;
              CFDictionaryAddValue(v4, CFSTR("USB_HOST_NOTIFICATION_USB_PRESENCE"), v9);
              CFRelease(v10);
              context[0] = a1;
              context[1] = 0xAAAAAAAA0000008CLL;
              context[2] = v4;
              context[3] = 1;
              CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
              v11 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification Apple80211Set: seqNum %d Total %d chg %d Presence %d \n", valuePtr, *(unsigned int *)(a1 + 2460), *(unsigned int *)(a1 + 2456), v16);
              objc_autoreleasePoolPop(v11);
              ++*(_DWORD *)(a1 + 2452);
              goto LABEL_12;
            }
            v13 = objc_autoreleasePoolPush();
            v14 = (void *)qword_10026DD20;
            if (qword_10026DD20)
            {
              v15 = "Usb Host Notification Error CFNumberCreate usbPresence\n";
              goto LABEL_23;
            }
LABEL_24:
            objc_autoreleasePoolPop(v13);
LABEL_12:
            CFRelease(v4);
            return;
          }
          v13 = objc_autoreleasePoolPush();
          v14 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_24;
          v15 = "Usb Host Notification Error CFNumberCreate usbChange\n";
        }
        else
        {
          v13 = objc_autoreleasePoolPush();
          v14 = (void *)qword_10026DD20;
          if (!qword_10026DD20)
            goto LABEL_24;
          v15 = "Usb Host Notification Error CFNumberCreate sequenceNum\n";
        }
LABEL_23:
        objc_msgSend(v14, "WFLog:message:", 4, v15);
        goto LABEL_24;
      }
      v12 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification Error creating notificationDict\n");
      objc_autoreleasePoolPop(v12);
    }
  }
}

void sub_10008BDE8(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    if (a2)
    {
      v2[0] = a1;
      v2[1] = 0xAAAAAAAA0000008CLL;
      v2[2] = a2;
      v2[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
    }
  }
}

void sub_10008BE34(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    if (a2)
    {
      v2[0] = a1;
      v2[1] = 0xAAAAAAAA0000008DLL;
      v2[2] = a2;
      v2[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
    }
  }
}

uint64_t sub_10008BE80(uint64_t a1, int a2)
{
  CFMutableArrayRef Mutable;
  const __CFArray *v4;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v6;
  uint64_t v7;
  __int16 valuePtr;

  if (!a2)
    return 0xFFFFFFFFLL;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
    return 0;
  v4 = Mutable;
  sub_10008BE34(a1, (uint64_t)Mutable);
  if (CFArrayGetCount(v4) == 2)
  {
    valuePtr = 0;
    ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v4, 0);
    CFNumberGetValue(ValueAtIndex, kCFNumberSInt8Type, (char *)&valuePtr + 1);
    v6 = (const __CFNumber *)CFArrayGetValueAtIndex(v4, 1);
    CFNumberGetValue(v6, kCFNumberSInt8Type, &valuePtr);
    v7 = ((char)valuePtr - SHIBYTE(valuePtr));
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v4);
  return v7;
}

void sub_10008BF4C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  NSObject *v11;
  _QWORD block[5];

  v7 = objc_autoreleasePoolPush();
  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: callbackType %@, error %@", "__WiFiManagerLocationManagerCallback", +[WiFiLocationManager getStringOfCallbackType:](WiFiLocationManager, "getStringOfCallbackType:", a1), objc_msgSend(a4, "userInfo"));
  objc_autoreleasePoolPop(v8);
  if (!a2)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager ref", "__WiFiManagerLocationManagerCallback");
    goto LABEL_16;
  }
  if (!a4)
  {
    if ((_DWORD)a1 == 1)
    {
      v11 = *(NSObject **)(a2 + 32);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000BA788;
      block[3] = &unk_10022EA38;
      block[4] = a2;
      dispatch_async(v11, block);
      goto LABEL_17;
    }
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ignoring callback", "__WiFiManagerLocationManagerCallback");
LABEL_16:
    objc_autoreleasePoolPop(v10);
    goto LABEL_17;
  }
  v9 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: errored %@", "__WiFiManagerLocationManagerCallback", a4);
  objc_autoreleasePoolPop(v9);
  if ((_DWORD)a1 == 3 && objc_msgSend(a4, "code") == (id)1)
    sub_1000A5BF0(a2, 0);
LABEL_17:
  objc_autoreleasePoolPop(v7);
}

void sub_10008C108(uint64_t a1)
{
  id v2;
  void *v3;

  v2 = +[WiFiAppStateManager sharedWiFiAppStateManager](WiFiAppStateManager, "sharedWiFiAppStateManager");
  if (v2)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2112) = v2;
    objc_msgSend(v2, "registerCallbackFunctionPtr:withContext:", sub_100006838);
    if (sub_10008C218(*(_QWORD *)(a1 + 32)))
    {
      objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "registerBundleCallbackFunctionPtr:withContext:", sub_10000659C);
      objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "startMonitoringBundleId:", CFSTR("com.apple.Preferences"));
    }
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "registerForegroundAppTrackerFunctionPtr:withContext:", sub_10000FF58);
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "registerAppReporterCallbackFunctionPtr:withContext:", sub_10008C284);
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "registerAppUnregistrationFunctionPtr:withContext:", sub_10008C31C);
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 2112), "scheduleWithQueue:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32));
  }
  else
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:%d manager->appStateManager is NULL ", "WiFiManagerScheduleWithQueue_block_invoke", 4808);
    objc_autoreleasePoolPop(v3);
  }
}

uint64_t sub_10008C218(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 2120);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "WiFiManagerGetAvailabilityEngineIsEnabled");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_10008C284(uint64_t a1, uint64_t a2)
{
  void *v2;
  _QWORD context[4];

  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000006CLL;
    context[2] = a2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerAppStateManagerAppReporterCallback");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_10008C31C(uint64_t a1, void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  void *ValueAtIndex;
  void *v7;
  const __CFString *v8;
  id v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  void *v14;
  void *v15;
  void *v16;
  const __CFArray *v18;
  CFIndex Count;
  CFIndex v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];

  if (a1)
  {
    v3 = sub_100090DA4(a1);
    if (v3)
    {
      v4 = v3;
      Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        v5 = 0;
        v18 = v4;
        do
        {
          v20 = v5;
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v4, v5);
          if (ValueAtIndex)
          {
            v7 = ValueAtIndex;
            v8 = (const __CFString *)sub_1000CB154((uint64_t)ValueAtIndex);
            v9 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("bundleIDs"));
            v21 = 0u;
            v22 = 0u;
            v23 = 0u;
            v24 = 0u;
            v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
            if (v10)
            {
              v11 = v10;
              v12 = *(_QWORD *)v22;
              do
              {
                for (i = 0; i != v11; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v22 != v12)
                    objc_enumerationMutation(v9);
                  if (v8
                    && CFStringCompare(v8, *(CFStringRef *)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)i), 0) == kCFCompareEqualTo
                    && sub_1000CB2D0((uint64_t)v7) == 1)
                  {
                    if (sub_1000C3F88((uint64_t)v7) && sub_1000CBE60((uint64_t)v7))
                    {
                      v14 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: can't remove network as its type Home or Work", "__WiFiAppStateManagerAppUnregisteredCallbackFunctionPtr");
                      objc_autoreleasePoolPop(v14);
                    }
                    else
                    {
                      v15 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing network", "__WiFiAppStateManagerAppUnregisteredCallbackFunctionPtr");
                      objc_autoreleasePoolPop(v15);
                      sub_100098DBC(a1, v7, (const void *)0xF);
                    }
                  }
                }
                v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
              }
              while (v11);
            }
          }
          v5 = v20 + 1;
          v4 = v18;
        }
        while (v20 + 1 != Count);
      }
      CFRelease(v4);
    }
  }
  else
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiAppStateManagerAppUnregisteredCallbackFunctionPtr");
    objc_autoreleasePoolPop(v16);
  }
}

void sub_10008C5A4(uint64_t a1, dispatch_queue_t *a2)
{
  _BOOL8 v3;
  dispatch_block_t v4;
  void *v5;
  _QWORD block[6];

  if (a2)
  {
    if (a2[4])
    {
      v3 = MKBGetDeviceLockState(0) == 1;
      CFRetain(a2);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000B9A84;
      block[3] = &unk_10022EF88;
      block[4] = a2;
      block[5] = v3;
      v4 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, 0, block);
      dispatch_async(a2[4], v4);
      _Block_release(v4);
      return;
    }
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null queue", "__WiFiManagerHandleKeybagLockStatus");
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiManagerHandleKeybagLockStatus");
  }
  objc_autoreleasePoolPop(v5);
}

void sub_10008C6C0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  const char *v5;
  _QWORD block[6];

  if (!a1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiManagerUpdateFamilyPreferences");
    goto LABEL_14;
  }
  if (!-[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
  {
    v3 = objc_autoreleasePoolPush();
    v4 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v5 = "%s: Setup not completed. Not querying family circle.";
LABEL_13:
      objc_msgSend(v4, "WFLog:message:", 4, v5, "__WiFiManagerUpdateFamilyPreferences");
    }
LABEL_14:
    objc_autoreleasePoolPop(v3);
    return;
  }
  if (!*(_BYTE *)(a1 + 1328))
  {
    v3 = objc_autoreleasePoolPush();
    v4 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v5 = "%s: Device not unlocked since boot. Not querying family circle.";
      goto LABEL_13;
    }
    goto LABEL_14;
  }
  *(_DWORD *)(a1 + 340) = 0;
  v2 = objc_autoreleasePoolPush();
  if (objc_opt_class(FAFamilyCircle))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000BAD6C;
    block[3] = &unk_1002306C8;
    block[4] = sub_1000A5DB4((_QWORD *)a1);
    block[5] = a1;
    dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  }
  objc_autoreleasePoolPop(v2);
}

void sub_10008C824(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    sub_10008C6C0(a2);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager.", "__WiFiManagerHandleFamilyUpdateNotification");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_10008C888(uint64_t a1, uint64_t a2, int a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  void **v9;
  unsigned int v10;
  __CFNotificationCenter *DarwinNotifyCenter;
  void *v12;
  void *v13;
  dispatch_time_t v14;
  NSObject *v15;
  __CFArray *v16;
  const __CFArray *v17;
  CFAbsoluteTime Current;
  CFIndex Count;
  CFIndex v20;
  CFIndex i;
  void *ValueAtIndex;
  void *v23;
  const __CFDate *v24;
  const __CFDate *v25;
  CFComparisonResult v26;
  void *v27;
  void **v28;
  void *v29;
  uint64_t v30;
  void *v31;
  const char *v32;
  void *v33;
  unsigned int v34;
  void *v35;
  id v36;
  void *v37;
  void *v38;
  const void *v39;
  uint64_t v40;
  int v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  const __CFDate *otherDate;
  _QWORD context[4];
  _QWORD block[5];

  v6 = objc_autoreleasePoolPush();
  v7 = *(_QWORD *)(a1 + 864);
  *(_QWORD *)(a1 + 864) = a2;
  if (MKBUserUnlockedSinceBoot(0))
  {
    if (!*(_BYTE *)(a1 + 1328))
    {
      v8 = objc_autoreleasePoolPush();
      v9 = (void **)&qword_10026DD20;
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "First unlock since launch");
      objc_autoreleasePoolPop(v8);
      *(_BYTE *)(a1 + 1328) = 1;
      sub_10008674C(a1);
      sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
      sub_1000875B0(a1);
      sub_100087FE4(a1);
      v10 = sub_10008F890((_QWORD *)a1);
      sub_10008F33C(a1, v10, 0);
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterRemoveObserver(DarwinNotifyCenter, 0, CFSTR("com.apple.mobile.keybagd.lock_status"), 0);
      sub_1000913FC(a1);
      sub_1000B906C((_QWORD *)a1, 0);
      if (*(_BYTE *)(a1 + 2254))
      {
        *(_BYTE *)(a1 + 2254) = 0;
        v12 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s reseting user auto join due after first unlock due to device restart", "__WiFiManagerLockStateUpdate");
        objc_autoreleasePoolPop(v12);
        sub_1000898A0(a1, 1, 3, 0);
      }
      sub_100031928(a1, 1);
      sub_1000094BC(a1, 1);
      if ((*(_BYTE *)(a1 + 832) & 0xF) != 0)
        sub_100031B4C(a1);
      else
        sub_1000317E8(a1);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        sub_100007F68(a1, 29);
      else
        sub_100090860(a1, 2);
      sub_100176AEC(*(void **)(a1 + 1432));
      if (&_WiFiCloudSyncEngineCreate && *(_QWORD *)(a1 + 1304))
      {
        CFRetain((CFTypeRef)a1);
        v14 = dispatch_time(0, 30000000000);
        v15 = *(NSObject **)(a1 + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000B9AD0;
        block[3] = &unk_10022EA38;
        block[4] = a1;
        dispatch_after(v14, v15, block);
      }
      if (sub_1000304D4((_QWORD *)a1))
      {
        v16 = sub_10009C2F0(objc_msgSend(*(id *)(a1 + 1104), "dictionaryRepresentation"));
        if (v16)
        {
          v17 = v16;
          Current = CFAbsoluteTimeGetCurrent();
          otherDate = CFDateCreate(0, Current + -63072000.0);
          if (otherDate)
          {
            v43 = a3;
            v44 = v7;
            v45 = v6;
            Count = CFArrayGetCount(v17);
            if (Count >= 1)
            {
              v20 = Count;
              for (i = 0; i != v20; ++i)
              {
                ValueAtIndex = (void *)CFArrayGetValueAtIndex(v17, i);
                if (ValueAtIndex)
                {
                  v23 = ValueAtIndex;
                  v24 = (const __CFDate *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("prevJoined"));
                  if (v24)
                  {
                    v25 = v24;
                    if (sub_1000CEBA4((uint64_t)v23))
                    {
                      v26 = CFDateCompare(v25, otherDate, 0);
                      v27 = objc_autoreleasePoolPush();
                      v28 = v9;
                      v29 = *v9;
                      if (v26 == kCFCompareGreaterThan)
                      {
                        if (v29)
                          objc_msgSend(v29, "WFLog:message:", 2, "This open network was joined in less than two years %@: %@: %@", v25, otherDate, sub_10002B088(v23));
                        objc_autoreleasePoolPop(v27);
                      }
                      else
                      {
                        if (v29)
                          objc_msgSend(v29, "WFLog:message:", 3, "Removing this open network that is older than two years since last joined %@: %@", v25, sub_10002B088(v23));
                        objc_autoreleasePoolPop(v27);
                        sub_100098DBC(a1, v23, (const void *)0x13);
                      }
                      v9 = v28;
                    }
                  }
                }
              }
            }
            CFRelease(otherDate);
            v7 = v44;
            v6 = v45;
            a3 = v43;
          }
          CFRelease(v17);
        }
      }
      sub_1000AD118(a1);
    }
    v30 = *(_QWORD *)(a1 + 864);
    sub_1000913FC(a1);
    if (!a3 && v7 == v30)
      goto LABEL_43;
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_QWORD *)(a1 + 864))
        v32 = "DISABLED";
      else
        v32 = "ENABLED";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "User interaction %s", v32);
    }
    objc_autoreleasePoolPop(v31);
    if (!*(_QWORD *)(a1 + 864))
    {
      if (*(_BYTE *)(a1 + 2404))
      {
        *(_BYTE *)(a1 + 2404) = 0;
        v33 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: lock state changed while in LPEM. Restoring power state.", "__WiFiManagerLockStateUpdate");
        objc_autoreleasePoolPop(v33);
        v34 = sub_10008F890((_QWORD *)a1);
        sub_10008F33C(a1, v34, CFSTR("LPEM"));
      }
      if (!*(_QWORD *)(a1 + 2184))
      {
        v35 = objc_autoreleasePoolPush();
        if (sub_10008C218(a1))
        {
          v36 = objc_msgSend(objc_alloc((Class)WiFi3BarsSource), "initWithChangeHandler:localStoreType:", 0, 0);
          *(_QWORD *)(a1 + 2184) = v36;
          context[0] = a1;
          context[1] = 0xAAAAAAAA00000062;
          context[2] = v36;
          context[3] = 0;
          CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
        }
        objc_autoreleasePoolPop(v35);
      }
      v37 = objc_autoreleasePoolPush();
      if (!objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"))
      {
        v38 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s initDeviceAnalyticsClient failed. Will retry", "__WiFiManagerLockStateUpdate");
        objc_autoreleasePoolPop(v38);
        -[WiFiManagerAnalytics triggerDeviceAnalyticsStoreMigrationWithCompletion:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "triggerDeviceAnalyticsStoreMigrationWithCompletion:", &stru_100230B70);
      }
      objc_autoreleasePoolPop(v37);
    }
    if ((*(_DWORD *)(a1 + 788) | 2) != 2)
    {
      v42 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignoring lock state manager->wakeMode %d\n", *(unsigned int *)(a1 + 788));
      objc_autoreleasePoolPop(v42);
      if (v7 == v30 || *(_QWORD *)(a1 + 864))
        goto LABEL_43;
      sub_100031928(a1, 1);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
LABEL_91:
        sub_100007F68(a1, 29);
        if (_os_feature_enabled_impl("WiFiManager", "AskToJoinPersonalHotspotBanner")
          && -[WiFiUserInteractionMonitor isPersonalHotspotRecommendationAllowed](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isPersonalHotspotRecommendationAllowed"))
        {
          sub_1000B9A3C(a1, 1);
        }
        goto LABEL_43;
      }
LABEL_90:
      sub_100090860(a1, 2);
      goto LABEL_43;
    }
    v39 = *(const void **)(a1 + 1136);
    v40 = *(_QWORD *)(a1 + 864);
    if (!v40)
    {
      v41 = 1;
      sub_100031928(a1, 1);
      if ((*(_BYTE *)(a1 + 832) & 0x11) != 0)
      {
        v41 = 0;
        v39 = *(const void **)(a1 + 1128);
      }
      sub_1000094BC(a1, 1);
      if ((*(_BYTE *)(a1 + 832) & 0xF) != 0)
        sub_100031B4C(a1);
      else
        sub_1000317E8(a1);
      if (v7 != v30)
        *(_QWORD *)(a1 + 880) = 0;
      goto LABEL_82;
    }
    sub_1000B99A4(a1);
    if ((*(_BYTE *)(a1 + 832) & 0x2A) == 0)
    {
      if (*(_BYTE *)(a1 + 1176))
      {
        v39 = *(const void **)(a1 + 1152);
        v41 = 3;
        goto LABEL_82;
      }
      if (!*(_BYTE *)(a1 + 1160))
        sub_1000094BC(a1, 0);
    }
    v41 = 1;
LABEL_82:
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_100014478(a1);
    else
      sub_1000069C0(a1, v39, v41);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      if (*(_QWORD *)(a1 + 864))
      {
        if (!*(_QWORD *)(a1 + 848))
          sub_100007F68(a1, 34);
        goto LABEL_43;
      }
      goto LABEL_91;
    }
    if (v40)
      goto LABEL_43;
    goto LABEL_90;
  }
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device has not been unlocked since boot");
  objc_autoreleasePoolPop(v13);
  sub_1000913FC(a1);
LABEL_43:
  objc_autoreleasePoolPop(v6);
}

void sub_10008D018(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 32);
  if (v1)
    sub_10007FDD8(v1);
}

void sub_10008D028(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    sub_10008D03C(v1, 0);
}

void sub_10008D03C(uint64_t a1, int a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  const char *v8;
  const void *v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  void *v18;
  _QWORD context[4];

  v4 = (uint64_t *)(a1 + 848);
  v5 = *(_QWORD *)(a1 + 848);
  if (notify_get_state(*(_DWORD *)(a1 + 856), (uint64_t *)(a1 + 848)))
    return;
  if (byte_10026DD60)
  {
    v6 = 1;
    *v4 = 1;
    if (a2)
      goto LABEL_8;
  }
  else
  {
    v6 = *v4;
    if (a2)
      goto LABEL_8;
  }
  if (v5 == v6)
    return;
LABEL_8:
  v7 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*v4)
      v8 = "ON";
    else
      v8 = "OFF";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Device display is %s", v8);
  }
  objc_autoreleasePoolPop(v7);
  if (!*(_DWORD *)(a1 + 788))
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Ignoring display state");
    objc_autoreleasePoolPop(v18);
    return;
  }
  v9 = *(const void **)(a1 + 1136);
  sub_1000913FC(a1);
  v10 = *(_QWORD *)(a1 + 848);
  if (v10)
  {
    if (*(_QWORD *)(a1 + 864))
      v11 = 1;
    else
      v11 = v5 == v6;
    v12 = !v11;
    v13 = *(_DWORD *)(a1 + 788);
    if (a2)
      v14 = 3;
    else
      v14 = 4;
    if (v13 == 2)
      v15 = v14;
    else
      v15 = v12;
    v16 = 1;
    if (v13 == 2)
      v17 = 1;
    else
      v17 = 2;
    if ((*(_BYTE *)(a1 + 832) & 0x11) != 0)
    {
      v16 = 0;
      v9 = *(const void **)(a1 + 1128);
    }
    sub_1000094BC(a1, 1);
    if ((*(_BYTE *)(a1 + 832) & 0xF) != 0)
      sub_100031B4C(a1);
    else
      sub_1000317E8(a1);
    if (v5 != v6)
      *(_QWORD *)(a1 + 880) = 0;
    goto LABEL_45;
  }
  sub_1000B99A4(a1);
  if ((*(_BYTE *)(a1 + 832) & 0x2A) == 0)
  {
    if (*(_BYTE *)(a1 + 1176))
    {
      v15 = 0;
      v9 = *(const void **)(a1 + 1152);
      v16 = 3;
      goto LABEL_44;
    }
    if (!*(_BYTE *)(a1 + 1160))
      sub_1000094BC(a1, 0);
  }
  v15 = 0;
  v16 = 1;
LABEL_44:
  v17 = 2;
LABEL_45:
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000006DLL;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  if (v15)
    sub_100031928(a1, v15);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_100014478(a1);
    if (!v10)
      return;
  }
  else
  {
    sub_1000069C0(a1, v9, v16);
    if (!v10)
      return;
  }
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    sub_100007F68(a1, 19);
  else
    sub_100090860(a1, v17);
}

void sub_10008D2F0(uint64_t a1)
{
  sub_10008D2FC(*(_QWORD *)(a1 + 32), 0);
}

void sub_10008D2FC(uint64_t a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  void *v11;
  _QWORD context[4];

  if (a1)
  {
    v4 = (_QWORD *)(a1 + 2296);
    v5 = *(_QWORD *)(a1 + 2296);
    if (notify_get_state(*(_DWORD *)(a1 + 2304), (uint64_t *)(a1 + 2296)))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: notify_get_state returned error", "__WiFiManagerSymptomsRecommendationUpdate");
      objc_autoreleasePoolPop(v6);
    }
    v7 = *v4;
    if (a2 || v5 != v7)
    {
      v8 = objc_autoreleasePoolPush();
      v9 = v7 & 1;
      if (qword_10026DD20)
      {
        v10 = "TRUE";
        if (!v9)
          v10 = "FALSE";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: LQM-WiFi : symptoms cellular outrank recommendation is set to %s (state=0x%llx)", "__WiFiManagerSymptomsRecommendationUpdate", v10, *v4);
      }
      objc_autoreleasePoolPop(v8);
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000080;
      context[2] = 0;
      context[3] = v9;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "__WiFiManagerSymptomsRecommendationUpdate");
    objc_autoreleasePoolPop(v11);
  }
}

uint64_t sub_10008D46C(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result;
  io_registry_entry_t v5;
  const __CFString *CFProperty;
  const __CFString *v7;
  void *v8;

  result = IOIteratorNext(iterator);
  if ((_DWORD)result)
  {
    v5 = result;
    do
    {
      CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(v5, CFSTR("IOInterfaceName"), kCFAllocatorDefault, 0);
      if (CFProperty)
      {
        v7 = CFProperty;
        if (sub_1000B0484((uint64_t)CFProperty))
          sub_1000AF7B4(a1, v7);
        CFRelease(v7);
      }
      else
      {
        v8 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "No interface name for IOService");
        objc_autoreleasePoolPop(v8);
      }
      IOObjectRelease(v5);
      result = IOIteratorNext(iterator);
      v5 = result;
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t sub_10008D554(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result;
  io_registry_entry_t v5;

  result = IOIteratorNext(iterator);
  if ((_DWORD)result)
  {
    v5 = result;
    do
    {
      if (a1)
      {
        sub_10000A1EC(a1, v5, -536723200);
        IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 960), v5, "IOGeneralInterest", (IOServiceInterestCallback)sub_10000A1EC, (void *)a1, (io_object_t *)(a1 + 980));
      }
      IOObjectRelease(v5);
      result = IOIteratorNext(iterator);
      v5 = result;
    }
    while ((_DWORD)result);
  }
  return result;
}

BOOL sub_10008D5F4(uint64_t a1)
{
  return (objc_msgSend(*(id *)(a1 + 1120), "containsObject:", CFSTR("wifi_usb_host_notification_override=1")) & 1) != 0|| _os_feature_enabled_impl("WiFiManager", "SCCA")&& MGGetBoolAnswer(CFSTR("DeviceSupportsUSBTypeC"))&& *(_DWORD *)(a1 + 112) == 1;
}

void sub_10008D664(uint64_t a1, io_iterator_t iterator)
{
  io_object_t v4;
  io_registry_entry_t v5;
  CFStringRef v6;
  void *v7;
  const __CFNumber *Value;
  int v9;
  void *v10;
  int v11;
  int v12;
  void *v13;
  const char *v14;
  id v15;
  id v16;
  void *v17;
  int v18;
  void *v19;
  CFMutableDictionaryRef properties;
  uint64_t valuePtr;
  io_name_t name;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v4 = IOIteratorNext(iterator);
  if (v4)
  {
    v5 = v4;
    v6 = 0;
    do
    {
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      memset(name, 0, sizeof(name));
      properties = 0;
      valuePtr = 0;
      IORegistryEntryCreateCFProperties(v5, &properties, kCFAllocatorDefault, 0);
      if (properties)
      {
        if (IORegistryEntryGetName(v5, name))
        {
          v7 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:%d Usb Host Notification: Failed to get device name \n", "__WiFiManagerhostNotificationUSBDeviceInserted", 4310);
          objc_autoreleasePoolPop(v7);
        }
        Value = (const __CFNumber *)CFDictionaryGetValue(properties, CFSTR("idVendor"));
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
          if (valuePtr == 1452)
          {
            v9 = 1;
            *(_BYTE *)(a1 + 2464) = 1;
          }
          else
          {
            v9 = 0;
            *(_BYTE *)(a1 + 2464) = 0;
          }
        }
        else
        {
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:%d Usb Host Notification Insertion: Failed to get Vendor ID \n", "__WiFiManagerhostNotificationUSBDeviceInserted", 4316);
          objc_autoreleasePoolPop(v10);
          v9 = 0;
        }
        if (properties)
        {
          CFRelease(properties);
          properties = 0;
        }
      }
      else
      {
        v9 = 0;
      }
      v11 = *(_DWORD *)(a1 + 2460);
      if (v11 >= 0)
        v12 = v11 + 1;
      else
        v12 = 1;
      *(_DWORD *)(a1 + 2460) = v12;
      if (v6)
        CFRelease(v6);
      v6 = CFStringCreateWithCString(kCFAllocatorDefault, name, 0x8000100u);
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (v9)
          v14 = "Y";
        else
          v14 = "N";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Insertion Host Notification for %s isApple %s seqNum %d Total %d\n", "__WiFiManagerhostNotificationUSBDeviceInserted", name, v14, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460));
      }
      objc_autoreleasePoolPop(v13);
      IOObjectRelease(v5);
      v15 = objc_alloc((Class)WiFiUsageMonitor_UsbDevice);
      v16 = objc_msgSend(v15, "initWithName:vid:isApple:locationID:", v6, valuePtr, *(_BYTE *)(a1 + 2464) != 0, 0);
      if (v16)
      {
        v17 = v16;
        objc_msgSend(*(id *)(a1 + 2488), "addObject:", v16);

      }
      v5 = IOIteratorNext(iterator);
    }
    while (v5);
    if (v6)
      CFRelease(v6);
  }
  if (*(_DWORD *)(a1 + 2460))
  {
    *(_DWORD *)(a1 + 2456) = 1;
    *(CFAbsoluteTime *)(a1 + 2480) = CFAbsoluteTimeGetCurrent();
    sub_10008BB68(a1);
    v18 = sub_10008BE80(a1, 1);
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - usbDevices(%lu) %@ \n", "__WiFiManagerhostNotificationUSBDeviceInserted", objc_msgSend(*(id *)(a1 + 2488), "count"), *(_QWORD *)(a1 + 2488));
    objc_autoreleasePoolPop(v19);
    -[WiFiUsageMonitor setUsbStatus:currentDevices:currentNoiseDelta:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setUsbStatus:currentDevices:currentNoiseDelta:", 1, *(_QWORD *)(a1 + 2488), v18);
  }
}

void sub_10008D9BC(uint64_t a1, io_iterator_t iterator)
{
  io_object_t v4;
  io_registry_entry_t v5;
  CFStringRef v6;
  void *v7;
  const __CFNumber *Value;
  void *v9;
  void *v10;
  unint64_t v11;
  _BOOL4 v12;
  void *v13;
  void *v14;
  void *v15;
  int v16;
  _QWORD v17[6];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  CFMutableDictionaryRef properties;
  uint64_t valuePtr;
  io_name_t name;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v16 = *(_DWORD *)(a1 + 2460);
  v4 = IOIteratorNext(iterator);
  if (!v4)
    goto LABEL_38;
  v5 = v4;
  v6 = 0;
  do
  {
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    memset(name, 0, sizeof(name));
    properties = 0;
    valuePtr = 0;
    --*(_DWORD *)(a1 + 2460);
    IORegistryEntryCreateCFProperties(v5, &properties, kCFAllocatorDefault, 0);
    if (properties)
    {
      if (IORegistryEntryGetName(v5, name))
      {
        v7 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:%d Usb Host Notification: Failed to get IORegistryEntryGetName \n", "__WiFiManagerhostNotificationUSBDeviceRemoved", 4384);
        objc_autoreleasePoolPop(v7);
      }
      Value = (const __CFNumber *)CFDictionaryGetValue(properties, CFSTR("idVendor"));
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        *(_BYTE *)(a1 + 2464) = valuePtr == 1452;
      }
      else
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s:%d Usb Host Notification Removal: Failed to get Vendor ID \n", "__WiFiManagerhostNotificationUSBDeviceRemoved", 4390);
        objc_autoreleasePoolPop(v9);
      }
      if (properties)
      {
        CFRelease(properties);
        properties = 0;
      }
    }
    if (v6)
      CFRelease(v6);
    v6 = CFStringCreateWithCString(kCFAllocatorDefault, name, 0x8000100u);
    if (!v6)
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Host Notification for %s failed CFStringCreateWithCString seqNum %d Total %d\n", "__WiFiManagerhostNotificationUSBDeviceRemoved", name, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460));
      goto LABEL_28;
    }
    if (!objc_msgSend(*(id *)(a1 + 2488), "count"))
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Host Notification for %s seqNum %d Total %d\n", "__WiFiManagerhostNotificationUSBDeviceRemoved", name, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460));
LABEL_28:
      objc_autoreleasePoolPop(v14);
      goto LABEL_35;
    }
    v18 = 0;
    v19 = &v18;
    v20 = 0x2020000000;
    v21 = -1;
    v10 = *(void **)(a1 + 2488);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_1000B8080;
    v17[3] = &unk_100230A30;
    v17[4] = &v18;
    v17[5] = v6;
    objc_msgSend(v10, "enumerateObjectsUsingBlock:", v17);
    v11 = v19[3];
    v12 = v11 < (unint64_t)objc_msgSend(*(id *)(a1 + 2488), "count");
    v13 = objc_autoreleasePoolPush();
    if (v12)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Host Notification for %s -- Removing device at index %lu from %@\n", "__WiFiManagerhostNotificationUSBDeviceRemoved", name, v19[3], *(_QWORD *)(a1 + 2488));
      objc_autoreleasePoolPop(v13);
      objc_msgSend(*(id *)(a1 + 2488), "removeObjectAtIndex:", v19[3]);
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Host Notification for %s seqNum %d managerTotal %d setTotal:%ld\n", "__WiFiManagerhostNotificationUSBDeviceRemoved", name, *(unsigned int *)(a1 + 2452), *(unsigned int *)(a1 + 2460), objc_msgSend(*(id *)(a1 + 2488), "count"));
    }
    else if (qword_10026DD20)
    {
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s - Usb Removal Host Notification for %s -- unable to find in %@\n", "__WiFiManagerhostNotificationUSBDeviceRemoved", name, *(_QWORD *)(a1 + 2488));
    }
    objc_autoreleasePoolPop(v13);
    _Block_object_dispose(&v18, 8);
LABEL_35:
    IOObjectRelease(v5);
    v5 = IOIteratorNext(iterator);
  }
  while (v5);
  if (v6)
    CFRelease(v6);
LABEL_38:
  if (v16 > *(_DWORD *)(a1 + 2460))
  {
    *(_DWORD *)(a1 + 2456) = 0;
    *(CFAbsoluteTime *)(a1 + 2480) = CFAbsoluteTimeGetCurrent();
    sub_10008BB68(a1);
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification metrics usbDevices removal count %lu %@ \n", objc_msgSend(*(id *)(a1 + 2488), "count"), *(_QWORD *)(a1 + 2488));
    objc_autoreleasePoolPop(v15);
    -[WiFiUsageMonitor setUsbStatus:currentDevices:currentNoiseDelta:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setUsbStatus:currentDevices:currentNoiseDelta:", 0, *(_QWORD *)(a1 + 2488), -1);
  }
}

void sub_10008DE60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10008DE80(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result;
  io_registry_entry_t v5;
  uint64_t RegistryEntryID;
  CFTypeRef CFProperty;
  unsigned int v8;
  CFTypeRef v9;
  CFTypeRef v10;
  CFTypeRef v11;
  unsigned int v12;
  unsigned int v13;
  NSNumber *v14;
  CFTypeRef v15;
  NSNumber *v16;
  BOOL v17;
  int v18;
  int v19;
  id v20;
  void *v21;
  int v22;
  void *v23;
  void *v24;
  NSNumber *v25;
  uint64_t v26;
  void *v27;
  io_object_t notification;
  uint64_t entryID;

  result = IOIteratorNext(iterator);
  if ((_DWORD)result)
  {
    v5 = result;
    do
    {
      entryID = 0;
      RegistryEntryID = IORegistryEntryGetRegistryEntryID(v5, &entryID);
      if ((_DWORD)RegistryEntryID)
      {
        v26 = RegistryEntryID;
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification IORegistryEntryGetRegistryEntryID failed: %08x", v26);
      }
      else if (objc_msgSend(*(id *)(a1 + 2496), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", entryID)))
      {
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Usb Host Notification Port object already exists for service, ignoring... (registryEntryID: %llu)", entryID);
      }
      else
      {
        CFProperty = IORegistryEntryCreateCFProperty(v5, CFSTR("DataRole"), kCFAllocatorDefault, 0);
        v8 = objc_msgSend((id)(id)CFMakeCollectable(CFProperty), "intValue");
        v9 = IORegistryEntryCreateCFProperty(v5, CFSTR("TransportDescription"), kCFAllocatorDefault, 0);
        v10 = (id)CFMakeCollectable(v9);
        v11 = IORegistryEntryCreateCFProperty(v5, CFSTR("TransportType"), kCFAllocatorDefault, 0);
        v12 = objc_msgSend((id)(id)CFMakeCollectable(v11), "intValue");
        v13 = v12;
        if (v8 || v12 != 5)
        {
          v15 = IORegistryEntryCreateCFProperty(v5, CFSTR("Vendor ID"), kCFAllocatorDefault, 0);
          v14 = (id)CFMakeCollectable(v15);
        }
        else
        {
          v14 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 0xFFFFLL);
        }
        v16 = v14;
        v17 = -[NSNumber intValue](v14, "intValue") == 1452 || -[NSNumber intValue](v16, "intValue") == 1452;
        *(_BYTE *)(a1 + 2464) = v17;
        if (v8 <= 1)
        {
          v18 = *(_DWORD *)(a1 + 2460);
          if (v18 >= 0)
            v19 = v18 + 1;
          else
            v19 = 1;
          *(_DWORD *)(a1 + 2460) = v19;
          v20 = objc_msgSend(objc_alloc((Class)WiFiUsageMonitor_UsbDevice), "initWithName:vid:isApple:locationID:", v10, -[NSNumber intValue](v16, "intValue"), *(_BYTE *)(a1 + 2464) != 0, 0);
          if (v20)
          {
            v21 = v20;
            objc_msgSend(*(id *)(a1 + 2488), "addObject:", v20);

          }
          if (*(_DWORD *)(a1 + 2460))
          {
            *(_DWORD *)(a1 + 2456) = 1;
            *(CFAbsoluteTime *)(a1 + 2480) = CFAbsoluteTimeGetCurrent();
            if (v13 == 2)
            {
              --*(_DWORD *)(a1 + 2460);
            }
            else if (v13 == 3)
            {
              sub_10008BB68(a1);
            }
            v22 = sub_10008BE80(a1, 1);
            v23 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s - Usb Host Notification usbDevices  (%lu) %@ \n", "__WiFiManagerhandleUnifiedE85ServiceAdded", objc_msgSend(*(id *)(a1 + 2488), "count"), *(_QWORD *)(a1 + 2488));
            objc_autoreleasePoolPop(v23);
            -[WiFiUsageMonitor setUsbStatus:currentDevices:currentNoiseDelta:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "setUsbStatus:currentDevices:currentNoiseDelta:", 1, *(_QWORD *)(a1 + 2488), v22);
          }
        }
        notification = 0;
        if (!IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 960), v5, "IOGeneralInterest", (IOServiceInterestCallback)sub_1000B80F8, (void *)a1, &notification))
        {
          if (notification)
          {
            v24 = *(void **)(a1 + 2496);
            v25 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
            objc_msgSend(v24, "setObject:forKey:", v25, +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", entryID));
          }
          goto LABEL_29;
        }
        v27 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Usb Host Notification Error: IOServiceAddInterestNotification failed", "__WiFiManagerhandleUnifiedE85ServiceAdded");
      }
      objc_autoreleasePoolPop(v27);
LABEL_29:
      IOObjectRelease(v5);
      result = IOIteratorNext(iterator);
      v5 = result;
    }
    while ((_DWORD)result);
  }
  return result;
}

void sub_10008E240(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  const char *v10;
  int v11;
  void *v12;
  void *v13;
  char v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  const char *v19;
  void *v20;
  void *v21;
  NSObject *v22;
  dispatch_time_t v23;
  const __CFString *v24;
  CFStringRef Copy;
  size_t v26;
  uint64_t context;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v7 = objc_autoreleasePoolPush();
  v26 = 255;
  if (a3 <= -536870145)
  {
    if (a3 == -536870272)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received kIOMessageSystemWillSleep");
      objc_autoreleasePoolPop(v13);
      v14 = *(_BYTE *)(a1 + 26);
      if (v14)
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System Sleep notification, Disabling auto-join");
        objc_autoreleasePoolPop(v15);
        sub_1000094BC(a1, 0);
        v14 = 1;
      }
      *(_BYTE *)(a1 + 1329) = v14;
      sub_100031B4C(a1);
      sub_1000B8FA8(a1, -536870272);
      context = a1;
      v28 = 0xAAAAAAAA00000051;
      v29 = 0;
      v30 = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    }
    else if (a3 == -536870256)
    {
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received kIOMessageSystemWillNotSleep");
      objc_autoreleasePoolPop(v8);
      if ((*(_BYTE *)(a1 + 1329) || *(_BYTE *)(a1 + 1176)) && !*(_BYTE *)(a1 + 26))
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (*(_BYTE *)(a1 + 1329))
            v10 = "Re-enabling auto-join";
          else
            v10 = "Enabling auto-join for LPAS";
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System Sleep Cancelled notification, %s", v10, v26);
        }
        objc_autoreleasePoolPop(v9);
        sub_1000094BC(a1, 1);
      }
      *(_BYTE *)(a1 + 1329) = 0;
      if ((*(_BYTE *)(a1 + 832) & 0xF) == 0)
        sub_1000317E8(a1);
      v11 = -536870256;
LABEL_23:
      sub_1000B8FA8(a1, v11);
      goto LABEL_59;
    }
    goto LABEL_59;
  }
  if (a3 == -536870144)
  {
    v16 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received kIOMessageSystemHasPoweredOn");
    objc_autoreleasePoolPop(v16);
    sysctlbyname("kern.wakereason", (void *)(a1 + 530), &v26, 0, 0);
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System wake reason: %s", a1 + 530, v26);
    objc_autoreleasePoolPop(v17);
    if (!*(_BYTE *)(a1 + 1329) && !*(_BYTE *)(a1 + 1176) || *(_BYTE *)(a1 + 26))
      goto LABEL_53;
    v18 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_BYTE *)(a1 + 1329))
        v19 = "Re-enabling auto-join";
      else
        v19 = "Enabling auto-join for LPAS";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "System Powered ON notification %s", v19);
    }
    objc_autoreleasePoolPop(v18);
    *(_BYTE *)(a1 + 2104) = 0;
    if (sub_1000092B8(a1))
    {
      if (*(double *)(a1 + 2096) <= 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 2096) <= 360.0)
      {
        v21 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AlwaysOnWiFi: Reschedule Scan after %d Seconds ", 360);
        objc_autoreleasePoolPop(v21);
        *(_BYTE *)(a1 + 2104) = 1;
        v22 = *(NSObject **)(a1 + 1576);
        v23 = dispatch_time(0, 360000000000);
        dispatch_source_set_timer(v22, v23, 0xFFFFFFFFFFFFFFFFLL, 0);
        goto LABEL_53;
      }
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "AlwaysOnWiFi: Scan time expired, Re-Enable Auto-Join");
      objc_autoreleasePoolPop(v20);
      *(CFAbsoluteTime *)(a1 + 2096) = CFAbsoluteTimeGetCurrent();
    }
    sub_1000094BC(a1, 1);
LABEL_53:
    *(_BYTE *)(a1 + 1329) = 0;
    if ((*(_BYTE *)(a1 + 832) & 0xF) == 0)
      sub_1000317E8(a1);
    context = a1;
    v28 = 0xAAAAAAAA0000004ELL;
    v29 = 0;
    v30 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    sub_1000B8FA8(a1, -536870144);
    if (*(_BYTE *)(a1 + 1520))
    {
      v24 = *(const __CFString **)(a1 + 1512);
      if (v24)
      {
        Copy = CFStringCreateCopy(kCFAllocatorDefault, v24);
        sub_10009FB18(a1, 1, Copy);
        if (Copy)
          CFRelease(Copy);
      }
    }
    goto LABEL_59;
  }
  if (a3 == -536870112)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Received kIOMessageSystemWillPowerOn");
    objc_autoreleasePoolPop(v12);
    v11 = -536870112;
    goto LABEL_23;
  }
LABEL_59:
  IOAllowPowerChange(*(_DWORD *)(a1 + 1028), a4);
  objc_autoreleasePoolPop(v7);
}

void sub_10008E708(uint64_t a1, int a2, uint64_t a3, NSObject **cf)
{
  CFTypeID v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t Default;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  _QWORD block[5];
  int v24;
  _QWORD v25[7];
  __int128 v26;
  uint64_t v27;
  unint64_t v28;

  if ((_DWORD)a3)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, result %d", "__WiFiManagerBluetoothCallback", a3);
    goto LABEL_21;
  }
  if (!cf)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, null userData", "__WiFiManagerBluetoothCallback", v22);
    goto LABEL_21;
  }
  v7 = CFGetTypeID(cf);
  v8 = qword_10026D658;
  if (!qword_10026D658)
  {
    pthread_once(&stru_10026C9C0, (void (*)(void))sub_1000830F0);
    v8 = qword_10026D658;
  }
  if (v7 != v8)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BT callback failure, invalid userData type", "__WiFiManagerBluetoothCallback", v22);
    goto LABEL_21;
  }
  if (!cf[4])
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager queue null", "__WiFiManagerBluetoothCallback", v22);
    goto LABEL_21;
  }
  if ((a2 - 1) < 2)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Mobile Bluetooth session terminated");
    objc_autoreleasePoolPop(v12);
    v13 = cf[4];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B9664;
    block[3] = &unk_100230B10;
    block[4] = cf;
    v24 = a2;
    v14 = block;
LABEL_17:
    dispatch_async(v13, v14);
    return;
  }
  if (a2 == 3)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to attach to Mobile Bluetooth", v21, v22);
    goto LABEL_21;
  }
  if (!a2)
  {
    if (!a1)
    {
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: session null", "__WiFiManagerBluetoothCallback", v22);
      goto LABEL_21;
    }
    v9 = BTServiceAddCallbacksWithFilter(a1, sub_1000B92F4, 0xFFFFFFFFLL, cf);
    if ((_DWORD)v9)
    {
      v10 = v9;
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to obtain Bluetooth AudioJack. result=0x%X", v10, v22);
LABEL_21:
      objc_autoreleasePoolPop(v11);
      return;
    }
    v28 = 0xAAAAAAAAAAAAAAAALL;
    Default = BTLocalDeviceGetDefault(a1, &v28);
    if ((_DWORD)Default)
    {
      v16 = Default;
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to obtain Bluetooth Local Device. result=0x%X", v16);
LABEL_28:
      objc_autoreleasePoolPop(v17);
      return;
    }
    v26 = off_100230AD8;
    v27 = 0;
    v18 = BTLocalDeviceAddCallbacks(v28, &v26, cf);
    if ((_DWORD)v18)
    {
      v19 = v18;
      v17 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Failed to set Bluetooth Local Device callbacks.  result=0x%X", v19);
      goto LABEL_28;
    }
    v13 = cf[4];
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_1000B9644;
    v25[3] = &unk_100230AF0;
    v25[4] = cf;
    v25[5] = a1;
    v25[6] = v28;
    v14 = v25;
    goto LABEL_17;
  }
}

void sub_10008EA88(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008EA90(uint64_t a1)
{
  void *v1;
  _QWORD block[5];

  if (a1 && *(_QWORD *)(a1 + 32))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B85D8;
    block[3] = &unk_10022EA38;
    block[4] = a1;
    dispatch_async((dispatch_queue_t)qword_10026DD40, block);
  }
  else
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager or queue.", "__WiFiManagerCellularDataRegistrationCallback");
    objc_autoreleasePoolPop(v1);
  }
}

void sub_10008EB4C(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008EB54(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008EB5C(uint64_t a1)
{
  __CTServerConnection *v2;
  __CTServerConnection *v3;
  __CTServerConnection *v4;
  _QWORD v5[5];
  _QWORD v6[5];
  _QWORD v7[5];

  if (-[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection"))
  {
    v2 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_10008EC94;
    v7[3] = &unk_10022EFA8;
    v7[4] = *(_QWORD *)(a1 + 32);
    _CTServerConnectionRegisterBlockForNotification(v2, kCTRegistrationDataStatusChangedNotification, v7);
    v3 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_10008EC9C;
    v6[3] = &unk_10022EFA8;
    v6[4] = *(_QWORD *)(a1 + 32);
    _CTServerConnectionRegisterBlockForNotification(v3, kCTRegistrationDisplayStatusChangedNotification, v6);
    v4 = -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_10008ECA4;
    v5[3] = &unk_10022EFA8;
    v5[4] = *(_QWORD *)(a1 + 32);
    _CTServerConnectionRegisterBlockForNotification(v4, kCTCarrierSettingsNewCarrierNotification, v5);
    sub_10008EA90(*(_QWORD *)(a1 + 32));
  }
}

__CTServerConnection *sub_10008EC78()
{
  return -[WiFiUserInteractionMonitor ctServerConnection](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "ctServerConnection");
}

void sub_10008EC94(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008EC9C(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008ECA4(uint64_t a1)
{
  sub_10008EA90(*(_QWORD *)(a1 + 32));
}

void sub_10008ECAC(uint64_t a1, int a2, uint64_t a3)
{
  int v5;
  void *v6;
  const char *v7;
  _QWORD context[4];

  v5 = a2 != 0;
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v7 = "FALSE";
    if (a2)
      v7 = "TRUE";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: builtInReceiver = %s", "__WiFiManagerAudioRouteCallback", v7);
  }
  objc_autoreleasePoolPop(v6);
  if (*(_DWORD *)(a3 + 1456) != v5)
  {
    *(_DWORD *)(a3 + 1456) = v5;
    context[0] = a3;
    context[1] = 0xAAAAAAAA00000009;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_10008ED74(uint64_t a1)
{
  unsigned int *v2;
  void *v3;
  _QWORD block[5];
  _QWORD handler[5];

  v2 = (unsigned int *)(a1 + 1592);
  *(_DWORD *)(a1 + 1592) = -1;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_1000A01D0;
  handler[3] = &unk_1002306E8;
  handler[4] = a1;
  notify_register_dispatch("com.apple.system.lowpowermode", (int *)(a1 + 1592), (dispatch_queue_t)qword_10026DD40, handler);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: battery save mode registered. Token=%d", "WiFiBatterySaveModeConfiguration", *v2);
  objc_autoreleasePoolPop(v3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000A01D8;
  block[3] = &unk_10022EA38;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)qword_10026DD40, block);
}

id sub_10008EE78(_QWORD *a1, uint64_t a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  _QWORD v9[2];
  _QWORD v10[2];

  v4 = 120.0;
  v5 = sub_10008EF8C(a1, CFSTR("SoftErrorReportingTimeout"), 120.0);
  if (v5 >= 0.0)
    v4 = v5;
  v6 = 86400.0;
  v7 = sub_10008EF8C(a1, CFSTR("SoftErrorUIReportingTimeout"), 86400.0);
  if (v7 >= 0.0)
    v6 = v7;
  v9[0] = CFSTR("intervalForMaxNonUIActions");
  v9[1] = CFSTR("intervalForMaxUIActions");
  v10[0] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v4);
  v10[1] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v6);
  return objc_msgSend(objc_alloc((Class)WiFiSoftError), "initWithName:andParams:", a2, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v10, v9, 2));
}

double sub_10008EF8C(_QWORD *a1, const __CFString *a2, double a3)
{
  const __SCPreferences *v4;
  const __CFNumber *v5;
  CFTypeID TypeID;
  double valuePtr;

  v4 = sub_10001D90C(a1, a2);
  valuePtr = a3;
  if (v4)
  {
    v5 = v4;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      return valuePtr;
    }
  }
  return a3;
}

void sub_10008EFF8(uint64_t a1)
{
  WiFiManagerMotionServices *v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[6];

  v2 = sub_1000BCC6C(*(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)sub_10008F078);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(NSObject **)(v3 + 32);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_10008F0FC;
    v5[3] = &unk_1002306C8;
    v5[4] = v2;
    v5[5] = v3;
    dispatch_async(v4, v5);
  }
}

void sub_10008F078(uint64_t a1, int a2, double a3)
{
  void *v6;
  _QWORD v7[4];

  v6 = objc_autoreleasePoolPush();
  if (a1)
  {
    *(_DWORD *)(a1 + 1408) = a2;
    *(double *)(a1 + 1416) = a3;
    v7[0] = a1;
    v7[1] = 0xAAAAAAAA0000003CLL;
    v7[2] = 0;
    v7[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v7);
  }
  objc_autoreleasePoolPop(v6);
}

void sub_10008F0FC(uint64_t a1)
{
  void *v1;

  *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40) = *(_QWORD *)(a1 + 32);
  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiManagerMotionServices initialized", "WiFiManagerScheduleWithQueue_block_invoke_9");
  objc_autoreleasePoolPop(v1);
}

void sub_10008F15C(uint64_t a1, void *a2)
{
  void *v4;
  void *v5;
  char v6;
  _QWORD context[4];

  v4 = objc_autoreleasePoolPush();
  if (a1 && _os_feature_enabled_impl("WiFiManager", "PM0DuringCarPlaySpeechSession"))
  {
    if (objc_msgSend(a2, "isEqualToString:", CFSTR("Short")))
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: voicePromptStyle is Short", "__WiFiManagerAVSystemMonitorCallback");
      v6 = 1;
LABEL_11:
      objc_autoreleasePoolPop(v5);
      *(_BYTE *)(a1 + 1424) = v6;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000078;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
      goto LABEL_12;
    }
    if (objc_msgSend(a2, "isEqualToString:", CFSTR("Normal")))
    {
      v5 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: voicePromptStyle is Normal", "__WiFiManagerAVSystemMonitorCallback");
      v6 = 0;
      goto LABEL_11;
    }
  }
LABEL_12:
  objc_autoreleasePoolPop(v4);
}

void sub_10008F28C(uint64_t a1, const void *a2)
{
  void *v4;
  CFTypeID v5;
  void *v6;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (a2)
    {
      if (*(_QWORD *)(a1 + 192))
      {
        v5 = CFGetTypeID(a2);
        if (v5 == CFDictionaryGetTypeID())
          objc_msgSend(*(id *)(a1 + 192), "setLocaleTestParams:", a2);
      }
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is null", "__WiFiManagerSetLocaleTestParams");
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_10008F33C(uint64_t a1, unsigned int a2, const void *a3)
{
  void *v6;
  const void *v7;
  unsigned int v8;
  void *v9;
  const __SCPreferences *v10;
  const __CFNumber *v11;
  CFTypeID TypeID;
  int v13;
  void *v14;
  _BOOL4 v15;
  void *v16;
  NSObject *CTGreenTeaOsLogHandle;
  NSObject *v18;
  const char *v19;
  unsigned int v20;
  const void *v21;
  void *v22;
  void *v23;
  void *v24;
  const char *v25;
  _BOOL4 v26;
  void *v27;
  _BYTE valuePtr[12];
  _BYTE v29[12];
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;

  v6 = objc_autoreleasePoolPush();
  if (!a1)
    goto LABEL_62;
  if (*(_BYTE *)(a1 + 1328))
  {
LABEL_3:
    v7 = *(const void **)(a1 + 320);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 320) = 0;
    }
    goto LABEL_5;
  }
  if (!a3 || (v20 = objc_msgSend(&off_100254088, "containsObject:", a3), a2 != 1) || !v20)
  {
    if (a2 || !*(_QWORD *)(a1 + 320))
      goto LABEL_5;
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: power turned OFF before first unlock by %@, overrides earlier power ON by %@", "WiFiManagerSetPowerExt", a3, *(_QWORD *)(a1 + 320));
    objc_autoreleasePoolPop(v23);
    goto LABEL_3;
  }
  v21 = *(const void **)(a1 + 320);
  if (v21)
  {
    CFRelease(v21);
    *(_QWORD *)(a1 + 320) = 0;
  }
  *(_QWORD *)(a1 + 320) = CFRetain(a3);
  v22 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: power turned ON before first unlock by %@", "WiFiManagerSetPowerExt", *(_QWORD *)(a1 + 320));
  objc_autoreleasePoolPop(v22);
LABEL_5:
  v8 = a2;
  if ((MGGetBoolAnswer(CFSTR("3kmXfug8VcxLI5yEmsqQKw")) & 1) == 0)
  {
    v8 = a2;
    if (!*(_QWORD *)(a1 + 320))
    {
      v8 = a2;
      if (!*(_BYTE *)(a1 + 1328))
      {
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: device hasn't been unlocked since boot. Overriding power state to OFF.", "WiFiManagerSetPowerExt");
        objc_autoreleasePoolPop(v9);
        v8 = 0;
      }
    }
  }
  if (*(_DWORD *)(a1 + 316) != v8)
  {
    v16 = objc_autoreleasePoolPush();
    if (a3)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Turning WiFiManager %s by %@", sub_1000648F0(v8), a3);
      objc_autoreleasePoolPop(v16);
      if (*(_QWORD *)(a1 + 2056))
      {
        CTGreenTeaOsLogHandle = getCTGreenTeaOsLogHandle();
        if (CTGreenTeaOsLogHandle)
        {
          v18 = CTGreenTeaOsLogHandle;
          if (os_log_type_enabled(CTGreenTeaOsLogHandle, OS_LOG_TYPE_INFO))
          {
            v19 = "yes";
            *(_DWORD *)valuePtr = 138413314;
            *(_QWORD *)&valuePtr[4] = a3;
            *(_QWORD *)&v29[2] = "com.apple.wifi.manager";
            *(_WORD *)v29 = 2080;
            if (!v8)
              v19 = "no";
            *(_WORD *)&v29[10] = 2080;
            v30 = "wifid";
            v31 = 2080;
            v32 = "WiFiManagerSetPowerExt";
            v33 = 2080;
            v34 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "<%@>[%s][%s]:[%s]WLAN enabled..%s", valuePtr, 0x34u);
          }
        }
      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Turning WiFiManager %s", sub_1000648F0(v8));
      objc_autoreleasePoolPop(v16);
    }
    *(_DWORD *)(a1 + 316) = v8;
    if (*(_BYTE *)(a1 + 1328) == 1)
    {
      v24 = objc_autoreleasePoolPush();
      if (v8 == 1)
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Registering with coex manager", "WiFiManagerSetPowerExt");
        objc_autoreleasePoolPop(v24);
        sub_100178D40(a1);
        objc_msgSend(*(id *)(a1 + 192), "determineAndSetLocale:", 0);
      }
      else
      {
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Un-registering with coex manager", "WiFiManagerSetPowerExt");
        objc_autoreleasePoolPop(v24);
        sub_1001790CC((xpc_object_t *)(a1 + 1320));
        if (&_RDUpdateCountryCodeFromWiFiAPs)
          sub_100093564(a1, 0, 1u);
      }
    }
    *(_QWORD *)valuePtr = a1;
    *(_DWORD *)v29 = -1431655766;
    *(_DWORD *)&valuePtr[8] = 18;
    v25 = (const char *)*(unsigned int *)(a1 + 316);
    *(_QWORD *)&v29[4] = 0;
    v30 = v25;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, valuePtr);
    if (*(_DWORD *)(a1 + 316) == 1)
    {
      if (!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_100090860(a1, 2);
        if (a2)
          goto LABEL_61;
LABEL_64:
        v26 = sub_100093504(a1, a3);
        if (a3 && !v26)
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ is not a user-interactive client, not persisting its requested power state %s to disk", "WiFiManagerSetPowerExt", a3, sub_1000648F0(0));
          objc_autoreleasePoolPop(v27);
          goto LABEL_62;
        }
LABEL_61:
        sub_10009322C((_QWORD *)a1, CFSTR("AllowEnable"), a2, 0);
        goto LABEL_62;
      }
      sub_100007F68(a1, 8);
    }
    if (a2)
      goto LABEL_61;
    goto LABEL_64;
  }
  v10 = sub_10001D90C((_QWORD *)a1, CFSTR("AllowEnable"));
  if (!v10)
    goto LABEL_21;
  v11 = v10;
  TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(v11))
  {
    *(_DWORD *)valuePtr = -1431655766;
    CFNumberGetValue(v11, kCFNumberIntType, valuePtr);
    v13 = *(_DWORD *)valuePtr;
    if (*(_DWORD *)valuePtr >= 5u)
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid saved power state: %d ", "WiFiManagerSetPowerExt", *(unsigned int *)valuePtr);
      objc_autoreleasePoolPop(v14);
      v13 = *(_DWORD *)valuePtr;
    }
    if (v13 != a2)
    {
LABEL_21:
      if (a2)
        goto LABEL_61;
      v15 = sub_100093504(a1, a3);
      if (!a3 || v15)
        goto LABEL_61;
    }
  }
LABEL_62:
  objc_autoreleasePoolPop(v6);
}

BOOL sub_10008F890(_QWORD *a1)
{
  const __SCPreferences *v2;
  const __CFNumber *v3;
  CFTypeID TypeID;
  CFTypeID v5;
  CFNumberRef v6;
  CFNumberRef v7;
  void *v8;
  void *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *MutableCopy;
  const __CFBoolean *Value;
  const __CFBoolean *v14;
  CFTypeID v15;
  uint64_t v16;
  CFNumberRef v17;
  CFNumberRef v18;
  void *v19;
  uint64_t v21;
  _BOOL8 valuePtr;

  valuePtr = 1;
  v2 = sub_10001D90C(a1, CFSTR("AllowEnable"));
  if (!v2)
    return valuePtr;
  v3 = v2;
  TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(v3))
  {
    CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    return valuePtr;
  }
  v5 = CFBooleanGetTypeID();
  if (v5 != CFGetTypeID(v3))
  {
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cannot read BOOLean value", "__WiFiManagerReadPowerState");
    goto LABEL_9;
  }
  valuePtr = v3 == kCFBooleanTrue;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (v6)
  {
    v7 = v6;
    sub_100087488(a1, CFSTR("AllowEnable"), v6, 1);
    CFRelease(v7);
  }
  else
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error creating CFNumber", "__WiFiManagerReadPowerState");
    objc_autoreleasePoolPop(v9);
  }
  v10 = (const __CFDictionary *)CFPreferencesCopyAppValue(CFSTR("original-network-state"), CFSTR("com.apple.preferences.network"));
  if (v10)
  {
    v11 = v10;
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v10);
    CFRelease(v11);
    if (MutableCopy)
    {
      v21 = 1;
      Value = (const __CFBoolean *)CFDictionaryGetValue(MutableCopy, CFSTR("wifi-network"));
      if (Value)
      {
        v14 = Value;
        v15 = CFBooleanGetTypeID();
        if (v15 == CFGetTypeID(v14))
        {
          v16 = 4;
          if (v14 == kCFBooleanTrue)
            v16 = 1;
          v21 = v16;
          v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &v21);
          if (v17)
          {
            v18 = v17;
            CFDictionarySetValue(MutableCopy, CFSTR("wifi-network"), v17);
            CFPreferencesSetAppValue(CFSTR("original-network-state"), MutableCopy, CFSTR("com.apple.preferences.network"));
            CFRelease(v18);
          }
          else
          {
            v19 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: error creating CFNumber", "__WiFiManagerReadPowerState");
            objc_autoreleasePoolPop(v19);
          }
        }
      }
      CFPreferencesAppSynchronize(CFSTR("com.apple.preferences.network"));
      CFRelease(MutableCopy);
      return valuePtr;
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: no previousSettings", "__WiFiManagerReadPowerState");
LABEL_9:
    objc_autoreleasePoolPop(v8);
  }
  return valuePtr;
}

void sub_10008FB58(uint64_t a1)
{
  WiFiSmartCoverStateObserver *v2;
  WiFiSmartCoverStateObserver *v3;
  void *v4;

  v2 = objc_alloc_init(WiFiSmartCoverStateObserver);
  if (v2)
  {
    v3 = v2;
    -[WiFiSmartCoverStateObserver registerSmartCoverStateCallback](v2, "registerSmartCoverStateCallback");
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = v3;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiManager Smart Cover Observer initialized", "WiFiManagerScheduleWithQueue_block_invoke_12");
  }
  else
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiManager Unable to register smartCoverCallback", "WiFiManagerScheduleWithQueue_block_invoke_12");
  }
  objc_autoreleasePoolPop(v4);
}

void sub_10008FC04(id a1, void *a2, unint64_t a3)
{
  NSObject *v4;
  void *v5;
  _QWORD block[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = a2;
  if (a2 && *((_QWORD *)a2 + 4))
  {
    CFRetain(a2);
    v4 = *(NSObject **)(v8[3] + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10008FD00;
    block[3] = &unk_10022F160;
    block[4] = &v7;
    block[5] = a3;
    dispatch_async(v4, block);
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager or queue", "WiFiManagerScheduleWithQueue_block_invoke_13");
    objc_autoreleasePoolPop(v5);
  }
  _Block_object_dispose(&v7, 8);
}

void sub_10008FCE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_10008FD00(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  void *v7;
  uint64_t v8;
  const void *v9;

  v2 = *(_QWORD *)(a1 + 40);
  if ((unint64_t)(v2 - 1) <= 1)
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: call state changed to %d", "WiFiManagerScheduleWithQueue_block_invoke_14", -[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress"));
    objc_autoreleasePoolPop(v3);
    v4 = -[WiFiUserInteractionMonitor isWiFiCallInProgress](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isWiFiCallInProgress");
    v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v4)
      sub_10008FE54(v5);
    else
      sub_10008FFF8(v5);
    v2 = *(_QWORD *)(a1 + 40);
  }
  if (v2 == 16)
  {
    v6 = -[WiFiUserInteractionMonitor isGameModeActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isGameModeActive");
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: game state changed to %d", "WiFiManagerScheduleWithQueue_block_invoke_14", v6);
    objc_autoreleasePoolPop(v7);
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
      sub_100090154(v8);
    else
      sub_100090250(v8);
  }
  v9 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_10008FE54(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  void *v4;
  void *v5;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("CB06911C-82BE-44A9-8359-F8C02AAF82DB");
  values[1] = kCFBooleanTrue;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    if (!*(_BYTE *)(a1 + 2288))
    {
      *(_BYTE *)(a1 + 2288) = 1;
      if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
      {
        if (*(_BYTE *)(a1 + 314)
          && -[WiFiUserInteractionMonitor isCallKitActive](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isCallKitActive"))
        {
          v4 = *(void **)(a1 + 1480);
          if ((objc_msgSend(v4, "isMegaWiFiProfileInstalled") & 1) != 0)
          {
            if (*(double *)(a1 + 2280) != 0.0)
              *(_QWORD *)(a1 + 2280) = 0;
          }
          else
          {
            objc_msgSend(v4, "installMegaWiFiProfile");
            *(_BYTE *)(a1 + 2276) = 1;
            *(_QWORD *)(a1 + 2280) = 0;
            v5 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MegaWiFiProfile has been installed", "WiFiManagerWiFiFaceTimeCallStart");
            objc_autoreleasePoolPop(v5);
          }
        }
      }
    }
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v3;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_10008FFF8(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  void *v4;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("CB06911C-82BE-44A9-8359-F8C02AAF82DB");
  values[1] = kCFBooleanFalse;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    if (*(_BYTE *)(a1 + 2288))
    {
      *(_BYTE *)(a1 + 2288) = 0;
      if (MGGetBoolAnswer(CFSTR("apple-internal-install")))
      {
        if (*(_BYTE *)(a1 + 2276))
        {
          v4 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: MegaWiFiProfile has been scheduled for removal", "WiFiManagerWiFiFaceTimeCallEnd");
          objc_autoreleasePoolPop(v4);
          *(CFAbsoluteTime *)(a1 + 2280) = CFAbsoluteTimeGetCurrent();
        }
      }
    }
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v3;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_100090154(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("kApple80211KeyGameModeUUIDString");
  values[1] = kCFBooleanTrue;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    if (!*(_BYTE *)(a1 + 2289))
      *(_BYTE *)(a1 + 2289) = 1;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_100090250(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("kApple80211KeyGameModeUUIDString");
  values[1] = kCFBooleanFalse;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    if (*(_BYTE *)(a1 + 2289))
      *(_BYTE *)(a1 + 2289) = 0;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

uint64_t sub_100090348(uint64_t a1, const void *a2, int a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  char v10;
  _BYTE *ValueAtIndex;
  uint64_t v12;

  v5 = sub_10000B29C(*(CFArrayRef *)(a1 + 32));
  if (v5)
  {
    v6 = v5;
    Count = CFArrayGetCount(v5);
    if (Count < 1)
    {
      v10 = 0;
    }
    else
    {
      v8 = Count;
      v9 = 0;
      v10 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, v9);
        v12 = sub_1000161D4((uint64_t)ValueAtIndex);
        if (v12 && sub_100029860(v12))
          v10 = sub_10010AB54(ValueAtIndex, a2, a3);
        ++v9;
      }
      while (v8 != v9);
    }
    CFRelease(v6);
  }
  else
  {
    v10 = 0;
  }
  return v10 & 1;
}

uint64_t sub_100090404(uint64_t a1, const __CFData *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  uint64_t v8;
  const void *ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  void *v12;

  v3 = sub_10000B29C(*(CFArrayRef *)(a1 + 32));
  if (!v3)
    return 4294963365;
  v4 = v3;
  Count = CFArrayGetCount(v3);
  if (Count < 1)
  {
    v8 = 4294963365;
  }
  else
  {
    v6 = Count;
    v7 = 0;
    v8 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v4, v7);
      v10 = sub_1000161D4((uint64_t)ValueAtIndex);
      if (v10)
      {
        v11 = sub_100029860(v10);
        if (v11)
        {
          v8 = sub_10011FB78((uint64_t)ValueAtIndex, v11, a2);
          if ((_DWORD)v8)
          {
            v12 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: NDD trigger failed[%d]\n", "__WiFiManagerPerformNDD", v8);
            objc_autoreleasePoolPop(v12);
          }
        }
      }
      ++v7;
    }
    while (v6 != v7);
  }
  CFRelease(v4);
  return v8;
}

void sub_100090510(id a1, CWFXPCEvent *a2)
{
  objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendXPCEvent:", a2);
}

uint64_t sub_10009053C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  _QWORD v7[2];
  _QWORD v8[2];

  if (!a1 || !*(_QWORD *)(a1 + 1792))
    return 4294963389;
  result = 4294963396;
  if (a3 && a4)
  {
    if (a5)
    {
      v7[0] = CWFNDDREQUESTPARAMSKEY;
      v7[1] = CWFNDDREQUESTCLIENTKEY;
      v8[0] = a3;
      v8[1] = a4;
      return (uint64_t)objc_msgSend(*(id *)(a1 + 1792), "handleRequest:withData:interface:", a2, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v8, v7, 2), a5);
    }
  }
  return result;
}

void sub_10009060C(uint64_t a1, void *a2, void *a3, void *a4, int a5)
{
  void *v10;
  CFTypeRef *v11;
  const void *v12;
  const void *v13;
  _QWORD v14[4];

  v10 = objc_autoreleasePoolPush();
  if (a1)
  {
    *(_BYTE *)(a1 + 2346) = 0;
    v11 = (CFTypeRef *)(a1 + 2368);
    *(_BYTE *)(a1 + 2392) = 0;
    if (a5)
    {
      if (*v11)
      {
        CFRelease(*v11);
        *v11 = 0;
      }
      v12 = *(const void **)(a1 + 2376);
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 2376) = 0;
      }
      v13 = *(const void **)(a1 + 2384);
      if (v13)
      {
        CFRelease(v13);
        *(_QWORD *)(a1 + 2384) = 0;
      }
      *(_QWORD *)(a1 + 2368) = objc_msgSend(a2, "copy");
      *(_QWORD *)(a1 + 2376) = objc_msgSend(a3, "copy");
      *(_QWORD *)(a1 + 2384) = objc_msgSend(a4, "copy");
      *(_BYTE *)(a1 + 2392) = 1;
      *(_BYTE *)(a1 + 2346) = 1;
    }
    v14[0] = a1;
    v14[1] = 0xAAAAAAAA0000007FLL;
    v14[2] = a1 + 2368;
    v14[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v14);
  }
  objc_autoreleasePoolPop(v10);
}

void sub_100090708(uint64_t a1)
{
  const __SCDynamicStore *v2;
  const void *v3;

  v2 = *(const __SCDynamicStore **)(a1 + 72);
  if (v2)
  {
    SCDynamicStoreSetDispatchQueue(v2, 0);
    v3 = *(const void **)(a1 + 72);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 72) = 0;
    }
  }
}

void sub_100090744(uint64_t a1)
{
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "stopMonitoringCarSession");

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = 0;
}

uint64_t sub_100090780(uint64_t a1)
{
  uint64_t result;

  result = notify_is_valid_token(*(_DWORD *)(a1 + 1592));
  if ((_DWORD)result)
  {
    result = notify_cancel(*(_DWORD *)(a1 + 1592));
    *(_DWORD *)(a1 + 1592) = -1;
  }
  return result;
}

void sub_1000907B8(uint64_t a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s", "WiFiManagerEnable");
  objc_autoreleasePoolPop(v2);
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 25))
    {
      *(_BYTE *)(a1 + 25) = 1;
      sub_1000094BC(a1, 1);
    }
  }
}

void sub_100090844(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 25))
    {
      *(_BYTE *)(a1 + 25) = 0;
      sub_1000094BC(a1, 0);
    }
  }
}

void sub_100090860(uint64_t a1, int a2)
{
  void *v3;
  _QWORD context[4];
  int v5;

  v5 = a2;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    v3 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s not allowed with Unified Auto-Join", "WiFiManagerAssociate");
    objc_autoreleasePoolPop(v3);
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    sub_100090934(a1, *(_DWORD *)(a1 + 2072), *(CFTypeRef *)(a1 + 2080), 0);
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000000DLL;
    context[2] = &v5;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_100090934(uint64_t a1, unsigned int a2, CFTypeRef cf, int a4)
{
  int v8;
  unsigned int v9;
  const void *v10;
  int v11;
  CFTypeRef v12;
  int v13;
  const void *v14;
  double Current;
  void *v16;
  void *v17;
  const __CFString *v18;
  void *v19;
  _QWORD context[4];

  v8 = *(_DWORD *)(a1 + 2072);
  if (v8 == a2)
  {
    v9 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 2072) = a2;
    v9 = a2;
  }
  v10 = *(const void **)(a1 + 2080);
  if (!cf)
  {
    if (!v10)
    {
      v13 = 0;
      goto LABEL_25;
    }
    v14 = *(const void **)(a1 + 2080);
LABEL_22:
    CFRelease(v14);
    *(_QWORD *)(a1 + 2080) = 0;
LABEL_23:
    v9 = *(_DWORD *)(a1 + 2072);
    v13 = 1;
    goto LABEL_25;
  }
  if (v10)
  {
    v11 = CFEqual(cf, v10);
    v12 = *(CFTypeRef *)(a1 + 2080);
    if (v11)
    {
      v13 = 0;
      goto LABEL_13;
    }
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a1 + 2080) = 0;
    }
  }
  v12 = CFRetain(cf);
  *(_QWORD *)(a1 + 2080) = v12;
  v13 = 1;
LABEL_13:
  if (!v12)
    goto LABEL_25;
  Current = CFAbsoluteTimeGetCurrent();
  if (Current >= CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 2080)))
  {
    if (!*(_DWORD *)(a1 + 2072))
      goto LABEL_25;
    v17 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no longer in disabled period. Re-enabling join recommendation for %@ networks", "WiFiManagerSetJoinRecommendationMode", sub_100091360(*(_DWORD *)(a1 + 2072)));
    objc_autoreleasePoolPop(v17);
    v14 = *(const void **)(a1 + 2080);
    if (!v14)
      goto LABEL_23;
    goto LABEL_22;
  }
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: join recommendation is disabled by user until %@", "WiFiManagerSetJoinRecommendationMode", *(_QWORD *)(a1 + 2080));
  objc_autoreleasePoolPop(v16);
  v9 = 0;
LABEL_25:
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000001ALL;
  context[2] = v9;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  if (v8 == a2)
  {
    if (!v13)
      return;
  }
  else
  {
    v18 = sub_100091360(*(_DWORD *)(a1 + 2072));
    if (v18)
      sub_100087488((_QWORD *)a1, CFSTR("JoinRecommendationMode"), v18, a4);
    if (!v13)
      goto LABEL_32;
  }
  sub_100087488((_QWORD *)a1, CFSTR("JoinRecommendationDisabledUntil"), *(const void **)(a1 + 2080), a4);
LABEL_32:
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: JoinRecommendation: mode: %@, disabledUntil: %@", "WiFiManagerSetJoinRecommendationMode", sub_100091360(*(_DWORD *)(a1 + 2072)), *(_QWORD *)(a1 + 2080));
  objc_autoreleasePoolPop(v19);
}

void sub_100090B8C(uint64_t a1)
{
  _QWORD v1[4];

  v1[0] = a1;
  v1[1] = 0xAAAAAAAA00000013;
  v1[2] = 0;
  v1[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v1);
}

uint64_t sub_100090BD0(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 314);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: managerRef is NULL", "WiFiManagerGetDeviceExternallyPowered");
  objc_autoreleasePoolPop(v2);
  return 0;
}

uint64_t sub_100090C3C(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned int *)(a1 + 984);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: managerRef is NULL", "WiFiManagerGetDeviceBatteryLevel");
  objc_autoreleasePoolPop(v2);
  return 0;
}

BOOL sub_100090CA8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 880) == 0;
}

__CFArray *sub_100090CB8(uint64_t a1, const __CFString *a2)
{
  CFArrayRef v3;
  const __CFArray *v4;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v10;
  const __CFString *v11;

  if (!a1)
    return 0;
  v3 = sub_100090DA4(a1);
  if (!v3)
    return 0;
  v4 = v3;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
        if (ValueAtIndex)
        {
          v10 = ValueAtIndex;
          v11 = (const __CFString *)sub_1000CB154((uint64_t)ValueAtIndex);
          if (v11)
          {
            if (CFStringCompare(v11, a2, 0) == kCFCompareEqualTo)
            {
              CFArrayAppendValue(Mutable, v10);
              if (!CFArrayGetCount(Mutable))
              {
                if (Mutable)
                {
                  CFRelease(Mutable);
                  Mutable = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  CFRelease(v4);
  return Mutable;
}

CFArrayRef sub_100090DA4(uint64_t a1)
{
  const __CFArray *v2;

  v2 = *(const __CFArray **)(a1 + 216);
  if (v2 && CFArrayGetCount(v2))
    return CFArrayCreateCopy(kCFAllocatorDefault, *(CFArrayRef *)(a1 + 216));
  else
    return 0;
}

__CFArray *sub_100090DF0(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v5;
  const void *ValueAtIndex;
  _WORD *v7;

  v2 = *(const __CFArray **)(a1 + 216);
  if (!v2 || !CFArrayGetCount(v2))
    return 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 216));
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
  if (Mutable && CFArrayGetCount(*(CFArrayRef *)(a1 + 216)) >= 1)
  {
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), v5);
      if (ValueAtIndex)
      {
        v7 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
        CFArrayAppendValue(Mutable, v7);
        CFRelease(v7);
      }
      ++v5;
    }
    while (v5 < CFArrayGetCount(*(CFArrayRef *)(a1 + 216)));
  }
  return Mutable;
}

const __CFArray *sub_100090EC4(uint64_t a1)
{
  const __CFArray *result;
  const __CFArray *v2;
  __CFArray *v3;

  result = sub_100090DA4(a1);
  if (result)
  {
    v2 = result;
    v3 = sub_100064614(result);
    CFRelease(v2);
    return v3;
  }
  return result;
}

void sub_100090EFC(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v8;
  const void *v9;
  void *v10;
  __CFArray *v11;
  void *v12;
  CFRange v13;

  if (a1)
  {
    v2 = *(const __CFArray **)(a1 + 216);
    if (v2)
    {
      Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        v4 = Count;
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        for (i = 0; i != v4; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), i);
          if (!sub_100007F24((uint64_t)ValueAtIndex))
          {
            v8 = sub_1000CB504((uint64_t)ValueAtIndex);
            if (v8)
            {
              v9 = v8;
              v10 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Adding %@ disabled until %@", "WiFiManagerReloadNetworksDisabledUntil", sub_10002B088(ValueAtIndex), v9);
              objc_autoreleasePoolPop(v10);
              CFArrayAppendValue(Mutable, ValueAtIndex);
            }
          }
        }
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1976));
        if (CFArrayGetCount(Mutable) >= 1)
        {
          v11 = *(__CFArray **)(a1 + 1976);
          v13.length = CFArrayGetCount(Mutable);
          v13.location = 0;
          CFArrayAppendArray(v11, Mutable, v13);
        }
        if (Mutable)
          CFRelease(Mutable);
      }
    }
  }
  else
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerReloadNetworksDisabledUntil");
    objc_autoreleasePoolPop(v12);
  }
}

void sub_1000910C8(uint64_t a1, const __CFDictionary *cf1)
{
  const void *v4;
  const void *v5;
  _QWORD v6[4];

  if (!cf1 || (v4 = *(const void **)(a1 + 208)) == 0 || !CFEqual(cf1, v4))
  {
    v5 = *(const void **)(a1 + 208);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 208) = 0;
    }
    if (cf1)
      *(_QWORD *)(a1 + 208) = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, cf1);
    v6[0] = a1;
    v6[1] = 0xAAAAAAAA00000004;
    v6[2] = 0;
    v6[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v6);
    if (cf1)
      -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", cf1, CFSTR("Custom network settings"));
  }
}

void sub_100091188(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000051;
  v2[2] = a2;
  v2[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
}

void sub_1000911CC(uint64_t a1, char a2)
{
  _QWORD v2[4];

  *(_BYTE *)(a1 + 1232) = a2;
  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000027;
  v2[2] = 0;
  v2[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
}

void sub_100091214(uint64_t a1, int a2, int a3)
{
  int v3;
  const CFStringRef *v7;
  const CFStringRef *v8;
  CFStringRef v9;
  _QWORD v10[4];

  v3 = *(_DWORD *)(a1 + 304);
  if (v3 != a2)
  {
    *(_DWORD *)(a1 + 304) = a2;
    v10[0] = a1;
    v10[1] = 0xAAAAAAAA00000017;
    v10[2] = 0;
    v10[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v10);
    v7 = &kSCValNetAirPortJoinModeAutomatic;
    v8 = &kSCValNetAirPortJoinModeAutomatic;
    switch(a2)
    {
      case 0:
        goto LABEL_7;
      case 1:
        v8 = &kSCValNetAirPortJoinModePreferred;
        goto LABEL_7;
      case 2:
        v8 = &kSCValNetAirPortJoinModeRecent;
        goto LABEL_7;
      case 3:
        v8 = &kSCValNetAirPortJoinModeStrongest;
        goto LABEL_7;
      case 4:
        v8 = &kSCValNetAirPortJoinModeRanked;
LABEL_7:
        if (*v8)
        {
          switch(a2)
          {
            case 0:
              goto LABEL_14;
            case 1:
              v7 = &kSCValNetAirPortJoinModePreferred;
              goto LABEL_14;
            case 2:
              v7 = &kSCValNetAirPortJoinModeRecent;
              goto LABEL_14;
            case 3:
              v7 = &kSCValNetAirPortJoinModeStrongest;
              goto LABEL_14;
            case 4:
              v7 = &kSCValNetAirPortJoinModeRanked;
LABEL_14:
              v9 = *v7;
              break;
            default:
              v9 = 0;
              break;
          }
          sub_100087488((_QWORD *)a1, kSCPropNetAirPortJoinMode, v9, a3);
        }
        break;
      case 5:
        *(_DWORD *)(a1 + 304) = v3;
        break;
      default:
        return;
    }
  }
}

const __CFString *sub_100091360(int a1)
{
  const __CFString *result;

  if (a1 <= 251)
  {
    if (a1)
    {
      if (a1 == 1)
      {
        return CFSTR("Quality");
      }
      else if (a1 == 2)
      {
        return CFSTR("Captive");
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return CFSTR("None");
    }
  }
  else
  {
    switch(a1)
    {
      case 252:
        result = CFSTR("Public");
        break;
      case 253:
        result = CFSTR("NewLocation");
        break;
      case 254:
        result = CFSTR("InfrequentNetwork");
        break;
      case 255:
        result = CFSTR("All");
        break;
      default:
        return 0;
    }
  }
  return result;
}

void sub_1000913FC(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  void *v15;
  const void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  void *v20;
  int v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  void **block;
  unint64_t v29;
  BOOL (*v30)(uint64_t);
  uint64_t v31;
  uint64_t v32;

  if (*(_BYTE *)(a1 + 1328))
  {
    if (*(_QWORD *)(a1 + 848))
      v2 = 1;
    else
      v2 = 3;
    if (*(_QWORD *)(a1 + 848))
      v3 = 2;
    else
      v3 = 3;
    if (*(_QWORD *)(a1 + 864))
      v4 = v3;
    else
      v4 = v2;
  }
  else
  {
    v4 = 0;
  }
  -[WiFiUserInteractionMonitor setCurrentDisplayState:andLockState:](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "setCurrentDisplayState:andLockState:", *(_QWORD *)(a1 + 848) != 0, *(_QWORD *)(a1 + 864) != 0);
  if (*(_DWORD *)(a1 + 1312) != v4)
  {
    *(_DWORD *)(a1 + 1312) = v4;
    if (v4 == 1)
    {
      if (*(_BYTE *)(a1 + 1808))
      {
        *(_BYTE *)(a1 + 1808) = 0;
        block = _NSConcreteStackBlock;
        v29 = 3221225472;
        v30 = sub_1000BAAD4;
        v31 = (uint64_t)&unk_10022EA38;
        v32 = a1;
        dispatch_async((dispatch_queue_t)qword_10026DD40, &block);
      }
    }
    else if ((v4 - 1) > 1)
    {
      goto LABEL_40;
    }
    v5 = objc_autoreleasePoolPush();
    if (sub_10000AF8C(a1))
      goto LABEL_37;
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: user auto join state is disabled, checking to re-enable", "__WiFiManagerCheckUserAutoJoinEnable");
    objc_autoreleasePoolPop(v6);
    v7 = *(void **)(a1 + 1960);
    if (objc_msgSend(*(id *)(a1 + 1696), "isAuthorized"))
    {
      if (*(_BYTE *)(a1 + 1953))
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no location was available when disabled", "__WiFiManagerCheckUserAutoJoinEnable");
      }
      else
      {
        if (v7)
        {
          v8 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1696), "latestLocation"), "copy");
          if (+[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v8, 1, 60.0))
          {
            objc_msgSend(v7, "horizontalAccuracy");
            v10 = v9;
            objc_msgSend(v8, "horizontalAccuracy");
            v12 = v11;
            objc_msgSend(v8, "distanceFromLocation:", v7);
            v14 = v13 - v10 - v12;
            v15 = objc_autoreleasePoolPush();
            if (v14 > 300.0)
            {
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: distance (%f) passed fence size (%f)", "__WiFiManagerCheckUserAutoJoinEnable", *(_QWORD *)&v14, 0x4072C00000000000);
              objc_autoreleasePoolPop(v15);
              *(_BYTE *)(a1 + 1952) = 0;
              v16 = *(const void **)(a1 + 1960);
              if (v16)
              {
                CFRelease(v16);
                *(_QWORD *)(a1 + 1960) = 0;
              }
              sub_100087488((_QWORD *)a1, CFSTR("UserAutoJoinDisabledLoc"), 0, 0);
LABEL_30:
              v17 = *(_DWORD *)(a1 + 1408);
              v18 = *(_QWORD *)(a1 + 1416);
              v19 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: motionState %@ (time %f)", "__WiFiManagerCheckUserAutoJoinEnable", sub_100024674(v17), v18);
              objc_autoreleasePoolPop(v19);
              v20 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabling user auto join due to motion state", "__WiFiManagerCheckUserAutoJoinEnable");
              objc_autoreleasePoolPop(v20);
              sub_1000898A0(a1, 1, 4, 0);
LABEL_35:
              if (v8)
                CFRelease(v8);
LABEL_37:
              objc_autoreleasePoolPop(v5);
              sub_100091914(a1, 0);
              if (!*(_BYTE *)(a1 + 2217)
                && -[WiFiUserInteractionMonitor isSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isSetupCompleted"))
              {
                sub_10008C6C0(a1);
              }
              goto LABEL_40;
            }
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s, distance (%f) from disabling is less than fence size (%f)", "__WiFiManagerCheckUserAutoJoinEnable", *(_QWORD *)&v14, 0x4072C00000000000);
          }
          else
          {
            v15 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: leeched location is not high accuracy", "__WiFiManagerCheckUserAutoJoinEnable", v26, v27);
          }
LABEL_45:
          objc_autoreleasePoolPop(v15);
          if (*(_QWORD *)(a1 + 1968))
          {
            v22 = objc_alloc_init((Class)NSDate);
            v23 = objc_msgSend(*(id *)(a1 + 1968), "compare:", v22);
            v24 = objc_autoreleasePoolPush();
            if (v23 == (id)-1)
            {
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabling user auto join due to time (date: %@)", "__WiFiManagerCheckUserAutoJoinEnable", *(_QWORD *)(a1 + 1968));
              objc_autoreleasePoolPop(v24);
              sub_1000898A0(a1, 1, 5, 0);
            }
            else
            {
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: keeping user auto join disabled, not past date %@", "__WiFiManagerCheckUserAutoJoinEnable", *(_QWORD *)(a1 + 1968));
              objc_autoreleasePoolPop(v24);
            }
            if (v22)
              CFRelease(v22);
          }
          else
          {
            v25 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no user auto join expiration date", "__WiFiManagerCheckUserAutoJoinEnable");
            objc_autoreleasePoolPop(v25);
          }
          goto LABEL_35;
        }
        v21 = *(unsigned __int8 *)(a1 + 1952);
        v15 = objc_autoreleasePoolPush();
        if (!v21)
        {
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: already past geofence. Checking motion activity.", "__WiFiManagerCheckUserAutoJoinEnable");
          objc_autoreleasePoolPop(v15);
          v8 = 0;
          goto LABEL_30;
        }
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no disabled location", "__WiFiManagerCheckUserAutoJoinEnable");
      }
    }
    else
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifi not authroized for location services", "__WiFiManagerCheckUserAutoJoinEnable");
    }
    v8 = 0;
    goto LABEL_45;
  }
LABEL_40:
  block = (void **)a1;
  v29 = 0xAAAAAAAA0000000ALL;
  v30 = 0;
  v31 = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &block);
}

void sub_100091914(uint64_t a1, unsigned int a2)
{
  void *v4;
  CFIndex Count;
  CFIndex v6;
  CFAbsoluteTime Current;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDate *v11;
  const __CFDate *v12;
  void *v13;
  void *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex j;
  void *v18;
  void *v19;
  const __CFDate *theDate;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Checking networks disabled until date (removeAll %d)", "WiFiManagerCheckNetworksDisabledUntil", a2);
  objc_autoreleasePoolPop(v4);
  if (a1)
  {
    if (*(_QWORD *)(a1 + 1976))
    {
      if (sub_10000AF8C(a1))
      {
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1976));
        if (Count >= 1)
        {
          v6 = Count;
          Current = CFAbsoluteTimeGetCurrent();
          theDate = CFDateCreate(kCFAllocatorDefault, Current);
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          for (i = 0; i != v6; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1976), i);
            if (!sub_100007F24((uint64_t)ValueAtIndex))
            {
              v11 = (const __CFDate *)sub_1000CB504((uint64_t)ValueAtIndex);
              if (v11)
              {
                v12 = v11;
                v13 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ disabled until %@", "WiFiManagerCheckNetworksDisabledUntil", sub_10002B088(ValueAtIndex), v12);
                objc_autoreleasePoolPop(v13);
                if (a2 || CFDateCompare(theDate, v12, 0) == kCFCompareGreaterThan)
                {
                  v14 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: enabling network %@", "WiFiManagerCheckNetworksDisabledUntil", sub_10002B088(ValueAtIndex));
                  objc_autoreleasePoolPop(v14);
                  CFArrayAppendValue(Mutable, ValueAtIndex);
                }
              }
            }
          }
          v15 = CFArrayGetCount(Mutable);
          if (v15 >= 1)
          {
            v16 = v15;
            for (j = 0; j != v16; ++j)
            {
              v18 = (void *)CFArrayGetValueAtIndex(Mutable, j);
              sub_1000C682C((uint64_t)v18, 0);
              sub_1000C6770((uint64_t)v18, 1);
              sub_100099EA4(a1, v18, 1u);
            }
            sub_100090EFC(a1);
          }
          if (Mutable)
            CFRelease(Mutable);
          if (theDate)
            CFRelease(theDate);
        }
      }
    }
  }
  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerCheckNetworksDisabledUntil");
    objc_autoreleasePoolPop(v19);
  }
}

uint64_t sub_100091BC8(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned int *)(a1 + 1312);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager Param is NULL!", "WiFiManagerGetUserInteractionMode");
  objc_autoreleasePoolPop(v2);
  return 3;
}

uint64_t sub_100091C34(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

void sub_100091C3C(uint64_t a1, unsigned int a2, int a3)
{
  void *v4;
  CFNumberRef v7;
  CFNumberRef v8;
  _QWORD context[4];
  unsigned int valuePtr;

  if (byte_10026DD61)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Lockdown Mode is enabled, ignoring set WiFiAskToJoinPreferenceType %ld", "WiFiManagerSetAskToJoinPreference", a2);
    objc_autoreleasePoolPop(v4);
  }
  else if (*(_DWORD *)(a1 + 824) != a2)
  {
    *(_DWORD *)(a1 + 824) = a2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000001BLL;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    valuePtr = a2;
    v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v7)
    {
      v8 = v7;
      sub_100087488((_QWORD *)a1, CFSTR("ATJPreference"), v7, a3);
      CFRelease(v8);
    }
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendUserSettingsDidChangeEvent");
  }
}

uint64_t sub_100091D64(uint64_t a1)
{
  return *(unsigned int *)(a1 + 824);
}

void sub_100091D6C(uint64_t a1, uint64_t a2, int a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  void *v8;
  void *v9;
  int v10;
  uint64_t valuePtr;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_DWORD *)(a1 + 336) != (_DWORD)a2)
  {
    *(_DWORD *)(a1 + 336) = a2;
    LODWORD(valuePtr) = a2;
    v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v6)
    {
      v7 = v6;
      sub_100087488((_QWORD *)a1, CFSTR("Compatibility"), v6, a3);
      CFRelease(v7);
    }
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: mode:%u", "WiFiManagerSet6ECompatibilityMode", a2);
    objc_autoreleasePoolPop(v8);
    v9 = *(void **)(a1 + 2416);
    if (v9)
      objc_msgSend(v9, "updateWithCompatibilityMode:", (_DWORD)a2 == 0);
    objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendUserSettingsDidChangeEvent");
    valuePtr = a1;
    v12 = 0xAAAAAAAA00000088;
    v13 = 0;
    v14 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &valuePtr);
    if ((_BYTE)v14)
    {
      if ((_DWORD)a2)
      {
        if ((_DWORD)a2 != 1)
          return;
        valuePtr = a1;
        v12 = 0xAAAAAAAAAAAAAAAALL;
        v10 = 137;
      }
      else
      {
        valuePtr = a1;
        v12 = 0xAAAAAAAAAAAAAAAALL;
        v10 = 138;
      }
      LODWORD(v12) = v10;
      v13 = 0;
      v14 = 0;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &valuePtr);
    }
  }
}

uint64_t sub_100091ECC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 2072);
}

uint64_t sub_100091ED4(uint64_t result, int a2)
{
  _QWORD *v3;
  const void **v4;
  _QWORD v5[4];

  if (*(unsigned __int8 *)(result + 308) != a2)
  {
    v3 = (_QWORD *)result;
    *(_BYTE *)(result + 308) = a2;
    v5[0] = result;
    v5[1] = 0xAAAAAAAA0000001DLL;
    v5[2] = 0;
    v5[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(result + 104), (CFSetApplierFunction)sub_10002E0D4, v5);
    v4 = (const void **)&kCFBooleanFalse;
    if (a2)
      v4 = (const void **)&kCFBooleanTrue;
    return sub_100087488(v3, CFSTR("mStageAutoJoin"), *v4, 0);
  }
  return result;
}

void sub_100091F6C(uint64_t a1, int a2, int a3, CFTypeRef cf)
{
  CFTypeID v8;
  double Current;
  int v10;
  int v11;
  const char *v12;
  void *v13;
  CFBooleanRef v14;
  CFBooleanRef v15;
  CFAbsoluteTime v16;
  CFDateRef v17;
  _QWORD context[4];

  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFDateGetTypeID()))
  {
    v10 = 1;
    goto LABEL_6;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v10 = 0;
  if (Current - CFDateGetAbsoluteTime((CFDateRef)cf) < 604800.0)
  {
LABEL_6:
    v11 = 1;
    v12 = "ENABLED";
    goto LABEL_7;
  }
  v11 = 0;
  v12 = "DISABLED";
LABEL_7:
  if (*(unsigned __int8 *)(a1 + 309) != a2
    || *(unsigned __int8 *)(a1 + 310) != a3
    || *(unsigned __int8 *)(a1 + 311) != v11)
  {
    if (*(unsigned __int8 *)(a1 + 311) != v11)
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Device updated learning phase to %s", v12);
      objc_autoreleasePoolPop(v13);
    }
    *(_BYTE *)(a1 + 309) = a2;
    *(_BYTE *)(a1 + 310) = a3;
    *(_BYTE *)(a1 + 311) = v11;
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000001ELL;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    if (a2)
      v14 = kCFBooleanTrue;
    else
      v14 = kCFBooleanFalse;
    sub_100087488((_QWORD *)a1, CFSTR("optimizedAutoJoin"), v14, 0);
    if (a3)
      v15 = kCFBooleanTrue;
    else
      v15 = kCFBooleanFalse;
    sub_100087488((_QWORD *)a1, CFSTR("Enable5GhzAutoJoinScan"), v15, 0);
    if (v10)
    {
      v16 = CFAbsoluteTimeGetCurrent();
      v17 = CFDateCreate(kCFAllocatorDefault, v16);
      sub_100087488((_QWORD *)a1, CFSTR("deviceUpdatedDate"), v17, 0);
      if (v17)
        CFRelease(v17);
    }
  }
}

void sub_100092158(uint64_t a1, char a2)
{
  _QWORD context[4];
  char v3;

  v3 = a2;
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000077;
  context[2] = &v3;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
}

void sub_1000921A4(uint64_t a1, const __CFString *a2, int a3)
{
  int v6;
  void *v7;
  const char *v8;
  int v9;
  int v10;
  void *v11;
  const char *v12;
  int v13;
  uint64_t context;
  unint64_t v15;
  int *v16;
  uint64_t v17;

  context = a1;
  v15 = 0xAAAAAAAA00000034;
  v16 = 0;
  v17 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  v6 = v17;
  *(_BYTE *)(a1 + 1208) = v17;
  if (v6 == a3)
  {
    v7 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (*(_BYTE *)(a1 + 1208) == 1)
        v8 = "enabled";
      else
        v8 = "disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS is already %s", v8);
    }
    objc_autoreleasePoolPop(v7);
    return;
  }
  *(_BYTE *)(a1 + 1208) = a3;
  if (!a3)
  {
    v13 = 0;
    if (sub_1000666C0(a2))
    {
      v9 = *(_DWORD *)(a1 + 340);
      if (v9 == 1)
      {
        v10 = 7;
      }
      else if (v9 == 2)
      {
        v10 = 6;
      }
      else
      {
        v10 = 3;
      }
    }
    else if (sub_100066658(a2))
    {
      v10 = 2;
    }
    else
    {
      if (!sub_100066624(a2) && !sub_1000666F4(a2))
        goto LABEL_22;
      v10 = 1;
    }
    v13 = v10;
LABEL_22:
    context = a1;
    v15 = 0xAAAAAAAA00000020;
    v16 = &v13;
    v17 = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    *(_BYTE *)(a1 + 1209) = 0;
    goto LABEL_23;
  }
  sub_1000923EC(a1, a2, a3, 0, 0, 0);
LABEL_23:
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 1208) == 1)
      v12 = "enabled";
    else
      v12 = "disabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS state set to %s", v12);
  }
  objc_autoreleasePoolPop(v11);
  if (objc_opt_class(CHSControlService))
    dispatch_async((dispatch_queue_t)qword_10026DD40, &stru_1002307A8);
}

uint64_t sub_1000923A8(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000034;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

void sub_1000923EC(uint64_t a1, const __CFString *a2, int a3, char a4, int a5, int a6)
{
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  const void *v18;
  char v19;
  const void *v20;
  void *v21;
  void *v22;
  const char *v23;
  const char *v24;
  void *v25;
  const char *v26;
  _QWORD v27[4];
  __int128 context;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  int v39;

  v39 = 0;
  if (sub_1000666C0(a2))
  {
    v12 = *(_DWORD *)(a1 + 340);
    if (v12 == 1)
    {
      v13 = 7;
LABEL_8:
      v39 = v13;
      v15 = _os_feature_enabled_impl("WiFiManager", "EnableNANPHS");
      v14 = 0;
      if (!a6)
        goto LABEL_19;
      goto LABEL_9;
    }
    if (v12 == 2)
    {
      v13 = 6;
      goto LABEL_8;
    }
    v16 = _os_feature_enabled_impl("WiFiManager", "EnableNANPHS");
    if (a6 && v16)
      goto LABEL_13;
    v14 = 0;
    v13 = 3;
LABEL_18:
    v39 = v13;
    goto LABEL_19;
  }
  if (sub_100066658(a2))
  {
    v14 = 0;
    v13 = 2;
    goto LABEL_18;
  }
  if (sub_100066624(a2) || sub_1000666F4(a2))
  {
    v14 = 0;
    v13 = 1;
    goto LABEL_18;
  }
  if (!sub_10006668C(a2))
  {
    v14 = 0;
    v13 = 0;
    goto LABEL_19;
  }
  v15 = _os_feature_enabled_impl("WiFiManager", "EnableNANPHS");
  v14 = 0;
  v13 = 0;
  if (a6)
  {
LABEL_9:
    if (!v15)
      goto LABEL_19;
LABEL_13:
    v13 = 8;
    v39 = 8;
    v14 = 1;
  }
LABEL_19:
  v17 = sub_1000666F4(a2);
  if (a3)
  {
    if (v17)
    {
      v18 = *(const void **)(a1 + 1224);
      if (v18)
        CFRelease(v18);
      *(_QWORD *)(a1 + 1224) = a2;
      CFRetain(a2);
    }
    if (a5)
      goto LABEL_25;
  }
  else if (v17)
  {
    v20 = *(const void **)(a1 + 1224);
    if (v20)
    {
      CFRelease(v20);
      *(_QWORD *)(a1 + 1224) = 0;
    }
  }
  if (*(unsigned __int8 *)(a1 + 1209) != a3 || *(unsigned __int8 *)(a1 + 1211) != a3)
  {
    *(_BYTE *)(a1 + 1211) = a3;
    if (a3)
      v19 = 0;
    else
      v19 = a4;
    if (!a3)
      LOBYTE(a5) = 0;
    goto LABEL_41;
  }
  if (a3 && (_os_feature_enabled_impl("WiFiManager", "EnableNANPHS") & v14) == 1)
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Bringing up NANPHS MIS Discovery is already enabled");
    objc_autoreleasePoolPop(v21);
LABEL_25:
    v19 = 0;
    *(_BYTE *)(a1 + 1211) = a3;
LABEL_41:
    *(_BYTE *)(a1 + 1210) = v19;
    *(_BYTE *)(a1 + 1212) = a5;
    *(_QWORD *)&context = a1;
    *((_QWORD *)&context + 1) = 0xAAAAAAAA00000021;
    *(_QWORD *)&v29 = &v39;
    *((_QWORD *)&v29 + 1) = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v23 = "disabled";
      if (*(_BYTE *)(a1 + 1211) == 1)
        v24 = "enabled";
      else
        v24 = "disabled";
      if (*(_BYTE *)(a1 + 1209) == 1)
        v23 = "enabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Discovery Req state %s Current state %s", v24, v23);
    }
    objc_autoreleasePoolPop(v22);
    return;
  }
  v25 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 1209) == 1)
      v26 = "enabled";
    else
      v26 = "disabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Discovery is already %s", v26);
  }
  objc_autoreleasePoolPop(v25);
  if (a3)
  {
    v38 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    context = 0u;
    v29 = 0u;
    LODWORD(context) = v13;
    v27[0] = a1;
    v27[1] = 0xAAAAAAAA0000004DLL;
    v27[2] = &context;
    v27[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v27);
  }
}

void sub_100092754(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Requesting PersonalHotspotControl extension to reload");
  objc_autoreleasePoolPop(v1);
  -[CHSControlService reloadControlsForExtension:kind:reason:](+[CHSControlService sharedInstance](CHSControlService, "sharedInstance"), "reloadControlsForExtension:kind:reason:", CFSTR("com.apple.WiFiKit.PersonalHotspotControl"), CFSTR("PersonalHotspotControl"), CFSTR("wifi manager set MIS state request PH widget to reload"));
}

uint64_t sub_1000927C0(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000083;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092804(uint64_t a1)
{
  void *v2;
  const char *v3;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 1209))
      v3 = "Enabled";
    else
      v3 = "Disabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "MIS Discovery is %s", v3);
  }
  objc_autoreleasePoolPop(v2);
  return *(unsigned __int8 *)(a1 + 1209);
}

void sub_10009287C(uint64_t a1, char a2, char a3, char a4, uint64_t a5)
{
  _QWORD v5[4];
  _QWORD v6[2];

  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = a5;
  LOBYTE(v6[0]) = a2;
  BYTE1(v6[0]) = a3;
  BYTE2(v6[0]) = a4;
  v5[0] = a1;
  v5[1] = 0xAAAAAAAA00000022;
  v5[2] = v6;
  v5[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v5);
}

uint64_t sub_1000928D4(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000030;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

__CFDictionary *sub_100092918(uint64_t a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  const void **v4;
  unsigned int Count;
  CFNumberRef v6;
  CFNumberRef v7;
  CFMutableArrayRef v8;
  void *v9;
  const char *v10;
  unsigned int valuePtr;

  if (!a1)
    return 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v3 = Mutable;
  if (Mutable)
  {
    v4 = (const void **)&kCFBooleanTrue;
    if (!*(_BYTE *)(a1 + 1160))
      v4 = (const void **)&kCFBooleanFalse;
    CFDictionaryAddValue(Mutable, CFSTR("WoWEnabled"), *v4);
    if (*(_BYTE *)(a1 + 1160))
      Count = CFSetGetCount(*(CFSetRef *)(a1 + 1168));
    else
      Count = 0;
    valuePtr = Count;
    v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v6)
    {
      v7 = v6;
      CFDictionaryAddValue(v3, CFSTR("WoWClientCount"), v6);
      CFRelease(v7);
    }
    if (valuePtr)
    {
      v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      CFSetApplyFunction(*(CFSetRef *)(a1 + 1168), (CFSetApplierFunction)sub_100092AB8, v8);
      CFDictionaryAddValue(v3, CFSTR("WoWClientPidList"), v8);
      if (v8)
        CFRelease(v8);
    }
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v10 = "Enabled";
      if (!*(_BYTE *)(a1 + 1160))
        v10 = "Disabled";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WoW is %s, %d WoW Clients", v10, valuePtr);
    }
    objc_autoreleasePoolPop(v9);
  }
  return v3;
}

void sub_100092AB8(uint64_t a1, __CFArray *a2)
{
  CFNumberRef v4;
  CFNumberRef v5;
  void *v6;
  int valuePtr;

  if (a1)
  {
    if (a2)
    {
      valuePtr = sub_10001493C(a1);
      v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (v4)
      {
        v5 = v4;
        v6 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@[%@] is a wow client", sub_1000161D4(a1), v5);
        objc_autoreleasePoolPop(v6);
        CFArrayAppendValue(a2, v5);
        CFRelease(v5);
      }
    }
  }
}

uint64_t sub_100092B74(uint64_t a1)
{
  void *v2;
  const char *v3;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 1176))
      v3 = "Enabled";
    else
      v3 = "Disabled";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "LPAS is %s", v3);
  }
  objc_autoreleasePoolPop(v2);
  return *(unsigned __int8 *)(a1 + 1176);
}

uint64_t sub_100092BEC(uint64_t a1)
{
  void *v2;
  const char *v3;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    if (*(_BYTE *)(a1 + 1184))
      v3 = "quiesced";
    else
      v3 = "unquiesced";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFi is %s (clients=%ld activity=%d)", v3, CFSetGetCount(*(CFSetRef *)(a1 + 1192)), objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isQuiesceWiFiActivityRegistered"));
  }
  objc_autoreleasePoolPop(v2);
  return *(unsigned __int8 *)(a1 + 1184);
}

uint64_t sub_100092C9C(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000032;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092CE0(_QWORD *a1)
{
  void *v1;

  if (sub_10001D90C(a1, CFSTR("SimulatedHardwareFailureStatus")))
  {
    v1 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Simulating a hardware failure", "WiFiManagerGetHardwareStatus");
    objc_autoreleasePoolPop(v1);
    return 2;
  }
  else if (sub_1000573F0())
  {
    return 2;
  }
  else
  {
    return 1;
  }
}

void sub_100092D6C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  v6 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "hardware failure status -- error %@", a3, v7);
  }
  else if (qword_10026DD20)
  {
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "hardware failure status -- success %d with status %d", a2, *(unsigned int *)(a1 + 32));
  }
  objc_autoreleasePoolPop(v6);
}

uint64_t sub_100092DF4(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000031;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092E38(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000031;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092E7C(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA0000003FLL;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092EC0(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA0000003FLL;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092F04(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000033;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092F48(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000033;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092F8C(uint64_t a1)
{
  _QWORD v2[3];
  uint64_t v3;

  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000048;
  v2[2] = 0;
  v3 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  return v3;
}

uint64_t sub_100092FD0(uint64_t a1, CFStringRef theString)
{
  const void *v4;
  CFStringRef Copy;
  _QWORD v7[3];
  uint64_t v8;

  v4 = *(const void **)(a1 + 1216);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 1216) = 0;
  }
  if (theString)
    Copy = CFStringCreateCopy(kCFAllocatorDefault, theString);
  else
    Copy = 0;
  *(_QWORD *)(a1 + 1216) = Copy;
  v7[0] = a1;
  v7[1] = 0xAAAAAAAA00000026;
  v7[2] = 0;
  v8 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v7);
  return v8;
}

CFStringRef sub_100093058(uint64_t a1)
{
  const __CFString *v2;
  _QWORD v4[4];

  v4[0] = a1;
  v4[1] = 0xAAAAAAAA00000035;
  v4[2] = 0;
  v4[3] = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v4);
  v2 = *(const __CFString **)(a1 + 1216);
  if (v2)
    return CFStringCreateCopy(kCFAllocatorDefault, v2);
  else
    return 0;
}

void sub_1000930C4(uint64_t a1, int a2)
{
  _QWORD v2[4];

  *(_DWORD *)(a1 + 276) = a2;
  v2[0] = a1;
  v2[1] = 0xAAAAAAAA00000023;
  v2[2] = 0;
  v2[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
}

uint64_t sub_10009310C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 276);
}

void sub_100093114(uint64_t a1, uint64_t a2, double a3)
{
  _QWORD v3[4];

  *(_QWORD *)(a1 + 280) = a2;
  *(double *)(a1 + 288) = a3;
  v3[0] = a1;
  v3[1] = 0xAAAAAAAA00000024;
  v3[2] = 0;
  v3[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v3);
}

void sub_100093160(uint64_t a1, uint64_t a2, double a3, double a4)
{
  _QWORD v4[6];

  v4[0] = a1;
  v4[1] = 0xAAAAAAAA00000063;
  v4[2] = a2;
  *(double *)&v4[3] = a3;
  *(double *)&v4[4] = a4;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v4);
}

void sub_1000931B0(uint64_t a1, unsigned int a2)
{
  _QWORD v4[4];

  if (*(_DWORD *)(a1 + 300) != a2)
  {
    *(_DWORD *)(a1 + 300) = a2;
    v4[0] = a1;
    v4[1] = 0xAAAAAAAA00000019;
    v4[2] = 0;
    v4[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v4);
    sub_10009322C((_QWORD *)a1, CFSTR("Fallback Preference"), a2, 0);
  }
}

void sub_10009322C(_QWORD *a1, const __CFString *a2, uint64_t a3, int a4)
{
  CFNumberRef v7;
  uint64_t valuePtr;

  valuePtr = a3;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  sub_100087488(a1, a2, v7, a4);
  if (v7)
    CFRelease(v7);
}

void sub_1000932A0(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 928) != a2)
  {
    *(double *)(a1 + 928) = a2;
    sub_1000932C4((_QWORD *)a1, CFSTR("DisassociationInterval"), a2);
  }
}

void sub_1000932C4(_QWORD *a1, const __CFString *a2, double a3)
{
  CFNumberRef v5;
  double valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  sub_100087488(a1, a2, v5, 0);
  if (v5)
    CFRelease(v5);
}

void sub_100093334(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 1880) != a2)
  {
    *(double *)(a1 + 1880) = a2;
    sub_1000932C4((_QWORD *)a1, CFSTR("DiagnosticsInterval"), a2);
  }
}

void sub_100093358(uint64_t a1, int a2, const __CFString *a3)
{
  void *v6;
  unsigned int v7;
  int v8;
  _QWORD context[3];
  uint64_t v10;

  if (a1)
  {
    if (objc_msgSend(*(id *)(a1 + 1480), "isWiFiPowerModificationDisabled"))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: wifi power cannot be modified, since modification is disabled %d", "WiFiManagerSetPower", 1);
      objc_autoreleasePoolPop(v6);
    }
    else
    {
      v7 = a2 != 0;
      v8 = *(_DWORD *)(a1 + 316);
      sub_10008F33C(a1, v7, a3);
      if (a3)
      {
        if (CFStringCompare(a3, CFSTR("Preferences"), 1uLL) == kCFCompareEqualTo && v8 != v7)
        {
          context[0] = a1;
          context[1] = 0xAAAAAAAA00000034;
          context[2] = 0;
          v10 = 0;
          CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
          if (!(_BYTE)v10 && !*(_BYTE *)(a1 + 2201))
            sub_1000934DC((void **)a1, v7);
        }
      }
    }
  }
}

uint64_t sub_100093470(uint64_t a1)
{
  void *v2;

  if (a1)
    return *(unsigned __int8 *)(a1 + 2201);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null manager", "WiFiManagerIsPowerModificationDisabled");
  objc_autoreleasePoolPop(v2);
  return 0;
}

void sub_1000934DC(void **a1, unsigned int a2)
{
  if (a2 <= 1)
  {
    if (a1[216])
      sub_10000E880(a1, a1[216], a2 == 1, 0);
  }
}

BOOL sub_100093504(uint64_t a1, const void *a2)
{
  _BOOL8 result;
  const __CFArray *v5;
  CFRange v6;

  result = 0;
  if (a1 && a2)
  {
    v5 = *(const __CFArray **)(a1 + 176);
    if (v5)
    {
      v6.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
      v6.location = 0;
      return CFArrayContainsValue(v5, v6, a2) != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_100093564(uint64_t a1, const __CFString *a2, unsigned int a3)
{
  void *v6;
  const __CFString *v7;
  double Current;
  double v9;
  void *v10;
  const void *v11;
  CFStringRef Copy;
  void *v13;
  void *v14;

  if (a2 || *(_QWORD *)(a1 + 2032))
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: countryCode %@, manager->ieCountryCode %@, force %d", "__WiFiManagerUpdateRegulatoryDomainCountryCode", a2, *(_QWORD *)(a1 + 2032), a3);
    objc_autoreleasePoolPop(v6);
    if (a2 && (v7 = *(const __CFString **)(a1 + 2032)) != 0 && CFStringCompare(a2, v7, 0) == kCFCompareEqualTo)
    {
      v14 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Country code %@ refreshed.", "__WiFiManagerUpdateRegulatoryDomainCountryCode", *(_QWORD *)(a1 + 2032));
      objc_autoreleasePoolPop(v14);
      *(CFAbsoluteTime *)(a1 + 2040) = CFAbsoluteTimeGetCurrent();
    }
    else
    {
      Current = CFAbsoluteTimeGetCurrent();
      if (a2 || (a3 & 1) != 0 || (v9 = Current - *(double *)(a1 + 2040), v9 >= 600.0))
      {
        v11 = *(const void **)(a1 + 2032);
        if (v11)
        {
          CFRelease(v11);
          *(_QWORD *)(a1 + 2032) = 0;
        }
        if (a2)
          Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
        else
          Copy = 0;
        *(_QWORD *)(a1 + 2032) = Copy;
        *(CFAbsoluteTime *)(a1 + 2040) = CFAbsoluteTimeGetCurrent();
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updating CountryCodeFromWiFiAPs to %@", "__WiFiManagerUpdateRegulatoryDomainCountryCode", a2);
        objc_autoreleasePoolPop(v13);
        RDUpdateCountryCodeFromWiFiAPs(a2);
        if (objc_msgSend(*(id *)(a1 + 192), "isDefaultCountryCode:", objc_msgSend(*(id *)(a1 + 192), "getLocaleCountryCode")))objc_msgSend(*(id *)(a1 + 192), "determineAndSetLocale:", 0);
      }
      else
      {
        v10 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Country code %@ refreshed %.2fs ago < %ds, not resetting", "__WiFiManagerUpdateRegulatoryDomainCountryCode", *(_QWORD *)(a1 + 2032), *(_QWORD *)&v9, 600);
        objc_autoreleasePoolPop(v10);
      }
    }
  }
}

uint64_t sub_100093790(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 328);
}

uint64_t sub_100093798(uint64_t result, int a2)
{
  uint64_t v3;
  void *v4;
  const char *v5;
  const void **v6;
  _QWORD context[4];

  if (*(unsigned __int8 *)(result + 328) != a2)
  {
    v3 = result;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v5 = "Disabling";
      if (!a2)
        v5 = "Enabling";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s BlackListing", v5);
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(v3 + 328) = a2;
    context[0] = v3;
    context[1] = 0xAAAAAAAA00000025;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(v3 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    v6 = (const void **)&kCFBooleanTrue;
    if (!a2)
      v6 = (const void **)&kCFBooleanFalse;
    return sub_100087488((_QWORD *)v3, CFSTR("DisableBlackList"), *v6, 0);
  }
  return result;
}

uint64_t sub_100093880(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t result;
  int v7;
  void *v8;
  const void **v9;
  _QWORD context[4];

  result = *(_QWORD *)(a1 + 816);
  if ((cf != 0) == (result != 0))
  {
    v7 = *(unsigned __int8 *)(a1 + 808);
    if (cf && result)
    {
      result = CFEqual((CFTypeRef)result, cf);
      if ((_DWORD)result && v7 == a2)
        return result;
      result = *(_QWORD *)(a1 + 816);
    }
    else if (v7 == a2)
    {
      return result;
    }
  }
  *(_BYTE *)(a1 + 808) = a2;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    *(_QWORD *)(a1 + 816) = 0;
  }
  if (cf)
  {
    *(_QWORD *)(a1 + 816) = CFRetain(cf);
    v8 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: test network %@", "WiFiManagerSetATJTestModeEnabled", cf);
    objc_autoreleasePoolPop(v8);
  }
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000028;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  v9 = (const void **)&kCFBooleanFalse;
  if (a2)
    v9 = (const void **)&kCFBooleanTrue;
  sub_100087488((_QWORD *)a1, CFSTR("ATJTestModeEnabled"), *v9, 0);
  return sub_100087488((_QWORD *)a1, CFSTR("ATJTestNetworkSSID"), cf, 0);
}

void sub_1000939D8(uint64_t a1, int a2)
{
  const void **v3;

  if (*(unsigned __int8 *)(a1 + 1162) != a2)
  {
    *(_BYTE *)(a1 + 1162) = a2;
    v3 = (const void **)&kCFBooleanTrue;
    if (!a2)
      v3 = (const void **)&kCFBooleanFalse;
    sub_100087488((_QWORD *)a1, CFSTR("lpasEnable"), *v3, 0);
    sub_10000A77C(a1, 0, *(unsigned __int8 *)(a1 + 1162), 2);
  }
}

_DWORD *sub_100093A54(_DWORD *result, _DWORD *a2)
{
  *result = dword_10026D68C;
  *a2 = dword_10026D690;
  return result;
}

void sub_100093A70(uint64_t a1, int a2, double a3)
{
  NSObject *v6;
  dispatch_time_t v7;
  CFDateRef v8;
  CFDateRef v9;
  void *v10;

  *(CFAbsoluteTime *)(a1 + 944) = CFAbsoluteTimeGetCurrent() + a3;
  if (a2)
    *(_QWORD *)(a1 + 936) = 0;
  v6 = *(NSObject **)(a1 + 920);
  v7 = dispatch_time(0, (uint64_t)(a3 * 1000000000.0));
  dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
  if (a3 != 315360000.0)
  {
    v8 = CFDateCreate(kCFAllocatorDefault, *(CFAbsoluteTime *)(a1 + 944));
    if (v8)
    {
      v9 = v8;
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation timer scheduled to fire at %@", v9);
      objc_autoreleasePoolPop(v10);
      CFRelease(v9);
    }
  }
}

void sub_100093B60(uint64_t a1)
{
  int v2;
  void *v3;
  double v4;
  void *v5;
  void *v6;

  v2 = *(_DWORD *)(a1 + 952);
  if (v2 == 3)
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Disassociation timer already fired, so not resuming");
    objc_autoreleasePoolPop(v5);
    sub_1000094BC(a1, 0);
    sub_10008A2B8(a1, "WiFiManagerResumeDisassociationTimer", 12722);
  }
  else
  {
    if (v2 == 1)
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Resuming disassociation timer with remaing interval of %f s", *(_QWORD *)(a1 + 936));
      objc_autoreleasePoolPop(v6);
      v4 = *(double *)(a1 + 936);
      goto LABEL_15;
    }
    if (!v2 && (!*(_BYTE *)(a1 + 314) || *(_DWORD *)(a1 + 788) == 2))
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Restart requested when Disassociation Timer is Idle. Starting timer");
      objc_autoreleasePoolPop(v3);
      v4 = *(double *)(a1 + 928);
LABEL_15:
      sub_100093A70(a1, 1, v4);
      *(_DWORD *)(a1 + 952) = 2;
    }
  }
}

void sub_100093C94(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  dispatch_time_t v5;
  _QWORD context[4];

  v2 = *(_QWORD *)(a1 + 1888);
  *(_QWORD *)(a1 + 1888) = v2 + 1;
  v3 = objc_autoreleasePoolPush();
  if (v2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: refCount %ld", "WiFiManagerStartDiagnosticsTimer", *(_QWORD *)(a1 + 1888));
    objc_autoreleasePoolPop(v3);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Starting Diagnostics Timer");
    objc_autoreleasePoolPop(v3);
    v4 = *(NSObject **)(a1 + 1872);
    v5 = dispatch_time(0, (uint64_t)(*(double *)(a1 + 1880) * 1000000000.0));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000015;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_100093D9C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;

  v1 = *(_QWORD *)(a1 + 1888);
  v2 = v1 - 1;
  if (v1 >= 1)
  {
    *(_QWORD *)(a1 + 1888) = v2;
    v4 = objc_autoreleasePoolPush();
    if (v2)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: refCount %ld", "WiFiManagerStopDiagnosticsTimer", *(_QWORD *)(a1 + 1888));
      objc_autoreleasePoolPop(v4);
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Stopping Diagnostics Timer");
      objc_autoreleasePoolPop(v4);
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1872), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
  }
}

void sub_100093E6C(uint64_t a1)
{
  sub_100013B90(a1, *(_QWORD *)(a1 + 832));
}

void sub_100093E74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[2];

  v3[0] = a2;
  v3[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_100093EA4, v3);
}

void sub_100093EA4(uint64_t a1, const void **a2)
{
  sub_100065084(a1, *a2, a2[1]);
}

void sub_100093EB0(uint64_t a1, void *context)
{
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_100093EC4, context);
}

void sub_100093EC8(uint64_t a1, __CFString *a2)
{
  const __CFString *v3;

  v3 = (const __CFString *)sub_1000161D4(a1);
  CFStringAppend(a2, v3);
  CFStringAppend(a2, CFSTR(" "));
}

void sub_100093F00(uint64_t a1, const void *a2)
{
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      v3 = sub_1000161D4(a1);
      sub_100072E44(v3, a2, 1);
    }
  }
}

void sub_100093F3C(uint64_t a1, const void *a2)
{
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 160), a2);
  sub_1000094BC(a1, *(unsigned __int8 *)(a1 + 24));
}

void sub_100093F68(uint64_t a1)
{
  sub_1000094BC(a1, *(unsigned __int8 *)(a1 + 24));
}

id sub_100093F70(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 2553) = a2;
  return -[WiFiUsageMonitor updateLinkRecoveryDisabled:](+[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"), "updateLinkRecoveryDisabled:", a2);
}

uint64_t sub_100093FA0(_QWORD *a1, const __CFString *a2, const void *a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = sub_100087488(a1, a2, a3, 0);
  v5 = v4;
  if ((_DWORD)v4)
    sub_10008488C(v4, 2, (uint64_t)a1);
  return v5;
}

uint64_t sub_100093FDC(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 912);
  return result;
}

uint64_t sub_100093FE8(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 2553);
  return result;
}

void sub_100093FF8(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t v6;
  int v9;
  void *v10;
  void *v11;

  v6 = *(_QWORD *)(a1 + 184);
  if (v6 && ((v9 = sub_1000D7204(v6), (_DWORD)a2 == -1) || v9 == (_DWORD)a2))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: notificationId %d response %d", "WiFiManagerDispatchNotificationResponse", a2, a3);
    objc_autoreleasePoolPop(v11);
    sub_1000D73D8(*(_QWORD **)(a1 + 184), a3, a4);
  }
  else
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "SpringBoard has responded to older request(%d). Ignoring.", a2);
    objc_autoreleasePoolPop(v10);
  }
}

void sub_1000940E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  const char *v9;
  _QWORD context[4];
  _DWORD v11[2];
  uint64_t v12;

  v8 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v9 = "yes";
    if (!*(_BYTE *)(a1 + 314))
      v9 = "no";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: priority %d, duration %u, type %@, external powered ? %s, battery level %u", "WiFiManagerIndicateCarPlayHIDEventReceived", a2, a3, a4, v9, *(unsigned int *)(a1 + 984));
    objc_autoreleasePoolPop(v8);
  }
  else
  {
    objc_autoreleasePoolPop(v8);
    if (!a1)
      return;
  }
  if (_os_feature_enabled_impl("WiFiManager", "PM0DuringCarPlayHIDSession"))
  {
    v11[0] = a2;
    v11[1] = a3;
    v12 = a4;
    if (*(_BYTE *)(a1 + 314) || *(_DWORD *)(a1 + 984) >= 0x15u)
    {
      context[0] = a1;
      context[1] = 0xAAAAAAAA0000007DLL;
      context[2] = v11;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
}

uint64_t sub_100094200(uint64_t a1, CFDictionaryRef *a2, int a3)
{
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  CFDictionaryRef *v13;
  CFDictionaryRef *v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  id v20;
  uint64_t v21;
  void *v23;

  if (!a1)
  {
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerUpdateCoreWiFiProfile");
    objc_autoreleasePoolPop(v23);
    return 0;
  }
  if (!sub_1000304D4((_QWORD *)a1))
    return 0;
  v6 = 0;
  if (!a2 || !*(_BYTE *)(a1 + 1328))
    return v6;
  v7 = objc_autoreleasePoolPush();
  if (!a3)
  {
    if (*(_BYTE *)(a1 + 1328) && (v11 = sub_1000C33D0((uint64_t)a2)) != 0)
    {
      v12 = v11;
      v13 = (CFDictionaryRef *)sub_10002B314((uint64_t)kCFAllocatorDefault, v11);
      if (v13)
      {
        v14 = v13;
        v15 = sub_100026664(v13);
        v16 = v15;
        if (v15)
        {
          v6 = (uint64_t)objc_msgSend(v15, "identifier");
          if (!v6)
          {
LABEL_21:
            objc_autoreleasePoolPop(v7);
            CFRelease(v12);
            CFRelease(v14);
LABEL_22:

            return v6;
          }
          v17 = objc_msgSend(v16, "externalForm");
          if (v17)
          {
            v18 = v17;
            v19 = objc_msgSend(*(id *)(a1 + 1104), "objectForKey:", v6);
            objc_msgSend(*(id *)(a1 + 1104), "setObject:forKey:", v18, v6);
            objc_msgSend(*(id *)(a1 + 1104), "synchronize");
            v20 = +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager");
            v6 = 1;
            if (v19)
              v21 = 2;
            else
              v21 = 1;
            objc_msgSend(v20, "sendKnownNetworkDidChangeEventForProfile:eventType:", v16, v21);
            goto LABEL_21;
          }
        }
        v6 = 0;
        goto LABEL_21;
      }
      objc_autoreleasePoolPop(v7);
      CFRelease(v12);
    }
    else
    {
      objc_autoreleasePoolPop(v7);
    }
    v6 = 0;
    v16 = 0;
    goto LABEL_22;
  }
  if (*(_BYTE *)(a1 + 1328))
  {
    v8 = sub_100026664(a2);
    v9 = v8;
    if (v8 && (v10 = objc_msgSend(v8, "identifier")) != 0)
    {
      objc_msgSend(*(id *)(a1 + 1104), "setObject:forKey:", 0, v10);
      objc_msgSend(*(id *)(a1 + 1104), "synchronize");
      objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "sendKnownNetworkDidChangeEventForProfile:eventType:", v9, 3);
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
    v9 = 0;
  }
  objc_autoreleasePoolPop(v7);

  return v6;
}

uint64_t sub_100094420(uint64_t a1, void *a2, uint64_t a3)
{
  void *v4;
  _BOOL4 v6;
  void *v7;
  void *v8;
  const char *v9;
  const void *v10;
  void *v11;
  const __SCPreferences *v12;
  void *v13;
  CFMutableDictionaryRef v14;
  const __SCPreferences *v15;
  const __SCPreferences *v16;
  uint64_t v17;
  const __CFArray *v18;
  void *v19;
  CFNumberRef v20;
  CFAbsoluteTime Current;
  CFDateRef v22;
  CFDateRef v23;
  const void *v24;
  uint64_t v25;
  int v26;
  int v27;
  void *v28;
  void *v29;
  void *v30;
  CFMutableArrayRef Mutable;
  CFIndex v32;
  const void *ValueAtIndex;
  const void *v34;
  int v35;
  const __CFNumber *v36;
  void *v37;
  void *v38;
  const __CFString *v39;
  void *v40;
  CFBooleanRef v41;
  CFBooleanRef v42;
  void *v43;
  _WORD *v44;
  const void *v45;
  CFAbsoluteTime v46;
  const __CFDate *v47;
  const __CFArray *v48;
  CFIndex v49;
  CFIndex v50;
  const void *v51;
  uint64_t v52;
  const __CFDate *v53;
  const __CFDate *v54;
  void *v55;
  int v56;
  void *v57;
  void *v58;
  const void *v59;
  CFIndex v60;
  void *v61;
  void *v62;
  void *v63;
  const void *v64;
  uint64_t v65;
  void *v66;
  void *v67;
  const void *v68;
  unsigned int v69;
  char v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  _BOOL4 v76;
  const __SCPreferences *v77;
  __CFDictionary *v78;
  void *v79;
  __CFArray *theArray;
  const void *v81;
  _QWORD block[6];
  CFIndex Count;
  CFIndex idx;
  int valuePtr;
  void *v86;
  uint64_t context;
  unint64_t v88;
  void **v89;
  uint64_t v90;

  v86 = a2;
  valuePtr = a3;
  Count = 0;
  idx = -1;
  if (!a1)
  {
    v61 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerAddNetwork");
    goto LABEL_135;
  }
  v4 = a2;
  if (!a2)
  {
    v61 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerAddNetwork");
LABEL_135:
    objc_autoreleasePoolPop(v61);
    v76 = 0;
    theArray = 0;
    v81 = 0;
    v20 = 0;
    v14 = 0;
    goto LABEL_136;
  }
  v81 = sub_10002B088(a2);
  v6 = sub_10002DA5C((_BOOL8)v4);
  v7 = objc_autoreleasePoolPush();
  v8 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    if (v6)
      v9 = "domain";
    else
      v9 = "SSID";
    v10 = v81;
    if (v6)
      v10 = sub_10002BE64((uint64_t)v4, CFSTR("DomainName"));
    objc_msgSend(v8, "WFLog:message:", 3, "%s: reason %d, with %s %@", "WiFiManagerAddNetwork", a3, v9, v10);
  }
  objc_autoreleasePoolPop(v7);
  if ((_DWORD)a3 == 17 && sub_1000C3B8C((_BOOL8)v4) && sub_1000C50F4((uint64_t)v4))
  {
    sub_10002C478((uint64_t)v4, CFSTR("WPA_IE"), 0);
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Both WEP & WPA-PSK are set incorrectly.  Removing WPA-PSK", "WiFiManagerAddNetwork");
    objc_autoreleasePoolPop(v11);
  }
  sub_10010CA10(v4);
  v12 = sub_10001D90C((_QWORD *)a1, CFSTR("kWiFiWhitelistingUUIDKey"));
  if (sub_1000C5378((uint64_t)v4) && v12)
  {
    sub_10002C478((uint64_t)v4, CFSTR("PolicyUUID"), v12);
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Added policyUUID %@ to network %@", "__WiFiManagerApplyWhitelistingPolicy", v12, sub_10002B088(v4));
    objc_autoreleasePoolPop(v13);
  }
  v14 = sub_1000C33B4((uint64_t)v4);
  v76 = v6;
  if (!v14
    || (v15 = (const __SCPreferences *)sub_10001D964((_QWORD *)a1, CFSTR("List of known networks"))) == 0
    || (v16 = v15, sub_100095360(v4), !sub_100007620(v16)))
  {
    theArray = 0;
    v20 = 0;
LABEL_136:
    v25 = 0;
    goto LABEL_182;
  }
  v78 = v14;
  v79 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerAddNetwork");
  v17 = sub_10008674C(a1);
  if (!v17)
  {
    v25 = 0;
    v20 = 0;
    theArray = 0;
LABEL_141:
    v56 = 1;
    v14 = v78;
    goto LABEL_148;
  }
  v18 = (const __CFArray *)v17;
  if (sub_1000C993C((uint64_t)v4))
  {
    v62 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Will not add HS2.0 network to known networks list", "WiFiManagerAddNetwork");
    objc_autoreleasePoolPop(v62);
    v20 = 0;
    theArray = 0;
    v25 = 1;
    goto LABEL_141;
  }
  sub_1000953B8(*(_DWORD *)(a1 + 304), v18, v4, &idx, &Count);
  v19 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:existingIndex %ld, insertIndex %ld", "WiFiManagerAddNetwork", idx, Count);
  objc_autoreleasePoolPop(v19);
  v77 = v16;
  if (idx != -1 || !CFArrayGetCount(v18))
    goto LABEL_29;
  if (-[WiFiUserInteractionMonitor isInitialSetupCompleted](+[WiFiUserInteractionMonitor sharedInstance](WiFiUserInteractionMonitor, "sharedInstance"), "isInitialSetupCompleted")|| valuePtr != 1)
  {
    theArray = 0;
    goto LABEL_30;
  }
  if (sub_10001D90C((_QWORD *)a1, CFSTR("IsNewInstall")) == kCFBooleanFalse)
    goto LABEL_29;
  v30 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setup not completed, filtering out non-managed known networks to retain only the new one", "WiFiManagerAddNetwork");
  objc_autoreleasePoolPop(v30);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
LABEL_29:
    theArray = 0;
    goto LABEL_30;
  }
  theArray = Mutable;
  if (CFArrayGetCount(v18) >= 1)
  {
    v32 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v18, v32);
      if (ValueAtIndex)
      {
        v34 = ValueAtIndex;
        v35 = sub_1000954F8((const __CFArray *)a1, ValueAtIndex);
        LODWORD(context) = 1;
        v36 = (const __CFNumber *)sub_10002BE64((uint64_t)v34, CFSTR("WiFiManagerKnownNetworksEventType"));
        if (v36)
          CFNumberGetValue(v36, kCFNumberIntType, &context);
        if (v35)
        {
          CFArrayAppendValue(theArray, v34);
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: retaining currently connected network %@", "WiFiManagerAddNetwork", sub_10002B088(v34));
        }
        else if (sub_1000C5378((uint64_t)v34) || sub_1000CB480((uint64_t)v34))
        {
          CFArrayAppendValue(theArray, v34);
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: retaining carrier/profile-based network %@", "WiFiManagerAddNetwork", sub_10002B088(v34));
        }
        else if ((_DWORD)context == 3)
        {
          CFArrayAppendValue(theArray, v34);
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: retaining cloud-synced network %@", "WiFiManagerAddNetwork", sub_10002B088(v34));
        }
        else
        {
          v37 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing network %@ during Setup", "WiFiManagerAddNetwork", sub_10002B088(v34));
        }
        objc_autoreleasePoolPop(v37);
      }
      ++v32;
    }
    while (v32 < CFArrayGetCount(v18));
  }
  v60 = Count;
  v18 = theArray;
  if (v60 > CFArrayGetCount(theArray))
    Count = CFArrayGetCount(theArray);
LABEL_30:
  v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v20)
    sub_10002C478((uint64_t)v4, CFSTR("WiFiManagerKnownNetworksEventType"), v20);
  Current = CFAbsoluteTimeGetCurrent();
  v22 = CFDateCreate(kCFAllocatorDefault, Current);
  if (v22)
  {
    v23 = v22;
    if (!sub_10002BE64((uint64_t)v4, CFSTR("addedAt")))
      sub_10002C478((uint64_t)v4, CFSTR("addedAt"), v23);
    CFRelease(v23);
  }
  if (idx == -1)
  {
    if (!sub_1000957A4(a1, v4, v18))
      goto LABEL_79;
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Different network with same ssid found and replaced", "WiFiManagerAddNetwork");
LABEL_145:
    objc_autoreleasePoolPop(v38);
    v56 = 0;
    v25 = 1;
    goto LABEL_146;
  }
  v24 = CFArrayGetValueAtIndex(v18, idx);
  v25 = (uint64_t)v24;
  if (!v24)
    goto LABEL_80;
  v26 = sub_100031670(v24);
  v27 = sub_100031670(v4);
  if (*(_BYTE *)(a1 + 2105))
  {
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s preferAutoJoinHomeNetwork, enabling added network", "WiFiManagerAddNetwork");
    objc_autoreleasePoolPop(v28);
    sub_1000C6770((uint64_t)v4, 1);
    sub_10002C478(v25, CFSTR("WiFiNetworkDisabledUntilDate"), 0);
  }
  if (!v27 || v26)
  {
    if (!sub_1000957A4(a1, v4, v18))
      goto LABEL_79;
    v38 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Replaced the existing network", "WiFiManagerAddNetwork");
    goto LABEL_145;
  }
  sub_1000C4734(v25, v27);
  sub_100094200(a1, (CFDictionaryRef *)v25, 0);
  if (!sub_100095610(a1, v18))
  {
LABEL_79:
    v25 = 0;
    goto LABEL_80;
  }
  v29 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Marked network as hidden", "WiFiManagerAddNetwork");
  objc_autoreleasePoolPop(v29);
  v25 = 1;
LABEL_80:
  if (sub_10002B704((uint64_t)v4))
  {
    v39 = CFSTR("AdHoc");
LABEL_84:
    sub_1000C68E8((CFMutableDictionaryRef *)v4, 0, v39);
    goto LABEL_85;
  }
  if (sub_1000CEDAC((uint64_t)v4))
  {
    v39 = CFSTR("Accessory");
    goto LABEL_84;
  }
  sub_1000C6770((uint64_t)v4, 1);
LABEL_85:
  if (*(_BYTE *)(a1 + 2105))
  {
    v40 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:NOI home-state: %d", "WiFiManagerAddNetwork", sub_1000C3F88((uint64_t)v4));
    objc_autoreleasePoolPop(v40);
    sub_100096508(a1, 0, v4);
  }
  if (idx == -1)
  {
    v41 = kCFBooleanFalse;
    if (sub_1000C5104((uint64_t)v4))
      v42 = kCFBooleanTrue;
    else
      v42 = kCFBooleanFalse;
    sub_10002C478((uint64_t)v4, CFSTR("ALLOW_WPA2_PSK"), v42);
    if (!sub_1000C5C14((uint64_t)v4) && !sub_1000C52E4((const __CFDictionary *)v4))
      v41 = kCFBooleanTrue;
    sub_10002C478((uint64_t)v4, CFSTR("ALLOW_OWE_TSN"), v41);
    if (CWFScanResultHas6GHzOnlyBSS(v4, &__NSArray0__struct, &stru_100230808))
    {
      v43 = sub_100026664((CFDictionaryRef *)v4);
      objc_msgSend(v43, "setWas6GHzOnlyAt:", +[NSDate date](NSDate, "date"));
      v44 = sub_1000CCB10(v43, 0);
      if (v44)
      {
        v45 = v44;
        sub_1000C38BC((uint64_t)v4, (uint64_t)v44);
        CFRelease(v45);
      }

    }
    sub_1000C6BC0(v4);
    if (valuePtr == 23 || sub_1000CB480((uint64_t)v4) && sub_100007F24((uint64_t)v4) && valuePtr == 17)
    {
      v46 = CFAbsoluteTimeGetCurrent();
      v47 = CFDateCreate(kCFAllocatorDefault, v46);
      v48 = *(const __CFArray **)(a1 + 2512);
      if (v48)
      {
        v49 = 0;
        v50 = -1;
        do
        {
          if (v49 >= CFArrayGetCount(v48))
            break;
          v51 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2512), v49);
          if (v51)
          {
            v52 = (uint64_t)v51;
            if (CFEqual(v4, v51))
            {
              v53 = (const __CFDate *)sub_10002BE64(v52, CFSTR("removedAt"));
              if (v53 && (v54 = v53, CFDateGetTimeIntervalSinceDate(v47, v53) < 86400.0))
              {
                v55 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                {
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: previously disabled carrier-based network %@ re-added at %@ (was removed at %@), disabling the network", "WiFiManagerAddNetwork", sub_10002B088(v4), v47, v54);
                  v4 = v86;
                }
                objc_autoreleasePoolPop(v55);
                sub_1000C6770((uint64_t)v4, 0);
                v50 = v49;
              }
              else
              {
                v50 = v49;
              }
            }
          }
          ++v49;
          v48 = *(const __CFArray **)(a1 + 2512);
        }
        while (v48);
        if (v50 != -1)
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 2512), v50);
      }
      if (v47)
        CFRelease(v47);
    }
    v4 = v86;
    CFArrayInsertValueAtIndex(v18, Count, v86);
    v25 = sub_100095610(a1, v18);
    v56 = 1;
    sub_100007FDC(a1, 1, 1, 1);
    sub_100094200(a1, (CFDictionaryRef *)v4, 0);
    if ((_DWORD)v25)
    {
      v57 = objc_autoreleasePoolPush();
      v58 = (void *)qword_10026DD20;
      v14 = v78;
      if (qword_10026DD20)
      {
        v59 = v81;
        if (v76)
          v59 = sub_10002BE64((uint64_t)v4, CFSTR("DomainName"));
        objc_msgSend(v58, "WFLog:message:", 3, "%s: Added %@ to list of known networks", "WiFiManagerAddNetwork", v59);
      }
      objc_autoreleasePoolPop(v57);
      v25 = 1;
      goto LABEL_147;
    }
  }
  else
  {
    v56 = 1;
  }
LABEL_146:
  v14 = v78;
LABEL_147:
  v16 = v77;
LABEL_148:
  sub_1000076D4(v16, v25);

  if (!(_DWORD)v25)
    goto LABEL_182;
  if (valuePtr == 6 || valuePtr == 1)
  {
    v63 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sync the added network <%@>", "WiFiManagerAddNetwork", v81);
    objc_autoreleasePoolPop(v63);
    if (&_WiFiCloudSyncEngineCreate)
    {
      v64 = *(const void **)(a1 + 1304);
      if (v64)
      {
        if (v4)
        {
          CFRetain(v64);
          CFRetain(v4);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_10009677C;
          block[3] = &unk_10022EF88;
          block[4] = a1;
          block[5] = v4;
          dispatch_async((dispatch_queue_t)qword_10026DD48, block);
        }
      }
    }
    sub_100176B68(*(void **)(a1 + 1432), (uint64_t)v4, 0);
  }
  else
  {
    v66 = objc_autoreleasePoolPush();
    v67 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v68 = v81;
      if (v76)
        v68 = sub_10002BE64((uint64_t)v4, CFSTR("DomainName"));
      objc_msgSend(v67, "WFLog:message:", 3, "%s: <%@> added due to sync", "WiFiManagerAddNetwork", v68);
    }
    objc_autoreleasePoolPop(v66);
  }
  sub_10008488C(v65, 2, a1);
  sub_100085F68(a1);
  sub_100058DC8((_QWORD *)a1, valuePtr, v4);
  if (v56)
    v69 = 0;
  else
    v69 = 2;
  sub_1000967B4(a1, v4, v69);
  if (v4)
    v70 = v56 ^ 1;
  else
    v70 = 1;
  if ((v70 & 1) == 0)
    sub_100096A30((_QWORD *)a1, v81);
  if (!*(_BYTE *)(a1 + 2105))
    goto LABEL_180;
  v71 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Attempting NOI Transition");
  objc_autoreleasePoolPop(v71);
  if (sub_1000C5378((uint64_t)v4))
  {
    v72 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Added network is profile based, set previous network prior to __WiFiManagerAttemptNetworkTransition so wifid transitions to this newly added network (%@)", v81);
    objc_autoreleasePoolPop(v72);
    context = a1;
    v88 = 0xAAAAAAAA00000064;
    v89 = &v86;
    v90 = 0;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  }
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_100007F68(a1, 28);
LABEL_180:
    v25 = 1;
    goto LABEL_182;
  }
  context = a1;
  v88 = 0xAAAAAAAA00000050;
  v25 = 1;
  v89 = 0;
  v90 = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
LABEL_182:
  if (!sub_100096B7C(a1, v86, CFSTR("PresentInKnownNetworks"), kCFBooleanTrue))
  {
    v73 = objc_autoreleasePoolPush();
    v74 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (v76)
        v81 = sub_10002BE64((uint64_t)v86, CFSTR("DomainName"));
      objc_msgSend(v74, "WFLog:message:", 3, "%s:Unable to update known network property in private mac network record for <%@>", "WiFiManagerAddNetwork", v81);
    }
    objc_autoreleasePoolPop(v73);
  }
  if (v20)
    CFRelease(v20);
  if (v14)
    CFRelease(v14);
  if (theArray)
    CFRelease(theArray);
  return v25;
}

void sub_100095360(const void *a1)
{
  const __CFString *v2;

  v2 = (const __CFString *)sub_10002BE64((uint64_t)a1, CFSTR("WiFiNetworkPasswordString"));
  if (v2)
  {
    sub_1000C64F0(a1, v2);
    sub_10002C478((uint64_t)a1, CFSTR("WiFiNetworkPasswordString"), 0);
  }
}

void sub_1000953B8(int a1, CFArrayRef theArray, void *a3, CFIndex *a4, CFIndex *a5)
{
  CFIndex Count;
  CFTypeID v11;
  CFIndex v12;
  const void **v13;
  const void **ValueAtIndex;
  void *v15;

  if (!theArray)
  {
LABEL_14:
    Count = 0;
    goto LABEL_15;
  }
  Count = CFArrayGetCount(theArray);
  if (!Count)
    goto LABEL_15;
  if (!a3 || (v11 = CFGetTypeID(a3), v11 != sub_1000C312C()))
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid network ref", "__GetKnownNetworkIndices");
    objc_autoreleasePoolPop(v15);
    goto LABEL_14;
  }
  if (a1 != 4)
  {
    if (Count >= 1)
    {
      v12 = 0;
      while (1)
      {
        ValueAtIndex = (const void **)CFArrayGetValueAtIndex(theArray, v12);
        if (sub_1000CE080(ValueAtIndex, (const __CFDictionary **)a3))
          break;
        if (Count == ++v12)
          goto LABEL_14;
      }
      Count = 0;
      if (a5)
        goto LABEL_17;
      goto LABEL_18;
    }
    goto LABEL_14;
  }
  v12 = Count;
  while (v12)
  {
    v13 = (const void **)CFArrayGetValueAtIndex(theArray, --v12);
    if (sub_1000CE080(v13, (const __CFDictionary **)a3))
      goto LABEL_16;
  }
LABEL_15:
  v12 = -1;
LABEL_16:
  if (a5)
LABEL_17:
    *a5 = Count;
LABEL_18:
  if (a4)
    *a4 = v12;
}

uint64_t sub_1000954F8(const __CFArray *a1, const void *a2)
{
  uint64_t v2;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  uint64_t v10;
  const void *v11;
  void *v12;
  const void *v13;
  int v14;
  void *v16;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = sub_10000B29C(a1);
    if (v4)
    {
      v5 = v4;
      Count = CFArrayGetCount(v4);
      if (Count < 1)
      {
LABEL_11:
        v2 = 0;
      }
      else
      {
        v7 = Count;
        v8 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v5, v8);
          v10 = sub_1000161D4((uint64_t)ValueAtIndex);
          if (v10)
          {
            v11 = (const void *)sub_100029860(v10);
            if (v11)
            {
              v12 = sub_1000169FC((uint64_t)ValueAtIndex, v11);
              if (v12)
              {
                v13 = v12;
                v14 = CFEqual(a2, v12);
                CFRelease(v13);
                if (v14)
                  break;
              }
            }
          }
          if (v7 == ++v8)
            goto LABEL_11;
        }
        v2 = 1;
      }
      CFRelease(v5);
    }
    else
    {
      v16 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "__WiFiManagerIsAssociatedToNetwork");
      objc_autoreleasePoolPop(v16);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_100095610(uint64_t a1, const __CFArray *a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  const __CFArray *v8;
  CFIndex Count;
  const __CFArray *v10;
  void *v11;
  void *v13;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    v5 = 0;
    if (a2 && *(_BYTE *)(a1 + 1328))
    {
      v6 = objc_autoreleasePoolPush();
      v7 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v8 = *(const __CFArray **)(a1 + 224);
        if (v8)
          Count = CFArrayGetCount(v8);
        else
          Count = 0;
        objc_msgSend(v7, "WFLog:message:", 3, "%s: Switching cached list from %ld to %ld known networks", "WiFiManagerSetKnownNetworksCache", Count, CFArrayGetCount(a2));
      }
      objc_autoreleasePoolPop(v6);
      v10 = *(const __CFArray **)(a1 + 224);
      if (v10 == a2)
        v10 = 0;
      else
        *(_QWORD *)(a1 + 224) = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updated %ld known networks in the cache", "WiFiManagerSetKnownNetworksCache", CFArrayGetCount(*(CFArrayRef *)(a1 + 224)));
      objc_autoreleasePoolPop(v11);
      sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
      if (v10)
        CFRelease(v10);
      v5 = 1;
    }
  }
  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerSetKnownNetworksCache");
    objc_autoreleasePoolPop(v13);
    v5 = 0;
  }
  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t sub_1000957A4(uint64_t a1, void *a2, const __CFArray *a3)
{
  _BOOL4 v6;
  CFIndex v7;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const void *ValueAtIndex;
  void *v13;
  void *v14;
  void *v15;
  const char *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const __CFArray *v24;
  const __CFArray *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  _BOOL4 v30;
  void *v31;
  void *v32;
  const void *v33;
  void *v34;
  const void *v35;
  void *v36;
  const void *v37;
  const void *v38;
  void *v39;
  const void *v40;
  const void *v41;
  void *v42;
  unsigned int v43;
  const void *v44;
  const void *v45;
  const __CFDate *v46;
  double v47;
  void *v48;
  void *v49;
  double v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const __CFDate *v54;
  const __CFDate *v55;
  void *v56;
  const void *v57;
  const void *v58;
  double v59;
  const void *v60;
  int v61;
  int v62;
  unsigned int v63;
  _BOOL4 v64;
  void *v65;
  void *v66;
  _BOOL4 v67;
  const __CFDictionary *v68;
  const __CFDictionary *v69;
  CFIndex v70;
  int v71;
  const void *v72;
  const __CFArray *v73;
  const void *v74;
  void *v75;
  const void *v76;
  __CFString *v77;
  uint64_t v78;
  void *v79;
  void *v80;
  void *v81;
  const void *v82;
  const void *v83;
  CFBooleanRef v84;
  CFBooleanRef v85;
  void *v87;
  uint64_t v88;
  void *v89;
  void *v90;
  CFArrayRef v91;
  CFArrayRef theArray;
  CFDictionaryRef theDict;
  void *value;
  CFIndex idx;
  CFRange v96;

  idx = -1;
  v6 = sub_10002DA5C((_BOOL8)a2);
  sub_1000B9C54(a3, a2, &idx);
  v7 = idx;
  if (idx == -1 && v6)
  {
    idx = -1;
    if (!a3)
      return 0;
    Count = CFArrayGetCount(a3);
    if (Count)
    {
      v10 = Count;
      if (Count < 1)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a3, v11);
          if (sub_1000C5FEC((uint64_t)a2, (uint64_t)ValueAtIndex))
            break;
          if (v10 == ++v11)
            goto LABEL_15;
        }
        idx = v11;
      }
      if (v11 == v10)
      {
LABEL_15:
        v13 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network with domain name %@ not found", "FindMatchingHS20Network", sub_1000C9A4C((uint64_t)a2));
        objc_autoreleasePoolPop(v13);
      }
    }
    v7 = idx;
  }
  if (v7 == -1)
    return 0;
  v14 = objc_autoreleasePoolPush();
  v15 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    if (v6)
      v16 = "domain name";
    else
      v16 = "SSID";
    if (v6)
      v17 = sub_1000C9A4C((uint64_t)a2);
    else
      v17 = sub_10002B088(a2);
    objc_msgSend(v15, "WFLog:message:", 3, "%s: Network with the same %s %@ found at index %ld", "__WiFiManagerModifyExistingNetwork", v16, v17, idx);
  }
  objc_autoreleasePoolPop(v14);
  v18 = CFArrayGetValueAtIndex(a3, idx);
  if (!v18)
  {
    v87 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null existingNetwork", "__WiFiManagerModifyExistingNetwork");
    objc_autoreleasePoolPop(v87);
    return 0;
  }
  v19 = v18;
  v20 = sub_1000C5C14((uint64_t)v18);
  v21 = sub_1000C5C14((uint64_t)a2);
  if ((_DWORD)v21 != (_DWORD)v20)
  {
    v22 = v21;
    v23 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: auth flag changed from 0x%0x to 0x%0x", "__WiFiManagerModifyExistingNetwork", v20, v22);
    objc_autoreleasePoolPop(v23);
  }
  v24 = (const __CFArray *)sub_10002BE64((uint64_t)v19, CFSTR("networkKnownBSSListKey"));
  if (v24)
  {
    v25 = v24;
    if (CFArrayGetCount(v24))
      sub_10002C478((uint64_t)a2, CFSTR("networkKnownBSSListKey"), v25);
  }
  v26 = sub_1000316E0((uint64_t)v19);
  if (v26)
  {
    sub_10002C478((uint64_t)a2, CFSTR("CHANNEL"), v26);
    v27 = sub_10002BE64((uint64_t)v19, CFSTR("CHANNEL_FLAGS"));
    sub_10002C478((uint64_t)a2, CFSTR("CHANNEL_FLAGS"), v27);
  }
  v28 = sub_10002BE64((uint64_t)v19, CFSTR("BSSID"));
  sub_10002C478((uint64_t)a2, CFSTR("BSSID"), v28);
  v29 = sub_10002BE64((uint64_t)v19, CFSTR("Standalone"));
  sub_10002C478((uint64_t)a2, CFSTR("Standalone"), v29);
  v30 = sub_1000C69C8((uint64_t)a2);
  v31 = objc_autoreleasePoolPush();
  if (v30)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: AJ prefs detected in incoming WiFiNetworkRef %@. AJ settings from existing network %@ will not be copied over", "__WiFiManagerModifyExistingNetwork", a2, v19);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No AJ prefs detected for incoming network %@, so preserve AJ settings in existing network %@", "__WiFiManagerModifyExistingNetwork", sub_10002B088(a2), v19);
    objc_autoreleasePoolPop(v31);
    sub_1000C3C70(a2, (uint64_t)v19);
    v31 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network properties after AJ properties merge: %@", "__WiFiManagerModifyExistingNetwork", a2, v88);
  }
  objc_autoreleasePoolPop(v31);
  if (&_CNForgetSSID)
  {
    if (sub_10002BE64((uint64_t)v19, kCNSNetworkWasCaptiveProperty))
    {
      v32 = (void *)kCNSNetworkWasCaptiveProperty;
      v33 = sub_10002BE64((uint64_t)v19, kCNSNetworkWasCaptiveProperty);
      sub_10002C478((uint64_t)a2, v32, v33);
    }
    if (sub_10002BE64((uint64_t)v19, kCNSCaptiveNetworkProperty))
    {
      v34 = (void *)kCNSCaptiveNetworkProperty;
      v35 = sub_10002BE64((uint64_t)v19, kCNSCaptiveNetworkProperty);
      sub_10002C478((uint64_t)a2, v34, v35);
    }
    if (sub_10002BE64((uint64_t)v19, kCNSDisabledByCaptiveProperty)
      && !sub_10002BE64((uint64_t)a2, kCNSDisabledByCaptiveProperty))
    {
      v36 = (void *)kCNSDisabledByCaptiveProperty;
      v37 = sub_10002BE64((uint64_t)v19, kCNSDisabledByCaptiveProperty);
      sub_10002C478((uint64_t)a2, v36, v37);
    }
  }
  if (sub_10002BE64((uint64_t)v19, CFSTR("NetworkOriginator"))
    && !sub_10002BE64((uint64_t)a2, CFSTR("NetworkOriginator")))
  {
    v38 = sub_10002BE64((uint64_t)v19, CFSTR("NetworkOriginator"));
    sub_10002C478((uint64_t)a2, CFSTR("NetworkOriginator"), v38);
  }
  v39 = (void *)CWFCoreWiFiSpecificAttributesKey;
  if (sub_10002BE64((uint64_t)v19, CWFCoreWiFiSpecificAttributesKey) && !sub_10002BE64((uint64_t)a2, v39))
  {
    v40 = sub_10002BE64((uint64_t)v19, v39);
    sub_10002C478((uint64_t)a2, v39, v40);
  }
  if (sub_10002BE64((uint64_t)v19, CFSTR("WiFiNetworkAttributeIsPublic"))
    && !sub_10002BE64((uint64_t)a2, CFSTR("WiFiNetworkAttributeIsPublic")))
  {
    v41 = sub_10002BE64((uint64_t)v19, CFSTR("WiFiNetworkAttributeIsPublic"));
    sub_10002C478((uint64_t)a2, CFSTR("WiFiNetworkAttributeIsPublic"), v41);
  }
  if (sub_100031670(v19) && !sub_100031670(a2))
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Force Directed setting for %@", "__WiFiManagerModifyExistingNetwork", sub_10002B088(a2));
    objc_autoreleasePoolPop(v42);
    sub_1000C4734((uint64_t)a2, 1);
  }
  if (!sub_100008280((uint64_t)a2))
  {
    v43 = sub_100008280((uint64_t)a2);
    if (v43 != sub_100008280((uint64_t)v19))
    {
      v44 = sub_10002BE64((uint64_t)v19, CFSTR("SaveDataMode"));
      sub_10002C478((uint64_t)a2, CFSTR("SaveDataMode"), v44);
    }
  }
  v45 = sub_1000CAC40((uint64_t)v19);
  v46 = (const __CFDate *)sub_1000CAC40((uint64_t)a2);
  if (v45 && (!v46 || CFDateCompare((CFDateRef)v45, v46, 0) == kCFCompareGreaterThan))
  {
    v47 = sub_1000CABB4((uint64_t)v19);
    sub_1000CACB4(a2, v45, v47);
    v48 = objc_autoreleasePoolPush();
    v49 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v50 = sub_1000CABB4((uint64_t)v19);
      objc_msgSend(v49, "WFLog:message:", 3, "%s: setting networkQuality to %.3f at %@ for network %@", "__WiFiManagerModifyExistingNetwork", *(_QWORD *)&v50, v45, sub_10002B088(a2));
    }
    objc_autoreleasePoolPop(v48);
  }
  if (sub_1000C6A58((uint64_t)v19, 1) && !sub_1000C6A58((uint64_t)a2, 1))
  {
    v51 = sub_1000C6A58((uint64_t)v19, 1);
    sub_1000C69F0(a2, 1, v51);
  }
  if (sub_1000C6A58((uint64_t)v19, 0) && !sub_1000C6A58((uint64_t)a2, 0))
  {
    v52 = sub_1000C6A58((uint64_t)v19, 0);
    sub_1000C69F0(a2, 0, v52);
  }
  v53 = sub_10002BE64((uint64_t)v19, CFSTR("prevJoined"));
  v54 = (const __CFDate *)sub_10002BE64((uint64_t)a2, CFSTR("prevJoined"));
  if (v53)
  {
    v55 = v54;
    if (v54)
    {
      if (CFDateCompare((CFDateRef)v53, v54, 0) == kCFCompareGreaterThan)
      {
        sub_10002C478((uint64_t)a2, CFSTR("prevJoined"), v53);
        v56 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: overriding previous join date from %@ to %@ for network %@", "__WiFiManagerModifyExistingNetwork", v55, v53, sub_10002B088(a2));
        objc_autoreleasePoolPop(v56);
      }
    }
  }
  if (sub_10002BE64((uint64_t)v19, CFSTR("WiFiManagerKnownNetworksEventType")))
  {
    v57 = sub_10002BE64((uint64_t)v19, CFSTR("WiFiManagerKnownNetworksEventType"));
    sub_10002C478((uint64_t)a2, CFSTR("WiFiManagerKnownNetworksEventType"), v57);
  }
  if (sub_10002BE64((uint64_t)v19, CFSTR("addedAt")))
  {
    v58 = sub_10002BE64((uint64_t)v19, CFSTR("addedAt"));
    sub_10002C478((uint64_t)a2, CFSTR("addedAt"), v58);
  }
  if (sub_10002DFE4((uint64_t)v19) != 0.0 && sub_10002DFE4((uint64_t)a2) == 0.0)
  {
    v59 = sub_10002DFE4((uint64_t)v19);
    sub_1000C6AD4((uint64_t)a2, v59);
  }
  if (sub_10002BE64((uint64_t)v19, CFSTR("userPreferredNetworkNames"))
    && !sub_10002BE64((uint64_t)a2, CFSTR("userPreferredNetworkNames")))
  {
    v60 = sub_10002BE64((uint64_t)v19, CFSTR("userPreferredNetworkNames"));
    sub_10002C478((uint64_t)a2, CFSTR("userPreferredNetworkNames"), v60);
  }
  if (sub_1000C3F88((uint64_t)v19) && !sub_1000C3F88((uint64_t)a2))
  {
    v61 = sub_1000C3F88((uint64_t)v19);
    sub_1000CBF00(a2, v61);
  }
  if (sub_1000CBE60((uint64_t)v19) && !sub_1000CBE60((uint64_t)a2))
  {
    v62 = sub_1000CBE60((uint64_t)v19);
    sub_1000CBD0C(a2, v62);
  }
  if (sub_1000CC884((uint64_t)v19))
  {
    v63 = sub_1000CC884((uint64_t)v19);
    sub_10002B698((uint64_t)a2, CFSTR("kWiFiNetworkSSIDHarvestStatusKey"), v63);
  }
  if (*(_BYTE *)(a1 + 2105))
    sub_100096508(a1, v19, a2);
  v64 = sub_1000081D8((uint64_t)a2);
  if (v64 != sub_1000081D8((uint64_t)v19))
  {
    v65 = objc_autoreleasePoolPush();
    v66 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v67 = sub_1000081D8((uint64_t)v19);
      objc_msgSend(v66, "WFLog:message:", 3, "%s: privacy proxy enabled changed from %d to %d", "__WiFiManagerModifyExistingNetwork", v67, sub_1000081D8((uint64_t)a2));
    }
    objc_autoreleasePoolPop(v65);
  }
  if (!sub_10002DAB4((uint64_t)v19) || !sub_10002DAB4((uint64_t)a2))
    goto LABEL_140;
  v68 = (const __CFDictionary *)sub_10002BE64((uint64_t)v19, CFSTR("EnterpriseProfile"));
  v69 = (const __CFDictionary *)sub_10002BE64((uint64_t)a2, CFSTR("EnterpriseProfile"));
  theDict = 0;
  value = 0;
  if (v68)
    CFDictionaryGetValueIfPresent(v68, CFSTR("EAPClientConfiguration"), (const void **)&value);
  if (v69)
    CFDictionaryGetValueIfPresent(v69, CFSTR("EAPClientConfiguration"), (const void **)&theDict);
  if (!value)
  {
    v79 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: No existing EAP config for %@, using new one", "__WiFiManagerModifyExistingNetwork", sub_10002B088(a2));
    objc_autoreleasePoolPop(v79);
    goto LABEL_140;
  }
  if (theDict)
  {
    v91 = 0;
    theArray = 0;
    CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("AcceptEAPTypes"), (const void **)&theArray);
    CFDictionaryGetValueIfPresent(theDict, CFSTR("AcceptEAPTypes"), (const void **)&v91);
    if (!theArray)
      goto LABEL_140;
    if (CFArrayGetCount(theArray) >= 1)
    {
      v70 = 0;
      v71 = 1;
      do
      {
        v72 = CFArrayGetValueAtIndex(theArray, v70);
        v73 = v91;
        if (!v91
          || (v74 = v72, v96.length = CFArrayGetCount(v91), v96.location = 0, !CFArrayContainsValue(v73, v96, v74)))
        {
          v71 = 0;
        }
        ++v70;
      }
      while (v70 < CFArrayGetCount(theArray));
      if (!v71)
        goto LABEL_140;
    }
    v89 = 0;
    v90 = 0;
    CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("UserName"), (const void **)&v90);
    CFDictionaryGetValueIfPresent(theDict, CFSTR("UserName"), (const void **)&v89);
    if (v89 || !v90)
      goto LABEL_140;
    v75 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Keeping EXISTING username for %@", "__WiFiManagerModifyExistingNetwork", sub_10002B088(a2));
    objc_autoreleasePoolPop(v75);
    v76 = v90;
    v77 = CFSTR("UserName");
    v78 = (uint64_t)a2;
  }
  else
  {
    v80 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Keeping EXISTING EAP config for %@", "__WiFiManagerModifyExistingNetwork", sub_10002B088(a2));
    objc_autoreleasePoolPop(v80);
    v76 = sub_10002BE64((uint64_t)v19, CFSTR("EnterpriseProfile"));
    v78 = (uint64_t)a2;
    v77 = CFSTR("EnterpriseProfile");
  }
  sub_10002C478(v78, v77, v76);
LABEL_140:
  if (!sub_10003145C((uint64_t)a2)
    && !sub_1000C3B8C((_BOOL8)a2)
    && !sub_10002DAB4((uint64_t)a2)
    && !sub_10002DAF0((_BOOL8)a2)
    && !sub_1000C433C((const __CFDictionary *)a2))
  {
    v81 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: new network is open, so remove existing password", "__WiFiManagerModifyExistingNetwork");
    objc_autoreleasePoolPop(v81);
    sub_1000C65D8(a2);
  }
  if (!sub_10002BE64((uint64_t)a2, CFSTR("WiFiNetworkNANServiceID"))
    && sub_10002BE64((uint64_t)v19, CFSTR("WiFiNetworkNANServiceID")))
  {
    v82 = sub_10002BE64((uint64_t)v19, CFSTR("WiFiNetworkNANServiceID"));
    sub_10002C478((uint64_t)a2, CFSTR("WiFiNetworkNANServiceID"), v82);
  }
  if (!sub_10002BE64((uint64_t)a2, CFSTR("PublicAirPlayNetwork"))
    && sub_10002BE64((uint64_t)v19, CFSTR("PublicAirPlayNetwork")))
  {
    v83 = sub_10002BE64((uint64_t)v19, CFSTR("PublicAirPlayNetwork"));
    sub_10002C478((uint64_t)a2, CFSTR("PublicAirPlayNetwork"), v83);
  }
  v84 = kCFBooleanFalse;
  if (sub_1000C5104((uint64_t)a2))
    v85 = kCFBooleanTrue;
  else
    v85 = kCFBooleanFalse;
  sub_10002C478((uint64_t)a2, CFSTR("ALLOW_WPA2_PSK"), v85);
  if (!sub_1000C5C14((uint64_t)a2) && !sub_1000C52E4((const __CFDictionary *)a2))
    v84 = kCFBooleanTrue;
  sub_10002C478((uint64_t)a2, CFSTR("ALLOW_OWE_TSN"), v84);
  CFArrayRemoveValueAtIndex(a3, idx);
  CFArrayInsertValueAtIndex(a3, idx, a2);
  sub_100094200(a1, (CFDictionaryRef *)a2, 0);
  sub_100095610(a1, a3);
  return 1;
}

void sub_100096508(uint64_t a1, const void *a2, const void *a3)
{
  void *v6;
  uint64_t v7;
  const void *v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  void *v12;
  void *v13;
  const void *v14;
  char v15;
  uint64_t context;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  char v20;

  v15 = 0;
  if (sub_1000C9410((uint64_t)a3) != 1)
  {
    v7 = sub_1000C8C90((uint64_t)a2, (uint64_t)a3, &v15);
    if (v7 == 1)
    {
      v20 = 1;
      context = a1;
      v17 = 0xAAAAAAAA0000004FLL;
      v18 = &v20;
      v19 = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
      sub_1000CBF00(a3, 1);
      return;
    }
    if (v7 == -1)
    {
      v8 = a3;
      v9 = 2;
    }
    else
    {
      if (!v15)
      {
LABEL_18:
        v20 = 0;
        context = a1;
        v17 = 0xAAAAAAAA0000004FLL;
        v18 = &v20;
        v19 = 1;
        goto LABEL_19;
      }
      if (a2)
      {
        v10 = (const __CFString *)sub_10002B088(a2);
        v11 = (const __CFString *)sub_10002B088(a3);
        if (CFStringCompare(v10, v11, 0))
        {
          v12 = objc_autoreleasePoolPush();
          v13 = (void *)qword_10026DD20;
          if (qword_10026DD20)
          {
            v14 = sub_10002B088(a2);
            objc_msgSend(v13, "WFLog:message:", 4, "NOI home-state: ERROR Multiple home networks exist '%@' , '%@' ", v14, sub_10002B088(a3));
          }
          objc_autoreleasePoolPop(v12);
          v20 = 1;
          context = a1;
          v17 = 0xAAAAAAAA0000004FLL;
          v18 = &v20;
          v19 = 1;
          CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
        }
      }
      v8 = a3;
      v9 = 1;
    }
    sub_1000CBF00(v8, v9);
    sub_1000C682C((uint64_t)a3, 0);
    sub_1000C6770((uint64_t)a3, 1);
    return;
  }
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s Forced fix network. Setting '%@' as NOI", "__WiFiManagerApplyHomeNetworkPolicy", sub_10002B088(a3));
  objc_autoreleasePoolPop(v6);
  sub_1000CC050(a3, 1);
  if (sub_1000C3F88((uint64_t)a3) != 1)
    goto LABEL_18;
  v20 = 1;
  context = a1;
  v17 = 0xAAAAAAAA0000004FLL;
  v18 = &v20;
  v19 = 1;
LABEL_19:
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
}

NSDictionary *__cdecl sub_100096760(id a1, id a2)
{
  CFDictionaryRef v2;

  v2 = sub_1000173C0((uint64_t)a2);
  return (NSDictionary *)(id)CFMakeCollectable(v2);
}

void sub_10009677C(uint64_t a1)
{
  sub_100050940(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), *(_QWORD *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_1000967B4(uint64_t a1, const void *a2, unsigned int a3)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v7;
  const void *v8;
  CFArrayRef v9;
  CFArrayRef v10;
  void *v11;
  void *v12;
  void *v13;
  __CFDictionary *context;
  void *values;

  values = 0;
  if (!a2)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network is null", "__WiFiManagerDispatchClientsNetworksChangedEvent");
    goto LABEL_27;
  }
  values = sub_1000173C0((uint64_t)a2);
  if (!values)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network attributes is null", "__WiFiManagerDispatchClientsNetworksChangedEvent");
    goto LABEL_27;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create dictionary", "__WiFiManagerDispatchClientsNetworksChangedEvent");
LABEL_27:
    objc_autoreleasePoolPop(v13);
    v7 = 0;
    goto LABEL_13;
  }
  v7 = Mutable;
  if (a3 > 2 || (v8 = *off_100230CE0[a3]) == 0)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create changeTypeKey", "__WiFiManagerDispatchClientsNetworksChangedEvent");
    goto LABEL_12;
  }
  v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  if (!v9)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to create changes array", "__WiFiManagerDispatchClientsNetworksChangedEvent");
LABEL_12:
    objc_autoreleasePoolPop(v12);
LABEL_13:
    v10 = 0;
    goto LABEL_14;
  }
  v10 = v9;
  CFDictionarySetValue(v7, v8, v9);
  v11 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: type %@ network %@", "__WiFiManagerDispatchClientsNetworksChangedEvent", v8, sub_10002B088(a2));
  objc_autoreleasePoolPop(v11);
  context = v7;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_1000B9D58, &context);
LABEL_14:
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  if (v10)
    CFRelease(v10);
  if (v7)
    CFRelease(v7);
}

void sub_100096A30(_QWORD *a1, const void *a2)
{
  void *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  CFIndex Count;
  __CFDictionary *MutableCopy;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (a2)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ssid: %@", "WiFiManagerRemoveNetworkNameFromUserNotificationBlacklist", a2);
      objc_autoreleasePoolPop(v4);
      v5 = sub_1000A6EF8(a1, 0);
      if (v5)
      {
        v6 = v5;
        if (CFDictionaryContainsKey(v5, a2))
        {
          Count = CFDictionaryGetCount(v6);
          MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count, v6);
          CFDictionaryRemoveValue(MutableCopy, a2);
          -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", MutableCopy, CFSTR("UserNotificationBlacklist"));
          sub_1000A371C((uint64_t)a1, MutableCopy);
          if (MutableCopy)
            CFRelease(MutableCopy);
        }
        CFRelease(v6);
      }
    }
    else
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ssid is null", "WiFiManagerRemoveNetworkNameFromUserNotificationBlacklist");
      objc_autoreleasePoolPop(v4);
    }
  }
}

uint64_t sub_100096B7C(uint64_t a1, void *a2, const __CFString *a3, CFBooleanRef a4)
{
  void *v8;
  const void *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex v12;
  void *v13;
  const void *ValueAtIndex;
  uint64_t v15;
  CFTypeID v16;
  const __CFString *v17;
  CFComparisonResult v18;
  CFTypeID v19;
  __CFString *v20;
  uint64_t v21;
  CFBooleanRef v22;
  int v23;
  void *v24;
  uint64_t v25;
  CFTypeID TypeID;
  const __CFBoolean *v27;
  void *v28;
  void *v29;
  void *v30;
  CFTypeID v32;
  CFTypeID v33;
  CFTypeID v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  __CFString *v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  void *v45;
  void *v46;
  uint64_t v47;
  CFIndex idx;

  v8 = objc_autoreleasePoolPush();
  v47 = 0;
  idx = -1;
  if (!a1)
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerPrivateMacUpdateProperty");
    goto LABEL_108;
  }
  if (!a2)
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerPrivateMacUpdateProperty");
    goto LABEL_108;
  }
  v9 = sub_10002B088(a2);
  v10 = (const __CFArray *)sub_1000875B0(a1);
  if (!v10)
  {
LABEL_52:
    v25 = 0;
    goto LABEL_53;
  }
  v11 = v10;
  sub_10002B7AC(v10, (const __CFDictionary **)a2, &idx, &v47);
  v12 = idx;
  if (idx == -1)
  {
    if (sub_1000C3BC4((_BOOL8)a2))
    {
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation :  Updating original HS2.0 Provisioning. SSID <%@> for <%@> with value <%@>", "WiFiManagerPrivateMacUpdateProperty", v9, a3, a4, v47);
      objc_autoreleasePoolPop(v13);
      sub_1000AADDC(v11, a2, &idx, &v47);
    }
    v12 = idx;
    if (idx == -1)
    {
      v29 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation :  Network not found in the private mac cache. Avoiding any updates. Requested update for : <%@> with value : <%@> for network : <%@>", "WiFiManagerPrivateMacUpdateProperty", a3, a4, v9);
      v30 = v29;
      goto LABEL_51;
    }
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v11, v12);
  if (!ValueAtIndex || (v15 = (uint64_t)ValueAtIndex, v16 = CFGetTypeID(ValueAtIndex), v16 != sub_1000C312C()))
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WFMacRandomisation : privateMacCache network invalid", "WiFiManagerPrivateMacUpdateProperty");
LABEL_108:
    v30 = v46;
LABEL_51:
    objc_autoreleasePoolPop(v30);
    goto LABEL_52;
  }
  if (CFStringCompare(a3, CFSTR("BSSID"), 1uLL) == kCFCompareEqualTo)
  {
    v20 = CFSTR("BSSID");
    goto LABEL_30;
  }
  if (CFStringCompare(a3, CFSTR("PresentInKnownNetworks"), 1uLL) == kCFCompareEqualTo)
  {
    if (!a4)
      goto LABEL_33;
    TypeID = CFBooleanGetTypeID();
    if (TypeID != CFGetTypeID(a4))
      goto LABEL_33;
    if (kCFBooleanFalse != a4 || idx == -1)
    {
      v20 = CFSTR("PresentInKnownNetworks");
      goto LABEL_30;
    }
    v27 = (const __CFBoolean *)sub_10002BE64(v15, CFSTR("NetworkAddedByProfile"));
    if (!sub_10002DA5C(v15) || !v27 || v27 != kCFBooleanTrue)
    {
      CFArrayRemoveValueAtIndex(v11, idx);
      goto LABEL_33;
    }
    if (!sub_1000AB7A0(a1, v15))
      goto LABEL_33;
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WFMacRandomisation : %s removed HS20 entries", "WiFiManagerPrivateMacUpdateProperty");
LABEL_47:
    objc_autoreleasePoolPop(v28);
    goto LABEL_33;
  }
  if (CFStringCompare(a3, CFSTR("PRIVATE_MAC_ADDRESS"), 1uLL) == kCFCompareEqualTo)
  {
    if (a4)
    {
      v32 = CFDictionaryGetTypeID();
      if (v32 == CFGetTypeID(a4))
      {
        v20 = CFSTR("PRIVATE_MAC_ADDRESS");
        goto LABEL_30;
      }
    }
    goto LABEL_33;
  }
  if (CFStringCompare(a3, CFSTR("PrivateMacFeatureToggled"), 1uLL) == kCFCompareEqualTo)
  {
    if (!a4)
      goto LABEL_33;
    v33 = CFBooleanGetTypeID();
    if (v33 != CFGetTypeID(a4) || kCFBooleanFalse != a4)
      goto LABEL_33;
    v20 = CFSTR("PrivateMacFeatureToggled");
    goto LABEL_61;
  }
  if (CFStringCompare(a3, CFSTR("MacAddressRandomisationClassificationAttempts"), 1uLL) == kCFCompareEqualTo)
  {
    if (!a4)
      goto LABEL_33;
    v34 = CFBooleanGetTypeID();
    if (v34 != CFGetTypeID(a4))
      goto LABEL_33;
    if (kCFBooleanTrue != a4)
      goto LABEL_33;
    v35 = sub_100017A54(v15, CFSTR("MacAddressRandomisationClassificationAttempts"));
    v36 = (v35 - 1);
    if (v35 < 1)
      goto LABEL_33;
    if (v35 != 1)
    {
      v37 = v15;
      v38 = CFSTR("MacAddressRandomisationClassificationAttempts");
LABEL_83:
      sub_10002B698(v37, v38, v36);
      goto LABEL_33;
    }
    sub_10002C478(v15, CFSTR("MacAddressRandomisationTagMigratedNetwork"), 0);
    sub_10002C478(v15, CFSTR("MacAddressRandomisationClassificationAttempts"), 0);
    sub_10002C478(v15, CFSTR("PrivateMacClassifyInterval"), 0);
    v20 = CFSTR("PrivateMacJoinDateAfterUpgrade");
LABEL_61:
    v21 = v15;
    v22 = 0;
    goto LABEL_32;
  }
  v17 = CFSTR("RandomMACBannerDisplayed");
  if (CFStringCompare(a3, CFSTR("RandomMACBannerDisplayed"), 1uLL) == kCFCompareEqualTo)
    goto LABEL_84;
  if (CFStringCompare(a3, CFSTR("isBackhaulLinkUp"), 1uLL) == kCFCompareEqualTo)
  {
    v20 = CFSTR("isBackhaulLinkUp");
    goto LABEL_30;
  }
  if (CFStringCompare(a3, CFSTR("FeatureOffBySystemForCarplay"), 1uLL) == kCFCompareEqualTo)
  {
    v20 = CFSTR("FeatureOffBySystemForCarplay");
    goto LABEL_30;
  }
  v17 = CFSTR("FailureThresholdMet");
  if (CFStringCompare(a3, CFSTR("FailureThresholdMet"), 1uLL) == kCFCompareEqualTo)
  {
    if (kCFBooleanFalse != a4)
      goto LABEL_33;
    v39 = sub_100017A54(v15, CFSTR("FailureCountThresholdCurrent"));
    if (*(_DWORD *)(a1 + 456) > v39)
    {
      sub_10002C478(v15, CFSTR("FailureThresholdMet"), a4);
    }
    else
    {
      v40 = *(_DWORD *)(a1 + 464) + v39;
      v41 = *(_DWORD *)(a1 + 460);
      if (v40 >= v41)
        v42 = v41;
      else
        v42 = v40;
      sub_10002C478(v15, CFSTR("FailureThresholdMet"), a4);
      if ((_DWORD)v42)
        sub_10002B698(v15, CFSTR("FailureCountThresholdCurrent"), v42);
    }
    v38 = CFSTR("FailureCountCurrent");
    v37 = v15;
    v36 = 0;
    goto LABEL_83;
  }
  if (CFStringCompare(a3, CFSTR("FailureCountCurrent"), 1uLL) == kCFCompareEqualTo)
  {
    if (kCFBooleanTrue != a4)
      goto LABEL_33;
    v43 = sub_100017A54(v15, CFSTR("FailureCountCurrent"));
    v44 = sub_100017A54(v15, CFSTR("FailureCountThresholdCurrent"));
    v36 = v43 + 1;
    if (v36 < v44)
    {
      v38 = CFSTR("FailureCountCurrent");
      v37 = v15;
      goto LABEL_83;
    }
LABEL_84:
    v21 = v15;
    v20 = (__CFString *)v17;
    goto LABEL_31;
  }
  if (CFStringCompare(a3, CFSTR("ResetCaptiveProbe"), 1uLL) == kCFCompareEqualTo)
  {
    if (kCFBooleanFalse == a4 || kCFBooleanTrue == a4)
    {
      v20 = CFSTR("ResetCaptiveProbe");
      goto LABEL_30;
    }
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Incorrect value being set for kWiFiPrivateMacResetCaptiveProbe", "WiFiManagerPrivateMacUpdateProperty");
    goto LABEL_47;
  }
  if (CFStringCompare(a3, CFSTR("IsPrivateMacAddressCarriedOver"), 1uLL) == kCFCompareEqualTo)
  {
    if (kCFBooleanFalse == a4 || kCFBooleanTrue == a4)
    {
      v20 = CFSTR("IsPrivateMacAddressCarriedOver");
      goto LABEL_30;
    }
    v28 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Incorrect value being set for kWiFiPrivateMacIsCarriedOver", "WiFiManagerPrivateMacUpdateProperty");
    goto LABEL_47;
  }
  if (CFStringCompare(a3, CFSTR("ForcedDisassoc"), 1uLL))
  {
    v18 = CFStringCompare(a3, CFSTR("LinkDownTimestamp"), 1uLL);
    if (a4)
    {
      if (v18 == kCFCompareEqualTo)
      {
        v19 = CFGetTypeID(a4);
        if (v19 == CFDateGetTypeID())
        {
          v20 = CFSTR("LinkDownTimestamp");
LABEL_30:
          v21 = v15;
LABEL_31:
          v22 = a4;
LABEL_32:
          sub_10002C478(v21, v20, v22);
        }
      }
    }
  }
  else if (kCFBooleanTrue == a4 && *(_BYTE *)(a1 + 362))
  {
    v45 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WFMacRandomisation : Manually disassociating from network : <%@> to apply new private MAC properties", "WiFiManagerPrivateMacUpdateProperty", v9);
    objc_autoreleasePoolPop(v45);
    if (sub_100087488((_QWORD *)a1, CFSTR("PrivateMacForcedDisassocPending"), 0, 0))
    {
      *(_BYTE *)(a1 + 362) = 0;
      sub_10008A2B8(a1, "WiFiManagerPrivateMacUpdateProperty", 29054);
      v20 = CFSTR("ForcedDisassoc");
      goto LABEL_30;
    }
  }
LABEL_33:
  v23 = sub_1000A46A8(a1, v11);
  sub_1000A485C(a1, 1, 0);
  if (!v23)
    goto LABEL_52;
  v24 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, " %s WFMacRandomisation : Updated property <%@> of network <%@> with value <%@> to the list of private mac networks", "WiFiManagerPrivateMacUpdateProperty", a3, v9, a4);
  objc_autoreleasePoolPop(v24);
  v25 = 1;
LABEL_53:
  objc_autoreleasePoolPop(v8);
  return v25;
}

uint64_t sub_100097414(uint64_t a1, uint64_t a2, const void *a3, const __CFDictionary *a4, void (*a5)(uint64_t, const void *, uint64_t, uint64_t), uint64_t a6)
{
  void *v10;
  __CFString *Value;
  __CFString *v12;
  id v13;
  NSString *v14;
  NSString *v15;
  NSString *v16;
  NSString *v17;
  NSString *v18;
  NSString *v19;
  NSString *v20;
  char v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  id v25;
  void *v26;
  __CFString *Mutable;
  __CFString *v28;
  void *v29;
  void *v30;
  const void *v31;
  CFTypeID v32;
  _BOOL4 v33;
  id v34;
  void *v35;
  void *v36;
  id v37;
  char v38;
  void *v39;
  CFIndex Count;
  CFIndex v41;
  CFIndex v42;
  const __CFString *v43;
  _BOOL8 v44;
  char v45;
  void *v46;
  void *v47;
  const void *v48;
  const __CFString *v49;
  const __CFArray *v50;
  CFIndex v51;
  CFIndex v52;
  CFIndex v53;
  const void *ValueAtIndex;
  const void *v55;
  void *v56;
  uint64_t v57;
  WiFiAddNetworkRequest *v58;
  uint64_t v59;
  void *v60;
  void *v61;
  void *v62;
  const char *v63;
  const void *v64;
  _BOOL4 v65;
  const void *v66;
  const void *v67;
  void *v68;
  char v69;
  const void *v70;
  const void *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  int v79;
  char v80;
  void *v81;
  int v83;
  void *v84;
  void *v85;
  void *v86;
  int v87;
  int v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  NSString *v96;
  _BOOL4 v97;
  uint64_t v99;
  void *v101;
  unsigned int v102;
  const __CFDictionary *theDict;
  uint64_t v104;
  const void *v105;
  _QWORD v106[5];
  uint64_t valuePtr;
  const void *v108;
  const void *v109;
  CFTypeRef v110;

  v10 = objc_autoreleasePoolPush();
  v109 = 0;
  v110 = 0;
  v108 = 0;
  if (a1)
  {
    v99 = a2;
    if (a4)
    {
      if (sub_10009836C(a1))
      {
        v92 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: restriction policy is active", "WiFiManagerAddNetworkAsync");
        v59 = 5;
        goto LABEL_165;
      }
      Value = (__CFString *)CFDictionaryGetValue(a4, CFSTR("BundleIdentifier"));
      if (Value)
      {
        v12 = Value;
        theDict = a4;
        v104 = a1;
        v101 = v10;
        v13 = objc_alloc((Class)NSMutableDictionary);
        v14 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("WiFiKnownNetworkAdded"));
        v15 = +[NSString stringWithString:](NSString, "stringWithString:", v12);
        v16 = +[NSString stringWithString:](NSString, "stringWithString:", sub_1000161D4(a2));
        v17 = +[NSString stringWithString:](NSString, "stringWithString:", sub_1000983E4((uint64_t)v12));
        v105 = a3;
        v18 = +[NSString stringWithString:](NSString, "stringWithString:", sub_1000984B4((uint64_t)v12));
        v19 = +[NSString stringWithString:](NSString, "stringWithString:", CFSTR("kWiFiAddNetworkOriginatorUser"));
        v20 = +[NSString stringWithString:](NSString, "stringWithString:", CFSTR("kWiFiManagerAddNetworkResultSuccess"));
        v21 = sub_1000C5C14((uint64_t)v105);
        v22 = CFSTR("kWiFiNetworkAuthFlagsWPA");
        v23 = CFSTR("kWiFiNetworkAuthFlagsWEP");
        if ((v21 & 1) == 0)
          v23 = CFSTR("kWiFiNetworkAuthFlagsOpen");
        if ((v21 & 2) == 0)
          v22 = v23;
        if ((v21 & 8) != 0)
          v24 = CFSTR("kWiFiNetworkAuthFlagsEAP");
        else
          v24 = v22;
        v96 = v18;
        a3 = v105;
        v25 = objc_msgSend(v13, "initWithObjectsAndKeys:", v14, CFSTR("Operation"), v15, CFSTR("AppBundleID"), v16, CFSTR("Process"), v17, CFSTR("BTTCCState"), v96, CFSTR("LocalNetworkTCCState"), v19, CFSTR("AddReason"), v20, CFSTR("Result"), +[NSString stringWithString:](NSString, "stringWithString:", v24), CFSTR("SecurityType"), 0);
        v26 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Request to add network with content: %@", "WiFiManagerAddNetworkAsync", v105);
        objc_autoreleasePoolPop(v26);
        if (sub_1000C3BC4((_BOOL8)v105))
        {
          Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
          if (Mutable)
          {
            v28 = Mutable;
            sub_1000C9564((uint64_t)v105, Mutable);
            v29 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS20 Account Info:%@", "WiFiManagerAddNetworkAsync", v28);
            objc_autoreleasePoolPop(v29);
            CFRelease(v28);
          }
          else
          {
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not allocate buffer for HS 2.0 info", "WiFiManagerAddNetworkAsync");
            objc_autoreleasePoolPop(v30);
          }
        }
        if (CFDictionaryContainsKey(theDict, CFSTR("NetworkOriginator")))
        {
          v31 = CFDictionaryGetValue(theDict, CFSTR("NetworkOriginator"));
          v32 = CFGetTypeID(v31);
          if (v32 == CFNumberGetTypeID())
          {
            LODWORD(valuePtr) = -1431655766;
            CFNumberGetValue((CFNumberRef)v31, kCFNumberIntType, &valuePtr);
            v33 = valuePtr == 1;
            if ((_DWORD)valuePtr == 6)
              v33 = 1;
            v102 = v33;
            if ((_DWORD)valuePtr == 6 || (_DWORD)valuePtr == 1)
            {
              valuePtr = 0;
              v34 = objc_msgSend(objc_alloc((Class)LSApplicationRecord), "initWithBundleIdentifier:allowPlaceholder:error:", v12, 1, &valuePtr);
              v35 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %@", "WiFiManagerAddNetworkAsync", valuePtr);
              objc_autoreleasePoolPop(v35);
              if (!v34)
              {
                valuePtr = 0;
                v34 = objc_msgSend(objc_alloc((Class)LSApplicationRecord), "initWithBundleIdentifier:allowPlaceholder:error:", v12, 1, &valuePtr);
                v36 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: error %@", "WiFiManagerAddNetworkAsync", valuePtr);
                objc_autoreleasePoolPop(v36);
                if (!v34)
                {
                  v90 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%@ bundle identifier is not installed", v12);
                  objc_autoreleasePoolPop(v90);
                  v57 = 0;
                  v37 = 0;
                  v58 = 0;
                  v59 = 4;
                  if (!v25)
                    goto LABEL_123;
                  goto LABEL_121;
                }
              }
              v37 = objc_msgSend(objc_msgSend(v34, "localizedName"), "copy");
              sub_10002C478((uint64_t)v105, CFSTR("OriginatingApp"), v37);

              v38 = 1;
LABEL_40:
              Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1688));
              if (Count >= 1)
              {
                v41 = Count;
                v42 = 0;
                while (1)
                {
                  v43 = (const __CFString *)objc_msgSend((id)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1688), v42), "bundleId");
                  if (CFStringCompare(v12, v43, 0) == kCFCompareEqualTo)
                    break;
                  if (v41 == ++v42)
                    goto LABEL_44;
                }
                v60 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Add network async request is already queued for bundleId %@", v12);
                objc_autoreleasePoolPop(v60);
                v57 = 0;
                v58 = 0;
                v59 = 3;
                if (!v25)
                {
LABEL_123:
                  v10 = v101;
                  if ((v57 & 1) != 0)
                    goto LABEL_128;
                  goto LABEL_124;
                }
LABEL_121:
                if (&_AnalyticsSendEventLazy)
                {
                  objc_msgSend(v25, "setObject:forKey:", +[NSString stringWithString:](NSString, "stringWithString:", off_100230CF8[v102]), CFSTR("AddReason"));
                  objc_msgSend(v25, "setObject:forKey:", +[NSString stringWithString:](NSString, "stringWithString:", sub_100098664(v59)), CFSTR("Result"));
                  NSLog(CFSTR("CoreAnalytics metricsDict %@"), v25);
                  v106[0] = _NSConcreteStackBlock;
                  v106[1] = 3221225472;
                  v106[2] = sub_100098DB4;
                  v106[3] = &unk_100230830;
                  v106[4] = v25;
                  AnalyticsSendEventLazy(CFSTR("com.apple.wifi.knownnetwork"), v106);
                }
                goto LABEL_123;
              }
LABEL_44:
              v44 = sub_10002DA5C((_BOOL8)v105);
              if (v44)
                v45 = v38;
              else
                v45 = 1;
              objc_msgSend(v25, "setObject:forKey:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v44), CFSTR("Hotspot20"));
              v46 = objc_autoreleasePoolPush();
              v47 = (void *)qword_10026DD20;
              if ((v45 & 1) == 0)
              {
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s HS20 network must use originator type kWiFiAddNetworkOriginator3rdParty", "WiFiManagerAddNetworkAsync");
                objc_autoreleasePoolPop(v46);
                v57 = 0;
                v58 = 0;
                goto LABEL_66;
              }
              if (qword_10026DD20)
              {
                v48 = sub_10002B088(v105);
                v49 = CFSTR("3rd Party");
                if (!v102)
                  v49 = CFSTR("user");
                objc_msgSend(v47, "WFLog:message:", 3, "%s: adding ssid='%@' bundleId='%@' appName='%@' originator='%@' HS20=%d", "WiFiManagerAddNetworkAsync", v48, v12, v37, v49, v44);
              }
              objc_autoreleasePoolPop(v46);
              v97 = CFDictionaryContainsKey(theDict, CFSTR("AddNetworkUseSSIDPrefix")) != 0;
              if (v44)
              {
                v50 = *(const __CFArray **)(a1 + 216);
                if (v50)
                {
                  v51 = CFArrayGetCount(v50);
                  if (v51 >= 1)
                  {
                    v52 = v51;
                    v53 = 0;
                    while (1)
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), v53);
                      v55 = sub_1000CB154((uint64_t)ValueAtIndex);
                      if (v55)
                      {
                        if (CFEqual(v55, v12) && sub_1000C5FEC((uint64_t)v105, (uint64_t)ValueAtIndex))
                          break;
                      }
                      if (v52 == ++v53)
                        goto LABEL_60;
                    }
                    v70 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), v53);
                    if (v70)
                    {
                      v71 = v70;
                      v72 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: matching HS20 network found at index %ld: %@", "__WiFiManagerCopyExistingHS20Network", v53, v71);
                      objc_autoreleasePoolPop(v72);
                      v110 = CFRetain(v71);
                      a3 = v105;
                      if (!v110)
                        goto LABEL_92;
                      goto LABEL_73;
                    }
                  }
LABEL_60:
                  v56 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matching HS20 network found", "__WiFiManagerCopyExistingHS20Network");
                  objc_autoreleasePoolPop(v56);
                  a3 = v105;
                }
                else
                {
                  v93 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager->networks is NULL", "__WiFiManagerCopyExistingHS20Network");
                  objc_autoreleasePoolPop(v93);
                }
              }
              else
              {
                sub_100098780(a1, v105, &v110);
              }
              if (!v110)
              {
LABEL_92:
                v69 = 0;
                v65 = 0;
                v67 = 0;
                goto LABEL_93;
              }
LABEL_73:
              v61 = objc_autoreleasePoolPush();
              v62 = (void *)qword_10026DD20;
              if (qword_10026DD20)
              {
                if (v44)
                  v63 = "domain";
                else
                  v63 = "SSID";
                if (v44)
                  v64 = sub_10002BE64((uint64_t)a3, CFSTR("DomainName"));
                else
                  v64 = sub_10002B088(a3);
                objc_msgSend(v62, "WFLog:message:", 3, "%s: Found existing network matching network to be added; %s %@",
                  "WiFiManagerAddNetworkAsync",
                  v63,
                  v64);
              }
              objc_autoreleasePoolPop(v61);
              v65 = sub_1000C5378((uint64_t)v110);
              v66 = sub_1000CB154((uint64_t)v110);
              v67 = v66;
              if (v66 && CFEqual(v66, v12))
              {
                v68 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is already owned by the same application.", "WiFiManagerAddNetworkAsync");
                objc_autoreleasePoolPop(v68);
                v97 = 0;
                v69 = 1;
              }
              else
              {
                v97 = 0;
                v69 = 0;
              }
LABEL_93:
              v73 = sub_100037F44(v12, a3, &v109, &v108);
              v74 = v73;
              switch(v73)
              {
                case 1:
                  v75 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: '%@' is authorized to join '%@'", "WiFiManagerAddNetworkAsync", v12, v105);
                  objc_autoreleasePoolPop(v75);
                  if (CFDictionaryGetValue(theDict, CFSTR("isAccessory")))
                  {
                    v102 = 6;
LABEL_109:
                    a3 = v105;
LABEL_110:
                    objc_msgSend(v25, "setObject:forKey:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v97), CFSTR("UsedPrefix"));
                    if (v67 && v65)
                    {
                      sub_1000CB0D8((uint64_t)a3, v67);
                    }
                    else
                    {
                      sub_1000CB0D8((uint64_t)a3, v12);
                      sub_1000CB1D4((uint64_t)a3, v102);
                    }
                    v79 = sub_1000954F8((const __CFArray *)a1, a3);
                    v80 = v69 ^ 1;
                    if (!v79)
                      v80 = 1;
                    if ((v80 & 1) == 0)
                    {
                      v81 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Already owned and associated to %@", "WiFiManagerAddNetworkAsync", sub_10002B088(a3));
                      objc_autoreleasePoolPop(v81);
                      v57 = 0;
                      v58 = 0;
                      v59 = 6;
                      break;
                    }
                    v83 = CFDictionaryContainsKey(theDict, CFSTR("DisassociateOnSessionEnd"));
                    if (v83)
                    {
                      v84 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Session based add requested by %@", "WiFiManagerAddNetworkAsync", v12);
                      objc_autoreleasePoolPop(v84);
                    }
                    objc_msgSend(v25, "setObject:forKey:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v83 != 0), CFSTR("SessionBased"));
                    if (v109)
                    {
                      sub_1000CFAB0((uint64_t)a3, v109);
                      v85 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting accessory display friendly name='%@' for %@", "WiFiManagerAddNetworkAsync", v109, sub_10002B088(a3));
                      objc_autoreleasePoolPop(v85);
                    }
                    if (v108)
                    {
                      sub_1000CFBAC((uint64_t)a3, v108);
                      v86 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: setting accessory identifier='%@' for %@", "WiFiManagerAddNetworkAsync", v108, sub_10002B088(a3));
                      objc_autoreleasePoolPop(v86);
                    }
                    v87 = *(_DWORD *)(a1 + 316);
                    v88 = *(unsigned __int8 *)(v104 + 129);
                    v89 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Add network async- prompting for user consent", "WiFiManagerAddNetworkAsync");
                    objc_autoreleasePoolPop(v89);
                    LOBYTE(v95) = v74 == 1;
                    BYTE2(v94) = v97;
                    BYTE1(v94) = v83 != 0;
                    LOBYTE(v94) = v88 != 0;
                    v58 = -[WiFiAddNetworkRequest initWithClient:network:bundleId:localizedAppName:originator:poweredOff:wapi:sessionBased:useSSIDPrefix:callback:context:bypassPrompt:]([WiFiAddNetworkRequest alloc], "initWithClient:network:bundleId:localizedAppName:originator:poweredOff:wapi:sessionBased:useSSIDPrefix:callback:context:bypassPrompt:", v99, a3, v12, v37, v102, v87 == 0, v94, a5, a6, v95);
                    if (v58)
                    {
                      a1 = v104;
                      CFArrayAppendValue(*(CFMutableArrayRef *)(v104 + 1688), v58);
                      sub_100098854(v104);
                      CFDictionaryContainsKey(theDict, CFSTR("DisassociateOnSessionEnd"));
                      v59 = 0;
                      v57 = 1;
                      if (!v25)
                        goto LABEL_123;
                      goto LABEL_121;
                    }
                    v57 = 0;
LABEL_66:
                    v59 = 4;
                    break;
                  }
                  v77 = objc_autoreleasePoolPush();
                  a3 = v105;
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: '%@' did not use joinAccessory API with authorized accessory", "WiFiManagerAddNetworkAsync", v12);
                  objc_autoreleasePoolPop(v77);
                  v57 = 0;
                  v58 = 0;
                  v59 = 11;
                  break;
                case 3:
                  v78 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: '%@' has DA record but did not declare WiFi support", "WiFiManagerAddNetworkAsync", v12);
                  objc_autoreleasePoolPop(v78);
                  goto LABEL_109;
                case 2:
                  v76 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: '%@' is not authorized to join '%@'", "WiFiManagerAddNetworkAsync", v12, a3);
                  objc_autoreleasePoolPop(v76);
                  v57 = 0;
                  v58 = 0;
                  v59 = 10;
                  break;
                default:
                  goto LABEL_110;
              }
              a1 = v104;
              if (!v25)
                goto LABEL_123;
              goto LABEL_121;
            }
            v38 = 0;
LABEL_39:
            v37 = 0;
            goto LABEL_40;
          }
          v39 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: wrong input type specified for originator", "WiFiManagerAddNetworkAsync");
          objc_autoreleasePoolPop(v39);
        }
        v38 = 0;
        v102 = 0;
        goto LABEL_39;
      }
      v92 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        v59 = 4;
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s missing bundle identifier from request", "WiFiManagerAddNetworkAsync");
LABEL_165:
        objc_autoreleasePoolPop(v92);
        v57 = 0;
        v37 = 0;
        v58 = 0;
        v25 = 0;
LABEL_124:
        if (v99)
          sub_100066564(v99, a1, (uint64_t)a3, v59);
        if (a5)
          a5(a1, a3, v59, a6);
        goto LABEL_128;
      }
    }
    else
    {
      v92 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: options is NULL", "WiFiManagerAddNetworkAsync");
    }
    v59 = 4;
    goto LABEL_165;
  }
  v91 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: manager is NULL", "WiFiManagerAddNetworkAsync");
  objc_autoreleasePoolPop(v91);
  v57 = 0;
  v37 = 0;
  v58 = 0;
  v25 = 0;
LABEL_128:
  if (v110)
  {
    CFRelease(v110);
    v110 = 0;
  }
  if (v58)
    CFRelease(v58);

  objc_autoreleasePoolPop(v10);
  return v57;
}

const __CFArray *sub_10009836C(uint64_t a1)
{
  const __CFArray *result;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  const void *ValueAtIndex;

  result = *(const __CFArray **)(a1 + 1608);
  if (result)
  {
    result = (const __CFArray *)CFArrayGetCount(result);
    if (result)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1608));
      if (Count < 1)
      {
        return 0;
      }
      else
      {
        v4 = Count;
        v5 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1608), v5);
          if (ValueAtIndex)
          {
            result = (const __CFArray *)sub_10003F5B4((uint64_t)ValueAtIndex);
            if ((_DWORD)result == 1)
              break;
          }
          if (v4 == ++v5)
            return 0;
        }
      }
    }
  }
  return result;
}

const __CFString *sub_1000983E4(uint64_t a1)
{
  void *v2;
  const void *v3;
  void *v4;
  const void *v5;
  void *v6;
  const __CFString *v7;

  v2 = objc_autoreleasePoolPush();
  v3 = (const void *)TCCAccessCopyBundleIdentifiersForService(kTCCServiceBluetoothAlways);
  v4 = (id)CFMakeCollectable(v3);
  v5 = (const void *)TCCAccessCopyBundleIdentifiersDisabledForService(kTCCServiceBluetoothAlways);
  v6 = (id)CFMakeCollectable(v5);
  if ((objc_msgSend(v4, "containsObject:", a1) & 1) != 0)
  {
    v7 = CFSTR("BluetoothTCCEnabled");
    NSLog(CFSTR("%s bundleId present in fAllowedAppBundles %@"), "__WiFiManagerBluetoothTCCState", a1);
  }
  else if (objc_msgSend(v6, "containsObject:", a1))
  {
    v7 = CFSTR("BluetoothTCCDisabled");
    NSLog(CFSTR("%s bundleId present in fDisallowedAppBundles %@"), "__WiFiManagerBluetoothTCCState", a1);
  }
  else
  {
    v7 = CFSTR("BluetoothTCCUnknown");
  }
  objc_autoreleasePoolPop(v2);
  return v7;
}

const __CFString *sub_1000984B4(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  const __CFString *v5;
  uint64_t v6;
  void *i;
  void *v8;
  unsigned int v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];

  if (!objc_opt_class(NEPathController))
    return CFSTR("LocalNetworkTCCUnknown");
  v2 = +[NEPathController copyAggregatePathRules](NEPathController, "copyAggregatePathRules");
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v3)
  {
    v4 = v3;
    v5 = CFSTR("LocalNetworkTCCUnknown");
    v6 = *(_QWORD *)v12;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v2);
        v8 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)i);
        if (objc_msgSend(objc_msgSend(v8, "matchSigningIdentifier"), "isEqualToString:", a1)
          && objc_msgSend(v8, "multicastPreferenceSet"))
        {
          v9 = objc_msgSend(v8, "denyMulticast");
          NSLog(CFSTR("%s bundleId has multicastAllow = %d set"), "__WiFiManagerLocalNetworkTCCState", v9 ^ 1);
          if (v9)
            v5 = CFSTR("LocalNetworkTCCDisabled");
          else
            v5 = CFSTR("LocalNetworkTCCEnabled");
        }
      }
      v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v4);
  }
  else
  {
    v5 = CFSTR("LocalNetworkTCCUnknown");
  }

  return v5;
}

__CFString *sub_100098644(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return off_100230CF8[a1];
}

const __CFString *sub_100098664(int a1)
{
  const __CFString *result;

  switch(a1)
  {
    case 0:
      result = CFSTR("kWiFiManagerAddNetworkResultSuccess");
      break;
    case 1:
      result = CFSTR("kWiFiManagerAddNetworkResultUserCancelled");
      break;
    case 2:
      result = CFSTR("kWiFiManagerAddNetworkResultSystemCancelled");
      break;
    case 3:
      result = CFSTR("kWiFiManagerAddNetworkResultRequestPending");
      break;
    case 4:
      result = CFSTR("kWiFiManagerAddNetworkResultInvalidBundleId");
      break;
    case 5:
      result = CFSTR("kWiFiManagerAddNetworkResultExistingNetwork");
      break;
    case 6:
      result = CFSTR("kWiFiManagerAddNetworkResultAlreadyAssociated");
      break;
    case 7:
      result = CFSTR("kWiFiManagerAddNetworkResultAssociationFailed");
      break;
    case 8:
      result = CFSTR("kWiFiManagerAddNetworkResultApplicationIsNotInForeground");
      break;
    case 9:
      result = CFSTR("kWiFiManagerAddNetworkResultNetworkNotFound");
      break;
    case 10:
      result = CFSTR("kWiFiManagerAddNetworkResultAccessoryNotAuthorized");
      break;
    case 11:
      result = CFSTR("kWiFiManagerAddNetworkResultAccessoryNetwork");
      break;
    default:
      if (a1 == 0x7FFFFFFF)
        result = CFSTR("kWiFiManagerAddNetworkResultUnknownError");
      else
        result = 0;
      break;
  }
  return result;
}

const __CFString *sub_100098730(uint64_t a1)
{
  char v1;
  const __CFString *v2;
  const __CFString *v3;

  v1 = sub_1000C5C14(a1);
  v2 = CFSTR("kWiFiNetworkAuthFlagsWPA");
  v3 = CFSTR("kWiFiNetworkAuthFlagsWEP");
  if ((v1 & 1) == 0)
    v3 = CFSTR("kWiFiNetworkAuthFlagsOpen");
  if ((v1 & 2) == 0)
    v2 = v3;
  if ((v1 & 8) != 0)
    return CFSTR("kWiFiNetworkAuthFlagsEAP");
  else
    return v2;
}

uint64_t sub_100098780(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  void *v6;
  void *v7;
  const void *v8;
  uint64_t result;
  CFIndex idx;

  idx = 0xAAAAAAAAAAAAAAAALL;
  sub_1000B9C54(*(CFArrayRef *)(a1 + 216), a2, &idx);
  if (idx == -1)
    return 0;
  v6 = objc_autoreleasePoolPush();
  v7 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v8 = sub_10002B088(a2);
    objc_msgSend(v7, "WFLog:message:", 3, "%s: Network with the same SSID %@ found at index %ld", "__WiFiManagerCopyExistingNetwork", v8, idx);
  }
  objc_autoreleasePoolPop(v6);
  result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), idx);
  if (result)
  {
    if (a3)
      *a3 = CFRetain((CFTypeRef)result);
    return 1;
  }
  return result;
}

void sub_100098854(uint64_t a1)
{
  void *v2;
  const __CFArray *v3;
  void *ValueAtIndex;
  void *v5;
  void *v6;
  id v7;
  unsigned int v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  double v14;
  void *v15;
  NSObject *v16;
  void *v17;
  __CFUserNotification *v18;
  __CFUserNotification *v19;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v21;
  __CFRunLoop *Main;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  const __CFString *v27;
  uint64_t v28;
  const __CFArray *v29;
  CFIndex FirstIndexOfValue;
  SInt32 error;
  void **block;
  unint64_t v33;
  void (*v34)(uint64_t);
  void *v35;
  uint64_t v36;
  uint64_t v37;
  CFRange v38;

  v2 = objc_autoreleasePoolPush();
  error = -1431655766;
  if (!*(_QWORD *)(a1 + 1648))
  {
    v3 = *(const __CFArray **)(a1 + 1688);
    if (!v3)
      goto LABEL_31;
    if (!CFArrayGetCount(v3))
      goto LABEL_31;
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1688), 0);
    if (!ValueAtIndex)
      goto LABEL_31;
    v5 = ValueAtIndex;
    if (objc_msgSend(ValueAtIndex, "sessionBased"))
    {
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: session based add, checking if application is in foreground", "__WiFiManagerDispatchNextAddNetworkAsyncRequest");
      objc_autoreleasePoolPop(v6);
      if (!objc_opt_class(BKSApplicationStateMonitor))
      {
LABEL_47:
        v28 = 0x7FFFFFFFLL;
LABEL_48:
        if (objc_msgSend(v5, "client"))
          sub_100066564((uint64_t)objc_msgSend(v5, "client"), a1, (uint64_t)objc_msgSend(v5, "network"), v28);
        if (objc_msgSend(v5, "callback"))
          ((void (*)(uint64_t, id, uint64_t, id))objc_msgSend(v5, "callback"))(a1, objc_msgSend(v5, "network"), v28, objc_msgSend(v5, "context"));
        v29 = *(const __CFArray **)(a1 + 1688);
        v38.length = CFArrayGetCount(v29);
        v38.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v29, v38, v5);
        if (FirstIndexOfValue != -1)
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1688), FirstIndexOfValue);
        sub_100098854(a1);
        goto LABEL_31;
      }
      v7 = objc_alloc_init((Class)BKSApplicationStateMonitor);
      v8 = objc_msgSend(v7, "applicationStateForApplication:", objc_msgSend(v5, "bundleId"));

      if (v8 != 8)
      {
        v24 = objc_autoreleasePoolPush();
        v25 = (void *)qword_10026DD20;
        if (qword_10026DD20)
        {
          v26 = objc_msgSend(v5, "bundleId");
          if (v8 - 1 > 3)
            v27 = CFSTR("Unknown");
          else
            v27 = off_100230D30[v8 - 1];
          objc_msgSend(v25, "WFLog:message:", 3, "%s: bundleId %@ is not in the foreground, current state = %@", "__WiFiManagerDispatchNextAddNetworkAsyncRequest", v26, v27);
        }
        objc_autoreleasePoolPop(v24);
        v28 = 8;
        goto LABEL_48;
      }
    }
    if (objc_msgSend(v5, "usingPrefix"))
    {
      v9 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: add network request using prefix, checking if matching network is nearby", "__WiFiManagerDispatchNextAddNetworkAsyncRequest");
      objc_autoreleasePoolPop(v9);
      block = (void **)a1;
      v33 = 0xAAAAAAAA00000069;
      v34 = (void (*)(uint64_t))objc_msgSend(v5, "network");
      v35 = 0;
LABEL_30:
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &block);
      goto LABEL_31;
    }
    if (objc_msgSend(v5, "sessionBased") && *(_QWORD *)(a1 + 1616))
    {
      v10 = objc_autoreleasePoolPush();
      v11 = objc_msgSend((id)sub_10002B088(objc_msgSend(v5, "network")), "stringByAppendingString:", objc_msgSend(v5, "bundleId"));
      v12 = objc_msgSend(*(id *)(a1 + 1616), "objectForKey:", v11);
      v13 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sessionKey = %@, object = %@", "__WiFiManagerDispatchNextAddNetworkAsyncRequest", v11, v12);
      objc_autoreleasePoolPop(v13);
      if (v12)
      {
        objc_msgSend(objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("timestamp")), "timeIntervalSinceNow");
        LODWORD(v12) = v14 > -21600.0;
      }
      objc_autoreleasePoolPop(v10);
    }
    else
    {
      LODWORD(v12) = 0;
    }
    if (objc_msgSend(v5, "bypassPrompt"))
    {
      v15 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Don't show popup as user has already given consent for this accessory network.", "__WiFiManagerDispatchNextAddNetworkAsyncRequest");
      objc_autoreleasePoolPop(v15);
      v16 = *(NSObject **)(qword_10026D680 + 32);
      block = _NSConcreteStackBlock;
      v33 = 3221225472;
      v34 = sub_1000B9F4C;
      v35 = &unk_10022EF88;
      v36 = 0;
      v37 = qword_10026D680;
      dispatch_async(v16, &block);
      goto LABEL_31;
    }
    v17 = objc_autoreleasePoolPush();
    if ((_DWORD)v12)
    {
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Don't show popup as user has already given consent for this session based network.", "__WiFiManagerDispatchNextAddNetworkAsyncRequest");
      objc_autoreleasePoolPop(v17);
      block = (void **)a1;
      v33 = 0xAAAAAAAA00000045;
      v34 = (void (*)(uint64_t))objc_msgSend(v5, "network");
      v35 = 0;
      sub_1000B9DBC((_QWORD *)a1, objc_msgSend(v5, "network"));
      goto LABEL_30;
    }
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Show user consent popup", "__WiFiManagerDispatchNextAddNetworkAsyncRequest");
    objc_autoreleasePoolPop(v17);
    v18 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, &error, (CFDictionaryRef)objc_msgSend(v5, "alertDictionary"));
    if (v18)
    {
      v19 = v18;
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v18, (CFUserNotificationCallBack)sub_1000B9D60, 0);
      if (RunLoopSource)
      {
        v21 = RunLoopSource;
        *(_QWORD *)(a1 + 1640) = RunLoopSource;
        *(_QWORD *)(a1 + 1648) = v19;
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, v21, kCFRunLoopDefaultMode);
        goto LABEL_31;
      }
      CFRelease(v19);
    }
    goto LABEL_47;
  }
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Add network request is in progress, cancelling dispatch");
  objc_autoreleasePoolPop(v23);
LABEL_31:
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_100098DB4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_100098DBC(uint64_t a1, void *a2, const void *a3)
{
  void *v6;
  _BOOL4 v7;
  const void *v8;
  void *v9;
  void *v10;
  const void *v11;
  const char *v12;
  const void *v13;
  void *v14;
  void *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  void *v18;
  _BOOL4 v19;
  CFIndex Count;
  CFIndex v21;
  CFIndex v22;
  const void *v23;
  uint64_t v24;
  const void *v25;
  const void *v26;
  void *v27;
  const void *v28;
  int v29;
  const __SCPreferences *v30;
  const __SCPreferences *v31;
  const __CFArray *v32;
  const __CFArray *v33;
  const void *v34;
  void *v35;
  void *v36;
  void *v37;
  const void *v38;
  CFIndex v39;
  _BOOL4 v40;
  const char *v41;
  _BOOL4 v42;
  const void *v43;
  const void *v44;
  const __CFString *v45;
  void *v46;
  const __CFDictionary *v47;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v49;
  const void *v50;
  const void *Value;
  const void *v52;
  const __CFArray *v53;
  const __CFArray *v54;
  CFIndex v55;
  void *v56;
  CFIndex i;
  const __SCNetworkSet *v58;
  const __SCNetworkSet *v59;
  CFStringRef Name;
  CFStringRef SetID;
  CFIndex v62;
  const __SCNetworkSet *v63;
  CFStringRef v64;
  unsigned int v65;
  int v66;
  void *v67;
  const __CFDictionary *v68;
  void *v69;
  const __CFArray *v70;
  const __CFArray *v71;
  const void *ValueAtIndex;
  CFDictionaryRef v73;
  uint64_t v74;
  _BOOL4 v75;
  CFAbsoluteTime Current;
  CFDateRef v77;
  void *v78;
  __CFArray *v79;
  int v80;
  void *v81;
  const __SCPreferences *v82;
  uint64_t v83;
  void *v84;
  const __SCPreferences *v85;
  const void *v86;
  const __SCPreferences *v87;
  void *v88;
  void *v90;
  CFStringRef v91;
  void *v92;
  void *v93;
  CFStringRef v94;
  void *v95;
  CFIndex j;
  const __SCNetworkSet *v97;
  CFStringRef v98;
  const __SCNetworkSet *v99;
  CFStringRef v100;
  CFStringRef v101;
  int v102;
  int v103;
  int v104;
  void *v105;
  unsigned int v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  const char *v115;
  __CFArray *Mutable;
  CFIndex v117;
  void *v118;
  _BOOL4 v119;
  void *v120;
  const void *v121;
  const void *v122;
  void *v123;
  const __SCPreferences *prefs;
  const __CFArray *v125;
  int v126;
  CFTypeRef cf2;
  __CFArray *cf;
  _QWORD v129[6];
  _QWORD block[5];
  CFIndex v131;
  uint64_t context;
  uint64_t *p_context;
  uint64_t v134;
  uint64_t v135;

  v6 = objc_autoreleasePoolPush();
  v131 = -1;
  if (!a1)
  {
    v108 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerRemoveNetwork");
    goto LABEL_191;
  }
  if (!a2)
  {
    v108 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerRemoveNetwork");
LABEL_191:
    objc_autoreleasePoolPop(v108);
    goto LABEL_192;
  }
  v7 = sub_10002DA5C((_BOOL8)a2);
  v8 = sub_10002BE64((uint64_t)a2, CFSTR("DomainName"));
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v11 = a3;
    if (v7)
      v12 = "domain";
    else
      v12 = "SSID";
    v13 = v8;
    if (!v7)
      v13 = sub_10002B088(a2);
    v115 = v12;
    a3 = v11;
    objc_msgSend(v10, "WFLog:message:", 3, "%s: reason %d, with %s %@", "WiFiManagerRemoveNetwork", v11, v115, v13);
  }
  objc_autoreleasePoolPop(v9);
  if (sub_1000CA608((uint64_t)a2) == 2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Carplay network + UserConfigured", "WiFiManagerRemoveNetwork");
    objc_autoreleasePoolPop(v14);
    if ((_DWORD)a3 == 2)
    {
      sub_10002C478((uint64_t)a2, CFSTR("lastJoined"), 0);
      v69 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removed kWiFiPreferenceLastJoinedKey", "WiFiManagerRemoveNetwork");
      objc_autoreleasePoolPop(v69);
      v70 = (const __CFArray *)sub_10008674C(a1);
      if (v70)
      {
        v71 = v70;
        sub_1000953B8(1, v70, a2, &v131, 0);
        if (v131 != -1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v71, v131);
          if (ValueAtIndex)
            sub_10002C478((uint64_t)ValueAtIndex, CFSTR("lastJoined"), 0);
        }
      }
    }
    else
    {
      if ((_DWORD)a3 == 7)
      {
        sub_1000CA74C((uint64_t)a2);
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removed CarPlay settings", "WiFiManagerRemoveNetwork", v113);
      }
      else
      {
        v15 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unexpected reason %d", "WiFiManagerRemoveNetwork", a3);
      }
      objc_autoreleasePoolPop(v15);
    }
    v73 = sub_1000173C0((uint64_t)a2);
    if (v73)
      CFRelease(v73);
    v74 = sub_100099EA4(a1, a2, 0);
    goto LABEL_144;
  }
  v126 = (int)a3;
  if (sub_1000CA608((uint64_t)a2) != 1)
    goto LABEL_28;
  v16 = sub_10000B29C((CFArrayRef)a1);
  if (!v16)
  {
    v111 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "__WiFiManagerRemoveCarPlay");
    objc_autoreleasePoolPop(v111);
    goto LABEL_28;
  }
  v17 = v16;
  v121 = v8;
  v18 = v6;
  v19 = v7;
  Count = CFArrayGetCount(v16);
  if (Count < 1)
    goto LABEL_27;
  v21 = Count;
  v22 = 0;
  while (1)
  {
    v23 = CFArrayGetValueAtIndex(v17, v22);
    v24 = sub_1000161D4((uint64_t)v23);
    if (!v24)
      goto LABEL_26;
    v25 = (const void *)sub_100029860(v24);
    if (!v25)
      goto LABEL_26;
    v26 = v25;
    v27 = sub_1000169FC((uint64_t)v23, v25);
    if (!v27)
      goto LABEL_26;
    v28 = v27;
    if (CFEqual(a2, v27))
      break;
    CFRelease(v28);
LABEL_26:
    if (v21 == ++v22)
      goto LABEL_27;
  }
  v90 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Current network is CarPlay. Disconnect\n", "__WiFiManagerRemoveCarPlay");
  objc_autoreleasePoolPop(v90);
  sub_1000F7F48((uint64_t)v23, v26, 7, "__WiFiManagerRemoveCarPlay", 16900);
  CFRelease(v28);
LABEL_27:
  CFRelease(v17);
  LODWORD(a3) = v126;
  v7 = v19;
  v6 = v18;
  v8 = v121;
LABEL_28:
  v29 = sub_10001395C((uint64_t)a2);
  if ((_DWORD)a3 == 2 && v29)
    sub_10002C478((uint64_t)a2, CFSTR("AutoHotspotDisableWiFiAutoJoinUntilUserJoin"), kCFBooleanTrue);
  v30 = (const __SCPreferences *)sub_10001D964((_QWORD *)a1, CFSTR("List of known networks"));
  v31 = v30;
  if (!v30)
  {
LABEL_130:
    v74 = 0;
    goto LABEL_140;
  }
  if (!sub_100007620(v30))
  {
LABEL_192:
    v74 = 0;
    goto LABEL_139;
  }
  v123 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerRemoveNetwork");
  v32 = (const __CFArray *)sub_10008674C(a1);
  prefs = v31;
  if (!v32)
    goto LABEL_193;
  v33 = v32;
  if ((_DWORD)a3 == 4)
  {
    sub_10009A914(v32, a2, &v131);
    v34 = sub_10002B088(a2);
    context = a1;
    p_context = (uint64_t *)0xAAAAAAAA00000051;
    v134 = (uint64_t)v34;
    v135 = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
  }
  else
  {
    sub_1000953B8(1, v32, a2, &v131, 0);
  }
  v35 = objc_autoreleasePoolPush();
  v36 = (void *)qword_10026DD20;
  v125 = v33;
  if (qword_10026DD20)
  {
    v37 = v6;
    v38 = v8;
    v39 = v131;
    v40 = v7;
    if (v7)
      v41 = "domain ";
    else
      v41 = "";
    a3 = v38;
    v42 = v40;
    if (!v40)
      v38 = sub_10002B088(a2);
    objc_msgSend(v36, "WFLog:message:", 3, "%s:existingIndex %ld of %s%@", "WiFiManagerRemoveNetwork", v39, v41, v38);
    v7 = v42;
    v6 = v37;
    v8 = a3;
    LODWORD(a3) = v126;
  }
  objc_autoreleasePoolPop(v35);
  if (v131 == -1)
  {
LABEL_193:
    v80 = 0;
    v31 = 0;
  }
  else
  {
    v43 = CFArrayGetValueAtIndex(v33, v131);
    v44 = v43;
    if ((_DWORD)a3 != 4
      || sub_10002DAB4((uint64_t)v43)
      || sub_1000C3B8C((_BOOL8)v44)
      || sub_10003145C((uint64_t)v44)
      || sub_10002DAF0((_BOOL8)v44)
      || sub_1000C433C((const __CFDictionary *)v44))
    {
      sub_100058DC8((_QWORD *)a1, (int)a3, v44);
      v45 = sub_10003149C(a2);
      sub_10009AA18(v45);
      context = a1;
      p_context = (uint64_t *)0xAAAAAAAA00000052;
      v134 = (uint64_t)a2;
      v135 = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
      cf = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      v46 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "__WiFiManagerRemoveNetworkSetting", sub_10002B088(a2));
      objc_autoreleasePoolPop(v46);
      v47 = *(const __CFDictionary **)(a1 + 208);
      if (v47)
      {
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v47);
        if (MutableCopy)
        {
          v49 = MutableCopy;
          v50 = sub_10002B088(a2);
          Value = CFDictionaryGetValue(v49, v50);
          if (Value)
          {
            cf2 = Value;
            CFRetain(Value);
            v52 = sub_10002B088(a2);
            CFDictionaryRemoveValue(v49, v52);
            -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v49, CFSTR("Custom network settings"));
            if (sub_100007620(*(const __SCPreferences **)(a1 + 1064)))
            {
              v120 = (void *)sub_10001E1C8((uint64_t)"__WiFiManagerRemoveNetworkSetting");
              v53 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 1064));
              if (v53)
              {
                v54 = v53;
                v119 = v7;
                v55 = CFArrayGetCount(v53);
                v56 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: remove set ID %@, total sets %ld", "__WiFiManagerRemoveNetworkSetting", cf2, v55);
                objc_autoreleasePoolPop(v56);
                if (v55 < 1)
                {
LABEL_73:
                  v65 = 0;
                }
                else
                {
                  v122 = v8;
                  v118 = v6;
                  for (i = 0; i != v55; ++i)
                  {
                    v58 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v54, i);
                    if (v58)
                    {
                      if ((v59 = v58, Name = SCNetworkSetGetName(v58), SetID = SCNetworkSetGetSetID(v59), Name)
                        && CFEqual(Name, CFSTR("Automatic"))
                        || SetID && CFDictionaryContainsValue(v49, SetID))
                      {
                        sub_1000A2FD0(cf, v59);
                      }
                    }
                  }
                  v62 = 0;
                  v6 = v118;
                  v8 = v122;
                  while (1)
                  {
                    v63 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v54, v62);
                    if (SCNetworkSetGetSetID(v63))
                    {
                      v64 = SCNetworkSetGetSetID(v63);
                      if (CFEqual(v64, cf2))
                        break;
                    }
                    if (v55 == ++v62)
                      goto LABEL_73;
                  }
                  if (SCNetworkSetGetName(v63))
                  {
                    v91 = SCNetworkSetGetName(v63);
                    if (CFEqual(v91, CFSTR("Automatic")))
                    {
                      v92 = objc_autoreleasePoolPush();
                      if (qword_10026DD20)
                        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: skipping automatic set from removal! automatic/custom network set ID: %@", "__WiFiManagerRemoveNetworkSetting", cf2);
                      objc_autoreleasePoolPop(v92);
                      goto LABEL_73;
                    }
                  }
                  sub_1000BAB18(v63, cf);
                  v65 = SCNetworkSetRemove(v63);
                  v93 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set removal status %d", "__WiFiManagerRemoveNetworkSetting", v65);
                  objc_autoreleasePoolPop(v93);
                  if (!v65)
                  {
                    v117 = CFArrayGetCount(v54);
                    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                    if (v63)
                    {
                      if (SCNetworkSetGetName(v63))
                      {
                        v94 = SCNetworkSetGetName(v63);
                        if (CFEqual(v94, CFSTR("Automatic")))
                        {
                          v95 = objc_autoreleasePoolPush();
                          v65 = qword_10026DD20;
                          if (qword_10026DD20)
                          {
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: aborting request to remove automatic network set! ID: %@", "__WiFiManagerRemoveCurrentNetworkSet", SCNetworkSetGetSetID(v63));
                            v65 = 0;
                          }
                          goto LABEL_185;
                        }
                      }
                    }
                    if (v117 >= 1)
                    {
                      for (j = 0; v117 != j; ++j)
                      {
                        v97 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v54, j);
                        v98 = SCNetworkSetGetName(v97);
                        v99 = v97;
                        v100 = SCNetworkSetGetSetID(v97);
                        v101 = v100;
                        if (v98)
                        {
                          v102 = CFEqual(CFSTR("Automatic"), v98);
                          v103 = v102;
                          if (!v101)
                          {
                            if (!v102)
                              continue;
LABEL_175:
                            v106 = SCNetworkSetSetCurrent(v99);
                            v107 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: SCNetworkSetSetCurrent(Automatic) %d", "__WiFiManagerRemoveCurrentNetworkSet", v106, v114);
LABEL_180:
                            objc_autoreleasePoolPop(v107);
                            sub_1000A2FD0(Mutable, v99);
                            continue;
                          }
                          v104 = CFDictionaryContainsValue(v49, v101);
                          if (v103 && v104)
                          {
                            v105 = objc_autoreleasePoolPush();
                            if (qword_10026DD20)
                              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: network set %@ (%@) is in both automatic and custom network sets!!.", "__WiFiManagerRemoveCurrentNetworkSet", v101, v98);
                            objc_autoreleasePoolPop(v105);
                            goto LABEL_175;
                          }
                          if (v103)
                            goto LABEL_175;
                        }
                        else
                        {
                          if (!v100)
                            continue;
                          v104 = CFDictionaryContainsValue(v49, v100);
                        }
                        if (v104)
                        {
                          v107 = objc_autoreleasePoolPush();
                          if (qword_10026DD20)
                            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Excluding services from set id %@ (%@)", "__WiFiManagerRemoveCurrentNetworkSet", v101, v98);
                          goto LABEL_180;
                        }
                      }
                    }
                    sub_1000BAB18(v63, Mutable);
                    v65 = SCNetworkSetRemove(v63);
                    v95 = objc_autoreleasePoolPush();
                    if (qword_10026DD20)
                      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: set removal status %d", "__WiFiManagerRemoveCurrentNetworkSet", v65);
                    v6 = v118;
                    v8 = v122;
LABEL_185:
                    objc_autoreleasePoolPop(v95);
                    if (Mutable)
                      CFRelease(Mutable);
                  }
                }
                CFRelease(v54);
                v66 = v126;
                v7 = v119;
              }
              else
              {
                v65 = 0;
                v66 = v126;
              }
              v33 = v125;
              sub_1000076D4(*(SCPreferencesRef *)(a1 + 1064), v65);

              LODWORD(a3) = v66;
            }
            else
            {
              v110 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get sc prefs lock", "__WiFiManagerRemoveNetworkSetting");
              objc_autoreleasePoolPop(v110);
            }
            CFRelease(v49);
            v68 = (const __CFDictionary *)cf2;
          }
          else
          {
            v67 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: not a custom network", "__WiFiManagerRemoveNetworkSetting");
            objc_autoreleasePoolPop(v67);
            v68 = v49;
          }
          CFRelease(v68);
        }
      }
      else
      {
        v109 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null wifi network sets", "__WiFiManagerRemoveNetworkSetting");
        objc_autoreleasePoolPop(v109);
      }
      if (cf)
        CFRelease(cf);
      if (!sub_100007F24((uint64_t)a2))
      {
        if ((_DWORD)a3 == 24 || (v75 = sub_1000CB480((uint64_t)a2), (_DWORD)a3 == 22) && v75)
        {
          Current = CFAbsoluteTimeGetCurrent();
          v77 = CFDateCreate(kCFAllocatorDefault, Current);
          sub_10002C478((uint64_t)a2, CFSTR("removedAt"), v77);
          v78 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: removing carrier-based auto-join disabled network %@ at %@", "WiFiManagerRemoveNetwork", sub_10002B088(a2), v77);
          objc_autoreleasePoolPop(v78);
          v79 = *(__CFArray **)(a1 + 2512);
          if (v79
            || (v79 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks),
                (*(_QWORD *)(a1 + 2512) = v79) != 0))
          {
            CFArrayAppendValue(v79, a2);
            if (CFArrayGetCount(*(CFArrayRef *)(a1 + 2512)) >= 11)
              CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 2512), 0);
          }
          if (v77)
            CFRelease(v77);
        }
      }
      CFArrayRemoveValueAtIndex(v33, v131);
      v80 = sub_100095610(a1, v33);
      sub_100007FDC(a1, 1, 1, 1);
      sub_100094200(a1, (CFDictionaryRef *)a2, 1);
      if (v80)
      {
        v31 = (const __SCPreferences *)sub_10002B088(a2);
        CFRetain(v31);
        v81 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
        {
          if (v7)
            v82 = (const __SCPreferences *)v8;
          else
            v82 = v31;
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Removed %@ from list of known networks", v82);
        }
        objc_autoreleasePoolPop(v81);
      }
      else
      {
        v31 = 0;
      }
      sub_10009AB1C((_QWORD *)a1, v31, 1, 0, 0);
      if (sub_1000C5408((uint64_t)a2))
      {
        context = 0;
        p_context = &context;
        v134 = 0x2020000000;
        v135 = (uint64_t)a2;
        CFRetain(a2);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10009AE5C;
        block[3] = &unk_100230858;
        block[4] = &context;
        dispatch_async((dispatch_queue_t)qword_10026DD40, block);
        _Block_object_dispose(&context, 8);
      }
    }
    else
    {
      v112 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Remove network event from iCloud ignored because this is an open network (%@)", "WiFiManagerRemoveNetwork", sub_10002B088(a2));
      objc_autoreleasePoolPop(v112);
      v80 = 0;
      v31 = 0;
    }
  }
  sub_1000076D4(prefs, v80);

  if (!v80)
    goto LABEL_130;
  sub_10008488C(v83, 2, a1);
  v84 = objc_autoreleasePoolPush();
  if (v126 == 2)
  {
    if (qword_10026DD20)
    {
      if (v7)
        v85 = (const __SCPreferences *)v8;
      else
        v85 = v31;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: sync the removal of <%@>", "WiFiManagerRemoveNetwork", v85);
    }
    objc_autoreleasePoolPop(v84);
    if (&_WiFiCloudSyncEngineCreate)
    {
      v86 = *(const void **)(a1 + 1304);
      if (v86)
      {
        CFRetain(v86);
        CFRetain(a2);
        v129[0] = _NSConcreteStackBlock;
        v129[1] = 3221225472;
        v129[2] = sub_10009AEFC;
        v129[3] = &unk_10022EF88;
        v129[4] = a1;
        v129[5] = a2;
        dispatch_async((dispatch_queue_t)qword_10026DD48, v129);
      }
    }
    sub_100176B68(*(void **)(a1 + 1432), (uint64_t)a2, 1);
    if (!v31)
      goto LABEL_138;
  }
  else
  {
    if (qword_10026DD20)
    {
      if (v7)
        v87 = (const __SCPreferences *)v8;
      else
        v87 = v31;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: <%@> removed due to sync", "WiFiManagerRemoveNetwork", v87);
    }
    objc_autoreleasePoolPop(v84);
    if (!v31)
      goto LABEL_138;
  }
  CFRelease(v31);
LABEL_138:
  v74 = 1;
  sub_1000967B4(a1, a2, 1u);
LABEL_139:
  v31 = 0;
LABEL_140:
  if (!sub_100096B7C(a1, a2, CFSTR("PresentInKnownNetworks"), kCFBooleanFalse))
  {
    v88 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s:Unable to update known network property in private mac network record for <%@>", "WiFiManagerRemoveNetwork", v31);
    objc_autoreleasePoolPop(v88);
  }
LABEL_144:
  objc_autoreleasePoolPop(v6);
  return v74;
}

void sub_100099E8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100099EA4(uint64_t a1, void *a2, unsigned int a3)
{
  void *v6;
  const __SCPreferences *v7;
  const __SCPreferences *v8;
  void *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v13;
  int v14;
  int v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  unsigned int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  unsigned int v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  _BOOL4 v29;
  const __CFDate *v30;
  const __CFDate *v31;
  __CFDictionary *Mutable;
  const void *v33;
  unsigned int v34;
  const void *v35;
  const void *v36;
  CFIndex v37;
  _BOOL4 v38;
  _BOOL4 v39;
  _BOOL8 v40;
  CFDictionaryRef *v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  const void *v46;
  NSObject *v47;
  _QWORD *v48;
  uint64_t v49;
  const void *v50;
  void *v51;
  uint64_t v52;
  const void *v54;
  const void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  _BOOL4 v64;
  _BOOL4 v65;
  unsigned int v66;
  void *v67;
  uint64_t v68;
  _QWORD block[6];
  _QWORD v70[6];
  _QWORD context[4];
  CFIndex v72;
  CFIndex v73[2];

  v72 = 0;
  v73[0] = -1;
  if (!a1)
  {
    v57 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerUpdateNetwork");
    goto LABEL_126;
  }
  v6 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerUpdateNetwork");
    v58 = v6;
    goto LABEL_127;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: merge %d, %@", "WiFiManagerUpdateNetwork", a3, a2);
  objc_autoreleasePoolPop(v6);
  sub_100095360(a2);
  v7 = (const __SCPreferences *)sub_10001D964((_QWORD *)a1, CFSTR("List of known networks"));
  if (!v7)
    return 0;
  v8 = v7;
  if (!sub_100007620(v7))
  {
    v57 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get prefs lock", "WiFiManagerUpdateNetwork");
LABEL_126:
    v58 = v57;
LABEL_127:
    objc_autoreleasePoolPop(v58);
    return 0;
  }
  v9 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerUpdateNetwork");
  v10 = (const __CFArray *)sub_10008674C(a1);
  if (!v10)
  {
    v59 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null networks", "WiFiManagerUpdateNetwork", v60);
    goto LABEL_135;
  }
  v11 = v10;
  sub_1000953B8(*(_DWORD *)(a1 + 304), v10, a2, v73, &v72);
  if (v73[0] == -1)
  {
    v59 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ does not  exist", "WiFiManagerUpdateNetwork", sub_10002B088(a2));
    goto LABEL_135;
  }
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v73[0]);
  if (!ValueAtIndex)
  {
    v59 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null existingNetwork", "WiFiManagerUpdateNetwork", v60);
LABEL_135:
    objc_autoreleasePoolPop(v59);
    v38 = 0;
    v68 = 0;
    v34 = 0;
    v62 = 0;
    v63 = 0;
    v40 = 0;
    v41 = 0;
    v66 = 0;
    v42 = 0;
    goto LABEL_74;
  }
  v13 = ValueAtIndex;
  v14 = sub_100031670(ValueAtIndex);
  if (sub_1000C4820((uint64_t)a2))
  {
    v15 = sub_1000C4820((uint64_t)v13);
    if (v15 == sub_1000C4820((uint64_t)a2))
    {
      v16 = sub_1000C47AC((uint64_t)v13);
      v17 = v16 != sub_1000C47AC((uint64_t)a2);
    }
    else
    {
      v17 = 1;
    }
  }
  else
  {
    v17 = 0;
  }
  if (sub_10002DAB4((uint64_t)v13))
  {
    v65 = 0;
  }
  else
  {
    v18 = sub_10003145C((uint64_t)v13)
       || sub_1000C3B8C((_BOOL8)v13)
       || sub_1000C433C(v13) != 0;
    v65 = v18;
  }
  v61 = v14;
  v64 = !sub_10002DAB4((uint64_t)a2)
     && !sub_1000C3B8C((_BOOL8)a2)
     && !sub_10003145C((uint64_t)a2)
     && !sub_10002DAF0((_BOOL8)a2)
     && sub_1000C433C((const __CFDictionary *)a2) == 0;
  v19 = a3;
  if (sub_1000C433C(v13))
    v20 = sub_10003145C((uint64_t)v13) == 0;
  else
    v20 = 0;
  if (sub_1000C433C((const __CFDictionary *)a2) && !sub_1000C5104((uint64_t)a2))
  {
    sub_10002C478((uint64_t)a2, CFSTR("WPA_IE"), 0);
    sub_10002C478((uint64_t)v13, CFSTR("WPA_IE"), 0);
  }
  LODWORD(v68) = v17;
  if (v17 && sub_1000C4820((uint64_t)a2) != 2 && !sub_100007F24((uint64_t)a2))
  {
    v54 = sub_10002BE64((uint64_t)a2, CFSTR("networkDisabledReason"));
    v55 = sub_10002BE64((uint64_t)a2, CFSTR("networkDisabledClientName"));
    if (v55)
    {
      if (v54 && CFEqual(v55, CFSTR("configd")))
      {
        v56 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Enabling auto-join for network %@ since captive status changed and was disabled by configd", "WiFiManagerUpdateNetwork", sub_10002B088(a2));
        objc_autoreleasePoolPop(v56);
        sub_1000C6770((uint64_t)a2, 1);
      }
    }
  }
  v67 = v9;
  if (sub_1000C433C((const __CFDictionary *)a2))
    v21 = sub_10003145C((uint64_t)a2) == 0;
  else
    v21 = 0;
  if (sub_100008280((uint64_t)a2))
  {
    v22 = sub_100008280((uint64_t)v13);
    LODWORD(v62) = v22 != sub_100008280((uint64_t)a2);
  }
  else
  {
    LODWORD(v62) = 0;
  }
  v23 = sub_10002BE64((uint64_t)v13, CFSTR("addedAt"));
  v24 = sub_10002BE64((uint64_t)a2, CFSTR("addedAt"));
  if (!v23 && v24 || !v24 && v23)
  {
LABEL_45:
    LODWORD(v63) = 1;
    goto LABEL_46;
  }
  LODWORD(v63) = 0;
  if (v23 && v24)
  {
    if (CFEqual(v23, v24))
    {
      LODWORD(v63) = 0;
      goto LABEL_46;
    }
    goto LABEL_45;
  }
LABEL_46:
  v25 = sub_10002BE64((uint64_t)v13, CFSTR("lastJoined"));
  v26 = sub_10002BE64((uint64_t)a2, CFSTR("lastJoined"));
  if (!v25 && v26 || !v26 && v25)
    goto LABEL_50;
  HIDWORD(v62) = 0;
  if (!v25 || !v26)
    goto LABEL_51;
  if (CFEqual(v25, v26))
    HIDWORD(v62) = 0;
  else
LABEL_50:
    HIDWORD(v62) = 1;
LABEL_51:
  v27 = sub_10002BE64((uint64_t)v13, CFSTR("lastAutoJoined"));
  v28 = sub_10002BE64((uint64_t)a2, CFSTR("lastAutoJoined"));
  if (!v27 && v28 || !v28 && v27)
  {
LABEL_55:
    HIDWORD(v68) = 1;
    goto LABEL_56;
  }
  HIDWORD(v68) = 0;
  if (v27 && v28)
  {
    if (CFEqual(v27, v28))
    {
      HIDWORD(v68) = 0;
      goto LABEL_56;
    }
    goto LABEL_55;
  }
LABEL_56:
  v29 = sub_1000081D8((uint64_t)a2);
  HIDWORD(v63) = v29 != sub_1000081D8((uint64_t)v13);
  v30 = (const __CFDate *)sub_1000CAC40((uint64_t)v13);
  v31 = (const __CFDate *)sub_1000CAC40((uint64_t)a2);
  if (v31 && (!v30 || CFDateCompare(v30, v31, 0) == kCFCompareLessThan))
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v33 = sub_10002BE64((uint64_t)a2, CFSTR("NetworkQualityResponsiveness"));
    CFDictionaryAddValue(Mutable, CFSTR("networkQualityResponsiveness"), v33);
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000081;
    context[2] = Mutable;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    if (Mutable)
      CFRelease(Mutable);
  }
  v34 = v65 && v64;
  v66 = v20 ^ v21;
  if (v19)
  {
    sub_10002B290((uint64_t)v13, (uint64_t)a2);
    v9 = v67;
    if (sub_1000C69C8((uint64_t)a2) && sub_1000CB504((uint64_t)v13) && !sub_1000CB504((uint64_t)a2))
      sub_1000C682C((uint64_t)v13, 0);
    v35 = sub_10002BE64((uint64_t)v13, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"));
    v36 = sub_10002BE64((uint64_t)a2, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"));
    if (v35 && !v36)
      sub_10002C478((uint64_t)v13, CFSTR("WiFiNetworkUserAcceptedRecommendationAt"), 0);
    CFRetain(v13);
    CFArrayRemoveValueAtIndex(v11, v73[0]);
    v37 = v72;
    if (*(_DWORD *)(a1 + 304) == 4)
      v37 = --v72;
    CFArrayInsertValueAtIndex(v11, v37, v13);
    v38 = v61 != sub_100031670(v13);
    v39 = sub_100007F24((uint64_t)v13);
    v40 = v39 != sub_100007F24((uint64_t)a2);
    v41 = (CFDictionaryRef *)sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)v13);
    CFRelease(v13);
  }
  else
  {
    CFArrayRemoveValueAtIndex(v11, v73[0]);
    CFArrayInsertValueAtIndex(v11, v73[0], a2);
    v41 = (CFDictionaryRef *)sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)a2);
    v38 = 0;
    v40 = 0;
    v9 = v67;
  }
  v42 = sub_100095610(a1, v11);
  sub_100094200(a1, v41, 0);
LABEL_74:
  sub_1000076D4(v8, v42);

  if (!v42)
  {
    v49 = 0;
    if (!v41)
      return v49;
    goto LABEL_109;
  }
  if (v34)
  {
    v43 = v62;
    v44 = HIDWORD(v62);
    v45 = v63;
    if (&_WiFiCloudSyncEngineCreate)
    {
      v46 = *(const void **)(a1 + 1304);
      if (v46)
      {
        if (v41)
        {
          CFRetain(v46);
          CFRetain(v41);
          v47 = qword_10026DD48;
          v70[0] = _NSConcreteStackBlock;
          v70[1] = 3221225472;
          v70[2] = sub_10009B550;
          v70[3] = &unk_10022EF88;
          v70[4] = a1;
          v70[5] = v41;
          v48 = v70;
LABEL_98:
          dispatch_async(v47, v48);
        }
      }
    }
  }
  else
  {
    v43 = v62;
    v44 = HIDWORD(v62);
    v45 = v63;
    if (&_WiFiCloudSyncEngineCreate)
    {
      v50 = *(const void **)(a1 + 1304);
      if (v50)
      {
        if (v41)
        {
          CFRetain(v50);
          CFRetain(v41);
          v47 = qword_10026DD48;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_10009B588;
          block[3] = &unk_10022EF88;
          block[4] = a1;
          block[5] = v41;
          v48 = block;
          goto LABEL_98;
        }
      }
    }
  }
  v51 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: hiddenChanged=%d captiveChanged=%d pskToOpen=%d didLowDataModeChanged=%d didWpa3Change=%d addedAtChanged=%d userJoinedAtChanged=%d autoJoinedAtChanged=%d, didPrivacyProxyPreferenceChange=%d autoJoinChanged=%d", "WiFiManagerUpdateNetwork", v38, v68, v34, v43, v66, v45, v44, HIDWORD(v68), HIDWORD(v63), v40);
  objc_autoreleasePoolPop(v51);
  if (v38 || (_DWORD)v68 || v34 || v43 || HIDWORD(v68) | v44 | v45 | v66 || HIDWORD(v63))
    sub_100176B68(*(void **)(a1 + 1432), (uint64_t)a2, 2);
  v52 = sub_100085F68(a1);
  sub_10008488C(v52, 2, a1);
  sub_1000967B4(a1, v41, 2u);
  v49 = 1;
  if (v41)
LABEL_109:
    CFRelease(v41);
  return v49;
}

void sub_10009A914(CFArrayRef theArray, const void *a2, CFIndex *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  void *v10;

  if (a3)
  {
    *a3 = -1;
    if (theArray)
    {
      Count = CFArrayGetCount(theArray);
      if (Count)
      {
        v7 = Count;
        if (Count < 1)
        {
          v8 = 0;
        }
        else
        {
          v8 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
            if (sub_1000C6060((uint64_t)a2, (uint64_t)ValueAtIndex))
              break;
            if (v7 == ++v8)
              goto LABEL_12;
          }
          *a3 = v8;
        }
        if (v8 == v7)
        {
LABEL_12:
          v10 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network %@ not found", "__GetNetworkIndicesMatchingSSIDOnly", sub_10002B088(a2));
          objc_autoreleasePoolPop(v10);
        }
      }
    }
  }
}

void sub_10009AA18(const void *a1)
{
  CFTypeRef v1;
  NSObject *global_queue;
  void *v3;
  _QWORD block[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  if (&_CNForgetSSID)
  {
    if (a1)
    {
      v1 = CFRetain(a1);
      v6[3] = (uint64_t)v1;
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000BA2C8;
      block[3] = &unk_100230858;
      block[4] = &v5;
      dispatch_async(global_queue, block);
    }
    else
    {
      v3 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null ssidDataRef.", "__AsyncCNForgetSSID");
      objc_autoreleasePoolPop(v3);
    }
  }
  _Block_object_dispose(&v5, 8);
}

void sub_10009AB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009AB1C(_QWORD *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFIndex Count;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v14;
  const __CFDictionary *Value;
  __CFDictionary *Mutable;
  CFAbsoluteTime Current;
  CFDateRef v18;
  NSNumber *v19;
  void *v20;

  if (!a1)
    return;
  v9 = objc_autoreleasePoolPush();
  if (a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: blacklisting ssid: %@", "WiFiManagerAddNetworkNameToUserNotificationBlacklist", a2);
    objc_autoreleasePoolPop(v9);
    v10 = sub_1000A6EF8(a1, 0);
    v11 = v10;
    if (v10)
    {
      Count = CFDictionaryGetCount(v10);
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count + 1, v11);
    }
    else
    {
      MutableCopy = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    v14 = MutableCopy;
    if (CFDictionaryContainsKey(MutableCopy, a2))
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v14, a2);
      Mutable = CFDictionaryCreateMutableCopy(0, 0, Value);
      if (CFDictionaryContainsKey(Mutable, CFSTR("timestamp")))
        CFDictionaryRemoveValue(Mutable, CFSTR("timestamp"));
    }
    else
    {
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    Current = CFAbsoluteTimeGetCurrent();
    v18 = CFDateCreate(kCFAllocatorDefault, Current);
    if (v18)
    {
      CFDictionarySetValue(Mutable, CFSTR("timestamp"), v18);
      CFDictionarySetValue(Mutable, CFSTR("type"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a3));
      CFDictionarySetValue(Mutable, CFSTR("notificationType"), +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a5));
      if (CFDictionaryContainsKey(Mutable, CFSTR("count")))
        v19 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", (char *)objc_msgSend(-[__CFDictionary objectForKey:](Mutable, "objectForKey:", CFSTR("count")), "integerValue")+ 1);
      else
        v19 = (NSNumber *)&off_100252D20;
      CFDictionarySetValue(Mutable, CFSTR("count"), v19);
      CFDictionarySetValue(v14, a2, Mutable);
      -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v14, CFSTR("UserNotificationBlacklist"));
      sub_1000A371C((uint64_t)a1, v14);
      if (!Mutable)
        goto LABEL_18;
    }
    else
    {
      v20 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: timestamp is null", "WiFiManagerAddNetworkNameToUserNotificationBlacklist");
      objc_autoreleasePoolPop(v20);
      if (!Mutable)
        goto LABEL_18;
    }
    CFRelease(Mutable);
LABEL_18:
    if (v18)
      CFRelease(v18);
    if (v14)
      CFRelease(v14);
    if (v11)
      CFRelease(v11);
    return;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ssid is null", "WiFiManagerAddNetworkNameToUserNotificationBlacklist");
  objc_autoreleasePoolPop(v9);
}

void sub_10009AE5C(uint64_t a1)
{
  void *v2;
  void *v3;
  const void *v4;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: network is app based, removing access in DA", "WiFiManagerRemoveNetwork_block_invoke");
  objc_autoreleasePoolPop(v2);
  v3 = (void *)sub_1000CB154(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  sub_100038450(v3, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v4 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_10009AEFC(uint64_t a1)
{
  sub_100050A28(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), *(_QWORD *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_10009AF34(uint64_t a1, const __CFString *a2)
{
  void *v4;
  __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  void *ValueAtIndex;
  void *v11;
  void *v12;

  if (a1 && a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: bundleId %@", "WiFiManagerRemoveNetworksWithBundleIdentifier", a2);
    objc_autoreleasePoolPop(v4);
    v5 = sub_100090CB8(a1, a2);
    if (v5)
    {
      v6 = v5;
      Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        v8 = Count;
        for (i = 0; i != v8; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, i);
          if (ValueAtIndex)
          {
            v11 = ValueAtIndex;
            v12 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Network %@ is no longer app owned, removing...", sub_10002B088(v11));
            objc_autoreleasePoolPop(v12);
            sub_100098DBC(a1, v11, (const void *)9);
            sub_1000C65D8(v11);
          }
        }
      }
      CFRelease(v6);
    }
  }
}

uint64_t sub_10009B080(uint64_t a1, void *a2, int a3, char a4)
{
  uint64_t v7;
  void *v8;
  const char *v9;
  void *v10;
  const char *v11;
  _QWORD context[4];

  if ((a4 & 1) != 0)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000016;
    context[2] = a2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      if (a3)
        v11 = "Enabling";
      else
        v11 = "Disabling";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "Temporarily %s %@ from list of know networks", v11, sub_10002B088(a2));
    }
    objc_autoreleasePoolPop(v10);
    return 1;
  }
  else
  {
    sub_1000C68E8((CFMutableDictionaryRef *)a2, a3, CFSTR("SetNetworkState"));
    v7 = sub_100099EA4(a1, a2, 1u);
    if ((_DWORD)v7)
    {
      v8 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
      {
        if (a3)
          v9 = "Enabled";
        else
          v9 = "Disabled";
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s auto join for %@ (%@)", v9, sub_10002B088(a2), a2);
      }
      objc_autoreleasePoolPop(v8);
    }
    if (a3)
    {
      sub_100031928(a1, 1);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        sub_100007F68(a1, 5);
      else
        sub_100090860(a1, 2);
    }
  }
  return v7;
}

BOOL sub_10009B224(uint64_t a1, const void *a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFRange v9;

  v3 = *(const __CFArray **)(a1 + 216);
  if (!v3)
    return 0;
  Count = CFArrayGetCount(v3);
  if (!Count)
    return 0;
  v9.length = Count;
  v9.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 216), v9, a2);
  if (FirstIndexOfValue == -1)
    return 0;
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), FirstIndexOfValue);
  return sub_100007F24((uint64_t)ValueAtIndex);
}

uint64_t sub_10009B28C(uint64_t a1, const void *a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  const void *ValueAtIndex;
  CFRange v9;

  v3 = *(const __CFArray **)(a1 + 216);
  if (!v3)
    return 0;
  Count = CFArrayGetCount(v3);
  if (!Count)
    return 0;
  v9.length = Count;
  v9.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 216), v9, a2);
  if (FirstIndexOfValue == -1)
    return 0;
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 216), FirstIndexOfValue);
  return sub_1000CAEC8((uint64_t)ValueAtIndex);
}

uint64_t sub_10009B2F4(uint64_t a1, void *a2, const void *a3)
{
  const __CFArray *v6;
  const __CFArray *v7;
  const void *ValueAtIndex;
  void *v9;
  CFAbsoluteTime Current;
  CFDateRef v11;
  CFDateRef v12;
  void *v14;
  void *v15;
  void *v16;
  const void *v17;
  void *v18;
  CFIndex v19;
  CFIndex idx;

  v19 = 0;
  idx = -1;
  if (!a1)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties");
    goto LABEL_26;
  }
  if (!a2)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties");
    goto LABEL_26;
  }
  v6 = (const __CFArray *)sub_10008674C(a1);
  if (!v6)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null networks", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties");
    goto LABEL_26;
  }
  v7 = v6;
  sub_1000953B8(*(_DWORD *)(a1 + 304), v6, a2, &idx, &v19);
  if (idx == -1)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = sub_10002B088(a2);
      objc_msgSend(v16, "WFLog:message:", 3, "%s: %@ does not  exist", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties", v17, v19);
    }
    v18 = v15;
    goto LABEL_27;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v7, idx);
  if (!ValueAtIndex)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null existingNetwork", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties");
LABEL_26:
    v18 = v14;
LABEL_27:
    objc_autoreleasePoolPop(v18);
    return 0;
  }
  if (sub_100007F24((uint64_t)ValueAtIndex) && !sub_100007F24((uint64_t)a2))
  {
    v9 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Auto join disabled by %@", "WiFiManagerUpdateNetworkForAutoJoinDisablementProperties", a3, v19);
    objc_autoreleasePoolPop(v9);
    Current = CFAbsoluteTimeGetCurrent();
    v11 = CFDateCreate(kCFAllocatorDefault, Current);
    if (v11)
    {
      v12 = v11;
      sub_10002C478((uint64_t)a2, CFSTR("networkDisabledTimestamp"), v11);
      CFRelease(v12);
    }
    sub_10002C478((uint64_t)a2, CFSTR("networkDisabledClientName"), a3);
    sub_10002C478((uint64_t)a2, CFSTR("networkDisabledReason"), CFSTR("ByClient"));
  }
  return 1;
}

void sub_10009B550(uint64_t a1)
{
  sub_100050A28(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), *(_QWORD *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_10009B588(uint64_t a1)
{
  sub_100050940(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), *(_QWORD *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

uint64_t sub_10009B5C0(_QWORD *a1, const __CFString *a2, const void *a3, const void *a4)
{
  _WORD *v8;
  const void *v9;
  const __SCPreferences *v10;
  const __SCPreferences *v11;
  void *v12;
  const __CFArray *v13;
  const __CFArray *v14;
  void *v15;
  const void *ValueAtIndex;
  uint64_t v17;
  const __CFDictionary *v18;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v20;
  _WORD *v21;
  uint64_t v22;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  CFIndex idx;

  idx = -1;
  if (!a1)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerUpdateNetworksGuessingFailureCount");
    goto LABEL_32;
  }
  if (!a2)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null network", "WiFiManagerUpdateNetworksGuessingFailureCount");
    goto LABEL_32;
  }
  if (!a3)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null bssid", "WiFiManagerUpdateNetworksGuessingFailureCount");
    goto LABEL_32;
  }
  v8 = sub_1000C323C(a2);
  if (!v8)
  {
    v24 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null known5GhzNetwork", "WiFiManagerUpdateNetworksGuessingFailureCount");
LABEL_32:
    objc_autoreleasePoolPop(v24);
    return 0;
  }
  v9 = v8;
  v10 = (const __SCPreferences *)sub_10001D964(a1, CFSTR("List of known networks"));
  if (!v10)
  {
LABEL_36:
    CFRelease(v9);
    return 0;
  }
  v11 = v10;
  if (!sub_100007620(v10))
  {
    v25 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get prefs lock", "WiFiManagerUpdateNetworksGuessingFailureCount");
    objc_autoreleasePoolPop(v25);
    goto LABEL_36;
  }
  v12 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerUpdateNetworksGuessingFailureCount");
  v13 = (const __CFArray *)sub_10008674C((uint64_t)a1);
  if (v13)
  {
    v14 = v13;
    sub_10009A914(v13, v9, &idx);
    if (idx == -1)
    {
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@ does not  exist", "WiFiManagerUpdateNetworksGuessingFailureCount", a2);
    }
    else
    {
      v15 = v12;
      ValueAtIndex = CFArrayGetValueAtIndex(v14, idx);
      if (ValueAtIndex)
      {
        v17 = (uint64_t)ValueAtIndex;
        v18 = (const __CFDictionary *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("WiFiPreference2GhzGuessingAttemptsPerBSSID"));
        if (v18)
          MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v18);
        else
          MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v20 = MutableCopy;
        if (MutableCopy)
        {
          if (CFDictionaryContainsKey(MutableCopy, a3))
            CFDictionaryReplaceValue(v20, a3, a4);
          else
            CFDictionaryAddValue(v20, a3, a4);
          v21 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, v17);
          sub_10002C478((uint64_t)v21, CFSTR("WiFiPreference2GhzGuessingAttemptsPerBSSID"), v20);
          CFArrayRemoveValueAtIndex(v14, idx);
          CFArrayInsertValueAtIndex(v14, idx, v21);
          v22 = sub_100095610((uint64_t)a1, v14);
          sub_100094200((uint64_t)a1, (CFDictionaryRef *)v21, 0);
        }
        else
        {
          v27 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null guessingAttemptPerBssidDict", "WiFiManagerUpdateNetworksGuessingFailureCount");
          objc_autoreleasePoolPop(v27);
          v21 = 0;
          v22 = 0;
          v20 = 0;
        }
        v12 = v15;
        goto LABEL_19;
      }
      v26 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null existingNetwork", "WiFiManagerUpdateNetworksGuessingFailureCount", v28);
    }
    objc_autoreleasePoolPop(v26);
  }
  v21 = 0;
  v22 = 0;
  v20 = 0;
LABEL_19:
  sub_1000076D4(v11, v22);

  CFRelease(v9);
  if (v21)
    CFRelease(v21);
  if (v20)
    CFRelease(v20);
  return v22;
}

uint64_t sub_10009B9A4(uint64_t a1, void *a2, void *a3, const void *a4)
{
  const __CFArray *v8;
  const __CFArray *v9;
  const void *ValueAtIndex;
  _WORD *v11;
  void *v12;
  uint64_t v13;
  void *v15;
  void *v16;
  const char *v17;
  void *v18;
  CFIndex idx;
  CFIndex v20;

  idx = -1;
  v20 = -1;
  if (!a1)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_20;
    v17 = "%s: null manager";
LABEL_19:
    objc_msgSend(v16, "WFLog:message:", 3, v17, "WiFiManagerSetNetworkProperty", v18);
    goto LABEL_20;
  }
  if (!a2)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_20;
    v17 = "%s: null network";
    goto LABEL_19;
  }
  v8 = (const __CFArray *)sub_10008674C(a1);
  if (!v8)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_20;
    v17 = "%s: null networks";
    goto LABEL_19;
  }
  v9 = v8;
  sub_1000953B8(*(_DWORD *)(a1 + 304), v8, a2, &idx, &v20);
  if (idx == -1)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_20;
    v18 = a2;
    v17 = "%s: %@ does not  exist";
    goto LABEL_19;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v9, idx);
  if (!ValueAtIndex)
  {
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = "%s: null existingNetwork";
      goto LABEL_19;
    }
LABEL_20:
    objc_autoreleasePoolPop(v15);
    return 0;
  }
  v11 = sub_10002B2DC((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
  if (!v11)
  {
    v15 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null networkCopy", "WiFiManagerSetNetworkProperty", v18);
    goto LABEL_20;
  }
  v12 = v11;
  sub_10002C478((uint64_t)v11, a3, a4);
  v13 = sub_100099EA4(a1, v12, 1u);
  CFRelease(v12);
  return v13;
}

uint64_t sub_10009BBB4(uint64_t a1, void *a2)
{
  void *v4;
  void *v5;
  id v6;
  void *v7;
  const __CFArray *v8;
  __CFArray *v9;
  const __CFArray *Mutable;
  __CFArray *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex Count;
  uint64_t v15;
  CFIndex v16;
  char v17;
  CFIndex v18;
  const void *ValueAtIndex;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  CFIndex FirstIndexOfValue;
  const void *v25;
  const void *v26;
  const __CFDate *v27;
  void *v28;
  const __CFDate *v29;
  void *v30;
  const __CFDate *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  __CFArray *v36;
  __CFArray *v37;
  CFIndex v38;
  CFDictionaryRef *v39;
  void *v40;
  void *v41;
  id v42;
  id v43;
  const char *v44;
  void *v46;
  void *v47;
  void *v48;
  char v49;
  void *v50;
  const __CFArray *v51;
  CFIndex range;
  CFRange v53;

  v4 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerMergeKnownNetworksToList");
  if (!a1)
  {
    v46 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerMergeKnownNetworksToList");
    v47 = v46;
    goto LABEL_89;
  }
  v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null path", "WiFiManagerMergeKnownNetworksToList");
    v47 = v5;
LABEL_89:
    objc_autoreleasePoolPop(v47);
    v35 = 0;
    v6 = 0;
    goto LABEL_82;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "<%s> Merging known networks to backup file '%@'", "WiFiManagerMergeKnownNetworksToList", a2);
  objc_autoreleasePoolPop(v5);
  v6 = -[NSDictionary mutableCopy](+[NSDictionary dictionaryWithContentsOfFile:](NSDictionary, "dictionaryWithContentsOfFile:", a2), "mutableCopy");
  v7 = objc_autoreleasePoolPush();
  if (v6)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "<%s> Backup file contents: %@", "WiFiManagerMergeKnownNetworksToList", v6);
    objc_autoreleasePoolPop(v7);
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "<%s> Backup file at specified path does not exist '%@'", "WiFiManagerMergeKnownNetworksToList", a2);
    objc_autoreleasePoolPop(v7);
    v6 = objc_alloc_init((Class)NSMutableDictionary);
  }
  if ((objc_msgSend(a2, "hasSuffix:", CFSTR("com.apple.wifi.plist")) & 1) != 0
    || objc_msgSend(a2, "hasSuffix:", CFSTR("com.apple.wifi-networks.plist")))
  {
    v8 = (const __CFArray *)objc_msgSend(v6, "objectForKey:", CFSTR("List of known networks"));
    if (v8)
    {
      v9 = sub_100064608(v8);
      goto LABEL_18;
    }
  }
  else if (objc_msgSend(a2, "hasSuffix:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.plist"), CWFKnownNetworksStoreIdentifier)))
  {
    v9 = sub_10009C2F0(v6);
LABEL_18:
    Mutable = v9;
    if (v9)
      goto LABEL_20;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
LABEL_20:
  v48 = a2;
  v50 = v4;
  if (sub_1000304D4((_QWORD *)a1))
  {
    v11 = sub_10009C2F0(objc_msgSend(*(id *)(a1 + 1104), "dictionaryRepresentation"));
    goto LABEL_24;
  }
  sub_100007FDC(a1, 1, 1, 1);
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 1080));
  v12 = sub_10001D90C((_QWORD *)a1, CFSTR("List of known networks"));
  if (v12)
  {
    v11 = sub_100064608(v12);
LABEL_24:
    v13 = v11;
    if (v11)
      goto LABEL_26;
  }
  v13 = CFArrayCreate(kCFAllocatorDefault, 0, 0, &kCFTypeArrayCallBacks);
LABEL_26:
  Count = CFArrayGetCount(v13);
  if (!Count || (v15 = Count, range = CFArrayGetCount(Mutable), v15 < 1))
  {
LABEL_58:
    v34 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "<%s> No new networks found in known networks list", "WiFiManagerMergeKnownNetworksToList");
    v35 = 1;
    v4 = v50;
    goto LABEL_78;
  }
  v16 = 0;
  v17 = 1;
  v51 = v13;
  while (2)
  {
    v49 = v17;
    v18 = v16;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v13, v18);
      if (ValueAtIndex)
        break;
LABEL_51:
      if (v15 == ++v18)
      {
        if ((v49 & 1) != 0)
          goto LABEL_58;
        goto LABEL_61;
      }
    }
    v20 = ValueAtIndex;
    v21 = sub_1000C6A58((uint64_t)ValueAtIndex, 0);
    v22 = sub_1000C6A58((uint64_t)v20, 1);
    v23 = sub_10002BE64((uint64_t)v20, CFSTR("prevJoined"));
    v53.location = 0;
    v53.length = range;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v53, v20);
    if (FirstIndexOfValue != -1)
    {
      v25 = CFArrayGetValueAtIndex(Mutable, FirstIndexOfValue);
      if (v25)
      {
        v26 = v25;
        if (v21)
        {
          v27 = (const __CFDate *)sub_1000C6A58((uint64_t)v25, 0);
          if (!v27 || CFDateCompare((CFDateRef)v21, v27, 0) == kCFCompareGreaterThan)
          {
            v28 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found newer auto-join date %@ for network %@", "__MergeNetworkLists", v21, sub_10002B088(v20));
            objc_autoreleasePoolPop(v28);
            sub_1000C69F0(v26, 0, v21);
            v13 = v51;
          }
        }
        if (v22)
        {
          v29 = (const __CFDate *)sub_1000C6A58((uint64_t)v26, 1);
          if (!v29 || CFDateCompare((CFDateRef)v22, v29, 0) == kCFCompareGreaterThan)
          {
            v30 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found newer last-join date %@ for network %@", "__MergeNetworkLists", v22, sub_10002B088(v20));
            objc_autoreleasePoolPop(v30);
            sub_1000C69F0(v26, 1, v22);
            v13 = v51;
          }
        }
        if (v23)
        {
          v31 = (const __CFDate *)sub_10002BE64((uint64_t)v26, CFSTR("prevJoined"));
          if (!v31 || CFDateCompare((CFDateRef)v23, v31, 0) == kCFCompareGreaterThan)
          {
            v32 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found newer prev-join date %@ for network %@", "__MergeNetworkLists", v23, sub_10002B088(v20));
            objc_autoreleasePoolPop(v32);
            sub_10002C478((uint64_t)v26, CFSTR("prevJoined"), v23);
          }
        }
      }
      goto LABEL_51;
    }
    CFArrayAppendValue(Mutable, v20);
    v33 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: added network %@ to the list", "__MergeNetworkLists", sub_10002B088(v20));
    objc_autoreleasePoolPop(v33);
    v17 = 0;
    v16 = v18 + 1;
    if (v15 - 1 != v18)
      continue;
    break;
  }
LABEL_61:
  if ((objc_msgSend(v48, "hasSuffix:", CFSTR("com.apple.wifi.plist")) & 1) != 0
    || (objc_msgSend(v48, "hasSuffix:", CFSTR("com.apple.wifi-networks.plist")) & 1) != 0)
  {
    v36 = sub_1000172FC(Mutable, 1);
    v4 = v50;
    if (v36)
    {
      v37 = v36;
      objc_msgSend(v6, "setObject:forKey:", v36, CFSTR("List of known networks"));
      CFRelease(v37);
    }
  }
  else
  {
    v4 = v50;
    if (CFArrayGetCount(Mutable) >= 1)
    {
      v38 = 0;
      do
      {
        v39 = (CFDictionaryRef *)CFArrayGetValueAtIndex(Mutable, v38);
        if (v39)
        {
          v40 = sub_100026664(v39);
          if (v40)
          {
            v41 = v40;
            v42 = objc_msgSend(v40, "identifier");
            v43 = objc_msgSend(v41, "externalForm");
            if (v42 && v43)
              objc_msgSend(v6, "setObject:forKey:", v43, v42);

          }
        }
        ++v38;
      }
      while (CFArrayGetCount(Mutable) > v38);
    }
  }
  v35 = (uint64_t)objc_msgSend(v6, "writeToFile:atomically:", v48, 1);
  v34 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v44 = "FAILED to";
    if ((_DWORD)v35)
      v44 = "SUCCEEDED to";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "<%s> %s write backup file contents: %@", "WiFiManagerMergeKnownNetworksToList", v44, v6);
  }
LABEL_78:
  objc_autoreleasePoolPop(v34);
  if (Mutable)
    CFRelease(Mutable);
  if (v13)
    CFRelease(v13);
LABEL_82:

  return v35;
}

__CFArray *sub_10009C2F0(void *a1)
{
  void *v2;
  __CFArray *Mutable;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  void *v12;
  _WORD *v13;
  const void *v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];

  v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v4 = objc_msgSend(a1, "allValues", 0);
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      if (v5)
      {
        v6 = v5;
        v7 = *(_QWORD *)v17;
        do
        {
          v8 = 0;
          do
          {
            if (*(_QWORD *)v17 != v7)
              objc_enumerationMutation(v4);
            v9 = *(_QWORD *)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)v8);
            v10 = objc_opt_class(NSDictionary);
            if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0)
            {
              v11 = objc_msgSend(objc_alloc((Class)CWFNetworkProfile), "initWithExternalForm:", v9);
              if (v11)
              {
                v12 = v11;
                v13 = sub_1000CCB10(v11, 0);
                if (v13)
                {
                  v14 = v13;
                  CFArrayAppendValue(Mutable, v13);
                  CFRelease(v14);
                }

              }
            }
            v8 = (char *)v8 + 1;
          }
          while (v6 != v8);
          v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
        }
        while (v6);
      }
    }
  }
  else
  {
    Mutable = 0;
  }
  objc_autoreleasePoolPop(v2);
  return Mutable;
}

uint64_t sub_10009C488(uint64_t a1, const __CFString *a2, char a3, char a4)
{
  const __CFArray *v8;
  const __CFArray *v9;
  const void *ValueAtIndex;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  const char *v17;

  v8 = sub_10000B29C((CFArrayRef)a1);
  v9 = v8;
  if (a2 && v8)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v8, 0);
    if (CFStringCompare(a2, &stru_100238178, 0))
      v11 = a2;
    else
      v11 = CFSTR("XZ");
    if (ValueAtIndex)
    {
      v12 = sub_10010883C((uint64_t)ValueAtIndex, v11, a3);
      if ((_DWORD)v12)
      {
        v13 = sub_100005AF0((uint64_t)ValueAtIndex);
        if (*(_DWORD *)(a1 + 2016) != (_DWORD)v13)
        {
          v14 = v13;
          v15 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "WiFiMC : band support changed. Before : %d, after : %d", *(unsigned int *)(a1 + 2016), v14);
          objc_autoreleasePoolPop(v15);
          *(_DWORD *)(a1 + 2016) = v14;
          sub_10009322C((_QWORD *)a1, CFSTR("WiFiCountryBandSupportKey"), v14, 1);
        }
      }
    }
    else
    {
      v12 = 0;
    }
    goto LABEL_15;
  }
  v12 = 0;
  v11 = a2;
  if (v8)
LABEL_15:
    CFRelease(v9);
  v16 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v17 = "succeeded";
    if (!(_DWORD)v12)
      v17 = "failed";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: <%@> %s", "WiFiManagerSetLocale", v11, v17);
  }
  objc_autoreleasePoolPop(v16);
  if ((_DWORD)v12 == 1)
  {
    *(_BYTE *)(a1 + 2012) = a4;
    sub_100176E70(*(void **)(a1 + 1432), (uint64_t)a2);
  }
  return v12;
}

uint64_t sub_10009C634(uint64_t result)
{
  if (result)
    LOBYTE(result) = objc_msgSend(*(id *)(result + 192), "getLocaleSource");
  return result;
}

void sub_10009C654(uint64_t a1, const void *a2)
{
  void *v4;
  const void *v5;

  if (a1)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Received companion based country code: %@, was %@", "WiFiManagerSetCompanionCountryCode", a2, *(_QWORD *)(a1 + 2024));
    objc_autoreleasePoolPop(v4);
    v5 = *(const void **)(a1 + 2024);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 2024) = 0;
    }
    if (a2)
      *(_QWORD *)(a1 + 2024) = CFRetain(a2);
  }
}

uint64_t sub_10009C6EC(uint64_t result, CFMutableStringRef theString)
{
  const __CFString *v2;

  if (result)
  {
    v2 = *(const __CFString **)(result + 2024);
    if (v2)
      CFStringAppend(theString, v2);
    return 1;
  }
  return result;
}

uint64_t sub_10009C718(uint64_t a1, __CFString *a2)
{
  double Current;
  double v5;
  const __CFDictionary *v6;
  CFTypeID TypeID;
  const __CFDate *Value;
  double AbsoluteTime;
  uint64_t v10;
  void *v11;
  uint64_t result;
  void *v13;
  uint64_t v14;

  Current = CFAbsoluteTimeGetCurrent();
  if (!a1)
    return 0;
  v5 = Current;
  v6 = sub_10009C91C();
  if (v6)
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      Value = (const __CFDate *)CFDictionaryGetValue(v6, CFSTR("countryCodeUserDefaultDate"));
      if (Value)
      {
        AbsoluteTime = CFDateGetAbsoluteTime(Value);
        if (v5 <= AbsoluteTime)
        {
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCC : last used time is [%f]", "WiFiManagerGetCountryCodeFromUserDefaults", *(_QWORD *)&AbsoluteTime);
        }
        else
        {
          if (v5 - AbsoluteTime < 5400.0)
          {
            v10 = (uint64_t)CFDictionaryGetValue(v6, CFSTR("countryCodeUserDefault"));
            if (!v10)
            {
LABEL_15:
              CFRelease(v6);
              return v10;
            }
            CFStringAppend(a2, (CFStringRef)v10);
            v11 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Getting Country Code from user defaults : [%@]", "WiFiManagerGetCountryCodeFromUserDefaults", v10);
            v10 = 1;
LABEL_14:
            objc_autoreleasePoolPop(v11);
            goto LABEL_15;
          }
          v11 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s WiFiCC : Country Code Data too old. Not using.", "WiFiManagerGetCountryCodeFromUserDefaults", v14);
        }
      }
      else
      {
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCC : last used date is NULL", "WiFiManagerGetCountryCodeFromUserDefaults", v14);
      }
      v10 = 0;
      goto LABEL_14;
    }
  }
  v13 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCC : No Country Code info present in user defaults", "WiFiManagerGetCountryCodeFromUserDefaults");
  objc_autoreleasePoolPop(v13);
  v10 = 0;
  result = 0;
  if (v6)
    goto LABEL_15;
  return result;
}

CFDictionaryRef sub_10009C91C()
{
  NSUserDefaults *v0;
  NSDictionary *v1;
  const __CFDictionary *v2;
  CFTypeID TypeID;

  v0 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  if (v0
    && (v1 = -[NSUserDefaults dictionaryForKey:](v0, "dictionaryForKey:", CFSTR("countryCodeUserDefaultData"))) != 0
    && (v2 = (const __CFDictionary *)v1, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v2)))
  {
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v2);
  }
  else
  {
    return 0;
  }
}

CFStringRef sub_10009C990()
{
  CFStringEncoding SystemEncoding;
  CFStringRef v1;
  void *v2;

  SystemEncoding = CFStringGetSystemEncoding();
  v1 = CFStringCreateWithCString(kCFAllocatorDefault, "WiFiManager-1753.111 Aug 13 2024 20:46:37", SystemEncoding);
  if (!v1)
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "failed to format build info string");
    objc_autoreleasePoolPop(v2);
  }
  return v1;
}

CFMutableArrayRef sub_10009CA08(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  if (!*(_QWORD *)(a1 + 136))
    return 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
    CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_10009CA70, Mutable);
  return Mutable;
}

void sub_10009CA70(uint64_t a1, __CFArray *a2)
{
  CFMutableStringRef Mutable;
  __CFString *v5;
  unsigned int v6;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const __CFArray *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v18;
  const void *v19;
  void *v20;

  if (!a1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null client", "__WiFiManagerAddNameToArray");
    goto LABEL_22;
  }
  if (!a2)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null names", "__WiFiManagerAddNameToArray");
    goto LABEL_22;
  }
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null description", "__WiFiManagerAddNameToArray");
LABEL_22:
    objc_autoreleasePoolPop(v20);
    return;
  }
  v5 = Mutable;
  v6 = sub_100005830(a1);
  if (v6 > 2)
    v7 = CFSTR("U");
  else
    v7 = off_100230D50[v6];
  CFStringAppend(v5, v7);
  v8 = sub_10001493C(a1);
  CFStringAppendFormat(v5, 0, CFSTR(": [%d]"), v8);
  v9 = sub_1000161D4(a1);
  CFStringAppendFormat(v5, 0, CFSTR("%@: "), v9);
  CFStringAppend(v5, CFSTR("{"));
  v10 = sub_100032338(a1);
  sub_1000BA318(v10, v5);
  CFStringAppend(v5, CFSTR(" } "));
  v11 = (const __CFArray *)sub_100016A7C(a1);
  v12 = sub_10000B29C(v11);
  if (v12)
  {
    v13 = v12;
    Count = CFArrayGetCount(v12);
    if (Count >= 1)
    {
      v15 = Count;
      for (i = 0; i != v15; ++i)
      {
        CFStringAppend(v5, CFSTR("{"));
        ValueAtIndex = CFArrayGetValueAtIndex(v13, i);
        v18 = sub_100029720(a1, (uint64_t)ValueAtIndex);
        if (v18)
          sub_1000BA318(v18, v5);
        CFStringAppend(v5, CFSTR(" } "));
      }
    }
    CFArrayAppendValue(a2, v5);
    CFRelease(v5);
    v19 = v13;
  }
  else
  {
    CFArrayAppendValue(a2, v5);
    v19 = v5;
  }
  CFRelease(v19);
}

uint64_t sub_10009CCDC(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 2012);
  return result;
}

__CFDictionary *sub_10009CCE8(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t v6;
  CFNumberRef v7;
  CFNumberRef v8;
  id v9;
  void *v11;
  uint64_t v12;
  unsigned int valuePtr;

  if (!*(_QWORD *)(a1 + 192))
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Null localeManagerUser", "WiFiManagerCopyLocaleStats");
    goto LABEL_14;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v11 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null localeStatsDict", "WiFiManagerCopyLocaleStats");
LABEL_14:
    objc_autoreleasePoolPop(v11);
    return 0;
  }
  v3 = Mutable;
  valuePtr = objc_msgSend(*(id *)(a1 + 192), "getLocaleSource");
  v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v4)
  {
    v5 = v4;
    CFDictionaryAddValue(v3, CFSTR("LocaleSource"), v4);
    CFRelease(v5);
  }
  objc_msgSend(*(id *)(a1 + 192), "getLocaleLastUpdatedTime");
  v12 = v6;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v12);
  if (v7)
  {
    v8 = v7;
    CFDictionaryAddValue(v3, CFSTR("LocaleLastTimeUpdated"), v7);
    CFRelease(v8);
  }
  v9 = objc_msgSend(*(id *)(a1 + 192), "getLocaleCountryCode");
  if (v9)
    CFDictionaryAddValue(v3, CFSTR("LocaleCountryCode"), v9);
  return v3;
}

uint64_t sub_10009CE70(uint64_t a1)
{
  _QWORD v3[3];
  uint64_t v4;

  v3[0] = a1;
  v3[1] = 0xAAAAAAAA0000006BLL;
  v3[2] = 0;
  v4 = 0;
  if (a1)
  {
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v3);
    return v4;
  }
  else
  {
    return 0;
  }
}

void sub_10009CEC4(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    v2[0] = a1;
    v2[1] = 0xAAAAAAAA00000036;
    v2[2] = a2;
    v2[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  }
}

void sub_10009CF0C(uint64_t a1, int a2)
{
  _QWORD context[4];
  int v3;

  v3 = a2;
  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000037;
    context[2] = &v3;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_10009CF5C(uint64_t a1, uint64_t a2)
{
  _QWORD v2[4];

  if (a1)
  {
    v2[0] = a1;
    v2[1] = 0xAAAAAAAA00000040;
    v2[2] = a2;
    v2[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
  }
}

void sub_10009CFA4(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("airplay");
  values[1] = kCFBooleanTrue;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_10009D090(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("airplay");
  values[1] = kCFBooleanFalse;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_10009D17C(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("WiFiCallingUUID");
  values[1] = kCFBooleanTrue;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_10009D268(uint64_t a1)
{
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD context[4];
  void *values[2];
  void *keys[2];

  keys[0] = CFSTR("appPolicyUUID");
  keys[1] = CFSTR("appPolicyState");
  values[0] = CFSTR("WiFiCallingUUID");
  values[1] = kCFBooleanFalse;
  v2 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v2)
  {
    v3 = v2;
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000041;
    context[2] = v2;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    CFRelease(v3);
  }
}

void sub_10009D354(uint64_t a1)
{
  void *v2;
  BOOL v3;
  const void *v4;
  NSObject *v5;
  _QWORD v6[5];
  _QWORD block[5];
  _QWORD context[4];

  v2 = objc_autoreleasePoolPush();
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000073;
  context[2] = 0;
  context[3] = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  if (&_WiFiCloudSyncEngineCreate)
    v3 = qword_10026DD48 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = *(const void **)(a1 + 1304);
    if (v4)
    {
      CFRetain(v4);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10009D458;
      block[3] = &unk_10022EA38;
      block[4] = a1;
      dispatch_async((dispatch_queue_t)qword_10026DD48, block);
    }
  }
  CFRetain((CFTypeRef)a1);
  v5 = *(NSObject **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10009D560;
  v6[3] = &unk_10022EA38;
  v6[4] = a1;
  dispatch_async(v5, v6);
  objc_autoreleasePoolPop(v2);
}

void sub_10009D458(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSString *v4;
  NSString *v5;
  uint64_t v6;
  void *v7;
  NSString *v8;
  NSString *v9;

  v2 = WiFiCloudSyncEngineCopyCompleteKVS(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), 1);
  if (v2)
  {
    v3 = (void *)v2;
    v4 = -[NSURL path](-[NSURL URLByAppendingPathComponent:](-[NSFileManager containerURLForSecurityApplicationGroupIdentifier:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "containerURLForSecurityApplicationGroupIdentifier:", CFSTR("group.com.apple.wifi.logs")), "URLByAppendingPathComponent:", CFSTR("com.apple.wifi.syncable-networks.legacy.plist")), "path");
    if (v4)
    {
      v5 = v4;
      -[NSFileManager removeItemAtPath:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtPath:error:", v4, 0);
      objc_msgSend(v3, "writeToFile:atomically:", v5, 1);
    }

  }
  v6 = WiFiCloudSyncEngineCopyCompleteKVS(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1304), 0);
  if (v6)
  {
    v7 = (void *)v6;
    v8 = -[NSURL path](-[NSURL URLByAppendingPathComponent:](-[NSFileManager containerURLForSecurityApplicationGroupIdentifier:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "containerURLForSecurityApplicationGroupIdentifier:", CFSTR("group.com.apple.wifi.logs")), "URLByAppendingPathComponent:", CFSTR("com.apple.wifi.syncable-networks.plist")), "path");
    if (v8)
    {
      v9 = v8;
      -[NSFileManager removeItemAtPath:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtPath:error:", v8, 0);
      objc_msgSend(v7, "writeToFile:atomically:", v9, 1);
    }

  }
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 1304));
}

void sub_10009D560(uint64_t a1)
{
  CFDictionaryRef v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  double v8;
  double v9;
  id v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  uint64_t v16;
  void *v17;
  id v18;
  void *v19;
  double v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *j;
  uint64_t v26;
  NSData *v27;
  NSData *v28;
  NSString *v29;
  NSString *v30;
  uint64_t v31;
  const __CFArray *v32;
  CFIndex Count;
  CFIndex v34;
  void *v35;
  CFIndex k;
  const void *ValueAtIndex;
  __CFString *Mutable;
  __CFString *v39;
  void *v40;
  void *v41;
  void *v42;
  CFDictionaryRef cf;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[128];
  _BYTE v54[128];

  v2 = sub_10009DA68(*(_QWORD **)(a1 + 32), 0);
  v3 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: --- Custom Network Settings start", "WiFiManagerDumpLogBufferAsync_block_invoke_2");
  objc_autoreleasePoolPop(v3);
  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: %@", "WiFiManagerDumpLogBufferAsync_block_invoke_2", v2);
  cf = v2;
  objc_autoreleasePoolPop(v4);
  v5 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: --- Custom Network Settings end", "WiFiManagerDumpLogBufferAsync_block_invoke_2");
  objc_autoreleasePoolPop(v5);
  v44 = a1;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = objc_autoreleasePoolPush();
  +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
  v9 = v8;
  v10 = +[NSMutableArray array](NSMutableArray, "array");
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  v11 = objc_msgSend(objc_msgSend(*(id *)(v6 + 1104), "dictionaryRepresentation"), "allValues");
  v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v49, v54, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v50;
    do
    {
      for (i = 0; i != v13; i = (char *)i + 1)
      {
        if (*(_QWORD *)v50 != v14)
          objc_enumerationMutation(v11);
        v16 = *(_QWORD *)(*((_QWORD *)&v49 + 1) + 8 * (_QWORD)i);
        v17 = objc_autoreleasePoolPush();
        v18 = objc_msgSend(objc_alloc((Class)CWFNetworkProfile), "initWithExternalForm:", v16);
        if (v18)
        {
          v19 = v18;
          if (objc_msgSend(v18, "lastJoinedAt"))
          {
            objc_msgSend(objc_msgSend(v19, "lastJoinedAt"), "timeIntervalSinceReferenceDate");
            if (v9 - v20 <= 86400.0)
              objc_msgSend(v10, "addObject:", v19);
          }
        }
        objc_autoreleasePoolPop(v17);
      }
      v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v49, v54, 16);
    }
    while (v13);
  }
  v21 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v22 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v45, v53, 16);
  if (v22)
  {
    v23 = v22;
    v24 = *(_QWORD *)v46;
    do
    {
      for (j = 0; j != v23; j = (char *)j + 1)
      {
        if (*(_QWORD *)v46 != v24)
          objc_enumerationMutation(v10);
        objc_msgSend(v21, "setObject:forKeyedSubscript:", objc_msgSend(*(id *)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)j), "externalForm"), objc_msgSend(*(id *)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)j), "identifier"));
      }
      v23 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v45, v53, 16);
    }
    while (v23);
  }
  v26 = CWFConvertPropertyListToJSON(v21, 0);
  if (v26)
  {
    v27 = +[NSJSONSerialization dataWithJSONObject:options:error:](NSJSONSerialization, "dataWithJSONObject:options:error:", v26, 0, 0);
    if (v27)
    {
      v28 = v27;
      v29 = -[NSURL path](-[NSURL URLByAppendingPathComponent:](-[NSFileManager containerURLForSecurityApplicationGroupIdentifier:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "containerURLForSecurityApplicationGroupIdentifier:", CFSTR("group.com.apple.wifi.logs")), "URLByAppendingPathComponent:", CFSTR("com.apple.wifi.recent-networks.json")), "path");
      if (v29)
      {
        v30 = v29;
        -[NSFileManager removeItemAtPath:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtPath:error:", v29, 0);
        -[NSData writeToFile:atomically:](v28, "writeToFile:atomically:", v30, 1);
      }
    }
  }
  objc_autoreleasePoolPop(v7);
  v31 = *(_QWORD *)(v44 + 32);
  if (!v31)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "__WiFiManagerDumpHS20Networks");
    goto LABEL_51;
  }
  v32 = *(const __CFArray **)(v31 + 216);
  if (!v32)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager->networks", "__WiFiManagerDumpHS20Networks");
LABEL_51:
    objc_autoreleasePoolPop(v42);
    goto LABEL_44;
  }
  Count = CFArrayGetCount(v32);
  if (Count >= 1)
  {
    v34 = Count;
    v35 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: --- HS 2.0 Networks", "__WiFiManagerDumpHS20Networks");
    objc_autoreleasePoolPop(v35);
    for (k = 0; k != v34; ++k)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v31 + 216), k);
      if (sub_10002DA5C((_BOOL8)ValueAtIndex))
      {
        Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
        if (Mutable)
        {
          v39 = Mutable;
          sub_1000C9564((uint64_t)ValueAtIndex, Mutable);
          v40 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: HS20 Account Info:%@", "__WiFiManagerDumpHS20Networks", v39);
          objc_autoreleasePoolPop(v40);
          CFRelease(v39);
        }
        else
        {
          v41 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Could not allocate buffer for HS 2.0 info", "__WiFiManagerDumpHS20Networks");
          objc_autoreleasePoolPop(v41);
        }
      }
    }
  }
LABEL_44:
  if (cf)
    CFRelease(cf);
  CFRelease(*(CFTypeRef *)(v44 + 32));
}

CFDictionaryRef sub_10009DA68(_QWORD *a1, int a2)
{
  NSUserDefaults *v4;
  const __CFDictionary *v5;
  const __SCPreferences *v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  void *v11;

  v4 = +[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults");
  v5 = -[NSUserDefaults dictionaryForKey:](v4, "dictionaryForKey:", CFSTR("Custom network settings"));
  if (v5)
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v5);
  v6 = sub_10001D90C(a1, CFSTR("Custom network settings"));
  if (!v6)
  {
    v7 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("wifid"));
    if (!v7)
      return 0;
    v8 = v7;
    v9 = objc_msgSend(v7, "dictionaryForKey:", CFSTR("Custom network settings"));
    if (v9)
    {
      v10 = v9;
      v11 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: found custom network settings list in legacy NSUserDefaults", "__WiFiManagerCopyCustomNetworkSettingsFromUserDefaults");
      objc_autoreleasePoolPop(v11);
      -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v10, CFSTR("Custom network settings"));
      v5 = -[NSUserDefaults dictionaryForKey:](v4, "dictionaryForKey:", CFSTR("Custom network settings"));
    }
    else
    {
      v5 = 0;
    }

    if (!v5)
      return 0;
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v5);
  }
  -[NSUserDefaults setObject:forKey:](+[NSUserDefaults standardUserDefaults](NSUserDefaults, "standardUserDefaults"), "setObject:forKey:", v6, CFSTR("Custom network settings"));
  sub_100087488(a1, CFSTR("Custom network settings"), 0, a2);
  v5 = -[NSUserDefaults dictionaryForKey:](v4, "dictionaryForKey:", CFSTR("Custom network settings"));
  if (v5)
    return CFDictionaryCreateCopy(kCFAllocatorDefault, v5);
  return 0;
}

void sub_10009DBE4(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v6;
  id v7;
  id v8;
  id v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  NSObject *v16;
  CFBooleanRef v17;
  int v18;
  void *v19;
  void *v20;
  void *v21;
  unsigned int valuePtr;
  void **context;
  unint64_t v24;
  void (*v25)(uint64_t);
  uint64_t v26;
  uint64_t v27;

  valuePtr = 0;
  if (!theDict)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null testParams", "WiFiManagerSetTestParams");
    goto LABEL_46;
  }
  if (!a1)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerSetTestParams");
    goto LABEL_46;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("WiFiTestCommandType"));
  if (!Value)
  {
    v20 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null cmdNum", "WiFiManagerSetTestParams");
LABEL_46:
    objc_autoreleasePoolPop(v20);
    return;
  }
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  if (MutableCopy)
  {
    v6 = MutableCopy;
    if (valuePtr < 0x65)
    {
      switch(valuePtr)
      {
        case 5u:
          v7 = -[__CFDictionary objectForKeyedSubscript:](MutableCopy, "objectForKeyedSubscript:", CFSTR("builtInReceiver"));
          v8 = -[__CFDictionary objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", CFSTR("cellularTx"));
          v9 = -[__CFDictionary objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", CFSTR("shortCellularTx"));
          if (v7)
          {
            v10 = objc_msgSend(v7, "intValue");
            if (v10 == 1)
              v11 = 1;
            else
              v11 = -1;
            if (!v10)
              v11 = 0;
            *(_DWORD *)(a1 + 1468) = v11;
          }
          if (v8)
          {
            v12 = objc_msgSend(v8, "intValue");
            if (v12 == 1)
              v13 = 1;
            else
              v13 = -1;
            if (!v12)
              v13 = 0;
            *(_DWORD *)(a1 + 1472) = v13;
          }
          if (v9)
          {
            v14 = objc_msgSend(v9, "intValue");
            if (v14 == 1)
              v15 = 1;
            else
              v15 = -1;
            if (!v14)
              v15 = 0;
            *(_DWORD *)(a1 + 1476) = v15;
          }
          v16 = *(NSObject **)(a1 + 32);
          context = _NSConcreteStackBlock;
          v24 = 3221225472;
          v25 = sub_1000BB4B0;
          v26 = (uint64_t)&unk_10022EA38;
          v27 = a1;
          dispatch_async(v16, &context);
          break;
        case 2u:
          v17 = (CFBooleanRef)CFDictionaryGetValue(MutableCopy, CFSTR("wowStateOverride"));
          if (v17)
          {
            v18 = v17 == kCFBooleanTrue;
            if (*(unsigned __int8 *)(a1 + 1163) != v18)
            {
              *(_BYTE *)(a1 + 1163) = v18;
              sub_10000A77C(a1, 0, *(unsigned __int8 *)(a1 + 1162), 2);
            }
          }
          v19 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WoW Parameters: WoWEnable %d WoWOverrideState %d lpasEnable %d", "__WiFiManagerSetWoWTestParams", *(unsigned __int8 *)(a1 + 1160), *(unsigned __int8 *)(a1 + 1163), *(unsigned __int8 *)(a1 + 1162));
          objc_autoreleasePoolPop(v19);
          break;
        case 1u:
          sub_100093FA0((_QWORD *)a1, CFSTR("LocaleTestParams"), MutableCopy);
          sub_10008F28C(a1, v6);
          break;
      }
    }
    else
    {
      context = (void **)a1;
      v24 = 0xAAAAAAAA00000038;
      v25 = (void (*)(uint64_t))MutableCopy;
      v26 = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    }
    CFRelease(v6);
  }
  else
  {
    v21 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null mutableTestParams", "WiFiManagerSetTestParams");
    objc_autoreleasePoolPop(v21);
  }
}

void *sub_10009DF50(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  const __CFNumber *Value;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v7;
  id v8;
  void *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  const __CFString *v13;
  void *v14;
  NSObject *v15;
  id v16;
  dispatch_time_t v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  NSNumber *v27;
  NSNumber *v28;
  NSNumber *v29;
  id v30;
  id v31;
  double v32;
  double v33;
  void *v34;
  WiFiManagerAnalytics *v35;
  dispatch_time_t v36;
  void *v37;
  void *v38;
  unsigned int valuePtr;
  void **context;
  unint64_t v42;
  intptr_t (*v43)(uint64_t, uint64_t);
  uint64_t v44;
  NSObject *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;

  v4 = objc_autoreleasePoolPush();
  valuePtr = 0;
  if (a2)
  {
    if (a1)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("WiFiTestCommandType"));
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
        if (MutableCopy)
        {
          v7 = MutableCopy;
          if (valuePtr >= 0x65)
          {
            context = (void **)a1;
            v42 = 0xAAAAAAAA00000038;
            v43 = (intptr_t (*)(uint64_t, uint64_t))MutableCopy;
            v44 = 1;
            CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
LABEL_82:
            v9 = 0;
            goto LABEL_83;
          }
          if (valuePtr != 4)
          {
            if (valuePtr != 5)
              goto LABEL_82;
            v8 = objc_alloc_init((Class)NSMutableDictionary);
            if (!v8)
            {
              v38 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null params", "__WiFiManagerCopyDualPowerOverrideParams");
              objc_autoreleasePoolPop(v38);
              goto LABEL_82;
            }
            v9 = v8;
            v10 = *(_DWORD *)(a1 + 1468) + 1;
            if (v10 <= 2)
              objc_msgSend(v8, "setObject:forKeyedSubscript:", off_100230D68[v10], CFSTR("builtInReceiver"));
            v11 = *(_DWORD *)(a1 + 1472) + 1;
            if (v11 <= 2)
              objc_msgSend(v9, "setObject:forKeyedSubscript:", off_100230D68[v11], CFSTR("cellularTx"));
            v12 = *(_DWORD *)(a1 + 1476);
            if (v12 == -1)
            {
              v13 = CFSTR("disabled");
            }
            else if (v12)
            {
              if (v12 != 1)
              {
LABEL_83:
                CFRelease(v7);
                goto LABEL_84;
              }
              v13 = CFSTR("on");
            }
            else
            {
              v13 = CFSTR("off");
            }
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v13, CFSTR("shortCellularTx"));
            goto LABEL_83;
          }
          v14 = objc_autoreleasePoolPush();
          v47 = 0;
          v48 = &v47;
          v49 = 0x2020000000;
          v50 = 0;
          v15 = dispatch_semaphore_create(0);
          if (!+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"))
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: sharedWiFiAnalyticsManager is nil", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse");
            goto LABEL_44;
          }
          if (!objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"))
          {
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: analyticsClient is nil", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse");
            goto LABEL_44;
          }
          if (-[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("dump")))
          {
            v16 = objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient");
            context = _NSConcreteStackBlock;
            v42 = 3221225472;
            v43 = sub_1000BA51C;
            v44 = (uint64_t)&unk_100230B98;
            v45 = v15;
            v46 = &v47;
            if (!objc_msgSend(v16, "dumpDeviceAnalyticsToFileWithCompletion:", &context))
              goto LABEL_45;
            v17 = dispatch_time(0, 60000000000);
            if (!dispatch_semaphore_wait(v15, v17))
              goto LABEL_45;
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Gave up waiting to get Device Analytics Store Dump. Bailing");
          }
          else if (-[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("roamTriggerRssi")))
          {
            v19 = -[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("roamTriggerRssi"));
            v20 = objc_msgSend(objc_alloc((Class)NSNumber), "initWithInteger:", objc_msgSend(objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"), "rssiRoamTriggerForBSS:ssid:", objc_msgSend(v19, "objectForKey:", CFSTR("bssid")), objc_msgSend(v19, "objectForKey:", CFSTR("ssid"))));
            v48[3] = (uint64_t)v20;
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s RoamTrigger :%d", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse", objc_msgSend((id)v48[3], "intValue"));
          }
          else if (-[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("neighborChannels")))
          {
            v21 = -[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("neighborChannels"));
            v22 = objc_msgSend(objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"), "neighborChannelsForBSS:ssid:", objc_msgSend(v21, "objectForKey:", CFSTR("bssid")), objc_msgSend(v21, "objectForKey:", CFSTR("ssid")));
            if (v22)
            {
              v23 = objc_msgSend(objc_alloc((Class)NSArray), "initWithArray:", v22);
              v48[3] = (uint64_t)v23;
            }
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s neighborChannelsForBSS :%@", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse", v48[3]);
          }
          else if (-[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("neighborBSSIDs")))
          {
            v24 = -[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("neighborBSSIDs"));
            v25 = objc_msgSend(objc_msgSend(+[WiFiAnalyticsManager sharedWiFiAnalyticsManager](WiFiAnalyticsManager, "sharedWiFiAnalyticsManager"), "deviceAnalyticsClient"), "neighborsForBSS:ssid:", objc_msgSend(v24, "objectForKey:", CFSTR("bssid")), objc_msgSend(v24, "objectForKey:", CFSTR("ssid")));
            if (v25)
            {
              v26 = objc_msgSend(objc_alloc((Class)NSArray), "initWithArray:", v25);
              v48[3] = (uint64_t)v26;
            }
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s neighborsForBSS :%@", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse", v48[3]);
          }
          else
          {
            if (-[__CFDictionary objectForKey:](v7, "objectForKey:", CFSTR("resetIntervals")))
            {
              v27 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", 86400.0);
              v28 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", 4233600.0);
              v29 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", 0);
              v30 = 0;
            }
            else
            {
              v27 = (NSNumber *)-[__CFDictionary valueForKey:](v7, "valueForKey:", CFSTR("procIntervalSecs"));
              v28 = (NSNumber *)-[__CFDictionary valueForKey:](v7, "valueForKey:", CFSTR("ageOutIntervalSecs"));
              v29 = (NSNumber *)-[__CFDictionary valueForKey:](v7, "valueForKey:", CFSTR("ageOutTestDaysDiff"));
              v30 = -[__CFDictionary valueForKey:](v7, "valueForKey:", CFSTR("roamSamples"));
            }
            if (v27 || v28 || v29)
            {
              v31 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
              if (v27)
              {
                -[NSNumber doubleValue](v27, "doubleValue");
                if (v32 < 0.0)
                {
                  v18 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid procIntervalSecs", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse");
                  goto LABEL_44;
                }
                objc_msgSend(v31, "setObject:forKey:", v27, CFSTR("WA_DEVICE_ANALYTICS_PROCESSING_INTERVAL"));
              }
              if (v28)
              {
                -[NSNumber doubleValue](v28, "doubleValue");
                if (v33 < 0.0)
                {
                  v18 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: invalid ageOutIntervalNum", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse");
                  goto LABEL_44;
                }
                objc_msgSend(v31, "setObject:forKey:", v28, CFSTR("WA_DEVICE_ANALYTICS_AGE_OUT_INTERVAL"));
              }
              if (v29)
              {
                -[NSNumber unsignedLongValue](v29, "unsignedLongValue");
                objc_msgSend(v31, "setObject:forKey:", v29, CFSTR("WA_DEVICE_ANALYTICS_CONFIG_AGE_OUT_TEST_DAYS_DIFF"));
              }
              if (v30)
              {
                objc_msgSend(v30, "unsignedLongValue");
                objc_msgSend(v31, "setObject:forKey:", v30, CFSTR("WA_DEVICE_ANALYTICS_CONFIG_ROAM_SAMPLES"));
              }
              v34 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Setting configuration: %s", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse", -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), v31), "UTF8String"));
              objc_autoreleasePoolPop(v34);
              -[WiFiManagerAnalytics setDeviceAnalyticsConfiguration:](+[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance"), "setDeviceAnalyticsConfiguration:", v31);
              v35 = +[WiFiManagerAnalytics sharedInstance](WiFiManagerAnalytics, "sharedInstance");
              context = _NSConcreteStackBlock;
              v42 = 3221225472;
              v43 = sub_1000BA5B0;
              v44 = (uint64_t)&unk_100230BC0;
              v45 = v15;
              v46 = &v47;
              -[WiFiManagerAnalytics getDeviceAnalyticsConfigurationWithCompletion:](v35, "getDeviceAnalyticsConfigurationWithCompletion:", &context);
              v36 = dispatch_time(0, 60000000000);
              if (!dispatch_semaphore_wait(v15, v36))
                goto LABEL_45;
              v18 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "Gave up waiting to getDeviceAnalyticsConfigurationWithCompletion. Bailing");
              goto LABEL_44;
            }
            v18 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: Invalid configuration %s", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse", -[NSString UTF8String](+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), v7), "UTF8String"));
          }
LABEL_44:
          objc_autoreleasePoolPop(v18);
LABEL_45:
          dispatch_release(v15);
          v9 = (void *)v48[3];
          _Block_object_dispose(&v47, 8);
          objc_autoreleasePoolPop(v14);
          goto LABEL_83;
        }
        v37 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null mutableTestParams", "WiFiManagerSetTestParamsAndCopyResponse");
      }
      else
      {
        v37 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null cmdNum", "WiFiManagerSetTestParamsAndCopyResponse");
      }
    }
    else
    {
      v37 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerSetTestParamsAndCopyResponse");
    }
  }
  else
  {
    v37 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null testParams", "WiFiManagerSetTestParamsAndCopyResponse");
  }
  objc_autoreleasePoolPop(v37);
  v9 = 0;
LABEL_84:
  objc_autoreleasePoolPop(v4);
  return v9;
}

void sub_10009E940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009E988(CFArrayRef *a1, void *a2)
{
  void *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;
  uint64_t v8;
  const void *v9;
  void *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFStringRef v13;
  CFDateRef v14;
  void *v15;
  void *v16;
  const void *v17;
  const void *v18;
  CFAbsoluteTime Current;
  void *v20;
  void *v21;
  const void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  const char *v26;
  void *v27;
  CFIndex Count;

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Checking password and network status for %@", "WiFiManagerCheckForUnexpectedPasswordDelete", sub_10002B088(a2));
  objc_autoreleasePoolPop(v4);
  if (CFArrayGetCount(a1[316]))
  {
    v24 = objc_autoreleasePoolPush();
    v25 = qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_41;
    Count = CFArrayGetCount(a1[316]);
    v26 = "%s: Already have remembered a network with a missing password, count: %ld";
LABEL_37:
    v27 = (void *)v25;
LABEL_40:
    objc_msgSend(v27, "WFLog:message:", 3, v26, "WiFiManagerCheckForUnexpectedPasswordDelete", Count);
    goto LABEL_41;
  }
  if (!sub_1000C5964((uint64_t)a2))
  {
    v24 = objc_autoreleasePoolPush();
    v25 = qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_41;
    Count = (CFIndex)sub_10002B088(a2);
    v26 = "%s: %@ does not require a password, disqualified from possible password-missing TTR";
    goto LABEL_37;
  }
  if (sub_10002DAB4((uint64_t)a2))
  {
    v24 = objc_autoreleasePoolPush();
    v25 = qword_10026DD20;
    if (!qword_10026DD20)
      goto LABEL_41;
    Count = (CFIndex)sub_10002B088(a2);
    v26 = "%s: %@ is an EAP network, disqualified from possible password-missing TTR";
    goto LABEL_37;
  }
  v5 = sub_10000B29C((CFArrayRef)a1);
  if (!v5)
  {
    v24 = objc_autoreleasePoolPush();
    v27 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v26 = "%s: null device managers array";
      goto LABEL_40;
    }
LABEL_41:
    objc_autoreleasePoolPop(v24);
    v12 = 0;
    v6 = 0;
    goto LABEL_21;
  }
  v6 = v5;
  ValueAtIndex = CFArrayGetValueAtIndex(v5, 0);
  if (!ValueAtIndex)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null device manager", "WiFiManagerCheckForUnexpectedPasswordDelete");
    goto LABEL_48;
  }
  v8 = (uint64_t)ValueAtIndex;
  v9 = (const void *)sub_100103560((uint64_t)ValueAtIndex);
  v10 = objc_autoreleasePoolPush();
  if (!v9)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Most recently joined network is null", "WiFiManagerCheckForUnexpectedPasswordDelete");
    goto LABEL_48;
  }
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Most recently joined network was: %@", "WiFiManagerCheckForUnexpectedPasswordDelete", v9);
  objc_autoreleasePoolPop(v10);
  v11 = sub_100103A48(v8, a2);
  if (!v11)
  {
    v10 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: no matching network in known networks list", "WiFiManagerCheckForUnexpectedPasswordDelete");
LABEL_48:
    objc_autoreleasePoolPop(v10);
    v12 = 0;
    goto LABEL_21;
  }
  v12 = v11;
  if (!CFEqual(v11, v9))
  {
LABEL_21:
    v14 = 0;
    goto LABEL_22;
  }
  v13 = sub_1000C37A0((CFDictionaryRef *)a2);
  if (v13)
  {
    v14 = (CFDateRef)v13;
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      v17 = sub_10002B088(v12);
      v18 = (const void *)sub_100103560(v8);
      objc_msgSend(v16, "WFLog:message:", 3, "%s: Not recording password for matchingNetworkCopy %@ and previously joined network %@", "WiFiManagerCheckForUnexpectedPasswordDelete", v17, sub_10002B088(v18));
    }
    objc_autoreleasePoolPop(v15);
    goto LABEL_22;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v14 = CFDateCreate(kCFAllocatorDefault, Current);
  sub_1000CA2C0(v12, v14);
  CFArrayAppendValue(a1[316], v12);
  v20 = objc_autoreleasePoolPush();
  v21 = (void *)qword_10026DD20;
  if (qword_10026DD20)
  {
    v22 = sub_10002B088(v12);
    objc_msgSend(v21, "WFLog:message:", 3, "%s: Recording that the password for %@ is not in the keychain. Network count with deleted passwords is now %ld", "WiFiManagerCheckForUnexpectedPasswordDelete", v22, CFArrayGetCount(a1[316]));
  }
  objc_autoreleasePoolPop(v20);
  if (v14)
  {
    CFRelease(v14);
    goto LABEL_21;
  }
LABEL_22:
  v23 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Status of networks with deleted keychain password, count: %ld", "WiFiManagerCheckForUnexpectedPasswordDelete", CFArrayGetCount(a1[316]));
  objc_autoreleasePoolPop(v23);
  if (v12)
    CFRelease(v12);
  if (v6)
    CFRelease(v6);
  if (v14)
    CFRelease(v14);
}

void sub_10009ED34(uint64_t a1, char a2)
{
  _QWORD v2[4];

  *(_BYTE *)(a1 + 1392) = a2;
  v2[0] = a1;
  v2[1] = 0xAAAAAAAA0000002ALL;
  v2[2] = 0;
  v2[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v2);
}

void sub_10009ED7C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  void *v5;
  _QWORD context[4];

  if (a1)
  {
    if (*(_DWORD *)(a1 + 1384) != a2
      || *(unsigned __int8 *)(a1 + 1388) != a3
      || *(unsigned __int8 *)(a1 + 1389) != a4
      || *(unsigned __int8 *)(a1 + 1390) != a5)
    {
      *(_DWORD *)(a1 + 1384) = a2;
      *(_BYTE *)(a1 + 1388) = a3;
      *(_BYTE *)(a1 + 1389) = a4;
      *(_BYTE *)(a1 + 1390) = a5;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000029;
      context[2] = 0;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: null manager", "WiFiManagerSetLQASettings");
    objc_autoreleasePoolPop(v5);
  }
}

void sub_10009EE54(uint64_t a1, uint64_t a2)
{
  void *v4;

  v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s", "WiFiManagerSetCoexMgrXpcObj");
    objc_autoreleasePoolPop(v4);
    *(_QWORD *)(a1 + 1320) = a2;
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: null manager", "WiFiManagerSetCoexMgrXpcObj");
    objc_autoreleasePoolPop(v4);
  }
}

void sub_10009EF00(uint64_t a1, int a2)
{
  void *v4;
  const char *v5;
  _QWORD context[4];

  v4 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v5 = "FALSE";
    if (a2)
      v5 = "TRUE";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: builtInReceiver = %s", "WiFiManagerSetBuiltInReceiver", v5);
  }
  objc_autoreleasePoolPop(v4);
  *(_DWORD *)(a1 + 1456) = a2 != 0;
  *(_DWORD *)(a1 + 1460) = 1;
  *(_BYTE *)(a1 + 1464) = 0;
  context[0] = a1;
  context[1] = 0xAAAAAAAA00000009;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
}

void sub_10009EFC4(uint64_t a1, double a2)
{
  void *v2;
  _QWORD context[4];
  double v4;

  v4 = a2;
  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000005ELL;
    context[2] = &v4;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "WiFiManagerSetNANOffHeadConnectionExpiry");
    objc_autoreleasePoolPop(v2);
  }
}

double sub_10009F064(const __CFArray *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  const void *ValueAtIndex;
  double v4;
  void *v6;

  v1 = sub_10000B29C(a1);
  if (!v1)
    return 0.0;
  v2 = v1;
  ValueAtIndex = CFArrayGetValueAtIndex(v1, 0);
  if (ValueAtIndex)
  {
    v4 = sub_100114768((uint64_t)ValueAtIndex);
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: deviceManager is NULL!", "WiFiManagerGetNANOffHeadConnectionExpiry");
    objc_autoreleasePoolPop(v6);
    v4 = 0.0;
  }
  CFRelease(v2);
  return v4;
}

void sub_10009F104(uint64_t a1, char a2, char a3)
{
  NSObject *v4;
  _QWORD v5[5];
  char v6;
  char v7;

  if (a1)
  {
    v4 = *(NSObject **)(a1 + 32);
    if (v4)
    {
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472;
      v5[2] = sub_10009F16C;
      v5[3] = &unk_100230878;
      v6 = a2;
      v5[4] = a1;
      v7 = a3;
      dispatch_async(v4, v5);
    }
  }
}

void sub_10009F16C(uint64_t a1)
{
  int v1;
  uint64_t v2;
  _QWORD v3[4];

  v1 = *(_BYTE *)(a1 + 40) != 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 1460) != v1 || *(unsigned __int8 *)(v2 + 1464) != *(unsigned __int8 *)(a1 + 41))
  {
    *(_DWORD *)(v2 + 1460) = v1;
    *(_BYTE *)(v2 + 1464) = *(_BYTE *)(a1 + 41);
    v3[0] = v2;
    v3[1] = 0xAAAAAAAA00000009;
    v3[2] = 0;
    v3[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(v2 + 104), (CFSetApplierFunction)sub_10002E0D4, v3);
  }
}

void sub_10009F1E8(uint64_t a1, char a2, char a3)
{
  NSObject *v4;
  _QWORD v5[5];
  char v6;
  char v7;

  if (a1)
  {
    v4 = *(NSObject **)(a1 + 32);
    if (v4)
    {
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472;
      v5[2] = sub_10009F250;
      v5[3] = &unk_100230878;
      v6 = a2;
      v7 = a3;
      v5[4] = a1;
      dispatch_async(v4, v5);
    }
  }
}

void sub_10009F250(uint64_t a1)
{
  void *v2;
  const char *v3;
  const char *v4;
  _BOOL4 v5;

  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
  {
    v3 = "Active";
    if (!*(_BYTE *)(a1 + 40))
      v3 = "Inactive";
    if (*(_BYTE *)(a1 + 41))
      v4 = "WiFi";
    else
      v4 = "Cellular";
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFi Calling registration %s on %s", "WiFiManagerWiFiCallingIMSRegistrationCallback_block_invoke", v3, v4);
  }
  objc_autoreleasePoolPop(v2);
  if (*(_BYTE *)(a1 + 40))
    v5 = *(_BYTE *)(a1 + 41) == 0;
  else
    v5 = 1;
  sub_10000A77C(*(_QWORD *)(a1 + 32), 0, *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 1162), v5);
}

void sub_10009F314(uint64_t a1, const void *a2, unsigned int a3, int a4, int a5)
{
  void *v10;
  const void *v11;
  CFTypeRef v12;
  int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  dispatch_time_t v18;
  void *v19;
  _QWORD context[4];

  *(_BYTE *)(a1 + 2088) = 1;
  context[0] = a1;
  context[1] = 0xAAAAAAAA0000004BLL;
  context[2] = 0;
  context[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  if (sub_1000092B8(a1))
  {
    sub_10009F5B8((id)a1);
    sub_10009F724(a1, a3);
    if (a3)
    {
      v10 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Enable AutoJoin On Companion AAJ trigger", "WiFiManagerSetCompanionAssistedAutoJoin");
      objc_autoreleasePoolPop(v10);
      sub_1000094BC(a1, 1);
    }
  }
  *(_BYTE *)(a1 + 1560) = a2 != 0;
  v11 = *(const void **)(a1 + 1568);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 1568) = 0;
  }
  if (a2)
    v12 = CFRetain(a2);
  else
    v12 = 0;
  *(_QWORD *)(a1 + 1568) = v12;
  v13 = *(unsigned __int8 *)(a1 + 1560);
  v14 = objc_autoreleasePoolPush();
  if (v13)
  {
    if (qword_10026DD20)
    {
      v15 = *(unsigned __int8 *)(a1 + 16);
      if (*(_BYTE *)(a1 + 16))
        v15 = *(_BYTE *)(a1 + 24) != 0;
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: is autojoin enabled %d", "WiFiManagerSetCompanionAssistedAutoJoin", v15);
    }
    objc_autoreleasePoolPop(v14);
    if (*(_BYTE *)(a1 + 16) && *(_BYTE *)(a1 + 24))
    {
      *(_DWORD *)(a1 + 1584) = a4;
      *(_DWORD *)(a1 + 1588) = a5;
      v17 = *(NSObject **)(a1 + 1576);
      v18 = dispatch_time(0, 30000000000);
      dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
      sub_10009F7C8(a1, a5, 1);
      v19 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ###START_CAAJ", "WiFiManagerSetCompanionAssistedAutoJoin");
      objc_autoreleasePoolPop(v19);
    }
  }
  else
  {
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: ###STOP_CAAJ", "WiFiManagerSetCompanionAssistedAutoJoin");
    objc_autoreleasePoolPop(v14);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1576), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    sub_10009F7C8(a1, 0, 0);
  }
  sub_10008488C(v16, 2, a1);
  sub_10008674C(a1);
  sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
}

void sub_10009F574(uint64_t a1)
{
  _QWORD v1[4];

  v1[0] = a1;
  v1[1] = 0xAAAAAAAA0000004BLL;
  v1[2] = 0;
  v1[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v1);
}

id sub_10009F5B8(id result)
{
  uint64_t v1;
  void *v2;
  void *v3;
  const char *v4;
  void *v5;
  void *v6;
  const char *v7;
  int v8;
  _QWORD context[4];

  if (result)
  {
    v1 = (uint64_t)result;
    v2 = objc_autoreleasePoolPush();
    v3 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (CFSetGetCount(*(CFSetRef *)(v1 + 144)))
        v4 = "present";
      else
        v4 = "not present";
      objc_msgSend(v3, "WFLog:message:", 3, "%s: background client %s", "WiFiManagerUpdateAlwaysOnWiFiParameters", v4);
    }
    objc_autoreleasePoolPop(v2);
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)qword_10026DD20;
    if (qword_10026DD20)
    {
      if (CFSetGetCount(*(CFSetRef *)(v1 + 168)))
        v7 = "present";
      else
        v7 = "not present";
      objc_msgSend(v6, "WFLog:message:", 3, "%s: Cloud client %s", "WiFiManagerUpdateAlwaysOnWiFiParameters", v7);
    }
    objc_autoreleasePoolPop(v5);
    if (sub_1000092B8(v1))
      v8 = 1;
    else
      v8 = sub_10009F84C(v1);
    sub_1000939D8(v1, v8);
    context[0] = v1;
    context[1] = 0xAAAAAAAA00000049;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(v1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    return objc_msgSend(*(id *)(v1 + 2416), "updateWowState:lpasState:lowPowerState:batterySaverState:", *(_BYTE *)(v1 + 1160) != 0, *(_BYTE *)(v1 + 1176) != 0, *(_BYTE *)(v1 + 1162) != 0, *(_QWORD *)(v1 + 1600) != 0);
  }
  return result;
}

void sub_10009F724(uint64_t a1, unsigned int a2)
{
  void *v4;
  _QWORD context[4];

  if (a1)
  {
    *(_BYTE *)(a1 + 2253) = a2;
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Updating companion WiFi state %d\n", "WiFiManagerSetCompanionWiFiState", a2);
    objc_autoreleasePoolPop(v4);
    context[0] = a1;
    context[1] = 0xAAAAAAAA00000075;
    context[2] = 0;
    context[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
  }
}

void sub_10009F7C8(uint64_t a1, int a2, char a3)
{
  _QWORD v3[4];

  if (a1)
  {
    *(_DWORD *)(a1 + 2248) = a2;
    *(_BYTE *)(a1 + 2252) = a3;
    v3[0] = a1;
    v3[1] = 0xAAAAAAAA00000074;
    v3[2] = 0;
    v3[3] = 1;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v3);
  }
}

uint64_t sub_10009F818(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 144)))
    return 1;
  else
    return (uint64_t)objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isBackgroundActivityRegistered");
}

uint64_t sub_10009F84C(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 168)))
    return 1;
  else
    return (uint64_t)objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isWiFiBoundActivityRegistered");
}

uint64_t sub_10009F880(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 152)))
    return 1;
  else
    return (uint64_t)objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isForegroundActivityRegistered");
}

uint64_t sub_10009F8B4(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 1168)))
    return 1;
  else
    return (uint64_t)objc_msgSend(+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"), "isWoWActivityRegistered");
}

uint64_t sub_10009F8E8(uint64_t a1)
{
  if (sub_10009F880(a1) || sub_10009F818(a1) || sub_10009F8B4(a1))
    return 1;
  else
    return sub_10009F84C(a1);
}

uint64_t sub_10009F938(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1552);
}

uint64_t sub_10009F940(_QWORD *a1)
{
  uint64_t v1;
  void *v2;

  v1 = sub_100030300(a1, CFSTR("WiFiCountryBandSupportKey"), 3);
  v2 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: WiFiCC : CountryBandSupport = %d", "WiFiManagerGetCountryBandSupport", v1);
  objc_autoreleasePoolPop(v2);
  return v1;
}

void sub_10009F9BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v6;
  _QWORD context[10];

  if (a2 <= 0x64)
  {
    context[8] = v2;
    context[9] = v3;
    if (*(_DWORD *)(a1 + 1552) != (_DWORD)a2)
    {
      kdebug_trace(731381816, 0, 0, 0, 0);
      v6 = objc_autoreleasePoolPush();
      if (qword_10026DD20)
        objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "setting thermal index from %d to %d", *(unsigned int *)(a1 + 1552), a2);
      objc_autoreleasePoolPop(v6);
      *(_DWORD *)(a1 + 1552) = a2;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000044;
      context[2] = a2;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
}

void sub_10009FA88(uint64_t a1, int a2, const void *a3)
{
  void *v6;

  kdebug_trace(731381764, 0, 0, 0, 0);
  v6 = objc_autoreleasePoolPush();
  if (qword_10026DD20)
    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "InCar notificaion received. UUID %@", a3);
  objc_autoreleasePoolPop(v6);
  sub_10009FB18(a1, a2, a3);
}

void sub_10009FB18(uint64_t a1, int a2, CFTypeRef cf)
{
  const void *v6;
  NSObject *v7;
  dispatch_time_t v8;
  uint64_t v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  void *ValueAtIndex;
  void *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  const void *v22;
  uint64_t context;
  unint64_t v24;
  unint64_t v25;

  if (*(unsigned __int8 *)(a1 + 1504) != a2)
  {
    v6 = *(const void **)(a1 + 1512);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 1512) = 0;
    }
    *(_BYTE *)(a1 + 1504) = a2;
    if (a2)
    {
      *(_QWORD *)(a1 + 1512) = CFRetain(cf);
      if (*(_BYTE *)(a1 + 1329) && !*(_BYTE *)(a1 + 26))
      {
        *(_BYTE *)(a1 + 1504) = 0;
        *(_BYTE *)(a1 + 1520) = 1;
        return;
      }
      *(_BYTE *)(a1 + 1520) = 0;
      v7 = *(NSObject **)(a1 + 1536);
      v8 = dispatch_time(0, 30000000000);
      dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
      context = a1;
      v24 = 0xAAAAAA0100000042;
      v25 = 0xAAAAAAAA00000001;
    }
    else
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1536), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      context = a1;
      v24 = 0xAAAAAA0000000042;
      v25 = 0xAAAAAAAA00000000;
    }
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, &context);
    sub_10008488C(v9, 2, a1);
    sub_10008674C(a1);
    if (!*(_BYTE *)(a1 + 1504))
      goto LABEL_17;
    v10 = *(const __CFArray **)(a1 + 224);
    Count = CFArrayGetCount(v10);
    if (Count < 1)
      goto LABEL_17;
    v12 = Count;
    v13 = 0;
    while (1)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v13);
      if (ValueAtIndex)
      {
        v15 = ValueAtIndex;
        v16 = (const __CFString *)sub_10002BE64((uint64_t)ValueAtIndex, CFSTR("CARPLAY_UUID"));
        if (v16)
        {
          v17 = *(const __CFString **)(a1 + 1512);
          if (v17)
          {
            if (CFStringCompare(v16, v17, 0) == kCFCompareEqualTo)
              break;
          }
        }
      }
      if (v12 == ++v13)
        goto LABEL_17;
    }
    if (sub_100007F24((uint64_t)v15)
      || (v18 = (const __CFString *)sub_10002BE64((uint64_t)v15, CFSTR("networkDisabledReason"))) == 0
      || CFStringCompare(v18, CFSTR("UserDisabledCarPlay"), 0))
    {
LABEL_17:
      sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
    }
    else
    {
      sub_10002C478((uint64_t)v15, CFSTR("enabled"), kCFBooleanTrue);
      sub_100099EA4(a1, v15, 1u);
      v19 = objc_autoreleasePoolPush();
      v20 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        v21 = *(_QWORD *)(a1 + 1512);
        v22 = sub_10002B088(v15);
        objc_msgSend(v20, "WFLog:message:", 3, "%s: Enabling CarPlay auto join for UUID %@ network %@", "__WiFiManagerEnableAutoJoinForCarPlay", v21, v22, context, v24, v25);
      }
      objc_autoreleasePoolPop(v19);
    }
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      sub_100014478(a1);
  }
}

void sub_10009FDA0(const __CFArray *a1, const void *a2)
{
  void *v4;
  void *v5;
  CFAbsoluteTime Current;
  CFDateRef v7;
  CFDateRef v8;
  void *v9;

  if (a1)
  {
    v4 = sub_10009FEE0(a1);
    if (v4)
    {
      v5 = v4;
      if (sub_1000CA608((uint64_t)v4) == 1 && sub_100007F24((uint64_t)v5))
      {
        Current = CFAbsoluteTimeGetCurrent();
        v7 = CFDateCreate(kCFAllocatorDefault, Current);
        if (v7)
        {
          v8 = v7;
          sub_10002C478((uint64_t)v5, CFSTR("networkDisabledTimestamp"), v7);
          CFRelease(v8);
        }
        sub_10002C478((uint64_t)v5, CFSTR("networkDisabledClientName"), a2);
        sub_10002C478((uint64_t)v5, CFSTR("networkDisabledReason"), CFSTR("UserDisabledCarPlay"));
        sub_10002C478((uint64_t)v5, CFSTR("enabled"), kCFBooleanFalse);
        sub_100099EA4((uint64_t)a1, v5, 1u);
        v9 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Disabling CarPlay auto join until next incar comes.", "WiFiManagerDisableAutoJoinForCarPlay");
        objc_autoreleasePoolPop(v9);
      }
      CFRelease(v5);
    }
  }
}

void *sub_10009FEE0(const __CFArray *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  const void *ValueAtIndex;
  uint64_t v7;
  const void *v8;
  void *v9;
  void *v10;
  void *v12;

  if (!a1)
    return 0;
  v1 = sub_10000B29C(a1);
  if (!v1)
  {
    v12 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: failed to get device managers", "__WiFiManagerCopyCurrentNetwork");
    objc_autoreleasePoolPop(v12);
    return 0;
  }
  v2 = v1;
  Count = CFArrayGetCount(v1);
  if (Count < 1)
  {
LABEL_9:
    v10 = 0;
  }
  else
  {
    v4 = Count;
    v5 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, v5);
      v7 = sub_1000161D4((uint64_t)ValueAtIndex);
      if (v7)
      {
        v8 = (const void *)sub_100029860(v7);
        if (v8)
        {
          v9 = sub_1000169FC((uint64_t)ValueAtIndex, v8);
          if (v9)
            break;
        }
      }
      if (v4 == ++v5)
        goto LABEL_9;
    }
    v10 = v9;
  }
  CFRelease(v2);
  return v10;
}

void sub_10009FFC4(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  const __CFString *Value;
  const __CFString *v6;
  void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  int v11;

  if (a1 && a2)
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: params %@", "WiFiManagerSetCarplayParams", a2);
    objc_autoreleasePoolPop(v4);
    Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("carplayNotificationKey"));
    if (Value)
    {
      v6 = Value;
      if (CFStringCompare(Value, CFSTR("carplayNotificationInCar"), 0))
      {
        if (CFStringCompare(v6, CFSTR("carplayNotificationOutOfCar"), 0))
        {
          v7 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: unknown notification %@", "WiFiManagerSetCarplayParams", v6);
LABEL_16:
          objc_autoreleasePoolPop(v7);
          return;
        }
        v10 = a1;
        v11 = 0;
        v9 = 0;
      }
      else
      {
        v8 = CFDictionaryGetValue(a2, CFSTR("CARPLAY_UUID"));
        if (!v8)
        {
          v7 = objc_autoreleasePoolPush();
          if (qword_10026DD20)
            objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: UUID is missing for %@", "WiFiManagerSetCarplayParams", v6);
          goto LABEL_16;
        }
        v9 = v8;
        v10 = a1;
        v11 = 1;
      }
      sub_10009FB18(v10, v11, v9);
    }
  }
}

__CFDictionary *sub_1000A0138(uint64_t a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  const __CFString *v4;
  CFBooleanRef v5;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v3 = Mutable;
  if (Mutable)
  {
    v4 = CFSTR("carplayState");
    if (*(_BYTE *)(a1 + 1504))
    {
      CFDictionarySetValue(Mutable, CFSTR("carplayState"), kCFBooleanTrue);
      v5 = *(CFBooleanRef *)(a1 + 1512);
      v4 = CFSTR("CARPLAY_UUID");
    }
    else
    {
      v5 = kCFBooleanFalse;
    }
    CFDictionarySetValue(v3, v4, v5);
  }
  return v3;
}

void sub_1000A01D0(uint64_t a1, uint64_t a2)
{
  sub_1000BA668(*(_QWORD *)(a1 + 32), a2);
}

void sub_1000A01D8(uint64_t a1)
{
  sub_1000BA668(*(_QWORD *)(a1 + 32), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 1592));
}

void sub_1000A01E4(_QWORD *a1, CFDictionaryRef theDict)
{
  _QWORD *v3;
  const __CFString *Value;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const void *v8;
  const void *v9;
  const __SCPreferences *v10;
  const __SCPreferences *v11;
  void *v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFIndex Count;
  CFIndex v16;
  CFIndex v17;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef *v19;
  const __CFString *v20;
  const __SCPreferences *v21;
  void *v22;
  const __CFArray *v23;
  const __CFArray *v24;
  const __CFArray *MutableCopy;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  void *v34;
  void *v35;
  __CFDictionary *v36;
  __CFDictionary *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  _QWORD *v45;
  const __SCPreferences *v46;
  void *v47;

  if (!a1 || !theDict)
    return;
  v3 = a1;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("LEAKY_AP_SSID"));
  if (!Value)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SSID is NULL", "WiFiManagerStoreLeakyAPData");
    goto LABEL_62;
  }
  v5 = Value;
  v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("LEAKY_AP_BSSID"));
  if (!v6)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BSSID is NULL", "WiFiManagerStoreLeakyAPData");
    goto LABEL_62;
  }
  v7 = v6;
  v8 = CFDictionaryGetValue(theDict, CFSTR("LEAKY_AP_LEARNED_DATA"));
  if (!v8)
  {
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: LEAKY_AP_LEARNED_DATA is NULL", "WiFiManagerStoreLeakyAPData");
LABEL_62:
    objc_autoreleasePoolPop(v42);
    return;
  }
  v9 = v8;
  v10 = (const __SCPreferences *)sub_10001D964(v3, CFSTR("List of known networks"));
  if (!v10)
    return;
  v11 = v10;
  if (!sub_100007620(v10))
    return;
  v12 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerStoreLeakyAPData");
  v13 = (const __CFArray *)sub_10008674C((uint64_t)v3);
  if (!v13)
  {
    LODWORD(v16) = 0;
    goto LABEL_64;
  }
  v14 = v13;
  Count = CFArrayGetCount(v13);
  v16 = Count;
  if (!Count)
  {
LABEL_64:
    v23 = 0;
    goto LABEL_47;
  }
  v47 = v12;
  if (Count < 1)
  {
LABEL_15:
    v21 = v11;
    v22 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: SSID %@ not found in known networks list", "WiFiManagerStoreLeakyAPData", v5);
    objc_autoreleasePoolPop(v22);
    LODWORD(v16) = 0;
    v23 = 0;
  }
  else
  {
    v17 = 0;
    while (1)
    {
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v14, v17);
      if (ValueAtIndex)
      {
        v19 = ValueAtIndex;
        v20 = (const __CFString *)sub_10002B088(ValueAtIndex);
        if (CFStringCompare(v5, v20, 0) == kCFCompareEqualTo)
          break;
      }
      if (v16 == ++v17)
        goto LABEL_15;
    }
    v24 = (const __CFArray *)sub_10002B750((uint64_t)v19);
    if (!v24)
    {
      v46 = v11;
      v32 = (const __CFString *)sub_10002BE64((uint64_t)v19, CFSTR("BSSID"));
      if (!v32)
      {
        v44 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cannot find BSSID in the network object", "WiFiManagerStoreLeakyAPData");
        objc_autoreleasePoolPop(v44);
        LODWORD(v16) = 0;
        v23 = 0;
LABEL_55:
        v11 = v46;
        goto LABEL_46;
      }
      v33 = v32;
      if (CFStringCompare(v7, v32, 0))
      {
        v34 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: BSSID doesn't match - reported %@, from known network %@", "WiFiManagerStoreLeakyAPData", v7, v33);
        v35 = v34;
      }
      else
      {
        sub_10002C478((uint64_t)v19, CFSTR("LEAKY_AP_LEARNED_DATA"), v9);
        v39 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updated LEAKY_AP_LEARNED_DATA for network %@ - %@", "WiFiManagerStoreLeakyAPData", v5, v7);
        v35 = v39;
      }
      objc_autoreleasePoolPop(v35);
      v23 = 0;
LABEL_44:
      v11 = v46;
      goto LABEL_45;
    }
    MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, v24);
    v23 = MutableCopy;
    if (!MutableCopy)
    {
      LODWORD(v16) = 0;
      goto LABEL_46;
    }
    v45 = v3;
    v26 = CFArrayGetCount(MutableCopy);
    if (v26)
    {
      v27 = v26;
      if (v26 >= 1)
      {
        v46 = v11;
        v28 = 0;
        while (1)
        {
          v29 = (const __CFDictionary *)CFArrayGetValueAtIndex(v23, v28);
          if (v29)
          {
            v30 = v29;
            v31 = (const __CFString *)CFDictionaryGetValue(v29, CFSTR("BSSID"));
            if (!v31)
            {
              v41 = objc_autoreleasePoolPush();
              if (qword_10026DD20)
                objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: cannot find BSSID in the network object", "WiFiManagerStoreLeakyAPData");
              objc_autoreleasePoolPop(v41);
              LODWORD(v16) = 0;
              v3 = v45;
              goto LABEL_55;
            }
            if (CFStringCompare(v7, v31, 0) == kCFCompareEqualTo)
            {
              v36 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v30);
              if (v36)
              {
                v37 = v36;
                CFDictionarySetValue(v36, CFSTR("LEAKY_AP_LEARNED_DATA"), v9);
                v38 = objc_autoreleasePoolPush();
                if (qword_10026DD20)
                  objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: updated LEAKY_AP_LEARNED_DATA for network %@ - %@", "WiFiManagerStoreLeakyAPData", v5, v7);
                objc_autoreleasePoolPop(v38);
                CFArraySetValueAtIndex(v23, v28, v37);
                CFRelease(v37);
                sub_10002C478((uint64_t)v19, CFSTR("networkKnownBSSListKey"), v23);
              }
LABEL_39:
              v3 = v45;
              goto LABEL_44;
            }
          }
          if (v27 == ++v28)
            goto LABEL_39;
        }
      }
      v3 = v45;
LABEL_45:
      LODWORD(v16) = sub_100095610((uint64_t)v3, v14);
      sub_100094200((uint64_t)v3, v19, 0);
      goto LABEL_46;
    }
    v21 = v11;
    v43 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: known BSSIDs list is empty for network %@!", "WiFiManagerStoreLeakyAPData", v5);
    objc_autoreleasePoolPop(v43);
    LODWORD(v16) = 0;
  }
  v11 = v21;
LABEL_46:
  v12 = v47;
LABEL_47:
  sub_1000076D4(v11, v16);

  if (v23)
    CFRelease(v23);
  if ((_DWORD)v16)
    sub_10008488C(v40, 2, (uint64_t)v3);
}

void sub_1000A0774(uint64_t a1, CFArrayRef theArray)
{
  CFMutableArrayRef MutableCopy;
  _QWORD v5[4];

  MutableCopy = *(CFMutableArrayRef *)(a1 + 1608);
  if (theArray)
  {
    if (MutableCopy)
    {
      CFRelease(MutableCopy);
      *(_QWORD *)(a1 + 1608) = 0;
    }
    MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, theArray);
    *(_QWORD *)(a1 + 1608) = MutableCopy;
  }
  v5[0] = a1;
  v5[1] = 0xAAAAAAAA00000043;
  v5[2] = MutableCopy;
  v5[3] = 1;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, v5);
}

uint64_t sub_1000A07F8(const __SCPreferences *a1, void *a2)
{
  uint64_t v2;
  __CFArray *v3;
  uint64_t v4;
  __CFArray *v6;
  const __SCPreferences *v7;
  void *v8;
  const __CFArray *v9;
  const __CFString *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const void *ValueAtIndex;
  const __CFString *v15;
  const char *v16;
  void *v17;
  void *newValues;
  CFRange v20;

  v2 = (uint64_t)a1;
  v3 = 0;
  v4 = 0;
  newValues = a2;
  if (a1)
  {
    v6 = 0;
    if (a2)
    {
      a1 = (const __SCPreferences *)sub_10001D964(a1, CFSTR("List of policies"));
      if (a1 && (v7 = a1, a1 = sub_100007620(a1), (_DWORD)a1))
      {
        v8 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerAddPolicy");
        v9 = sub_10001D90C((_QWORD *)v2, CFSTR("List of policies"));
        v6 = sub_10003F69C(v9);
        if (v6 && (v10 = (const __CFString *)sub_10003F540((uint64_t)a2), Count = CFArrayGetCount(v6), Count >= 1))
        {
          v12 = Count;
          v13 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v6, v13);
            if (ValueAtIndex)
            {
              v15 = (const __CFString *)sub_10003F540((uint64_t)ValueAtIndex);
              if (CFStringCompare(v15, v10, 0) == kCFCompareEqualTo)
                break;
            }
            if (v12 == ++v13)
              goto LABEL_11;
          }
          v20.location = v13;
          v20.length = 1;
          CFArrayReplaceValues(v6, v20, (const void **)&newValues, 0);
          v16 = "Replaced";
        }
        else
        {
LABEL_11:
          CFArrayAppendValue(v6, a2);
          v16 = "Added";
        }
        v3 = sub_10003F754(v6);
        if (v3)
        {
          v4 = sub_100087488((_QWORD *)v2, CFSTR("List of policies"), v3, 1);
          if ((_DWORD)v4)
          {
            v17 = objc_autoreleasePoolPush();
            if (qword_10026DD20)
              objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s %@ to policies list", v16, sub_10003F540((uint64_t)newValues));
            objc_autoreleasePoolPop(v17);
          }
        }
        else
        {
          v4 = 0;
        }
        sub_1000076D4(v7, v4);

      }
      else
      {
        v4 = 0;
        v3 = 0;
        v6 = 0;
      }
    }
  }
  else
  {
    v6 = 0;
  }
  sub_10008488C((uint64_t)a1, 2, v2);
  sub_10008674C(v2);
  sub_100086B84(v2, *(const __CFArray **)(v2 + 224));
  if (v3)
    CFRelease(v3);
  if (v6)
    CFRelease(v6);
  return v4;
}

uint64_t sub_1000A0A10(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  const __SCPreferences *Count;
  const __SCPreferences *v6;
  uint64_t v7;
  __CFArray *v8;
  uint64_t v9;
  const __SCPreferences *v10;
  void *v11;
  const __CFArray *v12;
  CFIndex v13;
  const void *ValueAtIndex;
  __CFArray *v15;
  __CFArray *v16;
  void *v17;
  void *v18;

  TypeID = CFStringGetTypeID();
  Count = (const __SCPreferences *)CFGetTypeID(a2);
  if (!a1)
    goto LABEL_26;
  v6 = Count;
  Count = (const __SCPreferences *)CFArrayGetCount(*(CFArrayRef *)(a1 + 1608));
  v7 = 0;
  v8 = 0;
  if (!a2)
    goto LABEL_23;
  v9 = (uint64_t)Count;
  if (!Count)
    goto LABEL_23;
  Count = (const __SCPreferences *)sub_10001D964((_QWORD *)a1, CFSTR("List of policies"));
  if (!Count || (v10 = Count, Count = sub_100007620(Count), !(_DWORD)Count))
  {
LABEL_26:
    v8 = 0;
    v7 = 0;
    goto LABEL_23;
  }
  v11 = (void *)sub_10001E1C8((uint64_t)"WiFiManagerRemovePolicy");
  v12 = sub_10001D90C((_QWORD *)a1, CFSTR("List of policies"));
  v8 = sub_10003F69C(v12);
  if (!v8)
    goto LABEL_27;
  if (v9 >= 1)
  {
    v13 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v8, v13);
      if ((const __SCPreferences *)TypeID == v6)
        ValueAtIndex = sub_10003F540((uint64_t)ValueAtIndex);
      if (CFEqual(ValueAtIndex, a2))
        break;
      if (v9 == ++v13)
        goto LABEL_15;
    }
    CFArrayRemoveValueAtIndex(v8, v13);
  }
LABEL_15:
  v15 = sub_10003F754(v8);
  if (v15)
  {
    v16 = v15;
    v7 = sub_100087488((_QWORD *)a1, CFSTR("List of policies"), v15, 1);
    CFRelease(v16);
    if ((_DWORD)v7)
    {
      v17 = objc_autoreleasePoolPush();
      v18 = (void *)qword_10026DD20;
      if (qword_10026DD20)
      {
        if ((const __SCPreferences *)TypeID != v6)
          a2 = sub_10003F540((uint64_t)a2);
        objc_msgSend(v18, "WFLog:message:", 3, "Removed %@ from policies list", a2);
      }
      objc_autoreleasePoolPop(v17);
    }
  }
  else
  {
LABEL_27:
    v7 = 0;
  }
  sub_1000076D4(v10, v7);

LABEL_23:
  sub_10008488C((uint64_t)Count, 2, a1);
  sub_10008674C(a1);
  sub_100086B84(a1, *(const __CFArray **)(a1 + 224));
  if (v8)
    CFRelease(v8);
  return v7;
}

CFArrayRef sub_1000A0C00(uint64_t a1)
{
  const __CFArray *v2;

  v2 = *(const __CFArray **)(a1 + 1608);
  if (v2 && CFArrayGetCount(v2))
    return CFArrayCreateCopy(kCFAllocatorDefault, *(CFArrayRef *)(a1 + 1608));
  else
    return 0;
}

void sub_1000A0C4C(uint64_t a1, int a2)
{
  void *v4;
  const __CFString *v5;
  void *v6;
  const char *v7;
  _QWORD *v8;
  void *v9;
  const void *v10;
  void *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef *v18;
  void *v19;
  const void *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex j;
  CFDictionaryRef *v26;
  CFDictionaryRef *v27;
  const __CFString *v28;
  void *v29;
  _BOOL4 v30;
  uint64_t v31;
  void *v32;

  v4 = objc_autoreleasePoolPush();
  v5 = (const __CFString *)sub_10001D90C((_QWORD *)a1, CFSTR("kWiFiWhitelistingUUIDKey"));
  if ((a2 != 0) == (v5 == 0))
  {
    v32 = v4;
    if (a2)
    {
      v8 = sub_10003F3FC(kCFAllocatorDefault, +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 1), 0, 0);
      if (v8)
      {
        v9 = v8;
        v10 = sub_10003F540((uint64_t)v8);
        v11 = objc_autoreleasePoolPush();
        if (qword_10026DD20)
          objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: created restriction policy with UUID %@", "WiFiManagerEnableNetworksWhitelisting", v10);
        objc_autoreleasePoolPop(v11);
        sub_1000A07F8((const __SCPreferences *)a1, v9);
        v12 = (const __CFArray *)sub_10008674C(a1);
        if (v12)
        {
          v13 = v12;
          v31 = (uint64_t)v9;
          Count = CFArrayGetCount(v12);
          if (Count >= 1)
          {
            v15 = Count;
            for (i = 0; i != v15; ++i)
            {
              ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v13, i);
              if (ValueAtIndex)
              {
                v18 = ValueAtIndex;
                if (sub_1000C5378((uint64_t)ValueAtIndex))
                {
                  sub_10002C478((uint64_t)v18, CFSTR("PolicyUUID"), v10);
                  sub_100094200(a1, v18, 0);
                  v19 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Added policyUUID %@ to network %@", "WiFiManagerEnableNetworksWhitelisting", v10, sub_10002B088(v18));
                  objc_autoreleasePoolPop(v19);
                }
              }
            }
          }
          sub_100095610(a1, v13);
          sub_100007FDC(a1, 1, 1, 1);
          v9 = (void *)v31;
          v20 = sub_10003F540(v31);
          sub_100093FA0((_QWORD *)a1, CFSTR("kWiFiWhitelistingUUIDKey"), v20);
          sub_1000A101C(a1, 0);
        }
        CFRelease(v9);
        v4 = v32;
      }
    }
    else
    {
      v21 = (const __CFArray *)sub_10008674C(a1);
      if (v21)
      {
        v22 = v21;
        v23 = CFArrayGetCount(v21);
        if (v23 >= 1)
        {
          v24 = v23;
          for (j = 0; j != v24; ++j)
          {
            v26 = (CFDictionaryRef *)CFArrayGetValueAtIndex(v22, j);
            if (v26)
            {
              v27 = v26;
              v28 = (const __CFString *)sub_10002BE64((uint64_t)v26, CFSTR("PolicyUUID"));
              if (v28)
              {
                if (CFStringCompare(v28, v5, 0) == kCFCompareEqualTo)
                {
                  sub_10002C478((uint64_t)v27, CFSTR("PolicyUUID"), 0);
                  sub_100094200(a1, v27, 0);
                  v29 = objc_autoreleasePoolPush();
                  if (qword_10026DD20)
                    objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Removed policyUUID %@ from network %@", "WiFiManagerEnableNetworksWhitelisting", v5, sub_10002B088(v27));
                  objc_autoreleasePoolPop(v29);
                }
              }
            }
          }
        }
        sub_100095610(a1, v22);
        sub_100007FDC(a1, 1, 1, 1);
        sub_1000A0A10(a1, v5);
        sub_100093FA0((_QWORD *)a1, CFSTR("kWiFiWhitelistingUUIDKey"), 0);
        if (byte_10026DD60)
          v30 = 0;
        else
          v30 = (*(_DWORD *)(a1 + 112) - 1) < 3;
        sub_1000A101C(a1, v30);
      }
    }
  }
  else
  {
    v6 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
    {
      v7 = "TRUE";
      if (!a2)
        v7 = "FALSE";
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: Nothing changed. restrictionUUID %@ and isWhitelistingEnabled %s", "WiFiManagerEnableNetworksWhitelisting", v5, v7);
    }
    objc_autoreleasePoolPop(v6);
  }
  objc_autoreleasePoolPop(v4);
}

void sub_1000A101C(uint64_t a1, int a2)
{
  void *v2;
  _QWORD context[4];
  char v4;

  v4 = a2;
  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 2120) != a2)
    {
      *(_BYTE *)(a1 + 2120) = a2;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000053;
      context[2] = &v4;
      context[3] = 1;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_10002E0D4, context);
    }
  }
  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 4, "%s: manager ref is null", "__WiFiManagerSetAvailabilityEngineIsEnabled");
    objc_autoreleasePoolPop(v2);
  }
}

void sub_1000A10CC(int a1, const void *a2, CLLocationDegrees a3, CLLocationDegrees a4, double a5, const void *a6)
{
  const void *v11;
  const void *v12;
  CFMutableArrayRef Mutable;
  __CFArray *v14;
  const __CFArray *v15;
  const __CFArray *v16;
  CFIndex v17;
  const __CFDictionary *v18;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v20;
  const void *Value;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v23;
  id v24;
  CLLocationCoordinate2D v25;
  id v26;
  const void *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  const __CFNumber *v30;
  id v31;
  CLLocationCoordinate2D v32;
  id v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  void *v42;
  double v43;
  CLLocationDegrees v44;
  CLLocationDegrees valuePtr;

  if (a2 && a6)
  {
    v11 = sub_10002BE64((uint64_t)a2, CFSTR("BSSID"));
    if (v11)
    {
      v12 = v11;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (!Mutable)
        return;
      v14 = Mutable;
      v15 = (const __CFArray *)sub_10002BE64((uint64_t)a2, CFSTR("networkKnownBSSListKey"));
      if (!v15)
        goto LABEL_28;
      v16 = v15;
      if (CFArrayGetCount(v15) < 1)
        goto LABEL_28;
      v17 = 0;
      v18 = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v17);
        if (ValueAtIndex)
        {
          v20 = ValueAtIndex;
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSSID"));
          if (Value)
          {
            if (CFEqual(Value, v12))
              v18 = v20;
            else
              CFArrayAppendValue(v14, v20);
          }
        }
        ++v17;
      }
      while (v17 < CFArrayGetCount(v16));
      if (!v18)
        goto LABEL_28;
      MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v18);
      if (!MutableCopy)
        goto LABEL_28;
      v23 = MutableCopy;
      v24 = objc_alloc((Class)CLLocation);
      v25 = CLLocationCoordinate2DMake(a3, a4);
      v26 = objc_msgSend(v24, "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:", a6, v25.latitude, v25.longitude, 0.0, a5, 0.0);
      v27 = CFDictionaryGetValue(v23, CFSTR("networkLocnTimestamp"));
      if (+[WiFiLocationManager isLocationValid:uptoSeconds:requiredAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:requiredAccuracy:", v26, 60.0, 1.79769313e308))
      {
        if (+[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:](WiFiLocationManager, "isLocationValid:uptoSeconds:isHighAccuracy:", v26, 1, 60.0)|| !v27)
        {
          goto LABEL_24;
        }
        valuePtr = 0.0;
        v28 = (const __CFNumber *)CFDictionaryGetValue(v23, CFSTR("networkLocnLat"));
        CFNumberGetValue(v28, kCFNumberDoubleType, &valuePtr);
        v44 = 0.0;
        v29 = (const __CFNumber *)CFDictionaryGetValue(v23, CFSTR("networkLocnLong"));
        CFNumberGetValue(v29, kCFNumberDoubleType, &v44);
        v43 = 0.0;
        v30 = (const __CFNumber *)CFDictionaryGetValue(v23, CFSTR("networkLocnAccuracy"));
        CFNumberGetValue(v30, kCFNumberDoubleType, &v43);
        v31 = objc_alloc((Class)CLLocation);
        v32 = CLLocationCoordinate2DMake(valuePtr, v44);
        v33 = objc_msgSend(v31, "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:", v27, v32.latitude, v32.longitude, 0.0, v43, 0.0);
        objc_msgSend(v33, "horizontalAccuracy");
        v35 = v34;
        objc_msgSend(v26, "horizontalAccuracy");
        if (v35 <= v36)
        {
          objc_msgSend(v33, "distanceFromLocation:", v26);
          v38 = v37;
          objc_msgSend(v33, "horizontalAccuracy");
          v40 = v38 - v39;
          objc_msgSend(v26, "horizontalAccuracy");
          if (v40 - v41 > 0.0)
          {

LABEL_24:
            CFDictionarySetValue(v23, CFSTR("networkLocnLat"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a3));
            CFDictionarySetValue(v23, CFSTR("networkLocnLong"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a4));
            CFDictionarySetValue(v23, CFSTR("networkLocnAccuracy"), +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a5));
            CFDictionarySetValue(v23, CFSTR("networkLocnTimestamp"), a6);
            CFArrayAppendValue(v14, v23);
            sub_10002C478((uint64_t)a2, CFSTR("networkKnownBSSListKey"), v14);
LABEL_27:
            CFRelease(v23);
LABEL_28:
            CFRelease(v14);
            return;
          }
        }

      }
      goto LABEL_27;
    }
    v42 = objc_autoreleasePoolPush();
    if (qword_10026DD20)
      objc_msgSend((id)qword_10026DD20, "WFLog:message:", 3, "%s: failed to get BSSID from %@", "WiFiManagerUpdateBSSLocation", sub_10002B088(a2));
    objc_autoreleasePoolPop(v42);
  }
}

