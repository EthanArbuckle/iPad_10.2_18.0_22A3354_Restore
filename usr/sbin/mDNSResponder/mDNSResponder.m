int main(int argc, const char **argv, const char **envp)
{
  const char *v3;
  os_log_t v6;
  BOOL v7;
  os_log_t v8;
  os_log_t v9;
  os_log_t v10;
  os_log_t v11;
  os_log_t v12;
  os_log_t v13;
  os_log_t v14;
  os_log_t v15;
  os_log_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  const char *v28;
  const char *v29;
  int v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  int v40;
  _QWORD *v41;
  uint64_t v42;
  const __CFString *v43;
  const __CFString *v44;
  const __CFURL *v45;
  __CFReadStream *v46;
  __CFReadStream *v47;
  NSObject **v48;
  CFPropertyListRef v49;
  CFTypeID v50;
  int Code;
  unsigned int v52;
  const __CFNumber *Value;
  const __CFNumber *v54;
  CFTypeID v55;
  int64_t v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  NSObject *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  const char *v85;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  NSObject *v95;
  os_log_type_t v96;
  uint32_t v97;
  kern_return_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t i;
  _QWORD *v114;
  uint64_t v115;
  int *v116;
  char *v117;
  _OWORD *v118;
  char *v119;
  _DWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  _DWORD *v126;
  _UNKNOWN **v127;
  void (*v128)(_DWORD *);
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  NSObject *v135;
  int v137;
  _BYTE *v138;
  _BYTE *v139;
  const char *v140;
  uint64_t v142;
  unsigned int v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  char *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char v155;
  char v156;
  int v157;
  const char *v158;
  NSObject *v159;
  char *v160;
  int v161;
  int v162;
  int v163;
  NSObject *v164;
  int *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int v179;
  uint64_t v180;
  int v181;
  int v182;
  NSObject *v183;
  int *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  int v191;
  NSObject *v192;
  int *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  NSObject *v199;
  int v200;
  int *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  int v208;
  NSObject *v209;
  int v210;
  int *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  CFStringRef NetworkInterfaceEntity;
  const __SCDynamicStore *v218;
  __CFArray *Mutable;
  CFStringRef v220;
  CFStringRef v221;
  CFMutableArrayRef v222;
  __CFArray *v223;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoop *Main;
  int v226;
  NSObject *v227;
  int v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  const char *v240;
  uint64_t v241;
  NSObject *v242;
  NSObject *v243;
  NSObject *v244;
  int v245;
  int v246;
  char *v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  int v253;
  int v254;
  int v255;
  uint64_t v256;
  void *v257;
  int v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  io_connect_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  __CFRunLoop *v283;
  __CFRunLoopSource *v284;
  const char *v285;
  char v286;
  char v287;
  char v288;
  int v289;
  NSObject *v290;
  int *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  NSObject *v303;
  int *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  __CFMachPort *v317;
  __CFRunLoopSource *v318;
  __CFRunLoop *v319;
  xpc_connection_t mach_service;
  _xpc_connection_s *v321;
  NSObject *v322;
  int v323;
  int v324;
  NSObject *v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  int *v331;
  uint64_t v332;
  int v333;
  int v334;
  mode_t v335;
  uint64_t v336;
  int v337;
  int8x16_t v338;
  BOOL v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  int v356;
  NSObject *v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  const char *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  NSObject *v369;
  os_log_type_t v370;
  NSObject *v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  int v389;
  int v390;
  int v391;
  int v392;
  int v393;
  int v394;
  SCDynamicStoreRef store;
  pthread_t v396;
  rlimit v397;
  void (*v398)(uint64_t);
  void *v399;
  uint64_t *v400;
  socklen_t v401;
  socklen_t v402;
  size_t v403;
  int v404[2];
  sockaddr v405;
  int v406[2];
  CFErrorRef error[2];
  __int128 v408;
  __int128 v409;
  __int128 v410;
  __int128 v411;
  __int128 v412;
  __int128 v413;
  __int128 v414;
  __int128 v415;
  __int128 v416;
  __int128 v417;
  __int128 v418;
  __int128 v419;
  __int128 v420;
  __int128 v421;
  __int128 v422;
  _BYTE cStr[112];
  __int128 v424;
  __int128 v425;
  __int128 v426;
  __int128 v427;
  __int128 v428;
  __int128 v429;
  __int128 v430;
  __int128 v431;
  __int128 v432;

  mDNSLogCategory_Default = (uint64_t)os_log_create("com.apple.mDNSResponder", "Default");
  v6 = os_log_create("com.apple.mDNSResponder", "Default_redacted");
  mDNSLogCategory_Default_redacted = (uint64_t)v6;
  if (mDNSLogCategory_Default)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the Default log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_Default = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_State = (uint64_t)os_log_create("com.apple.mDNSResponder", "State");
  v8 = os_log_create("com.apple.mDNSResponder", "State_redacted");
  mDNSLogCategory_State_redacted = (uint64_t)v8;
  if (!mDNSLogCategory_State || !v8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the State log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_State = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_mDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "mDNS");
  v9 = os_log_create("com.apple.mDNSResponder", "mDNS_redacted");
  mDNSLogCategory_mDNS_redacted = (uint64_t)v9;
  if (!mDNSLogCategory_mDNS || !v9)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the mDNS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_mDNS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_uDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "uDNS");
  v10 = os_log_create("com.apple.mDNSResponder", "uDNS_redacted");
  mDNSLogCategory_uDNS_redacted = (uint64_t)v10;
  if (!mDNSLogCategory_uDNS || !v10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the uDNS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_uDNS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_SPS = (uint64_t)os_log_create("com.apple.mDNSResponder", "SPS");
  v11 = os_log_create("com.apple.mDNSResponder", "SPS_redacted");
  mDNSLogCategory_SPS_redacted = (uint64_t)v11;
  if (!mDNSLogCategory_SPS || !v11)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the SPS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_SPS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_NAT = (uint64_t)os_log_create("com.apple.mDNSResponder", "NAT");
  v12 = os_log_create("com.apple.mDNSResponder", "NAT_redacted");
  mDNSLogCategory_NAT_redacted = (uint64_t)v12;
  if (!mDNSLogCategory_NAT || !v12)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the NAT log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_NAT = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_D2D = (uint64_t)os_log_create("com.apple.mDNSResponder", "D2D");
  v13 = os_log_create("com.apple.mDNSResponder", "D2D_redacted");
  mDNSLogCategory_D2D_redacted = (uint64_t)v13;
  if (!mDNSLogCategory_D2D || !v13)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the D2D log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_D2D = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_XPC = (uint64_t)os_log_create("com.apple.mDNSResponder", "XPC");
  v14 = os_log_create("com.apple.mDNSResponder", "XPC_redacted");
  mDNSLogCategory_XPC_redacted = (uint64_t)v14;
  if (!mDNSLogCategory_XPC || !v14)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the XPC log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_XPC = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_Analytics = (uint64_t)os_log_create("com.apple.mDNSResponder", "Analytics");
  v15 = os_log_create("com.apple.mDNSResponder", "Analytics_redacted");
  mDNSLogCategory_Analytics_redacted = (uint64_t)v15;
  if (!mDNSLogCategory_Analytics || !v15)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the Analytics log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_Analytics = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_DNSSEC = (uint64_t)os_log_create("com.apple.mDNSResponder", "DNSSEC");
  v16 = os_log_create("com.apple.mDNSResponder", "DNSSEC_redacted");
  mDNSLogCategory_DNSSEC_redacted = (uint64_t)v16;
  if (!mDNSLogCategory_DNSSEC || !v16)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the DNSSEC log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_DNSSEC = (uint64_t)&_os_log_default;
  }
  mDNSMacOSXSystemBuildNumber(0);
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s starting %s %d", v17, v18, v19, v20, v21, (int)"mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)");
  if (geteuid())
  {
    v27 = &unk_100158000;
    if (argc >= 2)
    {
      v3 = "-NoMulticastAdvertisements";
      v28 = "-DebugLogging";
      v29 = "-UnicastPacketLogging";
      v30 = 1;
      do
      {
        v31 = argv[v30];
        if (!strcasecmp(v31, v3))
          NoMulticastAdvertisements = 1;
        if (!strcasecmp(v31, v28))
          v27[3304] = 1;
        if (!strcasecmp(v31, v29))
          mDNS_PacketLoggingEnabled = 1;
        v32 = v30;
        if (!strcasecmp(v31, "-OfferSleepProxyService"))
        {
          v33 = v29;
          v34 = v28;
          v35 = v3;
          v36 = v30 + 1;
          if (v30 + 1 >= argc)
          {
            v38 = 100;
          }
          else
          {
            v37 = argv[v36];
            if (*(unsigned __int8 *)v37 - 48 > 9
              || *((unsigned __int8 *)v37 + 1) - 48 > 9
              || v37[2])
            {
              v38 = 100;
            }
            else
            {
              v38 = atoi(argv[v36]);
              v31 = v37;
              v32 = ++v30;
            }
            v27 = (_BYTE *)&unk_100158000;
          }
          OfferSleepProxyService = v38;
          v3 = v35;
          v28 = v34;
          v29 = v33;
        }
        if (!strcasecmp(v31, "-UseInternalSleepProxy"))
        {
          if (v30 + 1 >= argc || (v39 = argv[v30 + 1], *(unsigned __int8 *)v39 - 48 > 9) || v39[1])
          {
            v40 = 1;
          }
          else
          {
            v40 = atoi(v39);
            ++v30;
          }
          UseInternalSleepProxy = v40;
          v32 = v30;
          v31 = argv[v30];
        }
        if (!strcasecmp(v31, "-StrictUnicastOrdering"))
        {
          StrictUnicastOrdering = 1;
          v31 = argv[v32];
        }
        if (!strcasecmp(v31, "-AlwaysAppendSearchDomains"))
        {
          AlwaysAppendSearchDomains = 1;
          v31 = argv[v32];
        }
        if (!strcasecmp(v31, "-DisableAllowExpired"))
          EnableAllowExpired = 0;
        ++v30;
      }
      while (v30 < argc);
    }
    v27[3304] = 1;
    mDNS_PacketLoggingEnabled = 1;
    NoMulticastAdvertisements = PreferencesGetValueBool(CFSTR("NoMulticastAdvertisements"), NoMulticastAdvertisements);
    StrictUnicastOrdering = PreferencesGetValueBool(CFSTR("StrictUnicastOrdering"), StrictUnicastOrdering);
    AlwaysAppendSearchDomains = PreferencesGetValueBool(CFSTR("AlwaysAppendSearchDomains"), AlwaysAppendSearchDomains);
    EnableAllowExpired = PreferencesGetValueBool(CFSTR("EnableAllowExpired"), EnableAllowExpired);
    OfferSleepProxyService = PreferencesGetValueInt(CFSTR("OfferSleepProxyService"), OfferSleepProxyService);
    UseInternalSleepProxy = PreferencesGetValueInt(CFSTR("UseInternalSleepProxy"), UseInternalSleepProxy);
    v41 = &unk_100150000;
    PQWorkaroundThreshold = PreferencesGetValueInt(CFSTR("PQWorkaroundThreshold"), PQWorkaroundThreshold);
    *(_QWORD *)cStr = 0;
    v42 = (uint64_t)"com.apple.mDNSResponder";
    asprintf((char **)cStr, "/Library/Managed Preferences/mobile/%s.plist", "com.apple.mDNSResponder");
    if (*(_QWORD *)cStr)
    {
      v43 = CFStringCreateWithCStringNoCopy(0, *(const char **)cStr, 0x8000100u, kCFAllocatorMalloc);
      if (v43)
      {
        v44 = v43;
        *(_QWORD *)cStr = 0;
        v45 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v43, kCFURLPOSIXPathStyle, 0);
        CFRelease(v44);
        if (v45)
        {
          v46 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v45);
          v47 = v46;
          v48 = (NSObject **)&unk_100164000;
          if (v46)
          {
            if (CFReadStreamOpen(v46))
            {
              error[0] = 0;
              v49 = CFPropertyListCreateWithStream(0, v47, 0, 0, 0, error);
              if (v49)
              {
                v42 = (uint64_t)v49;
                v50 = CFGetTypeID(v49);
                if (v50 == CFDictionaryGetTypeID())
                {
                  Code = 0;
                }
                else
                {
                  CFRelease((CFTypeRef)v42);
                  v42 = 0;
                  Code = -6756;
                }
              }
              else
              {
                if (error[0])
                  Code = CFErrorGetCode(error[0]);
                else
                  Code = -6700;
                if (_mdns_managed_defaults_log_s_once != -1)
                  dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2328);
                v371 = _mdns_managed_defaults_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)cStr = 138543362;
                  *(CFErrorRef *)&cStr[4] = error[0];
                  _os_log_error_impl((void *)&_mh_execute_header, v371, OS_LOG_TYPE_ERROR, "CFPropertyListCreateWithStream failed: %{public}@", cStr, 0xCu);
                }
                v42 = 0;
              }
              if (error[0])
                CFRelease(error[0]);
              CFRelease(v47);
              if (v42)
              {
                CFRelease(v45);
                v52 = PQWorkaroundThreshold;
                Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v42, CFSTR("PQWorkaroundThreshold"));
                if (Value)
                {
                  v54 = Value;
                  v55 = CFGetTypeID(Value);
                  if (v55 == CFNumberGetTypeID() && !CFNumberIsFloatType(v54))
                  {
                    *(_QWORD *)cStr = 0;
                    if (CFNumberGetValue(v54, kCFNumberSInt64Type, cStr))
                    {
                      v56 = *(_QWORD *)cStr;
                      if (*(uint64_t *)cStr >= 0x7FFFFFFF)
                        v56 = 0x7FFFFFFFLL;
                      if (v56 <= (uint64_t)0xFFFFFFFF80000000)
                        v52 = 0x80000000;
                      else
                        v52 = v56;
                    }
                  }
                }
                PQWorkaroundThreshold = v52;
                v57 = (const void *)v42;
                goto LABEL_109;
              }
              if (_mdns_managed_defaults_log_s_once != -1)
                dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2328);
              v243 = _mdns_managed_defaults_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)cStr = 138543618;
                *(_QWORD *)&cStr[4] = v45;
                *(_WORD *)&cStr[12] = 2048;
                *(_QWORD *)&cStr[14] = Code;
                _os_log_error_impl((void *)&_mh_execute_header, v243, OS_LOG_TYPE_ERROR, "Failed to create dictionary -- url: %{public}@, error: %{mdns:err}ld", cStr, 0x16u);
              }
LABEL_371:
              v57 = v45;
LABEL_109:
              CFRelease(v57);
              goto LABEL_110;
            }
            CFRelease(v47);
            v42 = -6755;
          }
          else
          {
            v42 = -6729;
          }
          if (_mdns_managed_defaults_log_s_once != -1)
            dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2328);
          v369 = _mdns_managed_defaults_log_s_log;
          if (v47)
            v370 = OS_LOG_TYPE_DEBUG;
          else
            v370 = OS_LOG_TYPE_ERROR;
          if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, v370))
          {
            *(_DWORD *)cStr = 138543618;
            *(_QWORD *)&cStr[4] = v45;
            *(_WORD *)&cStr[12] = 2048;
            *(_QWORD *)&cStr[14] = v42;
            _os_log_impl((void *)&_mh_execute_header, v369, v370, "Failed to create read stream -- url: %{public}@, error: %{mdns:err}ld", cStr, 0x16u);
          }
          goto LABEL_371;
        }
      }
      else if (*(_QWORD *)cStr)
      {
        free(*(void **)cStr);
      }
      v241 = -6729;
    }
    else
    {
      v241 = -6728;
    }
    v48 = (NSObject **)&unk_100164000;
    if (_mdns_managed_defaults_log_s_once != -1)
      dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2328);
    v242 = _mdns_managed_defaults_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)cStr = 136446466;
      *(_QWORD *)&cStr[4] = "com.apple.mDNSResponder";
      *(_WORD *)&cStr[12] = 2048;
      *(_QWORD *)&cStr[14] = v241;
      _os_log_error_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_ERROR, "Failed to create URL -- domain: %{public}s, error: %{mdns:err}ld", cStr, 0x16u);
    }
LABEL_110:
    if (NoMulticastAdvertisements)
      LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "-NoMulticastAdvertisements is set: Administratively prohibiting multicast advertisements", v58, v59, v60, v61, v62, v390);
    if (AlwaysAppendSearchDomains)
      LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "-AlwaysAppendSearchDomains is set", v58, v59, v60, v61, v62, v390);
    if (StrictUnicastOrdering)
      LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "-StrictUnicastOrdering is set", v58, v59, v60, v61, v62, v390);
    signal(1, (void (__cdecl *)(int))HandleSIG);
    signal(2, (void (__cdecl *)(int))HandleSIG);
    signal(13, (void (__cdecl *)(int))1);
    signal(15, (void (__cdecl *)(int))HandleSIG);
    signal(29, (void (__cdecl *)(int))HandleSIG);
    signal(30, (void (__cdecl *)(int))HandleSIG);
    signal(31, (void (__cdecl *)(int))HandleSIG);
    signal(27, (void (__cdecl *)(int))HandleSIG);
    signal(18, (void (__cdecl *)(int))HandleSIG);
    signal(28, (void (__cdecl *)(int))HandleSIG);
    mDNSStorage[0] = (uint64_t)&PlatformStorage;
    KQueueFD = kqueue();
    if (KQueueFD == -1)
    {
      v64 = *__error();
      v76 = v48[295];
      strerror(v64);
      LogMsgWithLevel(v76, OS_LOG_TYPE_DEFAULT, "kqueue() failed errno %d (%s)", v77, v78, v79, v80, v81, v64);
      if (v64)
        goto LABEL_187;
LABEL_179:
      CFRunLoopRun();
      v135 = v48[295];
      if (gSensitiveLoggingEnabled != 1 || v135 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(v48[295], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
          goto LABEL_185;
        }
      }
      else
      {
        v135 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
LABEL_185:
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_FAULT, "ERROR: CFRunLoopRun Exiting.", cStr, 2u);
        }
      }
      mDNS_StartExit();
      mDNS_FinalExit();
      v64 = 0;
      goto LABEL_187;
    }
    v63 = pthread_mutex_init(&stru_1001508F0, 0);
    if (v63)
    {
      v64 = v63;
      v65 = v48[295];
      strerror(v63);
      LogMsgWithLevel(v65, OS_LOG_TYPE_DEFAULT, "pthread_mutex_init() failed error %d (%s)", v66, v67, v68, v69, v70, v64);
LABEL_187:
      LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "%s exiting", v71, v72, v73, v74, v75, (int)"mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)");
      return v64;
    }
    pthread_mutex_lock(&stru_1001508F0);
    *(_QWORD *)v404 = 0;
    if (socketpair(1, 1, 0, v404) == -1)
    {
      v64 = *__error();
      v86 = v48[295];
      strerror(v64);
      LogMsgWithLevel(v86, OS_LOG_TYPE_DEFAULT, "socketpair() failed errno %d (%s)", v87, v88, v89, v90, v91, v64);
      goto LABEL_178;
    }
    dword_100150934 = v404[0];
    KQueueSet(v404[1], 1u, -1, &main_wakeKQEntry);
    v82 = getpid();
    v83 = sandbox_check(v82, 0, 0);
    switch(v83)
    {
      case -1:
        v83 = *__error();
        break;
      case 0:
        v94 = (uint64_t)v48[295];
        if (gSensitiveLoggingEnabled != 1 || v94 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v48[295], OS_LOG_TYPE_FAULT))
            goto LABEL_151;
          *(_WORD *)cStr = 0;
          v85 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }
        else
        {
          v94 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
            goto LABEL_151;
          *(_WORD *)cStr = 0;
          v85 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }
        v95 = v94;
        v96 = OS_LOG_TYPE_FAULT;
        goto LABEL_149;
      case 1:
        v84 = (uint64_t)v48[295];
        if (gSensitiveLoggingEnabled != 1 || v84 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v48[295], OS_LOG_TYPE_DEFAULT))
            goto LABEL_151;
          *(_WORD *)cStr = 0;
          v85 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }
        else
        {
          v84 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_151;
          *(_WORD *)cStr = 0;
          v85 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }
        v95 = v84;
        v96 = OS_LOG_TYPE_DEFAULT;
LABEL_149:
        v97 = 2;
LABEL_150:
        _os_log_impl((void *)&_mh_execute_header, v95, v96, v85, cStr, v97);
LABEL_151:
        mDNSStorage[0] = (uint64_t)&PlatformStorage;
        dword_100158DD0 = 0;
        byte_100158DD4[0] = 0;
        byte_100158DD5[0] = NoMulticastAdvertisements == 0;
        byte_100158DD6 = 0;
        dword_100158DD8 = 1;
        *(_QWORD *)&word_100158DDC = 0;
        word_100158DE4 = 0;
        *((_BYTE *)mDNSStorage + &loc_100009420) = 0;
        dword_100158E14 = 0;
        qword_100158DF0 = 0;
        *(_QWORD *)&dword_100158DF8 = 0;
        off_100158DE8 = (uint64_t (*)(_QWORD, _QWORD))mDNS_StatusCallback;
        *(int *)((char *)&dword_100158DFC + 3) = 0;
        *(_QWORD *)cStr = 0;
        v98 = mach_timebase_info((mach_timebase_info_t)cStr);
        if (v98)
        {
          v64 = v98;
LABEL_177:
          LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "Daemon start: mDNS_Init failed %d", v99, v100, v101, v102, v103, v64);
          LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "Daemon start: mDNSDaemonInitialize failed", v130, v131, v132, v133, v134, v391);
          goto LABEL_178;
        }
        mDNSPlatformClockDivisor = 1000000 * (unint64_t)*(unsigned int *)&cStr[4] / *(unsigned int *)cStr;
        v104 = arc4random();
        dword_100158E04 = v104;
        v112 = v104 + mDNSPlatformRawTime(v104, v105, v106, v107, v108, v109, v110, v111);
        dword_100158E08 = 0;
        dword_100158E0C = v112;
        dword_100158E10 = v112;
        LODWORD(qword_100158E18) = v112;
        HIDWORD(qword_100158E18) = v112;
        *(int32x4_t *)&dword_100158E20 = vdupq_n_s32(v112 + 939524096);
        dword_100158E30 = v112 + 939524096;
        dword_100158E34 = v112 + 939524096;
        dword_100158E80 = v112 + 939524096;
        *(_QWORD *)&dword_100158E38 = (v112 + 939524096);
        byte_100158E40 = 0;
        qword_100158E5C = 0;
        unk_100158E70 = 0;
        dword_100158E78 = 0;
        qword_100158E44 = 0;
        unk_100158E4C = 0;
        dword_100158E54 = 0;
        *(_OWORD *)&qword_100158EB0 = 0u;
        *(__int128 *)((char *)&xmmword_100158E88 + 12) = 0u;
        unk_100158EA4 = 0u;
        unk_100158E84 = 0u;
        qword_100158EC4 = 0xA00000000;
        bzero(&qword_100158ED8, 0xF98uLL);
        for (i = 0; i != 1996; i += 4)
          *(_DWORD *)((char *)&mDNSStorage[533] + i) = v112 + 939524096;
        v114 = &unk_100150B68;
        v115 = 146;
        do
        {
          *(v114 - 28) = v114;
          v114 += 28;
          --v115;
        }
        while (v115);
        v116 = &dword_100158EB8;
        *((_BYTE *)&dword_100158EB8 + &unk_100002778) = 0;
        *((_BYTE *)&dword_100158EB8 + &unk_1000027B8) = 0;
        *((_BYTE *)&dword_100158EB8 + &unk_1000028B8) = 0;
        qword_100158968 = 0;
        qword_100158ED0 = (uint64_t)&rrcachestorage;
        *((_BYTE *)&dword_100158EB8 + &unk_1000029C0) = 0;
        dword_100158EB8 += 146;
        *((_BYTE *)&dword_100158EB8 + &loc_100002AC0) = 0;
        bzero((char *)&dword_100158EB8 + &unk_100001798, 0xFA1uLL);
        v117 = (char *)&dword_100158EB8 + &loc_100003054 + 4;
        v117[32] = 0;
        *(_OWORD *)v117 = 0u;
        *((_OWORD *)v117 + 1) = 0u;
        xmmword_10015BF38 = 0u;
        dword_10015BF48 = 0;
        dword_10015BF50 = v112 + 939524096;
        dword_10015BF54 = v112 + 939524096;
        *((_BYTE *)&dword_100158EB8 + &loc_100003668) = 0;
        *((_BYTE *)&dword_100158EB8 + &loc_100003768) = 0;
        qword_10015BFA0 = 0;
        v118 = (_OWORD *)((char *)&dword_100158EB8 + &loc_1000030A8);
        *v118 = 0u;
        v118[1] = 0u;
        v118[2] = 0u;
        *(_OWORD *)((char *)v118 + 44) = 0u;
        *(_QWORD *)((char *)&dword_100158EB8 + &loc_100004CCC) = 0;
        *(int *)((char *)&dword_100158EB8 + &loc_100004CD4) = 0;
        *(_OWORD *)((char *)&dword_100158EB8 + &loc_100003868) = 0u;
        dword_10015C07C = -1;
        dword_10015C730 = 0;
        xmmword_10015C748 = 0u;
        dword_10015C758 = 0;
        dword_10015C75C = v112 + 939524096;
        dword_10015C760 = 0;
        dword_10015C764 = arc4random();
        dword_10015C768 = arc4random();
        dword_10015C76C = arc4random();
        qword_10015C770 = 0;
        dword_10015C778 = 0;
        dword_10015C77C = v112;
        *(_WORD *)((char *)&dword_100158EB8 + &loc_1000038C8) = 0;
        v119 = (char *)&dword_100158EB8 + &loc_1000039B8;
        *(_OWORD *)v119 = 0u;
        v119[16] = 0;
        *(int *)((char *)&dword_100158EB8 + &loc_1000039C8 + 2) = 0;
        *((_BYTE *)&dword_100158EB8 + &loc_1000039D8) = 0;
        *(int *)((char *)&dword_100158EB8 + &loc_100004CC0) = 0;
        qword_10015C888 = 0;
        xmmword_10015C898 = 0u;
        xmmword_10015C8A8 = 0u;
        qword_10015C8B8 = 0;
        dword_10015C8C8 = 0;
        *(_WORD *)((char *)&dword_100158EBC + &loc_100003A10) = 0;
        *(_OWORD *)((char *)&dword_100158EB8 + &loc_100003A18) = 0u;
        *(_DWORD *)cStr = 0;
        v120 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
        if (!v120)
          goto LABEL_382;
        v126 = v120;
        v127 = &_dnssec_obj_trust_anchor_manager_kind;
        *((_QWORD *)v120 + 1) = &_dnssec_obj_trust_anchor_manager_kind;
        do
        {
          v128 = (void (*)(_DWORD *))v127[2];
          if (v128)
            v128(v126);
          v127 = (_UNKNOWN **)*v127;
        }
        while (v127);
        ++*v126;
        *(_DWORD *)cStr = 0;
        v116 = (int *)dnssec_obj_trust_anchor_create_with_ds_data(byte_100100770, 20326, 8, (__int128 *)&unk_100100772, 1485993600, -661490049, (int *)cStr);
        v42 = *(unsigned int *)cStr;
        v3 = (const char *)&unk_100158000;
        if (!*(_DWORD *)cStr)
        {
          v129 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v126, (uint64_t)v116);
          *(_DWORD *)cStr = v129;
          if (!(_DWORD)v129)
          {
            if (is_apple_internal_build_s_once != -1)
              dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_2_6036);
            if (is_apple_internal_build_is_internal)
            {
              v41 = dnssec_obj_trust_anchor_create_with_ds_data("\x06dnssec\x04test", 36815, 14, (__int128 *)&unk_100100792, 1645819915, -501663734, (int *)cStr);
              v42 = *(unsigned int *)cStr;
              if (!*(_DWORD *)cStr)
              {
                v42 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v126, (uint64_t)v41);
                *(_DWORD *)cStr = v42;
                if (!v116)
                  goto LABEL_173;
                goto LABEL_172;
              }
            }
            else
            {
              v41 = 0;
              v42 = *(unsigned int *)cStr;
            }
            if (!v116)
              goto LABEL_173;
            goto LABEL_172;
          }
          v42 = v129;
        }
        v41 = 0;
        if (!v116)
        {
LABEL_173:
          if (v41)
            ref_count_obj_release(v41);
          qword_10015DBE8 = (uint64_t)v126;
          if ((_DWORD)v42)
          {
            v64 = -65537;
            v48 = (NSObject **)&unk_100164000;
            goto LABEL_177;
          }
          v137 = v112 + 1800000;
          if ((v112 + 1800000) <= 1)
            v137 = 1;
          dword_100158E6C = v137;
          v138 = malloc_type_calloc(1uLL, 0x130uLL, 0xF1748037uLL);
          if (v138)
          {
            v139 = v138;
            v140 = "\x05local";
            v48 = (NSObject **)&unk_100164000;
            while (1)
            {
              if ("\x05local" == (char *)-256)
              {
                if (!v140)
                  goto LABEL_205;
              }
              else if (v140 >= "wed" || v140 == 0)
              {
                goto LABEL_205;
              }
              v142 = *(unsigned __int8 *)v140;
              if (v142 > 0x3F)
                goto LABEL_205;
              if (!*v140)
                break;
              v140 += v142 + 1;
            }
            v143 = (_DWORD)v140 - "\x05local" + 1;
            if ((unsigned __int16)v143 <= 0x100u)
            {
              memcpy(v138, "\x05local", (unsigned __int16)v143);
              goto LABEL_206;
            }
LABEL_205:
            *v138 = 0;
LABEL_206:
            *(_QWORD *)&byte_100158DD5[&loc_100003740 + 3] = v139;
            byte_100158DD6 = byte_100158DD5[0] == 0;
            v421 = 0u;
            v422 = 0u;
            v419 = 0u;
            v420 = 0u;
            v417 = 0u;
            v418 = 0u;
            v415 = 0u;
            v416 = 0u;
            v413 = 0u;
            v414 = 0u;
            v411 = 0u;
            v412 = 0u;
            v409 = 0u;
            v410 = 0u;
            *(_OWORD *)error = 0u;
            v408 = 0u;
            mDNSMacOSXSystemBuildNumber(error);
            if ((MEMORY[0xFFFFFC021] & 1) != 0)
            {
              SameDomainLabelPointer = (uint64_t (*)(_QWORD, _QWORD))vectorSameDomainLabel;
              v149 = "setSameDomainLabelPointer: using vector code";
            }
            else
            {
              v149 = "setSameDomainLabelPointer: using scalar code";
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v149, v144, v145, v146, v147, v148, v390);
            HelperQueue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.HelperQueue", 0);
            if (!HelperQueue)
            {
              v64 = -65539;
              v159 = mDNSLogCategory_Default;
              v160 = "dispatch_queue_create: Helper queue NULL";
              goto LABEL_259;
            }
            if (iOSVers)
              v155 = 2;
            else
              v155 = 4;
            if (OSXVers)
              v156 = 1;
            else
              v156 = v155;
            byte_10015BF4C = v156;
            v157 = 100;
            do
            {
              memset(cStr, 0, 64);
              GetUserSpecifiedLocalHostName(cStr);
              if (cStr[0])
                break;
              usleep(0xC350u);
              --v157;
            }
            while (v157);
            LOBYTE(xmmword_10015B630) = 0;
            GetRandomUUIDLocalHostname(byte_10015B770);
            *(_QWORD *)v406 = 0x200000006;
            v403 = 32;
            v158 = HINFO_HWstring_buffer;
            if (sysctl(v406, 2u, HINFO_HWstring_buffer, &v403, 0, 0))
              v158 = HINFO_HWstring;
            else
              HINFO_HWstring = HINFO_HWstring_buffer;
            if (strchr(HINFO_HWstring_buffer, 44))
              v161 = strcspn(v158, "0123456789");
            else
              v161 = strlen(v158);
            HINFO_HWstring_prefixlen = v161;
            v162 = socket(2, 2, 17);
            v163 = v162;
            if (v162 > 2)
            {
              *(_QWORD *)cStr = 3910402560;
              *(_QWORD *)&cStr[8] = 0;
              v176 = bind(v162, (const sockaddr *)cStr, 0x10u);
              close(v163);
              if (!v176)
              {
                byte_100158DD4[0] = 1;
                goto LABEL_230;
              }
            }
            else
            {
              v164 = mDNSLogCategory_Default;
              __error();
              v165 = __error();
              strerror(*v165);
              LogMsgWithLevel(v164, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_CanReceiveUnicast: socket error %d errno %d (%s)", v166, v167, v168, v169, v170, v163);
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "No unicast UDP responses", v171, v172, v173, v174, v175, v392);
LABEL_230:
            v177 = strlen(HINFO_HWstring);
            v178 = strlen((const char *)error);
            v179 = v178;
            if (v178 + v177 <= 0xFD)
            {
              byte_10015B878 = v177;
              byte_10015B978 = v178;
              memcpy(&unk_10015B879, HINFO_HWstring, v177);
              memcpy(&unk_10015B979, error, v179);
            }
            v180 = mDNSStorage[0];
            *(_WORD *)(mDNSStorage[0] + 8) = -5868;
            v180 += 8;
            *(_QWORD *)(v180 + 8) = mDNSStorage;
            *(_DWORD *)(v180 + 16) = -1;
            *(_QWORD *)(v180 + 24) = myKQSocketCallBack;
            *(_QWORD *)(v180 + 32) = v180;
            *(_QWORD *)(v180 + 40) = "IPv4 UDP packet reception";
            *(_DWORD *)(v180 + 48) = -1;
            *(_QWORD *)(v180 + 56) = myKQSocketCallBack;
            *(_QWORD *)(v180 + 64) = v180;
            *(_QWORD *)(v180 + 72) = "IPv6 UDP packet reception";
            v181 = SetupSocket((_QWORD *)v180, 0xE914u, 2, 0);
            if (v181)
            {
              v182 = v181;
              v183 = mDNSLogCategory_Default;
              __error();
              v184 = __error();
              strerror(*v184);
              LogMsgWithLevel(v183, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: SetupSocket(AF_INET) failed error %d errno %d (%s)", v185, v186, v187, v188, v189, v182);
            }
            v190 = SetupSocket((_QWORD *)(mDNSStorage[0] + 8), 0xE914u, 30, 0);
            if (v190)
            {
              v191 = v190;
              v192 = mDNSLogCategory_Default;
              __error();
              v193 = __error();
              strerror(*v193);
              LogMsgWithLevel(v192, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: SetupSocket(AF_INET6) failed error %d errno %d (%s)", v194, v195, v196, v197, v198, v191);
            }
            *(_QWORD *)&v405.sa_len = 0;
            *(_QWORD *)&v405.sa_data[6] = 0;
            v402 = 16;
            if (getsockname(*(_DWORD *)(mDNSStorage[0] + 24), &v405, &v402) < 0)
            {
              v199 = mDNSLogCategory_Default;
              v200 = *__error();
              v201 = __error();
              strerror(*v201);
              LogMsgWithLevel(v199, OS_LOG_TYPE_DEFAULT, "getsockname v4 error %d (%s)", v202, v203, v204, v205, v206, v200);
            }
            else
            {
              word_100158DDC = *(_WORD *)v405.sa_data;
            }
            v207 = mDNSStorage[0];
            v208 = *(_DWORD *)(mDNSStorage[0] + 56);
            if ((v208 & 0x80000000) == 0)
            {
              memset(cStr, 0, 28);
              v401 = 28;
              if (getsockname(v208, (sockaddr *)cStr, &v401) < 0)
              {
                v209 = mDNSLogCategory_Default;
                v210 = *__error();
                v211 = __error();
                strerror(*v211);
                LogMsgWithLevel(v209, OS_LOG_TYPE_DEFAULT, "getsockname v6 error %d (%s)", v212, v213, v214, v215, v216, v210);
              }
              else
              {
                word_100158DDE = *(_WORD *)&cStr[2];
              }
              v207 = mDNSStorage[0];
            }
            *(_QWORD *)v207 = 0;
            *(_BYTE *)(v207 + 108) = 0;
            *(_BYTE *)(v207 + 172) = 0;
            *(_BYTE *)(v207 + 364) = 0;
            *(_BYTE *)(v207 + 428) = 0;
            *(_BYTE *)(v207 + 236) = 0;
            *(_BYTE *)(v207 + 300) = 0;
            *(_DWORD *)(v207 + 492) = 0;
            *(_DWORD *)(v207 + 500) = 0;
            *(_QWORD *)(v207 + 600) = 0;
            *(_DWORD *)(v207 + 608) = 0;
            *(_WORD *)(v207 + 688) = 257;
            *(_DWORD *)(v207 + 692) = 0;
            *(_QWORD *)(v207 + 696) = 0;
            NetworkChangedKey_IPv4 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetIPv4);
            NetworkChangedKey_IPv6 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetIPv6);
            NetworkChangedKey_Hostnames = (uint64_t)SCDynamicStoreKeyCreateHostNames(0);
            NetworkChangedKey_Computername = (uint64_t)SCDynamicStoreKeyCreateComputerName(0);
            NetworkChangedKey_DNS = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetDNS);
            NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, &stru_10013FAA0, 0);
            NetworkChangedKey_StateInterfacePrefix = (uint64_t)NetworkInterfaceEntity;
            if (NetworkChangedKey_IPv4
              && NetworkChangedKey_IPv6
              && NetworkChangedKey_Hostnames
              && NetworkChangedKey_Computername
              && NetworkChangedKey_DNS
              && NetworkInterfaceEntity)
            {
              *(_QWORD *)cStr = 0;
              memset(&cStr[16], 0, 24);
              *(_QWORD *)&cStr[8] = mDNSStorage;
              v218 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:WatchForNetworkChanges"), (SCDynamicStoreCallBack)NetworkChanged, (SCDynamicStoreContext *)cStr);
              Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              v220 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4);
              v221 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv6);
              v222 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              v223 = v222;
              store = v218;
              v48 = (NSObject **)&unk_100164000;
              if (v218)
              {
                v3 = (_BYTE *)&unk_100158000;
                if (Mutable && v220 && v221 && v222)
                {
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv4);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv6);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Hostnames);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Computername);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_DNS);
                  CFArrayAppendValue(Mutable, CFSTR("Setup:/Network/DynamicDNS"));
                  CFArrayAppendValue(Mutable, CFSTR("State:/IOKit/PowerManagement/CurrentSettings"));
                  CFArrayAppendValue(v223, v220);
                  CFArrayAppendValue(v223, v221);
                  CFArrayAppendValue(v223, CFSTR("State:/Network/Interface/[^/]+/AirPort"));
                  if (SCDynamicStoreSetNotificationKeys(v218, Mutable, v223))
                  {
                    RunLoopSource = SCDynamicStoreCreateRunLoopSource(0, v218, 0);
                    *(_QWORD *)(mDNSStorage[0] + 512) = RunLoopSource;
                    if (RunLoopSource)
                    {
                      Main = CFRunLoopGetMain();
                      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
                      SCDynamicStoreSetDisconnectCallBack(v218, DynamicStoreReconnected);
                      v226 = 0;
                      *(_QWORD *)(mDNSStorage[0] + 504) = store;
LABEL_282:
                      CFRelease(v223);
LABEL_283:
                      if (v221)
                        CFRelease(v221);
                      if (v220)
                        CFRelease(v220);
                      if (Mutable)
                        CFRelease(Mutable);
                      if (v226)
                      {
                        v64 = -1;
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: WatchForNetworkChanges failed %d", v235, v236, v237, v238, v239, -1);
                        goto LABEL_308;
                      }
                      v253 = socket(32, 3, 1);
                      v254 = v253;
                      *(_DWORD *)(mDNSStorage[0] + 528) = v253;
                      if (v253 < 0)
                      {
                        v289 = -65539;
                        v290 = mDNSLogCategory_Default;
                        __error();
                        v291 = __error();
                        strerror(*v291);
                        LogMsgWithLevel(v290, OS_LOG_TYPE_DEFAULT, "WatchForSysEvents: socket failed error %d errno %d (%s)", v292, v293, v294, v295, v296, v254);
                      }
                      else
                      {
                        *(_DWORD *)&cStr[8] = 2;
                        *(_QWORD *)cStr = 0x100000001;
                        v255 = ioctl(v253, 0x800C6502uLL);
                        if ((v255 & 0x80000000) == 0)
                        {
                          v256 = mDNSStorage[0];
                          v257 = (void *)(mDNSStorage[0] + 536);
                          *(_QWORD *)(mDNSStorage[0] + 536) = SysEventCallBack;
                          *(_QWORD *)(v256 + 544) = mDNSStorage;
                          *(_QWORD *)(v256 + 552) = "System Event Notifier";
                          KQueueSet(*(_DWORD *)(v256 + 528), 1u, -1, v257);
                          v258 = time(0);
                          SystemWakeForNetworkAccess();
                          HIBYTE(dword_100158E54) = 0;
                          myGetIfAddrs();
                          UpdateInterfaceList(v258);
                          SetupActiveInterfaces(v258);
                          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8182);
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: SetDomainSecrets: no keychain support", v259, v260, v261, v262, v263, (int)cStr);
                          SetLocalDomains(v264, v265, v266, v267, v268, v269, v270, v271, v393);
                          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8185);
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: Compiled without SnowLeopard Fine-Grained Power Management support", v272, v273, v274, v275, v276, v394);
                          v277 = IORegisterForSystemPower(mDNSStorage, (IONotificationPortRef *)(mDNSStorage[0] + 560), (IOServiceInterestCallback)PowerChanged, (io_object_t *)(mDNSStorage[0] + 572));
                          *(_DWORD *)(mDNSStorage[0] + 568) = v277;
                          if (!v277)
                          {
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: IORegisterForSystemPower failed", v278, v279, v280, v281, v282, v390);
                            v64 = -1;
                            goto LABEL_308;
                          }
                          v283 = CFRunLoopGetMain();
                          v284 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
                          CFRunLoopAddSource(v283, v284, kCFRunLoopDefaultMode);
                          v285 = HINFO_HWstring;
                          v41 = &unk_10014C000;
                          v42 = (uint64_t)&unk_10014C000;
                          v116 = (int *)&unk_10014C000;
                          if (!strncasecmp(HINFO_HWstring, "Xserve", 6uLL) || !strncasecmp(v285, "RackMac", 7uLL))
                          {
                            v286 = 85;
                            v287 = 84;
                            v288 = 25;
                            goto LABEL_392;
                          }
                          if (!strncasecmp(v285, "MacPro", 6uLL))
                          {
                            v286 = 85;
                            v287 = 84;
                          }
                          else
                          {
                            if (strncasecmp(v285, "PowerMac", 8uLL))
                            {
                              if (strncasecmp(v285, "iMac", 4uLL))
                              {
                                if (!strncasecmp(v285, "Macmini", 7uLL))
                                {
                                  v286 = 74;
                                  v287 = 73;
                                  v288 = 33;
                                }
                                else if (!strncasecmp(v285, "TimeCapsule", 0xBuLL))
                                {
                                  v286 = 70;
                                  v287 = 10;
                                  v288 = 34;
                                }
                                else if (!strncasecmp(v285, "AirPort", 7uLL))
                                {
                                  v286 = 70;
                                  v287 = 10;
                                  v288 = 35;
                                }
                                else
                                {
                                  if (strncasecmp(v285, "MacBook", 7uLL))
                                  {
                                    v48 = (NSObject **)&unk_100164000;
                                    if (strncasecmp(v285, "PowerBook", 9uLL))
                                    {
LABEL_393:
                                      if (mDNS_LoggingEnabled == 1)
                                        LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "HW_MODEL: %.*s (%s) Portability %d Marginal Power %d Total Power %d Features %d", v121, v122, v123, v124, v125, HINFO_HWstring_prefixlen);
                                      SSLqueue = (uint64_t)dispatch_get_global_queue(0, 0);
                                      if (!SSLqueue)
                                        LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "dispatch_queue_create: SSL queue NULL", v372, v373, v374, v375, v376, v390);
                                      if (is_apple_internal_build_s_once != -1)
                                        dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_2_6036);
                                      if (v3[2856])
                                      {
                                        mDNSMacOSXUpdateEtcHosts_internal();
                                      }
                                      else
                                      {
                                        v401 = 16777343;
                                        RegisterLocalOnlyAddressRecord("\tlocalhost", 1, &v401, 4u);
                                        RegisterLocalOnlyAddressRecord("\rbroadcasthost", 1, &onesIPv4Addr, 4u);
                                        *(_QWORD *)cStr = 0;
                                        *(_QWORD *)&cStr[8] = 0x100000000000000;
                                        RegisterLocalOnlyAddressRecord("\tlocalhost", 28, cStr, 0x10u);
                                      }
                                      v431 = 0u;
                                      v432 = 0u;
                                      v429 = 0u;
                                      v430 = 0u;
                                      v427 = 0u;
                                      v428 = 0u;
                                      v425 = 0u;
                                      v426 = 0u;
                                      v424 = 0u;
                                      memset(cStr, 0, sizeof(cStr));
                                      AppendDNSNameString(cStr, "1.0.0.127.in-addr.arpa.", v377, v378, v379, v380, v381, v382);
                                      CreatePTRRecord(cStr);
                                      cStr[0] = 0;
                                      AppendDNSNameString(cStr, "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.", v383, v384, v385, v386, v387, v388);
                                      CreatePTRRecord(cStr);
                                      if (dnssd_analytics_init_sInitAnalyticsOnce != -1)
                                        dispatch_once(&dnssd_analytics_init_sInitAnalyticsOnce, &__block_literal_global_7161);
                                      if (_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy")
                                        && mdns_trust_checks_init_s_once != -1)
                                      {
                                        dispatch_once(&mdns_trust_checks_init_s_once, &__block_literal_global_7408);
                                      }
                                      v397.rlim_cur = (rlim_t)_NSConcreteStackBlock;
                                      v397.rlim_max = 0x40000000;
                                      v398 = __mDNSPlatformInit_setup_block_invoke;
                                      v399 = &__block_descriptor_tmp_362;
                                      v400 = mDNSStorage;
                                      util_managed_network_change_handler(&v397);
                                      mDNSCoreInitComplete();
                                      initializeD2DPlugins();
                                      v64 = 0;
LABEL_308:
                                      uDNS_SetupDNSConfig();
                                      if (DPCFeatureEnabled_sOnce != -1)
                                        dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
                                      if (DPCFeatureEnabled_sEnabled)
                                      {
                                        bzero(&DPCBrowse, 0x2B8uLL);
                                        mDNS_StartBrowse_internal((uint64_t)&DPCBrowse, "\x06_local\t_dnssd-dp\x04_tcp", "\x05local", 0, 0, 0, 0, (uint64_t)DPCBrowseHandler, 0);
                                        dword_10014E1B4 = -1;
                                      }
                                      if (v64)
                                        goto LABEL_177;
                                      if (_os_feature_enabled_impl("mDNSResponder", "preallocated_cache"))
                                      {
                                        v316 = 31;
                                        do
                                        {
                                          mDNS_StatusCallback((size_t)mDNSStorage, -65790, v310, v311, v312, v313, v314, v315);
                                          --v316;
                                        }
                                        while (v316);
                                      }
                                      v317 = CFMachPortCreate(0, (CFMachPortCallBack)SignalCallback, 0, 0);
                                      v318 = CFMachPortCreateRunLoopSource(0, v317, 0);
                                      signal_port = CFMachPortGetPort(v317);
                                      v319 = CFRunLoopGetMain();
                                      CFRunLoopAddSource(v319, v318, kCFRunLoopDefaultMode);
                                      if (v318)
                                        CFRelease(v318);
                                      mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder.log_utility", 0, 1uLL);
                                      if (mach_service
                                        && (v321 = mach_service,
                                            xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection))
                                      {
                                        log_utility_server_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.log_utility_server_queue", 0);
                                        xpc_connection_set_event_handler(v321, &__block_literal_global_7296);
                                        xpc_connection_resume(v321);
                                      }
                                      else
                                      {
                                        v322 = mDNSLogCategory_XPC;
                                        if (gSensitiveLoggingEnabled != 1
                                          || mDNSLogCategory_XPC == mDNSLogCategory_State)
                                        {
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR))
                                            goto LABEL_328;
                                          *(_WORD *)cStr = 0;
                                        }
                                        else
                                        {
                                          v322 = mDNSLogCategory_XPC_redacted;
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR))goto LABEL_328;
                                          *(_WORD *)cStr = 0;
                                        }
                                        _os_log_impl((void *)&_mh_execute_header, v322, OS_LOG_TYPE_ERROR, "Error Creating XPC Listener for Log Utility Server!", cStr, 2u);
                                      }
LABEL_328:
                                      v323 = launch_activate_socket("Listeners", (int **)&launchd_fds, (size_t *)&launchd_fds_count);
                                      if (v323)
                                      {
                                        v324 = v323;
                                        v325 = v48[295];
                                        strerror(v323);
                                        LogMsgWithLevel(v325, OS_LOG_TYPE_DEFAULT, "launch_activate_socket() failed error %d (%s)", v326, v327, v328, v329, v330, v324);
                                      }
                                      v331 = (int *)launchd_fds;
                                      v332 = launchd_fds_count;
                                      memset(cStr, 0, 106);
                                      if (launchd_fds)
                                      {
                                        if (launchd_fds_count)
                                        {
                                          do
                                          {
                                            v334 = *v331++;
                                            v333 = v334;
                                            if ((v334 & 0x80000000) == 0 && !uds_socket_setup(v333))
                                              goto LABEL_360;
                                          }
                                          while (--v332);
                                        }
LABEL_342:
                                        error[0] = 0;
                                        error[1] = 0;
                                        if (getrlimit(8, (rlimit *)error) < 0)
                                          goto LABEL_354;
                                        if (setrlimit(8, (const rlimit *)error) < 0)
                                          my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                        if (getrlimit(8, (rlimit *)error) < 0)
                                          goto LABEL_354;
                                        v338 = (int8x16_t)vdupq_n_s64(0x2800uLL);
                                        v397 = (rlimit)vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)error, (uint64x2_t)v338), *(int8x16_t *)error, v338);
                                        v339 = (unint64_t)error[1] >> 11 >= 5
                                            && (unint64_t)error[0] >> 11 > 4;
                                        if (!v339 && setrlimit(8, &v397) < 0)
                                          my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                        if (getrlimit(8, (rlimit *)error) < 0)
                                        {
LABEL_354:
                                          my_perror((int)"ERROR: Unable to get file descriptor limit");
                                        }
                                        else
                                        {
                                          mDNS_GetDomains((uint64_t)mDNSStorage + &loc_100003498, 2, 0, -2, (uint64_t)AutomaticBrowseDomainChange, 0);
                                          RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 3);
                                          RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 0);
                                          AddAutoBrowseDomain(0, "\x05local");
                                          udsserver_handle_configchange((size_t)mDNSStorage);
                                        }
                                        mDNSMacOSXNetworkChanged(v340, v341, v342, v343, v344, v345, v346, v347);
                                        UpdateDebugState(v348, v349, v350, v351, v352, v353, v354, v355, v390);
                                        v396 = 0;
                                        v356 = pthread_create(&v396, 0, (void *(__cdecl *)(void *))KQueueLoop, mDNSStorage);
                                        v64 = v356;
                                        if (v356)
                                        {
                                          v357 = v48[295];
                                          strerror(v356);
                                          LogMsgWithLevel(v357, OS_LOG_TYPE_DEFAULT, "pthread_create() failed error %d (%s)", v358, v359, v360, v361, v362, v64);
                                        }
LABEL_178:
                                        pthread_mutex_unlock(&stru_1001508F0);
                                        if (v64)
                                          goto LABEL_187;
                                        goto LABEL_179;
                                      }
                                      listenfd = socket(1, 1, 0);
                                      if (listenfd < 0)
                                      {
                                        v363 = "ERROR: socket(AF_DNSSD, SOCK_STREAM, 0); failed";
                                      }
                                      else
                                      {
                                        memset(&cStr[2], 0, 104);
                                        v335 = umask(0);
                                        unlink("/var/run/mDNSResponder");
                                        v336 = 0;
                                        *(_WORD *)cStr = 362;
                                        while (1)
                                        {
                                          cStr[v336 + 2] = aVarRunMdnsresp[v336];
                                          if (v336 == 22)
                                            break;
                                          ++v336;
                                        }
                                        v337 = bind(listenfd, (const sockaddr *)cStr, 0x6Au);
                                        umask(v335);
                                        if ((v337 & 0x80000000) == 0)
                                        {
                                          if (uds_socket_setup(listenfd))
                                            goto LABEL_342;
LABEL_360:
                                          my_perror((int)"ERROR: udsserver_init");
                                          LogMsgWithLevel(v48[295], OS_LOG_TYPE_DEFAULT, "Daemon start: udsserver_init failed", v364, v365, v366, v367, v368, v390);
                                          v64 = -1;
                                          goto LABEL_178;
                                        }
                                        v363 = "ERROR: bind(listenfd, (struct sockaddr *) &laddr, sizeof(laddr)); failed";
                                      }
                                      my_perror((int)v363);
                                      goto LABEL_360;
                                    }
                                    v286 = 72;
                                    v287 = 71;
                                    v288 = 37;
LABEL_392:
                                    *((_BYTE *)v41 + 1649) = v288;
                                    *(_BYTE *)(v42 + 1648) = v287;
                                    *((_BYTE *)v116 + 1650) = v286;
                                    goto LABEL_393;
                                  }
                                  v286 = 72;
                                  v287 = 71;
                                  v288 = 37;
                                }
LABEL_391:
                                v48 = (NSObject **)&unk_100164000;
                                goto LABEL_392;
                              }
LABEL_383:
                              v286 = 78;
                              v287 = 77;
                              v288 = 30;
                              goto LABEL_391;
                            }
                            v286 = 83;
                            v287 = 82;
                          }
                          v288 = 27;
                          goto LABEL_392;
                        }
                        v302 = v255;
                        v303 = mDNSLogCategory_Default;
                        __error();
                        v304 = __error();
                        strerror(*v304);
                        LogMsgWithLevel(v303, OS_LOG_TYPE_DEFAULT, "WatchForSysEvents: SIOCSKEVFILT failed error %d errno %d (%s)", v305, v306, v307, v308, v309, v302);
                        close(*(_DWORD *)(mDNSStorage[0] + 528));
                        *(_DWORD *)(mDNSStorage[0] + 528) = -1;
                        v289 = -65537;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: WatchForSysEvents failed %d", v297, v298, v299, v300, v301, v289);
                      v64 = v289;
                      goto LABEL_308;
                    }
                    v240 = "SCDynamicStoreCreateRunLoopSource failed: %s";
                  }
                  else
                  {
                    v240 = "SCDynamicStoreSetNotificationKeys failed: %s";
                  }
                  v244 = mDNSLogCategory_Default;
                  v245 = SCError();
                  v246 = SCErrorString(v245);
                  v247 = (char *)v240;
                  v48 = (NSObject **)&unk_100164000;
                  LogMsgWithLevel(v244, OS_LOG_TYPE_DEFAULT, v247, v248, v249, v250, v251, v252, v246);
                  v3 = (const char *)&unk_100158000;
                }
                CFRelease(v218);
              }
              else
              {
                v227 = mDNSLogCategory_Default;
                v228 = SCError();
                v229 = SCErrorString(v228);
                LogMsgWithLevel(v227, OS_LOG_TYPE_DEFAULT, "SCDynamicStoreCreate failed: %s", v230, v231, v232, v233, v234, v229);
                v3 = (_BYTE *)&unk_100158000;
              }
              v226 = -1;
              if (!v223)
                goto LABEL_283;
              goto LABEL_282;
            }
            v64 = -65539;
            v159 = mDNSLogCategory_Default;
            v160 = "SCDynamicStore string setup failed";
LABEL_259:
            LogMsgWithLevel(v159, OS_LOG_TYPE_DEFAULT, v160, v150, v151, v152, v153, v154, v392);
            goto LABEL_308;
          }
LABEL_382:
          __break(1u);
          goto LABEL_383;
        }
LABEL_172:
        ref_count_obj_release(v116);
        goto LABEL_173;
    }
    v92 = v83;
    v93 = (uint64_t)v48[295];
    if (gSensitiveLoggingEnabled != 1 || v93 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v48[295], OS_LOG_TYPE_FAULT))
        goto LABEL_151;
      *(_DWORD *)cStr = 134217984;
      *(_QWORD *)&cStr[4] = v92;
      v85 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }
    else
    {
      v93 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        goto LABEL_151;
      *(_DWORD *)cStr = 134217984;
      *(_QWORD *)&cStr[4] = v92;
      v85 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }
    v95 = v93;
    v96 = OS_LOG_TYPE_FAULT;
    v97 = 12;
    goto LABEL_150;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSResponder cannot be run as root !! Exiting..", v22, v23, v24, v25, v26, v389);
  return -1;
}

void LogMsgWithLevel(NSObject *a1, os_log_type_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint8_t buf[4];
  _OWORD *v12;
  _OWORD __b[32];

  memset(__b, 0, sizeof(__b));
  mDNS_vsnprintf((char *)__b, 512, a3, &a9);
  if (!a1)
    a1 = mDNSLogCategory_Default;
  if (os_log_type_enabled(a1, a2))
  {
    *(_DWORD *)buf = 136380675;
    v12 = __b;
    _os_log_impl((void *)&_mh_execute_header, a1, a2, "%{private}s", buf, 0xCu);
  }
}

uint64_t mDNS_vsnprintf(char *__b, int a2, char *a3, int *a4)
{
  uint64_t v4;
  unsigned int v6;
  unsigned __int8 *v7;
  uint64_t v8;
  int v9;
  char v10;
  char v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int *v17;
  int v18;
  unsigned __int8 *v19;
  unsigned int *v20;
  unsigned int v21;
  int v22;
  char v23;
  char v24;
  int v25;
  unint64_t v26;
  char v27;
  char **v28;
  char *v29;
  int *v30;
  uint64_t v31;
  int v32;
  int *v33;
  _DWORD *v34;
  int v35;
  int *v36;
  int *v37;
  _WORD *v38;
  unsigned int *v39;
  unint64_t v40;
  const char *v41;
  unsigned int *v42;
  unint64_t v43;
  char **v44;
  unsigned int *v45;
  unint64_t v46;
  unint64_t *v47;
  unsigned int v48;
  BOOL v49;
  uint64_t v50;
  char v51;
  char v52;
  unint64_t v53;
  unsigned int v54;
  int v55;
  _BYTE *v56;
  int v57;
  int v58;
  BOOL v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  uint64_t v64;
  unsigned int v65;
  char v66;
  uint64_t v67;
  char v68;
  unsigned int v69;
  unsigned int v70;
  char *v71;
  char *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  char *v87;
  uint64_t v88;
  int v89;
  int v90;
  unsigned int v91;
  char *v92;
  int v93;
  uint64_t v94;
  char *v95;
  int v96;
  int v97;
  void *v98;
  _BYTE *v99;
  int v100;
  int v102;
  unsigned int v103;
  unsigned int v104;
  _OWORD v106[16];
  _BYTE v107[300];
  char v108;
  _BYTE v109[3];

  if (!a2)
    return 0;
  v6 = a2 - 1;
  if (a2 == 1)
  {
    v8 = 0;
    goto LABEL_286;
  }
  v7 = (unsigned __int8 *)a3;
  v8 = 0;
  v9 = *a3;
  v102 = a2 - 2;
  v104 = a2 - 1;
LABEL_4:
  if (v9 != 37)
  {
    if (!v9)
      goto LABEL_286;
    *__b++ = v9;
    v8 = (v8 + 1);
    if (v8 >= v6)
      goto LABEL_286;
    goto LABEL_199;
  }
  v10 = 0;
  v11 = 0;
  v12 = 0;
  memset(v107, 0, sizeof(v107));
  while (2)
  {
    v9 = (char)*++v7;
    v13 = *v7;
    v14 = 4;
    switch(*v7)
    {
      case '*':
        v17 = a4;
        a4 += 2;
        v18 = *v17;
        if (v18 >= 0)
          v15 = v18;
        else
          v15 = -v18;
        v12 |= v18 >> 31;
        v9 = (char)*++v7;
        goto LABEL_26;
      case '+':
        v14 = 2;
        goto LABEL_12;
      case ',':
      case '.':
      case '/':
        goto LABEL_17;
      case '-':
        v14 = 1;
        goto LABEL_12;
      case '0':
LABEL_12:
        v12 |= v14;
        continue;
      default:
        if (v13 == 32)
        {
          v10 = 32;
          continue;
        }
        if (v13 == 35)
        {
          ++v11;
          continue;
        }
LABEL_17:
        if ((v13 - 48) > 9)
        {
          v15 = 0;
        }
        else
        {
          v15 = 0;
          do
          {
            v15 = v9 + 10 * v15 - 48;
            v16 = (char)*++v7;
            v9 = v16;
          }
          while ((v16 - 48) < 0xA);
        }
LABEL_26:
        if (v9 == 46)
        {
          v19 = v7 + 1;
          v9 = (char)v7[1];
          if (v9 == 42)
          {
            v20 = (unsigned int *)a4;
            a4 += 2;
            v21 = *v20;
            v9 = (char)v7[2];
            v19 = v7 + 2;
          }
          else if ((v9 - 48) > 9)
          {
            v21 = 0;
          }
          else
          {
            v21 = 0;
            do
            {
              v21 = v9 + 10 * v21 - 48;
              v22 = (char)*++v19;
              v9 = v22;
            }
            while ((v22 - 48) < 0xA);
          }
          LOBYTE(v12) = v12 | 8;
          v7 = v19;
        }
        else
        {
          v21 = 0;
        }
        if ((v12 & 1) != 0)
          v23 = v12 & 0xFB;
        else
          v23 = v12;
        while (2)
        {
          v24 = 32;
          if (v9 > 87)
          {
            switch(v9)
            {
              case 'a':
                v33 = a4;
                a4 += 2;
                v34 = *(_DWORD **)v33;
                if (!v34)
                {
                  v27 = 1;
                  LODWORD(v26) = 8;
                  v9 = 97;
                  v29 = "<<NULL>>";
                  goto LABEL_155;
                }
                if (!v11)
                {
                  switch(v21)
                  {
                    case 4u:
LABEL_219:
                      v29 = v107;
                      LODWORD(v26) = mDNS_snprintf(v107);
                      v27 = 1;
                      v21 = 4;
                      v9 = 97;
                      v6 = v104;
                      goto LABEL_155;
                    case 6u:
                      v29 = v107;
                      break;
                    case 0x10u:
LABEL_222:
                      v82 = 0;
                      v83 = 0;
                      v84 = 0;
                      v85 = 0;
                      v86 = 0;
                      v87 = (char *)v34 + 1;
                      v88 = 7;
                      while (1)
                      {
                        if (__rev16(*(unsigned __int16 *)(v87 - 1)))
                        {
                          if (v88 <= v84)
                            goto LABEL_232;
                          v86 = 0;
                        }
                        else
                        {
                          if (!v86)
                            v85 = v82;
                          if (v86 + 1 > v84)
                          {
                            v84 = v86 + 1;
                            v83 = v85;
                          }
                          ++v86;
                        }
                        v87 += 2;
                        --v88;
                        ++v82;
                        if (v88 == -1)
                        {
LABEL_232:
                          if (v84 <= 1)
                            v89 = -1;
                          else
                            v89 = v84 + v83 - 1;
                          v90 = 7;
                          v29 = &v108;
                          while (1)
                          {
                            if (v90 == v89)
                            {
                              if (v89 == 7)
                                *--v29 = 58;
                              --v29;
                              v90 = v83;
                            }
                            else
                            {
                              v91 = *((unsigned __int8 *)v34 + 2 * v90 + 1) | (*((unsigned __int8 *)v34 + 2 * v90) << 8);
                              do
                              {
                                v92 = v29;
                                *--v29 = a0123456789abcd[v91 & 0xF];
                                v59 = v91 > 0xF;
                                v91 >>= 4;
                              }
                              while (v59);
                              if (v90 < 1)
                              {
LABEL_245:
                                LODWORD(v26) = &v108 - (_DWORD)v29;
                                v27 = 1;
                                v21 = 16;
                                goto LABEL_261;
                              }
                              v29 = v92 - 2;
                            }
                            *v29 = 58;
                            if (--v90 < 0)
                              goto LABEL_245;
                          }
                        }
                      }
                    default:
                      v29 = v107;
                      break;
                  }
                  v97 = mDNS_snprintf(v107);
                  v6 = v104;
                  LODWORD(v26) = v97;
                  goto LABEL_260;
                }
                v35 = *v34;
                if (!*v34)
                {
                  v29 = v107;
                  goto LABEL_247;
                }
                if (v35 == 6)
                {
                  ++v34;
                  goto LABEL_222;
                }
                if (v35 == 4)
                  goto LABEL_219;
                v29 = v107;
LABEL_247:
                v93 = mDNS_snprintf(v107);
                v6 = v104;
                LODWORD(v26) = v93;
                v21 = 0;
LABEL_260:
                v27 = 1;
LABEL_261:
                v9 = 97;
LABEL_155:
                if (v26 < v15 && (v23 & 1) == 0)
                {
                  LODWORD(v64) = v15 + ~(_DWORD)v26;
                  if (v6 <= (int)v8 + 1)
                    v65 = v8 + 1;
                  else
                    v65 = v6;
                  v103 = v21;
                  v66 = v23;
                  v67 = v4;
                  v68 = v27;
                  v69 = v65 + ~(_DWORD)v8;
                  if (v64 >= v69)
                    v64 = v69;
                  else
                    v64 = v64;
                  memset(__b, 32, v64 + 1);
                  v27 = v68;
                  v4 = v67;
                  v23 = v66;
                  v21 = v103;
                  v6 = v104;
                  do
                  {
                    ++__b;
                    v8 = (v8 + 1);
                    if (v8 >= v104)
                      goto LABEL_286;
                  }
                  while (v26 < --v15);
                }
                v70 = v6 - v8;
                if ((v27 & 1) != 0)
                {
                  if (v26 <= v70)
                  {
                    if ((_DWORD)v26)
                      goto LABEL_188;
                    v70 = 0;
                  }
                  else if (v70)
                  {
                    while ((v29[v70] & 0xC0) == 0x80)
                    {
                      if (!--v70)
                        goto LABEL_191;
                    }
                    LODWORD(v26) = v70;
LABEL_188:
                    v75 = 0;
                    v70 = v26;
                    do
                    {
                      __b[v75] = v29[v75];
                      ++v75;
                    }
                    while ((_DWORD)v26 != (_DWORD)v75);
                    __b += v75;
                  }
                }
                else
                {
                  v71 = __b;
                  if ((v23 & 8) != 0)
                  {
                    v71 = __b;
                    if (v21)
                    {
                      v72 = &__b[v70];
                      v71 = __b;
                      if (__b < v72)
                      {
                        v73 = 0;
                        v71 = __b;
                        do
                        {
                          v74 = v29[v73];
                          if ((_DWORD)v73)
                            *v71++ = 32;
                          if (v71 < v72)
                            *v71++ = a0123456789abcd[v74 >> 4];
                          if (v71 < v72)
                            *v71++ = a0123456789abcd[v74 & 0xF];
                          ++v73;
                        }
                        while (v73 < v21 && v71 < v72);
                      }
                    }
                  }
                  v70 = (_DWORD)v71 - (_DWORD)__b;
                  __b = v71;
                }
LABEL_191:
                v8 = v70 + v8;
                if (v8 >= v6)
                  goto LABEL_286;
                v76 = v15 - v70;
                if (v15 > v70)
                {
                  LODWORD(v77) = v15 + ~v70;
                  if (v77 >= v102 - (int)v8)
                    v77 = (v102 - v8);
                  else
                    v77 = v77;
                  memset(__b, 32, v77 + 1);
                  v6 = v104;
                  do
                  {
                    ++__b;
                    v8 = (v8 + 1);
                    if (v8 >= v104)
                      goto LABEL_286;
                  }
                  while (--v76);
                }
LABEL_199:
                v78 = v9;
                v9 = 0;
                if (v78)
                {
LABEL_200:
                  v79 = (char)*++v7;
                  v9 = v79;
                }
                goto LABEL_4;
              case 'b':
              case 'e':
              case 'f':
              case 'g':
              case 'j':
              case 'k':
              case 'm':
              case 'q':
              case 'r':
              case 't':
              case 'v':
              case 'w':
                goto LABEL_50;
              case 'c':
                v36 = a4;
                a4 += 2;
                v107[299] = *v36;
                LODWORD(v26) = 1;
                v9 = 99;
                v29 = &v107[299];
                goto LABEL_154;
              case 'd':
              case 'i':
                v30 = a4;
                a4 += 2;
                if ((v23 & 0x20) != 0)
                  v31 = *(_QWORD *)v30;
                else
                  v31 = *v30;
                if ((v23 & 0x10) != 0)
                  v31 = (__int16)v31;
                if ((v23 & 2) != 0)
                  v10 = 43;
                if (v31 < 0)
                  v52 = 45;
                else
                  v52 = v10;
                if (v31 >= 0)
                  v46 = v31;
                else
                  v46 = -v31;
                goto LABEL_136;
              case 'h':
                v24 = 16;
                goto LABEL_43;
              case 'l':
                goto LABEL_43;
              case 'n':
                v37 = a4;
                a4 += 2;
                v38 = *(_WORD **)v37;
                if ((v23 & 0x10) != 0)
                {
                  *v38 = v8;
                }
                else if ((v23 & 0x20) != 0)
                {
                  *(_QWORD *)v38 = v8;
                }
                else
                {
                  *(_DWORD *)v38 = v8;
                }
                goto LABEL_200;
              case 'o':
                v39 = (unsigned int *)a4;
                a4 += 2;
                if ((v23 & 0x20) != 0)
                  v40 = *(_QWORD *)v39;
                else
                  v40 = *v39;
                if ((v23 & 0x10) != 0)
                  v53 = (unsigned __int16)v40;
                else
                  v53 = v40;
                if ((v23 & 4) != 0)
                  v54 = v15;
                else
                  v54 = v21;
                if (v54 <= 1)
                  v54 = 1;
                if ((v23 & 8) != 0)
                  v54 = v21;
                if (v54 >= 0x12B)
                  v21 = 299;
                else
                  v21 = v54;
                if (v53)
                {
                  v55 = -1;
                  v56 = v109;
                  do
                  {
                    v57 = v53 & 7 | 0x30;
                    *(v56 - 2) = v53 & 7 | 0x30;
                    v29 = v56 - 2;
                    v58 = v55++;
                    --v56;
                    v59 = v53 > 7;
                    v53 >>= 3;
                  }
                  while (v59);
                  LODWORD(v26) = v58 + 2;
                  if (v11 && v57 != 48)
                  {
                    *(v56 - 2) = 48;
                    LODWORD(v26) = v55 + 2;
                    v29 = v56 - 2;
                  }
                }
                else
                {
                  LODWORD(v26) = 0;
                  v29 = &v108;
                }
                if (v26 >= v21)
                {
                  v27 = 1;
                  v9 = 111;
                }
                else
                {
                  v80 = v21 + ~(_DWORD)v26;
                  v29 += ~v80;
                  memset(v29, 48, v80 + 1);
                  v6 = v104;
                  v27 = 1;
                  v9 = 111;
                  LODWORD(v26) = v21;
                }
                goto LABEL_155;
              case 'p':
                v23 |= 0x28u;
                v21 = 16;
                goto LABEL_66;
              case 's':
                v44 = (char **)a4;
                a4 += 2;
                v29 = *v44;
                if (*v44)
                {
                  if (v11)
                  {
                    if (v11 == 1)
                    {
                      v81 = *v29++;
                      LODWORD(v26) = v81;
                    }
                    else
                    {
                      if (v11 != 2)
                      {
                        LODWORD(v26) = 0;
                        goto LABEL_218;
                      }
                      if (*v29)
                      {
                        v26 = (unint64_t)v107;
                        goto LABEL_254;
                      }
                      v107[0] = 46;
                      v26 = (unint64_t)&v107[1];
                      if (*v29)
                      {
                        while (1)
                        {
LABEL_254:
                          memset(v106, 0, 253);
                          if (*v29 >= 0x40u)
                          {
                            v98 = (void *)v26;
                            goto LABEL_264;
                          }
                          if (v26 + *v29 >= (unint64_t)&v107[254])
                            break;
                          ConvertDomainLabelToCString_withescape((unsigned __int8 *)v29, (unsigned __int8 *)v106, 92);
                          v26 += mDNS_snprintf((void *)v26);
                          v95 = &v29[*v29];
                          v96 = v95[1];
                          v29 = v95 + 1;
                          v6 = v104;
                          if (!v96)
                            goto LABEL_265;
                        }
                        v98 = (void *)v26;
LABEL_264:
                        LODWORD(v26) = v26 + mDNS_snprintf(v98);
                        v6 = v104;
                      }
LABEL_265:
                      v29 = v107;
                      LODWORD(v26) = v26 - v107;
                    }
                  }
                  else if ((v23 & 8) != 0)
                  {
                    if (v21)
                    {
                      v94 = 0;
                      while (v29[v94])
                      {
                        if (v21 == ++v94)
                        {
                          LODWORD(v94) = v21;
                          break;
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v94) = 0;
                    }
                    v26 = v94;
                    do
                    {
                      if (!v26)
                        goto LABEL_218;
                      v99 = (_BYTE *)v26--;
                      v100 = (char)v99[(_QWORD)v29 - 1];
                    }
                    while ((v100 & 0xFFFFFFC0) == 0xFFFFFF80);
                    if (v100 < 0xFFFFFFC0)
                    {
                      LODWORD(v26) = (_DWORD)v99;
                    }
                    else if ((v94 - v26) <= 6 && (v100 >> (7 - (v94 - v26))) == 254)
                    {
                      LODWORD(v26) = v94;
                    }
                  }
                  else
                  {
                    LODWORD(v26) = -1;
                    do
                      LODWORD(v26) = v26 + 1;
                    while (v29[v26]);
                  }
                }
                else
                {
                  LODWORD(v26) = 8;
                  v29 = "<<NULL>>";
                }
                v27 = 1;
                v9 = 115;
                if ((v23 & 8) == 0 || v26 <= v21)
                  goto LABEL_155;
                if (!v21)
                {
                  LODWORD(v26) = 0;
                  goto LABEL_155;
                }
                LODWORD(v26) = v21;
                while ((v29[v26] & 0xC0) == 0x80)
                {
                  v27 = 1;
                  v9 = 115;
                  LODWORD(v26) = v26 - 1;
                  if (!(_DWORD)v26)
                    goto LABEL_155;
                }
LABEL_218:
                v27 = 1;
                v9 = 115;
                goto LABEL_155;
              case 'u':
                v45 = (unsigned int *)a4;
                a4 += 2;
                if ((v23 & 0x20) != 0)
                  v46 = *(_QWORD *)v45;
                else
                  v46 = *v45;
                v52 = 0;
                if ((v23 & 0x10) != 0)
                  v46 = (unsigned __int16)v46;
                v9 = 117;
LABEL_136:
                v60 = v15 - (v52 != 0);
                if ((v23 & 4) == 0)
                  v60 = v21;
                if (v60 <= 1)
                  v60 = 1;
                if ((v23 & 8) != 0)
                  v60 = v21;
                if (v60 >= 0x12B)
                  v21 = 299;
                else
                  v21 = v60;
                if (v46)
                {
                  v61 = 0;
                  do
                  {
                    v107[v61-- + 299] = (v46 % 0xA) | 0x30;
                    v49 = v46 >= 0xA;
                    v46 /= 0xAuLL;
                  }
                  while (v49);
                  LODWORD(v26) = -(int)v61;
                  v29 = &v109[v61 - 1];
                }
                else
                {
                  LODWORD(v26) = 0;
                  v29 = &v108;
                }
                if (v26 < v21)
                {
                  v62 = v21 + ~(_DWORD)v26;
                  v29 += ~v62;
                  v63 = v52;
                  memset(v29, 48, v62 + 1);
                  v52 = v63;
                  v6 = v104;
                  LODWORD(v26) = v21;
                }
                if (v52)
                {
                  *--v29 = v52;
                  LODWORD(v26) = v26 + 1;
                }
                goto LABEL_154;
              case 'x':
                v41 = "0123456789abcdef";
                if ((v23 & 0x20) != 0)
                  goto LABEL_77;
                goto LABEL_67;
              default:
                if (v9 != 88)
                  goto LABEL_50;
LABEL_66:
                v41 = "0123456789ABCDEF";
                if ((v23 & 0x20) != 0)
                {
LABEL_77:
                  v47 = (unint64_t *)a4;
                  a4 += 2;
                  v43 = *v47;
                }
                else
                {
LABEL_67:
                  v42 = (unsigned int *)a4;
                  a4 += 2;
                  v43 = *v42;
                }
                if ((v23 & 0x10) != 0)
                  v43 = (unsigned __int16)v43;
                v48 = v15 - 2;
                if (!v11)
                  v48 = v15;
                if ((v23 & 4) == 0)
                  v48 = v21;
                if (v48 <= 1)
                  v48 = 1;
                if ((v23 & 8) != 0)
                  v48 = v21;
                if (v48 >= 0x12B)
                  v21 = 299;
                else
                  v21 = v48;
                LODWORD(v26) = 0;
                if (v43)
                {
                  v29 = &v108;
                  do
                  {
                    *--v29 = v41[v43 & 0xF];
                    LODWORD(v26) = v26 + 1;
                    v49 = v43 >= 0x10;
                    v43 >>= 4;
                  }
                  while (v49);
                }
                else
                {
                  v29 = &v108;
                }
                if (v26 < v21)
                {
                  v50 = v21 + ~(_DWORD)v26;
                  v29 += ~v50;
                  v51 = v11;
                  memset(v29, 48, v50 + 1);
                  v11 = v51;
                  v6 = v104;
                  LODWORD(v26) = v21;
                }
                if (v11)
                {
                  *(v29 - 2) = 48;
                  v29 -= 2;
                  v29[1] = v9;
                  LODWORD(v26) = v26 + 2;
                }
                goto LABEL_154;
            }
          }
          if (v9 == 76)
          {
LABEL_43:
            v23 |= v24;
            v25 = (char)*++v7;
            v9 = v25;
            continue;
          }
          break;
        }
        if (v9 != 37)
        {
          if (v9 == 72)
          {
            LODWORD(v26) = 0;
            v27 = 0;
            v28 = (char **)a4;
            a4 += 2;
            v29 = *v28;
          }
          else
          {
LABEL_50:
            v29 = v107;
            v32 = mDNS_snprintf(v107);
            v6 = v104;
            LODWORD(v26) = v32;
LABEL_154:
            v27 = 1;
          }
          goto LABEL_155;
        }
        *__b++ = 37;
        v8 = (v8 + 1);
        if (v8 < v6)
        {
          LODWORD(v26) = 0;
          v27 = 1;
          v29 = &v108;
          goto LABEL_155;
        }
LABEL_286:
        *__b = 0;
        return v8;
    }
  }
}

uint64_t KQueueSet(int a1, uint16_t a2, int16_t a3, void *a4)
{
  int v4;
  uint64_t result;
  kevent v6;

  v6.ident = a1;
  v6.filter = a3;
  v6.flags = a2;
  v6.fflags = 0;
  v6.data = 0;
  v6.udata = a4;
  v4 = kevent(KQueueFD, &v6, 1, 0, 0, 0);
  result = 0;
  if (v4 < 0)
    return *__error();
  return result;
}

void mDNSMacOSXSystemBuildNumber(void *a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFDictionary *v8;
  const __CFString *Value;
  const __CFString *v10;
  const __CFString *v11;
  int *v12;
  int v13;
  char v14;
  uint64_t v15;
  char v16[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _OWORD v32[16];
  _OWORD buffer[16];

  v15 = 0;
  v14 = 0;
  buffer[0] = *(_OWORD *)"<Unknown>";
  memset(&buffer[1], 0, 240);
  v32[0] = *(_OWORD *)"<Unknown>";
  memset(&v32[1], 0, 240);
  v28 = xmmword_10010014C;
  v29 = unk_10010015C;
  v30 = xmmword_10010016C;
  v31 = unk_10010017C;
  v24 = xmmword_10010010C;
  v25 = unk_10010011C;
  v26 = xmmword_10010012C;
  v27 = unk_10010013C;
  v20 = xmmword_1001000CC;
  v21 = unk_1001000DC;
  v22 = xmmword_1001000EC;
  v23 = unk_1001000FC;
  *(_OWORD *)v16 = *(_OWORD *)"<Unknown>";
  v17 = unk_10010009C;
  v18 = xmmword_1001000AC;
  v19 = unk_1001000BC;
  v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (!v2)
    goto LABEL_10;
  v8 = v2;
  Value = (const __CFString *)CFDictionaryGetValue(v2, _kCFSystemVersionProductNameKey);
  v10 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionProductVersionKey);
  v11 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionBuildVersionKey);
  if (Value)
    CFStringGetCString(Value, (char *)buffer, 256, 0x8000100u);
  if (v10)
    CFStringGetCString(v10, (char *)v32, 256, 0x8000100u);
  if (v11 && CFStringGetCString(v11, v16, 256, 0x8000100u))
    sscanf(v16, "%d%c%d", (char *)&v15 + 4, &v14, &v15);
  CFRelease(v8);
  if (!HIDWORD(v15))
  {
LABEL_10:
    HIDWORD(v15) = 13;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: No Major Build Version number found; assuming 13",
      v3,
      v4,
      v5,
      v6,
      v7,
      v13);
  }
  if (a1)
    mDNS_snprintf(a1);
  if ((buffer[0] & 0xDF) == 0x4D)
    v12 = &OSXVers;
  else
    v12 = &iOSVers;
  *v12 = HIDWORD(v15);
}

unint64_t mDNSPlatformRawTime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;

  if (mDNSPlatformClockDivisor)
  {
    v13 = mach_absolute_time();
    if ((uint64_t)(v13 - mDNSPlatformRawTime_last_mach_absolute_time) < 0)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime: last_mach_absolute_time %08X%08X", v8, v9, v10, v11, v12, mDNSPlatformRawTime_last_mach_absolute_time);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime: this_mach_absolute_time %08X%08X", v14, v15, v16, v17, v18, v13);
      mDNSPlatformRawTime_last_mach_absolute_time = v13;
      NotifyOfElusiveBug((int)"mach_absolute_time went backwards!", (int)"This error occurs from time to time, often on newly released hardware, and usually the exact cause is different in each instance.\r\rPlease file a new Radar bug report with the title mach_absolute_time went backwards and assign it to Radar Component Kernel Version X.", v19, v20, v21, v22, v23, v24);
    }
    mDNSPlatformRawTime_last_mach_absolute_time = v13;
    return v13 / mDNSPlatformClockDivisor;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime called before mDNSPlatformTimeInit", a4, a5, a6, a7, a8, v26);
    return 0;
  }
}

uint64_t mDNS_snprintf(void *a1)
{
  return mDNS_vsnprintf(a1);
}

void GetUserSpecifiedLocalHostName(_BYTE *a1)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = SCDynamicStoreCopyLocalHostName(0);
  if (v2)
  {
    v3 = v2;
    mDNSDomainLabelFromCFString(v2, a1);
    CFRelease(v3);
  }
}

uint64_t SetupSocket(_QWORD *a1, unsigned __int16 a2, int a3, _WORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  int v32;
  unsigned int v33;
  const char *v34;
  char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  socklen_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  NSObject *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  int v81;
  int v82;
  int v83;
  _BYTE v84[24];
  int v85;
  uint8_t buf[4];
  char *v87;

  if (a3 == 2)
    v8 = 2;
  else
    v8 = 6;
  v83 = 1;
  v81 = 0;
  v82 = 255;
  if (a3 == 2)
    v9 = 3;
  else
    v9 = 7;
  if (a3 == 2)
    v10 = a1 + 3;
  else
    v10 = a1 + 7;
  a1[10] = 0;
  v11 = socket(a3, 2, 17);
  v12 = v11;
  if ((int)v11 <= 2)
  {
    if (*__error() != 47)
    {
      v13 = mDNSLogCategory_Default;
      __error();
      v14 = __error();
      strerror(*v14);
      LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SetupSocket: socket error %d errno %d (%s)", v15, v16, v17, v18, v19, v12);
    }
    return v12;
  }
  *(_DWORD *)v84 = 900;
  setsockopt(v11, 0xFFFF, 4230, v84, 4u);
  if (a2 != 59668)
  {
    if (a2 != 58900)
      goto LABEL_31;
    v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
    if ((v21 & 0x80000000) == 0)
    {
      v32 = 1;
      goto LABEL_32;
    }
LABEL_27:
    v33 = v21;
    v34 = "setsockopt - SO_REUSEPORT";
    goto LABEL_73;
  }
  v20 = setsockopt(v12, 0xFFFF, 4356, &v83, 4u);
  if (v20 < 0)
  {
    v33 = v20;
    v34 = "setsockopt - SO_RECV_ANYIF";
    goto LABEL_73;
  }
  v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
  if (v21 < 0)
    goto LABEL_27;
  *(_DWORD *)v84 = 1;
  if (setsockopt(v12, 0xFFFF, 0x10000, v84, 4u) == -1 && mDNS_LoggingEnabled)
  {
    v22 = mDNSLogCategory_Default;
    v23 = __error();
    v24 = strerror(*v23);
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetupSocket: SO_NOWAKEFROMSLEEP failed %s", v25, v26, v27, v28, v29, v24);
  }
  *(_OWORD *)v84 = xmmword_100100A30;
  if (!setsockopt(v12, 0xFFFF, 4360, v84, 0x10u))
    goto LABEL_31;
  v30 = *__error();
  v31 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
    {
LABEL_30:
      v35 = strerror(v30);
      *(_DWORD *)buf = 136446210;
      v87 = v35;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "SetupSocket: Attributing mDNS traffic to com.apple.datausage.dns.multicast failed: %{public}s", buf, 0xCu);
    }
  }
  else
  {
    v31 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_30;
  }
LABEL_31:
  v32 = 0;
LABEL_32:
  if (a3 == 2)
  {
    v36 = setsockopt(v12, 0, 7, &v83, 4u);
    if (v36 < 0)
    {
      v33 = v36;
      v34 = "setsockopt - IP_RECVDSTADDR";
    }
    else
    {
      v37 = setsockopt(v12, 0, 20, &v83, 4u);
      if (v37 < 0)
      {
        v33 = v37;
        v34 = "setsockopt - IP_RECVIF";
      }
      else
      {
        v38 = setsockopt(v12, 0, 24, &v83, 4u);
        if (v38 < 0)
        {
          v33 = v38;
          v34 = "setsockopt - IP_RECVTTL";
        }
        else
        {
          v39 = setsockopt(v12, 0, 4, &v82, 4u);
          if (v39 < 0)
          {
            v33 = v39;
            v34 = "setsockopt - IP_TTL";
          }
          else
          {
            v40 = setsockopt(v12, 0, 10, &v82, 4u);
            if ((v40 & 0x80000000) == 0)
            {
              *(_QWORD *)v84 = 512;
              *(_QWORD *)&v84[8] = 0;
              *(_WORD *)&v84[2] = a2;
              if (v32)
                v41 = 16777440;
              else
                v41 = 0;
              *(_DWORD *)&v84[4] = v41;
              v42 = v12;
              v43 = 16;
LABEL_42:
              v44 = bind(v42, (const sockaddr *)v84, v43);
              if (v44)
              {
                v33 = v44;
                v34 = "bind";
                goto LABEL_73;
              }
              if (a4)
                *a4 = *(_WORD *)&v84[2];
              goto LABEL_67;
            }
            v33 = v40;
            v34 = "setsockopt - IP_MULTICAST_TTL";
          }
        }
      }
    }
  }
  else
  {
    if (a3 != 30)
    {
LABEL_67:
      v61 = fcntl(v12, 3, 0, v78, v79, v80);
      fcntl(v12, 4, v61 | 4u);
      fcntl(v12, 2, 1);
      LODWORD(a1[v8]) = v12;
      a1[v9] = myKQSocketCallBack;
      v10[1] = a1;
      v10[2] = "UDP packet reception";
      KQueueSet(v12, 1u, -1, v10);
      return 0;
    }
    if (v32)
    {
      if (a4)
        *a4 = 0;
      close(v12);
      return 0;
    }
    v45 = setsockopt(v12, 41, 61, &v83, 4u);
    if (v45 < 0)
    {
      v33 = v45;
      v34 = "setsockopt - IPV6_RECVPKTINFO";
    }
    else
    {
      v46 = setsockopt(v12, 41, 37, &v83, 4u);
      if (v46 < 0)
      {
        v33 = v46;
        v34 = "setsockopt - IPV6_RECVHOPLIMIT";
      }
      else
      {
        v47 = setsockopt(v12, 41, 27, &v83, 4u);
        if (v47 < 0)
        {
          v33 = v47;
          v34 = "setsockopt - IPV6_V6ONLY";
        }
        else
        {
          v48 = setsockopt(v12, 41, 4, &v82, 4u);
          if (v48 < 0)
          {
            v33 = v48;
            v34 = "setsockopt - IPV6_UNICAST_HOPS";
          }
          else
          {
            v49 = setsockopt(v12, 41, 10, &v82, 4u);
            if (v49 < 0)
            {
              v33 = v49;
              v34 = "setsockopt - IPV6_MULTICAST_HOPS";
            }
            else
            {
              v50 = setsockopt(v12, 41, 11, &v83, 4u);
              if ((v50 & 0x80000000) == 0)
              {
                v51 = setsockopt(v12, 41, 42, &v81, 4u);
                if ((v51 & 0x80000000) != 0)
                {
                  v52 = v51;
                  v53 = mDNSLogCategory_Default;
                  v54 = *__error();
                  v55 = __error();
                  v79 = v54;
                  v80 = strerror(*v55);
                  v78 = v52;
                  LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "SetupSocket: setsockopt - IPV6_USE_MIN_MTU: IP6PO_MINMTU_DISABLE socket %d err %d errno %d (%s)", v56, v57, v58, v59, v60, v12);
                }
                *(_WORD *)v84 = 7708;
                *(_WORD *)&v84[2] = a2;
                *(_DWORD *)&v84[4] = 0;
                *(in6_addr *)&v84[8] = in6addr_any;
                v85 = 0;
                v42 = v12;
                v43 = 28;
                goto LABEL_42;
              }
              v33 = v50;
              v34 = "setsockopt - IPV6_MULTICAST_LOOP";
            }
          }
        }
      }
    }
  }
LABEL_73:
  v62 = *__error();
  if (strcmp(v34, "bind") || !a2 || a2 == 59668)
  {
    v63 = mDNSLogCategory_Default;
    strerror(v62);
    LogMsgWithLevel(v63, OS_LOG_TYPE_DEFAULT, "%s skt %d port %d error %d errno %d (%s)", v64, v65, v66, v67, v68, (int)v34);
  }
  v75 = !strcmp(v34, "bind") && v62 == 48;
  if (v75)
    v76 = 48;
  else
    v76 = v33;
  if (v75 && a2 == 59668)
  {
    NotifyOfElusiveBug((int)"Setsockopt SO_REUSEPORT failed", (int)"Congratulations, you've reproduced an elusive bug.\rPlease contact the current assignee of <rdar://problem/3814904>.\rAlternatively, you can send email to radar-3387020@group.apple.com. (Note number is different.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.", v69, v70, v71, v72, v73, v74);
    v76 = 48;
  }
  close(v12);
  return v76;
}

void SystemWakeForNetworkAccess()
{
  NSObject *v0;
  uint8_t *v2;
  __int16 v4;
  __int16 v5;

  v0 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEBUG))
      return;
    v5 = 0;
    v2 = (uint8_t *)&v5;
    goto LABEL_10;
  }
  v0 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEBUG))
  {
    v4 = 0;
    v2 = (uint8_t *)&v4;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "SystemWakeForNetworkAccess: compile-time disabled", v2, 2u);
  }
}

__n128 UpdateInterfaceList(int a1)
{
  uint64_t v1;
  int v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v13;
  const __CFString *v14;
  _QWORD *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  int *v32;
  uint64_t v33;
  CFStringEncoding v34;
  uint64_t v35;
  BOOL v36;
  BOOL v37;
  uint64_t v39;
  int v40;
  const __CFDictionary *v41;
  io_service_t MatchingService;
  const __CFString *CFProperty;
  const __CFString *v44;
  CFTypeID v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  int v50;
  uint64_t v52;
  int v53;
  NSObject *v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 *v70;
  uint64_t v71;
  int v72;
  NSObject *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  const __CFString *v86;
  const __CFString *v87;
  const __CFDictionary *v88;
  const __CFDictionary *v89;
  const __CFData *Value;
  const __CFData *v91;
  uint64_t v92;
  uint64_t v93;
  int ExtendedFlags;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  int v121;
  int v122;
  char v123;
  unsigned int v124;
  _BOOL4 v125;
  int v126;
  int v127;
  uint64_t v128;
  int v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  int *v133;
  char *v134;
  NSObject *v135;
  int *v137;
  char *v138;
  _BOOL4 v139;
  int *v140;
  char *v141;
  int v142;
  int v143;
  uint64_t v144;
  int v145;
  int v146;
  char v147;
  unsigned int v148;
  NSObject *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  BOOL v156;
  _DWORD *v157;
  _QWORD *v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  void *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  NSObject *v166;
  unsigned __int8 *v167;
  _BYTE *v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  int v172;
  char v173;
  uint64_t v174;
  unsigned int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  NSObject *v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  uint8_t *v184;
  uint8_t v185;
  unsigned __int8 *v186;
  int v187;
  BOOL v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  unsigned int v194;
  char *v195;
  char v196;
  unsigned __int8 *v197;
  int v198;
  BOOL v199;
  unsigned int v200;
  uint64_t v201;
  size_t v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  int v206;
  __n128 result;
  _OWORD *v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  uint64_t v213;
  char *v214;
  CFStringEncoding *v215;
  uint8_t *v216;
  uint64_t v217;
  __int16 v218;
  int v219;
  char *__s1;
  os_log_t log;
  os_log_t loga;
  NSObject *logb;
  CFStringEncoding nameEncoding[4];
  __int128 v226;
  __int128 v227;
  __int128 v228;
  uint8_t buf[48];
  __int128 v230;
  _OWORD v231[14];
  _OWORD v232[4];
  __int128 values;
  int v234;
  _BYTE v235[24];
  CFRange v236;

  v1 = myGetIfAddrs_ifa;
  if (!myGetIfAddrs_ifa)
  {
    getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
    v1 = myGetIfAddrs_ifa;
  }
  memset(v232, 0, sizeof(v232));
  v2 = socket(30, 2, 0);
  v3 = &unk_100164000;
  if (v2 <= 2 && *__error() != 47)
  {
    v4 = mDNSLogCategory_Default;
    v5 = *__error();
    v6 = __error();
    v213 = v5;
    v214 = strerror(*v6);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: InfoSocket error %d errno %d (%s)", v7, v8, v9, v10, v11, v2);
  }
  if (BYTE1(dword_100158E54) != 2 && v1 != 0)
  {
    do
    {
      if (!*(_QWORD *)(v1 + 24))
        goto LABEL_95;
      v16 = *(const char **)(v1 + 8);
      if (!strncmp(v16, "llw", 3uLL))
      {
        v28 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 136446210;
          *(_QWORD *)&nameEncoding[1] = v16;
          v26 = v28;
          v27 = "isExcludedInterface: excluding %{public}s";
          goto LABEL_30;
        }
        goto LABEL_95;
      }
      if (v2 < 0)
      {
        v29 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 67109120;
          nameEncoding[1] = v2;
          v30 = v29;
          v31 = "isExcludedInterface: invalid socket FD passed: %d";
LABEL_35:
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, v31, (uint8_t *)nameEncoding, 8u);
        }
      }
      else
      {
        memset(buf, 0, 32);
        if (!v16)
          goto LABEL_284;
        v17 = 0;
        while (1)
        {
          v18 = v16[v17];
          buf[v17] = v18;
          if (!v18)
            break;
          if (++v17 == 15)
          {
            buf[15] = 0;
            break;
          }
        }
        if (ioctl(v2, 0xC02069ADuLL, buf, v213, v214, v215, v216, v217) == -1)
        {
          v32 = __error();
          v33 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            v34 = *v32;
            nameEncoding[0] = 67109120;
            nameEncoding[1] = v34;
            v30 = v33;
            v31 = "isExcludedInterface: SIOCGIFFUNCTIONALTYPE failed -- error: %{darwin.errno}d";
            goto LABEL_35;
          }
        }
        else if (*(_DWORD *)&buf[16] == 6)
        {
          v25 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            nameEncoding[0] = 136446210;
            *(_QWORD *)&nameEncoding[1] = v16;
            v26 = v25;
            v27 = "isExcludedInterface: excluding coprocessor interface %{public}s";
LABEL_30:
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, v27, (uint8_t *)nameEncoding, 0xCu);
            goto LABEL_95;
          }
          goto LABEL_95;
        }
      }
      v35 = *(_QWORD *)(v1 + 24);
      if (*(_BYTE *)(v35 + 1) != 18)
        goto LABEL_78;
      if (*(_BYTE *)(v35 + 4) == 6)
      {
        v36 = *(_BYTE *)(v35 + 6) == 6 && (unsigned __int16)dword_100158DE0 == 0;
        v37 = v36 && HIWORD(dword_100158DE0) == 0;
        if (v37 && word_100158DE4 == 0)
        {
          v39 = v35 + *(unsigned __int8 *)(v35 + 5);
          v40 = *(_DWORD *)(v39 + 8);
          word_100158DE4 = *(_WORD *)(v39 + 12);
          dword_100158DE0 = v40;
        }
      }
      if ((getExtendedFlags(*(_QWORD *)(v1 + 8)) & 0x100000) == 0 || AWDLInterfaceID && WiFiAwareInterfaceID)
        goto LABEL_78;
      *(_QWORD *)nameEncoding = CFSTR("IOInterfaceName");
      *(_QWORD *)&values = 0;
      *(_QWORD *)&values = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(v1 + 8), 0x8000100u);
      *(_QWORD *)v235 = 0;
      *(_QWORD *)v235 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)nameEncoding, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      *(_QWORD *)nameEncoding = CFSTR("IOPropertyMatch");
      v41 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)nameEncoding, (const void **)v235, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v41);
      if ((_QWORD)values)
      {
        CFRelease((CFTypeRef)values);
        *(_QWORD *)&values = 0;
      }
      if (*(_QWORD *)v235)
      {
        CFRelease(*(CFTypeRef *)v235);
        *(_QWORD *)v235 = 0;
      }
      if (!MatchingService)
        goto LABEL_78;
      CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(MatchingService, CFSTR("IO80211VirtualInterfaceRole"), kCFAllocatorDefault, 0);
      if (CFProperty)
      {
        v44 = CFProperty;
        v45 = CFGetTypeID(CFProperty);
        if (v45 == CFStringGetTypeID())
        {
          if (!AWDLInterfaceID && CFStringCompare(v44, CFSTR("AirLink"), 0) == kCFCompareEqualTo)
          {
            log = (os_log_t)*(unsigned __int16 *)(v35 + 2);
            AWDLInterfaceID = (uint64_t)log;
            v46 = *((_QWORD *)v3 + 295);
            if (gSensitiveLoggingEnabled != 1 || v46 == mDNSLogCategory_State)
            {
              if (os_log_type_enabled(*((os_log_t *)v3 + 295), OS_LOG_TYPE_DEFAULT))
                goto LABEL_67;
            }
            else
            {
              v46 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_67:
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = log;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: AWDLInterfaceID = %lu", buf, 0xCu);
              }
            }
          }
          if (!WiFiAwareInterfaceID
            && CFStringCompare(v44, CFSTR("WiFi-Aware Discovery+Data"), 0) == kCFCompareEqualTo)
          {
            v47 = *(unsigned __int16 *)(v35 + 2);
            WiFiAwareInterfaceID = v47;
            v48 = *((_QWORD *)v3 + 295);
            if (gSensitiveLoggingEnabled != 1 || v48 == mDNSLogCategory_State)
            {
              if (os_log_type_enabled(*((os_log_t *)v3 + 295), OS_LOG_TYPE_DEFAULT))
                goto LABEL_75;
            }
            else
            {
              v48 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_75:
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v47;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: WiFiAwareInstanceID = %lu", buf, 0xCu);
              }
            }
          }
        }
        CFRelease(v44);
      }
      IOObjectRelease(MatchingService);
LABEL_78:
      if ((*(_BYTE *)(v1 + 16) & 1) == 0)
        goto LABEL_95;
      v49 = *(_QWORD *)(v1 + 24);
      v50 = *(unsigned __int8 *)(v49 + 1);
      if (v50 != 30 && v50 != 2)
        goto LABEL_95;
      v52 = *(_QWORD *)(v1 + 32);
      if (!v52)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v49, v19, v20, v21, v22, v23, v24);
        v62 = *((_QWORD *)v3 + 295);
        v63 = *(const char **)(v1 + 8);
        v64 = if_nametoindex(v63);
        v215 = (CFStringEncoding *)*(unsigned __int8 *)(*(_QWORD *)(v1 + 24) + 1);
        v216 = buf;
        v213 = v64;
        v214 = (char *)*(unsigned int *)(v1 + 16);
        LogMsgWithLevel(v62, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: ifa_netmask is NULL for %5s(%d) Flags %04X Family %2d %#a", v65, v66, v67, v68, v69, (int)v63);
        goto LABEL_95;
      }
      v53 = *(unsigned __int8 *)(v52 + 1);
      if (v53 != v50 && v53)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v49, v19, v20, v21, v22, v23, v24);
        v54 = *((_QWORD *)v3 + 295);
        v55 = *(const char **)(v1 + 8);
        v56 = if_nametoindex(v55);
        v216 = buf;
        v217 = *(unsigned __int8 *)(*(_QWORD *)(v1 + 32) + 1);
        v214 = (char *)*(unsigned int *)(v1 + 16);
        v215 = (CFStringEncoding *)*(unsigned __int8 *)(*(_QWORD *)(v1 + 24) + 1);
        v213 = v56;
        LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: ifa_netmask for %5s(%d) Flags %04X Family %2d %#a has different family: %d", v57, v58, v59, v60, v61, (int)v55);
        goto LABEL_95;
      }
      if ((int)if_nametoindex(*(const char **)(v1 + 8)) <= 0)
      {
        v73 = *((_QWORD *)v3 + 295);
        v74 = *(const char **)(v1 + 8);
        v213 = if_nametoindex(v74);
        LogMsgWithLevel(v73, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: if_nametoindex returned zero/negative value for %5s(%d)", v75, v76, v77, v78, v79, (int)v74);
        goto LABEL_95;
      }
      v70 = *(__int128 **)(v1 + 24);
      v71 = *(_QWORD *)(v1 + 32);
      v72 = *((unsigned __int8 *)v70 + 1);
      *(_BYTE *)(v71 + 1) = v72;
      if (v72 == 30)
      {
        if ((v2 & 0x80000000) == 0)
        {
          memset(v231, 0, sizeof(v231));
          v230 = 0u;
          memset(buf, 0, sizeof(buf));
          v80 = *(_QWORD *)(v1 + 8);
          if (!v80)
            goto LABEL_284;
          v81 = 0;
          while (1)
          {
            v82 = *(unsigned __int8 *)(v80 + v81);
            buf[v81] = v82;
            if (!v82)
              break;
            if (++v81 == 15)
            {
              buf[15] = 0;
              break;
            }
          }
          v83 = *v70;
          *(_OWORD *)&buf[28] = *(__int128 *)((char *)v70 + 12);
          *(_OWORD *)&buf[16] = v83;
          if (ioctl(v2, 0xC1206949uLL, buf) != -1 && (buf[16] & 0x9A) != 0)
            goto LABEL_95;
        }
      }
      else if (v72 == 2 && *(_DWORD *)(v71 + 4) == -1)
      {
        goto LABEL_95;
      }
      v84 = if_nametoindex(*(const char **)(v1 + 8));
      v85 = *(_QWORD *)(v1 + 8);
      *(_WORD *)&buf[4] = 0;
      *(_DWORD *)buf = 0;
      v86 = CFStringCreateWithFormat(0, 0, CFSTR("State:/Network/Interface/%s/AirPort"), v85);
      if (v86)
      {
        v87 = v86;
        v88 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, v86);
        if (v88)
        {
          v89 = v88;
          Value = (const __CFData *)CFDictionaryGetValue(v88, CFSTR("BSSID"));
          if (Value)
          {
            v91 = Value;
            if (CFDataGetLength(Value) == 6)
            {
              v236.location = 0;
              v236.length = 6;
              CFDataGetBytes(v91, v236, buf);
            }
          }
          CFRelease(v89);
        }
        CFRelease(v87);
      }
      v92 = *(unsigned __int16 *)&buf[4];
      v93 = *(unsigned int *)buf;
      ExtendedFlags = getExtendedFlags(*(_QWORD *)(v1 + 8));
      memset(nameEncoding, 0, sizeof(nameEncoding));
      LODWORD(v226) = 0;
      values = 0uLL;
      v234 = 0;
      if (SetupAddr((uint64_t)nameEncoding, *(_QWORD *)(v1 + 24), v95, v96, v97, v98, v99, v100)
        || SetupAddr((uint64_t)&values, *(_QWORD *)(v1 + 32), v101, v102, v103, v104, v105, v106))
      {
        goto LABEL_95;
      }
      v218 = v92;
      v219 = ExtendedFlags;
      v107 = v93 | (v92 << 32);
      loga = (os_log_t)(v107 >> 16);
      v108 = mDNSStorage[0];
      v109 = *(_QWORD *)mDNSStorage[0];
      if (!*(_QWORD *)mDNSStorage[0])
      {
LABEL_122:
        v111 = (char *)malloc_type_calloc(1uLL, 0xEC8uLL, 0xF1748037uLL);
        if (!v111
          || (v117 = (uint64_t)v111,
              *((_QWORD *)v111 + 444) = v84,
              *((_DWORD *)v111 + 894) = v226,
              *(_OWORD *)(v111 + 3560) = *(_OWORD *)nameEncoding,
              *((_DWORD *)v111 + 899) = v234,
              *(_OWORD *)(v111 + 3580) = values,
              (v118 = *(_QWORD *)(v1 + 8)) == 0))
        {
LABEL_284:
          __break(1u);
        }
        v119 = 3606;
        v120 = 64;
        while (1)
        {
          v121 = *(unsigned __int8 *)(v118 + v119 - 3606);
          v111[v119] = v121;
          if (!v121)
            break;
          --v120;
          ++v119;
          if (v120 <= 1)
          {
            v111[v119] = 0;
            break;
          }
        }
        v111[3669] = 0;
        if (byte_100158DD6)
        {
          v122 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
          v123 = v122;
        }
        else
        {
          v123 = byte_100158DD5;
          v122 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
        }
        v111[3670] = v123;
        v111[3673] = v122;
        v111[3674] = (v219 & 0x800) == 0;
        __s1 = v111 + 3606;
        if ((v219 & 0x20100000) != 0 || !strncmp(v111 + 3606, "p2p", 3uLL))
          v124 = 1;
        else
          v124 = util_is_car_play((uint64_t)__s1);
        *(_BYTE *)(v117 + 3676) = v124;
        if (v124 && mDNS_LoggingEnabled)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: DirectLink set for %s", v112, v113, v114, v115, v116, *(_QWORD *)(v1 + 8));
        *(_QWORD *)(v117 + 3680) = 0;
        *(_QWORD *)(v117 + 3688) = mDNSStorage;
        v125 = 1;
        *(_WORD *)(v117 + 3696) = 1;
        *(_BYTE *)(v117 + 3698) = 0;
        if ((v219 & 0x20000) == 0)
          v125 = strncmp(__s1, "p2p", 3uLL) == 0;
        *(_BYTE *)(v117 + 3699) = v125;
        if (v125 && mDNS_LoggingEnabled)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: D2DInterface set for %s", v112, v113, v114, v115, v116, *(_QWORD *)(v1 + 8));
        *(_BYTE *)(v117 + 3752) = (unint64_t)(v219 & 0x100000) >> 20;
        *(_BYTE *)(v117 + 3677) = (v219 & 0x100000) == 0;
        *(_DWORD *)(v117 + 3700) = a1;
        *(_DWORD *)(v117 + 3704) = a1;
        *(_DWORD *)(v117 + 3712) = *(_DWORD *)(v1 + 16);
        *(_DWORD *)(v117 + 3720) = v84;
        *(_WORD *)(v117 + 3724) = v93;
        *(_WORD *)(v117 + 3726) = (_WORD)loga;
        *(_WORD *)(v117 + 3728) = v218;
        *(_WORD *)(v117 + 3730) = *(unsigned __int8 *)(*(_QWORD *)(v1 + 24) + 1);
        *(_QWORD *)(v117 + 3776) = 0;
        *(_OWORD *)(v117 + 3732) = xmmword_100100980;
        v126 = socket(2, 2, 0);
        if (v126 != -1)
        {
          v127 = v126;
          v128 = 0;
          memset(buf, 0, 32);
          while (1)
          {
            v129 = __s1[v128];
            buf[v128] = v129;
            if (!v129)
              break;
            if (++v128 == 15)
            {
              buf[15] = 0;
              break;
            }
          }
          if (ioctl(v126, 0xC020699FuLL, buf) != -1)
          {
            v130 = *(_DWORD *)&buf[20];
            *(_DWORD *)(v117 + 3744) = *(_DWORD *)&buf[24];
            goto LABEL_167;
          }
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            logb = mDNSLogCategory_Default;
            v130 = 0;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
              goto LABEL_166;
          }
          else
          {
            logb = mDNSLogCategory_Default_redacted;
            v139 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
            v130 = 0;
            if (v139)
            {
LABEL_166:
              v140 = __error();
              v141 = strerror(*v140);
              *(_DWORD *)v235 = 136446210;
              *(_QWORD *)&v235[4] = v141;
              _os_log_impl((void *)&_mh_execute_header, logb, OS_LOG_TYPE_DEFAULT, "GetIFTFamily: SIOCGIFTYPE failed: %{public}s", v235, 0xCu);
              v130 = 0;
            }
          }
LABEL_167:
          close(v127);
LABEL_168:
          *(_DWORD *)(v117 + 3708) = v130;
          v142 = socket(30, 2, 0);
          if (v142 == -1)
          {
            v146 = 0;
          }
          else
          {
            v143 = v142;
            v144 = 0;
            memset(buf, 0, 32);
            while (1)
            {
              v145 = __s1[v144];
              buf[v144] = v145;
              if (!v145)
                break;
              if (++v144 == 15)
              {
                buf[15] = 0;
                break;
              }
            }
            if (ioctl(v142, 0xC02069ADuLL, buf) == -1)
              v146 = 0;
            else
              v146 = *(_DWORD *)&buf[16];
            close(v143);
          }
          *(_DWORD *)(v117 + 3748) = v146;
          v147 = *(_BYTE *)(*(_QWORD *)(v117 + 3688) + 120);
          if (v147)
            v147 = (*(_DWORD *)(v117 + 3712) & 0x8000) != 0 && (*(_DWORD *)(v117 + 3712) & 0x10) == 0;
          *(_BYTE *)(v117 + 3671) = v147;
          if (*(_DWORD *)(v117 + 3744) == 3)
            v148 = util_is_managed_network((uint64_t)__s1);
          else
            v148 = 0;
          *(_BYTE *)(v117 + 3753) = v148;
          v149 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
              goto LABEL_190;
          }
          else
          {
            v149 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_190:
              v155 = *(_QWORD *)(v117 + 3552);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = __s1;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v155;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v148;
              _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "AddInterfaceToList: Privacy risk -- ifname: %{public}s, ifid: %d, risk: %{mdns:yesno}d", buf, 0x18u);
            }
          }
          v156 = (v219 & 0x4000) == 0 && NetWakeInterface(v117);
          *(_BYTE *)(v117 + 3672) = v156;
          v157 = (_DWORD *)(v117 + 3600);
          v158 = (_QWORD *)myGetIfAddrs_ifa;
          if (myGetIfAddrs_ifa
            || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa), (v158 = (_QWORD *)myGetIfAddrs_ifa) != 0))
          {
            while (1)
            {
              v159 = v158[3];
              if (v159)
              {
                if (*(_BYTE *)(v159 + 1) == 18 && *(unsigned __int16 *)(v159 + 2) == (unsigned __int16)v84)
                  break;
              }
              v158 = (_QWORD *)*v158;
              if (!v158)
                goto LABEL_200;
            }
            v160 = v159 + *(unsigned __int8 *)(v159 + 5);
            v161 = *(_DWORD *)(v160 + 8);
            *(_WORD *)(v117 + 3604) = *(_WORD *)(v160 + 12);
            *v157 = v161;
          }
          else
          {
LABEL_200:
            *(_WORD *)(v117 + 3604) = 0;
            *v157 = 0;
          }
          if (*(_BYTE *)(v117 + 3672) && !*v157)
          {
            v215 = nameEncoding;
            v213 = v84;
            v214 = __s1;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: Bad MAC address %.6a for %d %s %#a", v150, v151, v152, v153, v154, v117 + 3600);
          }
          if (*(_BYTE *)(v117 + 3671) && !*(_BYTE *)(v117 + 3673) && *(_DWORD *)(v117 + 3748) == 3)
          {
            v162 = *(void **)(v117 + 8);
            if (v162)
            {
              os_release(v162);
              *(_QWORD *)(v117 + 8) = 0;
            }
            *(_QWORD *)(v117 + 8) = mdns_multicast_delay_histogram_create();
          }
          *(_QWORD *)v108 = v117;
          v3 = &unk_100164000;
          goto LABEL_95;
        }
        v131 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            v137 = __error();
            v138 = strerror(*v137);
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v138;
            v135 = v131;
LABEL_163:
            _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, "GetIFTFamily: socket() failed: %{public}s", buf, 0xCu);
          }
        }
        else
        {
          v132 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            v133 = __error();
            v134 = strerror(*v133);
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v134;
            v135 = v132;
            goto LABEL_163;
          }
        }
        v130 = 0;
        goto LABEL_168;
      }
      v110 = HIDWORD(v107);
      while ((_DWORD)v84 != *(_DWORD *)(v109 + 3720)
           || !mDNSSameAddress((int *)nameEncoding, (_DWORD *)(v109 + 3560))
           || *(unsigned __int16 *)(v109 + 3724) != (unsigned __int16)v93
           || *(unsigned __int16 *)(v109 + 3726) != (unsigned __int16)loga
           || (_DWORD)v110 != *(unsigned __int16 *)(v109 + 3728))
      {
        v108 = v109 + 3680;
        v109 = *(_QWORD *)(v109 + 3680);
        if (!v109)
          goto LABEL_122;
      }
      if (!*(_BYTE *)(v109 + 3696))
      {
        v167 = *(unsigned __int8 **)(v1 + 8);
        if (!v167)
          goto LABEL_284;
        v168 = (_BYTE *)(v109 + 3606);
        v169 = 64;
        while (1)
        {
          v170 = *v167;
          *v168 = v170;
          if (!v170)
            break;
          ++v168;
          ++v167;
          if ((unint64_t)--v169 <= 1)
          {
            *v168 = 0;
            break;
          }
        }
        v171 = *(_QWORD *)v108;
        v172 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v108 + 3688) + 120);
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)v108 + 3688) + 120))
          v172 = (*(_DWORD *)(v171 + 3712) & 0x8000) != 0 && (*(_DWORD *)(v171 + 3712) & 0x10) == 0;
        if (*(unsigned __int8 *)(v171 + 3671) == v172)
        {
          v173 = 1;
        }
        else
        {
          *(_BYTE *)(v171 + 3671) = v172;
          v173 = 2;
        }
        *(_BYTE *)(v171 + 3696) = v173;
        if (*(_DWORD *)(v171 + 3744) == 3)
          v175 = util_is_managed_network(v171 + 3606);
        else
          v175 = 0;
        v176 = *(_QWORD *)v108;
        if (*(unsigned __int8 *)(*(_QWORD *)v108 + 3753) != v175)
        {
          v177 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
            {
              v181 = *(_QWORD *)(v176 + 3552);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = v176 + 3606;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v181;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v175;
              v180 = v177;
LABEL_243:
              _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEBUG, "AddInterfaceToList: Updating for privacy risk -- ifname: %{public}s, ifid: %d, risk: %{mdns:yesno}d", buf, 0x18u);
            }
          }
          else
          {
            v178 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
              v179 = *(_QWORD *)(v176 + 3552);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = v176 + 3606;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v179;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v175;
              v180 = v178;
              goto LABEL_243;
            }
          }
          v176 = *(_QWORD *)v108;
          *(_BYTE *)(v176 + 3753) = v175;
          *(_BYTE *)(v176 + 3696) = 2;
        }
        v3 = &unk_100164000;
        if (*(_DWORD *)(v176 + 3704) != a1)
          *(_DWORD *)(v176 + 3700) = a1;
        v182 = NetWakeInterface(v176);
        v183 = *(_QWORD *)v108;
        if (*(unsigned __int8 *)(*(_QWORD *)v108 + 3672) != v182)
        {
          *(_BYTE *)(v183 + 3672) = v182;
          if (*(_QWORD *)(v183 + 3776))
          {
            mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"AddInterfaceToList", 3913);
            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"AddInterfaceToList", 3916);
            v183 = *(_QWORD *)v108;
          }
        }
        *(_BYTE *)(v183 + 3674) = (v219 & 0x800) == 0;
        if (*(_BYTE *)(v183 + 3671)
          && !*(_BYTE *)(v183 + 3673)
          && *(_DWORD *)(v183 + 3748) == 3
          && !*(_QWORD *)(v183 + 8))
        {
          *(_QWORD *)(*(_QWORD *)v108 + 8) = mdns_multicast_delay_histogram_create();
        }
        goto LABEL_95;
      }
      v3 = &unk_100164000;
      v163 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_95;
        v174 = *(_QWORD *)(v1 + 8);
        *(_DWORD *)buf = 136446979;
        *(_QWORD *)&buf[4] = v174;
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1045;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2101;
        *(_QWORD *)&buf[30] = nameEncoding;
        v166 = v163;
      }
      else
      {
        v164 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_95;
        v165 = *(_QWORD *)(v1 + 8);
        *(_DWORD *)buf = 136446979;
        *(_QWORD *)&buf[4] = v165;
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1045;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2101;
        *(_QWORD *)&buf[30] = nameEncoding;
        v166 = v164;
      }
      _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "Ignoring attempt to re-add interface (%{public}s, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P) already marked as existing", buf, 0x26u);
LABEL_95:
      v1 = *(_QWORD *)v1;
    }
    while (v1);
  }
  if ((v2 & 0x80000000) == 0)
    close(v2);
  mDNS_snprintf(v232);
  v230 = 0u;
  memset(buf, 0, sizeof(buf));
  nameEncoding[0] = 134217984;
  v13 = SCDynamicStoreCopyComputerName(0, nameEncoding);
  if (v13)
  {
    v14 = v13;
    mDNSDomainLabelFromCFString(v13, buf);
    CFRelease(v14);
    v15 = (_QWORD *)&unk_100158000;
    if (buf[0])
      goto LABEL_264;
  }
  else
  {
    v15 = &unk_100158000;
  }
  v184 = &buf[1];
  v185 = v232[0];
  if (LOBYTE(v232[0]))
  {
    v186 = (unsigned __int8 *)v232 + 1;
    do
    {
      *v184++ = v185;
      v187 = *v186++;
      v185 = v187;
      if (v187)
        v188 = v184 >= (uint8_t *)v231;
      else
        v188 = 1;
    }
    while (!v188);
  }
  buf[0] = (_BYTE)v184 + ~buf;
LABEL_264:
  v227 = 0u;
  v228 = 0u;
  *(_OWORD *)nameEncoding = 0u;
  v226 = 0u;
  GetUserSpecifiedLocalHostName(nameEncoding);
  v194 = LOBYTE(nameEncoding[0]);
  if (!LOBYTE(nameEncoding[0]))
  {
    v195 = (char *)nameEncoding + 1;
    v196 = v232[0];
    if (LOBYTE(v232[0]))
    {
      v197 = (unsigned __int8 *)v232 + 1;
      do
      {
        *v195++ = v196;
        v198 = *v197++;
        v196 = v198;
        if (v198)
          v199 = v195 >= (char *)buf;
        else
          v199 = 1;
      }
      while (!v199);
    }
    v200 = (_DWORD)v195 + ~nameEncoding;
    v194 = v200;
    LOBYTE(nameEncoding[0]) = v200;
  }
  v201 = v15[441];
  v202 = *(unsigned __int8 *)(v201 + 172);
  if (*(unsigned __int8 *)(v201 + 172) != buf[0] || memcmp((const void *)(v201 + 173), &buf[1], v202))
  {
    if ((_DWORD)v202)
    {
      LogMsgWithLevel(*((NSObject **)v3 + 295), OS_LOG_TYPE_DEFAULT, "User updated Computer Name from %#s to %#s", v189, v190, v191, v192, v193, v201 + 172);
      v201 = v15[441];
      v194 = LOBYTE(nameEncoding[0]);
    }
    v203 = *(_OWORD *)&buf[16];
    xmmword_10015B5F0 = *(_OWORD *)buf;
    unk_10015B600 = *(_OWORD *)&buf[16];
    v204 = *(_OWORD *)&buf[32];
    v205 = v230;
    xmmword_10015B610 = *(_OWORD *)&buf[32];
    unk_10015B620 = v230;
    *(_OWORD *)(v201 + 172) = *(_OWORD *)buf;
    *(_OWORD *)(v201 + 188) = v203;
    *(_OWORD *)(v201 + 204) = v204;
    *(_OWORD *)(v201 + 220) = v205;
  }
  v206 = *(unsigned __int8 *)(v201 + 108);
  if (v206 != v194 || memcmp((const void *)(v201 + 109), (char *)nameEncoding + 1, v194))
  {
    if (v206)
    {
      LogMsgWithLevel(*((NSObject **)v3 + 295), OS_LOG_TYPE_DEFAULT, "User updated Local Hostname from %#s to %#s", v189, v190, v191, v192, v193, v201 + 108);
      v201 = v15[441];
    }
    v208 = (_OWORD *)((char *)mDNSStorage + &unk_100002868);
    v209 = *(_OWORD *)nameEncoding;
    v210 = v226;
    *v208 = *(_OWORD *)nameEncoding;
    v208[1] = v210;
    v211 = v227;
    v212 = v228;
    v208[2] = v227;
    v208[3] = v212;
    *(_OWORD *)(v201 + 108) = v209;
    *(_OWORD *)(v201 + 124) = v210;
    *(_OWORD *)(v201 + 140) = v211;
    *(_OWORD *)(v201 + 156) = v212;
    mDNS_SetFQDN((uint64_t)mDNSStorage);
  }
  return result;
}

uint64_t myGetIfAddrs()
{
  if (myGetIfAddrs_ifa)
  {
    freeifaddrs((ifaddrs *)myGetIfAddrs_ifa);
    myGetIfAddrs_ifa = 0;
  }
  getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
  return myGetIfAddrs_ifa;
}

uint64_t SetupAddr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  char *v12;
  int v14;

  if (!a2)
  {
    v9 = 4294901747;
    v11 = mDNSLogCategory_Default;
    v12 = "SetupAddr ERROR: NULL sockaddr";
    goto LABEL_10;
  }
  v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 != 30)
  {
    if (v8 == 2)
    {
      v9 = 0;
      v10 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)a1 = 4;
      *(_DWORD *)(a1 + 4) = v10;
      return v9;
    }
    v9 = 4294901747;
    v11 = mDNSLogCategory_Default;
    v14 = *(unsigned __int8 *)(a2 + 1);
    v12 = "SetupAddr invalid sa_family %d";
    LOBYTE(a2) = 0;
LABEL_10:
    LogMsgWithLevel(v11, (os_log_type_t)a2, v12, a4, a5, a6, a7, a8, v14);
    return v9;
  }
  *(_DWORD *)a1 = 6;
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a2 + 8);
  if (*(unsigned __int8 *)(a2 + 8) != 254 || (*(_BYTE *)(a2 + 9) & 0xC0) != 0x80)
    return 0;
  v9 = 0;
  *(_WORD *)(a1 + 6) = 0;
  return v9;
}

BOOL NetWakeInterface(uint64_t a1)
{
  uint64_t v2;
  const char *v4;
  _BOOL8 result;
  NSObject *v6;
  os_log_type_t v7;
  uint32_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _BOOL4 v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  _BOOL4 v18;
  _BOOL4 v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v25;
  uint8_t buf[4];
  _BYTE v29[20];
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int128 v35;
  __int128 v36;

  if (*(_BYTE *)(*(_QWORD *)(a1 + 3688) + 120)
    && (*(_DWORD *)(a1 + 3712) & 0x8018) == 0x8000
    && !*(_BYTE *)(a1 + 3699))
  {
    v9 = a1 + 3606;
    if (!strcmp((const char *)(a1 + 3606), "ap1"))
    {
      v11 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v19)
          return result;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v29 = v9;
        v4 = "NetWakeInterface: returning false for %{public}s";
      }
      else
      {
        v11 = mDNSLogCategory_SPS_redacted;
        v12 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v12)
          return result;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v29 = v9;
        v4 = "NetWakeInterface: returning false for %{public}s";
      }
      v6 = v11;
      v7 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_14;
    }
    if (CheckInterfaceSupport(a1, "mDNS_Keepalive"))
    {
      v10 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)v29 = v9;
          goto LABEL_38;
        }
      }
      else
      {
        v10 = mDNSLogCategory_SPS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)v29 = v9;
LABEL_38:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "NetWakeInterface: interface supports TCP Keepalive -- ifname: %{public}s", buf, 0xCu);
        }
      }
      return 1;
    }
    v13 = socket(2, 2, 0);
    v14 = v13;
    if (v13 < 0)
    {
      v20 = *__error();
      v21 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
      }
      else
      {
        v21 = mDNSLogCategory_SPS_redacted;
        result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
      }
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)v29 = v14;
      *(_WORD *)&v29[4] = 2082;
      *(_QWORD *)&v29[6] = v9;
      *(_WORD *)&v29[14] = 1024;
      *(_DWORD *)&v29[16] = v20;
      v4 = "NetWakeInterface: socket failed -- socket: %d, ifname: %{public}s, error: %{darwin.errno}d";
      v6 = v21;
      v7 = OS_LOG_TYPE_ERROR;
      v8 = 24;
      goto LABEL_15;
    }
    v15 = 0;
    v35 = 0u;
    v36 = 0u;
    while (1)
    {
      v16 = *(unsigned __int8 *)(v9 + v15);
      *((_BYTE *)&v35 + v15) = v16;
      if (!v16)
        break;
      if (++v15 == 15)
      {
        HIBYTE(v35) = 0;
        break;
      }
    }
    if ((ioctl(v13, 0xC0206988uLL, &v35) & 0x80000000) == 0)
    {
LABEL_60:
      close(v14);
      v25 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
          return v36 & 1;
      }
      else
      {
        v25 = mDNSLogCategory_SPS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
          return v36 & 1;
      }
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)v29 = a1 + 3606;
      *(_WORD *)&v29[8] = 2160;
      *(_QWORD *)&v29[10] = 1752392040;
      *(_WORD *)&v29[18] = 1045;
      v30 = 20;
      v31 = 2101;
      v32 = a1 + 3560;
      v33 = 1024;
      v34 = v36 & 1;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "NetWakeInterface: interface -- ifname: %{public}s, address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, supports Wake-On-Lan: %{mdns:yesno}d", buf, 0x2Cu);
      return v36 & 1;
    }
    v17 = *__error();
    if (v17 == 102)
    {
      if (!*(_DWORD *)(a1 + 3724))
      {
        v18 = *(_BYTE *)(*(_QWORD *)(a1 + 3688) + 143) != 0;
LABEL_59:
        LODWORD(v36) = v18;
        goto LABEL_60;
      }
LABEL_58:
      v18 = 0;
      goto LABEL_59;
    }
    v22 = mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR))
        goto LABEL_58;
    }
    else
    {
      v22 = mDNSLogCategory_SPS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_58;
    }
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)v29 = a1 + 3606;
    *(_WORD *)&v29[8] = 1024;
    *(_DWORD *)&v29[10] = v17;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "NetWakeInterface: SIOCGIFWAKEFLAGS failed -- ifname: %{public}s, error: %{darwin.errno}d", buf, 0x12u);
    goto LABEL_58;
  }
  v2 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEBUG);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)v29 = a1 + 3606;
    v4 = "NetWakeInterface: returning false for %{public}s";
    goto LABEL_13;
  }
  v2 = mDNSLogCategory_SPS_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)v29 = a1 + 3606;
    v4 = "NetWakeInterface: returning false for %{public}s";
LABEL_13:
    v6 = v2;
    v7 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    v8 = 12;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v4, buf, v8);
    return 0;
  }
  return result;
}

void mDNS_SetFQDN(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t j;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD v32[16];
  uint64_t v33;

  memset(v32, 0, sizeof(v32));
  if (AppendDomainLabel(v32, (unsigned __int8 *)(a1 + 10344)) && AppendLiteralLabelString(v32, "local"))
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_SetFQDN", 16609);
    v7 = (uint64_t *)v32;
    if (!SameDomainNameCS((_BYTE *)(a1 + 10408), v32))
    {
      while (v7 < &v33)
      {
        if (!v7)
          break;
        v15 = *(unsigned __int8 *)v7;
        if (v15 > 0x3F)
          break;
        if (!*(_BYTE *)v7)
        {
          if ((unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1) <= 0x100u)
          {
            memcpy((void *)(a1 + 10408), v32, (unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1));
            goto LABEL_13;
          }
          break;
        }
        v7 = (uint64_t *)((char *)v7 + v15 + 1);
      }
      *(_BYTE *)(a1 + 10408) = 0;
LABEL_13:
      DeadvertiseAllInterfaceRecords(a1, 1);
      AdvertiseNecessaryInterfaceRecords(a1);
    }
    for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
    {
      if (*(_BYTE *)(i + 120))
      {
        D2D_stop_advertising_record(i, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, i);
        D2D_start_advertising_record(i, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    for (j = *(_QWORD *)(a1 + 12624); j; j = *(_QWORD *)j)
    {
      if (*(_BYTE *)(j + 120))
      {
        D2D_stop_advertising_record(j, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, j);
        D2D_start_advertising_record(j, v25, v26, v27, v28, v29, v30, v31);
      }
    }
    mDNS_Unlock_(a1, (uint64_t)"mDNS_SetFQDN", 16623);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNS_SetFQDN: Cannot create MulticastHostname", v2, v3, v4, v5, v6, v32[0]);
  }
}

uint64_t AppendDomainLabel(_BYTE *a1, unsigned __int8 *a2)
{
  unint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  uint64_t result;
  unint64_t v10;

  v2 = (unint64_t)(a1 + 256);
  v3 = 257;
  v4 = a1;
  if (a1 == (_BYTE *)-256)
  {
LABEL_3:
    while (v4)
    {
      v5 = *v4;
      if (v5 > 0x3F)
        break;
      if (!*v4)
      {
        v3 = (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
        break;
      }
      v4 += v5 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if ((unint64_t)v4 < v2)
      goto LABEL_3;
  }
  v6 = &a1[v3];
  v7 = *a2;
  if (v7 > 0x3F || (unint64_t)&v6[v7 + 1] > v2)
    return 0;
  v10 = -1;
  do
  {
    v6[v10] = a2[v10 + 1];
    ++v10;
  }
  while (v10 < *a2);
  result = (uint64_t)&v6[v10 + 1];
  v6[v10] = 0;
  return result;
}

_BYTE *AppendLiteralLabelString(_BYTE *a1, char *a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _BYTE *v5;
  unint64_t v6;
  char v7;
  _BYTE *v8;
  BOOL v9;
  int v10;
  BOOL v11;
  _BYTE *v12;

  v2 = 257;
  v3 = a1;
  if (a1 == (_BYTE *)-256)
  {
LABEL_3:
    while (v3)
    {
      v4 = *v3;
      if (v4 > 0x3F)
        break;
      if (!*v3)
      {
        v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }
      v3 += v4 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if (v3 < a1 + 256)
      goto LABEL_3;
  }
  v5 = &a1[v2];
  v6 = (unint64_t)(v5 + 63);
  if (a1 + 255 < v5 + 63)
    v6 = (unint64_t)(a1 + 255);
  v7 = *a2;
  v8 = v5;
  if (*a2)
    v9 = (unint64_t)v5 >= v6;
  else
    v9 = 1;
  if (!v9)
  {
    do
    {
      *v8++ = v7;
      v10 = *++a2;
      v7 = v10;
      if (v10)
        v11 = (unint64_t)v8 >= v6;
      else
        v11 = 1;
    }
    while (!v11);
  }
  *(v5 - 1) = (_BYTE)v8 - (_BYTE)v5;
  *v8 = 0;
  v12 = v8 + 1;
  if (*a2)
    return 0;
  else
    return v12;
}

void mDNS_Lock_(unsigned int *a1, uint64_t a2, int a3)
{
  _BOOL8 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v17;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  NSObject *v26;
  int v29;
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;

  mDNS_VerifyLockState("Lock", 0, a1[12], a1[13], a2, a3);
  v13 = a1[12];
  v14 = a1[16];
  if (!v13)
  {
    if (!v14)
      goto LABEL_23;
    v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
      if (!v5)
        goto LABEL_23;
    }
    else
    {
      v17 = mDNSLogCategory_Default_redacted;
      v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (!v5)
        goto LABEL_23;
    }
    v22 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v29 = 136446722;
    v30 = a2;
    v31 = 1024;
    v32 = v14;
    v33 = 1024;
    v34 = v22;
    v19 = "%{public}s: mDNS_Lock: m->timenow already set (%u/%u)";
    v20 = v17;
    v21 = 24;
    goto LABEL_22;
  }
  if (v14)
    goto LABEL_27;
  v15 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
LABEL_19:
      v29 = 136446466;
      v30 = a2;
      v31 = 1024;
      v32 = v13;
      v19 = "%{public}s: mDNS_Lock: m->mDNS_busy is %u but m->timenow not set";
      v20 = v15;
      v21 = 18;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v29, v21);
    }
  }
  else
  {
    v15 = mDNSLogCategory_Default_redacted;
    v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if (v5)
      goto LABEL_19;
  }
LABEL_23:
  v23 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  if (v23 <= 1)
    v14 = 1;
  else
    v14 = v23;
  a1[16] = v14;
LABEL_27:
  v24 = a1[17] - v14;
  if (v24 >= 1)
  {
    v25 = a1[15] + v24;
    a1[15] = v25;
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        v14 = a1[17];
        a1[16] = v14;
        goto LABEL_38;
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_37;
    }
    v29 = 136446722;
    v30 = a2;
    v31 = 1024;
    v32 = v24;
    v33 = 1024;
    v34 = v25;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: mDNSPlatformRawTime went backwards by %d ticks; setting correction factor to %d",
      (uint8_t *)&v29,
      0x18u);
    goto LABEL_37;
  }
LABEL_38:
  a1[17] = v14;
  ++a1[12];
}

BOOL SameDomainNameCS(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2;
  unsigned __int16 v3;
  uint64_t v4;
  _BYTE *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a1;
  if (a1 == (_BYTE *)-256)
    goto LABEL_5;
LABEL_2:
  v3 = 257;
  if (v2 < a1 + 256 && v2)
  {
    while (1)
    {
      v4 = *v2;
      if (v4 > 0x3F)
      {
LABEL_10:
        v3 = 257;
        goto LABEL_12;
      }
      if (!*v2)
        break;
      v2 += v4 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_2;
LABEL_5:
      if (!v2)
        goto LABEL_10;
    }
    v3 = (_WORD)v2 - (_WORD)a1 + 1;
  }
LABEL_12:
  v5 = a2;
  if (a2 == (_BYTE *)-256)
    goto LABEL_16;
LABEL_13:
  v6 = 257;
  if (v5 < a2 + 256 && v5)
  {
    while (1)
    {
      v7 = *v5;
      if (v7 > 0x3F)
      {
LABEL_21:
        v6 = 257;
        goto LABEL_23;
      }
      if (!*v5)
        break;
      v5 += v7 + 1;
      if (a2 != (_BYTE *)-256)
        goto LABEL_13;
LABEL_16:
      if (!v5)
        goto LABEL_21;
    }
    v6 = (_WORD)v5 - (_WORD)a2 + 1;
  }
LABEL_23:
  v8 = 0;
  if (v3 <= 0x100u && v3 == (unsigned __int16)v6)
    return memcmp(a1, a2, v3) == 0;
  return v8;
}

void mDNS_Unlock_(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  int v15;
  int v17;
  uint64_t i;
  uint64_t j;
  uint64_t v20;
  int v21;
  int next_scheduled_event;
  int v24;
  int v25;
  int v27;
  NSObject *v28;
  int v31;
  int v32;
  int v34;
  int v35;
  int v38;
  uint64_t v39;

  v6 = *(_DWORD *)(a1 + 52);
  v7 = *(_DWORD *)(a1 + 48) - 1;
  *(_DWORD *)(a1 + 48) = v7;
  mDNS_VerifyLockState("Unlock", 0, v7, v6, a2, a3);
  if (!*(_DWORD *)(a1 + 48))
  {
    v8 = *(_DWORD *)(a1 + 64);
    v9 = v8 + 939524096;
    if (*(_DWORD *)(a1 + 16))
    {
      v10 = v8 + 939524096;
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 200);
      if (!v11 || (v9 = *(_DWORD *)(v11 + 204), v10 = *(_DWORD *)(a1 + 64), v9))
      {
        v10 = *(_DWORD *)(a1 + 64);
        if (!*(_QWORD *)(a1 + 224))
        {
          v12 = *(uint64_t **)(a1 + 12632);
          if (v12)
          {
            while (*((_BYTE *)v12 + 8) == 2)
            {
              v12 = (uint64_t *)*v12;
              if (!v12)
                goto LABEL_10;
            }
            v10 = *(_DWORD *)(a1 + 64);
          }
          else
          {
LABEL_10:
            v10 = *(_DWORD *)(a1 + 64);
            if (!*(_BYTE *)(a1 + 12648))
            {
              v10 = *(_DWORD *)(a1 + 64);
              if (!*(_QWORD *)(a1 + 15112))
              {
                v10 = *(_DWORD *)(a1 + 64);
                if (!*(_BYTE *)(a1 + 140))
                {
                  if (v9 - *(_DWORD *)(a1 + 12680) > 0)
                    v9 = *(_DWORD *)(a1 + 12680);
                  if (v9 - *(_DWORD *)(a1 + 104) > 0)
                    v9 = *(_DWORD *)(a1 + 104);
                  v13 = *(_DWORD *)(a1 + 12684);
                  if (v9 - v13 > 0 && v13 != 0)
                    v9 = *(_DWORD *)(a1 + 12684);
                  if (v9 - *(_DWORD *)(a1 + 88) > 0)
                    v9 = *(_DWORD *)(a1 + 88);
                  if (v9 - *(_DWORD *)(a1 + 108) > 0)
                    v9 = *(_DWORD *)(a1 + 108);
                  v15 = *(_DWORD *)(a1 + 116);
                  if (v9 - *(_DWORD *)(a1 + 112) > 0)
                    v9 = *(_DWORD *)(a1 + 112);
                  if (v9 - v15 <= 0 || v15 == 0)
                    v17 = v9;
                  else
                    v17 = *(_DWORD *)(a1 + 116);
                  for (i = *(_QWORD *)(a1 + 14160); i; i = *(_QWORD *)(i + 296))
                  {
                    for (j = 0; j != 40; j += 8)
                    {
                      v20 = *(_QWORD *)(i + 256 + j);
                      if (v20)
                      {
                        if (*(_DWORD *)(v20 + 704) == 2)
                        {
                          v21 = *(_DWORD *)(v20 + 712);
                          if (v17 - v21 > 0)
                            v17 = v21;
                        }
                      }
                    }
                  }
                  next_scheduled_event = resolver_discovery_get_next_scheduled_event();
                  if (v17 - next_scheduled_event <= 0 || next_scheduled_event == 0)
                    v24 = v17;
                  else
                    v24 = next_scheduled_event;
                  v25 = *(_DWORD *)(a1 + 148);
                  if (!v25 && *(_DWORD *)(a1 + 152) && v24 - *(_DWORD *)(a1 + 180) > 0)
                    v24 = *(_DWORD *)(a1 + 180);
                  if (v24 - v25 > 0 && v25 != 0)
                    v24 = *(_DWORD *)(a1 + 148);
                  v27 = *(_DWORD *)(a1 + 80);
                  if (v27)
                  {
                    if (v24 - v27 > 0)
                      v24 = *(_DWORD *)(a1 + 80);
                  }
                  else
                  {
                    if (v24 - *(_DWORD *)(a1 + 92) > 0)
                      v24 = *(_DWORD *)(a1 + 92);
                    if (v24 - *(_DWORD *)(a1 + 96) > 0)
                      v24 = *(_DWORD *)(a1 + 96);
                  }
                  v31 = *(_DWORD *)(a1 + 84);
                  if (!v31)
                    v31 = *(_DWORD *)(a1 + 100);
                  if (v24 - v31 > 0)
                    v24 = v31;
                  v32 = *(_DWORD *)(a1 + 188);
                  if (v24 - *(_DWORD *)(a1 + 184) > 0)
                    v24 = *(_DWORD *)(a1 + 184);
                  if (v24 - v32 > 0 && v32 != 0)
                    v24 = *(_DWORD *)(a1 + 188);
                  v34 = *(_DWORD *)(a1 + 160);
                  v35 = *(_DWORD *)(a1 + 164);
                  if (v24 - v34 > 0 && v34 != 0)
                    v24 = *(_DWORD *)(a1 + 160);
                  if (v24 - v35 <= 0 || v35 == 0)
                    v10 = v24;
                  else
                    v10 = *(_DWORD *)(a1 + 164);
                }
              }
            }
          }
        }
      }
    }
    *(_DWORD *)(a1 + 72) = v10;
    if (v8)
      goto LABEL_73;
    v28 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_73:
        *(_DWORD *)(a1 + 64) = 0;
        return;
      }
      v38 = 136446210;
      v39 = a2;
    }
    else
    {
      v28 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_73;
      v38 = 136446210;
      v39 = a2;
    }
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: mDNS_Unlock: ERROR! m->timenow aready zero", (uint8_t *)&v38, 0xCu);
    goto LABEL_73;
  }
}

void SetupActiveInterfaces(int a1)
{
  int8x8_t *v1;
  uint64_t v2;
  uint64_t v3;
  int8x8_t v4;
  BOOL v5;
  NSObject *v6;
  BOOL v8;
  NSObject *v9;
  int v10;
  __int32 v11;
  __int32 v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  const char *v18;
  uint32_t v19;
  __int128 *v20;
  int v21;
  char v22;
  __int128 *v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int8x8_t v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  int v37;
  int8x8_t v38;
  NSObject *v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  int v44;
  uint32_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t i;
  _DWORD *v54;
  NSObject *v55;
  __int32 v56;
  int v57;
  const char *v58;
  const char *v59;
  const char *v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  uint8_t buf[4];
  _BYTE v71[24];
  __int16 v72;
  _BYTE v73[14];
  __int16 v74;
  int8x8_t *v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  uint64_t v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int8x8_t *v83;
  __int16 v84;
  int v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  const char *v89;
  __int16 v90;
  const char *v91;

  dword_10015BF48 = 0;
  v1 = *(int8x8_t **)mDNSStorage[0];
  if (*(_QWORD *)mDNSStorage[0])
  {
    v68 = 136447235;
    do
    {
      if (!v1[462].i8[0])
        goto LABEL_167;
      v2 = SearchForInterfaceByName((char *)&v1[450] + 6, 0);
      v3 = v2;
      v4 = v1[472];
      if (v4)
        v5 = *(_QWORD *)&v4 == v2;
      else
        v5 = 1;
      if (v5)
      {
        if (v4)
          goto LABEL_167;
      }
      else
      {
        v6 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(int8x8_t *)v71 = v4;
          *(_WORD *)&v71[8] = 2048;
          *(_QWORD *)&v71[10] = v3;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "SetupActiveInterfaces ERROR! n->Registered %p != primary %p", buf, 0x16u);
        }
      }
      v1[472] = (int8x8_t)v3;
      v8 = (v1[464].i8[0] & 8) == 0 && (~v1[463].i32[0] + a1) < 0x3B;
      v1[462].i8[2] = v8;
      if (!strncmp((const char *)&v1[450] + 6, "p2p", 3uLL) || v1[459].i8[4])
      {
        v9 = mDNSLogCategory_State;
        v10 = 1;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)v71 = (char *)v1 + 3606;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "SetupActiveInterfaces: %{public}s DirectLink interface registering", buf, 0xCu);
        }
      }
      else
      {
        v10 = 0;
      }
      if (v1[444])
      {
        v11 = v1[447].i32[1];
        if (v11 == 6)
        {
          if (vorr_s8(v1[448], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v1[448].i8, *(int8x16_t *)v1[448].i8, 8uLL)))
          {
            goto LABEL_25;
          }
        }
        else if (v11 == 4 && v1[448].i32[0])
        {
LABEL_25:
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", 16857);
          v1[2].i8[0] = 1;
          v12 = v1[445].i32[0];
          if (v12 == 4)
          {
            v13 = 0;
            v14 = 0;
            v1[2].i8[1] = v1[458].i8[7] != 0;
          }
          else
          {
            v13 = 0;
            v14 = 0;
            v1[2].i8[1] = 0;
            if (v12 == 6)
            {
              v14 = v1[458].i8[7] != 0;
              v13 = 1;
            }
          }
          v1[2].i8[2] = v14;
          v20 = (__int128 *)xmmword_10015BF38;
          if ((_QWORD)xmmword_10015BF38)
          {
            v21 = 1;
            v22 = 1;
            while (v20 != (__int128 *)v1)
            {
              v23 = v20;
              if (*((_QWORD *)v20 + 444) == *(_QWORD *)&v1[444])
              {
                v1[2].i8[0] = 0;
                if (v12 == *((_DWORD *)v20 + 890))
                  v22 = 0;
                if (v12 == 4 && v1[458].i8[7])
                  *((_BYTE *)v20 + 17) = 1;
                if (v13)
                {
                  v21 = v1[458].u8[7];
                  if (v1[458].i8[7])
                  {
                    v21 = 0;
                    *((_BYTE *)v20 + 18) = 1;
                  }
                }
                else
                {
                  v21 = 0;
                }
              }
              v20 = *(__int128 **)v20;
              if (!*(_QWORD *)v23)
                goto LABEL_59;
            }
            v34 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                goto LABEL_80;
            }
            else
            {
              v34 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
              {
LABEL_80:
                *(_DWORD *)buf = 136446979;
                *(_QWORD *)v71 = (char *)v1 + 3606;
                *(_WORD *)&v71[8] = 2160;
                *(_QWORD *)&v71[10] = 1752392040;
                *(_WORD *)&v71[18] = 1045;
                *(_DWORD *)&v71[20] = 20;
                v72 = 2101;
                *(_QWORD *)v73 = v1 + 445;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Tried to register a NetworkInterfaceInfo that's already in the list - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
              }
            }
            v37 = 16875;
LABEL_146:
            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", v37);
            goto LABEL_147;
          }
          v21 = 1;
          v22 = 1;
          v23 = &xmmword_10015BF38;
LABEL_59:
          *v1 = 0;
          *(_QWORD *)v23 = v1;
          if (v1[458].i8[6])
          {
            AdvertiseInterfaceIfNeeded(mDNSStorage, (uint64_t)v1);
            v21 = v1[2].u8[0];
          }
          v24 = gSensitiveLoggingEnabled;
          v25 = mDNSLogCategory_mDNS;
          if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
            v24 = 0;
          if (v21)
          {
            if ((v24 & 1) != 0)
            {
              v25 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                goto LABEL_66;
LABEL_85:
              if (!v1[458].i8[7] || !v22 && !v1[2].i8[0])
                goto LABEL_134;
              if (v10)
              {
                v39 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  v40 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_95;
                }
                else
                {
                  v39 = mDNSLogCategory_mDNS_redacted;
                  v40 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_95:
                    *(_DWORD *)buf = 136446979;
                    *(_QWORD *)v71 = (char *)v1 + 3606;
                    *(_WORD *)&v71[8] = 2160;
                    *(_QWORD *)&v71[10] = 1752392040;
                    *(_WORD *)&v71[18] = 1045;
                    *(_DWORD *)&v71[20] = 20;
                    v72 = 2101;
                    *(_QWORD *)v73 = v1 + 445;
                    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Using fast activation for DirectLink interface - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
                    v40 = 0;
                  }
                }
              }
              else
              {
                v40 = 500;
              }
              v41 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_101;
              }
              else
              {
                v41 = mDNSLogCategory_mDNS_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                {
LABEL_101:
                  *(_DWORD *)buf = v68;
                  *(_QWORD *)v71 = (char *)v1 + 3606;
                  *(_WORD *)&v71[8] = 2160;
                  *(_QWORD *)&v71[10] = 1752392040;
                  *(_WORD *)&v71[18] = 1045;
                  *(_DWORD *)&v71[20] = 20;
                  v72 = 2101;
                  *(_QWORD *)v73 = v1 + 445;
                  *(_WORD *)&v73[8] = 1024;
                  *(_DWORD *)&v73[10] = v40;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Interface probe will be delayed - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, probe delay: %d", buf, 0x2Cu);
                }
              }
              if (v10)
              {
                v43 = 0;
                qword_100158E18 = 0;
                goto LABEL_114;
              }
              if (!(_DWORD)qword_100158E18)
              {
                v44 = dword_100158E08;
                do
                  v45 = arc4random() & 0x1FF;
                while (v45 > 0x14E);
                v46 = v45 + v44;
                if (v46 <= 1)
                  v46 = 1;
                LODWORD(qword_100158E18) = v46;
              }
              v43 = dword_100158E08 + v40;
              if ((dword_100158E08 + v40) <= 1)
                v43 = 1;
              if (!dword_10015BF48 || dword_10015BF48 - v43 < 0)
LABEL_114:
                dword_10015BF48 = v43;
              ++*(_DWORD *)((char *)&xmmword_100158E84 + &loc_100004D40 + 4);
              v47 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
              if (*(_QWORD *)((char *)&xmmword_100158E84 + 4))
              {
                while (2)
                {
                  if (*(_WORD *)(v47 + 340))
                    goto LABEL_125;
                  v48 = *(_QWORD *)(v47 + 136);
                  if (v48)
                  {
                    if (v48 != *(_QWORD *)&v1[444])
                      goto LABEL_125;
                  }
                  else if (!mDNSPlatformValidQuestionForInterface(v47, (uint64_t)v1, v42, v26, v27, v28, v29, v30))
                  {
                    goto LABEL_125;
                  }
                  v49 = *(_DWORD *)(v47 + 212);
                  if (!v49 || v49 >= 335)
                  {
                    v49 = 334;
                    *(_DWORD *)(v47 + 212) = 334;
                    *(_BYTE *)(v47 + 352) = 2;
                  }
                  *(_DWORD *)(v47 + 208) = dword_100158E08 - v49;
                  *(_DWORD *)(v47 + 224) = 0;
                  SetNextQueryTime((uint64_t)mDNSStorage, v47);
LABEL_125:
                  v47 = *(_QWORD *)(v47 + 8);
                  if (!v47)
                    break;
                  continue;
                }
              }
              v50 = (_QWORD *)xmmword_10015BF10;
              if (!(_QWORD)xmmword_10015BF10)
              {
LABEL_134:
                if (mDNS_LoggingEnabled == 1)
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RestartRecordGetZoneData: ResourceRecords", v26, v27, v28, v29, v30, v68);
                for (i = xmmword_10015BF10; i; i = *(_QWORD *)i)
                {
                  if (!*(_QWORD *)(i + 32)
                    && !*(_BYTE *)(i + 122)
                    && !IsLocalDomain(*(_BYTE **)(i + 40))
                    && *(_DWORD *)(i + 344) != 8)
                  {
                    v54 = *(_DWORD **)(i + 376);
                    if (v54)
                    {
                      *(_WORD *)(i + 358) = 0;
                      CancelGetZoneData((uint64_t)mDNSStorage, v54);
                    }
                    *(_QWORD *)(i + 376) = StartGetZoneData((unsigned int *)mDNSStorage, *(_BYTE **)(i + 40), i);
                  }
                }
                mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
                v37 = 17043;
                goto LABEL_146;
              }
              while (2)
              {
                v51 = (uint64_t)v1[444];
                v52 = v50[4];
                if (v52)
                {
                  if (v52 == v51)
                    goto LABEL_129;
                }
                else if (mDNSPlatformValidRecordForInterface((uint64_t)v50, v51, v42, v26, v27, v28, v29, v30))
                {
LABEL_129:
                  mDNSCoreRestartRegistration(mDNSStorage, (uint64_t)v50, 4);
                }
                v50 = (_QWORD *)*v50;
                if (!v50)
                  goto LABEL_134;
                continue;
              }
            }
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              goto LABEL_85;
LABEL_66:
            v31 = v1[444];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)v71 = v31.i32[0];
            *(_WORD *)&v71[4] = 2082;
            *(_QWORD *)&v71[6] = (char *)v1 + 3606;
            *(_WORD *)&v71[14] = 2160;
            *(_QWORD *)&v71[16] = 1752392040;
            v72 = 1045;
            *(_DWORD *)v73 = 20;
            *(_WORD *)&v73[4] = 2101;
            *(_QWORD *)&v73[6] = v1 + 445;
            v32 = v25;
            v33 = "Interface not represented in list; marking active and retriggering queries - ifid: %d, ifname: %{publi"
                  "c}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P";
          }
          else
          {
            if ((v24 & 1) != 0)
            {
              v25 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                goto LABEL_85;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              goto LABEL_85;
            }
            v38 = v1[444];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)v71 = v38.i32[0];
            *(_WORD *)&v71[4] = 2082;
            *(_QWORD *)&v71[6] = (char *)v1 + 3606;
            *(_WORD *)&v71[14] = 2160;
            *(_QWORD *)&v71[16] = 1752392040;
            v72 = 1045;
            *(_DWORD *)v73 = 20;
            *(_WORD *)&v73[4] = 2101;
            *(_QWORD *)&v73[6] = v1 + 445;
            v32 = v25;
            v33 = "Interface already represented in list - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, "
                  "mdnsresponder:ip_addr}.20P";
          }
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 0x2Cu);
          goto LABEL_85;
        }
        v16 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_39:
            *(_DWORD *)buf = 141559043;
            *(_QWORD *)v71 = 1752392040;
            *(_WORD *)&v71[8] = 1045;
            *(_DWORD *)&v71[10] = 20;
            *(_WORD *)&v71[14] = 2101;
            *(_QWORD *)&v71[16] = v1 + 445;
            v72 = 1042;
            *(_DWORD *)v73 = 20;
            *(_WORD *)&v73[4] = 2098;
            *(_QWORD *)&v73[6] = (char *)v1 + 3580;
            v17 = v16;
            v18 = "Tried to register a NetworkInterfaceInfo with invalid mask - ifaddr: %{sensitive, mask.hash, mdnsrespo"
                  "nder:ip_addr}.20P, ifmask: %{public, mdnsresponder:ip_addr}.20P";
            v19 = 44;
            goto LABEL_40;
          }
        }
        else
        {
          v16 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_39;
        }
      }
      else
      {
        v15 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_37:
            *(_DWORD *)buf = 141558531;
            *(_QWORD *)v71 = 1752392040;
            *(_WORD *)&v71[8] = 1045;
            *(_DWORD *)&v71[10] = 20;
            *(_WORD *)&v71[14] = 2101;
            *(_QWORD *)&v71[16] = v1 + 445;
            v17 = v15;
            v18 = "Tried to register a NetworkInterfaceInfo with zero InterfaceID - ifaddr: %{sensitive, mask.hash, mdnsr"
                  "esponder:ip_addr}.20P";
            v19 = 28;
LABEL_40:
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v18, buf, v19);
          }
        }
        else
        {
          v15 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_37;
        }
      }
LABEL_147:
      v55 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        v56 = v1[465].i32[0];
        v57 = CountMaskBits((int *)&v1[447] + 1);
        v58 = " (Flashing)";
        if (!v1[462].i8[1])
          v58 = "";
        v59 = " (Occulting)";
        if (!v1[462].i8[2])
          v59 = "";
        v60 = " (Primary)";
        if (!v1[2].i8[0])
          v60 = "";
        *(_DWORD *)buf = 136449539;
        *(_QWORD *)v71 = (char *)v1 + 3606;
        *(_WORD *)&v71[8] = 1024;
        *(_DWORD *)&v71[10] = v56;
        *(_WORD *)&v71[14] = 2160;
        *(_QWORD *)&v71[16] = 1752392040;
        v72 = 1045;
        *(_DWORD *)v73 = 6;
        *(_WORD *)&v73[4] = 2101;
        *(_QWORD *)&v73[6] = (char *)v1 + 3724;
        v74 = 2048;
        v75 = v1;
        v76 = 2048;
        v77 = v3;
        v78 = 2160;
        v79 = 1752392040;
        v80 = 1045;
        v81 = 20;
        v82 = 2101;
        v83 = v1 + 445;
        v84 = 1024;
        v85 = v57;
        v86 = 2082;
        v87 = v58;
        v88 = 2082;
        v89 = v59;
        v90 = 2082;
        v91 = v60;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "SetupActiveInterfaces: Registered %{public}s (%u) BSSID %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Struct addr %p, primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d%{public}s%{public}s%{public}s", buf, 0x7Eu);
      }
      v61 = v1[466].u16[1];
      if (v1[458].i8[7])
      {
        if (v61 != 30 && v61 != 2)
          goto LABEL_167;
        v62 = 56;
        if (v61 == 2)
          v62 = 24;
        v63 = *(_DWORD *)(mDNSStorage[0] + v62);
        if ((int8x8_t *)SearchForInterfaceByName((char *)&v1[450] + 6, v1[466].u16[1]) == v1)
          mDNSGroupJoinOrLeave(v63, (uint64_t)v1, 0);
        v64 = v63;
        v65 = (uint64_t)v1;
        v66 = 1;
      }
      else
      {
        if (v61 != 30 && v61 != 2 || (int8x8_t *)SearchForInterfaceByName((char *)&v1[450] + 6, v1[466].u16[1]) != v1)
          goto LABEL_167;
        v67 = 56;
        if (v61 == 2)
          v67 = 24;
        v64 = *(_DWORD *)(mDNSStorage[0] + v67);
        v65 = (uint64_t)v1;
        v66 = 0;
      }
      mDNSGroupJoinOrLeave(v64, v65, v66);
LABEL_167:
      v1 = (int8x8_t *)v1[460];
    }
    while (v1);
  }
}

uint64_t SearchForInterfaceByName(char *__s2, int a2)
{
  uint64_t i;

  for (i = *(_QWORD *)mDNSStorage; i; i = *(_QWORD *)(i + 3680))
  {
    if (*(_BYTE *)(i + 3696) && !strcmp((const char *)(i + 3606), __s2))
    {
      switch(a2)
      {
        case 2:
          if (*(_DWORD *)(i + 3560) == 4)
            return i;
          break;
        case 30:
          if (*(_DWORD *)(i + 3560) == 6)
            return i;
          break;
        case 0:
          return i;
      }
    }
  }
  return i;
}

void AdvertiseInterface(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  BOOL v6;
  BOOL v7;
  int v8;
  int v9;
  _BYTE *v10;
  void *v11;
  int v12;
  uint64_t *FirstAddressRecord;
  uint64_t v14;
  int v15;
  char v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  uint64_t v26;
  unsigned __int16 v27;
  int v28;
  _OWORD *v29;
  uint64_t v30;
  _BYTE *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  char v43;
  uint64_t v44;
  int v45;
  uint8_t buf[4];
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  _OWORD v50[5];

  v5 = *(_QWORD *)(a2 + 3552);
  if (AWDLInterfaceID)
    v6 = AWDLInterfaceID == v5;
  else
    v6 = 0;
  if (v6)
  {
    v8 = 1;
  }
  else
  {
    if (WiFiAwareInterfaceID)
      v7 = WiFiAwareInterfaceID == v5;
    else
      v7 = 0;
    v8 = v7;
  }
  v9 = v8 | a3;
  if (v8 | a3)
    v10 = (_BYTE *)(a1 + 10664);
  else
    v10 = (_BYTE *)(a1 + 10408);
  if (v9)
    v11 = mDNS_RandomizedHostNameCallback;
  else
    v11 = mDNS_HostNameCallback;
  if (a3)
    v12 = v8;
  else
    v12 = 1;
  FirstAddressRecord = (uint64_t *)(a2 + 24);
  if (v12)
    v14 = a2 + 24;
  else
    v14 = a2 + 2376;
  if (*(_BYTE *)(v14 + 8))
    return;
  v45 = v12;
  v44 = a2 + 1200;
  v15 = v9 | *(unsigned __int8 *)(a2 + 3676);
  memset(v50, 0, 74);
  if (v15)
    v16 = 32;
  else
    v16 = 2;
  v43 = v16;
  v17 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      goto LABEL_38;
    v18 = "randomized";
    if (!v9)
      v18 = "normal";
  }
  else
  {
    v17 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_38;
    v18 = "randomized";
    if (!v9)
      v18 = "normal";
  }
  *(_DWORD *)buf = 136446466;
  v47 = (uint64_t)v18;
  v48 = 2082;
  v49 = a2 + 3606;
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "AdvertiseInterface: Advertising %{public}s hostname on interface %{public}s", buf, 0x16u);
LABEL_38:
  mDNS_SetupResourceRecord(v14, 0, *(_QWORD *)(a2 + 3552), 1, 0x1194u, v43, 0, (uint64_t)v11, a2);
  if (v45)
    mDNS_SetupResourceRecord(v44, 0, *(_QWORD *)(a2 + 3552), 12, 0x1194u, 32, 0, 0, 0);
  v25 = v10;
  if (v10 == (_BYTE *)-256)
  {
LABEL_42:
    while (v25)
    {
      v26 = *v25;
      if (v26 > 0x3F)
        break;
      if (!*v25)
      {
        v27 = (_WORD)v25 - (_WORD)v10 + 1;
        if (v27 > 0x100u)
          break;
        memcpy((void *)(v14 + 652), v10, v27);
        goto LABEL_50;
      }
      v25 += v26 + 1;
      if (v10 != (_BYTE *)-256)
        goto LABEL_41;
    }
  }
  else
  {
LABEL_41:
    if (v25 < v10 + 256)
      goto LABEL_42;
  }
  *(_BYTE *)(v14 + 652) = 0;
LABEL_50:
  v28 = *(_DWORD *)(a2 + 3560);
  if (v28 == 6)
  {
    v30 = 0;
    *(_WORD *)(v14 + 12) = 28;
    *(_OWORD *)(*(_QWORD *)(v14 + 48) + 4) = *(_OWORD *)(a2 + 3564);
    v31 = (char *)v50 + 3;
    do
    {
      v32 = *(unsigned __int8 *)(a2 + 3579 + v30);
      *(v31 - 3) = a0123456789abcd_0[v32 & 0xF];
      LOBYTE(v32) = a0123456789abcd_0[v32 >> 4];
      *(v31 - 2) = 46;
      *(v31 - 1) = v32;
      *v31 = 46;
      v31 += 4;
      --v30;
    }
    while (v30 != -16);
    v29 = &v50[4];
    goto LABEL_56;
  }
  if (v28 == 4)
  {
    *(_WORD *)(v14 + 12) = 1;
    *(_DWORD *)(*(_QWORD *)(v14 + 48) + 4) = *(_DWORD *)(a2 + 3564);
    v29 = v50;
LABEL_56:
    mDNS_snprintf(v29);
  }
  if (!v45
    || (*(_BYTE *)(a2 + 1852) = 0,
        AppendDNSNameString((_BYTE *)(a2 + 1852), (unsigned __int8 *)v50, v19, v20, v21, v22, v23, v24),
        *(_BYTE *)(a2 + 1320) = 1,
        *(_BYTE *)(a2 + 1322) = 1,
        (v8 & 1) == 0))
  {
    FirstAddressRecord = GetFirstAddressRecordEx(*(uint64_t **)(a1 + 12656), a3);
  }
  if (FirstAddressRecord)
    v33 = (uint64_t)FirstAddressRecord;
  else
    v33 = v14;
  *(_QWORD *)(v14 + 96) = v33;
  mDNS_Register_internal(a1, v14);
  v34 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb((unsigned __int8 *)(v14 + 8), (unsigned __int16 *)(*(_QWORD *)(v14 + 48) + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      v47 = 1752392040;
      v48 = 2085;
      v49 = a1 + 47032;
      v36 = v34;
      goto LABEL_69;
    }
  }
  else
  {
    v35 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb((unsigned __int8 *)(v14 + 8), (unsigned __int16 *)(*(_QWORD *)(v14 + 48) + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      v47 = 1752392040;
      v48 = 2085;
      v49 = a1 + 47032;
      v36 = v35;
LABEL_69:
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "Initialized RRSet for %{sensitive, mask.hash}s", buf, 0x16u);
    }
  }
  v37 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      goto LABEL_77;
    v39 = *(_QWORD *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    v47 = v39;
  }
  else
  {
    v37 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_77;
    v38 = *(_QWORD *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    v47 = v38;
  }
  _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "RRSet:                %lx", buf, 0xCu);
LABEL_77:
  if (v45)
    mDNS_Register_internal(a1, v44);
  v40 = *(_QWORD *)(a2 + 3552);
  if (v40 == AWDLInterfaceID || v40 == WiFiAwareInterfaceID)
  {
    if (!*(_BYTE *)(a2 + 32) && !*(_BYTE *)(a2 + 1208))
      goto LABEL_90;
    v41 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v47 = a2 + 3606;
        goto LABEL_89;
      }
    }
    else
    {
      v41 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v47 = a2 + 3606;
LABEL_89:
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "D2D_start_advertising_interface - ifname: %{public}s", buf, 0xCu);
      }
    }
LABEL_90:
    if (*(_BYTE *)(a2 + 32))
      internal_start_advertising_service(a2 + 32, 0, 0);
    if (*(_BYTE *)(a2 + 1208))
      internal_start_advertising_service(a2 + 1208, 0, 0);
  }
}

double mDNS_SetupResourceRecord(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5, char a6, int a7, uint64_t a8, uint64_t a9)
{
  NSObject *v17;
  const char *v19;
  int v25;
  int v26;
  double result;
  int v28;
  uint64_t v29;
  __int16 v30;
  int v31;

  if (a3 != -2 || a7 == 4)
  {
    if (a3 != -3 || a7 == 5)
    {
      if (a3 || (a7 & 0xFFFFFFFE) != 4)
        goto LABEL_35;
      v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_35;
      }
      else
      {
        v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_35;
      }
      v28 = 134218240;
      v29 = 0;
      v30 = 1024;
      v31 = a7;
      v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch InterfaceAny record InterfaceID %p called with artype %d";
    }
    else
    {
      v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_35;
      }
      else
      {
        v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_35;
      }
      v28 = 134218240;
      v29 = -3;
      v30 = 1024;
      v31 = a7;
      v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch P2P record InterfaceID %p called with artype %d";
    }
  }
  else
  {
    v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_35;
    }
    else
    {
      v17 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_35;
    }
    v28 = 134218240;
    v29 = -2;
    v30 = 1024;
    v31 = a7;
    v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch LocalOnly record InterfaceID %p called with artype %d";
  }
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v28, 0x12u);
LABEL_35:
  if (a5)
    v25 = a5;
  else
    v25 = 4500;
  *(_BYTE *)(a1 + 8) = a6;
  if (a5 <= 0x20C49B)
    v26 = v25;
  else
    v26 = 2147483;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = a1 + 652;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 14) = 1;
  *(_DWORD *)(a1 + 16) = v26;
  *(_QWORD *)(a1 + 56) = 0;
  if (!a2)
  {
    a2 = a1 + 908;
    *(_WORD *)(a1 + 908) = 264;
  }
  *(_QWORD *)(a1 + 48) = a2;
  result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = a8;
  *(_QWORD *)(a1 + 112) = a9;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_DWORD *)(a1 + 172) = a7;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_BYTE *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 356) = 0;
  *(_WORD *)(a1 + 358) = 0;
  *(_QWORD *)(a1 + 368) = a1 + 652;
  *(_DWORD *)(a1 + 616) = 0;
  *(_WORD *)(a1 + 620) = 0;
  *(_QWORD *)(a1 + 640) = 0;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_DWORD *)(a1 + 596) = 0;
  *(_BYTE *)(a1 + 652) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 577) = 0u;
  return result;
}

_BYTE *AppendDNSNameString(_BYTE *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  _BYTE *v13;
  unint64_t v14;
  _BYTE *i;
  _BYTE *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _BYTE *v21;
  uint64_t v22;
  BOOL v23;
  _BYTE *v24;

  v8 = 257;
  v9 = a1;
  if (a1 == (_BYTE *)-256)
  {
LABEL_3:
    while (v9)
    {
      v10 = *v9;
      if (v10 > 0x3F)
        break;
      if (!*v9)
      {
        v8 = (unsigned __int16)((_WORD)v9 - (_WORD)a1 + 1);
        break;
      }
      v9 += v10 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if (v9 < a1 + 256)
      goto LABEL_3;
  }
  v11 = (unint64_t)&a1[v8 - 1];
  v12 = *a2;
  v13 = a2;
  if (v12 == 46)
  {
    if (a2[1])
      v12 = 46;
    else
      v12 = 0;
    if (a2[1])
      v13 = a2;
    else
      v13 = a2 + 1;
  }
  if (!v12 || (v14 = (unint64_t)(a1 + 255), v11 >= (unint64_t)(a1 + 255)))
  {
    i = (_BYTE *)v11;
    goto LABEL_44;
  }
  while (2)
  {
    if (v12 == 46)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AppendDNSNameString: Illegal empty label in name \"%s\"", a4, a5, a6, a7, a8, (int)a2);
      return 0;
    }
    for (i = (_BYTE *)(v11 + 1); ; ++i)
    {
      if (!(_BYTE)v12 || v12 == 46 || (unint64_t)i >= v14)
      {
        v16 = v13;
        goto LABEL_32;
      }
      v16 = v13 + 1;
      if (v12 == 92)
        break;
LABEL_30:
      *i = v12;
      LOBYTE(v12) = *v16;
      v13 = v16;
    }
    v17 = (char)*v16;
    if (*v16)
    {
      LOBYTE(v12) = *v16;
      v16 = v13 + 2;
      if (v17 - 48 <= 9)
      {
        v18 = (char)*v16;
        if ((v18 - 48) <= 9)
        {
          v19 = v13[3];
          a4 = (v19 - 48);
          if (a4 <= 9)
          {
            v20 = 100 * v17 + 10 * v18 + v19;
            v21 = v13 + 4;
            if (v20 < 5584)
            {
              LOBYTE(v12) = v20 + 48;
              v16 = v21;
            }
          }
        }
      }
      goto LABEL_30;
    }
    LOBYTE(v12) = 0;
LABEL_32:
    v22 = (uint64_t)&i[~v11];
    if (v22 > 63)
      return 0;
    if (v12 == 46)
      v13 = v16 + 1;
    else
      v13 = v16;
    *(_BYTE *)v11 = v22;
    LOBYTE(v12) = *v13;
    if (*v13)
      v23 = (unint64_t)i >= v14;
    else
      v23 = 1;
    v11 = (unint64_t)i;
    if (!v23)
      continue;
    break;
  }
LABEL_44:
  *i = 0;
  v24 = i + 1;
  if (*v13)
    return 0;
  else
    return v24;
}

size_t mDNS_Register_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  unsigned int v11;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  NSObject *v19;
  uint32_t v20;
  uint64_t *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t *v24;
  uint64_t *v25;
  _QWORD *v26;
  NSObject *v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t *v31;
  BOOL v32;
  uint64_t v33;
  _BYTE *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  BOOL v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  char v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  const char *v61;
  const char *v62;
  int v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  _BYTE *v67;
  uint64_t v68;
  const char *v69;
  size_t result;
  _BYTE *v71;
  int v72;
  int v73;
  const char *v74;
  NSObject *v75;
  unint64_t v76;
  _BYTE *v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  _BYTE *v82;
  uint64_t v83;
  _BYTE *v84;
  uint64_t v85;
  uint64_t v86;
  unsigned __int8 *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  char *v92;
  int v93;
  char *v94;
  int v95;
  int v96;
  BOOL v97;
  BOOL v98;
  BOOL v99;
  char *v100;
  int v101;
  char *v102;
  uint64_t RDataBytesPointer;
  NSObject *v104;
  __int16 *v105;
  const char *v106;
  int v107;
  NSObject *v108;
  unsigned __int8 *v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  __int16 *v113;
  NSObject *v114;
  unsigned __int8 *v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  unsigned __int8 *v119;
  int v120;
  uint64_t v121;
  uint64_t *v122;
  unsigned __int8 *v123;
  int v124;
  uint64_t v125;
  int v126;
  unsigned int v127;
  size_t v128;
  unsigned int v129;
  uint64_t *inserted;
  int v131;
  unsigned int v132;
  size_t v133;
  unsigned int v134;
  _BYTE *v135;
  uint64_t v136;
  os_log_t log;
  NSObject *loga;
  os_log_t v139;
  NSObject *v140;
  void *__src;
  unsigned int __srca;
  unsigned int v143;
  void *v144;
  int v145;
  int v146;
  unsigned __int16 __n;
  int __n_2;
  _BYTE __n_6[50];
  __int16 v150;
  unsigned int v151;
  __int16 v152;
  __int16 *v153;

  v10 = 0;
  v11 = *(unsigned __int16 *)(a2 + 12);
  if (v11 > 0x20)
  {
    switch(v11)
    {
      case '!':
        v10 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 10);
        break;
      case '$':
LABEL_7:
        v10 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 6);
        break;
      case '\'':
LABEL_13:
        v10 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 4);
        break;
    }
  }
  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v11 == 2 || v11 == 5)
          goto LABEL_13;
        break;
    }
  }
  v13 = (unsigned __int8 *)(a2 + 8);
  v14 = *(_DWORD *)(a2 + 16);
  if (v14 <= 0)
  {
    v18 = mDNSLogCategory_State;
    v16 = 4294901756;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)__n_6 = 67109635;
    *(_DWORD *)&__n_6[4] = v14;
    *(_WORD *)&__n_6[8] = 2160;
    *(_QWORD *)&__n_6[10] = 1752392040;
    *(_WORD *)&__n_6[18] = 2085;
    *(_QWORD *)&__n_6[20] = a1 + 47032;
    v17 = "mDNS_Register_internal: TTL %X should be 1 - 0x7FFFFFFF %{sensitive, mask.hash}s";
    v19 = v18;
    v20 = 28;
    goto LABEL_26;
  }
  if (!*v13)
  {
    v15 = mDNSLogCategory_State;
    v16 = 4294901756;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(_QWORD *)&__n_6[14] = a1 + 47032;
    v17 = "mDNS_Register_internal: RecordType must be non-zero %{sensitive, mask.hash}s";
    goto LABEL_24;
  }
  if (*(_DWORD *)(a1 + 76))
  {
    v15 = mDNSLogCategory_State;
    v16 = 4294901733;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(_QWORD *)&__n_6[14] = a1 + 47032;
    v17 = "mDNS_Register_internal: Shutting down, can't register %{sensitive, mask.hash}s";
LABEL_24:
    v19 = v15;
LABEL_25:
    v20 = 22;
    goto LABEL_26;
  }
  v21 = (uint64_t *)(a1 + 12616);
  if (*(_BYTE *)(a1 + 14))
  {
    v22 = *(_QWORD *)(a2 + 32);
    if (!v22)
    {
      if (*(_BYTE *)(a2 + 122))
      {
        *(_QWORD *)(a2 + 32) = -2;
        *(_DWORD *)(a2 + 172) = 4;
LABEL_35:
        v23 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
          *(_DWORD *)__n_6 = 141558275;
          *(_QWORD *)&__n_6[4] = 1752392040;
          *(_WORD *)&__n_6[12] = 2085;
          *(_QWORD *)&__n_6[14] = a1 + 47032;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: Diverting record to local-only %{sensitive, mask.hash}s", __n_6, 0x16u);
        }
        goto LABEL_37;
      }
      if (!IsLocalDomain(*(_BYTE **)(a2 + 40)))
        goto LABEL_37;
      v22 = *(_QWORD *)(a2 + 32);
    }
    switch(v22)
    {
      case -3:
        goto LABEL_32;
      case -2:
        goto LABEL_37;
      case 0:
LABEL_32:
        *(_QWORD *)(a2 + 32) = -2;
        *(_DWORD *)(a2 + 172) = 4;
        goto LABEL_35;
    }
    v48 = a1 + 12656;
    while (1)
    {
      v48 = *(_QWORD *)v48;
      if (!v48)
        break;
      if (*(_QWORD *)(v48 + 3552) == v22)
      {
        if (*(_BYTE *)(v48 + 3670))
          break;
        goto LABEL_32;
      }
    }
  }
LABEL_37:
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v24 = AuthGroupForName(a1 + 6264, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
    v25 = (uint64_t *)(a1 + 12616);
    if (v24)
    {
      v26 = v24 + 2;
      while (1)
      {
        v26 = (_QWORD *)*v26;
        if (!v26)
          break;
        if (v26 == (_QWORD *)a2)
        {
          v27 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            v28 = *(_QWORD *)(a2 + 40);
            if (v28)
            {
              v29 = *(_BYTE **)(a2 + 40);
              if (v28 == -256)
              {
LABEL_46:
                while (v29)
                {
                  v30 = *v29;
                  if (v30 > 0x3F)
                    break;
                  if (!*v29)
                  {
                    v63 = (unsigned __int16)((_WORD)v29 - v28 + 1);
                    goto LABEL_144;
                  }
                  v29 += v30 + 1;
                  if (v28 != -256)
                    goto LABEL_45;
                }
              }
              else
              {
LABEL_45:
                if ((unint64_t)v29 < v28 + 256)
                  goto LABEL_46;
              }
              v63 = 257;
            }
            else
            {
              v63 = 0;
            }
LABEL_144:
            v69 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
            *(_DWORD *)__n_6 = 134219011;
            *(_QWORD *)&__n_6[4] = a2;
            *(_WORD *)&__n_6[12] = 2160;
            *(_QWORD *)&__n_6[14] = 1752392040;
            *(_WORD *)&__n_6[22] = 1040;
            *(_DWORD *)&__n_6[24] = v63;
            *(_WORD *)&__n_6[28] = 2101;
            *(_QWORD *)&__n_6[30] = v28;
            *(_WORD *)&__n_6[38] = 2082;
            *(_QWORD *)&__n_6[40] = v69;
            v62 = "mDNS_Register_internal: ERROR!! Tried to register LocalOnly AuthRecord %p %{sensitive, mask.hash, mdns"
                  "responder:domain_name}.*P (%{public}s) that's already in the list";
            goto LABEL_145;
          }
          return 4294901749;
        }
      }
      v25 = (uint64_t *)(a1 + 12616);
    }
  }
  else
  {
    v31 = (uint64_t *)(a1 + 12616);
    do
    {
      v25 = v31;
      v31 = (uint64_t *)*v31;
      if (v31)
        v32 = v31 == (uint64_t *)a2;
      else
        v32 = 1;
    }
    while (!v32);
    if (v31)
    {
      v27 = mDNSLogCategory_State;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        return 4294901749;
      v33 = *(_QWORD *)(a2 + 40);
      if (v33)
      {
        v34 = *(_BYTE **)(a2 + 40);
        if (v33 == -256)
        {
          while (1)
          {
LABEL_62:
            if (!v34)
              goto LABEL_115;
            v35 = *v34;
            if (v35 > 0x3F)
              goto LABEL_115;
            if (!*v34)
              break;
            v34 += v35 + 1;
            if (v33 != -256)
              goto LABEL_61;
          }
          v50 = (unsigned __int16)((_WORD)v34 - v33 + 1);
        }
        else
        {
LABEL_61:
          if ((unint64_t)v34 < v33 + 256)
            goto LABEL_62;
LABEL_115:
          v50 = 257;
        }
      }
      else
      {
        v50 = 0;
      }
      v64 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)__n_6 = 134219011;
      *(_QWORD *)&__n_6[4] = a2;
      *(_WORD *)&__n_6[12] = 2160;
      *(_QWORD *)&__n_6[14] = 1752392040;
      *(_WORD *)&__n_6[22] = 1040;
      *(_DWORD *)&__n_6[24] = v50;
      *(_WORD *)&__n_6[28] = 2101;
      *(_QWORD *)&__n_6[30] = v33;
      *(_WORD *)&__n_6[38] = 2082;
      *(_QWORD *)&__n_6[40] = v64;
      v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the list";
      goto LABEL_145;
    }
  }
  v36 = (uint64_t *)(a1 + 12624);
  do
  {
    v37 = v36;
    v36 = (uint64_t *)*v36;
    if (v36)
      v38 = v36 == (uint64_t *)a2;
    else
      v38 = 1;
  }
  while (!v38);
  if (v36)
  {
    v27 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      v39 = *(_QWORD *)(a2 + 40);
      if (v39)
      {
        v40 = *(_BYTE **)(a2 + 40);
        if (v39 == -256)
        {
LABEL_79:
          while (v40)
          {
            v41 = *v40;
            if (v41 > 0x3F)
              break;
            if (!*v40)
            {
              v49 = (unsigned __int16)((_WORD)v40 - v39 + 1);
              goto LABEL_129;
            }
            v40 += v41 + 1;
            if (v39 != -256)
              goto LABEL_78;
          }
        }
        else
        {
LABEL_78:
          if ((unint64_t)v40 < v39 + 256)
            goto LABEL_79;
        }
        v49 = 257;
      }
      else
      {
        v49 = 0;
      }
LABEL_129:
      v61 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)__n_6 = 134219011;
      *(_QWORD *)&__n_6[4] = a2;
      *(_WORD *)&__n_6[12] = 2160;
      *(_QWORD *)&__n_6[14] = 1752392040;
      *(_WORD *)&__n_6[22] = 1040;
      *(_DWORD *)&__n_6[24] = v49;
      *(_WORD *)&__n_6[28] = 2101;
      *(_QWORD *)&__n_6[30] = v39;
      *(_WORD *)&__n_6[38] = 2082;
      *(_QWORD *)&__n_6[40] = v61;
      v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the Duplicate list";
LABEL_145:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v62, __n_6, 0x30u);
    }
    return 4294901749;
  }
  v42 = *(_QWORD *)(a2 + 88);
  if (v42)
  {
    v43 = *v13;
    if (v43 != 32)
    {
      if (v43 != 2)
      {
        v16 = 4294901747;
        v57 = mDNSLogCategory_State;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          return v16;
        v58 = *(_QWORD *)(a2 + 40);
        if (v58)
        {
          v59 = *(_BYTE **)(a2 + 40);
          if (v58 == -256)
          {
            while (1)
            {
LABEL_123:
              if (!v59)
                goto LABEL_156;
              v60 = *v59;
              if (v60 > 0x3F)
                goto LABEL_156;
              if (!*v59)
                break;
              v59 += v60 + 1;
              if (v58 != -256)
                goto LABEL_122;
            }
            v72 = (unsigned __int16)((_WORD)v59 - v58 + 1);
          }
          else
          {
LABEL_122:
            if ((unint64_t)v59 < v58 + 256)
              goto LABEL_123;
LABEL_156:
            v72 = 257;
          }
        }
        else
        {
          v72 = 0;
        }
        v74 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        *(_DWORD *)__n_6 = 141558787;
        *(_QWORD *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v72;
        *(_WORD *)&__n_6[18] = 2101;
        *(_QWORD *)&__n_6[20] = v58;
        *(_WORD *)&__n_6[28] = 2082;
        *(_QWORD *)&__n_6[30] = v74;
        v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Dep"
              "endentOn && RecordType != kDNSRecordTypeUnique or kDNSRecordTypeKnownUnique";
        v19 = v57;
        v20 = 38;
        goto LABEL_26;
      }
      *v13 = 16;
    }
    if ((*(_BYTE *)(v42 + 8) & 0x32) != 0)
      goto LABEL_89;
    v16 = 4294901747;
    v65 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    v66 = *(_QWORD *)(a2 + 40);
    if (v66)
    {
      v67 = *(_BYTE **)(a2 + 40);
      if (v66 == -256)
      {
        while (1)
        {
LABEL_137:
          if (!v67)
            goto LABEL_158;
          v68 = *v67;
          if (v68 > 0x3F)
            goto LABEL_158;
          if (!*v67)
            break;
          v67 += v68 + 1;
          if (v66 != -256)
            goto LABEL_136;
        }
        v73 = (unsigned __int16)((_WORD)v67 - v66 + 1);
      }
      else
      {
LABEL_136:
        if ((unint64_t)v67 < v66 + 256)
          goto LABEL_137;
LABEL_158:
        v73 = 257;
      }
    }
    else
    {
      v73 = 0;
    }
    v106 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    v107 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 88) + 8);
    *(_DWORD *)__n_6 = 141559043;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 1040;
    *(_DWORD *)&__n_6[14] = v73;
    *(_WORD *)&__n_6[18] = 2101;
    *(_QWORD *)&__n_6[20] = v66;
    *(_WORD *)&__n_6[28] = 2082;
    *(_QWORD *)&__n_6[30] = v106;
    *(_WORD *)&__n_6[38] = 1024;
    *(_DWORD *)&__n_6[40] = v107;
    v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Depende"
          "ntOn->RecordType bad type %X";
    v19 = v65;
    v20 = 44;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v17, __n_6, v20);
    return v16;
  }
LABEL_89:
  *(_QWORD *)a2 = 0;
  v44 = *(unsigned __int8 *)(a2 + 120);
  if (*(_BYTE *)(a2 + 120) && v10)
  {
    *v10 = 0;
    v44 = *(unsigned __int8 *)(a2 + 120);
  }
  *(_WORD *)(a2 + 188) = 0;
  if (*(_BYTE *)(a2 + 8) == 2)
    v45 = 3;
  else
    v45 = 0;
  *(_BYTE *)(a2 + 190) = v45;
  *(_BYTE *)(a2 + 191) = 4;
  *(_DWORD *)(a2 + 192) = 0;
  *(_QWORD *)(a2 + 264) = 0;
  *(_QWORD *)(a2 + 272) = 0;
  *(_QWORD *)(a2 + 256) = 0;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_DWORD *)(a2 + 248) = 0;
  if (!v44)
    InitializeLastAPTime((_DWORD *)a1, a2);
  *(_QWORD *)(a2 + 304) = 0;
  *(_WORD *)(a2 + 312) = 0;
  *(_QWORD *)(a2 + 320) = 0;
  *(_QWORD *)(a2 + 328) = 10;
  *(_DWORD *)(a2 + 336) = 0;
  if (*(_DWORD *)(a2 + 126) && !*(_DWORD *)(a2 + 144))
    *(_BYTE *)(a2 + 191) = 2;
  *(_DWORD *)(a2 + 344) = 0;
  *(_BYTE *)(a2 + 348) = 0;
  *(_DWORD *)(a2 + 352) = 0;
  *(_BYTE *)(a2 + 356) = 0;
  *(_WORD *)(a2 + 358) = 0;
  v46 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 360) = 0;
  *(_QWORD *)(a2 + 368) = v46;
  *(_DWORD *)(a2 + 616) = 0;
  *(_WORD *)(a2 + 620) = 0;
  *(_QWORD *)(a2 + 376) = 0;
  *(_QWORD *)(a2 + 384) = 0;
  *(_QWORD *)(a2 + 624) = 0;
  *(_QWORD *)(a2 + 640) = 0;
  *(_QWORD *)(a2 + 632) = 0;
  if (*(_WORD *)(a2 + 12) == 16 && !*(_WORD *)(a2 + 20))
  {
    *(_WORD *)(a2 + 20) = 1;
    *(_BYTE *)(*(_QWORD *)(a2 + 48) + 4) = 0;
  }
  if (*(_BYTE *)(a2 + 120))
  {
    SetTargetToHostName(a1, a2);
    if (*(_DWORD *)(a2 + 344) == 8)
    {
      v47 = *(unsigned __int16 *)(a2 + 12);
      if (v47 <= 0x20)
      {
        switch(*(_WORD *)(a2 + 12))
        {
          case 0xC:
            goto LABEL_155;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_164;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_152;
          default:
            if (v47 == 2 || v47 == 5)
              goto LABEL_155;
            break;
        }
        goto LABEL_164;
      }
      switch(v47)
      {
        case '!':
          v71 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 10);
          break;
        case '$':
LABEL_152:
          v71 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 6);
          break;
        case '\'':
LABEL_155:
          v71 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 4);
          break;
        default:
LABEL_164:
          v75 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
            *(_DWORD *)__n_6 = 136446210;
            *(_QWORD *)&__n_6[4] = a1 + 47032;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: record %{public}s in NoTarget state", __n_6, 0xCu);
          }
          goto LABEL_166;
      }
      *v71 = 0;
      goto LABEL_164;
    }
  }
  else
  {
    *(_WORD *)(a2 + 20) = GetRDLength(a2 + 8, 0, a3, a4, a5, a6, a7, a8);
    *(_WORD *)(a2 + 22) = GetRDLength(a2 + 8, 1, v51, v52, v53, v54, v55, v56);
  }
LABEL_166:
  v76 = *(_QWORD *)(a2 + 40);
  v77 = (_BYTE *)v76;
  if (v76 != -256)
  {
LABEL_167:
    if ((unint64_t)v77 < v76 + 256)
      goto LABEL_168;
LABEL_177:
    v16 = 4294901747;
    v15 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(_QWORD *)&__n_6[14] = a1 + 47032;
    v17 = "Attempt to register record with invalid name: %{sensitive, mask.hash}s";
    goto LABEL_24;
  }
  while (1)
  {
LABEL_168:
    if (!v77)
      goto LABEL_177;
    v78 = *v77;
    if (v78 > 0x3F)
      goto LABEL_177;
    if (!*v77)
      break;
    v77 += v78 + 1;
    if (v76 != -256)
      goto LABEL_167;
  }
  if ((unsigned __int16)((_WORD)v77 - v76 + 1) >= 0x101u)
    goto LABEL_177;
  v79 = *(_QWORD *)(a2 + 48);
  if (!ValidateRData(*(unsigned __int16 *)(a2 + 12), *(unsigned __int16 *)(a2 + 20), (_BYTE *)v79))
  {
    v16 = 4294901747;
    v81 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    v82 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb(v13, (unsigned __int16 *)(v79 + 4), v82);
    *(_DWORD *)__n_6 = 141558275;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(_QWORD *)&__n_6[14] = v82;
    v17 = "Attempt to register record with invalid rdata: %{sensitive, mask.hash}s";
    v19 = v81;
    goto LABEL_25;
  }
  *(_DWORD *)(a2 + 24) = DomainNameHashValue(v76);
  if (v10)
    v80 = DomainNameHashValue((unint64_t)v10);
  else
    v80 = RDataHashValue(a2 + 8);
  *(_DWORD *)(a2 + 28) = v80;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4
    && (*v13 & 0x32) != 0
    && CheckAuthRecordConflict(a1 + 6264, a2))
  {
    v83 = mDNSLogCategory_State;
    v16 = 4294901748;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v16;
    v84 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v84);
    v85 = *(_QWORD *)(a2 + 32);
    *(_DWORD *)__n_6 = 141558787;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(_QWORD *)&__n_6[14] = v84;
    *(_WORD *)&__n_6[22] = 2048;
    *(_QWORD *)&__n_6[24] = a2;
    *(_WORD *)&__n_6[32] = 2048;
    *(_QWORD *)&__n_6[34] = v85;
    v17 = "mDNS_Register_internal: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p";
    v19 = v83;
    v20 = 42;
    goto LABEL_26;
  }
  if (!*(_QWORD *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    if (!*(_QWORD *)(a1 + 12632))
      *(_QWORD *)(a1 + 12632) = a2;
    do
    {
      v122 = v25;
      v25 = (uint64_t *)*v25;
    }
    while (v25);
    *v122 = a2;
    if (*(_BYTE *)(a2 + 8) == 2)
      *v13 = 16;
    v16 = 0;
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    if (*(_DWORD *)(a2 + 344) == 8)
      return v16;
    ActivateUnicastRegistration(a1, a2);
    return 0;
  }
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    v86 = CheckAuthIdenticalRecord(a1 + 6264, a2);
    v87 = *(unsigned __int8 **)(a2 + 40);
    v91 = mDNS_DomainNameFNV1aHash(v87);
    if (v86)
      goto LABEL_192;
LABEL_212:
    result = *(unsigned __int16 *)(a2 + 20);
    if (result >= 0x201)
    {
      result = (size_t)malloc_type_malloc(result, 0xA172743EuLL);
      if (!result)
        goto LABEL_342;
      v102 = (char *)result;
      LODWORD(result) = *(unsigned __int16 *)(a2 + 20);
      v100 = v102;
      v101 = result;
    }
    else
    {
      v100 = 0;
      v101 = 512;
      v102 = (char *)&unk_100164380;
    }
    if (!(_DWORD)result)
    {
      v108 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        if (v87)
        {
          v109 = v87;
          if (v87 == (unsigned __int8 *)-256)
            goto LABEL_228;
LABEL_225:
          v110 = 257;
          if (v109 < v87 + 256 && v109)
          {
            while (1)
            {
              v111 = *v109;
              if (v111 > 0x3F)
              {
LABEL_284:
                v110 = 257;
                goto LABEL_288;
              }
              if (!*v109)
                break;
              v109 += v111 + 1;
              if (v87 != (unsigned __int8 *)-256)
                goto LABEL_225;
LABEL_228:
              if (!v109)
                goto LABEL_284;
            }
            v110 = (unsigned __int16)((_WORD)v109 - (_WORD)v87 + 1);
          }
        }
        else
        {
          v110 = 0;
        }
LABEL_288:
        v126 = *(unsigned __int16 *)(a2 + 12);
        *(_DWORD *)__n_6 = 141559043;
        *(_QWORD *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v110;
        *(_WORD *)&__n_6[18] = 2101;
        *(_QWORD *)&__n_6[20] = v87;
        *(_WORD *)&__n_6[28] = 1024;
        *(_DWORD *)&__n_6[30] = v91;
        *(_WORD *)&__n_6[34] = 1024;
        *(_DWORD *)&__n_6[36] = v126;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>", __n_6, 0x28u);
      }
      goto LABEL_299;
    }
    __n_2 = 0;
    __n = 0;
    RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v102, v101, &__n, &__n_2, v88, v89, v90);
    if (__n_2)
    {
LABEL_299:
      if (v100)
        free(v100);
      if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4)
      {
        if (!*(_QWORD *)(a1 + 12632))
          *(_QWORD *)(a1 + 12632) = a2;
        *v25 = a2;
        goto LABEL_328;
      }
      inserted = InsertAuthRecord(a1 + 6264, a2);
      if (inserted && !inserted[5])
      {
        *(_BYTE *)(a1 + 12648) = 1;
        inserted[5] = a2;
      }
      if (*v13 == 2)
        *v13 = 16;
      AcknowledgeRecord(a1, a2);
      return 0;
    }
    __src = (void *)RDataBytesPointer;
    v145 = v91;
    if (__n < 0x1FFuLL)
    {
      v104 = 0;
      v143 = 512;
      v105 = word_100164580;
LABEL_252:
      v118 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        loga = v118;
        v139 = v104;
        if (v87)
        {
          v119 = v87;
          v120 = 257;
          if (v87 == (unsigned __int8 *)-256)
            goto LABEL_258;
LABEL_255:
          if (v119 < v87 + 256 && v119)
          {
            while (1)
            {
              v121 = *v119;
              if (v121 > 0x3F)
              {
LABEL_290:
                v120 = 257;
                goto LABEL_293;
              }
              if (!*v119)
                break;
              v119 += v121 + 1;
              if (v87 != (unsigned __int8 *)-256)
                goto LABEL_255;
LABEL_258:
              if (!v119)
                goto LABEL_290;
            }
            v120 = (unsigned __int16)((_WORD)v119 - (_WORD)v87 + 1);
          }
        }
        else
        {
          v120 = 0;
        }
LABEL_293:
        v127 = *(unsigned __int16 *)(a2 + 12);
        v128 = __n;
        v129 = __n + 2;
        if (v129 <= v143)
        {
          *v105 = __rev16(v127);
          memcpy(v105 + 1, __src, v128);
        }
        else
        {
          v105 = 0;
        }
        *(_DWORD *)__n_6 = 141559811;
        *(_QWORD *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v120;
        *(_WORD *)&__n_6[18] = 2101;
        *(_QWORD *)&__n_6[20] = v87;
        *(_WORD *)&__n_6[28] = 1024;
        *(_DWORD *)&__n_6[30] = v145;
        *(_WORD *)&__n_6[34] = 1024;
        *(_DWORD *)&__n_6[36] = v127;
        *(_WORD *)&__n_6[40] = 2160;
        *(_QWORD *)&__n_6[42] = 1752392040;
        v150 = 1040;
        v151 = v129;
        v152 = 2101;
        v153 = v105;
        _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", __n_6, 0x42u);
        v104 = v139;
      }
      if (v104)
        free(v104);
      goto LABEL_299;
    }
    v143 = __n + 2;
    result = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
    if (result)
    {
      v105 = (__int16 *)result;
      v104 = result;
      goto LABEL_252;
    }
LABEL_342:
    __break(1u);
    return result;
  }
  v86 = *v21;
  if (!*v21)
  {
LABEL_211:
    v87 = *(unsigned __int8 **)(a2 + 40);
    v91 = mDNS_DomainNameFNV1aHash(v87);
    goto LABEL_212;
  }
  while (1)
  {
    if (*(_QWORD *)(v86 + 32) != *(_QWORD *)(a2 + 32))
      goto LABEL_210;
    v95 = *(unsigned __int8 *)(v86 + 8);
    v96 = *v13;
    v97 = v96 == 1 || v95 == 1;
    v98 = v97 || v95 == v96;
    v99 = v98 || (v96 | v95) == 18;
    if (!v99 || !IdenticalResourceRecord(v86 + 8, a2 + 8))
      goto LABEL_210;
    if (*(_BYTE *)(v86 + 8) != 1)
      break;
    *(_BYTE *)(v86 + 191) = 0;
LABEL_210:
    v86 = *(_QWORD *)v86;
    if (!v86)
      goto LABEL_211;
  }
  v87 = *(unsigned __int8 **)(a2 + 40);
  v91 = mDNS_DomainNameFNV1aHash(v87);
LABEL_192:
  result = *(unsigned __int16 *)(a2 + 20);
  if (result < 0x201)
  {
    v92 = 0;
    v93 = 512;
    v94 = (char *)&unk_100164380;
    goto LABEL_235;
  }
  result = (size_t)malloc_type_malloc(result, 0xA172743EuLL);
  if (!result)
    goto LABEL_342;
  v94 = (char *)result;
  LODWORD(result) = *(unsigned __int16 *)(a2 + 20);
  v92 = v94;
  v93 = result;
LABEL_235:
  if (!(_DWORD)result)
  {
    v114 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      if (v87)
      {
        v115 = v87;
        if (v87 == (unsigned __int8 *)-256)
          goto LABEL_245;
LABEL_242:
        v116 = 257;
        if (v115 < v87 + 256 && v115)
        {
          while (1)
          {
            v117 = *v115;
            if (v117 > 0x3F)
            {
LABEL_291:
              v116 = 257;
              goto LABEL_314;
            }
            if (!*v115)
              break;
            v115 += v117 + 1;
            if (v87 != (unsigned __int8 *)-256)
              goto LABEL_242;
LABEL_245:
            if (!v115)
              goto LABEL_291;
          }
          v116 = (unsigned __int16)((_WORD)v115 - (_WORD)v87 + 1);
        }
      }
      else
      {
        v116 = 0;
      }
LABEL_314:
      v131 = *(unsigned __int16 *)(a2 + 12);
      *(_DWORD *)__n_6 = 141559043;
      *(_QWORD *)&__n_6[4] = 1752392040;
      *(_WORD *)&__n_6[12] = 1040;
      *(_DWORD *)&__n_6[14] = v116;
      *(_WORD *)&__n_6[18] = 2101;
      *(_QWORD *)&__n_6[20] = v87;
      *(_WORD *)&__n_6[28] = 1024;
      *(_DWORD *)&__n_6[30] = v91;
      *(_WORD *)&__n_6[34] = 1024;
      *(_DWORD *)&__n_6[36] = v131;
      _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>", __n_6, 0x28u);
    }
    goto LABEL_323;
  }
  __n_2 = 0;
  __n = 0;
  v112 = ResourceRecordGetRDataBytesPointer(a2 + 8, v94, v93, &__n, &__n_2, v88, v89, v90);
  if (__n_2)
    goto LABEL_323;
  v146 = v91;
  log = (os_log_t)v112;
  if (__n < 0x1FFuLL)
  {
    __srca = 512;
    v144 = 0;
    v113 = word_100164580;
    goto LABEL_273;
  }
  __srca = __n + 2;
  result = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
  if (!result)
    goto LABEL_342;
  v113 = (__int16 *)result;
  v144 = (void *)result;
LABEL_273:
  v140 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    if (v87)
    {
      v123 = v87;
      v124 = 257;
      if (v87 == (unsigned __int8 *)-256)
        goto LABEL_279;
LABEL_276:
      if (v123 < v87 + 256 && v123)
      {
        while (1)
        {
          v125 = *v123;
          if (v125 > 0x3F)
          {
LABEL_315:
            v124 = 257;
            goto LABEL_317;
          }
          if (!*v123)
            break;
          v123 += v125 + 1;
          if (v87 != (unsigned __int8 *)-256)
            goto LABEL_276;
LABEL_279:
          if (!v123)
            goto LABEL_315;
        }
        v124 = (unsigned __int16)((_WORD)v123 - (_WORD)v87 + 1);
      }
    }
    else
    {
      v124 = 0;
    }
LABEL_317:
    v132 = *(unsigned __int16 *)(a2 + 12);
    v133 = __n;
    v134 = __n + 2;
    if (v134 <= __srca)
    {
      *v113 = __rev16(v132);
      memcpy(v113 + 1, log, v133);
    }
    else
    {
      v113 = 0;
    }
    *(_DWORD *)__n_6 = 141559811;
    *(_QWORD *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 1040;
    *(_DWORD *)&__n_6[14] = v124;
    *(_WORD *)&__n_6[18] = 2101;
    *(_QWORD *)&__n_6[20] = v87;
    *(_WORD *)&__n_6[28] = 1024;
    *(_DWORD *)&__n_6[30] = v146;
    *(_WORD *)&__n_6[34] = 1024;
    *(_DWORD *)&__n_6[36] = v132;
    *(_WORD *)&__n_6[40] = 2160;
    *(_QWORD *)&__n_6[42] = 1752392040;
    v150 = 1040;
    v151 = v134;
    v152 = 2101;
    v153 = v113;
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", __n_6, 0x42u);
  }
  if (v144)
    free(v144);
LABEL_323:
  if (v92)
    free(v92);
  *v37 = a2;
  if (*(_BYTE *)(a2 + 8) == 2 && *(_BYTE *)(v86 + 8) == 16)
    *(_BYTE *)(a2 + 190) = 0;
LABEL_328:
  if (*(_QWORD *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    IncrementAutoTargetServices(a1, a2);
    if (*(unsigned __int8 *)(a2 + 8) - 1 >= 2)
      AcknowledgeRecord(a1, a2);
    mDNS_UpdateAllowSleep(a1);
  }
  if (!*(_DWORD *)(a2 + 126) && *(_WORD *)(a2 + 12) == 10)
  {
    v135 = *(_BYTE **)(a2 + 40);
    if (*v135)
      v136 = *v135 + 1;
    else
      v136 = 0;
    if (SameDomainLabelPointer(&v135[v136], "\n_keepalive"))
    {
      memset(__n_6, 0, 20);
      *(_BYTE *)(a2 + 8) = 32;
      *(_BYTE *)(a2 + 191) = 0;
      getKeepaliveRaddr(a1, a2, (uint64_t)__n_6);
      mDNSPlatformGetRemoteMacAddr((int *)__n_6);
    }
  }
  v16 = 0;
  *(_DWORD *)(a2 + 648) = *(_DWORD *)(a1 + 64);
  return v16;
}

void InitializeLastAPTime(_DWORD *a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint32_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint32_t v20;
  _DWORD v21[2];
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;
  unsigned int v29;

  v4 = *(_DWORD *)(a2 + 144);
  if (v4)
  {
    v5 = 1000;
  }
  else
  {
    if ((*(_BYTE *)(a2 + 8) & 0x30) != 0)
      v6 = 500;
    else
      v6 = 0;
    if ((*(_BYTE *)(a2 + 8) & 2) != 0)
      v7 = 250;
    else
      v7 = v6;
    if ((*(_BYTE *)(a2 + 8) & 0xC) != 0)
      v5 = 500;
    else
      v5 = v7;
  }
  *(_DWORD *)(a2 + 280) = v5;
  if (!*(_BYTE *)(a2 + 190))
  {
    v16 = *(unsigned __int8 *)(a2 + 8);
    if (v16 == 8 || v16 == 32 || (v17 = a1[3168]) == 0 || (v9 = a1[16], (int)(v17 - v9) < 0))
    {
      v9 = a1[16];
      v18 = v9 - v5;
    }
    else
    {
      v18 = v17 - v5 + (v5 >> 1) + 750;
    }
    *(_DWORD *)(a2 + 284) = v18;
    if (v4)
      goto LABEL_56;
    goto LABEL_57;
  }
  *(_DWORD *)(a2 + 180) = 0;
  v8 = a1[3168];
  v9 = a1[16];
  if (!v8 || ((v8 - v9) & 0x80000000) != 0)
  {
    do
      v10 = arc4random() & 0x7F;
    while (v10 > 0x7D);
    v8 = v9 + v10 + 125;
    if (v8 <= 1)
      v8 = 1;
    a1[3168] = v8;
    v11 = a1[24];
    if ((int)(v8 - v11) >= 0)
    {
      if (v11 <= 1)
        v8 = 1;
      else
        v8 = a1[24];
      a1[3168] = v8;
    }
    v9 = a1[16];
    if ((int)(v8 - v9) < 0)
    {
      a1[3168] = v9;
      v8 = v9;
    }
    v12 = a1[23];
    if ((int)(v8 - v12) >= 0)
    {
      if (v12 <= 1)
        v8 = 1;
      else
        v8 = a1[23];
      a1[3168] = v8;
    }
    if ((int)(v8 - v9) < 0)
    {
      a1[3168] = v9;
      v8 = v9;
    }
    v13 = a1[20];
    if (v13 && ((v8 - v13) & 0x80000000) != 0)
    {
      a1[3168] = v13;
      v8 = v13;
    }
    v14 = v8 - v9;
    if ((int)(v8 - v9) >= 8001)
    {
      v15 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_50;
      }
      else
      {
        v15 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_50;
      }
      v21[0] = 67110144;
      v21[1] = v14;
      v22 = 1024;
      v23 = v11 - v9;
      v24 = 1024;
      v25 = v12 - v9;
      v26 = 1024;
      v27 = v13;
      v28 = 1024;
      v29 = v13 - v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "InitializeLastAPTime ERROR m->SuppressProbes %d m->NextScheduledProbe %d m->NextScheduledQuery %d m->SuppressQueries %d %d", (uint8_t *)v21, 0x20u);
LABEL_50:
      v19 = a1[16];
      do
        v20 = arc4random() & 0x7F;
      while (v20 > 0x7D);
      v8 = v19 + v20 + 125;
      if (v8 <= 1)
        v8 = 1;
      a1[3168] = v8;
      v9 = a1[16];
    }
  }
  *(_DWORD *)(a2 + 284) = v8 - *(_DWORD *)(a2 + 280);
  if (*(_DWORD *)(a2 + 144))
LABEL_56:
    *(_DWORD *)(a2 + 284) = v9;
LABEL_57:
  *(_DWORD *)(a2 + 288) = v9;
  *(_QWORD *)(a2 + 296) = -1;
  SetNextAnnounceProbeTime((uint64_t)a1, a2);
}

void SetNextAnnounceProbeTime(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  int v5;
  int v6;
  NSObject *v7;
  _BOOL4 IsValidAnswer;
  int v11;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;

  v4 = (unsigned __int8 *)(a2 + 8);
  v5 = *(unsigned __int8 *)(a2 + 8);
  if (v5 == 2)
  {
    v6 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284) - *(_DWORD *)(a1 + 64);
    if (v6 < 10001)
      goto LABEL_25;
    v7 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        v13 = *(unsigned __int8 *)(a2 + 190);
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        v20 = 67109891;
        v21 = v13;
        v22 = 1024;
        v23 = v6;
        v24 = 2160;
        v25 = 1752392040;
        v26 = 2085;
        v27 = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetNextAnnounceProbeTime: ProbeCount %d Next in %d %{sensitive, mask.hash}s", (uint8_t *)&v20, 0x22u);
      }
    }
    else
    {
      v7 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
    }
    v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:
        v15 = *(_DWORD *)(a1 + 12672);
        v16 = *(_DWORD *)(a1 + 64);
        v20 = 67109632;
        v21 = v15;
        v22 = 1024;
        v23 = v16;
        v24 = 1024;
        LODWORD(v25) = v15 - v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SetNextAnnounceProbeTime: m->SuppressProbes %d m->timenow %d diff %d", (uint8_t *)&v20, 0x14u);
      }
    }
    else
    {
      v14 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_24;
    }
LABEL_25:
    v17 = *(_DWORD *)(a1 + 96);
    v18 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (v17 - v18 >= 0)
    {
      *(_DWORD *)(a1 + 96) = v18;
      v17 = v18;
    }
    v19 = *(_DWORD *)(a1 + 64);
    if (v17 - v19 < 0)
      *(_DWORD *)(a1 + 96) = v19;
    return;
  }
  if (*(_BYTE *)(a2 + 191))
  {
    IsValidAnswer = ResourceRecordIsValidAnswer(a2);
    if (v5 == 1 || IsValidAnswer)
    {
      v11 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
      if (*(_DWORD *)(a1 + 100) - v11 >= 0)
        *(_DWORD *)(a1 + 100) = v11;
    }
  }
}

uint64_t GetRDLength(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  int v11;
  unsigned __int16 v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  __int16 v16;
  __int16 v17;
  int v18;
  int v19;
  unsigned __int8 *v20;
  __int16 v21;
  uint64_t v22;
  int v23;
  __int16 v24;
  unsigned __int16 v25;

  if (a2)
    v10 = *(_BYTE **)(a1 + 32);
  else
    v10 = 0;
  if (*(_WORD *)(a1 + 6) == 255)
  {
    return *(unsigned __int16 *)(a1 + 12);
  }
  else
  {
    v11 = *(unsigned __int16 *)(a1 + 4);
    v12 = 4;
    v13 = *(unsigned __int8 **)(a1 + 40);
    v14 = v13 + 4;
    switch(*(_WORD *)(a1 + 4))
    {
      case 1:
        return v12;
      case 2:
      case 5:
      case 0xC:
      case 0x27:
        return CompressedDomainNameLength(v14, v10);
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0x10:
      case 0x13:
      case 0x14:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1B:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x22:
      case 0x23:
      case 0x25:
      case 0x26:
      case 0x28:
      case 0x29:
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2D:
      case 0x2E:
      case 0x30:
      case 0x31:
        return *(unsigned __int16 *)(a1 + 12);
      case 6:
        v17 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(v17 + CompressedDomainNameLength(v13 + 260, v10) + 20);
      case 0xD:
        LOWORD(v18) = *v14 + v14[*v14 + 1];
        return (unsigned __int16)(v18 + 2);
      case 0xE:
      case 0x11:
        v16 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 260, v10) + v16);
      case 0xF:
      case 0x12:
      case 0x15:
      case 0x24:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 6, v10) + 2);
      case 0x1A:
        v19 = CompressedDomainNameLength(v13 + 6, v10);
        v18 = v19 + CompressedDomainNameLength(v13 + 262, v10);
        return (unsigned __int16)(v18 + 2);
      case 0x1C:
        return 16;
      case 0x21:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 10, v10) + 6);
      case 0x2F:
        v20 = v13 + 4;
        v21 = -255;
        if (v13 != (unsigned __int8 *)-260)
          goto LABEL_20;
        break;
      default:
        if (v11 == 65323)
          return v12;
        return *(unsigned __int16 *)(a1 + 12);
    }
LABEL_23:
    if (v20)
    {
      while (1)
      {
        v22 = *v20;
        if (v22 > 0x3F)
          break;
        if (!*v20)
        {
          v21 = (_WORD)v14 - (_WORD)v20 + 1;
          goto LABEL_30;
        }
        v20 += v22 + 1;
        if (v13 == (unsigned __int8 *)-260)
          goto LABEL_23;
LABEL_20:
        if (v20 >= v13 + 260 || !v20)
          goto LABEL_30;
      }
    }
    v21 = -255;
LABEL_30:
    v23 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
    v12 = *(_WORD *)(a1 + 12);
    if (a2)
      v24 = v21;
    else
      v24 = 0;
    v25 = v24 + v12;
    if (!v23)
      return v25;
  }
  return v12;
}

uint64_t ValidateRData(int a1, int a2, _BYTE *a3)
{
  uint64_t result;
  unint64_t v5;
  _BYTE *v6;
  unsigned __int16 v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unint64_t v10;
  int v11;
  BOOL v12;
  _BYTE *v14;
  unsigned __int16 v15;
  uint64_t v16;
  _BYTE *v17;
  unsigned __int16 v18;
  uint64_t v19;

  result = 1;
  switch(a1)
  {
    case 1:
      return a2 == 4;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 12:
      v5 = (unint64_t)&a3[a2 + 4];
      v6 = a3 + 4;
      if (v5)
        goto LABEL_3;
      while (2)
      {
        if (!v6)
          goto LABEL_11;
LABEL_7:
        v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_11:
          v7 = 257;
        }
        else
        {
          if (*v6)
          {
            v6 += v8 + 1;
            if (!v5)
              continue;
LABEL_3:
            v7 = 257;
            if ((unint64_t)v6 >= v5 || !v6)
              break;
            goto LABEL_7;
          }
          v7 = (_WORD)v6 - ((_WORD)a3 + 4) + 1;
        }
        break;
      }
      v11 = v7;
      v12 = v7 >= 0x101u;
      return !v12 && v11 == a2;
    case 13:
    case 14:
    case 16:
      if (!a2)
        return 0;
      v9 = a3 + 4;
      v10 = (unint64_t)&a3[a2 + 4];
      while ((unint64_t)v9 < v10)
        v9 += *v9 + 1;
      return v9 == (unsigned __int8 *)v10;
    case 15:
      v14 = a3 + 6;
      if (&a3[a2] != (_BYTE *)-4)
        goto LABEL_28;
      while (2)
      {
        if (!v14)
          goto LABEL_46;
LABEL_32:
        v16 = *v14;
        if (v16 > 0x3F)
        {
LABEL_46:
          v15 = 257;
        }
        else
        {
          if (*v14)
          {
            v14 += v16 + 1;
            if (&a3[a2] == (_BYTE *)-4)
              continue;
LABEL_28:
            v15 = 257;
            if (v14 >= &a3[a2 + 4] || !v14)
              break;
            goto LABEL_32;
          }
          v15 = (_WORD)v14 - ((_WORD)a3 + 6) + 1;
        }
        break;
      }
      v12 = v15 >= 0x101u;
      v11 = v15 + 2;
      return !v12 && v11 == a2;
    case 28:
      return a2 == 16;
    case 33:
      v17 = a3 + 10;
      if (&a3[a2] != (_BYTE *)-4)
        goto LABEL_38;
      break;
    default:
      return result;
  }
LABEL_41:
  if (v17)
  {
    while (1)
    {
      v19 = *v17;
      if (v19 > 0x3F)
        break;
      if (!*v17)
      {
        v18 = (_WORD)v17 - ((_WORD)a3 + 10) + 1;
        goto LABEL_51;
      }
      v17 += v19 + 1;
      if (&a3[a2] == (_BYTE *)-4)
        goto LABEL_41;
LABEL_38:
      v18 = 257;
      if (v17 >= &a3[a2 + 4] || !v17)
        goto LABEL_51;
    }
  }
  v18 = 257;
LABEL_51:
  v12 = v18 >= 0x101u;
  v11 = v18 + 6;
  return !v12 && v11 == a2;
}

unint64_t DomainNameHashValue(unint64_t result)
{
  int v1;
  unint64_t v2;
  unsigned __int8 *i;
  int v4;
  unsigned int v5;
  int v6;
  unint64_t v7;
  int v8;

  v1 = *(unsigned __int8 *)result;
  if (!*(_BYTE *)result)
    return 0;
  v2 = result;
  LODWORD(result) = 0;
  for (i = (unsigned __int8 *)(v2 + 2); ; i += 2)
  {
    v4 = *(i - 1);
    v5 = v1 - 65;
    v6 = v1 << 8;
    if (v5 < 0x1A)
      v6 += 0x2000;
    if (!*(i - 1))
      break;
    if ((v4 - 65) < 0x1A)
      v4 += 32;
    HIDWORD(v7) = (v4 | v6) + result;
    LODWORD(v7) = HIDWORD(v7);
    result = (v7 >> 29);
    v8 = *i;
    v1 = v8;
    if (!v8)
      return result;
  }
  return (v6 + result);
}

unint64_t RDataHashValue(uint64_t a1)
{
  unint64_t result;
  int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  _BYTE *v12;
  unsigned __int16 v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  int32x4_t v19;

  result = 0;
  v3 = *(unsigned __int16 *)(a1 + 12);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = v4 + 4;
  switch(*(_WORD *)(a1 + 4))
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      v6 = v4 + 4;
      return DomainNameHashValue(v6);
    case 6:
      v19 = *(int32x4_t *)(v4 + 516);
      v9 = *(_DWORD *)(v4 + 532);
      v10 = DomainNameHashValue(v4 + 4);
      return vaddvq_s32(v19) + v9 + DomainNameHashValue(v4 + 260) + v10;
    case 0xE:
    case 0x11:
      v7 = DomainNameHashValue(v4 + 4);
      v8 = v4 + 260;
      return DomainNameHashValue(v8) + v7;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      v6 = v4 + 6;
      return DomainNameHashValue(v6);
    case 0x1A:
      v7 = DomainNameHashValue(v4 + 6);
      v8 = v4 + 262;
      return DomainNameHashValue(v8) + v7;
    case 0x21:
      v6 = v4 + 10;
      return DomainNameHashValue(v6);
    case 0x29:
      return result;
    case 0x2F:
      v11 = v4 + 260;
      v12 = (_BYTE *)(v4 + 4);
      if (v4 != -260)
        goto LABEL_11;
      break;
    default:
      goto LABEL_22;
  }
LABEL_14:
  if (v12)
  {
    while (1)
    {
      v14 = *v12;
      if (v14 > 0x3F)
        break;
      if (!*v12)
      {
        v13 = (_WORD)v12 - v5 + 1;
        goto LABEL_21;
      }
      v12 += v14 + 1;
      if (!v11)
        goto LABEL_14;
LABEL_11:
      v13 = 257;
      if ((unint64_t)v12 >= v11 || !v12)
        goto LABEL_21;
    }
  }
  v13 = 257;
LABEL_21:
  result = DomainNameHashValue(v5);
  v5 += v13;
  v3 -= v13;
LABEL_22:
  if (v3 < 2)
  {
    v18 = 0;
  }
  else
  {
    v15 = 0;
    do
    {
      HIDWORD(v16) = result + (bswap32(*(unsigned __int16 *)(v5 + v15)) >> 16);
      LODWORD(v16) = HIDWORD(v16);
      result = (v16 >> 29);
      v17 = v15 + 3;
      v15 += 2;
    }
    while (v17 < v3);
    v18 = v3 & 0xFFFFFFFE;
  }
  if ((int)v18 < v3)
    return result + (*(unsigned __int8 *)(v5 + v18) << 8);
  return result;
}

void SetTargetToHostName(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  unsigned int v5;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  NSObject *v10;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unsigned __int16 v20;
  char v21;
  char *ServiceTarget;
  NSObject *v23;
  char *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  char *v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  __int16 v38;
  _BYTE v39[14];
  __int16 v40;
  uint64_t v41;

  v4 = 0;
  v5 = *(unsigned __int16 *)(a2 + 12);
  if (v5 > 0x20)
  {
    switch(v5)
    {
      case '!':
        v4 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 10);
        break;
      case '$':
LABEL_7:
        v4 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 6);
        break;
      case '\'':
LABEL_13:
        v4 = (_BYTE *)(*(_QWORD *)(a2 + 48) + 4);
        break;
    }
  }
  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v5 == 2 || v5 == 5)
          goto LABEL_13;
        break;
    }
  }
  v7 = *(_QWORD *)(a2 + 32);
  if (v7 == -2)
  {
    v9 = "\tlocalhost";
  }
  else
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2
      || AWDLInterfaceID && AWDLInterfaceID == v7
      || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v7)
    {
      v8 = 10664;
    }
    else
    {
      v8 = 10408;
    }
    v9 = (char *)(a1 + v8);
  }
  if (!v4)
  {
    v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_33:
        v36 = 136446210;
        v37 = (uint64_t)DNSTypeName(v5);
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SetTargetToHostName: Don't know how to set the target of rrtype %{public}s", (uint8_t *)&v36, 0xCu);
      }
    }
    else
    {
      v10 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_33;
    }
  }
  if (!*(_BYTE *)(a2 + 122) && (*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4 && !IsLocalDomain((_BYTE *)(a2 + 652)))
  {
    if (*(_BYTE *)(a2 + 120))
      *(_BYTE *)(a2 + 120) = 2;
    ServiceTarget = (char *)GetServiceTarget(a1, a2);
    if (ServiceTarget)
    {
      v9 = ServiceTarget;
      if (*ServiceTarget)
      {
        v23 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            goto LABEL_37;
          v33 = v9;
          if (v9 == (char *)-256)
          {
LABEL_81:
            while (v33)
            {
              v34 = *v33;
              if (v34 > 0x3F)
                break;
              if (!*v33)
              {
                v35 = (unsigned __int16)((_WORD)v33 - (_WORD)v9 + 1);
                goto LABEL_90;
              }
              v33 += v34 + 1;
              if (v9 != (char *)-256)
                goto LABEL_80;
            }
          }
          else
          {
LABEL_80:
            if (v33 < v9 + 256)
              goto LABEL_81;
          }
          v35 = 257;
        }
        else
        {
          v23 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_37;
          v24 = v9;
          if (v9 == (char *)-256)
          {
LABEL_64:
            while (v24)
            {
              v25 = *v24;
              if (v25 > 0x3F)
                break;
              if (!*v24)
              {
                v35 = (unsigned __int16)((_WORD)v24 - (_WORD)v9 + 1);
                goto LABEL_90;
              }
              v24 += v25 + 1;
              if (v9 != (char *)-256)
                goto LABEL_63;
            }
          }
          else
          {
LABEL_63:
            if (v24 < v9 + 256)
              goto LABEL_64;
          }
          v35 = 257;
        }
LABEL_90:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        v36 = 141558787;
        v37 = 1752392040;
        v38 = 1040;
        *(_DWORD *)v39 = v35;
        *(_WORD *)&v39[4] = 2101;
        *(_QWORD *)&v39[6] = v9;
        v40 = 2082;
        v41 = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "SetUnicastTargetToHostName target %{sensitive, mask.hash, mdnsresponder:domain_name}.*P for resource record %{public}s", (uint8_t *)&v36, 0x26u);
        goto LABEL_37;
      }
    }
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_74:
        v32 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v32);
        v36 = 141558275;
        v37 = 1752392040;
        v38 = 2085;
        *(_QWORD *)v39 = v32;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "SetUnicastTargetToHostName No target for %{sensitive, mask.hash}s", (uint8_t *)&v36, 0x16u);
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_74;
    }
    *(_DWORD *)(a2 + 344) = 8;
    if (v4)
      *v4 = 0;
    SetNewRData(a2 + 8, 0, 0, v27, v28, v29, v30, v31);
    return;
  }
LABEL_37:
  if (v4)
  {
    SameDomainNameBytes(v4, v9);
    if (!SameDomainNameBytes(v4, v9))
    {
      v18 = v9;
      if (v9 == (char *)-256)
      {
LABEL_41:
        while (v18)
        {
          v19 = *v18;
          if (v19 > 0x3F)
            break;
          if (!*v18)
          {
            v20 = (_WORD)v18 - (_WORD)v9 + 1;
            if (v20 > 0x100u)
              break;
            memcpy(v4, v9, v20);
            goto LABEL_50;
          }
          v18 += v19 + 1;
          if (v9 != (char *)-256)
            goto LABEL_40;
        }
      }
      else
      {
LABEL_40:
        if (v18 < v9 + 256)
          goto LABEL_41;
      }
      *v4 = 0;
LABEL_50:
      SetNewRData(a2 + 8, 0, 0, v13, v14, v15, v16, v17);
      if (*(_BYTE *)(a2 + 8) == 2)
        v21 = 3;
      else
        v21 = 0;
      *(_BYTE *)(a2 + 190) = v21;
      *(_WORD *)(a2 + 191) = 4;
      *(_BYTE *)(a2 + 189) = 0;
      InitializeLastAPTime((_DWORD *)a1, a2);
    }
  }
}

unint64_t SetNewRData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t result;

  if (a2)
  {
    *(_QWORD *)(a1 + 40) = a2;
    *(_WORD *)(a1 + 12) = a3;
  }
  *(_WORD *)(a1 + 12) = GetRDLength(a1, 0, a3, a4, a5, a6, a7, a8);
  *(_WORD *)(a1 + 14) = GetRDLength(a1, 1, v9, v10, v11, v12, v13, v14);
  result = RDataHashValue(a1);
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

uint64_t CompressedDomainNameLength(unsigned __int8 *a1, _BYTE *a2)
{
  _BYTE *v3;
  unsigned __int8 *v4;
  unsigned int v5;

  if (a2)
  {
    if (*a2)
      v3 = a2;
    else
      v3 = 0;
  }
  else
  {
    v3 = 0;
  }
  v4 = a1;
  while (1)
  {
    v5 = *v4;
    if (!*v4)
      return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
    if (v5 > 0x3F)
      return 257;
    if (v3)
      break;
LABEL_12:
    v4 += v5 + 1;
    if (v4 - a1 > 255)
      return 257;
  }
  if (!SameDomainNameBytes(v4, v3))
  {
    v5 = *v4;
    goto LABEL_12;
  }
  return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 2);
}

void AcknowledgeRecord(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;

  if (*(_QWORD *)(a2 + 104))
  {
    *(_BYTE *)(a2 + 188) = 1;
    v4 = *(_DWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 52) + 1;
    *(_DWORD *)(a1 + 52) = v5;
    mDNS_VerifyLockState("Drop Lock", 0, v4, v5, (uint64_t)"AcknowledgeRecord", 1373);
    (*(void (**)(uint64_t, uint64_t, _QWORD))(a2 + 104))(a1, a2, 0);
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AcknowledgeRecord", 1375);
    --*(_DWORD *)(a1 + 52);
  }
}

uint64_t mDNS_StartBrowse_internal(uint64_t a1, unsigned __int8 *a2, _BYTE *a3, uint64_t a4, int a5, char a6, char a7, uint64_t a8, uint64_t a9)
{
  unsigned __int8 *v10;
  int v11;
  unint64_t v12;
  NSObject *v13;
  unsigned __int8 *j;
  uint64_t v15;
  unsigned __int8 *i;
  uint64_t v18;
  int v19;
  _DWORD v20[2];
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unsigned __int8 *v26;
  __int16 v27;
  int v28;

  *(_QWORD *)(a1 + 136) = a4;
  *(_DWORD *)(a1 + 324) = a5;
  *(_DWORD *)(a1 + 342) = 65548;
  *(_WORD *)(a1 + 632) = 1;
  *(_BYTE *)(a1 + 634) = a6;
  *(_BYTE *)(a1 + 635) = (a5 & 0x1000) != 0;
  *(_WORD *)(a1 + 636) = 0;
  *(_BYTE *)(a1 + 641) = 0;
  *(_BYTE *)(a1 + 639) = 0;
  *(_BYTE *)(a1 + 640) = a7;
  *(_BYTE *)(a1 + 652) = 0;
  *(_QWORD *)(a1 + 152) = a8;
  v10 = (unsigned __int8 *)(a1 + 376);
  *(_QWORD *)(a1 + 176) = a9;
  if (!ConstructServiceName((_BYTE *)(a1 + 376), 0, a2, a3))
    return 4294901756;
  v11 = *(_DWORD *)(a1 + 252);
  if (v11)
  {
    v12 = a1 + 632;
    v13 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        for (i = v10; ; i += v18 + 1)
        {
          if ((unint64_t)i >= v12 || !i || (v18 = *i, v18 > 0x3F))
          {
            v19 = 257;
            goto LABEL_24;
          }
          if (!*i)
            break;
        }
        v19 = (unsigned __int16)((_WORD)i - (_WORD)v10 + 1);
        goto LABEL_24;
      }
    }
    else
    {
      v13 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (j = v10; ; j += v15 + 1)
        {
          if ((unint64_t)j >= v12 || !j || (v15 = *j, v15 > 0x3F))
          {
            v19 = 257;
            goto LABEL_24;
          }
          if (!*j)
            break;
        }
        v19 = (unsigned __int16)((_WORD)j - (_WORD)v10 + 1);
LABEL_24:
        v20[0] = 67110147;
        v20[1] = v11;
        v21 = 2160;
        v22 = 1752392040;
        v23 = 1040;
        v24 = v19;
        v25 = 2101;
        v26 = v10;
        v27 = 1024;
        v28 = mDNS_DomainNameFNV1aHash(v10);
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse -> SubBrowser START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x)", (uint8_t *)v20, 0x28u);
      }
    }
  }
  return mDNS_StartQuery_internal((uint64_t)mDNSStorage, a1);
}

_BYTE *ConstructServiceName(_BYTE *a1, const char *a2, unsigned __int8 *a3, _BYTE *a4)
{
  unsigned __int8 *v5;
  _BYTE *v7;
  void *v8;
  NSObject **v9;
  const char *v10;
  unsigned int v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  NSObject *v22;
  int v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v28;
  _BYTE *v29;
  unsigned __int16 v30;
  uint64_t v31;
  int v32;
  _BYTE *v33;
  unsigned __int16 v34;
  uint64_t v35;
  int v36;
  unsigned __int8 *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  NSObject *v43;
  unsigned __int8 *v44;
  unsigned __int16 v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int8 *v50;
  int v51;
  uint64_t v52;
  _BYTE *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  int v59;
  unsigned __int8 *v60;
  int v61;
  uint64_t v62;
  unsigned __int8 *v64;
  uint64_t v65;
  _BYTE *v66;
  int v67;
  uint64_t v68;
  _BYTE *v69;
  uint64_t v70;
  _BYTE *result;
  uint8_t buf[4];
  uint64_t v73;
  __int16 v74;
  _BYTE v75[14];
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  _BYTE v79[14];
  __int16 v80;
  uint64_t v81;
  __int16 v82;
  _BYTE v83[14];
  __int16 v84;
  _BYTE *v85;

  v5 = a3;
  v7 = &unk_100164000;
  v8 = &unk_100164000;
  v9 = (NSObject **)&unk_100164000;
  if (a2)
  {
    v10 = a2;
    v11 = *(unsigned __int8 *)a2;
    if (*a2)
    {
      if (v11 > 0x3F)
      {
        v12 = "Service instance name too long";
        goto LABEL_141;
      }
      v20 = 0;
      v21 = v11 + 1;
      do
      {
        a1[v20] = a2[v20];
        ++v20;
      }
      while (v21 != (_DWORD)v20);
      v19 = (uint64_t)&a1[v20];
      goto LABEL_13;
    }
    goto LABEL_9;
  }
  v13 = *a3;
  if ((v13 - 1) <= 0x3E)
  {
    v14 = a3[v13 + 1];
    if ((v14 - 1) <= 0x3E)
    {
      v15 = &a3[v13 + 1 + v14];
      v18 = v15[1];
      v16 = v15 + 1;
      v17 = v18;
      if (v18 - 1 <= 0x3E && !v16[v17 + 1])
      {
        v52 = 0;
        do
        {
          a1[v52] = a3[v52];
          ++v52;
        }
        while ((_DWORD)v13 + 1 != (_DWORD)v52);
        v53 = &a1[v52];
        v53[4] = 98;
        *(_DWORD *)v53 = 1970495236;
        v54 = SameDomainNameBytes(a3, "\t_services\a_dns-sd\x04_udp");
        v55 = -5;
        if (!v54)
          v55 = 0;
        v19 = (uint64_t)&a1[v13 + 6 + v55];
        v10 = "";
        v5 += v13 + 1;
        goto LABEL_13;
      }
    }
LABEL_9:
    v10 = "";
    v19 = (uint64_t)a1;
LABEL_13:
    LODWORD(v13) = *v5;
    goto LABEL_15;
  }
  v10 = "";
  v19 = (uint64_t)a1;
LABEL_15:
  if ((v13 - 17) <= 0xFFFFFFF0)
  {
    v22 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v24 = *(unsigned __int8 *)v10 + 1;
        v25 = v5;
        if (v5 == (unsigned __int8 *)-256)
        {
LABEL_24:
          while (v25)
          {
            v26 = *v25;
            if (v26 > 0x3F)
              break;
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_40;
            }
            v25 += v26 + 1;
            if (v5 != (unsigned __int8 *)-256)
              goto LABEL_23;
          }
        }
        else
        {
LABEL_23:
          if (v25 < v5 + 256)
            goto LABEL_24;
        }
        LOWORD(v25) = 257;
LABEL_40:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          v29 = a4;
          if (a4 == (_BYTE *)-256)
            goto LABEL_45;
LABEL_42:
          v30 = 257;
          if (v29 < a4 + 256 && v29)
          {
            while (1)
            {
              v31 = *v29;
              if (v31 > 0x3F)
              {
LABEL_63:
                v30 = 257;
                goto LABEL_66;
              }
              if (!*v29)
                break;
              v29 += v31 + 1;
              if (a4 != (_BYTE *)-256)
                goto LABEL_42;
LABEL_45:
              if (!v29)
                goto LABEL_63;
            }
            v30 = (_WORD)v29 - (_WORD)a4 + 1;
          }
LABEL_66:
          v32 = v30;
        }
        else
        {
          v32 = 0;
        }
        goto LABEL_69;
      }
    }
    else
    {
      v22 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v24 = *(unsigned __int8 *)v10 + 1;
        v25 = v5;
        if (v5 == (unsigned __int8 *)-256)
        {
LABEL_32:
          while (v25)
          {
            v28 = *v25;
            if (v28 > 0x3F)
              break;
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_52;
            }
            v25 += v28 + 1;
            if (v5 != (unsigned __int8 *)-256)
              goto LABEL_31;
          }
        }
        else
        {
LABEL_31:
          if (v25 < v5 + 256)
            goto LABEL_32;
        }
        LOWORD(v25) = 257;
LABEL_52:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          v33 = a4;
          if (a4 == (_BYTE *)-256)
            goto LABEL_57;
LABEL_54:
          v34 = 257;
          if (v33 < a4 + 256 && v33)
          {
            while (1)
            {
              v35 = *v33;
              if (v35 > 0x3F)
              {
LABEL_64:
                v34 = 257;
                goto LABEL_68;
              }
              if (!*v33)
                break;
              v33 += v35 + 1;
              if (a4 != (_BYTE *)-256)
                goto LABEL_54;
LABEL_57:
              if (!v33)
                goto LABEL_64;
            }
            v34 = (_WORD)v33 - (_WORD)a4 + 1;
          }
LABEL_68:
          v32 = v34;
        }
        else
        {
          v32 = 0;
        }
LABEL_69:
        *(_DWORD *)buf = 141560067;
        v73 = 1752392040;
        v74 = 1040;
        *(_DWORD *)v75 = v24;
        *(_WORD *)&v75[4] = 2101;
        *(_QWORD *)&v75[6] = v10;
        v76 = 2160;
        v77 = 1752392040;
        v78 = 1040;
        *(_DWORD *)v79 = (_DWORD)v25;
        *(_WORD *)&v79[4] = 2101;
        *(_QWORD *)&v79[6] = v5;
        v80 = 2160;
        v81 = 1752392040;
        v82 = 1040;
        *(_DWORD *)v83 = v32;
        *(_WORD *)&v83[4] = 2101;
        *(_QWORD *)&v83[6] = a4;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Bad service type in %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P Application protocol name must be underscore plus 1-15 characters. See <http://www.dns-sd.org/ServiceTypes.html>", buf, 0x50u);
      }
    }
    if ((v13 - 64) < 0xFFFFFFC2
      || v13 >= 0x11 && !SameDomainNameBytes(a4, "\x05local"))
    {
      return 0;
    }
  }
  if (v5[1] != 95)
  {
    v12 = "Application protocol name must begin with underscore";
    goto LABEL_141;
  }
  v36 = 0;
  v37 = v5 + 256;
  v38 = v13;
  v39 = (v13 + 1);
  v40 = 2;
  do
  {
    v41 = v5[v40];
    if ((v41 - 48) < 0xA || (v41 & 0xFFFFFFDF) - 65 < 0x1A)
      goto LABEL_117;
    if (v41 != 45)
    {
      if (v40 >= v38 || v40 < 3 || v41 != 95)
      {
LABEL_127:
        v7 = (_BYTE *)&unk_100164000;
        v8 = &unk_100164000;
        v9 = (NSObject **)&unk_100164000;
        v12 = "Application protocol name must contain only letters, digits, and hyphens";
        goto LABEL_141;
      }
      if (v36)
        goto LABEL_116;
      v43 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          v47 = v5;
          if (v5 == (unsigned __int8 *)-256)
            goto LABEL_105;
LABEL_102:
          v45 = 257;
          if (v47 < v37 && v47)
          {
            while (1)
            {
              v48 = *v47;
              if (v48 > 0x3F)
              {
LABEL_111:
                v45 = 257;
                goto LABEL_115;
              }
              if (!*v47)
                break;
              v47 += v48 + 1;
              if (v5 != (unsigned __int8 *)-256)
                goto LABEL_102;
LABEL_105:
              if (!v47)
                goto LABEL_111;
            }
            v45 = (_WORD)v47 - (_WORD)v5 + 1;
          }
          goto LABEL_115;
        }
      }
      else
      {
        v43 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v44 = v5;
          if (v5 == (unsigned __int8 *)-256)
            goto LABEL_95;
LABEL_92:
          v45 = 257;
          if (v44 < v37 && v44)
          {
            while (1)
            {
              v46 = *v44;
              if (v46 > 0x3F)
              {
LABEL_110:
                v45 = 257;
                goto LABEL_115;
              }
              if (!*v44)
                break;
              v44 += v46 + 1;
              if (v5 != (unsigned __int8 *)-256)
                goto LABEL_92;
LABEL_95:
              if (!v44)
                goto LABEL_110;
            }
            v45 = (_WORD)v44 - (_WORD)v5 + 1;
          }
LABEL_115:
          *(_DWORD *)buf = 141558531;
          v73 = 1752392040;
          v74 = 1040;
          *(_DWORD *)v75 = v45;
          *(_WORD *)&v75[4] = 2101;
          *(_QWORD *)&v75[6] = v5;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "ConstructServiceName: Service type with non-leading underscore %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
        }
      }
LABEL_116:
      v36 = 1;
      goto LABEL_117;
    }
    if (v40 < 3 || v40 >= v38)
      goto LABEL_127;
LABEL_117:
    ++v40;
  }
  while (v40 != v39);
  v49 = 0;
  do
  {
    *(_BYTE *)(v19 + v49) = v5[v49];
    ++v49;
  }
  while ((_DWORD)v39 != (_DWORD)v49);
  v8 = &unk_100164000;
  v9 = (NSObject **)&unk_100164000;
  if (v5[v49] != 4)
  {
    v12 = "Transport protocol name must be _udp or _tcp";
    v7 = (_BYTE *)&unk_100164000;
    goto LABEL_141;
  }
  v50 = &v5[v49];
  v7 = &unk_100164000;
  if (v5[v49 + 1] != 95)
    goto LABEL_140;
  v51 = v50[2] & 0xDF;
  if (v51 == 84)
  {
    if ((v50[3] & 0xDF) != 0x43)
      goto LABEL_140;
  }
  else if (v51 != 85 || (v50[3] & 0xDF) != 0x44)
  {
LABEL_140:
    v12 = "Transport protocol name must be _udp or _tcp";
    goto LABEL_141;
  }
  if ((v50[4] & 0xDF) != 0x50)
    goto LABEL_140;
  v56 = 0;
  do
  {
    *(_BYTE *)(v19 + v56 + v49) = v5[v56 + v49];
    ++v56;
  }
  while ((_DWORD)v56 != 5);
  if (v5[v49 + v56])
  {
    v12 = "Service type must have only two labels";
    goto LABEL_141;
  }
  *(_BYTE *)(v19 + v49 + v56) = 0;
  if (!*a4)
  {
    v12 = "Service domain must be non-empty";
    goto LABEL_141;
  }
  if (SameDomainNameBytes(a4, "\x05local\x04arpa"))
  {
    v12 = "Illegal domain \"local.arpa.\" Use \"local.\" (or empty string)";
    goto LABEL_141;
  }
  result = AppendDomainName(a1, a4);
  if (result)
    return result;
  v12 = "Service domain too long";
LABEL_141:
  v57 = *((_QWORD *)v8 + 295);
  if (v7[2416] != 1 || v57 == v9[296])
  {
    if (!os_log_type_enabled(*((os_log_t *)v8 + 295), OS_LOG_TYPE_DEFAULT))
      return 0;
    v59 = *(unsigned __int8 *)v10 + 1;
    if (v5)
    {
      v60 = v5;
      if (v5 == (unsigned __int8 *)-256)
        goto LABEL_152;
LABEL_149:
      v61 = 257;
      if (v60 < v5 + 256 && v60)
      {
        while (1)
        {
          v62 = *v60;
          if (v62 > 0x3F)
          {
LABEL_172:
            v61 = 257;
            goto LABEL_173;
          }
          if (!*v60)
            break;
          v60 += v62 + 1;
          if (v5 != (unsigned __int8 *)-256)
            goto LABEL_149;
LABEL_152:
          if (!v60)
            goto LABEL_172;
        }
        v61 = (unsigned __int16)((_WORD)v60 - (_WORD)v5 + 1);
        if (a4)
          goto LABEL_174;
      }
      else
      {
LABEL_173:
        if (a4)
        {
LABEL_174:
          v66 = a4;
          if (a4 == (_BYTE *)-256)
            goto LABEL_178;
LABEL_175:
          v67 = 257;
          if (v66 < a4 + 256 && v66)
          {
            while (1)
            {
              v68 = *v66;
              if (v68 > 0x3F)
              {
LABEL_194:
                v67 = 257;
                goto LABEL_203;
              }
              if (!*v66)
                break;
              v66 += v68 + 1;
              if (a4 != (_BYTE *)-256)
                goto LABEL_175;
LABEL_178:
              if (!v66)
                goto LABEL_194;
            }
            v67 = (unsigned __int16)((_WORD)v66 - (_WORD)a4 + 1);
          }
          goto LABEL_203;
        }
      }
    }
    else
    {
      v61 = 0;
      if (a4)
        goto LABEL_174;
    }
    v67 = 0;
    goto LABEL_203;
  }
  v57 = mDNSLogCategory_Default_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    return 0;
  v59 = *(unsigned __int8 *)v10 + 1;
  if (!v5)
  {
    v61 = 0;
    if (!a4)
      goto LABEL_199;
LABEL_185:
    v69 = a4;
    if (a4 == (_BYTE *)-256)
      goto LABEL_189;
LABEL_186:
    v67 = 257;
    if (v69 < a4 + 256 && v69)
    {
      while (1)
      {
        v70 = *v69;
        if (v70 > 0x3F)
        {
LABEL_195:
          v67 = 257;
          goto LABEL_203;
        }
        if (!*v69)
          break;
        v69 += v70 + 1;
        if (a4 != (_BYTE *)-256)
          goto LABEL_186;
LABEL_189:
        if (!v69)
          goto LABEL_195;
      }
      v67 = (unsigned __int16)((_WORD)v69 - (_WORD)a4 + 1);
    }
    goto LABEL_203;
  }
  v64 = v5;
  if (v5 == (unsigned __int8 *)-256)
    goto LABEL_163;
LABEL_160:
  v61 = 257;
  if (v64 < v5 + 256 && v64)
  {
    while (1)
    {
      v65 = *v64;
      if (v65 > 0x3F)
      {
LABEL_183:
        v61 = 257;
        goto LABEL_184;
      }
      if (!*v64)
        break;
      v64 += v65 + 1;
      if (v5 != (unsigned __int8 *)-256)
        goto LABEL_160;
LABEL_163:
      if (!v64)
        goto LABEL_183;
    }
    v61 = (unsigned __int16)((_WORD)v64 - (_WORD)v5 + 1);
    if (!a4)
      goto LABEL_199;
    goto LABEL_185;
  }
LABEL_184:
  if (a4)
    goto LABEL_185;
LABEL_199:
  v67 = 0;
LABEL_203:
  *(_DWORD *)buf = 136448515;
  v73 = (uint64_t)v12;
  v74 = 2160;
  *(_QWORD *)v75 = 1752392040;
  *(_WORD *)&v75[8] = 1040;
  *(_DWORD *)&v75[10] = v59;
  v76 = 2101;
  v77 = (uint64_t)v10;
  v78 = 2160;
  *(_QWORD *)v79 = 1752392040;
  *(_WORD *)&v79[8] = 1040;
  *(_DWORD *)&v79[10] = v61;
  v80 = 2101;
  v81 = (uint64_t)v5;
  v82 = 2160;
  *(_QWORD *)v83 = 1752392040;
  *(_WORD *)&v83[8] = 1040;
  *(_DWORD *)&v83[10] = v67;
  v84 = 2101;
  v85 = a4;
  _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "ConstructServiceName: %{public}s: %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x5Au);
  return 0;
}

_BYTE *AppendDomainName(_BYTE *a1, _BYTE *a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _BYTE *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;

  v2 = 257;
  v3 = a1;
  if (a1 == (_BYTE *)-256)
  {
LABEL_3:
    while (v3)
    {
      v4 = *v3;
      if (v4 > 0x3F)
        break;
      if (!*v3)
      {
        v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }
      v3 += v4 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if (v3 < a1 + 256)
      goto LABEL_3;
  }
  v5 = &a1[v2 - 1];
  v6 = *a2;
  if (*a2)
  {
    while (&v5[v6 + 1] <= a1 + 255)
    {
      v7 = 0;
      do
      {
        v8 = v7;
        v5[v7] = a2[v7];
        ++v7;
      }
      while (v8 < *a2);
      v5 += v7;
      *v5 = 0;
      a2 += v7;
      v6 = *a2;
      if (!*a2)
        return v5;
    }
    return 0;
  }
  return v5;
}

uint64_t mDNS_StartQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  unint64_t v10;
  NSObject **v11;
  int v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v27;
  uint64_t *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  BOOL v40;
  unsigned int v41;
  const char *v42;
  NSObject *v43;
  os_log_type_t v44;
  uint32_t v45;
  unsigned int v46;
  uint64_t v47;
  BOOL v48;
  int v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  BOOL v54;
  _BYTE *v55;
  NSObject *v57;
  _BYTE *v59;
  int v60;
  uint64_t v61;
  _BOOL4 v62;
  _BOOL8 v63;
  uint64_t DNSServiceManager;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  _BYTE *v73;
  uint64_t v74;
  int v75;
  int v76;
  char v77;
  NSObject *v78;
  NSObject *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t *v86;
  const __CFAllocator *v87;
  const char *v88;
  int v89;
  unsigned int v90;
  void *v91;
  int v92;
  int v93;
  uint64_t v94;
  BOOL v96;
  unsigned int v97;
  unsigned int v98;
  NSObject *v99;
  unsigned int v100;
  _BYTE *j;
  unsigned __int16 v102;
  uint64_t v103;
  int v104;
  unsigned int v105;
  NSObject *v106;
  NSObject **v107;
  int v108;
  _BYTE *nn;
  unsigned __int16 v110;
  uint64_t v111;
  _BYTE *i;
  uint64_t v113;
  uint64_t *v114;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v116;
  CFStringRef v117;
  CFStringRef v118;
  const __CFArray *v119;
  _BYTE *mm;
  uint64_t v121;
  int v122;
  const char *v123;
  _BOOL4 v124;
  NSObject *v125;
  int v126;
  unsigned int v127;
  _BYTE *m;
  unsigned __int16 v129;
  uint64_t v130;
  _BYTE *k;
  uint64_t v132;
  int v133;
  const char *v134;
  void *v135;
  uint64_t DNSService;
  uint64_t v137;
  const char *v138;
  _DWORD *v139;
  int v140;
  unsigned int v141;
  _BYTE *kk;
  unsigned __int16 v143;
  uint64_t v144;
  int v145;
  int v146;
  _BYTE *v147;
  _BYTE *v148;
  int v149;
  _BYTE *jj;
  uint64_t v151;
  unint64_t v152;
  int v153;
  NSObject **v154;
  unsigned int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  unsigned int v159;
  unsigned __int8 *v160;
  int v161;
  BOOL v162;
  char v163;
  NSObject *v164;
  unint64_t v165;
  NSObject **v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  _QWORD *v171;
  NSObject *v172;
  _DWORD *v173;
  unsigned int v174;
  _BYTE *ii;
  unsigned __int16 v176;
  uint64_t v177;
  _BYTE *n;
  unsigned __int16 v179;
  uint64_t v180;
  NSObject *v181;
  int v182;
  unsigned int v183;
  uint64_t v184;
  int v185;
  const char *v186;
  uint64_t v187;
  const char *v188;
  int v189;
  uint64_t *AuthInfoForName_internal;
  int Suppression;
  BOOL v192;
  char v193;
  char v194;
  int v195;
  NSObject *v196;
  int v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  _BOOL4 v204;
  BOOL v205;
  int v206;
  uint64_t v207;
  _BOOL4 v208;
  BOOL v209;
  int v210;
  unint64_t v211;
  uint64_t *v212;
  uint64_t *v213;
  uint64_t v214;
  uint64_t v215;
  char v216;
  int v217;
  int v218;
  int v219;
  int v220;
  BOOL v221;
  _QWORD *v222;
  _UNKNOWN **v223;
  void (*v224)(uint64_t);
  int v225;
  _QWORD *v226;
  BOOL v227;
  uint64_t *v228;
  _UNKNOWN **v229;
  void (*v230)(uint64_t *);
  uint64_t v231;
  uint64_t v232;
  int v233;
  _QWORD *v234;
  _QWORD *v235;
  _UNKNOWN **v236;
  void (*v237)(_QWORD *);
  int v238;
  uint64_t *v239;
  _QWORD *v240;
  _QWORD *v241;
  NSObject *v242;
  unsigned int v243;
  _BYTE *v244;
  int v245;
  uint64_t v246;
  _BYTE *v247;
  uint64_t v248;
  int v249;
  int v250;
  uint64_t v251;
  void *v252;
  void *v253;
  NSObject *v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  _BYTE *v258;
  int v259;
  uint64_t v260;
  int v261;
  int v262;
  NSObject *v263;
  _BYTE *v264;
  uint64_t v265;
  unsigned int v266;
  _BOOL4 v267;
  const char *v268;
  int v269;
  const char *v270;
  int v271;
  const char *v272;
  const void *v273;
  const void *v274;
  _DWORD *v275;
  unint64_t v276;
  _DWORD *v277;
  uint64_t v278;
  _OWORD __src[16];
  uint64_t v280;
  CFRange v281;

  v2 = 4294901749;
  if (!*(_DWORD *)(a1 + 240))
    return 4294901750;
  v5 = (_DWORD *)(a1 + 19904);
  v6 = (_BYTE *)(a2 + 376);
  v7 = (_BYTE *)(a2 + 632);
  v8 = (_BYTE *)(a2 + 376);
  if (a2 != -632)
  {
LABEL_3:
    if (v8 < v7)
      goto LABEL_4;
LABEL_21:
    v20 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "ValidateParameters: Attempt to start query with invalid qname %##s (%s)", v21, v22, v23, v24, v25, (int)v6);
    return 4294901747;
  }
  while (1)
  {
LABEL_4:
    if (!v8)
      goto LABEL_21;
    v9 = *v8;
    if (v9 > 0x3F)
      goto LABEL_21;
    if (!*v8)
      break;
    v8 += v9 + 1;
    if (a2 != -632)
      goto LABEL_3;
  }
  if ((unsigned __int16)((_WORD)v8 - (_WORD)v6 + 1) > 0x100u)
    goto LABEL_21;
  v10 = *(_QWORD *)(a2 + 136);
  v11 = (NSObject **)&unk_100164000;
  if (v10 != 0 && v10 < 0xFFFFFFFFFFFFFFFBLL || ((1 << (v10 + 5)) & 0x2D) == 0)
  {
    v27 = (_QWORD *)(a1 + 12656);
    while (1)
    {
      v27 = (_QWORD *)*v27;
      if (!v27)
        break;
      if (v27[444] == v10)
        goto LABEL_13;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      v30 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "ValidateParameters: Note: InterfaceID %d for question %##s (%s) not currently found in active interface list", v31, v32, v33, v34, v35, v10);
    }
  }
LABEL_13:
  v12 = *v6;
  if (*v6)
  {
    v13 = v6;
    do
    {
      v14 = v13;
      v15 = &v13[v12];
      v16 = v15[1];
      v13 = v15 + 1;
      v12 = v16;
    }
    while (v16);
    v17 = *v14;
    if (*v14)
    {
      v18 = v14 + 1;
      while (1)
      {
        v19 = *v18++;
        if (v19 < 0)
          break;
        if (!--v17)
          goto LABEL_38;
      }
      memset(__src, 0, sizeof(__src));
      v28 = (uint64_t *)__src;
      if (PerformNextPunycodeConversion(a2, (char *)__src))
      {
        while (v28 < &v280)
        {
          if (!v28)
            break;
          v29 = *(unsigned __int8 *)v28;
          if (v29 > 0x3F)
            break;
          if (!*(_BYTE *)v28)
          {
            if ((unsigned __int16)((_WORD)v28 - (unsigned __int16)__src + 1) <= 0x100u)
            {
              memcpy(v6, __src, (unsigned __int16)((_WORD)v28 - (unsigned __int16)__src + 1));
              goto LABEL_38;
            }
            break;
          }
          v28 = (uint64_t *)((char *)v28 + v29 + 1);
        }
        *v6 = 0;
      }
    }
  }
LABEL_38:
  if (*(_BYTE *)(a2 + 638)
    || *(_BYTE *)(a2 + 652)
    || ((v39 = *(_QWORD *)(a2 + 136) + 5, v39 <= 3) ? (v40 = v39 == 1) : (v40 = 1),
        v40 && !*(_BYTE *)(a2 + 634) && !IsLocalDomain(v6)))
  {
    v36 = mDNS_NewMessageID(a1);
  }
  else
  {
    v36 = 0;
  }
  *(_WORD *)(a2 + 340) = v36;
  if (DNSQuestionIsEligibleForMDNSAlternativeService(a2)
    && Querier_IsMDNSAlternativeServiceAvailableForQuestion(a2))
  {
    *(_WORD *)(a2 + 340) = mDNS_NewMessageID(a1);
  }
  if (DNSQuestionNeedsSensitiveLogging(a2))
  {
    v10 = ++gNumOfSensitiveLoggingEnabledQuestions;
    if ((gSensitiveLoggingEnabled & 1) == 0)
    {
      gSensitiveLoggingEnabled = 1;
      v38 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_62;
      }
      else
      {
        v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_62;
      }
      v46 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      LODWORD(__src[0]) = 67109120;
      DWORD1(__src[0]) = v46;
      v42 = "[Q%u] Question enables sensitive logging, all the sensitive level logs and the state dump of the question wi"
            "ll now be redacted.";
      v43 = v38;
      v44 = OS_LOG_TYPE_DEFAULT;
      v45 = 8;
      goto LABEL_61;
    }
    v37 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_58:
        v41 = bswap32(*(unsigned __int16 *)(a2 + 340));
        LODWORD(__src[0]) = 67109376;
        DWORD1(__src[0]) = HIWORD(v41);
        WORD4(__src[0]) = 1024;
        *(_DWORD *)((char *)__src + 10) = v10;
        v42 = "[Q%u] Question enables sensitive logging, redaction already in effect. - number of enabled questions: %d.";
        v43 = v37;
        v44 = OS_LOG_TYPE_DEBUG;
        v45 = 14;
LABEL_61:
        _os_log_impl((void *)&_mh_execute_header, v43, v44, v42, (uint8_t *)__src, v45);
      }
    }
    else
    {
      v37 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_58;
    }
  }
LABEL_62:
  v47 = *(_QWORD *)(a2 + 136);
  v48 = v47 == -2 || v47 == -3;
  v278 = *(_QWORD *)(a2 + 136);
  v50 = v48 || v47 == -5;
  if (!&_NEHelperTrackerGetAppInfo && !_os_feature_enabled_impl("symptomsd", "networking_transparency"))
    goto LABEL_77;
  if (!*(_WORD *)(a2 + 340) || *(_WORD *)(a2 + 344) != 1 || (unint64_t)(v278 + 5) <= 3 && v278 != -4)
    goto LABEL_77;
  v85 = *(unsigned __int16 *)(a2 + 342);
  if (v85 > 0x1C || ((1 << v85) & 0x10000022) == 0)
    goto LABEL_77;
  v86 = &s_head_0;
  while (1)
  {
    v86 = (uint64_t *)*v86;
    if (!v86)
      break;
    if (v86[1] == a2)
    {
      v87 = kCFAllocatorDefault;
LABEL_210:
      bzero(__src, 0x3F1uLL);
      ConvertDomainNameToCString_withescape(v6, (unsigned __int8 *)__src);
      v117 = CFStringCreateWithCString(v87, (const char *)__src, 0x8000100u);
      if (v117)
      {
        v118 = v117;
        v119 = (const __CFArray *)v86[5];
        v281.length = CFArrayGetCount(v119);
        v281.location = 0;
        if (CFArrayGetFirstIndexOfValue(v119, v281, v118) == -1)
          CFArrayInsertValueAtIndex((CFMutableArrayRef)v86[5], 0, v118);
        CFRelease(v118);
        v11 = (NSObject **)&unk_100164000;
      }
      goto LABEL_77;
    }
  }
  v114 = (uint64_t *)malloc_type_calloc(1uLL, 0x38uLL, 0xF1748037uLL);
  if (!v114)
    goto LABEL_583;
  v86 = v114;
  v87 = kCFAllocatorDefault;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v86[5] = (uint64_t)Mutable;
  if (Mutable)
  {
    v116 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v86[6] = (uint64_t)v116;
    if (v116)
    {
      *v86 = s_head_0;
      v86[1] = a2;
      s_head_0 = (uint64_t)v86;
      goto LABEL_210;
    }
    v273 = (const void *)v86[5];
    if (v273)
    {
      CFRelease(v273);
      v86[5] = 0;
    }
  }
  v274 = (const void *)v86[6];
  if (v274)
    CFRelease(v274);
  free(v86);
LABEL_77:
  v51 = 192;
  if (v50)
    v51 = 216;
  v52 = *(_QWORD *)(a1 + v51);
  v53 = v52 != 0;
  v54 = v52 == a2;
  v55 = &unk_100164000;
  while (!v54 && v52 != 0)
  {
    v52 = *(_QWORD *)(v52 + 8);
    v53 = v52 != 0;
    v54 = v52 == a2;
  }
  if (!v53)
  {
    v10 = *(unsigned __int8 *)(a2 + 632);
    v62 = Querier_QuestionBelongsToSelf(a2);
    v63 = IsLocalDomain(v6);
    if ((_DWORD)v10)
    {
      if (!v62 && !v63)
      {
        DNSServiceManager = Querier_GetDNSServiceManager(v63);
        if ((!DNSServiceManager || !_Querier_GetCustomPushService(DNSServiceManager, a2))
          && !*(_QWORD *)(a2 + 184)
          && dns_push_handle_question_start(a1, a2))
        {
          return 4294901756;
        }
      }
    }
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 212) = 334;
    v65 = DomainNameHashValue((unint64_t)v6);
    *(_DWORD *)(a2 + 200) = v65;
    if (*(_WORD *)(a2 + 340))
      v71 = 0;
    else
      v71 = CheckForSoonToExpireRecordsEx(a1, v6, v65, *(unsigned __int16 *)(a2 + 342), *(unsigned __int16 *)(a2 + 344));
    *(_DWORD *)(a2 + 204) = v71;
    *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 216) = 0;
    v75 = *(_DWORD *)(a1 + 132);
    *(_QWORD *)(a2 + 224) = 0;
    *(_DWORD *)(a2 + 220) = v75;
    v76 = *(_DWORD *)(a2 + 324);
    if ((v76 & 0x2000000) != 0)
    {
      v77 = 1;
    }
    else
    {
      if ((v76 & 0x4000000) == 0)
      {
        *(_BYTE *)(a2 + 351) = 0;
        goto LABEL_126;
      }
      v77 = 20;
    }
    *(_BYTE *)(a2 + 351) = v77;
LABEL_126:
    *(_BYTE *)(a2 + 359) = 0;
    *(_QWORD *)(a2 + 232) = 0;
    *(_BYTE *)(a2 + 355) = 0;
    *(_BYTE *)(a2 + 654) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    if ((v76 & 0x10000000) != 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        v79 = v11[295];
        DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        LogMsgWithLevel(v79, OS_LOG_TYPE_DEFAULT, "InitCommonState: Query for %##s (%s), PID[%d], EUID[%d], ServiceID[%d] is already set by client", v80, v81, v82, v83, v84, (int)v6);
      }
LABEL_152:
      v91 = *(void **)(a2 + 80);
      if (v91)
      {
        os_release(v91);
        *(_QWORD *)(a2 + 80) = 0;
      }
      *(_BYTE *)(a2 + 648) = 0;
      v92 = *(unsigned __int8 *)(a2 + 637);
      if (*(_BYTE *)(a2 + 637))
        v93 = *(_DWORD *)(a2 + 240);
      else
        v93 = 0;
      *(_DWORD *)(a2 + 240) = v93;
      *(_DWORD *)(a2 + 268) = 0;
      *(_QWORD *)(a2 + 260) = 0;
      v94 = *(_QWORD *)(a2 + 136);
      v96 = v94 == -5 || v94 == -3 || v94 == -2;
      if (v96 && !v92)
        goto LABEL_368;
      v97 = *(unsigned __int16 *)(a2 + 340);
      if (*(_WORD *)(a2 + 340))
      {
        if (v92 && !v93)
        {
          v98 = *(_DWORD *)(a1 + 64) + 30000;
          if (v98 <= 1)
            v98 = 1;
          *(_DWORD *)(a2 + 240) = v98;
          v99 = v11[295];
          if (gSensitiveLoggingEnabled != 1 || v99 == mDNSLogCategory_State)
          {
            if (os_log_type_enabled(v11[295], OS_LOG_TYPE_DEBUG))
            {
              v100 = __rev16(v97);
              for (i = v6; ; i += v113 + 1)
              {
                v102 = 257;
                if (i >= v7 || !i)
                  break;
                v113 = *i;
                if (v113 > 0x3F)
                {
                  v102 = 257;
                  goto LABEL_226;
                }
                if (!*i)
                {
                  v102 = (_WORD)i - (_WORD)v6 + 1;
                  goto LABEL_226;
                }
              }
              goto LABEL_226;
            }
          }
          else
          {
            v99 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
              v100 = __rev16(v97);
              for (j = v6; ; j += v103 + 1)
              {
                v102 = 257;
                if (j >= v7 || !j)
                  break;
                v103 = *j;
                if (v103 > 0x3F)
                {
                  v102 = 257;
                  break;
                }
                if (!*j)
                {
                  v102 = (_WORD)j - (_WORD)v6 + 1;
                  break;
                }
              }
LABEL_226:
              v122 = v102;
              v123 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              LODWORD(__src[0]) = 67110403;
              DWORD1(__src[0]) = v100;
              WORD4(__src[0]) = 2048;
              *(_QWORD *)((char *)__src + 10) = a2;
              WORD1(__src[1]) = 2160;
              *(_QWORD *)((char *)&__src[1] + 4) = 1752392040;
              WORD6(__src[1]) = 1040;
              *(_DWORD *)((char *)&__src[1] + 14) = v122;
              WORD1(__src[2]) = 2101;
              *(_QWORD *)((char *)&__src[2] + 4) = v6;
              WORD6(__src[2]) = 2082;
              *(_QWORD *)((char *)&__src[2] + 14) = v123;
              _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEBUG, "[Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x36u);
            }
          }
        }
        v124 = _Querier_ExcludeEncryptedDNSServices(a2);
        v2 = a2 + 360;
        if (!uuid_is_null((const unsigned __int8 *)(a2 + 360)) && v124)
        {
          uuid_clear((unsigned __int8 *)(a2 + 360));
          v125 = v11[295];
          if (gSensitiveLoggingEnabled != 1 || v125 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v11[295], OS_LOG_TYPE_DEFAULT))
              goto LABEL_251;
            v275 = v5;
            v126 = *(_DWORD *)(a2 + 252);
            v127 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (k = v6; ; k += v132 + 1)
            {
              v129 = 257;
              if (k >= v7 || !k)
                break;
              v132 = *k;
              if (v132 > 0x3F)
              {
                v129 = 257;
                break;
              }
              if (!*k)
              {
                v129 = (_WORD)k - (_WORD)v6 + 1;
                break;
              }
            }
          }
          else
          {
            v125 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_251;
            v275 = v5;
            v126 = *(_DWORD *)(a2 + 252);
            v127 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (m = v6; ; m += v130 + 1)
            {
              v129 = 257;
              if (m >= v7 || !m)
                break;
              v130 = *m;
              if (v130 > 0x3F)
              {
                v129 = 257;
                break;
              }
              if (!*m)
              {
                v129 = (_WORD)m - (_WORD)v6 + 1;
                break;
              }
            }
          }
          v133 = v129;
          v134 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LODWORD(__src[0]) = 67110403;
          DWORD1(__src[0]) = v126;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v127;
          HIWORD(__src[0]) = 2160;
          *(_QWORD *)&__src[1] = 1752392040;
          WORD4(__src[1]) = 1040;
          *(_DWORD *)((char *)&__src[1] + 10) = v133;
          HIWORD(__src[1]) = 2101;
          *(_QWORD *)&__src[2] = v6;
          WORD4(__src[2]) = 2082;
          *(_QWORD *)((char *)&__src[2] + 10) = v134;
          _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Cleared resolver UUID for question: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x32u);
          v5 = v275;
          v11 = (NSObject **)&unk_100164000;
          v55 = &unk_100164000;
        }
LABEL_251:
        v135 = *(void **)(a2 + 80);
        if (v135)
        {
          os_release(v135);
          *(_QWORD *)(a2 + 80) = 0;
        }
        DNSService = _Querier_GetDNSService(a2, v124);
        v10 = DNSService;
        if (v124)
        {
LABEL_254:
          *(_QWORD *)(a2 + 80) = v10;
          if (!v10)
            goto LABEL_268;
LABEL_320:
          v166 = v11;
          os_retain((void *)v10);
          v167 = *(_QWORD *)(a2 + 80);
          v86 = *(uint64_t **)(a2 + 144);
          if (!v167)
          {
LABEL_328:
            v11 = v166;
            v55 = &unk_100164000;
LABEL_329:
            v172 = v11[295];
            if (v55[2416] != 1 || v172 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v11[295], OS_LOG_TYPE_DEFAULT))
                goto LABEL_362;
              v173 = v5;
              v10 = *(unsigned int *)(a2 + 252);
              v174 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              for (n = v6; ; n += v180 + 1)
              {
                v179 = 257;
                if (n >= v7 || !n)
                  break;
                v180 = *n;
                if (v180 > 0x3F)
                {
                  v179 = 257;
                  break;
                }
                if (!*n)
                {
                  v179 = (_WORD)n - (_WORD)v6 + 1;
                  break;
                }
              }
              v185 = v179;
              v186 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              v187 = *(_QWORD *)(a2 + 80);
              v188 = ", DNSSEC";
              LODWORD(__src[0]) = 67110915;
              DWORD1(__src[0]) = v10;
              if (!v86)
                v188 = "";
            }
            else
            {
              v172 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                goto LABEL_362;
              v173 = v5;
              v10 = *(unsigned int *)(a2 + 252);
              v174 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              for (ii = v6; ; ii += v177 + 1)
              {
                v176 = 257;
                if (ii >= v7 || !ii)
                  break;
                v177 = *ii;
                if (v177 > 0x3F)
                {
                  v176 = 257;
                  break;
                }
                if (!*ii)
                {
                  v176 = (_WORD)ii - (_WORD)v6 + 1;
                  break;
                }
              }
              v185 = v176;
              v186 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              v187 = *(_QWORD *)(a2 + 80);
              v188 = ", DNSSEC";
              LODWORD(__src[0]) = 67110915;
              DWORD1(__src[0]) = v10;
              if (!v86)
                v188 = "";
            }
            WORD4(__src[0]) = 1024;
            *(_DWORD *)((char *)__src + 10) = v174;
            HIWORD(__src[0]) = 2160;
            *(_QWORD *)&__src[1] = 1752392040;
            WORD4(__src[1]) = 1040;
            *(_DWORD *)((char *)&__src[1] + 10) = v185;
            HIWORD(__src[1]) = 2101;
            *(_QWORD *)&__src[2] = v6;
            WORD4(__src[2]) = 2082;
            *(_QWORD *)((char *)&__src[2] + 10) = v186;
            WORD1(__src[3]) = 2082;
            *(_QWORD *)((char *)&__src[3] + 4) = v188;
            WORD6(__src[3]) = 2112;
            *(_QWORD *)((char *)&__src[3] + 14) = v187;
            _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Question for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s%{public}s) assigned DNS service -- %@", (uint8_t *)__src, 0x46u);
            v5 = v173;
            v11 = (NSObject **)&unk_100164000;
            goto LABEL_361;
          }
          v10 = *(_QWORD *)(v167 + 112);
          if (!v10)
          {
            v170 = malloc_type_malloc(8uLL, 0xA172743EuLL);
            if (!v170)
              goto LABEL_583;
            v171 = v170;
            *v170 = mach_continuous_time();
            *(_QWORD *)(v167 + 112) = v171;
            *(_QWORD *)(v167 + 120) = mdns_free_context_finalizer;
            goto LABEL_328;
          }
          v168 = mach_continuous_time();
          v169 = v168 - *(_QWORD *)v10;
          if (mdns_mach_ticks_per_second_s_once != -1)
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
          if (v169 / mdns_mach_ticks_per_second_s_ticks_per_second >= 0x3C)
          {
            *(_QWORD *)v10 = v168;
            goto LABEL_328;
          }
          v11 = v166;
          v181 = v166[295];
          if (gSensitiveLoggingEnabled != 1 || v181 == mDNSLogCategory_State)
          {
            v267 = os_log_type_enabled(v166[295], OS_LOG_TYPE_DEFAULT);
            v55 = (_BYTE *)&unk_100164000;
            if (!v267)
              goto LABEL_362;
            v182 = *(_DWORD *)(a2 + 252);
            v183 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v184 = *(_QWORD *)(a2 + 80);
            if (v184)
              v184 = *(_QWORD *)(v184 + 24);
          }
          else
          {
            v181 = mDNSLogCategory_Default_redacted;
            v55 = (_BYTE *)&unk_100164000;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_362;
            v182 = *(_DWORD *)(a2 + 252);
            v183 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v184 = *(_QWORD *)(a2 + 80);
            if (v184)
              v184 = *(_QWORD *)(v184 + 24);
          }
          LODWORD(__src[0]) = 67109632;
          DWORD1(__src[0]) = v182;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v183;
          HIWORD(__src[0]) = 2048;
          *(_QWORD *)&__src[1] = v184;
          _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Question assigned DNS service %llu", (uint8_t *)__src, 0x18u);
LABEL_362:
          if (!*(_DWORD *)(a2 + 240))
          {
LABEL_365:
            if ((unint64_t)(*(_QWORD *)(a2 + 136) + 5) > 3 || *(_QWORD *)(a2 + 136) == -4)
              SetNextQueryTime(a1, a2);
LABEL_368:
            if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(a2 + 152) == GetZoneData_QuestionCallback
              || *(_WORD *)(a2 + 342) == 6)
            {
              AuthInfoForName_internal = 0;
            }
            else
            {
              AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v6);
            }
            *(_QWORD *)(a2 + 32) = AuthInfoForName_internal;
            if (*(_WORD *)(a2 + 340))
              Suppression = DetermineUnicastQuerySuppression(a2, *(_QWORD *)(a2 + 80));
            else
              Suppression = 0;
            *(_BYTE *)(a2 + 354) = Suppression != 0;
            if (*(_BYTE *)(a2 + 644))
              v192 = Suppression == 6;
            else
              v192 = 0;
            v193 = v192;
            *(_BYTE *)(a2 + 645) = v193;
            *(_QWORD *)(a2 + 48) = 0;
            *(_QWORD *)(a2 + 64) = 0;
            *(_BYTE *)(a2 + 358) = 0;
            *(_WORD *)(a2 + 352) = 2;
            *(_DWORD *)(a2 + 256) = *(_DWORD *)(a1 + 64);
            if (*(_BYTE *)(a2 + 639))
              v194 = 3;
            else
              v194 = 0;
            *(_BYTE *)(a2 + 356) = v194;
            *(_QWORD *)(a2 + 144) = 0;
            v195 = *(_DWORD *)(a2 + 204);
            if (v195 && mDNS_LoggingEnabled)
            {
              v196 = v11[295];
              v197 = v195 - *(_DWORD *)(a1 + 64);
              DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              LogMsgWithLevel(v196, OS_LOG_TYPE_DEFAULT, "InitCommonState: Delaying answering for %d ticks while cache stabilizes for %##s (%s)", v198, v199, v200, v201, v202, v197);
            }
            *(_QWORD *)(a2 + 72) = 0;
            v203 = *(_QWORD *)(a2 + 96);
            if (v203)
            {
              mdns_client_invalidate(v203);
              os_release(*(void **)(a2 + 96));
              *(_QWORD *)(a2 + 96) = 0;
            }
            *(_DWORD *)(a2 + 300) = 0;
            *(_OWORD *)(a2 + 284) = 0u;
            *(_WORD *)(a2 + 336) = 0;
            *(_OWORD *)(a2 + 104) = 0u;
            *(_BYTE *)(a2 + 350) = 1;
            *(_QWORD *)(a2 + 272) = 0;
            *(_QWORD *)(a2 + 328) = 0;
            *(_DWORD *)(a2 + 346) = 0;
            v2 = *(_QWORD *)(a1 + 192);
            if (!v2 || v2 == a2)
            {
LABEL_429:
              v2 = 0;
              *(_QWORD *)(a2 + 40) = 0;
              v210 = 1;
              goto LABEL_430;
            }
            v204 = QuestionSendsMDNSQueriesViaUnicast(a2);
            v10 = a2 + 304;
            while (1)
            {
              if ((*(_WORD *)(v2 + 340) == 0) != (*(_WORD *)(a2 + 340) != 0)
                && *(_DWORD *)(v2 + 200) == *(_DWORD *)(a2 + 200)
                && *(_QWORD *)(v2 + 136) == *(_QWORD *)(a2 + 136)
                && *(unsigned __int16 *)(v2 + 342) == *(unsigned __int16 *)(a2 + 342)
                && *(unsigned __int16 *)(v2 + 344) == *(unsigned __int16 *)(a2 + 344))
              {
                if (*(_BYTE *)(v2 + 632))
                  v205 = *(unsigned __int16 *)(v2 + 340) == 0;
                else
                  v205 = 1;
                v206 = !v205;
                if (*v7)
                {
                  if ((((*(_WORD *)(a2 + 340) != 0) ^ v206) & 1) != 0)
                    goto LABEL_424;
                }
                else if ((v206 & 1) != 0)
                {
                  goto LABEL_424;
                }
                if (*(_QWORD *)(v2 + 32) && !*(_QWORD *)(a2 + 32))
                  goto LABEL_424;
                if ((*(_BYTE *)(v2 + 354) != 0) == (*(_BYTE *)(a2 + 354) == 0))
                  goto LABEL_424;
                if (*(unsigned __int8 *)(v2 + 351) != *(unsigned __int8 *)(a2 + 351))
                  goto LABEL_424;
                if (((*(_DWORD *)(a2 + 324) ^ *(_DWORD *)(v2 + 324)) & 0x100000) != 0)
                  goto LABEL_424;
                if (*(_QWORD *)(v2 + 80) != *(_QWORD *)(a2 + 80))
                  goto LABEL_424;
                if ((*(_BYTE *)(v2 + 655) != 0) == (*(_BYTE *)(a2 + 655) == 0))
                  goto LABEL_424;
                if (*(_BYTE *)(v2 + 655))
                {
                  v207 = *(_QWORD *)(v2 + 144);
                  if (!v207 || !*(_BYTE *)(v207 + 24))
                    goto LABEL_424;
                }
                if (!SameDomainNameBytes((_BYTE *)(v2 + 376), v6))
                  goto LABEL_424;
                v208 = QuestionSendsMDNSQueriesViaUnicast(v2);
                v55 = (_BYTE *)&unk_100164000;
                if (v204)
                {
                  if (!v208 || !mDNSSameAddress((int *)(a2 + 304), (_DWORD *)(v2 + 304)))
                    goto LABEL_424;
LABEL_423:
                  if ((*(_QWORD *)(v2 + 184) != 0) != (*(_QWORD *)(a2 + 184) != 0))
                    goto LABEL_424;
                  v210 = 0;
                  *(_QWORD *)(a2 + 40) = v2;
                  *(_QWORD *)(a2 + 32) = *(_QWORD *)(v2 + 32);
LABEL_430:
                  v211 = *(_QWORD *)(a2 + 136) + 5;
                  if (v211 > 3)
                  {
                    v213 = (uint64_t *)((char *)&xmmword_100158E84 + 4);
                    v212 = (uint64_t *)((char *)&xmmword_100158E84 + 12);
                  }
                  else
                  {
                    v212 = (&off_10013F860)[v211];
                    v213 = (uint64_t *)*(&off_10013F880 + v211);
                  }
                  v214 = *v212;
                  v215 = *v213;
                  if (*v213)
                  {
                    v216 = 0;
                    v217 = 0;
                    do
                    {
                      if (v214)
                      {
                        if (v217 || v215 == v214)
                        {
                          v218 = *(_DWORD *)(v215 + 204);
                          if (v218)
                          {
                            if (v216)
                              v219 = 1;
                            else
                              v219 = v210;
                            if (v219 != 1)
                            {
                              v217 = 1;
LABEL_451:
                              if (v2)
                                v221 = v215 == v2;
                              else
                                v221 = 0;
                              v216 = v221;
                              goto LABEL_457;
                            }
                            v220 = *(_DWORD *)(a2 + 204);
                            if (!v220)
                              v220 = dword_100158E08;
                            if (v218 - v220 > 0)
                              break;
                          }
                          v217 = 1;
                        }
                        else
                        {
                          v217 = 0;
                        }
                        if (!v216)
                          goto LABEL_451;
                        v216 = 1;
                      }
LABEL_457:
                      v213 = (uint64_t *)(v215 + 8);
                      v215 = *(_QWORD *)(v215 + 8);
                    }
                    while (v215);
                  }
                  *(_QWORD *)(a2 + 8) = v215;
                  *v213 = a2;
                  if (!v214 || v214 == v215)
                    *v212 = a2;
                  if (!*(_BYTE *)(a2 + 655))
                    goto LABEL_495;
                  v86 = *(uint64_t **)(a2 + 40);
                  v222 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
                  if (!v222)
                    goto LABEL_583;
                  v2 = (uint64_t)v222;
                  v223 = &_dnssec_obj_dns_question_member_kind;
                  v222[1] = &_dnssec_obj_dns_question_member_kind;
                  do
                  {
                    v224 = (void (*)(uint64_t))v223[2];
                    if (v224)
                      v224(v2);
                    v223 = (_UNKNOWN **)*v223;
                  }
                  while (v223);
                  v225 = *(_DWORD *)v2;
                  *(_QWORD *)(v2 + 16) = 0;
                  *(_BYTE *)(v2 + 24) = v86 == 0;
                  *(_DWORD *)v2 = v225 + 2;
                  ref_count_obj_release((_QWORD *)v2);
                  if (v86)
                  {
                    ++*(_DWORD *)v2;
                    v226 = *(_QWORD **)(a2 + 144);
                    if (v226)
                      ref_count_obj_release(v226);
                    *(_QWORD *)(a2 + 144) = v2;
                    goto LABEL_494;
                  }
                  v10 = *(_QWORD *)(a2 + 152);
                  v227 = *(_BYTE *)(a2 + 635) != 0;
                  LODWORD(__src[0]) = 0;
                  if (!v10)
                    goto LABEL_586;
                  v277 = v5;
                  v228 = (uint64_t *)malloc_type_calloc(1uLL, 0x48uLL, 0xF1748037uLL);
                  if (!v228)
                    goto LABEL_583;
                  v86 = v228;
                  v229 = &_dnssec_obj_context_kind;
                  v228[1] = (uint64_t)&_dnssec_obj_context_kind;
                  do
                  {
                    v230 = (void (*)(uint64_t *))v229[2];
                    if (v230)
                      v230(v86);
                    v229 = (_UNKNOWN **)*v229;
                  }
                  while (v229);
                  ++*(_DWORD *)v86;
                  v86[2] = a1;
                  v86[3] = a2;
                  v231 = *(_QWORD *)(a2 + 136);
                  v232 = v231 + 5;
                  if ((unint64_t)(v231 + 5) < 6 && ((0x2Du >> v232) & 1) != 0)
                    LODWORD(v231) = dword_1001007C0[v232];
                  *((_DWORD *)v86 + 8) = v231;
                  v86[5] = v10;
                  *((_BYTE *)v86 + 36) = v227;
                  *((_DWORD *)v86 + 12) = 0;
                  v10 = (unint64_t)dnssec_obj_domain_name_create_with_labels(v6, 1, (int *)__src);
                  if (!LODWORD(__src[0]))
                  {
                    v233 = *((_DWORD *)v86 + 12);
                    v234 = malloc_type_calloc(1uLL, 0x98uLL, 0xF1748037uLL);
                    if (v234)
                    {
                      v235 = v234;
                      v236 = &_dnssec_obj_validation_manager_kind;
                      v234[1] = &_dnssec_obj_validation_manager_kind;
                      do
                      {
                        v237 = (void (*)(_QWORD *))v236[2];
                        if (v237)
                          v237(v235);
                        v236 = (_UNKNOWN **)*v236;
                      }
                      while (v236);
                      ++*(_DWORD *)v235;
                      v235[2] = v10;
                      ++*(_DWORD *)v10;
                      v235[4] = 0;
                      v235[5] = 0;
                      *((_DWORD *)v235 + 12) = 0;
                      *((_DWORD *)v235 + 13) = -6718;
                      *((_DWORD *)v235 + 28) = 0;
                      v235[7] = 0;
                      v235[8] = 0;
                      v235[11] = 0;
                      v235[12] = 0;
                      v235[10] = 0;
                      v235[15] = 0;
                      v235[16] = 0;
                      *((_DWORD *)v235 + 34) = v233;
                      *((_DWORD *)v235 + 35) = 0;
                      *((_BYTE *)v235 + 144) = 0;
                      ++*(_DWORD *)v235;
                      LODWORD(__src[0]) = 0;
                      ref_count_obj_release(v235);
                      v238 = __src[0];
                      if (LODWORD(__src[0]))
                      {
                        v239 = 0;
                      }
                      else
                      {
                        v86[8] = (uint64_t)v235;
                        ++*(_DWORD *)v235;
                        ++*(_DWORD *)v86;
                        LODWORD(__src[0]) = 0;
                        v239 = v86;
                      }
                      ref_count_obj_release(v86);
                      ref_count_obj_release((_QWORD *)v10);
                      ref_count_obj_release(v235);
                      if (!v238)
                      {
                        *((_DWORD *)v239 + 12) = 0;
                        ++*(_DWORD *)v239;
                        v240 = *(_QWORD **)(v2 + 16);
                        v11 = (NSObject **)&unk_100164000;
                        if (v240)
                          ref_count_obj_release(v240);
                        *(_QWORD *)(v2 + 16) = v239;
                        ++*(_DWORD *)v2;
                        v241 = *(_QWORD **)(a2 + 144);
                        v5 = v277;
                        if (v241)
                          ref_count_obj_release(v241);
                        *(_QWORD *)(a2 + 144) = v2;
                        *(_QWORD *)(a2 + 152) = dnssec_query_record_result_reply;
                        *(_BYTE *)(a2 + 635) = 1;
                        ref_count_obj_release((_QWORD *)v2);
                        v2 = (uint64_t)v239;
                        v55 = &unk_100164000;
LABEL_494:
                        ref_count_obj_release((_QWORD *)v2);
LABEL_495:
                        if (!*(_DWORD *)(a2 + 252))
                        {
                          v242 = mDNSLogCategory_mDNS;
                          if (v55[2416] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            {
                              v243 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                              v247 = v6;
                              v245 = 257;
                              while (v247 < v7 && v247)
                              {
                                v248 = *v247;
                                if (v248 > 0x3F)
                                {
                                  v245 = 257;
                                  break;
                                }
                                if (!*v247)
                                {
                                  v245 = (unsigned __int16)((_WORD)v247 - (_WORD)v6 + 1);
                                  break;
                                }
                                v247 += v248 + 1;
                              }
LABEL_517:
                              v249 = mDNS_DomainNameFNV1aHash(v6);
                              v250 = *(unsigned __int16 *)(a2 + 342);
                              LODWORD(__src[0]) = 67110403;
                              DWORD1(__src[0]) = v243;
                              WORD4(__src[0]) = 2160;
                              *(_QWORD *)((char *)__src + 10) = 1752392040;
                              WORD1(__src[1]) = 1040;
                              DWORD1(__src[1]) = v245;
                              WORD4(__src[1]) = 2101;
                              *(_QWORD *)((char *)&__src[1] + 10) = v6;
                              WORD1(__src[2]) = 1024;
                              DWORD1(__src[2]) = v249;
                              WORD4(__src[2]) = 1024;
                              *(_DWORD *)((char *)&__src[2] + 10) = v250;
                              _os_log_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StartQuery_internal START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), qtype: %{mdns:rrtype}d", (uint8_t *)__src, 0x2Eu);
                            }
                          }
                          else
                          {
                            v242 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
                              v243 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                              v244 = v6;
                              v245 = 257;
                              while (v244 < v7 && v244)
                              {
                                v246 = *v244;
                                if (v246 > 0x3F)
                                {
                                  v245 = 257;
                                  goto LABEL_517;
                                }
                                if (!*v244)
                                {
                                  v245 = (unsigned __int16)((_WORD)v244 - (_WORD)v6 + 1);
                                  goto LABEL_517;
                                }
                                v244 += v246 + 1;
                              }
                              goto LABEL_517;
                            }
                          }
                        }
                        if ((unint64_t)(v278 + 5) <= 3 && v278 != -4)
                          return 0;
                        if (*(_WORD *)(a2 + 340))
                        {
                          v251 = *(_QWORD *)(a2 + 40);
                          if (v251)
                          {
                            v252 = *(void **)(v251 + 80);
                            if (v252)
                              os_retain(v252);
                            v253 = *(void **)(a2 + 80);
                            if (v253)
                              os_release(v253);
                            *(_QWORD *)(a2 + 80) = *(_QWORD *)(v251 + 80);
                            v254 = v11[295];
                            if (v55[2416] != 1 || v254 == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled(v11[295], OS_LOG_TYPE_DEFAULT))
                              {
                                v255 = *(_DWORD *)(a2 + 252);
                                v256 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                                v257 = bswap32(*(unsigned __int16 *)(v251 + 340)) >> 16;
                                v264 = v6;
                                v259 = 257;
                                while (v264 < v7 && v264)
                                {
                                  v265 = *v264;
                                  if (v265 > 0x3F)
                                  {
                                    v259 = 257;
                                    break;
                                  }
                                  if (!*v264)
                                  {
                                    v259 = (unsigned __int16)((_WORD)v264 - (_WORD)v6 + 1);
                                    break;
                                  }
                                  v264 += v265 + 1;
                                }
LABEL_563:
                                v268 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
                                LODWORD(__src[0]) = 67110659;
                                DWORD1(__src[0]) = v255;
                                WORD4(__src[0]) = 1024;
                                *(_DWORD *)((char *)__src + 10) = v256;
                                HIWORD(__src[0]) = 1024;
                                LODWORD(__src[1]) = v257;
                                WORD2(__src[1]) = 2160;
                                *(_QWORD *)((char *)&__src[1] + 6) = 1752392040;
                                HIWORD(__src[1]) = 1040;
                                LODWORD(__src[2]) = v259;
                                WORD2(__src[2]) = 2101;
                                *(_QWORD *)((char *)&__src[2] + 6) = v6;
                                HIWORD(__src[2]) = 2082;
                                *(_QWORD *)&__src[3] = v268;
                                _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, "[R%u->DupQ%u->Q%u] Duplicate question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x38u);
                              }
                            }
                            else
                            {
                              v254 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                v255 = *(_DWORD *)(a2 + 252);
                                v256 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                                v257 = bswap32(*(unsigned __int16 *)(v251 + 340)) >> 16;
                                v258 = v6;
                                v259 = 257;
                                while (v258 < v7 && v258)
                                {
                                  v260 = *v258;
                                  if (v260 > 0x3F)
                                  {
                                    v259 = 257;
                                    goto LABEL_563;
                                  }
                                  if (!*v258)
                                  {
                                    v259 = (unsigned __int16)((_WORD)v258 - (_WORD)v6 + 1);
                                    goto LABEL_563;
                                  }
                                  v258 += v260 + 1;
                                }
                                goto LABEL_563;
                              }
                            }
                          }
                          ActivateUnicastQuery(a1, a2, 0);
                          return 0;
                        }
                        v261 = *v5;
                        v262 = v5[1] + 1;
                        v5[1] = v262;
                        if (v261 + v262 == 1)
                        {
                          *(_DWORD *)(a1 + 116) = 0;
                          if (!*(_BYTE *)(a1 + 120))
                          {
                            *(_BYTE *)(a1 + 120) = 1;
                            *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 64);
                          }
                        }
                        if (!*(_BYTE *)(a2 + 639))
                          return 0;
                        v263 = mDNSLogCategory_mDNS;
                        if (v55[2416] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_552;
                        }
                        else
                        {
                          v263 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_552:
                            v266 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                            LODWORD(__src[0]) = 67109120;
                            DWORD1(__src[0]) = v266;
                            _os_log_impl((void *)&_mh_execute_header, v263, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StartQuery_internal: Purging records before resolving", (uint8_t *)__src, 8u);
                          }
                        }
                        mDNS_PurgeBeforeResolve(a1, a2);
                        return 0;
                      }
                      ref_count_obj_release((_QWORD *)v2);
                      v2 = (uint64_t)v239;
                      if (!v239)
                        return 4294901759;
LABEL_586:
                      ref_count_obj_release((_QWORD *)v2);
                      return 4294901759;
                    }
LABEL_583:
                    __break(1u);
                  }
                  ref_count_obj_release(v86);
                  if (v10)
                    ref_count_obj_release((_QWORD *)v10);
                  goto LABEL_586;
                }
                if (!v208)
                  goto LABEL_423;
              }
LABEL_424:
              v2 = *(_QWORD *)(v2 + 8);
              if (v2)
                v209 = v2 == a2;
              else
                v209 = 1;
              if (v209)
                goto LABEL_429;
            }
          }
LABEL_363:
          mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SetNextQueryStopTime", 399);
          v189 = *(_DWORD *)(a2 + 240);
          if (*(_DWORD *)(a1 + 184) - v189 >= 1)
            *(_DWORD *)(a1 + 184) = v189;
          goto LABEL_365;
        }
        if (DNSService)
        {
          if ((*(_BYTE *)(a2 + 327) & 0x40) != 0)
          {
            v137 = *(_QWORD *)(a2 + 88);
            if (v137)
            {
              if (!*(_QWORD *)(a2 + 136) && *(_BYTE *)(DNSService + 282) != 1)
              {
                if (*(_QWORD *)(DNSService + 24) != v137
                  && *(_BYTE *)(DNSService + 280) == 1
                  && *(unsigned __int8 *)(DNSService + 281) - 2 >= 4
                  && (*(_WORD *)(DNSService + 276) & 0x200) == 0)
                {
                  v138 = "avoid non-private DNS service";
                  goto LABEL_270;
                }
                if (!uuid_is_null((const unsigned __int8 *)(a2 + 360))
                  && _Querier_VPNDNSServiceExistsForQName((uint64_t)v6))
                {
                  v138 = "QNAME is in a VPN DNS service's domain";
                  goto LABEL_270;
                }
              }
            }
          }
          *(_QWORD *)(a2 + 80) = v10;
          goto LABEL_320;
        }
        if (uuid_is_null((const unsigned __int8 *)(a2 + 360)))
        {
          *(_QWORD *)(a2 + 80) = 0;
LABEL_268:
          v86 = *(uint64_t **)(a2 + 144);
          goto LABEL_329;
        }
        v138 = "ResolverUUID may be stale";
LABEL_270:
        v2 = (uint64_t)v11[295];
        if (gSensitiveLoggingEnabled != 1 || v2 == mDNSLogCategory_State)
        {
          if (os_log_type_enabled(v11[295], OS_LOG_TYPE_DEBUG))
          {
            v139 = v5;
            v140 = *(_DWORD *)(a2 + 252);
            v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (jj = v6; ; jj += v151 + 1)
            {
              v143 = 257;
              if (jj >= v7 || !jj)
                break;
              v151 = *jj;
              if (v151 > 0x3F)
              {
                v143 = 257;
                goto LABEL_581;
              }
              if (!*jj)
              {
                v143 = (_WORD)jj - (_WORD)v6 + 1;
                goto LABEL_581;
              }
            }
            goto LABEL_581;
          }
        }
        else
        {
          v2 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
          {
            v139 = v5;
            v140 = *(_DWORD *)(a2 + 252);
            v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (kk = v6; ; kk += v144 + 1)
            {
              v143 = 257;
              if (kk >= v7 || !kk)
                break;
              v144 = *kk;
              if (v144 > 0x3F)
              {
                v143 = 257;
                break;
              }
              if (!*kk)
              {
                v143 = (_WORD)kk - (_WORD)v6 + 1;
                break;
              }
            }
LABEL_581:
            v271 = v143;
            v272 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
            LODWORD(__src[0]) = 67110659;
            DWORD1(__src[0]) = v140;
            WORD4(__src[0]) = 1024;
            *(_DWORD *)((char *)__src + 10) = v141;
            HIWORD(__src[0]) = 2160;
            *(_QWORD *)&__src[1] = 1752392040;
            WORD4(__src[1]) = 1040;
            *(_DWORD *)((char *)&__src[1] + 10) = v271;
            HIWORD(__src[1]) = 2101;
            *(_QWORD *)&__src[2] = v6;
            WORD4(__src[2]) = 2082;
            *(_QWORD *)((char *)&__src[2] + 10) = v272;
            WORD1(__src[3]) = 2082;
            *(_QWORD *)((char *)&__src[3] + 4) = v138;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)v2, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] Retrying path evaluation -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, reason: %{public}s", (uint8_t *)__src, 0x3Cu);
            v5 = v139;
            v11 = (NSObject **)&unk_100164000;
            v55 = (_BYTE *)&unk_100164000;
          }
        }
        mDNSPlatformGetDNSRoutePolicy(a2);
        v10 = _Querier_GetDNSService(a2, 0);
        goto LABEL_254;
      }
      if (!v92)
        goto LABEL_362;
      if (v93)
        goto LABEL_363;
      if ((unint64_t)(v94 + 5) <= 3 && v94 != -4)
        goto LABEL_184;
      v145 = *v6;
      if (*v6)
      {
        v146 = 0;
        v147 = v6;
        do
        {
          ++v146;
          v148 = &v147[v145];
          v149 = v148[1];
          v147 = v148 + 1;
          v145 = v149;
        }
        while (v149);
      }
      else
      {
        v146 = 0;
      }
      v10 = *(_QWORD *)(a1 + 12688);
      if (v10)
      {
        v152 = 0;
        v153 = -1;
        do
        {
          v154 = v11;
          v155 = *(unsigned __int8 *)(v10 + 20);
          if (*(_BYTE *)(v10 + 20))
          {
            v156 = 0;
            v157 = v10 + 20;
            do
            {
              ++v156;
              v158 = v157 + v155;
              v159 = *(unsigned __int8 *)(v158 + 1);
              v157 = v158 + 1;
              v155 = v159;
            }
            while (v159);
          }
          else
          {
            v156 = 0;
          }
          if (v146 >= v156 && v156 >= v153)
          {
            v276 = v152;
            v160 = v6;
            if (v146 - v156 >= 1)
            {
              v161 = v146 + 1 - v156;
              v160 = v6;
              do
              {
                if (!*v160)
                  break;
                v160 += *v160 + 1;
                --v161;
              }
              while (v161 > 1);
            }
            if (SameDomainNameBytes(v160, (_BYTE *)(v10 + 20)))
              v162 = v153 == v156;
            else
              v162 = 1;
            v163 = !v162;
            v152 = v276;
            if ((v163 & 1) != 0)
            {
              v152 = v10;
              v153 = v156;
            }
          }
          v10 = *(_QWORD *)v10;
          v11 = v154;
        }
        while (v10);
        if ((mDNS_LoggingEnabled & 1) == 0)
        {
          v55 = (_BYTE *)&unk_100164000;
LABEL_572:
          if (v152)
          {
            v104 = *(_DWORD *)(v152 + 276);
            goto LABEL_185;
          }
LABEL_184:
          v104 = 5;
LABEL_185:
          v105 = *(_DWORD *)(a1 + 64) + 1000 * v104;
          if (v105 <= 1)
            v105 = 1;
          *(_DWORD *)(a2 + 240) = v105;
          v106 = v11[295];
          if (v55[2416] != 1 || v106 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v11[295], OS_LOG_TYPE_DEBUG))
              goto LABEL_362;
            v107 = v11;
            v108 = *(_DWORD *)(a2 + 252);
            v10 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (mm = v6; ; mm += v121 + 1)
            {
              v110 = 257;
              if (mm >= v7 || !mm)
                break;
              v121 = *mm;
              if (v121 > 0x3F)
              {
                v110 = 257;
                break;
              }
              if (!*mm)
              {
                v110 = (_WORD)mm - (_WORD)v6 + 1;
                break;
              }
            }
          }
          else
          {
            v106 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              goto LABEL_362;
            v107 = v11;
            v108 = *(_DWORD *)(a2 + 252);
            v10 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (nn = v6; ; nn += v111 + 1)
            {
              v110 = 257;
              if (nn >= v7 || !nn)
                break;
              v111 = *nn;
              if (v111 > 0x3F)
              {
                v110 = 257;
                break;
              }
              if (!*nn)
              {
                v110 = (_WORD)nn - (_WORD)v6 + 1;
                break;
              }
            }
          }
          v269 = v110;
          v270 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LODWORD(__src[0]) = 67110659;
          DWORD1(__src[0]) = v108;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v10;
          HIWORD(__src[0]) = 2048;
          *(_QWORD *)&__src[1] = a2;
          WORD4(__src[1]) = 2160;
          *(_QWORD *)((char *)&__src[1] + 10) = 1752392040;
          WORD1(__src[2]) = 1040;
          DWORD1(__src[2]) = v269;
          WORD4(__src[2]) = 2101;
          *(_QWORD *)((char *)&__src[2] + 10) = v6;
          WORD1(__src[3]) = 2082;
          *(_QWORD *)((char *)&__src[3] + 4) = v270;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x3Cu);
          v11 = v107;
LABEL_361:
          v55 = (_BYTE *)&unk_100164000;
          goto LABEL_362;
        }
        v164 = v154[295];
        v55 = (_BYTE *)&unk_100164000;
      }
      else
      {
        if (mDNS_LoggingEnabled != 1)
          goto LABEL_184;
        v152 = 0;
        v164 = v11[295];
      }
      v165 = v152;
      LogMsgWithLevel(v164, OS_LOG_TYPE_DEFAULT, "GetTimeoutForMcastQuestion: question %##s curmatch %p, Timeout %d", v66, v67, v68, v69, v70, (int)v6);
      v152 = v165;
      goto LABEL_572;
    }
    *(_DWORD *)(a2 + 280) = -1;
    if ((v76 & 0x40000000) != 0)
    {
      if (!*(_BYTE *)(a2 + 642))
        goto LABEL_152;
      v78 = v11[295];
      if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(v11[295], OS_LOG_TYPE_DEFAULT))
        {
LABEL_150:
          v89 = *(_DWORD *)(a2 + 252);
          v90 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          LODWORD(__src[0]) = 67109376;
          DWORD1(__src[0]) = v89;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v90;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Forcing another path evaluation", (uint8_t *)__src, 0xEu);
        }
      }
      else
      {
        v78 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_150;
      }
    }
    *(_BYTE *)(a2 + 642) = 0;
    mDNSPlatformGetDNSRoutePolicy(a2);
    goto LABEL_152;
  }
  v57 = v11[295];
  if (gSensitiveLoggingEnabled != 1 || v57 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v11[295], OS_LOG_TYPE_DEFAULT))
      return v2;
    v59 = v6;
    v60 = 257;
    if (!v7)
      goto LABEL_96;
LABEL_93:
    if (v59 < v7 && v59)
    {
      while (1)
      {
        v61 = *v59;
        if (v61 > 0x3F)
        {
LABEL_141:
          v60 = 257;
          goto LABEL_148;
        }
        if (!*v59)
          break;
        v59 += v61 + 1;
        if (v7)
          goto LABEL_93;
LABEL_96:
        if (!v59)
          goto LABEL_141;
      }
      v60 = (unsigned __int16)((_WORD)v59 - (_WORD)v6 + 1);
    }
LABEL_148:
    v88 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LODWORD(__src[0]) = 141559043;
    *(_QWORD *)((char *)__src + 4) = 1752392040;
    WORD6(__src[0]) = 1040;
    *(_DWORD *)((char *)__src + 14) = v60;
    WORD1(__src[1]) = 2101;
    *(_QWORD *)((char *)&__src[1] + 4) = v6;
    WORD6(__src[1]) = 2082;
    *(_QWORD *)((char *)&__src[1] + 14) = v88;
    WORD3(__src[2]) = 2048;
    *((_QWORD *)&__src[2] + 1) = a2;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "mDNS_StartQuery_internal: Error! Tried to add a question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) %p that's already in the active list", (uint8_t *)__src, 0x30u);
    return v2;
  }
  v57 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    v73 = v6;
    v60 = 257;
    if (!v7)
      goto LABEL_114;
LABEL_111:
    if (v73 < v7 && v73)
    {
      while (1)
      {
        v74 = *v73;
        if (v74 > 0x3F)
        {
LABEL_142:
          v60 = 257;
          goto LABEL_148;
        }
        if (!*v73)
          break;
        v73 += v74 + 1;
        if (v7)
          goto LABEL_111;
LABEL_114:
        if (!v73)
          goto LABEL_142;
      }
      v60 = (unsigned __int16)((_WORD)v73 - (_WORD)v6 + 1);
    }
    goto LABEL_148;
  }
  return v2;
}

BOOL IsLocalDomain(_BYTE *a1)
{
  int v1;
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  int v10;

  v1 = *a1;
  if (!*a1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = a1;
    v7 = v3;
    v8 = v2;
    v9 = &a1[v1];
    v10 = v9[1];
    a1 = v9 + 1;
    v1 = v10;
    v2 = v3;
    v3 = v4;
    v4 = v5;
    v5 = v6;
  }
  while (v10);
  return SameDomainNameBytes(v6, "\x05local")
      || v7 && SameDomainNameBytes(v7, "\x03254\x03169\ain-addr\x04arpa")
      || v8
      && (SameDomainNameBytes(v8, "\x018\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x019\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x01a\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x01b\x01e\x01f\x03ip6\x04arpa"));
}

uint64_t *GetAuthInfoForName_internal(uint64_t a1, _BYTE *a2)
{
  char *v3;
  void **v4;
  int v5;
  NSObject *v6;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unsigned __int16 v16;
  char *v17;
  uint64_t v18;
  uint64_t i;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  char *v33;

  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"GetAuthInfoForName_internal", 398);
  v3 = *(char **)(a1 + 12760);
  if (v3)
  {
    v4 = (void **)(a1 + 12760);
    while (1)
    {
      v5 = *((_DWORD *)v3 + 2);
      if (v5)
      {
        if (*(_DWORD *)(a1 + 64) - v5 >= 0)
          break;
      }
      v4 = (void **)v3;
LABEL_55:
      v3 = (char *)*v4;
      if (!*v4)
        return GetAuthInfoForName_direct(a1, a2);
    }
    v6 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_50:
        *v4 = *(void **)v3;
        for (i = *(_QWORD *)(a1 + 192); i; i = *(_QWORD *)(i + 8))
        {
          if (*(char **)(i + 32) == v3)
            *(_QWORD *)(i + 32) = GetAuthInfoForName_direct(a1, (_BYTE *)(i + 376));
        }
        free(v3);
        goto LABEL_55;
      }
      v8 = v3 + 268;
      v9 = v3 + 12;
      if (v3 == (char *)-268)
      {
LABEL_13:
        while (v9)
        {
          v10 = *v9;
          if (v10 > 0x3F)
            break;
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_30;
          }
          v9 += v10 + 1;
          if (v3 != (char *)-268)
            goto LABEL_12;
        }
      }
      else
      {
LABEL_12:
        if (v9 < v8)
          goto LABEL_13;
      }
      LOWORD(v9) = 257;
LABEL_30:
      LODWORD(v9) = (unsigned __int16)v9;
      v14 = v3 + 268;
      if (v3 == (char *)-524)
      {
LABEL_32:
        while (v14)
        {
          v15 = *v14;
          if (v15 > 0x3F)
            break;
          if (!*v14)
          {
            v16 = (_WORD)v14 - (_WORD)v8 + 1;
            goto LABEL_49;
          }
          v14 += v15 + 1;
          if (v3 != (char *)-524)
            goto LABEL_31;
        }
      }
      else
      {
LABEL_31:
        if (v14 < v3 + 524)
          goto LABEL_32;
      }
      v16 = 257;
    }
    else
    {
      v6 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
      v12 = v3 + 268;
      v9 = v3 + 12;
      if (v3 == (char *)-268)
      {
LABEL_22:
        while (v9)
        {
          v13 = *v9;
          if (v13 > 0x3F)
            break;
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_39;
          }
          v9 += v13 + 1;
          if (v3 != (char *)-268)
            goto LABEL_21;
        }
      }
      else
      {
LABEL_21:
        if (v9 < v12)
          goto LABEL_22;
      }
      LOWORD(v9) = 257;
LABEL_39:
      LODWORD(v9) = (unsigned __int16)v9;
      v17 = v3 + 268;
      if (v3 == (char *)-524)
      {
LABEL_41:
        while (v17)
        {
          v18 = *v17;
          if (v18 > 0x3F)
            break;
          if (!*v17)
          {
            v16 = (_WORD)v17 - (_WORD)v12 + 1;
            goto LABEL_49;
          }
          v17 += v18 + 1;
          if (v3 != (char *)-524)
            goto LABEL_40;
        }
      }
      else
      {
LABEL_40:
        if (v17 < v3 + 524)
          goto LABEL_41;
      }
      v16 = 257;
    }
LABEL_49:
    *(_DWORD *)buf = 141559299;
    v23 = 1752392040;
    v24 = 1040;
    v25 = (int)v9;
    v26 = 2101;
    v27 = v3 + 12;
    v28 = 2160;
    v29 = 1752392040;
    v30 = 1040;
    v31 = v16;
    v32 = 2101;
    v33 = v3 + 268;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "GetAuthInfoForName_internal deleting expired key %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x36u);
    goto LABEL_50;
  }
  return GetAuthInfoForName_direct(a1, a2);
}

void SetNextQueryTime(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v6;

  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SetNextQueryTime", 407);
  v4 = *(_DWORD *)(a2 + 212);
  if (v4 >= 1 && !*(_QWORD *)(a2 + 40))
  {
    v5 = 12680;
    if (!*(_WORD *)(a2 + 340))
      v5 = 92;
    v6 = *(_DWORD *)(a2 + 208) + v4;
    if (*(_DWORD *)(a1 + v5) - v6 >= 1)
      *(_DWORD *)(a1 + v5) = v6;
  }
}

unsigned __int8 *ConvertDomainLabelToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 v6;
  unsigned __int8 v7;

  v5 = *a1;
  v3 = a1 + 1;
  v4 = v5;
  if (v5 > 0x3FuLL)
    return 0;
  if (v3 < &v3[v4])
  {
    do
    {
      v7 = *v3++;
      v6 = v7;
      if (a3)
      {
        if (v6 == 46 || v6 == a3)
        {
          *a2++ = a3;
        }
        else if (v6 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v6 / 0xAu) | 0x30;
          a2 += 3;
          v6 = (v6 % 0xAu) | 0x30;
        }
      }
      *a2++ = v6;
      --v4;
    }
    while (v4);
  }
  *a2 = 0;
  return a2;
}

void mDNSDynamicStoreSetConfig(int a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  CFPropertyListRef DeepCopy;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD block[6];
  int v17;

  DeepCopy = CFPropertyListCreateDeepCopy(0, a2, 0);
  if (DeepCopy)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = __mDNSDynamicStoreSetConfig_block_invoke;
    block[3] = &__block_descriptor_tmp_3508;
    v17 = a1;
    block[4] = DeepCopy;
    block[5] = 0;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSDynamicStoreSetConfig: ERROR valueCopy NULL", v11, v12, v13, v14, v15, a9);
  }
}

unsigned __int8 *ConvertDomainNameToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  int v3;
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;

  v2 = a1;
  v3 = *a1;
  if (*a1 || (*a2 = 46, ++a2, (v3 = *a1) != 0))
  {
    v4 = (unint64_t)(a1 + 256);
    while ((unint64_t)&v2[v3 + 1] < v4)
    {
      v5 = ConvertDomainLabelToCString_withescape(v2, a2, 92);
      v6 = v5;
      if (!v5)
        return v6;
      v7 = &v2[*v2];
      *v5 = 46;
      a2 = v5 + 1;
      v8 = v7[1];
      v2 = v7 + 1;
      v3 = v8;
      if (!v8)
        goto LABEL_7;
    }
    return 0;
  }
  else
  {
LABEL_7:
    *a2 = 0;
    return a2 + 1;
  }
}

void mDNSCoreInitComplete()
{
  dword_100158DD8 = 0;
  if (off_100158DE8)
  {
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19119);
    mDNS_VerifyLockState("Drop Lock", 0, dword_100158DF8, ++dword_100158DFC, (uint64_t)"mDNSCoreInitComplete", 19120);
    off_100158DE8(mDNSStorage, 0);
    mDNS_VerifyLockState("Reclaim Lock", 0, dword_100158DF8, dword_100158DFC, (uint64_t)"mDNSCoreInitComplete", 19122);
    --dword_100158DFC;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19123);
  }
}

void mDNS_StatusCallback(size_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  size_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;

  if (a2 <= -65549)
  {
    if (a2 == -65791)
    {
      mDNSPreferencesSetNames(1, (__int128 *)(*(_QWORD *)a1 + 172), (__int128 *)(a1 + 10280));
      mDNSPreferencesSetNames(2, (__int128 *)(*(_QWORD *)a1 + 108), (__int128 *)(a1 + 10344));
      udsserver_handle_configchange(a1);
    }
    else if (a2 == -65790 && mDNS_StatusCallback_allocated <= 0xF423F)
    {
      mDNS_StatusCallback_allocated += 32704;
      v9 = malloc_type_malloc(0x7FC0uLL, 0xA172743EuLL);
      if (v9)
      {
        v10 = v9;
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_GrowCache", 18342);
        v11 = (char *)(v10 + 28);
        v12 = 146;
        do
        {
          *((_QWORD *)v11 - 28) = v11;
          v11 += 224;
          --v12;
        }
        while (v12);
        v10[4060] = *(_QWORD *)(a1 + 264);
        *(_QWORD *)(a1 + 264) = v10;
        *(_DWORD *)(a1 + 240) += 146;
        mDNS_Unlock_(a1, (uint64_t)"mDNS_GrowCache", 18344);
      }
      else
      {
        __break(1u);
      }
    }
    return;
  }
  if (a2 != -65548)
  {
    if (a2)
      return;
    v14 = (unsigned __int8 *)(*(_QWORD *)a1 + 108);
    v13 = *v14;
    if ((_DWORD)v13 == *(unsigned __int8 *)(a1 + 10344))
    {
      if (!memcmp((const void *)(*(_QWORD *)a1 + 109), (const void *)(a1 + 10345), v13)
        || (mDNS_LoggingEnabled & 1) == 0)
      {
        goto LABEL_23;
      }
    }
    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_23:
      v18 = dword_100158E08 + 1000;
      if ((dword_100158E08 + 1000) <= 1)
        v18 = 1;
      *(_DWORD *)(mDNSStorage[0] + 492) = v18;
      return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname changed from \"%#s.local\" to \"%#s.local\"", a4, a5, a6, a7, a8, (int)v14);
    goto LABEL_23;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname conflict for \"%#s.local\"", a4, a5, a6, a7, a8, a1 + 10344);
  v15 = *(_QWORD *)a1;
  v16 = *(_DWORD *)(*(_QWORD *)a1 + 496);
  v17 = *(_DWORD *)(a1 + 64);
  if (v16)
  {
    if ((int)(v17 - v16) >= 60001)
      mDNSPreferencesSetNames(2, (__int128 *)(v15 + 108), 0);
  }
  else
  {
    if (v17 <= 1)
      v17 = 1;
    *(_DWORD *)(v15 + 496) = v17;
  }
}

void uDNS_SetupDNSConfig()
{
  uint64_t i;
  _DWORD *v1;
  uint64_t *v2;
  int v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const __CFString *Value;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t j;
  NSObject *v14;
  const __CFString *v15;
  const __CFString *v16;
  uint64_t IfAddrs;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  BOOL v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 *v40;
  __int128 *v41;
  _QWORD *v42;
  int v43;
  int v44;
  _QWORD v45[3];
  _BYTE v46[20];
  _DWORD v47[6];
  _OWORD v48[16];
  __int128 v49;
  int v50;
  _OWORD buffer[16];

  memset(v47, 0, 20);
  memset(v46, 0, sizeof(v46));
  memset(v45, 0, 20);
  memset(v48, 0, sizeof(v48));
  uDNS_SetupWABQueries();
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 18797);
  for (i = qword_10015BF58; i; i = *(_QWORD *)i)
    *(_DWORD *)(i + 16) |= 1u;
  if (!mDNSPlatformSetDNSConfig(1, 0, v48, 0, 0, 1))
  {
    SetDynDNSHostNameIfChanged(v48);
    for (j = qword_10015BF58; j; j = *(_QWORD *)j)
      *(_DWORD *)(j + 16) &= ~1u;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 18811);
    v14 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buffer[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "uDNS_SetupDNSConfig: No configuration change", (uint8_t *)buffer, 2u);
    }
    return;
  }
  v1 = (_DWORD *)qword_10015BF58;
  if (qword_10015BF58)
  {
    v2 = &qword_10015BF58;
    do
    {
      v3 = v1[4];
      if ((v3 & 1) != 0)
      {
        *v2 = *(_QWORD *)v1;
        free(v1);
      }
      else
      {
        v1[4] = v3 & 0xFFFFFFFD;
        v2 = (uint64_t *)v1;
      }
      v1 = (_DWORD *)*v2;
    }
    while (*v2);
  }
  Querier_ProcessDNSServiceChanges(0);
  SetDynDNSHostNameIfChanged(v48);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 19093);
  *(_OWORD *)((char *)v45 + 4) = 0uLL;
  memset(v46, 0, sizeof(v46));
  *(_OWORD *)&v47[1] = 0uLL;
  LODWORD(v45[0]) = 4;
  v47[0] = 4;
  v4 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, (CFStringRef)NetworkChangedKey_IPv4);
  if (!v4)
  {
    v12 = 0;
    goto LABEL_69;
  }
  v5 = v4;
  memset(buffer, 0, sizeof(buffer));
  v45[0] = 4;
  Value = (const __CFString *)CFDictionaryGetValue(v4, kSCPropNetIPv4Router);
  if (!Value)
    goto LABEL_20;
  if (!CFStringGetCString(Value, (char *)buffer, 256, 0x8000100u))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Could not convert router to CString", v7, v8, v9, v10, v11, v43);
LABEL_20:
    v12 = 0;
    goto LABEL_21;
  }
  v49 = 0x210uLL;
  inet_aton((const char *)buffer, (in_addr *)&v49 + 1);
  v12 = DWORD1(v49);
  HIDWORD(v45[0]) = DWORD1(v49);
LABEL_21:
  v15 = (const __CFString *)CFDictionaryGetValue(v5, kSCDynamicStorePropNetPrimaryInterface);
  if (!v15)
    goto LABEL_64;
  v16 = v15;
  IfAddrs = myGetIfAddrs();
  memset(v46, 0, sizeof(v46));
  memset(v47, 0, 20);
  if (!CFStringGetCString(v16, (char *)buffer, 256, 0x8000100u))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Could not convert router to CString", v18, v19, v20, v21, v22, v43);
    goto LABEL_64;
  }
  if (!IfAddrs)
  {
LABEL_64:
    v26 = 0;
    v25 = 0;
    goto LABEL_65;
  }
  v44 = v12;
  v23 = 0;
  do
  {
    v24 = v47[1];
    v25 = LOBYTE(v47[1]);
    v26 = BYTE1(v47[1]);
    v28 = BYTE1(v47[1]) == 254 || v23 == 0;
    while (1)
    {
      if (v24)
      {
        if (v25 == 169)
        {
          if (!v28)
            goto LABEL_62;
        }
        else if (v23)
        {
          goto LABEL_62;
        }
      }
      v29 = *(_QWORD *)(IfAddrs + 24);
      if (v29)
        break;
      v30 = *(const char **)(IfAddrs + 8);
      if (!v30)
        v30 = "name not found";
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Skip interface, %s, since ifa_addr is not set.", v18, v19, v20, v21, v22, (int)v30);
      IfAddrs = *(_QWORD *)IfAddrs;
      if (!IfAddrs)
        goto LABEL_62;
    }
    v50 = 0;
    v49 = 0uLL;
    if (!strcmp((const char *)buffer, *(const char **)(IfAddrs + 8)))
    {
      v32 = *(unsigned __int8 *)(v29 + 1);
      if (v32 == 30)
      {
        SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22);
        if ((BYTE4(v49) & 0xE0) == 0x20)
        {
          *(_OWORD *)v46 = v49;
          *(_DWORD *)&v46[16] = v50;
LABEL_43:
          v23 = 1;
        }
      }
      else if (v32 == 2 && (!v24 || v25 == 169 && v26 == 254))
      {
        SetupAddr((uint64_t)v47, v29, v31, v18, v19, v20, v21, v22);
      }
    }
    else
    {
      if (v23)
        goto LABEL_43;
      v33 = *(_BYTE *)(v29 + 1) == 30 && v46[4] == 0;
      if (v33 && (SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22), (BYTE4(v49) & 0xE0) == 0x20))
      {
        v23 = 0;
        *(_OWORD *)v46 = v49;
        *(_DWORD *)&v46[16] = v50;
      }
      else
      {
        v23 = 0;
      }
    }
    IfAddrs = *(_QWORD *)IfAddrs;
  }
  while (IfAddrs);
  v25 = LOBYTE(v47[1]);
  v26 = BYTE1(v47[1]);
LABEL_62:
  v12 = v44;
LABEL_65:
  CFRelease(v5);
  if (v25 == 169 && v26 == 254)
  {
    mDNS_SetPrimaryInterfaceInfo(0, 0, 0);
    if (byte_10015C620[0])
      mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_10015C620, 1, v34, v35, v36, v37, v38, v39);
    return;
  }
LABEL_69:
  if (v47[1])
    v40 = (__int128 *)v47;
  else
    v40 = 0;
  if (vorr_s8(*(int8x8_t *)&v46[4], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)&v46[4], *(int8x16_t *)&v46[4], 8uLL)))
    v41 = (__int128 *)v46;
  else
    v41 = 0;
  if (v12)
    v42 = v45;
  else
    v42 = 0;
  mDNS_SetPrimaryInterfaceInfo(v40, v41, (uint64_t)v42);
}

uint64_t mDNSPlatformSetDNSConfig(int a1, int a2, _BYTE *a3, _QWORD *a4, _QWORD *a5, int a6)
{
  NSObject *v11;
  __CFDictionary *Mutable;
  CFDataRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t v25;
  uint64_t IfAddrs;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  int v66;
  char *v67;
  int v68;
  char *v69;
  int v70;
  NSObject *v71;
  int v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t DNSServiceManager;
  uint64_t v81;
  NSObject *v82;
  unsigned int num;
  unint64_t v84;
  int v85;
  unsigned int v86;
  char *v87;
  int v88;
  int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v97;
  NSObject *v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const __CFDictionary *v105;
  const __CFDictionary *v106;
  const __CFArray *Value;
  const __CFArray *v108;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v110;
  const __CFString *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint8_t *v118;
  const __CFArray *v119;
  const __CFArray *v120;
  const __CFDictionary *v121;
  const __CFDictionary *v122;
  const __CFString *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint8_t *v130;
  const __CFArray *v131;
  const __CFArray *v132;
  int i;
  const __CFDictionary *v134;
  const __CFDictionary *v135;
  const __CFString *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint8_t *v143;
  int v145;
  _QWORD *v147[2];
  int v148;
  _QWORD *v149[2];
  int v150;
  _MD5_CTX v151;
  UInt8 bytes[4];
  int v153;
  uint64_t v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  uint8_t buf[48];
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;

  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  memset(&v151, 0, sizeof(v151));
  v11 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67110144;
    *(_DWORD *)&buf[4] = a1;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = a2;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = a3 != 0;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = a4 != 0;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = a5 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig new updates -- setservers: %{mdns:yesno}d, setsearch: %{mdns:yesno}d, fqdn: %{mdns:yesno}d, RegDomains: %{mdns:yesno}d, BrowseDomains: %{mdns:yesno}d", buf, 0x20u);
  }
  if (a2)
  {
    *(_OWORD *)&v151.A = xmmword_1001009D0;
    *(_QWORD *)&v151.Nl = 0;
    v151.num = 0;
    v154 = 0;
    *(_DWORD *)bytes = 528;
    v153 = DWORD1(xmmword_10015BF60);
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v13 = CFDataCreate(0, bytes, 16);
    CFDictionarySetValue(Mutable, CFSTR("remote-address"), v13);
    CFDictionarySetValue(Mutable, CFSTR("ServerBypass"), kCFBooleanTrue);
    v19 = (const void *)SCNetworkReachabilityCreateWithOptions(kCFAllocatorDefault, Mutable);
    if (Mutable)
      CFRelease(Mutable);
    if (v13)
      CFRelease(v13);
    if (v19)
    {
      *(_DWORD *)buf = 0;
      if (SCNetworkReachabilityGetFlags((SCNetworkReachabilityRef)v19, (SCNetworkReachabilityFlags *)buf))
      {
        v25 = buf[0];
        CFRelease(v19);
        if ((v25 & 4) != 0)
          goto LABEL_33;
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: AddrRequiresPPPConnection - SCNetworkReachabilityGetFlags", v20, v21, v22, v23, v24, v145);
        CFRelease(v19);
      }
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: RequiresConnection - SCNetworkReachabilityCreateWithOptions", v14, v15, v16, v17, v18, v145);
    }
    IfAddrs = myGetIfAddrs();
    if (IfAddrs)
    {
      v33 = IfAddrs;
      v34 = 0uLL;
      do
      {
        v149[0] = 0;
        v149[1] = 0;
        v150 = 0;
        v147[0] = 0;
        v147[1] = 0;
        v148 = 0;
        v157 = v34;
        v158 = v34;
        v155 = v34;
        v156 = v34;
        v35 = *(_QWORD *)(v33 + 24);
        if (*(_BYTE *)(v35 + 1) == 2)
        {
          if (*(_QWORD *)(v33 + 32))
          {
            if ((*(_BYTE *)(v33 + 16) & 8) == 0)
            {
              v36 = SetupAddr((uint64_t)v149, v35, v27, v28, v29, v30, v31, v32);
              v34 = 0uLL;
              if (!v36 && (BYTE4(v149[0]) != 169 || BYTE5(v149[0]) != 254))
              {
                v37 = *(_QWORD *)(v33 + 32);
                *(_BYTE *)(v37 + 1) = *(_BYTE *)(*(_QWORD *)(v33 + 24) + 1);
                SetupAddr((uint64_t)v147, v37, v27, v28, v29, v30, v31, v32);
                v145 = (HIBYTE(v147[0]) & HIBYTE(v149[0]));
                mDNS_snprintf(&v155);
                UpdateSearchDomainHash(&v151, (const char *)&v155, 0);
                v183 = 0u;
                v184 = 0u;
                v181 = 0u;
                v182 = 0u;
                v179 = 0u;
                v180 = 0u;
                v177 = 0u;
                v178 = 0u;
                v175 = 0u;
                v176 = 0u;
                v173 = 0u;
                v174 = 0u;
                v172 = 0u;
                memset(buf, 0, sizeof(buf));
                if (AppendDNSNameString(buf, (unsigned __int8 *)&v155, v38, v39, v40, v41, v42, v43) && buf[0])
                  mDNS_AddSearchDomain(buf, 0);
                v34 = 0uLL;
              }
            }
          }
        }
        v33 = *(_QWORD *)v33;
      }
      while (v33);
    }
  }
LABEL_33:
  if (!(a2 | a1))
    goto LABEL_101;
  v44 = dns_configuration_copy();
  if (!v44)
  {
    if (mDNSPlatformRawTime(0, v45, v46, v47, v48, v49, v50, v51) >= 0x2BF21)
    {
      v71 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "mDNSPlatformSetDNSConfig Error: dns_configuration_copy returned NULL", buf, 2u);
      }
    }
    goto LABEL_101;
  }
  v52 = v44;
  v53 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    v60 = *(_DWORD *)v52;
    v61 = *(_QWORD *)(v52 + 24);
    v62 = *(_QWORD *)(mDNSStorage[0] + 696);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v60;
    *(_WORD *)&buf[8] = 2048;
    *(_QWORD *)&buf[10] = v61;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v62;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v61 != v62;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig -- config->n_resolver: %d, this config generagtion: %llu, last config generation: %llu, changed: %{mdns:yesno}d", buf, 0x22u);
  }
  if (a1 && *(_QWORD *)(mDNSStorage[0] + 696) == *(_QWORD *)(v52 + 24))
  {
    dns_configuration_free(v52);
    v63 = 0;
    goto LABEL_102;
  }
  if (*(_DWORD *)v52
    && (v64 = **(_QWORD **)(v52 + 4), (v65 = *(unsigned __int8 **)v64) != 0)
    && *(_DWORD *)(v64 + 8)
    && **(_QWORD **)(v64 + 12))
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
    AppendDNSNameString(ActiveDirectoryPrimaryDomain, v65, v54, v55, v56, v57, v58, v59);
    v66 = ActiveDirectoryPrimaryDomain[0];
    if (ActiveDirectoryPrimaryDomain[0])
    {
      v67 = ActiveDirectoryPrimaryDomain;
      v68 = -1;
      do
      {
        v69 = &v67[v66];
        v70 = v69[1];
        v67 = v69 + 1;
        v66 = v70;
        ++v68;
      }
      while (v70);
      goto LABEL_53;
    }
  }
  else
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
  }
  v68 = -1;
  if (!*(_DWORD *)v52 || !*(_DWORD *)(**(_QWORD **)(v52 + 4) + 8))
    goto LABEL_63;
LABEL_53:
  if (v68 < 1)
  {
    v73 = ActiveDirectoryPrimaryDomain;
  }
  else
  {
    v72 = v68 + 1;
    v73 = ActiveDirectoryPrimaryDomain;
    do
    {
      if (!*v73)
        break;
      v73 += *v73 + 1;
      --v72;
    }
    while (v72 > 1);
  }
  if (SameDomainNameBytes(v73, "\x05local"))
  {
    SetupAddr((uint64_t)&ActiveDirectoryPrimaryDomainServer, **(_QWORD **)(**(_QWORD **)(v52 + 4) + 12), v74, v75, v76, v77, v78, v79);
  }
  else
  {
LABEL_63:
    ActiveDirectoryPrimaryDomain[0] = 0;
    ActiveDirectoryPrimaryDomainServer = 0;
    unk_100150480 = 0;
    dword_100150488 = 0;
  }
  if (a1)
  {
    DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
    {
      v81 = DNSServiceManager;
      if (_mdns_dns_service_queue_s_once != -1)
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __mdns_dns_service_manager_apply_dns_config_block_invoke;
      *(_QWORD *)&buf[24] = &__block_descriptor_tmp_12_815;
      *(_QWORD *)&buf[32] = v81;
      *(_QWORD *)&buf[40] = v52;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, buf);
      _Querier_LogDNSServices(v81);
    }
    a1 = 1;
  }
  ConfigResolvers((int *)v52, 0, a2, a1, &v151);
  ConfigResolvers((int *)v52, 1, a2, a1, &v151);
  ConfigResolvers((int *)v52, 2, a2, a1, &v151);
  if (a6)
  {
    *(_QWORD *)(mDNSStorage[0] + 696) = *(_QWORD *)(v52 + 24);
    v82 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig: acking configuration", buf, 2u);
    }
    AckConfigd(v52);
  }
  dns_configuration_free(v52);
  if (a2)
  {
    num = v151.num;
    v84 = (unint64_t)v151.num >> 2;
    v85 = v151.num & 3;
    if ((v151.num & 3) != 0)
    {
      v86 = v151.data[v84];
      v87 = &MD5_Final_end;
      if (v85 == 3)
        goto LABEL_82;
      if (v85 == 2)
      {
LABEL_81:
        v89 = *v87++;
        v86 |= v89 << 16;
LABEL_82:
        v151.data[v84] = v86 | (*v87 << 24);
        if (num <= 0x37)
        {
          if (num > 0x33)
            goto LABEL_89;
          v90 = v84 + 1;
        }
        else
        {
          if (num <= 0x3B)
            v151.data[15] = 0;
          md5_block_host_order(&v151, (int *)v151.data);
          v90 = 0;
        }
        bzero(&v151.data[v90], 4 * (13 - v90) + 4);
LABEL_89:
        *(_QWORD *)&v151.data[14] = *(_QWORD *)&v151.Nl;
        md5_block_host_order(&v151, (int *)v151.data);
        *(_QWORD *)&buf[4] = *(_QWORD *)&v151.B;
        *(_DWORD *)buf = v151.A;
        *(_DWORD *)&buf[12] = v151.D;
        v151.num = 0;
        if (*(_QWORD *)buf != (_QWORD)xmmword_10015C734 || *(_QWORD *)&buf[8] != *((_QWORD *)&xmmword_10015C734 + 1))
        {
          *(__int128 *)((char *)&xmmword_100158E84 + &loc_1000038AC + 4) = *(_OWORD *)buf;
          v97 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
          if (*(_QWORD *)((char *)&xmmword_100158E84 + 4))
          {
            while (!*(_BYTE *)(v97 + 641))
            {
              v97 = *(_QWORD *)(v97 + 8);
              if (!v97)
                goto LABEL_96;
            }
            if (mDNS_LoggingEnabled == 1)
            {
              v98 = mDNSLogCategory_Default;
              v99 = v97 + 376;
              DNSTypeName(*(unsigned __int16 *)(v97 + 342));
              LogMsgWithLevel(v98, OS_LOG_TYPE_DEFAULT, "RetrySearchDomainQuestions: Question with AppendSearchDomain found %##s (%s)", v100, v101, v102, v103, v104, v99);
            }
            mDNSCoreRestartAddressQueries(1, (void (*)(uint64_t *))FlushAddressCacheRecords, 0, 0);
          }
          else
          {
LABEL_96:
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RetrySearchDomainQuestions: Questions with AppendSearchDomain not found", v91, v92, v93, v94, v95, v145);
          }
        }
        goto LABEL_101;
      }
    }
    else
    {
      v87 = &byte_1000FFE9D;
      v86 = 128;
    }
    v88 = *v87++;
    v86 |= v88 << 8;
    goto LABEL_81;
  }
LABEL_101:
  v63 = 1;
LABEL_102:
  v149[0] = a4;
  v147[0] = a5;
  v105 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, CFSTR("Setup:/Network/DynamicDNS"));
  if (v105)
  {
    v106 = v105;
    bzero(buf, 0x3F1uLL);
    v169 = 0u;
    v170 = 0u;
    v167 = 0u;
    v168 = 0u;
    v165 = 0u;
    v166 = 0u;
    v163 = 0u;
    v164 = 0u;
    v161 = 0u;
    v162 = 0u;
    v159 = 0u;
    v160 = 0u;
    v157 = 0u;
    v158 = 0u;
    v155 = 0u;
    v156 = 0u;
    if (a3)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(v106, CFSTR("HostNames"));
      if (Value)
      {
        v108 = Value;
        if (CFArrayGetCount(Value) >= 1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v108, 0);
          if (ValueAtIndex)
          {
            v110 = ValueAtIndex;
            if (DictionaryIsEnabled(ValueAtIndex))
            {
              v111 = (const __CFString *)CFDictionaryGetValue(v110, CFSTR("Domain"));
              if (v111)
              {
                if (!CFStringGetCString(v111, (char *)buf, 1009, 0x8000100u)
                  || (*a3 = 0, !AppendDNSNameString(a3, buf, v112, v113, v114, v115, v116, v117))
                  || !*a3)
                {
                  if (buf[0])
                    v118 = buf;
                  else
                    v118 = (uint8_t *)"(unknown)";
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS host name: %s", v113, v114, v115, v116, v117, (int)v118);
                }
              }
            }
          }
        }
      }
    }
    if (a4)
    {
      v119 = (const __CFArray *)CFDictionaryGetValue(v106, CFSTR("RegistrationDomains"));
      if (v119)
      {
        v120 = v119;
        if (CFArrayGetCount(v119) >= 1)
        {
          v121 = (const __CFDictionary *)CFArrayGetValueAtIndex(v120, 0);
          if (v121)
          {
            v122 = v121;
            if (DictionaryIsEnabled(v121))
            {
              v123 = (const __CFString *)CFDictionaryGetValue(v122, CFSTR("Domain"));
              if (v123)
              {
                if (CFStringGetCString(v123, (char *)buf, 1009, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v124, v125, v126, v127, v128, v129))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v149, &v155);
                }
                else
                {
                  if (buf[0])
                    v130 = buf;
                  else
                    v130 = (uint8_t *)"(unknown)";
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS registration domain: %s", v125, v126, v127, v128, v129, (int)v130);
                }
              }
            }
          }
        }
      }
    }
    if (a5)
    {
      v131 = (const __CFArray *)CFDictionaryGetValue(v106, CFSTR("BrowseDomains"));
      if (v131)
      {
        v132 = v131;
        for (i = 0; CFArrayGetCount(v132) > i; ++i)
        {
          v134 = (const __CFDictionary *)CFArrayGetValueAtIndex(v132, i);
          if (v134)
          {
            v135 = v134;
            if (DictionaryIsEnabled(v134))
            {
              v136 = (const __CFString *)CFDictionaryGetValue(v135, CFSTR("Domain"));
              if (v136)
              {
                if (CFStringGetCString(v136, (char *)buf, 1009, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v137, v138, v139, v140, v141, v142))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v147, &v155);
                }
                else
                {
                  if (buf[0])
                    v143 = buf;
                  else
                    v143 = (uint8_t *)"(unknown)";
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS browsing domain: %s", v138, v139, v140, v141, v142, (int)v143);
                }
              }
            }
          }
        }
      }
    }
    CFRelease(v106);
  }
  return v63;
}

void mDNS_SetPrimaryInterfaceInfo(__int128 *a1, __int128 *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int *v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  _BOOL4 v17;
  int v18;
  int v19;
  int v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  BOOL v25;
  int v26;
  int v27;
  const char *v28;
  uint64_t i;
  uint64_t v30;
  unsigned __int16 *v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *j;
  const char *v53;
  int v54;
  int v55;
  int v56;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_SetPrimaryInterfaceInfo", 2709);
  if (a1 && *(_DWORD *)a1 != 4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo v4 address - incorrect type.  Discarding. %#a", v6, v7, v8, v9, v10, (int)a1);
  }
  else if (a2 && *(_DWORD *)a2 != 6)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo v6 address - incorrect type.  Discarding. %#a", v6, v7, v8, v9, v10, (int)a2);
  }
  else if (a3 && *(_DWORD *)a3 != 4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo passed non-v4 router.  Discarding. %#a", v6, v7, v8, v9, v10, a3);
  }
  else
  {
    v11 = &zerov4Addr;
    if (a1)
      v12 = (int *)a1 + 1;
    else
      v12 = &zerov4Addr;
    v13 = (_DWORD *)a2 + 1;
    if (!a2)
      v13 = &zerov6Addr;
    if ((_DWORD)qword_10015BF8C != *v13)
      goto LABEL_23;
    v14 = (_DWORD *)a2 + 2;
    if (!a2)
      v14 = &unk_1000FFE58;
    if (HIDWORD(qword_10015BF8C) != *v14)
      goto LABEL_23;
    v15 = (_DWORD *)a2 + 3;
    if (!a2)
      v15 = &unk_1000FFE5C;
    if (dword_10015BF94 == *v15)
    {
      v16 = &unk_1000FFE60;
      if (a2)
        v16 = a2 + 1;
      v17 = dword_10015BF98 == *v16;
    }
    else
    {
LABEL_23:
      v17 = 0;
    }
    v18 = dword_10015BF78;
    v19 = *v12;
    if (a3)
      v11 = (int *)(a3 + 4);
    v20 = *v11;
    if (a1)
    {
      v21 = *a1;
      unk_10015BF84 = *((_DWORD *)a1 + 4);
      unk_10015BF74 = v21;
    }
    else
    {
      dword_10015BF78 = 0;
    }
    if (a2)
    {
      v22 = *a2;
      dword_10015BF98 = *((_DWORD *)a2 + 4);
      unk_10015BF88 = v22;
    }
    else
    {
      qword_10015BF8C = 0;
      *(_QWORD *)&dword_10015BF94 = 0;
    }
    v23 = DWORD1(xmmword_10015BF60);
    if (a3)
    {
      v24 = *(_OWORD *)a3;
      dword_10015BF70 = *(_DWORD *)(a3 + 16);
      xmmword_10015BF60 = v24;
    }
    else
    {
      DWORD1(xmmword_10015BF60) = 0;
    }
    v25 = v18 == v19 && v23 == v20;
    v26 = !v25;
    v27 = !v25 || !v17;
    if (v27 == 1)
    {
      v56 = v26;
      if (mDNS_LoggingEnabled == 1)
      {
        v28 = "v4Changed ";
        if (v18 == v19)
          v28 = "";
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo: %s%s%s%#a %#a %#a", v6, v7, v8, v9, v10, (int)v28);
      }
      v55 = v18;
      for (i = xmmword_10015C720; i; i = *(_QWORD *)i)
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo updating host name registrations for %##s", v6, v7, v8, v9, v10, i + 208);
        if (*(unsigned __int8 *)(i + 472) >= 2u)
        {
          v30 = *(_QWORD *)(i + 512);
          v32 = *(_DWORD *)(v30 + 4);
          v31 = (unsigned __int16 *)(v30 + 4);
          if (v32 != dword_10015BF78)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v33 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 472), v31, word_100164580);
              LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo deregistering %s", v34, v35, v36, v37, v38, (int)word_100164580);
            }
            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 464, 0);
          }
        }
        if (*(unsigned __int8 *)(i + 1648) >= 2u)
        {
          v39 = *(_QWORD *)(i + 1688);
          if (*(_QWORD *)(v39 + 4) != qword_10015BF8C
            || *(_DWORD *)(v39 + 12) != dword_10015BF94
            || *(_DWORD *)(v39 + 16) != dword_10015BF98)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v40 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 1648), (unsigned __int16 *)(v39 + 4), word_100164580);
              LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo deregistering %s", v41, v42, v43, v44, v45, (int)word_100164580);
            }
            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 1640, 0);
          }
        }
        AdvertiseHostname((size_t)mDNSStorage, i);
      }
      if (v56)
      {
        if (a1)
          v46 = 0;
        else
          v46 = 5;
        dword_10015C760 = 0;
        *(_WORD *)((char *)mDNSStorage + &loc_1000039B8) = 0;
        RecreateNATMappings((uint64_t)mDNSStorage, 1000 * v46);
        for (j = (uint64_t *)xmmword_10015C748; j; j = (uint64_t *)*j)
          *((_DWORD *)j + 39) = 0;
        if (mDNS_LoggingEnabled == 1)
        {
          v53 = " v4Changed";
          if (v55 == v19)
            v53 = "";
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo:%s%s: recreating NAT mappings in %d seconds", v47, v48, v49, v50, v51, (int)v53);
        }
      }
      if (dword_10015C07C != -1)
        mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)mDNSStorage + &loc_1000031E0);
      *((_BYTE *)&dword_100158E08 + &loc_100003718) = 0;
      v54 = dword_100158E08;
      if (dword_100158E08 <= 1)
        v54 = 1;
      dword_10015BF54 = v54;
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_SetPrimaryInterfaceInfo", 2786);
}

uint64_t udsSupportAddFDToEventLoop(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  char *v11;
  void *v12;
  NSObject *v13;
  int v15;
  int *v16;
  char *v17;
  int v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char *v24;

  v6 = &gEventSources;
  do
  {
    v7 = *v6;
    if (!*v6)
    {
      v11 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0xF1748037uLL);
      if (!v11)
        __break(1u);
      v12 = v11;
      *(_QWORD *)v11 = 0;
      *((_DWORD *)v11 + 2) = a1;
      *((_QWORD *)v11 + 5) = a2;
      *((_QWORD *)v11 + 6) = a3;
      *((_QWORD *)v11 + 2) = kqUDSEventCallback;
      *((_QWORD *)v11 + 3) = v11;
      *((_QWORD *)v11 + 4) = "UDS client";
      if (!KQueueSet(a1, 1u, -1, v11 + 16))
      {
        v9 = 0;
        *v6 = (uint64_t)v12;
        return v9;
      }
      v13 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_22:
          v15 = *__error();
          v16 = __error();
          v17 = strerror(*v16);
          v19 = 67109634;
          v20 = a1;
          v21 = 1024;
          v22 = v15;
          v23 = 2082;
          v24 = v17;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "KQueueSet failed for fd %d errno %d (%{public}s)", (uint8_t *)&v19, 0x18u);
        }
      }
      else
      {
        v13 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_22;
      }
      free(v12);
      return 4294901756;
    }
    v6 = (uint64_t *)*v6;
  }
  while (*(_DWORD *)(v7 + 8) != a1);
  v8 = mDNSLogCategory_Default;
  v9 = 4294901749;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return v9;
    v19 = 67109120;
    v20 = a1;
    goto LABEL_19;
  }
  v8 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    v19 = 67109120;
    v20 = a1;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "udsSupportAddFDToEventLoop: ERROR fd %d already has EventLoop source entry", (uint8_t *)&v19, 8u);
  }
  return v9;
}

uint64_t mDNS_GetDomains(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Domains_Internal;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_GetDomains", 15966);
  Domains_Internal = mDNS_GetDomains_Internal((uint64_t)mDNSStorage, a1, a2, a3, a4, a5, a6);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_GetDomains", 15968);
  return Domains_Internal;
}

uint64_t mDNS_StartQuery(unsigned int *a1, uint64_t a2)
{
  uint64_t started;

  mDNS_Lock_(a1, (uint64_t)"mDNS_StartQuery", 15771);
  started = mDNS_StartQuery_internal(a1, a2);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_StartQuery", 15773);
  return started;
}

void RegisterLocalOnlyDomainEnumPTR(unsigned int *a1, _BYTE *a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  unsigned __int16 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v6 = malloc_type_calloc(1uLL, 0x4A0uLL, 0xF1748037uLL);
  if (v6)
  {
    v7 = v6;
    v8 = (uint64_t)(v6 + 1);
    mDNS_SetupResourceRecord((uint64_t)(v6 + 1), 0, -2, 12, 0x1C20u, 8, 4, (uint64_t)FreeARElemCallback_2558, (uint64_t)v6);
    v9 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
    *((_BYTE *)v7 + 660) = 0;
    AppendDNSNameString((_BYTE *)v7 + 660, v9, v10, v11, v12, v13, v14, v15);
    AppendDNSNameString((_BYTE *)v7 + 660, "local", v16, v17, v18, v19, v20, v21);
    v22 = a2;
    if (a2 == (_BYTE *)-256)
    {
LABEL_4:
      while (v22)
      {
        v23 = *v22;
        if (v23 > 0x3F)
          break;
        if (!*v22)
        {
          v24 = (_WORD)v22 - (_WORD)a2 + 1;
          if (v24 > 0x100u)
            break;
          memcpy((void *)(v7[7] + 4), a2, v24);
          goto LABEL_12;
        }
        v22 += v23 + 1;
        if (a2 != (_BYTE *)-256)
          goto LABEL_3;
      }
    }
    else
    {
LABEL_3:
      if (v22 < a2 + 256)
        goto LABEL_4;
    }
    *(_BYTE *)(v7[7] + 4) = 0;
LABEL_12:
    v25 = mDNS_Register(a1, v8);
    if (v25)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetSCPrefsBrowseDomain: mDNS_Register returned error %d", v26, v27, v28, v29, v30, v25);
      free(v7);
    }
    else
    {
      *v7 = LocalDomainEnumRecords;
      LocalDomainEnumRecords = (uint64_t)v7;
    }
  }
  else
  {
    __break(1u);
  }
}

size_t mDNS_Register(unsigned int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;

  mDNS_Lock_(a1, (uint64_t)"mDNS_Register", 16289);
  v10 = mDNS_Register_internal((uint64_t)a1, a2, v4, v5, v6, v7, v8, v9);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Register", 16291);
  return v10;
}

void AddAutoBrowseDomain(int a1, char *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unsigned __int16 v10;
  NSObject *v11;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  int v32;

  v4 = AutoBrowseDomains;
  if (!AutoBrowseDomains)
  {
LABEL_5:
    v5 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
    if (!v5)
      __break(1u);
    v6 = (uint64_t)v5;
    v7 = a2 + 256;
    v8 = a2;
    if (a2 == (char *)-256)
    {
LABEL_8:
      while (v8)
      {
        v9 = *v8;
        if (v9 > 0x3F)
          break;
        if (!*v8)
        {
          v10 = (_WORD)v8 - (_WORD)a2 + 1;
          if (v10 > 0x100u)
            break;
          memcpy(v5 + 12, a2, v10);
          goto LABEL_16;
        }
        v8 += v9 + 1;
        if (a2 != (char *)-256)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      if (v8 < v7)
        goto LABEL_8;
    }
    v5[12] = 0;
LABEL_16:
    *(_DWORD *)(v6 + 8) = a1;
    *(_QWORD *)v6 = AutoBrowseDomains;
    AutoBrowseDomains = v6;
    v11 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_51:
        udsserver_automatic_browse_domain_changed(v6, 1, v17, v18, v19, v20, v21, v22);
        return;
      }
      if (a2)
      {
        v13 = a2;
        if (a2 == (char *)-256)
          goto LABEL_27;
LABEL_24:
        v14 = 257;
        if (v13 < v7 && v13)
        {
          while (1)
          {
            v15 = *v13;
            if (v15 > 0x3F)
            {
LABEL_45:
              v14 = 257;
              goto LABEL_50;
            }
            if (!*v13)
              break;
            v13 += v15 + 1;
            if (a2 != (char *)-256)
              goto LABEL_24;
LABEL_27:
            if (!v13)
              goto LABEL_45;
          }
          v14 = (unsigned __int16)((_WORD)v13 - (_WORD)a2 + 1);
        }
      }
      else
      {
        v14 = 0;
      }
    }
    else
    {
      v11 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_51;
      if (a2)
      {
        v23 = a2;
        if (a2 == (char *)-256)
          goto LABEL_38;
LABEL_35:
        v14 = 257;
        if (v23 < v7 && v23)
        {
          while (1)
          {
            v24 = *v23;
            if (v24 > 0x3F)
            {
LABEL_46:
              v14 = 257;
              goto LABEL_50;
            }
            if (!*v23)
              break;
            v23 += v24 + 1;
            if (a2 != (char *)-256)
              goto LABEL_35;
LABEL_38:
            if (!v23)
              goto LABEL_46;
          }
          v14 = (unsigned __int16)((_WORD)v23 - (_WORD)a2 + 1);
        }
      }
      else
      {
        v14 = 0;
      }
    }
LABEL_50:
    v25 = 141558787;
    v26 = 1752392040;
    v27 = 1040;
    v28 = v14;
    v29 = 2101;
    v30 = a2;
    v31 = 1024;
    v32 = a1;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain is added - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u", (uint8_t *)&v25, 0x22u);
    goto LABEL_51;
  }
  while (!SameDomainNameBytes(a2, (_BYTE *)(v4 + 12)) || *(_DWORD *)(v4 + 8) != a1)
  {
    v4 = *(_QWORD *)v4;
    if (!v4)
      goto LABEL_5;
  }
}

void udsserver_automatic_browse_domain_changed(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _BYTE *v11;
  int *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  int v23;
  unsigned int v24;
  BOOL v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  BOOL v29;
  uint64_t v30;
  BOOL v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  BOOL v36;
  NSObject *v37;
  _BYTE *v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  _BYTE *v44;
  uint64_t v45;
  _BYTE *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _BYTE *v56;
  uint64_t v57;
  unsigned __int16 v58;
  unsigned __int16 v59;
  unsigned __int16 v60;
  const char *v61;
  NSObject *v62;
  int v63;
  const char *v64;
  int v65;
  const char *v66;
  uint64_t i;
  void (*v68)(uint64_t *, _QWORD *, uint64_t, _QWORD);
  unsigned int v69;
  int v70;
  unsigned int log;
  os_log_t loga;
  uint64_t *v73;
  uint8_t buf[4];
  _BYTE v75[14];
  __int16 v76;
  _BYTE v77[24];

  v8 = all_requests;
  if (all_requests)
  {
    v11 = (_BYTE *)(a1 + 12);
    v12 = &g_current_state;
    while (1)
    {
      if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 104) != browse_termination_callback)
        goto LABEL_4;
      v13 = *(_QWORD *)(v8 + 144);
      if (!*(_BYTE *)(v13 + 8))
        goto LABEL_4;
      v14 = *(_DWORD *)(a1 + 8);
      if (v14)
      {
        v15 = *(_DWORD *)(v8 + 188);
        if (v15 >= 0x1F5 && v15 != v14)
          goto LABEL_4;
      }
      v17 = (_QWORD *)(v13 + 272);
      v18 = *(_QWORD *)(v13 + 272);
      if (v18)
      {
        while (1)
        {
          v19 = SameDomainNameBytes((_BYTE *)(v18 + 8), v11);
          v20 = (_QWORD *)*v17;
          if (v19)
            break;
          v18 = *v20;
          v17 = (_QWORD *)*v17;
          if (!*v20)
          {
            v21 = 0;
            v17 = v20;
            if (a2)
              goto LABEL_19;
            goto LABEL_22;
          }
        }
        v21 = (_QWORD *)*v17;
        if (a2)
          goto LABEL_19;
      }
      else
      {
        v21 = 0;
        if (a2)
        {
LABEL_19:
          if (!v21)
            add_domain_to_browser(v8, v11);
          goto LABEL_4;
        }
      }
LABEL_22:
      if (!v21)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_automatic_browse_domain_changed ERROR %##s not found", a4, a5, a6, a7, a8, (int)v11);
        goto LABEL_4;
      }
      v22 = (uint64_t *)*((_QWORD *)v12 + 20);
      if (v22)
      {
        while (1)
        {
          v23 = *((_DWORD *)v22 + 2);
          if (!v23 || ((v24 = *(_DWORD *)(v8 + 188), v24 >= 0x1F5) ? (v25 = v24 == v23) : (v25 = 1), v25))
          {
            if (SameDomainNameBytes(v11, (_BYTE *)v22 + 12))
              goto LABEL_4;
          }
          v22 = (uint64_t *)*v22;
          if (!v22)
          {
            v21 = (_QWORD *)*v17;
            break;
          }
        }
      }
      *v17 = *v21;
      v26 = v21 + 33;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15818);
      v27 = (_QWORD *)&xmmword_100158E88 + 1;
      do
      {
        v28 = (_QWORD *)*v27;
        v27 = (_QWORD *)(*v27 + 8);
        if (v28)
          v29 = v28 == v26;
        else
          v29 = 1;
      }
      while (!v29);
      v30 = v21[50];
      v32 = v30 == -5 || v30 == -3 || v30 == -2;
      v33 = 24;
      if (v32)
        v33 = 27;
      v34 = &mDNSStorage[v33];
      do
      {
        v35 = *v34;
        v34 = (uint64_t *)(*v34 + 8);
        if (v35)
          v36 = v35 == (_QWORD)v26;
        else
          v36 = 1;
      }
      while (!v36);
      if (v35)
        break;
      v12 = &g_current_state;
      if ((*((_DWORD *)v21 + 119) & 0x80000000) != 0)
        goto LABEL_57;
      v37 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
          goto LABEL_57;
        v39 = v21 + 80;
        if (v21 == (_QWORD *)-896)
        {
LABEL_68:
          while (v39)
          {
            v40 = *v39;
            if (v40 > 0x3F)
              break;
            if (!*v39)
            {
              v58 = (_WORD)v39 - ((_WORD)v21 + 640) + 1;
              goto LABEL_110;
            }
            v39 += v40 + 1;
            if (v21 != (_QWORD *)-896)
              goto LABEL_67;
          }
        }
        else
        {
LABEL_67:
          if (v39 < (_BYTE *)v21 + 896)
            goto LABEL_68;
        }
        v58 = 257;
      }
      else
      {
        v37 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
          goto LABEL_57;
        v47 = v21 + 80;
        if (v21 == (_QWORD *)-896)
        {
LABEL_89:
          while (v47)
          {
            v48 = *v47;
            if (v48 > 0x3F)
              break;
            if (!*v47)
            {
              v58 = (_WORD)v47 - ((_WORD)v21 + 640) + 1;
              goto LABEL_110;
            }
            v47 += v48 + 1;
            if (v21 != (_QWORD *)-896)
              goto LABEL_88;
          }
        }
        else
        {
LABEL_88:
          if (v47 < (_BYTE *)v21 + 896)
            goto LABEL_89;
        }
        v58 = 257;
      }
LABEL_110:
      v63 = v58;
      v64 = DNSTypeName(*((unsigned __int16 *)v21 + 303));
      *(_DWORD *)buf = 141558787;
      *(_QWORD *)v75 = 1752392040;
      *(_WORD *)&v75[8] = 1040;
      *(_DWORD *)&v75[10] = v63;
      v76 = 2101;
      *(_QWORD *)v77 = v21 + 80;
      *(_WORD *)&v77[8] = 2082;
      *(_QWORD *)&v77[10] = v64;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Question not found in the active list - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s.", buf, 0x26u);
LABEL_56:
      v12 = &g_current_state;
LABEL_57:
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15855);
      free(v21);
LABEL_4:
      v8 = *(_QWORD *)(v8 + 16);
      if (!v8)
        return;
    }
    if (v28)
    {
LABEL_55:
      mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)(v21 + 33));
      goto LABEL_56;
    }
    v41 = (_WORD)v21 + 640;
    v73 = CacheGroupForName((uint64_t)mDNSStorage, *((_DWORD *)v21 + 116), (_BYTE *)v21 + 640);
    v42 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        log = bswap32(*((unsigned __int16 *)v21 + 302)) >> 16;
        v44 = v21 + 80;
        if (v21 == (_QWORD *)-896)
        {
LABEL_81:
          while (v44)
          {
            v45 = *v44;
            if (v45 > 0x3F)
              break;
            if (!*v44)
            {
              v59 = (_WORD)v44 - v41 + 1;
              goto LABEL_108;
            }
            v44 += v45 + 1;
            if (v21 != (_QWORD *)-896)
              goto LABEL_80;
          }
        }
        else
        {
LABEL_80:
          if (v44 < (_BYTE *)v21 + 896)
            goto LABEL_81;
        }
        v59 = 257;
LABEL_108:
        v70 = v59;
        v61 = DNSTypeName(*((unsigned __int16 *)v21 + 303));
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)v75 = log;
        *(_WORD *)&v75[4] = 2160;
        *(_QWORD *)&v75[6] = 1752392040;
        v76 = 1040;
        *(_DWORD *)v77 = v70;
        *(_WORD *)&v77[4] = 2101;
        *(_QWORD *)&v77[6] = v21 + 80;
        *(_WORD *)&v77[14] = 2082;
        *(_QWORD *)&v77[16] = v61;
        v62 = v42;
        goto LABEL_113;
      }
    }
    else
    {
      v49 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v69 = bswap32(*((unsigned __int16 *)v21 + 302)) >> 16;
        v56 = v21 + 80;
        loga = (os_log_t)v49;
        if (v21 == (_QWORD *)-896)
        {
LABEL_97:
          while (v56)
          {
            v57 = *v56;
            if (v57 > 0x3F)
              break;
            if (!*v56)
            {
              v60 = (_WORD)v56 - v41 + 1;
              goto LABEL_112;
            }
            v56 += v57 + 1;
            if (v21 != (_QWORD *)-896)
              goto LABEL_96;
          }
        }
        else
        {
LABEL_96:
          if (v56 < (_BYTE *)v21 + 896)
            goto LABEL_97;
        }
        v60 = 257;
LABEL_112:
        v65 = v60;
        v66 = DNSTypeName(*((unsigned __int16 *)v21 + 303));
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)v75 = v69;
        *(_WORD *)&v75[4] = 2160;
        *(_QWORD *)&v75[6] = 1752392040;
        v76 = 1040;
        *(_DWORD *)v77 = v65;
        *(_WORD *)&v77[4] = 2101;
        *(_QWORD *)&v77[6] = v21 + 80;
        *(_WORD *)&v77[14] = 2082;
        *(_QWORD *)&v77[16] = v66;
        v62 = loga;
LABEL_113:
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "[Q%u] Generating RMV events because the question will be stopped - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s.", buf, 0x2Cu);
      }
    }
    if (v73)
    {
      for (i = v73[2]; i; i = *(_QWORD *)i)
      {
        if (*(unsigned __int8 *)(i + 8) != 240
          && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, (uint64_t)(v21 + 33), v51, v52, v53, v54, v55))
        {
          v68 = (void (*)(uint64_t *, _QWORD *, uint64_t, _QWORD))v21[52];
          if (v68)
            v68(mDNSStorage, v21 + 33, i + 8, 0);
        }
      }
    }
    goto LABEL_55;
  }
}

void udsserver_handle_configchange(size_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  size_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t *i;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *j;
  _BYTE *v20;
  void **v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t *v39;
  uint64_t *v40;

  v39 = 0;
  v40 = 0;
  UpdateDeviceInfoRecord(a1);
  v7 = all_requests;
  if (all_requests)
  {
    v8 = (unsigned __int8 *)(a1 + 10280);
    do
    {
      if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v7 + 104) == regservice_termination_callback)
      {
        v9 = *(_QWORD *)(v7 + 120);
        if (*(_BYTE *)(v9 + 1612))
        {
          v10 = *(unsigned __int8 *)(v9 + 26);
          if ((_DWORD)v10 != *v8 || memcmp((const void *)(v9 + 27), (const void *)(a1 + 10281), v10))
          {
            v11 = *(_OWORD *)v8;
            v12 = *(_OWORD *)(a1 + 10296);
            v13 = *(_OWORD *)(a1 + 10328);
            *(_OWORD *)(v9 + 58) = *(_OWORD *)(a1 + 10312);
            *(_OWORD *)(v9 + 74) = v13;
            *(_OWORD *)(v9 + 26) = v11;
            *(_OWORD *)(v9 + 42) = v12;
            for (i = *(uint64_t **)(v9 + 1624); i; i = (uint64_t *)*i)
            {
              *((_BYTE *)i + 24) = 1;
              if (*((_BYTE *)i + 25))
                SendServiceRemovalNotification((uint64_t)(i + 36));
              if (mDNS_LoggingEnabled == 1)
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_handle_configchange: Calling deregister for Service %##s", v2, v3, v4, v5, v6, i[195]);
              if (mDNS_DeregisterService_drt((unsigned int *)a1, (uint64_t)(i + 36), 1, v2, v3, v4, v5, v6))regservice_callback(a1, (uint64_t)(i + 36), 0xFFFEFF00, v2, v3, v4, v5, v6);
            }
          }
        }
      }
      v7 = *(_QWORD *)(v7 + 16);
    }
    while (v7);
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"udsserver_handle_configchange", 3851);
  mDNSPlatformSetDNSConfig(0, 0, 0, &v40, &v39, 0);
  mDNS_Unlock_(a1, (uint64_t)"udsserver_handle_configchange", 3853);
  if (v40)
    SetPrefsBrowseDomains((unsigned int *)a1, v40, 1);
  if (AutoRegistrationDomains)
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)AutoRegistrationDomains, 0);
  for (j = v40; j; j = (uint64_t *)*j)
  {
    v20 = (_BYTE *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains)
      goto LABEL_28;
    v21 = (void **)&AutoRegistrationDomains;
    while (1)
    {
      if (*((_DWORD *)v20 + 2) == *((_DWORD *)j + 2))
      {
        v22 = SameDomainNameBytes(v20 + 12, (_BYTE *)j + 12);
        v20 = *v21;
        if (v22)
          break;
      }
      v21 = (void **)v20;
      v20 = *(_BYTE **)v20;
      if (!v20)
        goto LABEL_28;
    }
    if (v20)
    {
      *v21 = *(void **)v20;
      free(v20);
    }
    else
    {
LABEL_28:
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, (_BYTE *)j + 12, 3);
      udsserver_default_reg_domain_changed((uint64_t)j, 1, v23, v24, v25, v26, v27, v28);
    }
  }
  while (1)
  {
    v36 = (void *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains)
      break;
    v29 = (_BYTE *)(AutoRegistrationDomains + 12);
    AutoRegistrationDomains = *(_QWORD *)AutoRegistrationDomains;
    DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v29, 3, 0, v15, v16, v17, v18);
    udsserver_default_reg_domain_changed((uint64_t)v36, 0, v30, v31, v32, v33, v34, v35);
    free(v36);
  }
  AutoRegistrationDomains = (uint64_t)v40;
  if (v39)
    SetPrefsBrowseDomains((unsigned int *)a1, v39, 1);
  if (SCPrefBrowseDomains)
  {
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)SCPrefBrowseDomains, 0);
    v37 = (_QWORD *)SCPrefBrowseDomains;
    if (SCPrefBrowseDomains)
    {
      do
      {
        v38 = (_QWORD *)*v37;
        free(v37);
        v37 = v38;
      }
      while (v38);
    }
  }
  SCPrefBrowseDomains = (uint64_t)v39;
}

size_t UpdateDeviceInfoRecord(size_t result)
{
  size_t v1;
  size_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned __int8 *v6;
  size_t v7;
  NSObject *v8;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  size_t v20;
  NSObject *v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  _BYTE *v25;
  uint64_t v26;
  int v27;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;

  v1 = result;
  v2 = result + 11448;
  v3 = all_requests;
  if (!all_requests)
  {
    if (!*(_BYTE *)v2)
      return result;
    v4 = 0;
    v5 = result + 11440;
    goto LABEL_15;
  }
  v4 = 0;
  do
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v3 + 104) == regservice_termination_callback
      && *(_BYTE *)(*(_QWORD *)(v3 + 120) + 1612)
      && *(_DWORD *)(v3 + 244) != -1)
    {
      ++v4;
    }
    v3 = *(_QWORD *)(v3 + 16);
  }
  while (v3);
  v5 = result + 11440;
  if (!*(_BYTE *)v2)
    goto LABEL_47;
  if (!v4
    || (v6 = *(unsigned __int8 **)(result + 11480), v7 = *v6, (_DWORD)v7 != *(unsigned __int8 *)(result + 10280))
    || (result = memcmp(v6 + 1, (const void *)(result + 10281), v7), (_DWORD)result))
  {
LABEL_15:
    v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_46;
      v10 = *(_QWORD *)(v1 + 11480);
      if (v10)
      {
        v11 = *(_BYTE **)(v1 + 11480);
        if (v10 == -256)
        {
LABEL_24:
          while (v11)
          {
            v12 = *v11;
            if (v12 > 0x3F)
              break;
            if (!*v11)
            {
              v16 = (unsigned __int16)((_WORD)v11 - v10 + 1);
              goto LABEL_45;
            }
            v11 += v12 + 1;
            if (v10 != -256)
              goto LABEL_23;
          }
        }
        else
        {
LABEL_23:
          if ((unint64_t)v11 < v10 + 256)
            goto LABEL_24;
        }
        v16 = 257;
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_46:
        result = mDNS_Deregister((unsigned int *)v1, v5);
        if (*(_BYTE *)v2)
          return result;
LABEL_47:
        if (v4 < 1)
          return result;
        mDNS_SetupResourceRecord(v5, 0, 0, 16, 0x1194u, 4, 0, 0, 0);
        ConstructServiceName((_BYTE *)(v1 + 12092), (const char *)(v1 + 10280), "\f_device-info\x04_tcp", "\x05local");
        v17 = *(_QWORD *)(v1 + 11488);
        if (*(unsigned __int8 *)(v1 + 10928) >= 0xDBu)
          v18 = 219;
        else
          v18 = *(unsigned __int8 *)(v1 + 10928);
        *(_BYTE *)(v17 + 4) = v18 + 6;
        v19 = v17 + 4;
        *(_DWORD *)(v19 + 1) = 1701080941;
        *(_WORD *)(v19 + 5) = 15724;
        memcpy((void *)(v19 + 7), (const void *)(v1 + 10929), v18);
        v20 = v19 + 7 + v18;
        if (OSXVers)
        {
          buf[2] = 0;
          *(_WORD *)buf = 0;
          *(_BYTE *)v20 = 10;
          *(_QWORD *)(v20 + 1) = 0x3D7372657678736FLL;
          snprintf((char *)buf, 3uLL, "%d", OSXVers);
          *(_WORD *)(v20 + 9) = *(_WORD *)buf;
          LOWORD(v20) = v20 + 11;
        }
        *(_WORD *)(v2 + 12) = v20 - v19;
        v21 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(_QWORD *)(v1 + 11480);
            if (v22)
            {
              v25 = *(_BYTE **)(v1 + 11480);
              if (v22 == -256)
              {
LABEL_68:
                while (v25)
                {
                  v26 = *v25;
                  if (v26 > 0x3F)
                    break;
                  if (!*v25)
                  {
                    v27 = (unsigned __int16)((_WORD)v25 - v22 + 1);
                    goto LABEL_79;
                  }
                  v25 += v26 + 1;
                  if (v22 != -256)
                    goto LABEL_67;
                }
              }
              else
              {
LABEL_67:
                if ((unint64_t)v25 < v22 + 256)
                  goto LABEL_68;
              }
              v27 = 257;
            }
            else
            {
              v27 = 0;
            }
            goto LABEL_79;
          }
        }
        else
        {
          v21 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(_QWORD *)(v1 + 11480);
            if (v22)
            {
              v23 = *(_BYTE **)(v1 + 11480);
              if (v22 == -256)
              {
LABEL_59:
                while (v23)
                {
                  v24 = *v23;
                  if (v24 > 0x3F)
                    break;
                  if (!*v23)
                  {
                    v27 = (unsigned __int16)((_WORD)v23 - v22 + 1);
                    goto LABEL_79;
                  }
                  v23 += v24 + 1;
                  if (v22 != -256)
                    goto LABEL_58;
                }
              }
              else
              {
LABEL_58:
                if ((unint64_t)v23 < v22 + 256)
                  goto LABEL_59;
              }
              v27 = 257;
            }
            else
            {
              v27 = 0;
            }
LABEL_79:
            *(_DWORD *)buf = 141558531;
            v29 = 1752392040;
            v30 = 1040;
            v31 = v27;
            v32 = 2101;
            v33 = v22;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "UpdateDeviceInfoRecord Register %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
          }
        }
        return mDNS_Register((unsigned int *)v1, v5);
      }
      v10 = *(_QWORD *)(v1 + 11480);
      if (v10)
      {
        v14 = *(_BYTE **)(v1 + 11480);
        if (v10 == -256)
        {
LABEL_33:
          while (v14)
          {
            v15 = *v14;
            if (v15 > 0x3F)
              break;
            if (!*v14)
            {
              v16 = (unsigned __int16)((_WORD)v14 - v10 + 1);
              goto LABEL_45;
            }
            v14 += v15 + 1;
            if (v10 != -256)
              goto LABEL_32;
          }
        }
        else
        {
LABEL_32:
          if ((unint64_t)v14 < v10 + 256)
            goto LABEL_33;
        }
        v16 = 257;
      }
      else
      {
        v16 = 0;
      }
    }
LABEL_45:
    *(_DWORD *)buf = 141558531;
    v29 = 1752392040;
    v30 = 1040;
    v31 = v16;
    v32 = 2101;
    v33 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "UpdateDeviceInfoRecord Deregister %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
    goto LABEL_46;
  }
  return result;
}

_DWORD *AppendDNameListElem(_QWORD **a1, _BYTE *a2)
{
  _DWORD *result;
  _QWORD *v5;
  _BYTE *v6;
  uint64_t v7;
  unsigned __int16 v8;

  result = malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
  if (result)
  {
    v5 = result;
    *(_QWORD *)result = 0;
    result[2] = 0;
    v6 = a2;
    if (a2 == (_BYTE *)-256)
    {
LABEL_4:
      while (v6)
      {
        v7 = *v6;
        if (v7 > 0x3F)
          break;
        if (!*v6)
        {
          v8 = (_WORD)v6 - (_WORD)a2 + 1;
          result += 3;
          if (v8 > 0x100u)
            goto LABEL_10;
          result = (_DWORD *)__memcpy_chk(result, a2, v8, 260);
          goto LABEL_11;
        }
        v6 += v7 + 1;
        if (a2 != (_BYTE *)-256)
          goto LABEL_3;
      }
    }
    else
    {
LABEL_3:
      if (v6 < a2 + 256)
        goto LABEL_4;
    }
    result += 3;
LABEL_10:
    *(_BYTE *)result = 0;
LABEL_11:
    **a1 = v5;
    *a1 = v5;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void SetPrefsBrowseDomains(unsigned int *a1, uint64_t *a2, int a3)
{
  const char *v6;
  NSObject *v7;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  unsigned __int16 v18;
  int v19;
  _BYTE *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  const char *v38;

  if (a3)
    v6 = "add";
  else
    v6 = "remove";
  do
  {
    v7 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
      v9 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268)
      {
LABEL_12:
        while (v9)
        {
          v10 = *v9;
          if (v10 > 0x3F)
            break;
          if (!*v9)
          {
            v18 = (_WORD)v9 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }
          v9 += v10 + 1;
          if (a2 != (uint64_t *)-268)
            goto LABEL_11;
        }
      }
      else
      {
LABEL_11:
        if (v9 < (_BYTE *)a2 + 268)
          goto LABEL_12;
      }
      v18 = 257;
    }
    else
    {
      v7 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
      v16 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268)
      {
LABEL_20:
        while (v16)
        {
          v17 = *v16;
          if (v17 > 0x3F)
            break;
          if (!*v16)
          {
            v18 = (_WORD)v16 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }
          v16 += v17 + 1;
          if (a2 != (uint64_t *)-268)
            goto LABEL_19;
        }
      }
      else
      {
LABEL_19:
        if (v16 < (_BYTE *)a2 + 268)
          goto LABEL_20;
      }
      v18 = 257;
    }
LABEL_29:
    v19 = *((_DWORD *)a2 + 2);
    *(_DWORD *)buf = 141559043;
    v30 = 1752392040;
    v31 = 1040;
    v32 = v18;
    v33 = 2101;
    v34 = (uint64_t)a2 + 12;
    v35 = 1024;
    v36 = v19;
    v37 = 2082;
    v38 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetPrefsBrowseDomains is adding/removing domain for Browsing and Automatic Browsing domains - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u, result: %{public}s", buf, 0x2Cu);
LABEL_30:
    v20 = (char *)a2 + 12;
    if (a3)
    {
      RegisterLocalOnlyDomainEnumPTR(a1, v20, 0);
      v21 = *((_DWORD *)a2 + 2);
      if (v21)
        AddAutoBrowseDomain(v21, (char *)a2 + 12);
      else
        RegisterLocalOnlyDomainEnumPTR(a1, (_BYTE *)a2 + 12, 2);
    }
    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal(a1, v20, 0, 0, v12, v13, v14, v15);
      v28 = *((_DWORD *)a2 + 2);
      if (v28)
        RmvAutoBrowseDomain(v28, (_BYTE *)a2 + 12, v22, v23, v24, v25, v26, v27);
      else
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (_BYTE *)a2 + 12, 2, 0, v24, v25, v26, v27);
    }
    a2 = (uint64_t *)*a2;
  }
  while (a2);
}

void udsserver_default_reg_domain_changed(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  int v18;
  unsigned int v19;
  BOOL v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  BOOL v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v10 = "Adding";
  if (!a2)
    v10 = "Removing";
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s registration domain %##s", a4, a5, a6, a7, a8, (int)v10);
  for (i = all_requests; i; i = *(_QWORD *)(i + 16))
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(i + 104) == regservice_termination_callback)
    {
      v17 = *(_QWORD *)(i + 120);
      if (*(_BYTE *)(v17 + 1355))
      {
        v18 = *(_DWORD *)(a1 + 8);
        if (!v18 || ((v19 = *(_DWORD *)(i + 188), v19 >= 0x1F5) ? (v20 = v19 == v18) : (v20 = 1), v20))
        {
          v21 = (_QWORD *)(v17 + 1624);
          v22 = *(_QWORD *)(v17 + 1624);
          if (v22)
          {
            while (1)
            {
              v23 = SameDomainNameBytes((_BYTE *)(v22 + 28), (_BYTE *)(a1 + 12));
              v24 = (_QWORD *)*v21;
              if (v23)
                break;
              v22 = *v24;
              v21 = (_QWORD *)*v21;
              if (!*v24)
              {
                v25 = 0;
                v21 = v24;
                if (a2)
                  goto LABEL_20;
                goto LABEL_23;
              }
            }
            v25 = (_QWORD *)*v21;
            if (a2)
              goto LABEL_20;
LABEL_23:
            if (v25)
            {
              v26 = AutoRegistrationDomains;
              if (AutoRegistrationDomains)
              {
                while (1)
                {
                  v27 = *(_DWORD *)(v26 + 8);
                  if (!v27 || ((v28 = *(_DWORD *)(i + 188), v28 >= 0x1F5) ? (v29 = v28 == v27) : (v29 = 1), v29))
                  {
                    if (SameDomainNameBytes((_BYTE *)(a1 + 12), (_BYTE *)(v26 + 12)))
                      break;
                  }
                  v26 = *(_QWORD *)v26;
                  if (!v26)
                  {
                    v25 = (_QWORD *)*v21;
                    goto LABEL_34;
                  }
                }
              }
              else
              {
LABEL_34:
                *v21 = *v25;
                if (*((_BYTE *)v25 + 25))
                  SendServiceRemovalNotification((uint64_t)(v25 + 36));
                v25[1] = 0;
                v30 = mDNS_DeregisterService_drt((unsigned int *)mDNSStorage, (uint64_t)(v25 + 36), 0, v11, v12, v13, v14, v15);
                if (v30)
                {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_default_reg_domain_changed err %d", v11, v12, v13, v14, v15, v30);
                  unlink_and_free_service_instance(v25, v31, v32, v33, v34, v35, v36, v37);
                }
              }
            }
            else
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_default_reg_domain_changed domain %##s not found for service %#s type %s", v11, v12, v13, v14, v15, a1 + 12);
            }
            continue;
          }
          v25 = 0;
          if (!a2)
            goto LABEL_23;
LABEL_20:
          if (!v25)
            register_service_instance(i, (_BYTE *)(a1 + 12));
        }
      }
    }
  }
}

void mDNSMacOSXNetworkChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t IfAddrs;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 *v20;
  __int128 v21;
  NSObject *v22;
  int v23;
  uint64_t i;
  int v25;
  const __SCDynamicStore *v26;
  const __SCDynamicStore *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFNumber *Value;
  NSObject *v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  NSObject **v49;
  _QWORD *v50;
  void *v51;
  NSObject *v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  NSObject **v56;
  xpc_object_t v57;
  void *v58;
  _QWORD *v59;
  _xpc_connection_s *mach_service;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  NSObject *v70;
  int v71;
  uint8_t buf[16];
  _OWORD v73[2];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE aBlock[32];
  void *v90;
  NSObject *v91;

  if (dword_100158DD0)
  {
    v8 = mDNS_TimeNow(mDNSStorage, a2, a3, a4, a5, a6, a7, a8);
    v9 = dword_100158DD0;
    v10 = v8 - dword_100158DD0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v11 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v9;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** -- network changed: %{mdns:yesno}d, delay: %d ticks", buf, 0xEu);
  }
  dword_100158DD0 = 0;
  v12 = socket(30, 2, 0);
  if (v12 < 1)
    goto LABEL_21;
  v13 = v12;
  IfAddrs = myGetIfAddrs();
  if (!IfAddrs)
  {
LABEL_19:
    close(v13);
    v22 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change ***  No IPv6 address TENTATIVE, will continue", buf, 2u);
    }
LABEL_21:
    v23 = time(0);
    SystemWakeForNetworkAccess();
    *(_WORD *)((char *)&dword_100158E54 + 3) = 0;
    for (i = *(_QWORD *)mDNSStorage[0]; i; i = *(_QWORD *)(i + 3680))
    {
      if (*(_BYTE *)(i + 3696))
        *(_DWORD *)(i + 3704) = v23;
      *(_BYTE *)(i + 3696) = 0;
    }
    UpdateInterfaceList(v23);
    ClearInactiveInterfaces(v23);
    SetupActiveInterfaces(v23);
    v25 = OfferSleepProxyService;
    if (OfferSleepProxyService)
    {
      *(_DWORD *)buf = -1;
      v26 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:GetSystemSleepTimerSetting"), 0, 0);
      if (v26)
      {
        v27 = v26;
        v28 = (const __CFDictionary *)SCDynamicStoreCopyValue(v26, CFSTR("State:/IOKit/PowerManagement/CurrentSettings"));
        if (v28)
        {
          v29 = v28;
          Value = (const __CFNumber *)CFDictionaryGetValue(v28, CFSTR("System Sleep Timer"));
          if (Value)
            CFNumberGetValue(Value, kCFNumberSInt32Type, buf);
          CFRelease(v29);
        }
        CFRelease(v27);
        if (*(_DWORD *)buf)
          v25 = 0;
        else
          v25 = 80;
      }
      else
      {
        v31 = mDNSLogCategory_Default;
        v32 = SCError();
        v33 = SCErrorString(v32);
        LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "GetSystemSleepTimerSetting: SCDynamicStoreCreate failed: %s", v34, v35, v36, v37, v38, v33);
        v25 = 0;
      }
    }
    if (SPMetricMarginalPower <= 0x3Cu && v25 == 0)
      v25 = 70;
    if (OfferSleepProxyService >= 100 || OfferSleepProxyService == 0 || v25 == 0)
      v42 = v25;
    else
      v42 = OfferSleepProxyService;
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SetSPS", 5941);
    mDNSCoreBeSleepProxyServer_internal((uint64_t)mDNSStorage, v42, SPMetricPortability, SPMetricMarginalPower, SPMetricTotalPower, 1u);
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SetSPS", 5941);
    v48 = *(_QWORD *)mDNSStorage[0];
    if (!*(_QWORD *)mDNSStorage[0])
    {
LABEL_79:
      uDNS_SetupDNSConfig();
      v62 = mDNS_ConfigChanged((uint64_t)mDNSStorage);
      if (mDNS_McastTracingEnabled)
      {
        mDNS_McastTracingEnabled = 0;
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXNetworkChanged: Multicast Tracing %s", v65, v66, v67, v68, v69, (int)"Disabled");
        UpdateDebugState(v62, v63, v64, v65, v66, v67, v68, v69, v71);
      }
      return;
    }
    v49 = (NSObject **)&unk_100164000;
    v50 = &unk_100150000;
    v51 = &unk_100150000;
    while (1)
    {
      if (!*((_QWORD *)&xmmword_10015C8D0 + 1))
      {
        if ((*(_DWORD *)(v48 + 3732) & 0x80000000) == 0
          && !CountProxyTargets(v48, 0, 0, v43, v44, v45, v46, v47))
        {
          CloseBPF(v48, v54, v55, v43, v44, v45, v46, v47);
        }
        goto LABEL_68;
      }
      if (*(_BYTE *)(v48 + 3696)
        && *(_QWORD *)(v48 + 3776) == v48
        && *(_BYTE *)(v48 + 3671)
        && (*(_BYTE *)(v48 + 3712) & 8) == 0
        && !*(_BYTE *)(v48 + 3699)
        && *(_DWORD *)(v48 + 3732) == -1)
      {
        break;
      }
LABEL_68:
      v48 = *(_QWORD *)(v48 + 3680);
      if (!v48)
        goto LABEL_79;
    }
    LogMsgWithLevel(v49[295], OS_LOG_TYPE_DEFAULT, "%s mDNSMacOSXNetworkChanged: requesting BPF", v43, v44, v45, v46, v47, v48 + 3606);
    *(_DWORD *)(v48 + 3732) = -2;
    if (v50[134] != -1)
      dispatch_once(&mDNSMacOSXNetworkChanged_once, &__block_literal_global_3541);
    v52 = *((_QWORD *)v51 + 135);
    v53 = v49[295];
    if (gSensitiveLoggingEnabled != 1 || v53 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v49[295], OS_LOG_TYPE_DEBUG))
      {
LABEL_71:
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEBUG, "Requesting BPF from helper", buf, 2u);
      }
    }
    else
    {
      v53 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_71;
    }
    v56 = v49;
    v57 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v57, "command", "bpf_open");
    xpc_dictionary_set_int64(v57, "open_flags", 2);
    dispatch_retain(v52);
    v58 = _Block_copy(&__block_literal_global_126_3542);
    *(_QWORD *)aBlock = _NSConcreteStackBlock;
    *(_QWORD *)&aBlock[8] = 0x40000000;
    *(_QWORD *)&aBlock[16] = __mhc_bpf_open_block_invoke;
    *(_QWORD *)&aBlock[24] = &unk_10013EB48;
    v90 = v58;
    v91 = v52;
    v59 = v50;
    if (_mhc_queue_s_once != -1)
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_12_6479);
    mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder_Helper", (dispatch_queue_t)_mhc_queue_s_queue, 2uLL);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&v73[0] = ___mhc_create_connection_block_invoke;
    *((_QWORD *)&v73[0] + 1) = &__block_descriptor_tmp_10_6493;
    *(_QWORD *)&v73[1] = mach_service;
    xpc_connection_set_event_handler(mach_service, buf);
    xpc_connection_activate(mach_service);
    xpc_retain(v57);
    v61 = _Block_copy(aBlock);
    if (_mhc_queue_s_once != -1)
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_12_6479);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&v73[0] = ___mhc_send_message_with_reply_block_invoke;
    *((_QWORD *)&v73[0] + 1) = &unk_10013EBB0;
    *((_QWORD *)&v73[1] + 1) = mach_service;
    *(_QWORD *)&v74 = v57;
    *(_QWORD *)&v73[1] = v61;
    xpc_connection_send_message_with_reply(mach_service, v57, (dispatch_queue_t)_mhc_queue_s_queue, buf);
    if (v57)
      xpc_release(v57);
    v50 = v59;
    v49 = v56;
    v51 = &unk_100150000;
    goto LABEL_68;
  }
  v15 = (_QWORD *)IfAddrs;
  while (1)
  {
    v16 = v15[3];
    if (v16 && *(_BYTE *)(v16 + 1) == 30)
    {
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v74 = 0u;
      *(_OWORD *)buf = 0u;
      memset(v73, 0, sizeof(v73));
      v17 = v15[1];
      if (!v17)
        __break(1u);
      v18 = 0;
      while (1)
      {
        v19 = *(unsigned __int8 *)(v17 + v18);
        buf[v18] = v19;
        if (!v19)
          break;
        if (++v18 == 15)
        {
          buf[15] = 0;
          break;
        }
      }
      v20 = (__int128 *)v15[3];
      v21 = *v20;
      *(_OWORD *)((char *)v73 + 12) = *(__int128 *)((char *)v20 + 12);
      v73[0] = v21;
      if (ioctl(v13, 0xC1206949uLL, buf) != -1 && (v73[0] & 2) != 0)
        break;
    }
    v15 = (_QWORD *)*v15;
    if (!v15)
      goto LABEL_19;
  }
  v70 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)aBlock = 141558531;
    *(_QWORD *)&aBlock[4] = 1752392040;
    *(_WORD *)&aBlock[12] = 1045;
    *(_DWORD *)&aBlock[14] = 16;
    *(_WORD *)&aBlock[18] = 2101;
    *(_QWORD *)&aBlock[20] = (char *)v73 + 8;
    _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change ***  IPv6 address %{sensitive, mask.hash, network:in6_addr}.16P TENTATIVE, will retry", aBlock, 0x1Cu);
  }
  close(v13);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6379);
  SetNetworkChanged(500);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6381);
}

uint64_t mDNSSameAddress(int *a1, _DWORD *a2)
{
  int v2;
  int v3;
  int v4;

  v2 = *a1;
  if (*a1 == *a2)
  {
    switch(v2)
    {
      case 0:
        return 1;
      case 6:
        if (a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3])
        {
          v3 = a1[4];
          v4 = a2[4];
          return v3 == v4;
        }
        break;
      case 4:
        v3 = a1[1];
        v4 = a2[1];
        return v3 == v4;
    }
  }
  return 0;
}

void ClearInactiveInterfaces(int a1)
{
  uint64_t v1;
  int v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BOOL4 v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  _QWORD *v16;
  _QWORD *v17;
  BOOL v18;
  uint64_t v19;
  __int128 *v20;
  NSObject *v21;
  NSObject *v23;
  uint64_t i;
  int v26;
  NSObject *v27;
  int v30;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  _QWORD *j;
  uint64_t k;
  uint64_t v44;
  int v45;
  _BOOL4 v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  NSObject *v53;
  uint64_t *v54;
  int v55;
  uint64_t m;
  _QWORD *n;
  _QWORD *ii;
  uint64_t *v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  NSObject *v64;
  _BOOL4 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  int v75;
  int v76;
  NSObject *v77;
  const char *v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  void *v83;
  uint8_t buf[4];
  _BYTE v86[24];
  __int16 v87;
  _BYTE v88[14];
  __int16 v89;
  uint64_t v90;
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  uint64_t v94;
  __int16 v95;
  _BYTE v96[14];
  __int16 v97;
  _BYTE v98[10];
  _BYTE v99[6];
  _BOOL4 v100;
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;

  v1 = *(_QWORD *)mDNSStorage[0];
  if (!*(_QWORD *)mDNSStorage[0])
    return;
  v2 = a1;
  v3 = &unk_100164000;
  do
  {
    v4 = SearchForInterfaceByName((char *)(v1 + 3606), 0);
    v5 = *(_QWORD *)(v1 + 3776);
    if (!v5)
      goto LABEL_122;
    v6 = v4;
    v7 = (*(unsigned __int8 *)(v1 + 3696) | 2) != 2 && v5 == v4;
    if (v7)
      goto LABEL_122;
    v8 = (*(_BYTE *)(v1 + 3712) & 8) == 0 && v2 - *(_DWORD *)(v1 + 3700) < 60;
    *(_BYTE *)(v1 + 3697) = v8;
    v9 = *((_QWORD *)v3 + 296);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(v1 + 3720);
      v11 = *(_QWORD *)(v1 + 3552);
      v12 = CountMaskBits((int *)(v1 + 3580));
      v13 = *(unsigned __int8 *)(v1 + 3698);
      v14 = *(unsigned __int8 *)(v1 + 16);
      *(_DWORD *)buf = 136449795;
      *(_QWORD *)v86 = v1 + 3606;
      *(_WORD *)&v86[8] = 1024;
      *(_DWORD *)&v86[10] = v10;
      *(_WORD *)&v86[14] = 2160;
      *(_QWORD *)&v86[16] = 1752392040;
      v87 = 1045;
      *(_DWORD *)v88 = 6;
      *(_WORD *)&v88[4] = 2101;
      *(_QWORD *)&v88[6] = v1 + 3724;
      v3 = &unk_100164000;
      v89 = 2048;
      v90 = v11;
      v91 = 2048;
      v92 = v1;
      v93 = 2048;
      v94 = v6;
      v95 = 2160;
      *(_QWORD *)v96 = 1752392040;
      *(_WORD *)&v96[8] = 1045;
      *(_DWORD *)&v96[10] = 20;
      v97 = 2101;
      *(_QWORD *)v98 = v1 + 3560;
      v2 = a1;
      *(_WORD *)&v98[8] = 1024;
      *(_DWORD *)v99 = v12;
      *(_WORD *)&v99[4] = 1024;
      v100 = v8;
      v101 = 1024;
      v102 = v13;
      v103 = 1024;
      v104 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ClearInactiveInterfaces: Deregistering %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P InterfaceID %p(%p), primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d -- flashing: %{mdns:yesno}d, occulting: %{mdns:yesno}d, primary: %{mdns:yesno}d", buf, 0x7Cu);
    }
    if (!strncmp((const char *)(v1 + 3606), "p2p", 3uLL) || *(_BYTE *)(v1 + 3676))
    {
      v15 = *((_QWORD *)v3 + 296);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v86 = v1 + 3606;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ClearInactiveInterfaces: %{public}s DirectLink interface deregistering", buf, 0xCu);
      }
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", 17089);
    v16 = (uint64_t *)((char *)mDNSStorage + &loc_100003170);
    do
    {
      v17 = v16;
      v16 = (_QWORD *)*v16;
      if (v16)
        v18 = v16 == (_QWORD *)v1;
      else
        v18 = 1;
    }
    while (!v18);
    if (!v16)
    {
      v23 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((_QWORD *)v3 + 296))
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
        {
LABEL_57:
          v30 = 17096;
          goto LABEL_121;
        }
      }
      else
      {
        v23 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
          goto LABEL_57;
      }
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "NetworkInterfaceInfo not found in list", buf, 2u);
      goto LABEL_57;
    }
    *v17 = *v16;
    *(_QWORD *)v1 = 0;
    if (!*(_BYTE *)(v1 + 16))
    {
      for (i = xmmword_10015BF38; i; i = *(_QWORD *)i)
      {
        if (*(_BYTE *)(i + 16) && *(_QWORD *)(i + 3552) == *(_QWORD *)(v1 + 3552))
          UpdateInterfaceProtocols(i);
      }
      goto LABEL_47;
    }
    v19 = *(_QWORD *)(v1 + 3552);
    v20 = &xmmword_10015BF38;
    do
    {
      v20 = *(__int128 **)v20;
      if (!v20)
      {
        v27 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((_QWORD *)v3 + 296))
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            goto LABEL_60;
        }
        else
        {
          v27 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_60:
            ++dword_10015DBD0;
            v32 = *(void **)(v1 + 3552);
            if (DPCFeatureEnabled_sOnce != -1)
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
            if (DPCFeatureEnabled_sEnabled)
              _DPCRemovePushServer(v32);
            v33 = xmmword_100158E88;
            if (!(_QWORD)xmmword_100158E88)
            {
LABEL_72:
              v37 = 0;
              v38 = 0;
              v39 = 0;
              v40 = 0;
              v41 = 0;
              do
              {
                for (j = (_QWORD *)mDNSStorage[v37 + 34]; j; j = (_QWORD *)*j)
                {
                  for (k = j[2]; k; k = *(_QWORD *)k)
                  {
                    if (*(_QWORD *)(k + 32) == *(_QWORD *)(v1 + 3552))
                    {
                      v44 = *(_QWORD *)(k + 56);
                      if (v44)
                        v44 = *(_QWORD *)(v44 + 24);
                      v45 = *(_DWORD *)(k + 92);
                      v7 = v44 == 0;
                      v46 = v44 == 0;
                      v47 = !v7;
                      v48 = v40 + v46;
                      v49 = v38 + v47;
                      v50 = v41 + v46;
                      v51 = v39 + v47;
                      if (v45)
                        v41 = v50;
                      else
                        v40 = v48;
                      if (v45)
                        v39 = v51;
                      else
                        v38 = v49;
                      mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, k);
                    }
                  }
                }
                ++v37;
              }
              while (v37 != 499);
              v26 = 0;
              sCacheUsage_MulticastHitCount += v41;
              sCacheUsage_MulticastMissCount += v40;
              sCacheUsage_UnicastHitCount += v39;
              sCacheUsage_UnicastMissCount += v38;
              v3 = &unk_100164000;
              goto LABEL_106;
            }
            while (1)
            {
              if (!*(_WORD *)(v33 + 340))
              {
                v34 = *(_QWORD *)(v33 + 136);
                v35 = *(_QWORD *)(v1 + 3552);
                if (v34 == v35)
                {
                  *(_DWORD *)(v33 + 212) = 0;
LABEL_70:
                  v36 = *(_QWORD *)(v33 + 16);
                  *(_QWORD *)(v33 + 16) = v35;
                  *(_QWORD *)(v33 + 24) = v36;
                  goto LABEL_71;
                }
                if (!v34)
                  goto LABEL_70;
              }
LABEL_71:
              v33 = *(_QWORD *)(v33 + 8);
              if (!v33)
                goto LABEL_72;
            }
          }
        }
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)v86 = v19;
        *(_WORD *)&v86[4] = 2082;
        *(_QWORD *)&v86[6] = v1 + 3606;
        *(_WORD *)&v86[14] = 2160;
        *(_QWORD *)&v86[16] = 1752392040;
        v87 = 1045;
        *(_DWORD *)v88 = 20;
        *(_WORD *)&v88[4] = 2101;
        *(_QWORD *)&v88[6] = v1 + 3560;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Last representative of InterfaceID deregistered; marking questions etc. dormant - ifid: %d, ifname: %{public}s"
          ", ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P",
          buf,
          0x2Cu);
        goto LABEL_60;
      }
    }
    while (*((_QWORD *)v20 + 444) != v19);
    v21 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((_QWORD *)v3 + 296))
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_93;
    }
    else
    {
      v21 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_93:
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)v86 = v19;
        *(_WORD *)&v86[4] = 2082;
        *(_QWORD *)&v86[6] = v1 + 3606;
        *(_WORD *)&v86[14] = 2160;
        *(_QWORD *)&v86[16] = 1752392040;
        v87 = 1045;
        *(_DWORD *)v88 = 20;
        *(_WORD *)&v88[4] = 2101;
        *(_QWORD *)&v88[6] = v1 + 3560;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Another representative of InterfaceID exists - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x2Cu);
      }
    }
    if (*((_BYTE *)v20 + 16))
    {
      v53 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((_QWORD *)v3 + 296))
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          goto LABEL_100;
      }
      else
      {
        v53 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
LABEL_100:
          *(_DWORD *)buf = 136446979;
          *(_QWORD *)v86 = v1 + 3606;
          *(_WORD *)&v86[8] = 2160;
          *(_QWORD *)&v86[10] = 1752392040;
          *(_WORD *)&v86[18] = 1045;
          *(_DWORD *)&v86[20] = 20;
          v87 = 2101;
          *(_QWORD *)v88 = v1 + 3560;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "intf->InterfaceActive already set for interface - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
        }
      }
    }
    v26 = 1;
    *((_BYTE *)v20 + 16) = 1;
    UpdateInterfaceProtocols((uint64_t)v20);
    v54 = (uint64_t *)xmmword_10015BF38;
    if ((_QWORD)xmmword_10015BF38)
    {
      while (v54[444] != *(_QWORD *)(v1 + 3552) || *((_DWORD *)v54 + 890) != *(_DWORD *)(v1 + 3560))
      {
        v54 = (uint64_t *)*v54;
        if (!v54)
        {
          v26 = 1;
          goto LABEL_106;
        }
      }
LABEL_47:
      v26 = 0;
    }
LABEL_106:
    AdjustAddressRecordSetsEx(v1, 0);
    AdjustAddressRecordSetsEx(v1, 1);
    if (*(_BYTE *)(v1 + 3670))
      DeadvertiseInterface((uint64_t)mDNSStorage, v1, 3);
    if (dword_100158E14)
      v55 = 0;
    else
      v55 = v26;
    if (v55 == 1)
    {
      for (m = 0; m != 499; ++m)
      {
        for (n = (_QWORD *)mDNSStorage[m + 34]; n; n = (_QWORD *)*n)
        {
          for (ii = (_QWORD *)n[2]; ii; ii = (_QWORD *)*ii)
          {
            if (ii[4] == *(_QWORD *)(v1 + 3552))
              mDNS_Reconfirm_internal((uint64_t)mDNSStorage, (uint64_t)ii, 0x2710u);
          }
        }
      }
    }
    mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
    v30 = 17263;
LABEL_121:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", v30);
    *(_QWORD *)(v1 + 3776) = 0;
LABEL_122:
    v1 = *(_QWORD *)(v1 + 3680);
  }
  while (v1);
  v59 = (uint64_t *)mDNSStorage[0];
  v60 = *(_QWORD *)mDNSStorage[0];
  if (*(_QWORD *)mDNSStorage[0])
  {
    v61 = v2 - 1;
    while (2)
    {
      while (*(_BYTE *)(v60 + 3696))
      {
LABEL_141:
        v59 = (uint64_t *)(v60 + 3680);
        v60 = *(_QWORD *)(v60 + 3680);
        if (!v60)
          return;
      }
      v62 = *(_DWORD *)(v60 + 3704);
      if (v62 == v2)
      {
        *(_DWORD *)(v60 + 3704) = v61;
        v62 = v61;
      }
      v63 = v2 - v62;
      v64 = *((_QWORD *)v3 + 296);
      v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
      if (v63 < 60)
      {
        if (v65)
        {
          v79 = *(_DWORD *)(v60 + 3720);
          v80 = *(_QWORD *)(v60 + 3552);
          v81 = CountMaskBits((int *)(v60 + 3580));
          v82 = *(unsigned __int8 *)(v60 + 16);
          *(_DWORD *)buf = 136449283;
          *(_QWORD *)v86 = v60 + 3606;
          v2 = a1;
          *(_WORD *)&v86[8] = 1024;
          *(_DWORD *)&v86[10] = v79;
          *(_WORD *)&v86[14] = 2160;
          *(_QWORD *)&v86[16] = 1752392040;
          v87 = 1045;
          *(_DWORD *)v88 = 6;
          *(_WORD *)&v88[4] = 2101;
          *(_QWORD *)&v88[6] = v60 + 3724;
          v3 = &unk_100164000;
          v89 = 2048;
          v90 = v80;
          v91 = 2048;
          v92 = v60;
          v93 = 2160;
          v94 = 1752392040;
          v95 = 1045;
          *(_DWORD *)v96 = 20;
          *(_WORD *)&v96[4] = 2101;
          *(_QWORD *)&v96[6] = v60 + 3560;
          v97 = 1024;
          *(_DWORD *)v98 = v81;
          *(_WORD *)&v98[4] = 1024;
          *(_DWORD *)&v98[6] = v63;
          *(_WORD *)v99 = 1024;
          *(_DWORD *)&v99[2] = v82;
          v77 = v64;
          v78 = "ClearInactiveInterfaces: Holding %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Inter"
                "faceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
LABEL_133:
          _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, v78, buf, 0x6Cu);
        }
      }
      else if (v65)
      {
        v73 = *(_DWORD *)(v60 + 3720);
        v74 = *(_QWORD *)(v60 + 3552);
        v75 = CountMaskBits((int *)(v60 + 3580));
        v76 = *(unsigned __int8 *)(v60 + 16);
        *(_DWORD *)buf = 136449283;
        *(_QWORD *)v86 = v60 + 3606;
        *(_WORD *)&v86[8] = 1024;
        *(_DWORD *)&v86[10] = v73;
        *(_WORD *)&v86[14] = 2160;
        *(_QWORD *)&v86[16] = 1752392040;
        v87 = 1045;
        *(_DWORD *)v88 = 6;
        *(_WORD *)&v88[4] = 2101;
        *(_QWORD *)&v88[6] = v60 + 3724;
        v2 = a1;
        v89 = 2048;
        v90 = v74;
        v3 = &unk_100164000;
        v91 = 2048;
        v92 = v60;
        v93 = 2160;
        v94 = 1752392040;
        v95 = 1045;
        *(_DWORD *)v96 = 20;
        *(_WORD *)&v96[4] = 2101;
        *(_QWORD *)&v96[6] = v60 + 3560;
        v97 = 1024;
        *(_DWORD *)v98 = v75;
        *(_WORD *)&v98[4] = 1024;
        *(_DWORD *)&v98[6] = v63;
        *(_WORD *)v99 = 1024;
        *(_DWORD *)&v99[2] = v76;
        v77 = v64;
        v78 = "ClearInactiveInterfaces: Deleting %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Interf"
              "aceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
        goto LABEL_133;
      }
      if ((*(_DWORD *)(v60 + 3732) & 0x80000000) == 0)
        CloseBPF(v60, v66, v67, v68, v69, v70, v71, v72);
      if (v63 < 60)
        goto LABEL_141;
      *v59 = *(_QWORD *)(v60 + 3680);
      v83 = *(void **)(v60 + 8);
      if (v83)
        os_release(v83);
      free((void *)v60);
      v60 = *v59;
      if (!*v59)
        return;
      continue;
    }
  }
}

uint64_t mDNS_ConfigChanged(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  _BYTE v10[256];
  _BYTE v11[320];
  _OWORD v12[4];

  v1 = result;
  v2 = result + 15104;
  if (*(_BYTE *)(result + 15109) == 1)
  {
    memset(v12, 0, sizeof(v12));
    memset(&v11[256], 0, 64);
    DeconstructServiceName(*(char **)(result + 17576), v12, (uint64_t)v11, v10);
    v3 = mDNS_snprintf(&v11[257]);
    v11[256] = v3;
    if (LOBYTE(v12[0]) != v3 || (result = memcmp((char *)v12 + 1, &v11[257], v3), (_DWORD)result))
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Renaming SPS from %#s to %#s", v4, v5, v6, v7, v8, (int)v12);
      *(_BYTE *)(v2 + 5) = 2;
      result = mDNS_DeregisterService_drt((unsigned int *)v1, v1 + 15128, 1, v4, v5, v6, v7, v8);
    }
  }
  v9 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 32);
  if (v9)
    return v9(v1, 4294901505);
  return result;
}

uint64_t SameRDataBody(uint64_t a1, unsigned __int16 *a2, uint64_t (*a3)(uint64_t, unsigned __int16 *))
{
  unsigned __int16 *v3;
  uint64_t v5;
  unsigned __int16 *v6;
  int v7;
  uint64_t result;
  uint64_t v10;
  unsigned __int16 *v11;
  size_t v12;
  char *v13;
  _BYTE *v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned __int16 v19;
  uint64_t v20;

  v3 = a2;
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (unsigned __int16 *)(v5 + 4);
  v7 = *(unsigned __int16 *)(a1 + 4) - 2;
  result = 0;
  switch(v7)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 10:
    case 21:
    case 37:
      return SameDomainNameBytes((_BYTE *)(v5 + 4), a2);
    case 4:
      if (*(_DWORD *)(v5 + 516) != *((_DWORD *)a2 + 128)
        || *(_DWORD *)(v5 + 520) != *((_DWORD *)a2 + 129)
        || *(_DWORD *)(v5 + 524) != *((_DWORD *)a2 + 130)
        || *(_DWORD *)(v5 + 528) != *((_DWORD *)a2 + 131)
        || *(_DWORD *)(v5 + 532) != *((_DWORD *)a2 + 132))
      {
        return 0;
      }
      goto LABEL_15;
    case 12:
    case 15:
LABEL_15:
      result = a3(v5 + 4, a2);
      if (!(_DWORD)result)
        return result;
      v10 = v5 + 260;
      v11 = v3 + 128;
      return a3(v10, v11) != 0;
    case 13:
    case 16:
    case 19:
    case 34:
      if (*v6 != *a2)
        return 0;
      v10 = v5 + 6;
      v11 = a2 + 1;
      return a3(v10, v11) != 0;
    case 24:
      if (*v6 != *a2)
        return 0;
      result = a3(v5 + 6, a2 + 1);
      if (!(_DWORD)result)
        return result;
      v10 = v5 + 262;
      v11 = v3 + 129;
      return a3(v10, v11) != 0;
    case 31:
      if (*v6 != *a2 || *(unsigned __int16 *)(v5 + 6) != a2[1] || *(unsigned __int16 *)(v5 + 8) != a2[2])
        return 0;
      v10 = v5 + 10;
      v11 = a2 + 3;
      return a3(v10, v11) != 0;
    case 39:
      return result;
    case 45:
      v14 = (_BYTE *)(v5 + 4);
      if (v5 != -260)
        goto LABEL_22;
      break;
    default:
      v12 = *(unsigned __int16 *)(a1 + 12);
      v13 = (char *)(v5 + 4);
      return memcmp(v13, a2, v12) == 0;
  }
LABEL_25:
  if (v14)
  {
    while (1)
    {
      v16 = *v14;
      if (v16 > 0x3F)
        break;
      if (!*v14)
      {
        v15 = (_WORD)v14 - (_WORD)v6 + 1;
        goto LABEL_32;
      }
      v14 += v16 + 1;
      if (v5 == -260)
        goto LABEL_25;
LABEL_22:
      v15 = 257;
      if ((unint64_t)v14 >= v5 + 260 || !v14)
        goto LABEL_32;
    }
  }
  v15 = 257;
LABEL_32:
  v17 = v15;
  v18 = a2;
  if (a2 == (unsigned __int16 *)-256)
    goto LABEL_36;
LABEL_33:
  v19 = 257;
  if (v18 < a2 + 128 && v18)
  {
    while (1)
    {
      v20 = *(unsigned __int8 *)v18;
      if (v20 > 0x3F)
      {
LABEL_41:
        v19 = 257;
        goto LABEL_43;
      }
      if (!*(_BYTE *)v18)
        break;
      v18 = (unsigned __int16 *)((char *)v18 + v20 + 1);
      if (a2 != (unsigned __int16 *)-256)
        goto LABEL_33;
LABEL_36:
      if (!v18)
        goto LABEL_41;
    }
    v19 = (_WORD)v18 - (_WORD)a2 + 1;
  }
LABEL_43:
  if ((_DWORD)v17 != v19)
    return 0;
  result = a3((uint64_t)v6, a2);
  if ((_DWORD)result)
  {
    v13 = (char *)v6 + v17;
    a2 = (unsigned __int16 *)((char *)v3 + v17);
    v12 = *(unsigned __int16 *)(a1 + 12) - v17;
    return memcmp(v13, a2, v12) == 0;
  }
  return result;
}

uint64_t mDNS_Deregister(unsigned int *a1, uint64_t a2)
{
  uint64_t v4;

  mDNS_Lock_(a1, (uint64_t)"mDNS_Deregister", 16366);
  v4 = mDNS_Deregister_internal((uint64_t)a1, a2, 0);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Deregister", 16368);
  return v4;
}

uint64_t mDNS_Deregister_internal(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  unsigned __int8 *v7;
  unsigned int v8;
  int *v9;
  uint64_t *v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  BOOL v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  int j;
  int v24;
  int v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  uint64_t *v29;
  BOOL v30;
  uint64_t v31;
  uint64_t *i;
  int v33;
  int v34;
  BOOL v35;
  BOOL v36;
  BOOL v37;
  uint64_t v38;
  uint64_t *v39;
  int v40;
  int v41;
  BOOL v42;
  BOOL v43;
  BOOL v44;
  int v45;
  NSObject *v46;
  int v47;
  char v48;
  char v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  NSObject *v57;
  uint32_t v58;
  uint64_t v59;
  int v60;
  uint64_t *v61;
  uint64_t *v62;
  uint64_t *v63;
  BOOL v64;
  NSObject *v65;
  NSObject *v68;
  uint64_t v69;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int128 *v82;
  __int128 *v83;
  const char *v84;
  const char *v85;
  _DWORD *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  NSObject *v95;
  int v96;
  NSObject *v97;
  int v98;
  int v99;
  BOOL v100;
  char v101;
  uint64_t v102;
  int v103;
  NSObject *v104;
  uint64_t v105;
  uint64_t v106;
  BOOL v107;
  BOOL v108;
  char v109;
  int v110;
  NSObject *v111;
  uint64_t k;
  int v113;
  int v114;
  int v115;
  unsigned int v116;
  int v117;
  NSObject *v118;
  uint64_t v119;
  unsigned int v120;
  unsigned int v121;
  void (*v122)(uint64_t, uint64_t, uint64_t);
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t m;
  unsigned int v131;
  unsigned int v132;
  NSObject *v133;
  void (*v134)(uint64_t, uint64_t, uint64_t);
  NSObject *v135;
  NSObject *log;
  char loga;
  unsigned int v138;
  int v139;
  int v140;
  int v141;
  uint64_t **v142;
  int *v143;
  unsigned int v144;
  int v145;
  uint64_t v146;
  uint8_t buf[4];
  _BYTE v148[34];
  _OWORD __dst[16];

  v7 = (unsigned __int8 *)(a2 + 8);
  v6 = *(unsigned __int8 *)(a2 + 8);
  v8 = *(_DWORD *)(a2 + 24);
  v9 = (int *)(a1 + 19900);
  v10 = (uint64_t *)(a1 + 12616);
  memset(__dst, 0, sizeof(__dst));
  v11 = *(_BYTE **)(a2 + 40);
  v12 = v11;
  if (v11 == (_BYTE *)-256)
  {
LABEL_3:
    while (v12)
    {
      v13 = *v12;
      if (v13 > 0x3F)
        break;
      if (!*v12)
      {
        v14 = (_WORD)v12 - (_WORD)v11 + 1;
        if (v14 <= 0x100u)
          memcpy(__dst, *(const void **)(a2 + 40), v14);
        break;
      }
      v12 += v13 + 1;
      if (v11 != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if (v12 < v11 + 256)
      goto LABEL_3;
  }
  v143 = v9;
  v15 = *(unsigned __int16 *)(a2 + 12);
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v16 = AuthGroupForName(a1 + 6264, v8, v11);
    if (!v16)
      return 0;
    v142 = (uint64_t **)v10;
    v144 = v8;
    v10 = v16 + 2;
    do
    {
      v17 = v10;
      v10 = (uint64_t *)*v10;
      if (v10)
        v18 = v10 == (uint64_t *)a2;
      else
        v18 = 1;
    }
    while (!v18);
  }
  else
  {
    v144 = v8;
    v142 = (uint64_t **)v10;
    do
    {
      v17 = v10;
      v10 = (uint64_t *)*v10;
      if (v10)
        v19 = v10 == (uint64_t *)a2;
      else
        v19 = 1;
    }
    while (!v19);
  }
  v146 = a1;
  if (!v10)
  {
    v29 = (uint64_t *)(a1 + 12624);
    do
    {
      v17 = v29;
      v29 = (uint64_t *)*v29;
      if (v29)
        v30 = v29 == (uint64_t *)a2;
      else
        v30 = 1;
    }
    while (!v30);
    if (v29)
    {
      j = v6;
      *(_WORD *)(a2 + 130) = 0;
      *(_DWORD *)(a2 + 126) = 0;
      *(_BYTE *)(a2 + 192) = 0;
      *(_BYTE *)(a2 + 8) = 1;
      goto LABEL_110;
    }
LABEL_131:
    v54 = 4294901755;
    if (a3 == 3)
      return v54;
    v55 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v54;
    GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
    *(_DWORD *)buf = 134218499;
    *(_QWORD *)v148 = a2;
    *(_WORD *)&v148[8] = 2160;
    *(_QWORD *)&v148[10] = 1752392040;
    *(_WORD *)&v148[18] = 2085;
    *(_QWORD *)&v148[20] = v146 + 47032;
    v56 = "mDNS_Deregister_internal: Record %p not found in list %{sensitive, mask.hash}s";
    v57 = v55;
    v58 = 32;
LABEL_136:
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v56, buf, v58);
    return v54;
  }
  v18 = a3 == 4;
  v20 = a3;
  v21 = v15;
  if (v18)
  {
    v31 = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 32) = 0;
    for (i = *(uint64_t **)(v146 + 12624); i; i = (uint64_t *)*i)
    {
      if (i[4] == *(_QWORD *)(a2 + 32))
      {
        v33 = *((unsigned __int8 *)i + 8);
        v34 = *v7;
        v35 = v34 == 1 || v33 == 1;
        v36 = v35 || v33 == v34;
        v37 = v36 || (v34 | v33) == 18;
        if (v37
          && *((_DWORD *)i + 6) == *(_DWORD *)(a2 + 24)
          && resource_records_have_same_dnssec_rr_category(i[8], *(_QWORD *)(a2 + 64))
          && *((unsigned __int16 *)i + 6) == *(unsigned __int16 *)(a2 + 12)
          && *((unsigned __int16 *)i + 7) == *(unsigned __int16 *)(a2 + 14)
          && *((unsigned __int16 *)i + 10) == *(unsigned __int16 *)(a2 + 20)
          && *((_DWORD *)i + 7) == *(_DWORD *)(a2 + 28)
          && SameRDataBody((uint64_t)(i + 1), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((_BYTE *)i[5], *(_BYTE **)(a2 + 40)))
        {
          *((_BYTE *)i + 190) = -1;
        }
      }
    }
    *(_QWORD *)(a2 + 32) = v31;
    v15 = v21;
    a3 = v20;
    j = v6;
    goto LABEL_110;
  }
  v139 = v20;
  if (v20 == 2)
  {
    v22 = *(uint64_t **)(v146 + 12624);
    for (j = v6; v22; v22 = (uint64_t *)*v22)
    {
      if (v22[4] == *(_QWORD *)(a2 + 32))
      {
        v24 = *((unsigned __int8 *)v22 + 8);
        v25 = *v7;
        v26 = v25 == 1 || v24 == 1;
        v27 = v26 || v24 == v25;
        v28 = v27 || (v25 | v24) == 18;
        if (v28
          && *((_DWORD *)v22 + 6) == *(_DWORD *)(a2 + 24)
          && resource_records_have_same_dnssec_rr_category(v22[8], *(_QWORD *)(a2 + 64))
          && *((unsigned __int16 *)v22 + 6) == *(unsigned __int16 *)(a2 + 12)
          && *((unsigned __int16 *)v22 + 7) == *(unsigned __int16 *)(a2 + 14)
          && *((unsigned __int16 *)v22 + 10) == *(unsigned __int16 *)(a2 + 20)
          && *((_DWORD *)v22 + 7) == *(_DWORD *)(a2 + 28)
          && SameRDataBody((uint64_t)(v22 + 1), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((_BYTE *)v22[5], *(_BYTE **)(a2 + 40)))
        {
          *((_BYTE *)v22 + 190) = -1;
        }
      }
    }
    goto LABEL_109;
  }
  v38 = *(_QWORD *)(v146 + 12624);
  j = v6;
  if (!v38)
    goto LABEL_109;
  v39 = (uint64_t *)(v146 + 12624);
  while (1)
  {
    if (*(_QWORD *)(v38 + 32) != *(_QWORD *)(a2 + 32))
      goto LABEL_108;
    v40 = *(unsigned __int8 *)(v38 + 8);
    v41 = *v7;
    v42 = v41 == 1 || v40 == 1;
    v43 = v42 || v40 == v41;
    v44 = v43 || (v41 | v40) == 18;
    if (!v44
      || *(_DWORD *)(v38 + 24) != *(_DWORD *)(a2 + 24)
      || !resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v38 + 64), *(_QWORD *)(a2 + 64))
      || *(unsigned __int16 *)(v38 + 12) != *(unsigned __int16 *)(a2 + 12)
      || *(unsigned __int16 *)(v38 + 14) != *(unsigned __int16 *)(a2 + 14)
      || *(unsigned __int16 *)(v38 + 20) != *(unsigned __int16 *)(a2 + 20)
      || *(_DWORD *)(v38 + 28) != *(_DWORD *)(a2 + 28))
    {
      goto LABEL_108;
    }
    if (!SameRDataBody(v38 + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
    {
      v38 = *v39;
      goto LABEL_108;
    }
    v45 = SameDomainNameBytes(*(_BYTE **)(v38 + 40), *(_BYTE **)(a2 + 40));
    v38 = *v39;
    if (v45)
      break;
LABEL_108:
    v39 = (uint64_t *)v38;
    v38 = *(_QWORD *)v38;
    if (!v38)
      goto LABEL_109;
  }
  if (v38)
  {
    *v39 = *(_QWORD *)v38;
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
    {
      *(_QWORD *)v38 = 0;
      if (!InsertAuthRecord(v146 + 6264, v38))
      {
        v135 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          GetRRDisplayString_rdb((unsigned __int8 *)(v38 + 8), (unsigned __int16 *)(*(_QWORD *)(v38 + 48) + 4), (_BYTE *)(v146 + 47032));
          *(_DWORD *)buf = 141558275;
          *(_QWORD *)v148 = 1752392040;
          *(_WORD *)&v148[8] = 2085;
          *(_QWORD *)&v148[10] = v146 + 47032;
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: ERROR!! cannot insert %{sensitive, mask.hash}s", buf, 0x16u);
        }
      }
    }
    else
    {
      *(_QWORD *)v38 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v38;
    }
    *(_BYTE *)(v38 + 8) = *(_BYTE *)(a2 + 8);
    *(_DWORD *)(v38 + 189) = *(_DWORD *)(a2 + 189);
    *(_BYTE *)(v38 + 193) = *(_BYTE *)(a2 + 193);
    *(_BYTE *)(v38 + 195) = *(_BYTE *)(a2 + 195);
    *(_OWORD *)(v38 + 208) = *(_OWORD *)(a2 + 208);
    *(_DWORD *)(v38 + 232) = *(_DWORD *)(a2 + 232);
    *(_OWORD *)(v38 + 236) = *(_OWORD *)(a2 + 236);
    *(_QWORD *)(v38 + 280) = *(_QWORD *)(a2 + 280);
    *(_DWORD *)(v38 + 288) = *(_DWORD *)(a2 + 288);
    *(_QWORD *)(v38 + 296) = *(_QWORD *)(a2 + 296);
    *(_BYTE *)(v38 + 356) = *(_BYTE *)(a2 + 356);
    *(_DWORD *)(v38 + 344) = *(_DWORD *)(a2 + 344);
    *(_WORD *)(a2 + 192) = 0;
  }
LABEL_109:
  v15 = v21;
  a3 = v139;
LABEL_110:
  if (!*v17)
    goto LABEL_131;
  if (!*(_QWORD *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    if (*(_BYTE *)(a2 + 192))
    {
      v69 = *(_QWORD *)(a2 + 384);
      if (v69)
      {
        DisposeTCPConn(v69);
        *(_QWORD *)(a2 + 384) = 0;
      }
      *(_BYTE *)(a2 + 8) = 1;
      *(_BYTE *)(v146 + 140) = 1;
      uDNS_DeregisterRecord(v146, a2);
      return 0;
    }
    *(_WORD *)(a2 + 358) = 0;
    if (*(_QWORD *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(v146, a2 + 392);
      *(_QWORD *)(a2 + 584) = 0;
    }
    v86 = *(_DWORD **)(a2 + 376);
    if (v86)
    {
      CancelGetZoneData(v146, v86);
      *(_QWORD *)(a2 + 376) = 0;
    }
    v87 = *(_QWORD *)(a2 + 384);
    if (v87)
    {
      DisposeTCPConn(v87);
      *(_QWORD *)(a2 + 384) = 0;
    }
  }
  if (j == 1)
  {
    v54 = 4294901755;
    v59 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return v54;
    GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
    *(_DWORD *)buf = 141558275;
    *(_QWORD *)v148 = 1752392040;
    *(_WORD *)&v148[8] = 2085;
    *(_QWORD *)&v148[10] = v146 + 47032;
    v56 = "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeDeregistering";
    v57 = v59;
    v58 = 22;
    goto LABEL_136;
  }
  if (!j)
  {
    v46 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v148 = 1752392040;
      *(_WORD *)&v148[8] = 2085;
      *(_QWORD *)&v148[10] = v146 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeUnregistered", buf, 0x16u);
    }
  }
  v47 = *(_DWORD *)(a2 + 126);
  if (v47 || (j == 8 || *(_DWORD *)(a2 + 172) == 4) && (*(_BYTE *)(a2 + 192) || *(_BYTE *)(a2 + 193)))
  {
    *(_BYTE *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 16) = 0;
    if (a3 == 1)
      v48 = 1;
    else
      v48 = 3;
    if (v47)
      v49 = 18;
    else
      v49 = v48;
    *(_BYTE *)(a2 + 191) = v49;
    *(_DWORD *)(a2 + 280) = 2000;
    v50 = v146;
    v51 = *(_DWORD *)(v146 + 64);
    *(_DWORD *)(a2 + 284) = v51 - 2000;
    *(_BYTE *)(v146 + 140) = 1;
    v52 = v51 + 100;
    v53 = 0;
    if (*(_DWORD *)(v146 + 100) - v52 >= 0)
      *(_DWORD *)(v146 + 100) = v52;
    v60 = v144;
    goto LABEL_138;
  }
  if (!v10)
  {
    v53 = 0;
    v60 = v144;
    v50 = v146;
    goto LABEL_216;
  }
  v50 = v146;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4)
  {
    v60 = v144;
    if ((*v7 & 0x32) == 0)
    {
      v53 = 0;
      goto LABEL_213;
    }
    v71 = CacheGroupForName(v146, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
    v53 = (uint64_t)v71;
    if (!v71)
      goto LABEL_213;
    v78 = v71[2];
    if (!v78)
      goto LABEL_213;
    v140 = a3;
    while (1)
    {
      v79 = *(_QWORD *)(v78 + 32);
      v80 = *(_QWORD *)(a2 + 32);
      if (v80)
      {
        v81 = v15;
        if (v80 == v79)
          goto LABEL_187;
      }
      else
      {
        v81 = v15;
        if (mDNSPlatformValidRecordForInterface(a2, *(_QWORD *)(v78 + 32), v72, v73, v74, v75, v76, v77))
        {
LABEL_187:
          if (resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v78 + 64), *(_QWORD *)(a2 + 64))
            && *(unsigned __int16 *)(v78 + 12) == *(unsigned __int16 *)(a2 + 12)
            && *(unsigned __int16 *)(v78 + 14) == *(unsigned __int16 *)(a2 + 14)
            && *(unsigned __int16 *)(v78 + 20) == *(unsigned __int16 *)(a2 + 20)
            && *(_DWORD *)(v78 + 28) == *(_DWORD *)(a2 + 28)
            && SameRDataBody(v78 + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
          {
            log = mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
            {
              v145 = v60;
              v82 = &xmmword_10015BF38;
              while (1)
              {
                v82 = *(__int128 **)v82;
                if (!v82)
                  break;
                v83 = v82;
                if (*((_QWORD *)v82 + 444) == v79)
                  goto LABEL_199;
              }
              v83 = 0;
LABEL_199:
              v84 = (char *)v83 + 3606;
              if (v82)
                v85 = v84;
              else
                v85 = "";
              GetRRDisplayString_rdb((unsigned __int8 *)(v78 + 8), (unsigned __int16 *)(*(_QWORD *)(v78 + 48) + 4), (_BYTE *)(v146 + 47032));
              *(_DWORD *)buf = 136446979;
              *(_QWORD *)v148 = v85;
              *(_WORD *)&v148[8] = 1024;
              *(_DWORD *)&v148[10] = v79;
              *(_WORD *)&v148[14] = 2160;
              *(_QWORD *)&v148[16] = 1752392040;
              *(_WORD *)&v148[24] = 2085;
              *(_QWORD *)&v148[26] = v146 + 47032;
              _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "mDNS_Deregister_internal: Purging cached record that matches deregistered AuthRecord -- interface: %{public}s/%u, record: %{sensitive, mask.hash}s", buf, 0x26u);
              v60 = v145;
            }
            mDNS_PurgeCacheResourceRecord((unsigned int *)v146, v78);
          }
        }
      }
      v78 = *(_QWORD *)v78;
      v15 = v81;
      if (!v78)
      {
        a3 = v140;
        v50 = v146;
        goto LABEL_213;
      }
    }
  }
  v53 = 0;
  v60 = v144;
LABEL_213:
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v88 = RemoveAuthRecord(v50, v50 + 6264, a2);
    if (v88[5] == a2)
      v88[5] = *(_QWORD *)a2;
    goto LABEL_276;
  }
LABEL_216:
  *v17 = *(_QWORD *)a2;
  if (*(_QWORD *)(v50 + 12632) == a2)
    *(_QWORD *)(v50 + 12632) = *(_QWORD *)a2;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v95 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v50 + 47032));
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)v148 = v50 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: called for RRLocalOnly() record: %{public}s", buf, 0xCu);
    }
    goto LABEL_276;
  }
  if (!*(_QWORD *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40))
    || *(_WORD *)(a2 + 12) != 33
    || *(_BYTE *)(a2 + 120) != 1)
  {
    goto LABEL_266;
  }
  v138 = *(_DWORD *)(a2 + 172) & 0xFFFFFFFE;
  if (v138 == 2)
  {
    v96 = *(_DWORD *)(v50 + 10920) - 1;
    *(_DWORD *)(v50 + 10920) = v96;
    v97 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)v148 = v96;
      *(_WORD *)&v148[4] = 2160;
      *(_QWORD *)&v148[6] = 1752392040;
      *(_WORD *)&v148[14] = 2085;
      *(_QWORD *)&v148[16] = v146 + 47032;
      v50 = v146;
      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
      v96 = *(_DWORD *)(v146 + 10920);
    }
    if (v96)
      goto LABEL_266;
    v141 = a3;
    v98 = v15;
    v99 = *(_DWORD *)(v50 + 10924);
    v100 = v99 == 0;
    v101 = 2 * (v99 == 0);
    loga = 2;
  }
  else
  {
    v102 = *(_QWORD *)(a2 + 32);
    if ((!AWDLInterfaceID || AWDLInterfaceID != v102) && (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v102))
    {
      v110 = *v143 - 1;
      *v143 = v110;
      v111 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
        *(_DWORD *)buf = 67109635;
        *(_DWORD *)v148 = v110;
        *(_WORD *)&v148[4] = 2160;
        *(_QWORD *)&v148[6] = 1752392040;
        *(_WORD *)&v148[14] = 2085;
        *(_QWORD *)&v148[16] = v146 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
        v110 = *v143;
      }
      v50 = v146;
      if (!v110)
      {
        for (k = *(_QWORD *)(v146 + 12656); k; k = *(_QWORD *)k)
        {
          if (*(_BYTE *)(k + 3670))
            DeadvertiseInterface(v146, k, 1);
        }
      }
      goto LABEL_266;
    }
    v103 = *(_DWORD *)(v50 + 10924) - 1;
    *(_DWORD *)(v50 + 10924) = v103;
    v104 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)v148 = v103;
      *(_WORD *)&v148[4] = 2160;
      *(_QWORD *)&v148[6] = 1752392040;
      *(_WORD *)&v148[14] = 2085;
      *(_QWORD *)&v148[16] = v146 + 47032;
      v50 = v146;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
    }
    if (*(_DWORD *)(v50 + 10920))
      goto LABEL_266;
    v99 = *(_DWORD *)(v50 + 10924);
    if (v99)
      goto LABEL_266;
    v141 = a3;
    v98 = v15;
    loga = 0;
    v100 = 1;
    v101 = 2;
  }
  v105 = *(_QWORD *)(v50 + 12656);
  if (!v105)
  {
LABEL_257:
    LODWORD(v15) = v98;
    a3 = v141;
    v50 = v146;
    if (!v99)
      GetRandomUUIDLocalHostname((_BYTE *)(v146 + 10664));
    goto LABEL_266;
  }
  while (2)
  {
    if (*(_BYTE *)(v105 + 3670))
    {
      v106 = *(_QWORD *)(v105 + 3552);
      if (AWDLInterfaceID)
        v107 = AWDLInterfaceID == v106;
      else
        v107 = 0;
      if (v107 || (WiFiAwareInterfaceID ? (v108 = WiFiAwareInterfaceID == v106) : (v108 = 0), v108))
      {
        v109 = v101;
        if (!v100)
          goto LABEL_254;
      }
      else
      {
        v109 = loga;
        if (v138 != 2)
          goto LABEL_254;
      }
      DeadvertiseInterface(v146, v105, v109);
    }
LABEL_254:
    v105 = *(_QWORD *)v105;
    if (v105)
      continue;
    break;
  }
  v50 = v146;
  LODWORD(v15) = v98;
  a3 = v141;
  if (!*(_DWORD *)(v146 + 10920))
  {
    v98 = v15;
    v99 = *(_DWORD *)(v146 + 10924);
    goto LABEL_257;
  }
LABEL_266:
  if (*(_QWORD *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    v113 = v60;
    v114 = v143[1];
    v115 = v143[2];
    if (v115 + v114 == 1)
    {
      v116 = *(_DWORD *)(v146 + 64) + 60000;
      if (v116 <= 1)
        v116 = 1;
      *(_DWORD *)(v146 + 116) = v116;
    }
    v117 = v114 - 1;
    v143[1] = v114 - 1;
    v118 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      v50 = v146;
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v146 + 47032));
      *(_DWORD *)buf = 67109891;
      *(_DWORD *)v148 = v117;
      *(_WORD *)&v148[4] = 1024;
      *(_DWORD *)&v148[6] = v115;
      *(_WORD *)&v148[10] = 2160;
      *(_QWORD *)&v148[12] = 1752392040;
      *(_WORD *)&v148[20] = 2085;
      *(_QWORD *)&v148[22] = v146 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s", buf, 0x22u);
      v60 = v113;
    }
    else
    {
      v60 = v113;
      v50 = v146;
    }
  }
LABEL_276:
  if (*(_QWORD *)(v50 + 12640) == a2)
    *(_QWORD *)(v50 + 12640) = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_BYTE *)(a2 + 8) = 0;
  if (*(_QWORD *)(a2 + 304))
    CompleteRDataUpdate(v50, a2, v89, v90, v91, v92, v93, v94);
  if (a3 == 2 || a3 == 4)
  {
    if (a3 == 2)
      v119 = 4294901748;
    else
      v119 = 4294901724;
    RecordProbeFailure((_DWORD *)v50, a2);
    v120 = *(_DWORD *)(v50 + 48);
    v121 = *(_DWORD *)(v50 + 52) + 1;
    *(_DWORD *)(v50 + 52) = v121;
    mDNS_VerifyLockState("Drop Lock", 0, v120, v121, (uint64_t)"mDNS_Deregister_internal", 2519);
    v122 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v122)
      v122(v50, a2, v119);
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(v50 + 48), *(_DWORD *)(v50 + 52), (uint64_t)"mDNS_Deregister_internal", 2522);
    --*(_DWORD *)(v50 + 52);
    for (m = *(_QWORD *)(v50 + 12624); m; m = *(_QWORD *)m)
    {
      if (*(unsigned __int8 *)(m + 190) == 255)
      {
        D2D_stop_advertising_record(m, v123, v124, v125, v126, v127, v128, v129);
        mDNS_Deregister_internal(v50, m, v119);
        m = v50 + 12624;
      }
    }
  }
  else
  {
    v131 = *(_DWORD *)(v50 + 48);
    v132 = *(_DWORD *)(v50 + 52) + 1;
    *(_DWORD *)(v50 + 52) = v132;
    mDNS_VerifyLockState("Drop Lock", 0, v131, v132, (uint64_t)"mDNS_Deregister_internal", 2509);
    v133 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v50 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v148 = 1752392040;
      *(_WORD *)&v148[8] = 2085;
      *(_QWORD *)&v148[10] = v50 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: callback with mStatus_MemFree for %{sensitive, mask.hash}s", buf, 0x16u);
    }
    v134 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v134)
      v134(v50, a2, 4294901504);
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(v50 + 48), *(_DWORD *)(v50 + 52), (uint64_t)"mDNS_Deregister_internal", 2513);
    --*(_DWORD *)(v50 + 52);
  }
LABEL_138:
  mDNS_UpdateAllowSleep(v50);
  if ((_DWORD)v15 == 41)
    return 0;
  v61 = mDNSGetTSRForAuthRecordNamed(*v142, __dst, v60);
  v62 = v61;
  v63 = *v142;
  if (*v142 && v61)
  {
    do
    {
      if (*((_WORD *)v63 + 6) != 41
        && *((_DWORD *)v63 + 6) == v60
        && SameDomainNameBytes((_BYTE *)v63[5], __dst))
      {
        v62 = 0;
      }
      v63 = (uint64_t *)*v63;
      if (v63)
        v64 = v62 == 0;
      else
        v64 = 1;
    }
    while (!v64);
  }
  if (!v62)
    return 0;
  v65 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_159;
  }
  else
  {
    v65 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_159:
      GetRRDisplayString_rdb((unsigned __int8 *)v62 + 8, (unsigned __int16 *)(v62[6] + 4), (_BYTE *)(v50 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v148 = 1752392040;
      *(_WORD *)&v148[8] = 2085;
      *(_QWORD *)&v148[10] = v50 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Deregistering orphaned TSR - %{sensitive, mask.hash}s", buf, 0x16u);
    }
  }
  mDNS_Deregister_internal(v50, v62, 3);
  if (!v53)
    return 0;
  v54 = (uint64_t)mDNSGetTSRForCacheGroup(v53);
  if (v54)
  {
    v68 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
        goto LABEL_174;
    }
    else
    {
      v68 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_174:
        GetRRDisplayString_rdb((unsigned __int8 *)(v54 + 8), (unsigned __int16 *)(*(_QWORD *)(v54 + 48) + 4), (_BYTE *)(v50 + 47032));
        *(_DWORD *)buf = 141558275;
        *(_QWORD *)v148 = 1752392040;
        *(_WORD *)&v148[8] = 2085;
        *(_QWORD *)&v148[10] = v50 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEBUG, "Purging cached TSR record that matches orphaned TSR -- %{sensitive, mask.hash}s", buf, 0x16u);
      }
    }
    mDNS_PurgeCacheResourceRecord((unsigned int *)v50, v54);
    return 0;
  }
  return v54;
}

void RmvAutoBrowseDomain(int a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void **v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  NSObject *v15;
  _BYTE *v17;
  int v18;
  uint64_t v19;
  _BYTE *v21;
  uint64_t v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  _BYTE *v28;
  __int16 v29;
  int v30;

  v9 = AutoBrowseDomains;
  if (AutoBrowseDomains)
  {
    v11 = (void **)&AutoBrowseDomains;
    while (1)
    {
      v12 = SameDomainNameBytes((_BYTE *)(v9 + 12), a2);
      v14 = *v11;
      if (v12)
      {
        if (v14[2] == a1)
          break;
      }
      v9 = *(_QWORD *)v14;
      v11 = (void **)*v11;
      if (!*(_QWORD *)v14)
        goto LABEL_6;
    }
    *v11 = *(void **)v14;
    udsserver_automatic_browse_domain_changed((uint64_t)v14, 0, v13, a4, a5, a6, a7, a8);
    free(v14);
    v15 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          v17 = a2;
          if (a2 == (_BYTE *)-256)
            goto LABEL_19;
LABEL_16:
          v18 = 257;
          if (v17 < a2 + 256 && v17)
          {
            while (1)
            {
              v19 = *v17;
              if (v19 > 0x3F)
              {
LABEL_37:
                v18 = 257;
                goto LABEL_42;
              }
              if (!*v17)
                break;
              v17 += v19 + 1;
              if (a2 != (_BYTE *)-256)
                goto LABEL_16;
LABEL_19:
              if (!v17)
                goto LABEL_37;
            }
            v18 = (unsigned __int16)((_WORD)v17 - (_WORD)a2 + 1);
          }
        }
        else
        {
          v18 = 0;
        }
        goto LABEL_42;
      }
    }
    else
    {
      v15 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          v21 = a2;
          if (a2 == (_BYTE *)-256)
            goto LABEL_30;
LABEL_27:
          v18 = 257;
          if (v21 < a2 + 256 && v21)
          {
            while (1)
            {
              v22 = *v21;
              if (v22 > 0x3F)
              {
LABEL_38:
                v18 = 257;
                goto LABEL_42;
              }
              if (!*v21)
                break;
              v21 += v22 + 1;
              if (a2 != (_BYTE *)-256)
                goto LABEL_27;
LABEL_30:
              if (!v21)
                goto LABEL_38;
            }
            v18 = (unsigned __int16)((_WORD)v21 - (_WORD)a2 + 1);
          }
        }
        else
        {
          v18 = 0;
        }
LABEL_42:
        *(_DWORD *)buf = 141558787;
        v24 = 1752392040;
        v25 = 1040;
        v26 = v18;
        v27 = 2101;
        v28 = a2;
        v29 = 1024;
        v30 = a1;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain is removed - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u", buf, 0x22u);
      }
    }
  }
  else
  {
LABEL_6:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RmvAutoBrowseDomain: Got remove event for domain %##s not in list", a4, a5, a6, a7, a8, (int)a2);
  }
}

void KQueueLoop(uint64_t a1)
{
  NSObject **v2;
  NSObject *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  xpc_object_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v55;
  int v56;
  int v58;
  int v60;
  unsigned int v61;
  size_t v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  size_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  __darwin_time_t *v80;
  _BYTE *v81;
  __darwin_time_t v82;
  int8x16_t *v83;
  _QWORD *v84;
  uint64_t v85;
  size_t v86;
  ssize_t v87;
  __int32 v88;
  __int32 v89;
  _QWORD *v90;
  uint64_t v91;
  int v92;
  _BOOL4 v93;
  _BOOL4 v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  NSObject *v100;
  int *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int v112;
  NSObject *v113;
  int v114;
  int v115;
  int v116;
  unsigned int v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  uint64_t *v129;
  unint64_t v130;
  _QWORD *v131;
  _QWORD **v132;
  _QWORD *v133;
  _QWORD *v134;
  unsigned int v135;
  _QWORD **v136;
  _QWORD *v137;
  int v138;
  id v140;
  int v141;
  NSObject *v142;
  const char *v143;
  id v144;
  NSObject *v145;
  _QWORD *v147;
  _QWORD *v148;
  int v149;
  id v150;
  NSObject *v151;
  _QWORD *v152;
  _QWORD *v153;
  uint64_t v154;
  int v155;
  uint64_t *v156;
  id v157;
  NSObject *v158;
  uint64_t *v159;
  uint64_t *v160;
  uint64_t v161;
  int v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  _QWORD *v166;
  int v167;
  _QWORD *v168;
  uint64_t v169;
  uint64_t v170;
  int v171;
  _QWORD *v172;
  _QWORD **v173;
  _QWORD *v174;
  id v175;
  NSObject *v176;
  _QWORD *v177;
  void *v178;
  uint64_t v179;
  int v180;
  id v181;
  NSObject *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  void *v191;
  NSObject *v192;
  int v193;
  int v194;
  unsigned __int8 *v195;
  NSObject *v196;
  int v199;
  char v200;
  int v201;
  int v202;
  uint64_t v203;
  uint64_t *v204;
  time_t HaveAdvertisedMulticastServices;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  int v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  const __CFArray *v224;
  int v225;
  const __SCDynamicStore *v226;
  const __SCDynamicStore *v227;
  const __CFDictionary *v228;
  const __CFDictionary *v229;
  int64_t Count;
  int64_t v231;
  const void **v232;
  const void **v233;
  uint64_t v234;
  const __CFDictionary *v235;
  int64_t v236;
  const __CFDate *LeaseStartTime;
  const __CFData *OptionData;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  const __CFData *v244;
  BOOL v245;
  NSObject *v246;
  const UInt8 *BytePtr;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  unsigned int *v253;
  double Current;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  double v260;
  unsigned int v261;
  unsigned int v262;
  unsigned int v263;
  unsigned int v264;
  unsigned int v265;
  NSObject *v266;
  const char *v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  unsigned int v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  int v280;
  uint64_t *i;
  int v282;
  int v283;
  unsigned int v284;
  uint64_t *j;
  int v286;
  int v287;
  NSObject *v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  int v295;
  _BOOL4 v296;
  int v297;
  int v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  int v304;
  int v305;
  int v306;
  const char *v307;
  io_connect_t v308;
  intptr_t v309;
  int v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  int v321;
  NSObject *v322;
  int v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  int v329;
  NSObject *v330;
  int v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  _DWORD *v338;
  uint64_t v339;
  NSObject *v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  int v347;
  int v348;
  int v349;
  int v350;
  int v351;
  int v352;
  NSObject *v353;
  int v354;
  int v355;
  int *v356;
  char *v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  int v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  int v371;
  NSObject *v372;
  NSObject *v374;
  int v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  NSObject *v381;
  int v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  int v388;
  uint64_t v389;
  char *v391;
  NSObject *v392;
  NSObject *v393;
  char *v395;
  NSObject *v396;
  int v397;
  int v398;
  int v399;
  void *v400;
  void *__s2;
  __int128 *v402;
  __int128 *v403;
  uint64_t v404;
  int v405;
  _BYTE *v406;
  uint64_t v407;
  uint64_t *v408;
  unsigned int v409;
  uint64_t *v410;
  uint64_t v411;
  _QWORD *v412;
  const __SCDynamicStore *v413;
  unsigned int v414;
  const __CFArray *v415;
  int v416;
  unint64_t v417;
  unsigned int v418;
  unsigned int v419;
  int v420;
  timespec timeout;
  kevent eventlist;
  _BYTE block[24];
  void *v424;
  _QWORD v425[4];

  if (dnssd_server_init_s_once != -1)
    dispatch_once(&dnssd_server_init_s_once, &__block_literal_global_943);
  if (unicast_assist_init_s_once != -1)
    dispatch_once(&unicast_assist_init_s_once, &__block_literal_global_115);
  if (_mrcs_server_queue_s_once != -1)
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  *(_QWORD *)block = _NSConcreteStackBlock;
  *(_QWORD *)&block[8] = 0x40000000;
  *(_QWORD *)&block[16] = __mrcs_server_set_dns_service_registration_handlers_block_invoke;
  v424 = &__block_descriptor_tmp_4_4256;
  v425[0] = kMRCSServerDNSServiceRegistrationHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1)
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  *(_QWORD *)block = _NSConcreteStackBlock;
  *(_QWORD *)&block[8] = 0x40000000;
  *(_QWORD *)&block[16] = __mrcs_server_set_dns_proxy_handlers_block_invoke;
  v424 = &__block_descriptor_tmp_4252;
  v425[0] = kMRCSServerDNSProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1)
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  *(_QWORD *)block = _NSConcreteStackBlock;
  *(_QWORD *)&block[8] = 0x40000000;
  *(_QWORD *)&block[16] = __mrcs_server_set_discovery_proxy_handlers_block_invoke;
  v424 = &__block_descriptor_tmp_5_4257;
  v425[0] = kMRCSServerDiscoveryProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1)
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  *(_QWORD *)block = _NSConcreteStackBlock;
  *(_QWORD *)&block[8] = 0x40000000;
  *(_QWORD *)&block[16] = __mrcs_server_set_record_cache_handlers_block_invoke;
  v424 = &__block_descriptor_tmp_6_4258;
  v425[0] = kMRCServerRecordCacheHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1)
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  v403 = (__int128 *)(a1 + 10280);
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, &__block_literal_global_4259);
  pthread_mutex_lock(&stru_1001508F0);
  v2 = (NSObject **)&unk_100164000;
  v3 = mDNSLogCategory_Default;
  v4 = &unk_100164000;
  v5 = &unk_100164000;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v6)
    {
LABEL_20:
      *(_DWORD *)block = 67109376;
      *(_DWORD *)&block[4] = dword_100158E0C;
      *(_WORD *)&block[8] = 1024;
      *(_DWORD *)&block[10] = dword_100158E0C;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Starting time value 0x%08X (%d)", block, 0xEu);
    }
  }
  else
  {
    v3 = mDNSLogCategory_Default_redacted;
    v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v6)
      goto LABEL_20;
  }
  __s2 = (void *)(a1 + 10281);
  v402 = (__int128 *)(a1 + 10344);
  v400 = (void *)(a1 + 10345);
  v406 = (_BYTE *)(a1 + 47032);
  v404 = a1;
  while (1)
  {
    memset(&eventlist, 0, sizeof(eventlist));
    v405 = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
    v21 = mDNS_TimeNow((_DWORD *)a1, v14, v15, v16, v17, v18, v19, v20);
    v29 = v21;
    v30 = *(_DWORD *)(*(_QWORD *)a1 + 500);
    if (v30 && (((_DWORD)v21 - v30) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(_QWORD *)a1 + 500) = 0;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSDaemonIdle", 861);
      LogMsgWithLevel(v2[295], OS_LOG_TYPE_DEFAULT, "Note: SetDomainSecrets: no keychain support", v31, v32, v33, v34, v35, v397);
      mDNS_Unlock_(a1, (uint64_t)"mDNSDaemonIdle", 863);
    }
    v36 = *(_DWORD *)(a1 + 8);
    if (v36 && ((v29 - v36) & 0x80000000) == 0)
      mDNSMacOSXNetworkChanged(v21, v22, v23, v24, v25, v26, v27, v28);
    v37 = *(_DWORD *)(*(_QWORD *)a1 + 608);
    if (v37 && ((v29 - v37) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(_QWORD *)a1 + 608) = 0;
      mdns_power_cancel_all_events(CFSTR("com.apple.mDNSResponder"));
      v38 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_uint64(v38, "HelperMode", 5uLL);
      xpc_dictionary_set_uint64(v38, "powerreq_key", 0);
      xpc_dictionary_set_uint64(v38, "powerreq_interval", 0);
      v44 = SendDict_ToServer(v38);
      if (v38)
        xpc_release(v38);
      v2 = (NSObject **)&unk_100164000;
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPowerRequest: Using XPC IPC returning error_code %d", v39, v40, v41, v42, v43, v44);
    }
    v45 = mDNS_Execute(a1);
    v53 = *(_DWORD *)(a1 + 8);
    if ((int)(v45 - v53) <= 0 || v53 == 0)
      v53 = v45;
    v55 = *(_QWORD *)a1;
    v56 = *(_DWORD *)(*(_QWORD *)a1 + 500);
    if ((int)(v53 - v56) > 0 && v56 != 0)
      v53 = *(_DWORD *)(*(_QWORD *)a1 + 500);
    v58 = *(_DWORD *)(v55 + 608);
    if ((int)(v53 - v58) > 0 && v58 != 0)
      v53 = *(_DWORD *)(v55 + 608);
    v409 = v53;
    v60 = *(_DWORD *)(v55 + 492);
    if (v60)
    {
      if (v60 - v29 < 0)
      {
        v62 = *(unsigned __int8 *)(v55 + 172);
        if ((_DWORD)v62 != *(unsigned __int8 *)v403 || memcmp((const void *)(v55 + 173), __s2, v62))
        {
          LogMsgWithLevel(v2[295], OS_LOG_TYPE_DEFAULT, "Name Conflict: Updated Computer Name from \"%#s\" to \"%#s\"", v48, v49, v50, v51, v52, v55 + 172);
          mDNSPreferencesSetNames(1, (__int128 *)(*(_QWORD *)a1 + 172), v403);
          v63 = *(_QWORD *)a1;
          v64 = *v403;
          v65 = v403[1];
          v66 = v403[2];
          *(_OWORD *)(v63 + 220) = v403[3];
          *(_OWORD *)(v63 + 204) = v66;
          *(_OWORD *)(v63 + 188) = v65;
          *(_OWORD *)(v63 + 172) = v64;
          v55 = *(_QWORD *)a1;
        }
        v67 = *(unsigned __int8 *)(v55 + 108);
        if ((_DWORD)v67 != *(unsigned __int8 *)v402 || memcmp((const void *)(v55 + 109), v400, v67))
        {
          LogMsgWithLevel(v2[295], OS_LOG_TYPE_DEFAULT, "Name Conflict: Updated Local Hostname from \"%#s.local\" to \"%#s.local\"", v48, v49, v50, v51, v52, v55 + 108);
          mDNSPreferencesSetNames(2, (__int128 *)(*(_QWORD *)a1 + 108), v402);
          v68 = *(_QWORD *)a1;
          *(_DWORD *)(v68 + 496) = 0;
          v69 = *v402;
          v70 = v403[5];
          v71 = v403[6];
          *(_OWORD *)(v68 + 156) = v403[7];
          *(_OWORD *)(v68 + 140) = v71;
          *(_OWORD *)(v68 + 124) = v70;
          *(_OWORD *)(v68 + 108) = v69;
          v55 = *(_QWORD *)a1;
        }
        *(_DWORD *)(v55 + 492) = 0;
      }
      else
      {
        v61 = v409;
        if ((int)(v409 - v60) > 0)
          v61 = *(_DWORD *)(v55 + 492);
        v409 = v61;
      }
    }
    v72 = mDNS_TimeNow(mDNSStorage, v46, v47, v48, v49, v50, v51, v52);
    if (!all_requests)
      goto LABEL_118;
    v78 = v72;
    if (v72 <= 1)
      v79 = 1;
    else
      v79 = v72;
    v416 = v79;
    v419 = v72 + 1000;
    v80 = &all_requests;
    v81 = (_BYTE *)&unk_100158000;
    do
    {
      timeout.tv_sec = 0;
      v82 = *v80;
      timeout.tv_sec = v82;
      if (*(void (**)(uint64_t))(v82 + 104) == resolve_termination_callback)
      {
        v91 = *(_QWORD *)(v82 + 128);
        v92 = *(_DWORD *)(v91 + 1412);
        if (v92)
        {
          if (((v78 - v92) & 0x80000000) == 0)
          {
            *(_DWORD *)(v91 + 1412) = 0;
            if (*(_BYTE *)(v91 + 1417))
              v93 = 1;
            else
              v93 = *(_QWORD *)(v91 + 1392) != 0;
            if (*(_BYTE *)(v91 + 1418))
            {
              v94 = 1;
              if (!v93)
                goto LABEL_68;
            }
            else
            {
              v94 = *(_QWORD *)(v91 + 1400) != 0;
              if (!v93)
                goto LABEL_68;
            }
            if (v94)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Client application PID[%d](%s) has received results for DNSServiceResolve(%##s) yet remains active over two minutes.", v73, v74, v75, v76, v77, *(_DWORD *)(v82 + 180));
          }
        }
      }
LABEL_68:
      v84 = (_QWORD *)(v82 + 96);
      v83 = *(int8x16_t **)(v82 + 96);
      if (!v83)
        goto LABEL_105;
      while (1)
      {
        if (v83->i64[0])
          v83[2].i32[3] |= 0x1000000u;
        v85 = v83->u32[3];
        v86 = (v83->i32[2] - v85);
        v83[1] = vrev32q_s8(v83[1]);
        v83[2].i32[2] = bswap32(v83[2].u32[2]);
        v87 = send(*(_DWORD *)(v82 + 176), &v83[1].i8[v85], v86, 0);
        v83[1] = vrev32q_s8(v83[1]);
        v83[2].i32[2] = bswap32(v83[2].u32[2]);
        if ((v87 & 0x8000000000000000) == 0)
          goto LABEL_75;
        if (*__error() != 4 && *__error() != 35)
          break;
        LODWORD(v87) = 0;
LABEL_75:
        v88 = v83->i32[2];
        v89 = v83->i32[3] + v87;
        v83->i32[3] = v89;
        if (v89 != v88)
          goto LABEL_94;
        v90 = *(_QWORD **)(v82 + 96);
        *(_QWORD *)(v82 + 96) = *v90;
        free(v90);
        *(_DWORD *)(v82 + 236) = 0;
        *(_BYTE *)(v82 + 285) = 0;
        v83 = *(int8x16_t **)(v82 + 96);
        if (!v83)
          goto LABEL_105;
      }
      if (*__error() == 32)
      {
        *(_BYTE *)(v82 + 283) = 4;
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) because connection is terminated by the client", v95, v96, v97, v98, v99, *(_DWORD *)(v82 + 176));
      }
      else
      {
        v100 = mDNSLogCategory_Default;
        __error();
        v101 = __error();
        strerror(*v101);
        v4 = &unk_100164000;
        LogMsgWithLevel(v100, OS_LOG_TYPE_DEFAULT, "send_msg ERROR: failed to write %u of %d bytes to fd %d errno %d (%s)", v102, v103, v104, v105, v106, v86);
        v81 = &unk_100158000;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) because of error - aborting connection", v107, v108, v109, v110, v111, *(_DWORD *)(v82 + 176));
        LogClientInfo(v82);
      }
      abort_request(v82);
LABEL_94:
      if (!*v84)
        goto LABEL_105;
      v112 = v409;
      if ((int)(v409 - v78) > 1000)
        v112 = v419;
      v409 = v112;
      v113 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[296])
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_102;
      }
      else
      {
        v113 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_102:
          v114 = *(_DWORD *)(v82 + 192);
          *(_DWORD *)block = 67109376;
          *(_DWORD *)&block[4] = v114;
          *(_WORD *)&block[8] = 1024;
          *(_DWORD *)&block[10] = v409 - v78;
          _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "[R%u] Could not send all replies. Will try again in %d ticks.", block, 0xEu);
        }
      }
      if (v81[3669])
      {
        *(_DWORD *)(v82 + 236) = 0;
        goto LABEL_105;
      }
      v115 = *(_DWORD *)(v82 + 236);
      if (!v115)
      {
        *(_DWORD *)(v82 + 236) = v416;
LABEL_105:
        v5 = &unk_100164000;
        goto LABEL_106;
      }
      if ((int)(v78 - v115) < 10000 * *(unsigned __int8 *)(v82 + 285) + 10000)
        goto LABEL_105;
      v116 = -1;
      do
      {
        v84 = (_QWORD *)*v84;
        ++v116;
      }
      while (v84);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) after %ld seconds, %d repl%s waiting", v73, v74, v75, v76, v77, *(_DWORD *)(v82 + 176));
      v117 = ++*(_BYTE *)(v82 + 285);
      v5 = &unk_100164000;
      if (v117 >= 0x3C)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Client PID[%d](%s) unresponsive; aborting connection",
          v73,
          v74,
          v75,
          v76,
          v77,
          *(_DWORD *)(v82 + 176));
        LogClientInfo(v82);
        abort_request(v82);
      }
LABEL_106:
      if ((*(_DWORD *)(v82 + 176) & 0x80000000) != 0)
      {
        *v80 = *(_QWORD *)(v82 + 16);
        request_state_forget(&timeout);
      }
      else
      {
        v80 = (__darwin_time_t *)(v82 + 16);
      }
    }
    while (*v80);
LABEL_118:
    if (dnssd_server_idle_s_once != -1)
      dispatch_once(&dnssd_server_idle_s_once, &__block_literal_global_12);
    a1 = v404;
    dispatch_source_merge_data((dispatch_source_t)dnssd_server_idle_s_source, 1uLL);
    if (&_NEHelperTrackerGetAppInfo || _os_feature_enabled_impl("symptomsd", "networking_transparency"))
    {
      v118 = (_QWORD *)s_head_0;
      if (s_head_0)
      {
        do
        {
          _cache_item_report((uint64_t)v118);
          v118 = (_QWORD *)*v118;
        }
        while (v118);
      }
    }
    v119 = _os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache");
    if (!(_DWORD)v119)
      goto LABEL_198;
    v119 = mDNS_TimeNow(mDNSStorage, v120, v121, v122, v123, v124, v125, v126);
    v127 = s_interface_head_0;
    if (!s_interface_head_0)
      goto LABEL_198;
    v128 = v119;
    v129 = 0;
    v407 = 0;
    v130 = 0;
    while (2)
    {
      v410 = *(uint64_t **)v127;
      v130 += 40;
      v131 = *(_QWORD **)(v127 + 8);
      v412 = (_QWORD *)(v127 + 8);
      if (!v131)
        goto LABEL_166;
      v411 = v127;
      v408 = v129;
      v417 = v130;
      v132 = 0;
      v414 = 0;
      while (2)
      {
        v133 = (_QWORD *)*v131;
        v134 = (_QWORD *)v131[1];
        if (!v134)
          goto LABEL_152;
        v135 = 0;
        v136 = 0;
        while (2)
        {
          v137 = v134;
          v134 = (_QWORD *)*v134;
          v138 = v128 - *((_DWORD *)v137 + 3);
          if (v138 >= 86400000)
          {
            v140 = _unicast_assist_cache_log();
            v145 = objc_claimAutoreleasedReturnValue(v140);
            if (!os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
              goto LABEL_141;
            v141 = *((_DWORD *)v137 + 2);
            *(_QWORD *)block = 0x1404120302;
            *(_WORD *)&block[8] = 2098;
            *(_QWORD *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v141;
            v142 = v145;
            v143 = "unicast assist qhash flushed (aged) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
            goto LABEL_149;
          }
          if (v138 < 10000 || *((_BYTE *)v137 + 16) == 0)
          {
            ++v135;
            goto LABEL_144;
          }
          v144 = _unicast_assist_cache_log();
          v145 = objc_claimAutoreleasedReturnValue(v144);
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
          {
            v149 = *((_DWORD *)v137 + 2);
            *(_QWORD *)block = 0x1404120302;
            *(_WORD *)&block[8] = 2098;
            *(_QWORD *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v149;
            v142 = v145;
            v143 = "unicast assist qhash flushed (pending) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
LABEL_149:
            _os_log_debug_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEBUG, v143, block, 0x18u);
          }
LABEL_141:

          v147 = v137;
          v148 = v131 + 1;
          if ((_QWORD *)v131[1] != v137)
          {
            v147 = *v136;
            v148 = v136;
          }
          *v148 = *v147;
          free(v137);
          v137 = 0;
LABEL_144:
          if (v137)
            v136 = (_QWORD **)v137;
          if (v134)
            continue;
          break;
        }
        if (v135)
        {
          ++v414;
          v417 += 24 * v135 + 40;
          v4 = (_QWORD *)&unk_100164000;
          goto LABEL_160;
        }
LABEL_152:
        v150 = _unicast_assist_cache_log();
        v151 = objc_claimAutoreleasedReturnValue(v150);
        if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
        {
          v154 = *(_QWORD *)(v411 + 24);
          v155 = *(_DWORD *)(v411 + 32);
          *(_QWORD *)block = 0x1404120402;
          *(_WORD *)&block[8] = 2098;
          *(_QWORD *)&block[10] = v131 + 2;
          *(_WORD *)&block[18] = 1024;
          *(_DWORD *)&block[20] = v154;
          LOWORD(v424) = 1024;
          *(_DWORD *)((char *)&v424 + 2) = v155;
          _os_log_debug_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEBUG, "unicast assist record flushed (0 qhashes) - %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x", block, 0x1Eu);
        }

        if ((_QWORD *)*v412 == v131)
        {
          v152 = (_QWORD *)*v131;
          *v412 = *v131;
          v153 = v412;
        }
        else
        {
          v152 = (_QWORD *)**v132;
          *v132 = v152;
          v153 = v132;
        }
        v4 = (_QWORD *)&unk_100164000;
        if (!v152)
          *(_QWORD *)(v411 + 16) = v153;
        _unicast_assist_cache_free_addr(v131);
        v131 = 0;
LABEL_160:
        if (v131)
          v132 = (_QWORD **)v131;
        v131 = v133;
        if (v133)
          continue;
        break;
      }
      v129 = v408;
      if (v414)
      {
        v407 += v414;
        v5 = &unk_100164000;
        v130 = v417;
        v156 = (uint64_t *)v411;
        goto LABEL_172;
      }
      v5 = &unk_100164000;
      v130 = v417;
      v127 = v411;
LABEL_166:
      v157 = _unicast_assist_cache_log();
      v158 = objc_claimAutoreleasedReturnValue(v157);
      if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
      {
        v161 = *(_QWORD *)(v127 + 24);
        v162 = *(_DWORD *)(v127 + 32);
        *(_DWORD *)block = 67109376;
        *(_DWORD *)&block[4] = v161;
        *(_WORD *)&block[8] = 1024;
        *(_DWORD *)&block[10] = v162;
        _os_log_debug_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEBUG, "unicast assist interface flushed (0 addrs) - interface %2.2d ifhash %x", block, 0xEu);
      }

      v159 = &s_interface_head_0;
      if (s_interface_head_0 == v127)
      {
        v160 = (uint64_t *)v127;
      }
      else
      {
        v160 = (uint64_t *)*v129;
        v159 = v129;
      }
      *v159 = *v160;
      _unicast_assist_cache_free_interface((uint64_t **)v127);
      v156 = 0;
LABEL_172:
      if (v156)
        v129 = v156;
      v127 = (uint64_t)v410;
      if (v410)
        continue;
      break;
    }
    a1 = v404;
    if (v130 > 0x8000)
    {
      v163 = v130;
      v164 = 0;
      v165 = v407;
      while (1)
      {
        v166 = (_QWORD *)s_interface_head_0;
        if (!s_interface_head_0)
          break;
        v167 = 0;
        v168 = 0;
        do
        {
          v169 = v166[1];
          if (v169)
          {
            v170 = *(_QWORD *)(v169 + 8);
            if (v170)
            {
              v171 = v128 - *(_DWORD *)(v170 + 12);
              if (v171 > v167)
              {
                v168 = v166;
                v167 = v171;
              }
            }
          }
          v166 = (_QWORD *)*v166;
        }
        while (v166);
        if (!v168)
          break;
        v173 = (_QWORD **)(v168 + 1);
        v172 = (_QWORD *)v168[1];
        if (!v172)
          break;
        v174 = v172 + 1;
        v164 += 16;
        do
        {
          v174 = (_QWORD *)*v174;
          v164 += 24;
        }
        while (v174);
        v175 = _unicast_assist_cache_log();
        v176 = objc_claimAutoreleasedReturnValue(v175);
        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
        {
          v179 = v168[3];
          v180 = *((_DWORD *)v168 + 8);
          *(_DWORD *)block = 67110146;
          *(_DWORD *)&block[4] = v167 / 0x3E8u;
          *(_WORD *)&block[8] = 1042;
          *(_DWORD *)&block[10] = 20;
          *(_WORD *)&block[14] = 2098;
          *(_QWORD *)&block[16] = v172 + 2;
          LOWORD(v424) = 1024;
          *(_DWORD *)((char *)&v424 + 2) = v179;
          HIWORD(v424) = 1024;
          LODWORD(v425[0]) = v180;
          _os_log_debug_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEBUG, "unicast assist cache maintenance record flushed (memory) - age %ds %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x", block, 0x24u);
        }

        v177 = (_QWORD *)**v173;
        *v173 = v177;
        if (!v177)
          v168[2] = v173;
        _unicast_assist_cache_free_addr(v172);
        --v165;
        v178 = (void *)(v163 - v164);
        if (v163 - v164 <= 0x8000)
          goto LABEL_195;
      }
      v178 = (void *)(v163 - v164);
LABEL_195:
      v181 = _unicast_assist_cache_log();
      v182 = objc_claimAutoreleasedReturnValue(v181);
      v4 = &unk_100164000;
      a1 = v404;
      if (os_log_type_enabled(v182, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)block = 134218752;
        *(_QWORD *)&block[4] = v163;
        *(_WORD *)&block[12] = 2048;
        *(_QWORD *)&block[14] = v407;
        *(_WORD *)&block[22] = 2048;
        v424 = v178;
        LOWORD(v425[0]) = 2048;
        *(_QWORD *)((char *)v425 + 2) = v165;
        _os_log_debug_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEBUG, "unicast assist cache maintenance - (Was) size %zu count %zu | (Is) size %zu count %zu", block, 0x2Au);
      }

    }
LABEL_198:
    v190 = mDNSPlatformRawTime(v119, v120, v121, v122, v123, v124, v125, v126) - v405;
    v191 = &unk_100164000;
    if (v190 >= WatchDogReportingThreshold)
    {
      v192 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[296])
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_204;
      }
      else
      {
        v192 = *((_QWORD *)v5 + 297);
        if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
        {
LABEL_204:
          *(_DWORD *)block = 67109120;
          *(_DWORD *)&block[4] = v190;
          _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_DEFAULT, "WARNING: Idle task took %d ms to complete", block, 8u);
        }
      }
    }
    v193 = mDNS_TimeNow((_DWORD *)a1, v183, v184, v185, v186, v187, v188, v189);
    v194 = *(_DWORD *)(a1 + 76);
    if (v194)
    {
      v195 = (unsigned __int8 *)xmmword_10015BF10;
      if ((_QWORD)xmmword_10015BF10)
      {
        while (1)
        {
          v196 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[296])
            break;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            goto LABEL_215;
LABEL_216:
          if (mDNS_LoggingEnabled == 1)
            usleep(0x2710u);
          v195 = *(unsigned __int8 **)v195;
          if (!v195)
          {
            v194 = *(_DWORD *)(a1 + 76);
            goto LABEL_220;
          }
        }
        v196 = *((_QWORD *)v5 + 297);
        if (!os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT))
          goto LABEL_216;
LABEL_215:
        GetRRDisplayString_rdb(v195 + 8, (unsigned __int16 *)(*((_QWORD *)v195 + 6) + 4), v406);
        *(_DWORD *)block = 141558275;
        *(_QWORD *)&block[4] = 1752392040;
        *(_WORD *)&block[12] = 2085;
        *(_QWORD *)&block[14] = v406;
        _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "Cannot exit yet; Resource Record still exists: %{sensitive, mask.hash}s",
          block,
          0x16u);
        goto LABEL_216;
      }
LABEL_220:
      if (v193 - v194 < 0 && *(_QWORD *)(a1 + 12616))
      {
        v199 = v409;
        if ((int)(v409 - v194) >= 0)
          v199 = v194;
        v409 = v199;
        goto LABEL_225;
      }
LABEL_474:
      v396 = *((_QWORD *)v191 + 295);
      if (gSensitiveLoggingEnabled != 1 || v396 == v4[296])
      {
        if (os_log_type_enabled(*((os_log_t *)v191 + 295), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)block = 0;
LABEL_480:
          _os_log_impl((void *)&_mh_execute_header, v396, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit", block, 2u);
        }
      }
      else
      {
        v396 = *((_QWORD *)v5 + 297);
        if (os_log_type_enabled(v396, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)block = 0;
          goto LABEL_480;
        }
      }
      mDNS_FinalExit();
      usleep(0x3E8u);
      exit(0);
    }
LABEL_225:
    if (*(_DWORD *)(a1 + 152))
    {
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", 8427);
      if ((_DWORD)qword_100158E5C || HIDWORD(qword_100158E5C) - v193 >= 1 && dword_100158E7C - v193 > 0)
        goto LABEL_227;
      dword_100158E7C = v193 + 0x40000000;
      v203 = xmmword_100158E88;
      if ((_QWORD)xmmword_100158E88)
      {
        while (!*(_WORD *)(v203 + 340)
             || !*(_BYTE *)(v203 + 632)
             || *(_DWORD *)(v203 + 272)
             || !*(_QWORD *)(v203 + 112))
        {
          v203 = *(_QWORD *)(v203 + 8);
          if (!v203)
            goto LABEL_236;
        }
        if (mDNS_LoggingEnabled == 1)
        {
          v374 = mDNSLogCategory_Default;
          v375 = v203 + 376;
          DNSTypeName(*(unsigned __int16 *)(v203 + 342));
          LogMsgWithLevel(v374, OS_LOG_TYPE_DEFAULT, "mDNSCoreReadyForSleep: waiting for LLQ %##s (%s)", v376, v377, v378, v379, v380, v375);
        }
LABEL_227:
        v200 = 0;
        v201 = 1;
        v202 = 8531;
      }
      else
      {
LABEL_236:
        v204 = (uint64_t *)xmmword_10015BF10;
        if ((_QWORD)xmmword_10015BF10)
        {
          while (v204[4]
               || *((_BYTE *)v204 + 122)
               || IsLocalDomain((_BYTE *)v204[5])
               || *((_DWORD *)v204 + 86) != 5
               || !v204[48])
          {
            v204 = (uint64_t *)*v204;
            if (!v204)
              goto LABEL_243;
          }
          if (mDNS_LoggingEnabled == 1)
          {
            v381 = mDNSLogCategory_Default;
            v382 = *((_DWORD *)v204 + 91);
            GetRRDisplayString_rdb((unsigned __int8 *)v204 + 8, (unsigned __int16 *)(v204[6] + 4), word_100164580);
            v399 = v382;
            v191 = &unk_100164000;
            LogMsgWithLevel(v381, OS_LOG_TYPE_DEFAULT, "mDNSCoreReadyForSleep: waiting for Record updateIntID 0x%x 0x%x (updateid %d) %s", v383, v384, v385, v386, v387, v399);
          }
          goto LABEL_227;
        }
LABEL_243:
        v201 = 0;
        v200 = 1;
        v202 = 8490;
      }
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", v202);
      v213 = BYTE1(dword_100158E54);
      if (!BYTE1(dword_100158E54) || (v200 & 1) != 0)
      {
        *(_QWORD *)(mDNSStorage[0] + 600) = 0;
        if (v213)
          goto LABEL_249;
        LogMsgWithLevel(*((NSObject **)v191 + 295), OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Sleep request was canceled with %d ticks remaining", v208, v209, v210, v211, v212, HIDWORD(qword_100158E5C) - v193);
        v273 = 0;
        goto LABEL_352;
      }
      if (v193 - HIDWORD(qword_100158E5C) < 0)
      {
        v274 = v409;
        if ((int)(v409 - *(_DWORD *)(a1 + 152)) >= 0)
          v274 = *(_DWORD *)(a1 + 152);
        v409 = v274;
      }
      else
      {
        *(_QWORD *)(mDNSStorage[0] + 600) = 0;
LABEL_249:
        if (HIBYTE(dword_100158E54)
          && (HaveAdvertisedMulticastServices = mDNSCoreHaveAdvertisedMulticastServices(xmmword_10015BF10),
              (_DWORD)HaveAdvertisedMulticastServices))
        {
          *(_QWORD *)block = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetDHCP);
          v420 = v201;
          if (!*(_QWORD *)block)
          {
            LogMsgWithLevel(*((NSObject **)v191 + 295), OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: SCDynamicStoreKeyCreateNetworkServiceEntity failed\n", v214, v215, v216, v217, v218, v397);
            v225 = 86400;
            goto LABEL_306;
          }
          v224 = CFArrayCreate(0, (const void **)block, 1, &kCFTypeArrayCallBacks);
          if (*(_QWORD *)block)
          {
            CFRelease(*(CFTypeRef *)block);
            *(_QWORD *)block = 0;
          }
          v225 = 86400;
          if (v224)
          {
            v226 = SCDynamicStoreCreate(0, CFSTR("DHCP-LEASES"), 0, 0);
            v225 = 86400;
            if (!v226)
              goto LABEL_305;
            v227 = v226;
            v228 = SCDynamicStoreCopyMultiple(v226, 0, v224);
            v418 = 86400;
            if (!v228)
              goto LABEL_304;
            v229 = v228;
            v415 = v224;
            Count = CFDictionaryGetCount(v228);
            v418 = 86400;
            if (Count < 1)
              goto LABEL_303;
            v231 = Count;
            if ((unint64_t)Count >> 61
              || (v232 = (const void **)malloc_type_calloc(Count, 8uLL, 0xF1748037uLL)) == 0)
            {
              __break(1u);
              goto LABEL_474;
            }
            v233 = v232;
            v413 = v227;
            CFDictionaryGetKeysAndValues(v229, 0, v232);
            v234 = 0;
            v418 = 86400;
            while (2)
            {
              v235 = (const __CFDictionary *)v233[v234];
              if (v235)
              {
                v236 = v231;
                LeaseStartTime = DHCPInfoGetLeaseStartTime((CFDictionaryRef)v233[v234]);
                OptionData = DHCPInfoGetOptionData(v235, 0x33u);
                v244 = OptionData;
                if (LeaseStartTime)
                  v245 = OptionData == 0;
                else
                  v245 = 1;
                if (v245)
                {
                  v246 = mDNSLogCategory_Default;
                  if (OptionData)
                    goto LABEL_272;
                  goto LABEL_273;
                }
                if (CFDataGetLength(OptionData) > 3)
                {
                  BytePtr = CFDataGetBytePtr(v244);
                  if (!BytePtr)
                  {
                    v191 = &unk_100164000;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: CFDataGetBytePtr %ld failed", v248, v249, v250, v251, v252, v234);
                    goto LABEL_274;
                  }
                  v253 = (unsigned int *)BytePtr;
                  Current = CFAbsoluteTimeGetCurrent();
                  v260 = Current - CFDateGetAbsoluteTime(LeaseStartTime);
                  v261 = fmin(v260, 4294967300.0);
                  if (v260 < 0.0)
                    v261 = 0;
                  v262 = bswap32(*v253);
                  v263 = v262 - v261;
                  if (v262 < v261)
                    v263 = 0;
                  v231 = v236;
                  if (v263 < 0x3D)
                    v264 = 54;
                  else
                    v264 = v263 - v263 / 0xA;
                  v191 = &unk_100164000;
                  if (mDNS_LoggingEnabled == 1)
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DHCP Address Lease Elapsed %6u Lifetime %6u Remaining %6u Wake %6u", v255, v256, v257, v258, v259, v261);
                  if (v418 >= v264)
                    v265 = v264;
                  else
                    v265 = v418;
                  v418 = v265;
                }
                else
                {
                  v246 = mDNSLogCategory_Default;
LABEL_272:
                  CFDataGetLength(v244);
LABEL_273:
                  LogMsgWithLevel(v246, OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: SCDynamicStoreCopyDHCPInfo index %d failed CFDateRef start %p CFDataRef lease %p CFDataGetLength(lease) %d", v239, v240, v241, v242, v243, v234);
                  v191 = &unk_100164000;
LABEL_274:
                  v231 = v236;
                }
              }
              else
              {
                v191 = &unk_100164000;
              }
              if (v231 == ++v234)
              {
                free(v233);
                v227 = v413;
LABEL_303:
                CFRelease(v229);
                v224 = v415;
LABEL_304:
                CFRelease(v227);
                v225 = v418;
LABEL_305:
                CFRelease(v224);
                break;
              }
              continue;
            }
          }
LABEL_306:
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(*((NSObject **)v191 + 295), OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: DHCP Wake %d", v219, v220, v221, v222, v223, v225);
          v280 = v193 + 7200000;
          for (i = (uint64_t *)xmmword_10015C748; i; i = (uint64_t *)*i)
          {
            if (*((_BYTE *)i + 172))
            {
              v282 = *((_DWORD *)i + 2);
              if (v282)
              {
                if (v282 - v193 >= 4001)
                {
                  v283 = (v282 - v193) / -10 + v282;
                  if (v280 - v283 > 0)
                    v280 = v283;
                  if (mDNS_LoggingEnabled == 1)
                    LogMsgWithLevel(*((NSObject **)v191 + 295), OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: %p %s Int %5d Ext %5d Err %d Retry %5d Interval %5d Expire %5d Wake %5d", v219, v220, v221, v222, v223, (int)i);
                }
              }
            }
          }
          v284 = v225;
          for (j = (uint64_t *)xmmword_10015BF10; j; j = (uint64_t *)*j)
          {
            v286 = *((_DWORD *)j + 88);
            if (v286 && v286 - v193 >= 4001)
            {
              v287 = (v286 - v193) / -10 + v286;
              if (v280 - v287 > 0)
                v280 = v287;
              if (mDNS_LoggingEnabled == 1)
              {
                v288 = *((_QWORD *)v191 + 295);
                GetRRDisplayString_rdb((unsigned __int8 *)j + 8, (unsigned __int16 *)(j[6] + 4), word_100164580);
                v5 = &unk_100164000;
                v191 = &unk_100164000;
                v4 = (_QWORD *)&unk_100164000;
                LogMsgWithLevel(v288, OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: %p Int %7d Next %7d Expire %7d Wake %7d %s", v289, v290, v291, v292, v293, (int)j);
              }
            }
          }
          if ((v280 - v193) / 1000 <= v284 || v280 - v193 <= -1000)
            v295 = (v280 - v193) / 1000;
          else
            v295 = v284;
          v296 = v295 > 3600;
          if (v295 <= 60)
            v295 = 60;
          if ((v420 & v296) != 0)
            v297 = 3600;
          else
            v297 = v295;
          mdns_power_cancel_all_events(CFSTR("com.apple.mDNSResponder"));
          v298 = mdns_power_schedule_wake(v297);
          v273 = v298;
          if (v298)
          {
            a1 = v404;
            if (v298 != -536870184)
              goto LABEL_349;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds unsuccessful; retrying with longer intervals",
              v299,
              v300,
              v301,
              v302,
              v303,
              v297);
            do
            {
              v304 = v297 + 3;
              if (v297 + 3 < 0)
                v304 = v297 + 6;
              v305 = v304 >> 2;
              if (v297 < 20)
                v305 = 1;
              v297 += v305;
              v306 = mdns_power_schedule_wake(v297);
            }
            while (v306 == -536870184);
            if (v306)
            {
LABEL_349:
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds unsuccessful: %d %X", v299, v300, v301, v302, v303, v297);
            }
            else if (mDNS_LoggingEnabled == 1)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested later wakeup in %d seconds; will also attempt IOCancelPowerChange",
                v299,
                v300,
                v301,
                v302,
                v303,
                v297);
            }
          }
          else
          {
            a1 = v404;
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds", v299, v300, v301, v302, v303, v297);
          }
          HaveAdvertisedMulticastServices = time(0);
          *(_QWORD *)(mDNSStorage[0] + 600) = v297 + (int)HaveAdvertisedMulticastServices;
        }
        else
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v266 = *((_QWORD *)v191 + 295);
            if (HIBYTE(dword_100158E54))
              v267 = "is";
            else
              v267 = "not";
            mDNSCoreHaveAdvertisedMulticastServices(*(_QWORD *)((char *)&dword_100158E54
                                                              + &loc_1000030B4
                                                              + 5
                                                              + 3));
            LogMsgWithLevel(v266, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Not scheduling wakeup: SystemWakeOnLAN %s enabled; %s advertised services",
              v268,
              v269,
              v270,
              v271,
              v272,
              (int)v267);
          }
          v273 = 0;
        }
        BYTE1(dword_100158E54) = 2;
        mDNSMacOSXNetworkChanged(HaveAdvertisedMulticastServices, v206, v207, v208, v209, v210, v211, v212);
LABEL_352:
        if (mDNS_LoggingEnabled == 1)
        {
          v307 = "IOCancelPowerChange";
          if (!v273)
            v307 = "IOAllowPowerChange";
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: %s(%lX) %s at %ld (%d ticks remaining)", v275, v276, v277, v278, v279, (int)v307);
        }
        HIDWORD(qword_100158E5C) = 0;
        dword_100158E64 = time(0);
        v308 = *(_DWORD *)(mDNSStorage[0] + 568);
        v309 = *(_QWORD *)(mDNSStorage[0] + 592);
        if (v273)
          IOCancelPowerChange(v308, v309);
        else
          IOAllowPowerChange(v308, v309);
        v191 = &unk_100164000;
      }
    }
    if ((int)(v409 - v193) <= 1)
      v310 = 1;
    else
      v310 = v409 - v193;
    if (v310 > 1)
    {
LABEL_425:
      KQueueLoop_RepeatedBusy = 0;
    }
    else if (++KQueueLoop_RepeatedBusy >= 1000)
    {
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5626);
      LogMsgWithLevel(*((NSObject **)v191 + 295), OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** Continuously busy for more than a second", v311, v312, v313, v314, v315, v397);
      if (!*((_QWORD *)&xmmword_100158E88 + 1)
        || (v321 = *(_DWORD *)(*((_QWORD *)&xmmword_100158E88 + 1) + 204)) != 0 && dword_100158E08 - v321 < 0)
      {
        v329 = 0;
      }
      else
      {
        v322 = *((_QWORD *)v191 + 295);
        v323 = DWORD2(xmmword_100158E88) + 376;
        DNSTypeName(*(unsigned __int16 *)(*((_QWORD *)&xmmword_100158E88 + 1) + 342));
        LogMsgWithLevel(v322, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewQuestion %##s (%s)", v324, v325, v326, v327, v328, v323);
        v329 = 1;
      }
      if (qword_100158EA8)
      {
        ++v329;
        v330 = mDNSLogCategory_Default;
        v331 = qword_100158EA8 + 376;
        DNSTypeName(*(unsigned __int16 *)(qword_100158EA8 + 342));
        LogMsgWithLevel(v330, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalOnlyQuestions %##s (%s)", v332, v333, v334, v335, v336, v331);
      }
      v337 = qword_10015BF20;
      v338 = (_DWORD *)&unk_100158000;
      if (qword_10015BF20)
      {
        while (*(_BYTE *)(v337 + 8) == 2)
        {
          v337 = *(_QWORD *)v337;
          if (!v337)
            goto LABEL_377;
        }
        ++v329;
        v339 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v337 + 8), (unsigned __int16 *)(*(_QWORD *)(v337 + 48) + 4), word_100164580);
        v340 = v339;
        v338 = &unk_100158000;
        LogMsgWithLevel(v340, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalRecords %s", v341, v342, v343, v344, v345, (int)word_100164580);
      }
LABEL_377:
      if (byte_10015BF30)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalOnlyRecords", v316, v317, v318, v319, v320, v398);
      }
      if ((_QWORD)xmmword_10015C8D0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: SPSProxyListChanged", v316, v317, v318, v319, v320, v398);
      }
      if ((_BYTE)dword_100158E54)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: LocalRemoveEvents", v316, v317, v318, v319, v320, v398);
      }
      v346 = dword_100158E08;
      if (dword_100158E08 - dword_10015BF50 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextuDNSEvent %d", v316, v317, v318, v319, v320, dword_100158E08 - dword_10015BF50);
        v346 = v338[898];
      }
      if (v346 - dword_100158E30 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledNATOp %d", v316, v317, v318, v319, v320, v346 - dword_100158E30);
        v346 = v338[898];
      }
      if (dword_10015BF54 && v346 - dword_10015BF54 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextSRVUpdate %d", v316, v317, v318, v319, v320, v346 - dword_10015BF54);
        v346 = v338[898];
      }
      if (v346 - dword_100158E20 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextCacheCheck %d", v316, v317, v318, v319, v320, v346 - dword_100158E20);
        v346 = v338[898];
      }
      if (v346 - dword_100158E34 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledSPS %d", v316, v317, v318, v319, v320, v346 - dword_100158E34);
        v346 = v338[898];
      }
      v347 = v346 - dword_100158E38;
      if (v347 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledKA %d", v316, v317, v318, v319, v320, v347);
      }
      v348 = qword_100158E5C;
      if ((_DWORD)qword_100158E5C
        || HIDWORD(qword_100158E5C)
        && dword_100158E08 - dword_100158E7C >= 0
        && (++v329,
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledSPRetry %d", v316, v317, v318, v319, v320, dword_100158E08 - dword_100158E7C), (v348 = qword_100158E5C) != 0))
      {
        v349 = v338[898] - v348;
        if (v349 >= 0)
        {
          ++v329;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->DelaySleep %d", v316, v317, v318, v319, v320, v349);
        }
      }
      v350 = dword_100158E08;
      if ((_DWORD)qword_100158E18 && dword_100158E08 - (int)qword_100158E18 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->SuppressQueries %d", v316, v317, v318, v319, v320, dword_100158E08 - qword_100158E18);
        v350 = v338[898];
      }
      if (HIDWORD(qword_100158E18) && v350 - HIDWORD(qword_100158E18) >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->SuppressResponses %d", v316, v317, v318, v319, v320, v350 - HIDWORD(qword_100158E18));
        v350 = v338[898];
      }
      if (v350 - dword_100158E24 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledQuery %d", v316, v317, v318, v319, v320, v350 - dword_100158E24);
        v350 = v338[898];
      }
      if (v350 - dword_100158E28 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledProbe %d", v316, v317, v318, v319, v320, v350 - dword_100158E28);
        v350 = v338[898];
      }
      if (v350 - dword_100158E2C >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledResponse %d", v316, v317, v318, v319, v320, v350 - dword_100158E2C);
        v350 = v338[898];
      }
      if (v350 - dword_100158E80 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledStopTime %d", v316, v317, v318, v319, v320, v350 - dword_100158E80);
        v350 = v338[898];
      }
      v351 = v350 - dword_100158E10;
      if (v351 >= 0)
      {
        ++v329;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledEvent %d", v316, v317, v318, v319, v320, v351);
      }
      if (dword_100158DD0)
      {
        v352 = v338[898] - dword_100158DD0;
        if (v352 >= 0)
        {
          ++v329;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NetworkChanged %d", v316, v317, v318, v319, v320, v352);
        }
      }
      if (v329)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** %d potential cause%s identified (significant only if the same cause consistently appears)", v316, v317, v318, v319, v320, v329);
      else
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** No likely causes identified", v316, v317, v318, v319, v320, v398);
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5694);
      v191 = &unk_100164000;
      goto LABEL_425;
    }
    pthread_mutex_unlock(&stru_1001508F0);
    if (*(_DWORD *)(*(_QWORD *)a1 + 104))
    {
      SetLowWater(*(_QWORD *)a1 + 8, 0x10000);
      if (v310 >= 125)
        v310 = 125;
    }
    timeout.tv_sec = v310 / 1000;
    timeout.tv_nsec = 1000000 * (v310 % 1000);
    if (kevent(KQueueFD, 0, 0, &eventlist, 1, &timeout) < 0)
    {
      v353 = *((_QWORD *)v191 + 295);
      if (gSensitiveLoggingEnabled != 1 || v353 == v4[296])
      {
        if (os_log_type_enabled(*((os_log_t *)v191 + 295), OS_LOG_TYPE_DEFAULT))
          goto LABEL_435;
      }
      else
      {
        v353 = *((_QWORD *)v5 + 297);
        if (os_log_type_enabled(v353, OS_LOG_TYPE_DEFAULT))
        {
LABEL_435:
          v354 = KQueueFD;
          v355 = *__error();
          v356 = __error();
          v357 = strerror(*v356);
          *(_DWORD *)block = 67109634;
          *(_DWORD *)&block[4] = v354;
          *(_WORD *)&block[8] = 1024;
          *(_DWORD *)&block[10] = v355;
          *(_WORD *)&block[14] = 2082;
          *(_QWORD *)&block[16] = v357;
          _os_log_impl((void *)&_mh_execute_header, v353, OS_LOG_TYPE_DEFAULT, "kevent(%d) failed errno %d (%{public}s)", block, 0x18u);
        }
      }
      sleep(1u);
    }
    pthread_mutex_lock(&stru_1001508F0);
    if (*(_DWORD *)(*(_QWORD *)a1 + 104))
    {
      SetLowWater(*(_QWORD *)a1 + 8, 1);
      *(_DWORD *)(*(_QWORD *)a1 + 104) = 0;
    }
LABEL_439:
    while (2)
    {
      v6 = kevent(KQueueFD, 0, 0, &eventlist, 1, &KQueueLoop_zero_timeout);
      if ((_DWORD)v6)
      {
        if ((int)v6 > 1)
          goto LABEL_462;
        if ((v6 & 0x80000000) == 0)
        {
          v358 = 0;
          v359 = 32 * v6;
          while (1)
          {
            v360 = *(uint64_t *)((char *)&eventlist.udata + v358);
            v361 = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
            v362 = *(_QWORD *)(v360 + 16);
            v363 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))v360)(LODWORD(eventlist.ident), *(__int16 *)((char *)&eventlist.filter + v358), *(_QWORD *)(v360 + 8), *(unsigned __int16 *)((char *)&eventlist.flags + v358) >> 15);
            v6 = mDNSPlatformRawTime(v363, v364, v365, v366, v367, v368, v369, v370);
            v371 = v6 - v361;
            if ((int)v6 - v361 >= WatchDogReportingThreshold)
            {
              v372 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[296])
              {
                v372 = *((_QWORD *)v5 + 297);
                v6 = os_log_type_enabled(v372, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v6)
                  goto LABEL_453;
LABEL_452:
                *(_DWORD *)block = 136446466;
                *(_QWORD *)&block[4] = v362;
                *(_WORD *)&block[12] = 1024;
                *(_DWORD *)&block[14] = v371;
                _os_log_impl((void *)&_mh_execute_header, v372, OS_LOG_TYPE_DEFAULT, "WARNING: %{public}s took %d ms to complete", block, 0x12u);
                goto LABEL_453;
              }
              v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v6)
                goto LABEL_452;
            }
LABEL_453:
            v358 += 32;
            if (v359 == v358)
              goto LABEL_439;
          }
        }
        if (*__error() == 4)
          continue;
LABEL_462:
        v388 = *__error();
        v389 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[296])
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v391 = strerror(v388);
            *(_DWORD *)block = 67109378;
            *(_DWORD *)&block[4] = v388;
            *(_WORD *)&block[8] = 2082;
            *(_QWORD *)&block[10] = v391;
            v392 = v389;
            goto LABEL_471;
          }
        }
        else
        {
          v393 = *((_QWORD *)v5 + 297);
          if (os_log_type_enabled(v393, OS_LOG_TYPE_DEFAULT))
          {
            v395 = strerror(v388);
            *(_DWORD *)block = 67109378;
            *(_DWORD *)&block[4] = v388;
            *(_WORD *)&block[8] = 2082;
            *(_QWORD *)&block[10] = v395;
            v392 = v393;
LABEL_471:
            _os_log_impl((void *)&_mh_execute_header, v392, OS_LOG_TYPE_DEFAULT, "ERROR: KQueueLoop - kevent failed errno %d (%{public}s)", block, 0x12u);
          }
        }
        exit(v388);
      }
      break;
    }
    v2 = (NSObject **)&unk_100164000;
  }
}

uint64_t mDNS_TimeNow(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t result;
  int v16;
  int v17;

  if (!a1[12])
    goto LABEL_20;
  v9 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
    LOWORD(v16) = 0;
    goto LABEL_11;
  }
  v9 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v16) = 0;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Lock failure: mDNS_TimeNow called while holding mDNS lock. This is incorrect. Code protected by lock should just use m->timenow.", (uint8_t *)&v16, 2u);
  }
LABEL_12:
  if (a1[16])
    goto LABEL_20;
  v12 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
    v14 = a1[12];
    v16 = 67109120;
    v17 = v14;
  }
  else
  {
    v12 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
    v13 = a1[12];
    v16 = 67109120;
    v17 = v13;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Lock failure: mDNS_TimeNow: m->mDNS_busy is %u but m->timenow not set", (uint8_t *)&v16, 8u);
LABEL_20:
  result = a1[16];
  if (!(_DWORD)result)
    return a1[15] + mDNSPlatformRawTime(result, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

uint64_t mDNS_Execute(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  int *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  uint64_t i;
  int j;
  _QWORD *v46;
  int v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  BOOL v53;
  uint64_t v54;
  uint64_t DNSServiceManager;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  _QWORD *v60;
  void *v61;
  int *v62;
  char v63;
  unint64_t v64;
  int v65;
  NSObject *v66;
  _BYTE *k;
  unsigned __int16 v69;
  uint64_t v70;
  _BYTE *m;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  char v81;
  void *v82;
  NSObject *v83;
  _BYTE *n;
  uint64_t v86;
  _BYTE *ii;
  uint64_t v89;
  unsigned __int16 v90;
  _QWORD *v91;
  int v92;
  _QWORD *v93;
  uint64_t v94;
  int v95;
  unint64_t v96;
  NSObject *v97;
  _BYTE *jj;
  uint64_t v100;
  _BYTE *kk;
  uint64_t v103;
  unsigned __int16 v104;
  uint64_t v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  _QWORD *v109;
  _QWORD *mm;
  int v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  _QWORD *v119;
  uint64_t v120;
  _QWORD *v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  int v125;
  int rr_expire_time;
  int v128;
  NSObject *v129;
  uint64_t v131;
  int v132;
  int v134;
  uint64_t v136;
  int v137;
  uint64_t v139;
  int expiration_time;
  uint64_t v142;
  int v143;
  unsigned int v144;
  unsigned int v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  uint64_t *v151;
  uint64_t v152;
  _QWORD *v153;
  uint64_t v154;
  NSObject **v155;
  unsigned int v156;
  _BYTE *v157;
  unsigned int v158;
  int v159;
  uint64_t v160;
  void *v161;
  char *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t *v169;
  NSObject *v170;
  char *v171;
  uint64_t v172;
  NSObject *v173;
  unsigned int v174;
  _BYTE *v175;
  uint64_t v176;
  _BYTE *v177;
  uint64_t v178;
  unsigned __int16 v179;
  int v180;
  const char *v181;
  uint64_t v182;
  NSObject *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t *v189;
  uint64_t *v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unsigned int v197;
  int v198;
  BOOL v199;
  BOOL v200;
  int v201;
  uint64_t v202;
  int v203;
  char v204;
  _BYTE *v205;
  unsigned int v206;
  unsigned int v207;
  int v208;
  int v209;
  int v211;
  uint64_t v212;
  uint64_t v213;
  unsigned __int8 *v214;
  _BOOL4 v215;
  int v216;
  uint64_t v217;
  BOOL v218;
  BOOL v219;
  int v220;
  int v222;
  uint64_t v223;
  unsigned int v224;
  unsigned int v225;
  NSObject *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  int v232;
  int v233;
  uint32_t v234;
  void *v235;
  uint64_t v236;
  uint64_t v237;
  NSObject *v238;
  unsigned int v239;
  int v240;
  uint64_t i1;
  _QWORD *i2;
  uint64_t v243;
  uint64_t v244;
  unsigned int v245;
  uint64_t v246;
  unsigned int v247;
  NSObject *v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  NSObject *v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t *v262;
  uint64_t *v263;
  _QWORD *v264;
  int v265;
  _QWORD *v266;
  _QWORD *v267;
  uint64_t v268;
  int v269;
  uint64_t v270;
  uint64_t *v272;
  uint64_t *v273;
  uint64_t **v274;
  BOOL v275;
  uint64_t *v276;
  NSObject *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  _QWORD *i3;
  int v285;
  NSObject *v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  unsigned int v292;
  int v293;
  uint64_t v294;
  int v295;
  __int128 v296;
  uint64_t v297;
  int v298;
  uint64_t nn;
  NSObject *v300;
  uint64_t v302;
  uint64_t v303;
  uint64_t v305;
  NSObject *v306;
  uint64_t v307;
  _QWORD *v308;
  uint64_t *v309;
  uint64_t v310;
  unsigned int v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  unsigned int v316;
  uint64_t v317;
  int v318;
  NSObject *v319;
  uint64_t v320;
  uint64_t v321;
  _BYTE *v322;
  uint64_t v323;
  _BYTE *v324;
  uint64_t v325;
  unsigned __int16 v326;
  int v327;
  const char *v328;
  int v329;
  _BYTE *v330;
  int v331;
  uint64_t v332;
  NSObject *v333;
  int v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  int v341;
  uint64_t v342;
  int v343;
  _BYTE *v344;
  int v345;
  unsigned int v346;
  int v347;
  uint64_t v348;
  int v349;
  int v350;
  int v351;
  NSObject *v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  int v359;
  int v360;
  int v361;
  int v362;
  int v363;
  int v364;
  int v365;
  int v366;
  _BYTE *v367;
  _BYTE *v368;
  unsigned __int16 v369;
  uint64_t v370;
  NSObject *v371;
  int v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  int v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  int v383;
  uint64_t v384;
  int v385;
  uint64_t *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  unsigned int v393;
  int v394;
  uint64_t v395;
  NSObject *v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t *v402;
  _QWORD *v403;
  int v404;
  int v405;
  int v406;
  NSObject *v407;
  _QWORD *v408;
  NSObject *v409;
  _QWORD *v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  unsigned int v422;
  uint64_t *i4;
  unsigned int v424;
  int v425;
  BOOL v426;
  NSObject **v427;
  unint64_t v428;
  unint64_t v429;
  uint64_t i5;
  uint64_t v431;
  __int16 *v432;
  unsigned int v433;
  uint64_t v434;
  unint64_t v435;
  int v436;
  unint64_t v437;
  unint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  BOOL v444;
  _BOOL4 v445;
  int v446;
  int v447;
  unsigned int v448;
  unint64_t v449;
  unsigned __int8 *v450;
  int v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  int v455;
  int v456;
  int v457;
  int v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  BOOL v464;
  unsigned int v465;
  unsigned __int8 *v466;
  unint64_t v467;
  unsigned __int8 *Question;
  int v469;
  BOOL v470;
  uint64_t v471;
  int v472;
  int v473;
  uint64_t v474;
  __int16 v475;
  unsigned __int8 *v476;
  unint64_t v477;
  unsigned __int16 v478;
  int v479;
  char v480;
  uint64_t v481;
  uint64_t *v482;
  int v483;
  int v484;
  unsigned int v485;
  unsigned int v486;
  uint64_t *v487;
  _BYTE *v488;
  uint64_t *i6;
  uint64_t v490;
  unsigned int v491;
  NSObject *v492;
  unsigned __int16 v494;
  uint64_t v496;
  uint64_t *v497;
  unsigned __int16 v498;
  unint64_t v499;
  unint64_t v500;
  NSObject *v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t *v507;
  uint64_t *v508;
  uint64_t v509;
  __int16 v510;
  __int16 v511;
  __int16 v512;
  _QWORD *v513;
  void **v514;
  char *v515;
  uint64_t v516;
  uint64_t v517;
  __int16 v518;
  unsigned int v519;
  _DWORD *v520;
  int *v521;
  int v522;
  unint64_t v523;
  NSObject *v524;
  const char *v525;
  int v526;
  int v527;
  uint64_t v528;
  uint64_t v529;
  const char *v530;
  int v531;
  NSObject *v532;
  const char *v533;
  int v534;
  unsigned int v535;
  _QWORD *v536;
  _QWORD *v537;
  uint64_t *i7;
  uint64_t v539;
  int v540;
  NSObject *v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t i8;
  _QWORD *i9;
  uint64_t i10;
  uint64_t v551;
  unsigned int v552;
  int v553;
  uint64_t v554;
  uint64_t i11;
  uint64_t v556;
  _QWORD *v557;
  uint64_t v558;
  BOOL v559;
  NSObject *v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  int v568;
  NSObject *v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  int v575;
  int v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  int v582;
  uint64_t v583;
  NSObject *v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  int v592;
  _DWORD *v593;
  _BOOL4 v594;
  int v595;
  void *v596;
  void *v597;
  int v598;
  unsigned int v599;
  int v600;
  int *v601;
  int v602;
  int v603;
  int v604;
  int v605;
  uint64_t v606;
  _DWORD *v607;
  uint64_t v608;
  int v609;
  int v610;
  int v611;
  int v612;
  int v613;
  int v614;
  int v615;
  int v616;
  int v617;
  int v618;
  int v619;
  __int16 *v620;
  int v621;
  int v622;
  uint64_t v623;
  unsigned int v624;
  unsigned int v625;
  void (*v626)(uint64_t, uint64_t);
  uint64_t *v627;
  uint64_t v628;
  int v629;
  uint64_t v630;
  unint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  void *v635;
  _BOOL4 v636;
  NSObject *v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t *v643;
  int v644;
  int v645;
  BOOL v646;
  unint64_t v647;
  uint64_t *v648;
  __int16 v649;
  int v650;
  unint64_t v651;
  int v652;
  uint64_t *v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t *v659;
  _BYTE *v660;
  int v661;
  uint64_t v662;
  unsigned int v663;
  int v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  unsigned __int8 *v669;
  unsigned __int8 *v670;
  unsigned __int16 v671;
  uint64_t v672;
  _WORD *v673;
  uint64_t v674;
  int v675;
  int v676;
  int v677;
  int v678;
  int v679;
  _BYTE *v680;
  _BYTE *v681;
  unsigned __int16 v682;
  uint64_t v683;
  int v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  unint64_t v690;
  unint64_t v691;
  NSObject *v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  NSObject *v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  NSObject *v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t *v721;
  uint64_t *v722;
  uint64_t *v723;
  uint64_t *v724;
  uint64_t v725;
  NSObject *v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t *v732;
  uint64_t *v733;
  uint64_t v734;
  const char *v735;
  unsigned int v736;
  int v737;
  uint64_t v738;
  _DWORD *v739;
  uint64_t v740;
  uint64_t *AuthInfoForName_internal;
  _BYTE *v742;
  unsigned __int16 v743;
  uint64_t v744;
  const char *v745;
  uint64_t v746;
  NSObject *v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  unint64_t v754;
  __int16 v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  _WORD *v759;
  unint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  unint64_t updated;
  unint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  NSObject *v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  NSObject *v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  int v787;
  NSObject *v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t *v795;
  NSObject *v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  NSObject *v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  NSObject *v809;
  _BYTE *v811;
  uint64_t v812;
  _BYTE *v814;
  uint64_t v815;
  int v816;
  const char *v817;
  uint64_t v818;
  int v819;
  uint64_t v820;
  int v821;
  int v822;
  int v824;
  int v825;
  unsigned int v826;
  int v827;
  unsigned int v828;
  int v829;
  int v830;
  int v831;
  int v832;
  int v833;
  int v834;
  int v835;
  int v836;
  int v837;
  int v838;
  int v839;
  unsigned int v840;
  _BYTE *v841;
  int v842;
  _QWORD *v843;
  int v844;
  uint64_t v845;
  unsigned __int16 *v846;
  unint64_t v847;
  BOOL v848;
  unint64_t v849;
  uint64_t *v850;
  uint64_t v851;
  uint64_t *v852;
  NSObject *v853;
  int v854;
  int v855;
  unint64_t v856;
  unint64_t v857;
  unint64_t v858;
  int v859;
  NSObject *v860;
  int v861;
  uint64_t v862;
  __int16 *v863;
  uint64_t v864;
  NSObject *v865;
  NSObject *v866;
  uint64_t v867;
  uint64_t **v868;
  uint64_t v869;
  unsigned __int8 *v870;
  uint64_t v871;
  _WORD *v872;
  _BYTE *v873;
  unsigned int v874;
  uint64_t *v875;
  void *v876;
  _BYTE *v877;
  void *v878[8];
  uint64_t v879;
  uint8_t __dst[24];
  int v881;
  __int16 v882;
  _BYTE v883[10];
  uint64_t v884;
  __int128 v885;
  __int16 v886;
  int v887;
  __int16 v888;
  int v889;
  __int16 v890;
  int v891;
  __int16 v892;
  uint64_t v893;
  uint8_t buf[60];
  __int16 v895;
  const char *v896;
  __int16 v897;
  __int128 v898;
  __int128 v899;
  __int128 v900;
  __int128 v901;
  __int128 v902;
  __int128 v903;
  uint64_t v904;
  int v905;
  __int16 v906;
  unsigned __int16 v907;
  char v908;
  char v909;
  _BYTE *v910;
  _BYTE v911[242];
  __int16 v912;
  uint64_t v913;
  uint64_t v914;
  uint64_t v915;
  _BYTE v916[256];
  __int16 v917;
  int v918;
  char v919;
  int v920;

  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_Execute", 6731);
  if (*(_DWORD *)(a1 + 64) - *(_DWORD *)(a1 + 72) < 0)
    goto LABEL_1526;
  v9 = *(_QWORD *)(a1 + 208);
  if (v9)
  {
    v10 = mDNSLogCategory_Default;
    v11 = v9 + 376;
    DNSTypeName(*(unsigned __int16 *)(v9 + 342));
    LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR m->CurrentQuestion already set: %##s (%s)", v12, v13, v14, v15, v16, v11);
  }
  v17 = *(_QWORD *)(a1 + 12640);
  if (v17)
  {
    v18 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v17 + 8), (unsigned __int16 *)(*(_QWORD *)(v17 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR m->CurrentRecord already set: %s", v19, v20, v21, v22, v23, a1 + 47032);
  }
  v24 = *(_DWORD *)(a1 + 12672);
  v25 = *(_DWORD *)(a1 + 64);
  if (v24 && ((v25 - v24) & 0x80000000) == 0)
    *(_DWORD *)(a1 + 12672) = 0;
  if (*(_DWORD *)(a1 + 12668) && v25 - *(_DWORD *)(a1 + 12664) >= 10000)
    *(_DWORD *)(a1 + 12668) = 0;
  if (*(_DWORD *)(a1 + 240) && v25 - *(_DWORD *)(a1 + 88) >= 0)
  {
    v26 = 0;
    *(_DWORD *)(a1 + 88) = v25 + 939524096;
    do
    {
      v27 = *(_DWORD *)(a1 + 64);
      v28 = a1 + 4 * v26;
      v29 = *(_DWORD *)(v28 + 4264);
      if (v27 - v29 >= 0)
      {
        v30 = (int *)(v28 + 4264);
        v31 = a1 + 8 * v26;
        v29 = v27 + 939524096;
        *v30 = v27 + 939524096;
        v3 = *(_QWORD *)(v31 + 272);
        if (v3)
        {
          v32 = (uint64_t *)(v31 + 272);
          do
          {
            CheckCacheExpiration(a1, v26, v3, (uint64_t)v4, v5, v6, v7, v8, v824);
            v33 = (uint64_t *)*v32;
            if (!*(_QWORD *)(*v32 + 16))
            {
              ReleaseCacheGroup(a1, (_QWORD **)v32);
              v33 = v32;
            }
            v3 = *v33;
            v32 = v33;
          }
          while (*v33);
          v29 = *v30;
        }
      }
      if (*(_DWORD *)(a1 + 88) - v29 >= 1)
        *(_DWORD *)(a1 + 88) = v29;
      ++v26;
    }
    while (v26 != 499);
    v25 = *(_DWORD *)(a1 + 64);
  }
  if (v25 - *(_DWORD *)(a1 + 108) >= 0)
  {
    *(_DWORD *)(a1 + 108) = v25 + 939524096;
    CheckProxyRecords(a1, *(_QWORD *)(a1 + 12624), v3, (uint64_t)v4, v5, v6, v7, v8);
    CheckProxyRecords(a1, *(_QWORD *)(a1 + 12616), v34, v35, v36, v37, v38, v39);
  }
  v40 = *(_QWORD *)(a1 + 15112);
  if (v40)
    mDNSPlatformUpdateProxyList(v40, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
  *(_QWORD *)(a1 + 15112) = 0;
  v41 = *(_DWORD *)(a1 + 64);
  if (v41 - *(_DWORD *)(a1 + 112) >= 0)
  {
    *(_DWORD *)(a1 + 112) = v41 + 939524096;
    mDNS_SendKeepalives(a1);
  }
  v42 = *(_DWORD *)(a1 + 116);
  if (v42)
  {
    v43 = *(_DWORD *)(a1 + 64);
    if (v43 - v42 >= 0)
    {
      *(_DWORD *)(a1 + 8) = v43;
      *(_DWORD *)(a1 + 116) = 0;
      *(_BYTE *)(a1 + 120) = 0;
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: Scheduled network changed processing to leave multicast group.", (uint64_t)v4, v5, v6, v7, v8, v824);
    }
  }
  for (i = *(_QWORD *)(a1 + 14160); i; i = *(_QWORD *)(i + 296))
  {
    for (j = 0; j != 5; ++j)
      mDNS_SetUpDomainEnumeration((unsigned int *)a1, i, j);
  }
  if (!g_discover_resolvers)
    goto LABEL_188;
  v46 = *(_QWORD **)g_discover_resolvers;
  if (!*(_QWORD *)g_discover_resolvers)
    goto LABEL_188;
  v47 = dword_100158E08;
  v861 = dword_100158E08;
  do
  {
    v49 = v46;
    v46 = (_QWORD *)*v46;
    v48 = v49[1];
    if (!v48)
      continue;
    v50 = *(_QWORD *)(v48 + 272);
    if (!v50)
      continue;
    v51 = *(_QWORD *)(v50 + 696);
    if (!v51)
      continue;
    v52 = *(_DWORD *)(v51 + 1664);
    v53 = v52 && v52 - v47 <= 0;
    if (!v53)
      continue;
    v54 = *(_QWORD *)(v51 + 1672);
    if (v54)
    {
      DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager)
        mdns_dns_service_manager_deregister_native_service(DNSServiceManager, v54);
      *(_QWORD *)(v51 + 1672) = 0;
    }
    v56 = *(_QWORD *)(v51 + 256);
    v57 = v56 + 5;
    if ((unint64_t)(v56 + 5) < 6 && ((0x2Du >> v57) & 1) != 0)
      LODWORD(v56) = dword_1001007D8[v57];
    v58 = mdns_dns_service_definition_create();
    if (!v58)
      goto LABEL_142;
    v59 = (uint64_t)v58;
    mdns_dns_service_definition_set_interface_index((uint64_t)v58, v56, 2);
    bzero(buf, 0x3F1uLL);
    ConvertDomainNameToCString_withescape((unsigned __int8 *)v48, buf);
    v60 = mdns_domain_name_create((char *)buf, 0);
    if (!v60)
    {
      os_release((void *)v59);
LABEL_142:
      v81 = -1;
      v82 = &unk_100164000;
      goto LABEL_113;
    }
    v61 = v60;
    v867 = v54;
    CFSetAddValue(*(CFMutableSetRef *)(v59 + 32), v60);
    *(_BYTE *)(v59 + 53) = 1;
    os_release(v61);
    v62 = *(int **)(v51 + 1656);
    if (!v62)
    {
LABEL_109:
      if (v867)
        v81 = 3;
      else
        v81 = 0;
      goto LABEL_112;
    }
    v63 = 0;
    v64 = v51 + 256;
    v871 = v59;
    do
    {
      while (1)
      {
        v65 = *v62;
        if (*v62 == 6)
        {
          if (*((unsigned __int8 *)v62 + 4) == 254)
          {
            if ((*((_BYTE *)v62 + 5) & 0xC0) == 0x80)
              v74 = v56;
            else
              v74 = 0;
          }
          else
          {
            v74 = 0;
          }
          v78 = _mdns_address_new();
          if (!v78)
          {
LABEL_140:
            v81 = -1;
            v59 = v871;
            goto LABEL_112;
          }
          v77 = (void *)v78;
          *(_DWORD *)(v78 + 24) = 7708;
          *(_OWORD *)(v78 + 32) = *(_OWORD *)(v62 + 1);
          *(_DWORD *)(v78 + 48) = v74;
          goto LABEL_100;
        }
        if (v65 != 4)
          break;
        v75 = v62[1];
        v76 = _mdns_address_new();
        if (!v76)
          goto LABEL_140;
        v77 = (void *)v76;
        *(_DWORD *)(v76 + 24) = 528;
        *(_DWORD *)(v76 + 28) = v75;
LABEL_100:
        v59 = v871;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v871 + 24), v77);
        os_release(v77);
        v62 = (int *)*((_QWORD *)v62 + 3);
        v63 = 1;
        if (!v62)
          goto LABEL_103;
      }
      v66 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
          goto LABEL_89;
        for (k = (_BYTE *)v51; ; k += v70 + 1)
        {
          v69 = 257;
          if ((unint64_t)k >= v64 || !k)
            break;
          v70 = *k;
          if (v70 > 0x3F)
          {
            v69 = 257;
            goto LABEL_88;
          }
          if (!*k)
          {
            v69 = (_WORD)k - v51 + 1;
            goto LABEL_88;
          }
        }
        goto LABEL_88;
      }
      v66 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (m = (_BYTE *)v51; ; m += v73 + 1)
        {
          v69 = 257;
          if ((unint64_t)m >= v64 || !m)
            break;
          v73 = *m;
          if (v73 > 0x3F)
          {
            v69 = 257;
            break;
          }
          if (!*m)
          {
            v69 = (_WORD)m - v51 + 1;
            break;
          }
        }
LABEL_88:
        *(_DWORD *)buf = 141559043;
        *(_QWORD *)&buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2101;
        *(_QWORD *)&buf[20] = v51;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v56;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v65;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_FAULT, "Invalid mDNSAddrType - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, interface index: %u, mDNSAddrType: v%d.", buf, 0x28u);
      }
LABEL_89:
      v62 = (int *)*((_QWORD *)v62 + 3);
    }
    while (v62);
    v59 = v871;
    if ((v63 & 1) == 0)
      goto LABEL_109;
LABEL_103:
    v79 = Querier_RegisterNativeDNSService(v59);
    *(_QWORD *)(v51 + 1672) = v79;
    if (v867)
      v80 = 2;
    else
      v80 = 1;
    if (v79)
      v81 = v80;
    else
      v81 = -1;
LABEL_112:
    os_release((void *)v59);
    v82 = &unk_100164000;
    v47 = v861;
LABEL_113:
    v83 = *((_QWORD *)v82 + 295);
    if (gSensitiveLoggingEnabled != 1 || v83 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        for (n = (_BYTE *)v48; ; n += v86 + 1)
        {
          if ((unint64_t)n >= v48 + 256 || !n || (v86 = *n, v86 > 0x3F))
          {
            v90 = 257;
            goto LABEL_136;
          }
          if (!*n)
            break;
        }
        v90 = (_WORD)n - v48 + 1;
LABEL_136:
        *(_DWORD *)buf = 141558787;
        *(_QWORD *)&buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v90;
        *(_WORD *)&buf[18] = 2101;
        *(_QWORD *)&buf[20] = v48;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v81;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "Discovered local resolver configuration updated - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, result: %d", buf, 0x22u);
      }
    }
    else
    {
      v83 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (ii = (_BYTE *)v48; ; ii += v89 + 1)
        {
          if ((unint64_t)ii >= v48 + 256 || !ii || (v89 = *ii, v89 > 0x3F))
          {
            v90 = 257;
            goto LABEL_136;
          }
          if (!*ii)
            break;
        }
        v90 = (_WORD)ii - v48 + 1;
        goto LABEL_136;
      }
    }
    *(_DWORD *)(v51 + 1664) = 0;
  }
  while (v46);
  if (g_discover_resolvers)
  {
    v91 = *(_QWORD **)g_discover_resolvers;
    if (*(_QWORD *)g_discover_resolvers)
    {
      v92 = dword_100158E08;
      while (2)
      {
        v93 = v91;
        v91 = (_QWORD *)*v91;
        v94 = v93[1];
        if (*(_DWORD *)(v94 + 264))
          goto LABEL_187;
        v95 = *(_DWORD *)(v94 + 256);
        if (!v95 || v92 - v95 < 0)
          goto LABEL_187;
        v96 = v94 + 256;
        v97 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            for (jj = (_BYTE *)v94; ; jj += v100 + 1)
            {
              if ((unint64_t)jj >= v96 || !jj || (v100 = *jj, v100 > 0x3F))
              {
                v104 = 257;
                goto LABEL_172;
              }
              if (!*jj)
                break;
            }
            v104 = (_WORD)jj - v94 + 1;
LABEL_172:
            *(_DWORD *)buf = 141558531;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v104;
            *(_WORD *)&buf[18] = 2101;
            *(_QWORD *)&buf[20] = v94;
            _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "Stopping the resolver discovery -- domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
          }
        }
        else
        {
          v97 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            for (kk = (_BYTE *)v94; ; kk += v103 + 1)
            {
              if ((unint64_t)kk >= v96 || !kk || (v103 = *kk, v103 > 0x3F))
              {
                v104 = 257;
                goto LABEL_172;
              }
              if (!*kk)
                break;
            }
            v104 = (_WORD)kk - v94 + 1;
            goto LABEL_172;
          }
        }
        v105 = v93[1];
        if (v105)
        {
          v106 = *(_DWORD *)(v105 + 260) - 1;
          *(_DWORD *)(v105 + 260) = v106;
          v107 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
              goto LABEL_179;
          }
          else
          {
            v107 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_179:
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v106;
              _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "discover_resolver_t released - ref count after releasing: %u.", buf, 8u);
            }
          }
          v108 = v93[1];
          if (v108 && !*(_DWORD *)(v108 + 260))
            (*(void (**)(void))(v108 + 280))();
        }
        v109 = (_QWORD *)g_discover_resolvers;
        for (mm = *(_QWORD **)g_discover_resolvers; mm != v93; mm = (_QWORD *)*mm)
          v109 = mm;
        *v109 = *v93;
        free(v93);
LABEL_187:
        if (!v91)
          break;
        continue;
      }
    }
  }
LABEL_188:
  v111 = *(_DWORD *)(a1 + 148);
  if (v111)
  {
    if (*(_DWORD *)(a1 + 64) - v111 >= 0)
    {
      *(_DWORD *)(a1 + 148) = 0;
      if (*(_BYTE *)(a1 + 141) == 1)
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Re-sleep delay passed; now checking for Sleep Proxy Servers",
            (uint64_t)v4,
            v5,
            v6,
            v7,
            v8,
            v824);
        BeginSleepProcessing(a1);
      }
    }
  }
  v112 = *(_DWORD *)(a1 + 160);
  if (v112)
  {
    if (*(_DWORD *)(a1 + 64) - v112 >= 0)
    {
      *(_DWORD *)(a1 + 160) = 0;
      v113 = *(_QWORD *)(a1 + 192);
      if (v113)
      {
        while (2)
        {
          if (v113 == *(_QWORD *)(a1 + 200))
            goto LABEL_279;
          v114 = *(_QWORD *)(v113 + 144);
          if (!v114)
            goto LABEL_278;
          if (!*(_BYTE *)(v114 + 24))
            goto LABEL_278;
          v115 = *(_QWORD *)(*(_QWORD *)(v114 + 16) + 64);
          v116 = bswap32(*(unsigned __int16 *)(v113 + 340));
          v117 = HIWORD(v116);
          *(_WORD *)(v115 + 24) = HIWORD(v116);
          if ((*(_DWORD *)(v115 + 48) - 3) < 0xFFFFFFFE)
            goto LABEL_278;
          v118 = *(_QWORD *)(v115 + 32);
          if (v118)
          {
            v119 = *(_QWORD **)(v118 + 24);
            if (v119)
            {
              while (*(_DWORD *)(*v119 + 8))
              {
                v119 = (_QWORD *)v119[1];
                if (!v119)
                  goto LABEL_205;
              }
LABEL_226:
              v129 = mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
                {
                  v131 = *(_QWORD *)(v115 + 16);
                  if (v131)
                  {
                    v132 = *(_DWORD *)(v131 + 24);
                    v131 = *(_QWORD *)(v131 + 16);
                  }
                  else
                  {
                    v132 = 0;
                  }
LABEL_277:
                  *(_DWORD *)buf = 67109891;
                  *(_DWORD *)&buf[4] = v117;
                  *(_WORD *)&buf[8] = 2160;
                  *(_QWORD *)&buf[10] = 1752392040;
                  *(_WORD *)&buf[18] = 1040;
                  *(_DWORD *)&buf[20] = v132;
                  *(_WORD *)&buf[24] = 2101;
                  *(_QWORD *)&buf[26] = v131;
                  _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_INFO, "[Q%u] Current DNSSEC validation manager contains record(s) that are to be removed soon, wait for the coming update before updating the cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x22u);
                }
              }
              else
              {
                v129 = mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
                {
                  v131 = *(_QWORD *)(v115 + 16);
                  if (v131)
                  {
                    v132 = *(_DWORD *)(v131 + 24);
                    v131 = *(_QWORD *)(v131 + 16);
                  }
                  else
                  {
                    v132 = 0;
                  }
                  goto LABEL_277;
                }
              }
              goto LABEL_278;
            }
          }
LABEL_205:
          v120 = *(_QWORD *)(v115 + 40);
          if (v120)
          {
            v121 = *(_QWORD **)(v120 + 24);
            if (v121)
            {
              while (*(_DWORD *)(*v121 + 8))
              {
                v121 = (_QWORD *)v121[1];
                if (!v121)
                  goto LABEL_209;
              }
              goto LABEL_226;
            }
          }
LABEL_209:
          v122 = *(_QWORD *)(v115 + 64);
          if (v122)
          {
            v123 = *(_QWORD **)(v122 + 24);
            if (v123)
            {
              while (*(_DWORD *)(*v123 + 8))
              {
                v123 = (_QWORD *)v123[1];
                if (!v123)
                  goto LABEL_213;
              }
              goto LABEL_226;
            }
          }
LABEL_213:
          v124 = *(_QWORD *)(v115 + 88);
          if (v124 && !*(_DWORD *)(v124 + 8))
            goto LABEL_226;
          if (*(_DWORD *)(v115 + 52))
            goto LABEL_278;
          if (v118)
          {
            v125 = dword_100158E08;
            rr_expire_time = dnssec_obj_rrset_get_rr_expire_time(v118);
            if (rr_expire_time - dword_100158E08 < 1)
              goto LABEL_278;
            if (v125 + 939524096 - rr_expire_time <= 0 || rr_expire_time == 0)
              v128 = v125 + 939524096;
            else
              v128 = rr_expire_time;
            v120 = *(_QWORD *)(v115 + 40);
            if (!v120)
            {
LABEL_245:
              v136 = *(_QWORD *)(v115 + 64);
              if (v136)
              {
                v137 = dnssec_obj_rrset_get_rr_expire_time(v136);
                if (v137 - dword_100158E08 < 1)
                  goto LABEL_278;
                if (v128 - v137 > 0 && v137 != 0)
                  v128 = v137;
              }
              if (*(_DWORD *)(v115 + 112))
              {
                v139 = *(_QWORD *)(v115 + 88);
                if (!v139)
                  goto LABEL_278;
                expiration_time = resource_record_get_expiration_time(*(_QWORD *)(v139 + 56));
                if (expiration_time - dword_100158E08 < 1)
                  goto LABEL_278;
                if (v128 - expiration_time > 0 && expiration_time != 0)
                  v128 = expiration_time;
              }
              v142 = *(_QWORD *)(v115 + 32);
              if (!v142)
                v142 = *(_QWORD *)(v115 + 40);
              v143 = v128 - dnssec_obj_rrset_get_time_received(v142);
              if (v143 >= 1000)
              {
                v144 = v143 / 0x3E8u;
                if (v144 >= 0xE10)
                  v144 = 3600;
                v145 = v144 + (v144 >> 2) + 2;
                if (v145 <= 0xF)
                  v146 = 15;
                else
                  v146 = v145;
                v147 = *(_QWORD *)(v115 + 32);
                if (v147 && dnssec_obj_rrset_needs_to_update_cache(v147, v146))
                {
                  v148 = *(_QWORD *)(v115 + 32);
                }
                else
                {
                  v149 = *(_QWORD *)(v115 + 40);
                  if (!v149 || !dnssec_obj_rrset_needs_to_update_cache(v149, v146))
                    goto LABEL_278;
                  v148 = *(_QWORD *)(v115 + 40);
                }
                _update_validated_cache_with_rrset(v148, v146);
              }
LABEL_278:
              v113 = *(_QWORD *)(v113 + 8);
              if (!v113)
                goto LABEL_279;
              continue;
            }
          }
          else
          {
            if (!v120)
              goto LABEL_278;
            v128 = dword_100158E08 + 939524096;
          }
          break;
        }
        v134 = dnssec_obj_rrset_get_rr_expire_time(v120);
        if (v134 - dword_100158E08 < 1)
          goto LABEL_278;
        if (v128 - v134 > 0 && v134 != 0)
          v128 = v134;
        goto LABEL_245;
      }
    }
  }
LABEL_279:
  v150 = *(_DWORD *)(a1 + 164);
  if (v150 && *(_DWORD *)(a1 + 64) - v150 >= 0)
  {
    v151 = *(uint64_t **)(a1 + 12656);
    if (v151)
    {
      while (!*((_BYTE *)v151 + 16))
      {
        v151 = (uint64_t *)*v151;
        if (!v151)
          goto LABEL_284;
      }
      v295 = 0;
      v296 = 0uLL;
LABEL_580:
      v297 = v151[1];
      if (!v297)
        goto LABEL_610;
      v298 = 0;
      for (nn = 28; nn != 62; nn += 2)
        v298 += *(unsigned __int16 *)(v297 + nn);
      if (v298)
      {
        v300 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            v302 = v151[444];
            v303 = v302 + 5;
            if ((unint64_t)(v302 + 5) < 6 && ((0x2Du >> v303) & 1) != 0)
              LODWORD(v302) = dword_1001007F0[v303];
LABEL_598:
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = (char *)v151 + 3606;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v302;
            *(_WORD *)&buf[18] = 2112;
            *(_QWORD *)&buf[20] = v297;
            _os_log_impl((void *)&_mh_execute_header, v300, OS_LOG_TYPE_DEFAULT, "mDNS response delay distribution - interface name: %{public}s, interface index: %u, report: %@", buf, 0x1Cu);
          }
        }
        else
        {
          v300 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v302 = v151[444];
            v305 = v302 + 5;
            if ((unint64_t)(v302 + 5) < 6 && ((0x2Du >> v305) & 1) != 0)
              LODWORD(v302) = dword_100100808[v305];
            goto LABEL_598;
          }
        }
        v296 = 0uLL;
        if (v295)
        {
          v295 = 1;
          goto LABEL_609;
        }
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __mDNSPostResponseDelayMetrics_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_508;
        *(_QWORD *)&buf[32] = v297;
        if ((analytics_send_event_lazy("com.apple.mDNSResponder.mDNSResponseDelayEvent", buf, (__n128)0) & 1) == 0)
        {
          v306 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              goto LABEL_607;
          }
          else
          {
            v306 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
LABEL_607:
              *(_WORD *)__dst = 0;
              _os_log_impl((void *)&_mh_execute_header, v306, OS_LOG_TYPE_DEFAULT, "com.apple.mDNSResponder.mDNSResponseDelayEvent: Analytic not posted", __dst, 2u);
            }
          }
        }
        v295 = 1;
        v296 = 0uLL;
      }
LABEL_609:
      *(_QWORD *)(v297 + 54) = 0;
      *(_OWORD *)(v297 + 40) = v296;
      *(_OWORD *)(v297 + 24) = v296;
LABEL_610:
      while (1)
      {
        v151 = (uint64_t *)*v151;
        if (!v151)
          break;
        if (*((_BYTE *)v151 + 16))
          goto LABEL_580;
      }
    }
LABEL_284:
    *(_DWORD *)(a1 + 164) = *(_DWORD *)(a1 + 64) + 1800000;
  }
  v872 = (_WORD *)(a1 + 28960);
  v152 = a1 + 12648;
  v153 = (_QWORD *)(a1 + 200);
  v154 = *(_QWORD *)(a1 + 200);
  v155 = (NSObject **)&unk_100164000;
  v843 = (_QWORD *)(a1 + 200);
  if (!v154)
    goto LABEL_486;
  v156 = 0;
  v157 = (_BYTE *)(a1 + 47032);
  while (2)
  {
    v158 = v156;
    v159 = *(_DWORD *)(v154 + 204);
    if (v159)
    {
      if (*(_DWORD *)(a1 + 64) - v159 < 0)
        goto LABEL_486;
    }
    if (*(_WORD *)(v154 + 340))
    {
      if (*(_BYTE *)(v154 + 672) == 6)
      {
        *(_BYTE *)(v154 + 672) = 8;
        *(_QWORD *)__dst = 0;
        *(_QWORD *)&__dst[8] = 0;
        if (*(_QWORD *)(v154 + 80))
        {
          if (GetReverseIPv6Addr((_BYTE *)(v154 + 376), __dst))
          {
            v878[0] = 0;
            LODWORD(v879) = 0;
            LODWORD(v877) = 0;
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            *(_QWORD *)&buf[22] = 0;
            *(_QWORD *)&buf[16] = 0;
            if (!_DNS64GetPrefixes(a1, *(_QWORD *)(v154 + 80), v878, (int *)&v879))
            {
              v160 = v879;
              v161 = v878[0];
              v162 = (char *)v878[0];
              if ((_DWORD)v879)
              {
                while (!nw_nat64_extract_v4(v162, __dst, &v877))
                {
                  v162 += 16;
                  if (!--v160)
                    goto LABEL_299;
                }
                snprintf((char *)buf, 0x1EuLL, "%u.%u.%u.%u.in-addr.arpa.", BYTE3(v877), BYTE2(v877), BYTE1(v877), v877);
                *(_BYTE *)(v154 + 376) = 0;
                AppendDNSNameString((_BYTE *)(v154 + 376), buf, v163, v164, v165, v166, v167, v168);
                *(_DWORD *)(v154 + 200) = DomainNameHashValue(v154 + 376);
                *(_BYTE *)(v154 + 672) = 7;
              }
LABEL_299:
              v152 = a1 + 12648;
              if (v161)
                free(v161);
            }
          }
        }
      }
    }
    v169 = CacheGroupForName(a1, *(_DWORD *)(v154 + 200), (_BYTE *)(v154 + 376));
    if (v169)
      CheckCacheExpiration(a1, *(_DWORD *)(v154 + 200) % 0x1F3u, (uint64_t)v169, (uint64_t)v4, v5, v6, v7, v8, v824);
    if (*v153 == v154)
    {
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(v154 + 8);
      if (*(_BYTE *)(a1 + 56))
        LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "AnswerNewQuestion ERROR! Cache already locked!", (uint64_t)v4, v5, v6, v7, v8, v824);
      *(_BYTE *)(a1 + 56) = 1;
      v172 = *(_QWORD *)(a1 + 208);
      if (v172)
      {
        v173 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            goto LABEL_332;
          v854 = *(_DWORD *)(v172 + 252);
          v174 = bswap32(*(unsigned __int16 *)(v172 + 340)) >> 16;
          v177 = (_BYTE *)(v172 + 376);
          if (v172 == -632)
          {
LABEL_322:
            while (v177)
            {
              v178 = *v177;
              if (v178 > 0x3F)
                break;
              if (!*v177)
              {
                v179 = (_WORD)v177 - (v172 + 376) + 1;
                goto LABEL_331;
              }
              v177 += v178 + 1;
              if (v172 != -632)
                goto LABEL_321;
            }
          }
          else
          {
LABEL_321:
            if ((unint64_t)v177 < v172 + 632)
              goto LABEL_322;
          }
          v179 = 257;
        }
        else
        {
          v173 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_332;
          v854 = *(_DWORD *)(v172 + 252);
          v174 = bswap32(*(unsigned __int16 *)(v172 + 340)) >> 16;
          v175 = (_BYTE *)(v172 + 376);
          if (v172 == -632)
          {
LABEL_314:
            while (v175)
            {
              v176 = *v175;
              if (v176 > 0x3F)
                break;
              if (!*v175)
              {
                v179 = (_WORD)v175 - (v172 + 376) + 1;
                goto LABEL_331;
              }
              v175 += v176 + 1;
              if (v172 != -632)
                goto LABEL_313;
            }
          }
          else
          {
LABEL_313:
            if ((unint64_t)v175 < v172 + 632)
              goto LABEL_314;
          }
          v179 = 257;
        }
LABEL_331:
        v180 = v179;
        v181 = DNSTypeName(*(unsigned __int16 *)(v172 + 342));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)&buf[4] = v854;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v174;
        *(_WORD *)&buf[14] = 2160;
        *(_QWORD *)&buf[16] = 1752392040;
        *(_WORD *)&buf[24] = 1040;
        *(_DWORD *)&buf[26] = v180;
        *(_WORD *)&buf[30] = 2101;
        *(_QWORD *)&buf[32] = v172 + 376;
        *(_WORD *)&buf[40] = 2082;
        *(_QWORD *)&buf[42] = v181;
        _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEFAULT, "[R%d->Q%d] AnswerNewQuestion ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x32u);
        v153 = (_QWORD *)(a1 + 200);
        v157 = (_BYTE *)(a1 + 47032);
      }
LABEL_332:
      *(_QWORD *)(a1 + 208) = v154;
      v182 = *(_QWORD *)(a1 + 12640);
      if (v182)
      {
        v183 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v182 + 8), (unsigned __int16 *)(*(_QWORD *)(v182 + 48) + 4), v157);
        LogMsgWithLevel(v183, OS_LOG_TYPE_DEFAULT, "AnswerQuestionWithLORecord ERROR m->CurrentRecord already set %s", v184, v185, v186, v187, v188, (int)v157);
      }
      v189 = AuthGroupForName(a1 + 6264, *(_DWORD *)(v154 + 200), (_BYTE *)(v154 + 376));
      v190 = v189;
      if (v189)
      {
        v191 = v189[2];
        if (v191)
        {
          while (1)
          {
            if (v191 == v190[5])
              goto LABEL_345;
            v192 = *(_QWORD *)v191;
            *(_QWORD *)(a1 + 12640) = *(_QWORD *)v191;
            v193 = *(_DWORD *)(v191 + 172);
            if (v193 == 4)
              goto LABEL_341;
            if (v193 == 5)
              break;
LABEL_344:
            v191 = v192;
            if (!v192)
              goto LABEL_345;
          }
          v194 = *(_QWORD *)(v154 + 136);
          if (!v194 || v194 == -5)
          {
LABEL_341:
            if (LocalOnlyRecordAnswersQuestion(v191, v154, v3, (uint64_t)v4, v5, v6, v7, v8))
            {
              AnswerLocalQuestionWithLocalAuthRecord(a1, v191, 1);
              if (*(_QWORD *)(a1 + 208) != v154)
                goto LABEL_345;
            }
          }
          v192 = *(_QWORD *)(a1 + 12640);
          goto LABEL_344;
        }
      }
LABEL_345:
      *(_QWORD *)(a1 + 12640) = 0;
      if (*(_QWORD *)(a1 + 208) != v154)
      {
        v155 = (NSObject **)&unk_100164000;
        v152 = a1 + 12648;
        if (mDNS_LoggingEnabled != 1)
          goto LABEL_352;
        v170 = mDNSLogCategory_Default;
        v171 = "AnswerQuestionWithLORecord: Question deleted while while answering LocalOnly record answers";
LABEL_351:
        LogMsgWithLevel(v170, OS_LOG_TYPE_DEFAULT, v171, (uint64_t)v4, v5, v6, v7, v8, v824);
        goto LABEL_352;
      }
      v152 = a1 + 12648;
      if (*(_BYTE *)(v154 + 355))
      {
        v155 = (NSObject **)&unk_100164000;
        if (mDNS_LoggingEnabled != 1)
          goto LABEL_352;
        v195 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v154 + 342));
        v824 = v154;
        v170 = v195;
        v171 = "AnswerQuestionWithLORecord: Question %p %##s (%s) answered using local auth records LOAddressAnswers %d";
        goto LABEL_351;
      }
      if (v190)
      {
        v196 = v190[5];
        if (v196)
        {
          while (1)
          {
            v155 = (NSObject **)&unk_100164000;
            if (*(_DWORD *)(v196 + 172) == 4 && (*(_BYTE *)(v196 + 8) & 0x32) != 0)
            {
              v197 = *(unsigned __int16 *)(v196 + 12);
              v53 = v197 > 0x1C;
              v198 = (1 << v197) & 0x10001022;
              v199 = v53 || v198 == 0;
              if (!v199 && LocalOnlyRecordAnswersQuestion(v196, v154, v3, (uint64_t)v4, v5, v6, v7, v8))
                break;
            }
            v196 = *(_QWORD *)v196;
            if (!v196)
              goto LABEL_365;
          }
          v152 = a1 + 12648;
          if (mDNS_LoggingEnabled == 1)
          {
            v226 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v154 + 342));
            LogMsgWithLevel(v226, OS_LOG_TYPE_DEFAULT, "AnswerQuestionWithLORecord: Question %p %##s (%s) will be answered using new local auth records  LOAddressAnswers %d", v227, v228, v229, v230, v231, v154);
          }
          goto LABEL_352;
        }
      }
LABEL_365:
      if (*(_WORD *)(v154 + 340))
        v200 = *(_BYTE *)(v154 + 646) == 1;
      else
        v200 = 0;
      v201 = v200;
      if (*(_BYTE *)(v154 + 354) && !*(_BYTE *)(v154 + 645))
      {
        v204 = 1;
      }
      else
      {
        if (v169)
        {
          v202 = v169[2];
          if (v202)
          {
            v855 = 0;
            v848 = 0;
            v844 = 0;
            v203 = 0;
            v204 = 1;
            while (1)
            {
              v205 = (_BYTE *)(v202 + 8);
              if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v202 + 8), 0, v154, (uint64_t)v4, v5, v6, v7, v8))
              {
                if (!*(_WORD *)(v154 + 340))
                {
                  v209 = *(unsigned __int16 *)(v202 + 12);
                  if (v209 == 28 || v209 == 1)
                  {
                    v211 = *(unsigned __int16 *)(v154 + 342);
                    if (v211 == 28 || v211 == 1)
                      v204 = 0;
                  }
                }
                goto LABEL_411;
              }
              v206 = (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v202 + 80)) / 0x3E8u;
              v207 = *(_DWORD *)(v202 + 16);
              if (v207 <= v206)
              {
                if (!v201)
                  goto LABEL_411;
                v208 = *v205;
                if (v208 == 240)
                  goto LABEL_411;
              }
              else
              {
                v208 = *v205;
              }
              if ((v208 & 0x10) != 0 || *(_BYTE *)(v154 + 633))
              {
                if (v207 > v206)
                  v204 = 0;
                v212 = *(_QWORD *)(v154 + 144);
                if (v212)
                {
                  if (*(_BYTE *)(v212 + 24))
                  {
                    v213 = *(_QWORD *)(v202 + 64);
                    if (v213)
                    {
                      if (!*(_DWORD *)(v213 + 32))
                      {
                        ++v203;
                        v214 = (unsigned __int8 *)(v202 + 8);
                        if (v208 == 240)
                        {
                          v848 = resource_record_as_denial_of_existence_proves_wildcard_answer(v214);
                        }
                        else
                        {
                          if (resource_record_as_rrsig_get_covered_type((uint64_t)v214) == 5)
                          {
                            v215 = resource_record_as_rrsig_covers_wildcard_rr(v202 + 8);
                            v216 = v844;
                            if (v215)
                              v216 = 1;
                            v844 = v216;
                          }
                          if (!v855)
                            v855 = *(_DWORD *)(*(_QWORD *)(v202 + 64) + 24);
                        }
                      }
                    }
                  }
                }
              }
              ++*(_DWORD *)(v154 + 228);
              if (*(unsigned __int16 *)(v202 + 20) >= 0x401u)
                ++*(_DWORD *)(v154 + 232);
              if ((*v205 & 0x10) != 0)
                ++*(_DWORD *)(v154 + 236);
              *(_DWORD *)(v202 + 92) = *(_DWORD *)(a1 + 64);
              dnssd_analytics_update_cache_request(*(_WORD *)(v154 + 340) != 0, 0);
              AnswerCurrentQuestionWithResourceRecord(a1, v202, 1);
              if (*(_QWORD *)(a1 + 208) != v154)
                goto LABEL_414;
LABEL_411:
              v202 = *(_QWORD *)v202;
              if (!v202)
                goto LABEL_414;
            }
          }
        }
        v203 = 0;
        LOBYTE(v844) = 0;
        v848 = 0;
        v855 = 0;
        v204 = 1;
LABEL_414:
        if (*(_QWORD *)(a1 + 208) == v154)
        {
          v217 = *(_QWORD *)(v154 + 144);
          v155 = (NSObject **)&unk_100164000;
          if (!v217 || (*(_BYTE *)(v217 + 24) ? (v218 = v204 == 0) : (v218 = 0), !v218))
          {
LABEL_438:
            v223 = *(_QWORD *)(a1 + 208);
            if (v223 != v154)
              goto LABEL_439;
            if (v201)
            {
              if (*(_QWORD *)(v154 + 168))
              {
                v224 = *(_DWORD *)(a1 + 48);
                v225 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v225;
                mDNS_VerifyLockState("Drop Lock", 0, v224, v225, (uint64_t)"AnswerNewQuestion", 6246);
                (*(void (**)(uint64_t, uint64_t))(v154 + 168))(v154, 1);
                mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerNewQuestion", 6248);
                --*(_DWORD *)(a1 + 52);
                v223 = *(_QWORD *)(a1 + 208);
                if (v223 != v154)
                {
LABEL_439:
                  v152 = a1 + 12648;
                  if (v223 != v154)
                    goto LABEL_352;
                  goto LABEL_451;
                }
              }
              *(_BYTE *)(v154 + 646) = 2;
            }
            v152 = a1 + 12648;
            if (*(_BYTE *)(v154 + 354))
            {
              if (*(_BYTE *)(v154 + 635))
              {
                GenerateNegativeResponseEx(a1, 0, 4, 0, v5, v6, v7, v8, v824);
                v223 = *(_QWORD *)(a1 + 208);
                goto LABEL_439;
              }
              *(_DWORD *)(v154 + 212) = 0;
            }
LABEL_451:
            dnssd_analytics_update_cache_request(*(_WORD *)(v154 + 340) != 0, 1);
            *(_BYTE *)(v154 + 357) = 1;
            if (v204)
            {
              if (*(int *)(v154 + 212) >= 1 && !*(_QWORD *)(v154 + 40))
              {
                *(_DWORD *)(v154 + 212) = 334;
                v232 = *(_DWORD *)(a1 + 64) - 334;
                *(_DWORD *)(v154 + 208) = v232;
                if (!*(_WORD *)(v154 + 340))
                {
                  v233 = *(_DWORD *)(a1 + 124);
                  if (!v233)
                  {
                    do
                      v234 = arc4random() & 0x1FFF;
                    while (v234 > 0x1388);
                    v233 = ((85899346 * (unint64_t)(v234 + 999)) >> 32) + 1;
                    *(_DWORD *)(a1 + 124) = v233;
                    v232 = *(_DWORD *)(v154 + 208);
                  }
                  *(_DWORD *)(v154 + 208) = v233 + v232;
                }
              }
            }
            if (DPCFeatureEnabled_sOnce != -1)
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
            if (DPCFeatureEnabled_sEnabled
              && !*(_WORD *)(v154 + 340)
              && *(int *)(v154 + 212) >= 1
              && !*(_QWORD *)(v154 + 40))
            {
              v235 = *(void **)(v154 + 136);
              if (v235)
              {
                _DPCSubscribe(v154, v235);
              }
              else if (gDPCPushServers)
              {
                *(_QWORD *)buf = _NSConcreteStackBlock;
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = __DPCHandleNewQuestion_block_invoke;
                *(_QWORD *)&buf[24] = &__block_descriptor_tmp_27_3258;
                *(_QWORD *)&buf[32] = v154;
                mdns_cfdictionary_apply((const __CFDictionary *)gDPCPushServers, (uint64_t)buf);
              }
            }
            if (*(int *)(v154 + 212) >= 1 && !*(_QWORD *)(v154 + 40))
            {
              v236 = *(_QWORD *)(v154 + 184);
              if (v236)
              {
                v237 = *(_QWORD *)(v236 + 16);
                if (v237)
                {
                  if (*(_BYTE *)(v237 + 68))
                  {
                    *(_BYTE *)(v154 + 632) = 1;
                    *(_BYTE *)(v154 + 350) = 30;
                    *(_DWORD *)(v154 + 212) = 900000;
                    *(_DWORD *)(v154 + 208) = *(_DWORD *)(a1 + 64) - 899999;
                  }
                }
              }
            }
            SetNextQueryTime(a1, v154);
            goto LABEL_352;
          }
          if ((_BYTE)v844)
            v219 = v203 == v855 + 1;
          else
            v219 = 1;
          v220 = !v219;
          v222 = v848 && v203 == 1;
          if ((v220 & 1) == 0 && !v222)
          {
            v204 = 0;
LABEL_481:
            v153 = (_QWORD *)(a1 + 200);
            goto LABEL_438;
          }
          v238 = mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
            {
LABEL_479:
              v239 = bswap32(*(unsigned __int16 *)(v154 + 340));
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)&buf[4] = HIWORD(v239);
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v220;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&buf[16] = v222;
              _os_log_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_DEFAULT, "[Q%u] Continue sending out query for the primary DNSSEC question due to incomplete answer set - only positive: %{mdns:yesno}d, only negative: %{mdns:yesno}d", buf, 0x14u);
            }
          }
          else
          {
            v238 = mDNSLogCategory_DNSSEC_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_479;
          }
          v204 = 1;
          goto LABEL_481;
        }
      }
      v155 = (NSObject **)&unk_100164000;
      goto LABEL_438;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      v170 = v155[295];
      v171 = "AnswerNewQuestion: Question deleted while doing CheckCacheExpiration";
      goto LABEL_351;
    }
LABEL_352:
    *(_QWORD *)(a1 + 208) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    v154 = *(_QWORD *)(a1 + 200);
    if (v154)
    {
      v156 = v158 + 1;
      if (v158 < 0x3E7)
        continue;
    }
    break;
  }
  if (v158 >= 0x3E7)
    LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: AnswerNewQuestion exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v824);
LABEL_486:
  v240 = 0;
  v868 = (uint64_t **)(a1 + 12616);
  while (*(_BYTE *)(a1 + 140))
  {
    *(_BYTE *)(a1 + 140) = 0;
    *(_QWORD *)(a1 + 12640) = *(_QWORD *)(a1 + 12616);
    CheckRmvEventsForLocalRecords((_QWORD *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
    for (i1 = 0; i1 != 499; ++i1)
    {
      for (i2 = *(_QWORD **)(a1 + 8 * i1 + 6288); i2; i2 = (_QWORD *)*i2)
      {
        v243 = i2[2];
        *(_QWORD *)(a1 + 12640) = v243;
        if (v243)
          CheckRmvEventsForLocalRecords((_QWORD *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
      }
    }
    if (++v240 == 1000)
    {
      LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: m->LocalRemoveEvents exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v824);
      break;
    }
  }
  v244 = *(_QWORD *)(a1 + 224);
  if (v244)
  {
    v245 = 0;
    v246 = *(_QWORD *)(a1 + 208);
    do
    {
      v247 = v245;
      *(_QWORD *)(a1 + 224) = *(_QWORD *)(v244 + 8);
      if (v246)
      {
        v248 = v155[295];
        v249 = v246 + 376;
        DNSTypeName(*(unsigned __int16 *)(v246 + 342));
        LogMsgWithLevel(v248, OS_LOG_TYPE_DEFAULT, "AnswerNewLocalOnlyQuestion ERROR m->CurrentQuestion already set: %##s (%s)", v250, v251, v252, v253, v254, v249);
      }
      *(_QWORD *)(a1 + 208) = v244;
      v255 = *(_QWORD *)(a1 + 12640);
      if (v255)
      {
        v256 = v155[295];
        GetRRDisplayString_rdb((unsigned __int8 *)(v255 + 8), (unsigned __int16 *)(*(_QWORD *)(v255 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v256, OS_LOG_TYPE_DEFAULT, "AnswerNewLocalOnlyQuestion ERROR m->CurrentRecord already set %s", v257, v258, v259, v260, v261, a1 + 47032);
      }
      v262 = AuthGroupForName(a1 + 6264, *(_DWORD *)(v244 + 200), (_BYTE *)(v244 + 376));
      if (v262 && (v263 = v262, v264 = (_QWORD *)v262[2], (*(_QWORD *)(a1 + 12640) = v264) != 0))
      {
        v265 = 0;
        do
        {
          if (v264 == (_QWORD *)v263[5])
            break;
          *(_QWORD *)(a1 + 12640) = *v264;
          if (LocalOnlyRecordAnswersQuestion((uint64_t)v264, v244, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            v265 = 1;
            AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v264, 1);
            if (*(_QWORD *)(a1 + 208) != v244)
              break;
          }
          v264 = *(_QWORD **)(a1 + 12640);
        }
        while (v264);
      }
      else
      {
        v265 = 0;
      }
      if (*(_QWORD *)(a1 + 208) == v244)
      {
        v266 = *(_QWORD **)(a1 + 12616);
        *(_QWORD *)(a1 + 12640) = v266;
        v152 = a1 + 12648;
        if (v266)
        {
          while (v266 != *(_QWORD **)(a1 + 12632))
          {
            *(_QWORD *)(a1 + 12640) = *v266;
            if (RecordAnswersQuestion((uint64_t)(v266 + 1), 1, v244, (uint64_t)v4, v5, v6, v7, v8))
            {
              v265 = 1;
              AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v266, 1);
              if (*(_QWORD *)(a1 + 208) != v244)
                goto LABEL_517;
            }
            v266 = *(_QWORD **)(a1 + 12640);
            if (!v266)
              break;
          }
        }
      }
      else
      {
        v152 = a1 + 12648;
      }
      if (!v265 && *(_QWORD *)(a1 + 208) == v244 && *(_BYTE *)(v244 + 635))
        GenerateNegativeResponseEx(a1, -2, 3, 0, v5, v6, v7, v8, v824);
LABEL_517:
      *(_QWORD *)(a1 + 208) = 0;
      *(_QWORD *)(a1 + 12640) = 0;
      v244 = *(_QWORD *)(a1 + 224);
      v155 = (NSObject **)&unk_100164000;
      if (!v244)
        break;
      v246 = 0;
      v245 = v247 + 1;
    }
    while (v247 < 0x3E7);
    if (v247 >= 0x3E7)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: AnswerNewLocalOnlyQuestion exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v824);
  }
  v267 = 0;
  v268 = 0;
  v269 = 0;
  while (1)
  {
    v270 = *(_QWORD *)(a1 + 12632);
    if (!v270 || v270 == v268)
      break;
    v272 = *(uint64_t **)v270;
    *(_QWORD *)(a1 + 12632) = *(_QWORD *)v270;
    if (*(_BYTE *)(v270 + 8) == 2)
    {
      v273 = (uint64_t *)(a1 + 12616);
      if (v272)
      {
        do
        {
          v274 = (uint64_t **)v273;
          v273 = (uint64_t *)*v273;
          if (v273)
            v275 = v273 == (uint64_t *)v270;
          else
            v275 = 1;
        }
        while (!v275);
        if (!v273)
        {
          v277 = v155[295];
          GetRRDisplayString_rdb((unsigned __int8 *)(v270 + 8), (unsigned __int16 *)(*(_QWORD *)(v270 + 48) + 4), (_BYTE *)(a1 + 47032));
          LogMsgWithLevel(v277, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR!! Cannot find record %s in ResourceRecords list", v278, v279, v280, v281, v282, a1 + 47032);
          break;
        }
        *v274 = v272;
        if (v268)
        {
          *v267 = v270;
          *(_QWORD *)v270 = 0;
        }
        else
        {
          do
          {
            v276 = v272;
            v272 = (uint64_t *)*v272;
          }
          while (v272);
          *v276 = v270;
          *(_QWORD *)v270 = 0;
          v268 = v270;
        }
        v267 = (_QWORD *)v270;
      }
      else
      {
        if (v268)
          LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR!!: head %p, NewLocalRecords %p", (uint64_t)v4, v5, v6, v7, v8, v268);
        v268 = v270;
      }
    }
    else
    {
      AnswerAllLocalQuestionsWithLocalAuthRecord((_QWORD *)a1, v270, 1, (uint64_t)v4, v5, v6, v7, v8);
    }
    if (++v269 == 1000)
    {
      *(_QWORD *)(a1 + 12632) = v268;
      LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: m->NewLocalRecords exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v824);
      goto LABEL_554;
    }
  }
  *(_QWORD *)(a1 + 12632) = v268;
LABEL_554:
  if (*(_BYTE *)v152)
  {
    v283 = 0;
    *(_BYTE *)v152 = 0;
    do
    {
      for (i3 = *(_QWORD **)(a1 + 8 * v283 + 6288); i3; i3 = (_QWORD *)*i3)
      {
        v285 = 100;
        while (1)
        {
          v2 = i3[5];
          if (!v2)
            break;
          i3[5] = *(_QWORD *)v2;
          if (*(_BYTE *)(v2 + 8) == 2)
          {
            v286 = v155[295];
            GetRRDisplayString_rdb((unsigned __int8 *)(v2 + 8), (unsigned __int16 *)(*(_QWORD *)(v2 + 48) + 4), (_BYTE *)(a1 + 47032));
            LogMsgWithLevel(v286, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: LocalOnlyRecord %s not ready", v287, v288, v289, v290, v291, a1 + 47032);
          }
          else
          {
            AnswerAllLocalQuestionsWithLocalAuthRecord((_QWORD *)a1, v2, 1, (uint64_t)v4, v5, v6, v7, v8);
          }
          if (!--v285)
          {
            LogMsgWithLevel(v155[295], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ag->NewLocalOnlyRecords exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v824);
            break;
          }
        }
      }
      ++v283;
    }
    while (v283 != 499);
  }
  if (*(_DWORD *)(a1 + 16) || *(_BYTE *)(a1 + 141) == 2)
  {
    DiscardDeregistrations(a1);
    v292 = *(_DWORD *)(a1 + 64);
    if (*(_DWORD *)(a1 + 16))
      goto LABEL_1168;
  }
  else
  {
    v292 = *(_DWORD *)(a1 + 64);
  }
  v293 = *(_DWORD *)(a1 + 80);
  if (v293 && ((v292 - v293) & 0x80000000) != 0)
    goto LABEL_1163;
  *(_DWORD *)(a1 + 80) = 0;
  if ((int)(v292 - *(_DWORD *)(a1 + 92)) < 0 && (int)(v292 - *(_DWORD *)(a1 + 96)) < 0)
    goto LABEL_1161;
  v294 = *(_QWORD *)(a1 + 12656);
  if (v294)
  {
    while (!*(_BYTE *)(v294 + 16))
    {
      v294 = *(_QWORD *)v294;
      if (!v294)
        goto LABEL_578;
    }
    v851 = v294;
  }
  else
  {
LABEL_578:
    v851 = 0;
  }
  v307 = 0;
  v879 = 0;
  v849 = a1 + 28972;
  v858 = a1 + 37912;
  while (2)
  {
    v862 = v307;
    v308 = *(_QWORD **)(a1 + 8 * v307 + 272);
    if (v308)
    {
      while (1)
      {
        v309 = (uint64_t *)v308[2];
        if (v309)
          break;
LABEL_670:
        v308 = (_QWORD *)*v308;
        if (!v308)
          goto LABEL_671;
      }
      while (2)
      {
        v310 = v309[12];
        if (!v310)
          goto LABEL_635;
        v311 = *((unsigned __int8 *)v309 + 108);
        if (v311 > 3)
          goto LABEL_635;
        v312 = 1000 * *((_DWORD *)v309 + 4);
        if ((int)(v292 - *((_DWORD *)v309 + 22) + v312 / 50) < 0)
          goto LABEL_635;
        v313 = *(_QWORD *)(v310 + 56);
        v314 = v309[4];
        if (v313)
        {
          v315 = 0;
          v316 = v312 / 20 - v292;
          do
          {
            if (*(_QWORD *)(v313 + v315) == v314 && (int)(v316 + *(_DWORD *)(v313 + v315 + 8)) < 0)
              *(_QWORD *)(v313 + v315) = 0;
            v315 += 16;
          }
          while (v315 != 128);
        }
        if (*(_WORD *)(v310 + 340))
        {
          *(_DWORD *)(v310 + 208) = v292 - *(_DWORD *)(v310 + 212);
          *((_BYTE *)v309 + 108) = v311 + 1;
          ++*(_DWORD *)(v152 + 7336);
          if (!*(_WORD *)(v310 + 340))
            goto LABEL_633;
LABEL_635:
          v309 = (uint64_t *)*v309;
          if (!v309)
            goto LABEL_670;
          continue;
        }
        break;
      }
      v317 = *(_QWORD *)(v310 + 64);
      if (v317)
      {
        if (v317 == v314)
          goto LABEL_633;
        v314 = -1;
      }
      *(_QWORD *)(v310 + 64) = v314;
LABEL_633:
      if (*((_BYTE *)v309 + 130))
      {
LABEL_634:
        *(_BYTE *)(v310 + 359) = 1;
        goto LABEL_635;
      }
      v318 = *((_DWORD *)v309 + 33);
      if (v318 == 6)
      {
        if (!*(_QWORD *)&vorr_s8((int8x8_t)v309[17], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v309 + 17), *(int8x16_t *)(v309 + 17), 8uLL)))goto LABEL_634;
      }
      else if (v318 != 4 || !*((_DWORD *)v309 + 34))
      {
        goto LABEL_634;
      }
      if (mDNSAddrIsDNSMulticast((_DWORD *)v309 + 33))
        goto LABEL_634;
      v319 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
        {
          v324 = (_BYTE *)(v310 + 376);
          v845 = v310 + 376;
          if (v310 == -632)
          {
LABEL_656:
            while (v324)
            {
              v325 = *v324;
              if (v325 > 0x3F)
                break;
              if (!*v324)
              {
                v326 = (_WORD)v324 - (v310 + 376) + 1;
                goto LABEL_665;
              }
              v324 += v325 + 1;
              if (v310 != -632)
                goto LABEL_655;
            }
          }
          else
          {
LABEL_655:
            if ((unint64_t)v324 < v310 + 632)
              goto LABEL_656;
          }
          v326 = 257;
LABEL_665:
          v327 = v326;
          v328 = DNSTypeName(*(unsigned __int16 *)(v310 + 342));
          v329 = *(_DWORD *)(v310 + 200);
          *(_DWORD *)buf = 67111171;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2160;
          *(_QWORD *)&buf[10] = 1752392040;
          *(_WORD *)&buf[18] = 1045;
          *(_DWORD *)&buf[20] = 20;
          *(_WORD *)&buf[24] = 2101;
          *(_QWORD *)&buf[26] = (char *)v309 + 132;
          *(_WORD *)&buf[34] = 2160;
          *(_QWORD *)&buf[36] = 1752392040;
          *(_WORD *)&buf[44] = 1040;
          *(_DWORD *)&buf[46] = v327;
          *(_WORD *)&buf[50] = 2101;
          *(_QWORD *)&buf[52] = v845;
          v895 = 2080;
          v896 = v328;
          v897 = 1024;
          LODWORD(v898) = v329;
          _os_log_impl((void *)&_mh_execute_header, v319, OS_LOG_TYPE_INFO, "[Q%u] Sending unicast assist query (expiring) - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %s qhash %x", buf, 0x4Cu);
        }
      }
      else
      {
        v319 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
        {
          v322 = (_BYTE *)(v310 + 376);
          v845 = v310 + 376;
          if (v310 == -632)
          {
LABEL_648:
            while (v322)
            {
              v323 = *v322;
              if (v323 > 0x3F)
                break;
              if (!*v322)
              {
                v326 = (_WORD)v322 - (v310 + 376) + 1;
                goto LABEL_665;
              }
              v322 += v323 + 1;
              if (v310 != -632)
                goto LABEL_647;
            }
          }
          else
          {
LABEL_647:
            if ((unint64_t)v322 < v310 + 632)
              goto LABEL_648;
          }
          v326 = 257;
          goto LABEL_665;
        }
      }
      *v872 = *(_WORD *)(v310 + 340);
      *(_WORD *)(a1 + 28962) = 0;
      *(_QWORD *)(a1 + 28964) = 0;
      v330 = putQuestion((unint64_t)v872, v849, v858, (unsigned __int8 *)(v310 + 376), *(unsigned __int16 *)(v310 + 342), *(unsigned __int16 *)(v310 + 344) | 0x8000u, v320, v321);
      mDNSSendDNSMessage(a1, (unint64_t)v872, (unint64_t)v330, v309[4], 0, 0, (int *)v309 + 33, 0xE914u, 0, *(_BYTE *)(v310 + 640));
      v292 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v310 + 208) = v292;
      *(_DWORD *)(v310 + 256) = v292;
      *(_DWORD *)(v310 + 224) = 0;
      if (v292 <= 1)
        v331 = 1;
      else
        v331 = v292;
      *(_DWORD *)(v310 + 216) = v331;
      *(_QWORD *)(v310 + 64) = 0;
      *((_BYTE *)v309 + 130) = 1;
      *((_DWORD *)v309 + 26) = v292;
      v152 = a1 + 12648;
      goto LABEL_635;
    }
LABEL_671:
    v307 = v862 + 1;
    if (v862 != 498)
      continue;
    break;
  }
  v332 = *(_QWORD *)(a1 + 208);
  if (v332)
  {
    v333 = mDNSLogCategory_Default;
    v334 = v332 + 376;
    DNSTypeName(*(unsigned __int16 *)(v332 + 342));
    LogMsgWithLevel(v333, OS_LOG_TYPE_DEFAULT, "SendQueries ERROR m->CurrentQuestion already set: %##s (%s)", v335, v336, v337, v338, v339, v334);
  }
  v340 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 208) = v340;
  if (!v340)
  {
    *(_QWORD *)(a1 + 208) = 0;
    v350 = *(_DWORD *)(a1 + 64) + 939524096;
    *(_DWORD *)(a1 + 92) = v350;
    goto LABEL_777;
  }
  v341 = 0;
  while (2)
  {
    if (v340 != *v843)
    {
      if (!*(_WORD *)(v340 + 340))
      {
        v343 = *(_DWORD *)(v340 + 212);
        if (v343 >= 1 && !*(_QWORD *)(v340 + 40) && *(_DWORD *)(a1 + 64) - (v343 + *(_DWORD *)(v340 + 208)) >= 0)
        {
          if (QuestionSendsMDNSQueriesViaUnicast(v340))
          {
            *(_DWORD *)v872 = 0;
            *(_QWORD *)(a1 + 28964) = 0;
            v344 = putQuestion((unint64_t)v872, v849, v858, (unsigned __int8 *)(v340 + 376), *(unsigned __int16 *)(v340 + 342), *(unsigned __int16 *)(v340 + 344) | 0x8000u, v7, v8);
            mDNSSendDNSMessage(a1, (unint64_t)v872, (unint64_t)v344, *(_QWORD *)(v340 + 136), 0, 0, (int *)(v340 + 304), 0xE914u, 0, *(_BYTE *)(v340 + 640));
            v345 = 3 * *(_DWORD *)(v340 + 212);
            if (v345 >= 3600000)
              v345 = 3600000;
            *(_DWORD *)(v340 + 212) = v345;
            v346 = *(_DWORD *)(a1 + 64);
            *(_DWORD *)(v340 + 208) = v346;
            *(_DWORD *)(v340 + 256) = v346;
            *(_DWORD *)(v340 + 224) = 0;
            *(_QWORD *)(v340 + 64) = 0;
            if (v346 <= 1)
              v346 = 1;
            *(_DWORD *)(v340 + 216) = v346;
          }
          else
          {
            if (!*(_BYTE *)(v340 + 688))
            {
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = buf;
              *(_QWORD *)&buf[16] = 0x2000000000;
              *(_QWORD *)&buf[24] = 0;
              *(_QWORD *)&buf[24] = CacheGroupForName(a1, *(_DWORD *)(v340 + 200), (_BYTE *)(v340 + 376));
              *(_QWORD *)__dst = 0;
              *(_QWORD *)&__dst[8] = __dst;
              *(_QWORD *)&__dst[16] = 0x2000000000;
              LOBYTE(v881) = 0;
              *(_BYTE *)(v340 + 688) = 1;
              v347 = *(_DWORD *)(v340 + 200);
              v348 = *(_QWORD *)(v340 + 136);
              v878[0] = _NSConcreteStackBlock;
              v878[1] = (void *)0x40000000;
              v878[2] = __SendQueries_block_invoke;
              v878[3] = &unk_100139DE0;
              v878[6] = (void *)v340;
              v878[7] = (void *)a1;
              v878[4] = buf;
              v878[5] = __dst;
              unicast_assist_addr_enumerate(v347, v348, v878);
              v349 = *(unsigned __int8 *)(*(_QWORD *)&__dst[8] + 24);
              _Block_object_dispose(__dst, 8);
              _Block_object_dispose(buf, 8);
              if (v349)
                goto LABEL_678;
              v343 = *(_DWORD *)(v340 + 212);
            }
            *(_QWORD *)(v340 + 64) = -1;
            if (v341 <= v343)
              v341 = v343;
          }
        }
      }
LABEL_678:
      v342 = *(_QWORD *)(a1 + 208);
      if (v340 == v342)
      {
        v342 = *(_QWORD *)(v340 + 8);
        *(_QWORD *)(a1 + 208) = v342;
      }
      v340 = v342;
      if (!v342)
        goto LABEL_701;
      continue;
    }
    break;
  }
  v351 = mDNS_LoggingEnabled;
  do
  {
    if (v351)
    {
      v352 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v340 + 342));
      LogMsgWithLevel(v352, OS_LOG_TYPE_DEFAULT, "SendQueries question loop 1: Skipping NewQuestion %##s (%s)", v353, v354, v355, v356, v357, v340 + 376);
      v351 = mDNS_LoggingEnabled;
      v340 = *(_QWORD *)(a1 + 208);
    }
    v340 = *(_QWORD *)(v340 + 8);
    *(_QWORD *)(a1 + 208) = v340;
  }
  while (v340);
LABEL_701:
  v358 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 208) = 0;
  v350 = *(_DWORD *)(a1 + 64) + 939524096;
  *(_DWORD *)(a1 + 92) = v350;
  if (!v358)
    goto LABEL_776;
  while (v358 != *v843)
  {
    if (!*(_WORD *)(v358 + 340) && !QuestionSendsMDNSQueriesViaUnicast(v358))
    {
      if (*(_QWORD *)(v358 + 64))
      {
        v359 = *(_DWORD *)(a1 + 64);
        v360 = *(_DWORD *)(v358 + 208);
        goto LABEL_707;
      }
      v364 = *(_DWORD *)(v358 + 212);
      if (v364 >= 1 && !*(_QWORD *)(v358 + 40) && v364 <= v341)
      {
        v365 = *(_DWORD *)(a1 + 64);
        v366 = *(_DWORD *)(v358 + 208) + v364;
        if ((int)(v365 + v364 / 0xAu - v366) >= 0)
          goto LABEL_723;
        if ((int)(v365 + (v364 >> 1) - v366) >= 0)
        {
          v367 = (_BYTE *)(v358 + 376);
          v368 = (_BYTE *)(v358 + 376);
          if (v358 == -632)
            goto LABEL_730;
LABEL_727:
          v369 = 257;
          if ((unint64_t)v368 < v358 + 632 && v368)
          {
            while (1)
            {
              v370 = *v368;
              if (v370 > 0x3F)
              {
LABEL_737:
                v369 = 257;
                goto LABEL_765;
              }
              if (!*v368)
                break;
              v368 += v370 + 1;
              if (v358 != -632)
                goto LABEL_727;
LABEL_730:
              if (!v368)
                goto LABEL_737;
            }
            v369 = (_WORD)v368 - (_WORD)v367 + 1;
          }
LABEL_765:
          v386 = CacheGroupForName(a1, *(_DWORD *)(v358 + 200), v367);
          if (v386)
          {
            v392 = v386[2];
            if (v392)
            {
              v393 = v369 + 4;
              do
              {
                if (*(unsigned __int16 *)(v392 + 20) <= 0x400u
                  && SameNameRecordAnswersQuestion((unsigned __int8 *)(v392 + 8), 0, v358, v387, v388, v389, v390, v391))
                {
                  v394 = *(_DWORD *)(a1 + 64);
                  if (*(_DWORD *)(v392 + 80) - v394 + ((1000 * *(_DWORD *)(v392 + 16)) >> 1) >= 0
                    && *(_DWORD *)(v392 + 88) - (v394 + *(_DWORD *)(v358 + 212)) >= 1)
                  {
                    v393 += *(unsigned __int16 *)(v392 + 22) + 12;
                    if (v393 > 0x1FF)
                      goto LABEL_753;
                  }
                }
                v392 = *(_QWORD *)v392;
              }
              while (v392);
            }
          }
LABEL_723:
          v360 = *(_DWORD *)(v358 + 208);
          v359 = *(_DWORD *)(a1 + 64);
          if (v360 == v359)
            goto LABEL_753;
LABEL_707:
          v361 = *(_DWORD *)(v358 + 212);
          if (v361 >= 0)
            v362 = *(_DWORD *)(v358 + 212);
          else
            v362 = v361 + 1;
          if (v359 - v360 - (v362 >> 1) >= 0)
          {
            if (!*(_BYTE *)(v358 + 351)
              || *(_DWORD *)(v358 + 228) < *(unsigned __int8 *)(v358 + 351)
              || *(_BYTE *)(v358 + 359)
              || (*(_BYTE *)(v358 + 327) & 4) != 0 && v361 == 334)
            {
              *(_QWORD *)(v358 + 64) = -1;
              v363 = 3 * v361;
              *(_DWORD *)(v358 + 212) = 3 * v361;
              goto LABEL_717;
            }
            *(_QWORD *)(v358 + 64) = 0;
            *(_DWORD *)(v358 + 208) = v359;
            *(_DWORD *)(v358 + 212) = 3600000;
            *(_BYTE *)(v358 + 352) = 0;
            if (mDNS_LoggingEnabled == 1)
            {
              v371 = mDNSLogCategory_Default;
              v372 = DNSTypeName(*(unsigned __int16 *)(v358 + 342));
              LogMsgWithLevel(v371, OS_LOG_TYPE_DEFAULT, "SendQueries: (%s) %##s reached threshold of %d answers", v373, v374, v375, v376, v377, v372);
              v363 = *(_DWORD *)(v358 + 212);
LABEL_717:
              if (v363 > 3600000)
              {
                *(_DWORD *)(v358 + 212) = 3600000;
                goto LABEL_740;
              }
            }
            else
            {
              v363 = 3600000;
            }
            if (*(_WORD *)(v358 + 340))
              goto LABEL_740;
            v384 = *(_QWORD *)(v358 + 136);
            if (!v384 || *(_DWORD *)(v358 + 228) || v363 != 9018 || *(_BYTE *)(v358 + 352))
              goto LABEL_740;
            v385 = *(unsigned __int16 *)(v358 + 342);
            if (v385 == 28 || v385 == 1)
            {
              if (CacheHasAddressTypeForName(a1, (_BYTE *)(v358 + 376), *(_DWORD *)(v358 + 200)))
                goto LABEL_740;
              v384 = *(_QWORD *)(v358 + 136);
            }
            ReconfirmAntecedents(a1, (_BYTE *)(v358 + 376), *(_DWORD *)(v358 + 200), v384, 0);
          }
LABEL_740:
          v378 = *(_QWORD *)(v358 + 64);
          *(_BYTE *)(v358 + 358) = v378 == -1;
          if (v378 == -1)
          {
            v380 = v851;
            if (v851)
            {
              v380 = *(_QWORD *)(v358 + 136);
              if (!v380)
                v380 = *(_QWORD *)(v851 + 3552);
            }
            *(_QWORD *)(v358 + 64) = v380;
            v379 = *(_DWORD *)(a1 + 64);
            *(_DWORD *)(v358 + 208) = v379;
          }
          else
          {
            v379 = *(_DWORD *)(a1 + 64);
          }
          v381 = *(_QWORD *)(v358 + 56);
          if (v381)
          {
            v382 = 0;
            v383 = *(_DWORD *)(v358 + 212) / 2 - v379;
            do
            {
              if (v383 + *(_DWORD *)(v381 + v382 + 8) < 0)
                *(_QWORD *)(v381 + v382) = 0;
              v382 += 16;
            }
            while (v382 != 128);
          }
          *(_DWORD *)(v358 + 256) = v379;
          *(_DWORD *)(v358 + 224) = 0;
          if (*(_BYTE *)(v358 + 352))
            --*(_BYTE *)(v358 + 352);
        }
      }
    }
LABEL_753:
    SetNextQueryTime(a1, v358);
    v358 = *(_QWORD *)(v358 + 8);
    if (v358)
      continue;
    break;
  }
  v350 = *(_DWORD *)(a1 + 64) + 939524096;
LABEL_776:
  v152 = a1 + 12648;
LABEL_777:
  *(_DWORD *)(a1 + 96) = v350;
  v395 = *(_QWORD *)(a1 + 12640);
  if (v395)
  {
    v396 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v395 + 8), (unsigned __int16 *)(*(_QWORD *)(v395 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v396, OS_LOG_TYPE_DEFAULT, "SendQueries ERROR m->CurrentRecord already set %s", v397, v398, v399, v400, v401, a1 + 47032);
  }
  v402 = *v868;
  v403 = (_QWORD *)(a1 + 200);
  if (*v868)
  {
    while (2)
    {
      *(_QWORD *)(a1 + 12640) = *v402;
      if (!v402[4] && !*((_BYTE *)v402 + 122) && !IsLocalDomain((_BYTE *)v402[5])
        || *((_BYTE *)v402 + 8) != 2
        || *((_WORD *)v402 + 6) == 41)
      {
        goto LABEL_835;
      }
      v404 = *(_DWORD *)(a1 + 64);
      if (v404 - (*((_DWORD *)v402 + 71) + *((_DWORD *)v402 + 70)) >= 0)
      {
        v405 = *((unsigned __int8 *)v402 + 190);
        if (*((_BYTE *)v402 + 190))
        {
          v406 = *((_DWORD *)v402 + 36);
          if (v406 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v409 = mDNSLogCategory_Default;
              v410 = (_QWORD *)(a1 + 12656);
              do
                v410 = (_QWORD *)*v410;
              while (v410 && v410[444] != v402[4]);
              GetRRDisplayString_rdb((unsigned __int8 *)v402 + 8, (unsigned __int16 *)(v402[6] + 4), (_BYTE *)(a1 + 47032));
              LogMsgWithLevel(v409, OS_LOG_TYPE_DEFAULT, "SendQueries NDP Probe %d %s %s", v416, v417, v418, v419, v420, v405);
              v403 = (_QWORD *)(a1 + 200);
              v152 = a1 + 12648;
            }
            SendNDP(a1, 135, 0, (uint64_t)v402, (int8x8_t *)&zerov6Addr, 0, (uint64_t)v402 + 148, (uint64_t)v402 + 132);
          }
          else if (v406 == 4)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v407 = mDNSLogCategory_Default;
              v408 = (_QWORD *)(a1 + 12656);
              do
                v408 = (_QWORD *)*v408;
              while (v408 && v408[444] != v402[4]);
              GetRRDisplayString_rdb((unsigned __int8 *)v402 + 8, (unsigned __int16 *)(v402[6] + 4), (_BYTE *)(a1 + 47032));
              LogMsgWithLevel(v407, OS_LOG_TYPE_DEFAULT, "SendQueries ARP Probe %d %s %s", v411, v412, v413, v414, v415, v405);
              v403 = (_QWORD *)(a1 + 200);
              v152 = a1 + 12648;
            }
            SendARP(a1, 1, (uint64_t)v402, (uint64_t)&zerov4Addr, (uint64_t)&zeroEthAddr, (uint64_t)v402 + 148, (uint64_t)v402 + 132);
          }
          v421 = v851;
          if (v851)
          {
            if (*(_DWORD *)((char *)v402 + 126))
            {
              v421 = 0;
            }
            else
            {
              v421 = v402[4];
              if (!v421)
                v421 = *(_QWORD *)(v851 + 3552);
            }
          }
          v402[28] = v421;
          *((_DWORD *)v402 + 71) = *(_DWORD *)(a1 + 64);
          v422 = *((unsigned __int8 *)v402 + 190);
          if (v422 >= 3)
            LOBYTE(v422) = 3;
          *((_BYTE *)v402 + 190) = v422 - 1;
          SetNextAnnounceProbeTime(a1, (uint64_t)v402);
          if (!*((_BYTE *)v402 + 190))
          {
            for (i4 = *(uint64_t **)(a1 + 12624); i4; i4 = (uint64_t *)*i4)
            {
              if (*((_BYTE *)i4 + 8) == 2 && i4[4] == v402[4])
              {
                v424 = *((unsigned __int8 *)v402 + 8);
                v53 = v424 > 0x12;
                v425 = (1 << v424) & 0x50006;
                v426 = v53 || v425 == 0;
                if (!v426
                  && *((_DWORD *)i4 + 6) == *((_DWORD *)v402 + 6)
                  && resource_records_have_same_dnssec_rr_category(i4[8], v402[8])
                  && *((unsigned __int16 *)i4 + 6) == *((unsigned __int16 *)v402 + 6)
                  && *((unsigned __int16 *)i4 + 7) == *((unsigned __int16 *)v402 + 7)
                  && *((unsigned __int16 *)i4 + 10) == *((unsigned __int16 *)v402 + 10)
                  && *((_DWORD *)i4 + 7) == *((_DWORD *)v402 + 7)
                  && SameRDataBody((uint64_t)(i4 + 1), (unsigned __int16 *)(v402[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((_BYTE *)i4[5], (_BYTE *)v402[5]))
                {
                  *((_BYTE *)i4 + 190) = 0;
                }
              }
            }
            v152 = a1 + 12648;
            if (!*((_BYTE *)v402 + 188))
              AcknowledgeRecord(a1, (uint64_t)v402);
          }
LABEL_835:
          v402 = *(uint64_t **)(a1 + 12640);
          if (!v402)
            goto LABEL_836;
          continue;
        }
        if (!*((_BYTE *)v402 + 188))
        {
          AcknowledgeRecord(a1, (uint64_t)v402);
          v404 = *(_DWORD *)(a1 + 64);
        }
        *((_BYTE *)v402 + 8) = 16;
        *((_DWORD *)v402 + 70) = 500;
        *((_DWORD *)v402 + 71) = v404 - 500;
      }
      break;
    }
    SetNextAnnounceProbeTime(a1, (uint64_t)v402);
    goto LABEL_835;
  }
LABEL_836:
  v2 = *(_QWORD *)(a1 + 12624);
  *(_QWORD *)(a1 + 12640) = v2;
  v427 = (NSObject **)&unk_100164000;
  v428 = a1 + 28960;
  v429 = a1 + 28972;
  i5 = v851;
  if (v2)
  {
    do
    {
      v431 = *(_QWORD *)v2;
      *(_QWORD *)(a1 + 12640) = *(_QWORD *)v2;
      if (*(_BYTE *)(v2 + 8) == 2 && !*(_BYTE *)(v2 + 190) && !*(_BYTE *)(v2 + 188))
      {
        AcknowledgeRecord(a1, v2);
        v431 = *(_QWORD *)(a1 + 12640);
      }
      v2 = v431;
    }
    while (v431);
  }
  if (!v851)
    goto LABEL_1115;
  v831 = 0;
  v830 = 0;
  v432 = (__int16 *)(a1 + 28966);
  v856 = a1 + 30412;
  v863 = (__int16 *)(a1 + 28968);
  v841 = (_BYTE *)(a1 + 47032);
  v846 = (unsigned __int16 *)(a1 + 28970);
  while (2)
  {
    v837 = mDNS_McastTracingEnabled;
    if (mDNS_McastTracingEnabled)
      v433 = 20;
    else
      v433 = 0;
    v876 = 0;
    v877 = (_BYTE *)v429;
    *(_DWORD *)v428 = 0;
    *(_QWORD *)(v428 + 4) = 0;
    v434 = v879;
    v852 = (uint64_t *)i5;
    if (v879)
    {
      LOBYTE(v836) = 0;
      v435 = v429;
      goto LABEL_849;
    }
    v875 = &v879;
    v828 = v433;
    v874 = v433;
    v440 = *(_QWORD *)(a1 + 192);
    if (!v440)
    {
      LOBYTE(v836) = 0;
      goto LABEL_928;
    }
    v836 = 0;
    while (v440 != *v403)
    {
      if (*(_WORD *)(v440 + 340) || *(_QWORD *)(v440 + 64) != *(_QWORD *)(i5 + 3552))
        goto LABEL_903;
      if (!mDNSPlatformValidQuestionForInterface(v440, i5, v3, (uint64_t)v4, v5, v6, v7, v8))
        goto LABEL_900;
      v441 = *(_QWORD *)(i5 + 3552);
      if (DPCFeatureEnabled_sOnce != -1)
        dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
      if (DPCFeatureEnabled_sEnabled && _DPCQuestionGetSubscriber(*(const __CFSet **)(v440 + 192), v441))
      {
        v429 = a1 + 28972;
        goto LABEL_900;
      }
      v442 = *(_QWORD *)(v440 + 56);
      v429 = a1 + 28972;
      if (v442)
      {
        v443 = 0;
        v444 = *(_BYTE *)(i5 + 17) == 0;
        v445 = *(_BYTE *)(i5 + 18) == 0;
        while (1)
        {
          if (*(_QWORD *)(v442 + v443) == *(_QWORD *)(i5 + 3552))
          {
            v446 = *(_DWORD *)(v442 + v443 + 12);
            v447 = v446 == 6 || v445;
            if (v446 == 4)
              v444 = 1;
            else
              v445 = v447;
            if (v444 && v445)
              break;
          }
          v443 += 16;
          if (v443 == 128)
            goto LABEL_882;
        }
        ++*(_DWORD *)(v152 + 7272);
      }
      else
      {
LABEL_882:
        if (!BuildQuestion(a1, i5, v428, (unint64_t *)&v877, v440, &v875, &v874, v8))
          goto LABEL_903;
        if (!*(_QWORD *)(v440 + 40) && !*(_WORD *)(v440 + 340))
        {
          if (!*(_DWORD *)(v440 + 264) || *(_BYTE *)(v440 + 268))
          {
            v448 = *(_DWORD *)(a1 + 64);
            if (v448 <= 1)
              v448 = 1;
            *(_DWORD *)(v440 + 264) = v448;
            *(_BYTE *)(v440 + 268) = 0;
          }
          ++*(_DWORD *)(v440 + 260);
        }
      }
      if (!*(_BYTE *)(v440 + 356))
        goto LABEL_897;
      v449 = *(_QWORD *)(v440 + 136);
      v450 = (unsigned __int8 *)(v440 + 376);
      if ((v449 == 0 || v449 >= 0xFFFFFFFFFFFFFFFBLL) && ((1 << (v449 + 5)) & 0x2D) != 0)
      {
        LogMsgWithLevel(v427[295], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Invalid InterfaceID %p for question %##s", (uint64_t)v4, v5, v6, v7, v8, *(_QWORD *)(v440 + 136));
        goto LABEL_896;
      }
      v453 = *v450;
      if (v453 < 2)
      {
LABEL_918:
        LogMsgWithLevel(v427[295], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed WakeOnResolve name %##s", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
        goto LABEL_896;
      }
      v454 = 0;
      v455 = 0;
      while (2)
      {
        v456 = *(unsigned __int8 *)(v440 + 377 + v454);
        if (v456 == 58)
        {
          ++v455;
LABEL_917:
          if (v453 - 1 == ++v454)
            goto LABEL_918;
          continue;
        }
        break;
      }
      if (v456 != 64)
        goto LABEL_917;
      memset(__dst, 0, 18);
      memset(buf, 0, 47);
      if (v455 == 5)
      {
        v457 = v454 + 1;
        v458 = v454;
        if ((v454 + 1) >= 0x13)
        {
          v427 = (NSObject **)&unk_100164000;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, length %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
          goto LABEL_925;
        }
        v459 = v453 - v457;
        if ((int)v459 < 47)
        {
          memcpy(__dst, (const void *)(v440 + 377), v454);
          __dst[v458] = 0;
          memcpy(buf, &v450[v457 + 1], v459);
          buf[v459] = 0;
          v152 = a1 + 12648;
          ++*(_DWORD *)(a1 + 19992);
          mDNSPlatformSendWakeupPacket(v449, (const char *)__dst, (const char *)buf, 3 - *(unsigned __int8 *)(v440 + 356), v460, v461, v462, v463);
          v427 = (NSObject **)&unk_100164000;
          v403 = (_QWORD *)(a1 + 200);
        }
        else
        {
          v427 = (NSObject **)&unk_100164000;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed IP address %##s, length %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
          v403 = (_QWORD *)(a1 + 200);
LABEL_925:
          v152 = a1 + 12648;
        }
      }
      else
      {
        LogMsgWithLevel(v427[295], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, cnt %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
      }
LABEL_896:
      --*(_BYTE *)(v440 + 356);
      v429 = a1 + 28972;
LABEL_897:
      v451 = v836;
      if (*(_BYTE *)(v440 + 640))
        v451 = 1;
      v836 = v451;
LABEL_900:
      if (*(_QWORD *)(v440 + 136) || !*(_BYTE *)(v440 + 358))
      {
        v452 = 0;
      }
      else
      {
        v452 = *(_QWORD *)i5;
        if (*(_QWORD *)i5)
        {
          while (!*(_BYTE *)(v452 + 16))
          {
            v452 = *(_QWORD *)v452;
            if (!v452)
              goto LABEL_902;
          }
          v452 = *(_QWORD *)(v452 + 3552);
        }
      }
LABEL_902:
      *(_QWORD *)(v440 + 64) = v452;
LABEL_903:
      v440 = *(_QWORD *)(v440 + 8);
      if (v440)
        continue;
      break;
    }
LABEL_928:
    if (DPCFeatureEnabled_sOnce != -1)
      dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
    if (DPCFeatureEnabled_sEnabled)
      v464 = v831 == 0;
    else
      v464 = 0;
    if (v464)
    {
      if (*(_WORD *)(v428 + 4))
      {
        v465 = 0;
        v466 = (unsigned __int8 *)v429;
        v467 = (unint64_t)v877;
        do
        {
          bzero(buf, 0x2B8uLL);
          Question = getQuestion(v428, v466, v467, 0, buf);
          if (!Question)
            break;
          v466 = Question;
          v469 = v907 & 0x7FFF;
          v907 &= ~0x8000u;
          v470 = v906 == word_10014E236 && v469 == (unsigned __int16)word_10014E238;
          if (v470 && v905 == dword_10014E1A8 && SameDomainNameBytes(v911, byte_10014E258))
            goto LABEL_947;
          ++v465;
        }
        while (v465 < *(unsigned __int16 *)(v428 + 4));
        qword_10014E120 = *(_QWORD *)(i5 + 3552);
        byte_10014E240 = 2;
        BuildQuestion(a1, i5, v428, (unint64_t *)&v877, (uint64_t)&DPCBrowse, &v875, &v874, v8);
        qword_10014E120 = 0;
LABEL_947:
        v831 = 1;
        v429 = a1 + 28972;
      }
      else
      {
        v831 = 0;
      }
    }
    v471 = (uint64_t)*v868;
    if (!*v868)
    {
      v494 = 0;
      v491 = v828;
      goto LABEL_1030;
    }
    v472 = 0;
    v832 = 0;
    v826 = v874;
    while (2)
    {
      if (!*(_BYTE *)(v471 + 194))
      {
        v2 = *(_QWORD *)(v471 + 224);
        if (v2 == *(_QWORD *)(i5 + 3552) && *(_WORD *)(v471 + 12) != 41)
        {
          if (mDNSPlatformValidRecordForInterface(v471, v2, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            v825 = v472;
            if (*(unsigned __int8 *)(v471 + 190) >= 2u && *(_BYTE *)(a1 + 12))
            {
              v473 = *(unsigned __int16 *)(v428 + 4);
              v474 = 1440;
              if (!*(_WORD *)(v428 + 4))
                v474 = 8940;
              if (*(_BYTE *)(i5 + 3677))
                v475 = 0x8000;
              else
                v475 = 0;
            }
            else
            {
              v475 = 0;
              v473 = *(unsigned __int16 *)(v428 + 4);
              v474 = 1440;
              if (!*(_WORD *)(v428 + 4))
                v474 = 8940;
            }
            v476 = (unsigned __int8 *)v429;
            v477 = v429 + v474;
            v478 = *(_WORD *)(v471 + 14) | v475;
            bzero(buf, 0x2B8uLL);
            if (v473)
            {
              v479 = 0;
              while (1)
              {
                v476 = getQuestion(v428, v476, v477, 0, buf);
                if (v476)
                {
                  if (v906 == 255
                    && v907 == v478
                    && v905 == *(_DWORD *)(v471 + 24)
                    && SameDomainNameBytes(v911, *(_BYTE **)(v471 + 40)))
                  {
                    break;
                  }
                }
                v480 = 0;
                if (v476)
                {
                  if (++v479 < *(unsigned __int16 *)(v428 + 4))
                    continue;
                }
                goto LABEL_983;
              }
              v480 = 1;
            }
            else
            {
              v480 = 0;
            }
LABEL_983:
            v482 = UnsafeBufferPointer(*v868, v471, (uint64_t **)&v876);
            v483 = v832;
            if ((unsigned __int16)v832 | v837)
              v484 = 14;
            else
              v484 = 25;
            v485 = v826 + v484;
            if (v482)
              v483 = v832 + 1;
            v832 = v483;
            if (v482)
              v486 = v485;
            else
              v486 = v826;
            v487 = *v868;
            for (i5 = (uint64_t)v852; v487; v487 = (uint64_t *)*v487)
            {
              if (AddRecordInProbe(a1, v471, (uint64_t)v487, v852[444]))
                v486 += *((unsigned __int16 *)v487 + 11) + 12;
            }
            v2 = (uint64_t)v877;
            if ((v480 & 1) != 0)
            {
              v152 = a1 + 12648;
              if ((unint64_t)&v877[v486] >= v477)
                goto LABEL_1013;
              goto LABEL_1000;
            }
            v488 = putQuestion(v428, (unint64_t)v877, v477 - v486, *(unsigned __int8 **)(v471 + 40), 0xFFuLL, v478, v7, v8);
            if (v488)
            {
              v877 = v488;
              v152 = a1 + 12648;
LABEL_1000:
              for (i6 = *v868; i6; i6 = (uint64_t *)*i6)
              {
                if (AddRecordInProbe(a1, v471, (uint64_t)i6, v852[444]))
                {
                  if (*(_QWORD *)(v471 + 32))
                  {
                    v490 = 0;
                  }
                  else
                  {
                    v490 = *v852;
                    if (*v852)
                    {
                      while (!*(_BYTE *)(v490 + 16))
                      {
                        v490 = *(_QWORD *)v490;
                        if (!v490)
                          goto LABEL_1004;
                      }
                      v490 = *(_QWORD *)(v490 + 3552);
                    }
                  }
LABEL_1004:
                  i6[28] = v490;
                  *((_BYTE *)i6 + 194) = 1;
                }
              }
              v826 = v486;
LABEL_1013:
              v429 = a1 + 28972;
              v472 = v825;
            }
            else
            {
              v472 = v825 + 1;
              v152 = a1 + 12648;
              v429 = a1 + 28972;
            }
          }
          else
          {
            if (*(_QWORD *)(v471 + 32))
            {
              v481 = 0;
            }
            else
            {
              v481 = *(_QWORD *)i5;
              if (*(_QWORD *)i5)
              {
                while (!*(_BYTE *)(v481 + 16))
                {
                  v481 = *(_QWORD *)v481;
                  if (!v481)
                    goto LABEL_976;
                }
                v481 = *(_QWORD *)(v481 + 3552);
              }
            }
LABEL_976:
            *(_QWORD *)(v471 + 224) = v481;
            *(_BYTE *)(v471 + 194) = 0;
          }
        }
      }
      v471 = *(_QWORD *)v471;
      if (v471)
        continue;
      break;
    }
    v491 = v828;
    if (v472)
    {
      v492 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
          goto LABEL_1028;
      }
      else
      {
        v492 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
        {
LABEL_1028:
          v496 = *(_QWORD *)(i5 + 3552);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v472;
          *(_WORD *)&buf[8] = 2048;
          *(_QWORD *)&buf[10] = v496;
          _os_log_impl((void *)&_mh_execute_header, v492, OS_LOG_TYPE_DEBUG, "SendQueries: %u questions will be sent in a later request on InterfaceID= %p", buf, 0x12u);
        }
      }
    }
    v494 = v832;
LABEL_1030:
    v434 = v879;
    v435 = (unint64_t)v877;
    if (v879)
    {
      v433 = v491 + 14 * v494;
      if (v494)
      {
        v436 = 11;
        goto LABEL_850;
      }
LABEL_849:
      v436 = 0;
LABEL_850:
      if (v837)
        v436 = 0;
      v437 = v856 - (v436 + v433);
      while (1)
      {
        v438 = PutResourceRecordTTLWithLimit(v428, v435, v432, v434 + 8, *(_DWORD *)(v434 + 16) - (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v434 + 80)) / 0x3E8u, v437, v7, v8);
        if (!v438)
          break;
        v435 = v438;
        v877 = (_BYTE *)v438;
        v879 = *(_QWORD *)(v434 + 72);
        v439 = v879;
        *(_QWORD *)(v434 + 72) = 0;
        v434 = v439;
        if (!v439)
          goto LABEL_1033;
      }
      if (*(unsigned __int16 *)(v428 + 4) >= 2u)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendQueries:   Put %d answers; No more space for known answers",
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          (unsigned __int16)*v432);
      *(_BYTE *)(v428 + 2) |= 2u;
      v435 = (unint64_t)v877;
    }
LABEL_1033:
    v497 = *v868;
    if (*v868)
    {
      v498 = 0;
      v499 = v435;
      do
      {
        if (*((_BYTE *)v497 + 194))
        {
          if (*(unsigned __int16 *)(v428 + 4) <= 1u)
            v500 = a1 + 37912;
          else
            v500 = a1 + 30412;
          v435 = PutResourceRecordTTLWithLimit(v428, v499, v863, (uint64_t)(v497 + 1), *((unsigned int *)v497 + 4), v500, v7, v8);
          *((_BYTE *)v497 + 194) = 0;
          if (!v435)
          {
            v501 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)v497 + 8, (unsigned __int16 *)(v497[6] + 4), v841);
            LogMsgWithLevel(v501, OS_LOG_TYPE_DEFAULT, "SendQueries:   How did we fail to have space for the Update record %s", v502, v503, v504, v505, v506, (int)v841);
            v435 = v499;
          }
          v507 = UnsafeBufferPointer(*v868, (uint64_t)v497, (uint64_t **)&v876);
          if (v507)
          {
            v508 = v507;
            v509 = v497[5];
            v510 = *v432;
            v511 = *v846;
            v512 = *v863;
            v513 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v513)
              __break(1u);
            ++v498;
            *((_WORD *)v508 + 4) = v510 + v511 + v512 - 1;
            v513[1] = v508;
            v513[2] = v509;
            *v513 = v876;
            v876 = v513;
            v428 = a1 + 28960;
            v152 = a1 + 12648;
            i5 = (uint64_t)v852;
          }
          else
          {
            v152 = a1 + 12648;
          }
        }
        else
        {
          v435 = v499;
        }
        v497 = (uint64_t *)*v497;
        v499 = v435;
      }
      while (v497);
    }
    else
    {
      v498 = 0;
    }
    v877 = (_BYTE *)v435;
    v429 = a1 + 28972;
    if (v435 <= v849)
    {
      i5 = *(_QWORD *)i5;
      if (i5)
      {
        v427 = (NSObject **)&unk_100164000;
        v403 = (_QWORD *)(a1 + 200);
        do
        {
          if (*(_BYTE *)(i5 + 16))
            break;
          i5 = *(_QWORD *)i5;
        }
        while (i5);
        v831 = 0;
      }
      else
      {
        v831 = 0;
        v427 = (NSObject **)&unk_100164000;
        v403 = (_QWORD *)(a1 + 200);
      }
      goto LABEL_1110;
    }
    v514 = (void **)v876;
    if (v837 || v876)
    {
      bzero(buf, 0x498uLL);
      buf[8] = 32;
      strcpy((char *)&buf[12], ")");
      *(_DWORD *)&buf[16] = 4500;
      v917 = 264;
      *(_QWORD *)&buf[40] = v916;
      *(_QWORD *)&buf[48] = &v917;
      v908 = 0;
      v909 = 0;
      v898 = 0u;
      v899 = 0u;
      v900 = 0u;
      v901 = 0u;
      v902 = 0u;
      v903 = 0u;
      v904 = 0;
      v910 = v916;
      v912 = 0;
      v914 = 0;
      v915 = 0;
      v913 = 0;
      v916[0] = 0;
      memset(v911, 0, 217);
      *(_WORD *)&buf[14] = 1440;
      *(_WORD *)&buf[22] = 0;
      if (v837)
      {
        v919 = *(_BYTE *)(v152 + 28);
        v920 = -1735965292;
        *(_DWORD *)&buf[20] = 1572888;
        v918 = 392681;
        v518 = 48;
        v519 = 1;
        if (v514)
          goto LABEL_1060;
LABEL_1063:
        v523 = 4500;
      }
      else
      {
        v519 = 0;
        v518 = 24;
        if (!v514)
          goto LABEL_1063;
LABEL_1060:
        *(_WORD *)&buf[20] = v518;
        *(_WORD *)&buf[22] = v518;
        v520 = v514[1];
        v521 = &v918 + 6 * v519;
        v521[2] = v520[1];
        *((_WORD *)v521 + 6) = *((_WORD *)v520 + 4);
        v522 = *v520;
        *v521 = 720362;
        v521[1] = v522;
        v876 = *v514;
        free(v514);
        v523 = *(unsigned int *)&buf[16];
      }
      v515 = (char *)PutResourceRecordTTLWithLimit(v428, v435, v846, (uint64_t)&buf[8], v523, v858, v516, v517);
      v877 = v515;
      if (v515 && v876)
      {
        v515 = AddTSRROptsToMessage(&v876, v428, (_WORD *)(v435 + 9), v515, v858, v6, v7, v8);
        v877 = v515;
      }
      v427 = (NSObject **)&unk_100164000;
      if (!v515)
      {
        v524 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
            if (v837)
              v525 = "TRACER";
            else
              v525 = "";
LABEL_1078:
            v526 = *(unsigned __int16 *)(a1 + 28964);
            v827 = *(unsigned __int16 *)(a1 + 28966);
            v829 = *(unsigned __int16 *)(a1 + 28968);
            v833 = *(unsigned __int16 *)(a1 + 28970);
            GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(_QWORD *)&buf[48] + 4), v841);
            *(_DWORD *)__dst = 136316930;
            *(_QWORD *)&__dst[4] = "";
            *(_WORD *)&__dst[12] = 2080;
            *(_QWORD *)&__dst[14] = v525;
            *(_WORD *)&__dst[22] = 1024;
            v881 = v498;
            v428 = a1 + 28960;
            v882 = 1024;
            *(_DWORD *)v883 = v526;
            i5 = (uint64_t)v852;
            *(_WORD *)&v883[4] = 1024;
            *(_DWORD *)&v883[6] = v827;
            LOWORD(v884) = 1024;
            *(_DWORD *)((char *)&v884 + 2) = v829;
            v427 = (NSObject **)&unk_100164000;
            HIWORD(v884) = 1024;
            LODWORD(v885) = v833;
            WORD2(v885) = 2080;
            *(_QWORD *)((char *)&v885 + 6) = a1 + 47032;
            v152 = a1 + 12648;
            _os_log_impl((void *)&_mh_execute_header, v524, OS_LOG_TYPE_ERROR, "SendQueries: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s", __dst, 0x3Eu);
          }
        }
        else
        {
          v524 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          {
            if (v837)
              v525 = "TRACER";
            else
              v525 = "";
            goto LABEL_1078;
          }
        }
      }
      if ((unint64_t)v515 > v856)
      {
        v527 = *(unsigned __int16 *)(v428 + 4);
        if (v527 != 1 || *v432 || *v863 != 1 || *v846 != 1)
        {
          v528 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
            {
              if (v837)
                v533 = "TRACER";
              else
                v533 = "";
              v534 = (unsigned __int16)*v432;
              v835 = (unsigned __int16)*v863;
              v839 = *v846;
              GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(_QWORD *)&buf[48] + 4), v841);
              *(_DWORD *)__dst = 136317698;
              *(_QWORD *)&__dst[4] = "";
              *(_WORD *)&__dst[12] = 2080;
              *(_QWORD *)&__dst[14] = v533;
              v428 = a1 + 28960;
              *(_WORD *)&__dst[22] = 1024;
              v881 = v498;
              v882 = 2048;
              *(_QWORD *)v883 = a1 + 28972;
              *(_WORD *)&v883[8] = 2048;
              v884 = a1 + 30412;
              LOWORD(v885) = 2048;
              *(_QWORD *)((char *)&v885 + 2) = v515;
              WORD5(v885) = 1024;
              HIDWORD(v885) = v527;
              v886 = 1024;
              v887 = v534;
              i5 = (uint64_t)v852;
              v888 = 1024;
              v889 = v835;
              v890 = 1024;
              v891 = v839;
              v427 = (NSObject **)&unk_100164000;
              v892 = 2080;
              v893 = a1 + 47032;
              v152 = a1 + 12648;
              v532 = v528;
LABEL_1096:
              _os_log_impl((void *)&_mh_execute_header, v532, OS_LOG_TYPE_ERROR, "SendQueries: Why did we generate oversized packet with %s %s TSR(%d) OPT record %p %p %p (%d/%d/%d/%d) %s", __dst, 0x5Cu);
            }
          }
          else
          {
            v529 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            {
              if (v837)
                v530 = "TRACER";
              else
                v530 = "";
              v531 = (unsigned __int16)*v432;
              v834 = (unsigned __int16)*v863;
              v838 = *v846;
              GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(_QWORD *)&buf[48] + 4), v841);
              *(_DWORD *)__dst = 136317698;
              *(_QWORD *)&__dst[4] = "";
              *(_WORD *)&__dst[12] = 2080;
              *(_QWORD *)&__dst[14] = v530;
              v428 = a1 + 28960;
              *(_WORD *)&__dst[22] = 1024;
              v881 = v498;
              v882 = 2048;
              *(_QWORD *)v883 = a1 + 28972;
              *(_WORD *)&v883[8] = 2048;
              v884 = a1 + 30412;
              LOWORD(v885) = 2048;
              *(_QWORD *)((char *)&v885 + 2) = v515;
              WORD5(v885) = 1024;
              HIDWORD(v885) = v527;
              v886 = 1024;
              v887 = v531;
              i5 = (uint64_t)v852;
              v888 = 1024;
              v889 = v834;
              v890 = 1024;
              v891 = v838;
              v427 = (NSObject **)&unk_100164000;
              v892 = 2080;
              v893 = a1 + 47032;
              v152 = a1 + 12648;
              v532 = v529;
              goto LABEL_1096;
            }
          }
        }
      }
      v429 = a1 + 28972;
      goto LABEL_1098;
    }
    v515 = (char *)v435;
    v427 = (NSObject **)&unk_100164000;
LABEL_1098:
    v403 = (_QWORD *)(a1 + 200);
    if ((*(_BYTE *)(v428 + 2) & 2) != 0 && *(unsigned __int16 *)(v428 + 4) >= 2u)
      LogMsgWithLevel(v427[295], OS_LOG_TYPE_DEFAULT, "SendQueries: Should not have more than one question (%d) in a truncated packet", (uint64_t)v4, v5, v6, v7, v8, *(unsigned __int16 *)(v428 + 4));
    if (*(_BYTE *)(i5 + 17))
      mDNSSendDNSMessage(a1, v428, (unint64_t)v515, *(_QWORD *)(i5 + 3552), 0, 0, AllDNSLinkGroup_v4, 0xE914u, 0, v836);
    if (*(_BYTE *)(i5 + 18))
      mDNSSendDNSMessage(a1, v428, (unint64_t)v877, *(_QWORD *)(i5 + 3552), 0, 0, &AllDNSLinkGroup_v6, 0xE914u, 0, v836);
    if (!*(_DWORD *)(a1 + 80))
    {
      v535 = *(_DWORD *)(a1 + 64) + 100;
      if (v535 <= 1)
        v535 = 1;
      *(_DWORD *)(a1 + 80) = v535;
    }
    if (++v830 >= 1000)
    {
      LogMsgWithLevel(v427[295], OS_LOG_TYPE_DEFAULT, "SendQueries exceeded loop limit %d: giving up", (uint64_t)v4, v5, v6, v7, v8, v830);
      break;
    }
LABEL_1110:
    v536 = v876;
    if (v876)
    {
      do
      {
        v537 = (_QWORD *)*v536;
        free(v536);
        v536 = v537;
      }
      while (v537);
    }
    if (i5)
      continue;
    break;
  }
LABEL_1115:
  for (i7 = *v868; i7; i7 = (uint64_t *)*i7)
  {
    v539 = i7[28];
    if (v539)
    {
      v540 = *((_DWORD *)i7 + 43);
      if (v540 != 4 && v540 != 5 && mDNS_LoggingEnabled != 0)
      {
        v542 = v427[295];
        GetRRDisplayString_rdb((unsigned __int8 *)i7 + 8, (unsigned __int16 *)(i7[6] + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v542, OS_LOG_TYPE_DEFAULT, "SendQueries: No active interface %d to send probe: %d %s", v543, v544, v545, v546, v547, v539);
      }
      i7[28] = 0;
    }
  }
  for (i8 = 0; i8 != 499; ++i8)
  {
    for (i9 = *(_QWORD **)(a1 + 8 * i8 + 272); i9; i9 = (_QWORD *)*i9)
    {
      for (i10 = i9[2]; i10; i10 = *(_QWORD *)i10)
      {
        v551 = *(_QWORD *)(i10 + 96);
        if (v551)
        {
          v552 = *(unsigned __int8 *)(i10 + 108);
          if (v552 <= 3)
          {
            v553 = *(_DWORD *)(a1 + 64);
            v554 = 1374389535000 * *(_DWORD *)(i10 + 16);
            if ((int)(v553 - *(_DWORD *)(i10 + 88) + (v554 >> 36) + ((unint64_t)v554 >> 63)) >= 0)
            {
              if (*(_DWORD *)(i10 + 104) != v553)
                *(_BYTE *)(i10 + 108) = v552 + 1;
              *(_QWORD *)(v551 + 64) = 0;
              SetNextCacheCheckTimeForRecord(a1, i10);
            }
          }
        }
      }
    }
  }
  for (i11 = *(_QWORD *)(a1 + 192); i11; i11 = *(_QWORD *)(i11 + 8))
  {
    v556 = *(_QWORD *)(i11 + 64);
    if (v556)
    {
      v557 = (_QWORD *)(a1 + 200);
      do
      {
        v558 = *v557;
        v557 = (_QWORD *)(*v557 + 8);
        if (v558)
          v559 = v558 == i11;
        else
          v559 = 1;
      }
      while (!v559);
      if (*(_QWORD *)(i11 + 136) != -5 && mDNS_LoggingEnabled != 0)
      {
        v561 = v427[295];
        DNSTypeName(*(unsigned __int16 *)(i11 + 342));
        v427 = (NSObject **)&unk_100164000;
        v152 = a1 + 12648;
        LogMsgWithLevel(v561, OS_LOG_TYPE_DEFAULT, "SendQueries: No active interface %d to send %s question: %d %##s (%s)", v562, v563, v564, v565, v566, v556);
      }
      *(_QWORD *)(i11 + 64) = 0;
    }
    *(_BYTE *)(i11 + 359) = 0;
  }
  v292 = *(_DWORD *)(a1 + 64);
  if ((int)(v292 - *(_DWORD *)(a1 + 92)) >= 0)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send all its queries (%d - %d = %d) will try again in one second", (uint64_t)v4, v5, v6, v7, v8, v292);
    v292 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 92) = v292 + 1000;
    v567 = *(_QWORD *)(a1 + 192);
    if (v567)
    {
      do
      {
        if (v567 == *v843)
          break;
        v568 = *(_DWORD *)(v567 + 212);
        if (v568 >= 1 && !*(_QWORD *)(v567 + 40) && *(_DWORD *)(a1 + 64) - (v568 + *(_DWORD *)(v567 + 208)) >= 0)
        {
          v569 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v567 + 342));
          LogMsgWithLevel(v569, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send %##s (%s)", v570, v571, v572, v573, v574, v567 + 376);
        }
        v567 = *(_QWORD *)(v567 + 8);
      }
      while (v567);
      v292 = *(_DWORD *)(a1 + 64);
    }
  }
LABEL_1161:
  if ((int)(v292 - *(_DWORD *)(a1 + 96)) >= 0)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send all its probes (%d - %d = %d) will try again in one second", (uint64_t)v4, v5, v6, v7, v8, v292);
    v292 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 96) = v292 + 1000;
  }
LABEL_1163:
  v575 = *(_DWORD *)(a1 + 84);
  if (!v575 || ((v292 - v575) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = 0;
    if ((int)(v292 - *(_DWORD *)(a1 + 100)) >= 0)
    {
      SendResponses(a1, v2, v3, v4, v5, v6, v7, v8);
      v292 = *(_DWORD *)(a1 + 64);
      if ((int)(v292 - *(_DWORD *)(a1 + 100)) >= 0)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendResponses didn't send all its responses; will try again in one second",
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          v824);
        v292 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 100) = v292 + 1000;
      }
    }
  }
LABEL_1168:
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  v576 = *(_DWORD *)(a1 + 184);
  if (v576 && ((v292 - v576) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 184) = v292 + 939524096;
    TimeoutQuestions_internal(a1, *(_QWORD *)(a1 + 192), 0, (uint64_t)v4, v5, v6, v7, v8);
    TimeoutQuestions_internal(a1, *(_QWORD *)(a1 + 216), -2, v577, v578, v579, v580, v581);
    v292 = *(_DWORD *)(a1 + 64);
  }
  v582 = *(_DWORD *)(a1 + 12684);
  if (v582 && ((v292 - v582) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 12684) = 0;
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateAllSRVRecords %d", (uint64_t)v4, v5, v6, v7, v8, *(unsigned __int8 *)(a1 + 141));
    v583 = *(_QWORD *)(a1 + 12640);
    if (v583)
    {
      v584 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v583 + 8), (unsigned __int16 *)(*(_QWORD *)(v583 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v584, OS_LOG_TYPE_DEFAULT, "UpdateAllSRVRecords ERROR m->CurrentRecord already set %s", v585, v586, v587, v588, v589, a1 + 47032);
    }
    v590 = *(_QWORD *)(a1 + 12616);
    *(_QWORD *)(a1 + 12640) = v590;
    if (v590)
    {
      do
      {
        v591 = *(_QWORD *)v590;
        *(_QWORD *)(a1 + 12640) = *(_QWORD *)v590;
        if (!*(_QWORD *)(v590 + 32))
        {
          if (!*(_BYTE *)(v590 + 122) && !IsLocalDomain(*(_BYTE **)(v590 + 40)) && *(_WORD *)(v590 + 12) == 33)
            UpdateOneSRVRecord(a1, v590);
          v591 = *(_QWORD *)(a1 + 12640);
        }
        v590 = v591;
      }
      while (v591);
    }
    v292 = *(_DWORD *)(a1 + 64);
  }
  if ((int)(v292 - *(_DWORD *)(a1 + 104)) < 0)
    goto LABEL_1294;
  v593 = (_DWORD *)(v152 + 72);
  v592 = *(unsigned __int8 *)(v152 + 72);
  if (v592 == 10)
    goto LABEL_1191;
  if (v592 == 172)
  {
    if ((*(_BYTE *)(v152 + 73) & 0xF0) == 0x10)
      goto LABEL_1191;
    goto LABEL_1195;
  }
  if (v592 != 192 || *(unsigned __int8 *)(v152 + 73) != 168)
  {
LABEL_1195:
    v595 = *(_DWORD *)(a1 + 12720);
    v594 = v595 != 0;
    *(_DWORD *)(a1 + 104) = v292 + 939524096;
    if (v595)
      *(_DWORD *)(a1 + 14744) = v595;
    goto LABEL_1198;
  }
LABEL_1191:
  *(_DWORD *)(a1 + 104) = v292 + 939524096;
  if (!*(_QWORD *)(a1 + 14720))
  {
    v594 = 0;
LABEL_1198:
    v596 = *(void **)(a1 + 14760);
    if (v596)
    {
      CloseSocketSet(*(_QWORD *)(a1 + 14760));
      free(v596);
      *(_QWORD *)(a1 + 14760) = 0;
    }
    v597 = *(void **)(a1 + 15024);
    if (v597)
    {
      CloseSocketSet(*(_QWORD *)(a1 + 15024));
      free(v597);
      *(_QWORD *)(a1 + 15024) = 0;
    }
    goto LABEL_1202;
  }
  if (*(_QWORD *)(a1 + 14760))
    goto LABEL_1193;
  v601 = mDNSPlatformUDPSocket(0xE614u);
  *(_QWORD *)(a1 + 14760) = v601;
  if (v601)
  {
    v594 = 0;
    CheckNATMappings_needLog = 0;
  }
  else if ((CheckNATMappings_needLog & 1) != 0)
  {
LABEL_1193:
    v594 = 0;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CheckNATMappings: Failed to allocate port 5350 UDP multicast socket for PCP & NAT-PMP announcements", (uint64_t)v4, v5, v6, v7, v8, v824);
    v594 = 0;
    CheckNATMappings_needLog = 1;
  }
LABEL_1202:
  v598 = *(_DWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 14720))
  {
    v599 = *(_DWORD *)(a1 + 14740);
    if ((int)(v598 - v599) >= 0)
    {
      v600 = *(unsigned __int8 *)(a1 + 12700);
      if (v600 != 10)
      {
        if (v600 == 172)
        {
          if ((*(_BYTE *)(a1 + 12701) & 0xF0) != 0x10)
            goto LABEL_1221;
        }
        else if (v600 != 192 || *(unsigned __int8 *)(a1 + 12701) != 168)
        {
          goto LABEL_1221;
        }
      }
      mDNSPlatformSendUDP((_QWORD *)a1, uDNS_RequestAddress_req, (uint64_t)&uDNS_RequestAddress_req[1], 0, 0, (int *)(a1 + 12696), 0xE714u, 0);
      if (*(_WORD *)(a1 + 15034) && *(_WORD *)(a1 + 15036))
      {
        v602 = SendSOAPMsgControlAction(a1, a1 + 14784, (uint64_t)"GetExternalIPAddress", 0, 0, 2);
        if (v602)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_RequestAddress: LNT_GetExternalAddress returned error %d", (uint64_t)v4, v5, v6, v7, v8, v602);
      }
      else
      {
        LNT_SendDiscoveryMsg(a1);
      }
LABEL_1221:
      v603 = *(_DWORD *)(a1 + 14736);
      v604 = 2 * v603;
      if (v603 >= 450000)
        v604 = 900000;
      if (v603 >= 250)
        v605 = v604;
      else
        v605 = 250;
      *(_DWORD *)(a1 + 14736) = v605;
      v599 = *(_DWORD *)(a1 + 64) + v605;
      if (v599 <= 1)
        v599 = 1;
      *(_DWORD *)(a1 + 14740) = v599;
    }
  }
  else
  {
    v599 = v598 + 939524096;
    if ((v598 + 939524096) <= 1)
      v599 = 1;
    *(_DWORD *)(a1 + 14740) = v599;
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_RequestAddress: Setting retryGetAddr to future", (uint64_t)v4, v5, v6, v7, v8, v824);
      v599 = *(_DWORD *)(a1 + 14740);
    }
  }
  if ((int)(*(_DWORD *)(a1 + 104) - v599) >= 1)
    *(_DWORD *)(a1 + 104) = v599;
  if (*(_QWORD *)(a1 + 14728))
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "WARNING m->CurrentNATTraversal already in use", (uint64_t)v4, v5, v6, v7, v8, v824);
  v606 = *(_QWORD *)(a1 + 14720);
  *(_QWORD *)(a1 + 14728) = v606;
  if (v606)
  {
    while (2)
    {
      v607 = (_DWORD *)(v606 + 156);
      v608 = *(_QWORD *)v606;
      if (v594)
        v607 = v593;
      *(_DWORD *)buf = *v607;
      *(_QWORD *)(a1 + 14728) = v608;
      if (v594)
      {
        *(_DWORD *)(v606 + 8) = 0;
        *(_DWORD *)(v606 + 20) = 0;
      }
      else
      {
        v609 = *(_DWORD *)(a1 + 64);
        v610 = *(_DWORD *)(v606 + 16);
        if (v609 - v610 >= 0)
        {
          v611 = *(_DWORD *)(v606 + 8);
          if (v611 && v611 - v609 < 0)
            *(_QWORD *)(v606 + 8) = 0xFA00000000;
          uDNS_SendNATMsg(a1, v606, 1, 0);
          v612 = *(_DWORD *)(v606 + 8);
          if (v612)
          {
            v613 = (v612 - *(_DWORD *)(a1 + 64)) / 2;
            if (v613 <= 2000)
              v613 = 2000;
            *(_DWORD *)(v606 + 12) = v613;
            v614 = *(_DWORD *)(a1 + 64);
          }
          else
          {
            v615 = *(_DWORD *)(v606 + 12);
            v614 = 2 * v615;
            if (v615 >= 450000)
              v614 = 900000;
            if (v615 < 250)
              v614 = 250;
            *(_DWORD *)(v606 + 12) = v614;
            v613 = *(_DWORD *)(a1 + 64);
          }
          v610 = v614 + v613;
          *(_DWORD *)(v606 + 16) = v610;
        }
        if (*(_DWORD *)(a1 + 104) - v610 >= 1)
          *(_DWORD *)(a1 + 104) = v610;
      }
      v616 = *(_DWORD *)buf;
      if (!*(_DWORD *)buf && *(int *)(v606 + 12) < 2001)
        goto LABEL_1292;
      v617 = *(_DWORD *)(v606 + 20);
      if (v617)
      {
        if (v594)
          goto LABEL_1258;
LABEL_1267:
        if (*(_DWORD *)buf)
        {
          if (*(_DWORD *)(v606 + 8))
            v620 = (__int16 *)(v606 + 176);
          else
            v620 = &zeroIPPort;
        }
        else
        {
          v620 = &zeroIPPort;
        }
        v618 = (unsigned __int16)*v620;
        v619 = *(unsigned __int8 *)(v606 + 172);
        if (*(_BYTE *)(v606 + 172))
        {
          if (*(_DWORD *)(v606 + 8) || *(int *)(v606 + 12) >= 2001)
          {
            v619 = 1;
            goto LABEL_1276;
          }
        }
        else
        {
LABEL_1276:
          if (*(_DWORD *)(v606 + 152) != *(_DWORD *)buf
            || *(unsigned __int16 *)(v606 + 160) != v618
            || *(_DWORD *)(v606 + 168) != v617)
          {
            if (!v619 || v618)
            {
              v621 = 0;
              *(_DWORD *)(v606 + 152) = *(_DWORD *)buf;
              *(_WORD *)(v606 + 160) = v618;
              v622 = *(_DWORD *)(v606 + 8);
              if (v622 && v618)
              {
                v623 = 274877907 * (v622 - *(_DWORD *)(a1 + 64) + 500);
                v621 = (v623 >> 38) + ((unint64_t)v623 >> 63);
              }
            }
            else
            {
              if (*(_DWORD *)(a1 + 12700) && (v617 || mDNS_LoggingEnabled == 1))
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CheckNATMapping: Failed to obtain NAT port mapping %p from router %#a external address %.4a internal port %5d interval %d error %d", (uint64_t)v4, v5, v6, v7, v8, v606);
                v616 = *(_DWORD *)buf;
              }
              v621 = 0;
              *(_DWORD *)(v606 + 152) = v616;
              *(_WORD *)(v606 + 160) = 0;
            }
            *(_DWORD *)(v606 + 164) = v621;
            *(_DWORD *)(v606 + 168) = v617;
            v624 = *(_DWORD *)(a1 + 48);
            v625 = *(_DWORD *)(a1 + 52) + 1;
            *(_DWORD *)(a1 + 52) = v625;
            mDNS_VerifyLockState("Drop Lock", 0, v624, v625, (uint64_t)"CheckNATMappings", 5109);
            v626 = *(void (**)(uint64_t, uint64_t))(v606 + 184);
            if (v626)
              v626(a1, v606);
            mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"CheckNATMappings", 5112);
            --*(_DWORD *)(a1 + 52);
          }
        }
LABEL_1292:
        v606 = *(_QWORD *)(a1 + 14728);
        if (!v606)
          goto LABEL_1293;
        continue;
      }
      break;
    }
    if (buf[0] != 10)
    {
      if (buf[0] != 172)
      {
        if (buf[0] == 192 && buf[1] == 168)
          goto LABEL_1263;
LABEL_1266:
        v617 = 0;
        if (!v594)
          goto LABEL_1267;
LABEL_1258:
        v618 = *(unsigned __int16 *)(v606 + 174);
        v619 = *(unsigned __int8 *)(v606 + 172);
        goto LABEL_1276;
      }
      if ((buf[1] & 0xF0) != 0x10)
        goto LABEL_1266;
    }
LABEL_1263:
    v617 = -65558;
    if (!v594)
      goto LABEL_1267;
    goto LABEL_1258;
  }
LABEL_1293:
  v292 = *(_DWORD *)(a1 + 64);
LABEL_1294:
  if ((int)(v292 - *(_DWORD *)(a1 + 12680)) < 0)
    goto LABEL_1526;
  v840 = v292 + 939524096;
  *(_DWORD *)(a1 + 12680) = v292 + 939524096;
  v627 = *(uint64_t **)(a1 + 12616);
  if (!v627)
    goto LABEL_1483;
  v628 = 0;
  v873 = (_BYTE *)(a1 + 47032);
  v847 = a1 + 28972;
  while (2)
  {
    v629 = v292 + 1000;
    if (v628)
    {
      v635 = &unk_100164000;
      if (!AreRecordsMergeable(a1, v628, (uint64_t)v627, v629))
        goto LABEL_1304;
      goto LABEL_1301;
    }
    v636 = IsRecordMergeable(a1, (uint64_t)v627, v292 + 1000);
    v628 = (uint64_t)v627;
    v635 = &unk_100164000;
    if (!v636)
    {
      v627 = (uint64_t *)*v627;
      if (v627)
        goto LABEL_1401;
      v733 = *v868;
      if (!*v868)
        goto LABEL_1483;
      v734 = a1 + 37912;
      v735 = "SendRecordDeregistration: Error formatting message for %s";
      while (1)
      {
        if (!v733[4] && !*((_BYTE *)v733 + 122) && !IsLocalDomain((_BYTE *)v733[5]))
        {
          v736 = *((_DWORD *)v733 + 86);
          if (v736 > 8)
            goto LABEL_1470;
          v737 = 1 << v736;
          if ((v737 & 0xAE) != 0)
          {
            if (*((_DWORD *)v733 + 70) + *((_DWORD *)v733 + 71) - *(_DWORD *)(a1 + 64) > 0)
              goto LABEL_1470;
            v738 = v733[48];
            if (v738)
            {
              DisposeTCPConn(v738);
              v733[48] = 0;
            }
            v739 = (_DWORD *)v733[47];
            if (v739)
            {
              if (v739[198])
              {
                if (*((_DWORD *)v733 + 86) == 3)
                {
                  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SendRecordDeregistration", 4294);
                  v740 = v733[47];
                  if (v740 && *(_DWORD *)(v740 + 792))
                  {
                    AuthInfoForName_internal = GetAuthInfoForName_internal(a1, (_BYTE *)v733[5]);
                    if (AuthInfoForName_internal)
                    {
                      v742 = (char *)AuthInfoForName_internal + 268;
                      if (AuthInfoForName_internal == (uint64_t *)-524)
                        goto LABEL_1442;
LABEL_1439:
                      if (v742 >= (_BYTE *)AuthInfoForName_internal + 524)
                      {
LABEL_1454:
                        v743 = 257;
                      }
                      else
                      {
                        v743 = 257;
                        if (v742)
                        {
                          while (1)
                          {
                            v744 = *v742;
                            if (v744 > 0x3F)
                              goto LABEL_1454;
                            if (!*v742)
                              break;
                            v742 += v744 + 1;
                            if (AuthInfoForName_internal != (uint64_t *)-524)
                              goto LABEL_1439;
LABEL_1442:
                            if (!v742)
                              goto LABEL_1454;
                          }
                          v743 = (_WORD)v742 - ((_WORD)AuthInfoForName_internal + 268) + 1;
                        }
                      }
                      v753 = -103 - v743;
                    }
                    else
                    {
                      v753 = -35;
                    }
                    v870 = (unsigned __int8 *)(v733 + 1);
                    v754 = v734 + v753;
                    v755 = mDNS_NewMessageID(a1);
                    *((_WORD *)v733 + 179) = v755;
                    *v872 = v755;
                    *(_WORD *)(a1 + 28962) = 40;
                    *(_QWORD *)(a1 + 28964) = 0;
                    v759 = putZone((unint64_t)v872, v847, v754, (unsigned __int8 *)v733[46], bswap32(*((unsigned __int16 *)v733 + 7)) >> 16, v756, v757, v758);
                    if (v759
                      && (updated = BuildUpdateMessage(a1, (unint64_t)v759, (uint64_t)v733, v754, v760, v761, v762, v763)) != 0)
                    {
                      v765 = updated;
                      if (*((_BYTE *)v733 + 356))
                      {
                        if (!mDNS_LoggingEnabled)
                          goto LABEL_1464;
                        v866 = mDNSLogCategory_Default;
                        v766 = v733[48];
                        GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                        LogMsgWithLevel(v866, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration TCP %p %s", v767, v768, v769, v770, v771, v766);
                        v772 = v733[48];
                        if (v772 && mDNS_LoggingEnabled)
                        {
                          v773 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                          LogMsgWithLevel(v773, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration: Disposing existing TCP connection for %s", v774, v775, v776, v777, v778, (int)v873);
LABEL_1464:
                          v772 = v733[48];
                        }
                        if (v772)
                        {
                          DisposeTCPConn(v772);
                          v733[48] = 0;
                        }
                        v779 = v733[47];
                        if (v779)
                        {
                          v733[48] = (uint64_t)MakeTCPConn(a1, v872, v765, 1, (int *)(v779 + 788), *(unsigned __int16 *)(v779 + 786), (_BYTE *)(v779 + 530), 0, (uint64_t)v733);
                          goto LABEL_1479;
                        }
                        v796 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                        LogMsgWithLevel(v796, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration:Private:ERROR!! nta is NULL for %s", v797, v798, v799, v800, v801, (int)v873);
                      }
                      else
                      {
                        if (mDNS_LoggingEnabled)
                        {
                          v788 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                          LogMsgWithLevel(v788, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration UDP %s", v789, v790, v791, v792, v793, (int)v873);
                        }
                        v794 = v733[47];
                        if (v794)
                        {
                          v795 = GetAuthInfoForName_internal(a1, (_BYTE *)v733[5]);
                          mDNSSendDNSMessage(a1, (unint64_t)v872, v765, 0, 0, 0, (int *)(v794 + 788), *(_WORD *)(v794 + 786), v795, 0);
LABEL_1479:
                          SetRecordRetry(a1, (uint64_t)v733, 0);
                        }
                        else
                        {
                          v802 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                          LogMsgWithLevel(v802, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration:ERROR!! nta is NULL for %s", v803, v804, v805, v806, v807, (int)v873);
                        }
                      }
                      v735 = "SendRecordDeregistration: Error formatting message for %s";
                    }
                    else
                    {
                      v780 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v870, (unsigned __int16 *)(v733[6] + 4), v873);
                      v781 = v780;
                      v735 = "SendRecordDeregistration: Error formatting message for %s";
                      LogMsgWithLevel(v781, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration: Error formatting message for %s", v782, v783, v784, v785, v786, (int)v873);
                    }
                  }
                  else
                  {
                    v869 = v734;
                    v745 = v735;
                    v746 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)v733 + 8, (unsigned __int16 *)(v733[6] + 4), v873);
                    v747 = v746;
                    v735 = v745;
                    v734 = v869;
                    LogMsgWithLevel(v747, OS_LOG_TYPE_DEFAULT, "SendRecordDeRegistration: No zone info for Resource record %s RecordType %d", v748, v749, v750, v751, v752, (int)v873);
                  }
                }
                else
                {
                  SendRecordRegistration(a1, (uint64_t)v733);
                }
LABEL_1470:
                v787 = v840;
                if ((int)(v840 - (*((_DWORD *)v733 + 70) + *((_DWORD *)v733 + 71))) > 0)
                  v787 = *((_DWORD *)v733 + 70) + *((_DWORD *)v733 + 71);
                v840 = v787;
                goto LABEL_1473;
              }
              *((_WORD *)v733 + 179) = 0;
              CancelGetZoneData(a1, v739);
            }
            v733[47] = (uint64_t)StartGetZoneData((unsigned int *)a1, (_BYTE *)v733[5], (uint64_t)v733);
            SetRecordRetry(a1, (uint64_t)v733, 0);
            goto LABEL_1470;
          }
          if ((v737 & 0x140) == 0)
            goto LABEL_1470;
        }
LABEL_1473:
        v733 = (uint64_t *)*v733;
        if (!v733)
          goto LABEL_1483;
      }
    }
LABEL_1301:
    if (v627[28])
    {
      v637 = *((_QWORD *)v635 + 295);
      GetRRDisplayString_rdb((unsigned __int8 *)v627 + 8, (unsigned __int16 *)(v627[6] + 4), v873);
      LogMsgWithLevel(v637, OS_LOG_TYPE_DEFAULT, "MarkRRForSending: Resourcerecord %s already marked for sending", v638, v639, v640, v641, v642, (int)v873);
    }
    v627[28] = -4;
LABEL_1304:
    v627 = (uint64_t *)*v627;
    if (v627)
      goto LABEL_1402;
    v643 = *v868;
    if (!*v868)
      goto LABEL_1483;
    v644 = 0;
    do
    {
      v645 = *((_DWORD *)v643 + 86);
      v646 = v645 == 5 || v645 == 2;
      if (v646
        && v643[28] != -4
        && AreRecordsMergeable(a1, v628, (uint64_t)v643, *(_DWORD *)(a1 + 64) + *((_DWORD *)v643 + 70) / 2))
      {
        v643[28] = -4;
        ++v644;
      }
      v643 = (uint64_t *)*v643;
    }
    while (v643);
    if (v644 && mDNS_LoggingEnabled)
      LogMsgWithLevel(*((NSObject **)v635 + 295), OS_LOG_TYPE_DEFAULT, "MarkRRForSending: Accelereated %d records", v630, v631, v632, v633, v634, v644);
    v647 = a1 + 28960;
    v648 = *v868;
    if (!*v868)
      goto LABEL_1483;
    v649 = 0;
    v857 = 0;
    v650 = 0;
    v842 = 1;
    v651 = a1 + 28972;
LABEL_1321:
    v850 = 0;
    v652 = 0;
    v864 = 0;
    v859 = 0;
    while (2)
    {
      if (v648[28] != -4)
      {
LABEL_1383:
        v648 = (uint64_t *)*v648;
        if (!v648)
          goto LABEL_1393;
        continue;
      }
      break;
    }
    v648[28] = 0;
    if (v864)
      goto LABEL_1352;
    v653 = GetAuthInfoForName_internal(a1, (_BYTE *)v648[46]);
    v659 = v653;
    if (!v653)
    {
      v661 = 35;
      goto LABEL_1338;
    }
    v660 = (char *)v653 + 268;
    if (v653 == (uint64_t *)-524)
      goto LABEL_1329;
LABEL_1326:
    v661 = 360;
    if (v660 < (_BYTE *)v653 + 524 && v660)
    {
      while (1)
      {
        v662 = *v660;
        if (v662 > 0x3F)
        {
LABEL_1335:
          v661 = 360;
          goto LABEL_1338;
        }
        if (!*v660)
          break;
        v660 += v662 + 1;
        if (v653 != (uint64_t *)-524)
          goto LABEL_1326;
LABEL_1329:
        if (!v660)
          goto LABEL_1335;
      }
      v663 = (unsigned __int16)((_WORD)v660 - ((_WORD)v653 + 268) + 1);
      if (v663 < 0x539)
      {
        v661 = v663 + 103;
        goto LABEL_1338;
      }
      LogMsgWithLevel(*((NSObject **)v635 + 295), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR!!: spaceleft is zero at the beginning", v654, v655, v656, v657, v658, v824);
      v732 = *v868;
      if (!*v868)
        goto LABEL_1483;
      do
      {
        *((_DWORD *)v732 + 149) = 1;
        v732[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v732);
        v732 = (uint64_t *)*v732;
      }
      while (v732);
      goto LABEL_1411;
    }
LABEL_1338:
    v664 = 1440 - v661;
    v649 = mDNS_NewMessageID(a1);
    *(_WORD *)v647 = v649;
    *(_WORD *)(v647 + 2) = 40;
    *(_QWORD *)(v647 + 4) = 0;
    v669 = (unsigned __int8 *)v648[46];
    v670 = v669;
    if (v669 == (unsigned __int8 *)-256)
      goto LABEL_1342;
LABEL_1339:
    v671 = 257;
    if (v670 < v669 + 256 && v670)
    {
      while (1)
      {
        v672 = *v670;
        if (v672 > 0x3F)
        {
LABEL_1347:
          v671 = 257;
          goto LABEL_1349;
        }
        if (!*v670)
          break;
        v670 += v672 + 1;
        if (v669 != (unsigned __int8 *)-256)
          goto LABEL_1339;
LABEL_1342:
        if (!v670)
          goto LABEL_1347;
      }
      v671 = (_WORD)v670 - (_WORD)v669 + 1;
    }
LABEL_1349:
    v859 = v671 + 4;
    v650 = v664 - v859;
    if (v664 <= v859)
    {
      LogMsgWithLevel(*((NSObject **)v635 + 295), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR no space for zone information, disabling merge", (uint64_t)v669, v665, v666, v667, v668, v824);
      v722 = *v868;
      if (!*v868)
        goto LABEL_1483;
      do
      {
        *((_DWORD *)v722 + 149) = 1;
        v722[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v722);
        v722 = (uint64_t *)*v722;
      }
      while (v722);
      goto LABEL_1411;
    }
    v850 = v659;
    v857 = v847 + v664;
    v673 = putZone(v647, v847, v857, v669, bswap32(*((unsigned __int16 *)v648 + 7)) >> 16, v666, v667, v668);
    if (!v673)
    {
      LogMsgWithLevel(*((NSObject **)v635 + 295), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR! Cannot put zone, disabling merge", v674, v631, v632, v633, v634, v824);
      v723 = *v868;
      if (!*v868)
        goto LABEL_1483;
      do
      {
        *((_DWORD *)v723 + 149) = 1;
        v723[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v723);
        v723 = (uint64_t *)*v723;
      }
      while (v723);
LABEL_1411:
      v724 = *v868;
      if (!*v868)
        goto LABEL_1483;
      while (1)
      {
        while (1)
        {
          v725 = (uint64_t)v724;
          v724 = (uint64_t *)*v724;
          if (*(_QWORD *)(v725 + 224) == -4)
            break;
LABEL_1415:
          if (!v724)
            goto LABEL_1398;
        }
        if (*(_DWORD *)(v725 + 280) + *(_DWORD *)(v725 + 284) - *(_DWORD *)(a1 + 64) >= 1)
        {
          v726 = *((_QWORD *)v635 + 295);
          GetRRDisplayString_rdb((unsigned __int8 *)(v725 + 8), (unsigned __int16 *)(*(_QWORD *)(v725 + 48) + 4), v873);
          LogMsgWithLevel(v726, OS_LOG_TYPE_DEFAULT, "CheckGroupRecordUpdates: ERROR!! Resourcerecord %s not ready", v727, v728, v729, v730, v731, (int)v873);
          goto LABEL_1415;
        }
        *(_QWORD *)(v725 + 224) = 0;
        SendRecordRegistration(a1, v725);
        if (!v724)
          goto LABEL_1398;
      }
    }
    v651 = (unint64_t)v673;
    v864 = (uint64_t)v648;
LABEL_1352:
    v675 = *((_DWORD *)v648 + 86);
    if (v675 == 7)
    {
      v676 = *((unsigned __int16 *)v648 + 309) + *((unsigned __int16 *)v648 + 308);
      goto LABEL_1356;
    }
    v676 = *((unsigned __int16 *)v648 + 11);
    if (v675 == 3)
    {
      v677 = 12;
    }
    else
    {
LABEL_1356:
      v678 = *((unsigned __int8 *)v648 + 8);
      if (v678 == 32)
        v679 = 24;
      else
        v679 = 12;
      if (v678 == 16)
        v677 = 24;
      else
        v677 = v679;
    }
    v680 = (_BYTE *)v648[5];
    v681 = v680;
    if (v680 == (_BYTE *)-256)
      goto LABEL_1366;
LABEL_1363:
    v682 = 257;
    if (v681 < v680 + 256 && v681)
    {
      while (1)
      {
        v683 = *v681;
        if (v683 > 0x3F)
        {
LABEL_1371:
          v682 = 257;
          goto LABEL_1373;
        }
        if (!*v681)
          break;
        v681 += v683 + 1;
        if (v680 != (_BYTE *)-256)
          goto LABEL_1363;
LABEL_1366:
        if (!v681)
          goto LABEL_1371;
      }
      v682 = (_WORD)v681 - (_WORD)v680 + 1;
    }
LABEL_1373:
    v684 = v677 - v859 + v676 + v682 + 4;
    if (v650 - v684 < 0)
    {
      v647 = a1 + 28960;
      if (v652)
      {
        if (mDNS_LoggingEnabled)
        {
          v860 = *((_QWORD *)v635 + 295);
          GetRRDisplayString_rdb((unsigned __int8 *)(v864 + 8), (unsigned __int16 *)(*(_QWORD *)(v864 + 48) + 4), v873);
          LogMsgWithLevel(v860, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates:1: Parsed %d records and sending using %s, spaceleft %d, rrSize %d", v699, v700, v701, v702, v703, v652);
        }
        SendGroupRRMessage(a1, v864, v651, v850);
        if (!v648)
          goto LABEL_1393;
      }
      else
      {
        if (mDNS_LoggingEnabled)
        {
          v865 = *((_QWORD *)v635 + 295);
          GetRRDisplayString_rdb((unsigned __int8 *)v648 + 8, (unsigned __int16 *)(v648[6] + 4), v873);
          LogMsgWithLevel(v865, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Skipping message %s, spaceleft %d, rrSize %d", v704, v705, v706, v707, v708, (int)v873);
        }
        v864 = 0;
        v842 = 0;
        v648[28] = -4;
        *((_DWORD *)v648 + 70) = 1000;
        *((_DWORD *)v648 + 71) = *(_DWORD *)(a1 + 64) - 1000;
        v648 = (uint64_t *)*v648;
        if (!v648)
        {
LABEL_1393:
          if (v864)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v709 = *((_QWORD *)v635 + 295);
              GetRRDisplayString_rdb((unsigned __int8 *)(v864 + 8), (unsigned __int16 *)(*(_QWORD *)(v864 + 48) + 4), v873);
              LogMsgWithLevel(v709, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Parsed %d records and sending using %s", v710, v711, v712, v713, v714, v652);
            }
            SendGroupRRMessage(a1, v864, v651, v850);
          }
          if (!v842)
            goto LABEL_1411;
LABEL_1398:
          v627 = *v868;
          if (!*v868)
            goto LABEL_1483;
LABEL_1401:
          v628 = 0;
LABEL_1402:
          v292 = *(_DWORD *)(a1 + 64);
          continue;
        }
      }
      goto LABEL_1321;
    }
    break;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    v853 = *((_QWORD *)v635 + 295);
    GetRRDisplayString_rdb((unsigned __int8 *)v648 + 8, (unsigned __int16 *)(v648[6] + 4), v873);
    LogMsgWithLevel(v853, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Building a message with resource record %s, next %p, state %d, ttl %d", v685, v686, v687, v688, v689, (int)v873);
  }
  v690 = BuildUpdateMessage(a1, v651, (uint64_t)v648, v857, v631, v632, v633, v634);
  if (v690)
  {
    v691 = v690;
    if ((uint64_t)(v690 - v651) <= v684)
    {
      v650 -= v690 - v651;
    }
    else
    {
      v692 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v648 + 8, (unsigned __int16 *)(v648[6] + 4), v873);
      LogMsgWithLevel(v692, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR!! Record size estimation is wrong for %s, Estimate %d, Actual %d, state %d", v693, v694, v695, v696, v697, (int)v873);
      v650 -= v684;
    }
    v698 = v648[48];
    v647 = a1 + 28960;
    if (v698)
    {
      DisposeTCPConn(v698);
      v648[48] = 0;
    }
    ++v652;
    *((_WORD *)v648 + 179) = v649;
    SetRecordRetry(a1, (uint64_t)v648, 0);
    v651 = v691;
    v635 = &unk_100164000;
    goto LABEL_1383;
  }
  v715 = *((_QWORD *)v635 + 295);
  GetRRDisplayString_rdb((unsigned __int8 *)v648 + 8, (unsigned __int16 *)(v648[6] + 4), v873);
  LogMsgWithLevel(v715, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ptr NULL while building message with %s", v716, v717, v718, v719, v720, (int)v873);
  v721 = *v868;
  if (*v868)
  {
    do
    {
      *((_DWORD *)v721 + 149) = 1;
      v721[28] = 0;
      ActivateUnicastRegistration(a1, (uint64_t)v721);
      v721 = (uint64_t *)*v721;
    }
    while (v721);
    goto LABEL_1411;
  }
LABEL_1483:
  if ((int)(*(_DWORD *)(a1 + 12680) - v840) >= 1)
    *(_DWORD *)(a1 + 12680) = v840;
  v808 = *(_QWORD *)(a1 + 208);
  if (v808)
  {
    v809 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v811 = (_BYTE *)(v808 + 376);
        if (v808 == -632)
        {
LABEL_1494:
          while (v811)
          {
            v812 = *v811;
            if (v812 > 0x3F)
              break;
            if (!*v811)
            {
              v816 = (unsigned __int16)((_WORD)v811 - (v808 + 376) + 1);
              goto LABEL_1511;
            }
            v811 += v812 + 1;
            if (v808 != -632)
              goto LABEL_1493;
          }
        }
        else
        {
LABEL_1493:
          if ((unint64_t)v811 < v808 + 632)
            goto LABEL_1494;
        }
        v816 = 257;
LABEL_1511:
        v817 = DNSTypeName(*(unsigned __int16 *)(v808 + 342));
        *(_DWORD *)buf = 141559043;
        *(_QWORD *)&buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v816;
        *(_WORD *)&buf[18] = 2101;
        *(_QWORD *)&buf[20] = v808 + 376;
        *(_WORD *)&buf[28] = 2160;
        *(_QWORD *)&buf[30] = 1752392040;
        *(_WORD *)&buf[38] = 2085;
        *(_QWORD *)&buf[40] = v817;
        _os_log_impl((void *)&_mh_execute_header, v809, OS_LOG_TYPE_DEFAULT, "uDNS_Tasks ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{sensitive, mask.hash}s)", buf, 0x30u);
      }
    }
    else
    {
      v809 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v814 = (_BYTE *)(v808 + 376);
        if (v808 == -632)
        {
LABEL_1502:
          while (v814)
          {
            v815 = *v814;
            if (v815 > 0x3F)
              break;
            if (!*v814)
            {
              v816 = (unsigned __int16)((_WORD)v814 - (v808 + 376) + 1);
              goto LABEL_1511;
            }
            v814 += v815 + 1;
            if (v808 != -632)
              goto LABEL_1501;
          }
        }
        else
        {
LABEL_1501:
          if ((unint64_t)v814 < v808 + 632)
            goto LABEL_1502;
        }
        v816 = 257;
        goto LABEL_1511;
      }
    }
  }
  v818 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 208) = v818;
  if (v818)
  {
    while (v818 != *v843)
    {
      v819 = *(_DWORD *)(v818 + 212);
      if (v819 < 1 || *(_QWORD *)(v818 + 40) || !*(_WORD *)(v818 + 340))
      {
LABEL_1516:
        v820 = *(_QWORD *)(v818 + 8);
        *(_QWORD *)(a1 + 208) = v820;
      }
      else
      {
        v821 = v819 + *(_DWORD *)(v818 + 208);
        v820 = v818;
        if (*(_DWORD *)(a1 + 64) - v821 >= 0)
        {
          Querier_HandleUnicastQuestion(v818);
          v820 = *(_QWORD *)(a1 + 208);
        }
        if (v818 == v820)
        {
          v822 = *(_DWORD *)(v818 + 212) + *(_DWORD *)(v818 + 208);
          if (*(_DWORD *)(a1 + 12680) - v822 >= 1)
            *(_DWORD *)(a1 + 12680) = v822;
          goto LABEL_1516;
        }
      }
      v818 = v820;
      if (!v820)
        break;
      continue;
    }
  }
  *(_QWORD *)(a1 + 208) = 0;
LABEL_1526:
  mDNS_Unlock_(a1, (uint64_t)"mDNS_Execute", 7048);
  return *(unsigned int *)(a1 + 72);
}

void connect_callback(int a1)
{
  int v1;
  int v2;
  NSObject *v3;
  int v4;
  unint64_t v5;
  int v6;
  int *v7;
  char *v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned int v12;
  NSObject *v13;
  int v14;
  int v15;
  socklen_t v16;
  uint64_t v17;
  socklen_t v18;
  uint8_t v19[4];
  int v20;
  __int16 v21;
  int v22;
  uint8_t buf[16];
  __int128 v24;
  __int128 v25;
  _DWORD v26[7];
  sockaddr v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[26];

  v31 = 0u;
  memset(v32, 0, sizeof(v32));
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  v27 = (sockaddr)0;
  v18 = 106;
  v1 = accept(a1, &v27, &v18);
  v17 = 1;
  if ((v1 & 0x80000000) == 0)
  {
    v2 = v1;
    if ((setsockopt(v1, 0xFFFF, 4130, &v17, 8u) & 0x80000000) == 0)
      goto LABEL_12;
    v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_12;
    }
    else
    {
      v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_12;
    }
    v6 = *__error();
    v7 = __error();
    v8 = strerror(*v7);
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&buf[4] = v2;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v6;
    *(_WORD *)&buf[14] = 2082;
    *(_QWORD *)&v24 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%3d: WARNING: setsockopt - SO_NOSIGPIPE %d (%{public}s)", buf, 0x18u);
LABEL_12:
    v9 = fcntl(v2, 3, 0);
    if (fcntl(v2, 4, v9 | 4u))
    {
      my_perror((int)"ERROR: fcntl(sd, F_SETFL, O_NONBLOCK) - aborting client");
      close(v2);
      return;
    }
    v10 = NewRequest();
    v11 = (uint64_t)v10;
    v10[283] = 1;
    *((_DWORD *)v10 + 44) = v2;
    *((_DWORD *)v10 + 46) = v2;
    do
      v12 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
    while (__stlxr(v12 + 1, &dnssd_server_get_new_request_id_s_next_id));
    *((_DWORD *)v10 + 49) = 0;
    *((_DWORD *)v10 + 50) = 0;
    *((_DWORD *)v10 + 48) = v12;
    set_peer_pid((uint64_t)v10);
    v25 = 0u;
    memset(v26, 0, sizeof(v26));
    *(_OWORD *)buf = 0u;
    v24 = 0u;
    v16 = 76;
    if (getsockopt(v2, 0, 1, buf, &v16) < 0 || *(_DWORD *)buf)
      my_perror((int)"ERROR: getsockopt, LOCAL_PEERCRED");
    else
      *(_DWORD *)(v11 + 188) = *(_DWORD *)&buf[4];
    v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_25:
        v14 = *(_DWORD *)(v11 + 176);
        v15 = *(_DWORD *)(v11 + 188);
        *(_DWORD *)v19 = 67109376;
        v20 = v14;
        v21 = 1024;
        v22 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%3d: connect_callback: Adding FD for uid %u", v19, 0xEu);
      }
    }
    else
    {
      v13 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_25;
    }
    udsSupportAddFDToEventLoop(v2, (uint64_t)request_callback, v11);
    return;
  }
  if (*__error() != 35)
  {
    v4 = my_throttled_perror_uds_throttle_count++;
    HIDWORD(v5) = 652835029 * v4 + 17179868;
    LODWORD(v5) = HIDWORD(v5);
    if ((v5 >> 1) <= 0x10624DC)
      my_perror((int)"ERROR: accept");
  }
}

void *NewRequest()
{
  void *result;
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  result = malloc_type_calloc(1uLL, 0x120uLL, 0xF1748037uLL);
  if (result)
  {
    v1 = &all_requests;
    do
    {
      v2 = v1;
      v3 = *v1;
      v1 = (uint64_t *)(*v1 + 16);
    }
    while (v3);
    *v2 = (uint64_t)result;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void request_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned __int8 v9;
  int v10;
  ssize_t v11;
  uint64_t v12;
  uint64_t v13;
  ssize_t v14;
  unsigned int v15;
  int8x16_t v16;
  __int32 v17;
  uid_t v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  ssize_t v22;
  uint64_t v23;
  int v24;
  uint8_t *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  int v29;
  uint32_t v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  socklen_t *v34;
  unsigned __int8 *v35;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v44;
  int v45;
  unint64_t v46;
  NSObject *v47;
  int v48;
  int v49;
  int *v50;
  char *v51;
  uint8_t *v52;
  NSObject *v53;
  const char *v54;
  uint32_t v55;
  int v57;
  int v58;
  int v59;
  int *v60;
  char *v61;
  int v62;
  char v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int *v70;
  char *v71;
  int v72;
  int v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  int v77;
  int v79;
  NSObject *v80;
  int v81;
  int v82;
  uint64_t v83;
  NSObject *v84;
  int updated;
  char *v86;
  __int128 v87;
  unsigned int v88;
  void *v89;
  void *v90;
  NSObject *v91;
  int v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  unint64_t v96;
  int v97;
  NSObject *v98;
  uint64_t v99;
  unint64_t v100;
  void (*v101)(uint64_t);
  uint64_t v102;
  uint64_t SubordinateRequest;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  stat *v111;
  NSObject *v112;
  os_log_type_t v113;
  const char *v114;
  void *v115;
  unsigned int *v116;
  unint64_t v117;
  unsigned int *v118;
  int v119;
  unsigned int *v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  uint64_t v126;
  const char *v127;
  int Domains;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int *v137;
  unsigned int v138;
  unsigned int *v139;
  unint64_t v140;
  unsigned int v141;
  void *v142;
  unsigned int *v143;
  unsigned int v144;
  unsigned int *v145;
  unint64_t v146;
  unsigned int v147;
  void *v148;
  unsigned int v149;
  unsigned int *v150;
  unint64_t v151;
  unsigned int *v152;
  unsigned int v153;
  void *v154;
  unsigned int *v155;
  unint64_t v156;
  unsigned int *v157;
  gid_t v158;
  uid_t v159;
  _BYTE *p_st_size;
  unsigned __int8 *v161;
  int v163;
  unsigned __int16 *v164;
  unint64_t v165;
  unsigned __int16 *v166;
  BOOL v167;
  unsigned __int8 *v168;
  unsigned int v169;
  unsigned __int16 *v170;
  unsigned __int16 *v171;
  uint64_t v172;
  uint64_t IdenticalRecordInCache;
  unsigned __int8 *v174;
  unsigned int v175;
  unint64_t v176;
  uint64_t v177;
  unsigned int v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  char *v182;
  unint64_t v183;
  uint64_t v184;
  unsigned int *v185;
  BOOL v186;
  void *v188;
  unsigned int v189;
  NSObject *v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  unint64_t v194;
  stat *v195;
  unsigned __int8 *v196;
  int v198;
  unint64_t v199;
  stat *v200;
  unsigned __int8 *v201;
  int v203;
  NSObject *v204;
  unsigned int *v206;
  unsigned int v207;
  unsigned int *v208;
  unint64_t v209;
  int v210;
  void *v211;
  unsigned __int8 *v212;
  unint64_t v213;
  int v214;
  int v215;
  unsigned int v216;
  unsigned int v217;
  unsigned __int8 *v218;
  dev_t v219;
  unsigned int v220;
  unsigned int v221;
  unsigned __int8 *v222;
  int v224;
  unsigned __int8 *v225;
  uint64_t v226;
  unsigned __int8 *v227;
  const UInt8 *v228;
  CFIndex v229;
  unsigned int v230;
  unsigned __int16 *signed_data_tlvs;
  uint64_t v232;
  int v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  char v241;
  uint64_t v242;
  sockaddr *nn;
  unsigned int v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unsigned int *v251;
  unint64_t v252;
  unsigned int *v253;
  unsigned int v254;
  unsigned int v255;
  socklen_t *v256;
  unsigned __int8 *v257;
  int v259;
  unint64_t v260;
  unsigned __int8 *v261;
  unsigned __int8 *v262;
  int v264;
  unint64_t v265;
  unsigned __int8 *v266;
  int v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  NSObject *v274;
  int v275;
  uint8_t *i5;
  unsigned int v277;
  uint64_t v278;
  NSObject *v279;
  int v280;
  __darwin_ino64_t v281;
  uint64_t v282;
  int v283;
  int v284;
  uint64_t v285;
  int v286;
  uint64_t v287;
  int v288;
  int v289;
  int v290;
  NSObject *v291;
  int v292;
  int v293;
  unsigned int *v294;
  unsigned int *v295;
  unsigned int v296;
  NSObject *v297;
  int v298;
  int *v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  NSObject *v305;
  int v306;
  int *v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  unsigned __int16 *rr_from_ipc_msg;
  int service_attr_tsr_params;
  int v315;
  int v316;
  uint64_t v317;
  __darwin_time_t v318;
  _BYTE *v319;
  uint64_t v320;
  int v321;
  int v322;
  uid_t v323;
  uint64_t v324;
  uint64_t *v325;
  uint64_t v326;
  void *v327;
  uint64_t v328;
  uint64_t v329;
  unsigned int *v330;
  BOOL v331;
  unsigned __int8 *v333;
  unsigned int *v334;
  unsigned int v335;
  void (*v336)(uint64_t);
  uint64_t v337;
  uint64_t v338;
  int v339;
  uint64_t v340;
  int v341;
  uint64_t v342;
  int v343;
  _BYTE *v344;
  unint64_t v345;
  uint64_t v346;
  unsigned __int16 *v347;
  unsigned __int16 *v348;
  _BYTE *v349;
  _BYTE *v350;
  _BYTE *v351;
  unsigned int *v352;
  unsigned int *v353;
  unsigned int v354;
  dev_t v355;
  char v356;
  unsigned int v357;
  NSObject *v358;
  uint64_t v359;
  int v360;
  uint64_t v361;
  uint64_t v362;
  unint64_t v363;
  sockaddr *v364;
  unsigned __int8 *v365;
  int v367;
  unint64_t v368;
  unsigned __int8 *v369;
  int v371;
  unsigned int v372;
  size_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t k;
  unsigned __int8 *v381;
  int v382;
  unsigned __int8 *v383;
  char v384;
  uint64_t v385;
  uint64_t v386;
  unsigned __int8 *v387;
  uint64_t v388;
  char v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  __darwin_time_t v393;
  _BYTE *v394;
  unsigned __int16 v395;
  uint64_t v396;
  uint64_t v397;
  unsigned __int8 *v398;
  uint64_t v399;
  uint64_t v400;
  int v401;
  unsigned __int8 *v402;
  int v404;
  int v406;
  const void *v407;
  size_t v408;
  uint64_t v409;
  int v410;
  int v411;
  NSObject *v412;
  const char *v413;
  uint64_t v414;
  uint64_t *v415;
  unsigned __int16 v416;
  uint64_t *v417;
  uint64_t *v418;
  uint64_t *v419;
  BOOL v420;
  unint64_t v421;
  sockaddr *v422;
  unsigned __int8 *v423;
  int v425;
  unint64_t v426;
  unsigned __int8 *v427;
  int v429;
  unint64_t v430;
  unsigned __int8 *v431;
  int v433;
  int signed_browse_tlvs;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  unsigned __int8 *v440;
  unint64_t v441;
  stat *v442;
  unsigned __int8 *v443;
  int v445;
  unint64_t v446;
  unsigned __int8 *v447;
  int v449;
  unint64_t v450;
  unsigned __int8 *v451;
  int v453;
  unint64_t v454;
  unsigned __int8 *v455;
  int v457;
  uint64_t v458;
  uint64_t v459;
  unint64_t v460;
  int v461;
  unint64_t v462;
  _BYTE *v463;
  unsigned __int16 *v464;
  size_t v465;
  BOOL v466;
  int v467;
  int v468;
  void (*v469)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int);
  void (**v470)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int);
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  int v474;
  uint64_t v475;
  void *v476;
  void *v477;
  uint64_t v478;
  uint64_t *v479;
  uint64_t v480;
  int v481;
  uint64_t *v482;
  int v483;
  uint64_t v484;
  int v485;
  int v486;
  int v487;
  int v488;
  int v489;
  uint64_t v490;
  int v491;
  uint64_t v492;
  int v493;
  int v494;
  BOOL v495;
  unsigned __int8 *v496;
  uint64_t v497;
  uint64_t *v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  unsigned __int16 *v506;
  unsigned __int16 *v507;
  uint64_t v508;
  uint64_t v509;
  BOOL v510;
  NSObject *v511;
  uint64_t v512;
  _BYTE *v513;
  uint64_t v514;
  unsigned __int8 *v515;
  uint64_t v516;
  __darwin_time_t v517;
  _BYTE *v518;
  unsigned __int16 v519;
  uint64_t v520;
  __uint8_t *v521;
  unsigned __int8 *v522;
  uint64_t v523;
  int v524;
  int v525;
  int v526;
  int v527;
  int v528;
  uint64_t v529;
  int v530;
  BOOL v531;
  unsigned __int8 *v532;
  uint64_t v533;
  int v534;
  int v535;
  int v536;
  int v537;
  int v538;
  int v539;
  int v540;
  uint32_t v541;
  _QWORD *v542;
  uint64_t v543;
  void *v544;
  uint64_t v545;
  NSObject *v546;
  int v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  int v555;
  int v556;
  int v557;
  uint64_t v558;
  unsigned int v559;
  dev_t v560;
  dev_t v561;
  uint64_t v562;
  uint64_t v564;
  uint64_t v565;
  _BYTE *v566;
  unsigned __int16 v567;
  uint64_t v568;
  uint64_t v570;
  _BYTE *v571;
  unsigned __int16 v572;
  uint64_t v573;
  uint64_t v574;
  int v575;
  uint64_t v576;
  uint64_t v577;
  int v578;
  __darwin_time_t v579;
  int v580;
  unsigned __int8 *v581;
  _OWORD *v582;
  int64_t v583;
  unsigned int v584;
  uint64_t v585;
  int v586;
  int v587;
  int v588;
  int v589;
  int v590;
  int v591;
  int v592;
  int v593;
  unsigned __int16 v594;
  unsigned __int16 v595;
  char v596;
  unsigned __int8 *v597;
  const UInt8 *v598;
  CFIndex v599;
  unsigned int v600;
  int v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  NSObject *v607;
  int v608;
  char v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  _BOOL4 v616;
  int v617;
  char v618;
  uint64_t v619;
  NSObject *v620;
  sockaddr *mm;
  unsigned int v622;
  uint64_t v623;
  NSObject *v624;
  char *v625;
  int v626;
  unsigned __int16 v627;
  unsigned __int16 v628;
  uint64_t v629;
  int v630;
  unsigned int v631;
  int v632;
  uint32_t v633;
  uint64_t v634;
  int v635;
  NSObject *v636;
  gid_t v637;
  int v638;
  int v639;
  int v640;
  int v641;
  gid_t v642;
  int v643;
  int v644;
  int v645;
  uint64_t v646;
  __darwin_time_t v647;
  NSObject *v648;
  __darwin_time_t v649;
  gid_t v650;
  uint64_t v651;
  __int128 v652;
  char *v653;
  dev_t v654;
  dev_t v655;
  uint64_t v656;
  _BYTE *v657;
  int v658;
  _BYTE *v659;
  int v660;
  uint64_t v661;
  char v662;
  gid_t v663;
  int v664;
  int v665;
  int v666;
  int v667;
  gid_t v668;
  int v669;
  int v670;
  int v671;
  void *v672;
  int v673;
  gid_t v674;
  int v675;
  uid_t v676;
  void *v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  _BYTE *v684;
  _BYTE *v685;
  uint64_t v686;
  unsigned __int16 v687;
  int v688;
  uint64_t v689;
  int v690;
  NSObject *v691;
  int v692;
  uid_t v693;
  int v694;
  int v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  NSObject *v701;
  NSObject *v702;
  int v703;
  int v704;
  NSObject *v705;
  _QWORD *v706;
  _QWORD *v707;
  uint64_t v708;
  BOOL v709;
  NSObject *v710;
  uint64_t v712;
  int v715;
  uint64_t v716;
  int v718;
  uint8_t *v719;
  NSObject *v720;
  os_log_type_t v721;
  const char *v722;
  uint32_t v723;
  sockaddr *i2;
  unsigned int v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v729;
  NSObject *v730;
  sockaddr *jj;
  unsigned int v732;
  uint64_t v733;
  uint64_t v734;
  void *v735;
  unsigned int v736;
  unint64_t v737;
  unsigned int v739;
  NSObject *v740;
  int v741;
  char *reply;
  int v743;
  uint64_t v744;
  NSObject *v745;
  uint64_t v747;
  uint64_t v748;
  _BYTE *v749;
  uint64_t v750;
  uint64_t v752;
  _BYTE *v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  gid_t v758;
  _BYTE *v760;
  unsigned __int16 v761;
  uint64_t v762;
  _BYTE *v763;
  unsigned __int16 v764;
  uint64_t v765;
  uint64_t v766;
  socklen_t *m;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  int v771;
  const char *v772;
  int v773;
  NSObject *v774;
  const char *v775;
  int v776;
  uint64_t v777;
  int v778;
  unsigned __int8 *v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  BOOL v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  void *v794;
  int v795;
  const char *v796;
  int v797;
  uint8_t *i4;
  uint64_t v799;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  NSObject *v806;
  const char *v807;
  uint32_t v808;
  _BYTE *v809;
  unsigned __int16 *v810;
  sockaddr *kk;
  uint64_t v812;
  sockaddr *ii;
  uint64_t sa_len;
  sockaddr *i1;
  uint64_t v816;
  sockaddr *i3;
  uint64_t v818;
  uint64_t v819;
  NSObject *v820;
  uint64_t v821;
  int v822;
  int v823;
  unsigned int v824;
  int v825;
  char v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  int v834;
  _BYTE *v835;
  uint64_t v836;
  _BYTE *v837;
  uint64_t v838;
  unsigned __int16 v839;
  unsigned __int16 v840;
  socklen_t v841;
  socklen_t v842;
  NSObject *v843;
  const char *v844;
  uint32_t v845;
  BOOL v846;
  int v847;
  BOOL v848;
  size_t v849;
  unsigned __int16 *v850;
  void *v851;
  int v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  __int16 v859;
  uint64_t v860;
  uint8_t v861;
  uint8_t *v862;
  size_t v863;
  _BYTE *v864;
  uint8_t *v865;
  gid_t v866;
  socklen_t v867;
  socklen_t v868;
  NSObject *v869;
  const char *v870;
  uint32_t v871;
  uint64_t v872;
  int v873;
  NSObject *v874;
  const char *v875;
  uint32_t v876;
  int v877;
  unsigned __int8 *v878;
  unsigned __int8 *n;
  uint64_t v880;
  unsigned __int16 v881;
  unsigned int v882;
  int v883;
  _BYTE *v884;
  char v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  int v896;
  const char *v897;
  int v898;
  const char *v899;
  unsigned __int16 v900;
  int v901;
  int v902;
  NSObject *v903;
  const char *v904;
  uint32_t v905;
  int v906;
  int v907;
  socklen_t v908;
  socklen_t v909;
  socklen_t v910;
  int v911;
  int v912;
  int v913;
  socklen_t v914;
  dev_t st_dev;
  socklen_t v916;
  int v917;
  int v918;
  int v919;
  socklen_t v920;
  dev_t v921;
  socklen_t v922;
  int v923;
  int v924;
  int v925;
  uint64_t v926;
  uint64_t v927;
  int v928;
  char v929;
  NSObject *v930;
  NSObject *v931;
  socklen_t v932;
  socklen_t v933;
  void *v934;
  socklen_t v935;
  socklen_t v936;
  __int128 v937;
  __int128 v938;
  __int128 v939;
  char v940;
  unsigned __int16 v941;
  unsigned __int16 v942;
  int v943;
  BOOL v944;
  _BYTE *v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  int v951;
  int v952;
  int v953;
  NSObject *v954;
  uint64_t v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  int v962;
  int v963;
  uint64_t v964;
  uint64_t v965;
  uint64_t v966;
  uint64_t v967;
  uint64_t v968;
  uint64_t v969;
  uint64_t v970;
  uint64_t v971;
  uint64_t v972;
  uint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t v979;
  uint64_t v980;
  int v981;
  uint64_t v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  int ShouldLogFullRequestInfo;
  char v988;
  uint64_t v989;
  _BYTE *v990;
  uint64_t v991;
  socklen_t v992;
  socklen_t st_rdev_low;
  socklen_t v994;
  int v995;
  int v996;
  int v997;
  _UNKNOWN ***v998;
  NSObject *v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  socklen_t v1006;
  int v1007;
  int v1008;
  int v1009;
  int v1010;
  int v1011;
  int v1012;
  int v1013;
  int v1014;
  uint64_t v1015;
  uint64_t uuid;
  int is_signed_result_uuid_valid;
  char v1018;
  NSObject *v1019;
  NSObject *v1020;
  int v1021;
  _BYTE *v1022;
  uint64_t v1023;
  uint64_t v1024;
  unsigned __int16 v1025;
  int v1026;
  void *v1027;
  int v1028;
  void *v1029;
  int v1030;
  _BYTE *v1031;
  uint64_t v1032;
  int v1033;
  int v1034;
  NSObject *v1035;
  const char *v1036;
  uint32_t v1037;
  unsigned __int16 v1038;
  unsigned __int16 v1039;
  uint8_t *i;
  unsigned int v1041;
  uint64_t v1042;
  uint8_t *j;
  unsigned int v1044;
  uint64_t v1045;
  int v1046;
  unsigned int v1047;
  int v1048;
  int v1049;
  int v1050;
  unsigned int v1051;
  int v1052;
  void *v1053;
  uint64_t v1054;
  int v1056;
  const char *v1057;
  uint64_t v1058;
  int v1061;
  NSObject *v1062;
  uint32_t v1063;
  int v1065;
  char v1066;
  int v1067;
  uint64_t v1068;
  int v1069;
  uint64_t v1070;
  int v1071;
  int v1072;
  int v1073;
  int *v1074;
  char *v1075;
  int v1076;
  int v1077;
  void *v1078;
  unint64_t v1079;
  uint64_t v1080;
  uint64_t v1081;
  int v1082;
  int v1083;
  int v1084;
  int v1085;
  dev_t v1086;
  dev_t v1087;
  int v1088;
  int v1089;
  int v1090;
  int v1091;
  int v1092;
  int v1093;
  int v1094;
  __darwin_time_t v1095;
  __darwin_time_t v1096;
  int v1097;
  int v1098;
  int v1099;
  int v1100;
  NSObject *v1101;
  int v1102;
  void (**v1103)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int);
  uint64_t *v1104;
  int v1105;
  int v1106;
  int v1107;
  int v1108;
  int v1109;
  int v1110;
  socklen_t v1111;
  NSObject *v1112;
  uint64_t v1113;
  NSObject *v1114;
  int v1115;
  int v1116;
  int v1117;
  socklen_t v1118;
  uid_t v1119;
  socklen_t v1120;
  socklen_t v1121;
  unint64_t v1122;
  uint64_t v1123;
  int v1124;
  uid_t v1125;
  uint8_t v1126[4];
  int v1127;
  __int16 v1128;
  uint64_t v1129;
  __int16 v1130;
  int v1131;
  __int16 v1132;
  uint64_t v1133;
  __int16 v1134;
  uint64_t v1135;
  __int16 v1136;
  int v1137;
  __int16 v1138;
  uint8_t *v1139;
  __int16 v1140;
  unsigned int v1141;
  __int16 v1142;
  int v1143;
  __int16 v1144;
  int v1145;
  __int16 v1146;
  int v1147;
  __int16 v1148;
  uint64_t v1149;
  __int16 v1150;
  int v1151;
  int v1152[64];
  __int128 v1153;
  __int128 v1154;
  __int128 v1155;
  __int128 v1156;
  __int128 v1157;
  __int128 v1158;
  __int128 v1159;
  __int128 v1160;
  __int128 v1161;
  __int128 v1162;
  __int128 v1163;
  __int128 v1164;
  __int128 v1165;
  __int128 v1166;
  __int128 v1167;
  __int128 v1168;
  socklen_t __src[12];
  _DWORD v1170[8];
  __int128 v1171;
  __int128 v1172;
  __int128 v1173;
  __int128 v1174;
  __int128 v1175;
  __int128 v1176;
  __int128 v1177;
  __int128 v1178;
  __int128 v1179;
  __int128 v1180;
  __int128 v1181;
  _BYTE v1182[753];
  _BYTE v1183[15];
  uint8_t aBlock[96];
  __int128 v1185;
  __int128 v1186;
  __int128 v1187;
  __int128 v1188;
  __int128 v1189;
  __int128 v1190;
  __int128 v1191;
  __int128 v1192;
  __int128 v1193;
  __int128 v1194;
  uint8_t buf[48];
  __int128 v1196;
  __int128 v1197;
  __int128 v1198;
  __int128 v1199;
  __int128 v1200;
  __int128 v1201;
  __int128 v1202;
  __int128 v1203;
  __int128 v1204;
  __int128 v1205;
  __int128 v1206;
  __int128 v1207;
  __int128 v1208;
  stat v1209;
  __int128 v1210;
  __int128 v1211;
  __int128 v1212;
  __int128 v1213;
  __int128 v1214;
  __int128 v1215;
  __int128 v1216;
  _BYTE v1217[753];
  unsigned __int8 v1218[4];
  _BYTE v1219[92];
  _OWORD v1220[10];
  _BYTE v1221[7];
  uint64_t v1222;
  sockaddr v1223[2];
  __int128 v1224;
  __int128 v1225;
  __int128 v1226;
  _BYTE v1227[32];
  __int128 v1228;
  __int128 v1229;
  __int128 v1230;
  __int128 v1231;
  __int128 v1232;
  __int128 v1233;
  __int128 v1234;
  __int128 v1235;
  __int128 v1236;
  _BYTE v1237[753];
  _BYTE v1238[7];

  v8 = a2;
  v9 = *(_BYTE *)(a2 + 283);
  while (2)
  {
    if (v9 != 1)
    {
      if (v9 == 2)
      {
        *(_DWORD *)&v1223[0].sa_len = 0;
        v10 = 4;
        v11 = recv(*(_DWORD *)(v8 + 176), v1223, 4uLL, 0);
        if (!v11)
        {
LABEL_36:
          *(_BYTE *)(v8 + 283) = v10;
          goto LABEL_116;
        }
        if ((v11 & 0x8000000000000000) == 0)
        {
          v12 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
LABEL_32:
              v29 = *(_DWORD *)(v8 + 192);
              v1209.st_dev = 67109120;
              *(_DWORD *)&v1209.st_mode = v29;
              v25 = (uint8_t *)&v1209;
              v26 = v12;
              v27 = OS_LOG_TYPE_ERROR;
              v28 = "[R%u] ERROR: read data from a completed request";
              goto LABEL_33;
            }
          }
          else
          {
            v12 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_32;
          }
LABEL_35:
          v10 = 3;
          goto LABEL_36;
        }
        goto LABEL_28;
      }
      if (v9 - 3 > 1)
      {
        v1058 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        else
        {
          v1058 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        v1065 = *(_DWORD *)(v8 + 192);
        v1209.st_dev = 67109376;
        *(_DWORD *)&v1209.st_mode = v1065;
        LOWORD(v1209.st_ino) = 1024;
        *(_DWORD *)((char *)&v1209.st_ino + 2) = v9;
        v1057 = "[R%u] ERROR: read_msg called with invalid transfer state (%d)";
        v1062 = v1058;
        v1063 = 14;
LABEL_1913:
        _os_log_impl((void *)&_mh_execute_header, v1062, OS_LOG_TYPE_ERROR, v1057, (uint8_t *)&v1209, v1063);
        goto LABEL_1914;
      }
      v1054 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          goto LABEL_1914;
        v1056 = *(_DWORD *)(v8 + 192);
        v1209.st_dev = 67109120;
        *(_DWORD *)&v1209.st_mode = v1056;
        v1057 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }
      else
      {
        v1054 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_1914;
        v1061 = *(_DWORD *)(v8 + 192);
        v1209.st_dev = 67109120;
        *(_DWORD *)&v1209.st_mode = v1061;
        v1057 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }
LABEL_1884:
      v1062 = v1054;
      v1063 = 8;
      goto LABEL_1913;
    }
    v13 = *(unsigned int *)(v8 + 204);
    if (v13 > 0x1B)
    {
LABEL_19:
      if ((_DWORD)v13 != 28)
        goto LABEL_115;
      v20 = *(_QWORD *)(v8 + 64);
      v21 = *(unsigned int *)(v8 + 212);
      if (v21 > v20)
      {
        *(_QWORD *)buf = *(_QWORD *)(v8 + 72) + v20;
        *(_QWORD *)&buf[8] = v21 - v20;
        *(&v1209.st_rdev + 1) = 0;
        memset(__src, 0, 28);
        *(_QWORD *)&v1209.st_dev = 0;
        *(_QWORD *)&v1209.st_uid = buf;
        v1209.st_ino = 0;
        v1209.st_rdev = 1;
        v1209.st_atimespec.tv_sec = (__darwin_time_t)__src;
        v1209.st_atimespec.tv_nsec = 28;
        v22 = recvmsg(*(_DWORD *)(v8 + 176), (msghdr *)&v1209, 0);
        if (!v22)
        {
          v10 = 4;
          goto LABEL_36;
        }
        if (v22 < 0)
          goto LABEL_28;
        v20 = *(_QWORD *)(v8 + 64) + v22;
        *(_QWORD *)(v8 + 64) = v20;
        v21 = *(unsigned int *)(v8 + 212);
        if (v20 > v21)
        {
          v23 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
              goto LABEL_35;
          }
          else
          {
            v23 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_35;
          }
          v24 = *(_DWORD *)(v8 + 192);
          *(_DWORD *)&v1223[0].sa_len = 67109120;
          *(_DWORD *)&v1223[0].sa_data[2] = v24;
          v25 = (uint8_t *)v1223;
          v26 = v23;
          v27 = OS_LOG_TYPE_ERROR;
          v28 = "[R%u] ERROR: read_msg - read too many data bytes";
LABEL_33:
          v30 = 8;
LABEL_34:
          _os_log_impl((void *)&_mh_execute_header, v26, v27, v28, v25, v30);
          goto LABEL_35;
        }
        if ((*(_BYTE *)(v8 + 216) & 4) == 0 && LODWORD(v1209.st_atimespec.tv_nsec) >= 0xC)
        {
          if (v1209.st_atimespec.tv_sec)
          {
            if (*(_DWORD *)(v1209.st_atimespec.tv_sec + 4) == 0xFFFF && *(_DWORD *)(v1209.st_atimespec.tv_sec + 8) == 1)
            {
              v31 = *(_DWORD *)(v1209.st_atimespec.tv_sec + 12);
              *(_DWORD *)(v8 + 184) = v31;
              if (v20 < v21)
              {
                v32 = mDNSLogCategory_Default;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                    goto LABEL_35;
                }
                else
                {
                  v32 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                    goto LABEL_35;
                }
                v65 = *(_DWORD *)(v8 + 192);
                v66 = *(_DWORD *)(v8 + 180);
                *(_DWORD *)&v1223[0].sa_len = 67110402;
                *(_DWORD *)&v1223[0].sa_data[2] = v65;
                *(_WORD *)&v1223[0].sa_data[6] = 1024;
                *(_DWORD *)&v1223[0].sa_data[8] = v66;
                *(_WORD *)&v1223[0].sa_data[12] = 2082;
                *(_QWORD *)&v1223[1].sa_len = v8 + 248;
                *(_WORD *)&v1223[1].sa_data[6] = 1024;
                *(_DWORD *)&v1223[1].sa_data[8] = v31;
                *(_WORD *)&v1223[1].sa_data[12] = 2048;
                *(_QWORD *)&v1224 = v20;
                WORD4(v1224) = 1024;
                *(_DWORD *)((char *)&v1224 + 10) = v21;
                v25 = (uint8_t *)v1223;
                v26 = v32;
                v27 = OS_LOG_TYPE_DEBUG;
                v28 = "[R%u] Client(PID [%d](%{public}s)) sent result code socket %d via SCM_RIGHTS with req->data_bytes "
                      "%lu < req->hdr.datalen %d";
                v30 = 46;
                goto LABEL_34;
              }
            }
          }
        }
        if (*(_DWORD *)(v8 + 204) != 28)
          goto LABEL_115;
      }
      if (v20 != v21)
        goto LABEL_115;
      if ((*(_BYTE *)(v8 + 216) & 4) != 0 || !*(_QWORD *)(v8 + 104) || *(_DWORD *)(v8 + 220) == 63)
      {
LABEL_53:
        *(_BYTE *)(v8 + 283) = 2;
        goto LABEL_117;
      }
      v1226 = 0u;
      memset(v1227, 0, 26);
      v1224 = 0u;
      v1225 = 0u;
      memset(v1223, 0, sizeof(v1223));
      *(_QWORD *)&v1172 = 0;
      v1171 = 0u;
      memset(v1170, 0, sizeof(v1170));
      memset(__src, 0, sizeof(__src));
      if (*(_QWORD *)(v8 + 80))
      {
        v33 = *(_QWORD *)(v8 + 88);
        v34 = __src;
        while (1)
        {
          v35 = *(unsigned __int8 **)(v8 + 80);
          if ((unint64_t)v35 >= v33 || v34 >= (socklen_t *)&v1172 + 2)
            break;
          *(_QWORD *)(v8 + 80) = v35 + 1;
          v37 = *v35;
          *(_BYTE *)v34 = v37;
          v34 = (socklen_t *)((char *)v34 + 1);
          if (!v37)
            goto LABEL_65;
        }
        *((_BYTE *)v34 - (v34 == (socklen_t *)((char *)&v1172 + 8))) = 0;
        *(_QWORD *)(v8 + 80) = 0;
      }
LABEL_65:
      v38 = 0;
      v1226 = 0u;
      memset(v1227, 0, 26);
      v1224 = 0u;
      v1225 = 0u;
      memset(v1223, 0, sizeof(v1223));
      v1223[0].sa_family = 1;
      while (1)
      {
        v39 = *((unsigned __int8 *)__src + v38);
        v1223[0].sa_data[v38] = v39;
        if (!v39)
          break;
        if (++v38 == 103)
        {
          v1227[25] = 0;
          break;
        }
      }
      if (!LOBYTE(__src[0]))
      {
        v41 = *(_DWORD *)(v8 + 184);
        if (v41 == *(_DWORD *)(v8 + 176))
        {
          v42 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
              goto LABEL_114;
          }
          else
          {
            v42 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_114;
          }
          v57 = *(_DWORD *)(v8 + 192);
          v1209.st_dev = 67109120;
          *(_DWORD *)&v1209.st_mode = v57;
          v52 = (uint8_t *)&v1209;
          v53 = v42;
          v54 = "[R%u] read_msg: ERROR failed to get errsd via SCM_RIGHTS";
          v55 = 8;
          goto LABEL_113;
        }
LABEL_81:
        v1077 = fcntl(v41, 3, 0, v1078, v1079, v1080, v1081) | 4;
        if (!fcntl(v41, 4))
          goto LABEL_53;
        v44 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
LABEL_93:
            v48 = *(_DWORD *)(v8 + 192);
            v49 = *__error();
            v50 = __error();
            v51 = strerror(*v50);
            v1209.st_dev = 67109634;
            *(_DWORD *)&v1209.st_mode = v48;
            LOWORD(v1209.st_ino) = 1024;
            *(_DWORD *)((char *)&v1209.st_ino + 2) = v49;
            HIWORD(v1209.st_ino) = 2082;
            *(_QWORD *)&v1209.st_uid = v51;
            v52 = (uint8_t *)&v1209;
            v53 = v44;
            v54 = "[R%u] ERROR: could not set control socket to non-blocking mode errno %d (%{public}s)";
            v55 = 24;
LABEL_113:
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, v54, v52, v55);
          }
        }
        else
        {
          v44 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_93;
        }
LABEL_114:
        *(_BYTE *)(v8 + 283) = 3;
        goto LABEL_115;
      }
      v40 = socket(1, 1, 0);
      *(_DWORD *)(v8 + 184) = v40;
      if (v40 < 0)
      {
        v45 = my_throttled_perror_uds_throttle_count++;
        HIDWORD(v46) = 652835029 * v45 + 17179868;
        LODWORD(v46) = HIDWORD(v46);
        if ((v46 >> 1) <= 0x10624DC)
          my_perror((int)"ERROR: socket");
        goto LABEL_114;
      }
      if ((connect(v40, v1223, 0x6Au) & 0x80000000) == 0)
      {
        v41 = *(_DWORD *)(v8 + 184);
        goto LABEL_81;
      }
      memset(&v1209, 0, sizeof(v1209));
      v47 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          goto LABEL_98;
      }
      else
      {
        v47 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_98;
      }
      v58 = *(_DWORD *)(v8 + 192);
      v59 = *__error();
      v60 = __error();
      v61 = strerror(*v60);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&buf[4] = v58;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v1223[0].sa_data;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v59;
      *(_WORD *)&buf[24] = 2082;
      *(_QWORD *)&buf[26] = v61;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "[R%u] read_msg: Couldn't connect to error return path socket %{public}s errno %d (%{public}s)", buf, 0x22u);
LABEL_98:
      v62 = stat(v1223[0].sa_data, &v1209);
      v63 = gSensitiveLoggingEnabled;
      v64 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State)
        v63 = 0;
      if (v62 < 0)
      {
        if ((v63 & 1) != 0)
        {
          v64 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_114;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
          goto LABEL_114;
        }
        v68 = *(_DWORD *)(v8 + 192);
        v69 = *__error();
        v70 = __error();
        v71 = strerror(*v70);
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v68;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = v1223[0].sa_data;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v69;
        *(_WORD *)&buf[24] = 2082;
        *(_QWORD *)&buf[26] = v71;
        v52 = buf;
        v53 = v64;
        v54 = "[R%u] read_msg: stat failed %{public}s errno %d (%{public}s)";
        v55 = 34;
        goto LABEL_113;
      }
      if ((v63 & 1) != 0)
      {
        v64 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_114;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_114;
      }
      v67 = *(_DWORD *)(v8 + 192);
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v67;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v1223[0].sa_data;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v1209.st_mode;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v1209.st_uid;
      *(_WORD *)&buf[30] = 1024;
      *(_DWORD *)&buf[32] = v1209.st_gid;
      v52 = buf;
      v53 = v64;
      v54 = "[R%u] read_msg: file %{public}s mode %o (octal) uid %d gid %d";
      v55 = 36;
      goto LABEL_113;
    }
    v14 = recv(*(_DWORD *)(v8 + 176), (void *)(v8 + v13 + 208), 28 - v13, 0);
    if (!v14)
    {
      v1066 = 4;
LABEL_1915:
      *(_BYTE *)(v8 + 283) = v1066;
LABEL_1916:
      AbortUnlinkAndFree((_QWORD *)v8);
      return;
    }
    if ((v14 & 0x8000000000000000) == 0)
    {
      v15 = *(_DWORD *)(v8 + 204) + v14;
      *(_DWORD *)(v8 + 204) = v15;
      if (v15 >= 0x1D)
      {
        v1054 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
          v1069 = *(_DWORD *)(v8 + 192);
          v1209.st_dev = 67109120;
          *(_DWORD *)&v1209.st_mode = v1069;
          v1057 = "[R%u] ERROR: read_msg - read too many header bytes";
        }
        else
        {
          v1054 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
          v1067 = *(_DWORD *)(v8 + 192);
          v1209.st_dev = 67109120;
          *(_DWORD *)&v1209.st_mode = v1067;
          v1057 = "[R%u] ERROR: read_msg - read too many header bytes";
        }
        goto LABEL_1884;
      }
      if (v15 != 28)
        goto LABEL_115;
      v16 = vrev32q_s8(*(int8x16_t *)(v8 + 208));
      *(int8x16_t *)(v8 + 208) = v16;
      *(_DWORD *)(v8 + 232) = bswap32(*(_DWORD *)(v8 + 232));
      v17 = v16.i32[0];
      if (v16.i32[0] == 1)
      {
        v18 = v16.u32[1];
        if (v16.i32[1] < 0x11171u)
        {
          v19 = (char *)malloc_type_calloc(1uLL, (v16.i32[1] + 5), 0xF1748037uLL);
          if (!v19)
            goto LABEL_1918;
          *(_QWORD *)(v8 + 72) = v19;
          *(_QWORD *)(v8 + 80) = v19;
          *(_QWORD *)(v8 + 88) = &v19[*(unsigned int *)(v8 + 212)];
          LODWORD(v13) = *(_DWORD *)(v8 + 204);
          goto LABEL_19;
        }
        v1070 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        else
        {
          v1070 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        v1076 = *(_DWORD *)(v8 + 192);
        v1209.st_dev = 67109632;
        *(_DWORD *)&v1209.st_mode = v1076;
        LOWORD(v1209.st_ino) = 1024;
        *(_DWORD *)((char *)&v1209.st_ino + 2) = v18;
        HIWORD(v1209.st_ino) = 1024;
        v1209.st_uid = v18;
        v1057 = "[R%u] ERROR: read_msg: hdr.datalen %u (0x%X) > 70000";
      }
      else
      {
        v1070 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        else
        {
          v1070 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_1914;
        }
        v1071 = *(_DWORD *)(v8 + 192);
        v1209.st_dev = 67109632;
        *(_DWORD *)&v1209.st_mode = v1071;
        LOWORD(v1209.st_ino) = 1024;
        *(_DWORD *)((char *)&v1209.st_ino + 2) = v17;
        HIWORD(v1209.st_ino) = 1024;
        v1209.st_uid = 1;
        v1057 = "[R%u] ERROR: client version 0x%08X daemon version 0x%08X";
      }
      v1062 = v1070;
      v1063 = 20;
      goto LABEL_1913;
    }
LABEL_28:
    if (*__error() != 35 && *__error() != 4)
    {
      v1068 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
LABEL_1907:
          v1072 = *(_DWORD *)(v8 + 192);
          v1073 = *__error();
          v1074 = __error();
          v1075 = strerror(*v1074);
          v1209.st_dev = 67109634;
          *(_DWORD *)&v1209.st_mode = v1072;
          LOWORD(v1209.st_ino) = 1024;
          *(_DWORD *)((char *)&v1209.st_ino + 2) = v1073;
          HIWORD(v1209.st_ino) = 2082;
          *(_QWORD *)&v1209.st_uid = v1075;
          v1057 = "[R%u] ERROR: read_msg errno %d (%{public}s)";
          v1062 = v1068;
          v1063 = 24;
          goto LABEL_1913;
        }
      }
      else
      {
        v1068 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_1907;
      }
LABEL_1914:
      v1066 = 3;
      goto LABEL_1915;
    }
LABEL_115:
    v10 = *(unsigned __int8 *)(v8 + 283);
LABEL_116:
    if (v10 == 2)
    {
LABEL_117:
      v72 = *(_DWORD *)(v8 + 220);
      v73 = 4;
      switch(v72)
      {
        case 1:
          goto LABEL_122;
        case 2:
          v73 = 19;
          goto LABEL_132;
        case 3:
        case 19:
          goto LABEL_132;
        case 4:
          v73 = 8;
          goto LABEL_132;
        case 5:
          v73 = 16;
          goto LABEL_132;
        case 6:
        case 11:
          v73 = 10;
          goto LABEL_132;
        case 7:
        case 18:
          v73 = 11;
          goto LABEL_132;
        case 8:
        case 15:
          v73 = 13;
          goto LABEL_132;
        case 9:
          v73 = 15;
          goto LABEL_132;
        case 10:
          v73 = 12;
          goto LABEL_132;
        case 12:
          v73 = 5;
          goto LABEL_132;
        case 13:
          v73 = 2;
          goto LABEL_132;
        case 14:
          v73 = 20;
          goto LABEL_132;
        case 16:
        case 17:
          goto LABEL_123;
        default:
          if (v72 == 63)
          {
LABEL_122:
            v73 = 0;
          }
          else
          {
LABEL_123:
            v1078 = (void *)*(unsigned int *)(v8 + 180);
            v1079 = v8 + 248;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: ERROR: validate_message - unsupported req type: %d PID[%d][%s]", a4, a5, a6, a7, a8, v72);
            v73 = -1;
          }
LABEL_132:
          v74 = *(_QWORD *)(v8 + 64);
          if (v73 > (int)v74)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: Invalid message %d bytes; min for %d is %d PID[%d][%s]",
              a4,
              a5,
              a6,
              a7,
              a8,
              v74);
            goto LABEL_1916;
          }
          v75 = *(_DWORD *)(v8 + 220);
          if (v75 > 0x3F || ((1 << v75) & 0x8000000000000C0CLL) == 0)
          {
            if (!*(_QWORD *)(v8 + 104))
              goto LABEL_138;
            goto LABEL_136;
          }
          if (*(_QWORD *)(v8 + 104))
          {
LABEL_136:
            if (v75 > 0x3F || ((1 << v75) & 0x8000000000000C0CLL) == 0)
            {
              v86 = (char *)NewRequest();
              v76 = (uint64_t)v86;
              *((_QWORD *)v86 + 3) = v8;
              *((_DWORD *)v86 + 44) = *(_DWORD *)(v8 + 176);
              *((_QWORD *)v86 + 23) = *(_QWORD *)(v8 + 184);
              v87 = *(_OWORD *)(v8 + 208);
              *(_OWORD *)(v86 + 220) = *(_OWORD *)(v8 + 220);
              *((_OWORD *)v86 + 13) = v87;
              *(_OWORD *)(v86 + 72) = *(_OWORD *)(v8 + 72);
              *((_QWORD *)v86 + 11) = *(_QWORD *)(v8 + 88);
              do
                v88 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
              while (__stlxr(v88 + 1, &dnssd_server_get_new_request_id_s_next_id));
              *((_DWORD *)v86 + 49) = 0;
              *((_DWORD *)v86 + 50) = 0;
              *((_DWORD *)v86 + 48) = v88;
              v89 = *(void **)(v8 + 32);
              if (v89)
                os_retain(v89);
              v90 = *(void **)(v76 + 32);
              if (v90)
                os_release(v90);
              *(_QWORD *)(v76 + 32) = *(_QWORD *)(v8 + 32);
              if (*(_BYTE *)(v8 + 280))
              {
                *(_BYTE *)(v76 + 280) = 1;
                *(_OWORD *)(v76 + 264) = *(_OWORD *)(v8 + 264);
              }
              else
              {
                v94 = *(_DWORD *)(v8 + 180);
                if (v94)
                {
                  *(_DWORD *)(v76 + 180) = v94;
                  v95 = 248;
                  v96 = 16;
                  while (1)
                  {
                    v97 = *(unsigned __int8 *)(v8 + v95);
                    *(_BYTE *)(v76 + v95) = v97;
                    if (!v97)
                      break;
                    --v96;
                    ++v95;
                    if (v96 <= 1)
                    {
                      *(_BYTE *)(v76 + v95) = 0;
                      break;
                    }
                  }
                }
                else
                {
                  set_peer_pid(v76);
                }
              }
LABEL_139:
              if ((*(_BYTE *)(v76 + 216) & 1) != 0)
                *(_BYTE *)(v76 + 284) = 1;
              if (dword_100158E14)
              {
                v77 = *(_DWORD *)(v76 + 220);
                if (v77 != 63 && v77 != 13)
                {
                  updated = -65563;
                  goto LABEL_1267;
                }
              }
              if (*(_QWORD *)(v76 + 32))
                goto LABEL_148;
              v81 = *(_DWORD *)(v76 + 176);
              memset(&v1209, 0, 32);
              __src[0] = 32;
              if (getsockopt(v81, 0, 6, &v1209, __src))
              {
                if (*__error())
                {
                  v82 = *__error();
                  if (!v82)
                    goto LABEL_156;
                }
                else
                {
                  v82 = -6700;
                }
                v91 = mDNSLogCategory_Default;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                    goto LABEL_148;
                }
                else
                {
                  v91 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                    goto LABEL_148;
                }
                v92 = *(_DWORD *)(v76 + 192);
                v93 = *(int *)(v76 + 180);
                v1209.st_dev = 67109890;
                *(_DWORD *)&v1209.st_mode = v92;
                LOWORD(v1209.st_ino) = 2048;
                *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = v82;
                HIWORD(v1209.st_uid) = 2048;
                *(_QWORD *)&v1209.st_gid = v93;
                *((_WORD *)&v1209.st_rdev + 2) = 2082;
                *(_QWORD *)((char *)&v1209.st_rdev + 6) = v76 + 248;
                _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "[R%u] Failed to get peer audit token -- error: %ld, client pid: %lld (%{public}s)", (uint8_t *)&v1209, 0x26u);
                goto LABEL_148;
              }
LABEL_156:
              v1223[0] = *(sockaddr *)&v1209.st_dev;
              v1223[1] = *(sockaddr *)&v1209.st_uid;
              v83 = mdns_audit_token_create(v1223);
              *(_QWORD *)(v76 + 32) = v83;
              if (!v83)
              {
                v84 = mDNSLogCategory_Default;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                  {
LABEL_420:
                    v280 = *(_DWORD *)(v76 + 192);
                    v281 = *(int *)(v76 + 180);
                    v1209.st_dev = 67109634;
                    *(_DWORD *)&v1209.st_mode = v280;
                    LOWORD(v1209.st_ino) = 2048;
                    *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = v281;
                    HIWORD(v1209.st_uid) = 2082;
                    *(_QWORD *)&v1209.st_gid = v76 + 248;
                    _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_FAULT, "[R%u] Failed to create peer audit token -- client pid: %lld (%{public}s)", (uint8_t *)&v1209, 0x1Cu);
                  }
                }
                else
                {
                  v84 = mDNSLogCategory_Default_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                    goto LABEL_420;
                }
                updated = -65539;
                goto LABEL_1267;
              }
LABEL_148:
              v79 = *(_DWORD *)(v76 + 220);
              switch(v79)
              {
                case 1:
                  v80 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_431;
                  }
                  else
                  {
                    v80 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_431;
                  }
                  v283 = *(_DWORD *)(v76 + 192);
                  v284 = *(_DWORD *)(v76 + 180);
                  v1209.st_dev = 67109634;
                  *(_DWORD *)&v1209.st_mode = v283;
                  LOWORD(v1209.st_ino) = 1024;
                  *(_DWORD *)((char *)&v1209.st_ino + 2) = v284;
                  HIWORD(v1209.st_ino) = 2082;
                  *(_QWORD *)&v1209.st_uid = v76 + 248;
                  _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateConnection START PID[%d](%{public}s)", (uint8_t *)&v1209, 0x18u);
LABEL_431:
                  updated = 0;
                  *(_QWORD *)(v76 + 104) = connection_termination;
                  goto LABEL_1267;
                case 2:
                  if (*(void (**)(uint64_t))(v76 + 104) != connection_termination)
                  {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRegisterRecord(not a shared connection ref)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                    goto LABEL_1266;
                  }
                  rr_from_ipc_msg = (unsigned __int16 *)read_rr_from_ipc_msg(v76, 1, 1);
                  *(_DWORD *)v1126 = 0;
                  v1125 = 0;
                  service_attr_tsr_params = get_service_attr_tsr_params(v76, (int *)v1126, &v1125);
                  updated = -65540;
                  if (!rr_from_ipc_msg)
                    goto LABEL_1267;
                  v315 = service_attr_tsr_params;
                  if (service_attr_tsr_params)
                  {
                    v316 = *(_DWORD *)v1126;
                    if (*(_DWORD *)v1126 > 0x93A80u)
                    {
                      v317 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                        v318 = *((_QWORD *)rr_from_ipc_msg + 5);
                        if (v318)
                        {
                          v319 = (_BYTE *)*((_QWORD *)rr_from_ipc_msg + 5);
                          if (v318 == -256)
                          {
LABEL_966:
                            while (v319)
                            {
                              v576 = *v319;
                              if (v576 > 0x3F)
                                break;
                              if (!*v319)
                              {
                                LOWORD(v319) = (_WORD)v319 - v318 + 1;
                                goto LABEL_1399;
                              }
                              v319 += v576 + 1;
                              if (v318 != -256)
                                goto LABEL_965;
                            }
                          }
                          else
                          {
LABEL_965:
                            if ((unint64_t)v319 < v318 + 256)
                              goto LABEL_966;
                          }
                          LOWORD(v319) = 257;
LABEL_1399:
                          LODWORD(v319) = (unsigned __int16)v319;
                        }
                        else
                        {
                          LODWORD(v319) = 0;
                        }
                      }
                      else
                      {
                        v317 = mDNSLogCategory_mDNS_redacted;
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                        v318 = *((_QWORD *)rr_from_ipc_msg + 5);
                        if (v318)
                        {
                          v319 = (_BYTE *)*((_QWORD *)rr_from_ipc_msg + 5);
                          if (v318 == -256)
                          {
LABEL_472:
                            while (v319)
                            {
                              v320 = *v319;
                              if (v320 > 0x3F)
                                break;
                              if (!*v319)
                              {
                                LOWORD(v319) = (_WORD)v319 - v318 + 1;
                                goto LABEL_1397;
                              }
                              v319 += v320 + 1;
                              if (v318 != -256)
                                goto LABEL_471;
                            }
                          }
                          else
                          {
LABEL_471:
                            if ((unint64_t)v319 < v318 + 256)
                              goto LABEL_472;
                          }
                          LOWORD(v319) = 257;
LABEL_1397:
                          LODWORD(v319) = (unsigned __int16)v319;
                        }
                        else
                        {
                          LODWORD(v319) = 0;
                        }
                      }
                      v1209.st_dev = 67110147;
                      *(_DWORD *)&v1209.st_mode = v316;
                      v1209.st_ino = 0x87000093A800400;
                      *(_QWORD *)&v1209.st_uid = 1752392040;
                      LOWORD(v1209.st_rdev) = 1040;
                      *(dev_t *)((char *)&v1209.st_rdev + 2) = (int)v319;
                      *((_WORD *)&v1209.st_rdev + 3) = 2101;
                      v1209.st_atimespec.tv_sec = v318;
                      v111 = &v1209;
                      v112 = v317;
                      v113 = OS_LOG_TYPE_ERROR;
                      v114 = "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P";
                      v633 = 40;
                      goto LABEL_1071;
                    }
                    *(_QWORD *)&v1209.st_dev = 0;
                    v1209.st_ino = 0;
                    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)&v1209);
                    v1115 = v1209.st_dev - v316;
                  }
                  else
                  {
                    v1115 = 0;
                  }
                  v498 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_10015BF10, *((_BYTE **)rr_from_ipc_msg + 5), *((_DWORD *)rr_from_ipc_msg + 6));
                  v505 = (uint64_t)v498;
                  v506 = (unsigned __int16 *)*(int *)(v76 + 176);
                  *((_QWORD *)rr_from_ipc_msg + 12) = v506;
                  if (!v315 && !v498)
                    goto LABEL_847;
                  v1104 = v498;
                  if ((_DWORD)v506)
                    v507 = v506;
                  else
                    v507 = rr_from_ipc_msg;
                  v508 = xmmword_10015BF10;
                  if ((_QWORD)xmmword_10015BF10)
                  {
                    while (1)
                    {
                      v509 = *(_QWORD *)(v508 + 96);
                      if (!v509)
                        v509 = v508;
                      v510 = *(_WORD *)(v508 + 12) == 41 || v507 == (unsigned __int16 *)v509;
                      if (!v510
                        && SameResourceRecordNameClassInterface(v508, (uint64_t)rr_from_ipc_msg, v499, v500, v501, v502, v503, v504)&& (!resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v508 + 64), *((_QWORD *)rr_from_ipc_msg + 8))|| *(unsigned __int16 *)(v508 + 12) != rr_from_ipc_msg[6]|| *(unsigned __int16 *)(v508 + 14) != rr_from_ipc_msg[7]|| *(unsigned __int16 *)(v508 + 20) != rr_from_ipc_msg[10]|| *(_DWORD *)(v508 + 28) != *((_DWORD *)rr_from_ipc_msg + 7)|| !SameRDataBody(v508 + 8, (unsigned __int16 *)(*((_QWORD *)rr_from_ipc_msg + 6) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                        && ((rr_from_ipc_msg[4] & 0x32) != 0 || (*(_BYTE *)(v508 + 8) & 0x32) != 0))
                      {
                        break;
                      }
                      v508 = *(_QWORD *)v508;
                      if (!v508)
                        goto LABEL_834;
                    }
                    v607 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_1097:
                        GetRRDisplayString_rdb((unsigned __int8 *)(v508 + 8), (unsigned __int16 *)(*(_QWORD *)(v508 + 48) + 4), word_100164580);
                        v647 = *(_QWORD *)(v508 + 32);
                        v1209.st_dev = 141558787;
                        *(_QWORD *)&v1209.st_mode = 1752392040;
                        WORD2(v1209.st_ino) = 2085;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 6) = (__darwin_ino64_t)word_100164580;
                        HIWORD(v1209.st_gid) = 2048;
                        *(_QWORD *)&v1209.st_rdev = v508;
                        LOWORD(v1209.st_atimespec.tv_sec) = 2048;
                        *(__darwin_time_t *)((char *)&v1209.st_atimespec.tv_sec + 2) = v647;
                        _os_log_impl((void *)&_mh_execute_header, v607, OS_LOG_TYPE_DEFAULT, "Conflict with %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1209, 0x2Au);
                      }
                    }
                    else
                    {
                      v607 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1097;
                    }
                    v648 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_1103:
                        GetRRDisplayString_rdb((unsigned __int8 *)rr_from_ipc_msg + 8, (unsigned __int16 *)(*((_QWORD *)rr_from_ipc_msg + 6) + 4), word_100164580);
                        v649 = *((_QWORD *)rr_from_ipc_msg + 4);
                        v1209.st_dev = 141558787;
                        *(_QWORD *)&v1209.st_mode = 1752392040;
                        WORD2(v1209.st_ino) = 2085;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 6) = (__darwin_ino64_t)word_100164580;
                        HIWORD(v1209.st_gid) = 2048;
                        *(_QWORD *)&v1209.st_rdev = rr_from_ipc_msg;
                        LOWORD(v1209.st_atimespec.tv_sec) = 2048;
                        *(__darwin_time_t *)((char *)&v1209.st_atimespec.tv_sec + 2) = v649;
                        _os_log_impl((void *)&_mh_execute_header, v648, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1209, 0x2Au);
                      }
                    }
                    else
                    {
                      v648 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1103;
                    }
                    free(rr_from_ipc_msg);
                    updated = -65548;
                    goto LABEL_1267;
                  }
LABEL_834:
                  v505 = (uint64_t)v1104;
                  if (v315
                    && conflictWithCacheRecordsOrFlush(*((_DWORD *)rr_from_ipc_msg + 6), *((_BYTE **)rr_from_ipc_msg + 5), *(int *)v1126, v1125))
                  {
                    v511 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        v512 = *((_QWORD *)rr_from_ipc_msg + 5);
                        if (v512)
                        {
                          v513 = (_BYTE *)*((_QWORD *)rr_from_ipc_msg + 5);
                          if (v512 == -256)
                          {
LABEL_1090:
                            while (v513)
                            {
                              v646 = *v513;
                              if (v646 > 0x3F)
                                break;
                              if (!*v513)
                              {
                                LOWORD(v513) = (_WORD)v513 - v512 + 1;
                                goto LABEL_1575;
                              }
                              v513 += v646 + 1;
                              if (v512 != -256)
                                goto LABEL_1089;
                            }
                          }
                          else
                          {
LABEL_1089:
                            if ((unint64_t)v513 < v512 + 256)
                              goto LABEL_1090;
                          }
                          LOWORD(v513) = 257;
LABEL_1575:
                          LODWORD(v513) = (unsigned __int16)v513;
                        }
                        else
                        {
                          LODWORD(v513) = 0;
                        }
                        goto LABEL_1576;
                      }
                    }
                    else
                    {
                      v511 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      {
                        v512 = *((_QWORD *)rr_from_ipc_msg + 5);
                        if (v512)
                        {
                          v513 = (_BYTE *)*((_QWORD *)rr_from_ipc_msg + 5);
                          if (v512 == -256)
                          {
LABEL_842:
                            while (v513)
                            {
                              v514 = *v513;
                              if (v514 > 0x3F)
                                break;
                              if (!*v513)
                              {
                                LOWORD(v513) = (_WORD)v513 - v512 + 1;
                                goto LABEL_1573;
                              }
                              v513 += v514 + 1;
                              if (v512 != -256)
                                goto LABEL_841;
                            }
                          }
                          else
                          {
LABEL_841:
                            if ((unint64_t)v513 < v512 + 256)
                              goto LABEL_842;
                          }
                          LOWORD(v513) = 257;
LABEL_1573:
                          LODWORD(v513) = (unsigned __int16)v513;
                        }
                        else
                        {
                          LODWORD(v513) = 0;
                        }
LABEL_1576:
                        v872 = *((_QWORD *)rr_from_ipc_msg + 4);
                        v1209.st_dev = 141558787;
                        *(_QWORD *)&v1209.st_mode = 1752392040;
                        WORD2(v1209.st_ino) = 1040;
                        *(_DWORD *)((char *)&v1209.st_ino + 6) = (_DWORD)v513;
                        HIWORD(v1209.st_uid) = 2101;
                        *(_QWORD *)&v1209.st_gid = v512;
                        *((_WORD *)&v1209.st_rdev + 2) = 2048;
                        *(_QWORD *)((char *)&v1209.st_rdev + 6) = v872;
                        _os_log_impl((void *)&_mh_execute_header, v511, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdnsresponder:domain_name}.*P InterfaceID %p", (uint8_t *)&v1209, 0x26u);
                      }
                    }
                    free(rr_from_ipc_msg);
                    updated = -65572;
                    goto LABEL_1267;
                  }
LABEL_847:
                  if (!_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy")
                    || !IsLocalDomain(*((_BYTE **)rr_from_ipc_msg + 5)))
                  {
                    goto LABEL_1145;
                  }
                  if (*(_QWORD *)(v76 + 32))
                  {
                    bzero(&v1209, 0x3F1uLL);
                    v1196 = 0u;
                    memset(buf, 0, sizeof(buf));
                    v1235 = 0u;
                    v1236 = 0u;
                    v1233 = 0u;
                    v1234 = 0u;
                    v1231 = 0u;
                    v1232 = 0u;
                    v1229 = 0u;
                    v1230 = 0u;
                    v1228 = 0u;
                    v1226 = 0u;
                    memset(v1227, 0, sizeof(v1227));
                    v1224 = 0u;
                    v1225 = 0u;
                    memset(v1223, 0, sizeof(v1223));
                    v1180 = 0u;
                    v1181 = 0u;
                    v1178 = 0u;
                    v1179 = 0u;
                    v1176 = 0u;
                    v1177 = 0u;
                    v1174 = 0u;
                    v1175 = 0u;
                    v1172 = 0u;
                    v1173 = 0u;
                    v1171 = 0u;
                    memset(v1170, 0, sizeof(v1170));
                    memset(__src, 0, sizeof(__src));
                    if (DeconstructServiceName(*((char **)rr_from_ipc_msg + 5), buf, (uint64_t)v1223, __src))
                    {
                      v515 = (unsigned __int8 *)&v1209;
                      ConvertDomainNameToCString_withescape(&v1223[0].sa_len, (unsigned __int8 *)&v1209);
                    }
                    else
                    {
                      v515 = 0;
                    }
                    v651 = *(_QWORD *)(v76 + 32);
                    v1152[0] = 0;
                    v652 = *(_OWORD *)(v651 + 40);
                    v1153 = *(_OWORD *)(v651 + 24);
                    v1154 = v652;
                    v653 = (char *)&loc_100026120
                         + *((int *)qword_10009EA30
                           + mdns_trust_checks_check(&v1153, 0, 0, v515, 0, 1, v1152));
                    __asm { BR              X9 }
                  }
                  v636 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_1144:
                      v673 = *(_DWORD *)(v76 + 192);
                      v674 = *(_DWORD *)(v76 + 180);
                      v1209.st_dev = 67109634;
                      *(_DWORD *)&v1209.st_mode = v673;
                      LOWORD(v1209.st_ino) = 2080;
                      *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = v76 + 248;
                      HIWORD(v1209.st_uid) = 1024;
                      v1209.st_gid = v674;
                      _os_log_impl((void *)&_mh_execute_header, v636, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_regrecord_request_with_trust: no audit token for pid(%s %d)", (uint8_t *)&v1209, 0x18u);
                    }
                  }
                  else
                  {
                    v636 = mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1144;
                  }
LABEL_1145:
                  v675 = _handle_regrecord_request_start(v76, (uint64_t)rr_from_ipc_msg);
                  updated = v675;
                  if (!v315 || v675)
                    goto LABEL_1267;
                  v676 = v1125;
                  if (v505)
                  {
                    updated = updateTSRRecord(v76, v505, v1115, v1125);
                    if (!updated)
                    {
LABEL_1175:
                      v702 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        updated = 0;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                      }
                      else
                      {
                        v702 = mDNSLogCategory_mDNS_redacted;
                        updated = 0;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                      }
                      v1209.st_dev = 67109632;
                      *(_DWORD *)&v1209.st_mode = v1115;
                      LOWORD(v1209.st_ino) = 1024;
                      *(_DWORD *)((char *)&v1209.st_ino + 2) = *(_DWORD *)v1126;
                      HIWORD(v1209.st_ino) = 1024;
                      v1209.st_uid = v1125;
                      _os_log_impl((void *)&_mh_execute_header, v702, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: TSR record added with timestampContinuous %d tsrTimestamp %d tsrHostkeyHash %x", (uint8_t *)&v1209, 0x14u);
                      goto LABEL_662;
                    }
LABEL_1184:
                    v705 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                      {
LABEL_1189:
                        v1209.st_dev = 67109120;
                        *(_DWORD *)&v1209.st_mode = updated;
                        _os_log_impl((void *)&_mh_execute_header, v705, OS_LOG_TYPE_ERROR, "handle_regrecord_request: Failed to add TSR record with error %d", (uint8_t *)&v1209, 8u);
                      }
                    }
                    else
                    {
                      v705 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                        goto LABEL_1189;
                    }
                    v543 = *((_QWORD *)rr_from_ipc_msg + 14);
                    v706 = (_QWORD *)(v76 + 168);
                    do
                    {
                      v707 = v706;
                      v708 = *v706;
                      v706 = (_QWORD *)(*v706 + 8);
                      if (v708)
                        v709 = v708 == v543;
                      else
                        v709 = 1;
                    }
                    while (!v709);
                    if (!v708)
                    {
                      v712 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                      }
                      else
                      {
                        v712 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                      }
                      v718 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v718;
                      v719 = (uint8_t *)&v1209;
                      v720 = v712;
                      v721 = OS_LOG_TYPE_ERROR;
                      v722 = "[R%u] handle_regrecord_request - record not in list!";
                      goto LABEL_1217;
                    }
                    *v707 = *v706;
                    v710 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                        goto LABEL_1213;
                    }
                    else
                    {
                      v710 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                      {
LABEL_1213:
                        *((_QWORD *)rr_from_ipc_msg + 14) = 0;
                        mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)rr_from_ipc_msg);
                        if (!v543)
                          goto LABEL_1267;
                        goto LABEL_1395;
                      }
                    }
                    v715 = *(_DWORD *)(v76 + 192);
                    GetRRDisplayString_rdb((unsigned __int8 *)rr_from_ipc_msg + 8, (unsigned __int16 *)(*((_QWORD *)rr_from_ipc_msg + 6) + 4), word_100164580);
                    v716 = *((_QWORD *)rr_from_ipc_msg + 4);
                    v1209.st_dev = 67110147;
                    *(_DWORD *)&v1209.st_mode = v715;
                    LOWORD(v1209.st_ino) = 2160;
                    *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                    HIWORD(v1209.st_uid) = 2085;
                    *(_QWORD *)&v1209.st_gid = word_100164580;
                    *((_WORD *)&v1209.st_rdev + 2) = 2048;
                    *(_QWORD *)((char *)&v1209.st_rdev + 6) = rr_from_ipc_msg;
                    HIWORD(v1209.st_atimespec.tv_sec) = 2048;
                    v1209.st_atimespec.tv_nsec = v716;
                    _os_log_impl((void *)&_mh_execute_header, v710, OS_LOG_TYPE_ERROR, "[R%u] handle_regrecord_request: TSR fail, removing %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1209, 0x30u);
                    goto LABEL_1213;
                  }
                  v677 = malloc_type_calloc(1uLL, 0x5A4uLL, 0xF1748037uLL);
                  if (!v677)
                    goto LABEL_1918;
                  v678 = (uint64_t)v677;
                  mDNS_SetupResourceRecord((uint64_t)v677, 0, *((_QWORD *)rr_from_ipc_msg + 4), 41, 0x1194u, 2, 0, 0, 0);
                  v684 = (_BYTE *)*((_QWORD *)rr_from_ipc_msg + 5);
                  v685 = v684;
                  if (v684 == (_BYTE *)-256)
                  {
LABEL_1153:
                    while (v685)
                    {
                      v686 = *v685;
                      if (v686 > 0x3F)
                        break;
                      if (!*v685)
                      {
                        v687 = (_WORD)v685 - (_WORD)v684 + 1;
                        if (v687 > 0x100u)
                          break;
                        memcpy((void *)(v678 + 652), v684, v687);
                        goto LABEL_1161;
                      }
                      v685 += v686 + 1;
                      if (v684 != (_BYTE *)-256)
                        goto LABEL_1152;
                    }
                  }
                  else
                  {
LABEL_1152:
                    if (v685 < v684 + 256)
                      goto LABEL_1153;
                  }
                  *(_BYTE *)(v678 + 652) = 0;
LABEL_1161:
                  *(_WORD *)(v678 + 14) = 1440;
                  v688 = *((_DWORD *)rr_from_ipc_msg + 6);
                  *(_DWORD *)(v678 + 20) = 917518;
                  *(_DWORD *)(v678 + 24) = v688;
                  v689 = *(_QWORD *)(v678 + 48);
                  *(_DWORD *)(v689 + 4) = 720362;
                  *(_DWORD *)(v689 + 8) = v1115;
                  *(_DWORD *)(v689 + 12) = v676;
                  *(_WORD *)(v689 + 16) = 0;
                  *(_QWORD *)(v678 + 104) = regrecord_callback;
                  SetNewRData(v678 + 8, 0, 0, v679, v680, v681, v682, v683);
                  v690 = *(_DWORD *)(v76 + 240);
                  *(_BYTE *)(v678 + 122) = (v690 & 0x400) != 0;
                  v691 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1167;
                  }
                  else
                  {
                    v691 = mDNSLogCategory_mDNS_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1167;
                  }
                  v692 = *(_DWORD *)(v76 + 192);
                  v693 = *(_DWORD *)(v76 + 244);
                  GetRRDisplayString_rdb((unsigned __int8 *)(v678 + 8), (unsigned __int16 *)(*(_QWORD *)(v678 + 48) + 4), word_100164580);
                  v694 = *(_DWORD *)(v76 + 180);
                  v1209.st_dev = 67110659;
                  *(_DWORD *)&v1209.st_mode = v692;
                  LOWORD(v1209.st_ino) = 1024;
                  *(_DWORD *)((char *)&v1209.st_ino + 2) = v690;
                  HIWORD(v1209.st_ino) = 1024;
                  v1209.st_uid = v693;
                  LOWORD(v1209.st_gid) = 2160;
                  *(_QWORD *)((char *)&v1209.st_gid + 2) = 1752392040;
                  *((_WORD *)&v1209.st_rdev + 3) = 2085;
                  v1209.st_atimespec.tv_sec = (__darwin_time_t)word_100164580;
                  LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v694;
                  HIWORD(v1209.st_atimespec.tv_nsec) = 2082;
                  v1209.st_mtimespec.tv_sec = v76 + 248;
                  _os_log_impl((void *)&_mh_execute_header, v691, OS_LOG_TYPE_DEFAULT, "[R%d] regRecordAddTSRRecord(0x%X, %d, %{sensitive, mask.hash}s) START PID[%d](%{public}s)", (uint8_t *)&v1209, 0x38u);
LABEL_1167:
                  v695 = mDNS_Register((unsigned int *)mDNSStorage, v678);
                  if (!v695)
                  {
                    if (mDNS_McastLoggingEnabled)
                      LogMcastService(v678, v76, 1, v696, v697, v698, v699, v700, v1077);
                    *(_QWORD *)(v678 + 96) = *(int *)(v76 + 176);
                    goto LABEL_1175;
                  }
                  updated = v695;
                  v701 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_1182:
                      v703 = *(_DWORD *)(v76 + 192);
                      v704 = *(_DWORD *)(v76 + 240);
                      v1119 = *(_DWORD *)(v76 + 244);
                      GetRRDisplayString_rdb((unsigned __int8 *)(v678 + 8), (unsigned __int16 *)(*(_QWORD *)(v678 + 48) + 4), word_100164580);
                      v1209.st_dev = 67110403;
                      *(_DWORD *)&v1209.st_mode = v703;
                      LOWORD(v1209.st_ino) = 1024;
                      *(_DWORD *)((char *)&v1209.st_ino + 2) = v704;
                      HIWORD(v1209.st_ino) = 1024;
                      v1209.st_uid = v1119;
                      LOWORD(v1209.st_gid) = 2160;
                      *(_QWORD *)((char *)&v1209.st_gid + 2) = 1752392040;
                      *((_WORD *)&v1209.st_rdev + 3) = 2085;
                      v1209.st_atimespec.tv_sec = (__darwin_time_t)word_100164580;
                      LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                      *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = updated;
                      _os_log_impl((void *)&_mh_execute_header, v701, OS_LOG_TYPE_DEFAULT, "[R%d] regRecordAddTSRRecord(0x%X, %d,%{sensitive, mask.hash}s) ERROR (%d)", (uint8_t *)&v1209, 0x2Eu);
                    }
                  }
                  else
                  {
                    v701 = mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1182;
                  }
                  free((void *)v678);
                  goto LABEL_1184;
                case 3:
                  v99 = *(_QWORD *)(v76 + 80);
                  if (v99 && (v100 = v99 + 4, v100 <= *(_QWORD *)(v76 + 88)))
                  {
                    *(_QWORD *)(v76 + 80) = v100;
                    if (v100)
                    {
                      v101 = *(void (**)(uint64_t))(v76 + 104);
                      v102 = v76;
                      if (v101 == connection_termination)
                      {
                        SubordinateRequest = LocateSubordinateRequest(v76);
                        v102 = SubordinateRequest;
                        v101 = *(void (**)(uint64_t))(SubordinateRequest + 104);
                        if (v101 == connection_termination)
                        {
                          v542 = (_QWORD *)(SubordinateRequest + 168);
                          v543 = *(_QWORD *)(SubordinateRequest + 168);
                          v544 = (void *)*(unsigned int *)(SubordinateRequest + 232);
                          if (!v543)
                            goto LABEL_1005;
                          if (*(_DWORD *)(v543 + 16) != (_DWORD)v544)
                          {
                            do
                            {
                              v545 = v543;
                              v543 = *(_QWORD *)(v543 + 8);
                              if (!v543)
                              {
LABEL_1005:
                                v1078 = (void *)*(unsigned int *)(SubordinateRequest + 232);
                                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRemoveRecord(%u) not found", v104, v105, v106, v107, v108, *(_DWORD *)(SubordinateRequest + 176));
                                updated = -65541;
                                goto LABEL_1267;
                              }
                            }
                            while (*(_DWORD *)(v543 + 16) != (_DWORD)v544);
                            v542 = (_QWORD *)(v545 + 8);
                          }
                          *v542 = *(_QWORD *)(v543 + 8);
                          if (mDNS_LoggingEnabled == 1)
                          {
                            v546 = mDNSLogCategory_Default;
                            v547 = *(_DWORD *)(SubordinateRequest + 176);
                            GetRRDisplayString_rdb((unsigned __int8 *)(*(_QWORD *)(v543 + 56) + 8), (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v543 + 56) + 48) + 4), word_100164580);
                            v1080 = *(unsigned int *)(v102 + 180);
                            v1081 = v102 + 248;
                            v1078 = v544;
                            v1079 = (unint64_t)word_100164580;
                            LogMsgWithLevel(v546, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRemoveRecord(%u %s)  PID[%d](%s)", v548, v549, v550, v551, v552, v547);
                          }
                          v553 = *(_QWORD *)(v543 + 56);
                          *(_QWORD *)(v553 + 112) = 0;
                          if (*(_BYTE *)(v543 + 40))
                          {
                            internal_stop_advertising_service(v553 + 8, *(_DWORD *)(v102 + 240), *(_DWORD *)(v102 + 180));
                            *(_BYTE *)(v543 + 40) = 0;
                          }
                          if (mDNS_McastLoggingEnabled)
                            LogMcastService(*(_QWORD *)(v543 + 56), v102, 0, v104, v105, v106, v107, v108, v1077);
                          if (*(_QWORD *)v543)
                          {
                            v554 = *(unsigned int *)(v102 + 244);
                            if ((_DWORD)v554)
                            {
                              if (AWDLInterfaceID && AWDLInterfaceID == v554)
                              {
                                v555 = 1;
                              }
                              else
                              {
                                if (WiFiAwareInterfaceID)
                                  v788 = WiFiAwareInterfaceID == v554;
                                else
                                  v788 = 0;
                                v555 = v788;
                              }
                            }
                            else
                            {
                              v555 = (*(_DWORD *)(v102 + 240) >> 20) & 1;
                            }
                            _mdns_powerlog_bonjour_event(12, v555, (char *)(v102 + 248), *(_QWORD *)v543);
                          }
                          updated = mDNS_Deregister((unsigned int *)mDNSStorage, *(_QWORD *)(v543 + 56));
                          if (updated)
                          {
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: remove_record, mDNS_Deregister: %d", v789, v790, v791, v792, v793, updated);
                            v794 = *(void **)(v543 + 56);
                            if (v794)
                              free(v794);
                          }
LABEL_1395:
                          v672 = (void *)v543;
LABEL_1141:
                          free(v672);
                          goto LABEL_1267;
                        }
                      }
                      if ((char *)v101 != (char *)regservice_termination_callback)
                      {
                        v109 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                        {
                          v109 = mDNSLogCategory_mDNS_redacted;
                          updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1267;
LABEL_200:
                          v110 = *(_DWORD *)(v102 + 192);
                          v1209.st_dev = 67109120;
                          *(_DWORD *)&v1209.st_mode = v110;
                          v111 = &v1209;
                          v112 = v109;
                          v113 = OS_LOG_TYPE_DEFAULT;
                          v114 = "[R%d] DNSServiceRemoveRecord(not a registered service ref)";
                          goto LABEL_1070;
                        }
                        updated = -65540;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_200;
                        goto LABEL_1267;
                      }
                      v414 = *(_QWORD *)(v102 + 120);
                      v415 = *(uint64_t **)(v414 + 1624);
                      v416 = 0;
                      if (v415)
                      {
                        do
                        {
                          v417 = v415 + 39;
                          v418 = v415 + 39;
                          do
                          {
                            v418 = (uint64_t *)*v418;
                            if (!v418)
                              goto LABEL_685;
                          }
                          while (*((_DWORD *)v418 + 2) != *(_DWORD *)(v102 + 232));
                          v416 = *((_WORD *)v418 + 14);
                          if (*((_BYTE *)v415 + 27))
                            internal_stop_advertising_service((uint64_t)(v418 + 3), *(_DWORD *)(v102 + 240), *(_DWORD *)(v102 + 180));
                          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17577);
                          do
                          {
                            v419 = v417;
                            v417 = (uint64_t *)*v417;
                            if (v417)
                              v420 = v417 == v418;
                            else
                              v420 = 1;
                          }
                          while (!v420);
                          if (!v417)
                          {
                            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17593);
LABEL_685:
                            updated = -65541;
                            goto LABEL_686;
                          }
                          v418[15] = (uint64_t)FreeExtraRR;
                          v418[16] = (uint64_t)v418;
                          *v419 = *(_QWORD *)*v419;
                          updated = mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v418 + 2), 0);
                          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17593);
                          if (!updated)
                            goto LABEL_687;
LABEL_686:
                          if (*((_BYTE *)v415 + 26))
                            goto LABEL_929;
LABEL_687:
                          v415 = (uint64_t *)*v415;
                        }
                        while (v415);
                        updated = 0;
                      }
                      else
                      {
                        updated = -65541;
                      }
LABEL_929:
                      v562 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                        v564 = *(_QWORD *)(v414 + 1624);
                        if (v564)
                        {
                          v565 = *(_QWORD *)(v564 + 2736);
                          if (v565)
                          {
                            v566 = *(_BYTE **)(v564 + 2736);
                            if (v565 == -256)
                              goto LABEL_941;
LABEL_938:
                            v567 = 257;
                            if ((unint64_t)v566 < v565 + 256 && v566)
                            {
                              while (1)
                              {
                                v568 = *v566;
                                if (v568 > 0x3F)
                                {
LABEL_1376:
                                  v567 = 257;
                                  goto LABEL_1403;
                                }
                                if (!*v566)
                                  break;
                                v566 += v568 + 1;
                                if (v565 != -256)
                                  goto LABEL_938;
LABEL_941:
                                if (!v566)
                                  goto LABEL_1376;
                              }
                              v567 = (_WORD)v566 - v565 + 1;
                            }
LABEL_1403:
                            v650 = v567;
                          }
                          else
                          {
                            v650 = 0;
                          }
                        }
                        else
                        {
                          v650 = 0;
                          v565 = 0;
                        }
                        v795 = *(_DWORD *)(v102 + 192);
                        if (!v416)
                        {
                          v796 = "<NONE>";
LABEL_1411:
                          v797 = *(_DWORD *)(v102 + 180);
                          v1209.st_dev = 67110915;
                          *(_DWORD *)&v1209.st_mode = v795;
                          LOWORD(v1209.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                          HIWORD(v1209.st_uid) = 1040;
                          v1209.st_gid = v650;
                          LOWORD(v1209.st_rdev) = 2101;
                          *(_QWORD *)((char *)&v1209.st_rdev + 2) = v565;
                          WORD1(v1209.st_atimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1209.st_atimespec.tv_sec + 4) = (__darwin_time_t)v796;
                          WORD2(v1209.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 6) = v797;
                          WORD1(v1209.st_mtimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1209.st_mtimespec.tv_sec + 4) = v102 + 248;
                          WORD2(v1209.st_mtimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_nsec + 6) = updated;
                          v719 = (uint8_t *)&v1209;
                          v720 = v562;
                          v721 = OS_LOG_TYPE_DEFAULT;
                          v722 = "[R%d] DNSServiceRemoveRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{p"
                                 "ublic}s) PID[%d](%{public}s): %d";
                          v723 = 66;
                          goto LABEL_1499;
                        }
                      }
                      else
                      {
                        v562 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                        v570 = *(_QWORD *)(v414 + 1624);
                        if (v570)
                        {
                          v565 = *(_QWORD *)(v570 + 2736);
                          if (v565)
                          {
                            v571 = *(_BYTE **)(v570 + 2736);
                            if (v565 == -256)
                              goto LABEL_953;
LABEL_950:
                            v572 = 257;
                            if ((unint64_t)v571 < v565 + 256 && v571)
                            {
                              while (1)
                              {
                                v573 = *v571;
                                if (v573 > 0x3F)
                                {
LABEL_1377:
                                  v572 = 257;
                                  goto LABEL_1407;
                                }
                                if (!*v571)
                                  break;
                                v571 += v573 + 1;
                                if (v565 != -256)
                                  goto LABEL_950;
LABEL_953:
                                if (!v571)
                                  goto LABEL_1377;
                              }
                              v572 = (_WORD)v571 - v565 + 1;
                            }
LABEL_1407:
                            v650 = v572;
                          }
                          else
                          {
                            v650 = 0;
                          }
                        }
                        else
                        {
                          v650 = 0;
                          v565 = 0;
                        }
                        v795 = *(_DWORD *)(v102 + 192);
                        if (!v416)
                        {
                          v796 = "<NONE>";
                          goto LABEL_1411;
                        }
                      }
                      v796 = DNSTypeName(v416);
                      goto LABEL_1411;
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  v285 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                  {
                    v285 = mDNSLogCategory_mDNS_redacted;
                    updated = -65540;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1267;
LABEL_436:
                    v286 = *(_DWORD *)(v76 + 192);
                    v1209.st_dev = 67109120;
                    *(_DWORD *)&v1209.st_mode = v286;
                    v111 = &v1209;
                    v112 = v285;
                    v113 = OS_LOG_TYPE_DEFAULT;
                    v114 = "[R%d] DNSServiceRemoveRecord(unreadable parameters)";
                    goto LABEL_1070;
                  }
                  updated = -65540;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_436;
                  goto LABEL_1267;
                case 4:
                  v115 = 0;
                  v116 = 0;
                  v118 = *(unsigned int **)(v76 + 80);
                  v117 = *(_QWORD *)(v76 + 88);
                  if (v118 && (unint64_t)(v118 + 1) <= v117)
                  {
                    v115 = (void *)bswap32(*v118);
                    v116 = v118 + 1;
                  }
                  v119 = 0;
                  v120 = 0;
                  *(_QWORD *)(v76 + 80) = v116;
                  if ((v115 & 0x80) != 0)
                    v121 = 4;
                  else
                    v121 = 1;
                  if (v116 && (unint64_t)(v116 + 1) <= v117)
                  {
                    v119 = bswap32(*v116);
                    v120 = v116 + 1;
                  }
                  *(_QWORD *)(v76 + 80) = v120;
                  v122 = mDNSPlatformInterfaceIDfromInterfaceIndex(v119, a2, a3, a4, a5, a6, a7, a8);
                  v123 = v122;
                  if (v119)
                  {
                    updated = -65540;
                    if (!v122)
                      goto LABEL_1267;
                  }
                  if (!*(_QWORD *)(v76 + 80))
                  {
                    v400 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                        goto LABEL_1267;
                    }
                    else
                    {
                      v400 = mDNSLogCategory_Default_redacted;
                      updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                        goto LABEL_1267;
                    }
                    v401 = *(_DWORD *)(v76 + 192);
                    v1209.st_dev = 67109120;
                    *(_DWORD *)&v1209.st_mode = v401;
                    v111 = &v1209;
                    v112 = v400;
                    v113 = OS_LOG_TYPE_ERROR;
                    v114 = "[R%u] DNSServiceEnumerateDomains(unreadable parameters)";
                    goto LABEL_1070;
                  }
                  v124 = *(_QWORD **)(v76 + 112);
                  if (!v124)
                  {
                    v125 = malloc_type_calloc(1uLL, 0x830uLL, 0xF1748037uLL);
                    if (!v125)
                      goto LABEL_1918;
                    v124 = v125;
                    *(_QWORD *)(v76 + 112) = v125;
                  }
                  *(_DWORD *)(v76 + 240) = (_DWORD)v115;
                  *(_DWORD *)(v76 + 244) = v119;
                  *(_DWORD *)v124 = v115 & 0x80;
                  v124[23] = v76;
                  v124[110] = v76;
                  if ((v115 & 0x80) == 0)
                    v124[197] = v76;
                  if (v123)
                    v126 = v123;
                  else
                    v126 = -2;
                  if (mDNS_LoggingEnabled == 1)
                  {
                    v127 = "kDNSServiceFlagsRegistrationDomains";
                    if ((v115 & 0x80) == 0)
                      v127 = "<<Unknown>>";
                    if ((v115 & 0x40) != 0)
                      v127 = "kDNSServiceFlagsBrowseDomains";
                    v1078 = v115;
                    v1079 = (unint64_t)v127;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains(%X=%s)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                  }
                  updated = mDNS_GetDomains((uint64_t)(v124 + 1), ((char)v115 >> 7) & 3, 0, v126, (uint64_t)enum_result_callback, v76);
                  if (updated)
                    goto LABEL_1267;
                  Domains = mDNS_GetDomains((uint64_t)(v124 + 88), v121, 0, v126, (uint64_t)enum_result_callback, v76);
                  if (Domains)
                  {
                    updated = Domains;
                    v136 = (uint64_t)(v124 + 1);
LABEL_230:
                    mDNS_StopQuery((unsigned int *)mDNSStorage, v136);
                    goto LABEL_1267;
                  }
                  if ((v115 & 0x80) != 0)
                  {
                    *(_QWORD *)(v76 + 104) = enum_termination_callback;
                    if (mDNS_LoggingEnabled == 1)
                    {
                      v1078 = (void *)*(unsigned int *)(v76 + 180);
                      v1079 = v76 + 248;
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains Start WAB Registration PID[%d](%s)", v131, v132, v133, v134, v135, *(_DWORD *)(v76 + 176));
                    }
                    v596 = 4;
                  }
                  else
                  {
                    v557 = mDNS_GetDomains((uint64_t)(v124 + 175), 2, 0, v126, (uint64_t)enum_result_callback, v76);
                    if (v557)
                    {
                      updated = v557;
                      mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v124 + 1));
                      v136 = (uint64_t)(v124 + 88);
                      goto LABEL_230;
                    }
                    *(_QWORD *)(v76 + 104) = enum_termination_callback;
                    if (mDNS_LoggingEnabled == 1)
                    {
                      v1078 = (void *)*(unsigned int *)(v76 + 180);
                      v1079 = v76 + 248;
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains Start WAB Browse PID[%d](%s)", v131, v132, v133, v134, v135, *(_DWORD *)(v76 + 176));
                    }
                    v596 = 3;
                  }
                  uDNS_StartWABQueries(v596, v129, v130, v131, v132, v133, v134, v135);
                  goto LABEL_662;
                case 5:
                  v137 = 0;
                  v138 = 0;
                  v139 = *(unsigned int **)(v76 + 80);
                  if (v139)
                  {
                    v140 = *(_QWORD *)(v76 + 88);
                    v141 = 0;
                    if ((unint64_t)(v139 + 1) <= v140)
                    {
                      v141 = 0;
                      v137 = 0;
                      v138 = bswap32(*v139);
                      *(_QWORD *)(v76 + 80) = v139 + 1;
                      if (v139 != (unsigned int *)-4 && (unint64_t)(v139 + 2) <= v140)
                      {
                        v141 = bswap32(v139[1]);
                        v137 = v139 + 2;
                      }
                    }
                  }
                  else
                  {
                    v141 = 0;
                  }
                  *(_QWORD *)(v76 + 80) = v137;
                  if (*(_QWORD *)(v76 + 120))
                    goto LABEL_498;
                  v327 = malloc_type_calloc(1uLL, 0x660uLL, 0xF1748037uLL);
                  if (!v327)
                    goto LABEL_1918;
                  *(_QWORD *)(v76 + 120) = v327;
LABEL_498:
                  if (v141 == -3)
                  {
                    if (mDNS_LoggingEnabled == 1)
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P", a4, a5, a6, a7, a8, v1077);
                    v141 = 0;
                    v138 |= 0x20000u;
                  }
                  v328 = mDNSPlatformInterfaceIDfromInterfaceIndex(v141, a2, a3, a4, a5, a6, a7, a8);
                  v329 = v328;
                  if (!v141 || v328)
                    goto LABEL_718;
                  if (v141 == 0 || v141 >= 0xFFFFFFFC)
                  {
                    updated = -65540;
                    if (mDNS_LoggingEnabled != 1)
                      goto LABEL_1267;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: bad interfaceIndex %d", a4, a5, a6, a7, a8, v141);
                    goto LABEL_1266;
                  }
                  v329 = v141;
                  if (mDNS_LoggingEnabled == 1)
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: registration pending for interface index %d", a4, a5, a6, a7, a8, v141);
LABEL_718:
                  v1207 = 0u;
                  v1208 = 0u;
                  v1205 = 0u;
                  v1206 = 0u;
                  v1203 = 0u;
                  v1204 = 0u;
                  v1201 = 0u;
                  v1202 = 0u;
                  v1199 = 0u;
                  v1200 = 0u;
                  v1197 = 0u;
                  v1198 = 0u;
                  v1196 = 0u;
                  memset(buf, 0, sizeof(buf));
                  bzero(&v1209, 0x3F1uLL);
                  bzero(v1223, 0x3F1uLL);
                  bzero(__src, 0x3F1uLL);
                  v1193 = 0u;
                  v1194 = 0u;
                  v1191 = 0u;
                  v1192 = 0u;
                  v1189 = 0u;
                  v1190 = 0u;
                  v1187 = 0u;
                  v1188 = 0u;
                  v1185 = 0u;
                  v1186 = 0u;
                  memset(aBlock, 0, sizeof(aBlock));
                  v1167 = 0u;
                  v1168 = 0u;
                  v1165 = 0u;
                  v1166 = 0u;
                  v1163 = 0u;
                  v1164 = 0u;
                  v1161 = 0u;
                  v1162 = 0u;
                  v1159 = 0u;
                  v1160 = 0u;
                  v1153 = 0u;
                  v1154 = 0u;
                  v1155 = 0u;
                  v1156 = 0u;
                  v1157 = 0u;
                  v1158 = 0u;
                  if (!*(_QWORD *)(v76 + 80))
                    goto LABEL_1264;
                  v441 = *(_QWORD *)(v76 + 88);
                  v442 = (stat *)buf;
                  while (1)
                  {
                    v443 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v443 >= v441 || v442 >= &v1209)
                      break;
                    *(_QWORD *)(v76 + 80) = v443 + 1;
                    v445 = *v443;
                    LOBYTE(v442->st_dev) = v445;
                    v442 = (stat *)((char *)v442 + 1);
                    if (!v445)
                    {
                      if (*(_QWORD *)(v76 + 80))
                      {
                        v446 = *(_QWORD *)(v76 + 88);
                        v442 = (stat *)__src;
                        do
                        {
                          v447 = *(unsigned __int8 **)(v76 + 80);
                          if ((unint64_t)v447 >= v446 || v442 >= (stat *)v1183)
                          {
                            v522 = v1183;
                            goto LABEL_1259;
                          }
                          *(_QWORD *)(v76 + 80) = v447 + 1;
                          v449 = *v447;
                          LOBYTE(v442->st_dev) = v449;
                          v442 = (stat *)((char *)v442 + 1);
                        }
                        while (v449);
                        if (*(_QWORD *)(v76 + 80))
                        {
                          v450 = *(_QWORD *)(v76 + 88);
                          v442 = &v1209;
                          do
                          {
                            v451 = *(unsigned __int8 **)(v76 + 80);
                            if ((unint64_t)v451 >= v450 || v442 >= (stat *)v1218)
                            {
                              v522 = v1218;
                              goto LABEL_1259;
                            }
                            *(_QWORD *)(v76 + 80) = v451 + 1;
                            v453 = *v451;
                            LOBYTE(v442->st_dev) = v453;
                            v442 = (stat *)((char *)v442 + 1);
                          }
                          while (v453);
                          if (*(_QWORD *)(v76 + 80))
                          {
                            v454 = *(_QWORD *)(v76 + 88);
                            v442 = (stat *)v1223;
                            while (1)
                            {
                              v455 = *(unsigned __int8 **)(v76 + 80);
                              if ((unint64_t)v455 >= v454 || v442 >= (stat *)v1238)
                                break;
                              *(_QWORD *)(v76 + 80) = v455 + 1;
                              v457 = *v455;
                              LOBYTE(v442->st_dev) = v457;
                              v442 = (stat *)((char *)v442 + 1);
                              if (!v457)
                              {
                                v458 = 0;
                                *(_DWORD *)(v76 + 240) = v138;
                                *(_DWORD *)(v76 + 244) = v141;
                                v459 = *(_QWORD *)(v76 + 120);
                                *(_QWORD *)v459 = v329;
                                *(_QWORD *)(v459 + 1624) = 0;
                                *(_WORD *)(v459 + 8) = 0;
                                *(_QWORD *)(v459 + 16) = 0;
                                v460 = v459 + 90;
                                while (1)
                                {
                                  v461 = *((unsigned __int8 *)__src + v458);
                                  *(_BYTE *)(v460 + v458) = v461;
                                  if (!v461)
                                    break;
                                  if (++v458 == 1008)
                                  {
                                    *(_BYTE *)(v459 + 1098) = 0;
                                    break;
                                  }
                                }
                                v463 = *(_BYTE **)(v76 + 80);
                                v462 = *(_QWORD *)(v76 + 88);
                                if ((unint64_t)(v463 + 2) <= v462)
                                {
                                  v464 = 0;
                                  *(_QWORD *)(v76 + 80) = v463 + 1;
                                  *(_BYTE *)(v459 + 24) = *v463;
                                  v809 = *(_BYTE **)(v76 + 80);
                                  *(_QWORD *)(v76 + 80) = v809 + 1;
                                  *(_BYTE *)(v459 + 25) = *v809;
                                  v810 = *(unsigned __int16 **)(v76 + 80);
                                  v462 = *(_QWORD *)(v76 + 88);
                                  if (v810 && (unint64_t)(v810 + 1) <= v462)
                                  {
                                    v465 = __rev16(*v810);
                                    v464 = v810 + 1;
                                  }
                                  else
                                  {
                                    v465 = 0;
                                  }
                                }
                                else
                                {
                                  v464 = 0;
                                  v465 = 0;
                                  *(_QWORD *)(v76 + 80) = 0;
                                }
                                *(_WORD *)(v459 + 8) = v465;
                                if (v464)
                                  v846 = (unint64_t)v464 + v465 > v462;
                                else
                                  v846 = 1;
                                v847 = v846;
                                v848 = v847 == 0;
                                if (v847)
                                  v849 = 0;
                                else
                                  v849 = (size_t)v464 + v465;
                                if (v848)
                                  v850 = v464;
                                else
                                  v850 = 0;
                                *(_QWORD *)(v76 + 80) = v849;
                                if (!v849)
                                {
                                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRegister(unreadable parameters)", v246, v247, v248, v249, v250, *(_DWORD *)(v76 + 176));
                                  goto LABEL_1266;
                                }
                                if (!v465)
                                  goto LABEL_1556;
                                v851 = malloc_type_malloc(v465, 0xA172743EuLL);
                                if (v851)
                                {
                                  *(_QWORD *)(v459 + 16) = v851;
                                  memcpy(v851, v850, *(unsigned __int16 *)(v459 + 8));
LABEL_1556:
                                  v852 = ChopSubTypes((unsigned __int8 *)(v459 + 90));
                                  if (v852 < 0)
                                  {
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - ChopSubTypes failed %s", v854, v855, v856, v857, v858, v459 + 90);
                                    goto LABEL_1809;
                                  }
                                  *(_DWORD *)(v459 + 1616) = v852;
                                  if (!*(_BYTE *)(v459 + 90)
                                    || (v859 = v459 + 1099,
                                        *(_BYTE *)(v459 + 1099) = 0,
                                        !AppendDNSNameString((_BYTE *)(v459 + 1099), (unsigned __int8 *)(v459 + 90), v853, v854, v855, v856, v857, v858)))
                                  {
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - type_as_string bad %s", v854, v855, v856, v857, v858, v459 + 90);
                                    goto LABEL_1809;
                                  }
                                  v861 = buf[0];
                                  if (buf[0])
                                  {
                                    if ((v138 & 8) != 0)
                                    {
                                      v864 = (_BYTE *)(v459 + 26);
                                      v865 = (uint8_t *)(v459 + 27);
                                    }
                                    else
                                    {
                                      v862 = buf;
                                      v863 = strlen((const char *)buf);
                                      buf[TruncateUTF8ToLength((uint64_t)buf, v863, 0x3Fu)] = 0;
                                      v861 = buf[0];
                                      v864 = (_BYTE *)(v459 + 26);
                                      v865 = (uint8_t *)(v459 + 27);
                                      if (!buf[0])
                                        goto LABEL_1694;
                                    }
                                    v862 = buf;
                                    do
                                    {
                                      *v865++ = v861;
                                      v943 = *++v862;
                                      v861 = v943;
                                      if (v943)
                                        v944 = (unint64_t)v865 >= v460;
                                      else
                                        v944 = 1;
                                    }
                                    while (!v944);
LABEL_1694:
                                    *v864 = (_BYTE)v865 + ~(_BYTE)v864;
                                    v940 = *v862;
                                    if (*v862)
                                    {
                                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - name bad %s", v854, v855, v856, v857, v858, (int)buf);
                                      goto LABEL_1809;
                                    }
                                  }
                                  else
                                  {
                                    v937 = xmmword_10015B5F0;
                                    v938 = unk_10015B600;
                                    v939 = xmmword_10015B610;
                                    *(_OWORD *)(v459 + 74) = unk_10015B620;
                                    *(_OWORD *)(v459 + 58) = v939;
                                    *(_OWORD *)(v459 + 42) = v938;
                                    *(_OWORD *)(v459 + 26) = v937;
                                    v940 = 1;
                                  }
                                  *(_BYTE *)(v459 + 1612) = v940;
                                  v945 = (_BYTE *)(v459 + 1355);
                                  if (LOBYTE(v1209.st_dev))
                                  {
                                    *v945 = 0;
                                    aBlock[0] = 0;
                                    if (!AppendDNSNameString(aBlock, (unsigned __int8 *)&v1209, v860, v854, v855, v856, v857, v858))
                                    {
                                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - domain bad %s", v946, v947, v948, v949, v950, (int)&v1209);
                                      goto LABEL_1809;
                                    }
                                  }
                                  else
                                  {
                                    *v945 = 1;
                                    aBlock[0] = 0;
                                    AppendDNSNameString(aBlock, "local.", v860, v854, v855, v856, v857, v858);
                                  }
                                  if (ConstructServiceName(&v1153, (const char *)(v459 + 26), (unsigned __int8 *)(v459 + 1099), aBlock))
                                  {
                                    *(_BYTE *)(v459 + 1356) = 0;
                                    if (AppendDNSNameString((_BYTE *)(v459 + 1356), &v1223[0].sa_len, v970, v971, v972, v973, v974, v975))
                                    {
                                      *(_BYTE *)(v459 + 1613) = (v138 & 8) == 0;
                                      *(_BYTE *)(v459 + 1614) = (v138 & 0x200) != 0;
                                      if (*(_WORD *)(v459 + 24))
                                      {
                                        v981 = CountExistingRegistrations(&v1153, *(_WORD *)(v459 + 24));
                                        if (v981)
                                        {
                                          v1079 = (v981 + 1);
                                          v1080 = (uint64_t)&v1153;
                                          v1078 = (void *)(v76 + 248);
                                          v1081 = bswap32(*(unsigned __int16 *)(v459 + 24)) >> 16;
                                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Client application[%d](%s) registered %d identical instances of service %##s port %u.", v982, v983, v984, v985, v986, *(_DWORD *)(v76 + 180));
                                        }
                                      }
                                      memset(v1152, 0, sizeof(v1152));
                                      ConstructServiceName(v1152, (const char *)(v459 + 26), (unsigned __int8 *)(v459 + 1099), aBlock);
                                      ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(v76);
                                      v988 = gSensitiveLoggingEnabled;
                                      v989 = mDNSLogCategory_mDNS;
                                      if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                                        v988 = 0;
                                      if (ShouldLogFullRequestInfo)
                                      {
                                        if ((v988 & 1) != 0)
                                        {
                                          v1123 = mDNSLogCategory_mDNS_redacted;
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                          {
                                            v1108 = *(_DWORD *)(v76 + 192);
                                            v990 = (_BYTE *)(v459 + 1099);
                                            if (v459 == -1355)
                                            {
LABEL_1731:
                                              while (v990)
                                              {
                                                v991 = *v990;
                                                if (v991 > 0x3F)
                                                  break;
                                                if (!*v990)
                                                {
                                                  v1038 = (_WORD)v990 - v859 + 1;
                                                  goto LABEL_1833;
                                                }
                                                v990 += v991 + 1;
                                                if (v459 != -1355)
                                                  goto LABEL_1730;
                                              }
                                            }
                                            else
                                            {
LABEL_1730:
                                              if (v990 < v945)
                                                goto LABEL_1731;
                                            }
                                            v1038 = 257;
LABEL_1833:
                                            v1099 = v1038;
                                            for (i = aBlock; ; i += v1042 + 1)
                                            {
                                              LOWORD(v1041) = 257;
                                              if (i >= buf || !i)
                                                break;
                                              v1042 = *i;
                                              if (v1042 > 0x3F)
                                              {
                                                LOWORD(v1041) = 257;
                                                break;
                                              }
                                              if (!*i)
                                              {
                                                v1041 = (_DWORD)i - aBlock + 1;
                                                break;
                                              }
                                            }
                                            v1046 = (unsigned __int16)v1041;
                                            v1047 = bswap32(*(unsigned __int16 *)(v459 + 24)) >> 16;
                                            v1048 = *(_DWORD *)(v76 + 240);
                                            v1082 = *(_DWORD *)(v76 + 244);
                                            v1084 = *(_DWORD *)(v76 + 180);
                                            v1049 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1152);
                                            *(_DWORD *)v1126 = 67112195;
                                            v1127 = v1108;
                                            v1128 = 2160;
                                            v1129 = 1752392040;
                                            v1130 = 1040;
                                            v1131 = v1099;
                                            v1132 = 2101;
                                            v1133 = v459 + 1099;
                                            v1134 = 2160;
                                            v1135 = 1752392040;
                                            v1136 = 1040;
                                            v1137 = v1046;
                                            v1138 = 2101;
                                            v1139 = aBlock;
                                            v1140 = 1024;
                                            v1141 = v1047;
                                            v1142 = 1024;
                                            v1143 = v1048;
                                            v1144 = 1024;
                                            v1145 = v1082;
                                            v1146 = 1024;
                                            v1147 = v1084;
                                            v1148 = 2082;
                                            v1149 = v76 + 248;
                                            v1150 = 1024;
                                            v1151 = v1049;
                                            v1035 = v1123;
                                            v1036 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask.ha"
                                                    "sh, mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, m"
                                                    "dnsresponder:domain_name}.*P, port: %u, flags: 0x%X, interface index"
                                                    ": %d, client pid: %d (%{public}s), name hash: %x";
                                            goto LABEL_1852;
                                          }
LABEL_1854:
                                          *(_QWORD *)(v76 + 104) = 0;
                                          if (_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy")&& (*v945 || IsLocalDomain(aBlock)))
                                          {
                                            updated = _handle_regservice_request_with_trust(v76, aBlock);
                                            if (updated == -65555)
                                            {
                                              v1053 = *(void **)(v459 + 16);
                                              if (v1053)
                                              {
                                                free(v1053);
                                                *(_QWORD *)(v459 + 16) = 0;
                                              }
                                              updated = -65555;
                                            }
                                            goto LABEL_1267;
                                          }
                                          v778 = _handle_regservice_request_start(v76, aBlock);
LABEL_1757:
                                          updated = v778;
                                          goto LABEL_1267;
                                        }
                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                          goto LABEL_1854;
                                        v1124 = *(_DWORD *)(v76 + 192);
                                        v1031 = (_BYTE *)(v459 + 1099);
                                        if (v459 == -1355)
                                        {
LABEL_1823:
                                          while (v1031)
                                          {
                                            v1032 = *v1031;
                                            if (v1032 > 0x3F)
                                              break;
                                            if (!*v1031)
                                            {
                                              v1039 = (_WORD)v1031 - v859 + 1;
                                              goto LABEL_1841;
                                            }
                                            v1031 += v1032 + 1;
                                            if (v459 != -1355)
                                              goto LABEL_1822;
                                          }
                                        }
                                        else
                                        {
LABEL_1822:
                                          if (v1031 < v945)
                                            goto LABEL_1823;
                                        }
                                        v1039 = 257;
LABEL_1841:
                                        v1109 = v1039;
                                        for (j = aBlock; ; j += v1045 + 1)
                                        {
                                          LOWORD(v1044) = 257;
                                          if (j >= buf || !j)
                                            break;
                                          v1045 = *j;
                                          if (v1045 > 0x3F)
                                          {
                                            LOWORD(v1044) = 257;
                                            break;
                                          }
                                          if (!*j)
                                          {
                                            v1044 = (_DWORD)j - aBlock + 1;
                                            break;
                                          }
                                        }
                                        v1050 = (unsigned __int16)v1044;
                                        v1051 = bswap32(*(unsigned __int16 *)(v459 + 24)) >> 16;
                                        v1083 = *(_DWORD *)(v76 + 240);
                                        v1085 = *(_DWORD *)(v76 + 244);
                                        v1094 = *(_DWORD *)(v76 + 180);
                                        v1052 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1152);
                                        *(_DWORD *)v1126 = 67112195;
                                        v1127 = v1124;
                                        v1128 = 2160;
                                        v1129 = 1752392040;
                                        v1130 = 1040;
                                        v1131 = v1109;
                                        v1132 = 2101;
                                        v1133 = v459 + 1099;
                                        v1134 = 2160;
                                        v1135 = 1752392040;
                                        v1136 = 1040;
                                        v1137 = v1050;
                                        v1138 = 2101;
                                        v1139 = aBlock;
                                        v1140 = 1024;
                                        v1141 = v1051;
                                        v1142 = 1024;
                                        v1143 = v1083;
                                        v1144 = 1024;
                                        v1145 = v1085;
                                        v1146 = 1024;
                                        v1147 = v1094;
                                        v1148 = 2082;
                                        v1149 = v76 + 248;
                                        v1150 = 1024;
                                        v1151 = v1052;
                                        v1035 = v989;
                                        v1036 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask.hash, "
                                                "mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsrespo"
                                                "nder:domain_name}.*P, port: %u, flags: 0x%X, interface index: %d, client"
                                                " pid: %d (%{public}s), name hash: %x";
LABEL_1852:
                                        v1037 = 100;
                                      }
                                      else
                                      {
                                        if ((v988 & 1) != 0)
                                        {
                                          v989 = mDNSLogCategory_mDNS_redacted;
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1854;
                                        }
                                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                        {
                                          goto LABEL_1854;
                                        }
                                        v1033 = *(_DWORD *)(v76 + 192);
                                        v1034 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1152);
                                        *(_DWORD *)v1126 = 67109376;
                                        v1127 = v1033;
                                        v1128 = 1024;
                                        LODWORD(v1129) = v1034;
                                        v1035 = v989;
                                        v1036 = "[R%u] DNSServiceRegister START -- name hash: %x";
                                        v1037 = 14;
                                      }
                                      _os_log_impl((void *)&_mh_execute_header, v1035, OS_LOG_TYPE_DEFAULT, v1036, v1126, v1037);
                                      goto LABEL_1854;
                                    }
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - host bad %s", v976, v977, v978, v979, v980, (int)v1223);
                                  }
                                  else
                                  {
                                    v1078 = (void *)(v459 + 1099);
                                    v1079 = (unint64_t)aBlock;
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - Couldn't ConstructServiceName from, %#s %##s %##s", v971, v972, v973, v974, v975, v459 + 26);
                                  }
LABEL_1809:
                                  v1029 = *(void **)(v459 + 16);
                                  if (v1029)
                                    free(v1029);
                                  *(_QWORD *)(v459 + 16) = 0;
LABEL_1266:
                                  updated = -65540;
                                  goto LABEL_1267;
                                }
LABEL_1918:
                                __break(1u);
                              }
                            }
                            v522 = v1238;
LABEL_1259:
                            v466 = v442 == (stat *)v522;
LABEL_1260:
                            v734 = v466;
                            *((_BYTE *)&v442->st_dev - v734) = 0;
                            *(_QWORD *)(v76 + 80) = 0;
                          }
                          else
                          {
                            v1223[0].sa_len = 0;
                          }
                        }
                        else
                        {
                          LOBYTE(v1209.st_dev) = 0;
                        }
                      }
                      else
                      {
                        LOBYTE(__src[0]) = 0;
                      }
LABEL_1264:
                      v624 = mDNSLogCategory_Default;
                      v625 = "ERROR: handle_regservice_request - Couldn't read name/regtype/domain";
LABEL_1265:
                      LogMsgWithLevel(v624, OS_LOG_TYPE_DEFAULT, v625, v246, v247, v248, v249, v250, v1077);
                      goto LABEL_1266;
                    }
                  }
                  v466 = v442 == &v1209;
                  goto LABEL_1260;
                case 6:
                  if (*(_QWORD *)(v76 + 144))
                    goto LABEL_239;
                  v142 = malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
                  if (!v142)
                    goto LABEL_1918;
                  *(_QWORD *)(v76 + 144) = v142;
LABEL_239:
                  v143 = 0;
                  v144 = 0;
                  v145 = *(unsigned int **)(v76 + 80);
                  if (v145)
                  {
                    v146 = *(_QWORD *)(v76 + 88);
                    v147 = 0;
                    if ((unint64_t)(v145 + 1) <= v146)
                    {
                      v147 = 0;
                      v143 = 0;
                      v144 = bswap32(*v145);
                      *(_QWORD *)(v76 + 80) = v145 + 1;
                      if (v145 != (unsigned int *)-4 && (unint64_t)(v145 + 2) <= v146)
                      {
                        v147 = bswap32(v145[1]);
                        v143 = v145 + 2;
                      }
                    }
                  }
                  else
                  {
                    v147 = 0;
                  }
                  *(_QWORD *)(v76 + 80) = v143;
                  v361 = mDNSPlatformInterfaceIDfromInterfaceIndex(v147, a2, a3, a4, a5, a6, a7, a8);
                  v362 = v361;
                  if (!v147 || v361)
                    goto LABEL_573;
                  if (v147 >= 0xFFFFFFFC)
                  {
                    updated = -65540;
                    if (mDNS_LoggingEnabled != 1)
                      goto LABEL_1267;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_browse_request: bad interfaceIndex %d", a4, a5, a6, a7, a8, v147);
                    goto LABEL_1266;
                  }
                  v362 = v147;
                  if (mDNS_LoggingEnabled == 1)
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_browse_request: browse pending for interface index %d", a4, a5, a6, a7, a8, v147);
LABEL_573:
                  bzero(&v1209, 0x3F1uLL);
                  bzero(v1223, 0x3F1uLL);
                  v1180 = 0u;
                  v1181 = 0u;
                  v1178 = 0u;
                  v1179 = 0u;
                  v1176 = 0u;
                  v1177 = 0u;
                  v1174 = 0u;
                  v1175 = 0u;
                  v1172 = 0u;
                  v1173 = 0u;
                  v1171 = 0u;
                  memset(v1170, 0, sizeof(v1170));
                  memset(__src, 0, sizeof(__src));
                  v1207 = 0u;
                  v1208 = 0u;
                  v1205 = 0u;
                  v1206 = 0u;
                  v1203 = 0u;
                  v1204 = 0u;
                  v1201 = 0u;
                  v1202 = 0u;
                  v1199 = 0u;
                  v1200 = 0u;
                  memset(buf, 0, sizeof(buf));
                  v1196 = 0u;
                  v1197 = 0u;
                  v1198 = 0u;
                  updated = -65540;
                  if (!*(_QWORD *)(v76 + 80))
                    goto LABEL_1267;
                  v363 = *(_QWORD *)(v76 + 88);
                  v364 = (sockaddr *)&v1209;
                  while (1)
                  {
                    v365 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v365 >= v363 || v364 >= (sockaddr *)v1218)
                      break;
                    *(_QWORD *)(v76 + 80) = v365 + 1;
                    v367 = *v365;
                    v364->sa_len = v367;
                    v364 = (sockaddr *)((char *)v364 + 1);
                    if (!v367)
                    {
                      updated = -65540;
                      if (!*(_QWORD *)(v76 + 80))
                        goto LABEL_1267;
                      v368 = *(_QWORD *)(v76 + 88);
                      v364 = v1223;
                      while (1)
                      {
                        v369 = *(unsigned __int8 **)(v76 + 80);
                        if ((unint64_t)v369 >= v368 || v364 >= (sockaddr *)v1238)
                          break;
                        *(_QWORD *)(v76 + 80) = v369 + 1;
                        v371 = *v369;
                        v364->sa_len = v371;
                        v364 = (sockaddr *)((char *)v364 + 1);
                        if (!v371)
                        {
                          if (!*(_QWORD *)(v76 + 80))
                          {
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceBrowse(unreadable parameters)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                            goto LABEL_1266;
                          }
                          _get_signed_data_tlvs(v76, 0);
                          *(_DWORD *)(v76 + 240) = v144;
                          *(_DWORD *)(v76 + 244) = v147;
                          LOBYTE(__src[0]) = 0;
                          v372 = ChopSubTypes((unsigned __int8 *)&v1209);
                          updated = -65540;
                          if (v372 > 1)
                            goto LABEL_1267;
                          if (v372 == 1)
                          {
                            v373 = strlen((const char *)&v1209);
                            updated = -65540;
                            if (!AppendDNSNameString(__src, (unsigned __int8 *)&v1209.st_dev + v373 + 1, v374, v375, v376, v377, v378, v379))goto LABEL_1267;
                          }
                          updated = -65540;
                          if (!LOBYTE(v1209.st_dev))
                            goto LABEL_1267;
                          updated = -65540;
                          if (!AppendDNSNameString(__src, (unsigned __int8 *)&v1209, a3, a4, a5, a6, a7, a8))
                            goto LABEL_1267;
                          buf[0] = 0;
                          updated = -65540;
                          if (!AppendDNSNameString(buf, (unsigned __int8 *)&v1209, a3, a4, a5, a6, a7, a8))
                            goto LABEL_1267;
                          if (buf[0] >= 0x10u && !v1223[0].sa_len)
                          {
                            for (k = 0; ; ++k)
                            {
                              *(&v1223[0].sa_len + k) = aLocal[k];
                              if (k == 6)
                                break;
                            }
                          }
                          v766 = *(_QWORD *)(v76 + 144);
                          *(_BYTE *)(v766 + 9) = (v144 & 0x400) != 0;
                          *(_QWORD *)v766 = v362;
                          for (m = __src; ; m = (socklen_t *)((char *)m + v768 + 1))
                          {
                            if (m >= (socklen_t *)v1182)
                              goto LABEL_1502;
                            if (!m)
                              goto LABEL_1502;
                            v768 = *(unsigned __int8 *)m;
                            if (v768 > 0x3F)
                              goto LABEL_1502;
                            if (!*(_BYTE *)m)
                              break;
                          }
                          v824 = (_DWORD)m - __src + 1;
                          if ((unsigned __int16)v824 > 0x100u)
LABEL_1502:
                            *(_BYTE *)(v766 + 10) = 0;
                          else
                            memcpy((void *)(v766 + 10), __src, (unsigned __int16)v824);
                          *(_BYTE *)(v766 + 8) = v1223[0].sa_len == 0;
                          *(_QWORD *)(v766 + 272) = 0;
                          v825 = requestShouldLogFullRequestInfo(v76);
                          v826 = gSensitiveLoggingEnabled;
                          v827 = mDNSLogCategory_mDNS;
                          if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            v826 = 0;
                          if (v825)
                          {
                            if ((v826 & 1) != 0)
                            {
                              v827 = mDNSLogCategory_mDNS_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                v834 = *(_DWORD *)(v76 + 192);
                                v835 = (_BYTE *)(v766 + 10);
                                if (v766 == -266)
                                {
                                  while (1)
                                  {
LABEL_1510:
                                    if (!v835)
                                      goto LABEL_1626;
                                    v836 = *v835;
                                    if (v836 > 0x3F)
                                      goto LABEL_1626;
                                    if (!*v835)
                                      break;
                                    v835 += v836 + 1;
                                    if (v766 != -266)
                                      goto LABEL_1509;
                                  }
                                  v900 = (_WORD)v835 - (v766 + 10) + 1;
                                }
                                else
                                {
LABEL_1509:
                                  if ((unint64_t)v835 < v766 + 266)
                                    goto LABEL_1510;
LABEL_1626:
                                  v900 = 257;
                                }
                                goto LABEL_1701;
                              }
LABEL_1703:
                              if (*(_BYTE *)(v766 + 8))
                              {
                                v954 = mDNSLogCategory_mDNS;
                                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                                {
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                    goto LABEL_1709;
                                }
                                else
                                {
                                  v954 = mDNSLogCategory_mDNS_redacted;
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                  {
LABEL_1709:
                                    v962 = *(_DWORD *)(v76 + 192);
                                    v963 = *(_DWORD *)(v76 + 180);
                                    *(_DWORD *)aBlock = 67109634;
                                    *(_DWORD *)&aBlock[4] = v962;
                                    *(_WORD *)&aBlock[8] = 1024;
                                    *(_DWORD *)&aBlock[10] = v963;
                                    *(_WORD *)&aBlock[14] = 2082;
                                    *(_QWORD *)&aBlock[16] = v76 + 248;
                                    _os_log_impl((void *)&_mh_execute_header, v954, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse Start domain enumeration for WAB and mDNS PID[%d](%{public}s)", aBlock, 0x18u);
                                  }
                                }
                                uDNS_StartWABQueries(2, v955, v956, v957, v958, v959, v960, v961);
                                mDNS_StartDomainEnumeration();
                              }
                              *(_QWORD *)(v76 + 104) = 0;
                              memset(aBlock, 0, sizeof(aBlock));
                              v1193 = 0u;
                              v1194 = 0u;
                              v1191 = 0u;
                              v1192 = 0u;
                              v1189 = 0u;
                              v1190 = 0u;
                              v1187 = 0u;
                              v1188 = 0u;
                              v1185 = 0u;
                              v1186 = 0u;
                              updated = -65540;
                              if (!AppendDNSNameString(aBlock, &v1223[0].sa_len, v828, v829, v830, v831, v832, v833))
                                goto LABEL_1267;
                              if (_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy")
                                && (*(_BYTE *)(v766 + 8) || IsLocalDomain(aBlock) || *(_BYTE *)(v766 + 9)))
                              {
                                v778 = _handle_browse_request_with_trust(v76, &v1223[0].sa_len);
                              }
                              else
                              {
                                v778 = _handle_browse_request_start(v76, &v1223[0].sa_len, v964, v965, v966, v967, v968, v969);
                              }
                              goto LABEL_1757;
                            }
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1703;
                            v834 = *(_DWORD *)(v76 + 192);
                            v837 = (_BYTE *)(v766 + 10);
                            if (v766 == -266)
                            {
                              while (1)
                              {
LABEL_1522:
                                if (!v837)
                                  goto LABEL_1627;
                                v838 = *v837;
                                if (v838 > 0x3F)
                                  goto LABEL_1627;
                                if (!*v837)
                                  break;
                                v837 += v838 + 1;
                                if (v766 != -266)
                                  goto LABEL_1521;
                              }
                              v900 = (_WORD)v837 - (v766 + 10) + 1;
                            }
                            else
                            {
LABEL_1521:
                              if ((unint64_t)v837 < v766 + 266)
                                goto LABEL_1522;
LABEL_1627:
                              v900 = 257;
                            }
LABEL_1701:
                            v951 = *(_DWORD *)(v76 + 240);
                            v952 = *(_DWORD *)(v76 + 244);
                            v953 = *(_DWORD *)(v76 + 180);
                            *(_DWORD *)aBlock = 67111427;
                            *(_DWORD *)&aBlock[4] = v834;
                            *(_WORD *)&aBlock[8] = 2160;
                            *(_QWORD *)&aBlock[10] = 1752392040;
                            *(_WORD *)&aBlock[18] = 1040;
                            *(_DWORD *)&aBlock[20] = v900;
                            *(_WORD *)&aBlock[24] = 2101;
                            *(_QWORD *)&aBlock[26] = v766 + 10;
                            *(_WORD *)&aBlock[34] = 2160;
                            *(_QWORD *)&aBlock[36] = 1752392040;
                            *(_WORD *)&aBlock[44] = 2085;
                            *(_QWORD *)&aBlock[46] = v1223;
                            *(_WORD *)&aBlock[54] = 1024;
                            *(_DWORD *)&aBlock[56] = v951;
                            *(_WORD *)&aBlock[60] = 1024;
                            *(_DWORD *)&aBlock[62] = v952;
                            *(_WORD *)&aBlock[66] = 1024;
                            *(_DWORD *)&aBlock[68] = v953;
                            *(_WORD *)&aBlock[72] = 2082;
                            *(_QWORD *)&aBlock[74] = v76 + 248;
                            v874 = v827;
                            v875 = "[R%u] DNSServiceBrowse START -- service type: %{sensitive, mask.hash, mdnsresponder:d"
                                   "omain_name}.*P, domain: %{sensitive, mask.hash}s, flags: 0x%X, interface index: %d, c"
                                   "lient pid: %d (%{public}s), ";
                            v876 = 82;
                          }
                          else
                          {
                            if ((v826 & 1) != 0)
                            {
                              v827 = mDNSLogCategory_mDNS_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                goto LABEL_1703;
                            }
                            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            {
                              goto LABEL_1703;
                            }
                            v873 = *(_DWORD *)(v76 + 192);
                            *(_DWORD *)aBlock = 67109120;
                            *(_DWORD *)&aBlock[4] = v873;
                            v874 = v827;
                            v875 = "[R%u] DNSServiceBrowse START -- ";
                            v876 = 8;
                          }
                          _os_log_impl((void *)&_mh_execute_header, v874, OS_LOG_TYPE_DEFAULT, v875, aBlock, v876);
                          goto LABEL_1703;
                        }
                      }
                      v381 = v1238;
LABEL_865:
                      v521 = &v364->sa_len - (v364 == (sockaddr *)v381);
                      goto LABEL_921;
                    }
                  }
                  v381 = v1218;
                  goto LABEL_865;
                case 7:
                  if (*(_QWORD *)(v76 + 128))
                    goto LABEL_247;
                  v148 = malloc_type_calloc(1uLL, 0x590uLL, 0xF1748037uLL);
                  if (!v148)
                    goto LABEL_1918;
                  *(_QWORD *)(v76 + 128) = v148;
LABEL_247:
                  v149 = 0;
                  v150 = *(unsigned int **)(v76 + 80);
                  if (!v150
                    || (v151 = *(_QWORD *)(v76 + 88), (unint64_t)(v150 + 1) > v151)
                    || (v152 = v150 + 2,
                        v149 = bswap32(*v150),
                        *(_QWORD *)(v76 + 80) = v150 + 1,
                        v150 == (unsigned int *)-4)
                    || (unint64_t)v152 > v151)
                  {
                    v153 = 0;
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  else
                  {
                    v153 = bswap32(v150[1]);
                    *(_QWORD *)(v76 + 80) = v152;
                    if (v153 == -3)
                    {
                      if (mDNS_LoggingEnabled == 1)
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P", a4, a5, a6, a7, a8, v1077);
                      v153 = 0;
                      v149 |= 0x20000u;
                    }
                  }
                  v282 = mDNSPlatformInterfaceIDfromInterfaceIndex(v153, a2, a3, a4, a5, a6, a7, a8);
                  v1222 = v282;
                  if (!v153 || v282)
                    goto LABEL_691;
                  if (v153 == 0 || v153 >= 0xFFFFFFFC)
                  {
                    updated = -65540;
                    if (mDNS_LoggingEnabled != 1)
                      goto LABEL_1267;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: bad interfaceIndex %d", a4, a5, a6, a7, a8, v153);
                    goto LABEL_1266;
                  }
                  v1222 = v153;
                  if (mDNS_LoggingEnabled == 1)
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: resolve pending for interface index %d", a4, a5, a6, a7, a8, v153);
LABEL_691:
                  v1180 = 0u;
                  v1181 = 0u;
                  v1178 = 0u;
                  v1179 = 0u;
                  v1176 = 0u;
                  v1177 = 0u;
                  v1174 = 0u;
                  v1175 = 0u;
                  v1172 = 0u;
                  v1173 = 0u;
                  v1171 = 0u;
                  memset(v1170, 0, sizeof(v1170));
                  memset(__src, 0, sizeof(__src));
                  bzero(v1223, 0x3F1uLL);
                  bzero(&v1209, 0x4F8uLL);
                  if (!*(_QWORD *)(v76 + 80))
                    goto LABEL_1048;
                  v421 = *(_QWORD *)(v76 + 88);
                  v422 = (sockaddr *)__src;
                  do
                  {
                    v423 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v423 >= v421 || v422 >= (sockaddr *)v1182)
                    {
                      v440 = v1182;
                      goto LABEL_1047;
                    }
                    *(_QWORD *)(v76 + 80) = v423 + 1;
                    v425 = *v423;
                    v422->sa_len = v425;
                    v422 = (sockaddr *)((char *)v422 + 1);
                  }
                  while (v425);
                  if (!*(_QWORD *)(v76 + 80))
                  {
                    LOBYTE(v1209.st_dev) = 0;
LABEL_1048:
                    v624 = mDNSLogCategory_Default;
                    v625 = "ERROR: handle_resolve_request - Couldn't read name/regtype/domain";
                    goto LABEL_1265;
                  }
                  v426 = *(_QWORD *)(v76 + 88);
                  v422 = (sockaddr *)&v1209;
                  do
                  {
                    v427 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v427 >= v426 || v422 >= (sockaddr *)v1218)
                    {
                      v440 = v1218;
LABEL_1047:
                      *(&v422->sa_len - (v422 == (sockaddr *)v440)) = 0;
                      *(_QWORD *)(v76 + 80) = 0;
                      goto LABEL_1048;
                    }
                    *(_QWORD *)(v76 + 80) = v427 + 1;
                    v429 = *v427;
                    v422->sa_len = v429;
                    v422 = (sockaddr *)((char *)v422 + 1);
                  }
                  while (v429);
                  if (!*(_QWORD *)(v76 + 80))
                  {
                    v1223[0].sa_len = 0;
                    goto LABEL_1048;
                  }
                  v430 = *(_QWORD *)(v76 + 88);
                  v422 = v1223;
                  while (2)
                  {
                    v431 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v431 >= v430 || v422 >= (sockaddr *)v1238)
                    {
                      v440 = v1238;
                      goto LABEL_1047;
                    }
                    *(_QWORD *)(v76 + 80) = v431 + 1;
                    v433 = *v431;
                    v422->sa_len = v433;
                    v422 = (sockaddr *)((char *)v422 + 1);
                    if (v433)
                      continue;
                    break;
                  }
                  if (!*(_QWORD *)(v76 + 80))
                  {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceResolve(unreadable parameters)", v246, v247, v248, v249, v250, *(_DWORD *)(v76 + 176));
                    goto LABEL_1266;
                  }
                  signed_browse_tlvs = get_signed_browse_tlvs(v76);
                  if (signed_browse_tlvs)
                  {
                    updated = signed_browse_tlvs;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_resolve_request err reading Validation TLVS", v435, v436, v437, v438, v439, *(_DWORD *)(v76 + 176));
                    goto LABEL_1267;
                  }
                  v779 = v1218;
                  if ((build_domainname_from_strings(v1218, __src, (unsigned __int8 *)&v1209, &v1223[0].sa_len, v436, v437, v438, v439) & 0x80000000) != 0)
                  {
                    v1078 = &v1209;
                    v1079 = (unint64_t)v1223;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_resolve_request bad %s %s %s", v781, v782, v783, v784, v785, (int)__src);
                    goto LABEL_1266;
                  }
                  *(_DWORD *)(v76 + 240) = v149;
                  *(_DWORD *)(v76 + 244) = v153;
                  v786 = *(_QWORD *)(v76 + 128);
                  *(_QWORD *)(v786 + 832) = v1222;
                  *(_DWORD *)(v786 + 1020) = v149;
                  while (v779 < v1221)
                  {
                    if (!v779)
                      break;
                    v787 = *v779;
                    if (v787 > 0x3F)
                      break;
                    if (!*v779)
                    {
                      if ((unsigned __int16)((_WORD)v779 - (unsigned __int16)v1218 + 1) <= 0x100u)
                      {
                        memcpy((void *)(v786 + 1072), v1218, (unsigned __int16)((_WORD)v779 - (unsigned __int16)v1218 + 1));
                        goto LABEL_1583;
                      }
                      break;
                    }
                    v779 += v787 + 1;
                  }
                  *(_BYTE *)(v786 + 1072) = 0;
LABEL_1583:
                  *(_DWORD *)(v786 + 1038) = 65569;
                  v877 = (v149 >> 8) & 1;
                  v1122 = v786 + 1328;
                  *(_BYTE *)(v786 + 1328) = BYTE1(v149) & 1;
                  *(_BYTE *)(v786 + 1329) = 1;
                  *(_BYTE *)(v786 + 1330) = (v149 & 0x400) != 0;
                  *(_BYTE *)(v786 + 1331) = (v149 & 0x1000) != 0;
                  *(_WORD *)(v786 + 1332) = 0;
                  *(_BYTE *)(v786 + 1337) = 0;
                  *(_BYTE *)(v786 + 1335) = (v149 & 0x40000) != 0;
                  *(_BYTE *)(v786 + 1336) = (v149 & 0x80000) != 0;
                  *(_BYTE *)(v786 + 1348) = 0;
                  *(_DWORD *)(v786 + 940) = *(_DWORD *)(v76 + 180);
                  *(_DWORD *)(v786 + 944) = *(_DWORD *)(v76 + 188);
                  *(_QWORD *)(v786 + 848) = resolve_result_callback;
                  *(_QWORD *)(v786 + 872) = v76;
                  *(_QWORD *)(v786 + 136) = v1222;
                  *(_DWORD *)(v786 + 324) = v149;
                  v878 = v1218;
                  for (n = v1218; n < v1221; n += v880 + 1)
                  {
                    if (!n)
                      break;
                    v880 = *n;
                    if (v880 > 0x3F)
                      break;
                    if (!*n)
                    {
                      v881 = (_WORD)n - (unsigned __int16)v1218 + 1;
                      if (v881 <= 0x100u)
                      {
                        memcpy((void *)(v786 + 376), v1218, v881);
                        v877 = (v149 >> 8) & 1;
                        goto LABEL_1592;
                      }
                      break;
                    }
                  }
                  *(_BYTE *)(v786 + 376) = 0;
LABEL_1592:
                  *(_DWORD *)(v786 + 342) = 65552;
                  *(_BYTE *)(v786 + 632) = v877;
                  *(_BYTE *)(v786 + 633) = 1;
                  *(_BYTE *)(v786 + 634) = (v149 & 0x400) != 0;
                  *(_BYTE *)(v786 + 635) = (v149 & 0x1000) != 0;
                  *(_WORD *)(v786 + 636) = 0;
                  *(_BYTE *)(v786 + 641) = 0;
                  *(_BYTE *)(v786 + 639) = 0;
                  *(_BYTE *)(v786 + 640) = (v149 & 0x80000) != 0;
                  *(_BYTE *)(v786 + 652) = 0;
                  *(_DWORD *)(v786 + 244) = *(_DWORD *)(v76 + 180);
                  *(_DWORD *)(v786 + 248) = *(_DWORD *)(v76 + 188);
                  *(_QWORD *)(v786 + 152) = resolve_result_callback;
                  *(_QWORD *)(v786 + 176) = v76;
                  v882 = mDNS_TimeNow(mDNSStorage, (uint64_t)v878, v780, v781, v782, v783, v784, v785) + 130000;
                  if (v882 <= 1)
                    v882 = 1;
                  *(_DWORD *)(v786 + 1412) = v882;
                  *(_BYTE *)(v786 + 1416) = 0;
                  v883 = requestShouldLogFullRequestInfo(v76);
                  v884 = (_BYTE *)(v786 + 1072);
                  v885 = gSensitiveLoggingEnabled;
                  v886 = mDNSLogCategory_mDNS;
                  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    v885 = 0;
                  if (!v883)
                  {
                    if ((v885 & 1) != 0)
                    {
                      v886 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1765;
                    }
                    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
                      goto LABEL_1765;
                    }
                    v901 = *(_DWORD *)(v76 + 192);
                    v902 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v786 + 1072));
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)&buf[4] = v901;
                    *(_WORD *)&buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v902;
                    v903 = v886;
                    v904 = "[R%u] DNSServiceResolve START -- name hash: %x";
                    v905 = 14;
                    goto LABEL_1764;
                  }
                  if ((v885 & 1) == 0)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1765;
                    v1107 = *(_DWORD *)(v76 + 192);
                    while (1)
                    {
                      if ((unint64_t)v884 >= v1122
                        || !v884
                        || (v895 = *v884, v895 > 0x3F))
                      {
                        v942 = 257;
                        goto LABEL_1762;
                      }
                      if (!*v884)
                        break;
                      v884 += v895 + 1;
                    }
                    v942 = (_WORD)v884 - (v786 + 1072) + 1;
LABEL_1762:
                    v1011 = v942;
                    v1012 = *(_DWORD *)(v76 + 240);
                    v1093 = *(_DWORD *)(v76 + 244);
                    v1013 = *(_DWORD *)(v76 + 180);
                    v884 = (_BYTE *)(v786 + 1072);
                    v1014 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v786 + 1072));
                    *(_DWORD *)buf = 67111171;
                    *(_DWORD *)&buf[4] = v1107;
                    *(_WORD *)&buf[8] = 2160;
                    *(_QWORD *)&buf[10] = 1752392040;
                    *(_WORD *)&buf[18] = 1040;
                    *(_DWORD *)&buf[20] = v1011;
                    *(_WORD *)&buf[24] = 2101;
                    *(_QWORD *)&buf[26] = v786 + 1072;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v1012;
                    *(_WORD *)&buf[40] = 1024;
                    *(_DWORD *)&buf[42] = v1093;
                    *(_WORD *)&buf[46] = 1024;
                    LODWORD(v1196) = v1013;
                    WORD2(v1196) = 2082;
                    *(_QWORD *)((char *)&v1196 + 6) = v76 + 248;
                    HIWORD(v1196) = 1024;
                    LODWORD(v1197) = v1014;
                    v903 = v886;
                    v904 = "[R%u] DNSServiceResolve START -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}"
                           ".*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x";
LABEL_1763:
                    v905 = 68;
LABEL_1764:
                    _os_log_impl((void *)&_mh_execute_header, v903, OS_LOG_TYPE_DEFAULT, v904, buf, v905);
                    goto LABEL_1765;
                  }
                  v887 = mDNSLogCategory_mDNS_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  {
                    v1106 = *(_DWORD *)(v76 + 192);
                    while (1)
                    {
                      if ((unint64_t)v884 >= v1122
                        || !v884
                        || (v894 = *v884, v894 > 0x3F))
                      {
                        v941 = 257;
                        goto LABEL_1760;
                      }
                      if (!*v884)
                        break;
                      v884 += v894 + 1;
                    }
                    v941 = (_WORD)v884 - (v786 + 1072) + 1;
LABEL_1760:
                    v1007 = v941;
                    v1008 = *(_DWORD *)(v76 + 240);
                    v1092 = *(_DWORD *)(v76 + 244);
                    v1009 = *(_DWORD *)(v76 + 180);
                    v884 = (_BYTE *)(v786 + 1072);
                    v1010 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v786 + 1072));
                    *(_DWORD *)buf = 67111171;
                    *(_DWORD *)&buf[4] = v1106;
                    *(_WORD *)&buf[8] = 2160;
                    *(_QWORD *)&buf[10] = 1752392040;
                    *(_WORD *)&buf[18] = 1040;
                    *(_DWORD *)&buf[20] = v1007;
                    *(_WORD *)&buf[24] = 2101;
                    *(_QWORD *)&buf[26] = v786 + 1072;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v1008;
                    *(_WORD *)&buf[40] = 1024;
                    *(_DWORD *)&buf[42] = v1092;
                    *(_WORD *)&buf[46] = 1024;
                    LODWORD(v1196) = v1009;
                    WORD2(v1196) = 2082;
                    *(_QWORD *)((char *)&v1196 + 6) = v76 + 248;
                    HIWORD(v1196) = 1024;
                    LODWORD(v1197) = v1010;
                    v903 = v887;
                    v904 = "[R%u] DNSServiceResolve START -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}"
                           ".*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x";
                    goto LABEL_1763;
                  }
LABEL_1765:
                  *(_QWORD *)(v76 + 104) = 0;
                  v1015 = *(_QWORD *)(v76 + 56);
                  if (!v1015)
                    goto LABEL_1800;
                  if (*(_UNKNOWN ***)(v1015 + 16) != &_mdns_signed_browse_result_kind
                    || !mdns_signed_browse_result_contains(*(_QWORD *)(v76 + 56), v1218, v153))
                  {
                    v1020 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                      {
                        v1021 = *(_DWORD *)(v76 + 192);
                        v1022 = v884;
                        while (1)
                        {
                          if ((unint64_t)v884 >= v1122
                            || !v884
                            || (v1024 = *v884, v1024 > 0x3F))
                          {
                            v1025 = 257;
                            goto LABEL_1797;
                          }
                          if (!*v884)
                            break;
                          v884 += v1024 + 1;
                        }
                        v1025 = (_WORD)v884 - (_WORD)v1022 + 1;
LABEL_1797:
                        *(_DWORD *)buf = 67110147;
                        *(_DWORD *)&buf[4] = v1021;
                        *(_WORD *)&buf[8] = 2160;
                        *(_QWORD *)&buf[10] = 1752392040;
                        *(_WORD *)&buf[18] = 1040;
                        *(_DWORD *)&buf[20] = v1025;
                        *(_WORD *)&buf[24] = 2101;
                        *(_QWORD *)&buf[26] = v1022;
                        *(_WORD *)&buf[34] = 1024;
                        *(_DWORD *)&buf[36] = v153;
                        _os_log_impl((void *)&_mh_execute_header, v1020, OS_LOG_TYPE_ERROR, "[R%d] DNSServiceResolve: Signed result does not cover service: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ifindex: %u.", buf, 0x28u);
                      }
                    }
                    else
                    {
                      v1020 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                      {
                        v1021 = *(_DWORD *)(v76 + 192);
                        v1022 = v884;
                        while (1)
                        {
                          if ((unint64_t)v884 >= v1122
                            || !v884
                            || (v1023 = *v884, v1023 > 0x3F))
                          {
                            v1025 = 257;
                            goto LABEL_1797;
                          }
                          if (!*v884)
                            break;
                          v884 += v1023 + 1;
                        }
                        v1025 = (_WORD)v884 - (_WORD)v1022 + 1;
                        goto LABEL_1797;
                      }
                    }
                    *(_BYTE *)(v76 + 282) = 0;
                    v1027 = *(void **)(v76 + 56);
                    if (v1027)
                    {
                      os_release(v1027);
                      *(_QWORD *)(v76 + 56) = 0;
                    }
LABEL_1800:
                    v1028 = 1;
                    goto LABEL_1801;
                  }
                  uuid = _mdns_signed_browse_result_get_uuid(v1015);
                  is_signed_result_uuid_valid = mdns_system_is_signed_result_uuid_valid(uuid);
                  v1018 = gSensitiveLoggingEnabled;
                  v1019 = mDNSLogCategory_mDNS;
                  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    v1018 = 0;
                  if (is_signed_result_uuid_valid)
                  {
                    if ((v1018 & 1) != 0)
                    {
                      v1019 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
                      {
LABEL_1813:
                        v1030 = *(_DWORD *)(v76 + 192);
                        *(_DWORD *)buf = 67109120;
                        *(_DWORD *)&buf[4] = v1030;
                        _os_log_impl((void *)&_mh_execute_header, v1019, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceResolve: Allowing signed result", buf, 8u);
                      }
                    }
                    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
                    {
                      goto LABEL_1813;
                    }
                    v1028 = 0;
LABEL_1801:
                    v1207 = 0u;
                    v1208 = 0u;
                    v1205 = 0u;
                    v1206 = 0u;
                    v1203 = 0u;
                    v1204 = 0u;
                    v1201 = 0u;
                    v1202 = 0u;
                    v1199 = 0u;
                    v1200 = 0u;
                    v1197 = 0u;
                    v1198 = 0u;
                    v1196 = 0u;
                    memset(buf, 0, sizeof(buf));
                    updated = -65540;
                    if (!AppendDNSNameString(buf, &v1223[0].sa_len, v888, v889, v890, v891, v892, v893))
                      goto LABEL_1267;
                    if (v1028
                      && _os_feature_enabled_impl("mDNSResponder", "bonjour_privacy")
                      && (IsLocalDomain(buf) || *(_BYTE *)(v786 + 1330)))
                    {
                      v778 = _handle_resolve_request_with_trust(v76, (unsigned __int8 *)&v1209);
                    }
                    else
                    {
                      v778 = _handle_resolve_request_start(v76, (uint64_t)&v1209);
                    }
                    goto LABEL_1757;
                  }
                  if ((v1018 & 1) != 0)
                  {
                    v1019 = mDNSLogCategory_mDNS_redacted;
                    updated = -65570;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                      goto LABEL_1267;
                  }
                  else
                  {
                    updated = -65570;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                      goto LABEL_1267;
                  }
                  v1026 = *(_DWORD *)(v76 + 192);
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&buf[4] = v1026;
                  v719 = buf;
                  v720 = v1019;
                  v721 = OS_LOG_TYPE_ERROR;
                  v722 = "[R%d] DNSServiceResolve: Signed result UUID revoked.";
LABEL_1217:
                  v723 = 8;
LABEL_1499:
                  _os_log_impl((void *)&_mh_execute_header, v720, v721, v722, v719, v723);
LABEL_1267:
                  v735 = *(void **)(v76 + 72);
                  if (v735)
                  {
                    free(v735);
                    *(_QWORD *)(v76 + 72) = 0;
                  }
                  v736 = *(_DWORD *)(v76 + 220);
                  v167 = v736 > 0x3F;
                  v737 = (1 << v736) & 0x8000000000022000;
                  if (v167 || v737 == 0)
                  {
                    v739 = bswap32(updated);
                    *(_DWORD *)&v1223[0].sa_len = v739;
                    if ((*(_BYTE *)(v76 + 216) & 4) == 0)
                    {
                      send_all(*(_DWORD *)(v76 + 184), v1223, 4uLL);
LABEL_1287:
                      v743 = *(_DWORD *)(v76 + 184);
                      if (v743 != *(_DWORD *)(v76 + 176))
                      {
                        close(v743);
                        *(_DWORD *)(v76 + 184) = *(_DWORD *)(v76 + 176);
                        v744 = *(_QWORD *)(v76 + 24);
                        if (v744)
                          *(_DWORD *)(v744 + 184) = *(_DWORD *)(v744 + 176);
                      }
                      goto LABEL_1273;
                    }
                    v740 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1284;
                    }
                    else
                    {
                      v740 = mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_1284:
                        v741 = *(_DWORD *)(v76 + 192);
                        v1209.st_dev = 67109376;
                        *(_DWORD *)&v1209.st_mode = v741;
                        LOWORD(v1209.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ino + 2) = updated;
                        _os_log_impl((void *)&_mh_execute_header, v740, OS_LOG_TYPE_DEFAULT, "[R%u] returnAsyncErrorCode: error code(%d)", (uint8_t *)&v1209, 0xEu);
                      }
                    }
                    if (updated)
                    {
                      reply = create_reply((char *)0x49, 18, v76, a4, a5, a6, a7, a8);
                      *((_DWORD *)reply + 11) = 0;
                      *((_DWORD *)reply + 12) = 0;
                      *((_DWORD *)reply + 13) = v739;
                      *((_DWORD *)reply + 14) = 0;
                      *((_WORD *)reply + 30) = 0;
                      append_reply(v76, reply);
                    }
                    goto LABEL_1287;
                  }
LABEL_1273:
                  if (*(_QWORD *)(v76 + 24))
                    v8 = *(_QWORD *)(v76 + 24);
                  else
                    v8 = v76;
                  v9 = 1;
                  *(_BYTE *)(v8 + 283) = 1;
                  *(_DWORD *)(v8 + 204) = 0;
                  *(_OWORD *)(v8 + 64) = 0u;
                  *(_OWORD *)(v8 + 80) = 0u;
                  continue;
                case 8:
                  if (*(_QWORD *)(v76 + 136))
                    goto LABEL_258;
                  v154 = malloc_type_calloc(1uLL, 0x320uLL, 0xF1748037uLL);
                  if (!v154)
                    goto LABEL_1918;
                  *(_QWORD *)(v76 + 136) = v154;
LABEL_258:
                  bzero(&v1209, 0x468uLL);
                  v1209.st_ino = (__darwin_ino64_t)&v1209.st_size;
                  v155 = *(unsigned int **)(v76 + 80);
                  if (!v155)
                    goto LABEL_922;
                  v156 = *(_QWORD *)(v76 + 88);
                  if ((unint64_t)(v155 + 1) > v156)
                    goto LABEL_922;
                  v157 = v155 + 2;
                  v158 = bswap32(*v155);
                  *(_QWORD *)(v76 + 80) = v155 + 1;
                  v1209.st_gid = v158;
                  if (v155 == (unsigned int *)-4 || (unint64_t)v157 > v156)
                    goto LABEL_922;
                  v159 = bswap32(v155[1]);
                  *(_QWORD *)(v76 + 80) = v157;
                  v1209.st_uid = v159;
                  updated = -65540;
                  if (!v157)
                    goto LABEL_1267;
                  p_st_size = &v1209.st_size;
                  while (1)
                  {
                    v161 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v161 >= v156 || p_st_size >= (_BYTE *)v1220)
                      break;
                    *(_QWORD *)(v76 + 80) = v161 + 1;
                    v163 = *v161;
                    *p_st_size++ = v163;
                    if (!v163)
                    {
                      v164 = *(unsigned __int16 **)(v76 + 80);
                      v165 = *(_QWORD *)(v76 + 88);
                      v166 = v164 + 1;
                      if (v164)
                        v167 = (unint64_t)v166 > v165;
                      else
                        v167 = 1;
                      if (v167)
                      {
                        v168 = 0;
                        LOWORD(v169) = 0;
                        LOWORD(v1209.st_rdev) = 0;
                      }
                      else
                      {
                        LOWORD(v169) = 0;
                        v168 = 0;
                        v559 = bswap32(*v164);
                        *(_QWORD *)(v76 + 80) = v166;
                        LOWORD(v1209.st_rdev) = HIWORD(v559);
                        if (v164 != (unsigned __int16 *)-2 && (unint64_t)(v164 + 2) <= v165)
                        {
                          v169 = bswap32(v164[1]) >> 16;
                          v168 = (unsigned __int8 *)(v164 + 2);
                        }
                      }
                      *(_QWORD *)(v76 + 80) = v168;
                      HIWORD(v1209.st_rdev) = v169;
                      v560 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = v560;
                      if (*(_BYTE *)(v76 + 280))
                        v561 = 0;
                      else
                        v561 = *(_DWORD *)(v76 + 180);
                      if (*(_BYTE *)(v76 + 280))
                        v579 = v76 + 264;
                      else
                        v579 = 0;
                      v1209.st_atimespec.tv_sec = v579;
                      v580 = *(_DWORD *)(v76 + 188);
                      *(&v1209.st_rdev + 1) = v561;
                      LODWORD(v1209.st_atimespec.tv_nsec) = v580;
                      v1209.st_ctimespec.tv_nsec = *(_QWORD *)(v76 + 32);
                      if (v168)
                      {
                        *(int32x2_t *)(v76 + 240) = vrev64_s32(*(int32x2_t *)&v1209.st_uid);
                        if ((*(_BYTE *)(v76 + 216) & 2) != 0)
                        {
                          BYTE1(v1209.st_birthtimespec.tv_nsec) = get_tlv_uint32(v168, v165, 3, 0) == 1;
                          v581 = v168;
                          do
                          {
                            if ((uint64_t)(v165 - (_QWORD)v581) < 4)
                              goto LABEL_1011;
                            v582 = v581 + 4;
                            if (v581 == (unsigned __int8 *)-4)
                              goto LABEL_1011;
                            v583 = __rev16(*((unsigned __int16 *)v581 + 1));
                            if ((uint64_t)(v165 - (_QWORD)v582) < v583)
                              goto LABEL_1011;
                            v584 = __rev16(*(unsigned __int16 *)v581);
                            v581 = (unsigned __int8 *)v582 + v583;
                          }
                          while (v584 != 10);
                          if (v583 == 16)
                          {
                            v1220[0] = *v582;
                            v1209.st_mtimespec.tv_sec = (__darwin_time_t)v1220;
                            BYTE4(v1209.st_ctimespec.tv_sec) = 1;
                          }
                          else
                          {
LABEL_1011:
                            BYTE1(v1209.st_ctimespec.tv_sec) = get_tlv_uint32(v168, v165, 4, 0) == 1;
                            v597 = v168;
                            do
                            {
                              if ((uint64_t)(v165 - (_QWORD)v597) < 4)
                                goto LABEL_1017;
                              v598 = v597 + 4;
                              if (v597 == (unsigned __int8 *)-4)
                                goto LABEL_1017;
                              v599 = __rev16(*((unsigned __int16 *)v597 + 1));
                              if ((uint64_t)(v165 - (_QWORD)v598) < v599)
                                goto LABEL_1017;
                              v600 = __rev16(*(unsigned __int16 *)v597);
                              v597 = (unsigned __int8 *)&v598[v599];
                            }
                            while (v600 != 1);
                            v1209.st_mtimespec.tv_nsec = Querier_RegisterCustomDNSServiceWithPListData(v598, v599);
                            *(_QWORD *)v76 = v1209.st_mtimespec.tv_nsec;
LABEL_1017:
                            LOBYTE(v1209.st_ctimespec.tv_sec) = get_tlv_uint32(v168, v165, 2, 0) != 0;
                          }
                        }
                        v601 = get_signed_browse_tlvs(v76);
                        if (v601)
                        {
                          updated = v601;
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_queryrecord_request err reading Validation TLVS", v602, v603, v604, v605, v606, *(_DWORD *)(v76 + 176));
                          goto LABEL_1267;
                        }
                        get_tracker_info_tlvs(v76);
                        v608 = *(_DWORD *)(v76 + 240);
                        v609 = _os_feature_enabled_impl("mDNSResponder", "dnssec");
                        memset(v1223, 0, sizeof(v1223));
                        v1224 = 0u;
                        v1225 = 0u;
                        v1226 = 0u;
                        memset(v1227, 0, sizeof(v1227));
                        v1228 = 0u;
                        v1229 = 0u;
                        v1230 = 0u;
                        v1231 = 0u;
                        v1232 = 0u;
                        v1233 = 0u;
                        v1234 = 0u;
                        v1235 = 0u;
                        v1236 = 0u;
                        updated = -65540;
                        if (!AppendDNSNameString(v1223, (unsigned __int8 *)&v1209.st_size, v610, v611, v612, v613, v614, v615))goto LABEL_1267;
                        v616 = IsLocalDomain(v1223);
                        v617 = requestShouldLogFullRequestInfo(v76);
                        v618 = v609 ^ 1;
                        if ((v608 & 0x200000) == 0)
                          v618 = 1;
                        if ((v618 & 1) != 0)
                        {
                          if (v617)
                          {
                            if (!gSensitiveLoggingEnabled
                              || (v616 ? (v729 = mDNSLogCategory_mDNS) : (v729 = mDNSLogCategory_Default),
                                  v729 == mDNSLogCategory_State))
                            {
                              if (v616)
                                v730 = mDNSLogCategory_mDNS;
                              else
                                v730 = mDNSLogCategory_Default;
                              if (!os_log_type_enabled(v730, OS_LOG_TYPE_DEFAULT))
                                goto LABEL_1744;
                              v1121 = *(_DWORD *)(v76 + 192);
                              for (ii = v1223; ; ii = (sockaddr *)((char *)ii + sa_len + 1))
                              {
                                LOWORD(v732) = 257;
                                if (ii >= (sockaddr *)v1237 || !ii)
                                  goto LABEL_1741;
                                sa_len = ii->sa_len;
                                if (sa_len > 0x3F)
                                {
                                  LOWORD(v732) = 257;
                                  goto LABEL_1741;
                                }
                                if (!ii->sa_len)
                                  break;
                              }
                              v732 = (_DWORD)ii - v1223 + 1;
                            }
                            else
                            {
                              if (v616)
                                v730 = mDNSLogCategory_mDNS;
                              else
                                v730 = mDNSLogCategory_Default_redacted;
                              if (!os_log_type_enabled(v730, OS_LOG_TYPE_DEFAULT))
                                goto LABEL_1744;
                              v1121 = *(_DWORD *)(v76 + 192);
                              for (jj = v1223; ; jj = (sockaddr *)((char *)jj + v733 + 1))
                              {
                                LOWORD(v732) = 257;
                                if (jj >= (sockaddr *)v1237 || !jj)
                                  goto LABEL_1741;
                                v733 = jj->sa_len;
                                if (v733 > 0x3F)
                                {
                                  LOWORD(v732) = 257;
                                  goto LABEL_1741;
                                }
                                if (!jj->sa_len)
                                  break;
                              }
                              v732 = (_DWORD)jj - v1223 + 1;
                            }
LABEL_1741:
                            v992 = (unsigned __int16)v732;
                            st_rdev_low = LOWORD(v1209.st_rdev);
                            v994 = *(_DWORD *)(v76 + 240);
                            v995 = *(_DWORD *)(v76 + 244);
                            v996 = *(_DWORD *)(v76 + 180);
                            v997 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1121;
                            LOWORD(__src[2]) = 2160;
                            *(_QWORD *)((char *)&__src[2] + 2) = 1752392040;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v992;
                            LOWORD(__src[6]) = 2101;
                            *(_QWORD *)((char *)&__src[6] + 2) = v1223;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = st_rdev_low;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v994;
                            HIWORD(__src[11]) = 1024;
                            v1170[0] = v995;
                            LOWORD(v1170[1]) = 1024;
                            *(_DWORD *)((char *)&v1170[1] + 2) = v996;
                            HIWORD(v1170[2]) = 2082;
                            *(_QWORD *)&v1170[3] = v76 + 248;
                            LOWORD(v1170[5]) = 1024;
                            *(_DWORD *)((char *)&v1170[5] + 2) = v997;
                            v843 = v730;
                            v844 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder:dom"
                                   "ain_name}.*P, qtype: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %"
                                   "d (%{public}s), name hash: %x";
                            goto LABEL_1742;
                          }
                          if (!gSensitiveLoggingEnabled
                            || (v616 ? (v821 = mDNSLogCategory_mDNS) : (v821 = mDNSLogCategory_Default),
                                v821 == mDNSLogCategory_State))
                          {
                            if (v616)
                              v820 = mDNSLogCategory_mDNS;
                            else
                              v820 = mDNSLogCategory_Default;
                            if (!os_log_type_enabled(v820, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1744;
                          }
                          else
                          {
                            if (v616)
                              v820 = mDNSLogCategory_mDNS;
                            else
                              v820 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled(v820, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1744;
                          }
                        }
                        else
                        {
                          if (v617)
                          {
                            if (!gSensitiveLoggingEnabled
                              || (v616 ? (v619 = mDNSLogCategory_mDNS) : (v619 = mDNSLogCategory_Default),
                                  v619 == mDNSLogCategory_State))
                            {
                              if (v616)
                                v620 = mDNSLogCategory_mDNS;
                              else
                                v620 = mDNSLogCategory_Default;
                              if (os_log_type_enabled(v620, OS_LOG_TYPE_DEFAULT))
                              {
                                v1118 = *(_DWORD *)(v76 + 192);
                                for (kk = v1223; ; kk = (sockaddr *)((char *)kk + v812 + 1))
                                {
                                  LOWORD(v622) = 257;
                                  if (kk >= (sockaddr *)v1237 || !kk)
                                    break;
                                  v812 = kk->sa_len;
                                  if (v812 > 0x3F)
                                  {
                                    LOWORD(v622) = 257;
                                    goto LABEL_1640;
                                  }
                                  if (!kk->sa_len)
                                  {
                                    v622 = (_DWORD)kk - v1223 + 1;
                                    goto LABEL_1640;
                                  }
                                }
                                goto LABEL_1640;
                              }
                            }
                            else
                            {
                              if (v616)
                                v620 = mDNSLogCategory_mDNS;
                              else
                                v620 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled(v620, OS_LOG_TYPE_DEFAULT))
                              {
                                v1118 = *(_DWORD *)(v76 + 192);
                                for (mm = v1223; ; mm = (sockaddr *)((char *)mm + v623 + 1))
                                {
                                  LOWORD(v622) = 257;
                                  if (mm >= (sockaddr *)v1237 || !mm)
                                    goto LABEL_1640;
                                  v623 = mm->sa_len;
                                  if (v623 > 0x3F)
                                  {
                                    LOWORD(v622) = 257;
                                    goto LABEL_1640;
                                  }
                                  if (!mm->sa_len)
                                    break;
                                }
                                v622 = (_DWORD)mm - v1223 + 1;
LABEL_1640:
                                v908 = (unsigned __int16)v622;
                                v909 = LOWORD(v1209.st_rdev);
                                v910 = *(_DWORD *)(v76 + 240);
                                v911 = *(_DWORD *)(v76 + 244);
                                v912 = *(_DWORD *)(v76 + 180);
                                v913 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                                __src[0] = 67111427;
                                __src[1] = v1118;
                                LOWORD(__src[2]) = 2160;
                                *(_QWORD *)((char *)&__src[2] + 2) = 1752392040;
                                HIWORD(__src[4]) = 1040;
                                __src[5] = v908;
                                LOWORD(__src[6]) = 2101;
                                *(_QWORD *)((char *)&__src[6] + 2) = v1223;
                                HIWORD(__src[8]) = 1024;
                                __src[9] = v909;
                                LOWORD(__src[10]) = 1024;
                                *(socklen_t *)((char *)&__src[10] + 2) = v910;
                                HIWORD(__src[11]) = 1024;
                                v1170[0] = v911;
                                LOWORD(v1170[1]) = 1024;
                                *(_DWORD *)((char *)&v1170[1] + 2) = v912;
                                HIWORD(v1170[2]) = 2082;
                                *(_QWORD *)&v1170[3] = v76 + 248;
                                LOWORD(v1170[5]) = 1024;
                                *(_DWORD *)((char *)&v1170[5] + 2) = v913;
                                v843 = v620;
                                v844 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder"
                                       ":domain_name}.*P, qtype: %{mdns:rrtype}d, DNSSEC enabled, flags: 0x%X, interface "
                                       "index: %d, client pid: %d (%{public}s), name hash: %x";
LABEL_1742:
                                v845 = 74;
LABEL_1743:
                                _os_log_impl((void *)&_mh_execute_header, v843, OS_LOG_TYPE_DEFAULT, v844, (uint8_t *)__src, v845);
                              }
                            }
LABEL_1744:
                            *(_QWORD *)(v76 + 104) = 0;
                            v998 = *(_UNKNOWN ****)(v76 + 56);
                            if (v998)
                            {
                              if (v998[2] == &_mdns_signed_browse_result_kind
                                && mdns_signed_browse_result_contains(*(_QWORD *)(v76 + 56), &v1223[0].sa_len, *(_DWORD *)(v76 + 244)))
                              {
                                v999 = mDNSLogCategory_Default;
                                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                                {
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                                    goto LABEL_1755;
                                }
                                else
                                {
                                  v999 = mDNSLogCategory_Default_redacted;
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                                  {
LABEL_1755:
                                    v1006 = *(_DWORD *)(v76 + 192);
                                    __src[0] = 67109120;
                                    __src[1] = v1006;
                                    _os_log_impl((void *)&_mh_execute_header, v999, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceQueryRecord: Allowing signed result", (uint8_t *)__src, 8u);
                                  }
                                }
LABEL_1756:
                                v778 = _handle_queryrecord_request_start(v76, (uint64_t)&v1209, v1000, v1001, v1002, v1003, v1004, v1005);
                                goto LABEL_1757;
                              }
                              *(_BYTE *)(v76 + 282) = 0;
                              os_release(v998);
                              *(_QWORD *)(v76 + 56) = 0;
                            }
                            if (_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy"))
                            {
                              v778 = _handle_queryrecord_request_with_trust(v76, (uint64_t)&v1209);
                              goto LABEL_1757;
                            }
                            goto LABEL_1756;
                          }
                          if (!gSensitiveLoggingEnabled
                            || (v616 ? (v819 = mDNSLogCategory_mDNS) : (v819 = mDNSLogCategory_Default),
                                v819 == mDNSLogCategory_State))
                          {
                            if (v616)
                              v820 = mDNSLogCategory_mDNS;
                            else
                              v820 = mDNSLogCategory_Default;
                            if (!os_log_type_enabled(v820, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1744;
                          }
                          else
                          {
                            if (v616)
                              v820 = mDNSLogCategory_mDNS;
                            else
                              v820 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled(v820, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1744;
                          }
                        }
                        v841 = *(_DWORD *)(v76 + 192);
                        v842 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                        __src[0] = 67109376;
                        __src[1] = v841;
                        LOWORD(__src[2]) = 1024;
                        *(socklen_t *)((char *)&__src[2] + 2) = v842;
                        v843 = v820;
                        v844 = "[R%u] DNSServiceQueryRecord START -- name hash: %x";
                        v845 = 14;
                        goto LABEL_1743;
                      }
                      v585 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                      }
                      else
                      {
                        v585 = mDNSLogCategory_Default_redacted;
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                          goto LABEL_1267;
                      }
                      __src[0] = 67109120;
                      __src[1] = v560;
                      v111 = (stat *)__src;
                      v112 = v585;
                      v113 = OS_LOG_TYPE_ERROR;
                      v114 = "[R%d] DNSServiceQueryRecord(unreadable parameters)";
LABEL_1070:
                      v633 = 8;
LABEL_1071:
                      _os_log_impl((void *)&_mh_execute_header, v112, v113, v114, (uint8_t *)v111, v633);
                      goto LABEL_1266;
                    }
                  }
                  v495 = p_st_size == (_BYTE *)v1220;
                  goto LABEL_917;
                case 9:
                  v170 = (unsigned __int16 *)read_rr_from_ipc_msg(v76, 0, 0);
                  updated = -65540;
                  if (!v170)
                    goto LABEL_1267;
                  v171 = v170;
                  v172 = (uint64_t)(v170 + 4);
                  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15873);
                  IdenticalRecordInCache = FindIdenticalRecordInCache((uint64_t)mDNSStorage, v172);
                  if (IdenticalRecordInCache)
                  {
                    mDNS_Reconfirm_internal((uint64_t)mDNSStorage, IdenticalRecordInCache, 0x1388u);
                    ReconfirmAntecedents((uint64_t)mDNSStorage, *(_BYTE **)(IdenticalRecordInCache + 40), *(_DWORD *)(IdenticalRecordInCache + 24), *(_QWORD *)(IdenticalRecordInCache + 32), 0);
                    updated = 0;
                  }
                  else
                  {
                    updated = -65541;
                  }
                  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15878);
                  v382 = requestShouldLogFullRequestInfo(v76);
                  v383 = (unsigned __int8 *)*((_QWORD *)v171 + 5);
                  v384 = gSensitiveLoggingEnabled;
                  v385 = mDNSLogCategory_mDNS;
                  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    v384 = 0;
                  if (IdenticalRecordInCache)
                  {
                    if (v382)
                    {
                      if (!v383)
                      {
                        if ((v384 & 1) != 0)
                        {
                          v484 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1140;
                          v485 = *(_DWORD *)(v76 + 192);
                          v486 = *(_DWORD *)(v76 + 180);
                          v488 = *(_DWORD *)(v76 + 240);
                          v487 = *(_DWORD *)(v76 + 244);
                          v489 = v171[6];
                          v1209.st_dev = 67111171;
                          *(_DWORD *)&v1209.st_mode = v485;
                          LOWORD(v1209.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                          HIWORD(v1209.st_uid) = 1040;
                          v1209.st_gid = 0;
                          LOWORD(v1209.st_rdev) = 2101;
                          *(_QWORD *)((char *)&v1209.st_rdev + 2) = 0;
                          WORD1(v1209.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1209.st_atimespec.tv_sec) = v489;
                          LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v488;
                          HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1209.st_mtimespec.tv_sec) = v487;
                          WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v486;
                          WORD1(v1209.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1209.st_mtimespec.tv_nsec + 4) = v76 + 248;
                          v412 = v484;
                          v413 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), ";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1140;
                          v536 = *(_DWORD *)(v76 + 192);
                          v537 = *(_DWORD *)(v76 + 180);
                          v539 = *(_DWORD *)(v76 + 240);
                          v538 = *(_DWORD *)(v76 + 244);
                          v540 = v171[6];
                          v1209.st_dev = 67111171;
                          *(_DWORD *)&v1209.st_mode = v536;
                          LOWORD(v1209.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                          HIWORD(v1209.st_uid) = 1040;
                          v1209.st_gid = 0;
                          LOWORD(v1209.st_rdev) = 2101;
                          *(_QWORD *)((char *)&v1209.st_rdev + 2) = 0;
                          WORD1(v1209.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1209.st_atimespec.tv_sec) = v540;
                          LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v539;
                          HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1209.st_mtimespec.tv_sec) = v538;
                          WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v537;
                          WORD1(v1209.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1209.st_mtimespec.tv_nsec + 4) = v76 + 248;
                          v412 = v385;
                          v413 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), ";
                        }
                        v541 = 68;
LABEL_1139:
                        _os_log_impl((void *)&_mh_execute_header, v412, OS_LOG_TYPE_DEFAULT, v413, (uint8_t *)&v1209, v541);
LABEL_1140:
                        v672 = v171;
                        goto LABEL_1141;
                      }
                      if ((v384 & 1) != 0)
                      {
                        v386 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v1100 = *(_DWORD *)(v76 + 192);
                        v387 = v383;
                        v1112 = v386;
                        if (v383 == (unsigned __int8 *)-256)
                        {
                          while (1)
                          {
LABEL_610:
                            if (!v387)
                              goto LABEL_1003;
                            v388 = *v387;
                            if (v388 > 0x3F)
                              goto LABEL_1003;
                            if (!*v387)
                              break;
                            v387 += v388 + 1;
                            if (v383 != (unsigned __int8 *)-256)
                              goto LABEL_609;
                          }
                          v594 = (_WORD)v387 - (_WORD)v383 + 1;
                        }
                        else
                        {
LABEL_609:
                          if (v387 < v383 + 256)
                            goto LABEL_610;
LABEL_1003:
                          v594 = 257;
                        }
                        v637 = v594;
                        v638 = v171[6];
                        v639 = *(_DWORD *)(v76 + 240);
                        v1088 = *(_DWORD *)(v76 + 244);
                        v640 = *(_DWORD *)(v76 + 180);
                        v641 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67111427;
                        *(_DWORD *)&v1209.st_mode = v1100;
                        LOWORD(v1209.st_ino) = 2160;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                        HIWORD(v1209.st_uid) = 1040;
                        v1209.st_gid = v637;
                        LOWORD(v1209.st_rdev) = 2101;
                        *(_QWORD *)((char *)&v1209.st_rdev + 2) = v383;
                        WORD1(v1209.st_atimespec.tv_sec) = 1024;
                        HIDWORD(v1209.st_atimespec.tv_sec) = v638;
                        LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v639;
                        HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1209.st_mtimespec.tv_sec) = v1088;
                        WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v640;
                        WORD1(v1209.st_mtimespec.tv_nsec) = 2082;
                        *(uint64_t *)((char *)&v1209.st_mtimespec.tv_nsec + 4) = v76 + 248;
                        WORD2(v1209.st_ctimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ctimespec.tv_sec + 6) = v641;
                        v412 = v1112;
                        v413 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder:d"
                               "omain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %"
                               "d (%{public}s), name hash: %x";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v1116 = *(_DWORD *)(v76 + 192);
                        v496 = v383;
                        if (v383 == (unsigned __int8 *)-256)
                        {
                          while (1)
                          {
LABEL_806:
                            if (!v496)
                              goto LABEL_1004;
                            v497 = *v496;
                            if (v497 > 0x3F)
                              goto LABEL_1004;
                            if (!*v496)
                              break;
                            v496 += v497 + 1;
                            if (v383 != (unsigned __int8 *)-256)
                              goto LABEL_805;
                          }
                          v595 = (_WORD)v496 - (_WORD)v383 + 1;
                        }
                        else
                        {
LABEL_805:
                          if (v496 < v383 + 256)
                            goto LABEL_806;
LABEL_1004:
                          v595 = 257;
                        }
                        v642 = v595;
                        v643 = v171[6];
                        v644 = *(_DWORD *)(v76 + 240);
                        v1097 = *(_DWORD *)(v76 + 244);
                        v1089 = *(_DWORD *)(v76 + 180);
                        v645 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67111427;
                        *(_DWORD *)&v1209.st_mode = v1116;
                        LOWORD(v1209.st_ino) = 2160;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                        HIWORD(v1209.st_uid) = 1040;
                        v1209.st_gid = v642;
                        LOWORD(v1209.st_rdev) = 2101;
                        *(_QWORD *)((char *)&v1209.st_rdev + 2) = v383;
                        WORD1(v1209.st_atimespec.tv_sec) = 1024;
                        HIDWORD(v1209.st_atimespec.tv_sec) = v643;
                        LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v644;
                        HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1209.st_mtimespec.tv_sec) = v1097;
                        WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v1089;
                        WORD1(v1209.st_mtimespec.tv_nsec) = 2082;
                        *(uint64_t *)((char *)&v1209.st_mtimespec.tv_nsec + 4) = v76 + 248;
                        WORD2(v1209.st_ctimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ctimespec.tv_sec + 6) = v645;
                        v412 = v385;
                        v413 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder:d"
                               "omain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %"
                               "d (%{public}s), name hash: %x";
                      }
LABEL_1085:
                      v541 = 74;
                      goto LABEL_1139;
                    }
                    if (v383)
                    {
                      if ((v384 & 1) != 0)
                      {
                        v409 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v410 = *(_DWORD *)(v76 + 192);
                        v411 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67109376;
                        *(_DWORD *)&v1209.st_mode = v410;
                        LOWORD(v1209.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ino + 2) = v411;
                        v412 = v409;
                        v413 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v534 = *(_DWORD *)(v76 + 192);
                        v535 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67109376;
                        *(_DWORD *)&v1209.st_mode = v534;
                        LOWORD(v1209.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ino + 2) = v535;
                        v412 = v385;
                        v413 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                      }
LABEL_997:
                      v541 = 14;
                      goto LABEL_1139;
                    }
                    if ((v384 & 1) != 0)
                    {
                      v529 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1140;
                      v530 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v530;
                      v412 = v529;
                      v413 = "[R%u] DNSServiceReconfirmRecord START -- ";
                    }
                    else
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1140;
                      v593 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v593;
                      v412 = v385;
                      v413 = "[R%u] DNSServiceReconfirmRecord START -- ";
                    }
                  }
                  else
                  {
                    if (v382)
                    {
                      if (v383)
                      {
                        if ((v384 & 1) != 0)
                        {
                          v397 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1140;
                          v1102 = *(_DWORD *)(v76 + 192);
                          v398 = v383;
                          v1114 = v397;
                          if (v383 == (unsigned __int8 *)-256)
                          {
                            while (1)
                            {
LABEL_637:
                              if (!v398)
                                goto LABEL_1054;
                              v399 = *v398;
                              if (v399 > 0x3F)
                                goto LABEL_1054;
                              if (!*v398)
                                break;
                              v398 += v399 + 1;
                              if (v383 != (unsigned __int8 *)-256)
                                goto LABEL_636;
                            }
                            v627 = (_WORD)v398 - (_WORD)v383 + 1;
                          }
                          else
                          {
LABEL_636:
                            if (v398 < v383 + 256)
                              goto LABEL_637;
LABEL_1054:
                            v627 = 257;
                          }
                          v663 = v627;
                          v664 = v171[6];
                          v665 = *(_DWORD *)(v76 + 240);
                          v1090 = *(_DWORD *)(v76 + 244);
                          v666 = *(_DWORD *)(v76 + 180);
                          v667 = mDNS_DomainNameFNV1aHash(v383);
                          v1209.st_dev = 67111683;
                          *(_DWORD *)&v1209.st_mode = v1102;
                          LOWORD(v1209.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                          HIWORD(v1209.st_uid) = 1040;
                          v1209.st_gid = v663;
                          LOWORD(v1209.st_rdev) = 2101;
                          *(_QWORD *)((char *)&v1209.st_rdev + 2) = v383;
                          WORD1(v1209.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1209.st_atimespec.tv_sec) = v664;
                          LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1209.st_mtimespec.tv_sec) = v665;
                          WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v1090;
                          WORD1(v1209.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1209.st_mtimespec.tv_nsec) = v666;
                          LOWORD(v1209.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1209.st_ctimespec.tv_sec + 2) = v76 + 248;
                          WORD1(v1209.st_ctimespec.tv_nsec) = 1024;
                          HIDWORD(v1209.st_ctimespec.tv_nsec) = v667;
                          v412 = v1114;
                          v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), name hash: %x";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1140;
                          v1117 = *(_DWORD *)(v76 + 192);
                          v532 = v383;
                          if (v383 == (unsigned __int8 *)-256)
                          {
                            while (1)
                            {
LABEL_881:
                              if (!v532)
                                goto LABEL_1055;
                              v533 = *v532;
                              if (v533 > 0x3F)
                                goto LABEL_1055;
                              if (!*v532)
                                break;
                              v532 += v533 + 1;
                              if (v383 != (unsigned __int8 *)-256)
                                goto LABEL_880;
                            }
                            v628 = (_WORD)v532 - (_WORD)v383 + 1;
                          }
                          else
                          {
LABEL_880:
                            if (v532 < v383 + 256)
                              goto LABEL_881;
LABEL_1055:
                            v628 = 257;
                          }
                          v668 = v628;
                          v669 = v171[6];
                          v670 = *(_DWORD *)(v76 + 240);
                          v1098 = *(_DWORD *)(v76 + 244);
                          v1091 = *(_DWORD *)(v76 + 180);
                          v671 = mDNS_DomainNameFNV1aHash(v383);
                          v1209.st_dev = 67111683;
                          *(_DWORD *)&v1209.st_mode = v1117;
                          LOWORD(v1209.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                          HIWORD(v1209.st_uid) = 1040;
                          v1209.st_gid = v668;
                          LOWORD(v1209.st_rdev) = 2101;
                          *(_QWORD *)((char *)&v1209.st_rdev + 2) = v383;
                          WORD1(v1209.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1209.st_atimespec.tv_sec) = v669;
                          LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1209.st_mtimespec.tv_sec) = v670;
                          WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v1098;
                          WORD1(v1209.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1209.st_mtimespec.tv_nsec) = v1091;
                          LOWORD(v1209.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1209.st_ctimespec.tv_sec + 2) = v76 + 248;
                          WORD1(v1209.st_ctimespec.tv_nsec) = 1024;
                          HIDWORD(v1209.st_ctimespec.tv_nsec) = v671;
                          v412 = v385;
                          v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), name hash: %x";
                        }
                        v541 = 80;
                        goto LABEL_1139;
                      }
                      if ((v384 & 1) != 0)
                      {
                        v523 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v524 = *(_DWORD *)(v76 + 192);
                        v525 = *(_DWORD *)(v76 + 180);
                        v527 = *(_DWORD *)(v76 + 240);
                        v526 = *(_DWORD *)(v76 + 244);
                        v528 = v171[6];
                        v1209.st_dev = 67111427;
                        *(_DWORD *)&v1209.st_mode = v524;
                        LOWORD(v1209.st_ino) = 2160;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                        HIWORD(v1209.st_uid) = 1040;
                        v1209.st_gid = 0;
                        LOWORD(v1209.st_rdev) = 2101;
                        *(_QWORD *)((char *)&v1209.st_rdev + 2) = 0;
                        WORD1(v1209.st_atimespec.tv_sec) = 1024;
                        HIDWORD(v1209.st_atimespec.tv_sec) = v528;
                        LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = updated;
                        HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1209.st_mtimespec.tv_sec) = v527;
                        WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v526;
                        WORD1(v1209.st_mtimespec.tv_nsec) = 1024;
                        HIDWORD(v1209.st_mtimespec.tv_nsec) = v525;
                        LOWORD(v1209.st_ctimespec.tv_sec) = 2082;
                        *(__darwin_time_t *)((char *)&v1209.st_ctimespec.tv_sec + 2) = v76 + 248;
                        v412 = v523;
                        v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponder:"
                               "domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %d, c"
                               "lient pid: %d (%{public}s), ";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v588 = *(_DWORD *)(v76 + 192);
                        v589 = *(_DWORD *)(v76 + 180);
                        v591 = *(_DWORD *)(v76 + 240);
                        v590 = *(_DWORD *)(v76 + 244);
                        v592 = v171[6];
                        v1209.st_dev = 67111427;
                        *(_DWORD *)&v1209.st_mode = v588;
                        LOWORD(v1209.st_ino) = 2160;
                        *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                        HIWORD(v1209.st_uid) = 1040;
                        v1209.st_gid = 0;
                        LOWORD(v1209.st_rdev) = 2101;
                        *(_QWORD *)((char *)&v1209.st_rdev + 2) = 0;
                        WORD1(v1209.st_atimespec.tv_sec) = 1024;
                        HIDWORD(v1209.st_atimespec.tv_sec) = v592;
                        LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = updated;
                        HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1209.st_mtimespec.tv_sec) = v591;
                        WORD2(v1209.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v590;
                        WORD1(v1209.st_mtimespec.tv_nsec) = 1024;
                        HIDWORD(v1209.st_mtimespec.tv_nsec) = v589;
                        LOWORD(v1209.st_ctimespec.tv_sec) = 2082;
                        *(__darwin_time_t *)((char *)&v1209.st_ctimespec.tv_sec + 2) = v76 + 248;
                        v412 = v385;
                        v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponder:"
                               "domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %d, c"
                               "lient pid: %d (%{public}s), ";
                      }
                      goto LABEL_1085;
                    }
                    if (v383)
                    {
                      if ((v384 & 1) != 0)
                      {
                        v492 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v493 = *(_DWORD *)(v76 + 192);
                        v494 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67109376;
                        *(_DWORD *)&v1209.st_mode = v493;
                        LOWORD(v1209.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ino + 2) = v494;
                        v412 = v492;
                        v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1140;
                        v586 = *(_DWORD *)(v76 + 192);
                        v587 = mDNS_DomainNameFNV1aHash(v383);
                        v1209.st_dev = 67109376;
                        *(_DWORD *)&v1209.st_mode = v586;
                        LOWORD(v1209.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1209.st_ino + 2) = v587;
                        v412 = v385;
                        v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                      }
                      goto LABEL_997;
                    }
                    if ((v384 & 1) != 0)
                    {
                      v577 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1140;
                      v578 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v578;
                      v412 = v577;
                      v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                    }
                    else
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_1140;
                      v626 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v626;
                      v412 = v385;
                      v413 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                    }
                  }
                  v541 = 8;
                  goto LABEL_1139;
                case 10:
                  v174 = 0;
                  v175 = 0;
                  v177 = *(_QWORD *)(v76 + 80);
                  v176 = *(_QWORD *)(v76 + 88);
                  if (v177)
                  {
                    v178 = 0;
                    v179 = 0;
                    if (v177 + 4 > v176)
                      goto LABEL_509;
                    v174 = 0;
                    v175 = 0;
                    v180 = v177 + 6;
                    v178 = bswap32(*(_DWORD *)v177);
                    *(_QWORD *)(v76 + 80) = v177 + 4;
                    if (v177 != -4 && v180 <= v176)
                    {
                      v179 = 0;
                      v174 = 0;
                      v175 = bswap32(*(unsigned __int16 *)(v177 + 4)) >> 16;
                      *(_QWORD *)(v76 + 80) = v180;
                      if (v177 != -6 && v177 + 8 <= v176)
                      {
                        v179 = bswap32(*(unsigned __int16 *)(v177 + 6)) >> 16;
                        v174 = (unsigned __int8 *)(v177 + 8);
                      }
LABEL_509:
                      v330 = (unsigned int *)&v174[v179];
                      if (v174)
                        v331 = (unint64_t)v330 > v176;
                      else
                        v331 = 1;
                      if (v331)
                      {
                        v330 = 0;
                        v333 = 0;
                      }
                      else
                      {
                        v333 = v174;
                      }
                      *(_QWORD *)(v76 + 80) = v330;
                      if (v330 && (v334 = v330 + 1, (unint64_t)(v330 + 1) <= v176))
                      {
                        v335 = bswap32(*v330);
                        *(_QWORD *)(v76 + 80) = v334;
                        if (v335)
                        {
                          if (v330 != (unsigned int *)-4)
                            goto LABEL_522;
                          goto LABEL_531;
                        }
                      }
                      else
                      {
                        v334 = 0;
                        *(_QWORD *)(v76 + 80) = 0;
                      }
                      v335 = 4500;
                      if (v334)
                      {
LABEL_522:
                        v336 = *(void (**)(uint64_t))(v76 + 104);
                        v337 = v76;
                        if (v336 == connection_termination)
                        {
                          v337 = LocateSubordinateRequest(v76);
                          v336 = *(void (**)(uint64_t))(v337 + 104);
                        }
                        if ((char *)v336 != (char *)regservice_termination_callback)
                        {
                          v338 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                          }
                          else
                          {
                            v338 = mDNSLogCategory_mDNS_redacted;
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                          }
                          v339 = *(_DWORD *)(v337 + 192);
                          v1209.st_dev = 67109120;
                          *(_DWORD *)&v1209.st_mode = v339;
                          v111 = &v1209;
                          v112 = v338;
                          v113 = OS_LOG_TYPE_DEFAULT;
                          v114 = "[R%d] DNSServiceAddRecord(not a registered service ref)";
                          goto LABEL_1070;
                        }
                        v389 = gSensitiveLoggingEnabled;
                        v390 = mDNSLogCategory_mDNS;
                        if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          v389 = 0;
                        if (!*(_WORD *)(*(_QWORD *)(v337 + 120) + 24))
                        {
                          if ((v389 & 1) != 0)
                          {
                            v490 = mDNSLogCategory_mDNS_redacted;
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                            v491 = *(_DWORD *)(v337 + 192);
                            v1209.st_dev = 67109120;
                            *(_DWORD *)&v1209.st_mode = v491;
                            v111 = &v1209;
                            v112 = v490;
                            v113 = OS_LOG_TYPE_DEFAULT;
                            v114 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                          }
                          else
                          {
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                            v556 = *(_DWORD *)(v337 + 192);
                            v1209.st_dev = 67109120;
                            *(_DWORD *)&v1209.st_mode = v556;
                            v111 = &v1209;
                            v112 = v390;
                            v113 = OS_LOG_TYPE_DEFAULT;
                            v114 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                          }
                          goto LABEL_1070;
                        }
                        v1113 = *(_QWORD *)(v337 + 120);
                        if ((v389 & 1) != 0)
                        {
                          v391 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
                            v392 = *(_QWORD *)(v1113 + 1624);
                            v1101 = v391;
                            if (v392)
                            {
                              v393 = *(_QWORD *)(v392 + 2736);
                              if (v393)
                              {
                                v394 = *(_BYTE **)(v392 + 2736);
                                if (v393 == -256)
                                  goto LABEL_626;
LABEL_623:
                                v395 = 257;
                                if ((unint64_t)v394 < v393 + 256 && v394)
                                {
                                  while (1)
                                  {
                                    v396 = *v394;
                                    if (v396 > 0x3F)
                                    {
LABEL_1229:
                                      v395 = 257;
                                      goto LABEL_1362;
                                    }
                                    if (!*v394)
                                      break;
                                    v394 += v396 + 1;
                                    if (v393 != -256)
                                      goto LABEL_623;
LABEL_626:
                                    if (!v394)
                                      goto LABEL_1229;
                                  }
                                  v395 = (_WORD)v394 - v393 + 1;
                                }
LABEL_1362:
                                v654 = v395;
                              }
                              else
                              {
                                v654 = 0;
                              }
                              v1086 = v654;
                              v1095 = v393;
                            }
                            else
                            {
                              v1086 = 0;
                              v1095 = 0;
                            }
                            v771 = *(_DWORD *)(v337 + 192);
                            v772 = DNSTypeName(v175);
                            v773 = *(_DWORD *)(v337 + 180);
                            v1209.st_dev = 67111171;
                            *(_DWORD *)&v1209.st_mode = v771;
                            LOWORD(v1209.st_ino) = 1024;
                            *(_DWORD *)((char *)&v1209.st_ino + 2) = v178;
                            HIWORD(v1209.st_ino) = 2160;
                            *(_QWORD *)&v1209.st_uid = 1752392040;
                            LOWORD(v1209.st_rdev) = 1040;
                            *(dev_t *)((char *)&v1209.st_rdev + 2) = v1086;
                            *((_WORD *)&v1209.st_rdev + 3) = 2101;
                            v774 = v1101;
                            v1209.st_atimespec.tv_sec = v1095;
                            LOWORD(v1209.st_atimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1209.st_atimespec.tv_nsec + 2) = (uint64_t)v772;
                            WORD1(v1209.st_mtimespec.tv_sec) = 1024;
                            HIDWORD(v1209.st_mtimespec.tv_sec) = v179;
                            LOWORD(v1209.st_mtimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1209.st_mtimespec.tv_nsec + 2) = v773;
                            HIWORD(v1209.st_mtimespec.tv_nsec) = 2082;
                            v1209.st_ctimespec.tv_sec = v337 + 248;
LABEL_1369:
                            _os_log_impl((void *)&_mh_execute_header, v774, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceAddRecord(%X, %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{public}s, %d) PID[%d](%{public}s)", (uint8_t *)&v1209, 0x48u);
                          }
                        }
                        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          v516 = *(_QWORD *)(v1113 + 1624);
                          if (v516)
                          {
                            v517 = *(_QWORD *)(v516 + 2736);
                            if (v517)
                            {
                              v518 = *(_BYTE **)(v516 + 2736);
                              if (v517 == -256)
                                goto LABEL_859;
LABEL_856:
                              v519 = 257;
                              if ((unint64_t)v518 < v517 + 256 && v518)
                              {
                                while (1)
                                {
                                  v520 = *v518;
                                  if (v520 > 0x3F)
                                  {
LABEL_1230:
                                    v519 = 257;
                                    goto LABEL_1366;
                                  }
                                  if (!*v518)
                                    break;
                                  v518 += v520 + 1;
                                  if (v517 != -256)
                                    goto LABEL_856;
LABEL_859:
                                  if (!v518)
                                    goto LABEL_1230;
                                }
                                v519 = (_WORD)v518 - v517 + 1;
                              }
LABEL_1366:
                              v655 = v519;
                            }
                            else
                            {
                              v655 = 0;
                            }
                            v1087 = v655;
                            v1096 = v517;
                          }
                          else
                          {
                            v1087 = 0;
                            v1096 = 0;
                          }
                          v1105 = *(_DWORD *)(v337 + 192);
                          v775 = DNSTypeName(v175);
                          v776 = *(_DWORD *)(v337 + 180);
                          v1209.st_dev = 67111171;
                          *(_DWORD *)&v1209.st_mode = v1105;
                          LOWORD(v1209.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1209.st_ino + 2) = v178;
                          HIWORD(v1209.st_ino) = 2160;
                          *(_QWORD *)&v1209.st_uid = 1752392040;
                          LOWORD(v1209.st_rdev) = 1040;
                          *(dev_t *)((char *)&v1209.st_rdev + 2) = v1087;
                          *((_WORD *)&v1209.st_rdev + 3) = 2101;
                          v1209.st_atimespec.tv_sec = v1096;
                          LOWORD(v1209.st_atimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1209.st_atimespec.tv_nsec + 2) = (uint64_t)v775;
                          WORD1(v1209.st_mtimespec.tv_sec) = 1024;
                          HIDWORD(v1209.st_mtimespec.tv_sec) = v179;
                          LOWORD(v1209.st_mtimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1209.st_mtimespec.tv_nsec + 2) = v776;
                          HIWORD(v1209.st_mtimespec.tv_nsec) = 2082;
                          v1209.st_ctimespec.tv_sec = v337 + 248;
                          v774 = v390;
                          goto LABEL_1369;
                        }
                        v777 = *(_QWORD *)(v1113 + 1624);
                        if (!v777)
                        {
                          updated = -65537;
                          goto LABEL_1267;
                        }
                        while (1)
                        {
                          v778 = add_record_to_service(v337, v777, v175, v179, v333, v335);
                          if (v778)
                          {
                            if (*(_BYTE *)(v777 + 26))
                              goto LABEL_1757;
                          }
                          updated = 0;
                          v777 = *(_QWORD *)v777;
                          if (!v777)
                            goto LABEL_1267;
                        }
                      }
LABEL_531:
                      v340 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                      }
                      else
                      {
                        v340 = mDNSLogCategory_mDNS_redacted;
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1267;
                      }
                      v341 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109120;
                      *(_DWORD *)&v1209.st_mode = v341;
                      v111 = &v1209;
                      v112 = v340;
                      v113 = OS_LOG_TYPE_DEFAULT;
                      v114 = "[R%d] DNSServiceAddRecord(unreadable parameters)";
                      goto LABEL_1070;
                    }
                  }
                  else
                  {
                    v178 = 0;
                  }
                  v179 = 0;
                  goto LABEL_509;
                case 11:
                  v181 = 0;
                  v182 = 0;
                  v184 = *(_QWORD *)(v76 + 80);
                  v183 = *(_QWORD *)(v76 + 88);
                  if (v184)
                  {
                    if (v184 + 4 <= v183)
                    {
                      v181 = 0;
                      v182 = 0;
                      *(_QWORD *)(v76 + 80) = v184 + 4;
                      if (v184 != -4 && v184 + 6 <= v183)
                      {
                        v181 = bswap32(*(unsigned __int16 *)(v184 + 4)) >> 16;
                        v182 = (char *)(v184 + 6);
                      }
                    }
                  }
                  v185 = (unsigned int *)&v182[v181];
                  if (v182)
                    v186 = (unint64_t)v185 > v183;
                  else
                    v186 = 1;
                  if (v186)
                  {
                    v185 = 0;
                    v188 = 0;
                  }
                  else
                  {
                    v188 = v182;
                  }
                  *(_QWORD *)(v76 + 80) = v185;
                  if (v185 && (unint64_t)(v185 + 1) <= v183)
                  {
                    v189 = *v185;
                    *(_QWORD *)(v76 + 80) = v185 + 1;
                    if (v185 != (unsigned int *)-4)
                    {
                      *(_DWORD *)&v1223[0].sa_len = 0;
                      __src[0] = 0;
                      v1110 = get_service_attr_tsr_params(v76, (int *)v1223, __src);
                      if (!v1110)
                        goto LABEL_755;
                      v190 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_755;
                      }
                      else
                      {
                        v190 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_755;
                      }
                      v467 = *(_DWORD *)(v76 + 192);
                      v1209.st_dev = 67109632;
                      *(_DWORD *)&v1209.st_mode = v467;
                      LOWORD(v1209.st_ino) = 1024;
                      *(_DWORD *)((char *)&v1209.st_ino + 2) = *(_DWORD *)&v1223[0].sa_len;
                      HIWORD(v1209.st_ino) = 1024;
                      v1209.st_uid = __src[0];
                      _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceUpdateRecord foundTSRParams tsrTimestamp[%u] hostkeyHash[%x]", (uint8_t *)&v1209, 0x14u);
LABEL_755:
                      v468 = bswap32(v189);
                      v470 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v76 + 104);
                      v469 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v76 + 104);
                      if ((char *)v469 != (char *)connection_termination)
                      {
                        v471 = v76;
LABEL_758:
                        if (v469 != regservice_termination_callback)
                        {
                          v473 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                          {
                            v473 = mDNSLogCategory_mDNS_redacted;
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
LABEL_762:
                            v474 = *(_DWORD *)(v471 + 192);
                            v1209.st_dev = 67109120;
                            *(_DWORD *)&v1209.st_mode = v474;
                            v111 = &v1209;
                            v112 = v473;
                            v113 = OS_LOG_TYPE_DEFAULT;
                            v114 = "[R%d] DNSServiceUpdateRecord(not a registered service ref)";
                            goto LABEL_1070;
                          }
                          updated = -65540;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_762;
                          goto LABEL_1267;
                        }
                        v475 = *(_QWORD *)(v471 + 120);
                        if (!*(_WORD *)(v475 + 24))
                        {
                          v574 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                          }
                          else
                          {
                            v574 = mDNSLogCategory_mDNS_redacted;
                            updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1267;
                          }
                          v575 = *(_DWORD *)(v471 + 192);
                          v1209.st_dev = 67109120;
                          *(_DWORD *)&v1209.st_mode = v575;
                          v111 = &v1209;
                          v112 = v574;
                          v113 = OS_LOG_TYPE_DEFAULT;
                          v114 = "[R%d] DNSServiceUpdateRecord: updating the record of a service registered with zero port";
                          goto LABEL_1070;
                        }
                        if (!v1110 && *(_DWORD *)(v76 + 232) == -1)
                        {
                          v476 = *(void **)(v475 + 16);
                          if (v476)
                          {
                            free(v476);
                            *(_QWORD *)(v475 + 16) = 0;
                          }
                          if ((_DWORD)v181)
                          {
                            v477 = malloc_type_malloc(v181, 0xA172743EuLL);
                            if (!v477)
                              goto LABEL_1918;
                            *(_QWORD *)(v475 + 16) = v477;
                            memcpy(v477, v188, v181);
                          }
                          *(_WORD *)(v475 + 8) = v181;
                        }
                        v1103 = v470;
                        v478 = v471;
                        v479 = *(uint64_t **)(v475 + 1624);
                        updated = -65541;
                        v480 = 0;
                        if (v479)
                        {
                          while (1)
                          {
                            v481 = *(_DWORD *)(v76 + 232);
                            if (v481 == -1)
                            {
                              v480 = (uint64_t)(v479 + 484);
                            }
                            else
                            {
                              v482 = v479 + 39;
                              while (1)
                              {
                                v482 = (uint64_t *)*v482;
                                if (!v482)
                                  break;
                                if (*((_DWORD *)v482 + 2) == v481)
                                {
                                  v480 = (uint64_t)(v482 + 2);
                                  goto LABEL_780;
                                }
                              }
                              if (!v480)
                                goto LABEL_1112;
                            }
LABEL_780:
                            if (v1110)
                              break;
                            v483 = update_record(v480, v181, (unsigned __int8 *)v188, v468, (uint64_t)v479 + 27, *(_DWORD *)(v478 + 192));
                            if (v483 && *((_BYTE *)v479 + 26))
                            {
                              updated = v483;
                              goto LABEL_1112;
                            }
                            v479 = (uint64_t *)*v479;
                            if (!v479)
                            {
                              updated = 0;
                              goto LABEL_1112;
                            }
                          }
                          v471 = v478;
                          updated = handle_tsr_update_request(v478, v480, *(unsigned int *)&v1223[0].sa_len, __src[0]);
                        }
                        else
                        {
LABEL_1112:
                          v471 = v478;
                        }
                        v470 = v1103;
LABEL_1114:
                        if (*v470 != regservice_termination_callback)
                          goto LABEL_1267;
                        v656 = *(_QWORD *)(*(_QWORD *)(v471 + 120) + 1624);
                        if (v656)
                        {
                          v657 = *(_BYTE **)(v656 + 2736);
                          if (v657)
                          {
                            v658 = -2128831035;
                            v659 = *(_BYTE **)(v656 + 2736);
                            if (v657 == (_BYTE *)-256)
                              goto LABEL_1121;
LABEL_1118:
                            v660 = 257;
                            if (v659 < v657 + 256 && v659)
                            {
                              do
                              {
                                v661 = *v659;
                                if (v661 > 0x3F)
                                  break;
                                if (!*v659)
                                {
                                  v660 = (unsigned __int16)((_WORD)v659 - (_WORD)v657 + 1);
                                  if ((_WORD)v659 - (_WORD)v657 != 0xFFFF)
                                    goto LABEL_1316;
LABEL_1318:
                                  v662 = 0;
LABEL_1319:
                                  if (v480)
                                    LODWORD(v480) = *(unsigned __int16 *)(v480 + 12);
                                  v756 = mDNSLogCategory_mDNS;
                                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                                  {
                                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                      goto LABEL_1267;
                                    if ((v662 & 1) != 0)
                                    {
                                      v758 = 0;
                                    }
                                    else
                                    {
                                      v760 = v657;
                                      if (v657 == (_BYTE *)-256)
                                        goto LABEL_1336;
LABEL_1333:
                                      v761 = 257;
                                      if (v760 < v657 + 256 && v760)
                                      {
                                        while (1)
                                        {
                                          v762 = *v760;
                                          if (v762 > 0x3F)
                                          {
LABEL_1456:
                                            v761 = 257;
                                            goto LABEL_1495;
                                          }
                                          if (!*v760)
                                            break;
                                          v760 += v762 + 1;
                                          if (v657 != (_BYTE *)-256)
                                            goto LABEL_1333;
LABEL_1336:
                                          if (!v760)
                                            goto LABEL_1456;
                                        }
                                        v761 = (_WORD)v760 - (_WORD)v657 + 1;
                                      }
LABEL_1495:
                                      v758 = v761;
                                    }
                                  }
                                  else
                                  {
                                    v756 = mDNSLogCategory_mDNS_redacted;
                                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1267;
                                    if ((v662 & 1) != 0)
                                    {
                                      v758 = 0;
                                    }
                                    else
                                    {
                                      v763 = v657;
                                      if (v657 == (_BYTE *)-256)
                                        goto LABEL_1345;
LABEL_1342:
                                      v764 = 257;
                                      if (v763 < v657 + 256 && v763)
                                      {
                                        while (1)
                                        {
                                          v765 = *v763;
                                          if (v765 > 0x3F)
                                          {
LABEL_1457:
                                            v764 = 257;
                                            goto LABEL_1497;
                                          }
                                          if (!*v763)
                                            break;
                                          v763 += v765 + 1;
                                          if (v657 != (_BYTE *)-256)
                                            goto LABEL_1342;
LABEL_1345:
                                          if (!v763)
                                            goto LABEL_1457;
                                        }
                                        v764 = (_WORD)v763 - (_WORD)v657 + 1;
                                      }
LABEL_1497:
                                      v758 = v764;
                                    }
                                  }
                                  v822 = *(_DWORD *)(v471 + 192);
                                  v823 = *(_DWORD *)(v471 + 180);
                                  v1209.st_dev = 67110915;
                                  *(_DWORD *)&v1209.st_mode = v822;
                                  LOWORD(v1209.st_ino) = 2160;
                                  *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                                  HIWORD(v1209.st_uid) = 1040;
                                  v1209.st_gid = v758;
                                  LOWORD(v1209.st_rdev) = 2101;
                                  *(_QWORD *)((char *)&v1209.st_rdev + 2) = v657;
                                  WORD1(v1209.st_atimespec.tv_sec) = 1024;
                                  HIDWORD(v1209.st_atimespec.tv_sec) = v658;
                                  LOWORD(v1209.st_atimespec.tv_nsec) = 1024;
                                  *(_DWORD *)((char *)&v1209.st_atimespec.tv_nsec + 2) = v480;
                                  HIWORD(v1209.st_atimespec.tv_nsec) = 1024;
                                  LODWORD(v1209.st_mtimespec.tv_sec) = v823;
                                  WORD2(v1209.st_mtimespec.tv_sec) = 2080;
                                  *(__darwin_time_t *)((char *)&v1209.st_mtimespec.tv_sec + 6) = v471 + 248;
                                  v719 = (uint8_t *)&v1209;
                                  v720 = v756;
                                  v721 = OS_LOG_TYPE_DEFAULT;
                                  v722 = "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}"
                                         ".*P (%x), %{mdns:rrtype}d) UPDATE PID[%d](%s)";
                                  v723 = 62;
                                  goto LABEL_1499;
                                }
                                v659 += v661 + 1;
                                if (v657 != (_BYTE *)-256)
                                  goto LABEL_1118;
LABEL_1121:
                                ;
                              }
                              while (v659);
                              v660 = 257;
                            }
LABEL_1316:
                            v755 = 0;
                            do
                              v658 = 16777619 * (v658 ^ v657[v755++]);
                            while (v660 != v755);
                            goto LABEL_1318;
                          }
                        }
                        else
                        {
                          v657 = 0;
                        }
                        v658 = 0;
                        v662 = 1;
                        goto LABEL_1319;
                      }
                      v472 = LocateSubordinateRequest(v76);
                      v471 = v472;
                      v470 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v472 + 104);
                      v469 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v472 + 104);
                      if ((char *)v469 != (char *)connection_termination)
                        goto LABEL_758;
                      v480 = *(_QWORD *)(v472 + 168);
                      updated = -65541;
                      if (!v480)
                        goto LABEL_1114;
                      while (*(_DWORD *)(v480 + 16) != *(_DWORD *)(v76 + 232))
                      {
                        v480 = *(_QWORD *)(v480 + 8);
                        if (!v480)
                          goto LABEL_1114;
                      }
                      v634 = *(_QWORD *)(v480 + 56);
                      if (v1110)
                        v635 = handle_tsr_update_request(v472, v634, *(unsigned int *)&v1223[0].sa_len, __src[0]);
                      else
                        v635 = update_record(v634, v181, (unsigned __int8 *)v188, v468, v480 + 40, *(_DWORD *)(v472 + 192));
                      updated = v635;
                      v745 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1625:
                          v480 = 0;
                          goto LABEL_1114;
                        }
                        v747 = *(_QWORD *)(v480 + 56);
                        v748 = *(_QWORD *)(v747 + 40);
                        if (v748)
                        {
                          v749 = *(_BYTE **)(v747 + 40);
                          if (v748 == -256)
                          {
                            while (1)
                            {
LABEL_1301:
                              if (!v749)
                                goto LABEL_1527;
                              v750 = *v749;
                              if (v750 > 0x3F)
                                goto LABEL_1527;
                              if (!*v749)
                                break;
                              v749 += v750 + 1;
                              if (v748 != -256)
                                goto LABEL_1300;
                            }
                            v839 = (_WORD)v749 - v748 + 1;
                          }
                          else
                          {
LABEL_1300:
                            if ((unint64_t)v749 < v748 + 256)
                              goto LABEL_1301;
LABEL_1527:
                            v839 = 257;
                          }
                          v866 = v839;
                        }
                        else
                        {
                          v866 = 0;
                        }
                        v896 = *(_DWORD *)(v471 + 192);
                        v897 = DNSTypeName(*(unsigned __int16 *)(v747 + 12));
                        v898 = *(_DWORD *)(v471 + 180);
                        v899 = " & TSR";
                        if (!v1110)
                          v899 = "";
                      }
                      else
                      {
                        v745 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1625;
                        v752 = *(_QWORD *)(v480 + 56);
                        v748 = *(_QWORD *)(v752 + 40);
                        if (v748)
                        {
                          v753 = *(_BYTE **)(v752 + 40);
                          if (v748 == -256)
                          {
                            while (1)
                            {
LABEL_1310:
                              if (!v753)
                                goto LABEL_1528;
                              v754 = *v753;
                              if (v754 > 0x3F)
                                goto LABEL_1528;
                              if (!*v753)
                                break;
                              v753 += v754 + 1;
                              if (v748 != -256)
                                goto LABEL_1309;
                            }
                            v840 = (_WORD)v753 - v748 + 1;
                          }
                          else
                          {
LABEL_1309:
                            if ((unint64_t)v753 < v748 + 256)
                              goto LABEL_1310;
LABEL_1528:
                            v840 = 257;
                          }
                          v866 = v840;
                        }
                        else
                        {
                          v866 = 0;
                        }
                        v896 = *(_DWORD *)(v471 + 192);
                        v897 = DNSTypeName(*(unsigned __int16 *)(v752 + 12));
                        v898 = *(_DWORD *)(v471 + 180);
                        v899 = " & TSR";
                        if (!v1110)
                          v899 = "";
                      }
                      v1209.st_dev = 67110915;
                      *(_DWORD *)&v1209.st_mode = v896;
                      LOWORD(v1209.st_ino) = 2160;
                      *(__darwin_ino64_t *)((char *)&v1209.st_ino + 2) = 1752392040;
                      HIWORD(v1209.st_uid) = 1040;
                      v1209.st_gid = v866;
                      LOWORD(v1209.st_rdev) = 2101;
                      *(_QWORD *)((char *)&v1209.st_rdev + 2) = v748;
                      WORD1(v1209.st_atimespec.tv_sec) = 2082;
                      *(__darwin_time_t *)((char *)&v1209.st_atimespec.tv_sec + 4) = (__darwin_time_t)v897;
                      WORD2(v1209.st_atimespec.tv_nsec) = 2082;
                      *(uint64_t *)((char *)&v1209.st_atimespec.tv_nsec + 6) = (uint64_t)v899;
                      HIWORD(v1209.st_mtimespec.tv_sec) = 1024;
                      LODWORD(v1209.st_mtimespec.tv_nsec) = v898;
                      WORD2(v1209.st_mtimespec.tv_nsec) = 2082;
                      *(uint64_t *)((char *)&v1209.st_mtimespec.tv_nsec + 6) = v471 + 248;
                      _os_log_impl((void *)&_mh_execute_header, v745, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{public}s%{public}s) PID[%d](%{public}s)", (uint8_t *)&v1209, 0x46u);
                      goto LABEL_1625;
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  v287 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                  {
                    v287 = mDNSLogCategory_mDNS_redacted;
                    updated = -65540;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1267;
LABEL_441:
                    v288 = *(_DWORD *)(v76 + 192);
                    v1209.st_dev = 67109120;
                    *(_DWORD *)&v1209.st_mode = v288;
                    v111 = &v1209;
                    v112 = v287;
                    v113 = OS_LOG_TYPE_DEFAULT;
                    v114 = "[R%d] DNSServiceUpdateRecord(unreadable parameters)";
                    goto LABEL_1070;
                  }
                  updated = -65540;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_441;
                  goto LABEL_1267;
                case 12:
                  bzero(&v1209, 0x3F1uLL);
                  v1235 = 0u;
                  v1236 = 0u;
                  v1233 = 0u;
                  v1234 = 0u;
                  v1231 = 0u;
                  v1232 = 0u;
                  v1229 = 0u;
                  v1230 = 0u;
                  v1228 = 0u;
                  v1226 = 0u;
                  memset(v1227, 0, sizeof(v1227));
                  v1224 = 0u;
                  v1225 = 0u;
                  memset(v1223, 0, sizeof(v1223));
                  v192 = *(_QWORD *)(v76 + 80);
                  if (v192 && (v193 = *(_QWORD *)(v76 + 88), v194 = v192 + 4, v194 <= v193))
                  {
                    *(_QWORD *)(v76 + 80) = v194;
                    if (!v194)
                      goto LABEL_443;
                    v195 = &v1209;
                    while (1)
                    {
                      v196 = *(unsigned __int8 **)(v76 + 80);
                      if ((unint64_t)v196 >= v193 || v195 >= (stat *)v1218)
                        break;
                      *(_QWORD *)(v76 + 80) = v196 + 1;
                      v198 = *v196;
                      LOBYTE(v195->st_dev) = v198;
                      v195 = (stat *)((char *)v195 + 1);
                      if (!v198)
                      {
                        v1223[0].sa_len = 0;
                        if (!AppendDNSNameString(v1223, (unsigned __int8 *)&v1209, v191, a4, a5, a6, a7, a8))
                          goto LABEL_444;
                        if (mDNS_LoggingEnabled == 1)
                        {
                          v1078 = v1223;
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceSetDefaultDomainForUser(%##s)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                        }
                        goto LABEL_662;
                      }
                    }
                    *((_BYTE *)&v195->st_dev - (v195 == (stat *)v1218)) = 0;
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  else
                  {
                    *(_QWORD *)(v76 + 80) = 0;
LABEL_443:
                    LOBYTE(v1209.st_dev) = 0;
                  }
LABEL_444:
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceSetDefaultDomainForUser(unreadable parameters)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                  goto LABEL_1266;
                case 13:
                  __src[0] = -50331905;
                  v1215 = 0u;
                  v1216 = 0u;
                  v1213 = 0u;
                  v1214 = 0u;
                  v1211 = 0u;
                  v1212 = 0u;
                  v1210 = 0u;
                  memset(&v1209, 0, sizeof(v1209));
                  if (!*(_QWORD *)(v76 + 80))
                    goto LABEL_660;
                  v199 = *(_QWORD *)(v76 + 88);
                  v200 = &v1209;
                  do
                  {
                    v201 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v201 >= v199 || v200 >= (stat *)v1217)
                    {
                      *((_BYTE *)&v200->st_dev - (v200 == (stat *)v1217)) = 0;
                      *(_QWORD *)(v76 + 80) = 0;
                      goto LABEL_660;
                    }
                    *(_QWORD *)(v76 + 80) = v201 + 1;
                    v203 = *v201;
                    LOBYTE(v200->st_dev) = v203;
                    v200 = (stat *)((char *)v200 + 1);
                  }
                  while (v203);
                  v204 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_655;
                  }
                  else
                  {
                    v204 = mDNSLogCategory_Default_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_655:
                      v404 = *(_DWORD *)(v76 + 192);
                      *(_DWORD *)&v1223[0].sa_len = 67109378;
                      *(_DWORD *)&v1223[0].sa_data[2] = v404;
                      *(_WORD *)&v1223[0].sa_data[6] = 2082;
                      *(_QWORD *)&v1223[0].sa_data[8] = &v1209;
                      _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceGetProperty(%{public}s)", &v1223[0].sa_len, 0x12u);
                    }
                  }
                  if (*(_QWORD *)&v1209.st_dev == 0x65566E6F6D656144
                    && *(_QWORD *)&v1209.st_nlink == 0x6E6F6973726556)
                  {
                    *(_QWORD *)&v1223[0].sa_len = 0x400000000000000;
                    *(_DWORD *)&v1223[0].sa_data[6] = -1807382632;
                    v406 = *(_DWORD *)(v76 + 176);
                    v407 = v1223;
                    v408 = 12;
                  }
                  else
                  {
LABEL_660:
                    v406 = *(_DWORD *)(v76 + 176);
                    v407 = __src;
                    v408 = 4;
                  }
                  send_all(v406, v407, v408);
                  goto LABEL_662;
                case 14:
                  v206 = 0;
                  v207 = 0;
                  v208 = *(unsigned int **)(v76 + 80);
                  if (v208)
                  {
                    v209 = *(_QWORD *)(v76 + 88);
                    v210 = 0;
                    if ((unint64_t)(v208 + 1) <= v209)
                    {
                      v210 = 0;
                      v206 = 0;
                      v207 = bswap32(*v208);
                      *(_QWORD *)(v76 + 80) = v208 + 1;
                      if (v208 != (unsigned int *)-4 && (unint64_t)(v208 + 2) <= v209)
                      {
                        v210 = bswap32(v208[1]);
                        v206 = v208 + 2;
                      }
                    }
                  }
                  else
                  {
                    v210 = 0;
                  }
                  *(_QWORD *)(v76 + 80) = v206;
                  v342 = mDNSPlatformInterfaceIDfromInterfaceIndex(v210, a2, a3, a4, a5, a6, a7, a8);
                  v343 = 0;
                  v344 = 0;
                  v346 = *(_QWORD *)(v76 + 80);
                  v345 = *(_QWORD *)(v76 + 88);
                  if (v346 && v346 + 4 <= v345)
                  {
                    v343 = *(unsigned __int8 *)(v346 + 3);
                    v344 = (_BYTE *)(v346 + 4);
                  }
                  *(_QWORD *)(v76 + 80) = v344;
                  if (v210)
                  {
                    updated = -65540;
                    if (!v342)
                      goto LABEL_1267;
                  }
                  v347 = *(unsigned __int16 **)(v76 + 152);
                  if (v347)
                    goto LABEL_544;
                  v348 = (unsigned __int16 *)malloc_type_calloc(1uLL, 0xD0uLL, 0xF1748037uLL);
                  if (!v348)
                    goto LABEL_1918;
                  v347 = v348;
                  *(_QWORD *)(v76 + 152) = v348;
                  v344 = *(_BYTE **)(v76 + 80);
                  v345 = *(_QWORD *)(v76 + 88);
                  if ((unint64_t)(v344 + 8) > v345)
                    goto LABEL_560;
                  *(_QWORD *)(v76 + 80) = v344 + 1;
                  *((_BYTE *)v347 + 182) = *v344;
                  v349 = *(_BYTE **)(v76 + 80);
                  *(_QWORD *)(v76 + 80) = v349 + 1;
                  *((_BYTE *)v347 + 183) = *v349;
                  v350 = *(_BYTE **)(v76 + 80);
                  *(_QWORD *)(v76 + 80) = v350 + 1;
                  *(_BYTE *)v347 = *v350;
                  v351 = *(_BYTE **)(v76 + 80);
                  *(_QWORD *)(v76 + 80) = v351 + 1;
                  *((_BYTE *)v347 + 1) = *v351;
                  v352 = *(unsigned int **)(v76 + 80);
                  if (!v352)
                    goto LABEL_560;
LABEL_544:
                  v353 = v352 + 1;
                  if ((unint64_t)(v352 + 1) <= *(_QWORD *)(v76 + 88))
                  {
                    v354 = *v352;
                    *(_QWORD *)(v76 + 80) = v353;
                    if (v353)
                    {
                      v355 = bswap32(v354);
                      updated = -65540;
                      if (v343)
                      {
                        if (!v347[91])
                          goto LABEL_1267;
                        updated = -65540;
                        if ((v343 & 0x30) == 0)
                          goto LABEL_1267;
                      }
                      else
                      {
                        if (v347[91])
                          goto LABEL_1267;
                        updated = -65540;
                        if (*v347)
                          goto LABEL_1267;
                        updated = -65540;
                        if (v355)
                          goto LABEL_1267;
                      }
                      *(_DWORD *)(v76 + 240) = v207;
                      *(_DWORD *)(v76 + 244) = v210;
                      if (v343 == 16)
                        v356 = 1;
                      else
                        v356 = 2;
                      if (!v343)
                        v356 = 0;
                      *((_BYTE *)v347 + 180) = v356;
                      v357 = *v347;
                      v347[92] = v357;
                      *((_DWORD *)v347 + 47) = v355;
                      *((_QWORD *)v347 + 24) = port_mapping_create_request_callback;
                      *((_QWORD *)v347 + 25) = v76;
                      v358 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1065;
                      }
                      else
                      {
                        v358 = mDNSLogCategory_Default_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_1065;
                      }
                      v630 = *(_DWORD *)(v76 + 192);
                      v631 = bswap32(v347[91]);
                      v632 = *(_DWORD *)(v76 + 180);
                      v1209.st_dev = 67110658;
                      *(_DWORD *)&v1209.st_mode = v630;
                      LOWORD(v1209.st_ino) = 1024;
                      *(_DWORD *)((char *)&v1209.st_ino + 2) = v343;
                      HIWORD(v1209.st_ino) = 1024;
                      v1209.st_uid = HIWORD(v631);
                      LOWORD(v1209.st_gid) = 1024;
                      *(gid_t *)((char *)&v1209.st_gid + 2) = __rev16(v357);
                      HIWORD(v1209.st_rdev) = 1024;
                      *(&v1209.st_rdev + 1) = v355;
                      LOWORD(v1209.st_atimespec.tv_sec) = 1024;
                      *(_DWORD *)((char *)&v1209.st_atimespec.tv_sec + 2) = v632;
                      HIWORD(v1209.st_atimespec.tv_sec) = 2082;
                      v1209.st_atimespec.tv_nsec = v76 + 248;
                      _os_log_impl((void *)&_mh_execute_header, v358, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START PID[%d](%{public}s)", (uint8_t *)&v1209, 0x30u);
LABEL_1065:
                      updated = mDNS_StartNATOperation((uint64_t)(v347 + 4));
                      if (updated)
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNS_StartNATOperation: %d", a4, a5, a6, a7, a8, updated);
                      else
                        *(_QWORD *)(v76 + 104) = port_mapping_termination_callback;
                      goto LABEL_1267;
                    }
                  }
                  else
                  {
LABEL_560:
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  v359 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
                  {
                    v359 = mDNSLogCategory_Default_redacted;
                    updated = -65540;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_1267;
LABEL_564:
                    v360 = *(_DWORD *)(v76 + 192);
                    v1209.st_dev = 67109120;
                    *(_DWORD *)&v1209.st_mode = v360;
                    v111 = &v1209;
                    v112 = v359;
                    v113 = OS_LOG_TYPE_DEFAULT;
                    v114 = "[R%d] DNSServiceNATPortMappingCreate(unreadable parameters)";
                    goto LABEL_1070;
                  }
                  updated = -65540;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_564;
                  goto LABEL_1267;
                case 15:
                  if (*(_QWORD *)(v76 + 160))
                    goto LABEL_341;
                  v211 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
                  if (!v211)
                    goto LABEL_1918;
                  *(_QWORD *)(v76 + 160) = v211;
LABEL_341:
                  bzero(&v1209.st_mode, 0x3F4uLL);
                  v212 = *(unsigned __int8 **)(v76 + 80);
                  if (!v212)
                    goto LABEL_922;
                  v213 = *(_QWORD *)(v76 + 88);
                  if ((unint64_t)(v212 + 4) > v213)
                    goto LABEL_922;
                  v214 = v212[1];
                  v215 = *v212;
                  v216 = *((unsigned __int16 *)v212 + 1);
                  *(_QWORD *)(v76 + 80) = v212 + 4;
                  if (v212 == (unsigned __int8 *)-4)
                    goto LABEL_922;
                  if ((unint64_t)(v212 + 8) > v213)
                    goto LABEL_922;
                  v217 = *((_DWORD *)v212 + 1);
                  *(_QWORD *)(v76 + 80) = v212 + 8;
                  if (v212 == (unsigned __int8 *)-8)
                    goto LABEL_922;
                  v218 = v212 + 12;
                  if ((unint64_t)(v212 + 12) > v213)
                    goto LABEL_922;
                  v219 = bswap32(*((_DWORD *)v212 + 2));
                  *(_QWORD *)(v76 + 80) = v218;
                  v1209.st_dev = v219;
                  updated = -65540;
                  if (!v218)
                    goto LABEL_1267;
                  v220 = (v215 << 24) | (v214 << 16) | (bswap32(v216) >> 16);
                  v221 = bswap32(v217);
                  p_st_size = &v1209.st_mode;
                  do
                  {
                    v222 = *(unsigned __int8 **)(v76 + 80);
                    if ((unint64_t)v222 >= v213 || p_st_size >= v1219)
                    {
                      v495 = p_st_size == v1219;
LABEL_917:
                      v558 = v495;
                      v521 = &p_st_size[-v558];
LABEL_921:
                      *v521 = 0;
LABEL_922:
                      *(_QWORD *)(v76 + 80) = 0;
                      goto LABEL_1266;
                    }
                    *(_QWORD *)(v76 + 80) = v222 + 1;
                    v224 = *v222;
                    *p_st_size++ = v224;
                  }
                  while (v224);
                  v225 = *(unsigned __int8 **)(v76 + 80);
                  if (!v225)
                  {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceGetAddrInfo(unreadable parameters)", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                    goto LABEL_1266;
                  }
                  v1219[0] = 0;
                  if ((*(_BYTE *)(v76 + 216) & 2) == 0)
                    goto LABEL_363;
                  v226 = *(_QWORD *)(v76 + 88);
                  v227 = v225;
                  do
                  {
                    if (v226 - (uint64_t)v227 < 4)
                      goto LABEL_362;
                    v228 = v227 + 4;
                    if (v227 == (unsigned __int8 *)-4)
                      goto LABEL_362;
                    v229 = __rev16(*((unsigned __int16 *)v227 + 1));
                    if (v226 - (uint64_t)v228 < v229)
                      goto LABEL_362;
                    v230 = __rev16(*(unsigned __int16 *)v227);
                    v227 = (unsigned __int8 *)&v228[v229];
                  }
                  while (v230 != 1);
                  *(_QWORD *)v76 = Querier_RegisterCustomDNSServiceWithPListData(v228, v229);
LABEL_362:
                  v1219[0] = get_tlv_uint32(v225, v226, 2, 0) != 0;
LABEL_363:
                  *(_QWORD *)buf = 0;
                  signed_data_tlvs = _get_signed_data_tlvs(v76, (uint64_t *)buf);
                  if (!*(_BYTE *)(v76 + 282))
                    goto LABEL_368;
                  if (signed_data_tlvs)
                  {
                    *(_DWORD *)aBlock = 0;
                    v232 = mdns_signed_resolve_result_create_from_data((uint64_t)signed_data_tlvs, *(size_t *)buf, (int *)aBlock);
                    if (v232 && !*(_DWORD *)aBlock)
                    {
                      *(_QWORD *)(v76 + 56) = v232;
LABEL_368:
                      *(_DWORD *)(v76 + 240) = v220;
                      *(_DWORD *)(v76 + 244) = v221;
                      v233 = _os_feature_enabled_impl("mDNSResponder", "dnssec");
                      memset(v1223, 0, sizeof(v1223));
                      v1224 = 0u;
                      v1225 = 0u;
                      v1226 = 0u;
                      memset(v1227, 0, sizeof(v1227));
                      v1228 = 0u;
                      v1229 = 0u;
                      v1230 = 0u;
                      v1231 = 0u;
                      v1232 = 0u;
                      v1233 = 0u;
                      v1234 = 0u;
                      v1235 = 0u;
                      v1236 = 0u;
                      AppendDNSNameString(v1223, (unsigned __int8 *)&v1209.st_mode, v234, v235, v236, v237, v238, v239);
                      v240 = requestShouldLogFullRequestInfo(v76);
                      v241 = gSensitiveLoggingEnabled;
                      v242 = mDNSLogCategory_Default;
                      if (mDNSLogCategory_Default == mDNSLogCategory_State)
                        v241 = 0;
                      if ((v214 & 0x20) != 0 && v233)
                      {
                        if (v240)
                        {
                          if ((v241 & 1) != 0)
                          {
                            v242 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1657;
                            v1111 = *(_DWORD *)(v76 + 192);
                            for (nn = v1223; ; nn = (sockaddr *)((char *)nn + v245 + 1))
                            {
                              LOWORD(v244) = 257;
                              if (nn >= (sockaddr *)v1237 || !nn)
                                goto LABEL_1648;
                              v245 = nn->sa_len;
                              if (v245 > 0x3F)
                              {
                                LOWORD(v244) = 257;
                                goto LABEL_1648;
                              }
                              if (!nn->sa_len)
                                break;
                            }
                            v244 = (_DWORD)nn - v1223 + 1;
                          }
                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1657;
                            v1111 = *(_DWORD *)(v76 + 192);
                            for (i1 = v1223; ; i1 = (sockaddr *)((char *)i1 + v816 + 1))
                            {
                              LOWORD(v244) = 257;
                              if (i1 >= (sockaddr *)v1237 || !i1)
                                goto LABEL_1648;
                              v816 = i1->sa_len;
                              if (v816 > 0x3F)
                              {
                                LOWORD(v244) = 257;
                                goto LABEL_1648;
                              }
                              if (!i1->sa_len)
                                break;
                            }
                            v244 = (_DWORD)i1 - v1223 + 1;
                          }
LABEL_1648:
                          v914 = (unsigned __int16)v244;
                          st_dev = v1209.st_dev;
                          v916 = *(_DWORD *)(v76 + 240);
                          v917 = *(_DWORD *)(v76 + 244);
                          v918 = *(_DWORD *)(v76 + 180);
                          v919 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                          __src[0] = 67111427;
                          __src[1] = v1111;
                          LOWORD(__src[2]) = 2160;
                          *(_QWORD *)((char *)&__src[2] + 2) = 1752392040;
                          HIWORD(__src[4]) = 1040;
                          __src[5] = v914;
                          LOWORD(__src[6]) = 2101;
                          *(_QWORD *)((char *)&__src[6] + 2) = v1223;
                          HIWORD(__src[8]) = 1024;
                          __src[9] = st_dev;
                          LOWORD(__src[10]) = 1024;
                          *(socklen_t *)((char *)&__src[10] + 2) = v916;
                          HIWORD(__src[11]) = 1024;
                          v1170[0] = v917;
                          LOWORD(v1170[1]) = 1024;
                          *(_DWORD *)((char *)&v1170[1] + 2) = v918;
                          HIWORD(v1170[2]) = 2082;
                          *(_QWORD *)&v1170[3] = v76 + 248;
                          LOWORD(v1170[5]) = 1024;
                          *(_DWORD *)((char *)&v1170[5] + 2) = v919;
                          v869 = v242;
                          v870 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:do"
                                 "main_name}.*P, protocols: %u, DNSSEC enabled, flags: 0x%X, interface index: %d, client "
                                 "pid: %d (%{public}s), name hash: %x";
LABEL_1655:
                          v871 = 74;
                          goto LABEL_1656;
                        }
                        if ((v241 & 1) != 0)
                        {
                          v242 = mDNSLogCategory_Default_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1657;
                        }
                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                        {
                          goto LABEL_1657;
                        }
                      }
                      else
                      {
                        if (v240)
                        {
                          if ((v241 & 1) != 0)
                          {
                            v242 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1657;
                            v1120 = *(_DWORD *)(v76 + 192);
                            for (i2 = v1223; ; i2 = (sockaddr *)((char *)i2 + v726 + 1))
                            {
                              LOWORD(v725) = 257;
                              if (i2 >= (sockaddr *)v1237 || !i2)
                                goto LABEL_1654;
                              v726 = i2->sa_len;
                              if (v726 > 0x3F)
                              {
                                LOWORD(v725) = 257;
                                goto LABEL_1654;
                              }
                              if (!i2->sa_len)
                                break;
                            }
                            v725 = (_DWORD)i2 - v1223 + 1;
                          }
                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_1657;
                            v1120 = *(_DWORD *)(v76 + 192);
                            for (i3 = v1223; ; i3 = (sockaddr *)((char *)i3 + v818 + 1))
                            {
                              LOWORD(v725) = 257;
                              if (i3 >= (sockaddr *)v1237 || !i3)
                                goto LABEL_1654;
                              v818 = i3->sa_len;
                              if (v818 > 0x3F)
                              {
                                LOWORD(v725) = 257;
                                goto LABEL_1654;
                              }
                              if (!i3->sa_len)
                                break;
                            }
                            v725 = (_DWORD)i3 - v1223 + 1;
                          }
LABEL_1654:
                          v920 = (unsigned __int16)v725;
                          v921 = v1209.st_dev;
                          v922 = *(_DWORD *)(v76 + 240);
                          v923 = *(_DWORD *)(v76 + 244);
                          v924 = *(_DWORD *)(v76 + 180);
                          v925 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                          __src[0] = 67111427;
                          __src[1] = v1120;
                          LOWORD(__src[2]) = 2160;
                          *(_QWORD *)((char *)&__src[2] + 2) = 1752392040;
                          HIWORD(__src[4]) = 1040;
                          __src[5] = v920;
                          LOWORD(__src[6]) = 2101;
                          *(_QWORD *)((char *)&__src[6] + 2) = v1223;
                          HIWORD(__src[8]) = 1024;
                          __src[9] = v921;
                          LOWORD(__src[10]) = 1024;
                          *(socklen_t *)((char *)&__src[10] + 2) = v922;
                          HIWORD(__src[11]) = 1024;
                          v1170[0] = v923;
                          LOWORD(v1170[1]) = 1024;
                          *(_DWORD *)((char *)&v1170[1] + 2) = v924;
                          HIWORD(v1170[2]) = 2082;
                          *(_QWORD *)&v1170[3] = v76 + 248;
                          LOWORD(v1170[5]) = 1024;
                          *(_DWORD *)((char *)&v1170[5] + 2) = v925;
                          v869 = v242;
                          v870 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:do"
                                 "main_name}.*P, protocols: %u, flags: 0x%X, interface index: %d, client pid: %d (%{publi"
                                 "c}s), name hash: %x";
                          goto LABEL_1655;
                        }
                        if ((v241 & 1) != 0)
                        {
                          v242 = mDNSLogCategory_Default_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_1657;
                        }
                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                        {
                          goto LABEL_1657;
                        }
                      }
                      v867 = *(_DWORD *)(v76 + 192);
                      v868 = mDNS_DomainNameFNV1aHash(&v1223[0].sa_len);
                      __src[0] = 67109376;
                      __src[1] = v867;
                      LOWORD(__src[2]) = 1024;
                      *(socklen_t *)((char *)&__src[2] + 2) = v868;
                      v869 = v242;
                      v870 = "[R%u] DNSServiceGetAddrInfo START -- name hash: %x";
                      v871 = 14;
LABEL_1656:
                      _os_log_impl((void *)&_mh_execute_header, v869, OS_LOG_TYPE_DEFAULT, v870, (uint8_t *)__src, v871);
LABEL_1657:
                      *(_QWORD *)(v76 + 104) = 0;
                      v926 = *(_QWORD *)(v76 + 56);
                      if (!v926)
                        goto LABEL_1674;
                      if (*(_UNKNOWN ***)(v926 + 16) == &_mdns_signed_resolve_result_kind
                        && mdns_signed_resolve_result_contains(*(_QWORD *)(v76 + 56), (char *)&v1209.st_mode, v221))
                      {
                        v927 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v926 + 16) + 56))(v926);
                        v928 = mdns_system_is_signed_result_uuid_valid(v927);
                        v929 = gSensitiveLoggingEnabled;
                        v930 = mDNSLogCategory_Default;
                        if (mDNSLogCategory_Default == mDNSLogCategory_State)
                          v929 = 0;
                        if (!v928)
                        {
                          if ((v929 & 1) != 0)
                          {
                            v930 = mDNSLogCategory_Default_redacted;
                            updated = -65570;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                              goto LABEL_1267;
                          }
                          else
                          {
                            updated = -65570;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                              goto LABEL_1267;
                          }
                          v935 = *(_DWORD *)(v76 + 192);
                          __src[0] = 67109120;
                          __src[1] = v935;
                          v719 = (uint8_t *)__src;
                          v720 = v930;
                          v721 = OS_LOG_TYPE_ERROR;
                          v722 = "[R%d] DNSServiceGetAddrInfo: Signed result UUID revoked.";
                          goto LABEL_1217;
                        }
                        if ((v929 & 1) != 0)
                        {
                          v930 = mDNSLogCategory_Default_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                            goto LABEL_1680;
                        }
                        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                        {
LABEL_1680:
                          v936 = *(_DWORD *)(v76 + 192);
                          __src[0] = 67109120;
                          __src[1] = v936;
                          _os_log_impl((void *)&_mh_execute_header, v930, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceGetAddrInfo: Allowing signed result", (uint8_t *)__src, 8u);
                        }
LABEL_1681:
                        v778 = _handle_addrinfo_request_start(v76, &v1209.st_dev);
                        goto LABEL_1757;
                      }
                      v931 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                          goto LABEL_1672;
                      }
                      else
                      {
                        v931 = mDNSLogCategory_Default_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                          goto LABEL_1672;
                      }
                      v932 = *(_DWORD *)(v76 + 192);
                      v933 = *(_DWORD *)(v76 + 244);
                      __src[0] = 67109891;
                      __src[1] = v932;
                      LOWORD(__src[2]) = 2160;
                      *(_QWORD *)((char *)&__src[2] + 2) = 1752392040;
                      HIWORD(__src[4]) = 2085;
                      *(_QWORD *)&__src[5] = &v1209.st_mode;
                      LOWORD(__src[7]) = 1024;
                      *(socklen_t *)((char *)&__src[7] + 2) = v933;
                      _os_log_impl((void *)&_mh_execute_header, v931, OS_LOG_TYPE_ERROR, "[R%d] DNSServiceGetAddrInfo: Signed result does not cover hostname: %{sensitive, mask.hash}s, ifindex: %u.", (uint8_t *)__src, 0x22u);
LABEL_1672:
                      *(_BYTE *)(v76 + 282) = 0;
                      v934 = *(void **)(v76 + 56);
                      if (v934)
                      {
                        os_release(v934);
                        *(_QWORD *)(v76 + 56) = 0;
                      }
LABEL_1674:
                      if (_os_feature_enabled_impl("mDNSResponder", "bonjour_privacy"))
                      {
                        v778 = _handle_addrinfo_request_with_trust(v76, (uint64_t)&v1209);
                        goto LABEL_1757;
                      }
                      goto LABEL_1681;
                    }
                    v769 = *(int *)aBlock;
                    v770 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      {
LABEL_1453:
                        __src[0] = 134218240;
                        *(_QWORD *)&__src[1] = *(_QWORD *)buf;
                        LOWORD(__src[3]) = 2048;
                        *(_QWORD *)((char *)&__src[3] + 2) = v769;
                        v806 = v770;
                        v807 = "get_signed_resolve_tlvs len %ld data invalid %ld";
                        v808 = 22;
                        goto LABEL_1454;
                      }
                    }
                    else
                    {
                      v770 = mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                        goto LABEL_1453;
                    }
LABEL_1455:
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_addrinfo_request err reading Validation TLVS", v801, v802, v803, v804, v805, *(_DWORD *)(v76 + 176));
                    updated = -65549;
                    goto LABEL_1267;
                  }
                  v727 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      goto LABEL_1455;
                  }
                  else
                  {
                    v727 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                      goto LABEL_1455;
                  }
                  LOWORD(__src[0]) = 0;
                  v806 = v727;
                  v807 = "get_signed_resolve_tlvs data invalid";
                  v808 = 2;
LABEL_1454:
                  _os_log_impl((void *)&_mh_execute_header, v806, OS_LOG_TYPE_DEBUG, v807, (uint8_t *)__src, v808);
                  goto LABEL_1455;
                case 16:
                case 17:
                  goto LABEL_188;
                case 18:
                  v1180 = 0u;
                  v1181 = 0u;
                  v1178 = 0u;
                  v1179 = 0u;
                  v1176 = 0u;
                  v1177 = 0u;
                  v1174 = 0u;
                  v1175 = 0u;
                  v1172 = 0u;
                  v1173 = 0u;
                  v1171 = 0u;
                  memset(v1170, 0, sizeof(v1170));
                  memset(__src, 0, sizeof(__src));
                  bzero(&v1209, 0x3F1uLL);
                  bzero(v1223, 0x3F1uLL);
                  v1207 = 0u;
                  v1208 = 0u;
                  v1205 = 0u;
                  v1206 = 0u;
                  v1203 = 0u;
                  v1204 = 0u;
                  v1201 = 0u;
                  v1202 = 0u;
                  v1199 = 0u;
                  v1200 = 0u;
                  v1197 = 0u;
                  v1198 = 0u;
                  v1196 = 0u;
                  memset(buf, 0, sizeof(buf));
                  v251 = *(unsigned int **)(v76 + 80);
                  if (v251 && (v252 = *(_QWORD *)(v76 + 88), v253 = v251 + 1, (unint64_t)(v251 + 1) <= v252))
                  {
                    v254 = *v251;
                    *(_QWORD *)(v76 + 80) = v253;
                    if (!v253)
                      goto LABEL_446;
                    v255 = bswap32(v254);
                    v256 = __src;
                    do
                    {
                      v257 = *(unsigned __int8 **)(v76 + 80);
                      if ((unint64_t)v257 >= v252 || v256 >= (socklen_t *)v1182)
                      {
                        v402 = (unsigned __int8 *)v256 - (v256 == (socklen_t *)v1182);
                        goto LABEL_1061;
                      }
                      *(_QWORD *)(v76 + 80) = v257 + 1;
                      v259 = *v257;
                      *(_BYTE *)v256 = v259;
                      v256 = (socklen_t *)((char *)v256 + 1);
                    }
                    while (v259);
                    if (*(_QWORD *)(v76 + 80))
                    {
                      v260 = *(_QWORD *)(v76 + 88);
                      v261 = (unsigned __int8 *)&v1209;
                      do
                      {
                        v262 = *(unsigned __int8 **)(v76 + 80);
                        if ((unint64_t)v262 >= v260 || v261 >= v1218)
                        {
                          v531 = v261 == v1218;
                          goto LABEL_1057;
                        }
                        *(_QWORD *)(v76 + 80) = v262 + 1;
                        v264 = *v262;
                        *v261++ = v264;
                      }
                      while (v264);
                      if (*(_QWORD *)(v76 + 80))
                      {
                        v265 = *(_QWORD *)(v76 + 88);
                        v261 = (unsigned __int8 *)v1223;
                        while (1)
                        {
                          v266 = *(unsigned __int8 **)(v76 + 80);
                          if ((unint64_t)v266 >= v265 || v261 >= v1238)
                            break;
                          *(_QWORD *)(v76 + 80) = v266 + 1;
                          v268 = *v266;
                          *v261++ = v268;
                          if (!v268)
                          {
                            if (!*(_QWORD *)(v76 + 80))
                            {
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: PeerConnectionRelease(unreadable parameters)", v246, v247, v248, v249, v250, *(_DWORD *)(v76 + 176));
                              goto LABEL_1266;
                            }
                            if ((build_domainname_from_strings(buf, __src, (unsigned __int8 *)&v1209, &v1223[0].sa_len, v247, v248, v249, v250) & 0x80000000) != 0)
                            {
                              v1078 = &v1209;
                              v1079 = (unint64_t)v1223;
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_release_request bad %s %s %s", v269, v270, v271, v272, v273, (int)__src);
                              goto LABEL_1266;
                            }
                            v274 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              {
                                v275 = *(_DWORD *)(v76 + 192);
                                for (i4 = buf; ; i4 += v799 + 1)
                                {
                                  LOWORD(v277) = 257;
                                  if (i4 >= (uint8_t *)&v1209 || !i4)
                                    goto LABEL_1635;
                                  v799 = *i4;
                                  if (v799 > 0x3F)
                                  {
                                    LOWORD(v277) = 257;
                                    goto LABEL_1635;
                                  }
                                  if (!*i4)
                                    break;
                                }
                                v277 = (_DWORD)i4 - buf + 1;
LABEL_1635:
                                v906 = (unsigned __int16)v277;
                                v907 = *(_DWORD *)(v76 + 180);
                                *(_DWORD *)aBlock = 67110659;
                                *(_DWORD *)&aBlock[4] = v275;
                                *(_WORD *)&aBlock[8] = 1024;
                                *(_DWORD *)&aBlock[10] = v255;
                                *(_WORD *)&aBlock[14] = 2160;
                                *(_QWORD *)&aBlock[16] = 1752392040;
                                *(_WORD *)&aBlock[24] = 1040;
                                *(_DWORD *)&aBlock[26] = v906;
                                *(_WORD *)&aBlock[30] = 2101;
                                *(_QWORD *)&aBlock[32] = buf;
                                *(_WORD *)&aBlock[40] = 1024;
                                *(_DWORD *)&aBlock[42] = v907;
                                *(_WORD *)&aBlock[46] = 2082;
                                *(_QWORD *)&aBlock[48] = v76 + 248;
                                _os_log_impl((void *)&_mh_execute_header, v274, OS_LOG_TYPE_DEFAULT, "[R%d] PeerConnectionRelease(%X %{sensitive, mask.hash, mdnsresponder:domain_name}.*P) START PID[%d](%{public}s)", aBlock, 0x38u);
                              }
                            }
                            else
                            {
                              v274 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                v275 = *(_DWORD *)(v76 + 192);
                                for (i5 = buf; ; i5 += v278 + 1)
                                {
                                  LOWORD(v277) = 257;
                                  if (i5 >= (uint8_t *)&v1209 || !i5)
                                    goto LABEL_1635;
                                  v278 = *i5;
                                  if (v278 > 0x3F)
                                  {
                                    LOWORD(v277) = 257;
                                    goto LABEL_1635;
                                  }
                                  if (!*i5)
                                    break;
                                }
                                v277 = (_DWORD)i5 - buf + 1;
                                goto LABEL_1635;
                              }
                            }
                            external_connection_release(buf);
LABEL_662:
                            updated = 0;
                            goto LABEL_1267;
                          }
                        }
                        v531 = v261 == v1238;
LABEL_1057:
                        v629 = v531;
                        v402 = &v261[-v629];
LABEL_1061:
                        *v402 = 0;
                        *(_QWORD *)(v76 + 80) = 0;
                      }
                      else
                      {
                        v1223[0].sa_len = 0;
                      }
                    }
                    else
                    {
                      LOBYTE(v1209.st_dev) = 0;
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v76 + 80) = 0;
LABEL_446:
                    LOBYTE(__src[0]) = 0;
                  }
                  v624 = mDNSLogCategory_Default;
                  v625 = "ERROR: handle_release_request - Couldn't read name/regtype/domain";
                  goto LABEL_1265;
                case 19:
                  v279 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_449;
                  }
                  else
                  {
                    v279 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_449;
                  }
                  v289 = *(_DWORD *)(v76 + 192);
                  v290 = *(_DWORD *)(v76 + 180);
                  v1209.st_dev = 67109634;
                  *(_DWORD *)&v1209.st_mode = v289;
                  LOWORD(v1209.st_ino) = 1024;
                  *(_DWORD *)((char *)&v1209.st_ino + 2) = v290;
                  HIWORD(v1209.st_ino) = 2082;
                  *(_QWORD *)&v1209.st_uid = v76 + 248;
                  _os_log_impl((void *)&_mh_execute_header, v279, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)", (uint8_t *)&v1209, 0x18u);
LABEL_449:
                  *(_QWORD *)(v76 + 104) = connection_termination;
                  v291 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_455;
                  }
                  else
                  {
                    v291 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_455;
                  }
                  v292 = *(_DWORD *)(v76 + 192);
                  v293 = *(_DWORD *)(v76 + 180);
                  v1209.st_dev = 67109634;
                  *(_DWORD *)&v1209.st_mode = v292;
                  LOWORD(v1209.st_ino) = 1024;
                  *(_DWORD *)((char *)&v1209.st_ino + 2) = v293;
                  HIWORD(v1209.st_ino) = 2082;
                  *(_QWORD *)&v1209.st_uid = v76 + 248;
                  _os_log_impl((void *)&_mh_execute_header, v291, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)", (uint8_t *)&v1209, 0x18u);
LABEL_455:
                  *(_QWORD *)(v76 + 104) = connection_termination;
                  v294 = *(unsigned int **)(v76 + 80);
                  if (v294 && (v295 = v294 + 1, (unint64_t)(v294 + 1) <= *(_QWORD *)(v76 + 88)))
                  {
                    v296 = bswap32(*v294);
                    *(_QWORD *)(v76 + 80) = v295;
                    if (v296)
                    {
                      v1209.st_dev = 4;
                      if (getsockopt(*(_DWORD *)(v76 + 176), 0, 3, (void *)(v76 + 180), (socklen_t *)&v1209))
                      {
                        v297 = mDNSLogCategory_Default;
                        v298 = *__error();
                        v299 = __error();
                        v1078 = strerror(*v299);
                        LogMsgWithLevel(v297, OS_LOG_TYPE_DEFAULT, "handle_connection_delegate_request: getsockopt for LOCAL_PEEREPID failed errno:%d / %s", v300, v301, v302, v303, v304, v298);
                      }
                      else
                      {
                        mdns_system_pid_to_name(*(_DWORD *)(v76 + 180), v76 + 248);
                      }
                      goto LABEL_662;
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v76 + 80) = 0;
                  }
                  v1209.st_dev = 16;
                  if (getsockopt(*(_DWORD *)(v76 + 176), 0, 5, (void *)(v76 + 264), (socklen_t *)&v1209))
                  {
                    v305 = mDNSLogCategory_Default;
                    v306 = *__error();
                    v307 = __error();
                    v1078 = strerror(*v307);
                    LogMsgWithLevel(v305, OS_LOG_TYPE_DEFAULT, "handle_connection_delegate_request: getsockopt for LOCAL_PEEREUUID failed errno:%d / %s", v308, v309, v310, v311, v312, v306);
                  }
                  else
                  {
                    *(_BYTE *)(v76 + 280) = 1;
                  }
                  goto LABEL_662;
                default:
                  if (v79 != 63)
                  {
LABEL_188:
                    v1079 = *(unsigned int *)(v76 + 180);
                    v1080 = v76 + 248;
                    v1078 = (void *)*(unsigned int *)(v76 + 220);
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: %3d:ERROR: Unsupported UDS req:%d PID[%d][%s]", a4, a5, a6, a7, a8, *(_DWORD *)(v76 + 176));
                    goto LABEL_1266;
                  }
                  v98 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      goto LABEL_479;
                  }
                  else
                  {
                    v98 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                      goto LABEL_479;
                  }
                  v321 = *(_DWORD *)(v76 + 192);
                  v323 = *(_DWORD *)(v76 + 224);
                  v322 = *(_DWORD *)(v76 + 228);
                  v1209.st_dev = 67109632;
                  *(_DWORD *)&v1209.st_mode = v321;
                  LOWORD(v1209.st_ino) = 1024;
                  *(_DWORD *)((char *)&v1209.st_ino + 2) = v322;
                  HIWORD(v1209.st_ino) = 1024;
                  v1209.st_uid = v323;
                  _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEBUG, "[R%d] Cancel %08X %08X", (uint8_t *)&v1209, 0x14u);
LABEL_479:
                  v324 = all_requests;
                  if (!all_requests)
                    goto LABEL_662;
                  v325 = &all_requests;
                  do
                  {
                    if (*(_QWORD *)(v324 + 24) == v76
                      && *(_DWORD *)(v324 + 224) == *(_DWORD *)(v76 + 224)
                      && *(_DWORD *)(v324 + 228) == *(_DWORD *)(v76 + 228))
                    {
                      *(_QWORD *)&v1209.st_dev = 0;
                      *(_QWORD *)&v1209.st_dev = *v325;
                      v326 = *(_QWORD *)&v1209.st_dev;
                      abort_request(*(uint64_t *)&v1209.st_dev);
                      *v325 = *(_QWORD *)(v326 + 16);
                      request_state_forget(&v1209);
                    }
                    else
                    {
                      v325 = (uint64_t *)(v324 + 16);
                    }
                    updated = 0;
                    v324 = *v325;
                  }
                  while (*v325);
                  goto LABEL_1267;
              }
            }
LABEL_138:
            v76 = v8;
            goto LABEL_139;
          }
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: Reg/Add/Update/Remove %d require existing connection PID[%d][%s]", a4, a5, a6, a7, a8, v75);
          break;
      }
      goto LABEL_1916;
    }
    break;
  }
  if ((v10 - 3) < 2)
    goto LABEL_1916;
  if (v10 != 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: req->ts %d != t_complete PID[%d][%s]", a4, a5, a6, a7, a8, v10);
    goto LABEL_1916;
  }
}

uint64_t mDNSPlatformInterfaceIDfromInterfaceIndex(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t result;
  uint64_t *v11;
  uint64_t v12;

  v9 = a1 + 4;
  result = 0;
  v11 = &mDNSInterface_LocalOnly;
  switch(v9)
  {
    case 0:
      v11 = &mDNSInterface_BLE;
      return *v11;
    case 1:
      v11 = &mDNSInterface_P2P;
      return *v11;
    case 3:
      return *v11;
    case 4:
      return result;
    default:
      v12 = *(_QWORD *)mDNSStorage[0];
      if (!*(_QWORD *)mDNSStorage[0])
        goto LABEL_8;
      break;
  }
  while (!*(_QWORD *)(v12 + 3776) || *(_DWORD *)(v12 + 3720) != a1)
  {
    v12 = *(_QWORD *)(v12 + 3680);
    if (!v12)
    {
LABEL_8:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInterfaceIDfromInterfaceIndex: InterfaceID for interface index %d not found; Updating interface list",
          a4,
          a5,
          a6,
          a7,
          a8,
          a1);
      mDNSMacOSXNetworkChanged(result, a2, a3, a4, a5, a6, a7, a8);
      v12 = *(_QWORD *)mDNSStorage[0];
      if (!*(_QWORD *)mDNSStorage[0])
        return 0;
      while (!*(_QWORD *)(v12 + 3776) || *(_DWORD *)(v12 + 3720) != a1)
      {
        v12 = *(_QWORD *)(v12 + 3680);
        if (!v12)
          return 0;
      }
      break;
    }
  }
  v11 = (uint64_t *)(v12 + 3552);
  return *v11;
}

uint64_t ChopSubTypes(unsigned __int8 *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  while (1)
  {
    v1 = *a1;
    if (v1 == 44)
    {
      v1 = a1[1];
      if (a1[1])
      {
        v3 = 0;
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    if (v1 != 92)
      break;
    if (a1[1])
    {
      v2 = 2;
      goto LABEL_10;
    }
LABEL_9:
    v2 = 1;
LABEL_10:
    a1 += v2;
  }
  if (*a1)
    goto LABEL_9;
  v3 = 0;
  while (v1)
  {
    if (v1 == 44)
      return 0xFFFFFFFFLL;
    v3 = (v3 + 1);
    while (v1 > 91)
    {
      if (v1 == 92 && a1[1])
      {
        v4 = 2;
        goto LABEL_22;
      }
LABEL_21:
      v4 = 1;
LABEL_22:
      a1 += v4;
      v1 = *a1;
    }
    if (!v1)
      continue;
    if (v1 != 44)
    {
      if (v1 == 46)
        return 0xFFFFFFFFLL;
      goto LABEL_21;
    }
    if (a1[1])
    {
      v1 = a1[1];
LABEL_27:
      *a1++ = 0;
    }
  }
  return v3;
}

uint64_t register_service_instance(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int service_attr_tsr_params;
  int v9;
  uint64_t v10;
  size_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint8_t *j;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  _QWORD *v34;
  uint64_t v35;
  BOOL v36;
  char v37;
  _BYTE *v38;
  uint64_t v39;
  unsigned __int16 v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  unsigned __int8 *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v53;
  unsigned int v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  uint8_t *i;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  BOOL v75;
  __uint64_t monotonic_time_ns;
  uint64_t *v77;
  uint64_t updated;
  char v79;
  uint64_t v80;
  uint64_t v81;
  NSObject *v82;
  uint64_t v83;
  NSObject *v84;
  NSObject *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  _BYTE *v94;
  int v95;
  uint64_t v96;
  _BYTE *v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  unsigned int v101;
  int v102;
  int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  _BYTE __tp[18];
  __int16 v109;
  uint8_t *v110;
  __int16 v111;
  uint64_t v112;
  uint8_t buf[48];
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  uint64_t v127;

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(unsigned __int16 *)(v4 + 8);
  v6 = SameDomainNameBytes(a2, "\x05local");
  v7 = *(_QWORD *)v4;
  v107 = 0;
  service_attr_tsr_params = get_service_attr_tsr_params(v3, (int *)&v107 + 1, &v107);
  if (!service_attr_tsr_params)
  {
    v12 = 0;
    goto LABEL_21;
  }
  v125 = 0u;
  v126 = 0u;
  v123 = 0u;
  v124 = 0u;
  v121 = 0u;
  v122 = 0u;
  v119 = 0u;
  v120 = 0u;
  v117 = 0u;
  v118 = 0u;
  v116 = 0u;
  v114 = 0u;
  v115 = 0u;
  memset(buf, 0, sizeof(buf));
  v9 = HIDWORD(v107);
  if (HIDWORD(v107) <= 0x93A80)
  {
    v13 = v3;
    *(_QWORD *)__tp = 0;
    *(_QWORD *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    v14 = *(_DWORD *)__tp;
    v15 = HIDWORD(v107);
    ConstructServiceName(buf, (const char *)(v4 + 26), (unsigned __int8 *)(v4 + 1099), a2);
    v16 = DomainNameHashValue((unint64_t)buf);
    if (conflictWithCacheRecordsOrFlush(v16, buf, v15, v107))
    {
      v17 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        v11 = 4294901724;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          return v11;
        for (i = buf; ; i += v70 + 1)
        {
          if (i >= (uint8_t *)&v127 || !i || (v70 = *i, v70 > 0x3F))
          {
            v73 = 257;
            goto LABEL_85;
          }
          if (!*i)
            break;
        }
        v73 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
      }
      else
      {
        v17 = mDNSLogCategory_mDNS_redacted;
        v11 = 4294901724;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return v11;
        for (j = buf; ; j += v19 + 1)
        {
          if (j >= (uint8_t *)&v127 || !j || (v19 = *j, v19 > 0x3F))
          {
            v73 = 257;
            goto LABEL_85;
          }
          if (!*j)
            break;
        }
        v73 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
      }
LABEL_85:
      *(_DWORD *)__tp = 141558787;
      *(_QWORD *)&__tp[4] = 1752392040;
      *(_WORD *)&__tp[12] = 1040;
      *(_DWORD *)&__tp[14] = v73;
      v109 = 2101;
      v110 = buf;
      v111 = 2048;
      v112 = v7;
      v20 = "register_service_instance: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdnsresponder:domai"
            "n_name}.*P InterfaceID %p";
      v21 = v17;
      v22 = OS_LOG_TYPE_DEFAULT;
      v23 = 38;
      goto LABEL_86;
    }
    v12 = v14 - v9;
    v3 = v13;
LABEL_21:
    if (v6)
      v24 = 1;
    else
      v24 = *(_BYTE *)(v4 + 1355) == 0;
    if (v24)
      v25 = v7;
    else
      v25 = 0;
    v26 = (uint64_t *)(v4 + 1624);
    v27 = *(uint64_t **)(v4 + 1624);
    if (v27)
    {
      while (!SameDomainNameBytes((_BYTE *)v27 + 28, a2))
      {
        v26 = (uint64_t *)*v26;
        v27 = (uint64_t *)*v26;
        if (!*v26)
          goto LABEL_30;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "register_service_instance: domain %##s already registered for %#s.%##s", v28, v29, v30, v31, v32, (int)a2);
      return 4294901749;
    }
LABEL_30:
    v105 = v12;
    if (v5 <= 0x108)
      v33 = 5048;
    else
      v33 = v5 + 4784;
    v34 = malloc_type_calloc(1uLL, v33, 0xF1748037uLL);
    if (!v34)
      goto LABEL_150;
    v35 = (uint64_t)v34;
    *v34 = 0;
    v34[1] = v3;
    *((_WORD *)v34 + 12) = 0;
    if (*(_BYTE *)(v4 + 1355))
      v36 = v6 == 0;
    else
      v36 = 1;
    v37 = !v36;
    *((_BYTE *)v34 + 26) = v37;
    *((_BYTE *)v34 + 27) = 0;
    v38 = a2;
    v106 = v25;
    if (a2 == (_BYTE *)-256)
    {
LABEL_42:
      while (v38)
      {
        v39 = *v38;
        if (v39 > 0x3F)
          break;
        if (!*v38)
        {
          v40 = (_WORD)v38 - (_WORD)a2 + 1;
          if (v40 > 0x100u)
            break;
          memcpy((char *)v34 + 28, a2, v40);
          goto LABEL_51;
        }
        v38 += v39 + 1;
        if (a2 != (_BYTE *)-256)
          goto LABEL_41;
      }
    }
    else
    {
LABEL_41:
      if (v38 < a2 + 256)
        goto LABEL_42;
    }
    *((_BYTE *)v34 + 28) = 0;
LABEL_51:
    v41 = *(unsigned int *)(v4 + 1616);
    if ((_DWORD)v41)
    {
      v104 = v3;
      v42 = (char *)malloc_type_calloc(1uLL, 1176 * v41, 0xF1748037uLL);
      if (v42)
      {
        v43 = v42;
        v44 = 0;
        v45 = (unsigned __int8 *)(v4 + 90);
        while (1)
        {
          mDNS_SetupResourceRecord((uint64_t)&v43[1176 * v44], 0, 0, 255, 0x1194u, 0, 0, 0, 0);
          while (*v45++)
            ;
          v53 = &v43[1176 * v44 + 652];
          *v53 = 0;
          if (!AppendDNSNameString(v53, v45, v46, v47, v48, v49, v50, v51))
            break;
          if (++v44 == v41)
          {
            v54 = *(_DWORD *)(v4 + 1616);
            v3 = v104;
            goto LABEL_60;
          }
        }
        v11 = 4294901756;
        free(v43);
        v68 = (_QWORD *)v35;
        goto LABEL_66;
      }
LABEL_150:
      __break(1u);
    }
    v54 = 0;
    v43 = 0;
LABEL_60:
    *(_QWORD *)(v35 + 16) = v43;
    if (*(_BYTE *)(v4 + 1356))
      v55 = (_BYTE *)(v4 + 1356);
    else
      v55 = 0;
    v11 = mDNS_RegisterService((unsigned int *)mDNSStorage, v35 + 288, (const char *)(v4 + 26), (unsigned __int8 *)(v4 + 1099), a2, v55, *(_WORD *)(v4 + 24), 0, *(unsigned __int16 **)(v4 + 16), *(_WORD *)(v4 + 8), (uint64_t)v43, v54, v106, (uint64_t)regservice_callback, v35, *(_DWORD *)(v3 + 240));
    if ((_DWORD)v11)
    {
LABEL_64:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "register_service_instance %#s.%##s%##s error %d", v56, v57, v58, v59, v60, v4 + 26);
      v68 = (_QWORD *)v35;
LABEL_66:
      unlink_and_free_service_instance(v68, v61, v62, v63, v64, v65, v66, v67);
      return v11;
    }
    v71 = *(unsigned int *)(v3 + 244);
    if ((_DWORD)v71 != -1 && v6)
    {
      if ((_DWORD)v71)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v71)
        {
          v72 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID)
            v75 = WiFiAwareInterfaceID == v71;
          else
            v75 = 0;
          v72 = v75;
        }
      }
      else
      {
        v72 = (*(_DWORD *)(v3 + 240) >> 20) & 1;
      }
      monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      _mdns_powerlog_bonjour_event(16, v72, (char *)(v3 + 248), monotonic_time_ns);
      *(_QWORD *)(v3 + 8) = monotonic_time_ns;
    }
    if (service_attr_tsr_params)
    {
      v77 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_10015BF10, *(_BYTE **)(v35 + 2736), *(_DWORD *)(v35 + 2720));
      if (v77)
      {
        updated = updateTSRRecord(v3, (uint64_t)v77, v105, v107);
      }
      else
      {
        *(_DWORD *)buf = 167832317;
        buf[4] = HIBYTE(v105);
        buf[5] = BYTE2(v105);
        buf[6] = BYTE1(v105);
        buf[7] = v105;
        buf[8] = BYTE3(v107);
        buf[9] = BYTE2(v107);
        buf[10] = BYTE1(v107);
        buf[11] = v107;
        *(_WORD *)&buf[12] = 0;
        updated = add_record_to_service(v3, v35, 41, 14, buf, 0x1194u);
      }
      v11 = updated;
      v79 = gSensitiveLoggingEnabled;
      v80 = mDNSLogCategory_mDNS;
      if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
        v79 = 0;
      if ((_DWORD)updated)
      {
        if ((v79 & 1) != 0)
        {
          v81 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_64;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = HIDWORD(v107);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          v82 = v81;
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
            goto LABEL_64;
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = HIDWORD(v107);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          v82 = v80;
        }
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "Failed to add TSR record with tsrTimestamp %u error %d", buf, 0xEu);
        goto LABEL_64;
      }
      if ((v79 & 1) != 0)
      {
        v83 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v105;
          v84 = v83;
LABEL_113:
          _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "TSR record added with tsrTimestamp %d", buf, 8u);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v105;
        v84 = v80;
        goto LABEL_113;
      }
    }
    *v26 = v35;
    v85 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        v91 = v3;
        v92 = *(_DWORD *)(v3 + 192);
        v93 = *(_QWORD *)(v35 + 2736);
        if (v93)
        {
          v97 = *(_BYTE **)(v35 + 2736);
          v95 = 257;
          if (v93 == -256)
            goto LABEL_133;
LABEL_130:
          if ((unint64_t)v97 < v93 + 256 && v97)
          {
            while (1)
            {
              v98 = *v97;
              if (v98 > 0x3F)
              {
LABEL_141:
                v99 = v35;
                v95 = 257;
                goto LABEL_146;
              }
              if (!*v97)
                break;
              v97 += v98 + 1;
              if (v93 != -256)
                goto LABEL_130;
LABEL_133:
              if (!v97)
                goto LABEL_141;
            }
            v99 = v35;
            v95 = (unsigned __int16)((_WORD)v97 - v93 + 1);
          }
          else
          {
            v99 = v35;
          }
        }
        else
        {
          v99 = v35;
          v95 = 0;
        }
        goto LABEL_146;
      }
    }
    else
    {
      v85 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v91 = v3;
        v92 = *(_DWORD *)(v3 + 192);
        v93 = *(_QWORD *)(v35 + 2736);
        if (v93)
        {
          v94 = *(_BYTE **)(v35 + 2736);
          v95 = 257;
          if (v93 == -256)
            goto LABEL_122;
LABEL_119:
          if ((unint64_t)v94 < v93 + 256 && v94)
          {
            while (1)
            {
              v96 = *v94;
              if (v96 > 0x3F)
              {
LABEL_140:
                v99 = v35;
                v95 = 257;
                goto LABEL_146;
              }
              if (!*v94)
                break;
              v94 += v96 + 1;
              if (v93 != -256)
                goto LABEL_119;
LABEL_122:
              if (!v94)
                goto LABEL_140;
            }
            v99 = v35;
            v95 = (unsigned __int16)((_WORD)v94 - v93 + 1);
          }
          else
          {
            v99 = v35;
          }
        }
        else
        {
          v99 = v35;
          v95 = 0;
        }
LABEL_146:
        v100 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v35 + 2736));
        v101 = bswap32(*(unsigned __int16 *)(v4 + 24)) >> 16;
        v102 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v99 + 1560));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&buf[4] = v92;
        *(_WORD *)&buf[8] = 2160;
        *(_QWORD *)&buf[10] = 1752392040;
        *(_WORD *)&buf[18] = 1040;
        *(_DWORD *)&buf[20] = v95;
        *(_WORD *)&buf[24] = 2101;
        *(_QWORD *)&buf[26] = v93;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v100;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v101;
        v35 = v99;
        *(_WORD *)&buf[46] = 1024;
        LODWORD(v114) = v102;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister result -- event: ADDED, SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), port: %u, PTR name hash: %x", buf, 0x34u);
        v3 = v91;
      }
    }
    if (mDNS_McastLoggingEnabled)
      LogMcastService(v35 + 2696, v3, 1, v86, v87, v88, v89, v90, v103);
    return 0;
  }
  v10 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    v11 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
    {
LABEL_19:
      *(_DWORD *)__tp = 67109376;
      *(_DWORD *)&__tp[4] = v9;
      *(_WORD *)&__tp[8] = 1024;
      *(_DWORD *)&__tp[10] = 604800;
      v20 = "tsrTimestamp[%u] out of range (%u) on TSR";
      v21 = v10;
      v22 = OS_LOG_TYPE_ERROR;
      v23 = 14;
LABEL_86:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, v20, __tp, v23);
    }
  }
  else
  {
    v11 = 4294901756;
    v10 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
  }
  return v11;
}

size_t mDNS_RegisterService(unsigned int *a1, uint64_t a2, const char *a3, unsigned __int8 *a4, _BYTE *a5, _BYTE *a6, __int16 a7, uint64_t a8, unsigned __int16 *a9, unsigned __int16 a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16)
{
  char v19;
  _BOOL4 v20;
  BOOL v21;
  int v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  _BYTE *v30;
  _BYTE *v31;
  _BYTE *v32;
  uint64_t v33;
  int v34;
  _BOOL4 v35;
  BOOL v36;
  int v37;
  int v38;
  BOOL v39;
  int v40;
  unsigned __int16 v42;
  _BYTE *v43;
  _BYTE *v44;
  uint64_t v45;
  unsigned __int16 v46;
  _BYTE *v47;
  _BYTE *v48;
  uint64_t v49;
  unsigned __int16 v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned __int16 v57;
  _BYTE *v58;
  uint64_t v59;
  unsigned __int16 v60;
  uint64_t v61;
  _BYTE *v62;
  unsigned int *v63;
  unsigned __int16 *v64;
  uint64_t v65;
  unsigned __int16 v66;
  unsigned __int16 *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v97;
  _OWORD __dst[16];

  if ((a16 & 0x800) != 0)
    v19 = 32;
  else
    v19 = 2;
  *(_QWORD *)a2 = a14;
  *(_QWORD *)(a2 + 8) = a15;
  *(_BYTE *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 32) = a12;
  *(_QWORD *)(a2 + 40) = a11;
  *(_DWORD *)(a2 + 48) = a16;
  if (a13 == -2)
  {
    v26 = 4;
  }
  else
  {
    v20 = (a16 & 0x100000) == 0;
    v21 = (a16 & 0x20000) != 0 && a13 == 0;
    v22 = !v21;
    if (!v21)
      v20 = 1;
    if (v20)
      v23 = 1;
    else
      v23 = 3;
    if (a13)
      v24 = 1;
    else
      v24 = (a16 & 0x100000) == 0;
    if (v24)
      v25 = 0;
    else
      v25 = 2;
    if (v22 != 1)
      v25 = v23;
    if (a13 == -3)
      v25 = 5;
    if (a13 == -5)
      v26 = 5;
    else
      v26 = v25;
  }
  v94 = a2 + 56;
  mDNS_SetupResourceRecord(a2 + 56, 0, a13, 12, 0x1194u, 4, v26, (uint64_t)ServiceCallback, a2);
  mDNS_SetupResourceRecord(a2 + 1232, 0, a13, 12, 0x1194u, 8, v26, (uint64_t)ServiceCallback, a2);
  if ((a16 & 0x1000000) != 0)
    *(_BYTE *)(a2 + 1355) = 1;
  v97 = -65540;
  v27 = a2 + 2408;
  mDNS_SetupResourceRecord(a2 + 2408, 0, a13, 33, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  v28 = a2 + 3584;
  mDNS_SetupResourceRecord(a2 + 3584, a8, a13, 16, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  if (a7)
  {
    v29 = *(unsigned __int16 **)(a2 + 3632);
    if (*v29 < a10)
      *v29 = a10;
    v30 = a5;
    if (!ConstructServiceName((_BYTE *)(a2 + 708), "\t_services", "\a_dns-sd\x04_udp", a5)
      || !ConstructServiceName((_BYTE *)(a2 + 1884), 0, a4, a5)
      || !ConstructServiceName((_BYTE *)(a2 + 3060), a3, a4, a5))
    {
      return v97;
    }
    v31 = *(_BYTE **)(a2 + 2448);
    v32 = v31;
    if (v31 == (_BYTE *)-256)
    {
LABEL_40:
      while (v32)
      {
        v33 = *v32;
        if (v33 > 0x3F)
          break;
        if (!*v32)
        {
          v42 = (_WORD)v32 - (_WORD)v31 + 1;
          if (v42 > 0x100u)
            break;
          memcpy((void *)(a2 + 4236), v31, v42);
          goto LABEL_74;
        }
        v32 += v33 + 1;
        if (v31 != (_BYTE *)-256)
          goto LABEL_39;
      }
    }
    else
    {
LABEL_39:
      if (v32 < v31 + 256)
        goto LABEL_40;
    }
    *(_BYTE *)(a2 + 4236) = 0;
LABEL_74:
    v43 = *(_BYTE **)(a2 + 1272);
    v44 = v43;
    if (v43 == (_BYTE *)-256)
    {
LABEL_76:
      while (v44)
      {
        v45 = *v44;
        if (v45 > 0x3F)
          break;
        if (!*v44)
        {
          v46 = (_WORD)v44 - (_WORD)v43 + 1;
          if (v46 > 0x100u)
            break;
          memcpy((void *)(*(_QWORD *)(a2 + 104) + 4), v43, v46);
          goto LABEL_84;
        }
        v44 += v45 + 1;
        if (v43 != (_BYTE *)-256)
          goto LABEL_75;
      }
    }
    else
    {
LABEL_75:
      if (v44 < v43 + 256)
        goto LABEL_76;
    }
    *(_BYTE *)(*(_QWORD *)(a2 + 104) + 4) = 0;
LABEL_84:
    v47 = *(_BYTE **)(a2 + 2448);
    v48 = v47;
    if (v47 == (_BYTE *)-256)
    {
LABEL_86:
      while (v48)
      {
        v49 = *v48;
        if (v49 > 0x3F)
          break;
        if (!*v48)
        {
          v50 = (_WORD)v48 - (_WORD)v47 + 1;
          if (v50 > 0x100u)
            break;
          memcpy((void *)(*(_QWORD *)(a2 + 1280) + 4), v47, v50);
          goto LABEL_94;
        }
        v48 += v49 + 1;
        if (v47 != (_BYTE *)-256)
          goto LABEL_85;
      }
    }
    else
    {
LABEL_85:
      if (v48 < v47 + 256)
        goto LABEL_86;
    }
    *(_BYTE *)(*(_QWORD *)(a2 + 1280) + 4) = 0;
LABEL_94:
    *(_QWORD *)(a2 + 1304) = v27;
    *(_QWORD *)(a2 + 1312) = v28;
    if (a12)
    {
      v51 = 0;
      v52 = *(_QWORD *)(a2 + 40);
      do
      {
        memset(__dst, 0, sizeof(__dst));
        v54 = *(char **)(v52 + 1176 * v51 + 40);
        v53 = v54;
        if (v54 != (char *)-256)
        {
LABEL_97:
          v55 = 0;
          if (v54 >= v53 + 256 || !v54)
            goto LABEL_108;
          goto LABEL_101;
        }
        while (1)
        {
          if (!v54)
            goto LABEL_107;
LABEL_101:
          v56 = *v54;
          if (v56 > 0x3F)
            goto LABEL_107;
          if (!*v54)
            break;
          v54 += v56 + 1;
          if (v53 != (char *)-256)
            goto LABEL_97;
        }
        v57 = (_WORD)v54 - (_WORD)v53 + 1;
        if (v57 > 0x100u)
        {
LABEL_107:
          v55 = 0;
        }
        else
        {
          memcpy(__dst, v53, v57);
          v55 = LOBYTE(__dst[0]);
        }
LABEL_108:
        *((_BYTE *)__dst + v55 + 1) = 0;
        AppendDomainName(__dst, a4);
        mDNS_SetupResourceRecord(*(_QWORD *)(a2 + 40) + 1176 * v51, 0, a13, 12, 0x1194u, 8, v26, (uint64_t)ServiceCallback, a2);
        v30 = a5;
        if (!ConstructServiceName((_BYTE *)(*(_QWORD *)(a2 + 40) + 1176 * v51 + 652), 0, (unsigned __int8 *)__dst, a5))return v97;
        v58 = (_BYTE *)(a2 + 3060);
        if (a2 == -3316)
        {
LABEL_111:
          while (v58)
          {
            v59 = *v58;
            if (v59 > 0x3F)
              break;
            if (!*v58)
            {
              v60 = (_WORD)v58 - (a2 + 3060) + 1;
              if (v60 > 0x100u)
                break;
              memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 1176 * v51 + 48) + 4), (const void *)(a2 + 3060), v60);
              goto LABEL_119;
            }
            v58 += v59 + 1;
            if (a2 != -3316)
              goto LABEL_110;
          }
        }
        else
        {
LABEL_110:
          if ((unint64_t)v58 < a2 + 3316)
            goto LABEL_111;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 1176 * v51 + 48) + 4) = 0;
LABEL_119:
        v52 = *(_QWORD *)(a2 + 40);
        v61 = v52 + 1176 * v51;
        *(_QWORD *)(v61 + 72) = v27;
        *(_QWORD *)(v61 + 80) = v28;
        ++v51;
      }
      while (v51 != a12);
    }
    *(_WORD *)(*(_QWORD *)(a2 + 2456) + 4) = 0;
    *(_WORD *)(*(_QWORD *)(a2 + 2456) + 6) = 0;
    *(_WORD *)(*(_QWORD *)(a2 + 2456) + 8) = a7;
    if (a6 && *a6)
    {
      v62 = a6;
      v63 = a1;
      v64 = a9;
      if (a6 == (_BYTE *)-256)
      {
LABEL_124:
        while (v62)
        {
          v65 = *v62;
          if (v65 > 0x3F)
            break;
          if (!*v62)
          {
            v66 = (_WORD)v62 - (_WORD)a6 + 1;
            if (v66 > 0x100u)
              break;
            memcpy((void *)(*(_QWORD *)(a2 + 2456) + 10), a6, v66);
            goto LABEL_133;
          }
          v62 += v65 + 1;
          if (a6 != (_BYTE *)-256)
            goto LABEL_123;
        }
      }
      else
      {
LABEL_123:
        if (v62 < a6 + 256)
          goto LABEL_124;
      }
      *(_BYTE *)(*(_QWORD *)(a2 + 2456) + 10) = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 2528) = 1;
      *(_BYTE *)(*(_QWORD *)(a2 + 2456) + 10) = 0;
      v63 = a1;
      v64 = a9;
    }
LABEL_133:
    if (v64)
    {
      v67 = *(unsigned __int16 **)(a2 + 3632);
      if (v67 + 2 != v64)
      {
        *(_WORD *)(a2 + 3604) = a10;
        if (*v67 < a10)
          return v97;
        memcpy(v67 + 2, v64, a10);
      }
    }
    else
    {
      *(_WORD *)(a2 + 3604) = 0;
    }
    *(_QWORD *)(a2 + 3672) = v27;
    mDNS_Lock_(v63, (uint64_t)"mDNS_RegisterService", 17472);
    v74 = mDNS_Register_internal((uint64_t)v63, a2 + 2408, v68, v69, v70, v71, v72, v73);
    if (v74)
    {
      v97 = v74;
      mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17482);
    }
    else
    {
      v87 = mDNS_Register_internal((uint64_t)v63, a2 + 3584, v75, v76, v77, v78, v79, v80);
      if (!v87)
        v87 = mDNS_Register_internal((uint64_t)v63, v94, v81, v82, v83, v84, v85, v86);
      if (a12)
      {
        v88 = 0;
        do
        {
          if (!v87)
            v87 = mDNS_Register_internal((uint64_t)v63, *(_QWORD *)(a2 + 40) + v88, v81, v82, v83, v84, v85, v86);
          v88 += 1176;
        }
        while (1176 * a12 != v88);
      }
      if (v87)
      {
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17495);
      }
      else
      {
        v87 = mDNS_Register_internal((uint64_t)v63, a2 + 1232, v81, v82, v83, v84, v85, v86);
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17495);
        if (!v87)
        {
          if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4)
          {
            if (SameDomainNameBytes(v30, "\x05local"))
              unicast_assist_auth_add(*(_BYTE **)(a2 + 1272), *(unsigned int *)(a2 + 1256), a13);
          }
          return 0;
        }
      }
      v97 = v87;
      mDNS_DeregisterService_drt(v63, a2, 0, v89, v90, v91, v92, v93);
    }
  }
  else
  {
    if (a13 == -2)
    {
      v34 = 4;
    }
    else
    {
      v34 = 5;
      if (a13 != -5 && a13 != -3)
      {
        v35 = (a16 & 0x100000) == 0;
        v36 = (a16 & 0x20000) != 0 && a13 == 0;
        v37 = !v36;
        if (!v36)
          v35 = 1;
        if (v35)
          v38 = 1;
        else
          v38 = 3;
        if (a13)
          v39 = 1;
        else
          v39 = (a16 & 0x100000) == 0;
        if (v39)
          v40 = 0;
        else
          v40 = 2;
        if (v37 == 1)
          v34 = v40;
        else
          v34 = v38;
      }
    }
    mDNS_SetupResourceRecord(a2 + 2408, 0, a13, 33, 0x1194u, 2, v34, (uint64_t)NSSCallback, a2);
    if (ConstructServiceName((_BYTE *)(a2 + 3060), a3, a4, a5))
    {
      *(_WORD *)(*(_QWORD *)(a2 + 2456) + 4) = 0;
      *(_WORD *)(*(_QWORD *)(a2 + 2456) + 6) = 0;
      *(_WORD *)(*(_QWORD *)(a2 + 2456) + 8) = 0;
      *(_BYTE *)(a2 + 2528) = 1;
      return mDNS_Register(a1, a2 + 2408);
    }
  }
  return v97;
}

void ServiceCallback(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _BYTE *v15;
  int v16;
  NSObject *v17;
  const char *v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  _BYTE *v24;
  uint64_t v25;
  int v26;
  int v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;

  v8 = a3;
  v11 = *(_QWORD *)(a2 + 112);
  v12 = v11 + 2408;
  if (!(_DWORD)a3 && v12 != a2)
    return;
  if ((_DWORD)a3 != -65792)
  {
    if ((_DWORD)a3 == -65548)
    {
      *(_BYTE *)(v11 + 16) = 1;
      mDNS_DeregisterService_drt(a1, v11, 0, a4, a5, a6, a7, a8);
      return;
    }
    v16 = 1;
LABEL_31:
    v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_65;
      v19 = "";
      if (!v16)
        v19 = "un";
      v20 = *(_QWORD *)(v11 + 1272);
      if (v20)
      {
        v21 = *(_BYTE **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_42:
          while (v21)
          {
            v22 = *v21;
            if (v22 > 0x3F)
              break;
            if (!*v21)
            {
              v26 = (unsigned __int16)((_WORD)v21 - v20 + 1);
              goto LABEL_64;
            }
            v21 += v22 + 1;
            if (v20 != -256)
              goto LABEL_41;
          }
        }
        else
        {
LABEL_41:
          if ((unint64_t)v21 < v20 + 256)
            goto LABEL_42;
        }
        v26 = 257;
      }
      else
      {
        v26 = 0;
      }
    }
    else
    {
      v17 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_65;
      v19 = "";
      if (!v16)
        v19 = "un";
      v20 = *(_QWORD *)(v11 + 1272);
      if (v20)
      {
        v24 = *(_BYTE **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_53:
          while (v24)
          {
            v25 = *v24;
            if (v25 > 0x3F)
              break;
            if (!*v24)
            {
              v26 = (unsigned __int16)((_WORD)v24 - v20 + 1);
              goto LABEL_64;
            }
            v24 += v25 + 1;
            if (v20 != -256)
              goto LABEL_52;
          }
        }
        else
        {
LABEL_52:
          if ((unint64_t)v24 < v20 + 256)
            goto LABEL_53;
        }
        v26 = 257;
      }
      else
      {
        v26 = 0;
      }
    }
LABEL_64:
    v27 = 136446979;
    v28 = v19;
    v29 = 2160;
    v30 = 1752392040;
    v31 = 1040;
    v32 = v26;
    v33 = 2101;
    v34 = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "ServiceCallback: All records %{public}sregistered for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v27, 0x26u);
LABEL_65:
    if (*(_QWORD *)v11)
      (*(void (**)(unsigned int *, uint64_t, uint64_t))v11)(a1, v11, v8);
    return;
  }
  if (*(_BYTE *)(v11 + 2416) || *(_BYTE *)(v11 + 3592) || *(_BYTE *)(v11 + 1240) || *(_BYTE *)(v11 + 64))
    return;
  v13 = *(uint64_t **)(v11 + 24);
  v14 = *(unsigned int *)(v11 + 32);
  if ((_DWORD)v14)
  {
    v15 = (_BYTE *)(*(_QWORD *)(v11 + 40) + 8);
    while (!*v15)
    {
      v15 += 1176;
      if (!--v14)
        goto LABEL_15;
    }
  }
  else
  {
LABEL_15:
    if (!v13)
    {
LABEL_18:
      if (*(_BYTE *)(v11 + 16))
        v8 = 4294901748;
      else
        v8 = 4294901504;
      if (*(_QWORD *)(v11 + 2712))
        CompleteRDataUpdate((uint64_t)a1, v12, a3, a4, a5, a6, a7, a8);
      if (*(_QWORD *)(v11 + 3888))
        CompleteRDataUpdate((uint64_t)a1, v11 + 3584, a3, a4, a5, a6, a7, a8);
      if (*(_QWORD *)(v11 + 1536))
        CompleteRDataUpdate((uint64_t)a1, v11 + 1232, a3, a4, a5, a6, a7, a8);
      if (*(_QWORD *)(v11 + 360))
        CompleteRDataUpdate((uint64_t)a1, v11 + 56, a3, a4, a5, a6, a7, a8);
      v16 = 0;
      goto LABEL_31;
    }
    while (!*((_BYTE *)v13 + 24))
    {
      v13 = (uint64_t *)*v13;
      if (!v13)
        goto LABEL_18;
    }
  }
}

uint64_t GetServiceTarget(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int v5;
  int v6;
  _BYTE *v7;
  int v8;
  uint64_t result;
  uint64_t *v10;
  int v11;
  uint64_t *v12;
  int v13;
  BOOL v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  unsigned __int8 *v28;
  int v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int started;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD v61[4];

  if (!*(_BYTE *)(a2 + 120))
    return *(_QWORD *)(a2 + 48) + 10;
  v3 = a1;
  v4 = *(_BYTE **)(a2 + 40);
  v5 = *v4;
  if (*v4)
  {
    v6 = 0;
    do
    {
      ++v6;
      v7 = &v4[v5];
      v8 = v7[1];
      v4 = v7 + 1;
      v5 = v8;
    }
    while (v8);
  }
  else
  {
    v6 = 0;
  }
  v10 = *(uint64_t **)(a1 + 14680);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *((_DWORD *)v10 + 202);
      v14 = v13 == 2 || v13 == 5;
      if (v14 || ((v15 = *((_DWORD *)v10 + 496), v15 != 5) ? (v16 = v15 == 2) : (v16 = 1), v16))
      {
        v17 = *((unsigned __int8 *)v10 + 208);
        if (*((_BYTE *)v10 + 208))
        {
          v18 = 0;
          v19 = v10 + 26;
          do
          {
            ++v18;
            v20 = (uint64_t)v19 + v17;
            v21 = *(unsigned __int8 *)(v20 + 1);
            v19 = (uint64_t *)(v20 + 1);
            v17 = v21;
          }
          while (v21);
        }
        else
        {
          v18 = 0;
        }
        v22 = v18 >= v6 ? v6 : v18;
        if (v22 >= 1 && v22 > v11)
        {
          v24 = v6 + 1 - v22;
          v25 = v18 - v22 + 1;
          do
          {
            v26 = *(unsigned __int8 **)(a2 + 40);
            if (v6 - v22 >= 1)
            {
              v27 = v24;
              do
              {
                if (!*v26)
                  break;
                v26 += *v26 + 1;
                --v27;
              }
              while (v27 > 1);
            }
            v28 = (unsigned __int8 *)(v10 + 26);
            if (v18 - v22 >= 1)
            {
              v29 = v25;
              v28 = (unsigned __int8 *)(v10 + 26);
              do
              {
                if (!*v28)
                  break;
                v28 += *v28 + 1;
                --v29;
              }
              while (v29 > 1);
            }
            if (SameDomainNameBytes(v26, v28))
            {
              v12 = v10;
              v11 = v22;
            }
            if (v22 < 2)
              break;
            --v22;
            ++v24;
            ++v25;
          }
          while (v22 > v11);
        }
      }
      v10 = (uint64_t *)*v10;
    }
    while (v10);
    v3 = a1;
    if (v12)
      return (uint64_t)(v12 + 26);
  }
  result = v3 + 14168;
  if (!*(_BYTE *)(v3 + 14168))
  {
    if (*(_DWORD *)(v3 + 12980) == -1 && *(_DWORD *)(v3 + 12720))
    {
      v30 = (_DWORD *)(v3 + 13110);
      memset(v61, 0, 30);
      bzero((void *)(v3 + 12768), 0x2B8uLL);
      mDNS_snprintf(v61);
      *(_BYTE *)(v3 + 13144) = 0;
      if (AppendDNSNameString((_BYTE *)(v3 + 13144), (unsigned __int8 *)v61, v31, v32, v33, v34, v35, v36))
      {
        *(_QWORD *)(v3 + 12904) = 0;
        *(_DWORD *)(v3 + 13092) = 0;
        *v30 = 65548;
        *(_DWORD *)(v3 + 13400) = 0x1000000;
        *(_WORD *)(v3 + 13404) = 0;
        *(_BYTE *)(v3 + 13409) = 0;
        *(_WORD *)(v3 + 13407) = 0;
        *(_BYTE *)(v3 + 13420) = 0;
        *(_DWORD *)(v3 + 13012) = getpid();
        *(_DWORD *)(v3 + 13016) = 0;
        *(_QWORD *)(v3 + 12920) = FoundStaticHostname;
        *(_QWORD *)(v3 + 12944) = 0;
        if (mDNS_LoggingEnabled == 1)
        {
          v42 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)v30);
          LogMsgWithLevel(v42, OS_LOG_TYPE_DEFAULT, "GetStaticHostname: %##s (%s)", v43, v44, v45, v46, v47, v3 + 13144);
        }
        started = mDNS_StartQuery_internal(v3, v3 + 12768);
        if (started)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: GetStaticHostname - StartQuery returned error %d", v49, v50, v51, v52, v53, started);
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: GetStaticHostname - bad name %s", v37, v38, v39, v40, v41, (int)v61);
      }
    }
    if (mDNS_LoggingEnabled == 1)
    {
      v54 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(v3 + 47032));
      LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "GetServiceTarget: Returning NULL for %s", v55, v56, v57, v58, v59, v3 + 47032);
    }
    return 0;
  }
  return result;
}

void NetworkChanged(uint64_t a1, const __CFArray *a2, unsigned int *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t Count;
  int v14;
  CFIndex v15;
  CFIndex v16;
  CFMutableArrayRef Mutable;
  __CFArray *v18;
  const __CFString *v19;
  CFStringRef NetworkServiceEntity;
  CFStringRef v21;
  CFStringRef v22;
  CFStringRef v23;
  const __CFDictionary *v24;
  CFIndex v25;
  CFIndex v26;
  size_t v27;
  const void **v28;
  CFStringRef *v29;
  CFIndex v30;
  const __CFString *ValueAtIndex;
  const __CFString *v32;
  const __CFString *v33;
  CFIndex v34;
  CFTypeRef *v35;
  CFTypeID TypeID;
  const void *Value;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  CFStringRef v41;
  const void *v42;
  CFTypeID v43;
  const void *v44;
  int v45;
  int v46;
  CFIndex v47;
  const __CFString *v48;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v50;
  const __CFString *v51;
  int v52;
  CFIndex i;
  const __CFString *v54;
  NSObject *v55;
  NSObject *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  CFStringRef *v73;
  CFIndex v74;
  CFIndex v75;
  void **values;
  const __CFDictionary *theDict;
  int v78;
  int v79;
  int v80;
  int v81;
  const __CFString *cf;
  unsigned int *v83;
  unsigned int *v84;
  uint8_t buf[4];
  char *v86;
  char buffer[32];
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  CFRange v102;
  CFRange v103;
  CFRange v104;
  CFRange v105;

  v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  mDNS_Lock_(a3, (uint64_t)"NetworkChanged", 6611);
  Count = CFArrayGetCount(a2);
  v102.location = 0;
  v102.length = Count;
  v80 = CFArrayContainsValue(a2, v102, (const void *)NetworkChangedKey_Hostnames);
  v103.location = 0;
  v103.length = Count;
  v79 = CFArrayContainsValue(a2, v103, (const void *)NetworkChangedKey_Computername);
  v104.location = 0;
  v104.length = Count;
  v78 = CFArrayContainsValue(a2, v104, (const void *)NetworkChangedKey_DNS);
  v105.location = 0;
  v105.length = Count;
  v14 = CFArrayContainsValue(a2, v105, CFSTR("Setup:/Network/DynamicDNS"));
  v15 = CFArrayGetCount(a2);
  if (v15 >= 1 && (v16 = v15, (Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks)) != 0))
  {
    v18 = Mutable;
    v19 = kSCDynamicStoreDomainSetup;
    NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetInterface);
    if (!NetworkServiceEntity)
      goto LABEL_38;
    v21 = NetworkServiceEntity;
    CFArrayAppendValue(v18, NetworkServiceEntity);
    CFRelease(v21);
    v22 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv4);
    if (!v22)
      goto LABEL_38;
    v23 = v22;
    CFArrayAppendValue(v18, v22);
    CFRelease(v23);
    v24 = SCDynamicStoreCopyMultiple(0, 0, v18);
    CFRelease(v18);
    if (v24)
    {
      v25 = CFDictionaryGetCount(v24);
      if (v25 >= 1)
      {
        v26 = v25;
        v27 = (8 * v25);
        if (!(_DWORD)v27
          || (values = (void **)malloc_type_malloc((8 * v25), 0xA172743EuLL)) == 0
          || (v75 = v26, v83 = a3, (v28 = (const void **)malloc_type_malloc(v27, 0xA172743EuLL)) == 0))
        {
          __break(1u);
        }
        v29 = (CFStringRef *)v28;
        theDict = v24;
        CFDictionaryGetKeysAndValues(v24, v28, (const void **)values);
        v81 = 0;
        v30 = 0;
        v73 = v29;
        v74 = v16;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v30);
          v100 = 0u;
          v101 = 0u;
          v98 = 0u;
          v99 = 0u;
          v96 = 0u;
          v97 = 0u;
          v94 = 0u;
          v95 = 0u;
          v92 = 0u;
          v93 = 0u;
          v90 = 0u;
          v91 = 0u;
          v88 = 0u;
          v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          if (CFStringHasPrefix(ValueAtIndex, CFSTR("State:/Network/Interface/")))
          {
            if (CFStringHasSuffix(ValueAtIndex, kSCEntNetIPv4))
            {
              v32 = (const __CFString *)CopyNameFromKey(ValueAtIndex);
              if (v32)
                break;
            }
          }
LABEL_35:
          if (++v30 == v16)
          {
            free(values);
            free(v29);
            a3 = v83;
            v24 = theDict;
            goto LABEL_40;
          }
        }
        v33 = v32;
        if (mDNS_LoggingEnabled == 1 && !CFStringGetCString(v32, buffer, 256, 0x8000100u))
          buffer[0] = 0;
        v34 = v75;
        v35 = (CFTypeRef *)values;
        cf = v33;
        while (1)
        {
          if (!CFStringHasSuffix(*v29, kSCEntNetInterface))
            goto LABEL_33;
          TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(*v35))
            goto LABEL_33;
          Value = CFDictionaryGetValue((CFDictionaryRef)*v35, kSCPropNetInterfaceDeviceName);
          if (!Value)
            goto LABEL_33;
          if (!CFEqual(v33, Value))
            goto LABEL_33;
          v38 = (const __CFString *)CopyNameFromKey(*v29);
          if (!v38)
            goto LABEL_33;
          v39 = v38;
          v40 = v19;
          v41 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, v19, v38, kSCEntNetIPv4);
          CFRelease(v39);
          if (!v41)
            break;
          v42 = CFDictionaryGetValue(theDict, v41);
          CFRelease(v41);
          if (!v42)
            break;
          v43 = CFDictionaryGetTypeID();
          if (v43 != CFGetTypeID(v42))
            break;
          v44 = CFDictionaryGetValue((CFDictionaryRef)v42, kSCPropNetIPv4ConfigMethod);
          v19 = v40;
          if (!v44)
            goto LABEL_32;
          v45 = CFEqual(v44, kSCValNetIPv4ConfigMethodLinkLocal);
          v46 = v81;
          if (v45)
            v46 = v81 + 1;
          v81 = v46;
          v33 = cf;
          if (v45)
          {
LABEL_34:
            CFRelease(v33);
            v29 = v73;
            v16 = v74;
            goto LABEL_35;
          }
LABEL_33:
          ++v35;
          ++v29;
          if (!--v34)
            goto LABEL_34;
        }
        v19 = v40;
LABEL_32:
        v33 = cf;
        goto LABEL_33;
      }
      LOBYTE(v81) = 0;
LABEL_40:
      CFRelease(v24);
    }
    else
    {
LABEL_38:
      LOBYTE(v81) = 0;
    }
  }
  else
  {
    LOBYTE(v81) = 0;
  }
  if (Count >= 1)
  {
    v84 = a3;
    v47 = 0;
    while (1)
    {
      v48 = (const __CFString *)CFArrayGetValueAtIndex(a2, v47);
      if (CFStringHasPrefix(v48, (CFStringRef)NetworkChangedKey_StateInterfacePrefix)
        && (CFStringHasSuffix(v48, kSCEntNetIPv6) || CFStringHasSuffix(v48, kSCEntNetIPv4)))
      {
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v48, CFSTR("/"));
        if (!ArrayBySeparatingStrings)
          goto LABEL_54;
        v50 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
        {
          v100 = 0u;
          v101 = 0u;
          v98 = 0u;
          v99 = 0u;
          v96 = 0u;
          v97 = 0u;
          v94 = 0u;
          v95 = 0u;
          v92 = 0u;
          v93 = 0u;
          v90 = 0u;
          v91 = 0u;
          v88 = 0u;
          v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          v51 = (const __CFString *)CFArrayGetValueAtIndex(v50, 3);
          if (CFStringGetCString(v51, buffer, 256, 0x8000100u))
          {
            if (strstr(buffer, "p2p")
              || (getExtendedFlags((uint64_t)buffer) & 0x20100000) != 0
              || (util_is_car_play((uint64_t)buffer) & 1) != 0)
            {
              CFRelease(v50);
              v52 = 0;
LABEL_58:
              if ((mDNS_LoggingEnabled & 1) != 0)
              {
                for (i = 0; i != Count; ++i)
                {
                  v100 = 0u;
                  v101 = 0u;
                  v98 = 0u;
                  v99 = 0u;
                  v96 = 0u;
                  v97 = 0u;
                  v94 = 0u;
                  v95 = 0u;
                  v92 = 0u;
                  v93 = 0u;
                  v90 = 0u;
                  v91 = 0u;
                  v88 = 0u;
                  v89 = 0u;
                  memset(buffer, 0, sizeof(buffer));
                  v54 = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
                  if (!CFStringGetCString(v54, buffer, 256, 0x8000100u))
                    buffer[0] = 0;
                  v55 = mDNSLogCategory_State;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136446210;
                    v86 = buffer;
                    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** SC key: %{public}s", buf, 0xCu);
                  }
                }
                a3 = v84;
LABEL_66:
                v56 = mDNSLogCategory_State;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                {
                  v57 = v80 != 0;
                  if (v79)
                    v57 |= 2u;
                  if (v78)
                    v57 |= 4u;
                  if (v14)
                    v57 |= 8u;
                  if ((_BYTE)v81)
                    v57 |= 0x10u;
                  *(_DWORD *)buffer = 134218496;
                  *(_QWORD *)&buffer[4] = Count;
                  if (!v52)
                    v57 |= 0x20u;
                  *(_WORD *)&buffer[12] = 1024;
                  *(_DWORD *)&buffer[14] = 25;
                  *(_WORD *)&buffer[18] = 1026;
                  *(_DWORD *)&buffer[20] = v57;
                  _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** -- change count: %ld, delay: %d, flags: %{public, mdnsresponder:net_change_flags}d", (uint8_t *)buffer, 0x18u);
                }
              }
              goto LABEL_78;
            }
          }
        }
        CFRelease(v50);
      }
      if (Count == ++v47)
      {
LABEL_54:
        v52 = 1;
        goto LABEL_58;
      }
    }
  }
  if ((mDNS_LoggingEnabled & 1) != 0)
  {
    v52 = 1;
    goto LABEL_66;
  }
LABEL_78:
  SetNetworkChanged(25);
  if (v14)
  {
    v63 = *(_DWORD *)(mDNSStorage[0] + 500);
    v64 = dword_100158E08 + 25;
    if ((dword_100158E08 + 25) <= 1)
      v64 = 1;
    if (v63)
      v65 = v63 - v64 < 1;
    else
      v65 = 0;
    if (!v65)
    {
      *(_DWORD *)(mDNSStorage[0] + 500) = v64;
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetKeyChainTimer: %d", v58, v59, v60, v61, v62, 25);
    }
  }
  mDNS_Unlock_((uint64_t)a3, (uint64_t)"NetworkChanged", 6702);
  KQueueUnlock((uint64_t)"NetworkChanged", v66, v67, v68, v69, v70, v71, v72);
}

unint64_t KQueueLock()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t result;

  v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  result = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  *(_DWORD *)(mDNSStorage[0] + 680) = result;
  return result;
}

uint64_t mDNS_StartNATOperation_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t *v11;
  int v12;
  uint64_t result;

  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_StartNATOperation_internal %p Protocol %d IntPort %d RequestedPort %d NATLease %d", a4, a5, a6, a7, a8, a2);
  v10 = *(_QWORD *)(a1 + 14720);
  v11 = (uint64_t *)(a1 + 14720);
  if (v10)
  {
    v11 = (uint64_t *)(a1 + 14720);
    while (v10 != a2)
    {
      if (*(_BYTE *)(a2 + 172) && *(unsigned __int8 *)(a2 + 172) == *(unsigned __int8 *)(v10 + 172))
      {
        v12 = *(unsigned __int16 *)(a2 + 174);
        if (v12 == *(unsigned __int16 *)(v10 + 174) && v12 != 5632)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Warning: Created port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p Prot %d Int %d TTL %d", a4, a5, a6, a7, a8, a2);
          v10 = *v11;
        }
      }
      v11 = (uint64_t *)v10;
      v10 = *(_QWORD *)v10;
      if (!v10)
        goto LABEL_14;
    }
    LogFatalError("Error! Tried to add a NAT traversal that's already in the active list: request %p Prot %d Int %d TTL %d", a2, a3, a4, a5, a6, a7, a8, a2);
    return 4294901749;
  }
  else
  {
LABEL_14:
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0xFA00000000;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 64);
    *(_BYTE *)(a2 + 28) = 0;
    *(_QWORD *)(a2 + 20) = 0;
    *(_QWORD *)(a2 + 152) = 0xFFFFFFFFLL;
    *(_WORD *)(a2 + 160) = 0;
    *(_DWORD *)(a2 + 164) = 0;
    *(_DWORD *)(a2 + 168) = 0;
    if (!*(_DWORD *)(a2 + 180))
      *(_DWORD *)(a2 + 180) = 7200;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    if (!*(_QWORD *)(a1 + 14720))
    {
      *(_DWORD *)(a1 + 14740) = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 14736) = 250;
    }
    if (!*(_BYTE *)(a2 + 172))
      *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14744);
    result = 0;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
    *v11 = a2;
  }
  return result;
}

void send_all(int a1, const void *a2, size_t a3)
{
  unint64_t v5;
  NSObject *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = send(a1, a2, a3, 0);
  if ((v5 & 0x8000000000000000) != 0 || v5 < a3)
  {
    v6 = mDNSLogCategory_Default;
    __error();
    v7 = __error();
    strerror(*v7);
    LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "ERROR: send_all(%d) wrote %ld of %lu errno %d (%s)", v8, v9, v10, v11, v12, a1);
  }
}

void uDNS_SendNATMsg(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v7;
  uint64_t v8;
  const char *v10;
  int *v12;
  NSObject *v13;
  uint32_t v14;
  int *v15;
  int v16;
  int v17;
  char v18;
  __int16 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  char v28;
  unsigned int v29;
  int v30;
  char v31;
  char v32;
  char v33;
  char v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  char v40;
  __int16 v41;
  char v42;
  __int16 v43;
  __int16 v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;

  if (!a2)
  {
    v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v30) = 0;
      v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }
    else
    {
      v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v30) = 0;
      v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }
    v12 = &v30;
    v13 = v8;
    v14 = 2;
    goto LABEL_17;
  }
  v7 = *(unsigned __int8 *)(a1 + 12700);
  if (v7 != 10)
  {
    if (v7 == 172)
    {
      if ((*(_BYTE *)(a1 + 12701) & 0xF0) != 0x10)
        return;
    }
    else if (v7 != 192 || *(unsigned __int8 *)(a1 + 12701) != 168)
    {
      return;
    }
  }
  v15 = (int *)(a1 + 12696);
  if (a3)
  {
    v30 = 258;
    v16 = *(_DWORD *)(a2 + 180);
    v31 = HIBYTE(v16);
    v32 = BYTE2(v16);
    v33 = BYTE1(v16);
    v34 = v16;
    v35 = 0;
    v36 = -65536;
    v37 = *(_DWORD *)(a1 + 12720);
    v38 = *(_QWORD *)(a1 + 14748);
    v39 = *(_DWORD *)(a1 + 14756);
    v17 = *(unsigned __int8 *)(a2 + 172);
    if (v17 == 1)
      v18 = 17;
    else
      v18 = 6;
    v40 = v18;
    v41 = 0;
    v42 = 0;
    if (v17)
      v19 = (__int16 *)(a2 + 174);
    else
      v19 = (__int16 *)&DiscardPort;
    v43 = *v19;
    v44 = *(_WORD *)(a2 + 176);
    v45 = 0;
    v46 = -65536;
    v47 = *(_DWORD *)(a2 + 156);
    mDNSPlatformSendUDP((_QWORD *)a1, (unsigned __int16 *)&v30, (uint64_t)&v48, 0, 0, v15, 0xE714u, 0);
    *(_BYTE *)(a2 + 28) = 0;
    if (!a4)
    {
      if (!*(_WORD *)(a1 + 15034) || !*(_WORD *)(a1 + 15036))
      {
        LNT_SendDiscoveryMsg(a1);
        return;
      }
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_MapPort", v20, v21, v22, v23, v24, v30);
      if (!*(_QWORD *)(a2 + 56))
      {
        *(_QWORD *)(a2 + 48) = a2;
        *(_DWORD *)(a2 + 136) = 0;
        v25 = SendPortMapRequest(a1, a2);
        if (v25)
        {
          v26 = v25;
          v27 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
              return;
            v49 = 67109120;
            v50 = v26;
            v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }
          else
          {
            v27 = mDNSLogCategory_NAT_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            v49 = 67109120;
            v50 = v26;
            v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }
          v12 = &v49;
          v13 = v27;
          v14 = 8;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)v12, v14);
        }
      }
    }
  }
  else if (!*(_BYTE *)(a2 + 28))
  {
    v28 = *(_BYTE *)(a2 + 172);
    if (v28)
    {
      uDNS_SendNATMsg_NATPortReq = 0;
      byte_10014DDD5 = v28;
      word_10014DDD6 = 0;
      v29 = bswap32(*(_DWORD *)(a2 + 180));
      dword_10014DDD8 = *(_DWORD *)(a2 + 174);
      unk_10014DDDC = v29;
      mDNSPlatformSendUDP((_QWORD *)a1, (unsigned __int16 *)&uDNS_SendNATMsg_NATPortReq, (uint64_t)&uDNS_RequestAddress_req, 0, 0, v15, 0xE714u, 0);
    }
    *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14744);
    *(_BYTE *)(a2 + 28) = 1;
  }
}

void KQueueUnlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  NSObject *v10;
  NSObject *v13;
  int v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  int v24;

  v9 = mDNSPlatformRawTime(a1, a2, a3, a4, a5, a6, a7, a8) - *(_DWORD *)(mDNSStorage + 680);
  if (v9 < WatchDogReportingThreshold)
    goto LABEL_11;
  v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
  }
  else
  {
    v10 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
  }
  *(_DWORD *)buf = 136446466;
  v22 = a1;
  v23 = 1024;
  v24 = v9;
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "WARNING: %{public}s took %d ms to complete", buf, 0x12u);
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(mDNSStorage + 616));
  buf[0] = 1;
  if (send(*(_DWORD *)(mDNSStorage + 684), buf, 1uLL, 0) == -1)
  {
    v13 = mDNSLogCategory_Default;
    v14 = *__error();
    v15 = __error();
    strerror(*v15);
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "ERROR: KQueueWake: send failed with error code: %d (%s)", v16, v17, v18, v19, v20, v14);
  }
}

ssize_t KQWokenFlushBytes(int a1)
{
  ssize_t result;
  _OWORD v3[6];
  int v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  do
    result = recv(a1, v3, 0x64uLL, 128);
  while (result > 0);
  return result;
}

uint64_t mDNS_NewMessageID(uint64_t a1)
{
  int v2;
  uint64_t **v3;
  uint32_t v4;
  uint64_t result;
  uint64_t **v6;
  uint64_t v7;

  v2 = 0;
  v3 = (uint64_t **)(a1 + 12616);
  do
LABEL_2:
    v4 = arc4random();
  while ((_WORD)v4 == 0xFFFF);
  result = bswap32(v4 + 1) >> 16;
  v6 = v3;
  while (1)
  {
    v6 = (uint64_t **)*v6;
    if (!v6)
      break;
    if (*((unsigned __int16 *)v6 + 179) == (_DWORD)result)
      goto LABEL_6;
  }
  v7 = *(_QWORD *)(a1 + 192);
  if (!v7)
    return result;
  while (*(unsigned __int16 *)(v7 + 340) != (_DWORD)result)
  {
    v7 = *(_QWORD *)(v7 + 8);
    if (!v7)
      return result;
  }
LABEL_6:
  if (++v2 != 10)
    goto LABEL_2;
  return result;
}

void ActivateUnicastQuery(uint64_t a1, uint64_t a2, int a3)
{
  void *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  BOOL v17;
  int v18;
  BOOL v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!*(_QWORD *)(a2 + 40))
  {
    *(_BYTE *)(a2 + 353) = 0;
    v6 = *(void **)(a2 + 104);
    if (v6)
    {
      CancelGetZoneData(a1, v6);
      *(_QWORD *)(a2 + 104) = 0;
    }
    if (*(_BYTE *)(a2 + 632))
    {
      *(_BYTE *)(a2 + 350) = 1;
      *(_QWORD *)(a2 + 328) = 0;
      *(_WORD *)(a2 + 336) = 0;
      v7 = *(_QWORD *)(a2 + 112);
      if (v7)
      {
        DisposeTCPConn(v7);
        *(_QWORD *)(a2 + 112) = 0;
      }
    }
    if (a3)
    {
      v8 = AuthGroupForName(a1 + 6264, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 376));
      if (v8 && (v15 = v8[2]) != 0)
      {
        while (1)
        {
          if (*(_DWORD *)(v15 + 172) == 4 && (*(_BYTE *)(v15 + 8) & 0x32) != 0)
          {
            v16 = *(unsigned __int16 *)(v15 + 12);
            v17 = v16 > 0x1C;
            v18 = (1 << v16) & 0x10001022;
            v19 = v17 || v18 == 0;
            if (!v19 && LocalOnlyRecordAnswersQuestion(v15, a2, v9, v10, v11, v12, v13, v14))
              break;
          }
          v15 = *(_QWORD *)v15;
          if (!v15)
            goto LABEL_19;
        }
        if (mDNS_LoggingEnabled == 1)
        {
          v20 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          GetRRDisplayString_rdb((unsigned __int8 *)(v15 + 8), (unsigned __int16 *)(*(_QWORD *)(v15 + 48) + 4), (_BYTE *)(a1 + 47032));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "QuestionHasLocalAnswers: Question %p %##s (%s) has local answer %s", v21, v22, v23, v24, v25, a2);
        }
      }
      else
      {
LABEL_19:
        *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64) - 334;
        *(_DWORD *)(a2 + 212) = 334;
        SetNextQueryTime(a1, a2);
      }
    }
  }
}

uint64_t *CacheGroupForName(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t *i;

  for (i = *(uint64_t **)(a1 + 8 * (a2 % 0x1F3) + 272); i; i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 2) == a2 && SameDomainNameBytes((_BYTE *)i[4], a3))
      break;
  }
  return i;
}

void MakeNegativeCacheRecord(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, __int16 a6, int a7, uint64_t a8, void *a9, __int16 a10)
{
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;

  if (a1 + 37912 == a2)
  {
    v18 = (unsigned __int8 *)(a1 + 37920);
    if (*(_BYTE *)(a1 + 37920))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4), (_BYTE *)(a1 + 47032));
      LogFatalError("MakeNegativeCacheRecord: m->rec appears to be already in use for %s", v19, v20, v21, v22, v23, v24, v25, a1 + 47032);
    }
  }
  *(_BYTE *)(a2 + 8) = -16;
  *(_QWORD *)(a2 + 32) = a8;
  v26 = *(void **)(a2 + 56);
  if (v26)
  {
    os_release(v26);
    *(_QWORD *)(a2 + 56) = 0;
  }
  if (a9)
  {
    v27 = mdns_cache_metadata_create();
    *(_QWORD *)(a2 + 56) = v27;
    mdns_dns_push_service_definition_set_srv_name(v27, a9);
  }
  *(_WORD *)(a2 + 152) = 0;
  v28 = a2 + 152;
  *(_WORD *)(v28 - 140) = a5;
  *(_WORD *)(v28 - 138) = a6;
  *(_DWORD *)(v28 - 136) = a7;
  *(_DWORD *)(v28 - 132) = 0;
  *(_DWORD *)(v28 - 128) = a4;
  *(_DWORD *)(v28 - 124) = 0;
  *(_QWORD *)(v28 - 112) = a3;
  *(_QWORD *)(v28 - 104) = v28;
  *(_QWORD *)(v28 - 88) = 0;
  *(_QWORD *)(v28 - 80) = 0;
  v29 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v28 - 72) = v29;
  *(_DWORD *)(v28 - 68) = 0;
  *(_DWORD *)(v28 - 64) = v29;
  *(_BYTE *)(v28 - 44) = 0;
  *(_QWORD *)(v28 - 60) = 0;
  *(_QWORD *)(v28 - 52) = 0;
  *(_QWORD *)(v28 - 40) = 0;
  *(_QWORD *)(v28 - 32) = 0;
  *(_WORD *)(v28 - 42) = a10;
  *(_BYTE *)(v28 - 143) = HIBYTE(a10) & 0xF;
}

uint64_t GetCacheEntity(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v11;
  unsigned int v12;
  NSObject *v13;
  unsigned int v16;
  NSObject *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD **v24;
  uint64_t v25;
  uint64_t *v26;
  _QWORD *v27;
  NSObject *v29;
  int v32;
  unsigned int v33;
  NSObject *v34;
  unsigned int v37;
  int v38;
  int v40;
  unsigned int v41;
  __int16 v42;
  unsigned int v43;
  __int16 v44;
  int v45;

  if (!*(_BYTE *)(a1 + 56))
  {
    *(_BYTE *)(a1 + 56) = 1;
    v8 = *(_QWORD *)(a1 + 264);
    if (v8)
      goto LABEL_54;
    if (!*(_QWORD *)(a1 + 32))
      goto LABEL_23;
    v12 = *(_DWORD *)(a1 + 240);
    v11 = *(_DWORD *)(a1 + 244);
    if (v11 == v12)
    {
LABEL_16:
      if (v11 < 0x1389 || (v16 = *(_DWORD *)(a1 + 252), v16 >= v11 >> 5))
      {
        v18 = *(_DWORD *)(a1 + 48);
        v19 = *(_DWORD *)(a1 + 52) + 1;
        *(_DWORD *)(a1 + 52) = v19;
        mDNS_VerifyLockState("Drop Lock", 0, v18, v19, (uint64_t)"GetCacheEntity", 6405);
        (*(void (**)(uint64_t, uint64_t))(a1 + 32))(a1, 4294901506);
        mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"GetCacheEntity", 6407);
        --*(_DWORD *)(a1 + 52);
        goto LABEL_23;
      }
      v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_23;
      }
      else
      {
        v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_23;
      }
      v40 = 67109376;
      v41 = v11;
      v42 = 1024;
      v43 = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Possible denial-of-service attack in progress: m->rrcache_size %u; m->rrcache_active %u",
        (uint8_t *)&v40,
        0xEu);
LABEL_23:
      v8 = *(_QWORD *)(a1 + 264);
      if (v8)
        goto LABEL_54;
      v20 = 0;
      v21 = *(_DWORD *)(a1 + 244);
      do
      {
        v22 = a1 + 8 * v20;
        v23 = *(_QWORD **)(v22 + 272);
        if (v23)
        {
          v24 = (_QWORD **)(v22 + 272);
          do
          {
            v26 = v23 + 2;
            v25 = v23[2];
            if (v25)
            {
              do
              {
                if (*(_QWORD *)(v25 + 96) || *(_QWORD *)(v25 + 112) || *(_DWORD *)(v25 + 84) || *(_BYTE *)(v25 + 128))
                {
                  v26 = (uint64_t *)v25;
                }
                else
                {
                  *v26 = *(_QWORD *)v25;
                  ReleaseCacheRecord(a1, v25);
                }
                v25 = *v26;
              }
              while (*v26);
              v23 = *v24;
            }
            v23[3] = v26;
            v27 = *v24;
            if (*v24 != a2 && (*v24)[2] == 0)
            {
              ReleaseCacheGroup(a1, v24);
              v27 = v24;
            }
            v23 = (_QWORD *)*v27;
            v24 = (_QWORD **)v27;
          }
          while (*v27);
        }
        ++v20;
      }
      while (v20 != 499);
      v29 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_53;
      }
      else
      {
        v29 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_53:
          v8 = *(_QWORD *)(a1 + 264);
          if (!v8)
          {
LABEL_72:
            *(_BYTE *)(a1 + 56) = 0;
            return v8;
          }
LABEL_54:
          *(_QWORD *)(a1 + 264) = *(_QWORD *)v8;
          v33 = *(_DWORD *)(a1 + 244) + 1;
          *(_DWORD *)(a1 + 244) = v33;
          if (v33 < *(_DWORD *)(a1 + 256))
          {
LABEL_71:
            *(_OWORD *)(v8 + 192) = 0u;
            *(_OWORD *)(v8 + 208) = 0u;
            *(_OWORD *)(v8 + 160) = 0u;
            *(_OWORD *)(v8 + 176) = 0u;
            *(_OWORD *)(v8 + 128) = 0u;
            *(_OWORD *)(v8 + 144) = 0u;
            *(_OWORD *)(v8 + 96) = 0u;
            *(_OWORD *)(v8 + 112) = 0u;
            *(_OWORD *)(v8 + 64) = 0u;
            *(_OWORD *)(v8 + 80) = 0u;
            *(_OWORD *)(v8 + 32) = 0u;
            *(_OWORD *)(v8 + 48) = 0u;
            *(_OWORD *)v8 = 0u;
            *(_OWORD *)(v8 + 16) = 0u;
            goto LABEL_72;
          }
          v34 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            {
              v40 = 67109120;
              v41 = v33;
LABEL_64:
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "RR Cache now using %u objects", (uint8_t *)&v40, 8u);
            }
          }
          else
          {
            v34 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v40 = 67109120;
              v41 = v33;
              goto LABEL_64;
            }
          }
          v37 = *(_DWORD *)(a1 + 256);
          if (v37 >= 0x3E8)
            v38 = 1000;
          else
            v38 = 100;
          if (v37 < 0x64)
            v38 = 10;
          *(_DWORD *)(a1 + 256) = v37 + v38;
          goto LABEL_71;
        }
      }
      v32 = *(_DWORD *)(a1 + 244);
      v40 = 67109632;
      v41 = v21 - v32;
      v42 = 1024;
      v43 = v21;
      v44 = 1024;
      v45 = v32;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "GetCacheEntity recycled %d records to reduce cache from %d to %d", (uint8_t *)&v40, 0x14u);
      goto LABEL_53;
    }
    v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        v11 = *(_DWORD *)(a1 + 240);
        goto LABEL_16;
      }
    }
    else
    {
      v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_15;
    }
    v40 = 67109376;
    v41 = v11;
    v42 = 1024;
    v43 = v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR: count mismatch: m->rrcache_totalused %u != m->rrcache_size %u", (uint8_t *)&v40, 0xEu);
    goto LABEL_15;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR ERROR! Cache already locked!", a4, a5, a6, a7, a8, v40);
  return 0;
}

BOOL SameNameRecordAnswersQuestion(unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _BOOL8 result;
  uint64_t v13;
  BOOL v14;
  uint64_t v16;
  uint64_t v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;

  v9 = *((_QWORD *)a1 + 3);
  if ((unint64_t)(v9 + 5) <= 3 && v9 != -4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SameNameRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p", a4, a5, a6, a7, a8, v9);
    return 0;
  }
  if (*(_BYTE *)(a3 + 354) && (!*(_BYTE *)(a3 + 645) || *((_WORD *)a1 + 2) != 5))
    return 0;
  if (v9)
  {
    v13 = *(_QWORD *)(a3 + 136);
    v14 = v13 == -2 || v13 == 0;
    if (!v14 && v9 != v13)
      return 0;
  }
  v16 = *(_QWORD *)(a3 + 80);
  if (v16 && (*(_WORD *)(v16 + 276) & 0x4000) != 0)
  {
    v19 = *((_QWORD *)a1 + 6);
    if (v19)
      v19 = *(_QWORD *)(v19 + 24);
  }
  else
  {
    v17 = *((_QWORD *)a1 + 6);
    v18 = (!v17 || !*(_QWORD *)(v17 + 24)) && v9 != 0;
    if (v18 | a2)
    {
      if (v18 && *(_WORD *)(a3 + 340))
        return 0;
      goto LABEL_36;
    }
    if (!*(_WORD *)(a3 + 340))
      return 0;
    if (v17)
      v19 = *(_QWORD *)(v17 + 24);
    else
      v19 = 0;
  }
  if (v19 != v16)
    return 0;
LABEL_36:
  if (*((_WORD *)a1 + 2) == 5 && *a1 == 240 && *(_WORD *)(a3 + 342) != 5)
    return 0;
  v20 = *(_QWORD *)(a3 + 144);
  if (v20)
    v21 = *(unsigned __int8 *)(v20 + 24);
  else
    v21 = 0;
  if (v20)
    v22 = v21 | 2;
  else
    v22 = v21;
  result = RRTypeAnswersQuestionType((uint64_t)a1, *(unsigned __int16 *)(a3 + 342), v22, a4, a5, a6, a7, a8);
  if (result)
  {
    v23 = *(unsigned __int16 *)(a3 + 344);
    if (*((unsigned __int16 *)a1 + 3) == v23 || v23 == 255)
    {
      v24 = *((_QWORD *)a1 + 3);
      if (!v24 || v24 == *(_QWORD *)(a3 + 136) || v24 != AWDLInterfaceID && v24 != WiFiAwareInterfaceID)
        return 1;
      if ((*(_BYTE *)(a3 + 326) & 0x10) != 0)
        return 1;
    }
    return 0;
  }
  return result;
}

void CheckCacheExpiration(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v11;
  uint64_t *v12;
  int *v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  NSObject *v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  NSObject *v51;
  uint64_t v52;
  uint8_t buf[4];
  unsigned int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;

  if (*(_BYTE *)(a1 + 56))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CheckCacheExpiration ERROR! Cache already locked!", a4, a5, a6, a7, a8, a9);
    return;
  }
  v12 = (uint64_t *)(a3 + 16);
  v11 = *(_QWORD *)(a3 + 16);
  *(_BYTE *)(a1 + 56) = 1;
  if (v11)
  {
    v13 = (int *)(a1 + 4 * a2 + 4264);
    while (1)
    {
      if (*(_BYTE *)(v11 + 109))
        v14 = dword_100158E08 + 939524096;
      else
        v14 = *(_DWORD *)(v11 + 80) + 1000 * *(_DWORD *)(v11 + 16);
      v15 = *(_DWORD *)(a1 + 64);
      if (v15 - v14 < 0)
      {
        v17 = *(_DWORD *)(v11 + 84);
        if (v17 && v17 - v15 > 0)
        {
          v14 = *(_DWORD *)(v11 + 84);
        }
        else
        {
          if (v17)
            CacheRecordDeferredAdd((_QWORD *)a1, v11, a3, a4, a5, a6, a7, a8);
          if (*(_QWORD *)(v11 + 96) && *(unsigned __int8 *)(v11 + 108) <= 3u)
          {
            v18 = *(_DWORD *)(a1 + 64);
            v19 = *(_DWORD *)(v11 + 88);
            if (v18 - v19 < 0)
            {
              v52 = 1374389535000 * *(_DWORD *)(v11 + 16);
              v18 = (v52 >> 36) + ((unint64_t)v52 >> 63);
            }
            else
            {
              *(_DWORD *)(a1 + 92) = v18;
              v19 = 939524096;
            }
            v14 = v18 + v19;
          }
        }
        goto LABEL_83;
      }
      v16 = *(_QWORD *)(v11 + 96);
      if (v16)
        break;
LABEL_68:
      v50 = *(unsigned __int8 *)(v11 + 10);
      if (*(_BYTE *)(v11 + 10) && *(_DWORD *)(v11 + 16))
      {
        v14 += 604800000;
        if (v50 == 1)
        {
          *(_BYTE *)(v11 + 10) = 2;
          if (*(_DWORD *)(v11 + 84))
          {
            *(_DWORD *)(v11 + 84) = 0;
            v51 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                goto LABEL_80;
            }
            else
            {
              v51 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_80:
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "CheckCacheExpiration: Resetting DelayDelivery for new ghost", buf, 2u);
              }
            }
          }
LABEL_83:
          if (*v13 - v14 >= 1)
            *v13 = v14;
          v12 = (uint64_t *)v11;
          goto LABEL_86;
        }
        if (v50 != 2 || *(_DWORD *)(a1 + 64) - v14 < 0)
          goto LABEL_83;
      }
      *v12 = *(_QWORD *)v11;
      ReleaseCacheRecord(a1, v11);
LABEL_86:
      v11 = *v12;
      if (!*v12)
        goto LABEL_87;
    }
    if (*(_WORD *)(v16 + 340))
    {
      if (!*(_BYTE *)(v16 + 632))
        goto LABEL_23;
    }
    else if ((*(_BYTE *)(v11 + 8) & 0x10) != 0)
    {
LABEL_23:
      if (*(int *)(v16 + 212) >= 1 && !*(_QWORD *)(v16 + 40))
      {
        *(_DWORD *)(v16 + 208) = v15 - 334;
        *(_DWORD *)(v16 + 212) = 334;
        SetNextQueryTime(a1, v16);
      }
    }
    v20 = *(_QWORD *)(a1 + 208);
    if (v20)
    {
      v21 = mDNSLogCategory_Default;
      v22 = v20 + 376;
      DNSTypeName(*(unsigned __int16 *)(v20 + 342));
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv ERROR m->CurrentQuestion already set: %##s (%s)", v23, v24, v25, v26, v27, v22);
    }
    v28 = *(_QWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 208) = v28;
    if (v28)
    {
      while (1)
      {
        if (v28 == *(_QWORD *)(a1 + 200))
          goto LABEL_67;
        if (!*(_BYTE *)(v28 + 354) && RecordAnswersQuestion(v11 + 8, 0, v28, a4, a5, a6, a7, a8))
        {
          *(_QWORD *)(v28 + 16) = 0;
          *(_QWORD *)(v28 + 24) = 0;
          v29 = *(_DWORD *)(v28 + 228);
          if (v29)
          {
            *(_DWORD *)(v28 + 228) = --v29;
            if (*(unsigned __int16 *)(v11 + 20) >= 0x401u)
              --*(_DWORD *)(v28 + 232);
            if ((*(_BYTE *)(v11 + 8) & 0x10) != 0)
              --*(_DWORD *)(v28 + 236);
          }
          if (!*(_WORD *)(v28 + 340))
          {
            if (*(_BYTE *)(v28 + 351))
            {
              if (v29 < *(unsigned __int8 *)(v28 + 351))
              {
                *(_DWORD *)(v28 + 212) = 334;
                *(_DWORD *)(v28 + 208) = *(_DWORD *)(a1 + 64) - 334;
                SetNextQueryTime(a1, v28);
                if (mDNS_LoggingEnabled == 1)
                {
                  v37 = mDNSLogCategory_Default;
                  v38 = DNSTypeName(*(unsigned __int16 *)(v28 + 342));
                  LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv: (%s) %##s dropped below threshold of %d answers", v39, v40, v41, v42, v43, v38);
                }
              }
            }
          }
          if (**(_WORD **)(v11 + 48))
            goto LABEL_39;
          v44 = *(_QWORD *)(v11 + 64);
          if (v44)
          {
            v45 = *(_DWORD *)(v44 + 32);
            if (!v45 || v45 == 1 && dnssec_obj_resource_record_member_get_validation_result(v44) == 1)
              break;
          }
        }
LABEL_45:
        v36 = *(_QWORD *)(a1 + 208);
        if (v36 == v28)
        {
          v36 = *(_QWORD *)(v28 + 8);
          *(_QWORD *)(a1 + 208) = v36;
        }
        v28 = v36;
        if (!v36)
          goto LABEL_67;
      }
      v46 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
        {
          v47 = *(_QWORD *)(v11 + 64);
          if (v47)
            LODWORD(v47) = *(_DWORD *)(v47 + 32) == 1;
LABEL_66:
          v48 = bswap32(*(unsigned __int16 *)(v28 + 340));
          v49 = *(unsigned __int16 *)(v11 + 12);
          *(_DWORD *)buf = 67109632;
          v54 = HIWORD(v48);
          v55 = 1024;
          v56 = v49;
          v57 = 1024;
          v58 = v47;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "[Q%u] Delivering RMV event for the negative record - rr type: %{mdns:rrtype}d, validated: %{mdns:yesno}d", buf, 0x14u);
        }
      }
      else
      {
        v46 = mDNSLogCategory_DNSSEC_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
        {
          v47 = *(_QWORD *)(v11 + 64);
          if (v47)
            LODWORD(v47) = *(_DWORD *)(v47 + 32) == 1;
          goto LABEL_66;
        }
      }
LABEL_39:
      if (!*(_DWORD *)(v28 + 228) && !*(_WORD *)(v28 + 340))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v30 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v28 + 342));
          LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv: Last answer for %##s (%s) expired from cache; will reconfirm antecedents",
            v31,
            v32,
            v33,
            v34,
            v35,
            v28 + 376);
        }
        ReconfirmAntecedents(a1, (_BYTE *)(v28 + 376), *(_DWORD *)(v28 + 200), *(_QWORD *)(v11 + 32), 0);
      }
      AnswerCurrentQuestionWithResourceRecord(a1, v11, 0);
      goto LABEL_45;
    }
LABEL_67:
    *(_QWORD *)(a1 + 208) = 0;
    --*(_DWORD *)(a1 + 252);
    goto LABEL_68;
  }
LABEL_87:
  *(_QWORD *)(a3 + 24) = v12;
  *(_BYTE *)(a1 + 56) = 0;
}

void CacheRecordDeferredAdd(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  *(_DWORD *)(a2 + 84) = 0;
  v10 = a1[26];
  if (v10)
  {
    v11 = mDNSLogCategory_Default;
    v12 = v10 + 376;
    DNSTypeName(*(unsigned __int16 *)(v10 + 342));
    LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "CacheRecordDeferredAdd ERROR m->CurrentQuestion already set: %##s (%s)", v13, v14, v15, v16, v17, v12);
  }
  v18 = a1[24];
  a1[26] = v18;
  if (v18)
  {
    do
    {
      if (v18 == a1[25])
        break;
      if (RecordAnswersQuestion(a2 + 8, 0, v18, a4, a5, a6, a7, a8))
        AnswerCurrentQuestionWithResourceRecord((uint64_t)a1, a2, 1);
      v19 = a1[26];
      if (v19 == v18)
      {
        v19 = *(_QWORD *)(v18 + 8);
        a1[26] = v19;
      }
      v18 = v19;
    }
    while (v19);
  }
  a1[26] = 0;
}

void AnswerCurrentQuestionWithResourceRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unsigned __int8 *v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  BOOL v32;
  int v33;
  int v34;
  uint64_t *p_src;
  void *v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  _BOOL4 v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  int v53;
  int v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _WORD *v68;
  __int16 v69;
  int v70;
  uint64_t v71;
  int v72;
  __int128 __src;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;

  v6 = *(_QWORD *)(a1 + 208);
  v7 = (unsigned __int8 *)(a2 + 8);
  v8 = FollowCNAME(v6, (unsigned __int8 *)(a2 + 8), a3);
  if (DNSQuestionNeedsSensitiveLogging(v6))
  {
    if (*(_BYTE *)(a2 + 129))
      goto LABEL_7;
    v15 = 1;
  }
  else
  {
    v15 = 2;
  }
  *(_BYTE *)(a2 + 129) = v15;
  v16 = *(_QWORD *)(a2 + 120);
  if (v16)
    *(_BYTE *)(v16 + 129) = v15;
LABEL_7:
  if (*(_BYTE *)(v6 + 355))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v17 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v6 + 342));
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "AnswerCurrentQuestionWithResourceRecord: Question %p %##s (%s) not answering with record %s due to LOAddressAnswers %d", v18, v19, v20, v21, v22, v6);
    }
    return;
  }
  if ((_DWORD)a3 == 4
    || !*(_BYTE *)(v6 + 354)
    || (*(_BYTE *)(v6 + 645) ? (v23 = !v8) : (v23 = 1),
        !v23 || *(_BYTE *)(v6 + 637) && *v7 == 240 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v6 + 240) >= 0))
  {
    if ((_DWORD)a3 == 1 && *(_WORD *)(v6 + 340))
    {
      if (!*(_BYTE *)(a2 + 10)
        && *(unsigned __int8 *)(v6 + 646) - 1 <= 1
        && *v7 != 240
        && !*(_QWORD *)(v6 + 144)
        && !*(_QWORD *)(a2 + 64))
      {
        *(_BYTE *)(a2 + 10) = 1;
      }
    }
    else if ((_DWORD)a3 != 1)
    {
      if ((_DWORD)a3 != 2 || *(_BYTE *)(v6 + 352))
        goto LABEL_57;
      goto LABEL_52;
    }
    if (*(_BYTE *)(v6 + 638) || *(_BYTE *)(v6 + 652))
    {
      if (v8)
        goto LABEL_49;
    }
    else
    {
      v31 = *(_QWORD *)(v6 + 136) + 5;
      v32 = v31 > 3 || v31 == 1;
      if (!v32 || *(_BYTE *)(v6 + 634) || IsLocalDomain((_BYTE *)(v6 + 376)) || v8)
        goto LABEL_49;
    }
    if (!*(_BYTE *)(v6 + 268))
    {
      v24 = *(_QWORD *)(v6 + 80);
      if (v24 && (*(_BYTE *)(v24 + 281) - 1) <= 3u)
      {
        v25 = dword_100100A10[(*(_BYTE *)(v24 + 281) - 1)];
        v10 = *(unsigned int *)(v6 + 260);
        v26 = *(_QWORD *)(v6 + 96);
        if (v26 && *(_UNKNOWN ***)(v26 + 16) == &_mdns_querier_kind)
        {
          v27 = atomic_load((unsigned int *)(v26 + 208));
          v10 = v27 + v10;
          v24 = *(_QWORD *)(v6 + 80);
        }
        if ((_DWORD)v10)
        {
          v28 = *(_DWORD *)(v6 + 264);
          if (v28)
          {
            v29 = (*(unsigned __int16 *)(v24 + 276) >> 3) & 1;
            v30 = 274877907000 * (*(_DWORD *)(a1 + 64) - v28);
            dnssd_analytics_update_dns_query_info(v29, (0x203010100uLL >> (8 * v25)), *(unsigned __int16 *)(v6 + 342), v10, (v30 >> 38) + ((unint64_t)v30 >> 63), *v7 != 240);
          }
        }
      }
      *(_BYTE *)(v6 + 268) = 1;
    }
LABEL_49:
    if (!*(_QWORD *)(v6 + 40))
    {
      v39 = *(_QWORD *)(a2 + 96);
      if (v39 != v6 && *(_BYTE *)(a2 + 10) != 2)
      {
        if (!v39)
        {
          ++*(_DWORD *)(a1 + 252);
          AdjustUnansweredQueries(a1, a2);
        }
        *(_QWORD *)(a2 + 96) = v6;
        SetNextCacheCheckTimeForRecord(a1, a2);
      }
    }
    if (!*(_BYTE *)(v6 + 633) && (*v7 & 0x10) == 0)
    {
LABEL_57:
      if (*(_DWORD *)(a2 + 84))
        return;
      if (*(_WORD *)(v6 + 340))
      {
        switch(*(_BYTE *)(v6 + 672))
        {
          case 0:
            v34 = *v7;
            if ((_DWORD)a3 != 1 || v34 != 240)
              goto LABEL_62;
            v53 = *(unsigned __int16 *)(v6 + 342);
            if (v53 != 28)
              goto LABEL_172;
            if (*(_WORD *)(a2 + 12) == 28 && *(_WORD *)(a2 + 14) == 1)
            {
              v54 = *(_DWORD *)(v6 + 200);
              if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1)
                dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_574);
              if (v54 != _DNS64IPv4OnlyFQDNHash_sHash
                || !SameDomainNameBytes((_BYTE *)(v6 + 376), "\bipv4only\x04arpa"))
              {
                v55 = *(_QWORD *)(v6 + 80);
                if (v55)
                {
                  if (*(_BYTE *)(v55 + 282) == 2 && (*(_WORD *)(v55 + 276) & 0x30) == 0x20)
                  {
                    _DNS64RestartQuestion(a1, v6, 1);
                    return;
                  }
                }
              }
            }
            v53 = *(unsigned __int16 *)(v6 + 342);
LABEL_172:
            if (v53 != 12)
              goto LABEL_61;
            if (*(_WORD *)(a2 + 12) != 12)
              goto LABEL_61;
            if (*(_WORD *)(a2 + 14) != 1)
              goto LABEL_61;
            v71 = *(_QWORD *)(v6 + 80);
            if (!v71
              || *(_BYTE *)(v71 + 282) != 2
              || (*(_WORD *)(v71 + 276) & 0x30) != 0x20
              || !GetReverseIPv6Addr((_BYTE *)(v6 + 376), 0))
            {
              goto LABEL_61;
            }
            _DNS64RestartQuestion(a1, v6, 2);
            return;
          case 1:
            if ((_DWORD)a3 != 1 || *v7 == 240 || *(_WORD *)(a2 + 12) != 28 || *(_WORD *)(a2 + 14) != 1)
              goto LABEL_147;
            _DNS64RestartQuestion(a1, v6, 3);
            return;
          case 2:
            mDNS_StopQuery_internal(a1, v6);
            *(_BYTE *)(v6 + 672) = 6;
            v56 = 12;
            goto LABEL_148;
          case 3:
            v57 = *(unsigned __int16 *)(a2 + 12);
            if (v57 == 5)
              goto LABEL_61;
            if (*v7 != 240 && v57 == 1 && (_DWORD)a3 == 1 && *(_WORD *)(a2 + 14) == 1)
            {
              v58 = *(_QWORD *)(v6 + 80);
              if (v58)
              {
                if (_DNS64TestIPv6Synthesis(a1, v58, (int *)(*(_QWORD *)(a2 + 48) + 4)))
                {
                  *(_BYTE *)(v6 + 672) = 4;
                  goto LABEL_61;
                }
              }
            }
LABEL_147:
            mDNS_StopQuery_internal(a1, v6);
            *(_BYTE *)(v6 + 672) = 5;
            v56 = 28;
LABEL_148:
            *(_WORD *)(v6 + 342) = v56;
            mDNS_StartQuery_internal(a1, v6);
            break;
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            goto LABEL_61;
          default:
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS64StateMachine: unrecognized DNS64 state %d", v10, v11, v12, v13, v14, *(unsigned __int8 *)(v6 + 672));
            goto LABEL_61;
        }
        return;
      }
LABEL_61:
      v34 = *v7;
LABEL_62:
      if (v34 == 240)
      {
        v87 = 0u;
        v88 = 0u;
        v85 = 0u;
        v86 = 0u;
        v83 = 0u;
        v84 = 0u;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v77 = 0u;
        v78 = 0u;
        v75 = 0u;
        v76 = 0u;
        __src = 0u;
        v74 = 0u;
        p_src = (uint64_t *)&__src;
        if (PerformNextPunycodeConversion(v6, (char *)&__src))
        {
          v36 = *(void **)(v6 + 72);
          v37 = *(_WORD *)(v6 + 340);
          *(_QWORD *)(v6 + 72) = 0;
          mDNS_StopQuery_internal(a1, v6);
          while (p_src < &v89)
          {
            if (!p_src)
              break;
            v38 = *(unsigned __int8 *)p_src;
            if (v38 > 0x3F)
              break;
            if (!*(_BYTE *)p_src)
            {
              if ((unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1) <= 0x100u)
              {
                memcpy((void *)(v6 + 376), &__src, (unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1));
                goto LABEL_113;
              }
              break;
            }
            p_src = (uint64_t *)((char *)p_src + v38 + 1);
          }
          *(_BYTE *)(v6 + 376) = 0;
LABEL_113:
          *(_DWORD *)(v6 + 200) = DomainNameHashValue(v6 + 376);
          mDNS_StartQuery_internal(a1, v6);
          if (v36)
          {
            if (*(_QWORD *)(v6 + 40))
            {
              CloseSocketSet((uint64_t)v36);
              free(v36);
            }
            else
            {
              *(_QWORD *)(v6 + 72) = v36;
              *(_WORD *)(v6 + 340) = v37;
            }
          }
          return;
        }
        v34 = *v7;
      }
      v40 = *(unsigned __int16 *)(v6 + 342);
      v41 = v40 != 47
         && *(_WORD *)(a2 + 12) == 47
         && RRAssertsExistence((uint64_t)v7, v40, v9, v10, v11, v12, v13, v14) == 0;
      if (v34 == 240 || v41)
      {
        if ((a3 - 1) >= 2)
        {
          if (!(_DWORD)a3)
          {
            v42 = *(_QWORD *)(v6 + 144);
            if (!v42 || !*(_BYTE *)(v42 + 24))
              return;
            goto LABEL_93;
          }
        }
        else if (!*(_BYTE *)(v6 + 635))
        {
          return;
        }
      }
      else if (!(_DWORD)a3)
      {
LABEL_93:
        if (*(_QWORD *)(v6 + 152) && (!v8 || *(_BYTE *)(v6 + 635) || *(_BYTE *)(v6 + 646) == 1))
        {
          v43 = *(_DWORD *)(a1 + 48);
          v44 = *(_DWORD *)(a1 + 52) + 1;
          *(_DWORD *)(a1 + 52) = v44;
          mDNS_VerifyLockState("Drop Lock", 0, v43, v44, (uint64_t)"AnswerCurrentQuestionWithResourceRecord", 5468);
          v51 = *(unsigned __int16 *)(v6 + 342);
          if (v51 == 47
            || *(_WORD *)(a2 + 12) != 47
            || RRAssertsExistence((uint64_t)v7, v51, v45, v46, v47, v48, v49, v50))
          {
            if (*(unsigned __int8 *)(v6 + 672) - 3 <= 1 && *(_WORD *)(a2 + 12) == 1)
              DNS64AnswerCurrentQuestion(a1, (uint64_t)v7, a3);
            else
              (*(void (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t))(v6 + 152))(a1, v6, v7, a3);
          }
          else if (!*(_WORD *)(v6 + 340))
          {
            v85 = 0u;
            v86 = 0u;
            v83 = 0u;
            v84 = 0u;
            v81 = 0u;
            v82 = 0u;
            v79 = 0u;
            v80 = 0u;
            v77 = 0u;
            v78 = 0u;
            v75 = 0u;
            v76 = 0u;
            __src = 0u;
            v74 = 0u;
            MakeNegativeCacheRecordForQuestion(a1, (uint64_t)&__src, v6, *(_QWORD *)(a2 + 32));
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t))(v6 + 152))(a1, v6, (char *)&__src + 8, a3);
          }
          mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerCurrentQuestionWithResourceRecord", 5494);
          --*(_DWORD *)(a1 + 52);
        }
        if (*(_QWORD *)(a1 + 208) == v6 && v8)
          AnswerQuestionByFollowingCNAME(a1, v6, (uint64_t)v7);
        return;
      }
      if (!*(_QWORD *)(v6 + 40) && !*(_WORD *)(v6 + 340))
      {
        if (!*(_BYTE *)(v6 + 268))
          *(_BYTE *)(v6 + 268) = 1;
        v59 = *(uint64_t **)(a1 + 12656);
        if (v59)
        {
          while (!*((_BYTE *)v59 + 16))
          {
            v59 = (uint64_t *)*v59;
            if (!v59)
              goto LABEL_93;
          }
LABEL_158:
          v60 = v59[1];
          if (v60 && v59[444] == *(_QWORD *)(a2 + 32))
          {
            if (*(_BYTE *)(v6 + 357))
            {
              v61 = *(_DWORD *)(v6 + 264);
              if (v61)
              {
                v62 = *(_DWORD *)(a1 + 64) - v61;
                if (v62 >= 1)
                {
                  v63 = 1000 * (v62 % 0x3E8u) / 0x3E8 + 1000 * (v62 / 0x3E8u);
                  v64 = v63 >> 3;
                  v65 = 15;
                  if (v63 >> 5 >= 0x271)
                    v65 = 16;
                  v66 = (unsigned __int16)v63 / 0x3E8u;
                  if (v64 > 0x752)
                    v66 = v65;
                  v67 = v60 + 2 * v66;
                  v70 = *(unsigned __int16 *)(v67 + 28);
                  v68 = (_WORD *)(v67 + 28);
                  v69 = v70;
                  if (v70 != 0xFFFF)
                    *v68 = v69 + 1;
                }
              }
            }
            else
            {
              v72 = *(_DWORD *)(v60 + 24);
              if (v72 != -1)
                *(_DWORD *)(v60 + 24) = v72 + 1;
            }
          }
          else
          {
            while (1)
            {
              v59 = (uint64_t *)*v59;
              if (!v59)
                break;
              if (*((_BYTE *)v59 + 16))
                goto LABEL_158;
            }
          }
        }
      }
      goto LABEL_93;
    }
LABEL_52:
    if (*(int *)(v6 + 212) >= 1 && !*(_QWORD *)(v6 + 40) && (!*(_WORD *)(v6 + 340) || !*(_BYTE *)(v6 + 632)))
    {
      v33 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v6 + 256) = v33;
      *(_DWORD *)(v6 + 224) = 0;
      *(_DWORD *)(v6 + 208) = v33;
      *(_DWORD *)(v6 + 212) = 3600000;
      *(_BYTE *)(v6 + 352) = 0;
      *(_BYTE *)(v6 + 648) = 0;
    }
    goto LABEL_57;
  }
}

char *create_reply(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  size_t v9;
  int v11;
  int v12;

  if ((a2 & 0xFFFFFFFC) > 0xBuLL)
  {
    v8 = a2;
    v9 = a2 + 44;
    if (v9 && (v11 = (int)result, (result = (char *)malloc_type_calloc(1uLL, v9, 0xF1748037uLL)) != 0))
    {
      *(_QWORD *)result = 0;
      *((_DWORD *)result + 2) = v8 + 28;
      *(_QWORD *)(result + 12) = &_mh_execute_header;
      *((_DWORD *)result + 5) = v8;
      *((_DWORD *)result + 6) = 0;
      *((_DWORD *)result + 7) = v11;
      *((_QWORD *)result + 4) = *(_QWORD *)(a3 + 224);
      *((_DWORD *)result + 10) = 0;
    }
    else
    {
      __break(1u);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: create_reply - data length less than length of required fields", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  return result;
}

uint64_t mDNSPlatformInterfaceIndexfromInterfaceID(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a2;
  v10 = a2 + 5;
  if ((unint64_t)(a2 + 5) < 6 && ((0x2Du >> v10) & 1) != 0)
    return dword_100100880[v10];
  v11 = **a1;
  if (v11)
  {
    while (*(_DWORD *)(v11 + 3720) != (_DWORD)a2)
    {
      v11 = *(_QWORD *)(v11 + 3680);
      if (!v11)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    if (!(_DWORD)a3)
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Interface index for InterfaceID %p not found; Updating interface list",
          a4,
          a5,
          a6,
          a7,
          a8,
          a2);
      mDNSMacOSXNetworkChanged((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
      v12 = **a1;
      if (v12)
      {
        while (*(_DWORD *)(v12 + 3720) != (_DWORD)v8)
        {
          v12 = *(_QWORD *)(v12 + 3680);
          if (!v12)
            return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v8;
}

void abort_request(uint64_t a1)
{
  void (*v2)(uint64_t);
  uint64_t v3;
  int v5;
  int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  int v22;
  int v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  int v27;
  int v28;
  uint64_t *v29;
  uint64_t *v30;
  int v31;
  _QWORD *v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  _BYTE v36[10];
  uint64_t v37;

  v2 = *(void (**)(uint64_t))(a1 + 104);
  if (!v2)
  {
LABEL_11:
    if (*(_QWORD *)a1)
    {
      Querier_DeregisterCustomDNSService(*(_QWORD *)a1);
      *(_QWORD *)a1 = 0;
    }
    v5 = *(_DWORD *)(a1 + 176);
    if (v5 < 0)
    {
      v14 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          return;
      }
      else
      {
        v14 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          return;
      }
      v22 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109632;
      v34 = v22;
      v35 = 2048;
      *(_QWORD *)v36 = a1;
      *(_WORD *)&v36[8] = 1024;
      LODWORD(v37) = v5;
      v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with invalid fd %d";
      v19 = v14;
      v20 = 24;
      goto LABEL_32;
    }
    if (*(_QWORD *)(a1 + 24))
    {
LABEL_50:
      *(_DWORD *)(a1 + 184) = -1;
      *(_DWORD *)(a1 + 176) = -1;
      *(_QWORD *)(a1 + 104) = -1;
      return;
    }
    v6 = *(_DWORD *)(a1 + 184);
    v7 = gSensitiveLoggingEnabled;
    v8 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
      v7 = 0;
    if (v6 == v5)
    {
      if ((v7 & 1) != 0)
      {
        v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
          goto LABEL_41;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }
      v23 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109376;
      v34 = v23;
      v35 = 1024;
      *(_DWORD *)v36 = v5;
      v24 = "[R%d] Removing FD %d";
      v25 = v8;
      v26 = 14;
    }
    else
    {
      if ((v7 & 1) != 0)
      {
        v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
          goto LABEL_41;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }
      v27 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109632;
      v34 = v27;
      v35 = 1024;
      *(_DWORD *)v36 = v5;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v6;
      v24 = "[R%d] Removing FD %d and closing errsd %d";
      v25 = v8;
      v26 = 20;
    }
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, v24, buf, v26);
LABEL_41:
    v28 = *(_DWORD *)(a1 + 176);
    v29 = &gEventSources;
    while (1)
    {
      v30 = v29;
      v29 = (uint64_t *)*v29;
      if (!v29)
        break;
      if (*((_DWORD *)v29 + 2) == v28)
      {
        *v30 = *v29;
        close(v28);
        free(v29);
        goto LABEL_46;
      }
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsSupportRemoveFDFromEventLoop: ERROR fd %d not found in EventLoop source list", v9, v10, v11, v12, v13, *(_DWORD *)(a1 + 176));
LABEL_46:
    v31 = *(_DWORD *)(a1 + 184);
    if (v31 != *(_DWORD *)(a1 + 176))
    {
      close(v31);
      *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 176);
    }
    while (1)
    {
      v32 = *(_QWORD **)(a1 + 96);
      if (!v32)
        break;
      *(_QWORD *)(a1 + 96) = *v32;
      free(v32);
    }
    goto LABEL_50;
  }
  if (v2 != (void (*)(uint64_t))-1)
  {
    v2(a1);
    goto LABEL_11;
  }
  v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return;
    goto LABEL_29;
  }
  v3 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_29:
    v17 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)buf = 67109632;
    v34 = v17;
    v35 = 2048;
    *(_QWORD *)v36 = a1;
    *(_WORD *)&v36[8] = 2048;
    v37 = -1;
    v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with req->terminate %p";
    v19 = v3;
    v20 = 28;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
  }
}

void queryrecord_termination_callback(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _BYTE *v16;
  uint64_t v17;
  int v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  BOOL v44;
  int v45;
  int v46;
  _BYTE __tp[20];
  int v48;
  __int16 v49;
  unsigned __int8 *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;

  v2 = *(_QWORD *)(a1 + 136);
  v3 = (unsigned __int8 *)(v2 + 376);
  v4 = IsLocalDomain((_BYTE *)(v2 + 376));
  v5 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 136) + 342);
  if (!requestShouldLogFullRequestInfo(a1))
  {
    if (!gSensitiveLoggingEnabled
      || (v4 ? (v21 = mDNSLogCategory_mDNS) : (v21 = mDNSLogCategory_Default), v21 == mDNSLogCategory_State))
    {
      if (v4)
        v22 = mDNSLogCategory_mDNS;
      else
        v22 = mDNSLogCategory_Default;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        goto LABEL_52;
    }
    else
    {
      if (v4)
        v22 = mDNSLogCategory_mDNS;
      else
        v22 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        goto LABEL_52;
    }
    v23 = *(_DWORD *)(a1 + 192);
    v24 = mDNS_DomainNameFNV1aHash(v3);
    *(_QWORD *)__tp = 0;
    *(_QWORD *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    v25 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v23;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v24;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v25;
    v26 = "[R%u] DNSServiceQueryRecord STOP -- name hash: %x, duration: %{mdns:time_duration}u";
    v27 = v22;
    v28 = 20;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, __tp, v28);
    goto LABEL_52;
  }
  if (!gSensitiveLoggingEnabled
    || (v4 ? (v6 = mDNSLogCategory_mDNS) : (v6 = mDNSLogCategory_Default), v6 == mDNSLogCategory_State))
  {
    if (v4)
      v7 = mDNSLogCategory_mDNS;
    else
      v7 = mDNSLogCategory_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v46 = v5;
      v18 = *(_DWORD *)(a1 + 192);
      v19 = (_BYTE *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_24:
        while (v19)
        {
          v20 = *v19;
          if (v20 > 0x3F)
            break;
          if (!*v19)
          {
            v29 = (unsigned __int16)((_WORD)v19 - (_WORD)v3 + 1);
            goto LABEL_46;
          }
          v19 += v20 + 1;
          if (v2 != -632)
            goto LABEL_23;
        }
      }
      else
      {
LABEL_23:
        if ((unint64_t)v19 < v2 + 632)
          goto LABEL_24;
      }
      v29 = 257;
LABEL_46:
      v30 = *(_DWORD *)(a1 + 240);
      v31 = *(_DWORD *)(a1 + 244);
      v32 = *(_DWORD *)(a1 + 180);
      v33 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(_QWORD *)__tp = 0;
      *(_QWORD *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      v34 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v18;
      *(_WORD *)&__tp[8] = 2160;
      *(_QWORD *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      v48 = v29;
      v49 = 2101;
      v50 = v3;
      v51 = 1024;
      v52 = v46;
      v53 = 1024;
      v54 = v30;
      v55 = 1024;
      v56 = v31;
      v57 = 1024;
      v58 = v32;
      v59 = 2082;
      v60 = a1 + 248;
      v61 = 1024;
      v62 = v33;
      v63 = 1024;
      v64 = v34;
      v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
      goto LABEL_50;
    }
  }
  else
  {
    if (v4)
      v7 = mDNSLogCategory_mDNS;
    else
      v7 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(a1 + 192);
      v16 = (_BYTE *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_13:
        while (v16)
        {
          v17 = *v16;
          if (v17 > 0x3F)
            break;
          if (!*v16)
          {
            v35 = (unsigned __int16)((_WORD)v16 - (_WORD)v3 + 1);
            goto LABEL_49;
          }
          v16 += v17 + 1;
          if (v2 != -632)
            goto LABEL_12;
        }
      }
      else
      {
LABEL_12:
        if ((unint64_t)v16 < v2 + 632)
          goto LABEL_13;
      }
      v35 = 257;
LABEL_49:
      v36 = *(_DWORD *)(a1 + 240);
      v37 = *(_DWORD *)(a1 + 244);
      v38 = *(_DWORD *)(a1 + 180);
      v39 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(_QWORD *)__tp = 0;
      *(_QWORD *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      v40 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v15;
      *(_WORD *)&__tp[8] = 2160;
      *(_QWORD *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      v48 = v35;
      v49 = 2101;
      v50 = v3;
      v51 = 1024;
      v52 = v5;
      v53 = 1024;
      v54 = v36;
      v55 = 1024;
      v56 = v37;
      v57 = 1024;
      v58 = v38;
      v59 = 2082;
      v60 = a1 + 248;
      v61 = 1024;
      v62 = v39;
      v63 = 1024;
      v64 = v40;
      v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
LABEL_50:
      v27 = v7;
      v28 = 80;
      goto LABEL_51;
    }
  }
LABEL_52:
  QueryRecordClientRequestStop(*(_QWORD *)(a1 + 136), v8, v9, v10, v11, v12, v13, v14, v45);
  v41 = *(_QWORD *)(a1 + 8);
  if (v41)
  {
    v42 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v42)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v42)
      {
        v43 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v44 = WiFiAwareInterfaceID == v42;
        else
          v44 = 0;
        v43 = v44;
      }
    }
    else
    {
      v43 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(9, v43, (char *)(a1 + 248), v41);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void mDNS_StopQuery(unsigned int *a1, uint64_t a2)
{
  mDNS_Lock_(a1, (uint64_t)"mDNS_StopQuery", 15780);
  mDNS_StopQuery_internal(a1, a2);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_StopQuery", 15782);
}

uint64_t mDNS_StopQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  NSObject *v6;
  unsigned int v7;
  _BYTE *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned __int16 v12;
  int v13;
  const char *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  int v24;
  uint64_t v25;
  BOOL v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  BOOL v31;
  unint64_t v32;
  BOOL v33;
  NSObject *v34;
  uint64_t v36;
  unsigned int v37;
  NSObject *v38;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  unsigned int v45;
  int v46;
  uint64_t v47;
  void *v48;
  NSObject *v49;
  NSObject *v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _BYTE *v56;
  __int128 v57;
  void *v58;
  void *v59;
  void *v60;
  uint64_t v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  NSObject *v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  NSObject *v76;
  void *v77;
  _BYTE *v78;
  uint64_t v79;
  _BYTE *v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t *v83;
  unsigned __int16 v84;
  int v85;
  const char *v86;
  NSObject *v87;
  void *v88;
  _BYTE *v89;
  uint64_t v90;
  _BYTE *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t *v94;
  unsigned __int16 v95;
  int v96;
  const char *v97;
  _BYTE *v98;
  uint64_t v99;
  _BYTE *v101;
  uint64_t v102;
  unsigned __int16 v103;
  unsigned __int16 v104;
  int v105;
  const char *v106;
  uint64_t v107;
  _BYTE *v108;
  uint64_t v109;
  uint64_t *v110;
  unsigned __int16 v111;
  int v112;
  const char *v113;
  uint64_t v114;
  _BYTE *v115;
  uint64_t v116;
  const char *v117;
  unsigned __int16 v118;
  int v119;
  const char *v120;
  int v121;
  const char *v122;
  _QWORD *i;
  uint64_t v124;
  uint64_t v125;
  NSObject *v126;
  _BYTE *v127;
  uint64_t v128;
  _BYTE *v129;
  uint64_t v130;
  unsigned __int16 v131;
  const char *v132;
  int v133;
  const char *v134;
  uint64_t v135;
  void *v136;
  void *v137;
  uint64_t v138;
  const __CFSet *Mutable;
  NSObject *v140;
  int v141;
  uint64_t v142;
  void *v143;
  void *v144;
  const __CFSet *v145;
  const void *v146;
  int v147;
  char v148;
  NSObject *v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  _QWORD *v155;
  void *v156;
  int v158;
  int v159;
  uint64_t *v160;
  int v161;
  unsigned int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  unsigned int v167;
  uint8_t buf[4];
  _BYTE v169[52];
  __int16 v170;
  const char *v171;
  __int16 v172;
  uint64_t v173;
  __int16 v174;
  uint64_t v175;
  __int16 v176;
  int v177;
  __int16 v178;
  uint64_t v179;
  __int16 v180;
  const char *v181;

  v4 = *(_QWORD *)(a2 + 144);
  if (v4 && *(_BYTE *)(v4 + 24))
  {
    v5 = gSensitiveLoggingEnabled;
    v6 = mDNSLogCategory_DNSSEC;
    if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      v5 = 0;
    if (!*(_BYTE *)(a2 + 655))
    {
      if ((v5 & 1) != 0)
      {
        v6 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
          goto LABEL_29;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        goto LABEL_29;
      }
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)v169 = "question->enableDNSSEC";
      *(_WORD *)&v169[8] = 2082;
      *(_QWORD *)&v169[10] = "";
      *(_WORD *)&v169[18] = 2082;
      *(_QWORD *)&v169[20] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
      *(_WORD *)&v169[28] = 1024;
      *(_DWORD *)&v169[30] = 126;
      *(_WORD *)&v169[34] = 2048;
      *(_QWORD *)&v169[36] = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
      goto LABEL_29;
    }
    if ((v5 & 1) != 0)
    {
      v6 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
      {
        v7 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        v8 = (_BYTE *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_10:
          while (v8)
          {
            v9 = *v8;
            if (v9 > 0x3F)
              break;
            if (!*v8)
            {
              v12 = (_WORD)v8 - (a2 + 376) + 1;
              goto LABEL_27;
            }
            v8 += v9 + 1;
            if (a2 != -632)
              goto LABEL_9;
          }
        }
        else
        {
LABEL_9:
          if ((unint64_t)v8 < a2 + 632)
            goto LABEL_10;
        }
        v12 = 257;
LABEL_27:
        v13 = v12;
        v14 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)v169 = v7;
        *(_WORD *)&v169[4] = 2160;
        *(_QWORD *)&v169[6] = 1752392040;
        *(_WORD *)&v169[14] = 1040;
        *(_DWORD *)&v169[16] = v13;
        *(_WORD *)&v169[20] = 2101;
        *(_QWORD *)&v169[22] = a2 + 376;
        *(_WORD *)&v169[30] = 2160;
        *(_QWORD *)&v169[32] = 1752392040;
        *(_WORD *)&v169[40] = 2085;
        *(_QWORD *)&v169[42] = v14;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "[Q%u] Stopping Primary DNSSEC question - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s", buf, 0x36u);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
    {
      v7 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v10 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_18:
        while (v10)
        {
          v11 = *v10;
          if (v11 > 0x3F)
            break;
          if (!*v10)
          {
            v12 = (_WORD)v10 - (a2 + 376) + 1;
            goto LABEL_27;
          }
          v10 += v11 + 1;
          if (a2 != -632)
            goto LABEL_17;
        }
      }
      else
      {
LABEL_17:
        if ((unint64_t)v10 < a2 + 632)
          goto LABEL_18;
      }
      v12 = 257;
      goto LABEL_27;
    }
    v15 = *(_QWORD *)(*(_QWORD *)(a2 + 144) + 16);
    *(_QWORD *)(a2 + 152) = *(_QWORD *)(v15 + 40);
    *(_BYTE *)(a2 + 635) = *(_BYTE *)(v15 + 36);
  }
LABEL_29:
  if (*(_QWORD *)(a1 + 232) != a2 && *(_QWORD *)(a2 + 184))
    dns_push_handle_question_stop((unsigned int *)a1, a2);
  v16 = (_QWORD *)(a2 + 376);
  v22 = CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 376));
  v23 = (uint64_t *)(a1 + 192);
  v24 = *(_DWORD *)(a2 + 252);
  v25 = *(_QWORD *)(a2 + 136);
  v27 = v25 == -5 || v25 == -3 || v25 == -2;
  v28 = (_QWORD *)(a1 + 216);
  if (!v27)
    v28 = (_QWORD *)(a1 + 192);
  do
  {
    v29 = v28;
    v30 = *v28;
    v28 = (_QWORD *)(*v28 + 8);
    if (v30)
      v31 = v30 == a2;
    else
      v31 = 1;
  }
  while (!v31);
  if (!v30)
  {
    v36 = 4294901755;
    if ((*(_DWORD *)(a2 + 212) & 0x80000000) != 0)
      return v36;
    v37 = __rev16(*(unsigned __int16 *)(a2 + 340));
    v38 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        return v36;
      v40 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_67:
        while (v40)
        {
          v41 = *v40;
          if (v41 > 0x3F)
            break;
          if (!*v40)
          {
            v105 = (unsigned __int16)((_WORD)v40 - (_WORD)v16 + 1);
            goto LABEL_273;
          }
          v40 += v41 + 1;
          if (a2 != -632)
            goto LABEL_66;
        }
      }
      else
      {
LABEL_66:
        if ((unint64_t)v40 < a2 + 632)
          goto LABEL_67;
      }
      v105 = 257;
    }
    else
    {
      v38 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        return v36;
      v101 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_193:
        while (v101)
        {
          v102 = *v101;
          if (v102 > 0x3F)
            break;
          if (!*v101)
          {
            v105 = (unsigned __int16)((_WORD)v101 - (_WORD)v16 + 1);
            goto LABEL_273;
          }
          v101 += v102 + 1;
          if (a2 != -632)
            goto LABEL_192;
        }
      }
      else
      {
LABEL_192:
        if ((unint64_t)v101 < a2 + 632)
          goto LABEL_193;
      }
      v105 = 257;
    }
LABEL_273:
    v132 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    *(_DWORD *)buf = 67110403;
    *(_DWORD *)v169 = v24;
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v37;
    *(_WORD *)&v169[10] = 2160;
    *(_QWORD *)&v169[12] = 1752392040;
    *(_WORD *)&v169[20] = 1040;
    *(_DWORD *)&v169[22] = v105;
    *(_WORD *)&v169[26] = 2101;
    *(_QWORD *)&v169[28] = a2 + 376;
    *(_WORD *)&v169[36] = 2082;
    *(_QWORD *)&v169[38] = v132;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "[R%u->Q%u] mDNS_StopQuery_internal: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) not found in active list.", buf, 0x32u);
    return v36;
  }
  *v29 = *v28;
  v32 = *(_QWORD *)(a2 + 136) + 5;
  v33 = v32 > 3 || v32 == 1;
  if (v33 && !*(_WORD *)(a2 + 340))
  {
    v42 = *(_DWORD *)(a1 + 19908);
    if (v42 + *(_DWORD *)(a1 + 19904) == 1)
    {
      v43 = *(_DWORD *)(a1 + 64) + 60000;
      if (v43 <= 1)
        v43 = 1;
      *(_DWORD *)(a1 + 116) = v43;
    }
    *(_DWORD *)(a1 + 19908) = v42 - 1;
  }
  if (!v24)
  {
    v34 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_80;
      goto LABEL_79;
    }
    v34 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_79:
      v45 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v46 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v169 = v45;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v46;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StopQuery_internal STOP -- name hash: %x", buf, 0xEu);
    }
  }
LABEL_80:
  v47 = *(_QWORD *)(a2 + 40);
  v48 = &unk_100164000;
  if (!v47)
  {
    v53 = *v23;
    if (!*v23)
      goto LABEL_224;
    v54 = 0;
    v55 = a2 + 284;
    v56 = &unk_100164000;
    while (1)
    {
      if (*(_QWORD *)(v53 + 40) != a2)
        goto LABEL_180;
      *(_QWORD *)(v53 + 40) = v54;
      if (v54)
        goto LABEL_180;
      *(_OWORD *)(v53 + 208) = *(_OWORD *)(a2 + 208);
      *(_DWORD *)(v53 + 224) = *(_DWORD *)(a2 + 224);
      *(_WORD *)(v53 + 352) = *(_WORD *)(a2 + 352);
      *(_DWORD *)(v53 + 256) = *(_DWORD *)(a2 + 256);
      *(_QWORD *)(v53 + 104) = *(_QWORD *)(a2 + 104);
      v57 = *(_OWORD *)v55;
      *(_DWORD *)(v53 + 300) = *(_DWORD *)(v55 + 16);
      *(_OWORD *)(v53 + 284) = v57;
      *(_WORD *)(v53 + 336) = *(_WORD *)(a2 + 336);
      v58 = *(void **)(a2 + 80);
      if (v58)
        os_retain(v58);
      v59 = *(void **)(v53 + 80);
      if (v59)
        os_release(v59);
      *(_QWORD *)(v53 + 80) = *(_QWORD *)(a2 + 80);
      v60 = *(void **)(a2 + 80);
      if (v60)
      {
        os_release(v60);
        *(_QWORD *)(a2 + 80) = 0;
      }
      v61 = *(_QWORD *)(v53 + 96);
      if (v61)
      {
        mdns_client_invalidate(v61);
        os_release(*(void **)(v53 + 96));
        *(_QWORD *)(v53 + 96) = 0;
      }
      v62 = *(void **)(a2 + 96);
      if (v62)
      {
        os_retain(v62);
        v63 = *(void **)(v53 + 96);
        if (v63)
          os_release(v63);
      }
      *(_QWORD *)(v53 + 96) = *(_QWORD *)(a2 + 96);
      v64 = *(void **)(a2 + 96);
      if (v64)
      {
        os_release(v64);
        *(_QWORD *)(a2 + 96) = 0;
      }
      *(_QWORD *)(v53 + 192) = *(_QWORD *)(a2 + 192);
      *(_QWORD *)(a2 + 192) = 0;
      v65 = *(_QWORD *)(a2 + 144);
      if (v65)
      {
        if (*(_BYTE *)(v65 + 24))
          break;
      }
LABEL_123:
      *(_WORD *)(v53 + 340) = *(_WORD *)(a2 + 340);
      *(_BYTE *)(v53 + 350) = *(_BYTE *)(a2 + 350);
      *(_QWORD *)(v53 + 272) = *(_QWORD *)(a2 + 272);
      *(_WORD *)(v53 + 348) = *(_WORD *)(a2 + 348);
      *(_QWORD *)(v53 + 328) = *(_QWORD *)(a2 + 328);
      *(_QWORD *)(a2 + 104) = 0;
      if (!*(_QWORD *)(a2 + 40) && !*(_WORD *)(a2 + 340))
      {
        v75 = *(_QWORD *)(a2 + 260);
        *(_DWORD *)(v53 + 268) = *(_DWORD *)(a2 + 268);
        *(_QWORD *)(v53 + 260) = v75;
      }
      if (*(_QWORD *)(v53 + 104))
      {
        v76 = *((_QWORD *)v48 + 295);
        if (v56[2416] != 1 || v76 == mDNSLogCategory_State)
        {
          if (os_log_type_enabled(*((os_log_t *)v48 + 295), OS_LOG_TYPE_DEFAULT))
          {
            v77 = v48;
            v80 = (_BYTE *)(v53 + 376);
            if (v53 == -632)
            {
LABEL_140:
              while (v80)
              {
                v81 = *v80;
                if (v81 > 0x3F)
                  break;
                if (!*v80)
                {
                  v82 = v16;
                  v83 = v22;
                  v84 = (_WORD)v80 - (v53 + 376) + 1;
                  goto LABEL_149;
                }
                v80 += v81 + 1;
                if (v53 != -632)
                  goto LABEL_139;
              }
            }
            else
            {
LABEL_139:
              if ((unint64_t)v80 < v53 + 632)
                goto LABEL_140;
            }
            v82 = v16;
            v83 = v22;
            v84 = 257;
LABEL_149:
            v85 = v84;
            v86 = DNSTypeName(*(unsigned __int16 *)(v53 + 342));
            *(_DWORD *)buf = 141558787;
            *(_QWORD *)v169 = 1752392040;
            *(_WORD *)&v169[8] = 1040;
            *(_DWORD *)&v169[10] = v85;
            *(_WORD *)&v169[14] = 2101;
            *(_QWORD *)&v169[16] = v53 + 376;
            *(_WORD *)&v169[24] = 2082;
            *(_QWORD *)&v169[26] = v86;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates transferred nta pointer for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
            v48 = v77;
            v22 = v83;
            v16 = v82;
            v55 = a2 + 284;
            v56 = &unk_100164000;
          }
        }
        else
        {
          v76 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v77 = v48;
            v78 = (_BYTE *)(v53 + 376);
            if (v53 == -632)
            {
LABEL_132:
              while (v78)
              {
                v79 = *v78;
                if (v79 > 0x3F)
                  break;
                if (!*v78)
                {
                  v82 = v16;
                  v83 = v22;
                  v84 = (_WORD)v78 - (v53 + 376) + 1;
                  goto LABEL_149;
                }
                v78 += v79 + 1;
                if (v53 != -632)
                  goto LABEL_131;
              }
            }
            else
            {
LABEL_131:
              if ((unint64_t)v78 < v53 + 632)
                goto LABEL_132;
            }
            v82 = v16;
            v83 = v22;
            v84 = 257;
            goto LABEL_149;
          }
        }
        *(_QWORD *)(*(_QWORD *)(v53 + 104) + 824) = v53;
      }
      if (*(_QWORD *)(a2 + 112) && mDNS_LoggingEnabled)
        LogMsgWithLevel(*((NSObject **)v48 + 295), OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates did not transfer tcp pointer", v17, v18, v19, v20, v21, v159);
      if (*(_BYTE *)(a2 + 350) != 22)
        goto LABEL_179;
      v87 = *((_QWORD *)v48 + 295);
      if (v56[2416] != 1 || v87 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(*((os_log_t *)v48 + 295), OS_LOG_TYPE_DEFAULT))
        {
          v88 = v48;
          v91 = (_BYTE *)(v53 + 376);
          if (v53 == -632)
          {
LABEL_168:
            while (v91)
            {
              v92 = *v91;
              if (v92 > 0x3F)
                break;
              if (!*v91)
              {
                v93 = v16;
                v94 = v22;
                v95 = (_WORD)v91 - (v53 + 376) + 1;
                goto LABEL_177;
              }
              v91 += v92 + 1;
              if (v53 != -632)
                goto LABEL_167;
            }
          }
          else
          {
LABEL_167:
            if ((unint64_t)v91 < v53 + 632)
              goto LABEL_168;
          }
          v93 = v16;
          v94 = v22;
          v95 = 257;
          goto LABEL_177;
        }
      }
      else
      {
        v87 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v88 = v48;
          v89 = (_BYTE *)(v53 + 376);
          if (v53 == -632)
          {
LABEL_160:
            while (v89)
            {
              v90 = *v89;
              if (v90 > 0x3F)
                break;
              if (!*v89)
              {
                v93 = v16;
                v94 = v22;
                v95 = (_WORD)v89 - (v53 + 376) + 1;
                goto LABEL_177;
              }
              v89 += v90 + 1;
              if (v53 != -632)
                goto LABEL_159;
            }
          }
          else
          {
LABEL_159:
            if ((unint64_t)v89 < v53 + 632)
              goto LABEL_160;
          }
          v93 = v16;
          v94 = v22;
          v95 = 257;
LABEL_177:
          v96 = v95;
          v97 = DNSTypeName(*(unsigned __int16 *)(v53 + 342));
          *(_DWORD *)buf = 141558787;
          *(_QWORD *)v169 = 1752392040;
          *(_WORD *)&v169[8] = 1040;
          *(_DWORD *)&v169[10] = v96;
          *(_WORD *)&v169[14] = 2101;
          *(_QWORD *)&v169[16] = v53 + 376;
          *(_WORD *)&v169[24] = 2082;
          *(_QWORD *)&v169[26] = v97;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates transferred LLQ state for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
          v48 = v88;
          v22 = v94;
          v16 = v93;
          v55 = a2 + 284;
          v56 = (_BYTE *)&unk_100164000;
        }
      }
      *(_BYTE *)(a2 + 350) = 0;
LABEL_179:
      SetNextQueryTime(a1, v53);
      v54 = v53;
LABEL_180:
      v53 = *(_QWORD *)(v53 + 8);
      if (!v53)
        goto LABEL_224;
    }
    v66 = mDNSLogCategory_DNSSEC;
    if (v56[2416] != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
      {
LABEL_115:
        v67 = bswap32(*(unsigned __int16 *)(v53 + 340));
        v68 = bswap32(*(unsigned __int16 *)(a2 + 340));
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v169 = HIWORD(v67);
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = HIWORD(v68);
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_INFO, "[Q%u->Q%u] Non-primary DNSSEC question becomes primary due to primary question cancelation.", buf, 0xEu);
      }
    }
    else
    {
      v66 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
        goto LABEL_115;
    }
    v69 = *(_QWORD *)(a2 + 144);
    if (v69)
      ++*(_DWORD *)v69;
    v70 = *(_QWORD **)(v53 + 144);
    if (v70)
    {
      ref_count_obj_release(v70);
      *(_QWORD *)(v53 + 144) = 0;
      v69 = *(_QWORD *)(a2 + 144);
    }
    *(_QWORD *)(v53 + 144) = v69;
    v71 = *(_QWORD **)(a2 + 144);
    if (v71)
    {
      ref_count_obj_release(v71);
      *(_QWORD *)(a2 + 144) = 0;
      v69 = *(_QWORD *)(v53 + 144);
    }
    v72 = *(_QWORD *)(v69 + 16);
    v73 = *(_QWORD *)(v53 + 152);
    v74 = *(_BYTE *)(v53 + 635) != 0;
    *(_QWORD *)(v72 + 24) = v53;
    *(_QWORD *)(v72 + 40) = v73;
    *(_BYTE *)(v72 + 36) = v74;
    *(_QWORD *)(v53 + 152) = dnssec_query_record_result_reply;
    *(_BYTE *)(v53 + 635) = 1;
    *(_DWORD *)(v53 + 228) = *(_DWORD *)(a2 + 228);
    goto LABEL_123;
  }
  v49 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      v98 = (_BYTE *)(a2 + 376);
      v167 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v165 = bswap32(*(unsigned __int16 *)(v47 + 340)) >> 16;
      v163 = *(_DWORD *)(a2 + 252);
      if (a2 == -632)
      {
LABEL_185:
        while (v98)
        {
          v99 = *v98;
          if (v99 > 0x3F)
            break;
          if (!*v98)
          {
            v104 = (_WORD)v98 - (_WORD)v16 + 1;
            goto LABEL_212;
          }
          v98 += v99 + 1;
          if (a2 != -632)
            goto LABEL_184;
        }
      }
      else
      {
LABEL_184:
        if ((unint64_t)v98 < a2 + 632)
          goto LABEL_185;
      }
      v104 = 257;
LABEL_212:
      v112 = v104;
      v113 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      v114 = *(_QWORD *)(a2 + 40);
      v115 = (_BYTE *)(v114 + 376);
      v160 = v22;
      if (v114 == -632)
      {
LABEL_214:
        while (v115)
        {
          v116 = *v115;
          if (v116 > 0x3F)
            break;
          if (!*v115)
          {
            v117 = v113;
            v118 = (_WORD)v115 - (v114 + 376) + 1;
            goto LABEL_223;
          }
          v115 += v116 + 1;
          if (v114 != -632)
            goto LABEL_213;
        }
      }
      else
      {
LABEL_213:
        if ((unint64_t)v115 < v114 + 632)
          goto LABEL_214;
      }
      v117 = v113;
      v118 = 257;
LABEL_223:
      v121 = v118;
      v122 = DNSTypeName(*(unsigned __int16 *)(v114 + 342));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)v169 = v163;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v167;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v165;
      *(_WORD *)&v169[16] = 2048;
      *(_QWORD *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(_QWORD *)&v169[28] = 1752392040;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v112;
      *(_WORD *)&v169[42] = 2101;
      *(_QWORD *)&v169[44] = a2 + 376;
      v170 = 2082;
      v171 = v117;
      v172 = 2048;
      v173 = v114;
      v174 = 2160;
      v175 = 1752392040;
      v176 = 1040;
      v177 = v121;
      v178 = 2101;
      v179 = v114 + 376;
      v180 = 2082;
      v181 = v122;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x70u);
      v48 = &unk_100164000;
      v22 = v160;
    }
  }
  else
  {
    v50 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      v166 = *(_DWORD *)(a2 + 252);
      v164 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v162 = bswap32(*(unsigned __int16 *)(v47 + 340)) >> 16;
      v51 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_86:
        while (v51)
        {
          v52 = *v51;
          if (v52 > 0x3F)
            break;
          if (!*v51)
          {
            v103 = (_WORD)v51 - (_WORD)v16 + 1;
            goto LABEL_203;
          }
          v51 += v52 + 1;
          if (a2 != -632)
            goto LABEL_85;
        }
      }
      else
      {
LABEL_85:
        if ((unint64_t)v51 < a2 + 632)
          goto LABEL_86;
      }
      v103 = 257;
LABEL_203:
      v161 = v103;
      v106 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      v107 = *(_QWORD *)(a2 + 40);
      v108 = (_BYTE *)(v107 + 376);
      if (v107 == -632)
      {
LABEL_205:
        while (v108)
        {
          v109 = *v108;
          if (v109 > 0x3F)
            break;
          if (!*v108)
          {
            v110 = v22;
            v111 = (_WORD)v108 - (v107 + 376) + 1;
            goto LABEL_221;
          }
          v108 += v109 + 1;
          if (v107 != -632)
            goto LABEL_204;
        }
      }
      else
      {
LABEL_204:
        if ((unint64_t)v108 < v107 + 632)
          goto LABEL_205;
      }
      v110 = v22;
      v111 = 257;
LABEL_221:
      v119 = v111;
      v120 = DNSTypeName(*(unsigned __int16 *)(v107 + 342));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)v169 = v166;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v164;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v162;
      *(_WORD *)&v169[16] = 2048;
      *(_QWORD *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(_QWORD *)&v169[28] = 1752392040;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v161;
      *(_WORD *)&v169[42] = 2101;
      *(_QWORD *)&v169[44] = a2 + 376;
      v170 = 2082;
      v171 = v106;
      v172 = 2048;
      v173 = v107;
      v174 = 2160;
      v175 = 1752392040;
      v176 = 1040;
      v177 = v119;
      v178 = 2101;
      v179 = v107 + 376;
      v180 = 2082;
      v181 = v120;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x70u);
      v48 = &unk_100164000;
      v22 = v110;
    }
  }
LABEL_224:
  *(_DWORD *)(a2 + 212) = -1;
  if (v22)
  {
    for (i = (_QWORD *)v22[2]; i; i = (_QWORD *)*i)
    {
      if (i[12] == a2)
      {
        v124 = *v23;
        if (*v23)
        {
          v125 = 0;
          do
          {
            if (v124 == *(_QWORD *)(a1 + 200))
              break;
            if (!*(_QWORD *)(v124 + 40)
              && !*(_BYTE *)(v124 + 354)
              && RecordAnswersQuestion((uint64_t)(i + 1), 0, v124, v17, v18, v19, v20, v21))
            {
              if (*(int *)(v124 + 212) >= 1)
              {
                i[12] = v124;
                goto LABEL_241;
              }
              if (!v125)
                v125 = v124;
            }
            v124 = *(_QWORD *)(v124 + 8);
          }
          while (v124);
          i[12] = v125;
          if (v125)
            continue;
        }
        else
        {
          i[12] = 0;
        }
        --*(_DWORD *)(a1 + 252);
      }
LABEL_241:
      ;
    }
  }
  if (*(_QWORD *)(a1 + 208) == a2)
    *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 200) == a2)
    *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 224) == a2)
    *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 232) == a2)
  {
    v126 = *((_QWORD *)v48 + 295);
    if (gSensitiveLoggingEnabled != 1 || v126 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(*((os_log_t *)v48 + 295), OS_LOG_TYPE_DEFAULT))
      {
        v129 = v16;
        if (a2 == -632)
        {
LABEL_264:
          while (v129)
          {
            v130 = *v129;
            if (v130 > 0x3F)
              break;
            if (!*v129)
            {
              v131 = (_WORD)v129 - (_WORD)v16 + 1;
              goto LABEL_276;
            }
            v129 += v130 + 1;
            if (a2 != -632)
              goto LABEL_263;
          }
        }
        else
        {
LABEL_263:
          if ((unint64_t)v129 < a2 + 632)
            goto LABEL_264;
        }
        v131 = 257;
        goto LABEL_276;
      }
    }
    else
    {
      v126 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v127 = v16;
        if (a2 == -632)
        {
LABEL_256:
          while (v127)
          {
            v128 = *v127;
            if (v128 > 0x3F)
              break;
            if (!*v127)
            {
              v131 = (_WORD)v127 - (_WORD)v16 + 1;
              goto LABEL_276;
            }
            v127 += v128 + 1;
            if (a2 != -632)
              goto LABEL_255;
          }
        }
        else
        {
LABEL_255:
          if ((unint64_t)v127 < a2 + 632)
            goto LABEL_256;
        }
        v131 = 257;
LABEL_276:
        v133 = v131;
        v134 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        *(_DWORD *)buf = 141558787;
        *(_QWORD *)v169 = 1752392040;
        *(_WORD *)&v169[8] = 1040;
        *(_DWORD *)&v169[10] = v133;
        *(_WORD *)&v169[14] = 2101;
        *(_QWORD *)&v169[16] = v16;
        *(_WORD *)&v169[24] = 2082;
        *(_QWORD *)&v169[26] = v134;
        _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "mDNS_StopQuery_internal: Just deleted the current restart question: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
      }
    }
    *(_QWORD *)(a1 + 232) = *(_QWORD *)(a2 + 8);
  }
  *(_QWORD *)(a2 + 8) = 0;
  v135 = *(_QWORD *)(a2 + 112);
  if (v135)
  {
    DisposeTCPConn(v135);
    *(_QWORD *)(a2 + 112) = 0;
  }
  v136 = *(void **)(a2 + 72);
  if (v136)
  {
    CloseSocketSet(*(_QWORD *)(a2 + 72));
    free(v136);
    *(_QWORD *)(a2 + 72) = 0;
  }
  v137 = *(void **)(a2 + 104);
  if (v137)
  {
    CancelGetZoneData(a1, v137);
    *(_QWORD *)(a2 + 104) = 0;
  }
  v138 = *(_QWORD *)(a2 + 96);
  if (v138)
  {
    if (*(_UNKNOWN ***)(v138 + 16) != &_mdns_querier_kind
      || *(_BYTE *)(v138 + 248)
      || (*(_WORD *)(*(_QWORD *)(v138 + 32) + 276) & 1) != 0
      || (Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet) == 0
      && (Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
          (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) == 0)
      || CFSetGetCount(Mutable) > 9)
    {
      v142 = *(_QWORD *)(a2 + 96);
      if (!v142)
        goto LABEL_298;
      mdns_client_invalidate(v142);
      v143 = *(void **)(a2 + 96);
      goto LABEL_297;
    }
    CFSetAddValue(Mutable, (const void *)v138);
    v140 = *((_QWORD *)v48 + 295);
    if (gSensitiveLoggingEnabled != 1 || v140 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(*((os_log_t *)v48 + 295), OS_LOG_TYPE_DEFAULT))
        goto LABEL_335;
      v158 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v169 = v158;
    }
    else
    {
      v140 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_335;
      v141 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v169 = v141;
    }
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "[Q%u] Keeping orphaned querier for up to 5 seconds", buf, 8u);
LABEL_335:
    mdns_querier_set_time_limit_ms((void *)v138, 5000);
    v143 = *(void **)(a2 + 96);
    if (!v143)
      goto LABEL_298;
LABEL_297:
    os_release(v143);
    *(_QWORD *)(a2 + 96) = 0;
  }
LABEL_298:
  v144 = *(void **)(a2 + 80);
  if (v144)
  {
    os_release(v144);
    *(_QWORD *)(a2 + 80) = 0;
  }
  if (DPCFeatureEnabled_sOnce != -1)
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
  if (DPCFeatureEnabled_sEnabled)
  {
    v145 = *(const __CFSet **)(a2 + 192);
    if (v145)
    {
      mdns_cfset_enumerate(v145, (uint64_t)&__block_literal_global_30_3270);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a2 + 192));
      v146 = *(const void **)(a2 + 192);
      if (v146)
      {
        CFRelease(v146);
        *(_QWORD *)(a2 + 192) = 0;
      }
    }
  }
  *(_DWORD *)(a2 + 268) = 0;
  *(_QWORD *)(a2 + 260) = 0;
  switch(*(_BYTE *)(a2 + 672))
  {
    case 0:
    case 5:
    case 6:
    case 7:
    case 8:
      break;
    case 1:
      goto LABEL_309;
    case 2:
      *(_WORD *)(a2 + 342) = 12;
LABEL_309:
      *(_QWORD *)((char *)v16 + 7) = *(_QWORD *)(a2 + 680);
      *v16 = *(_QWORD *)(a2 + 673);
      *(_DWORD *)(a2 + 200) = DomainNameHashValue((unint64_t)v16);
      break;
    case 3:
    case 4:
      *(_WORD *)(a2 + 342) = 28;
      break;
    default:
      LogMsgWithLevel(*((NSObject **)v48 + 295), OS_LOG_TYPE_DEFAULT, "DNS64ResetState: unrecognized DNS64 state %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a2 + 672));
      break;
  }
  *(_BYTE *)(a2 + 672) = 0;
  if (!DNSQuestionNeedsSensitiveLogging(a2))
    goto LABEL_326;
  v147 = gNumOfSensitiveLoggingEnabledQuestions;
  v148 = gSensitiveLoggingEnabled;
  v149 = *((_QWORD *)v48 + 295);
  if (v149 == mDNSLogCategory_State)
    v148 = 0;
  v150 = --gNumOfSensitiveLoggingEnabledQuestions;
  if (v147 == 1)
  {
    if ((v148 & 1) != 0)
    {
      v149 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_324;
    }
    else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
LABEL_324:
      v152 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v169 = v152;
      _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "[Q%u] Last question that enables sensitive logging is stopped.", buf, 8u);
    }
    gSensitiveLoggingEnabled = 0;
    goto LABEL_326;
  }
  if ((v148 & 1) != 0)
  {
    v149 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_322;
  }
  else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
  {
LABEL_322:
    v151 = bswap32(*(unsigned __int16 *)(a2 + 340));
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v169 = HIWORD(v151);
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v150;
    _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "[Q%u] number of sensitive logging enabled questions: %u.", buf, 0xEu);
  }
LABEL_326:
  v153 = *(_DWORD *)(a1 + 48);
  v154 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v154;
  mDNS_VerifyLockState("Drop Lock", 0, v153, v154, (uint64_t)"mDNS_StopQuery_internal", 15756);
  v155 = *(_QWORD **)(a2 + 144);
  if (v155)
  {
    ref_count_obj_release(v155);
    *(_QWORD *)(a2 + 144) = 0;
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNS_StopQuery_internal", 15758);
  --*(_DWORD *)(a1 + 52);
  v156 = *(void **)(a2 + 56);
  if (!v156)
    return 0;
  free(v156);
  v36 = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return v36;
}

_BYTE *putQuestion(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;
  __int16 v9;
  _BYTE *result;
  _BYTE *v13;

  v8 = a6;
  v9 = a5;
  result = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    result += 4;
    if ((unint64_t)result >= a3)
    {
      return 0;
    }
    else
    {
      *v13 = HIBYTE(v9);
      v13[1] = v9;
      v13[2] = HIBYTE(v8);
      v13[3] = v8;
      ++*(_WORD *)(a1 + 4);
    }
  }
  return result;
}

_BYTE *putDomainNameAsLabels(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  _BYTE *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v15;
  unsigned __int8 *v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  char v21;
  __int16 v23;

  if (a2)
  {
    v8 = *a4;
    if (*a4)
    {
      v10 = (_BYTE *)a2;
      v11 = (char *)a4;
      while (1)
      {
        if (v8 >= 0x40)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Malformed domain name %##s (label more than 63 bytes)", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
          return 0;
        }
        if (&v11[v8 + 1] >= (char *)a4 + 256)
          break;
        if (a1 && v8)
        {
          v12 = (unsigned __int8 *)(a2 - v8);
LABEL_9:
          while ((unint64_t)(v12 - 1) >= a1)
          {
            v13 = v12--;
            if (*(v13 - 1) == v8 && *v13 == v11[1] && (unint64_t)&v12[v8] < a2)
            {
              LODWORD(v15) = v8;
              v16 = v12;
              v17 = v11;
LABEL_16:
              v18 = v15 + 1;
              a5 = (unint64_t)v16;
              a6 = (uint64_t)v17;
              a7 = v18;
              while (1)
              {
                v19 = *(unsigned __int8 *)a5++;
                a8 = v19;
                v20 = *(unsigned __int8 *)a6++;
                if ((_DWORD)a8 != v20)
                  break;
                if (!--a7)
                {
                  v16 += v18;
                  v17 += v18;
                  v15 = *v17;
                  a5 = *v16;
                  if (!*v17)
                  {
                    if (*v16)
                      goto LABEL_9;
                    if ((unint64_t)(v10 + 2) <= a3)
                    {
                      v23 = (_WORD)v12 - a1;
                      *v10 = HIBYTE(v23) | 0xC0;
                      v10[1] = v23;
                      return v10 + 2;
                    }
                    return 0;
                  }
                  if (a5 < 0x40
                    || a5 >= 0xC0
                    && (a6 = (uint64_t)(v16 + 1), (unint64_t)(v16 + 1) < a2)
                    && (a6 = v16[1], a5 = a1 + ((a5 & 0x3F) << 8) + a6, (unint64_t)v16 >= a5)
                    && (a6 = *(unsigned __int8 *)a5, v16 = (unsigned __int8 *)a5, a6 <= 0x3F))
                  {
                    a5 = (unint64_t)&v16[v15];
                    if ((unint64_t)&v16[v15] < a2)
                      goto LABEL_16;
                  }
                  goto LABEL_9;
                }
              }
            }
          }
        }
        if ((unint64_t)&v10[v8 + 1] >= a3)
          return 0;
        *v10++ = v8;
        ++v11;
        do
        {
          v21 = *v11++;
          *v10++ = v21;
          --v8;
        }
        while (v8);
        v8 = *v11;
        if (!*v11)
          goto LABEL_36;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Malformed domain name %##s (more than 256 bytes)", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
    }
    else
    {
      v10 = (_BYTE *)a2;
      if (a2 < a3)
      {
LABEL_36:
        *v10 = 0;
        return v10 + 1;
      }
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "putDomainNameAsLabels %##s ptr is null", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
  }
  return 0;
}

unint64_t PutResourceRecordTTLWithLimit(unint64_t a1, unint64_t a2, _WORD *a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  unint64_t v12;
  unint64_t v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  char *v20;
  NSObject *v21;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  _BYTE *v35;
  int v36;
  uint64_t v37;
  _BYTE *v39;
  uint64_t v40;
  _BYTE *v41;
  uint64_t v42;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  int v52;
  uint64_t v53;
  _BYTE *v54;
  uint64_t v55;
  const char *v56;
  const char *v57;
  _BYTE *v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  NSObject *v62;
  os_log_type_t v63;
  uint32_t v64;
  const char *v65;
  const char *v67;
  const char *v68;
  int v69;
  uint64_t v70;
  __int16 v71;
  int v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  uint64_t v78;

  v9 = a5;
  v12 = a2;
  if (*(_WORD *)a1 && (*(_BYTE *)(a1 + 2) & 0x78) == 0x28 && *(_WORD *)(a4 + 4) == 33)
    v13 = 0;
  else
    v13 = a1;
  if (*(_BYTE *)a4)
  {
    if (!a2)
    {
      v32 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          return 0;
        v34 = *(_QWORD *)(a4 + 32);
        if (v34)
        {
          v35 = *(_BYTE **)(a4 + 32);
          v36 = 257;
          if (v34 == -256)
            goto LABEL_53;
LABEL_50:
          if ((unint64_t)v35 < v34 + 256 && v35)
          {
            while (1)
            {
              v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_143:
                v36 = 257;
                goto LABEL_164;
              }
              if (!*v35)
                break;
              v35 += v37 + 1;
              if (v34 != -256)
                goto LABEL_50;
LABEL_53:
              if (!v35)
                goto LABEL_143;
            }
            v36 = (unsigned __int16)((_WORD)v35 - v34 + 1);
          }
        }
        else
        {
          v36 = 0;
        }
      }
      else
      {
        v32 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          return 0;
        v34 = *(_QWORD *)(a4 + 32);
        if (v34)
        {
          v44 = *(_BYTE **)(a4 + 32);
          v36 = 257;
          if (v34 == -256)
            goto LABEL_86;
LABEL_83:
          if ((unint64_t)v44 < v34 + 256 && v44)
          {
            while (1)
            {
              v45 = *v44;
              if (v45 > 0x3F)
              {
LABEL_144:
                v36 = 257;
                goto LABEL_164;
              }
              if (!*v44)
                break;
              v44 += v45 + 1;
              if (v34 != -256)
                goto LABEL_83;
LABEL_86:
              if (!v44)
                goto LABEL_144;
            }
            v36 = (unsigned __int16)((_WORD)v44 - v34 + 1);
          }
        }
        else
        {
          v36 = 0;
        }
      }
LABEL_164:
      v65 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
      v69 = 141558787;
      v70 = 1752392040;
      v71 = 1040;
      v72 = v36;
      v73 = 2101;
      v74 = v34;
      v75 = 2082;
      v76 = v65;
      v61 = "Pointer to message is NULL while filling resource record %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
      v62 = v32;
      v63 = OS_LOG_TYPE_ERROR;
      v64 = 38;
      goto LABEL_165;
    }
    v14 = putDomainNameAsLabels(a1, a2, a6, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
    v19 = v14;
    if (v14 && (unint64_t)(v14 + 10) < a6)
    {
      *v14 = *(_BYTE *)(a4 + 5);
      v14[1] = *(_BYTE *)(a4 + 4);
      v14[2] = *(_BYTE *)(a4 + 7);
      v14[3] = *(_BYTE *)(a4 + 6);
      v14[4] = HIBYTE(v9);
      v14[5] = BYTE2(v9);
      v14[6] = BYTE1(v9);
      v14[7] = v9;
      v20 = putRData(v13, v14 + 10, a6, a4, v15, v16, v17, v18);
      if (v20)
      {
        v12 = (unint64_t)v20;
        *((_WORD *)v19 + 4) = bswap32((_DWORD)v20 - (_DWORD)v19 - 10) >> 16;
        if (a3)
        {
          ++*a3;
          return v12;
        }
        v21 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            return v12;
          v50 = *(_QWORD *)(a4 + 32);
          if (v50)
          {
            v58 = *(_BYTE **)(a4 + 32);
            v52 = 257;
            if (v50 == -256)
              goto LABEL_151;
LABEL_148:
            if ((unint64_t)v58 < v50 + 256 && v58)
            {
              while (1)
              {
                v59 = *v58;
                if (v59 > 0x3F)
                {
LABEL_179:
                  v52 = 257;
                  goto LABEL_181;
                }
                if (!*v58)
                  break;
                v58 += v59 + 1;
                if (v50 != -256)
                  goto LABEL_148;
LABEL_151:
                if (!v58)
                  goto LABEL_179;
              }
              v52 = (unsigned __int16)((_WORD)v58 - v50 + 1);
            }
          }
          else
          {
            v52 = 0;
          }
        }
        else
        {
          v21 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            return v12;
          v50 = *(_QWORD *)(a4 + 32);
          if (v50)
          {
            v51 = *(_BYTE **)(a4 + 32);
            v52 = 257;
            if (v50 == -256)
              goto LABEL_114;
LABEL_111:
            if ((unint64_t)v51 < v50 + 256 && v51)
            {
              while (1)
              {
                v53 = *v51;
                if (v53 > 0x3F)
                {
LABEL_178:
                  v52 = 257;
                  goto LABEL_181;
                }
                if (!*v51)
                  break;
                v51 += v53 + 1;
                if (v50 != -256)
                  goto LABEL_111;
LABEL_114:
                if (!v51)
                  goto LABEL_178;
              }
              v52 = (unsigned __int16)((_WORD)v51 - v50 + 1);
            }
          }
          else
          {
            v52 = 0;
          }
        }
LABEL_181:
        v68 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
        v69 = 141558787;
        v70 = 1752392040;
        v71 = 1040;
        v72 = v52;
        v73 = 2101;
        v74 = v50;
        v75 = 2082;
        v76 = v68;
        v57 = "No target count to update for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
LABEL_142:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v57, (uint8_t *)&v69, 0x26u);
        return v12;
      }
      v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          v46 = *(_QWORD *)(a4 + 32);
          if (v46)
          {
            v54 = *(_BYTE **)(a4 + 32);
            v48 = 257;
            if (v46 == -256)
              goto LABEL_129;
LABEL_126:
            if ((unint64_t)v54 < v46 + 256 && v54)
            {
              while (1)
              {
                v55 = *v54;
                if (v55 > 0x3F)
                {
LABEL_171:
                  v48 = 257;
                  goto LABEL_175;
                }
                if (!*v54)
                  break;
                v54 += v55 + 1;
                if (v46 != -256)
                  goto LABEL_126;
LABEL_129:
                if (!v54)
                  goto LABEL_171;
              }
              v48 = (unsigned __int16)((_WORD)v54 - v46 + 1);
            }
          }
          else
          {
            v48 = 0;
          }
          goto LABEL_175;
        }
      }
      else
      {
        v27 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          v46 = *(_QWORD *)(a4 + 32);
          if (v46)
          {
            v47 = *(_BYTE **)(a4 + 32);
            v48 = 257;
            if (v46 == -256)
              goto LABEL_99;
LABEL_96:
            if ((unint64_t)v47 < v46 + 256 && v47)
            {
              while (1)
              {
                v49 = *v47;
                if (v49 > 0x3F)
                {
LABEL_170:
                  v48 = 257;
                  goto LABEL_175;
                }
                if (!*v47)
                  break;
                v47 += v49 + 1;
                if (v46 != -256)
                  goto LABEL_96;
LABEL_99:
                if (!v47)
                  goto LABEL_170;
              }
              v48 = (unsigned __int16)((_WORD)v47 - v46 + 1);
            }
          }
          else
          {
            v48 = 0;
          }
LABEL_175:
          v67 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          v69 = 141559043;
          v70 = 1752392040;
          v71 = 1040;
          v72 = v48;
          v73 = 2101;
          v74 = v46;
          v75 = 2082;
          v76 = v67;
          v77 = 2048;
          v78 = a6 - (_QWORD)v19 - 10;
          v61 = "Can't put more rdata into current message, will possibly put it into the next message - name: %{sensitiv"
                "e, mask.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
          goto LABEL_160;
        }
      }
      return 0;
    }
    v27 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        return 0;
      v28 = *(_QWORD *)(a4 + 32);
      if (v28)
      {
        v41 = *(_BYTE **)(a4 + 32);
        v30 = 257;
        if (v28 == -256)
          goto LABEL_75;
LABEL_72:
        if ((unint64_t)v41 < v28 + 256 && v41)
        {
          while (1)
          {
            v42 = *v41;
            if (v42 > 0x3F)
            {
LABEL_137:
              v30 = 257;
              goto LABEL_159;
            }
            if (!*v41)
              break;
            v41 += v42 + 1;
            if (v28 != -256)
              goto LABEL_72;
LABEL_75:
            if (!v41)
              goto LABEL_137;
          }
          v30 = (unsigned __int16)((_WORD)v41 - v28 + 1);
        }
      }
      else
      {
        v30 = 0;
      }
    }
    else
    {
      v27 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        return 0;
      v28 = *(_QWORD *)(a4 + 32);
      if (v28)
      {
        v29 = *(_BYTE **)(a4 + 32);
        v30 = 257;
        if (v28 == -256)
          goto LABEL_37;
LABEL_34:
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_136:
              v30 = 257;
              goto LABEL_159;
            }
            if (!*v29)
              break;
            v29 += v31 + 1;
            if (v28 != -256)
              goto LABEL_34;
LABEL_37:
            if (!v29)
              goto LABEL_136;
          }
          v30 = (unsigned __int16)((_WORD)v29 - v28 + 1);
        }
      }
      else
      {
        v30 = 0;
      }
    }
LABEL_159:
    v60 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    v69 = 141559043;
    v70 = 1752392040;
    v71 = 1040;
    v72 = v30;
    v73 = 2101;
    v74 = v28;
    v75 = 2082;
    v76 = v60;
    v77 = 2048;
    v78 = a6 - (_QWORD)v19;
    v61 = "Can't put more names into current message, will possibly put it into the next message - name: %{sensitive, mas"
          "k.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
LABEL_160:
    v62 = v27;
    v63 = OS_LOG_TYPE_DEBUG;
    v64 = 48;
LABEL_165:
    _os_log_impl((void *)&_mh_execute_header, v62, v63, v61, (uint8_t *)&v69, v64);
    return 0;
  }
  v21 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      return v12;
    v23 = *(_QWORD *)(a4 + 32);
    if (v23)
    {
      v24 = *(_BYTE **)(a4 + 32);
      v25 = 257;
      if (v23 == -256)
        goto LABEL_24;
LABEL_21:
      if ((unint64_t)v24 < v23 + 256 && v24)
      {
        while (1)
        {
          v26 = *v24;
          if (v26 > 0x3F)
          {
LABEL_119:
            v25 = 257;
            goto LABEL_141;
          }
          if (!*v24)
            break;
          v24 += v26 + 1;
          if (v23 != -256)
            goto LABEL_21;
LABEL_24:
          if (!v24)
            goto LABEL_119;
        }
        v25 = (unsigned __int16)((_WORD)v24 - v23 + 1);
      }
    }
    else
    {
      v25 = 0;
    }
    goto LABEL_141;
  }
  v21 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    v23 = *(_QWORD *)(a4 + 32);
    if (v23)
    {
      v39 = *(_BYTE **)(a4 + 32);
      v25 = 257;
      if (v23 == -256)
        goto LABEL_64;
LABEL_61:
      if ((unint64_t)v39 < v23 + 256 && v39)
      {
        while (1)
        {
          v40 = *v39;
          if (v40 > 0x3F)
          {
LABEL_120:
            v25 = 257;
            goto LABEL_141;
          }
          if (!*v39)
            break;
          v39 += v40 + 1;
          if (v23 != -256)
            goto LABEL_61;
LABEL_64:
          if (!v39)
            goto LABEL_120;
        }
        v25 = (unsigned __int16)((_WORD)v39 - v23 + 1);
      }
    }
    else
    {
      v25 = 0;
    }
LABEL_141:
    v56 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    v69 = 141558787;
    v70 = 1752392040;
    v71 = 1040;
    v72 = v25;
    v73 = 2101;
    v74 = v23;
    v75 = 2082;
    v76 = v56;
    v57 = "Attempt to put kDNSRecordTypeUnregistered %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
    goto LABEL_142;
  }
  return v12;
}

char *putRData(unint64_t a1, char *__dst, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  char *v10;
  uint64_t v11;
  _OWORD *v12;
  unint64_t v13;
  size_t v14;
  char *v15;
  unsigned __int8 *v16;
  _BYTE *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  BOOL v23;
  char *v24;
  char *v25;
  uint64_t v27;
  unsigned __int16 *v28;
  int v29;
  unsigned __int16 *v30;
  unsigned int v31;
  int v32;
  unsigned __int16 *v33;
  unsigned __int16 *i;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  unsigned __int16 *v41;
  _BYTE *v42;
  unsigned __int16 v43;
  uint64_t v44;
  NSObject *v45;
  char *v46;
  char *v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  unsigned int v60;
  char *v61;
  uint64_t v62;
  char v63;
  NSObject *v64;
  uint64_t v66;
  _BYTE *v67;
  int v68;
  uint64_t v69;
  _BYTE *v71;
  uint64_t v72;
  int v73;
  _BYTE __tp[22];
  __int16 v75;
  int v76;
  __int16 v77;
  uint64_t v78;

  v9 = a3;
  v10 = __dst;
  v11 = *(_QWORD *)(a4 + 40);
  v12 = (_OWORD *)(v11 + 4);
  v13 = a1;
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      v15 = 0;
      if ((unint64_t)(__dst + 4) <= a3 && *(_WORD *)(a4 + 12) == 4)
      {
        *__dst = *(_BYTE *)(v11 + 4);
        __dst[1] = *(_BYTE *)(v11 + 5);
        __dst[2] = *(_BYTE *)(v11 + 6);
        __dst[3] = *(_BYTE *)(v11 + 7);
        return __dst + 4;
      }
      return v15;
    case 2:
    case 5:
    case 0xC:
    case 0x27:
      v16 = (unsigned __int8 *)(v11 + 4);
      return putDomainNameAsLabels(a1, (unint64_t)__dst, a3, v16, a5, a6, a7, a8);
    case 3:
    case 4:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x23:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
      goto LABEL_2;
    case 6:
      v17 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v17)
        return 0;
      v22 = putDomainNameAsLabels(v13, (unint64_t)v17, v9, (unsigned __int8 *)(v11 + 260), v18, v19, v20, v21);
      v15 = (char *)(v22 + 5);
      v23 = !v22 || (unint64_t)v15 > v9;
      if (v23)
        return 0;
      *v22 = bswap32(*(_DWORD *)(v11 + 516));
      v22[1] = bswap32(*(_DWORD *)(v11 + 520));
      v22[2] = bswap32(*(_DWORD *)(v11 + 524));
      v22[3] = bswap32(*(_DWORD *)(v11 + 528));
      v22[4] = bswap32(*(_DWORD *)(v11 + 532));
      return v15;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      if ((unint64_t)(__dst + 3) > a3)
        return 0;
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      v16 = (unsigned __int8 *)(v11 + 6);
      __dst += 2;
      goto LABEL_29;
    case 0x11:
      v24 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v24)
        return 0;
      __dst = v24;
      v16 = (unsigned __int8 *)(v11 + 260);
      goto LABEL_28;
    case 0x1A:
      if ((unint64_t)(__dst + 5) > a3)
        return 0;
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      v25 = putDomainNameAsLabels(a1, (unint64_t)(__dst + 2), a3, (unsigned __int8 *)(v11 + 6), a5, a6, a7, a8);
      if (!v25)
        return 0;
      __dst = v25;
      v16 = (unsigned __int8 *)(v11 + 262);
      goto LABEL_28;
    case 0x1C:
      if (*(_WORD *)(a4 + 12) != 16)
        return 0;
      v15 = __dst + 16;
      if ((unint64_t)(__dst + 16) > a3)
        return 0;
      *(_OWORD *)__dst = *v12;
      return v15;
    case 0x21:
      if ((unint64_t)(__dst + 7) > a3)
        return 0;
      *__dst = *(_BYTE *)(v11 + 5);
      __dst[1] = *(_BYTE *)(v11 + 4);
      __dst[2] = *(_BYTE *)(v11 + 7);
      __dst[3] = *(_BYTE *)(v11 + 6);
      __dst[4] = *(_BYTE *)(v11 + 8);
      __dst[5] = *(_BYTE *)(v11 + 9);
      __dst += 6;
      v16 = (unsigned __int8 *)(v11 + 10);
LABEL_28:
      a1 = v13;
LABEL_29:
      a3 = v9;
      return putDomainNameAsLabels(a1, (unint64_t)__dst, a3, v16, a5, a6, a7, a8);
    case 0x29:
      v27 = *(unsigned __int16 *)(a4 + 12);
      v28 = (unsigned __int16 *)((char *)v12 + v27);
      if (v12 >= (_OWORD *)((char *)v12 + v27))
      {
        v15 = __dst;
        if ((unint64_t)__dst <= a3)
          return v15;
        goto LABEL_95;
      }
      v29 = 0;
      v30 = (unsigned __int16 *)(v11 + 20);
      while (1)
      {
        v31 = *(v30 - 8);
        if (v31 <= 3)
        {
          if (v31 == 1)
          {
            v32 = 22;
          }
          else
          {
            if (v31 != 2)
              goto LABEL_48;
            v32 = 8;
          }
        }
        else
        {
          switch(v31)
          {
            case 0xFDEAu:
              v32 = 14;
              break;
            case 0xFDE9u:
              v32 = 9;
              break;
            case 4u:
              if (*(v30 - 5) == *(v30 - 2) && *(v30 - 4) == *(v30 - 1))
              {
                if (*(v30 - 3) == *v30)
                  v32 = 12;
                else
                  v32 = 18;
              }
              else
              {
                v32 = 18;
              }
              break;
            default:
LABEL_48:
              v32 = 0x10000;
              break;
          }
        }
        v29 += v32;
        v33 = v30 + 4;
        v30 += 12;
        if (v33 >= v28)
        {
          if ((unint64_t)&__dst[v29] <= a3)
          {
            for (i = (unsigned __int16 *)(v11 + 12); ; i += 12)
            {
              v35 = *(i - 4);
              if (v35 <= 3)
              {
                if (v35 == 1)
                {
                  v36 = 22;
                }
                else
                {
                  if (v35 != 2)
                    goto LABEL_68;
                  v36 = 8;
                }
              }
              else
              {
                switch(v35)
                {
                  case 0xFDEAu:
                    v36 = 14;
                    break;
                  case 0xFDE9u:
                    v36 = 9;
                    break;
                  case 4u:
                    if (*(i - 1) == i[2] && *i == i[3])
                    {
                      if (i[1] == i[4])
                        v36 = 12;
                      else
                        v36 = 18;
                    }
                    else
                    {
                      v36 = 18;
                    }
                    break;
                  default:
LABEL_68:
                    v36 = 0x10000;
                    break;
                }
              }
              *v10 = BYTE1(v35);
              v10[1] = v35;
              v10[2] = (unsigned __int16)(v36 - 4) >> 8;
              v10[3] = v36 - 4;
              v15 = v10 + 4;
              v37 = *(i - 4);
              if (v37 <= 3)
              {
                if (v37 == 1)
                {
                  *((_WORD *)v10 + 2) = bswap32(*(i - 2)) >> 16;
                  *((_WORD *)v10 + 3) = bswap32(*(i - 1)) >> 16;
                  *((_WORD *)v10 + 4) = bswap32(*i) >> 16;
                  *(_QWORD *)(v10 + 10) = *(_QWORD *)(i + 2);
                  *(_DWORD *)(v10 + 18) = bswap32(*((_DWORD *)i + 3));
                  v15 = v10 + 22;
                }
                else if (v37 == 2)
                {
                  *((_DWORD *)v10 + 1) = bswap32(*((_DWORD *)i - 1));
                  v15 = v10 + 8;
                }
              }
              else
              {
                switch(v37)
                {
                  case 4u:
                    v10[4] = *((_BYTE *)i - 4);
                    v10[5] = *((_BYTE *)i - 3);
                    v38 = *(_DWORD *)(i - 1);
                    *((_WORD *)v10 + 5) = i[1];
                    *(_DWORD *)(v10 + 6) = v38;
                    v15 = v10 + 12;
                    if (v36 >= 0x12)
                    {
                      v39 = *((_DWORD *)i + 1);
                      *((_WORD *)v10 + 8) = i[4];
                      *(_DWORD *)v15 = v39;
                      v15 = v10 + 18;
                      v40 = v36 - 18;
                      if (v36 != 18)
                      {
                        memcpy(v15, i + 5, v36 - 18);
                        v15 += v40;
                      }
                    }
                    break;
                  case 0xFDE9u:
                    v10[4] = *((_BYTE *)i - 4);
                    *(_DWORD *)(v10 + 5) = bswap32(*(_DWORD *)i);
                    v15 = v10 + 9;
                    break;
                  case 0xFDEAu:
                    *(_QWORD *)__tp = 0;
                    *(_QWORD *)&__tp[8] = 0;
                    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                    *((_DWORD *)v10 + 1) = bswap32(*(_DWORD *)__tp - *((_DWORD *)i - 1));
                    *((_DWORD *)v10 + 2) = bswap32(*(_DWORD *)i);
                    *((_WORD *)v10 + 6) = bswap32(i[2]) >> 16;
                    v15 = v10 + 14;
                    break;
                }
              }
              v41 = i + 8;
              v10 = v15;
              if (v41 >= v28)
                return v15;
            }
          }
LABEL_95:
          v45 = mDNSLogCategory_Default;
          v46 = "ERROR: putOptRData - out of space";
          goto LABEL_135;
        }
      }
    case 0x2F:
      v42 = (_BYTE *)(v11 + 4);
      if (v11 != -260)
        goto LABEL_86;
      while (2)
      {
        if (!v42)
          goto LABEL_96;
LABEL_90:
        v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_96:
          v43 = 257;
        }
        else
        {
          if (*v42)
          {
            v42 += v44 + 1;
            if (v11 == -260)
              continue;
LABEL_86:
            v43 = 257;
            if ((unint64_t)v42 >= v11 + 260 || !v42)
              break;
            goto LABEL_90;
          }
          v43 = (_WORD)v42 - (_WORD)v12 + 1;
        }
        break;
      }
      v47 = (char *)v12 + v43;
      if (RRAssertsExistence(a4, 0x2Fu, a3, a4, a5, a6, a7, a8))
      {
        v14 = *(unsigned __int16 *)(a4 + 12);
        v48 = v14 - v43;
        if ((_DWORD)v14 == v43)
        {
LABEL_104:
          if ((unint64_t)&v10[v14] <= v9)
          {
LABEL_3:
            memcpy(v10, v12, v14);
            return &v10[*(unsigned __int16 *)(a4 + 12)];
          }
          v51 = mDNSLogCategory_Default;
          v52 = *(_QWORD *)(a4 + 32);
          DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "putRData: NSEC rdlength beyond limit %##s (%s), ptr %p, rdlength %d, limit %p", v53, v54, v55, v56, v57, v52);
        }
        else
        {
          while (1)
          {
            v49 = v48 - 2;
            if (v48 <= 2)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "putRData: invalid length %d", a4, a5, a6, a7, a8, v48);
              return 0;
            }
            v50 = v47[1];
            if (v49 < v50 || (v50 - 33) <= 0xFFFFFFDF)
              break;
            v47 += v50 + 2;
            v48 = v49 - v50;
            if (!v48)
              goto LABEL_104;
          }
          v45 = mDNSLogCategory_Default;
          v73 = v47[1];
          v46 = "putRData: invalid window length %d";
LABEL_135:
          LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, v46, a4, a5, a6, a7, a8, v73);
        }
        return 0;
      }
      v58 = v47[1];
      v59 = v47 + 2;
      while (1)
      {
        v60 = v58;
        v23 = v58-- < 1;
        if (v23)
          break;
        if (v59[v58])
          goto LABEL_111;
      }
      v60 = 0;
LABEL_111:
      v61 = putDomainNameAsLabels(v13, (unint64_t)v10, v9, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
      v15 = v61;
      if (!v60 || !v61)
        goto LABEL_116;
      if ((unint64_t)&v61[v60 + 2] <= v9)
      {
        v62 = v60;
        *v61 = 0;
        v61[1] = v60;
        v15 = v61 + 2;
        do
        {
          v63 = *v59++;
          *v15++ = v63;
          --v62;
        }
        while (v62);
LABEL_116:
        if (v15)
          return v15;
      }
      v64 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
          return 0;
        v66 = *(_QWORD *)(a4 + 32);
        if (v66)
        {
          v67 = *(_BYTE **)(a4 + 32);
          if (v66 == -256)
            goto LABEL_128;
LABEL_125:
          v68 = 257;
          if ((unint64_t)v67 < v66 + 256 && v67)
          {
            while (1)
            {
              v69 = *v67;
              if (v69 > 0x3F)
              {
LABEL_151:
                v68 = 257;
                goto LABEL_156;
              }
              if (!*v67)
                break;
              v67 += v69 + 1;
              if (v66 != -256)
                goto LABEL_125;
LABEL_128:
              if (!v67)
                goto LABEL_151;
            }
            v68 = (unsigned __int16)((_WORD)v67 - v66 + 1);
          }
        }
        else
        {
          v68 = 0;
        }
        goto LABEL_156;
      }
      v64 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        v66 = *(_QWORD *)(a4 + 32);
        if (v66)
        {
          v71 = *(_BYTE **)(a4 + 32);
          if (v66 == -256)
            goto LABEL_144;
LABEL_141:
          v68 = 257;
          if ((unint64_t)v71 < v66 + 256 && v71)
          {
            while (1)
            {
              v72 = *v71;
              if (v72 > 0x3F)
              {
LABEL_152:
                v68 = 257;
                goto LABEL_156;
              }
              if (!*v71)
                break;
              v71 += v72 + 1;
              if (v66 != -256)
                goto LABEL_141;
LABEL_144:
              if (!v71)
                goto LABEL_152;
            }
            v68 = (unsigned __int16)((_WORD)v71 - v66 + 1);
          }
        }
        else
        {
          v68 = 0;
        }
LABEL_156:
        *(_DWORD *)__tp = 134218755;
        *(_QWORD *)&__tp[4] = v9 - (_QWORD)v10;
        *(_WORD *)&__tp[12] = 2160;
        *(_QWORD *)&__tp[14] = 1752392040;
        v75 = 1040;
        v76 = v68;
        v77 = 2101;
        v78 = v66;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEBUG, "The mDNS message does not have enough space for the NSEC record, will add it to the next message (This is not an error message) -- remaining space: %ld, NSEC name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", __tp, 0x26u);
      }
      return 0;
    default:
      if (*(unsigned __int16 *)(a4 + 4) == 65323)
      {
        *(_QWORD *)__tp = 0;
        *(_QWORD *)&__tp[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
        *(_DWORD *)v10 = bswap32(*(_DWORD *)__tp - *(_DWORD *)v12);
        return v10 + 4;
      }
LABEL_2:
      v14 = *(unsigned __int16 *)(a4 + 12);
      if ((unint64_t)&__dst[v14] > v9)
        return 0;
      goto LABEL_3;
  }
}

uint64_t mDNSSendDNSMessage(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, int *a7, unsigned __int16 a8, _DWORD *a9, unsigned __int8 a10)
{
  unsigned __int16 v10;
  int *v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  unint64_t v15;
  unint64_t v18;
  uint64_t v19;
  __int16 v20;
  __int16 v21;
  unsigned int v23;
  CCHmacAlgorithm v24;
  NSObject *v25;
  uint64_t v27;
  _BOOL4 v28;
  __int16 v29;
  NSObject *v30;
  const void *v31;
  _DWORD *v32;
  _BYTE *i;
  uint64_t v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  _BYTE *j;
  uint64_t v38;
  const char *v39;
  const char *v40;
  const char *v41;
  uint64_t v42;
  unsigned __int16 v43;
  size_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  _WORD *v66;
  void *v67;
  ssize_t v68;
  ssize_t v69;
  NSObject *v70;
  unsigned int v71;
  const char *v72;
  int v74;
  __int16 v78;
  CCHmacContext ctx;
  unsigned __int16 v80;
  __int16 data;
  int v82;
  __int16 v83;
  _OWORD macOut[4];
  uint8_t buf[4];
  unint64_t v86;
  _BYTE v87[10];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  _BYTE *v91;
  __int16 *v92;
  uint64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  int v101;
  char v102;
  int v103;
  char v104;
  __int16 v105;
  _BYTE *v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  _BYTE v119[25];
  int v120;
  int v121;
  __int16 v122;
  __int128 v123;
  uint64_t v124;
  _BYTE v125[256];
  __int16 v126;

  v10 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v15 = a3;
  v78 = *(_WORD *)(a2 + 10);
  if (*(_WORD *)a2)
    ++*(_DWORD *)(a1 + 168);
  else
    ++*(_DWORD *)(a1 + 172);
  v18 = a2 + 12;
  v19 = a3 - (a2 + 12);
  if (a3 >= a2 + 12 && v19 < 8941)
  {
    *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
    *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
    *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
    v20 = *(unsigned __int8 *)(a2 + 10);
    v21 = *(unsigned __int8 *)(a2 + 11);
    *(_WORD *)(a2 + 10) = v21 | (v20 << 8);
    if (a9)
    {
      v80 = v20 | (v21 << 8);
      v23 = a9[196] - 1;
      if (v23 > 4)
        v24 = 4;
      else
        v24 = dword_1000FFEAC[v23];
      bzero(buf, 0x498uLL);
      v83 = 0;
      v82 = 0;
      memset(macOut, 0, sizeof(macOut));
      memset(&ctx, 0, sizeof(ctx));
      CCHmacInit(&ctx, v24, a9 + 198, a9[197]);
      CCHmacUpdate(&ctx, (const void *)a2, v15 - a2);
      BYTE4(v86) = 32;
      v90 = 0;
      v91 = v125;
      *(_QWORD *)v87 = 0x1194000100FALL;
      v126 = 264;
      v93 = 0;
      v92 = &v126;
      v101 = 0;
      v102 = 0;
      v103 = 0;
      v104 = 0;
      v105 = 0;
      v94 = 0u;
      v95 = 0u;
      v96 = 0u;
      v97 = 0u;
      v98 = 0u;
      v99 = 0u;
      v100 = 0;
      v106 = v125;
      v121 = 0;
      v122 = 0;
      v124 = 0;
      v123 = 0u;
      v120 = 0;
      v125[0] = 0;
      v31 = a9 + 67;
      v32 = a9 + 131;
      v107 = 0u;
      v108 = 0u;
      v109 = 0u;
      v110 = 0u;
      v111 = 0u;
      v112 = 0u;
      v113 = 0u;
      v114 = 0u;
      v115 = 0u;
      v116 = 0u;
      v117 = 0u;
      v118 = 0u;
      memset(v119, 0, sizeof(v119));
      for (i = a9 + 67; i < (_BYTE *)v32; i += v34 + 1)
      {
        if (!i)
          break;
        v34 = *i;
        if (v34 > 0x3F)
          break;
        if (!*i)
        {
          v35 = (_WORD)i - (_WORD)v31 + 1;
          if (v35 <= 0x100u)
            memcpy(v125, v31, v35);
          break;
        }
      }
      v36 = 257;
      for (j = a9 + 67; j < (_BYTE *)v32; j += v38 + 1)
      {
        if (!j)
          break;
        v38 = *j;
        if (v38 > 0x3F)
          break;
        if (!*j)
        {
          v36 = (_WORD)j - (_WORD)v31 + 1;
          break;
        }
      }
      CCHmacUpdate(&ctx, v31, v36);
      *(_WORD *)&v87[2] = 255;
      data = -256;
      CCHmacUpdate(&ctx, &data, 2uLL);
      *(_DWORD *)&v87[4] = 0;
      CCHmacUpdate(&ctx, &v87[4], 4uLL);
      if (v23 > 5)
        v39 = "\fhmac-invalid";
      else
        v39 = off_10013BD68[v23];
      v40 = v39 + 256;
      v41 = v39;
      if (v39 == (const char *)-256)
      {
LABEL_44:
        while (v41)
        {
          v42 = *(unsigned __int8 *)v41;
          if (v42 > 0x3F)
            break;
          if (!*v41)
          {
            v43 = (_WORD)v41 - (_WORD)v39 + 1;
            if (v43 > 0x100u)
              break;
            memcpy(v92 + 2, v39, v43);
            goto LABEL_52;
          }
          v41 += v42 + 1;
          if (v39 != (const char *)-256)
            goto LABEL_43;
        }
      }
      else
      {
LABEL_43:
        if (v41 < v40)
          goto LABEL_44;
      }
      *((_BYTE *)v92 + 4) = 0;
LABEL_52:
      v44 = 257;
      v45 = v39;
      if (v39 == (const char *)-256)
      {
LABEL_54:
        while (v45)
        {
          v46 = *(unsigned __int8 *)v45;
          if (v46 > 0x3F)
            break;
          if (!*v45)
          {
            v44 = (unsigned __int16)((_WORD)v45 - (_WORD)v39 + 1);
            break;
          }
          v45 += v46 + 1;
          if (v39 != (const char *)-256)
            goto LABEL_53;
        }
      }
      else
      {
LABEL_53:
        if (v45 < v40)
          goto LABEL_54;
      }
      v47 = (uint64_t)v92 + v44 + 4;
      CCHmacUpdate(&ctx, v39, v44);
      v53 = time(0);
      if (v53 == -1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DNSDigest_SignMessage - mDNSPlatformUTC returned bad time -1", v48, v49, v50, v51, v52, v74);
      LOWORD(v82) = 0;
      BYTE2(v82) = HIBYTE(v53);
      HIBYTE(v82) = BYTE2(v53);
      LOBYTE(v83) = BYTE1(v53);
      HIBYTE(v83) = v53;
      v54 = v82;
      *(_WORD *)(v47 + 4) = v83;
      *(_DWORD *)v47 = v54;
      CCHmacUpdate(&ctx, &v82, 6uLL);
      *(_WORD *)(v47 + 6) = 11265;
      CCHmacUpdate(&ctx, (const void *)(v47 + 6), 2uLL);
      data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      CCHmacFinal(&ctx, macOut);
      v55 = 0;
      v11 = a7;
      if (v23 <= 5)
        v55 = word_1000FFEA0[v23];
      *(_BYTE *)(v47 + 8) = 0;
      *(_BYTE *)(v47 + 9) = v55;
      memcpy((void *)(v47 + 10), macOut, v55);
      v56 = v47 + 10 + v55;
      *(_BYTE *)v56 = *(_BYTE *)a2;
      *(_BYTE *)(v56 + 1) = *(_BYTE *)(a2 + 1);
      *(_DWORD *)(v56 + 2) = 0;
      *(_WORD *)&v87[8] = v56 - (_WORD)v92 + 2;
      v15 = PutResourceRecordTTLWithLimit(a2, v15, &v80, (uint64_t)&v86 + 4, 0, a2 + 8952, v57, v58);
      if (v15)
        *(_WORD *)(a2 + 10) = bswap32(v80) >> 16;
      else
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DNSDigest_SignMessage - could not put TSIG", v59, v60, v61, v62, v63, v74);
      v10 = a8;
      v13 = a5;
      v29 = v78;
      v12 = a6;
      if (v15)
      {
LABEL_68:
        if (!v13)
        {
          v27 = mDNSPlatformSendUDP((_QWORD *)a1, (unsigned __int16 *)a2, v15, a4, (uint64_t)v12, v11, v10, a10);
          goto LABEL_85;
        }
        v64 = (uint64_t)v13;
        v65 = (unsigned __int16)(v15 - a2);
        v66 = malloc_type_malloc((v65 + 2), 0xA172743EuLL);
        if (!v66)
          __break(1u);
        v67 = v66;
        *v66 = bswap32(v15 - a2) >> 16;
        memcpy(v66 + 1, (const void *)a2, (unsigned __int16)(v15 - a2));
        v68 = mDNSPlatformWriteTCP(v64, v67, (v65 + 2));
        if (v68 == v65 + 2)
        {
          v27 = 0;
          v11 = a7;
LABEL_84:
          free(v67);
          v29 = v78;
          v13 = (unsigned __int16 *)v64;
          v12 = a6;
LABEL_85:
          *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
          *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
          *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
          *(_WORD *)(a2 + 10) = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
          if (v12)
          {
            v71 = *v12;
            if (v13)
            {
LABEL_87:
              if (*((_DWORD *)v13 + 1))
                v72 = "TLS";
              else
                v72 = "TCP";
              v71 = *v13;
              goto LABEL_93;
            }
          }
          else
          {
            v71 = 59668;
            if (v13)
              goto LABEL_87;
          }
          v72 = "UDP";
LABEL_93:
          DumpPacket(v27, 1, (uint64_t)v72, 0, v71, (__int128 *)v11, v10, (unsigned __int8 *)a2, v15, a4);
          *(_WORD *)(a2 + 10) = v29;
          return v27;
        }
        v69 = v68;
        v27 = 4294901508;
        v70 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
LABEL_82:
            *(_DWORD *)buf = 134218240;
            v86 = v69;
            *(_WORD *)v87 = 1024;
            *(_DWORD *)&v87[2] = (unsigned __int16)(v15 - a2);
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: write message failed %ld/%d", buf, 0x12u);
          }
        }
        else
        {
          v70 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_82;
        }
        v11 = a7;
        goto LABEL_84;
      }
    }
    else
    {
      v29 = v78;
      if (a3)
        goto LABEL_68;
    }
    v30 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_79;
      }
    }
    else
    {
      v30 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_79:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: DNSDigest_SignMessage failed", buf, 2u);
        v27 = 4294901757;
        goto LABEL_85;
      }
    }
    v27 = 4294901757;
    goto LABEL_85;
  }
  v25 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    v27 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      *(_DWORD *)buf = 134218496;
      v86 = v18;
      *(_WORD *)v87 = 2048;
      *(_QWORD *)&v87[2] = v15;
      v88 = 2048;
      v89 = v19;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: invalid message %p %p %ld", buf, 0x20u);
    }
  }
  else
  {
    v25 = mDNSLogCategory_Default_redacted;
    v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    v27 = 4294901756;
    if (v28)
      goto LABEL_17;
  }
  return v27;
}

uint64_t mDNSPlatformSendUDP(_QWORD *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, unsigned int a7, int a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v18;
  const char *v19;
  int *v20;
  NSObject *v22;
  os_log_type_t v23;
  uint32_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  NSObject *v29;
  int *v30;
  int v31;
  unsigned int *v32;
  int v33;
  int v34;
  char *v35;
  char v36;
  uint64_t v37;
  uint8_t *v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  const char *v43;
  NSObject *v44;
  uint32_t v45;
  int v46;
  int *v47;
  char *v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  ssize_t v55;
  int v56;
  NSObject *v57;
  _BOOL8 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  int v67;
  char *v68;
  int v69;
  unsigned int v70;
  int v71;
  char *v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  char v78;
  uint64_t v79;
  NSObject *v80;
  uint64_t v81;
  const char *v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  char *v86;
  int v87;
  const char *v88;
  NSObject *v89;
  os_log_type_t v90;
  uint32_t v91;
  unsigned int v92;
  char *v93;
  int v94;
  unsigned int v95;
  char *v96;
  int v97;
  unsigned int v99;
  int *v100;
  char *v101;
  unsigned int v102;
  int v103;
  int __errnum;
  unsigned int __errnuma;
  NSObject *__errnumb;
  const char *v107;
  const char *v108;
  _QWORD *v109;
  uint8_t buf[4];
  _BYTE v111[30];
  __int16 v112;
  int v113;
  __int16 v114;
  _BYTE v115[14];
  __int16 v116;
  int *v117;
  __int16 v118;
  unsigned int v119;
  __int16 v120;
  int v121;
  __int16 v122;
  ssize_t v123;
  __int16 v124;
  int v125;
  __int16 v126;
  char *v127;
  __int16 v128;
  int v129;
  __int16 v130;
  int v131;
  char v132[8];
  uint64_t v133;
  sockaddr v134[8];

  memset(v134, 0, sizeof(v134));
  if (a4)
  {
    v14 = *(_QWORD *)mDNSStorage;
    if (!*(_QWORD *)mDNSStorage)
    {
LABEL_6:
      v15 = mDNSLogCategory_NAT;
      v16 = 4294901756;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          return v16;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v111 = a4;
        v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }
      else
      {
        v15 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          return v16;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v111 = a4;
        v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }
      v22 = v15;
      v23 = OS_LOG_TYPE_DEFAULT;
      v24 = 12;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, v18, buf, v24);
      return v16;
    }
    while (!*(_QWORD *)(v14 + 3776) || *(_DWORD *)(v14 + 3720) != (_DWORD)a4)
    {
      v14 = *(_QWORD *)(v14 + 3680);
      if (!v14)
        goto LABEL_6;
    }
  }
  else
  {
    v14 = 0;
  }
  if (a4)
    v19 = (const char *)(v14 + 3606);
  else
    v19 = "unicast";
  if (*a6 == 6)
  {
    *(_WORD *)&v134[0].sa_len = 7708;
    *(_WORD *)v134[0].sa_data = a7;
    *(sockaddr *)&v134[0].sa_data[6] = *(sockaddr *)(a6 + 1);
    if (v14)
      v25 = *(_DWORD *)(v14 + 3720);
    else
      v25 = 0;
    *(_DWORD *)&v134[1].sa_data[6] = v25;
    v109 = a1;
    if (a5)
      v30 = (int *)(a5 + 48);
    else
      v30 = (int *)(*a1 + 56);
    v28 = *v30;
    if (!v14)
      goto LABEL_80;
    v107 = v19;
    if (!mDNSAddrIsDNSMulticast(a6))
      goto LABEL_75;
    v32 = (unsigned int *)(v14 + 3720);
    v33 = setsockopt(v28, 41, 9, (const void *)(v14 + 3720), 4u);
    if ((v33 & 0x80000000) == 0)
      goto LABEL_75;
    v34 = v33;
    __errnum = *__error();
    *(_QWORD *)v132 = 0;
    v133 = 0;
    v35 = if_indextoname(*v32, v132);
    v36 = gSensitiveLoggingEnabled;
    if (mDNSLogCategory_NAT == mDNSLogCategory_State)
      v36 = 0;
    if (v35)
    {
      if ((v36 & 1) != 0)
      {
        v37 = mDNSLogCategory_NAT_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_63;
      }
      else
      {
        v37 = mDNSLogCategory_NAT;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
        {
LABEL_63:
          v102 = bswap32(*a2) >> 16;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)v111 = v102;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v34;
          *(_WORD *)&v111[10] = 1024;
          *(_DWORD *)&v111[12] = __errnum;
          *(_WORD *)&v111[16] = 2082;
          *(_QWORD *)&v111[18] = strerror(__errnum);
          v43 = "[Q%u] setsockopt - IPV6_MULTICAST_IF error %d errno %d (%{public}s)";
          v44 = v37;
          v45 = 30;
LABEL_74:
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v43, buf, v45);
        }
      }
LABEL_75:
      if (mDNSAddrIsDNSMulticast(a6))
        goto LABEL_76;
      v19 = v107;
      if (!*(_DWORD *)(v14 + 3720))
      {
        v80 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
            goto LABEL_80;
        }
        else
        {
          v80 = mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_80;
        }
        v83 = bswap32(*a2);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)v111 = HIWORD(v83);
        *(_WORD *)&v111[4] = 2048;
        *(_QWORD *)&v111[6] = v14;
        *(_WORD *)&v111[14] = 2082;
        *(_QWORD *)&v111[16] = v107;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "[Q%u] IPV6_BOUND_IF socket option not set -- info %p (%{public}s) scope_id is zero", buf, 0x1Cu);
LABEL_80:
        if (v28 < 0)
          return 4294901747;
        if (a8)
        {
          *(_DWORD *)buf = 100;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }
        v55 = sendto(v28, a2, a3 - (_QWORD)a2, 0, v134, v134[0].sa_len);
        v56 = 0;
        if (v55 < 0)
          v56 = *__error();
        if (a8)
        {
          *(_DWORD *)buf = 900;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }
        if ((v55 & 0x8000000000000000) == 0)
          return 0;
        v108 = v19;
        v57 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR);
          if (!v58)
            goto LABEL_97;
          v70 = bswap32(*a2) >> 16;
          v71 = *a6;
          v72 = strerror(v56);
          v73 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)v111 = v70;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(_QWORD *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(_QWORD *)&v111[22] = v108;
          v112 = 1024;
          v113 = v71;
          v114 = 2160;
          *(_QWORD *)v115 = 1752392040;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          v116 = 2101;
          v117 = a6;
          v118 = 1024;
          v119 = bswap32(a7) >> 16;
          v120 = 1024;
          v121 = v28;
          v122 = 2048;
          v123 = v55;
          v124 = 1024;
          v125 = v56;
          v126 = 2082;
          v127 = v72;
          v128 = 1024;
          v129 = v73;
        }
        else
        {
          v57 = mDNSLogCategory_NAT_redacted;
          v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR);
          if (!v58)
            goto LABEL_97;
          v66 = bswap32(*a2) >> 16;
          v67 = *a6;
          v68 = strerror(v56);
          v69 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)v111 = v66;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(_QWORD *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(_QWORD *)&v111[22] = v108;
          v112 = 1024;
          v113 = v67;
          v114 = 2160;
          *(_QWORD *)v115 = 1752392040;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          v116 = 2101;
          v117 = a6;
          v118 = 1024;
          v119 = bswap32(a7) >> 16;
          v120 = 1024;
          v121 = v28;
          v122 = 2048;
          v123 = v55;
          v124 = 1024;
          v125 = v56;
          v126 = 2082;
          v127 = v68;
          v128 = 1024;
          v129 = v69;
        }
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "[Q%u] mDNSPlatformSendUDP -> sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u", buf, 0x6Eu);
LABEL_97:
        v74 = *a6;
        if (*a6 == 6)
        {
          if (a6[1] != 767 || a6[2] || a6[3])
            goto LABEL_109;
          v75 = a6[4];
          v76 = -83886080;
        }
        else
        {
          if (v74 != 4)
            goto LABEL_109;
          v75 = a6[1];
          v76 = -83885856;
        }
        if (v75 == v76)
        {
          if (v56 != 49)
          {
            if (v56 != 50)
            {
              if (v56 == 65)
              {
                if (mDNSPlatformRawTime(v58, v59, v60, v61, v62, v63, v64, v65) >= 0x2BF20)
                  goto LABEL_128;
                return 4294901734;
              }
LABEL_116:
              v77 = ++mDNSPlatformSendUDP_MessageCount;
              v78 = gSensitiveLoggingEnabled;
              v79 = mDNSLogCategory_Default;
              if (mDNSLogCategory_Default == mDNSLogCategory_State)
                v78 = 0;
              if (v77 > 49)
              {
                if ((v78 & 1) != 0)
                {
                  v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                    return 4294901759;
                }
                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                {
                  return 4294901759;
                }
                v95 = bswap32(*a2) >> 16;
                v96 = strerror(v56);
                v97 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)v111 = v95;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(_QWORD *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(_QWORD *)&v111[22] = v108;
                v112 = 1024;
                v113 = v74;
                v114 = 2160;
                *(_QWORD *)v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                v116 = 2101;
                v117 = a6;
                v118 = 1024;
                v119 = bswap32(a7) >> 16;
                v120 = 1024;
                v121 = v28;
                v122 = 2048;
                v123 = v55;
                v124 = 1024;
                v125 = v56;
                v126 = 2082;
                v127 = v96;
                v128 = 1024;
                v129 = v97;
                v130 = 1024;
                v131 = mDNSPlatformSendUDP_MessageCount;
                v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                v89 = v79;
                v90 = OS_LOG_TYPE_DEFAULT;
              }
              else
              {
                if ((v78 & 1) != 0)
                {
                  v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                    return 4294901759;
                }
                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                {
                  return 4294901759;
                }
                v92 = bswap32(*a2) >> 16;
                v93 = strerror(v56);
                v94 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)v111 = v92;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(_QWORD *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(_QWORD *)&v111[22] = v108;
                v112 = 1024;
                v113 = v74;
                v114 = 2160;
                *(_QWORD *)v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                v116 = 2101;
                v117 = a6;
                v118 = 1024;
                v119 = bswap32(a7) >> 16;
                v120 = 1024;
                v121 = v28;
                v122 = 2048;
                v123 = v55;
                v124 = 1024;
                v125 = v56;
                v126 = 2082;
                v127 = v93;
                v128 = 1024;
                v129 = v94;
                v130 = 1024;
                v131 = mDNSPlatformSendUDP_MessageCount;
                v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                v89 = v79;
                v90 = OS_LOG_TYPE_ERROR;
              }
              v91 = 116;
              goto LABEL_144;
            }
LABEL_128:
            v81 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
              {
LABEL_138:
                v84 = bswap32(*a2) >> 16;
                v85 = *a6;
                v86 = strerror(v56);
                v87 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112451;
                *(_DWORD *)v111 = v84;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(_QWORD *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(_QWORD *)&v111[22] = v82;
                v112 = 1024;
                v113 = v85;
                v114 = 2160;
                *(_QWORD *)v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                v116 = 2101;
                v117 = a6;
                v118 = 1024;
                v119 = bswap32(a7) >> 16;
                v120 = 1024;
                v121 = v28;
                v122 = 2048;
                v123 = v55;
                v124 = 1024;
                v125 = v56;
                v126 = 2082;
                v127 = v86;
                v128 = 1024;
                v129 = v87;
                v88 = "[Q%u] mDNSPlatformSendUDP sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{se"
                      "nsitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u";
                v89 = v81;
                v90 = OS_LOG_TYPE_ERROR;
                v91 = 110;
LABEL_144:
                _os_log_impl((void *)&_mh_execute_header, v89, v90, v88, buf, v91);
              }
            }
            else
            {
              v81 = mDNSLogCategory_NAT_redacted;
              v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
                goto LABEL_138;
            }
            return 4294901759;
          }
LABEL_126:
          if (*((_DWORD *)v109 + 2))
            return 4294901734;
          goto LABEL_128;
        }
LABEL_109:
        if (v56 > 50)
        {
          v16 = 4294901510;
          switch(v56)
          {
            case '3':
              return v16;
            case '@':
              return 4294901734;
            case 'A':
              return v16;
          }
          goto LABEL_116;
        }
        if (v56 != 49)
        {
          if (v56 == 50)
            return 4294901734;
          goto LABEL_116;
        }
        goto LABEL_126;
      }
      v38 = (uint8_t *)(v14 + 3720);
      v39 = v28;
      v40 = 41;
      v41 = 125;
LABEL_79:
      setsockopt(v39, v40, v41, v38, 4u);
      goto LABEL_80;
    }
    if ((v36 & 1) != 0)
    {
      v42 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_75;
    }
    else
    {
      v42 = mDNSLogCategory_NAT;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
        goto LABEL_75;
    }
    v53 = bswap32(*a2);
    v54 = *v32;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v111 = HIWORD(v53);
    *(_WORD *)&v111[4] = 1024;
    *(_DWORD *)&v111[6] = v54;
    v43 = "[Q%u] setsockopt - IPV6_MUTLICAST_IF scopeid %d, not a valid interface";
    v44 = v42;
    v45 = 14;
    goto LABEL_74;
  }
  if (*a6 == 4)
  {
    *(_WORD *)&v134[0].sa_len = 528;
    *(_WORD *)v134[0].sa_data = a7;
    *(_DWORD *)&v134[0].sa_data[2] = a6[1];
    v109 = a1;
    if (a5)
      v20 = (int *)(a5 + 16);
    else
      v20 = (int *)(*a1 + 24);
    v28 = *v20;
    if (mDNSAddrIsDNSMulticast(a6))
    {
      if (v14 && setsockopt(v28, 0, 66, (const void *)(v14 + 3720), 4u) < 0)
      {
        v107 = v19;
        if (*__error() != 42)
        {
          v29 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
            {
LABEL_65:
              __errnuma = bswap32(*a2) >> 16;
              v46 = *__error();
              v47 = __error();
              v48 = strerror(*v47);
              *(_DWORD *)buf = 67109634;
              *(_DWORD *)v111 = __errnuma;
              *(_WORD *)&v111[4] = 1024;
              *(_DWORD *)&v111[6] = v46;
              *(_WORD *)&v111[10] = 2082;
              *(_QWORD *)&v111[12] = v48;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "[Q%u] mDNSPlatformSendUDP: setsockopt: IP_MUTLTICAST_IFINDEX returned %d (%{public}s)", buf, 0x18u);
            }
          }
          else
          {
            v29 = mDNSLogCategory_NAT_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_65;
          }
        }
        v49 = v14 + 3716;
        v50 = setsockopt(v28, 0, 9, (const void *)(v14 + 3716), 4u);
        if ((v50 & 0x80000000) == 0 || *((_DWORD *)v109 + 2))
          goto LABEL_76;
        v51 = v50;
        v52 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
          {
LABEL_149:
            __errnumb = v52;
            v99 = bswap32(*a2) >> 16;
            v103 = *__error();
            v100 = __error();
            v101 = strerror(*v100);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)v111 = v99;
            *(_WORD *)&v111[4] = 2160;
            *(_QWORD *)&v111[6] = 1752392040;
            *(_WORD *)&v111[14] = 1045;
            *(_DWORD *)&v111[16] = 4;
            *(_WORD *)&v111[20] = 2101;
            *(_QWORD *)&v111[22] = v49;
            v112 = 1024;
            v113 = v51;
            v114 = 1024;
            *(_DWORD *)v115 = v103;
            *(_WORD *)&v115[4] = 2082;
            *(_QWORD *)&v115[6] = v101;
            _os_log_impl((void *)&_mh_execute_header, __errnumb, OS_LOG_TYPE_ERROR, "[Q%u] setsockopt - IP_MULTICAST_IF error %{sensitive, mask.hash, network:in_addr}.4P %d errno %d (%{public}s)", buf, 0x38u);
          }
        }
        else
        {
          v52 = mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
LABEL_76:
        v19 = v107;
        goto LABEL_80;
      }
      goto LABEL_80;
    }
    if (v14)
      v31 = *(_DWORD *)(v14 + 3720);
    else
      v31 = 0;
    *(_DWORD *)buf = v31;
    v38 = buf;
    v39 = v28;
    v40 = 0;
    v41 = 25;
    goto LABEL_79;
  }
  v26 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    v16 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_FAULT))
    {
LABEL_31:
      v27 = bswap32(*a2) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v111 = v27;
      v18 = "[Q%u] mDNSPlatformSendUDP: dst is not an IPv4 or IPv6 address!";
      v22 = v26;
      v23 = OS_LOG_TYPE_FAULT;
      v24 = 8;
      goto LABEL_32;
    }
  }
  else
  {
    v16 = 4294901756;
    v26 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_FAULT))
      goto LABEL_31;
  }
  return v16;
}

BOOL mDNSAddrIsDNSMulticast(_DWORD *a1)
{
  _DWORD *v1;
  int v2;

  if (*a1 == 6)
  {
    if (a1[1] == 767 && !a1[2] && !a1[3])
    {
      v2 = -83886080;
      v1 = a1 + 4;
      return *v1 == v2;
    }
  }
  else if (*a1 == 4)
  {
    v1 = a1 + 1;
    v2 = -83885856;
    return *v1 == v2;
  }
  return 0;
}

void myKQSocketCallBack(int a1, int a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  ssize_t v24;
  uint64_t msg_controllen;
  unsigned int *msg_control;
  unsigned int v27;
  unsigned int v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  int v37;
  uint64_t v38;
  _DWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  int *v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t *v46;
  unsigned int v47;
  uint64_t v48;
  char *v49;
  unsigned int v50;
  NSObject *v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  int *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  NSObject *v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  NSObject *v79;
  int *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  unsigned int v87;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  _QWORD **v101;
  int v102[6];
  _BYTE v103[20];
  int v104;
  msghdr v105;
  socklen_t v106[2];
  uint64_t v107;
  char __s2[8];
  uint64_t v109;
  timeval v110[8];
  fd_set v111;

  v8 = a4;
  v101 = (_QWORD **)*((_QWORD *)a3 + 1);
  v104 = 0;
  if (a2 != -1)
  {
    v96 = 0xFFFFFFFFLL;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: Why is filter %d not EVFILT_READ (%d)?", a4, a5, a6, a7, a8, a2);
  }
  if (*((_DWORD *)a3 + 4) != a1 && *((_DWORD *)a3 + 12) != a1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: native socket %d", a4, a5, a6, a7, a8, a1);
    v96 = *((unsigned int *)a3 + 12);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: sktv4 %d sktv6 %d", v11, v12, v13, v14, v15, *((_DWORD *)a3 + 4));
  }
  if (!v8)
  {
    v17 = 0;
    v18 = (unsigned __int8 *)(v101 + 2501);
    v100 = a1;
    while (1)
    {
      memset(v103, 0, sizeof(v103));
      memset(v102, 0, 20);
      memset(v110, 0, sizeof(v110));
      *(_QWORD *)__s2 = 0;
      v109 = 0;
      *(_QWORD *)v106 = v18;
      v107 = 8952;
      memset(&v105.msg_namelen, 0, 24);
      bzero(&v111, 0x400uLL);
      v105.msg_name = v110;
      v105.msg_namelen = 128;
      v105.msg_iov = (iovec *)v106;
      v105.msg_iovlen = 1;
      v105.msg_control = &v111;
      *(_QWORD *)&v105.msg_controllen = 1024;
      v24 = recvmsg(a1, &v105, 0);
      if (v24 < 0)
      {
        if (*__error() == 35)
          goto LABEL_99;
        v47 = myrecvfrom_numLogMessages++;
        if (v47 > 0x63)
          goto LABEL_99;
        v48 = mDNSLogCategory_Default;
        v96 = v24;
        v97 = *__error();
        v95 = a1;
        v49 = "mDNSMacOSX.c: recvmsg(%d) returned error %d errno %d";
LABEL_95:
        v51 = v48;
        goto LABEL_98;
      }
      msg_controllen = v105.msg_controllen;
      if (v105.msg_controllen <= 0xB)
      {
        v50 = myrecvfrom_numLogMessages++;
        if (v50 > 0x63)
          goto LABEL_99;
        v48 = mDNSLogCategory_Default;
        v99 = *__error();
        v97 = msg_controllen;
        v98 = 12;
        v95 = a1;
        v96 = v24;
        v49 = "mDNSMacOSX.c: recvmsg(%d) returned %d msg.msg_controllen %d < sizeof(struct cmsghdr) %lu, errno %d";
        goto LABEL_95;
      }
      if ((v105.msg_flags & 0x20) != 0)
      {
        v52 = myrecvfrom_numLogMessages++;
        if (v52 <= 0x63)
        {
          v51 = mDNSLogCategory_Default;
          v95 = a1;
          v49 = "mDNSMacOSX.c: recvmsg(%d) msg.msg_flags & MSG_CTRUNC";
LABEL_98:
          LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, v49, v19, v20, v21, v22, v23, v95);
        }
LABEL_99:
        v58 = *__error();
        if (v58 == 57)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: ENOTCONN, closing socket", v53, v54, v55, v56, v57, v94);
          close(a1);
        }
        else if (v58 != 35 || !v17)
        {
          LODWORD(v105.msg_name) = -1;
          *(_DWORD *)v103 = -1;
          v102[0] = -1;
          *(_QWORD *)&v110[0].tv_usec = 0;
          memset(&v111, 0, sizeof(v111));
          if (__darwin_check_fd_set_overflow(a1, &v111, 0))
            *(__int32_t *)((char *)v111.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
          v110[0].tv_sec = 0;
          select(a1 + 1, &v111, 0, 0, v110);
          v106[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4103, &v105, v106) == -1)
          {
            v59 = mDNSLogCategory_Default;
            v60 = __error();
            LogMsgWithLevel(v59, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack getsockopt(SO_ERROR) error %d", v61, v62, v63, v64, v65, *v60);
          }
          v106[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4128, v103, v106) == -1)
          {
            v66 = mDNSLogCategory_Default;
            v67 = __error();
            LogMsgWithLevel(v66, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack getsockopt(SO_NREAD) error %d", v68, v69, v70, v71, v72, *v67);
          }
          if (ioctl(a1, 0x4004667FuLL, v102, v96, v97, v98, v99) == -1)
          {
            v79 = mDNSLogCategory_Default;
            v80 = __error();
            LogMsgWithLevel(v79, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack ioctl(FIONREAD) error %d", v81, v82, v83, v84, v85, *v80);
          }
          v86 = myKQSocketCallBack_numLogMessages;
          v87 = ++myKQSocketCallBack_numLogMessages;
          if (v86 <= 0x63)
          {
            v88 = mDNSLogCategory_Default;
            strerror(v58);
            __darwin_check_fd_set_overflow(a1, &v111, 0);
            LogMsgWithLevel(v88, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack recvfrom skt %d error %d errno %d (%s) select %d (%spackets waiting) so_error %d so_nread %d fionread %d count %d", v89, v90, v91, v92, v93, a1);
            v87 = myKQSocketCallBack_numLogMessages;
          }
          if (v87 >= 6)
            NotifyOfElusiveBug((int)"Flaw in Kernel (select/recvfrom mismatch)", (int)"Congratulations, you've reproduced an elusive bug.\rPlease send email to radar-3387020@group.apple.com.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.", v73, v74, v75, v76, v77, v78);
          sleep(1u);
        }
        return;
      }
      msg_control = (unsigned int *)v105.msg_control;
      if (v105.msg_control)
      {
        do
        {
          v27 = msg_control[1];
          if (v27)
          {
LABEL_15:
            if (v27 == 41 && msg_control[2] == 46)
            {
              v102[0] = 6;
              *(_OWORD *)&v102[1] = *(_OWORD *)(msg_control + 3);
              v28 = msg_control[7];
              v29 = (_QWORD *)myGetIfAddrs_ifa;
              if (myGetIfAddrs_ifa
                || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa), (v29 = (_QWORD *)myGetIfAddrs_ifa) != 0))
              {
                while (1)
                {
                  v30 = v29[3];
                  if (v30)
                  {
                    if (*(_BYTE *)(v30 + 1) == 18 && *(unsigned __int16 *)(v30 + 2) == (unsigned __int16)v28)
                      break;
                  }
                  v29 = (_QWORD *)*v29;
                  if (!v29)
                    goto LABEL_36;
                }
                v33 = v29[1];
                if (!v33)
                  __break(1u);
                v34 = 0;
                while (1)
                {
                  v35 = *(unsigned __int8 *)(v33 + v34);
                  __s2[v34] = v35;
                  if (!v35)
                    break;
                  if (++v34 == 15)
                  {
                    HIBYTE(v109) = 0;
                    goto LABEL_36;
                  }
                }
              }
            }
            goto LABEL_36;
          }
          v31 = msg_control[2];
          if (v31 == 20)
          {
            v32 = *((unsigned __int8 *)msg_control + 17);
            if (v32 > 0xF)
              goto LABEL_36;
            __memcpy_chk(__s2, msg_control + 5, v32, 16);
            __s2[*((unsigned __int8 *)msg_control + 17)] = 0;
          }
          else
          {
            if (v31 != 7)
              goto LABEL_36;
            v102[0] = 4;
            v102[1] = msg_control[3];
          }
          v27 = msg_control[1];
          if (v27)
            goto LABEL_15;
LABEL_36:
          msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
          if (msg_control)
            v36 = (char *)(msg_control + 3) > (char *)v105.msg_control + v105.msg_controllen;
          else
            v36 = 1;
        }
        while (!v36);
      }
      v37 = v102[0];
      if (v102[0] == 4)
      {
        if ((v102[1] & 0xF0) == 0xE0)
          goto LABEL_46;
      }
      else if (v102[0] == 6 && LOBYTE(v102[1]) == 255)
      {
LABEL_46:
        ++*((_DWORD *)*v101 + 26);
      }
      if (BYTE1(v110[0].tv_sec) == 30)
      {
        *(_DWORD *)v103 = 6;
        *(timeval *)&v103[4] = *(timeval *)&v110[0].tv_usec;
      }
      else
      {
        if (BYTE1(v110[0].tv_sec) != 2)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack from is unknown address family %d", v19, v20, v21, v22, v23, BYTE1(v110[0].tv_sec));
          return;
        }
        *(_DWORD *)v103 = 4;
        *(_DWORD *)&v103[4] = HIDWORD(v110[0].tv_sec);
      }
      v38 = WORD1(v110[0].tv_sec);
      v39 = *v101;
      v40 = **v101;
      if (v40)
      {
        while (!*(_BYTE *)(v40 + 3696) || strcmp((const char *)(v40 + 3606), __s2))
        {
          v40 = *(_QWORD *)(v40 + 3680);
          if (!v40)
            goto LABEL_55;
        }
        v45 = *(_QWORD *)(v40 + 3552);
        v18 = (unsigned __int8 *)(v101 + 2501);
        if (v45)
          goto LABEL_79;
      }
      else
      {
LABEL_55:
        if (v37 == 4)
        {
          v43 = -83885856;
          v42 = &v102[1];
          v18 = (unsigned __int8 *)(v101 + 2501);
        }
        else
        {
          v41 = &mDNSInterface_Any;
          v18 = (unsigned __int8 *)(v101 + 2501);
          if (v37 != 6)
            goto LABEL_78;
          if (*(_QWORD *)&v102[1] != 767 || (v42 = &v102[4], v43 = -83886080, v102[3]))
          {
LABEL_72:
            v46 = (uint64_t *)xmmword_10015BF38;
            if ((_QWORD)xmmword_10015BF38)
            {
              while (*((_DWORD *)v46 + 890) != 6
                   || !*((_BYTE *)v46 + 3671)
                   || *(_OWORD *)((char *)v46 + 3564) != *(_OWORD *)&v102[1])
              {
                v46 = (uint64_t *)*v46;
                if (!v46)
                  goto LABEL_77;
              }
LABEL_86:
              v41 = v46 + 444;
              goto LABEL_78;
            }
            goto LABEL_77;
          }
        }
        if (*v42 == v43)
        {
          v44 = v104;
          a1 = v100;
          goto LABEL_84;
        }
      }
      if (v37 == 6)
        goto LABEL_72;
      v41 = &mDNSInterface_Any;
      if (v37 == 4)
      {
        v46 = (uint64_t *)xmmword_10015BF38;
        if ((_QWORD)xmmword_10015BF38)
        {
          while (*((_DWORD *)v46 + 890) != 4 || !*((_BYTE *)v46 + 3671) || *((_DWORD *)v46 + 891) != v102[1])
          {
            v46 = (uint64_t *)*v46;
            if (!v46)
              goto LABEL_77;
          }
          goto LABEL_86;
        }
LABEL_77:
        v41 = &mDNSInterface_Any;
      }
LABEL_78:
      v45 = *v41;
LABEL_79:
      *((_QWORD *)a3 + 10) = &v104;
      if (*((_BYTE *)a3 + 88))
      {
        v94 = 0;
        (*((void (**)(_DWORD *, unsigned __int8 *, unsigned __int8 *, _BYTE *, uint64_t, int *, _QWORD, uint64_t))v39
         + 122))(v39 + 176, v18, &v18[v24], v103, v38, v102, *a3, v45);
      }
      else
      {
        mDNSCoreReceive((uint64_t)v101, v18, (unint64_t)&v18[v24], (int *)v103, v38, v102, *a3, v45);
      }
      v44 = v104;
      a1 = v100;
      if (v104)
        return;
      *((_QWORD *)a3 + 10) = 0;
LABEL_84:
      ++v17;
      if (v44)
        return;
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: socket %d is no longer readable (EOF)", a4, a5, a6, a7, a8, a1);
  if (*((_DWORD *)a3 + 4) == a1)
  {
    *((_BYTE *)a3 + 89) = 1;
    v16 = a3 + 12;
LABEL_89:
    KQueueSet(a1, 2u, -1, v16);
    return;
  }
  if (*((_DWORD *)a3 + 12) == a1)
  {
    *((_BYTE *)a3 + 90) = 1;
    v16 = a3 + 28;
    goto LABEL_89;
  }
}

void mDNSCoreReceive(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int *a4, unsigned __int16 a5, int *a6, unsigned __int16 a7, uint64_t a8)
{
  __int128 *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  unsigned __int8 v38;
  uint64_t v39;
  const char *v40;
  _WORD *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  NSObject *v58;
  char *v59;
  const char *v60;
  unsigned __int8 *v62;
  unsigned __int8 *v63;
  int v64;
  int v65;
  uint64_t v66;
  unsigned __int8 *v67;
  void *v68;
  _QWORD *v69;
  void *v70;
  NSObject *v71;
  char *v72;
  uint64_t v73;
  int v75;
  int IsLocalSubnet;
  const char *v77;
  signed __int8 v78;
  unsigned int v79;
  unsigned int v80;
  _QWORD *i;
  unsigned int v82;
  unsigned int v83;
  int v84;
  int v85;
  uint64_t v86;
  int v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  int v99;
  unsigned int v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  unsigned int v109;
  unsigned int v110;
  uint32_t v111;
  const char *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  int v124;
  unsigned int v125;
  unsigned int v126;
  int v127;
  int v128;
  uint64_t j;
  void *v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  BOOL v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  _OWORD v140[8];

  if (a6 == (int *)1)
    v15 = 0;
  else
    v15 = (__int128 *)a6;
  v16 = a1 + 12696;
  if (mDNSSameAddress(a4, (_DWORD *)(a1 + 12696)))
  {
    v22 = (_WORD *)(a1 + 14776);
    if (a5 == 27655 || (v23 = *(unsigned __int16 **)(a1 + 15024)) != 0 && *v23 == a7)
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13729);
      if (*(_WORD *)(a1 + 15034) || !a2 || (_WORD)a3 == (_WORD)a2)
        goto LABEL_9;
      v39 = 0;
      v40 = (const char *)&a2[(unsigned __int16)(a3 - (_WORD)a2)];
      v41 = (_WORD *)(a1 + 15034);
      v42 = (unsigned __int16)(a3 - (_WORD)a2) - 1;
      while ((a2[v39] & 0xDF) != 0x57 || strncasecmp((const char *)&a2[v39], "WANIPConnection:1", 0x11uLL))
      {
        v43 = v39 + 1;
        if (&a2[v39] != (unsigned __int8 *)-1)
        {
          v134 = v42 == v39++;
          if (!v134)
            continue;
        }
        v44 = &a2[v43];
        goto LABEL_46;
      }
      v44 = &a2[v39];
LABEL_46:
      if (v44 == (unsigned __int8 *)v40)
        v60 = (const char *)a2;
      else
        v60 = (const char *)v44;
      if (v44 == (unsigned __int8 *)v40)
      {
        v73 = (unsigned __int16)(a3 - (_WORD)a2) - 1;
        v60 = (const char *)a2;
        do
        {
          if ((*v60 & 0xDF) == 0x57 && !strncasecmp(v60, "WANPPPConnection:1", 0x12uLL))
            break;
          if (!++v60)
            break;
        }
        while (v73--);
      }
      if (!v60 || v60 == v40)
        goto LABEL_9;
      do
      {
        if ((*a2 & 0xDF) == 0x4C && !strncasecmp((const char *)a2, "Location:", 9uLL))
          break;
        if (!++a2)
          break;
      }
      while (v42--);
      if (!a2 || a2 == (unsigned __int8 *)v40)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v71 = mDNSLogCategory_Default;
          v72 = "LNT_ConfigureRouterInfo: Location field not found";
          goto LABEL_84;
        }
LABEL_9:
        mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13731);
        return;
      }
      v62 = a2 + 9;
      do
      {
        v63 = v62;
        v65 = *v62++;
        v64 = v65;
      }
      while (v63 < (unsigned __int8 *)v40 && v64 == 32);
      if (v63 >= (unsigned __int8 *)v40)
        goto LABEL_9;
      v66 = (uint64_t)(v62 - 1);
      v67 = v62 - 1;
      while (*v67 != 13)
      {
        if (++v67 == (unsigned __int8 *)v40)
        {
          v67 = (unsigned __int8 *)v40;
          break;
        }
      }
      *v41 = 20480;
      v68 = *(void **)(a1 + 15064);
      if (v68)
      {
        free(v68);
        *(_QWORD *)(a1 + 15064) = 0;
      }
      v69 = (_QWORD *)(a1 + 15040);
      v70 = *(void **)(a1 + 15040);
      if (v70)
      {
        free(v70);
        *v69 = 0;
      }
      if (ParseHttpUrl(v66, (unint64_t)v67, (_QWORD *)(a1 + 15064), (_WORD *)(a1 + 15034), (_QWORD *)(a1 + 15040)))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v71 = mDNSLogCategory_Default;
          v72 = "LNT_ConfigureRouterInfo: Failed to parse URL";
LABEL_84:
          LogMsgWithLevel(v71, OS_LOG_TYPE_DEFAULT, v72, v24, v25, v26, v27, v28, v136);
          goto LABEL_9;
        }
        goto LABEL_9;
      }
      *(_QWORD *)(a1 + 15016) = a8;
      if (*(_QWORD *)(a1 + 15064))
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router address string [%s]", v24, v25, v26, v27, v28, *(_QWORD *)(a1 + 15064));
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: UPnPRouterAddressString is NULL", v24, v25, v26, v27, v28, v136);
      }
      if (*v69)
      {
        if (mDNS_LoggingEnabled != 1)
        {
LABEL_184:
          v123 = *(void **)(a1 + 15024);
          if (v123)
          {
            CloseSocketSet(*(_QWORD *)(a1 + 15024));
            free(v123);
            *(_QWORD *)(a1 + 15024) = 0;
          }
          GetDeviceDescription(a1, a1 + 14896);
          goto LABEL_9;
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router URL [%s]", v24, v25, v26, v27, v28, *v69);
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: UPnPRouterURL is NULL", v24, v25, v26, v27, v28, v136);
      }
      if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router port %d", v113, v114, v115, v116, v117, bswap32((unsigned __int16)*v41) >> 16);
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router interface %d", v118, v119, v120, v121, v122, *(_QWORD *)(a1 + 15016));
      }
      goto LABEL_184;
    }
    if (a5 == 59156)
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13737);
      v35 = (unsigned __int16)(a3 - (_WORD)a2);
      if ((_WORD)a3 == (_WORD)a2)
      {
        v58 = mDNSLogCategory_Default;
        v59 = "uDNS_ReceiveNATPacket: zero length packet";
      }
      else
      {
        if (*a2)
        {
          if (*a2 != 2)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPacket: packet with version %u (expected %u or %u)", v30, v31, v32, v33, v34, *a2);
            goto LABEL_195;
          }
          v36 = (unsigned __int16)(a3 - (_WORD)a2);
          if (v35 <= 0x17)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: message too short (%d bytes)", v30, v31, v32, v33, v34, v36);
            goto LABEL_195;
          }
          v78 = a2[1];
          if ((v78 & 0x80000000) == 0 || (v79 = v78 & 0x7F, v79 >= 2))
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: unhandled opCode %u", v30, v31, v32, v33, v34, a2[1]);
            goto LABEL_195;
          }
          v99 = *(_DWORD *)(a1 + 14768);
          v100 = bswap32(*((_DWORD *)a2 + 2));
          *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)a2 + 1));
          *((_DWORD *)a2 + 2) = v100;
          v101 = *(_DWORD *)(a1 + 64);
          v137 = *(_DWORD *)(a1 + 14772);
          v138 = v99;
          if (v100 <= 1)
            v102 = 1;
          else
            v102 = v100;
          *(_DWORD *)(a1 + 14768) = v102;
          *(_DWORD *)(a1 + 14772) = v101;
          LNT_ClearState(a1);
          v108 = *(void **)(a1 + 15024);
          if (v108)
          {
            CloseSocketSet(*(_QWORD *)(a1 + 15024));
            free(v108);
            *(_QWORD *)(a1 + 15024) = 0;
          }
          if (v138)
          {
            v109 = (v101 - v137) / 1000;
            v110 = v100 - v138;
            if (v109 + 2 < v110 - (v110 >> 4) || v110 + 2 < v109 - (v109 >> 4))
            {
              if (v79)
              {
                v111 = 0;
              }
              else
              {
                do
                  v111 = arc4random() & 0x1FFF;
                while (v111 > 0x1388);
              }
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: Epoch invalid, %#a likely rebooted, waiting %u ticks", v103, v104, v105, v106, v107, v16);
              RecreateNATMappings(a1, v111);
              goto LABEL_195;
            }
          }
          if (!v79)
          {
LABEL_195:
            mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13739);
            return;
          }
          v124 = a2[3];
          *v22 = v124;
          if (v124)
          {
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: error received from server. opcode %X result %X lifetime %X epoch %X", v103, v104, v105, v106, v107, a2[1]);
            v125 = 0;
            if (v35 < 0x3C)
            {
              v127 = 0;
              v128 = 0;
              v126 = 0;
            }
            else
            {
              v126 = 0;
              v127 = a2[36];
              v128 = *((unsigned __int16 *)a2 + 20);
            }
            goto LABEL_210;
          }
          if (v35 <= 0x3B)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: mapping response too short (%d bytes)", v103, v104, v105, v106, v107, v36);
            goto LABEL_195;
          }
          if (*((_QWORD *)a2 + 3) != *(_QWORD *)(a1 + 14748) || *((_DWORD *)a2 + 8) != *(_DWORD *)(a1 + 14756))
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: invalid nonce, ignoring. received { %x %x %x } expected { %x %x %x }", v103, v104, v105, v106, v107, *((_DWORD *)a2 + 6));
            goto LABEL_195;
          }
          v127 = a2[36];
          v128 = *((unsigned __int16 *)a2 + 20);
          v126 = *((unsigned __int16 *)a2 + 21);
          if (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 12) || *((_WORD *)a2 + 26) || *((__int16 *)a2 + 27) != -1)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: unexpected external address: %.16a", v103, v104, v105, v106, v107, (_DWORD)a2 + 44);
            v125 = 0;
          }
          else
          {
            v125 = *((_DWORD *)a2 + 14);
            if (v125)
            {
LABEL_210:
              v131 = *(_QWORD *)(a1 + 14720);
              if (v131)
              {
                v132 = v125;
                do
                {
                  if ((*(_BYTE *)(v131 + 172) & 2) != 0)
                    v133 = 6;
                  else
                    v133 = 17;
                  if (v133 == v127 && *(unsigned __int16 *)(v131 + 174) == v128
                    || (!*(_BYTE *)(v131 + 172) ? (v134 = v127 == 6) : (v134 = 0), v134 && v128 == 2304))
                  {
                    if (a2[3])
                      v135 = 3;
                    else
                      v135 = 0;
                    natTraversalHandlePortMapReplyWithAddress(a1, v131, a8, v135, v132, v126, *((unsigned int *)a2 + 1), 3);
                  }
                  v131 = *(_QWORD *)v131;
                }
                while (v131);
              }
              goto LABEL_195;
            }
          }
          a2[3] = 3;
          goto LABEL_210;
        }
        v75 = (unsigned __int16)(a3 - (_WORD)a2);
        if (v35 <= 3)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP message too short (%d bytes)", v30, v31, v32, v33, v34, (unsigned __int16)(a3 - (_WORD)a2));
          goto LABEL_195;
        }
        v80 = __rev16(*((unsigned __int16 *)a2 + 1));
        *((_WORD *)a2 + 1) = v80;
        if (v80 == 1)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP version unsupported message received", v30, v31, v32, v33, v34, v136);
          for (i = *(_QWORD **)(a1 + 14720); i; i = (_QWORD *)*i)
            uDNS_SendNATMsg(a1, (uint64_t)i, 0, 0);
          *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
          goto LABEL_195;
        }
        if (v35 <= 7)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP message too short (%d bytes) 0x%X 0x%X", v30, v31, v32, v33, v34, (unsigned __int16)(a3 - (_WORD)a2));
          goto LABEL_195;
        }
        v82 = bswap32(*((_DWORD *)a2 + 1));
        *((_DWORD *)a2 + 1) = v82;
        v83 = *(_DWORD *)(a1 + 14768);
        v84 = v82 - v83;
        if (v82 < v83
          || (v85 = *(_DWORD *)(a1 + 64),
              v86 = 274877907 * (v85 - *(_DWORD *)(a1 + 14772)),
              LODWORD(v86) = (v86 >> 38) + ((unint64_t)v86 >> 63),
              v84 + 2 < v86 - (v86 >> 3)))
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP epoch time check failed: assuming NAT gateway %#a rebooted", v30, v31, v32, v33, v34, v16);
          RecreateNATMappings(a1, 0);
          v82 = *((_DWORD *)a2 + 1);
          v85 = *(_DWORD *)(a1 + 64);
        }
        *(_DWORD *)(a1 + 14768) = v82;
        *(_DWORD *)(a1 + 14772) = v85;
        LNT_ClearState(a1);
        v87 = a2[1];
        if ((v87 - 129) < 2)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v88 = "failure";
            if (!*((_WORD *)a2 + 1))
              v88 = "success";
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPMPPacket: PortMapRequest %s %s - error %d", v30, v31, v32, v33, v34, (int)v88);
          }
          v89 = *((_WORD *)a2 + 1);
          if (!v89)
          {
            if (v35 <= 0xF)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP PortMapReply message too short (%d bytes)", v30, v31, v32, v33, v34, v75);
              goto LABEL_195;
            }
            *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)a2 + 3));
          }
          *v22 = v89;
          for (j = *(_QWORD *)(a1 + 14720); j; j = *(_QWORD *)j)
          {
            if (*(_BYTE *)(j + 172) == (v87 & 0x7F) && *(unsigned __int16 *)(j + 174) == *((unsigned __int16 *)a2 + 4))
              natTraversalHandlePortMapReplyWithAddress(a1, j, a8, *((unsigned __int16 *)a2 + 1), *(unsigned int *)(a1 + 14744), *((unsigned __int16 *)a2 + 5), *((unsigned int *)a2 + 3), 1);
          }
LABEL_205:
          v130 = *(void **)(a1 + 15024);
          if (v130)
          {
            CloseSocketSet(*(_QWORD *)(a1 + 15024));
            free(v130);
            *(_QWORD *)(a1 + 15024) = 0;
          }
          goto LABEL_195;
        }
        if (v87 == 128)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v112 = "failure";
            if (!*((_WORD *)a2 + 1))
              v112 = "success";
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPMPPacket: AddressRequest %s error %d", v30, v31, v32, v33, v34, (int)v112);
          }
          if (v35 <= 0xB && !*((_WORD *)a2 + 1))
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP AddrResponse message too short (%d bytes)", v30, v31, v32, v33, v34, v75);
            goto LABEL_195;
          }
          natTraversalHandleAddressReply(a1, *((unsigned __int16 *)a2 + 1), *((_DWORD *)a2 + 2), v30, v31, v32, v33, v34);
          goto LABEL_205;
        }
        v58 = mDNSLogCategory_Default;
        v136 = a2[1];
        v59 = "Received NAT-PMP response with unknown opcode 0x%X";
      }
      LogMsgWithLevel(v58, OS_LOG_TYPE_DEFAULT, v59, v30, v31, v32, v33, v34, v136);
      goto LABEL_195;
    }
  }
  else
  {
    v29 = *(unsigned __int16 **)(a1 + 15024);
    if (v29 && *v29 == a7)
      return;
  }
  v37 = a3 - (_DWORD)a2;
  if (((a3 - (unint64_t)a2) & 0xFFFFFFFC) <= 0xB)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS Message from %#a:%d to %#a:%d length %d too short", v17, v18, v19, v20, v21, (int)a4);
    return;
  }
  v38 = a2[2];
  *((_WORD *)a2 + 2) = bswap32(*((unsigned __int16 *)a2 + 2)) >> 16;
  *((_WORD *)a2 + 3) = bswap32(*((unsigned __int16 *)a2 + 3)) >> 16;
  *((_WORD *)a2 + 4) = bswap32(*((unsigned __int16 *)a2 + 4)) >> 16;
  *((_WORD *)a2 + 5) = bswap32(*((unsigned __int16 *)a2 + 5)) >> 16;
  if (*a4 == 6)
  {
    v45 = a4[1];
    v46 = a4[2];
    v47 = a4[3];
    v48 = a4[4];
    if (v46 | v45 | v47 | v48 && (v46 & v45 & v47 & v48) != 0xFFFFFFFF)
    {
LABEL_36:
      v49 = v38 & 0xF8;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13767);
      ++*(_DWORD *)(a1 + 132);
      if (*(_WORD *)a2
        || (++*(_DWORD *)(a1 + 136), IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, a4), !v15)
        || IsLocalSubnet)
      {
        if (!v15)
        {
          v77 = "TCP";
LABEL_128:
          v57 = a8;
          if (*(_WORD *)a2)
          {
            if ((mDNS_PacketLoggingEnabled & 1) != 0)
            {
              if (a6 == (int *)1)
                v90 = "TLS";
              else
                v90 = v77;
              v91 = a5;
              DumpPacket(0, 0, (uint64_t)v90, (__int128 *)a4, a5, v15, a7, a2, a3, a8);
            }
            else
            {
              v91 = a5;
            }
            uDNS_ReceiveMsg(a1, (unsigned __int16 *)a2, a3, a4, v91, v52, v53, v57);
            v57 = 0;
          }
LABEL_136:
          if (v49 > 127)
          {
            if (v49 == 128)
            {
              mDNSCoreReceiveResponse(a1, a2, a3, (__int128 *)a4, a5, v15, a7, 0, 0, v57);
              goto LABEL_156;
            }
            if (v49 == 168)
            {
              mDNSCoreReceiveUpdateR(a1, (unsigned __int16 *)a2, a3, (uint64_t)a4, a8);
              goto LABEL_156;
            }
          }
          else
          {
            if (!v49)
            {
              mDNSCoreReceiveQuery(a1, (unint64_t)a2, a3, a4, a5, v15, a7, v57);
              goto LABEL_156;
            }
            if (v49 == 40)
            {
              mDNSCoreReceiveUpdate(a1, (unint64_t)a2, a3, (uint64_t)a4, a5, v15, a7, a8);
LABEL_156:
              mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13828);
              return;
            }
          }
          if (mDNS_LoggingEnabled == 1 && mDNSCoreReceive_msgCount <= 999)
          {
            ++mDNSCoreReceive_msgCount;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Unknown DNS packet type %02X%02X from %#-15a:%-5d to %#-15a:%-5d length %d on %p (ignored)", v50, v51, v52, v53, v57, a2[2]);
            if (v37 >= 1)
            {
              v92 = 0;
              do
              {
                memset(v140, 0, sizeof(v140));
                v98 = (char *)v140 + mDNS_snprintf(v140);
                do
                {
                  if (v92 < v37)
                    v98 += mDNS_snprintf(v98);
                  ++v92;
                }
                while ((v92 & 0xF) != 0);
                if (mDNS_LoggingEnabled == 1)
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s", v93, v94, v95, v96, v97, (int)v140);
              }
              while (v92 < v37);
            }
          }
          goto LABEL_156;
        }
        v54 = *(_DWORD *)v15;
        goto LABEL_39;
      }
      v54 = *(_DWORD *)v15;
      if (*(_DWORD *)v15 == 6)
      {
        if (*((_DWORD *)v15 + 1) != 767)
          goto LABEL_126;
        if (*((_DWORD *)v15 + 2) || *((_DWORD *)v15 + 3) || *((_DWORD *)v15 + 4) != -83886080)
          goto LABEL_102;
      }
      else
      {
        if (v54 != 4)
        {
LABEL_39:
          if (v54 != 6)
          {
            if (v54 != 4)
              goto LABEL_126;
            v55 = *((_DWORD *)v15 + 1);
            v56 = -83885856;
            goto LABEL_42;
          }
          if (*((_DWORD *)v15 + 1) != 767)
            goto LABEL_126;
LABEL_102:
          if (*((_DWORD *)v15 + 2) || *((_DWORD *)v15 + 3))
            goto LABEL_126;
          v55 = *((_DWORD *)v15 + 4);
          v56 = -83886080;
LABEL_42:
          v57 = a8;
          if (v55 == v56)
            goto LABEL_136;
LABEL_126:
          v77 = "UDP";
          if (v49 != 168)
          {
            v57 = a8;
            if (v49 != 128)
              goto LABEL_136;
          }
          goto LABEL_128;
        }
        if (*((_DWORD *)v15 + 1) != -83885856)
          goto LABEL_126;
      }
      ++*(_DWORD *)(a1 + 176);
      goto LABEL_39;
    }
  }
  else if (*a4 == 4 && (a4[1] + 1) >= 2)
  {
    goto LABEL_36;
  }
}

void mDNSCoreReceiveQuery(uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9;
  _DWORD *v10;
  unint64_t v11;
  __int128 *v13;
  _BOOL4 v14;
  __int128 *v15;
  _BOOL4 IsDNSMulticast;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *OptRR;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unsigned __int8 v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  unsigned __int8 *v39;
  char *v40;
  uint64_t v41;
  uint64_t v43;
  int v44;
  int v45;
  NSObject *v46;
  const char *v47;
  uint64_t v48;
  BOOL v49;
  _BOOL4 v50;
  uint64_t v52;
  int v53;
  int v54;
  unsigned int v55;
  unint64_t v56;
  NSObject *v57;
  uint64_t v60;
  _QWORD *v61;
  int v62;
  BOOL v63;
  BOOL v64;
  uint64_t *v65;
  NSObject **v66;
  _DWORD *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int16 v70;
  char v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  BOOL v84;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  unint64_t v89;
  _BYTE *v90;
  _BYTE *v91;
  void **v92;
  _BOOL4 IsValidAnswer;
  uint64_t v94;
  BOOL v95;
  int v96;
  unsigned __int8 *Authorities;
  unsigned __int8 *v98;
  unsigned __int8 *v99;
  int v100;
  int v101;
  unsigned __int8 *LargeResourceRecord;
  unsigned int v103;
  int v104;
  int v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint8_t *v121;
  char *v122;
  uint64_t v123;
  char *v124;
  unsigned __int8 *v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  int v131;
  _BOOL4 v132;
  unsigned int v133;
  unsigned int v134;
  _QWORD *v135;
  int v136;
  unsigned __int8 *v137;
  _QWORD *v138;
  int v139;
  unsigned __int8 *v140;
  unsigned __int8 *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  NSObject *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  _QWORD *v151;
  uint64_t v152;
  int v153;
  unsigned __int8 *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  _QWORD *v161;
  NSObject *v162;
  uint64_t v163;
  _BYTE *v164;
  uint64_t v165;
  unsigned int v166;
  _BYTE *v167;
  uint64_t v168;
  _QWORD *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  const char *v173;
  uint64_t v174;
  _BYTE *v175;
  uint64_t v176;
  uint64_t v177;
  const char *v178;
  uint64_t v179;
  _BYTE *v180;
  uint64_t v181;
  unsigned __int16 v182;
  unsigned __int16 v183;
  int v184;
  const char *v185;
  uint64_t v186;
  unsigned __int16 v187;
  unsigned __int16 v188;
  const char *v189;
  int v190;
  int v191;
  NSObject *v192;
  NSObject *v193;
  uint64_t v194;
  const char *v195;
  uint64_t v196;
  _BYTE *v197;
  uint64_t v198;
  const char *v199;
  _BYTE *v200;
  uint64_t v201;
  unsigned __int16 v202;
  unsigned __int16 v203;
  int v204;
  NSObject *v205;
  uint64_t v206;
  _BYTE *v207;
  unsigned __int16 v208;
  uint64_t v209;
  _BYTE *v210;
  unsigned __int16 v211;
  uint64_t v212;
  int v213;
  const char *v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t *v219;
  uint64_t v220;
  uint64_t i;
  uint64_t *v222;
  int v223;
  _QWORD *j;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  _BYTE *v231;
  _QWORD *k;
  uint64_t m;
  uint64_t v234;
  uint64_t IdenticalRecordInCache;
  uint64_t v236;
  uint64_t *v237;
  uint64_t v238;
  uint64_t *v239;
  _BOOL4 v240;
  uint64_t *v241;
  _QWORD *v242;
  uint64_t v243;
  _QWORD *v244;
  uint64_t v245;
  uint64_t v246;
  int v247;
  int v248;
  int *v249;
  uint64_t v250;
  int v251;
  int v253;
  uint64_t v255;
  uint64_t *v256;
  uint64_t v257;
  uint64_t v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int v263;
  int v264;
  unint64_t v265;
  unsigned __int8 *v266;
  int v267;
  int v268;
  int v269;
  uint32_t v270;
  unsigned int v271;
  uint64_t v272;
  uint64_t v273;
  unsigned int v274;
  unsigned int v275;
  unsigned __int8 *v276;
  uint64_t v277;
  _WORD *v278;
  uint64_t v279;
  unint64_t v280;
  unsigned int v281;
  unint64_t v282;
  uint64_t v283;
  unsigned int v284;
  unint64_t v285;
  uint64_t v286;
  unint64_t v287;
  _QWORD *v288;
  _QWORD *v289;
  _QWORD *v290;
  uint64_t v291;
  BOOL v292;
  int v293;
  unsigned int v294;
  NSObject *v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t n;
  char *v303;
  int v304;
  int v305;
  uint64_t v306;
  char *v307;
  uint64_t v308;
  char *v309;
  _QWORD *v310;
  _QWORD *v311;
  int v312;
  unsigned __int8 *v313;
  uint64_t *v314;
  __int128 *v315;
  NSObject *v316;
  NSObject *v317;
  const char *v318;
  _BOOL4 v319;
  uint64_t v320;
  unsigned __int8 *v321;
  unsigned __int8 *v322;
  uint64_t *v323;
  int v324;
  int *v325;
  uint64_t v326;
  uint64_t v327;
  const char *v328;
  uint64_t v329;
  BOOL v330;
  int v331;
  unsigned int v332;
  _BYTE *v334;
  int IsD2D;
  uint64_t v336;
  _WORD *v339;
  char v340;
  unsigned __int8 *v341;
  int v342;
  uint64_t v343;
  uint64_t v344;
  _DWORD *v345;
  char *v346;
  int v347;
  int IsLocalSubnet;
  char v349;
  _WORD *v350;
  _BOOL4 v351;
  unsigned __int8 *Question;
  int v353;
  _BYTE *v354;
  void *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t *v358;
  _QWORD *v359;
  _OWORD v360[16];
  uint8_t __dst[80];
  __int128 v362;
  __int128 v363;
  __int128 v364;
  __int128 v365;
  __int128 v366;
  __int128 v367;
  __int128 v368;
  __int128 v369;
  __int128 v370;
  __int128 v371;
  __int128 v372;
  uint8_t buf[4];
  int v374;
  __int16 v375;
  uint64_t v376;
  __int16 v377;
  _BYTE v378[10];
  __int16 v379;
  unsigned int v380;
  uint64_t v381;
  uint64_t v382;
  unsigned int v383;
  __int16 v384;
  unsigned __int16 v385;
  unsigned __int16 v386;
  unsigned __int8 v387[320];

  v9 = a5;
  v10 = a4;
  v11 = a2;
  if (!a4 || !a6)
  {
    if (!a6)
    {
LABEL_55:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring Query from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes (%s)", (uint64_t)a4, a5, (uint64_t)a6, a7, a8, (int)v10);
      return;
    }
    v320 = a7;
    v14 = 0;
    if (a8)
      goto LABEL_12;
    goto LABEL_10;
  }
  v320 = a7;
  v13 = a6;
  v14 = !mDNSAddrIsDNSMulticast(a6) && mDNS_AddressIsLocalSubnet(a1, a8, v10) != 0;
  a6 = v13;
  v11 = a2;
  if (!a8)
  {
LABEL_10:
    v15 = a6;
    IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    a6 = v15;
    if (IsDNSMulticast)
    {
      LODWORD(v10) = (_DWORD)a4;
      a7 = v320;
      goto LABEL_55;
    }
  }
LABEL_12:
  v17 = a1 + 37921;
  v339 = (_WORD *)(a1 + 28960);
  v18 = (_DWORD *)(a1 + 19924);
  v19 = v9;
  v351 = v9 != 59668;
  v315 = a6;
  v319 = mDNSAddrIsDNSMulticast(a6);
  IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, a4);
  v358 = (uint64_t *)&v359;
  v359 = 0;
  IsD2D = mDNSPlatformInterfaceIsD2D(a8, v20, v21, v22, v23, v24, v25, v26);
  v356 = 0;
  v357 = 0;
  v355 = 0;
  v27 = a3;
  OptRR = LocateOptRR(v11, a3, 12);
  v336 = v19;
  v345 = (_DWORD *)(a1 + 19924);
  v354 = (_BYTE *)(a1 + 37921);
  if (!OptRR)
    goto LABEL_60;
  if (!GetLargeResourceRecord(a1, v11, OptRR, a3, a8, 128, a1 + 37912))
    goto LABEL_58;
  if (*(unsigned __int8 *)(a1 + 37920) == 240)
    goto LABEL_58;
  if (*(_WORD *)(a1 + 37924) != 41)
    goto LABEL_58;
  v33 = *(_QWORD *)(a1 + 37960);
  v34 = v33 + 4 + *(unsigned __int16 *)(a1 + 37932);
  if (v33 + 4 >= v34)
    goto LABEL_58;
  v35 = 0;
  v346 = 0;
  v36 = v33 + 8;
  do
  {
    v37 = *(unsigned __int16 *)(v36 - 4);
    if (v37 == 65002)
    {
      ++v35;
      v38 = *(unsigned __int16 *)(v36 + 8);
      v39 = DomainNamePtrAtTSRIndex((unsigned __int16 *)v11, a3, v38);
      if (v39)
      {
        v40 = UnsafeBufferPointer(v11, v39, a3, v36 - 4);
        if (v40)
        {
          v18 = (_DWORD *)(a1 + 19924);
          *(_QWORD *)v40 = v346;
          v355 = v40;
          v346 = v40;
LABEL_26:
          v17 = a1 + 37921;
          goto LABEL_46;
        }
        v48 = mDNSLogCategory_mDNS;
        v49 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
        v18 = (_DWORD *)(a1 + 19924);
        if (v49)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
            goto LABEL_26;
        }
        else
        {
          v48 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_26;
        }
        v52 = *(_QWORD *)(a1 + 37944);
        v53 = *(_DWORD *)v36;
        v54 = *(_DWORD *)(v36 + 4);
        v55 = *(unsigned __int16 *)(v36 + 8);
        *(_DWORD *)buf = 67110144;
        v374 = v35;
        v375 = 2048;
        v376 = v52;
        v377 = 1024;
        *(_DWORD *)v378 = v53;
        *(_WORD *)&v378[4] = 1024;
        *(_DWORD *)&v378[6] = v54;
        v379 = 1024;
        v380 = v55;
        v46 = v48;
        v17 = a1 + 37921;
        v47 = "ProcessQuery: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
      }
      else
      {
        v41 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          v18 = (_DWORD *)(a1 + 19924);
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
            goto LABEL_26;
        }
        else
        {
          v41 = mDNSLogCategory_mDNS_redacted;
          v50 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
          v18 = (_DWORD *)(a1 + 19924);
          if (!v50)
            goto LABEL_26;
        }
        v43 = *(_QWORD *)(a1 + 37944);
        v44 = *(_DWORD *)v36;
        v45 = *(_DWORD *)(v36 + 4);
        *(_DWORD *)buf = 67110144;
        v374 = v35;
        v375 = 2048;
        v376 = v43;
        v377 = 1024;
        *(_DWORD *)v378 = v44;
        *(_WORD *)&v378[4] = 1024;
        *(_DWORD *)&v378[6] = v45;
        v379 = 1024;
        v380 = v38;
        v17 = a1 + 37921;
        v46 = v41;
        v47 = "ProcessQuery: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
      }
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v47, buf, 0x24u);
    }
    else if (v37 == 4 && !*(_BYTE *)v36 && *(_DWORD *)(v36 + 2))
    {
      ClearProxyRecords(a1, v36, *(_QWORD *)(a1 + 12624));
      ClearProxyRecords(a1, v36, *(_QWORD *)(a1 + 12616));
    }
LABEL_46:
    v56 = v36 + 20;
    v36 += 24;
  }
  while (v56 < v34);
  if (v346)
  {
    v57 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
        goto LABEL_57;
    }
    else
    {
      v57 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_57:
        v60 = *(_QWORD *)(v17 + 23);
        GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 37920), (unsigned __int16 *)(*(_QWORD *)(v17 + 39) + 4), (_BYTE *)(a1 + 47032));
        *(_DWORD *)buf = 67109634;
        v374 = v35;
        v18 = (_DWORD *)(a1 + 19924);
        v375 = 2048;
        v376 = v60;
        v377 = 2082;
        *(_QWORD *)v378 = a1 + 47032;
        v17 = a1 + 37921;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEBUG, "ProcessQuery: Received TSR(%u) if %p %{public}s", buf, 0x1Cu);
      }
    }
  }
LABEL_58:
  *(_BYTE *)(a1 + 37920) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(_BYTE *)v17 = 0;
  v61 = *(_QWORD **)(v17 + 55);
  v27 = a3;
  if (v61)
  {
    ref_count_obj_release(v61);
    *(_QWORD *)(v17 + 55) = 0;
  }
LABEL_60:
  v313 = (unsigned __int8 *)(v11 + 12);
  if (*(_WORD *)(v11 + 4))
  {
    v62 = 0;
    v331 = 0;
    v63 = v336 != 59668;
    if (!v319)
      v63 = 1;
    v340 = v63;
    v334 = (_BYTE *)(a1 + 47032);
    v324 = v319 || v14;
    v344 = a1 + 37912;
    v341 = (unsigned __int8 *)(a1 + 37920);
    if (IsLocalSubnet | v351)
      v64 = 1;
    else
      v64 = !v319;
    v330 = v64;
    v65 = &v357;
    v314 = &v356;
    v66 = (NSObject **)&unk_100164000;
    Question = (unsigned __int8 *)(v11 + 12);
    v67 = a4;
    while (1)
    {
      bzero(buf, 0x2B8uLL);
      Question = getQuestion(v11, Question, v27, a8, buf);
      if (!Question)
        goto LABEL_503;
      v70 = v386;
      v71 = v340;
      if ((v386 & 0x8000u) != 0)
        v71 = 1;
      v349 = v71;
      if ((__int16)v386 < 0)
        ++v18[3];
      else
        ++v18[4];
      v347 = v62;
      v386 = v70 & 0x7FFF;
      v72 = *(_QWORD *)(a1 + 12640);
      if (v72)
      {
        v73 = v65;
        v74 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v72 + 8), (unsigned __int16 *)(*(_QWORD *)(v72 + 48) + 4), v334);
        v75 = v74;
        v65 = v73;
        v66 = (NSObject **)&unk_100164000;
        LogMsgWithLevel(v75, OS_LOG_TYPE_DEFAULT, "ProcessQuery ERROR m->CurrentRecord already set %s", v76, v77, v78, v79, v80, (int)v334);
      }
      v81 = *(_QWORD *)(a1 + 12616);
      *(_QWORD *)(a1 + 12640) = v81;
      if (!v81)
      {
LABEL_350:
        v331 = 1000;
        goto LABEL_351;
      }
      v343 = 0;
      v342 = 0;
      v82 = (uint64_t)Question;
      if (v336 == 59668)
        v82 = -2;
      v329 = v82;
      do
      {
        *(_QWORD *)(a1 + 12640) = *(_QWORD *)v81;
        v83 = *(_QWORD *)(v81 + 32);
        if ((unint64_t)(v83 + 3) < 2)
          goto LABEL_82;
        if (!v83)
          goto LABEL_94;
        if (v83 == -5)
        {
LABEL_82:
          LogMsgWithLevel(v66[295], OS_LOG_TYPE_DEFAULT, "AnyTypeRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p", v69, v29, v30, v31, v32, *(_QWORD *)(v81 + 32));
          goto LABEL_83;
        }
        v84 = v382 == -2 || v382 == 0;
        if (v84 || v83 == v382)
        {
LABEL_94:
          if (v381 && (*(_WORD *)(v381 + 276) & 0x4000) != 0)
          {
            v88 = *(_QWORD *)(v81 + 56);
            if (v88)
              v88 = *(_QWORD *)(v88 + 24);
            if (v88 != v381)
              goto LABEL_83;
          }
          else
          {
            v86 = *(_QWORD *)(v81 + 56);
            if (v86)
            {
              if (*(_QWORD *)(v86 + 24))
                v87 = 1;
              else
                v87 = v83 == 0;
              if (!v87)
                goto LABEL_110;
              v83 = *(_QWORD *)(v86 + 24);
LABEL_102:
              if (v83 != v381
                || !mDNSPlatformValidRecordForInterface(v81, v382, v68, v69, v29, v30, v31, v32))
              {
                goto LABEL_83;
              }
            }
            else
            {
              if (!v83)
                goto LABEL_102;
LABEL_110:
              if (v384)
                goto LABEL_83;
            }
          }
          if (*(unsigned __int16 *)(v81 + 14) != v386 && v386 != 255
            || *(_DWORD *)(v81 + 24) != v383
            || !SameDomainNameBytes(*(_BYTE **)(v81 + 40), v387)
            || !v324 && !*(_BYTE *)(v81 + 121))
          {
            goto LABEL_83;
          }
          v89 = v27;
          ++v18[5];
          v90 = (_BYTE *)(v81 + 8);
          if (!RRTypeAnswersQuestionType(v81 + 8, v385, 0, v69, v29, v30, v31, v32))
          {
            if ((*v90 & 0x30) != 0)
            {
              IsValidAnswer = ResourceRecordIsValidAnswer(v81);
              v94 = v343;
              if (v343)
                v95 = 1;
              else
                v95 = !IsValidAnswer;
              if (!v95)
                v94 = v81;
              v343 = v94;
            }
            v27 = v89;
            v17 = a1 + 37921;
            goto LABEL_83;
          }
          v323 = v65;
          v91 = *(_BYTE **)(v81 + 40);
          v92 = &v355;
          while (1)
          {
            v92 = (void **)*v92;
            if (!v92)
              break;
            if (SameDomainNameBytes((_BYTE *)v92 + 20, v91))
            {
              v325 = (int *)(v92 + 1);
              goto LABEL_131;
            }
          }
          v325 = 0;
LABEL_131:
          v96 = *v90;
          Authorities = LocateAuthorities(v11, v89);
          v98 = Authorities;
          if (v96 == 2)
          {
            v99 = (unsigned __int8 *)(a1 + 37920);
            if (*(_WORD *)(v11 + 8))
            {
              v321 = (unsigned __int8 *)(v81 + 8);
              v100 = 0;
              v101 = 0;
              v27 = v89;
              v17 = a1 + 37921;
              while (2)
              {
                LargeResourceRecord = GetLargeResourceRecord(a1, v11, v98, v27, v382, 160, v344);
                if (!LargeResourceRecord)
                  goto LABEL_192;
                v98 = LargeResourceRecord;
                if (*v99 == 240 || !RecordAnswersQuestion((uint64_t)v99, 0, (uint64_t)buf, v69, v29, v30, v31, v32))
                  goto LABEL_167;
                if (v325)
                {
                  v103 = CheckTSRForAuthRecord(*(uint64_t **)(a1 + 12616), v325, *(_DWORD *)(v81 + 24), *(_BYTE **)(v81 + 40));
                  if (v103)
                  {
                    v67 = a4;
                    v66 = (NSObject **)&unk_100164000;
                    if (v103 != -1)
                      goto LABEL_195;
                    v162 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        v163 = *(_QWORD *)(v81 + 40);
                        if (v163)
                        {
                          v167 = *(_BYTE **)(v81 + 40);
                          if (v163 == -256)
                          {
LABEL_232:
                            while (v167)
                            {
                              v168 = *v167;
                              if (v168 > 0x3F)
                                break;
                              if (!*v167)
                              {
                                v183 = (_WORD)v167 - v163 + 1;
                                goto LABEL_269;
                              }
                              v167 += v168 + 1;
                              if (v163 != -256)
                                goto LABEL_231;
                            }
                          }
                          else
                          {
LABEL_231:
                            if ((unint64_t)v167 < v163 + 256)
                              goto LABEL_232;
                          }
                          v183 = 257;
LABEL_269:
                          v184 = v183;
                        }
                        else
                        {
                          v184 = 0;
                        }
LABEL_270:
                        v185 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
                        v186 = *(_QWORD *)(v81 + 32);
                        *(_DWORD *)__dst = 141559043;
                        *(_QWORD *)&__dst[4] = 1752392040;
                        *(_WORD *)&__dst[12] = 1040;
                        *(_DWORD *)&__dst[14] = v184;
                        *(_WORD *)&__dst[18] = 2101;
                        *(_QWORD *)&__dst[20] = v163;
                        *(_WORD *)&__dst[28] = 2082;
                        *(_QWORD *)&__dst[30] = v185;
                        *(_WORD *)&__dst[38] = 2048;
                        *(_QWORD *)&__dst[40] = v186;
                        _os_log_impl((void *)&_mh_execute_header, v162, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface id: %p due to TSR conflict", __dst, 0x30u);
                        v11 = a2;
                      }
                    }
                    else
                    {
                      v162 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      {
                        v163 = *(_QWORD *)(v81 + 40);
                        if (v163)
                        {
                          v164 = *(_BYTE **)(v81 + 40);
                          if (v163 == -256)
                          {
LABEL_220:
                            while (v164)
                            {
                              v165 = *v164;
                              if (v165 > 0x3F)
                                break;
                              if (!*v164)
                              {
                                v182 = (_WORD)v164 - v163 + 1;
                                goto LABEL_267;
                              }
                              v164 += v165 + 1;
                              if (v163 != -256)
                                goto LABEL_219;
                            }
                          }
                          else
                          {
LABEL_219:
                            if ((unint64_t)v164 < v163 + 256)
                              goto LABEL_220;
                          }
                          v182 = 257;
LABEL_267:
                          v184 = v182;
                        }
                        else
                        {
                          v184 = 0;
                        }
                        goto LABEL_270;
                      }
                    }
                    mDNS_Deregister_internal(a1, v81, 4);
                    v99 = (unsigned __int8 *)(a1 + 37920);
                    goto LABEL_195;
                  }
                }
                if (!PacketRRConflict(a1, v81, v344))
                {
                  v100 = 1;
                  goto LABEL_167;
                }
                v104 = *(unsigned __int16 *)(v81 + 14);
                v105 = *(unsigned __int16 *)(v17 + 5);
                v106 = v104 - v105;
                if (v104 == v105)
                {
                  v106 = *(unsigned __int16 *)(v81 + 12) - *(unsigned __int16 *)(v17 + 3);
                  if (!v106)
                    goto LABEL_146;
                }
                else
                {
                  if (v106)
                    goto LABEL_142;
LABEL_146:
                  memset(__dst, 0, sizeof(__dst));
                  v362 = 0u;
                  v363 = 0u;
                  v364 = 0u;
                  v365 = 0u;
                  v366 = 0u;
                  v367 = 0u;
                  v368 = 0u;
                  v369 = 0u;
                  v370 = 0u;
                  v371 = 0u;
                  v372 = 0u;
                  memset(v360, 0, sizeof(v360));
                  v121 = __dst;
                  v122 = putRData(0, (char *)__dst, (unint64_t)buf, (uint64_t)v321, v29, v30, v31, v32);
                  v123 = (uint64_t)v99;
                  v124 = v122;
                  v125 = (unsigned __int8 *)v360;
                  v130 = putRData(0, (char *)v360, (unint64_t)__dst, v123, v126, v127, v128, v129);
                  v131 = v360 < (_OWORD *)v130;
                  v132 = __dst < (uint8_t *)v124;
                  if (__dst < (uint8_t *)v124 && v360 < (_OWORD *)v130)
                  {
                    v121 = __dst;
                    v125 = (unsigned __int8 *)v360;
                    while (1)
                    {
                      v133 = *v121;
                      v134 = *v125;
                      if (v133 != v134)
                        break;
                      ++v121;
                      v131 = ++v125 < (unsigned __int8 *)v130;
                      v132 = v121 < (uint8_t *)v124;
                      if (v121 >= (uint8_t *)v124 || v125 >= (unsigned __int8 *)v130)
                        goto LABEL_152;
                    }
                    v99 = (unsigned __int8 *)(a1 + 37920);
LABEL_159:
                    if (v134 <= v133)
                    {
                      if (v134 < v133)
                      {
                        v106 = 1;
                        goto LABEL_165;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompareRData ERROR: Invalid state", v69, v29, v30, v31, v32, v312);
                    }
                    v106 = -1;
                    goto LABEL_165;
                  }
LABEL_152:
                  if (v132)
                    v106 = 1;
                  else
                    v106 = v131 << 31 >> 31;
                  if (v132)
                  {
                    v99 = (unsigned __int8 *)(a1 + 37920);
                    if (v131)
                    {
                      v134 = *v125;
                      v133 = *v121;
                      goto LABEL_159;
                    }
                  }
                  else
                  {
                    v99 = (unsigned __int8 *)(a1 + 37920);
                  }
LABEL_165:
                  v17 = a1 + 37921;
                  if (!v106)
                  {
                    v100 = 1;
                    v11 = a2;
                    goto LABEL_167;
                  }
                }
LABEL_142:
                v107 = mDNSLogCategory_Default;
                v108 = v17;
                v109 = v382;
                GetRRDisplayString_rdb(v99, (unsigned __int16 *)(*(_QWORD *)(v108 + 39) + 4), v334);
                LogMsgWithLevel(v107, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %p Pkt Record:        %08lX %s", v110, v111, v112, v113, v114, v109);
                v316 = mDNSLogCategory_Default;
                v115 = *(_QWORD *)(v81 + 32);
                GetRRDisplayString_rdb(v321, (unsigned __int16 *)(*(_QWORD *)(v81 + 48) + 4), v334);
                LogMsgWithLevel(v316, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %p Our Record %d %s %08lX %s", v116, v117, v118, v119, v120, v115);
                if (v106 < 0)
                {
                  v166 = *(_DWORD *)(a1 + 64) + 1000;
                  if (v166 <= 1)
                    v166 = 1;
                  *(_DWORD *)(a1 + 12672) = v166;
                  *(_WORD *)(v81 + 190) = 1027;
                  InitializeLastAPTime((_DWORD *)a1, v81);
                  v11 = a2;
                  v67 = a4;
                  v27 = a3;
                  v17 = a1 + 37921;
                  v99 = (unsigned __int8 *)(a1 + 37920);
                  v66 = (NSObject **)&unk_100164000;
                  goto LABEL_195;
                }
                v100 = 1;
                v11 = a2;
                v27 = a3;
                v17 = a1 + 37921;
                v99 = (unsigned __int8 *)(a1 + 37920);
LABEL_167:
                *v99 = 0;
                *(_WORD *)(v17 + 101) = 0;
                *(_BYTE *)v17 = 0;
                v135 = *(_QWORD **)(v17 + 55);
                if (v135)
                {
                  ref_count_obj_release(v135);
                  *(_QWORD *)(v17 + 55) = 0;
                }
                if (++v101 >= *(unsigned __int16 *)(v11 + 8))
                  goto LABEL_192;
                continue;
              }
            }
            v100 = 0;
            v27 = v89;
            v17 = a1 + 37921;
LABEL_192:
            v67 = a4;
            v66 = (NSObject **)&unk_100164000;
            if (!v100 && mDNS_LoggingEnabled)
            {
              v143 = mDNSLogCategory_Default;
              v144 = *(_QWORD *)(v81 + 40);
              DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              v145 = v143;
              v99 = (unsigned __int8 *)(a1 + 37920);
              LogMsgWithLevel(v145, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %##s (%s): No Update Record found", v146, v147, v148, v149, v150, v144);
            }
LABEL_195:
            *v99 = 0;
            *(_WORD *)(v17 + 101) = 0;
            *(_BYTE *)v17 = 0;
            v151 = *(_QWORD **)(v17 + 55);
            if (v151)
            {
              ref_count_obj_release(v151);
              *(_QWORD *)(v17 + 55) = 0;
            }
LABEL_198:
            v18 = (_DWORD *)(a1 + 19924);
            v65 = v323;
            goto LABEL_83;
          }
          v322 = (unsigned __int8 *)(v81 + 8);
          v18 = (_DWORD *)(a1 + 19924);
          v27 = v89;
          v17 = a1 + 37921;
          if (Authorities && *(_WORD *)(v11 + 8))
          {
            v136 = 0;
            while (1)
            {
              v137 = GetLargeResourceRecord(a1, v11, v98, v27, v382, 160, v344);
              if (!v137)
                goto LABEL_184;
              v98 = v137;
              v138 = *(_QWORD **)(a1 + 37976);
              if (resource_records_have_same_dnssec_rr_category((uint64_t)v138, *(_QWORD *)(v81 + 64)))
              {
                if (*(unsigned __int16 *)(a1 + 37924) == *(unsigned __int16 *)(v81 + 12)
                  && *(unsigned __int16 *)(a1 + 37926) == *(unsigned __int16 *)(v81 + 14)
                  && *(unsigned __int16 *)(a1 + 37932) == *(unsigned __int16 *)(v81 + 20)
                  && *(_DWORD *)(a1 + 37940) == *(_DWORD *)(v81 + 28))
                {
                  v139 = SameRDataBody((uint64_t)v341, (unsigned __int16 *)(*(_QWORD *)(v81 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
                  v138 = *(_QWORD **)(a1 + 37976);
                  if (v139)
                    break;
                }
              }
              *v341 = 0;
              *(_WORD *)(a1 + 38022) = 0;
              *v354 = 0;
              if (v138)
              {
                ref_count_obj_release(v138);
                *(_QWORD *)(a1 + 37976) = 0;
              }
              if (++v136 >= *(unsigned __int16 *)(v11 + 8))
                goto LABEL_184;
            }
            *v341 = 0;
            *(_WORD *)(a1 + 38022) = 0;
            *v354 = 0;
            if (v138)
            {
              ref_count_obj_release(v138);
              *(_QWORD *)(a1 + 37976) = 0;
            }
            v67 = a4;
            v65 = v323;
            v66 = (NSObject **)&unk_100164000;
            goto LABEL_83;
          }
LABEL_184:
          v140 = LocateAuthorities(v11, v27);
          v66 = (NSObject **)&unk_100164000;
          if (!v140
            || !*(_WORD *)(v11 + 8)
            || (v141 = v140,
                CheckTSRForAuthRecord(*(uint64_t **)(a1 + 12616), v325, *(_DWORD *)(v81 + 24), *(_BYTE **)(v81 + 40)) != -1)|| !*(_WORD *)(v11 + 8))
          {
LABEL_187:
            if (ResourceRecordIsValidAnswer(v81))
            {
              ++v342;
              v67 = a4;
              v18 = (_DWORD *)(a1 + 19924);
              v65 = v323;
              if ((v349 & v330 & 1) != 0)
              {
                if (*(_QWORD *)(v81 + 264))
                  goto LABEL_83;
                v142 = v329;
              }
              else
              {
                if ((*(_DWORD *)(a1 + 64) - *(_DWORD *)(v81 + 288)) <= 0x3E7)
                {
                  v152 = *(_QWORD *)(v81 + 296);
                  if (v152 == a8 || v152 == -1)
                    goto LABEL_83;
                }
                v142 = -1;
              }
              *(_QWORD *)(v81 + 264) = v142;
              goto LABEL_83;
            }
            v67 = a4;
            goto LABEL_198;
          }
          v153 = 0;
          while (1)
          {
            v154 = GetLargeResourceRecord(a1, v11, v141, v27, v382, 160, v344);
            if (!v154)
              goto LABEL_187;
            v141 = v154;
            if (PacketRRMatchesSignature(v344, v81, v155, v156, v157, v158, v159, v160))
            {
              if ((*v322 & 0x32) != 0)
                break;
            }
            *v341 = 0;
            *(_WORD *)(a1 + 38022) = 0;
            *v354 = 0;
            v161 = *(_QWORD **)(a1 + 37976);
            if (v161)
            {
              ref_count_obj_release(v161);
              *(_QWORD *)(a1 + 37976) = 0;
            }
            if (++v153 >= *(unsigned __int16 *)(v11 + 8))
              goto LABEL_187;
          }
          *v341 = 0;
          *(_WORD *)(a1 + 38022) = 0;
          *v354 = 0;
          v169 = *(_QWORD **)(a1 + 37976);
          if (v169)
          {
            ref_count_obj_release(v169);
            *(_QWORD *)(a1 + 37976) = 0;
          }
          v170 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              v177 = v382;
              v178 = DNSTypeName(*(unsigned __int16 *)(a1 + 37924));
              v179 = *(_QWORD *)(a1 + 37952);
              v327 = v177;
              v318 = v178;
              if (v179)
              {
                v180 = *(_BYTE **)(a1 + 37952);
                if (v179 == -256)
                {
                  while (1)
                  {
LABEL_254:
                    if (!v180)
                      goto LABEL_273;
                    v181 = *v180;
                    if (v181 > 0x3F)
                      goto LABEL_273;
                    if (!*v180)
                      break;
                    v180 += v181 + 1;
                    if (v179 != -256)
                      goto LABEL_253;
                  }
                  v188 = (_WORD)v180 - v179 + 1;
                }
                else
                {
LABEL_253:
                  if ((unint64_t)v180 < v179 + 256)
                    goto LABEL_254;
LABEL_273:
                  v188 = 257;
                }
                v191 = v188;
              }
              else
              {
                v191 = 0;
              }
              v17 = a1 + 37921;
              GetRRDisplayString_rdb(v341, (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4), v334);
              *(_DWORD *)__dst = 134219779;
              *(_QWORD *)&__dst[4] = v327;
              *(_WORD *)&__dst[12] = 2160;
              *(_QWORD *)&__dst[14] = 1752392040;
              *(_WORD *)&__dst[22] = 2085;
              *(_QWORD *)&__dst[24] = v318;
              *(_WORD *)&__dst[32] = 2160;
              *(_QWORD *)&__dst[34] = 1752392040;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v191;
              *(_WORD *)&__dst[48] = 2101;
              *(_QWORD *)&__dst[50] = v179;
              *(_WORD *)&__dst[58] = 2160;
              *(_QWORD *)&__dst[60] = 1752392040;
              *(_WORD *)&__dst[68] = 2085;
              *(_QWORD *)&__dst[70] = a1 + 47032;
              v192 = v170;
LABEL_282:
              _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_DEFAULT, "ProbeRRMatchAndTSRCheck: pkt ar on interface  %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s", __dst, 0x4Eu);
              v11 = a2;
            }
          }
          else
          {
            v171 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v172 = v382;
              v173 = DNSTypeName(*(unsigned __int16 *)(a1 + 37924));
              v174 = *(_QWORD *)(a1 + 37952);
              v326 = v172;
              v317 = v171;
              if (v174)
              {
                v175 = *(_BYTE **)(a1 + 37952);
                if (v174 == -256)
                {
                  while (1)
                  {
LABEL_245:
                    if (!v175)
                      goto LABEL_272;
                    v176 = *v175;
                    if (v176 > 0x3F)
                      goto LABEL_272;
                    if (!*v175)
                      break;
                    v175 += v176 + 1;
                    if (v174 != -256)
                      goto LABEL_244;
                  }
                  v187 = (_WORD)v175 - v174 + 1;
                }
                else
                {
LABEL_244:
                  if ((unint64_t)v175 < v174 + 256)
                    goto LABEL_245;
LABEL_272:
                  v187 = 257;
                }
                v189 = v173;
                v190 = v187;
              }
              else
              {
                v189 = v173;
                v190 = 0;
              }
              v17 = a1 + 37921;
              GetRRDisplayString_rdb(v341, (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4), v334);
              *(_DWORD *)__dst = 134219779;
              *(_QWORD *)&__dst[4] = v326;
              *(_WORD *)&__dst[12] = 2160;
              *(_QWORD *)&__dst[14] = 1752392040;
              *(_WORD *)&__dst[22] = 2085;
              *(_QWORD *)&__dst[24] = v189;
              *(_WORD *)&__dst[32] = 2160;
              *(_QWORD *)&__dst[34] = 1752392040;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v190;
              *(_WORD *)&__dst[48] = 2101;
              *(_QWORD *)&__dst[50] = v174;
              *(_WORD *)&__dst[58] = 2160;
              *(_QWORD *)&__dst[60] = 1752392040;
              *(_WORD *)&__dst[68] = 2085;
              *(_QWORD *)&__dst[70] = a1 + 47032;
              v192 = v317;
              goto LABEL_282;
            }
          }
          v193 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              v194 = *(_QWORD *)(v81 + 32);
              v199 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              v196 = *(_QWORD *)(v81 + 40);
              v328 = v199;
              if (v196)
              {
                v200 = *(_BYTE **)(v81 + 40);
                if (v196 == -256)
                {
                  while (1)
                  {
LABEL_298:
                    if (!v200)
                      goto LABEL_304;
                    v201 = *v200;
                    if (v201 > 0x3F)
                      goto LABEL_304;
                    if (!*v200)
                      break;
                    v200 += v201 + 1;
                    if (v196 != -256)
                      goto LABEL_297;
                  }
                  v203 = (_WORD)v200 - v196 + 1;
                }
                else
                {
LABEL_297:
                  if ((unint64_t)v200 < v196 + 256)
                    goto LABEL_298;
LABEL_304:
                  v203 = 257;
                }
                v204 = v203;
              }
              else
              {
                v204 = 0;
              }
LABEL_311:
              GetRRDisplayString_rdb(v322, (unsigned __int16 *)(*(_QWORD *)(v81 + 48) + 4), v334);
              *(_DWORD *)__dst = 134219779;
              *(_QWORD *)&__dst[4] = v194;
              *(_WORD *)&__dst[12] = 2160;
              *(_QWORD *)&__dst[14] = 1752392040;
              *(_WORD *)&__dst[22] = 2085;
              *(_QWORD *)&__dst[24] = v328;
              *(_WORD *)&__dst[32] = 2160;
              *(_QWORD *)&__dst[34] = 1752392040;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v204;
              *(_WORD *)&__dst[48] = 2101;
              *(_QWORD *)&__dst[50] = v196;
              *(_WORD *)&__dst[58] = 2160;
              *(_QWORD *)&__dst[60] = 1752392040;
              *(_WORD *)&__dst[68] = 2085;
              *(_QWORD *)&__dst[70] = a1 + 47032;
              _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "ProbeRRMatchAndTSRCheck: Conflict with our ar %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s", __dst, 0x4Eu);
              v11 = a2;
              v17 = a1 + 37921;
            }
          }
          else
          {
            v193 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v194 = *(_QWORD *)(v81 + 32);
              v195 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              v196 = *(_QWORD *)(v81 + 40);
              v328 = v195;
              if (v196)
              {
                v197 = *(_BYTE **)(v81 + 40);
                if (v196 == -256)
                {
                  while (1)
                  {
LABEL_289:
                    if (!v197)
                      goto LABEL_303;
                    v198 = *v197;
                    if (v198 > 0x3F)
                      goto LABEL_303;
                    if (!*v197)
                      break;
                    v197 += v198 + 1;
                    if (v196 != -256)
                      goto LABEL_288;
                  }
                  v202 = (_WORD)v197 - v196 + 1;
                }
                else
                {
LABEL_288:
                  if ((unint64_t)v197 < v196 + 256)
                    goto LABEL_289;
LABEL_303:
                  v202 = 257;
                }
                v204 = v202;
              }
              else
              {
                v204 = 0;
              }
              goto LABEL_311;
            }
          }
          v205 = mDNSLogCategory_mDNS;
          v67 = a4;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              v206 = *(_QWORD *)(v81 + 40);
              if (v206)
              {
                v210 = *(_BYTE **)(v81 + 40);
                if (v206 == -256)
                  goto LABEL_331;
LABEL_328:
                v211 = 257;
                if ((unint64_t)v210 < v206 + 256 && v210)
                {
                  while (1)
                  {
                    v212 = *v210;
                    if (v212 > 0x3F)
                    {
LABEL_339:
                      v211 = 257;
                      goto LABEL_343;
                    }
                    if (!*v210)
                      break;
                    v210 += v212 + 1;
                    if (v206 != -256)
                      goto LABEL_328;
LABEL_331:
                    if (!v210)
                      goto LABEL_339;
                  }
                  v211 = (_WORD)v210 - v206 + 1;
                }
LABEL_343:
                v213 = v211;
              }
              else
              {
                v213 = 0;
              }
LABEL_344:
              v214 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              v215 = *(_QWORD *)(v81 + 32);
              *(_DWORD *)__dst = 141559043;
              *(_QWORD *)&__dst[4] = 1752392040;
              *(_WORD *)&__dst[12] = 1040;
              *(_DWORD *)&__dst[14] = v213;
              *(_WORD *)&__dst[18] = 2101;
              *(_QWORD *)&__dst[20] = v206;
              *(_WORD *)&__dst[28] = 2082;
              *(_QWORD *)&__dst[30] = v214;
              *(_WORD *)&__dst[38] = 2048;
              *(_QWORD *)&__dst[40] = v215;
              _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "ProcessQuery - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface id: %p due to TSR conflict", __dst, 0x30u);
              v11 = a2;
            }
          }
          else
          {
            v205 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v206 = *(_QWORD *)(v81 + 40);
              if (v206)
              {
                v207 = *(_BYTE **)(v81 + 40);
                if (v206 == -256)
                  goto LABEL_320;
LABEL_317:
                v208 = 257;
                if ((unint64_t)v207 < v206 + 256 && v207)
                {
                  while (1)
                  {
                    v209 = *v207;
                    if (v209 > 0x3F)
                    {
LABEL_338:
                      v208 = 257;
                      goto LABEL_341;
                    }
                    if (!*v207)
                      break;
                    v207 += v209 + 1;
                    if (v206 != -256)
                      goto LABEL_317;
LABEL_320:
                    if (!v207)
                      goto LABEL_338;
                  }
                  v208 = (_WORD)v207 - v206 + 1;
                }
LABEL_341:
                v213 = v208;
              }
              else
              {
                v213 = 0;
              }
              goto LABEL_344;
            }
          }
          mDNS_Deregister_internal(a1, v81, 4);
          goto LABEL_198;
        }
LABEL_83:
        v81 = *(_QWORD *)(a1 + 12640);
      }
      while (v81);
      if (v342 || !v343)
      {
        if (!v342)
          goto LABEL_350;
      }
      else
      {
        *(_QWORD *)(v343 + 200) = a8;
        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64);
      }
LABEL_351:
      if ((*(_BYTE *)(v11 + 2) & 2) != 0)
        ++v18[1];
      if ((v349 & 1) == 0 && (*(_BYTE *)(v11 + 2) & 2) == 0)
      {
        if (!IsD2D)
        {
          v219 = CacheGroupForName(a1, v383, v387);
          if (v219)
          {
            for (i = v219[2]; i; i = *(_QWORD *)i)
            {
              if (SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, (uint64_t)buf, v220, v29, v30, v31, v32)
                && *(unsigned __int16 *)(i + 20) <= 0x400u
                && !*(_QWORD *)(i + 72)
                && v65 != (uint64_t *)(i + 72))
              {
                *v65 = i;
                v65 = (uint64_t *)(i + 72);
              }
            }
          }
        }
        v216 = v65;
        v217 = *(_QWORD *)(a1 + 192);
        if (v217)
        {
          v18 = (_DWORD *)(a1 + 19924);
          do
          {
            if (!QuestionSendsMDNSQueriesViaUnicast(v217)
              && *(int *)(v217 + 212) >= 1
              && !*(_QWORD *)(v217 + 40)
              && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v217 + 256) >= 251)
            {
              v218 = *(_QWORD *)(v217 + 136);
              if (!v218 || v218 == a8)
              {
                if (!*(_QWORD *)(v217 + 48)
                  && v314 != (uint64_t *)(v217 + 48)
                  && *(unsigned __int16 *)(v217 + 342) == v385
                  && *(unsigned __int16 *)(v217 + 344) == v386
                  && *(_DWORD *)(v217 + 200) == v383
                  && SameDomainNameBytes((_BYTE *)(v217 + 376), v387))
                {
                  *v314 = v217;
                  v314 = (uint64_t *)(v217 + 48);
                }
                v18 = (_DWORD *)(a1 + 19924);
              }
            }
            v217 = *(_QWORD *)(v217 + 8);
          }
          while (v217);
        }
        else
        {
          v18 = (_DWORD *)(a1 + 19924);
        }
        v65 = v216;
        v66 = (NSObject **)&unk_100164000;
      }
      v62 = v347 + 1;
      if (v347 + 1 >= *(unsigned __int16 *)(v11 + 4))
      {
        v222 = v358;
        v223 = v331;
        goto LABEL_388;
      }
    }
  }
  v223 = 0;
  v222 = (uint64_t *)&v359;
  Question = (unsigned __int8 *)(v11 + 12);
  v67 = a4;
LABEL_388:
  for (j = *(_QWORD **)(a1 + 12616); j; j = (_QWORD *)*j)
  {
    if (j[33])
    {
      if (!j[32] && v222 != j + 32)
      {
        *v222 = (uint64_t)j;
        j[34] = 0;
        v222 = j + 32;
      }
    }
  }
  v332 = v223;
  v358 = v222;
  AddAdditionalsToResponseList(a1, (uint64_t)v359, &v358, a8, v29, v30, v31, v32);
  if (*(_WORD *)(v11 + 6))
  {
    v230 = 0;
    v231 = (_BYTE *)(a1 + 37920);
    while (1)
    {
      Question = GetLargeResourceRecord(a1, v11, Question, v27, a8, 192, a1 + 37912);
      if (!Question)
        break;
      if (*v231 != 240)
      {
        for (k = v359; k; k = (_QWORD *)k[32])
        {
          if ((k[33] || k[34]) && ShouldSuppressKnownAnswer(a1 + 37912, (uint64_t)k))
          {
            ++*v345;
            k[33] = 0;
            k[34] = 0;
          }
        }
        for (m = *(_QWORD *)(a1 + 12616); m; m = *(_QWORD *)m)
        {
          if (*(_QWORD *)(m + 208) == a8 && ShouldSuppressKnownAnswer(a1 + 37912, m))
          {
            if (*v67 == 6)
            {
              if (*(_DWORD *)(m + 236) == v67[1]
                && *(_DWORD *)(m + 240) == v67[2]
                && *(_DWORD *)(m + 244) == v67[3]
                && *(_DWORD *)(m + 248) == v67[4])
              {
                *(_QWORD *)(m + 236) = 0;
                *(_QWORD *)(m + 244) = 0;
              }
            }
            else if (*v67 == 4 && *(_DWORD *)(m + 232) == v67[1])
            {
              *(_DWORD *)(m + 232) = 0;
            }
            if (!*(_DWORD *)(m + 232)
              && !*(_QWORD *)&vorr_s8(*(int8x8_t *)(m + 236), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(m + 236), *(int8x16_t *)(m + 236), 8uLL)))
            {
              ++*v345;
              *(_QWORD *)(m + 208) = 0;
              *(_BYTE *)(m + 195) = 0;
            }
          }
        }
        IdenticalRecordInCache = FindIdenticalRecordInCache(a1, (uint64_t)v231);
        if (!IsD2D)
        {
          v236 = v357;
          if (v357)
          {
            v237 = &v357;
            do
            {
              if (*(_QWORD *)(v236 + 32) == a8
                && *(_DWORD *)(a1 + 37936) == *(_DWORD *)(v236 + 24)
                && resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a1 + 37976), *(_QWORD *)(v236 + 64))&& *(unsigned __int16 *)(a1 + 37924) == *(unsigned __int16 *)(v236 + 12)&& *(unsigned __int16 *)(a1 + 37926) == *(unsigned __int16 *)(v236 + 14)&& *(unsigned __int16 *)(a1 + 37932) == *(unsigned __int16 *)(v236 + 20)&& *(_DWORD *)(a1 + 37940) == *(_DWORD *)(v236 + 28)&& SameRDataBody((uint64_t)v231, (unsigned __int16 *)(*(_QWORD *)(v236 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(_BYTE **)(a1 + 37952), *(_BYTE **)(v236 + 40)))
              {
                *v237 = *(_QWORD *)(v236 + 72);
                *(_QWORD *)(v236 + 72) = 0;
              }
              else
              {
                v237 = (uint64_t *)(v236 + 72);
              }
              v236 = *v237;
            }
            while (*v237);
          }
        }
        v67 = a4;
        if (!IdenticalRecordInCache)
        {
          v238 = v356;
          if (v356)
          {
            v239 = &v356;
            do
            {
              v240 = RecordAnswersQuestion((uint64_t)v231, 0, v238, v226, v227, v234, v228, v229);
              v241 = (uint64_t *)(v238 + 48);
              if (v240)
              {
                *v239 = *v241;
                *v241 = 0;
              }
              else
              {
                v239 = (uint64_t *)(v238 + 48);
              }
              v238 = *v239;
            }
            while (*v239);
          }
        }
      }
      *v231 = 0;
      v17 = a1 + 37921;
      *(_WORD *)(a1 + 38022) = 0;
      *v354 = 0;
      v242 = *(_QWORD **)(a1 + 37976);
      if (v242)
      {
        ref_count_obj_release(v242);
        *(_QWORD *)(a1 + 37976) = 0;
      }
      if (++v230 >= *(unsigned __int16 *)(v11 + 6))
        goto LABEL_448;
    }
LABEL_503:
    v353 = 0;
    v265 = 0;
    goto LABEL_567;
  }
LABEL_448:
  v243 = (uint64_t)v359;
  if (v359)
  {
    v244 = v359;
    v226 = a1 + 19924;
    v227 = v319;
    v245 = v332;
    do
    {
      v246 = v244[34];
      if (v246 && !*(_QWORD *)(v246 + 264) && !*(_QWORD *)(v246 + 272))
      {
        v244[33] = 0;
        v244[34] = 0;
      }
      v244 = (_QWORD *)v244[32];
    }
    while (v244);
    v247 = 0;
    v248 = 0;
    v249 = v67 + 1;
    while (1)
    {
      v250 = *(_QWORD *)(v243 + 264);
      if (!v250)
      {
        v255 = *(_QWORD *)(v243 + 272);
        if (v255 && *(_QWORD *)(v255 + 264) == -1)
          *(_QWORD *)(v243 + 216) = a8;
        goto LABEL_499;
      }
      v251 = *(_DWORD *)(a1 + 64);
      v253 = v319 && v251 - *(_DWORD *)(v243 + 288) >= (1000 * *(_DWORD *)(v243 + 16)) >> 2;
      if (v250 == -2 && v253 != 0)
      {
        ++*(_DWORD *)(a1 + 19956);
        v250 = -1;
        *(_QWORD *)(v243 + 264) = -1;
      }
      if (v250 == -2)
      {
        ++*(_DWORD *)(a1 + 19948);
        *(_DWORD *)(a1 + 100) = v251;
        v256 = (uint64_t *)(v243 + 208);
        v257 = *(_QWORD *)(v243 + 208);
        if (v257 && v257 != a8)
          goto LABEL_492;
        *(_QWORD *)(v243 + 208) = a8;
        *(_BYTE *)(v243 + 195) = 1;
      }
      else
      {
        if (v250 == -1)
        {
          ++*(_DWORD *)(a1 + 19952);
        }
        else
        {
          v248 = 1;
          if (!v253)
            goto LABEL_494;
        }
        *(_DWORD *)(a1 + 100) = v251;
        v256 = (uint64_t *)(v243 + 208);
        v258 = *(_QWORD *)(v243 + 208);
        if (v258 && v258 != a8)
          goto LABEL_492;
        *v256 = a8;
      }
      if (*v67 != 6)
      {
        if (*v67 == 4)
        {
          v259 = *(_DWORD *)(v243 + 232);
          v260 = *v249;
          if (v259)
          {
            if (v259 != v260)
              *(_DWORD *)(v243 + 232) = -1;
          }
          else
          {
            *(_DWORD *)(v243 + 232) = v260;
          }
        }
        goto LABEL_493;
      }
      v261 = *(_DWORD *)(v243 + 236);
      v262 = *(_DWORD *)(v243 + 240);
      v256 = (uint64_t *)(v243 + 236);
      v264 = *(_DWORD *)(v243 + 244);
      v263 = *(_DWORD *)(v243 + 248);
      if (!(v262 | v261 | v264 | v263))
      {
        *(_OWORD *)v256 = *(_OWORD *)v249;
        goto LABEL_493;
      }
      if (v261 == *v249 && v262 == v67[2] && v264 == v67[3] && v263 == v67[4])
        goto LABEL_493;
      *(_QWORD *)(v243 + 244) = -1;
LABEL_492:
      *v256 = -1;
LABEL_493:
      v247 = 1;
LABEL_494:
      if ((*(_BYTE *)(v11 + 2) & 2) != 0)
      {
        v245 = 20000;
      }
      else if (*(_BYTE *)(v243 + 8) == 8)
      {
        v245 = 1000;
      }
      else
      {
        v245 = v245;
      }
LABEL_499:
      v243 = *(_QWORD *)(v243 + 256);
      if (!v243)
        goto LABEL_505;
    }
  }
  v247 = 0;
  v248 = 0;
  v245 = v332;
LABEL_505:
  v353 = v247;
  v266 = v313;
  if ((_DWORD)v245 && !*(_DWORD *)(a1 + 76))
  {
    v267 = *(_DWORD *)(a1 + 84);
    v268 = *(_DWORD *)(a1 + 64);
    if (v267)
    {
      v269 = v245 + 49;
      if (v267 - v268 >= (int)(((int)v245 + 49) / 0x32u))
        goto LABEL_515;
    }
    else
    {
      v269 = v245 + 49;
    }
    do
      v270 = arc4random() & 0x1FFF;
    while (v270 > 0x1388);
    v271 = (v270 + v269) / 0x32 + v268;
    if (v271 <= 1)
      v271 = 1;
    *(_DWORD *)(a1 + 84) = v271;
  }
LABEL_515:
  if (!v248)
  {
    v265 = 0;
    v11 = a2;
    goto LABEL_567;
  }
  v272 = (uint64_t)v359;
  v273 = a1 + 28972;
  if (a8)
    v274 = 4500;
  else
    v274 = 3600;
  v11 = a2;
  *v339 = *(_WORD *)a2;
  *(_WORD *)(a1 + 28962) = 132;
  *(_QWORD *)(a1 + 28964) = 0;
  if (v336 == 59668)
  {
    v265 = a1 + 28972;
  }
  else
  {
    if (!*(_WORD *)(a2 + 4))
      goto LABEL_564;
    v275 = 0;
    v265 = a1 + 28972;
    do
    {
      bzero(buf, 0x2B8uLL);
      v276 = getQuestion(a2, v266, a3, a8, buf);
      if (!v276)
        goto LABEL_565;
      v266 = v276;
      if (v272)
      {
        v277 = v272;
        while (*(unsigned __int8 **)(v277 + 264) != v276)
        {
          v277 = *(_QWORD *)(v277 + 256);
          if (!v277)
            goto LABEL_529;
        }
        v265 = (unint64_t)putQuestion((unint64_t)v339, v265, a1 + 37912, v387, v385, v386, v228, v229);
        if (!v265)
          goto LABEL_565;
      }
LABEL_529:
      ++v275;
    }
    while (v275 < *(unsigned __int16 *)(a2 + 4));
    if (!*(_WORD *)(a1 + 28964))
    {
LABEL_564:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GenerateUnicastResponse: ERROR! Why no questions?", v226, v227, v245, v228, v229, v312);
LABEL_565:
      v265 = 0;
      goto LABEL_566;
    }
    v274 = 10;
  }
  if (!v272)
    goto LABEL_566;
  v278 = (_WORD *)(a1 + 28966);
  v350 = (_WORD *)(a1 + 28970);
  v279 = v272;
  while (2)
  {
    v280 = v265;
    if (*(_QWORD *)(v279 + 264))
    {
      v281 = *(_DWORD *)(v279 + 16);
      if (v274 >= v281)
        v282 = v281;
      else
        v282 = v274;
      if (*v278 || *(_WORD *)(a1 + 28968) || *v350)
        v283 = 1440;
      else
        v283 = 8940;
      v265 = PutResourceRecordTTLWithLimit((unint64_t)v339, v265, v278, v279 + 8, v282, v273 + v283, v228, v229);
      if (!v265)
      {
        *(_BYTE *)(a1 + 28962) |= 2u;
        goto LABEL_546;
      }
    }
    else
    {
LABEL_546:
      v265 = v280;
    }
    v279 = *(_QWORD *)(v279 + 256);
    if (v279)
      continue;
    break;
  }
  do
  {
    if (*(_QWORD *)(v272 + 272) && !*(_QWORD *)(v272 + 264))
    {
      v284 = *(_DWORD *)(v272 + 16);
      v285 = v274 >= v284 ? v284 : v274;
      v286 = *v278 || *(_WORD *)(a1 + 28968) || *v350 ? 1440 : 8940;
      v287 = PutResourceRecordTTLWithLimit((unint64_t)v339, v265, v350, v272 + 8, v285, v273 + v286, v228, v229);
      if (v287)
        v265 = v287;
    }
    v272 = *(_QWORD *)(v272 + 256);
  }
  while (v272);
LABEL_566:
  v17 = a1 + 37921;
LABEL_567:
  *(_BYTE *)(a1 + 37920) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(_BYTE *)v17 = 0;
  v288 = *(_QWORD **)(v17 + 55);
  if (v288)
  {
    ref_count_obj_release(v288);
    *(_QWORD *)(v17 + 55) = 0;
  }
  v289 = v359;
  if (v359)
  {
    do
    {
      v290 = (_QWORD *)v289[32];
      v289[33] = 0;
      v289[34] = 0;
      v289[32] = 0;
      v289 = v290;
    }
    while (v290);
    v359 = 0;
  }
  v291 = v357;
  if (v357)
    v292 = IsD2D == 0;
  else
    v292 = 0;
  if (v292)
  {
    do
    {
      v357 = *(_QWORD *)(v291 + 72);
      *(_QWORD *)(v291 + 72) = 0;
      if ((*(_BYTE *)(v11 + 2) & 2) == 0)
      {
        v293 = *(_DWORD *)(a1 + 64);
        if (!*(_BYTE *)(v291 + 108) || v293 - *(_DWORD *)(v291 + 104) >= 750)
        {
          ++*(_BYTE *)(v291 + 108);
          *(_DWORD *)(v291 + 104) = v293;
          SetNextCacheCheckTimeForRecord(a1, v291);
        }
      }
      v294 = *(unsigned __int8 *)(v291 + 108);
      if (v294 < 4)
        goto LABEL_593;
      if (*(_BYTE *)(v291 + 109))
      {
        if (dword_100158E08 - *(_DWORD *)(a1 + 64) + 939524096 < 7667 || mDNS_LoggingEnabled == 0)
          goto LABEL_592;
      }
      else if (*(_DWORD *)(v291 + 80) + 1000 * *(_DWORD *)(v291 + 16) - *(_DWORD *)(a1 + 64) < 7667
             || (mDNS_LoggingEnabled & 1) == 0)
      {
        goto LABEL_592;
      }
      v296 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v291 + 8), (unsigned __int16 *)(*(_QWORD *)(v291 + 48) + 4), (_BYTE *)(a1 + 47032));
      v11 = a2;
      LogMsgWithLevel(v296, OS_LOG_TYPE_DEFAULT, "ProcessQuery: UnansweredQueries %lu interface %lu TTL %lu mDNS_Reconfirm() for %s", v297, v298, v299, v300, v301, v294);
LABEL_592:
      ++*(_DWORD *)(a1 + 19932);
      mDNS_Reconfirm_internal(a1, v291, 0x1388u);
LABEL_593:
      v291 = v357;
    }
    while (v357);
  }
  for (n = v356; v356; n = v356)
  {
    v303 = *(char **)(n + 56);
    v356 = *(_QWORD *)(n + 48);
    *(_QWORD *)(n + 48) = 0;
    v304 = *(_DWORD *)(a1 + 64);
    v305 = *a4;
    if (v303)
    {
      v306 = 0;
      v307 = v303;
      while (*(_QWORD *)v307 != a8 || *((_DWORD *)v307 + 3) != v305)
      {
        ++v306;
        v307 += 16;
        if (v306 == 8)
          goto LABEL_603;
      }
      v309 = &v303[16 * v306];
    }
    else
    {
      v303 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xF1748037uLL);
      if (!v303)
        __break(1u);
      *(_QWORD *)(n + 56) = v303;
LABEL_603:
      v308 = 0;
      v309 = v303;
      while (*(_QWORD *)&v303[v308])
      {
        if (*(_DWORD *)&v303[v308 + 8] - *((_DWORD *)v309 + 2) < 0)
          v309 = &v303[v308];
        v308 += 16;
        if (v308 == 128)
          goto LABEL_611;
      }
      v309 = &v303[v308];
    }
LABEL_611:
    *(_QWORD *)v309 = a8;
    *((_DWORD *)v309 + 2) = v304;
    *((_DWORD *)v309 + 3) = v305;
  }
  v310 = v355;
  if (v355)
  {
    do
    {
      v311 = (_QWORD *)*v310;
      free(v310);
      v310 = v311;
    }
    while (v311);
  }
  if (v353)
    DumpPacket(0, 0, (uint64_t)"N/A", (__int128 *)a4, v336, v315, (unsigned __int16)v320, (unsigned __int8 *)a2, a3, a8);
  if (v265)
    mDNSSendDNSMessage(a1, (unint64_t)v339, v265, a8, 0, 0, a4, v336, 0, 0);
}

_BYTE *LocateOptRR(unint64_t a1, unint64_t a2, int a3)
{
  _BYTE *Additionals;
  int v7;

  Additionals = LocateAdditionals(a1, a2);
  if (Additionals)
  {
    v7 = *(unsigned __int16 *)(a1 + 10) + 1;
    while (--v7)
    {
      if ((unint64_t)&Additionals[a3 + 11] > a2
        || *Additionals
        || Additionals[1]
        || Additionals[2] != 41
        || (unsigned __int16)a3 > bswap32(*(unsigned __int16 *)(Additionals + 9)) >> 16)
      {
        Additionals = skipResourceRecord(a1, Additionals, a2);
        if (Additionals)
          continue;
      }
      return Additionals;
    }
    return 0;
  }
  return Additionals;
}

_BYTE *LocateAdditionals(unint64_t a1, unint64_t a2)
{
  _BYTE *Authorities;
  int v5;

  Authorities = LocateAuthorities(a1, a2);
  v5 = *(unsigned __int16 *)(a1 + 8);
  if (*(_WORD *)(a1 + 8))
  {
    do
    {
      Authorities = skipResourceRecord(a1, Authorities, a2);
      --v5;
    }
    while (v5);
  }
  return Authorities;
}

_BYTE *LocateAuthorities(unint64_t a1, unint64_t a2)
{
  _BYTE *Answers;
  _BYTE *v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  _BYTE *v9;

  Answers = LocateAnswers(a1, a2);
  v5 = Answers;
  v6 = *(unsigned __int16 *)(a1 + 6);
  if (*(_WORD *)(a1 + 6))
    v7 = Answers == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = 1;
    do
    {
      v9 = skipResourceRecord(a1, v5, a2);
      v5 = v9;
      if (v8 >= v6)
        break;
      ++v8;
    }
    while (v9);
  }
  return v5;
}

_BYTE *LocateAnswers(unint64_t a1, unint64_t a2)
{
  _BYTE *v3;
  unsigned int v4;
  unsigned int v6;
  _BYTE *v7;
  _BYTE *result;

  v3 = (_BYTE *)(a1 + 12);
  v4 = *(unsigned __int16 *)(a1 + 4);
  if (!*(_WORD *)(a1 + 4))
    return (_BYTE *)(a1 + 12);
  v6 = 1;
  do
  {
    v7 = skipDomainName(a1, v3, a2);
    v3 = v7 + 4;
    if ((unint64_t)(v7 + 4) > a2 || v7 == 0)
      result = 0;
    else
      result = v7 + 4;
    if (v6 >= v4)
      break;
    ++v6;
  }
  while (result);
  return result;
}

_BYTE *skipResourceRecord(unint64_t a1, _BYTE *a2, unint64_t a3)
{
  _BYTE *result;
  uint64_t v5;

  result = skipDomainName(a1, a2, a3);
  if (result)
  {
    if ((unint64_t)(result + 10) <= a3)
    {
      v5 = __rev16(*((unsigned __int16 *)result + 4));
      if ((unint64_t)&result[v5 + 10] <= a3)
        result += v5 + 10;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unsigned __int8 *getQuestion(unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, void *a5)
{
  unsigned __int8 *DomainName;
  unsigned __int8 *v11;
  unsigned __int8 *v12;

  bzero(a5, 0x2B8uLL);
  *((_QWORD *)a5 + 17) = a4;
  if (!a4)
    *((_WORD *)a5 + 170) = -1;
  DomainName = getDomainName(a1, a2, a3, (_BYTE *)a5 + 376);
  if (!DomainName)
    return 0;
  v11 = DomainName;
  v12 = DomainName + 4;
  if ((unint64_t)(DomainName + 4) > a3)
    return 0;
  *((_DWORD *)a5 + 50) = DomainNameHashValue((unint64_t)a5 + 376);
  *((_WORD *)a5 + 171) = bswap32(*(unsigned __int16 *)v11) >> 16;
  *((_WORD *)a5 + 172) = bswap32(*((unsigned __int16 *)v11 + 1)) >> 16;
  return v12;
}

unsigned __int8 *getDomainName(unint64_t a1, unsigned __int8 *a2, unint64_t a3, _BYTE *a4)
{
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned int v6;
  _BYTE *v7;
  unint64_t v8;
  unint64_t v9;
  char v11;

  v4 = 0;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    *a4 = 0;
    v5 = a2 + 1;
    v6 = *a2;
    if (*a2)
    {
      v7 = 0;
      v8 = (unint64_t)(a4 + 256);
      while (1)
      {
        if (v6 >> 6)
        {
          if (v6 >> 6 != 3 || (unint64_t)v5 >= a3)
            return 0;
          v9 = *v5 | ((unint64_t)(v6 & 0x3F) << 8);
          v5 = (unsigned __int8 *)(a1 + v9);
          if (a1 + v9 < a1 || (unint64_t)v5 >= a3)
            return 0;
          if (!v7)
            v7 = a2 + 2;
          v6 = *v5;
          if (v6 >= 0x40)
            return 0;
        }
        else
        {
          v4 = 0;
          if ((unint64_t)&v5[v6] >= a3 || (unint64_t)&a4[v6 + 1] >= v8)
            return (unsigned __int8 *)v4;
          *a4++ = v6;
          do
          {
            v11 = *v5++;
            *a4++ = v11;
            --v6;
          }
          while (v6);
          *a4 = 0;
          v6 = *v5;
        }
        a2 = v5++;
        if (!v6)
          goto LABEL_25;
      }
    }
    v7 = 0;
LABEL_25:
    if (v7)
      return v7;
    else
      return v5;
  }
  return (unsigned __int8 *)v4;
}

unsigned __int8 *GetLargeResourceRecord(uint64_t a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  unsigned int v13;
  _BYTE *v14;
  _BYTE *v15;
  _QWORD *v16;
  int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  unsigned __int8 *DomainName;
  unsigned __int16 *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned int v35;
  int v36;
  int v37;
  unsigned int v38;
  BOOL v40;
  uint64_t v41;
  char v42;
  unsigned __int8 *v43;
  NSObject *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  _BYTE *v53;
  _BYTE *v54;
  int v55;
  uint64_t v56;
  _BYTE *v57;
  uint64_t v58;
  const char *v59;
  uint8_t buf[4];
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  _BYTE *v66;
  __int16 v67;
  const char *v68;

  if (a5)
    v13 = 4500;
  else
    v13 = 3600;
  if (a1 + 37912 == a7)
  {
    v18 = (unsigned __int8 *)(a1 + 37920);
    if (*(_BYTE *)(a1 + 37920))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4), (_BYTE *)(a1 + 47032));
      LogFatalError("GetLargeResourceRecord: m->rec appears to be already in use for %s", v19, v20, v21, v22, v23, v24, v25, a1 + 47032);
    }
    *(_QWORD *)a7 = 0;
    v14 = (_BYTE *)(a7 + 8348);
    v15 = (_BYTE *)(a7 + 8);
    *(_QWORD *)(a7 + 40) = a7 + 8348;
    v16 = (_QWORD *)(a7 + 40);
    *(_QWORD *)(a7 + 72) = 0;
  }
  else
  {
    *(_QWORD *)a7 = 0;
    v14 = (_BYTE *)(a7 + 8348);
    v15 = (_BYTE *)(a7 + 8);
    *(_QWORD *)(a7 + 40) = a7 + 8348;
    v16 = (_QWORD *)(a7 + 40);
    *(_QWORD *)(a7 + 72) = 0;
    if (!a1)
    {
      v17 = 0;
      goto LABEL_11;
    }
  }
  v17 = *(_DWORD *)(a1 + 64);
LABEL_11:
  *(_DWORD *)(a7 + 80) = v17;
  *(_DWORD *)(a7 + 84) = 0;
  *(_DWORD *)(a7 + 88) = v17;
  *(_QWORD *)(a7 + 112) = 0;
  *(_QWORD *)(a7 + 100) = 0;
  *(_QWORD *)(a7 + 92) = 0;
  *(_BYTE *)(a7 + 108) = 0;
  *(_QWORD *)(a7 + 32) = a5;
  v26 = *(void **)(a7 + 56);
  if (v26)
  {
    os_release(v26);
    *(_QWORD *)(a7 + 56) = 0;
  }
  DomainName = getDomainName(a2, a3, a4, v14);
  if (DomainName)
  {
    v28 = (unsigned __int16 *)DomainName;
    *(_DWORD *)(a7 + 24) = DomainNameHashValue(*(_QWORD *)(a7 + 40));
    v34 = (unsigned __int8 *)(v28 + 5);
    if ((unint64_t)(v28 + 5) <= a4)
    {
      v35 = bswap32(*v28);
      v36 = HIWORD(v35);
      *(_WORD *)(a7 + 12) = HIWORD(v35);
      v37 = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      *(_WORD *)(a7 + 14) = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      v38 = bswap32(*((_DWORD *)v28 + 1));
      if (v38 != -1 && v38 > v13)
        v38 = v13;
      *(_DWORD *)(a7 + 16) = v38;
      v40 = *((char *)v28 + 2) <= -1 || a5 == 0;
      v41 = __rev16(v28[4]);
      v42 = v40 ? a6 | 0x10 : a6;
      v43 = &v34[v41];
      if ((unint64_t)&v34[v41] <= a4)
      {
        *(_WORD *)(a7 + 152) = 0x2000;
        *(_QWORD *)(a7 + 48) = a7 + 152;
        if (v41 > 0x2000)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v45 = mDNSLogCategory_Default;
            v46 = DNSTypeName(v36);
            LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, "GetLargeResourceRecord: %s rdata size (%d) exceeds storage (%d)", v47, v48, v49, v50, v51, v46);
          }
          goto LABEL_33;
        }
        if (!(_DWORD)v41 && v37 == 255)
        {
          *(_WORD *)(a7 + 20) = 0;
LABEL_38:
          SetNewRData((uint64_t)v15, 0, 0, v29, v30, v31, v32, v33);
          *v15 = v42;
          return v43;
        }
        if (SetRData(a2, v34, (unint64_t)&v34[v41], (uint64_t)v15, v41, v31, v32, v33))
          goto LABEL_38;
        v52 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            v53 = (_BYTE *)*v16;
            if (*v16)
            {
              v57 = (_BYTE *)*v16;
              v55 = 257;
              if (v53 == (_BYTE *)-256)
                goto LABEL_58;
LABEL_55:
              if (v57 < v53 + 256 && v57)
              {
                while (1)
                {
                  v58 = *v57;
                  if (v58 > 0x3F)
                  {
LABEL_66:
                    v55 = 257;
                    goto LABEL_70;
                  }
                  if (!*v57)
                    break;
                  v57 += v58 + 1;
                  if (v53 != (_BYTE *)-256)
                    goto LABEL_55;
LABEL_58:
                  if (!v57)
                    goto LABEL_66;
                }
                v55 = (unsigned __int16)((_WORD)v57 - (_WORD)v53 + 1);
              }
            }
            else
            {
              v55 = 0;
            }
            goto LABEL_70;
          }
        }
        else
        {
          v52 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            v53 = (_BYTE *)*v16;
            if (*v16)
            {
              v54 = (_BYTE *)*v16;
              v55 = 257;
              if (v53 == (_BYTE *)-256)
                goto LABEL_47;
LABEL_44:
              if (v54 < v53 + 256 && v54)
              {
                while (1)
                {
                  v56 = *v54;
                  if (v56 > 0x3F)
                  {
LABEL_65:
                    v55 = 257;
                    goto LABEL_70;
                  }
                  if (!*v54)
                    break;
                  v54 += v56 + 1;
                  if (v53 != (_BYTE *)-256)
                    goto LABEL_44;
LABEL_47:
                  if (!v54)
                    goto LABEL_65;
                }
                v55 = (unsigned __int16)((_WORD)v54 - (_WORD)v53 + 1);
              }
            }
            else
            {
              v55 = 0;
            }
LABEL_70:
            v59 = DNSTypeName(*(unsigned __int16 *)(a7 + 12));
            *(_DWORD *)buf = 141558787;
            v62 = 1752392040;
            v63 = 1040;
            v64 = v55;
            v65 = 2101;
            v66 = v53;
            v67 = 2082;
            v68 = v59;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "GetLargeResourceRecord: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
          }
        }
LABEL_33:
        *(_BYTE *)(a7 + 8) = -16;
        *(_DWORD *)(a7 + 20) = 0;
        *(_DWORD *)(a7 + 28) = 0;
        return v43;
      }
    }
  }
  return 0;
}

uint64_t PacketRRConflict(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v13;
  char v14;

  if ((*(_BYTE *)(a2 + 8) & 0x32) == 0 || *(_QWORD *)(a2 + 88))
    return 0;
  v6 = (uint64_t **)(a1 + 12616);
  v7 = (_QWORD *)(a1 + 12616);
  while (1)
  {
    v7 = (_QWORD *)*v7;
    if (!v7)
      break;
    if (PacketRecordMatches((uint64_t)v7, a3, a2))
      return 0;
  }
  v8 = (_QWORD *)(a1 + 12624);
  while (1)
  {
    v8 = (_QWORD *)*v8;
    if (!v8)
      break;
    if (PacketRecordMatches((uint64_t)v8, a3, a2))
      return 0;
  }
  v9 = *(_QWORD *)(a2 + 96) ? *(uint64_t **)(a2 + 96) : (uint64_t *)a2;
  v10 = *v6;
  if (v10)
  {
    while (*((_DWORD *)v10 + 6) != *(_DWORD *)(a3 + 24)
         || !resource_records_have_same_dnssec_rr_category(v10[8], *(_QWORD *)(a3 + 64))
         || *((unsigned __int16 *)v10 + 6) != *(unsigned __int16 *)(a3 + 12)
         || *((unsigned __int16 *)v10 + 7) != *(unsigned __int16 *)(a3 + 14)
         || *((unsigned __int16 *)v10 + 10) != *(unsigned __int16 *)(a3 + 20)
         || *((_DWORD *)v10 + 7) != *(_DWORD *)(a3 + 28)
         || !SameRDataBody((uint64_t)(v10 + 1), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes((_BYTE *)v10[5], *(_BYTE **)(a3 + 40)))
    {
      v10 = (uint64_t *)*v10;
      if (!v10)
        goto LABEL_24;
    }
    v11 = (uint64_t *)v10[12];
    if (!v11)
      v11 = v10;
  }
  else
  {
LABEL_24:
    v11 = 0;
  }
  if (v11 == v9)
    return 0;
  if (v11)
    v13 = *(_DWORD *)(a2 + 126) == 0;
  else
    v13 = 1;
  v14 = v13;
  return v14 & 1;
}

uint64_t AddAdditionalsToResponseList(uint64_t result, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t i;
  int v22;
  uint64_t v24;
  uint64_t j;
  int v26;
  uint64_t v28;

  if (a2)
  {
    v10 = a2;
    v11 = (_QWORD *)result;
    v12 = result + 11440;
    v13 = (uint64_t *)(result + 11696);
    while (1)
    {
      v14 = *(_QWORD *)(v10 + 72);
      if (v14 && ResourceRecordIsValidInterfaceAnswer(v14, a4, (uint64_t)a3, a4, a5, a6, a7, a8))
      {
        v15 = *(_QWORD *)(v10 + 72);
        if (!*(_QWORD *)(v15 + 256) && *a3 != (uint64_t *)(v15 + 256))
        {
          **a3 = v15;
          v16 = *(_QWORD *)(v10 + 272);
          if (!v16)
            v16 = v10;
          *(_QWORD *)(v15 + 272) = v16;
          *a3 = (uint64_t *)(v15 + 256);
          v15 = *(_QWORD *)(v10 + 72);
        }
        AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v15, a4, a6, a7, a8);
      }
      result = *(_QWORD *)(v10 + 80);
      if (result)
      {
        result = ResourceRecordIsValidInterfaceAnswer(result, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          v17 = *(_QWORD *)(v10 + 80);
          if (!*(_QWORD *)(v17 + 256) && *a3 != (uint64_t *)(v17 + 256))
          {
            **a3 = v17;
            v18 = *(_QWORD *)(v10 + 272);
            if (!v18)
              v18 = v10;
            *(_QWORD *)(v17 + 272) = v18;
            *a3 = (uint64_t *)(v17 + 256);
            v17 = *(_QWORD *)(v10 + 80);
          }
          result = AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v17, a4, a6, a7, a8);
        }
      }
      v19 = *(unsigned __int16 *)(v10 + 12);
      if (v19 > 0x1B)
        break;
      if (v19 == 1)
        goto LABEL_47;
      if (v19 == 12)
      {
        result = ResourceRecordIsValidInterfaceAnswer(v12, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          result = SameDomainLabelPointer(*(_QWORD *)(v10 + 48) + 4, v11[1435]);
          if ((_DWORD)result)
          {
            if (!*v13 && *a3 != v13)
            {
              **a3 = v12;
              v20 = *(_QWORD *)(v10 + 272);
              if (!v20)
                v20 = v10;
              v11[1464] = v20;
              *a3 = v13;
            }
          }
        }
      }
LABEL_62:
      v10 = *(_QWORD *)(v10 + 256);
      if (!v10)
        return result;
    }
    if (v19 != 28)
    {
      if (v19 == 33)
      {
        for (i = v11[1577]; i; i = *(_QWORD *)i)
        {
          v22 = *(unsigned __int16 *)(i + 12);
          if (v22 == 28 || v22 == 1)
          {
            result = ResourceRecordIsValidInterfaceAnswer(i, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
            if ((_DWORD)result)
            {
              if (*(_DWORD *)(v10 + 28) == *(_DWORD *)(i + 24))
              {
                result = SameDomainNameBytes((_BYTE *)(*(_QWORD *)(v10 + 48) + 10), *(_BYTE **)(i + 40));
                if ((_DWORD)result)
                {
                  if (!*(_QWORD *)(i + 256) && *a3 != (uint64_t *)(i + 256))
                  {
                    **a3 = i;
                    v24 = *(_QWORD *)(v10 + 272);
                    if (!v24)
                      v24 = v10;
                    *(_QWORD *)(i + 272) = v24;
                    *a3 = (uint64_t *)(i + 256);
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_62;
    }
LABEL_47:
    for (j = v11[1577]; j; j = *(_QWORD *)j)
    {
      v26 = *(unsigned __int16 *)(j + 12);
      if (v26 == 28 || v26 == 1)
      {
        result = ResourceRecordIsValidInterfaceAnswer(j, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(j + 24))
          {
            result = SameDomainNameBytes(*(_BYTE **)(v10 + 40), *(_BYTE **)(j + 40));
            if ((_DWORD)result)
            {
              if (!*(_QWORD *)(j + 256) && *a3 != (uint64_t *)(j + 256))
              {
                **a3 = j;
                v28 = *(_QWORD *)(v10 + 272);
                if (!v28)
                  v28 = v10;
                *(_QWORD *)(j + 272) = v28;
                *a3 = (uint64_t *)(j + 256);
              }
            }
          }
        }
      }
    }
    goto LABEL_62;
  }
  return result;
}

void mDNS_HostNameCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void (*v9)(uint64_t, _QWORD);
  __int128 v10;
  __int128 v11;
  void (*v12)(uint64_t, uint64_t);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[4];

  if (a3 != -65792)
  {
    if (a3 == -65548)
    {
      v10 = *(_OWORD *)(a1 + 10360);
      v18[0] = *(_OWORD *)(a1 + 10344);
      v18[1] = v10;
      v11 = *(_OWORD *)(a1 + 10392);
      v18[2] = *(_OWORD *)(a1 + 10376);
      v18[3] = v11;
      v12 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      if (v12)
        v12(a1, 4294901748);
      if (SameDomainLabelPointer(a1 + 10344, v18))
        IncrementLabelSuffix((unsigned __int8 *)(a1 + 10344), 0);
      mDNS_SetFQDN(a1);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname %#s.local already in use; will try %#s.local instead",
        v13,
        v14,
        v15,
        v16,
        v17,
        (int)v18);
    }
    else if (a3)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_HostNameCallback: Unknown error %d for registration of record %s", a4, a5, a6, a7, a8, a3);
    }
    else
    {
      v9 = *(void (**)(uint64_t, _QWORD))(a1 + 32);
      if (v9)
        v9(a1, 0);
    }
  }
}

void regservice_callback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  const char *v16;
  uint64_t v17;
  unsigned int v18;
  const char *v22;
  const char *v23;
  int v24;
  _BYTE *v25;
  unint64_t v26;
  _BYTE *v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  int v32;
  NSObject *v33;
  _BYTE *v35;
  unsigned __int16 v36;
  uint64_t v37;
  _BYTE *v39;
  unsigned __int16 v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t *i;
  NSObject *v46;
  unsigned int v48;
  _BYTE *v49;
  _BYTE *v50;
  uint64_t v51;
  NSObject *v52;
  uint32_t v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  _BYTE *v60;
  _BYTE *v61;
  uint64_t v62;
  NSObject *v63;
  unsigned int v64;
  _BYTE *v65;
  _BYTE *v66;
  uint64_t v67;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _BYTE *v74;
  uint64_t v75;
  _BYTE *v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  _BYTE *v80;
  uint64_t v81;
  int v82;
  NSObject *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  unint64_t v95;
  uint64_t v96;
  _QWORD *j;
  int v98;
  int v99;
  int v100;
  const char *v101;
  unsigned int v102;
  void *v103;
  uint8_t buf[4];
  unsigned int v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  int v109;
  __int16 v110;
  _BYTE *v111;
  __int16 v112;
  int v113;
  __int16 v114;
  unsigned int v115;
  __int16 v116;
  const char *v117;
  _OWORD v118[2];

  v103 = 0;
  if (!a2)
  {
    v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: srs is NULL %d";
    }
    else
    {
      v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: srs is NULL %d";
    }
LABEL_118:
    v52 = v14;
    v53 = 8;
LABEL_119:
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v16, buf, v53);
    return;
  }
  v10 = *(_QWORD *)(a2 + 8);
  if (!v10)
  {
    v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }
    else
    {
      v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }
    goto LABEL_118;
  }
  v12 = *(_QWORD *)(v10 + 8);
  v13 = !v12 || !*(_BYTE *)(*(_QWORD *)(v12 + 120) + 1355) || *(_BYTE *)(v10 + 26) != 0;
  if (mDNS_LoggingEnabled == 1)
  {
    memset(v118, 0, sizeof(v118));
    v17 = *(_QWORD *)(v10 + 8);
    if (v17)
      v18 = *(_DWORD *)(v17 + 192);
    else
      v18 = 0;
    v102 = v18;
    if (a3)
    {
      if (a3 == -65548)
      {
        v22 = "NAME CONFLICT";
      }
      else
      {
        if (a3 != -65792)
        {
          v23 = "suppressed error";
          if (v13)
            v23 = "CALLBACK";
          v100 = (int)v23;
          v101 = (const char *)v118;
          mDNS_snprintf(v118);
          goto LABEL_39;
        }
        v22 = "DEREGISTERED";
      }
    }
    else
    {
      v22 = "REGISTERED";
    }
    v101 = v22;
LABEL_39:
    v24 = -2128831035;
    v25 = *(_BYTE **)(a2 + 2448);
    v26 = (unint64_t)(v25 + 256);
    v27 = v25;
    if (v25 == (_BYTE *)-256)
      goto LABEL_43;
LABEL_40:
    v28 = 257;
    if ((unint64_t)v27 >= v26 || !v27)
      goto LABEL_50;
    while (1)
    {
      v29 = *v27;
      if (v29 > 0x3F)
      {
LABEL_48:
        v28 = 257;
        goto LABEL_50;
      }
      if (!*v27)
        break;
      v27 += v29 + 1;
      if (v25 != (_BYTE *)-256)
        goto LABEL_40;
LABEL_43:
      if (!v27)
        goto LABEL_48;
    }
    v28 = (unsigned __int16)((_WORD)v27 - (_WORD)v25 + 1);
    if ((_WORD)v27 - (_WORD)v25 != 0xFFFF)
    {
LABEL_50:
      v30 = v28;
      v31 = *(unsigned __int8 **)(a2 + 2448);
      do
      {
        v32 = *v31++;
        v24 = 16777619 * (v24 ^ v32);
        --v30;
      }
      while (v30);
    }
    v33 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_88:
        v12 = *(_QWORD *)(v10 + 8);
        goto LABEL_89;
      }
      if (v25)
      {
        v35 = v25;
        if (v25 == (_BYTE *)-256)
          goto LABEL_63;
LABEL_60:
        v36 = 257;
        if ((unint64_t)v35 < v26 && v35)
        {
          while (1)
          {
            v37 = *v35;
            if (v37 > 0x3F)
            {
LABEL_81:
              v36 = 257;
              goto LABEL_84;
            }
            if (!*v35)
              break;
            v35 += v37 + 1;
            if (v25 != (_BYTE *)-256)
              goto LABEL_60;
LABEL_63:
            if (!v35)
              goto LABEL_81;
          }
          v36 = (_WORD)v35 - (_WORD)v25 + 1;
        }
LABEL_84:
        v42 = v36;
      }
      else
      {
        v42 = 0;
      }
    }
    else
    {
      v33 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_88;
      if (v25)
      {
        v39 = v25;
        if (v25 == (_BYTE *)-256)
          goto LABEL_74;
LABEL_71:
        v40 = 257;
        if ((unint64_t)v39 < v26 && v39)
        {
          while (1)
          {
            v41 = *v39;
            if (v41 > 0x3F)
            {
LABEL_82:
              v40 = 257;
              goto LABEL_86;
            }
            if (!*v39)
              break;
            v39 += v41 + 1;
            if (v25 != (_BYTE *)-256)
              goto LABEL_71;
LABEL_74:
            if (!v39)
              goto LABEL_82;
          }
          v40 = (_WORD)v39 - (_WORD)v25 + 1;
        }
LABEL_86:
        v42 = v40;
      }
      else
      {
        v42 = 0;
      }
    }
    v43 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a2 + 2456) + 8)) >> 16;
    *(_DWORD *)buf = 67110659;
    v105 = v102;
    v106 = 2160;
    v107 = 1752392040;
    v108 = 1040;
    v109 = v42;
    v110 = 2101;
    v111 = v25;
    v112 = 1024;
    v113 = v24;
    v114 = 1024;
    v115 = v43;
    v116 = 2080;
    v117 = v101;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), %u) %s", buf, 0x38u);
    goto LABEL_88;
  }
LABEL_89:
  if (a3 != -65792 && !v12)
  {
    v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: instance->request is NULL %d";
    }
    else
    {
      v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109120;
      v105 = a3;
      v16 = "regservice_callback: instance->request is NULL %d";
    }
    goto LABEL_118;
  }
  if (a3 == -65792)
  {
    if (v12 && *(_BYTE *)(v10 + 24))
    {
      external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
      *(_BYTE *)(v10 + 24) = 0;
      v54 = mDNS_RenameAndReregisterService((unsigned int *)a1, a2, (const char *)(*(_QWORD *)(*(_QWORD *)(v10 + 8) + 120) + 26));
      if (!v54)
        return;
      v55 = v54;
      v56 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          return;
      }
      else
      {
        v56 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          return;
      }
      v78 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
      *(_DWORD *)buf = 67109376;
      v105 = v78;
      v106 = 1024;
      LODWORD(v107) = v55;
      v16 = "[R%u] ERROR: regservice_callback - RenameAndReregisterService returned %d";
      v52 = v56;
      v53 = 14;
      goto LABEL_119;
    }
    goto LABEL_238;
  }
  if (a3 != -65548)
  {
    if (a3)
    {
      if (!v13)
        return;
      if (!GenerateNTDResponse(*(char **)(a2 + 2448), *(_QWORD *)(a2 + 2440), v12, (char **)&v103, (char *)0x41, 2u, a3))
      {
        append_reply(*(_QWORD *)(v10 + 8), v103);
        *(_BYTE *)(v10 + 25) = 1;
        return;
      }
      v58 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          return;
        v59 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
        v60 = *(_BYTE **)(a2 + 2448);
        if (v60)
        {
          v76 = *(_BYTE **)(a2 + 2448);
          if (v60 == (_BYTE *)-256)
          {
LABEL_175:
            while (v76)
            {
              v77 = *v76;
              if (v77 > 0x3F)
                break;
              if (!*v76)
              {
                v82 = (unsigned __int16)((_WORD)v76 - (_WORD)v60 + 1);
                goto LABEL_230;
              }
              v76 += v77 + 1;
              if (v60 != (_BYTE *)-256)
                goto LABEL_174;
            }
          }
          else
          {
LABEL_174:
            if (v76 < v60 + 256)
              goto LABEL_175;
          }
          v82 = 257;
        }
        else
        {
          v82 = 0;
        }
      }
      else
      {
        v58 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        v59 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
        v60 = *(_BYTE **)(a2 + 2448);
        if (v60)
        {
          v61 = *(_BYTE **)(a2 + 2448);
          if (v60 == (_BYTE *)-256)
          {
LABEL_142:
            while (v61)
            {
              v62 = *v61;
              if (v62 > 0x3F)
                break;
              if (!*v61)
              {
                v82 = (unsigned __int16)((_WORD)v61 - (_WORD)v60 + 1);
                goto LABEL_230;
              }
              v61 += v62 + 1;
              if (v60 != (_BYTE *)-256)
                goto LABEL_141;
            }
          }
          else
          {
LABEL_141:
            if (v61 < v60 + 256)
              goto LABEL_142;
          }
          v82 = 257;
        }
        else
        {
          v82 = 0;
        }
      }
LABEL_230:
      *(_DWORD *)buf = 67109891;
      v105 = v59;
      v106 = 2160;
      v107 = 1752392040;
      v108 = 1040;
      v109 = v82;
      v110 = 2101;
      v111 = v60;
      v16 = "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name";
      v52 = v58;
      v53 = 34;
      goto LABEL_119;
    }
    v44 = *(_QWORD *)(v12 + 120);
    if (*(_BYTE *)(v44 + 1614))
    {
      *(_BYTE *)(a2 + 177) = 1;
      *(_BYTE *)(a2 + 1353) = 1;
      *(_BYTE *)(a2 + 2529) = 1;
      *(_BYTE *)(a2 + 3705) = 1;
      for (i = *(uint64_t **)(v10 + 312); i; i = (uint64_t *)*i)
        *((_BYTE *)i + 137) = 1;
    }
    if (!GenerateNTDResponse(*(char **)(a2 + 2448), *(_QWORD *)(a2 + 2440), v12, (char **)&v103, (char *)0x41, 2u, 0))
    {
      append_reply(*(_QWORD *)(v10 + 8), v103);
      *(_BYTE *)(v10 + 25) = 1;
      goto LABEL_202;
    }
    v46 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_202;
      v48 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
      v49 = *(_BYTE **)(a2 + 2448);
      if (v49)
      {
        v50 = *(_BYTE **)(a2 + 2448);
        if (v49 == (_BYTE *)-256)
        {
LABEL_111:
          while (v50)
          {
            v51 = *v50;
            if (v51 > 0x3F)
              break;
            if (!*v50)
            {
              v79 = (unsigned __int16)((_WORD)v50 - (_WORD)v49 + 1);
              goto LABEL_201;
            }
            v50 += v51 + 1;
            if (v49 != (_BYTE *)-256)
              goto LABEL_110;
          }
        }
        else
        {
LABEL_110:
          if (v50 < v49 + 256)
            goto LABEL_111;
        }
        v79 = 257;
      }
      else
      {
        v79 = 0;
      }
    }
    else
    {
      v46 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_202:
        if (!callExternalHelpers(*(_QWORD *)v44, (_BYTE *)(v10 + 28), *(unsigned int *)(*(_QWORD *)(v10 + 8) + 240), v69, v70, v71, v72, v73))
        {
LABEL_221:
          if (*(_BYTE *)(v44 + 1612) && !CountPeerRegistrations(a2))
          {
            v98 = dword_100158E08;
            if (dword_100158E08 <= 1)
              v98 = 1;
            *(_DWORD *)(mDNSStorage[0] + 492) = v98;
          }
          return;
        }
        v83 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            goto LABEL_210;
          v90 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
          *(_DWORD *)buf = 67109120;
          v105 = v90;
        }
        else
        {
          v83 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_210;
          v89 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
          *(_DWORD *)buf = 67109120;
          v105 = v89;
        }
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: calling external_start_advertising_helper()", buf, 8u);
LABEL_210:
        v91 = *(_QWORD *)(v10 + 8);
        v92 = *(_QWORD *)(v91 + 120);
        if (*(_WORD *)(v92 + 24))
        {
          v93 = *(_QWORD *)(v10 + 16);
          v94 = *(_DWORD *)(v91 + 180);
          if (*(_BYTE *)(v10 + 27))
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_start_advertising_helper: external_advertise already set!", v84, v85, v86, v87, v88, v100);
          if (*(_DWORD *)(v92 + 1616))
          {
            v95 = 0;
            v96 = v93 + 8;
            do
            {
              internal_start_advertising_service(v96, *(_DWORD *)(*(_QWORD *)(v10 + 8) + 240), v94);
              ++v95;
              v96 += 1176;
            }
            while (v95 < *(unsigned int *)(v92 + 1616));
          }
          internal_start_advertising_service(v10 + 1528, *(_DWORD *)(*(_QWORD *)(v10 + 8) + 240), v94);
          internal_start_advertising_service(v10 + 2704, *(_DWORD *)(*(_QWORD *)(v10 + 8) + 240), v94);
          internal_start_advertising_service(v10 + 3880, *(_DWORD *)(*(_QWORD *)(v10 + 8) + 240), v94);
          for (j = *(_QWORD **)(v10 + 312); j; j = (_QWORD *)*j)
            internal_start_advertising_service((uint64_t)(j + 3), *(_DWORD *)(*(_QWORD *)(v10 + 8) + 240), v94);
          *(_BYTE *)(v10 + 27) = 1;
        }
        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_start_advertising_helper: Not registering service with port number zero", v84, v85, v86, v87, v88, v100);
        }
        goto LABEL_221;
      }
      v48 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
      v49 = *(_BYTE **)(a2 + 2448);
      if (v49)
      {
        v74 = *(_BYTE **)(a2 + 2448);
        if (v49 == (_BYTE *)-256)
        {
LABEL_165:
          while (v74)
          {
            v75 = *v74;
            if (v75 > 0x3F)
              break;
            if (!*v74)
            {
              v79 = (unsigned __int16)((_WORD)v74 - (_WORD)v49 + 1);
              goto LABEL_201;
            }
            v74 += v75 + 1;
            if (v49 != (_BYTE *)-256)
              goto LABEL_164;
          }
        }
        else
        {
LABEL_164:
          if (v74 < v49 + 256)
            goto LABEL_165;
        }
        v79 = 257;
      }
      else
      {
        v79 = 0;
      }
    }
LABEL_201:
    *(_DWORD *)buf = 67109891;
    v105 = v48;
    v106 = 2160;
    v107 = 1752392040;
    v108 = 1040;
    v109 = v79;
    v110 = 2101;
    v111 = v49;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name", buf, 0x22u);
    goto LABEL_202;
  }
  v57 = *(_QWORD *)(v12 + 120);
  if (!*(_BYTE *)(v57 + 1613))
  {
    if (v13)
    {
      if (GenerateNTDResponse(*(char **)(a2 + 2448), *(_QWORD *)(a2 + 2440), v12, (char **)&v103, (char *)0x41, 2u, 0xFFFEFFF4))
      {
        v63 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v64 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
            v65 = *(_BYTE **)(a2 + 2448);
            if (v65)
            {
              v80 = *(_BYTE **)(a2 + 2448);
              if (v65 == (_BYTE *)-256)
              {
LABEL_191:
                while (v80)
                {
                  v81 = *v80;
                  if (v81 > 0x3F)
                    break;
                  if (!*v80)
                  {
                    v99 = (unsigned __int16)((_WORD)v80 - (_WORD)v65 + 1);
                    goto LABEL_237;
                  }
                  v80 += v81 + 1;
                  if (v65 != (_BYTE *)-256)
                    goto LABEL_190;
                }
              }
              else
              {
LABEL_190:
                if (v80 < v65 + 256)
                  goto LABEL_191;
              }
              v99 = 257;
            }
            else
            {
              v99 = 0;
            }
            goto LABEL_237;
          }
        }
        else
        {
          v63 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v64 = *(_DWORD *)(*(_QWORD *)(v10 + 8) + 192);
            v65 = *(_BYTE **)(a2 + 2448);
            if (v65)
            {
              v66 = *(_BYTE **)(a2 + 2448);
              if (v65 == (_BYTE *)-256)
              {
LABEL_156:
                while (v66)
                {
                  v67 = *v66;
                  if (v67 > 0x3F)
                    break;
                  if (!*v66)
                  {
                    v99 = (unsigned __int16)((_WORD)v66 - (_WORD)v65 + 1);
                    goto LABEL_237;
                  }
                  v66 += v67 + 1;
                  if (v65 != (_BYTE *)-256)
                    goto LABEL_155;
                }
              }
              else
              {
LABEL_155:
                if (v66 < v65 + 256)
                  goto LABEL_156;
              }
              v99 = 257;
            }
            else
            {
              v99 = 0;
            }
LABEL_237:
            *(_DWORD *)buf = 67109891;
            v105 = v64;
            v106 = 2160;
            v107 = 1752392040;
            v108 = 1040;
            v109 = v99;
            v110 = 2101;
            v111 = v65;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name", buf, 0x22u);
          }
        }
      }
      else
      {
        append_reply(*(_QWORD *)(v10 + 8), v103);
        *(_BYTE *)(v10 + 25) = 1;
      }
    }
LABEL_238:
    unlink_and_free_service_instance((_QWORD *)v10, a2, v12, a4, a5, a6, a7, a8);
    return;
  }
  external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(v57 + 1612) && !CountPeerRegistrations(a2))
  {
    IncrementLabelSuffix((unsigned __int8 *)(a1 + 10280), 1);
    mDNS_ConfigChanged(a1);
  }
  else
  {
    if (*(_BYTE *)(v10 + 25))
      SendServiceRemovalNotification(a2);
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0);
  }
}

uint64_t GenerateNTDResponse(char *a1, uint64_t a2, uint64_t a3, char **a4, char *a5, unsigned int a6, unsigned int a7)
{
  uint64_t v14;
  char *v15;
  _BYTE *v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  size_t v25;
  size_t v26;
  unsigned int v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  const char *data;
  unsigned __int16 v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  NSObject *v41;
  char *reply;
  char *v43;
  char *v44;
  size_t v45;
  char *v46;
  size_t v47;
  char *v48;
  char *v49;
  unsigned int v50;
  int v51;
  char v52;
  char v53;
  char __src;
  uint64_t v55;
  _OWORD __s[4];
  unsigned __int8 v57[256];
  unsigned __int8 v58[256];
  _BYTE v59[64];
  unsigned __int16 out[12];

  memset(v59, 0, sizeof(v59));
  memset(v58, 0, sizeof(v58));
  memset(v57, 0, sizeof(v57));
  *a4 = 0;
  if (a1)
  {
    if (!DeconstructServiceName(a1, v59, (uint64_t)v58, v57))
      return 4294901747;
    memset(__s, 0, sizeof(__s));
    bzero(&__src, 0x3F1uLL);
    bzero(&v52, 0x3F1uLL);
    v14 = v59[0];
    if (v59[0] <= 0x3FuLL)
    {
      v15 = &v59[1];
      if (&v59[1] >= &v59[v59[0] + 1])
      {
        v16 = __s;
      }
      else
      {
        v16 = __s;
        do
        {
          v17 = *v15++;
          *v16++ = v17;
          --v14;
        }
        while (v14);
      }
      *v16 = 0;
    }
    v50 = a7;
    ConvertDomainNameToCString_withescape(v58, (unsigned __int8 *)&__src);
    ConvertDomainNameToCString_withescape(v57, (unsigned __int8 *)&v52);
  }
  else
  {
    v50 = a7;
    __s[3] = 0uLL;
    *(_OWORD *)((char *)&__s[2] + 1) = 0uLL;
    *(_OWORD *)((char *)&__s[1] + 1) = 0uLL;
    *(_OWORD *)((char *)__s + 1) = 0uLL;
    bzero(&v55, 0x3F0uLL);
    bzero(&v53, 0x3F0uLL);
    LOBYTE(__s[0]) = 0;
    __src = 0;
    v52 = 0;
  }
  v24 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0, v18, v19, v20, v21, v22);
  v25 = strlen((const char *)__s);
  v26 = strlen(&__src);
  v27 = 0;
  v28 = 0;
  v34 = v25 + v26 + strlen(&v52) + 15;
  if (a1 && *(_BYTE *)(a3 + 282))
  {
    v51 = 0;
    memset(out, 0, 16);
    uuid_generate_random((unsigned __int8 *)out);
    v35 = _mdns_signed_browse_result_create_ex((const unsigned __int8 *)out, (unsigned __int8 *)a1, v24, 0, 0, &v51);
    v28 = (void *)v35;
    if (v35 && !v51)
    {
      *(_QWORD *)out = 0;
      data = mdns_signed_result_get_data(v35, out);
      v37 = out[0];
      v38 = out[0] + 4;
      if (*(_QWORD *)out >= 0x10000uLL)
        v38 = 0;
      v34 += v38;
      if (*(_QWORD *)out >= 0x10000uLL)
        v39 = 0;
      else
        v39 = data;
      if (*(_QWORD *)out >= 0x10000uLL)
        v37 = 0;
      v27 = v37;
      goto LABEL_34;
    }
    v40 = v51;
    v41 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(_QWORD *)&out[2] = v40;
        goto LABEL_32;
      }
    }
    else
    {
      v41 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(_QWORD *)&out[2] = v40;
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "GenerateBrowseReply signed_browse failed %ld", (uint8_t *)out, 0xCu);
      }
    }
    v39 = 0;
    v27 = 0;
    goto LABEL_34;
  }
  v39 = 0;
LABEL_34:
  reply = create_reply(a5, v34, a3, v29, v30, v31, v32, v33);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a6);
  *((_DWORD *)reply + 12) = bswap32(v24);
  *((_DWORD *)reply + 13) = bswap32(v50);
  v43 = reply + 56;
  memcpy(reply + 56, __s, v25 + 1);
  v44 = &v43[v25 + 1];
  v45 = strlen(&__src) + 1;
  memcpy(v44, &__src, v45);
  v46 = &v44[v45];
  v47 = strlen(&v52) + 1;
  memcpy(v46, &v52, v47);
  if (v39)
  {
    v48 = *a4;
    v49 = &v46[v47];
    if (&v46[v47])
    {
      if (v49 <= &v49[v34] && v34 >= (unint64_t)v27 + 4)
      {
        *(_WORD *)v49 = 1792;
        v49[2] = BYTE1(v27);
        v49[3] = v27;
        if (v27)
          memcpy(v49 + 4, v39, v27);
      }
    }
    *((_DWORD *)v48 + 6) |= 2u;
  }
  if (v28)
    os_release(v28);
  return 0;
}

uint64_t DeconstructServiceName(char *a1, _BYTE *a2, uint64_t a3, _BYTE *a4)
{
  int v4;
  unint64_t v5;
  int v6;
  char v7;
  int v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  uint64_t result;
  unsigned int v17;
  char v18;

  v4 = *a1;
  if ((v4 - 64) < 0xFFFFFFC1)
    return 0;
  v5 = (unint64_t)(a1 + 256);
  v6 = v4 + 1;
  do
  {
    v7 = *a1++;
    *a2++ = v7;
    --v6;
  }
  while (v6);
  v8 = *a1;
  if ((v8 - 64) < 0xFFFFFFC1)
    return 0;
  if (a1[1] != 95)
    return 0;
  v9 = 0;
  v10 = v8 + 1;
  do
  {
    *(_BYTE *)(a3 + v9) = a1[v9];
    ++v9;
  }
  while (v10 != (_DWORD)v9);
  v11 = (unsigned __int8 *)&a1[v9];
  if (a1[v9] != 4 || v11[1] != 95)
    return 0;
  v12 = v11[2] & 0xDF;
  if (v12 == 84)
  {
    if ((v11[3] & 0xDF) != 0x43)
      return 0;
  }
  else if (v12 != 85 || (v11[3] & 0xDF) != 0x44)
  {
    return 0;
  }
  if ((v11[4] & 0xDF) != 0x50)
    return 0;
  v13 = 0;
  do
  {
    v14 = *v11++;
    *(_BYTE *)(a3 + v13++ + v9) = v14;
  }
  while ((_DWORD)v13 != 5);
  *(_BYTE *)(a3 + v9 + v13) = 0;
  while (1)
  {
    v15 = *v11;
    if (!*v11)
      break;
    result = 0;
    if (v15 > 0x3F || (unint64_t)&v11[*v11 + 2] >= v5)
      return result;
    v17 = v15 + 1;
    do
    {
      v18 = *v11++;
      *a4++ = v18;
      --v17;
    }
    while (v17);
  }
  *a4 = 0;
  return 1;
}

uint64_t CountPeerRegistrations(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v3;
  _BOOL4 v4;

  v1 = (uint64_t *)xmmword_10015BF10;
  if (!(_QWORD)xmmword_10015BF10)
    return 0;
  v3 = 0;
  do
  {
    if (*((_WORD *)v1 + 6) == 33 && SameDomainNameBytes((_BYTE *)v1[5], *(_BYTE **)(a1 + 2448)))
    {
      v4 = resource_records_have_same_dnssec_rr_category(v1[8], *(_QWORD *)(a1 + 2472))
        && *((unsigned __int16 *)v1 + 6) == *(unsigned __int16 *)(a1 + 2420)
        && *((unsigned __int16 *)v1 + 7) == *(unsigned __int16 *)(a1 + 2422)
        && *((unsigned __int16 *)v1 + 10) == *(unsigned __int16 *)(a1 + 2428)
        && *((_DWORD *)v1 + 7) == *(_DWORD *)(a1 + 2436)
        && SameRDataBody((uint64_t)(v1 + 1), (unsigned __int16 *)(*(_QWORD *)(a1 + 2456) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
      v3 = v3 + !v4;
    }
    v1 = (uint64_t *)*v1;
  }
  while (v1);
  return v3;
}

void ClearProxyRecords(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;

  v6 = *(_QWORD *)(a1 + 12640);
  v7 = &unk_100164000;
  if (v6)
  {
    v8 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "ClearProxyRecords ERROR m->CurrentRecord already set %s", v9, v10, v11, v12, v13, a1 + 47032);
  }
  *(_QWORD *)(a1 + 12640) = a3;
  if (a3)
  {
    v14 = *(_QWORD *)(a1 + 37944);
    v15 = &unk_100158000;
    do
    {
      if (v14 != *(_QWORD *)(a3 + 32)
        || *(unsigned __int16 *)(a2 + 2) != *(unsigned __int16 *)(a3 + 126)
        || *(unsigned __int16 *)(a2 + 4) != *(unsigned __int16 *)(a3 + 128)
        || *(unsigned __int16 *)(a2 + 6) != *(unsigned __int16 *)(a3 + 130)
        || *(unsigned __int8 *)(a2 + 1) == *(unsigned __int8 *)(a3 + 125)
        && *(_DWORD *)(a1 + 64) - *(_DWORD *)(a3 + 164) < 60001)
      {
        goto LABEL_20;
      }
      v16 = (_BYTE *)(a3 + 8);
      if (v15[3304] == 1)
      {
        v31 = *((_QWORD *)v7 + 295);
        v17 = *(_DWORD *)(a1 + 19888);
        GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (_BYTE *)(a1 + 47032));
        v7 = &unk_100164000;
        v15 = (_BYTE *)&unk_100158000;
        LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "ClearProxyRecords: Removing %3d AC %2d %02X H-MAC %.6a I-MAC %.6a %d %d %s", v18, v19, v20, v21, v22, v17);
      }
      if (*v16 == 1)
        *v16 = 8;
      *(_WORD *)(a3 + 130) = 0;
      *(_DWORD *)(a3 + 126) = 0;
      *(_BYTE *)(a3 + 192) = 0;
      mDNS_Deregister_internal(a1, a3, 0);
      v14 = *(_QWORD *)(a1 + 15112);
      if (v14)
      {
        if (v14 != *(_QWORD *)(a1 + 37944))
        {
          mDNSPlatformUpdateProxyList(v14, v23, v24, v25, v26, v27, v28, v29);
          v14 = *(_QWORD *)(a1 + 37944);
        }
      }
      else
      {
        v14 = *(_QWORD *)(a1 + 37944);
      }
      *(_QWORD *)(a1 + 15112) = v14;
      v30 = *(_QWORD *)(a1 + 12640);
      if (v30 == a3)
      {
LABEL_20:
        v30 = *(_QWORD *)a3;
        *(_QWORD *)(a1 + 12640) = *(_QWORD *)a3;
      }
      a3 = v30;
    }
    while (v30);
  }
}

void SendResponses(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t *v9;
  _BYTE *v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int8 v42;
  int v43;
  unsigned __int8 v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t *v60;
  uint64_t v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t i;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t j;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t *v84;
  int v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  _QWORD *v95;
  int v96;
  _BOOL4 v97;
  uint64_t v98;
  _BOOL4 IsValidAnswer;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  unsigned __int16 v103;
  uint64_t v104;
  BOOL v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  uint64_t v110;
  __int16 v111;
  _QWORD *v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  unsigned __int16 v118;
  unint64_t v119;
  uint64_t v120;
  BOOL v121;
  uint64_t v122;
  int v123;
  int v124;
  unint64_t v125;
  uint64_t v126;
  __int16 v127;
  _QWORD *v128;
  char v129;
  uint64_t *v130;
  uint64_t v131;
  unint64_t v132;
  char v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t *v136;
  unsigned __int16 v137;
  uint64_t v138;
  BOOL v139;
  uint64_t v140;
  int v141;
  int v142;
  unint64_t v143;
  unint64_t v144;
  uint64_t v145;
  __int16 v146;
  __int16 v147;
  _QWORD *v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int v158;
  int v159;
  int v160;
  _BYTE *v161;
  _BYTE *v162;
  uint64_t v163;
  unsigned __int16 v164;
  _BYTE *v165;
  _BYTE *v166;
  uint64_t v167;
  unsigned __int16 v168;
  _QWORD *v169;
  uint64_t v170;
  __int16 v171;
  unint64_t v172;
  unsigned __int16 v173;
  _BYTE *v174;
  _BYTE *v175;
  uint64_t v176;
  unsigned __int16 v177;
  _WORD *v178;
  _WORD *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t *v191;
  unsigned __int16 v192;
  uint64_t v193;
  BOOL v194;
  uint64_t v195;
  int v196;
  int v197;
  unint64_t v198;
  uint64_t v199;
  __int16 v200;
  __int16 v201;
  _QWORD *v202;
  NSObject *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  unint64_t v210;
  void **v211;
  BOOL v212;
  uint64_t v213;
  uint64_t v214;
  __int16 v215;
  unsigned int v216;
  _DWORD *v217;
  int *v218;
  int v219;
  unint64_t v220;
  uint64_t v221;
  int v222;
  int v223;
  int v224;
  char v225;
  uint64_t v226;
  const char *v227;
  int v228;
  NSObject *v229;
  const char *v230;
  const char *v231;
  int v232;
  unsigned int v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  NSObject *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  _BYTE *v245;
  uint64_t v246;
  NSObject *v247;
  unsigned int v250;
  uint64_t v251;
  _BYTE *v252;
  __int16 *v253;
  uint64_t *v255;
  uint64_t *v256;
  int v257;
  int v258;
  uint64_t v259;
  int v260;
  _DWORD *v261;
  int v262;
  unsigned __int16 *v263;
  void *v264;
  uint8_t buf[4];
  _BYTE v266[18];
  __int16 v267;
  int v268;
  __int16 v269;
  int v270;
  __int16 v271;
  int v272;
  __int16 v273;
  int v274;
  __int16 v275;
  int v276;
  __int16 v277;
  uint64_t v278;
  uint8_t v279[16];
  unsigned int v280;
  _BYTE v281[10];
  __int16 v282;
  _BYTE *v283;
  _BYTE *v284;
  _WORD *v285;
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  uint64_t v292;
  char v293;
  char v294;
  _BYTE *v295;
  __int128 v296;
  __int128 v297;
  __int128 v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  _BYTE v308[25];
  __int16 v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  _BYTE v313[256];
  _WORD v314[2];
  int v315;
  char v316;
  int v317;

  v8 = *(uint64_t **)(a1 + 12656);
  if (v8)
  {
    while (!*((_BYTE *)v8 + 16))
    {
      v8 = (uint64_t *)*v8;
      if (!v8)
        goto LABEL_4;
    }
    v255 = v8;
  }
  else
  {
LABEL_4:
    v255 = 0;
  }
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64) + 939524096;
  v9 = *(uint64_t **)(a1 + 12616);
  if (!v9)
    goto LABEL_169;
  v10 = (_BYTE *)(a1 + 47032);
  do
  {
    if (*((_BYTE *)v9 + 195))
    {
      *(_OWORD *)v279 = xmmword_1000FFE88;
      *(_DWORD *)buf = 6;
      v11 = *((_DWORD *)v9 + 58);
      v280 = 0;
      *(_DWORD *)&v279[4] = v11;
      *(_OWORD *)v266 = *(_OWORD *)((char *)v9 + 236);
      if (v11)
        SendDelayedUnicastResponse(a1, (int *)v279, v9[26], (uint64_t)a4, a5, a6, a7, a8);
      if (vorr_s8(*(int8x8_t *)((char *)v9 + 236), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)((char *)v9 + 236), *(int8x16_t *)((char *)v9 + 236), 8uLL)))
      {
        SendDelayedUnicastResponse(a1, (int *)buf, v9[26], (uint64_t)a4, a5, a6, a7, a8);
      }
      if (*((_BYTE *)v9 + 195))
      {
        v12 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)v9 + 8, (unsigned __int16 *)(v9[6] + 4), v10);
        LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "SendResponses: ERROR: rr->ImmedUnicast still set: %s", v13, v14, v15, v16, v17, (int)v10);
        *((_BYTE *)v9 + 195) = 0;
      }
    }
    v9 = (uint64_t *)*v9;
  }
  while (v9);
  v18 = *(_QWORD *)(a1 + 12616);
  if (!v18)
    goto LABEL_169;
  v19 = 0;
  v20 = a1;
  do
  {
    v21 = *(_DWORD *)(v18 + 332);
    if (v21)
    {
      v22 = *(_DWORD *)(v20 + 64);
      do
      {
        if ((int)(v22 - v21) < 0)
          break;
        v23 = *(_DWORD *)(v18 + 328) + 1;
        *(_DWORD *)(v18 + 328) = v23;
        v21 += 6000;
        if (v21 <= 1)
          v21 = 1;
        v24 = v23 <= 9 ? v21 : 0;
        *(_DWORD *)(v18 + 332) = v24;
      }
      while (v23 < 0xA);
    }
    v25 = *(unsigned __int8 *)(v18 + 191);
    if (*(_BYTE *)(v18 + 191))
    {
      v26 = *(_DWORD *)(v20 + 64);
      v27 = *(_DWORD *)(v18 + 280);
      if (v26 - (*(_DWORD *)(v18 + 284) + v27) >= 0)
      {
        if (*(_BYTE *)(v18 + 8) == 1)
        {
          if (*(_DWORD *)(v18 + 126))
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v28 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(_QWORD *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "SendResponses: Sending wakeup %2d for %.6a %s", v29, v30, v31, v32, v33, v25 - 3);
              v25 = *(unsigned __int8 *)(v18 + 191);
            }
            SendWakeup(a1, *(_QWORD *)(v18 + 32), v18 + 132, v18 + 138, (v25 - 17) < 2);
            v34 = v18;
            do
            {
              if (*(_BYTE *)(v34 + 8) == 1)
              {
                v35 = *(unsigned __int8 *)(v34 + 191);
                if (*(_BYTE *)(v34 + 191))
                {
                  if (*(_QWORD *)(v34 + 32) == *(_QWORD *)(v18 + 32)
                    && *(unsigned __int16 *)(v34 + 132) == *(unsigned __int16 *)(v18 + 132)
                    && *(unsigned __int16 *)(v34 + 134) == *(unsigned __int16 *)(v18 + 134)
                    && *(unsigned __int16 *)(v34 + 136) == *(unsigned __int16 *)(v18 + 136)
                    && (*(_WORD *)(v34 + 126) || *(_WORD *)(v34 + 128) || *(_WORD *)(v34 + 130)))
                  {
                    if (v35 == 18 && *(_DWORD *)(v34 + 144) == 6)
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v36 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v34 + 8), (unsigned __int16 *)(*(_QWORD *)(v34 + 48) + 4), v10);
                        LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "NDP Announcement %2d Releasing traffic for H-MAC %.6a I-MAC %.6a %s", v37, v38, v39, v40, v41, 15);
                      }
                      SendNDP(a1, 136, 32, v34, (int8x8_t *)(v34 + 148), (int *)(v34 + 132), (uint64_t)&AllHosts_v6, (uint64_t)&AllHosts_v6_Eth);
                      LOBYTE(v35) = *(_BYTE *)(v34 + 191);
                    }
                    *(_DWORD *)(v34 + 284) = *(_DWORD *)(a1 + 64);
                    v42 = v35 - 1;
                    *(_BYTE *)(v34 + 191) = v42;
                    if (v42 <= 3u)
                    {
                      *(_WORD *)(v34 + 130) = 0;
                      *(_DWORD *)(v34 + 126) = 0;
                    }
                  }
                }
              }
              v34 = *(_QWORD *)v34;
            }
            while (v34);
          }
          else
          {
            *(_QWORD *)(v18 + 208) = -1;
          }
LABEL_63:
          v20 = a1;
          goto LABEL_64;
        }
        if (!ResourceRecordIsValidAnswer(v18))
          goto LABEL_63;
        v43 = *(_DWORD *)(v18 + 144);
        if (v43)
        {
          if (!*(_WORD *)(v18 + 126) && !*(_WORD *)(v18 + 128) && !*(_WORD *)(v18 + 130))
            goto LABEL_63;
          v44 = v25 - 1;
          *(_BYTE *)(v18 + 191) = v44;
          *(_DWORD *)(v18 + 280) = 2 * v27;
          *(_DWORD *)(v18 + 284) = v26;
          if (v43 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v51 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(_QWORD *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "NDP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s", v52, v53, v54, v55, v56, v44);
            }
            v20 = a1;
            SendNDP(a1, 136, 32, v18, (int8x8_t *)(v18 + 148), 0, (uint64_t)&AllHosts_v6, (uint64_t)&AllHosts_v6_Eth);
          }
          else
          {
            if (v43 != 4)
              goto LABEL_63;
            if (mDNS_LoggingEnabled == 1)
            {
              v45 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(_QWORD *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, "ARP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s", v46, v47, v48, v49, v50, v44);
            }
            v20 = a1;
            SendARP(a1, 1, v18, v18 + 148, (uint64_t)&zeroEthAddr, v18 + 148, (uint64_t)&onesEthAddr);
          }
        }
        else
        {
          *(_QWORD *)(v18 + 208) = -1;
          if (v19 <= v27)
            v19 = v27;
          v20 = a1;
          if (*(_DWORD *)(v18 + 336))
            *(_DWORD *)(v18 + 336) = 0;
        }
      }
    }
LABEL_64:
    v18 = *(_QWORD *)v18;
  }
  while (v18);
  v57 = *(_QWORD *)(v20 + 12616);
  if (!v57)
    goto LABEL_169;
  do
  {
    if (*(_QWORD *)(v57 + 32) && *(_QWORD *)(v57 + 208)
      || (v58 = *(_DWORD *)(v57 + 280), v58 <= v19)
      && *(_BYTE *)(v57 + 191)
      && (v58 >= 0 ? (v59 = *(_DWORD *)(v57 + 280)) : (v59 = v58 + 1),
          *(_DWORD *)(a1 + 64) + (v59 >> 1) - (v58 + *(_DWORD *)(v57 + 284)) >= 0
       && !*(_DWORD *)(v57 + 144)
       && ResourceRecordIsValidAnswer(v57)))
    {
      *(_QWORD *)(v57 + 208) = -1;
    }
    v57 = *(_QWORD *)v57;
  }
  while (v57);
  v60 = *(uint64_t **)(a1 + 12616);
  if (!v60)
    goto LABEL_169;
  while (2)
  {
    if (!v60[26])
      goto LABEL_115;
    if (*((_WORD *)v60 + 6) != 33)
      goto LABEL_107;
    v61 = *(_QWORD *)(a1 + 12616);
    if (!v61)
      goto LABEL_107;
    while (2)
    {
      v62 = *(unsigned __int16 *)(v61 + 12);
      v63 = v62 == 28 || v62 == 1;
      if (v63
        && ResourceRecordIsValidAnswer(v61)
        && *((_DWORD *)v60 + 72) - *(_DWORD *)(v61 + 288) >= 0
        && *((_DWORD *)v60 + 7) == *(_DWORD *)(v61 + 24)
        && SameDomainNameBytes((_BYTE *)(v60[6] + 10), *(_BYTE **)(v61 + 40)))
      {
        v64 = v60[26];
        v65 = *(_QWORD *)(v61 + 32);
        if (v64 == -1)
          goto LABEL_104;
        if (v64 == v65)
        {
          v65 = v60[26];
LABEL_104:
          *(_QWORD *)(v61 + 216) = v65;
        }
      }
      v61 = *(_QWORD *)v61;
      if (v61)
        continue;
      break;
    }
    if (v60[26])
    {
LABEL_107:
      if (*((_BYTE *)v60 + 8) == 8
        && *((_WORD *)v60 + 6) == 12
        && ResourceRecordIsValidAnswer(a1 + 11440)
        && SameDomainLabelPointer(v60[6] + 4, *(_QWORD *)(a1 + 11480)))
      {
        if (*(_QWORD *)(a1 + 11648))
          v66 = -1;
        else
          v66 = v60[26];
        *(_QWORD *)(a1 + 11648) = v66;
      }
    }
LABEL_115:
    v60 = (uint64_t *)*v60;
    if (v60)
      continue;
    break;
  }
  v67 = *(_QWORD *)(a1 + 12616);
  if (v67)
  {
    while (2)
    {
      if ((*(_BYTE *)(v67 + 8) & 0x32) == 0)
        goto LABEL_151;
      v68 = (uint64_t *)(v67 + 208);
      if (*(_QWORD *)(v67 + 208))
      {
        for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
        {
          if ((*(_BYTE *)(i + 8) & 0x32) != 0 && ResourceRecordIsValidAnswer(i))
          {
            v70 = *(_QWORD *)(i + 208);
            if (v70 != -1
              && v70 != *v68
              && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(v67 + 12)
              && SameResourceRecordNameClassInterface(i, v67, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              v71 = *v68;
              if (*v68 == -1)
                goto LABEL_129;
              v72 = *(_QWORD *)(i + 32);
              if (v72)
              {
                if (v72 == v71)
                  goto LABEL_129;
              }
              else if (mDNSPlatformValidRecordForInterface(i, v71, a3, (uint64_t)a4, a5, a6, a7, a8))
              {
LABEL_129:
                if (*(_QWORD *)(i + 208))
                  v73 = &mDNSInterfaceMark;
                else
                  v73 = (_QWORD *)(v67 + 208);
                *(_QWORD *)(i + 208) = *v73;
              }
            }
          }
        }
LABEL_151:
        v67 = *(_QWORD *)v67;
        if (v67)
          continue;
        for (j = *(_QWORD *)(a1 + 12616); j; j = *(_QWORD *)j)
        {
          v78 = *(_QWORD *)(j + 208);
          if (v78)
          {
            if (v78 == -1)
            {
              if (v255)
              {
                v79 = *(_QWORD *)(j + 32);
                if (!v79)
                  v79 = v255[444];
              }
              else
              {
                v79 = 0;
              }
              *(_QWORD *)(j + 216) = 0;
              *(_QWORD *)(j + 224) = v79;
              v80 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(j + 288) = v80;
              *(_QWORD *)(j + 296) = -1;
              *(_BYTE *)(j + 189) = 0;
              if (*(_BYTE *)(j + 191))
              {
                v81 = *(_DWORD *)(j + 280);
                v82 = v81 >= 0 ? *(_DWORD *)(j + 280) : v81 + 1;
                if (v80 + (v82 >> 1) - (v81 + *(_DWORD *)(j + 284)) >= 0)
                {
                  --*(_BYTE *)(j + 191);
                  if (*(_BYTE *)(j + 8) != 1)
                    *(_DWORD *)(j + 280) = 2 * v81;
                  *(_DWORD *)(j + 284) = v80;
                }
              }
            }
            else
            {
              *(_QWORD *)(j + 216) = 0;
              *(_QWORD *)(j + 224) = v78;
              *(_DWORD *)(j + 288) = *(_DWORD *)(a1 + 64);
              *(_QWORD *)(j + 296) = v78;
            }
          }
          SetNextAnnounceProbeTime(a1, j);
        }
        goto LABEL_169;
      }
      break;
    }
    if (!*(_QWORD *)(v67 + 216))
      goto LABEL_151;
    v74 = *(_QWORD *)(a1 + 12616);
    if (!v74)
      goto LABEL_151;
    while (2)
    {
      if ((*(_BYTE *)(v74 + 8) & 0x32) != 0
        && ResourceRecordIsValidAnswer(v74)
        && *(_QWORD *)(v74 + 216) != *(_QWORD *)(v67 + 216)
        && *(unsigned __int16 *)(v74 + 12) == *(unsigned __int16 *)(v67 + 12)
        && SameResourceRecordNameClassInterface(v74, v67, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        v75 = *(_QWORD *)(v67 + 216);
        v76 = *(_QWORD *)(v74 + 32);
        if (v76)
        {
          if (v76 == v75)
LABEL_149:
            *(_QWORD *)(v74 + 216) = *(_QWORD *)(v67 + 216);
        }
        else if (mDNSPlatformValidRecordForInterface(v74, v75, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          goto LABEL_149;
        }
      }
      v74 = *(_QWORD *)v74;
      if (!v74)
        goto LABEL_151;
      continue;
    }
  }
LABEL_169:
  v83 = a1;
  v84 = v255;
  if (!v255)
    goto LABEL_448;
  v257 = 0;
  v259 = a1 + 28972;
  v263 = (unsigned __int16 *)(a1 + 28966);
  v261 = (_DWORD *)(a1 + 28960);
  v253 = (__int16 *)(a1 + 28970);
  v252 = (_BYTE *)(a1 + 47032);
  while (2)
  {
    v260 = mDNS_McastTracingEnabled;
    if (mDNS_McastTracingEnabled)
      v85 = 20;
    else
      v85 = 0;
    v258 = v85;
    v264 = 0;
    *v261 = 8650752;
    *(_QWORD *)(a1 + 28964) = 0;
    v86 = *(_QWORD *)(v83 + 12616);
    v256 = v84;
    if (!v86)
    {
      LOWORD(v262) = 0;
      v87 = a1 + 28972;
      goto LABEL_384;
    }
    v262 = 0;
    v87 = a1 + 28972;
    while (2)
    {
      v88 = *(_QWORD *)(v86 + 224);
      v89 = v84[444];
      if (v88 == v89)
      {
        if (*(_QWORD *)(v86 + 32))
          goto LABEL_180;
        if (mDNSPlatformValidRecordForInterface(v86, v88, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          v88 = *(_QWORD *)(v86 + 224);
          v89 = v84[444];
          goto LABEL_177;
        }
        v113 = v87;
        goto LABEL_255;
      }
LABEL_177:
      if (v88 == v89)
      {
LABEL_180:
        v90 = v87;
        v91 = *(unsigned __int8 *)(v86 + 8);
        v92 = *(_QWORD *)(v86 + 48);
        v93 = *(unsigned __int16 *)(v86 + 20);
        if (v91 == 1)
        {
          v94 = 0;
          v95 = (_QWORD *)(v86 + 304);
          goto LABEL_217;
        }
        v96 = *(unsigned __int8 *)(v83 + 141);
        if ((*(_BYTE *)(v86 + 123) & 1) != 0)
        {
LABEL_185:
          v97 = v96 != 0;
        }
        else
        {
          if (v96 == 2)
          {
            v96 = *((unsigned __int8 *)v84 + 3675);
            goto LABEL_185;
          }
          v97 = 0;
        }
        v98 = *(_QWORD *)(v86 + 304);
        if (!v98 || v97)
          goto LABEL_215;
        IsValidAnswer = ResourceRecordIsValidAnswer(v86);
        if (v91 != 8)
          goto LABEL_214;
        v87 = v90;
        if (!IsValidAnswer || !*(_BYTE *)(v86 + 192))
          goto LABEL_214;
        v102 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v86, (uint64_t **)&v264);
        v103 = v262;
        if (v102)
          v103 = v262 + 1;
        if (*v263 || *(_WORD *)(a1 + 28968) || *v253)
          v104 = 1440;
        else
          v104 = 8940;
        if (v103)
          v105 = v260 == 0;
        else
          v105 = 0;
        v106 = v259 + v104;
        v107 = v258 + 14 * v103;
        if (v105)
          v108 = 11;
        else
          v108 = 0;
        v109 = PutResourceRecordTTLWithLimit((unint64_t)v261, v90, v263, v86 + 8, 0, v106 - (v107 + v108), v100, v101);
        v90 = v109;
        if (!v102)
        {
          if (v109)
            goto LABEL_213;
          goto LABEL_253;
        }
        if (!v109)
          goto LABEL_253;
        v110 = *(_QWORD *)(v86 + 40);
        v111 = *v263;
        v112 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
        if (!v112)
          goto LABEL_478;
        ++v262;
        *((_WORD *)v102 + 4) = v111 - 1;
        v112[1] = v102;
        v112[2] = v110;
        *v112 = v264;
        v264 = v112;
LABEL_213:
        *(_BYTE *)(v86 + 192) = 0;
        v98 = *(_QWORD *)(v86 + 304);
LABEL_214:
        SetNewRData(v86 + 8, v98, *(unsigned __int16 *)(v86 + 312), (uint64_t)a4, a5, a6, a7, a8);
        LOBYTE(v91) = *(_BYTE *)(v86 + 8);
LABEL_215:
        v94 = !v97;
        v95 = (_QWORD *)(v86 + 304);
        if ((v91 & 0x32) != 0)
          *(_WORD *)(v86 + 14) |= 0x8000u;
LABEL_217:
        v114 = v90;
        v117 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v86, (uint64_t **)&v264);
        v118 = v262;
        if (v117)
          v118 = v262 + 1;
        if (v94)
          v119 = *(unsigned int *)(v86 + 16);
        else
          v119 = 0;
        if (*v263 || *(_WORD *)(a1 + 28968) || *v253)
          v120 = 1440;
        else
          v120 = 8940;
        if (v118)
          v121 = v260 == 0;
        else
          v121 = 0;
        v122 = v259 + v120;
        v123 = v258 + 14 * v118;
        if (v121)
          v124 = 11;
        else
          v124 = 0;
        v125 = PutResourceRecordTTLWithLimit((unint64_t)v261, v90, v263, v86 + 8, v119, v122 - (v123 + v124), v115, v116);
        v113 = v125;
        if (v117)
        {
          if (v125)
          {
            v126 = *(_QWORD *)(v86 + 40);
            v127 = *v263;
            v128 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v128)
LABEL_478:
              __break(1u);
            ++v262;
            *((_WORD *)v117 + 4) = v127 - 1;
            v128[1] = v117;
            v128[2] = v126;
            *v128 = v264;
            v264 = v128;
            *(_WORD *)(v86 + 14) &= ~0x8000u;
            v83 = a1;
LABEL_237:
            v129 = 0;
            *(_BYTE *)(v86 + 192) = v94;
LABEL_240:
            if (*v95 && v94)
              SetNewRData(v86 + 8, v92, v93, (uint64_t)a4, a5, a6, a7, a8);
            v84 = v256;
            if (!v257 && v94 && (*(_BYTE *)(v86 + 8) & 0x30) != 0 && !*(_QWORD *)(v86 + 200))
            {
              *(_QWORD *)(v86 + 200) = -1;
              if ((v129 & 1) == 0)
                goto LABEL_248;
            }
            else if ((v129 & 1) == 0)
            {
LABEL_248:
              if (*(_QWORD *)(v86 + 208) != -1 || *(_QWORD *)(v86 + 32))
              {
                v130 = 0;
                goto LABEL_251;
              }
LABEL_255:
              v130 = (uint64_t *)*v84;
              if (*v84)
              {
                while (!*((_BYTE *)v130 + 16))
                {
                  v130 = (uint64_t *)*v130;
                  if (!v130)
                    goto LABEL_251;
                }
                v130 = (uint64_t *)v130[444];
              }
LABEL_251:
              *(_QWORD *)(v86 + 224) = v130;
            }
            v87 = v113;
            goto LABEL_253;
          }
          *(_WORD *)(v86 + 14) &= ~0x8000u;
        }
        else
        {
          *(_WORD *)(v86 + 14) &= ~0x8000u;
          if (v125)
            goto LABEL_237;
        }
        v113 = v114;
        v129 = 1;
        goto LABEL_240;
      }
LABEL_253:
      v86 = *(_QWORD *)v86;
      if (v86)
        continue;
      break;
    }
    v131 = *(_QWORD *)(v83 + 12616);
    v132 = v87;
    if (v131)
    {
      while (2)
      {
        if (*(_QWORD *)(v131 + 216) == v84[444] && ResourceRecordIsValidAnswer(v131))
        {
          if (*v263)
            goto LABEL_270;
          if ((*(_BYTE *)(v131 + 8) & 0x32) != 0 && (v149 = *(_QWORD *)(v83 + 12616)) != 0)
          {
            while (*(_DWORD *)(v149 + 288) != *(_DWORD *)(v83 + 64)
                 || *(_QWORD *)(v149 + 296) != v84[444]
                 || *(unsigned __int16 *)(v149 + 12) != *(unsigned __int16 *)(v131 + 12)
                 || !SameResourceRecordNameClassInterface(v149, v131, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              v149 = *(_QWORD *)v149;
              if (!v149)
                goto LABEL_300;
            }
LABEL_270:
            if (v87)
            {
              v133 = *(_BYTE *)(v131 + 8);
              if (!v257 && (*(_BYTE *)(v131 + 8) & 0x30) != 0 && !*(_QWORD *)(v131 + 200))
                *(_QWORD *)(v131 + 200) = -1;
              if ((v133 & 0x32) != 0)
                *(_WORD *)(v131 + 14) |= 0x8000u;
              v136 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v131, (uint64_t **)&v264);
              v137 = v262;
              if (v136)
                v137 = v262 + 1;
              if (*v263 || *(_WORD *)(a1 + 28968) || *v253)
                v138 = 1440;
              else
                v138 = 8940;
              if (v137)
                v139 = v260 == 0;
              else
                v139 = 0;
              v140 = v259 + v138;
              v141 = v258 + 14 * v137;
              if (v139)
                v142 = 11;
              else
                v142 = 0;
              v143 = PutResourceRecordTTLWithLimit((unint64_t)v261, v87, v253, v131 + 8, *(unsigned int *)(v131 + 16), v140 - (v141 + v142), v134, v135);
              v87 = v143;
              if (v136)
              {
                if (v143)
                {
                  v144 = v143;
                  v145 = *(_QWORD *)(v131 + 40);
                  v146 = *v263;
                  v147 = *v253;
                  v148 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
                  if (!v148)
                    goto LABEL_478;
                  LOWORD(v262) = v262 + 1;
                  *((_WORD *)v136 + 4) = v146 + v147 - 1;
                  v148[1] = v136;
                  v148[2] = v145;
                  *v148 = v264;
                  v264 = v148;
                  *(_WORD *)(v131 + 14) &= ~0x8000u;
                  v83 = a1;
                  v87 = v144;
LABEL_302:
                  *(_QWORD *)(v131 + 216) = 0;
                  *(_BYTE *)(v131 + 192) = 1;
                  *(_DWORD *)(v131 + 288) = *(_DWORD *)(v83 + 64);
                  *(_QWORD *)(v131 + 296) = v84[444];
                  v132 = v87;
                }
                else
                {
                  *(_WORD *)(v131 + 14) &= ~0x8000u;
                }
              }
              else
              {
                *(_WORD *)(v131 + 14) &= ~0x8000u;
                if (v143)
                  goto LABEL_302;
              }
            }
          }
          else
          {
LABEL_300:
            *(_QWORD *)(v131 + 216) = 0;
          }
        }
        v131 = *(_QWORD *)v131;
        if (v131)
          continue;
        break;
      }
      v150 = *(_QWORD *)(v83 + 12616);
      v151 = v87;
      v87 = v132;
      if (v150)
      {
        while (2)
        {
          v152 = *(_QWORD *)(v150 + 200);
          if (v152 == -1 || v152 == v84[444])
          {
            bzero(v279, 0x498uLL);
            v158 = *(_DWORD *)(v150 + 16);
            if (v158)
              v159 = *(_DWORD *)(v150 + 16);
            else
              v159 = 4500;
            v279[8] = 2;
            if (v158 <= 0x20C49B)
              v160 = v159;
            else
              v160 = 2147483;
            strcpy((char *)&v279[12], "/");
            v280 = v160;
            v314[0] = 264;
            v284 = v313;
            v285 = v314;
            v293 = 0;
            v294 = 0;
            v286 = 0u;
            v287 = 0u;
            v288 = 0u;
            v289 = 0u;
            v290 = 0u;
            v291 = 0u;
            v292 = 0;
            v295 = v313;
            v309 = 0;
            v311 = 0;
            v312 = 0;
            v310 = 0;
            v313[0] = 0;
            v296 = 0u;
            v297 = 0u;
            v298 = 0u;
            v299 = 0u;
            v300 = 0u;
            v301 = 0u;
            v302 = 0u;
            v303 = 0u;
            v304 = 0u;
            v305 = 0u;
            v306 = 0u;
            v307 = 0u;
            memset(v308, 0, sizeof(v308));
            v161 = *(_BYTE **)(v150 + 40);
            v162 = v161;
            *(_WORD *)&v279[14] = -32767;
            if (v161 == (_BYTE *)-256)
            {
LABEL_316:
              while (v162)
              {
                v163 = *v162;
                if (v163 > 0x3F)
                  break;
                if (!*v162)
                {
                  v164 = (_WORD)v162 - (_WORD)v161 + 1;
                  if (v164 <= 0x100u)
                    memcpy(v313, v161, v164);
                  break;
                }
                v162 += v163 + 1;
                if (v161 != (_BYTE *)-256)
                  goto LABEL_315;
              }
            }
            else
            {
LABEL_315:
              if (v162 < v161 + 256)
                goto LABEL_316;
            }
            v165 = *(_BYTE **)(v150 + 40);
            v166 = v165;
            if (v165 != (_BYTE *)-256)
            {
LABEL_324:
              if (v166 < v165 + 256)
                goto LABEL_325;
LABEL_330:
              v168 = 291;
              *(_WORD *)v281 = 291;
              goto LABEL_331;
            }
            while (1)
            {
LABEL_325:
              if (!v166)
                goto LABEL_330;
              v167 = *v166;
              if (v167 > 0x3F)
                goto LABEL_330;
              if (!*v166)
                break;
              v166 += v167 + 1;
              if (v165 != (_BYTE *)-256)
                goto LABEL_324;
            }
            v171 = (_WORD)v166 - (_WORD)v165;
            v168 = (_WORD)v166 - (_WORD)v165 + 35;
            *(_WORD *)v281 = v168;
            if (v168 > 0x108u)
            {
LABEL_331:
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendResponses: not enough space (%d)  in authrecord for nsec", v153, v154, v155, v156, v157, v168);
            }
            else
            {
              v172 = v87;
              v173 = v171 + 1;
              bzero(&v315, v168);
              v174 = *(_BYTE **)(v150 + 40);
              v175 = v174;
              if (v174 == (_BYTE *)-256)
              {
LABEL_346:
                while (v175)
                {
                  v176 = *v175;
                  if (v176 > 0x3F)
                    break;
                  if (!*v175)
                  {
                    v177 = (_WORD)v175 - (_WORD)v174 + 1;
                    if (v177 > 0x100u)
                      break;
                    memcpy(&v315, v174, v177);
                    goto LABEL_354;
                  }
                  v175 += v176 + 1;
                  if (v174 != (_BYTE *)-256)
                    goto LABEL_345;
                }
              }
              else
              {
LABEL_345:
                if (v175 < v174 + 256)
                  goto LABEL_346;
              }
              LOBYTE(v315) = 0;
LABEL_354:
              v178 = (_WORD *)((char *)&v315 + v173);
              *v178 = 0x2000;
              v179 = v178 + 1;
              v180 = *(_QWORD *)(v83 + 12616);
              if (v180)
              {
                while (1)
                {
                  if (ResourceRecordIsValidAnswer(v180)
                    && SameResourceRecordNameClassInterface(v180, v150, v181, v182, v183, v184, v185, v186))
                  {
                    v187 = *(unsigned __int16 *)(v180 + 12);
                    if (v187 >= 0xFF)
                    {
                      v203 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v180 + 8), (unsigned __int16 *)(*(_QWORD *)(v180 + 48) + 4), v252);
                      LogMsgWithLevel(v203, OS_LOG_TYPE_DEFAULT, "SendResponses: Can't create NSEC for record %s", v204, v205, v206, v207, v208, (int)v252);
                      v87 = v172;
                      v151 = v172;
                      goto LABEL_332;
                    }
                    *((_BYTE *)v179 + (v187 >> 3)) |= 0x80u >> (v187 & 7);
                  }
                  v180 = *(_QWORD *)v180;
                  if (!v180)
                  {
                    v188 = *(uint64_t **)(v83 + 12616);
                    goto LABEL_362;
                  }
                }
              }
              v188 = 0;
LABEL_362:
              v191 = UnsafeBufferPointer(v188, v150, (uint64_t **)&v264);
              v192 = v262;
              if (v191)
                v192 = v262 + 1;
              v87 = v172;
              if (*v263 || *(_WORD *)(a1 + 28968) || *v253)
                v193 = 1440;
              else
                v193 = 8940;
              if (v192)
                v194 = v260 == 0;
              else
                v194 = 0;
              v195 = v259 + v193;
              v196 = v258 + 14 * v192;
              if (v194)
                v197 = 11;
              else
                v197 = 0;
              v198 = PutResourceRecordTTLWithLimit((unint64_t)v261, v172, v253, (uint64_t)&v279[8], v280, v195 - (v196 + v197), v189, v190);
              v151 = v198;
              if (v191 && v198)
              {
                v199 = *(_QWORD *)(v150 + 40);
                v200 = *v263;
                v201 = *v253;
                v202 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
                if (!v202)
                  goto LABEL_478;
                LOWORD(v262) = v262 + 1;
                *((_WORD *)v191 + 4) = v200 + v201 - 1;
                v202[1] = v191;
                v202[2] = v199;
                *v202 = v264;
                v264 = v202;
                v83 = a1;
                v87 = v172;
              }
              if (v151)
                v87 = v151;
            }
LABEL_332:
            if (v151 || *(_QWORD *)(v150 + 200) == -1)
            {
              *(_QWORD *)(v150 + 200) = 0;
              v169 = *(_QWORD **)v150;
              if (*(_QWORD *)v150)
              {
                do
                {
                  if (SameResourceRecordNameClassInterface((uint64_t)v169, v150, a3, (uint64_t)a4, a5, a6, a7, a8))
                  {
                    v170 = v169[25];
                    if (v170 == -1 || v170 == v84[444])
                      v169[25] = 0;
                  }
                  v169 = (_QWORD *)*v169;
                }
                while (v169);
              }
            }
          }
          v150 = *(_QWORD *)v150;
          if (!v150)
            break;
          continue;
        }
      }
    }
LABEL_384:
    v209 = *v263;
    if (!*v263 && !*v253)
    {
      do
        v84 = (uint64_t *)*v84;
      while (v84 && !*((_BYTE *)v84 + 16));
      v257 = 0;
      goto LABEL_442;
    }
    v210 = v87;
    v211 = (void **)v264;
    if (v260)
      v212 = 0;
    else
      v212 = v264 == 0;
    if (v212)
      goto LABEL_432;
    bzero(v279, 0x498uLL);
    v279[8] = 32;
    strcpy((char *)&v279[12], ")");
    v280 = 4500;
    v314[0] = 264;
    v284 = v313;
    v285 = v314;
    v293 = 0;
    v294 = 0;
    v286 = 0u;
    v287 = 0u;
    v288 = 0u;
    v289 = 0u;
    v290 = 0u;
    v291 = 0u;
    v292 = 0;
    v295 = v313;
    v309 = 0;
    v311 = 0;
    v312 = 0;
    v310 = 0;
    v313[0] = 0;
    v296 = 0u;
    v297 = 0u;
    v298 = 0u;
    v299 = 0u;
    v300 = 0u;
    v301 = 0u;
    v302 = 0u;
    v303 = 0u;
    v304 = 0u;
    v305 = 0u;
    v306 = 0u;
    v307 = 0u;
    memset(v308, 0, sizeof(v308));
    *(_WORD *)&v279[14] = 1440;
    *(_WORD *)&v281[2] = 0;
    if (v260)
    {
      v316 = *(_BYTE *)(a1 + 12676);
      v317 = -1735965292;
      *(_DWORD *)v281 = 1572888;
      v315 = 392681;
      v215 = 48;
      v216 = 1;
      if (v211)
        goto LABEL_392;
LABEL_398:
      v220 = 4500;
      if (!v209)
        goto LABEL_399;
LABEL_401:
      v221 = 1440;
    }
    else
    {
      v216 = 0;
      v215 = 24;
      if (!v211)
        goto LABEL_398;
LABEL_392:
      *(_WORD *)v281 = v215;
      *(_WORD *)&v281[2] = v215;
      v217 = v211[1];
      v218 = &v315 + 6 * v216;
      v218[2] = v217[1];
      *((_WORD *)v218 + 6) = *((_WORD *)v217 + 4);
      v219 = *v217;
      *v218 = 720362;
      v218[1] = v219;
      v264 = *v211;
      free(v211);
      v220 = v280;
      if (*v263)
        goto LABEL_401;
LABEL_399:
      if (*(_WORD *)(a1 + 28968) || *v253)
        goto LABEL_401;
      v221 = 8940;
    }
    a4 = (char *)PutResourceRecordTTLWithLimit((unint64_t)v261, v87, v253, (uint64_t)&v279[8], v220, v259 + v221, v213, v214);
    if (a4 && v264)
      a4 = AddTSRROptsToMessage(&v264, (unint64_t)v261, (_WORD *)(v87 + 9), a4, a1 + 37912, a6, a7, a8);
    if (a4)
      goto LABEL_431;
    v222 = *(unsigned __int16 *)(a1 + 28966);
    v223 = *(unsigned __int16 *)(a1 + 28968);
    v224 = *(unsigned __int16 *)(a1 + 28970);
    v225 = gSensitiveLoggingEnabled;
    v226 = mDNSLogCategory_mDNS;
    if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
      v225 = 0;
    if (v223 + v222 + v224 != 1)
    {
      if ((v225 & 1) != 0)
      {
        v226 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_430;
        if (v260)
          v231 = "TRACER";
        else
          v231 = "";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          goto LABEL_430;
        if (v260)
          v231 = "TRACER";
        else
          v231 = "";
      }
      v232 = *(unsigned __int16 *)(a1 + 28964);
      GetRRDisplayString_rdb(&v279[8], v285 + 2, v252);
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)v266 = "";
      *(_WORD *)&v266[8] = 2080;
      *(_QWORD *)&v266[10] = v231;
      v267 = 1024;
      v268 = (unsigned __int16)v262;
      v83 = a1;
      v269 = 1024;
      v270 = v232;
      v271 = 1024;
      v272 = v222;
      v273 = 1024;
      v274 = v223;
      v275 = 1024;
      v276 = v224;
      v277 = 2080;
      v278 = a1 + 47032;
      v229 = v226;
      v230 = "SendResponses: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
      goto LABEL_429;
    }
    if ((v225 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        goto LABEL_430;
      if (v260)
        v227 = "TRACER";
      else
        v227 = "";
LABEL_414:
      v228 = *(unsigned __int16 *)(a1 + 28964);
      GetRRDisplayString_rdb(&v279[8], v285 + 2, v252);
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)v266 = "";
      *(_WORD *)&v266[8] = 2080;
      *(_QWORD *)&v266[10] = v227;
      v267 = 1024;
      v268 = (unsigned __int16)v262;
      v83 = a1;
      v269 = 1024;
      v270 = v228;
      v271 = 1024;
      v272 = v222;
      v273 = 1024;
      v274 = v223;
      v275 = 1024;
      v276 = v224;
      v277 = 2080;
      v278 = a1 + 47032;
      v229 = v226;
      v230 = "SendResponses: No space in packet for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
LABEL_429:
      _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, v230, buf, 0x3Eu);
      goto LABEL_430;
    }
    v226 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
    {
      if (v260)
        v227 = "TRACER";
      else
        v227 = "";
      goto LABEL_414;
    }
LABEL_430:
    a4 = (char *)v210;
    v84 = v256;
LABEL_431:
    v210 = (unint64_t)a4;
LABEL_432:
    if (*((_BYTE *)v84 + 17))
      mDNSSendDNSMessage(v83, (unint64_t)v261, v210, v84[444], 0, 0, AllDNSLinkGroup_v4, 0xE914u, 0, 0);
    if (*((_BYTE *)v84 + 18))
      mDNSSendDNSMessage(v83, (unint64_t)v261, v210, v84[444], 0, 0, &AllDNSLinkGroup_v6, 0xE914u, 0, 0);
    if (!*(_DWORD *)(v83 + 84) && !*(_DWORD *)(v83 + 76))
    {
      v233 = *(_DWORD *)(v83 + 64) + 100;
      if (v233 <= 1)
        v233 = 1;
      *(_DWORD *)(v83 + 84) = v233;
    }
    if (++v257 >= 1000)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendResponses exceeded loop limit %d: giving up", (uint64_t)a4, a5, a6, a7, a8, v257);
      break;
    }
LABEL_442:
    v234 = v264;
    if (v264)
    {
      do
      {
        v235 = (_QWORD *)*v234;
        free(v234);
        v234 = v235;
      }
      while (v235);
    }
    if (v84)
      continue;
    break;
  }
LABEL_448:
  v236 = *(_QWORD *)(v83 + 12640);
  if (v236)
  {
    v237 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v236 + 8), (unsigned __int16 *)(*(_QWORD *)(v236 + 48) + 4), (_BYTE *)(a1 + 47032));
    v83 = a1;
    LogMsgWithLevel(v237, OS_LOG_TYPE_DEFAULT, "SendResponses ERROR m->CurrentRecord already set %s", v238, v239, v240, v241, v242, a1 + 47032);
  }
  v243 = *(_QWORD *)(v83 + 12616);
  *(_QWORD *)(v83 + 12640) = v243;
  if (v243)
  {
    v244 = v83;
    v245 = (_BYTE *)(v83 + 47032);
    while (2)
    {
      *(_QWORD *)(v244 + 12640) = *(_QWORD *)v243;
      v246 = *(_QWORD *)(v243 + 224);
      if (!v246)
        goto LABEL_464;
      if ((*(_DWORD *)(v243 + 172) & 0xFFFFFFFE) != 4)
      {
        v247 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
            goto LABEL_462;
        }
        else
        {
          v247 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
          {
LABEL_462:
            v250 = *(unsigned __int8 *)(v243 + 8);
            v251 = *(_QWORD *)(v243 + 32);
            GetRRDisplayString_rdb((unsigned __int8 *)(v243 + 8), (unsigned __int16 *)(*(_QWORD *)(v243 + 48) + 4), v245);
            *(_DWORD *)v279 = 67110147;
            *(_DWORD *)&v279[4] = v246;
            *(_WORD *)&v279[8] = 1024;
            *(_DWORD *)&v279[10] = v251;
            *(_WORD *)&v279[14] = 1024;
            v280 = v250;
            strcpy(v281, "p\bhash");
            v281[7] = 0;
            *(_WORD *)&v281[8] = 0;
            v282 = 2085;
            v283 = v245;
            _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_INFO, "SendResponses: No active interface %d to send: %d %02X %{sensitive, mask.hash}s", v279, 0x28u);
          }
        }
      }
      *(_QWORD *)(v243 + 224) = 0;
LABEL_464:
      if (*(_QWORD *)(v243 + 208) || *(_BYTE *)(v243 + 8) == 1)
      {
        if (*(_QWORD *)(v243 + 304))
          CompleteRDataUpdate(a1, v243, a3, (uint64_t)a4, a5, a6, a7, a8);
        if (*(_BYTE *)(v243 + 8) == 1 && !*(_BYTE *)(v243 + 191))
        {
          if (*(_QWORD *)(v243 + 32) || *(_BYTE *)(v243 + 122) || IsLocalDomain(*(_BYTE **)(v243 + 40)))
            CompleteDeregistration(a1, v243);
        }
        else
        {
          *(_QWORD *)(v243 + 208) = 0;
          *(_BYTE *)(v243 + 195) = 0;
          *(_QWORD *)(v243 + 232) = 0;
          *(_QWORD *)(v243 + 240) = 0;
          *(_DWORD *)(v243 + 248) = 0;
        }
      }
      v244 = a1;
      v243 = *(_QWORD *)(a1 + 12640);
      if (!v243)
        return;
      continue;
    }
  }
}

void AnswerAllLocalQuestionsWithLocalAuthRecord(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  NSObject *v12;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v17;
  uint64_t v18;
  int v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  const char *v32;

  v11 = a1[26];
  if (v11)
  {
    v12 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_28;
      v14 = (_BYTE *)(v11 + 376);
      if (v11 == -632)
      {
LABEL_10:
        while (v14)
        {
          v15 = *v14;
          if (v15 > 0x3F)
            break;
          if (!*v14)
          {
            v19 = (unsigned __int16)((_WORD)v14 - (v11 + 376) + 1);
            goto LABEL_27;
          }
          v14 += v15 + 1;
          if (v11 != -632)
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        if ((unint64_t)v14 < v11 + 632)
          goto LABEL_10;
      }
      v19 = 257;
      goto LABEL_27;
    }
    v12 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v17 = (_BYTE *)(v11 + 376);
      if (v11 == -632)
      {
LABEL_18:
        while (v17)
        {
          v18 = *v17;
          if (v18 > 0x3F)
            break;
          if (!*v17)
          {
            v19 = (unsigned __int16)((_WORD)v17 - (v11 + 376) + 1);
            goto LABEL_27;
          }
          v17 += v18 + 1;
          if (v11 != -632)
            goto LABEL_17;
        }
      }
      else
      {
LABEL_17:
        if ((unint64_t)v17 < v11 + 632)
          goto LABEL_18;
      }
      v19 = 257;
LABEL_27:
      v20 = DNSTypeName(*(unsigned __int16 *)(v11 + 342));
      v25 = 141558787;
      v26 = 1752392040;
      v27 = 1040;
      v28 = v19;
      v29 = 2101;
      v30 = v11 + 376;
      v31 = 2082;
      v32 = v20;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "AnswerAllLocalQuestionsWithLocalAuthRecord ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)&v25, 0x26u);
    }
  }
LABEL_28:
  v21 = a1[27];
  a1[26] = v21;
  if (v21)
  {
    while (1)
    {
      if (v21 == a1[28])
        goto LABEL_38;
      if (*(_DWORD *)(a2 + 172) <= 3u)
        break;
      if (LocalOnlyRecordAnswersQuestion(a2, v21, a3, a4, a5, a6, a7, a8))
        goto LABEL_34;
LABEL_35:
      v22 = a1[26];
      if (v22 == v21)
      {
        v22 = *(_QWORD *)(v21 + 8);
        a1[26] = v22;
      }
      v21 = v22;
      if (!v22)
        goto LABEL_38;
    }
    if (!RecordAnswersQuestion(a2 + 8, 1, v21, a4, a5, a6, a7, a8))
      goto LABEL_35;
LABEL_34:
    AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
    goto LABEL_35;
  }
LABEL_38:
  a1[26] = 0;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v23 = a1[24];
    a1[26] = v23;
    if (v23)
    {
      while (1)
      {
        if (v23 == a1[25])
          goto LABEL_49;
        if (*(_DWORD *)(a2 + 172) <= 3u)
          break;
        if (LocalOnlyRecordAnswersQuestion(a2, v23, a3, a4, a5, a6, a7, a8))
          goto LABEL_45;
LABEL_46:
        v24 = a1[26];
        if (v24 == v23)
        {
          v24 = *(_QWORD *)(v23 + 8);
          a1[26] = v24;
        }
        v23 = v24;
        if (!v24)
          goto LABEL_49;
      }
      if (!RecordAnswersQuestion(a2 + 8, 1, v23, a4, a5, a6, a7, a8))
        goto LABEL_46;
LABEL_45:
      AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
      goto LABEL_46;
    }
LABEL_49:
    a1[26] = 0;
  }
}

void *read_rr_from_ipc_msg(uint64_t a1, int a2, int a3)
{
  unsigned int *v6;
  unint64_t v7;
  unsigned int *v8;
  BOOL v9;
  unsigned int v10;
  unsigned __int8 *v11;
  char v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int *v18;
  BOOL v19;
  unsigned __int8 *v21;
  unsigned int v22;
  unsigned int *v23;
  NSObject *v24;
  char *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int16 *v35;
  int v36;
  unsigned __int16 *v37;
  void *v38;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  void *v43;
  int v44;
  BOOL v45;
  _BOOL4 v46;
  _BOOL4 v47;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  int v68;
  uint64_t v69;
  _BYTE *v70;
  int v71;
  uint64_t v72;
  _BYTE *v73;
  uint64_t v74;
  int v75;
  int v76;
  unsigned int v77;
  uint8_t buf[4];
  int v79;
  __int16 v80;
  uint64_t v81;
  __int16 v82;
  int v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  const char *v87;
  unsigned __int8 v88;
  uint64_t v89;
  unsigned __int8 v90[16];

  v6 = *(unsigned int **)(a1 + 80);
  v7 = *(_QWORD *)(a1 + 88);
  v8 = v6 + 1;
  if (v6)
    v9 = (unint64_t)v8 > v7;
  else
    v9 = 1;
  if (v9)
  {
    v10 = 0;
LABEL_12:
    *(_QWORD *)(a1 + 80) = 0;
    bzero(&v89, 0x3F0uLL);
    LODWORD(v26) = 0;
LABEL_13:
    v13 = 0;
    LOWORD(v14) = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v88 = 0;
    goto LABEL_14;
  }
  v11 = (unsigned __int8 *)(v6 + 2);
  v10 = bswap32(*v6);
  *(_QWORD *)(a1 + 80) = v8;
  if (v6 == (unsigned int *)-4 || (unint64_t)v11 > v7)
    goto LABEL_12;
  LODWORD(v26) = bswap32(v6[1]);
  *(_QWORD *)(a1 + 80) = v11;
  v27 = &v88;
  bzero(&v88, 0x3F1uLL);
  if (!v11)
    goto LABEL_13;
  do
  {
    if ((unint64_t)v11 >= v7 || v27 >= v90)
    {
      v13 = 0;
      LOWORD(v14) = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v27[-(v27 == v90)] = 0;
      *(_QWORD *)(a1 + 80) = 0;
      goto LABEL_14;
    }
    v35 = (unsigned __int16 *)(v11 + 1);
    *(_QWORD *)(a1 + 80) = v11 + 1;
    v36 = *v11;
    *v27++ = v36;
    ++v11;
  }
  while (v36);
  v16 = 0;
  LOWORD(v14) = 0;
  v13 = 1;
  if (!v35 || (unint64_t)(v35 + 1) > v7)
  {
    v15 = 0;
LABEL_100:
    v17 = 0;
    goto LABEL_14;
  }
  v16 = 0;
  LOWORD(v14) = 0;
  v37 = v35 + 2;
  v15 = bswap32(*v35) >> 16;
  *(_QWORD *)(a1 + 80) = v35 + 1;
  v13 = 1;
  if (v35 == (unsigned __int16 *)-2 || (unint64_t)v37 > v7)
    goto LABEL_100;
  v17 = 0;
  v16 = 0;
  v14 = bswap32(v35[1]) >> 16;
  *(_QWORD *)(a1 + 80) = v37;
  v13 = 1;
  if (v35 != (unsigned __int16 *)-4 && (unint64_t)(v35 + 3) <= v7)
  {
    v17 = bswap32(v35[2]) >> 16;
    v13 = 1;
    v16 = (unsigned __int8 *)(v35 + 3);
  }
LABEL_14:
  v18 = (unsigned int *)&v16[v17];
  if (v16)
    v19 = (unint64_t)v18 > v7;
  else
    v19 = 1;
  if (v19)
  {
    v18 = 0;
    v21 = 0;
  }
  else
  {
    v21 = v16;
  }
  *(_QWORD *)(a1 + 80) = v18;
  v22 = 0;
  if (a2)
  {
    v23 = 0;
    if (v18 && (unint64_t)(v18 + 1) <= v7)
    {
      v22 = bswap32(*v18);
      v23 = v18 + 1;
    }
    *(_QWORD *)(a1 + 80) = v23;
    v18 = v23;
  }
  *(_DWORD *)(a1 + 240) = v10;
  *(_DWORD *)(a1 + 244) = v26;
  if ((v13 & 1) == 0)
  {
    v24 = mDNSLogCategory_Default;
    v25 = "ERROR: read_rr_from_ipc_msg - get_string";
    goto LABEL_48;
  }
  if (!v18)
  {
    v24 = mDNSLogCategory_Default;
    v25 = "Error reading Resource Record from client";
    goto LABEL_48;
  }
  if (a3 && (v10 & 0x10) == 0 && (v10 & 0x20) == 0 && (v10 & 0x800) == 0)
  {
    v24 = mDNSLogCategory_Default;
    v25 = "ERROR: Bad resource record flags (must be one of either kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNS"
          "ServiceFlagsKnownUnique)";
LABEL_48:
    LogMsgWithLevel(v24, OS_LOG_TYPE_DEFAULT, v25, v30, v31, v32, v33, v34, v76);
    return 0;
  }
  v77 = v15;
  v40 = mDNSPlatformInterfaceIDfromInterfaceIndex(v26, v28, v29, v30, v31, v32, v33, v34);
  if ((_DWORD)v26)
    v41 = v40 == 0;
  else
    v41 = 0;
  if (v41)
    v26 = v26;
  else
    v26 = v40;
  if (v17 <= 0x214)
    v42 = 532;
  else
    v42 = v17;
  v43 = malloc_type_calloc(1uLL, v42 + 912, 0xF1748037uLL);
  if (!v43)
    __break(1u);
  v38 = v43;
  if (v26 == -2)
  {
    v44 = 4;
  }
  else
  {
    v44 = 5;
    if (v26 != -5 && v26 != -3)
    {
      v45 = (v10 & 0x20000) != 0 && v26 == 0;
      v46 = !v45;
      v47 = (v10 & 0x100000) == 0 || v46;
      v44 = v47 ? 1 : 3;
      if (v46)
      {
        if ((v10 & 0x100000) != 0 && v26 == 0)
          v44 = 2;
        else
          v44 = 0;
      }
    }
  }
  if ((v10 & 0x800) != 0)
    v49 = 32;
  else
    v49 = 2;
  if ((v10 & 0x10) != 0)
    v50 = 8;
  else
    v50 = v49;
  mDNS_SetupResourceRecord((uint64_t)v43, 0, v26, v77, 0, v50, v44, 0, 0);
  *((_BYTE *)v38 + 652) = 0;
  if (!AppendDNSNameString((_BYTE *)v38 + 652, &v88, v51, v52, v53, v54, v55, v56))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: bad name: %s", v57, v58, v59, v60, v61, (int)&v88);
    goto LABEL_128;
  }
  if ((v10 & 0x200) != 0)
    *((_BYTE *)v38 + 121) = 1;
  *((_WORD *)v38 + 7) = v14;
  *((_WORD *)v38 + 10) = v17;
  **((_WORD **)v38 + 6) = v42;
  if (!SetRData(0, v21, (unint64_t)&v21[v17], (uint64_t)v38 + 8, v17, v59, v60, v61))
  {
    v67 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        v68 = *(_DWORD *)(a1 + 192);
        v69 = *((_QWORD *)v38 + 5);
        if (v69)
        {
          v73 = (_BYTE *)*((_QWORD *)v38 + 5);
          v71 = v77;
          if (v69 == -256)
          {
LABEL_116:
            while (v73)
            {
              v74 = *v73;
              if (v74 > 0x3F)
                break;
              if (!*v73)
              {
                v75 = (unsigned __int16)((_WORD)v73 - v69 + 1);
                goto LABEL_127;
              }
              v73 += v74 + 1;
              if (v69 != -256)
                goto LABEL_115;
            }
          }
          else
          {
LABEL_115:
            if ((unint64_t)v73 < v69 + 256)
              goto LABEL_116;
          }
          v75 = 257;
        }
        else
        {
          v75 = 0;
          v71 = v77;
        }
        goto LABEL_127;
      }
    }
    else
    {
      v67 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        v68 = *(_DWORD *)(a1 + 192);
        v69 = *((_QWORD *)v38 + 5);
        if (v69)
        {
          v70 = (_BYTE *)*((_QWORD *)v38 + 5);
          v71 = v77;
          if (v69 == -256)
          {
LABEL_107:
            while (v70)
            {
              v72 = *v70;
              if (v72 > 0x3F)
                break;
              if (!*v70)
              {
                v75 = (unsigned __int16)((_WORD)v70 - v69 + 1);
                goto LABEL_127;
              }
              v70 += v72 + 1;
              if (v69 != -256)
                goto LABEL_106;
            }
          }
          else
          {
LABEL_106:
            if ((unint64_t)v70 < v69 + 256)
              goto LABEL_107;
          }
          v75 = 257;
        }
        else
        {
          v75 = 0;
          v71 = v77;
        }
LABEL_127:
        *(_DWORD *)buf = 67110147;
        v79 = v68;
        v80 = 2160;
        v81 = 1752392040;
        v82 = 1040;
        v83 = v75;
        v84 = 2101;
        v85 = v69;
        v86 = 2082;
        v87 = DNSTypeName(v71);
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x2Cu);
      }
    }
LABEL_128:
    free(v38);
    return 0;
  }
  if (a2)
    *((_DWORD *)v38 + 4) = v22;
  *((_DWORD *)v38 + 6) = DomainNameHashValue(*((_QWORD *)v38 + 5));
  SetNewRData((uint64_t)v38 + 8, 0, 0, v62, v63, v64, v65, v66);
  return v38;
}

void regrecord_callback(uint64_t a1, char *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  _DWORD *v12;
  const char *v13;
  uint64_t v14;
  NSObject *v16;
  NSObject *v18;
  int v21;
  int v22;
  char *reply;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  const char *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  BOOL v40;
  void *v41;
  void *v42;
  int v44;
  NSObject *v45;
  int v46;
  int v48;
  NSObject *v50;
  uint32_t v51;
  char *v53;
  int v55;
  int v56;
  NSObject *v57;
  int v58;
  int v59;
  uint8_t buf[4];
  _BYTE v61[10];
  _BYTE v62[10];
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  const char *v66;
  _QWORD v67[2];

  v11 = *((_QWORD *)a2 + 14);
  if (!v11)
  {
    if (a3 != -65792)
    {
      if (!a3)
      {
        v14 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else
        {
          v14 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        GetRRDisplayString_rdb((unsigned __int8 *)a2 + 8, (unsigned __int16 *)(*((_QWORD *)a2 + 6) + 4), (_BYTE *)(a1 + 47032));
        *(_DWORD *)buf = 141558275;
        *(_QWORD *)v61 = 1752392040;
        *(_WORD *)&v61[8] = 2085;
        *(_QWORD *)v62 = a1 + 47032;
        v36 = "Error: regrecord_callback: successful registration of orphaned record %{sensitive, mask.hash}s";
        v50 = v14;
        v51 = 22;
LABEL_81:
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v36, buf, v51);
        return;
      }
      v16 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v61 = a3;
LABEL_70:
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "regrecord_callback: error %d received after parent termination", buf, 8u);
        }
      }
      else
      {
        v16 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v61 = a3;
          goto LABEL_70;
        }
      }
    }
    v53 = (char *)*((_QWORD *)a2 + 6);
    if (v53 != a2 + 908 && v53 != 0)
      free(v53);
    v42 = a2;
    goto LABEL_77;
  }
  v12 = *(_DWORD **)(v11 + 32);
  if (mDNS_LoggingEnabled != 1)
    goto LABEL_35;
  v67[0] = 0;
  v67[1] = 0;
  if (a3)
  {
    if (a3 == -65548)
    {
      v13 = "NAME CONFLICT";
    }
    else if (a3 == -65792)
    {
      v13 = "DEREGISTERED";
    }
    else
    {
      v13 = (const char *)v67;
      mDNS_snprintf(v67);
    }
  }
  else
  {
    v13 = "REGISTERED";
  }
  v18 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_35;
    goto LABEL_34;
  }
  v18 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_34:
    v21 = v12[48];
    v22 = *(_DWORD *)(v11 + 16);
    GetRRDisplayString_rdb((unsigned __int8 *)a2 + 8, (unsigned __int16 *)(*((_QWORD *)a2 + 6) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)buf = 67110147;
    *(_DWORD *)v61 = v21;
    *(_WORD *)&v61[4] = 1024;
    *(_DWORD *)&v61[6] = v22;
    strcpy(v62, "p\bhash");
    v62[7] = 0;
    *(_WORD *)&v62[8] = 0;
    v63 = 2085;
    v64 = a1 + 47032;
    v65 = 2082;
    v66 = v13;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegisterRecord(%u %{sensitive, mask.hash}s)%{public}s", buf, 0x2Cu);
  }
LABEL_35:
  if (a3 != -65792)
  {
    reply = create_reply((char *)0x45, 12, (uint64_t)v12, a4, a5, a6, a7, a8);
    *((_QWORD *)reply + 4) = *(_QWORD *)(v11 + 20);
    *((_DWORD *)reply + 11) = 0;
    *((_DWORD *)reply + 12) = bswap32(mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)a1, *((_QWORD *)a2 + 4), 0, v24, v25, v26, v27, v28));
    *((_DWORD *)reply + 13) = bswap32(a3);
    append_reply((uint64_t)v12, reply);
    if (a3)
    {
      if (a3 == -65542)
      {
        v34 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          v55 = v12[48];
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v61 = v55;
          v36 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
        }
        else
        {
          v34 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
          v35 = v12[48];
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v61 = v35;
          v36 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
        }
        goto LABEL_80;
      }
      goto LABEL_42;
    }
    if (*(_BYTE *)(v11 + 40))
    {
      v45 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          goto LABEL_85;
        v56 = v12[48];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v61 = v56;
      }
      else
      {
        v45 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_85;
        v46 = v12[48];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v61 = v46;
      }
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "[R%u] regrecord_callback: external_advertise already set!", buf, 8u);
    }
LABEL_85:
    if (!callExternalHelpers(*(_QWORD *)(v11 + 48), a2 + 652, v12[60], v29, v30, v31, v32, v33))
      return;
    v57 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        v59 = v12[48];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v61 = v59;
        goto LABEL_92;
      }
    }
    else
    {
      v57 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v58 = v12[48];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v61 = v58;
LABEL_92:
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "[R%u] regrecord_callback: calling external_start_advertising_service", buf, 8u);
      }
    }
    internal_start_advertising_service((uint64_t)(a2 + 8), v12[60], v12[45]);
    *(_BYTE *)(v11 + 40) = 1;
    return;
  }
LABEL_42:
  v37 = v12 + 42;
  do
  {
    v38 = v37;
    v39 = *v37;
    v37 = (_QWORD *)(*v37 + 8);
    if (v39)
      v40 = v39 == v11;
    else
      v40 = 1;
  }
  while (!v40);
  if (v39)
  {
    *v38 = *v37;
    v41 = *(void **)(v11 + 56);
    if (v41)
      free(v41);
    v42 = (void *)v11;
LABEL_77:
    free(v42);
    return;
  }
  v34 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      return;
    v44 = v12[48];
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)v61 = v44;
    v36 = "[R%u] regrecord_callback - record not in list!";
    goto LABEL_80;
  }
  v34 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    v48 = v12[48];
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)v61 = v48;
    v36 = "[R%u] regrecord_callback - record not in list!";
LABEL_80:
    v50 = v34;
    v51 = 8;
    goto LABEL_81;
  }
}

_BYTE *StartGetZoneData(unsigned int *a1, _BYTE *a2, uint64_t a3)
{
  _BYTE *result;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  unsigned __int16 v10;
  unsigned int v11;
  unsigned int v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned __int16 v16;

  result = malloc_type_calloc(1uLL, 0x5F8uLL, 0xF1748037uLL);
  if (result)
  {
    v7 = (uint64_t)result;
    v8 = a2;
    if (a2 == (_BYTE *)-256)
    {
LABEL_4:
      while (v8)
      {
        v9 = *v8;
        if (v9 > 0x3F)
          break;
        if (!*v8)
        {
          v10 = (_WORD)v8 - (_WORD)a2 + 1;
          if (v10 > 0x100u)
            break;
          memcpy(result, a2, v10);
          goto LABEL_12;
        }
        v8 += v9 + 1;
        if (a2 != (_BYTE *)-256)
          goto LABEL_3;
      }
    }
    else
    {
LABEL_3:
      if (v8 < a2 + 256)
        goto LABEL_4;
    }
    *result = 0;
LABEL_12:
    *(_DWORD *)(v7 + 256) = 0;
    *(_QWORD *)(v7 + 264) = v7;
    *(_BYTE *)(v7 + 272) = 0;
    *(_WORD *)(v7 + 528) = 0;
    *(_BYTE *)(v7 + 530) = 0;
    *(_OWORD *)(v7 + 786) = 0u;
    *(_QWORD *)(v7 + 801) = 0;
    *(_QWORD *)(v7 + 816) = RecordRegistrationGotZoneData;
    *(_QWORD *)(v7 + 824) = a3;
    *(_QWORD *)(v7 + 1008) = v7;
    v11 = a1[12];
    v12 = a1[13] + 1;
    a1[13] = v12;
    mDNS_VerifyLockState("Drop Lock", 0, v11, v12, (uint64_t)"StartGetZoneData", 1995);
    v13 = *(_BYTE **)(v7 + 264);
    v14 = v13;
    if (v13 == (_BYTE *)-256)
    {
LABEL_14:
      while (v14)
      {
        v15 = *v14;
        if (v15 > 0x3F)
          break;
        if (!*v14)
        {
          v16 = (_WORD)v14 - (_WORD)v13 + 1;
          if (v16 > 0x100u)
            break;
          memcpy((void *)(v7 + 1208), v13, v16);
          goto LABEL_22;
        }
        v14 += v15 + 1;
        if (v13 != (_BYTE *)-256)
          goto LABEL_13;
      }
    }
    else
    {
LABEL_13:
      if (v14 < v13 + 256)
        goto LABEL_14;
    }
    *(_BYTE *)(v7 + 1208) = 0;
LABEL_22:
    GetZoneData_StartQuery(a1, v7, 6);
    mDNS_VerifyLockState("Reclaim Lock", 0, a1[12], a1[13]--, (uint64_t)"StartGetZoneData", 1998);
    return (_BYTE *)v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t GetZoneData_StartQuery(unsigned int *a1, uint64_t a2, int a3)
{
  __int16 v3;
  int v6;
  int v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned __int16 v15;
  int v16;
  const char *v17;
  const char *v18;
  BOOL v19;
  const char *v20;

  v3 = a3;
  if (a3 != 33)
    goto LABEL_23;
  v6 = *(_DWORD *)(a2 + 256);
  switch(v6)
  {
    case 2:
      v7 = *(unsigned __int8 *)(a2 + 808);
      v8 = "\f_dns-llq-tls\x04_tcp";
      v9 = "\b_dns-llq\x04_udp";
      goto LABEL_8;
    case 1:
      v7 = *(unsigned __int8 *)(a2 + 808);
      v8 = "\x0E_dns-query-tls\x04_tcp";
      v9 = "";
LABEL_8:
      if (v7)
        v10 = v8;
      else
        v10 = v9;
      goto LABEL_13;
    case 0:
      v7 = *(unsigned __int8 *)(a2 + 808);
      v8 = "\x0F_dns-update-tls\x04_tcp";
      v9 = "\v_dns-update\x04_udp";
      goto LABEL_8;
  }
  v10 = "";
  if (v6 == 3)
    v10 = "\r_dns-push-tls\x04_tcp";
LABEL_13:
  v11 = v10;
  if (v10 == (const char *)-256)
  {
    while (1)
    {
LABEL_15:
      if (!v11)
        goto LABEL_20;
      v12 = *(unsigned __int8 *)v11;
      if (v12 > 0x3F)
        goto LABEL_20;
      if (!*v11)
        break;
      v11 += v12 + 1;
      if (v10 != (const char *)-256)
        goto LABEL_14;
    }
    v15 = (_WORD)v11 - (_WORD)v10 + 1;
    v13 = (_BYTE *)(a2 + 1208);
    if (v15 > 0x100u)
      goto LABEL_21;
    if (v6 == 2)
    {
      v16 = *(unsigned __int8 *)(a2 + 808);
      v17 = "\f_dns-llq-tls\x04_tcp";
      v18 = "\b_dns-llq\x04_udp";
    }
    else if (v6 == 1)
    {
      v16 = *(unsigned __int8 *)(a2 + 808);
      v17 = "\x0E_dns-query-tls\x04_tcp";
      v18 = "";
    }
    else
    {
      if (v6)
      {
        v17 = "";
        v18 = "\r_dns-push-tls\x04_tcp";
        v19 = v6 == 3;
        goto LABEL_33;
      }
      v16 = *(unsigned __int8 *)(a2 + 808);
      v17 = "\x0F_dns-update-tls\x04_tcp";
      v18 = "\v_dns-update\x04_udp";
    }
    v19 = v16 == 0;
LABEL_33:
    if (v19)
      v20 = v18;
    else
      v20 = v17;
    memcpy((void *)(a2 + 1208), v20, v15);
    goto LABEL_22;
  }
LABEL_14:
  if (v11 < v10 + 256)
    goto LABEL_15;
LABEL_20:
  v13 = (_BYTE *)(a2 + 1208);
LABEL_21:
  *v13 = 0;
LABEL_22:
  AppendDomainName(v13, (_BYTE *)(a2 + 272));
LABEL_23:
  *(_DWORD *)(a2 + 1044) = -1;
  *(_QWORD *)(a2 + 968) = 0;
  *(_DWORD *)(a2 + 1156) = 0;
  *(_WORD *)(a2 + 1174) = v3;
  *(_WORD *)(a2 + 1176) = 1;
  *(_DWORD *)(a2 + 1464) = 16777472;
  *(_WORD *)(a2 + 1468) = 0;
  *(_BYTE *)(a2 + 1473) = 0;
  *(_WORD *)(a2 + 1471) = 0;
  *(_BYTE *)(a2 + 1484) = 0;
  *(_DWORD *)(a2 + 1076) = getpid();
  *(_DWORD *)(a2 + 1080) = 0;
  *(_QWORD *)(a2 + 984) = GetZoneData_QuestionCallback;
  *(_QWORD *)(a2 + 1008) = a2;
  return mDNS_StartQuery(a1, a2 + 832);
}

void SetRecordRetry(uint64_t a1, uint64_t a2, uint32_t a3)
{
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  NSObject *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a2 + 284) = v5;
  v6 = *(_DWORD *)(a2 + 352);
  if (v6 && (v7 = *(unsigned __int8 *)(a2 + 600), v7 <= 4))
  {
    v8 = v6 - v5;
    *(_BYTE *)(a2 + 600) = v7 + 1;
    if (v8 <= 300000)
    {
      *(_DWORD *)(a2 + 280) = 300000;
      if (mDNS_LoggingEnabled == 1)
      {
        v28 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "SetRecordRetry clamping to min refresh in %d of %d for %s", v29, v30, v31, v32, v33, 300);
      }
    }
    else
    {
      v9 = v8 / 0xAu;
      v10 = 7 * (v8 / 0xAu);
      if (!a3)
      {
        v11 = 1;
        do
          v11 = (2 * v11) | 1;
        while (v11 < v9);
        do
          a3 = arc4random() & v11;
        while (a3 > v9);
      }
      v12 = a3 + v10;
      if ((int)(a3 + v10) <= 300000)
        v12 = 300000;
      *(_DWORD *)(a2 + 280) = v12;
      if (mDNS_LoggingEnabled == 1)
      {
        v13 = mDNSLogCategory_Default;
        v14 = v12 / 0x3E8;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SetRecordRetry refresh in %d of %d for %s", v15, v16, v17, v18, v19, v14);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    v20 = 3 * *(_DWORD *)(a2 + 280);
    if (v20 <= 1000)
      v20 = 1000;
    if (v20 >= 900000)
      v21 = 900000;
    else
      v21 = v20;
    *(_DWORD *)(a2 + 280) = v21;
    if (mDNS_LoggingEnabled == 1)
    {
      v22 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetRecordRetry retry in %d ms for %s", v23, v24, v25, v26, v27, v21);
    }
  }
}

unsigned int *GetZoneData_QuestionCallback(unsigned int *result, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int *v6;
  _BYTE *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  unint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  const void *v43;
  unint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t (*v47)(unsigned int *, uint64_t, _BYTE *);
  unsigned int *v48;
  uint64_t v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  const void *v52;
  _BYTE *i;
  uint64_t v54;
  unsigned __int16 v55;

  if (!a4)
    return result;
  v6 = result;
  v7 = *(_BYTE **)(a2 + 176);
  if ((a4 == 4 || a4 == 2) && !*(_WORD *)(a3 + 12))
    return result;
  v8 = *(unsigned __int16 *)(a3 + 4);
  if (v8 != *(unsigned __int16 *)(a2 + 342))
    return result;
  if (v8 == 1)
  {
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      v23 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v24, v25, v26, v27, v28, a2 + 376);
    }
    *((_DWORD *)v7 + 197) = 4;
    if (*(_WORD *)(a3 + 12) == 4)
      v29 = (int *)(*(_QWORD *)(a3 + 40) + 4);
    else
      v29 = &zerov4Addr;
    *((_DWORD *)v7 + 198) = *v29;
    goto LABEL_53;
  }
  if (v8 != 33)
  {
    if (v8 != 6)
      return result;
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      v14 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v15, v16, v17, v18, v19, a2 + 376);
    }
    if (*(_WORD *)(a3 + 12))
    {
      v20 = *(_BYTE **)(a3 + 32);
      v21 = v20;
      if (v20 == (_BYTE *)-256)
      {
LABEL_14:
        while (v21)
        {
          v22 = *v21;
          if (v22 > 0x3F)
            break;
          if (!*v21)
          {
            v50 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v50 > 0x100u)
              break;
            memcpy(v7 + 272, v20, v50);
            goto LABEL_48;
          }
          v21 += v22 + 1;
          if (v20 != (_BYTE *)-256)
            goto LABEL_13;
        }
      }
      else
      {
LABEL_13:
        if (v21 < v20 + 256)
          goto LABEL_14;
      }
      v7[272] = 0;
LABEL_48:
      *((_WORD *)v7 + 264) = *(_WORD *)(a3 + 6);
      return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 33);
    }
    v41 = (_BYTE *)*((_QWORD *)v7 + 33);
    if (*v41)
    {
      v42 = &v41[*v41];
      v43 = v42 + 1;
      *((_QWORD *)v7 + 33) = v42 + 1;
      v44 = (unint64_t)(v42 + 257);
      v45 = v42 + 1;
      if (v44)
      {
LABEL_38:
        if ((unint64_t)v45 < v44)
          goto LABEL_39;
      }
      else
      {
LABEL_39:
        while (v45)
        {
          v46 = *v45;
          if (v46 > 0x3F)
            break;
          if (!*v45)
          {
            v55 = (_WORD)v45 - (_WORD)v43 + 1;
            if (v55 > 0x100u)
              break;
            memcpy(v7 + 1208, v43, v55);
            return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 6);
          }
          v45 += v46 + 1;
          if (v44)
            goto LABEL_38;
        }
      }
      v7[1208] = 0;
      return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 6);
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetZoneData recursed to root label of %##s without finding SOA", v9, v10, v11, v12, v13, (int)v7);
    v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((_QWORD *)v7 + 102);
    v49 = 4294901758;
    v48 = v6;
    return (unsigned int *)v47(v48, v49, v7);
  }
  mDNS_StopQuery(result, a2);
  if (*(_DWORD *)(a2 + 212) != -1)
  {
    v30 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v31, v32, v33, v34, v35, a2 + 376);
  }
  if (!*(_WORD *)(a3 + 12))
  {
    v7[530] = 0;
    *(_OWORD *)(v7 + 786) = 0u;
    *(_QWORD *)(v7 + 801) = 0;
    v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((_QWORD *)v7 + 102);
    v48 = v6;
    v49 = 4294901742;
    return (unsigned int *)v47(v48, v49, v7);
  }
  v36 = *(_QWORD *)(a3 + 40);
  v37 = (const void *)(v36 + 10);
  v38 = v36 + 266;
  v39 = (_BYTE *)(v36 + 10);
  if (v38)
  {
LABEL_28:
    if ((unint64_t)v39 < v38)
      goto LABEL_29;
  }
  else
  {
LABEL_29:
    while (v39)
    {
      v40 = *v39;
      if (v40 > 0x3F)
        break;
      if (!*v39)
      {
        v51 = (_WORD)v39 - (_WORD)v37 + 1;
        if (v51 > 0x100u)
          break;
        memcpy(v7 + 530, v37, v51);
        goto LABEL_52;
      }
      v39 += v40 + 1;
      if (v38)
        goto LABEL_28;
    }
  }
  v7[530] = 0;
LABEL_52:
  *((_WORD *)v7 + 393) = *(_WORD *)(*(_QWORD *)(a3 + 40) + 8);
  if (*((_DWORD *)v7 + 64) == 3)
  {
LABEL_53:
    v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((_QWORD *)v7 + 102);
    v48 = v6;
    v49 = 0;
    return (unsigned int *)v47(v48, v49, v7);
  }
  v52 = v7 + 530;
  for (i = v7 + 530; i < v7 + 786; i += v54 + 1)
  {
    if (!i)
      break;
    v54 = *i;
    if (v54 > 0x3F)
      break;
    if (!*i)
    {
      if ((unsigned __int16)((_WORD)i - (_WORD)v52 + 1) <= 0x100u)
      {
        memcpy(v7 + 1208, v52, (unsigned __int16)((_WORD)i - (_WORD)v52 + 1));
        return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 1);
      }
      break;
    }
  }
  v7[1208] = 0;
  return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 1);
}

void RecordRegistrationGotZoneData(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  BOOL v27;
  unsigned int v28;
  unsigned __int8 *v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  NSObject *v35;
  char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  _BYTE *ServiceTarget;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  _BYTE *v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  if (!a3)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: RecordRegistrationGotZoneData invoked with NULL result and no error", a4, a5, a6, a7, a8, a9);
    return;
  }
  v12 = (unsigned __int8 *)(a1 + 12720);
  v13 = *(_QWORD *)(a3 + 824);
  v14 = *(_QWORD *)(v13 + 376);
  if (v14 != a3)
  {
    v15 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(v13 + 12));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: nta (%p) != zoneData (%p)  %##s (%s)", v16, v17, v18, v19, v20, v14);
  }
  mDNS_VerifyLockState("Check Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"RecordRegistrationGotZoneData", 4148);
  v26 = (_QWORD *)(a1 + 12616);
  do
  {
    v26 = (_QWORD *)*v26;
    if (v26)
      v27 = v26 == (_QWORD *)v13;
    else
      v27 = 1;
  }
  while (!v27);
  if (!v26)
  {
    v35 = mDNSLogCategory_Default;
    v36 = "RecordRegistrationGotZoneData - RR no longer in list.  Discarding.";
    goto LABEL_47;
  }
  if (a2 == -65538)
  {
LABEL_48:
    CancelGetZoneData(a1, *(_DWORD **)(v13 + 376));
    *(_QWORD *)(v13 + 376) = 0;
    return;
  }
  if (a2)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: error %d", v21, v22, v23, v24, v25, a2);
    goto LABEL_48;
  }
  if (*(unsigned __int16 *)(v13 + 14) != *(unsigned __int16 *)(a3 + 528))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: New resource record's class (%d) does not match zone class (%d)", v21, v22, v23, v24, v25, *(unsigned __int16 *)(v13 + 14));
    goto LABEL_48;
  }
  v28 = *(unsigned __int8 *)(a3 + 272);
  if (!*(_BYTE *)(a3 + 272))
  {
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: No name server found claiming responsibility for \"%##s\"!", v21, v22, v23, v24, v25, *(_QWORD *)(v13 + 40));
    goto LABEL_48;
  }
  v29 = *(unsigned __int8 **)(v13 + 40);
  v30 = *v29;
  if (*v29)
  {
    v31 = 0;
    v32 = *(_QWORD *)(v13 + 40);
    do
    {
      ++v31;
      v33 = v32 + v30;
      v34 = *(unsigned __int8 *)(v33 + 1);
      v32 = v33 + 1;
      v30 = v34;
    }
    while (v34);
  }
  else
  {
    v31 = 0;
  }
  v37 = 0;
  v38 = a3 + 272;
  do
  {
    ++v37;
    v39 = v38 + v28;
    v40 = *(unsigned __int8 *)(v39 + 1);
    v38 = v39 + 1;
    v28 = v40;
  }
  while (v40);
  v41 = v31 - v37;
  if (v31 < v37)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Zone \"%##s\" is longer than \"%##s\"", v21, v22, v23, v24, v25, a3 + 272);
    goto LABEL_48;
  }
  if (v41 >= 1)
  {
    v42 = v41 + 1;
    do
    {
      if (!*v29)
        break;
      v29 += *v29 + 1;
      --v42;
    }
    while (v42 > 1);
  }
  *(_QWORD *)(v13 + 368) = v29;
  if (!SameDomainNameBytes(v29, (_BYTE *)(a3 + 272)))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Zone \"%##s\" does not match \"%##s\" for \"%##s\"", v21, v22, v23, v24, v25, *(_QWORD *)(v13 + 368));
    goto LABEL_48;
  }
  if (!*(_WORD *)(a3 + 786))
    goto LABEL_45;
  v43 = *(_DWORD *)(a3 + 788);
  if (v43 == 6)
  {
    if (!(*(_DWORD *)(a3 + 796) | *(_DWORD *)(a3 + 792) | *(_DWORD *)(a3 + 800) | *(_DWORD *)(a3 + 804)))
    {
LABEL_45:
      if (mDNS_LoggingEnabled != 1)
        goto LABEL_48;
      v35 = mDNSLogCategory_Default;
      v78 = *(_QWORD *)(v13 + 40);
      v36 = "RecordRegistrationGotZoneData: No _dns-update._udp service found for \"%##s\"!";
LABEL_47:
      LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, v36, v21, v22, v23, v24, v25, v78);
      goto LABEL_48;
    }
  }
  else if (v43 == 4 && !*(_DWORD *)(a3 + 792))
  {
    goto LABEL_45;
  }
  if (!*(_BYTE *)(a3 + 530))
    goto LABEL_45;
  *(_BYTE *)(v13 + 356) = *(_BYTE *)(a3 + 808);
  if (*(_DWORD *)(v13 + 344) == 3)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4222);
    uDNS_DeregisterRecord(a1, v13);
    v44 = a1;
    v45 = 4224;
LABEL_96:
    mDNS_Unlock_(v44, (uint64_t)"RecordRegistrationGotZoneData", v45);
    return;
  }
  if (*(_WORD *)(v13 + 12) != 33)
    goto LABEL_88;
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4233);
  ServiceTarget = (_BYTE *)GetServiceTarget(a1, v13);
  mDNS_Unlock_(a1, (uint64_t)"RecordRegistrationGotZoneData", 4235);
  if (!ServiceTarget || !*ServiceTarget)
  {
    v55 = 0;
    v56 = *(unsigned __int16 *)(v13 + 12);
    if (v56 > 0x20)
    {
      switch(v56)
      {
        case '!':
          v55 = (_BYTE *)(*(_QWORD *)(v13 + 48) + 10);
          break;
        case '$':
LABEL_65:
          v55 = (_BYTE *)(*(_QWORD *)(v13 + 48) + 6);
          break;
        case '\'':
LABEL_68:
          v55 = (_BYTE *)(*(_QWORD *)(v13 + 48) + 4);
          break;
      }
    }
    else
    {
      switch(*(_WORD *)(v13 + 12))
      {
        case 0xC:
          goto LABEL_68;
        case 0xD:
        case 0xE:
        case 0x10:
        case 0x11:
        case 0x13:
        case 0x14:
          break;
        case 0xF:
        case 0x12:
        case 0x15:
          goto LABEL_65;
        default:
          if (v56 == 2 || v56 == 5)
            goto LABEL_68;
          break;
      }
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData - no target for %##s", v48, v49, v50, v51, v52, *(_QWORD *)(v13 + 40));
    if (v55)
      *v55 = 0;
    *(_DWORD *)(v13 + 20) = 0;
    *(_DWORD *)(v13 + 344) = 8;
    goto LABEL_48;
  }
  if (*(_WORD *)(v13 + 12) != 33 || (v53 = *(_QWORD *)(v13 + 48), !*(_WORD *)(v53 + 8)))
  {
LABEL_88:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4267);
    if (*(_DWORD *)(v13 + 604))
    {
      v65 = *(_DWORD *)(a1 + 64);
    }
    else
    {
      *(_DWORD *)(v13 + 280) = 1000;
      v65 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v13 + 284) = v65 - 1000;
    }
    if (IsRecordMergeable(a1, v13, v65 + 1000))
    {
      if (mDNS_LoggingEnabled == 1)
      {
        v66 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(*(_QWORD *)(v13 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v66, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Delayed registration for %s", v67, v68, v69, v70, v71, a1 + 47032);
      }
      *(_DWORD *)(v13 + 284) += 1000;
    }
    v44 = a1;
    v45 = 4285;
    goto LABEL_96;
  }
  v54 = *v12;
  if (v54 != 10)
  {
    if (v54 == 172)
    {
      if ((v12[1] & 0xF0) != 0x10)
        goto LABEL_88;
    }
    else if (v54 != 192 || v12[1] != 168)
    {
      goto LABEL_88;
    }
  }
  v57 = *(_QWORD *)(v13 + 376);
  if (!v57)
    goto LABEL_88;
  if (*(_DWORD *)(v57 + 788) == 4)
  {
    v58 = *(unsigned __int8 *)(v57 + 792);
    if (v58 == 10)
      goto LABEL_88;
    if (v58 == 172)
    {
      if ((*(_BYTE *)(v57 + 793) & 0xF0) == 0x10)
        goto LABEL_88;
    }
    else if (v58 == 192 && *(unsigned __int8 *)(v57 + 793) == 168)
    {
      goto LABEL_88;
    }
  }
  if (*(_BYTE *)(v13 + 120) != 2)
    goto LABEL_88;
  if (*(_QWORD *)(v13 + 584))
  {
    if (mDNS_LoggingEnabled)
    {
      v59 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v53 + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v59, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: StartRecordNatMap for %s, state %d, context %p", v60, v61, v62, v63, v64, a1 + 47032);
    }
    goto LABEL_88;
  }
  if (mDNS_LoggingEnabled)
  {
    v72 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v53 + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v72, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData StartRecordNatMap %s", v73, v74, v75, v76, v77, a1 + 47032);
  }
  *(_DWORD *)(v13 + 344) = 6;
  StartRecordNatMap(a1, v13, v47, v48, v49, v50, v51, v52);
}

uint64_t FindIdenticalRecordInCache(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;

  v3 = CacheGroupForName(a1, *(_DWORD *)(a2 + 16), *(_BYTE **)(a2 + 32));
  if (!v3)
    return 0;
  for (i = v3[2]; i; i = *(_QWORD *)i)
  {
    v5 = *(_QWORD *)(a2 + 24);
    if (v5)
    {
      v6 = *(_QWORD *)(i + 32);
    }
    else
    {
      v5 = *(_QWORD *)(a2 + 48);
      if (v5)
        v5 = *(_QWORD *)(v5 + 24);
      v6 = *(_QWORD *)(i + 56);
      if (v6)
        v6 = *(_QWORD *)(v6 + 24);
    }
    if (v5 == v6
      && resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a2 + 56), *(_QWORD *)(i + 64))
      && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(i + 12)
      && *(unsigned __int16 *)(a2 + 6) == *(unsigned __int16 *)(i + 14)
      && *(unsigned __int16 *)(a2 + 12) == *(unsigned __int16 *)(i + 20)
      && *(_DWORD *)(a2 + 20) == *(_DWORD *)(i + 28)
      && SameRDataBody(a2, (unsigned __int16 *)(*(_QWORD *)(i + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
    {
      break;
    }
  }
  return i;
}

uint64_t ShouldSuppressKnownAnswer(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24))
    return 0;
  result = resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a1 + 64), *(_QWORD *)(a2 + 64));
  if (!(_DWORD)result)
    return result;
  if (*(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(a1 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
  {
    return 0;
  }
  result = SameRDataBody(a1 + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if ((_DWORD)result)
  {
    result = SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40));
    if ((_DWORD)result)
      return *(_DWORD *)(a1 + 16) >= *(_DWORD *)(a2 + 16) >> 1;
  }
  return result;
}

void SysEventCallBack(int a1, uint64_t a2, unsigned int *a3)
{
  ssize_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[28];

  mDNS_Lock_(a3, (uint64_t)"SysEventCallBack", 6809);
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  v5 = recv(a1, &v10, 0x11CuLL, 0);
  v6 = mDNSLogCategory_State;
  if (v5 < 0)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
    {
      v7 = *__error();
      v8 = 134217984;
      v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "SysEventCallBack error -- error: %{mdns:err}ld", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 67240192;
      LODWORD(v9) = DWORD1(v11);
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SysEventCallBack -- event: %{public, mdnsresponder:kev_dl_event}d", (uint8_t *)&v8, 8u);
    }
    if (DWORD1(v11) == 17 || DWORD1(v11) == 13)
      SetNetworkChanged(2000);
  }
  mDNS_Unlock_((uint64_t)a3, (uint64_t)"SysEventCallBack", 6832);
}

uint64_t mDNS_PurgeCacheResourceRecord(unsigned int *a1, uint64_t a2)
{
  mDNS_VerifyLockState("Check Lock", 1, a1[12], a1[13], (uint64_t)"mDNS_PurgeCacheResourceRecord", 6526);
  *(_DWORD *)(a2 + 80) = a1[16] - 60000;
  *(_WORD *)(a2 + 108) = 4;
  *(_DWORD *)(a2 + 16) = 0;
  return SetNextCacheCheckTimeForRecord((uint64_t)a1, a2);
}

void DeadvertiseInterface(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  BOOL v7;
  BOOL v8;
  int v9;
  NSObject *v10;
  const char *v12;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;

  v6 = *(_QWORD *)(a2 + 3552);
  if (AWDLInterfaceID)
    v7 = AWDLInterfaceID == v6;
  else
    v7 = 0;
  if (v7)
  {
    v9 = 1;
  }
  else
  {
    if (WiFiAwareInterfaceID)
      v8 = WiFiAwareInterfaceID == v6;
    else
      v8 = 0;
    v9 = v8;
    if ((a3 & 1) != 0 && !v9)
      goto LABEL_18;
  }
  if ((a3 & 2) == 0 || !v9)
    goto LABEL_50;
  LOBYTE(v9) = 1;
LABEL_18:
  v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      v12 = "randomized";
      if ((a3 & 2) == 0)
        v12 = "normal";
      goto LABEL_30;
    }
  }
  else
  {
    v10 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      v12 = "randomized";
      if ((a3 & 2) == 0)
        v12 = "normal";
LABEL_30:
      v19 = 136446466;
      v20 = v12;
      v21 = 2082;
      v22 = a2 + 3606;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "DeadvertiseInterface: Deadvertising %{public}s hostname on interface %{public}s", (uint8_t *)&v19, 0x16u);
    }
  }
  v14 = *(_QWORD *)(a2 + 3552);
  if (v14 == AWDLInterfaceID || v14 == WiFiAwareInterfaceID)
  {
    if (!*(_BYTE *)(a2 + 32) && !*(_BYTE *)(a2 + 1208))
      goto LABEL_42;
    v15 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 136446210;
        v20 = (const char *)(a2 + 3606);
        goto LABEL_41;
      }
    }
    else
    {
      v15 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 136446210;
        v20 = (const char *)(a2 + 3606);
LABEL_41:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "D2D_stop_advertising_interface - ifname: %{public}s", (uint8_t *)&v19, 0xCu);
      }
    }
LABEL_42:
    if (*(_BYTE *)(a2 + 32))
      internal_stop_advertising_service(a2 + 32, 0, 0);
    if (*(_BYTE *)(a2 + 1208))
      internal_stop_advertising_service(a2 + 1208, 0, 0);
  }
  if (*(_BYTE *)(a2 + 32))
    mDNS_Deregister_internal(a1, a2 + 24, 0);
  if (*(_BYTE *)(a2 + 1208))
    mDNS_Deregister_internal(a1, a2 + 1200, 0);
LABEL_50:
  if ((a3 & 2) != 0 && (v9 & 1) == 0)
  {
    v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        goto LABEL_62;
      v19 = 136446210;
      v20 = (const char *)(a2 + 3606);
    }
    else
    {
      v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_62;
      v19 = 136446210;
      v20 = (const char *)(a2 + 3606);
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "DeadvertiseInterface: Deadvertising randomized hostname on interface %{public}s", (uint8_t *)&v19, 0xCu);
LABEL_62:
    if (*(_BYTE *)(a2 + 2384))
      mDNS_Deregister_internal(a1, a2 + 2376, 0);
  }
}

void LNT_ClearState(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;
  _DWORD *v4;

  v2 = (_DWORD *)(a1 + 15034);
  v3 = *(_DWORD **)(a1 + 14808);
  if (v3)
  {
    mDNSPlatformTCPCloseConnection(v3);
    *(_QWORD *)(a1 + 14808) = 0;
  }
  v4 = *(_DWORD **)(a1 + 14920);
  if (v4)
  {
    mDNSPlatformTCPCloseConnection(v4);
    *(_QWORD *)(a1 + 14920) = 0;
  }
  *v2 = 0;
}

void ReleaseCacheGroup(uint64_t a1, _QWORD **a2)
{
  _QWORD *v4;
  NSObject *v5;
  uint8_t *v7;
  _QWORD *v9;
  _QWORD *v10;
  __int16 v12;
  __int16 v13;

  v4 = *a2;
  if ((_QWORD *)(*a2)[3] == *a2 + 2)
    goto LABEL_12;
  v5 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
    v13 = 0;
    v7 = (uint8_t *)&v13;
  }
  else
  {
    v5 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
    v12 = 0;
    v7 = (uint8_t *)&v12;
  }
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "ERROR: (*cp)->members == mDNSNULL but (*cp)->rrcache_tail != &(*cp)->members)", v7, 2u);
LABEL_12:
  v9 = *a2;
  v10 = (_QWORD *)(*a2)[4];
  if (v10 != *a2 + 5 && v10 != 0)
  {
    free(v10);
    v9 = *a2;
  }
  v9[4] = 0;
  *a2 = (_QWORD *)**a2;
  *v4 = *(_QWORD *)(a1 + 264);
  *(_QWORD *)(a1 + 264) = v4;
  --*(_DWORD *)(a1 + 244);
}

size_t AdvertiseHostname(size_t result, uint64_t a2)
{
  uint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  _BYTE *v13;
  uint64_t v14;
  unsigned __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  _BYTE *v24;
  uint64_t v25;
  unsigned __int16 v26;

  v3 = result;
  if (!*(_DWORD *)(result + 12720) || *(_BYTE *)(a2 + 472))
    goto LABEL_24;
  v4 = (_DWORD *)(result + 12720);
  v5 = a2 + 464;
  mDNS_SetupResourceRecord(a2 + 464, 0, 0, 1, 0x1194u, 0, 0, (uint64_t)HostnameCallback, a2);
  v12 = (const void *)(a2 + 208);
  v13 = (_BYTE *)(a2 + 208);
  if (a2 == -464)
  {
LABEL_5:
    while (v13)
    {
      v14 = *v13;
      if (v14 > 0x3F)
        break;
      if (!*v13)
      {
        v15 = (_WORD)v13 - (_WORD)v12 + 1;
        if (v15 > 0x100u)
          break;
        memcpy((void *)(a2 + 1116), v12, v15);
        goto LABEL_13;
      }
      v13 += v14 + 1;
      if (a2 != -464)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    if ((unint64_t)v13 < v5)
      goto LABEL_5;
  }
  *(_BYTE *)(a2 + 1116) = 0;
LABEL_13:
  *(_DWORD *)(*(_QWORD *)(a2 + 512) + 4) = *v4;
  *(_DWORD *)(a2 + 808) = 4;
  v16 = *(unsigned __int8 *)v4;
  if (v16 == 10)
    goto LABEL_17;
  if (v16 == 172)
  {
    if ((*(_BYTE *)(v3 + 12721) & 0xF0) == 0x10)
    {
LABEL_17:
      if (*(_QWORD *)(a2 + 200))
        mDNS_StopNATOperation_internal(v3, a2 + 8);
      *(_BYTE *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 182) = 0;
      *(_DWORD *)(a2 + 188) = 0;
      *(_QWORD *)(a2 + 192) = hostnameGetPublicAddressCallback;
      *(_QWORD *)(a2 + 200) = a2;
      result = mDNS_StartNATOperation_internal(v3, a2 + 8, v6, v7, v8, v9, v10, v11);
      goto LABEL_24;
    }
  }
  else if (v16 == 192 && *(unsigned __int8 *)(v3 + 12721) == 168)
  {
    goto LABEL_17;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv4 %.4a", v7, v8, v9, v10, v11, *(_QWORD *)(a2 + 504));
  *(_BYTE *)(a2 + 472) = 32;
  result = mDNS_Register_internal(v3, a2 + 464, v6, v7, v8, v9, v10, v11);
LABEL_24:
  if (*(_DWORD *)(v3 + 12744) | *(_DWORD *)(v3 + 12740) | *(_DWORD *)(v3 + 12748) | *(_DWORD *)(v3 + 12752)
    && !*(_BYTE *)(a2 + 1648))
  {
    mDNS_SetupResourceRecord(a2 + 1640, 0, 0, 28, 0x1194u, 32, 0, (uint64_t)HostnameCallback, a2);
    v23 = (const void *)(a2 + 208);
    v24 = (_BYTE *)(a2 + 208);
    if (a2 == -464)
    {
LABEL_29:
      while (v24)
      {
        v25 = *v24;
        if (v25 > 0x3F)
          break;
        if (!*v24)
        {
          v26 = (_WORD)v24 - (_WORD)v23 + 1;
          if (v26 > 0x100u)
            break;
          memcpy((void *)(a2 + 2292), v23, v26);
          goto LABEL_37;
        }
        v24 += v25 + 1;
        if (a2 != -464)
          goto LABEL_28;
      }
    }
    else
    {
LABEL_28:
      if ((unint64_t)v24 < a2 + 464)
        goto LABEL_29;
    }
    *(_BYTE *)(a2 + 2292) = 0;
LABEL_37:
    *(_OWORD *)(*(_QWORD *)(a2 + 1688) + 4) = *(_OWORD *)(v3 + 12740);
    *(_DWORD *)(a2 + 1984) = 4;
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv6 %.16a", v18, v19, v20, v21, v22, *(_QWORD *)(a2 + 1680));
    return mDNS_Register_internal(v3, a2 + 1640, v17, v18, v19, v20, v21, v22);
  }
  return result;
}

void CancelGetZoneData(uint64_t a1, _DWORD *a2)
{
  NSObject *v3;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;

  if (a2[261] != -1)
  {
    mDNS_StopQuery_internal(a1, (uint64_t)(a2 + 208));
    if (a2[261] != -1)
    {
      v3 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          v5 = a2 + 302;
          if (a2 == (_DWORD *)-1464)
          {
LABEL_11:
            while (v5)
            {
              v6 = *v5;
              if (v6 > 0x3F)
                break;
              if (!*v5)
              {
                v10 = (unsigned __int16)((_WORD)v5 - ((_WORD)a2 + 1208) + 1);
                goto LABEL_28;
              }
              v5 += v6 + 1;
              if (a2 != (_DWORD *)-1464)
                goto LABEL_10;
            }
          }
          else
          {
LABEL_10:
            if (v5 < (_BYTE *)a2 + 1464)
              goto LABEL_11;
          }
          v10 = 257;
          goto LABEL_28;
        }
      }
      else
      {
        v3 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v8 = a2 + 302;
          if (a2 == (_DWORD *)-1464)
          {
LABEL_19:
            while (v8)
            {
              v9 = *v8;
              if (v9 > 0x3F)
                break;
              if (!*v8)
              {
                v10 = (unsigned __int16)((_WORD)v8 - ((_WORD)a2 + 1208) + 1);
                goto LABEL_28;
              }
              v8 += v9 + 1;
              if (a2 != (_DWORD *)-1464)
                goto LABEL_18;
            }
          }
          else
          {
LABEL_18:
            if (v8 < (_BYTE *)a2 + 1464)
              goto LABEL_19;
          }
          v10 = 257;
LABEL_28:
          v11 = DNSTypeName(*((unsigned __int16 *)a2 + 587));
          v12 = a2[261];
          v13 = 141559043;
          v14 = 1752392040;
          v15 = 1040;
          v16 = v10;
          v17 = 2101;
          v18 = (char *)(a2 + 302);
          v19 = 2082;
          v20 = v11;
          v21 = 1024;
          v22 = v12;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CancelGetZoneData: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) ThisQInterval %d not -1", (uint8_t *)&v13, 0x2Cu);
        }
      }
    }
  }
  free(a2);
}

int *mDNSPlatformUDPSocket(unsigned int a1)
{
  int *result;
  int *v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = (int *)malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
  if (result)
  {
    v3 = result;
    *(_WORD *)result = 0;
    *((_QWORD *)result + 1) = &mDNSStorage;
    result[4] = -1;
    result[12] = -1;
    *((_BYTE *)result + 88) = 0;
    v4 = -9999;
    LOWORD(v5) = a1;
    do
    {
      v6 = v4;
      if (!(_WORD)a1)
        v5 = bswap32(arc4random() | 0xC000) >> 16;
      v7 = SetupSocket((int)v3, (unsigned __int16)v5, 2);
      if (!v7)
      {
        v8 = SetupSocket((int)v3, (unsigned __int16)v5, 30);
        if (!v8)
          return v3;
        v7 = v8;
        close(v3[4]);
        v3[4] = -1;
      }
      if (v7 != 48)
        break;
      if ((_WORD)a1)
        break;
      v4 = v6 + 1;
    }
    while (v6);
    if ((unsigned __int16)a1 != 58900 || mDNS_LoggingEnabled)
    {
      v9 = mDNSLogCategory_Default;
      __error();
      v10 = __error();
      strerror(*v10);
      LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", v11, v12, v13, v14, v15, bswap32(a1) >> 16);
    }
    free(v3);
    return 0;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void uDNS_ReceiveMsg(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  uint32_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  NSObject **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  void (*v69)(uint64_t, uint64_t, _QWORD, _QWORD);
  int v70;
  _BYTE *ServiceTarget;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  _BOOL4 v80;
  unint64_t v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  NSObject **v89;
  NSObject *v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unsigned int v99;
  uint64_t v100;
  int v101;
  BOOL v102;
  char v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  _BYTE *v107;
  _BYTE *v108;
  int v109;
  int v110;
  NSObject *v111;
  int v112;
  int v113;
  int v114;
  NSObject *v115;
  int v116;
  int v117;

  v10 = a2[1] & 0xF8;
  if (v10 != 168)
  {
    if (v10 == 128)
    {
      v11 = *(_QWORD *)(a1 + 192);
      if (v11)
      {
        v13 = (unsigned __int16)a5;
        do
        {
          if ((a2[1] & 2) != 0
            && *(unsigned __int16 *)(v11 + 340) == *a2
            && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v11 + 208) <= 59999)
          {
            if (a4)
            {
              v14 = *(_QWORD *)(v11 + 112);
              if (v14)
              {
                DisposeTCPConn(v14);
                *(_QWORD *)(v11 + 112) = 0;
              }
              *(_QWORD *)(v11 + 112) = MakeTCPConn(a1, 0, 0, 0, a4, v13, 0, v11, 0);
            }
            else
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveMsg: TCP DNS response had TC bit set: ignoring", (uint64_t)a4, a5, a6, a7, a8, v109);
            }
          }
          v11 = *(_QWORD *)(v11 + 8);
        }
        while (v11);
      }
    }
    return;
  }
  v15 = a3;
  v16 = *((_BYTE *)a2 + 3);
  v117 = 0;
  if (GetPktLease(a1, (unint64_t)a2, a3, &v117))
    v17 = v117;
  else
    v17 = 3600;
  v112 = 1000 * v17 + *(_DWORD *)(a1 + 64);
  v18 = 1000 * v17 / 10;
  v19 = 1;
  if (v18 >= 2)
  {
    do
      v19 = (2 * v19) | 1;
    while (v19 < v18);
  }
  v116 = v16 & 0xF;
  do
    v20 = arc4random() & v19;
  while (v20 > v18);
  v21 = *(_QWORD *)(a1 + 12640);
  if (v21)
  {
    v22 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v21 + 8), (unsigned __int16 *)(*(_QWORD *)(v21 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveMsg ERROR m->CurrentRecord already set %s", v23, v24, v25, v26, v27, a1 + 47032);
  }
  v28 = *(_QWORD *)(a1 + 12616);
  *(_QWORD *)(a1 + 12640) = v28;
  if (v28)
  {
    v29 = (_BYTE *)(a1 + 47032);
    v30 = (NSObject **)&unk_100164000;
    while (1)
    {
      v31 = *(_QWORD *)v28;
      *(_QWORD *)(a1 + 12640) = *(_QWORD *)v28;
      if (!*(_QWORD *)(v28 + 32))
        break;
LABEL_87:
      v28 = v31;
      if (!v31)
        return;
    }
    if (*(_BYTE *)(v28 + 122) || IsLocalDomain(*(_BYTE **)(v28 + 40)) || *(unsigned __int16 *)(v28 + 358) != *a2)
    {
LABEL_86:
      v31 = *(_QWORD *)(a1 + 12640);
      goto LABEL_87;
    }
    v37 = *(_QWORD *)(v28 + 40);
    v38 = 0;
    v39 = -65548;
    switch(v116)
    {
      case 0:
        v39 = 0;
        v38 = 1;
        if (v17 && *(_BYTE *)(v28 + 348))
        {
          if (*(_DWORD *)(v28 + 352) - v112 < 0 && *(_DWORD *)(v28 + 344) == 7)
          {
            v39 = 0;
          }
          else
          {
            v39 = 0;
            *(_DWORD *)(v28 + 352) = v112;
            *(_BYTE *)(v28 + 600) = 0;
          }
        }
        goto LABEL_46;
      case 1:
        v39 = ParseTSIGError(a1, (unint64_t)a2, v15, *(_QWORD *)(v28 + 40));
        if (v39)
          goto LABEL_42;
        LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Format Error: %##s", v40, v41, v42, v43, v44, v37);
        goto LABEL_45;
      case 5:
        LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Update %##s refused", v32, v33, v34, v35, v36, *(_QWORD *)(v28 + 40));
        v38 = 0;
        v39 = -65553;
        goto LABEL_46;
      case 6:
        goto LABEL_46;
      case 8:
        LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Reregister refused (NXRRSET): %##s", v32, v33, v34, v35, v36, *(_QWORD *)(v28 + 40));
        v38 = 0;
        v39 = -65554;
        goto LABEL_46;
      case 9:
        v39 = ParseTSIGError(a1, (unint64_t)a2, v15, *(_QWORD *)(v28 + 40));
        if (v39)
        {
LABEL_42:
          v38 = 0;
        }
        else
        {
          LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Permission denied (NOAUTH): %##s", v45, v46, v47, v48, v49, v37);
LABEL_45:
          v38 = 0;
          v39 = -65537;
        }
LABEL_46:
        v114 = v39;
        v113 = v38;
        mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"hndlRecordUpdateReply", 3501);
        if (mDNS_LoggingEnabled == 1)
        {
          v111 = v30[295];
          GetRRDisplayString_rdb((unsigned __int8 *)(v28 + 8), (unsigned __int16 *)(*(_QWORD *)(v28 + 48) + 4), v29);
          LogMsgWithLevel(v111, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: err %d ID %d state %d %s(%p)", v50, v51, v52, v53, v54, v114);
        }
        *(_DWORD *)(v28 + 604) = v114;
        SetRecordRetry(a1, v28, v20);
        *(_WORD *)(v28 + 358) = 0;
        v60 = *(_QWORD *)(v28 + 376);
        if (v60)
        {
          if (*(_DWORD *)(v60 + 1044) != -1)
          {
            v61 = v30[295];
            GetRRDisplayString_rdb((unsigned __int8 *)(v28 + 8), (unsigned __int16 *)(*(_QWORD *)(v28 + 48) + 4), v29);
            DNSTypeName(*(unsigned __int16 *)(*(_QWORD *)(v28 + 376) + 1174));
            LogMsgWithLevel(v61, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: ResourceRecord %s, zone info question %##s (%s) interval %d not -1", v62, v63, v64, v65, v66, (int)v29);
            v60 = *(_QWORD *)(v28 + 376);
          }
          v67 = *(unsigned __int16 *)(v60 + 786);
          CancelGetZoneData(a1, (_DWORD *)v60);
          *(_QWORD *)(v28 + 376) = 0;
        }
        else
        {
          v67 = 0;
        }
        v68 = v113;
        if (*(_BYTE *)(v28 + 8) == 1 && *(_DWORD *)(v28 + 344) == 3)
        {
          if ((v113 & 1) == 0)
            LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "ERROR: Deregistration of record %##s type %d failed with error %d", v55, v56, v57, v58, v59, *(_QWORD *)(v28 + 40));
          *(_DWORD *)(v28 + 344) = 4;
          CompleteDeregistration(a1, v28);
          goto LABEL_86;
        }
        if (*(_BYTE *)(a1 + 141))
        {
          if (*(_WORD *)(v28 + 12) == 33 && *(_DWORD *)(v28 + 344) == 3)
            goto LABEL_84;
          goto LABEL_86;
        }
        if (*(_DWORD *)(v28 + 344) == 7)
        {
          if ((v113 & 1) == 0)
            LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Update record failed for %##s (err %d)", v55, v56, v57, v58, v59, *(_QWORD *)(v28 + 40));
          *(_DWORD *)(v28 + 344) = 2;
          v69 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(v28 + 320);
          if (v69)
            v69(a1, v28, *(_QWORD *)(v28 + 624), *(unsigned __int16 *)(v28 + 616));
          SetNewRData(v28 + 8, *(_QWORD *)(v28 + 632), *(unsigned __int16 *)(v28 + 618), v55, v56, v57, v58, v59);
          *(_OWORD *)(v28 + 624) = 0u;
          v68 = v113;
        }
        if (*(_BYTE *)(v28 + 592))
        {
          v70 = *(unsigned __int16 *)(v28 + 12);
          if (v70 != 33)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v115 = v30[295];
              v81 = v15;
              v82 = v29;
              v83 = *(_QWORD *)(v28 + 40);
              DNSTypeName(v70);
              v110 = v83;
              v29 = v82;
              v15 = v81;
              LogMsgWithLevel(v115, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Deregistered %##s (%s), state %d", v84, v85, v86, v87, v88, v110);
            }
            *(_BYTE *)(v28 + 592) = 0;
            if (*(_DWORD *)(v28 + 344) != 3)
            {
              v89 = v30;
              v90 = v30[295];
              GetRRDisplayString_rdb((unsigned __int8 *)(v28 + 8), (unsigned __int16 *)(*(_QWORD *)(v28 + 48) + 4), v29);
              v91 = v90;
              v30 = v89;
              LogMsgWithLevel(v91, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: ResourceRecord %s not in DeregPending state %d", v92, v93, v94, v95, v96, (int)v29);
            }
LABEL_84:
            v97 = 8;
LABEL_85:
            *(_DWORD *)(v28 + 344) = v97;
            goto LABEL_86;
          }
          ServiceTarget = (_BYTE *)GetServiceTarget(a1, v28);
          if (ServiceTarget)
          {
            v77 = (int)ServiceTarget;
            if (*ServiceTarget)
            {
              v78 = *(_DWORD *)(v28 + 344);
              if (v78 != 3)
              {
                if (v78 != 1)
                {
LABEL_117:
                  *(_BYTE *)(v28 + 592) = 0;
                  goto LABEL_86;
                }
                if (SameDomainNameBytes(ServiceTarget, (_BYTE *)(*(_QWORD *)(v28 + 48) + 10)))
                {
                  if (*(_DWORD *)(v28 + 344) == 1)
                    *(_DWORD *)(v28 + 344) = 2;
                  goto LABEL_117;
                }
              }
              v106 = *(unsigned __int16 *)(v28 + 12);
              if (v106 <= 0x20)
              {
                switch(*(_WORD *)(v28 + 12))
                {
                  case 0xC:
                    goto LABEL_139;
                  case 0xD:
                  case 0xE:
                  case 0x10:
                  case 0x11:
                  case 0x13:
                  case 0x14:
                    goto LABEL_145;
                  case 0xF:
                  case 0x12:
                  case 0x15:
                    goto LABEL_133;
                  default:
                    if (v106 == 2 || v106 == 5)
                      goto LABEL_139;
                    break;
                }
                goto LABEL_145;
              }
              switch(v106)
              {
                case '!':
                  v108 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 10);
                  break;
                case '$':
LABEL_133:
                  v108 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 6);
                  break;
                case '\'':
LABEL_139:
                  v108 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 4);
                  break;
                default:
                  goto LABEL_145;
              }
              *v108 = 0;
LABEL_145:
              *(_DWORD *)(v28 + 344) = 8;
              *(_DWORD *)(v28 + 20) = 0;
              if (mDNS_LoggingEnabled == 1)
                LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, Valid Target %##s, Registering all records for %##s, state %d", v72, v73, v74, v75, v76, v77);
              *(_BYTE *)(v28 + 592) = 0;
              UpdateOneSRVRecord(a1, v28);
              goto LABEL_86;
            }
          }
          v98 = *(_DWORD *)(v28 + 344);
          if (v98 == 1)
          {
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, No Target, Deregistering again %##s, state %d", v72, v73, v74, v75, v76, *(_QWORD *)(v28 + 40));
            *(_DWORD *)(v28 + 280) = 1000;
            *(_DWORD *)(v28 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            v97 = 3;
            goto LABEL_85;
          }
          if (v98 != 3)
          {
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: Not in DeregPending or RegPending state %##s, state %d", v72, v73, v74, v75, v76, *(_QWORD *)(v28 + 40));
            goto LABEL_117;
          }
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, No Target, SRV Deregistered for %##s, state %d", v72, v73, v74, v75, v76, *(_QWORD *)(v28 + 40));
          *(_BYTE *)(v28 + 592) = 0;
          v99 = *(unsigned __int16 *)(v28 + 12);
          if (v99 <= 0x20)
          {
            switch(*(_WORD *)(v28 + 12))
            {
              case 0xC:
                goto LABEL_136;
              case 0xD:
              case 0xE:
              case 0x10:
              case 0x11:
              case 0x13:
              case 0x14:
                goto LABEL_142;
              case 0xF:
              case 0x12:
              case 0x15:
                goto LABEL_128;
              default:
                if (v99 == 2 || v99 == 5)
                  goto LABEL_136;
                break;
            }
            goto LABEL_142;
          }
          switch(v99)
          {
            case '!':
              v107 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 10);
              break;
            case '$':
LABEL_128:
              v107 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 6);
              break;
            case '\'':
LABEL_136:
              v107 = (_BYTE *)(*(_QWORD *)(v28 + 48) + 4);
              break;
            default:
              goto LABEL_142;
          }
          *v107 = 0;
LABEL_142:
          *(_DWORD *)(v28 + 344) = 8;
          *(_DWORD *)(v28 + 20) = 0;
          goto LABEL_86;
        }
        v79 = *(_DWORD *)(v28 + 344);
        if ((v79 | 4) != 5)
        {
          v80 = 1;
          goto LABEL_99;
        }
        if (v68)
        {
          v80 = v79 != 5;
          *(_DWORD *)(v28 + 344) = 2;
          goto LABEL_99;
        }
        LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Registration of record %##s type %d failed with error %d", v55, v56, v57, v58, v59, *(_QWORD *)(v28 + 40));
        if (*(_BYTE *)(v28 + 356))
        {
          v80 = 1;
        }
        else
        {
          v80 = 1;
          if (v114 == -65537)
          {
            LOBYTE(v68) = v113;
            if (*(_BYTE *)(v28 + 348) && v67 == 13568)
            {
              LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Will retry update of record %##s without lease option", v55, v56, v57, v58, v59, *(_QWORD *)(v28 + 40));
              *(_BYTE *)(v28 + 348) = 0;
LABEL_102:
              *(_DWORD *)(v28 + 280) = 1000;
              v101 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(v28 + 284) = v101 - 1000;
              if (*(_DWORD *)(a1 + 12680) - v101 >= 0)
                *(_DWORD *)(a1 + 12680) = v101;
              goto LABEL_86;
            }
LABEL_99:
            v100 = *(_QWORD *)(v28 + 640);
            if (!v100 || *(_DWORD *)(v28 + 344) != 2)
            {
              v102 = !v80;
              v103 = v68 ^ 1;
              if (v102)
                v103 = 1;
              if ((v103 & 1) == 0 && *(_QWORD *)(v28 + 104))
              {
                if (mDNS_LoggingEnabled == 1)
                  LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Calling record callback on %##s", v55, v56, v57, v58, v59, *(_QWORD *)(v28 + 40));
                v104 = *(_DWORD *)(a1 + 48);
                v105 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v105;
                mDNS_VerifyLockState("Drop Lock", 0, v104, v105, (uint64_t)"hndlRecordUpdateReply", 3627);
                (*(void (**)(uint64_t, uint64_t, _QWORD))(v28 + 104))(a1, v28, 0);
                mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"hndlRecordUpdateReply", 3629);
                --*(_DWORD *)(a1 + 52);
              }
              goto LABEL_86;
            }
            *(_DWORD *)(v28 + 344) = 7;
            *(_QWORD *)(v28 + 632) = v100;
            *(_WORD *)(v28 + 618) = *(_WORD *)(v28 + 620);
            *(_QWORD *)(v28 + 624) = *(_QWORD *)(v28 + 48);
            *(_WORD *)(v28 + 616) = *(_WORD *)(v28 + 20);
            *(_QWORD *)(v28 + 640) = 0;
            goto LABEL_102;
          }
        }
        LOBYTE(v68) = v113;
        goto LABEL_99;
      default:
        LogMsgWithLevel(v30[295], OS_LOG_TYPE_DEFAULT, "Update %##s failed with rcode %d", v32, v33, v34, v35, v36, *(_QWORD *)(v28 + 40));
        goto LABEL_45;
    }
  }
}

uint64_t ExpectingUnicastResponseForQuestion(uint64_t result, unsigned __int16 a2, unsigned __int16 a3, uint64_t a4, int a5)
{
  uint64_t v8;
  int v9;
  _BYTE *v10;
  unsigned __int16 *v11;

  if (result)
  {
    v8 = result;
    v9 = a2;
    v10 = (_BYTE *)(a4 + 376);
    while (1)
    {
      if (a5)
      {
        v11 = (unsigned __int16 *)(v8 + 338);
      }
      else
      {
        v11 = *(unsigned __int16 **)(v8 + 72);
        if (!v11)
          goto LABEL_11;
      }
      if (*v11 == v9
        && *(unsigned __int16 *)(v8 + 342) == *(unsigned __int16 *)(a4 + 342)
        && *(unsigned __int16 *)(v8 + 344) == *(unsigned __int16 *)(a4 + 344)
        && *(_DWORD *)(v8 + 200) == *(_DWORD *)(a4 + 200)
        && SameDomainNameBytes((_BYTE *)(v8 + 376), v10))
      {
        if (*(unsigned __int16 *)(v8 + 340) == a3)
          return v8;
        else
          return 0;
      }
LABEL_11:
      v8 = *(_QWORD *)(v8 + 8);
      if (!v8)
        return 0;
    }
  }
  return result;
}

uint64_t CloseSocketSet(uint64_t a1)
{
  int v2;
  uint64_t result;
  _DWORD *v4;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2 != -1)
  {
    close(v2);
    *(_DWORD *)(a1 + 16) = -1;
  }
  result = *(unsigned int *)(a1 + 48);
  if ((_DWORD)result != -1)
  {
    result = close(result);
    *(_DWORD *)(a1 + 48) = -1;
  }
  v4 = *(_DWORD **)(a1 + 80);
  if (v4)
    *v4 = 1;
  return result;
}

void SendRecordRegistration(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  uint64_t *AuthInfoForName_internal;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t updated;
  unint64_t v21;
  NSObject *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;

  v4 = (unsigned __int8 *)(a2 + 8);
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
  if (AuthInfoForName_internal)
  {
    v6 = (char *)AuthInfoForName_internal + 268;
    v7 = -360;
    if (AuthInfoForName_internal == (uint64_t *)-524)
      goto LABEL_6;
LABEL_3:
    if (v6 < (_BYTE *)AuthInfoForName_internal + 524 && v6)
    {
      while (1)
      {
        v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_12:
          v7 = -360;
          goto LABEL_14;
        }
        if (!*v6)
          break;
        v6 += v8 + 1;
        if (AuthInfoForName_internal != (uint64_t *)-524)
          goto LABEL_3;
LABEL_6:
        if (!v6)
          goto LABEL_12;
      }
      v7 = -103 - (unsigned __int16)((_WORD)v6 - ((_WORD)AuthInfoForName_internal + 268) + 1);
    }
  }
  else
  {
    v7 = -35;
  }
LABEL_14:
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SendRecordRegistration", 2994);
  v9 = *(_QWORD *)(a2 + 376);
  if (!v9 || !*(_DWORD *)(v9 + 792))
  {
    v37 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: No Zone information, should not happen %s", v38, v39, v40, v41, v42, a1 + 47032);
    return;
  }
  v10 = a1 + 37912 + v7;
  v11 = mDNS_NewMessageID(a1);
  *(_WORD *)(a2 + 358) = v11;
  *(_WORD *)(a1 + 28960) = v11;
  *(_WORD *)(a1 + 28962) = 40;
  *(_QWORD *)(a1 + 28964) = 0;
  v15 = putZone(a1 + 28960, a1 + 28972, v10, *(unsigned __int8 **)(a2 + 368), bswap32(*(unsigned __int16 *)(a2 + 14)) >> 16, v12, v13, v14);
  if (!v15
    || (updated = BuildUpdateMessage(a1, (unint64_t)v15, a2, v10, v16, v17, v18, v19)) == 0
    || (v21 = updated, *(_BYTE *)(a2 + 348)) && (v21 = putUpdateLeaseWithLimit(a1 + 28960, updated, v10)) == 0)
  {
    v43 = mDNSLogCategory_Default;
    v44 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v44);
    LogMsgWithLevel(v43, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: Error formatting message for %s, disabling further updates", v45, v46, v47, v48, v49, (int)v44);
    *(_DWORD *)(a2 + 344) = 8;
    return;
  }
  if (*(_BYTE *)(a2 + 356))
  {
    if ((mDNS_LoggingEnabled & 1) != 0)
    {
      v22 = mDNSLogCategory_Default;
      v23 = (uint64_t *)(a2 + 384);
      v24 = *(_QWORD *)(a2 + 384);
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration TCP %p %s", v25, v26, v27, v28, v29, v24);
      v30 = *(_QWORD *)(a2 + 384);
      if (!v30 || !mDNS_LoggingEnabled)
      {
LABEL_33:
        if (v30)
        {
          DisposeTCPConn(v30);
          *v23 = 0;
        }
        v58 = *(_QWORD *)(a2 + 376);
        if (v58)
        {
          *(_QWORD *)(a2 + 384) = MakeTCPConn(a1, (const void *)(a1 + 28960), v21, 1, (int *)(v58 + 788), *(unsigned __int16 *)(v58 + 786), (_BYTE *)(v58 + 530), 0, a2);
          goto LABEL_37;
        }
        v59 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v59, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration:Private:ERROR!! nta is NULL for %s", v60, v61, v62, v63, v64, a1 + 47032);
        return;
      }
      v31 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: Disposing existing TCP connection for %s", v32, v33, v34, v35, v36, a1 + 47032);
    }
    else
    {
      v23 = (uint64_t *)(a2 + 384);
    }
    v30 = *v23;
    goto LABEL_33;
  }
  if (mDNS_LoggingEnabled)
  {
    v50 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v50, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration UDP %s", v51, v52, v53, v54, v55, a1 + 47032);
  }
  v56 = *(_QWORD *)(a2 + 376);
  if (v56)
  {
    v57 = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
    mDNSSendDNSMessage(a1, a1 + 28960, v21, 0, 0, 0, (int *)(v56 + 788), *(_WORD *)(v56 + 786), v57, 0);
LABEL_37:
    SetRecordRetry(a1, a2, 0);
    return;
  }
  v65 = mDNSLogCategory_Default;
  GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
  LogMsgWithLevel(v65, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration:ERROR!! nta is NULL for %s", v66, v67, v68, v69, v70, a1 + 47032);
}

_WORD *putZone(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;
  _WORD *v11;
  uint64_t v12;

  v8 = a5;
  v11 = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  v12 = 0;
  if (v11 && (unint64_t)(v11 + 2) <= a3)
  {
    *v11 = 1536;
    v11[1] = v8;
    ++*(_WORD *)(a1 + 4);
    return v11 + 2;
  }
  return (_WORD *)v12;
}

_QWORD *MakeTCPConn(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4, int *a5, uint64_t a6, _BYTE *a7, uint64_t a8, uint64_t a9)
{
  __int16 v11;
  int v13;
  int v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  NSObject *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  NSObject *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  int *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  __int16 v68;
  int v69;
  uint8_t buf[4];
  const void *v71;
  __int16 v72;
  unint64_t v73;

  v11 = a6;
  v13 = a4;
  v68 = 0;
  if (a8)
  {
    v17 = *(unsigned __int8 *)(a8 + 640);
    if ((a4 & 1) == 0)
      goto LABEL_7;
  }
  else
  {
    v17 = 0;
    if ((a4 & 1) == 0)
      goto LABEL_7;
  }
  if (!a7 || !*a7)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: TLS connection being setup with NULL hostname", a4, (uint64_t)a5, a6, (uint64_t)a7, a8, v65);
    return 0;
  }
LABEL_7:
  v18 = malloc_type_calloc(1uLL, 0x2358uLL, 0xF1748037uLL);
  if (!v18)
    __break(1u);
  v19 = v18;
  if (a2)
  {
    v20 = a3 - (_QWORD)a2;
    if (a3 < (unint64_t)a2 || v20 >= 8953)
    {
      v21 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          *(_DWORD *)buf = 134218240;
          v71 = a2;
          v72 = 2048;
          v73 = a3;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "MakeTCPConn: invalid DNS message pointers -- msg: %p, end: %p", buf, 0x16u);
        }
      }
      else
      {
        v21 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_17;
      }
LABEL_26:
      free(v19);
      return 0;
    }
    *((_DWORD *)v18 + 2242) = v20;
    memcpy(v18 + 2, a2, (a3 - (_DWORD)a2));
  }
  *v19 = a1;
  v22 = mDNSPlatformTCPSocket(v13, *a5, &v68, a7, v17);
  v19[1] = v22;
  v19[1122] = a8;
  v19[1123] = a9;
  v28 = a5[4];
  *((_OWORD *)v19 + 562) = *(_OWORD *)a5;
  *((_DWORD *)v19 + 2252) = v28;
  *((_WORD *)v19 + 4506) = v11;
  v19[1127] = 0;
  *((_WORD *)v19 + 4512) = 0;
  v19[1129] = 0;
  *((_DWORD *)v19 + 2260) = 0;
  *((_WORD *)v19 + 4507) = v68;
  if (!v22)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: unable to create TCP socket", v23, v24, v25, v26, v27, v65);
    goto LABEL_26;
  }
  if (a8)
  {
    v29 = *((unsigned int *)v22 + 4);
    if ((v29 & 0x80000000) == 0)
    {
      bzero(buf, 0x3F1uLL);
      if (*(_DWORD *)(a8 + 244))
      {
        if (setsockopt(v29, 0xFFFF, 4359, (const void *)(a8 + 244), 4u) == -1)
        {
          v30 = mDNSLogCategory_Default;
          v31 = __error();
          v66 = strerror(*v31);
          LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: Delegate PID failed %s for PID %d", v32, v33, v34, v35, v36, v66);
        }
      }
      else if (setsockopt(v29, 0xFFFF, 4360, (const void *)(a8 + 656), 0x10u) == -1)
      {
        v39 = mDNSLogCategory_Default;
        v40 = __error();
        v67 = strerror(*v40);
        LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: Delegate UUID failed %s", v41, v42, v43, v44, v45, v67);
      }
      ConvertDomainNameToCString_withescape((unsigned __int8 *)(a8 + 376), buf);
      if ((ne_session_set_socket_attributes(v29, buf, 0) & 1) == 0 && mDNS_LoggingEnabled)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: ne_session_set_socket_attributes()-> setting domain failed for %s", v46, v47, v48, v49, v50, (int)buf);
      v69 = 1;
      if (setsockopt(v29, 0xFFFF, 0x10000, &v69, 4u) == -1 && mDNS_LoggingEnabled)
      {
        v51 = mDNSLogCategory_Default;
        v52 = __error();
        v53 = strerror(*v52);
        LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: SO_NOWAKEFROMSLEEP failed %s", v54, v55, v56, v57, v58, v53);
      }
      v22 = (_QWORD *)v19[1];
    }
    v38 = *(_QWORD *)(a8 + 136);
  }
  else
  {
    v38 = 0;
  }
  v59 = mDNSPlatformTCPConnect((uint64_t)v22, a5, v11, v38, (uint64_t)tcpCallback, (uint64_t)v19);
  if (v59 != -65787)
  {
    if (v59 == -65789)
    {
      tcpCallback(v19[1], (uint64_t)v19, 1, 0, v61, v62, v63, v64);
      return v19;
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: connection failed", v60, v61, v62, v63, v64, v65);
    DisposeTCPConn((uint64_t)v19);
    return 0;
  }
  return v19;
}

_QWORD *mDNSPlatformTCPSocket(int a1, int a2, _WORD *a3, _BYTE *a4, int a5)
{
  size_t v10;
  char *v11;
  _QWORD *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned __int16 v16;
  int v17;
  int v18;
  int v19;
  NSObject *v20;
  int v21;
  __int16 v22;
  NSObject *v23;
  int *v24;
  char *v25;
  const char *v26;
  int v27;
  int *v28;
  char *v29;
  int v30;
  NSObject *v31;
  int v32;
  int *v33;
  char *v34;
  int *v35;
  char *v36;
  NSObject *v37;
  int v38;
  int v39;
  int *v40;
  char *v41;
  int v43;
  socklen_t v44;
  int v45;
  uint8_t buf[4];
  char *v47;
  sockaddr v48[2];

  v43 = 0x4000;
  if (a4)
    v10 = 344;
  else
    v10 = 88;
  v11 = (char *)malloc_type_calloc(1uLL, v10, 0xF1748037uLL);
  if (!v11)
    __break(1u);
  v12 = v11;
  if (a4)
  {
    v13 = v11 + 88;
    v12[6] = v12 + 11;
    v14 = a4;
    if (a4 == (_BYTE *)-256)
    {
LABEL_8:
      while (v14)
      {
        v15 = *v14;
        if (v15 > 0x3F)
          break;
        if (!*v14)
        {
          v16 = (_WORD)v14 - (_WORD)a4 + 1;
          if (v16 > 0x100u)
            break;
          memcpy(v13, a4, v16);
          goto LABEL_16;
        }
        v14 += v15 + 1;
        if (a4 != (_BYTE *)-256)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      if (v14 < a4 + 256)
        goto LABEL_8;
    }
    *v13 = 0;
  }
LABEL_16:
  if (a2 == 4)
    v17 = 2;
  else
    v17 = 30;
  v45 = 15384;
  v18 = socket(v17, 1, 6);
  v19 = v18;
  if (v18 <= 2)
  {
    if (*__error() != 47)
    {
      v20 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_43:
          v27 = *__error();
          v28 = __error();
          v29 = strerror(*v28);
          *(_DWORD *)&v48[0].sa_len = 67109634;
          *(_DWORD *)&v48[0].sa_data[2] = v19;
          *(_WORD *)&v48[0].sa_data[6] = 1024;
          *(_DWORD *)&v48[0].sa_data[8] = v27;
          *(_WORD *)&v48[0].sa_data[12] = 2082;
          *(_QWORD *)&v48[1].sa_len = v29;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "mDNSPosixTCPSocketSetup: socket error %d errno %d (%{public}s)", &v48[0].sa_len, 0x18u);
        }
      }
      else
      {
        v20 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_43;
      }
    }
    v19 = -1;
    goto LABEL_45;
  }
  memset(v48, 0, 28);
  if (a3)
  {
    v21 = a2 == 4 ? 16 : 28;
    *(_OWORD *)&v48[0].sa_data[10] = 0uLL;
    *(_QWORD *)&v48[0].sa_data[2] = 0;
    v48[0].sa_family = v17;
    v48[0].sa_len = v21;
    *(_WORD *)v48[0].sa_data = *a3;
    if (bind(v18, v48, v21) < 0)
    {
      v23 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_68;
      }
      else
      {
        v23 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_68;
      }
      v33 = __error();
      v34 = strerror(*v33);
      *(_DWORD *)buf = 136446210;
      v47 = v34;
      v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
      goto LABEL_67;
    }
  }
  v44 = 28;
  if (getsockname(v19, v48, &v44) < 0)
  {
    v23 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_68;
    }
    else
    {
      v23 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_68;
    }
    v24 = __error();
    v25 = strerror(*v24);
    *(_DWORD *)buf = 136446210;
    v47 = v25;
    v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
LABEL_67:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v26, buf, 0xCu);
    goto LABEL_68;
  }
  v22 = *(_WORD *)v48[0].sa_data;
  *(_WORD *)v12 = *(_WORD *)v48[0].sa_data;
  if (a3)
    *a3 = v22;
  if (setsockopt(v19, 6, 513, &v45, 4u) < 0)
  {
    v23 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_66:
        v35 = __error();
        v36 = strerror(*v35);
        *(_DWORD *)buf = 136446210;
        v47 = v36;
        v26 = "mDNSPosixTCPSocketSetup: TCP_NOTSENT_LOWAT failed: %{public}s";
        goto LABEL_67;
      }
    }
    else
    {
      v23 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_66;
    }
LABEL_68:
    close(v19);
    v37 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_73:
        v38 = *((_DWORD *)v12 + 4);
        v39 = *__error();
        v40 = __error();
        v41 = strerror(*v40);
        *(_DWORD *)&v48[0].sa_len = 67109634;
        *(_DWORD *)&v48[0].sa_data[2] = v38;
        *(_WORD *)&v48[0].sa_data[6] = 1024;
        *(_DWORD *)&v48[0].sa_data[8] = v39;
        *(_WORD *)&v48[0].sa_data[12] = 2082;
        *(_QWORD *)&v48[1].sa_len = v41;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTCPSocket: socket error %d errno %d (%{public}s)", &v48[0].sa_len, 0x18u);
      }
    }
    else
    {
      v37 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_73;
    }
    free(v12);
    return 0;
  }
LABEL_45:
  if (a5)
    v30 = 100;
  else
    v30 = 900;
  *(_DWORD *)&v48[0].sa_len = v30;
  setsockopt(v19, 0xFFFF, 4230, v48, 4u);
  *((_DWORD *)v12 + 4) = v19;
  v12[3] = tcpKQSocketCallback;
  v12[4] = v12;
  v12[5] = "mDNSPlatformTCPSocket";
  if (setsockopt(v19, 6, 513, &v43, 4u) < 0)
  {
    v31 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        v32 = *__error();
        *(_DWORD *)&v48[0].sa_len = 67109120;
        *(_DWORD *)&v48[0].sa_data[2] = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTCPSocket: TCP_NOTSENT_LOWAT returned %d", &v48[0].sa_len, 8u);
      }
    }
    else
    {
      v31 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_55;
    }
    mDNSPlatformTCPCloseConnection(v12);
    return 0;
  }
  v12[1] = 0;
  *((_DWORD *)v12 + 1) = a1;
  v12[7] = 0;
  *((_WORD *)v12 + 32) = 0;
  *((_DWORD *)v12 + 17) = 0;
  v12[9] = &mDNSStorage;
  *((_DWORD *)v12 + 20) = 0;
  return v12;
}

uint64_t mDNSPlatformTCPConnect(uint64_t a1, _DWORD *a2, __int16 a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v9;
  socklen_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t i;
  int v15;
  const void *v16;
  int v17;
  int v18;
  uint64_t v19;
  NSObject *v21;
  NSObject *v22;
  int *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  const char *v28;
  int v30;
  int v31;
  int *v32;
  char *v33;
  NSObject *v34;
  uint32_t v35;
  _BOOL4 v36;
  _BOOL4 v37;
  uint64_t v38;
  int v39;
  int v40;
  int *v41;
  char *v42;
  uint8_t buf[4];
  _BYTE v44[10];
  __int16 v45;
  char *v46;
  __int16 v47;
  int sa_len;
  sockaddr v49[8];

  memset(v49, 0, sizeof(v49));
  *(_QWORD *)(a1 + 8) = a5;
  *(_QWORD *)(a1 + 56) = a6;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  v9 = a2 + 1;
  if (*a2 == 4)
  {
    v49[0].sa_family = 2;
    *(_WORD *)v49[0].sa_data = a3;
    *(_DWORD *)&v49[0].sa_data[2] = *v9;
    v10 = 16;
  }
  else
  {
    memset(&v49[0].sa_data[6], 0, 20);
    *(_QWORD *)&v49[0].sa_len = 7680;
    *(_WORD *)v49[0].sa_data = a3;
    *(sockaddr *)&v49[0].sa_data[6] = *(sockaddr *)v9;
    v10 = 28;
  }
  v49[0].sa_len = v10;
  if (KQueueSet(*(_DWORD *)(a1 + 16), 1u, -2, (void *)(a1 + 24)))
  {
    v11 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_20;
      }
    }
    else
    {
      v11 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPlatformTCPConnect - KQueueSet failed", buf, 2u);
      }
    }
    return *__error();
  }
  v12 = *(_DWORD *)(a1 + 16);
  v13 = fcntl(v12, 3, 0);
  if (fcntl(v12, 4, v13 | 4u) < 0)
  {
    v21 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_36:
        v23 = __error();
        v24 = strerror(*v23);
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v44 = v24;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ERROR: setsockopt O_NONBLOCK - %{public}s", buf, 0xCu);
      }
    }
    else
    {
      v21 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_36;
    }
    return 4294901759;
  }
  if (!a4)
  {
LABEL_30:
    if ((connect(*(_DWORD *)(a1 + 16), v49, v10) & 0x80000000) == 0)
    {
      v22 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        v19 = 0;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          return v19;
        *(_WORD *)buf = 0;
      }
      else
      {
        v22 = mDNSLogCategory_NAT_redacted;
        v19 = 0;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          return v19;
        *(_WORD *)buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "NOTE: mDNSPlatformTCPConnect completed synchronously", buf, 2u);
      return 0;
    }
    v19 = 4294901508;
    if (*__error() == 36)
      return 4294901509;
    if (*__error() == 65 || *__error() == 49 || *__error() == 50)
    {
      v25 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          return v19;
      }
      else
      {
        v25 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          return v19;
      }
      v30 = *(_DWORD *)(a1 + 16);
      v31 = *__error();
      v32 = __error();
      v33 = strerror(*v32);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)v44 = v30;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v31;
      v45 = 2082;
      v46 = v33;
      v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s)";
      v34 = v25;
      v35 = 24;
    }
    else
    {
      v38 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          return v19;
      }
      else
      {
        v38 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          return v19;
      }
      v39 = *(_DWORD *)(a1 + 16);
      v40 = *__error();
      v41 = __error();
      v42 = strerror(*v41);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v44 = v39;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v40;
      v45 = 2082;
      v46 = v42;
      v47 = 1024;
      sa_len = v49[0].sa_len;
      v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s) length %d";
      v34 = v38;
      v35 = 30;
    }
LABEL_71:
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v28, buf, v35);
    return v19;
  }
  for (i = *(_QWORD *)mDNSStorage; i; i = *(_QWORD *)(i + 3680))
  {
    if (*(_QWORD *)(i + 3776) && *(_DWORD *)(i + 3720) == (_DWORD)a4)
      break;
  }
  if (*a2 == 4)
  {
    if (i)
    {
      v15 = *(_DWORD *)(a1 + 16);
      v16 = (const void *)(i + 3720);
      v17 = 0;
      v18 = 25;
LABEL_29:
      setsockopt(v15, v17, v18, v16, 4u);
      goto LABEL_30;
    }
    v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      v19 = 4294901756;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return v19;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v44 = a4;
      v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
    v26 = mDNSLogCategory_NAT_redacted;
    v36 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    v19 = 4294901756;
    if (v36)
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v44 = a4;
      v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
LABEL_70:
      v34 = v26;
      v35 = 12;
      goto LABEL_71;
    }
  }
  else
  {
    if (i)
    {
      v15 = *(_DWORD *)(a1 + 16);
      v16 = (const void *)(i + 3720);
      v17 = 41;
      v18 = 125;
      goto LABEL_29;
    }
    v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      v19 = 4294901756;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return v19;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v44 = a4;
      v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
    v26 = mDNSLogCategory_NAT_redacted;
    v37 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    v19 = 4294901756;
    if (v37)
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v44 = a4;
      v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
  }
  return v19;
}

uint64_t tcpKQSocketCallback(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  char *v10;
  int v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  int v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  BOOL v29;
  int v31;
  socklen_t v32;
  int __errnum;

  *(_DWORD *)(a3 + 80) = 0;
  if (a2 != -2)
    goto LABEL_18;
  if (*(_BYTE *)(a3 + 65))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v9 = mDNSLogCategory_Default;
      v10 = "ERROR: TCPConnectCallback called with write event when socket is connected.";
LABEL_11:
      LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, v10, a4, a5, a6, a7, a8, v31);
    }
  }
  else
  {
    v32 = 4;
    __errnum = 0;
    if (getsockopt(a1, 0xFFFF, 4103, &__errnum, &v32) < 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        v14 = mDNSLogCategory_Default;
        v15 = *(_DWORD *)(a3 + 16);
        __error();
        v16 = __error();
        strerror(*v16);
        LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "ERROR: TCPConnectCallback - unable to get connect error: socket %d: Error %d (%s)", v17, v18, v19, v20, v21, v15);
      }
      *(_DWORD *)(a3 + 80) = -65788;
      goto LABEL_15;
    }
    v11 = __errnum;
    if (__errnum)
    {
      *(_DWORD *)(a3 + 80) = -65788;
      if ((v11 - 49) > 0x10 || ((1 << (v11 - 49)) & 0x10003) == 0 || mDNS_LoggingEnabled == 1)
      {
        v12 = mDNSLogCategory_Default;
        v13 = *(_DWORD *)(a3 + 16);
        strerror(v11);
        v31 = v13;
        v10 = "ERROR: TCPConnectCallback - connect failed: socket %d: Error %d (%s)";
        v9 = v12;
        goto LABEL_11;
      }
    }
  }
LABEL_15:
  KQueueSet(*(_DWORD *)(a3 + 16), 2u, -2, (void *)(a3 + 24));
  if (!*(_DWORD *)(a3 + 80) && KQueueSet(*(_DWORD *)(a3 + 16), 1u, -1, (void *)(a3 + 24)))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: tcpKQSocketCallback - KQueueSet failed", v22, v23, v24, v25, v26, v31);
    *(_DWORD *)(a3 + 80) = -65562;
  }
LABEL_18:
  if ((*(_BYTE *)(a3 + 4) & 1) != 0)
  {
    v27 = 4294901752;
    *(_DWORD *)(a3 + 80) = -65544;
    v28 = *(_BYTE *)(a3 + 65) == 0;
  }
  else
  {
    v27 = *(unsigned int *)(a3 + 80);
    v28 = *(_BYTE *)(a3 + 65) == 0;
    if (*(_BYTE *)(a3 + 65))
      v29 = 0;
    else
      v29 = (_DWORD)v27 == 0;
    if (v29)
    {
      v27 = 0;
      v28 = 1;
      *(_BYTE *)(a3 + 65) = 1;
    }
  }
  return (*(uint64_t (**)(uint64_t, _QWORD, _BOOL8, uint64_t))(a3 + 8))(a3, *(_QWORD *)(a3 + 56), v28, v27);
}

void tcpCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  char v16;
  int32x2_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int32 v29;
  int32x4_t v30;
  unsigned int v31;
  int32x4_t v32;
  int8x16_t v33;
  int8x16_t v34;
  unsigned __int16 *v35;
  uint64_t v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t *AuthInfoForName_internal;
  unint64_t v40;
  ssize_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  size_t v48;
  uint64_t v49;
  _BYTE *v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  ssize_t v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unint64_t v67;
  char v68;
  NSObject *v69;
  _BYTE *i;
  uint64_t v71;
  unint64_t v72;
  _BYTE *k;
  uint64_t v74;
  _BYTE *j;
  uint64_t v76;
  _BYTE *m;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  NSObject *v81;
  ssize_t v82;
  ssize_t v83;
  char *v84;
  char *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  int v91;
  const char *v92;
  const char *v93;
  uint64_t v94;
  unsigned int v95;
  NSObject *v96;
  _BYTE *v97;
  uint64_t v98;
  _BYTE *v99;
  uint64_t v100;
  int v101;
  const char *v102;
  const char *v103;
  const char *v104;
  uint64_t v105;
  int v106;
  unsigned int v107;
  char v108;
  uint8_t buf[16];
  _BYTE v110[14];
  __int16 v111;
  _BYTE v112[28];

  v8 = a4;
  v108 = 0;
  v12 = *(_QWORD *)a2;
  v13 = *(_QWORD *)(a2 + 8976);
  if (v13)
  {
    v14 = (_QWORD *)(v13 + 112);
  }
  else
  {
    v15 = *(_QWORD *)(a2 + 8984);
    if (!v15)
    {
      v14 = 0;
      v16 = 1;
      if ((_DWORD)a4)
        goto LABEL_8;
      goto LABEL_24;
    }
    v14 = (_QWORD *)(v15 + 384);
  }
  if (*v14 != a2)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "tcpCallback: %d backpointer %p incorrect tcpInfo %p question %p rr %p", a4, a5, a6, a7, a8, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 16));
  v16 = 0;
  if (v8)
  {
LABEL_8:
    if ((v16 & 1) == 0)
      *v14 = 0;
    mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1541);
    if (!v13)
      goto LABEL_150;
    v18 = *(_DWORD *)(v13 + 212);
    if (v18)
    {
      v19 = *(_DWORD *)(v13 + 208) + v18;
      v20 = *(_DWORD *)(v12 + 64);
      v21 = v19 - v20;
      if (*(_BYTE *)(v13 + 632))
        v22 = 900000;
      else
        v22 = 3600000;
      if (v21 > v22)
      {
        *(_DWORD *)(v13 + 208) = v20;
        *(_DWORD *)(v13 + 212) = v22;
        SetNextQueryTime(v12, v13);
        v23 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms", v24, v25, v26, v27, v28, v13 + 376);
      }
    }
    else
    {
      *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
      if (*(_BYTE *)(v13 + 632))
      {
        v29 = *(__int16 *)(v13 + 348);
        *(_DWORD *)(v13 + 212) = 334;
        if (v29 == -1)
          goto LABEL_40;
        v17.i32[0] = v29;
        v30 = (int32x4_t)xmmword_100100930;
        v31 = (v29 & 0xFFFFFFFC) + 4;
        v32.i64[0] = 0x300000003;
        v32.i64[1] = 0x300000003;
        do
        {
          v33 = (int8x16_t)v30;
          v30 = vmulq_s32(v30, v32);
          v31 -= 4;
        }
        while (v31);
        v34 = vbslq_s8((int8x16_t)vcgtq_u32((uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32(v29 & 0xFFFFFFFC), (int8x16_t)xmmword_100100940), (uint32x4_t)vdupq_lane_s32(v17, 0)), v33, (int8x16_t)v30);
        *(int32x2_t *)v34.i8 = vmul_s32(*(int32x2_t *)v34.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
        *(_DWORD *)(v13 + 212) = v34.i32[0] * v34.i32[1];
        if (v34.i32[0] * v34.i32[1] <= 900000)
LABEL_40:
          *(_WORD *)(v13 + 348) = v29 + 1;
        else
          *(_DWORD *)(v13 + 212) = 900000;
        v51 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for LLQ %##s (%s) failed %d times, retrying in %d ms", v52, v53, v54, v55, v56, v13 + 376);
      }
      else
      {
        *(_DWORD *)(v13 + 212) = 3600000;
        v60 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms", v61, v62, v63, v64, v65, v13 + 376);
      }
      SetNextQueryTime(v12, v13);
    }
    if (!*(_BYTE *)(v13 + 632))
      goto LABEL_150;
    v66 = *(unsigned __int8 *)(v13 + 350);
    if (v66 == 21)
    {
      *(_BYTE *)(v13 + 350) = 20;
      if (v8 == -65788)
        goto LABEL_150;
    }
    else if (v8 == -65788 || v66 == 30)
    {
      goto LABEL_150;
    }
    v67 = v13 + 632;
    v106 = *(_DWORD *)(v13 + 252);
    v107 = bswap32(*(unsigned __int16 *)(v13 + 340)) >> 16;
    v68 = gSensitiveLoggingEnabled;
    v69 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
      v68 = 0;
    if (*(_DWORD *)(v13 + 212) != -1)
    {
      if ((v68 & 1) != 0)
      {
        v69 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_121;
        for (i = (_BYTE *)(v13 + 376); ; i += v71 + 1)
        {
          if ((unint64_t)i >= v67 || !i || (v71 = *i, v71 > 0x3F))
          {
            v90 = 257;
            goto LABEL_120;
          }
          if (!*i)
            break;
        }
        v90 = (unsigned __int16)((_WORD)i - (v13 + 376) + 1);
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_121;
        for (j = (_BYTE *)(v13 + 376); ; j += v76 + 1)
        {
          if ((unint64_t)j >= v67 || !j || (v76 = *j, v76 > 0x3F))
          {
            v90 = 257;
            goto LABEL_120;
          }
          if (!*j)
            break;
        }
        v90 = (unsigned __int16)((_WORD)j - (v13 + 376) + 1);
      }
LABEL_120:
      v92 = DNSTypeName(*(unsigned __int16 *)(v13 + 342));
      v93 = LLQStateToString(*(unsigned __int8 *)(v13 + 350));
      *(_DWORD *)buf = 67110659;
      *(_DWORD *)&buf[4] = v106;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v107;
      *(_WORD *)&buf[14] = 2160;
      *(_QWORD *)v110 = 1752392040;
      *(_WORD *)&v110[8] = 1040;
      *(_DWORD *)&v110[10] = v90;
      v111 = 2101;
      *(_QWORD *)v112 = v13 + 376;
      *(_WORD *)&v112[8] = 2082;
      *(_QWORD *)&v112[10] = v92;
      *(_WORD *)&v112[18] = 2082;
      *(_QWORD *)&v112[20] = v93;
      _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Starting long-lived query polling - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, LLQ_State: %{public}s.", buf, 0x3Cu);
LABEL_121:
      v94 = *(_QWORD *)(v13 + 104);
      if (!v94)
      {
LABEL_146:
        *(_BYTE *)(v13 + 350) = 30;
        *(_DWORD *)(v13 + 212) = 3000;
        *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64) - 2999;
        SetNextQueryTime(v12, v13);
        goto LABEL_150;
      }
      v95 = bswap32(*(unsigned __int16 *)(v94 + 1172)) >> 16;
      v96 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          v99 = (_BYTE *)(v94 + 1208);
          if (v94 == -1464)
          {
LABEL_135:
            while (v99)
            {
              v100 = *v99;
              if (v100 > 0x3F)
                break;
              if (!*v99)
              {
                v101 = (unsigned __int16)((_WORD)v99 - (v94 + 1208) + 1);
                goto LABEL_144;
              }
              v99 += v100 + 1;
              if (v94 != -1464)
                goto LABEL_134;
            }
          }
          else
          {
LABEL_134:
            if ((unint64_t)v99 < v94 + 1464)
              goto LABEL_135;
          }
          v101 = 257;
          goto LABEL_144;
        }
      }
      else
      {
        v96 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v97 = (_BYTE *)(v94 + 1208);
          if (v94 == -1464)
          {
LABEL_127:
            while (v97)
            {
              v98 = *v97;
              if (v98 > 0x3F)
                break;
              if (!*v97)
              {
                v101 = (unsigned __int16)((_WORD)v97 - (v94 + 1208) + 1);
                goto LABEL_144;
              }
              v97 += v98 + 1;
              if (v94 != -1464)
                goto LABEL_126;
            }
          }
          else
          {
LABEL_126:
            if ((unint64_t)v97 < v94 + 1464)
              goto LABEL_127;
          }
          v101 = 257;
LABEL_144:
          v102 = DNSTypeName(*(unsigned __int16 *)(v94 + 1174));
          *(_DWORD *)buf = 67110659;
          *(_DWORD *)&buf[4] = v106;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v107;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)v110 = v95;
          *(_WORD *)&v110[4] = 2160;
          *(_QWORD *)&v110[6] = 1752392040;
          v111 = 1040;
          *(_DWORD *)v112 = v101;
          *(_WORD *)&v112[4] = 2101;
          *(_QWORD *)&v112[6] = v94 + 1208;
          *(_WORD *)&v112[14] = 2082;
          *(_QWORD *)&v112[16] = v102;
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u->subQ%u] Stop getting the zone data - zone qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, zone qtype: %{public}s.", buf, 0x38u);
        }
      }
      CancelGetZoneData(v12, *(_DWORD **)(v13 + 104));
      *(_QWORD *)(v13 + 104) = 0;
      goto LABEL_146;
    }
    if ((v68 & 1) != 0)
    {
      v69 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (k = (_BYTE *)(v13 + 376); ; k += v74 + 1)
        {
          if ((unint64_t)k >= v67 || !k || (v74 = *k, v74 > 0x3F))
          {
            v91 = 257;
            goto LABEL_149;
          }
          if (!*k)
            break;
        }
        v91 = (unsigned __int16)((_WORD)k - (v13 + 376) + 1);
LABEL_149:
        v103 = DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        v104 = LLQStateToString(*(unsigned __int8 *)(v13 + 350));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&buf[4] = v106;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v107;
        *(_WORD *)&buf[14] = 2160;
        *(_QWORD *)v110 = 1752392040;
        *(_WORD *)&v110[8] = 1040;
        *(_DWORD *)&v110[10] = v91;
        v111 = 2101;
        *(_QWORD *)v112 = v13 + 376;
        *(_WORD *)&v112[8] = 2082;
        *(_QWORD *)&v112[10] = v103;
        *(_WORD *)&v112[18] = 2082;
        *(_QWORD *)&v112[20] = v104;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, "[R%u->Q%u] Not starting long-lived query polling since the question has been stopped - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, LLQ_State: %{public}s.", buf, 0x3Cu);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
      for (m = (_BYTE *)(v13 + 376); ; m += v78 + 1)
      {
        if ((unint64_t)m >= v67 || !m || (v78 = *m, v78 > 0x3F))
        {
          v91 = 257;
          goto LABEL_149;
        }
        if (!*m)
          break;
      }
      v91 = (unsigned __int16)((_WORD)m - (v13 + 376) + 1);
      goto LABEL_149;
    }
LABEL_150:
    mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1603);
    DisposeTCPConn(a2);
    return;
  }
LABEL_24:
  v35 = (unsigned __int16 *)(a2 + 9012);
  if (!a3)
  {
    v40 = *(_QWORD *)(a2 + 9032);
    if (v40 >= 2)
    {
      v57 = *(char **)(a2 + 9016);
      v58 = *(_QWORD *)(a2 + 9032);
    }
    else
    {
      v41 = mDNSPlatformReadTCP(a1, (char *)v35 + v40 + 12, 2 - v40, &v108);
      if (v41 < 0)
      {
        v8 = -65788;
        v79 = mDNSLogCategory_Default;
        LODWORD(v105) = v41;
        v80 = "ERROR: tcpCallback - attempt to read message length failed (%d)";
        goto LABEL_100;
      }
      if (v108)
      {
LABEL_45:
        if (*(_DWORD *)(a2 + 9040))
        {
          if ((v16 & 1) == 0)
            *v14 = 0;
          DisposeTCPConn(a2);
          return;
        }
        v8 = -65788;
        v81 = mDNSLogCategory_Default;
        v105 = *(_QWORD *)(a2 + 9032);
        v80 = "ERROR: socket closed prematurely tcpInfo->nread = %d";
LABEL_102:
        LogMsgWithLevel(v81, OS_LOG_TYPE_DEFAULT, v80, v42, v43, v44, v45, v46, v105);
        goto LABEL_8;
      }
      v47 = *(_QWORD *)(a2 + 9032) + v41;
      *(_QWORD *)(a2 + 9032) = v47;
      if (v47 < 2)
        return;
      v48 = __rev16(*(unsigned __int16 *)(a2 + 9024));
      *(_WORD *)(a2 + 9024) = v48;
      if (v48 <= 0xB)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: tcpCallback - length too short (%d bytes)", v42, v43, v44, v45, v46, v48);
LABEL_70:
        v8 = -65537;
        goto LABEL_8;
      }
      v57 = (char *)malloc_type_malloc(v48, 0xA172743EuLL);
      if (!v57)
        __break(1u);
      *(_QWORD *)(a2 + 9016) = v57;
      v58 = *(_QWORD *)(a2 + 9032);
    }
    v59 = mDNSPlatformReadTCP(a1, &v57[v58 - 2], *(unsigned __int16 *)(a2 + 9024) - (v58 - 2), &v108);
    if ((v59 & 0x8000000000000000) == 0)
    {
      if (v108)
        goto LABEL_45;
      v82 = *(_QWORD *)(a2 + 9032) + v59;
      *(_QWORD *)(a2 + 9032) = v82;
      v83 = v82 - 2;
      if (v83 != *(unsigned __int16 *)(a2 + 9024))
        return;
      v84 = *(char **)(a2 + 9016);
      v85 = &v84[v83];
      *(_OWORD *)buf = *(_OWORD *)(a2 + 8992);
      *(_DWORD *)v110 = *(_DWORD *)(a2 + 9008);
      v86 = *v35;
      ++*(_DWORD *)(a2 + 9040);
      *(_QWORD *)(a2 + 9016) = 0;
      *(_QWORD *)(a2 + 9032) = 0;
      *(_WORD *)(a2 + 9024) = 0;
      v87 = *(_DWORD *)(a1 + 4);
      if (v13)
      {
        v88 = *(_QWORD *)(v13 + 112);
        if (v88)
        {
          v89 = *(unsigned __int16 *)(v88 + 9014);
          *(_WORD *)(v13 + 338) = v89;
        }
        else
        {
          v89 = 0;
        }
        if ((v16 & 1) == 0 && (!*(_BYTE *)(v13 + 632) || *(_BYTE *)(v12 + 141)))
          goto LABEL_160;
      }
      else
      {
        v89 = 0;
        if ((v16 & 1) == 0)
        {
LABEL_160:
          *v14 = 0;
          DisposeTCPConn(a2);
        }
      }
      mDNSCoreReceive(v12, v84, v85, buf, v86, v87 & 1, v89, 0);
      if (v84)
        free(v84);
      return;
    }
    if (v40 < 2)
      return;
    v8 = -65788;
    v79 = mDNSLogCategory_Default;
    LODWORD(v105) = v59;
    v80 = "ERROR: tcpCallback - read returned %d";
LABEL_100:
    v81 = v79;
    goto LABEL_102;
  }
  v36 = *(int *)(a2 + 8968);
  v37 = *(_QWORD *)(a2 + 8984);
  if (v37)
  {
    v38 = *(_BYTE **)(v37 + 40);
    if (v38 == (_BYTE *)(v37 + 652))
    {
LABEL_29:
      if (v38 != (_BYTE *)(v37 + 652))
        return;
      mDNS_Lock_((unsigned int *)v12, (uint64_t)"GetAuthInfoForName", 434);
      AuthInfoForName_internal = GetAuthInfoForName_internal(v12, v38);
      mDNS_Unlock_(v12, (uint64_t)"GetAuthInfoForName", 436);
      goto LABEL_38;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "tcpCallback: ERROR: tcpInfo->rr->resrec.name %p != &tcpInfo->rr->namestorage %p", a4, a5, a6, a7, a8, (int)v38);
    v37 = *(_QWORD *)(a2 + 8984);
    if (v37)
    {
      v38 = *(_BYTE **)(v37 + 40);
      goto LABEL_29;
    }
  }
  AuthInfoForName_internal = 0;
LABEL_38:
  v49 = a2 + 16;
  if (v13)
  {
    *(_WORD *)(a2 + 16) = *(_WORD *)(v13 + 340);
    *(_WORD *)(a2 + 18) = 1;
    *(_QWORD *)(a2 + 20) = 0;
    v50 = putQuestion(a2 + 16, a2 + 28, a2 + 8968, (unsigned __int8 *)(v13 + 376), *(unsigned __int16 *)(v13 + 342), *(unsigned __int16 *)(v13 + 344), a7, a8);
    AuthInfoForName_internal = *(uint64_t **)(v13 + 32);
  }
  else
  {
    v50 = (_BYTE *)(v49 + v36);
  }
  if (mDNSSendDNSMessage(v12, a2 + 16, (unint64_t)v50, 0, (unsigned __int16 *)a1, 0, (int *)(a2 + 8992), *v35, AuthInfoForName_internal, 0))goto LABEL_70;
  if (*v35 == 13568)
  {
    if (v13)
    {
      v72 = *(_QWORD *)(v13 + 80);
      if (v72)
        v72 = ((unint64_t)*(unsigned __int16 *)(v72 + 276) >> 3) & 1;
    }
    else
    {
      LODWORD(v72) = 0;
    }
    if ((__int128 *)((char *)&s_dns_analytics + 104 * v72))
      *((_QWORD *)&s_dns_analytics + 13 * v72 + 2) += ((_DWORD)v50 - v49);
  }
  if (v13)
  {
    mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1406);
    *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
    if (*(int *)(v13 + 212) < 256000)
      *(_DWORD *)(v13 + 212) = 256000;
    SetNextQueryTime(v12, v13);
    mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1411);
  }
}

int MD5_Update(_MD5_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned __int8 *v4;
  _MD5_CTX *v5;
  char *v6;
  unint64_t Nl;
  unsigned int v8;
  unsigned int Nh;
  unint64_t num;
  size_t v11;
  unsigned __int8 *v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int D;
  unsigned int v18;
  unsigned int B;
  unsigned int A;
  _DWORD *v21;
  size_t v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  int v75;
  unsigned int v76;
  int v77;
  unsigned int v78;
  int v79;
  unsigned int v80;
  int v81;
  unsigned int v82;
  int v83;
  unsigned int v84;
  int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  int v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  int v99;
  unsigned int v100;
  int v101;
  unsigned int v102;
  int v103;
  unsigned int v104;
  int v105;
  unsigned int v106;
  int v107;
  unsigned int v108;
  int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  int v113;
  unsigned int v114;
  int v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  int v119;
  unsigned int v120;
  int v121;
  unsigned int v122;
  int v123;
  unsigned int v124;
  int v125;
  unsigned int v126;
  int v127;
  unsigned int v128;
  int v129;
  unsigned int v130;
  int v131;
  unsigned int v132;
  int v133;
  unsigned int v134;
  int v135;
  unsigned int v136;
  int v137;
  unsigned int v138;
  int v139;
  unsigned int v140;
  int v141;
  unsigned int v142;
  int v143;
  unsigned int v144;
  int v145;
  int v146;
  unsigned int v147;
  int v148;
  unsigned int v149;
  int v150;
  unsigned int v151;
  int v152;
  unsigned int v153;
  int v154;
  unsigned int v155;
  int v156;
  unsigned int v157;
  int v158;
  unsigned int v159;
  int v160;
  unsigned int v161;
  int v162;
  unsigned int v163;
  int v164;
  unsigned int v165;
  unsigned int *v166;
  int v167;
  int v168;
  uint64_t v169;
  unsigned int v170;
  BOOL v172;
  unsigned int v173;
  unsigned __int8 *v174;
  int v175;
  int v176;
  unsigned int v177;
  unsigned int v178;
  int v179;
  unint64_t v180;
  int v181;
  unsigned int v182;
  uint64_t v183;
  unsigned __int8 *v184;
  int v185;
  int v186;
  unsigned int *v187;
  unsigned int v188;
  unint64_t v189;
  int64_t v190;
  unsigned int v191;
  int v192;
  char *v193;
  int v194;
  int v195;
  size_t v198;
  char *v200;
  _MD5_CTX *v203;

  if (!len)
    return (int)c;
  v3 = len;
  v4 = (unsigned __int8 *)data;
  v5 = c;
  v6 = (char *)data + len;
  Nl = c->Nl;
  v8 = Nl + 8 * len;
  if (Nl <= v8)
    Nh = c->Nh;
  else
    Nh = c->Nh + 1;
  c->Nl = v8;
  c->Nh = Nh + (len >> 29);
  num = c->num;
  v11 = len;
  v12 = (unsigned __int8 *)data;
  if ((_DWORD)num)
  {
    v13 = c->data;
    v14 = num >> 2;
    v15 = num & 3;
    v16 = num + len;
    if (num + len >= 0x40)
      __asm { BR              X13 }
    c->num = v16;
    if (v15 + len <= 3)
    {
      v177 = v13[v14];
      if ((_DWORD)v15 == 2
        || ((_DWORD)v15 == 1 || (num & 3) == 0 && (v178 = *v4, ++v4, v177 = v178, v3 = len - 1, len != 1))
        && (v179 = *v4, ++v4, v177 |= v179 << 8, v3 != 1))
      {
        v177 |= *v4 << 16;
      }
      v13[v14] = v177;
      return (int)c;
    }
    v180 = v16 >> 2;
    v181 = v16 & 3;
    if ((num & 3) != 0)
    {
      v182 = v13[v14];
      v183 = v14;
      v184 = v4;
      if ((_DWORD)v15 != 1)
      {
        if ((_DWORD)v15 != 2)
        {
LABEL_42:
          v187 = (unsigned int *)(v184 + 1);
          v13[v183] = v182 | (*v184 << 24);
          v188 = v14 + 1;
          if (v188 < v180 && v6 - (char *)v187 >= 4)
          {
            v189 = num >> 2;
            v190 = &v4[len] - v184 - 5;
            do
            {
              v191 = *v187++;
              c->data[v189 + 1] = v191;
              v188 = v189 + 2;
              if (v189 + 2 >= v180)
                break;
              ++v189;
              v172 = v190 <= 3;
              v190 -= 4;
            }
            while (!v172);
          }
          if ((v16 & 3) != 0)
          {
            v192 = 0;
            v193 = (char *)v187 + (v16 & 3);
            if (v181 != 1)
            {
              if (v181 != 2)
              {
                v194 = *--v193;
                v192 = v194 << 16;
              }
              v195 = *--v193;
              v192 |= v195 << 8;
            }
            v13[v188] = v192 | *(v193 - 1);
          }
          return (int)c;
        }
LABEL_41:
        v186 = *v184++;
        v182 |= v186 << 16;
        goto LABEL_42;
      }
    }
    else
    {
      v184 = v4 + 1;
      v182 = *v4;
      v183 = v14;
    }
    v185 = *v184++;
    v182 |= v185 << 8;
    goto LABEL_41;
  }
  if ((int)(len >> 6) >= 1)
  {
    v200 = (char *)data + len;
    v18 = c->C;
    D = c->D;
    A = c->A;
    B = c->B;
    v198 = v11 >> 6;
    v21 = data;
    v22 = v11 >> 6;
    v203 = c;
    do
    {
      v23 = v21[1];
      v24 = A + (v18 & B | D & ~B) - 680876936 + *v21;
      v25 = B + (v24 << 7) + (v24 >> 25);
      v26 = D + v23 - 389564586 + (B & v25 | v18 & ~v25);
      v27 = v25 + (v26 << 12) + (v26 >> 20);
      v29 = v21[2];
      v28 = v21[3];
      v30 = v18 + v29 + 606105819 + (v25 & v27 | B & ~v27);
      v31 = v27 + (v30 << 17) + (v30 >> 15);
      v32 = B + v28 - 1044525330 + (v27 & v31 | v25 & ~v31);
      v33 = v31 + (v32 << 22) + (v32 >> 10);
      v35 = v21[4];
      v34 = v21[5];
      v36 = v25 + v35 - 176418897 + (v31 & v33 | v27 & ~v33);
      v37 = v33 + (v36 << 7) + (v36 >> 25);
      v38 = v27 + v34 + 1200080426 + (v33 & v37 | v31 & ~v37);
      v39 = v37 + (v38 << 12) + (v38 >> 20);
      v41 = v21[6];
      v40 = v21[7];
      v42 = v31 + v41 - 1473231341 + (v37 & v39 | v33 & ~v39);
      v43 = v39 + (v42 << 17) + (v42 >> 15);
      v44 = v40 + v33 - 45705983 + (v39 & v43 | v37 & ~v43);
      v45 = v43 + (v44 << 22) + (v44 >> 10);
      v46 = v21[8];
      v47 = v21[9];
      v48 = v46 + v37 + 1770035416 + (v43 & v45 | v39 & ~v45);
      v49 = v45 + (v48 << 7) + (v48 >> 25);
      v50 = v47 + v39 - 1958414417 + (v45 & v49 | v43 & ~v49);
      v51 = v49 + (v50 << 12) + (v50 >> 20);
      v52 = v21[10];
      v53 = v21[11];
      v54 = v52 + v43 - 42063 + (v49 & v51 | v45 & ~v51);
      v55 = v51 + (v54 << 17) + (v54 >> 15);
      v56 = v53 + v45 - 1990404162 + (v51 & v55 | v49 & ~v55);
      v57 = v55 + (v56 << 22) + (v56 >> 10);
      v59 = v21[12];
      v58 = v21[13];
      v60 = v59 + v49 + 1804603682 + (v55 & v57 | v51 & ~v57);
      v61 = v57 + (v60 << 7) + (v60 >> 25);
      v62 = v58 + v51 - 40341101 + (v57 & v61 | v55 & ~v61);
      v63 = v61 + (v62 << 12) + (v62 >> 20);
      v65 = v21[14];
      v64 = v21[15];
      v66 = v65 + v55 - 1502002290 + (v61 & v63 | v57 & ~v63);
      v67 = v63 + (v66 << 17) + (v66 >> 15);
      v68 = v64 + v57 + 1236535329 + (v63 & v67 | v61 & ~v67);
      v69 = v67 + (v68 << 22) + (v68 >> 10);
      v70 = v23 + v61 - 165796510 + (v69 & v63 | v67 & ~v63);
      v71 = v69 + 32 * v70 + (v70 >> 27);
      v72 = v41 + v63 - 1069501632 + (v71 & v67 | v69 & ~v67);
      v73 = v71 + (v72 << 9) + (v72 >> 23);
      v74 = v53 + v67 + 643717713 + (v73 & v69 | v71 & ~v69);
      v75 = v73 + (v74 << 14) + (v74 >> 18);
      v76 = *v21 + v69 - 373897302 + (v75 & v71 | v73 & ~v71);
      v77 = v75 + (v76 << 20) + (v76 >> 12);
      v78 = v34 + v71 - 701558691 + (v77 & v73 | v75 & ~v73);
      v79 = v77 + 32 * v78 + (v78 >> 27);
      v80 = v52 + v73 + 38016083 + (v79 & v75 | v77 & ~v75);
      v81 = v79 + (v80 << 9) + (v80 >> 23);
      v82 = v64 + v75 - 660478335 + (v81 & v77 | v79 & ~v77);
      v83 = v81 + (v82 << 14) + (v82 >> 18);
      v84 = v35 + v77 - 405537848 + (v83 & v79 | v81 & ~v79);
      v85 = v83 + (v84 << 20) + (v84 >> 12);
      v86 = v47 + v79 + 568446438 + (v85 & v81 | v83 & ~v81);
      v87 = v85 + 32 * v86 + (v86 >> 27);
      v88 = v65 + v81 - 1019803690 + (v87 & v83 | v85 & ~v83);
      v89 = v87 + (v88 << 9) + (v88 >> 23);
      v90 = v28 + v83 - 187363961 + (v89 & v85 | v87 & ~v85);
      v91 = v89 + (v90 << 14) + (v90 >> 18);
      v92 = v46 + v85 + 1163531501 + (v91 & v87 | v89 & ~v87);
      v93 = v91 + (v92 << 20) + (v92 >> 12);
      v94 = v58 + v87 - 1444681467 + (v93 & v89 | v91 & ~v89);
      v95 = v93 + 32 * v94 + (v94 >> 27);
      v96 = v29 + v89 - 51403784 + (v95 & v91 | v93 & ~v91);
      v97 = v95 + (v96 << 9) + (v96 >> 23);
      v98 = v40 + v91 + 1735328473 + (v97 & v93 | v95 & ~v93);
      v99 = v97 + (v98 << 14) + (v98 >> 18);
      v100 = v59 + v93 - 1926607734 + ((v99 ^ v97) & v95 ^ v97);
      v101 = v99 + (v100 << 20) + (v100 >> 12);
      v102 = v34 + v95 - 378558 + (v99 ^ v97 ^ v101);
      v103 = v101 + 16 * v102 + (v102 >> 28);
      v104 = v46 + v97 - 2022574463 + (v101 ^ v99 ^ v103);
      v105 = v103 + (v104 << 11) + (v104 >> 21);
      v106 = v53 + v99 + 1839030562 + (v103 ^ v101 ^ v105);
      v107 = v105 + (v106 << 16) + HIWORD(v106);
      v108 = v65 + v101 - 35309556 + (v105 ^ v103 ^ v107);
      v109 = v107 + (v108 << 23) + (v108 >> 9);
      v110 = v23 + v103 - 1530992060 + (v107 ^ v105 ^ v109);
      v111 = v109 + 16 * v110 + (v110 >> 28);
      v112 = v35 + v105 + 1272893353 + (v109 ^ v107 ^ v111);
      v113 = v111 + (v112 << 11) + (v112 >> 21);
      v114 = v40 + v107 - 155497632 + (v111 ^ v109 ^ v113);
      v115 = v113 + (v114 << 16) + HIWORD(v114);
      v116 = v52 + v109 - 1094730640 + (v113 ^ v111 ^ v115);
      v117 = v115 + (v116 << 23) + (v116 >> 9);
      v118 = v58 + v111 + 681279174 + (v115 ^ v113 ^ v117);
      v119 = v117 + 16 * v118 + (v118 >> 28);
      v120 = *v21 + v113 - 358537222 + (v117 ^ v115 ^ v119);
      v121 = v119 + (v120 << 11) + (v120 >> 21);
      v122 = v28 + v115 - 722521979 + (v119 ^ v117 ^ v121);
      v123 = v121 + (v122 << 16) + HIWORD(v122);
      v124 = v41 + v117 + 76029189 + (v121 ^ v119 ^ v123);
      v125 = v123 + (v124 << 23) + (v124 >> 9);
      v126 = v47 + v119 - 640364487 + (v123 ^ v121 ^ v125);
      v127 = v125 + 16 * v126 + (v126 >> 28);
      v128 = v59 + v121 - 421815835 + (v125 ^ v123 ^ v127);
      v129 = v127 + (v128 << 11) + (v128 >> 21);
      v130 = v64 + v123 + 530742520 + (v127 ^ v125 ^ v129);
      v131 = v129 + (v130 << 16) + HIWORD(v130);
      v132 = v29 + v125 - 995338651 + (v129 ^ v127 ^ v131);
      v133 = v131 + (v132 << 23) + (v132 >> 9);
      v134 = *v21 + v127 - 198630844 + ((v133 | ~v129) ^ v131);
      v135 = v133 + (v134 << 6) + (v134 >> 26);
      v136 = v40 + v129 + 1126891415 + ((v135 | ~v131) ^ v133);
      v137 = v135 + (v136 << 10) + (v136 >> 22);
      v138 = v65 + v131 - 1416354905 + ((v137 | ~v133) ^ v135);
      v139 = v137 + (v138 << 15) + (v138 >> 17);
      v140 = v34 + v133 - 57434055 + ((v139 | ~v135) ^ v137);
      v141 = v139 + (v140 << 21) + (v140 >> 11);
      v142 = v59 + v135 + 1700485571 + ((v141 | ~v137) ^ v139);
      v143 = v141 + (v142 << 6) + (v142 >> 26);
      v144 = v28 + v137 - 1894986606 + ((v143 | ~v139) ^ v141);
      v145 = v143 + (v144 << 10) + (v144 >> 22);
      v146 = v52 + v139;
      v5 = v203;
      v147 = v146 - 1051523 + ((v145 | ~v141) ^ v143);
      v148 = v145 + (v147 << 15) + (v147 >> 17);
      v149 = v23 + v141 - 2054922799 + ((v148 | ~v143) ^ v145);
      v150 = v148 + (v149 << 21) + (v149 >> 11);
      v151 = v46 + v143 + 1873313359 + ((v150 | ~v145) ^ v148);
      v152 = v150 + (v151 << 6) + (v151 >> 26);
      v153 = v64 + v145 - 30611744 + ((v152 | ~v148) ^ v150);
      v154 = v152 + (v153 << 10) + (v153 >> 22);
      v155 = v41 + v148 - 1560198380 + ((v154 | ~v150) ^ v152);
      v156 = v154 + (v155 << 15) + (v155 >> 17);
      v157 = v58 + v150 + 1309151649 + ((v156 | ~v152) ^ v154);
      v158 = v156 + (v157 << 21) + (v157 >> 11);
      LODWORD(c) = -145523070;
      v159 = v35 + v152 - 145523070 + ((v158 | ~v154) ^ v156);
      v160 = v158 + (v159 << 6) + (v159 >> 26);
      v161 = v53 + v154 - 1120210379 + ((v160 | ~v156) ^ v158);
      v162 = v160 + (v161 << 10) + (v161 >> 22);
      v163 = v29 + v156 + 718787259 + ((v162 | ~v158) ^ v160);
      v164 = v162 + (v163 << 15) + (v163 >> 17);
      v165 = v47 + v158 - 343485551 + ((v164 | ~v160) ^ v162);
      A += v160;
      B += v164 + (v165 << 21) + (v165 >> 11);
      v18 += v164;
      D += v162;
      v203->A = A;
      v203->B = B;
      v203->C = v18;
      v203->D = D;
      v21 += 16;
      LODWORD(v22) = v22 - 1;
    }
    while ((_DWORD)v22);
    v12 = (unsigned __int8 *)data + (int)((_DWORD)v198 << 6);
    v6 = v200;
    v11 = len - (int)((_DWORD)v198 << 6);
    v3 = len;
    v4 = (unsigned __int8 *)data;
  }
  if (v11)
  {
    v166 = v5->data;
    v5->num = v11;
    v167 = v11 & 3;
    if ((v11 >> 2) && v6 - (char *)v12 >= 4)
    {
      v168 = (v11 >> 2) - 1;
      v169 = &v4[v3] - v12 - 4;
      do
      {
        v170 = *(_DWORD *)v12;
        v12 += 4;
        *v166++ = v170;
        if (v168-- == 0)
          break;
        v172 = v169 <= 3;
        v169 -= 4;
      }
      while (!v172);
    }
    v173 = 0;
    v174 = &v12[v11 & 3];
    if (v167 != 1)
    {
      if (v167 != 2)
      {
        if (v167 != 3)
        {
LABEL_26:
          *v166 = v173;
          return (int)c;
        }
        v175 = *--v174;
        v173 = v175 << 16;
      }
      v176 = *--v174;
      v173 |= v176 << 8;
    }
    v173 |= *(v174 - 1);
    goto LABEL_26;
  }
  return (int)c;
}

_DWORD *md5_block_host_order(_DWORD *result, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  int v82;
  unsigned int v83;
  int v84;
  unsigned int v85;
  int v86;
  unsigned int v87;
  int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  int v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  int v98;
  unsigned int v99;
  int v100;
  unsigned int v101;
  int v102;
  unsigned int v103;
  int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  int v108;
  unsigned int v109;
  int v110;
  unsigned int v111;
  int v112;
  unsigned int v113;
  int v114;
  unsigned int v115;
  int v116;
  unsigned int v117;
  int v118;
  unsigned int v119;
  int v120;
  unsigned int v121;
  int v122;
  unsigned int v123;
  int v124;
  unsigned int v125;
  int v126;
  unsigned int v127;
  int v128;
  unsigned int v129;
  int v130;
  unsigned int v131;
  int v132;
  unsigned int v133;
  int v134;
  unsigned int v135;
  int v136;
  unsigned int v137;
  int v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  int v144;
  unsigned int v145;
  int v146;
  unsigned int v147;

  v3 = result[2];
  v2 = result[3];
  v4 = result[1];
  v5 = *a2;
  v6 = a2[1];
  v7 = *result + *a2 - 680876936 + (v3 & v4 | v2 & ~v4);
  v8 = v4 + (v7 << 7) + (v7 >> 25);
  v9 = v2 + v6 - 389564586 + (v4 & v8 | v3 & ~v8);
  v10 = v8 + (v9 << 12) + (v9 >> 20);
  v11 = a2[2];
  v12 = a2[3];
  v13 = v3 + v11 + 606105819 + (v8 & v10 | v4 & ~v10);
  v14 = v10 + (v13 << 17) + (v13 >> 15);
  v15 = v4 + v12 - 1044525330 + (v10 & v14 | v8 & ~v14);
  v16 = v14 + (v15 << 22) + (v15 >> 10);
  v18 = a2[4];
  v17 = a2[5];
  v19 = v18 + v8 - 176418897 + (v14 & v16 | v10 & ~v16);
  v20 = v16 + (v19 << 7) + (v19 >> 25);
  v21 = v17 + v10 + 1200080426 + (v16 & v20 | v14 & ~v20);
  v22 = v20 + (v21 << 12) + (v21 >> 20);
  v23 = a2[6];
  v24 = a2[7];
  v25 = v23 + v14 - 1473231341 + (v20 & v22 | v16 & ~v22);
  v26 = v22 + (v25 << 17) + (v25 >> 15);
  v27 = v24 + v16 - 45705983 + (v22 & v26 | v20 & ~v26);
  v28 = v26 + (v27 << 22) + (v27 >> 10);
  v29 = a2[8];
  v30 = a2[9];
  v31 = v29 + v20 + 1770035416 + (v26 & v28 | v22 & ~v28);
  v32 = v28 + (v31 << 7) + (v31 >> 25);
  v33 = v30 + v22 - 1958414417 + (v28 & v32 | v26 & ~v32);
  v34 = v32 + (v33 << 12) + (v33 >> 20);
  v36 = a2[10];
  v35 = a2[11];
  v37 = v36 + v26 - 42063 + (v32 & v34 | v28 & ~v34);
  v38 = v34 + (v37 << 17) + (v37 >> 15);
  v39 = v35 + v28 - 1990404162 + (v34 & v38 | v32 & ~v38);
  v40 = v38 + (v39 << 22) + (v39 >> 10);
  v42 = a2[12];
  v41 = a2[13];
  v43 = v42 + v32 + 1804603682 + (v38 & v40 | v34 & ~v40);
  v44 = v40 + (v43 << 7) + (v43 >> 25);
  v45 = v41 + v34 - 40341101 + (v40 & v44 | v38 & ~v44);
  v46 = v44 + (v45 << 12) + (v45 >> 20);
  v48 = a2[14];
  v47 = a2[15];
  v49 = v48 + v38 - 1502002290 + (v44 & v46 | v40 & ~v46);
  v50 = v46 + (v49 << 17) + (v49 >> 15);
  v51 = v47 + v40 + 1236535329 + (v46 & v50 | v44 & ~v50);
  v52 = v50 + (v51 << 22) + (v51 >> 10);
  v53 = v6 + v44 - 165796510 + (v52 & v46 | v50 & ~v46);
  v54 = v52 + 32 * v53 + (v53 >> 27);
  v55 = v23 + v46 - 1069501632 + (v54 & v50 | v52 & ~v50);
  v56 = v54 + (v55 << 9) + (v55 >> 23);
  v57 = v35 + v50 + 643717713 + (v56 & v52 | v54 & ~v52);
  v58 = v56 + (v57 << 14) + (v57 >> 18);
  v59 = v5 + v52 - 373897302 + (v58 & v54 | v56 & ~v54);
  v60 = v58 + (v59 << 20) + (v59 >> 12);
  v61 = v17 + v54 - 701558691 + (v60 & v56 | v58 & ~v56);
  v62 = v60 + 32 * v61 + (v61 >> 27);
  v63 = v36 + v56 + 38016083 + (v62 & v58 | v60 & ~v58);
  v64 = v62 + (v63 << 9) + (v63 >> 23);
  v65 = v47 + v58 - 660478335 + (v64 & v60 | v62 & ~v60);
  v66 = v64 + (v65 << 14) + (v65 >> 18);
  v67 = v18 + v60 - 405537848 + (v66 & v62 | v64 & ~v62);
  v68 = v66 + (v67 << 20) + (v67 >> 12);
  v69 = v30 + v62 + 568446438 + (v68 & v64 | v66 & ~v64);
  v70 = v68 + 32 * v69 + (v69 >> 27);
  v71 = v48 + v64 - 1019803690 + (v70 & v66 | v68 & ~v66);
  v72 = v70 + (v71 << 9) + (v71 >> 23);
  v73 = v12 + v66 - 187363961 + (v72 & v68 | v70 & ~v68);
  v74 = v72 + (v73 << 14) + (v73 >> 18);
  v75 = v29 + v68 + 1163531501 + (v74 & v70 | v72 & ~v70);
  v76 = v74 + (v75 << 20) + (v75 >> 12);
  v77 = v41 + v70 - 1444681467 + (v76 & v72 | v74 & ~v72);
  v78 = v76 + 32 * v77 + (v77 >> 27);
  v79 = v11 + v72 - 51403784 + (v78 & v74 | v76 & ~v74);
  v80 = v78 + (v79 << 9) + (v79 >> 23);
  v81 = v24 + v74 + 1735328473 + (v80 & v76 | v78 & ~v76);
  v82 = v80 + (v81 << 14) + (v81 >> 18);
  v83 = v42 + v76 - 1926607734 + ((v82 ^ v80) & v78 ^ v80);
  v84 = v82 + (v83 << 20) + (v83 >> 12);
  v85 = v17 + v78 - 378558 + (v82 ^ v80 ^ v84);
  v86 = v84 + 16 * v85 + (v85 >> 28);
  v87 = v29 + v80 - 2022574463 + (v84 ^ v82 ^ v86);
  v88 = v86 + (v87 << 11) + (v87 >> 21);
  v89 = v35 + v82 + 1839030562 + (v86 ^ v84 ^ v88);
  v90 = v88 + (v89 << 16) + HIWORD(v89);
  v91 = v48 + v84 - 35309556 + (v88 ^ v86 ^ v90);
  v92 = v90 + (v91 << 23) + (v91 >> 9);
  v93 = v6 + v86 - 1530992060 + (v90 ^ v88 ^ v92);
  v94 = v92 + 16 * v93 + (v93 >> 28);
  v95 = v18 + v88 + 1272893353 + (v92 ^ v90 ^ v94);
  v96 = v94 + (v95 << 11) + (v95 >> 21);
  v97 = v24 + v90 - 155497632 + (v94 ^ v92 ^ v96);
  v98 = v96 + (v97 << 16) + HIWORD(v97);
  v99 = v36 + v92 - 1094730640 + (v96 ^ v94 ^ v98);
  v100 = v98 + (v99 << 23) + (v99 >> 9);
  v101 = v41 + v94 + 681279174 + (v98 ^ v96 ^ v100);
  v102 = v100 + 16 * v101 + (v101 >> 28);
  v103 = v5 + v96 - 358537222 + (v100 ^ v98 ^ v102);
  v104 = v102 + (v103 << 11) + (v103 >> 21);
  v105 = v12 + v98 - 722521979 + (v102 ^ v100 ^ v104);
  v106 = v104 + (v105 << 16) + HIWORD(v105);
  v107 = v23 + v100 + 76029189 + (v104 ^ v102 ^ v106);
  v108 = v106 + (v107 << 23) + (v107 >> 9);
  v109 = v30 + v102 - 640364487 + (v106 ^ v104 ^ v108);
  v110 = v108 + 16 * v109 + (v109 >> 28);
  v111 = v42 + v104 - 421815835 + (v108 ^ v106 ^ v110);
  v112 = v110 + (v111 << 11) + (v111 >> 21);
  v113 = v47 + v106 + 530742520 + (v110 ^ v108 ^ v112);
  v114 = v112 + (v113 << 16) + HIWORD(v113);
  v115 = v11 + v108 - 995338651 + (v112 ^ v110 ^ v114);
  v116 = v114 + (v115 << 23) + (v115 >> 9);
  v117 = v5 + v110 - 198630844 + ((v116 | ~v112) ^ v114);
  v118 = v116 + (v117 << 6) + (v117 >> 26);
  v119 = v24 + v112 + 1126891415 + ((v118 | ~v114) ^ v116);
  v120 = v118 + (v119 << 10) + (v119 >> 22);
  v121 = v48 + v114 - 1416354905 + ((v120 | ~v116) ^ v118);
  v122 = v120 + (v121 << 15) + (v121 >> 17);
  v123 = v17 + v116 - 57434055 + ((v122 | ~v118) ^ v120);
  v124 = v122 + (v123 << 21) + (v123 >> 11);
  v125 = v42 + v118 + 1700485571 + ((v124 | ~v120) ^ v122);
  v126 = v124 + (v125 << 6) + (v125 >> 26);
  v127 = v12 + v120 - 1894986606 + ((v126 | ~v122) ^ v124);
  v128 = v126 + (v127 << 10) + (v127 >> 22);
  v129 = v36 + v122 - 1051523 + ((v128 | ~v124) ^ v126);
  v130 = v128 + (v129 << 15) + (v129 >> 17);
  v131 = v6 + v124 - 2054922799 + ((v130 | ~v126) ^ v128);
  v132 = v130 + (v131 << 21) + (v131 >> 11);
  v133 = v29 + v126 + 1873313359 + ((v132 | ~v128) ^ v130);
  v134 = v132 + (v133 << 6) + (v133 >> 26);
  v135 = v47 + v128 - 30611744 + ((v134 | ~v130) ^ v132);
  v136 = v134 + (v135 << 10) + (v135 >> 22);
  v137 = v23 + v130 - 1560198380 + ((v136 | ~v132) ^ v134);
  v138 = v136 + (v137 << 15) + (v137 >> 17);
  v139 = v41 + v132 + 1309151649 + ((v138 | ~v134) ^ v136);
  v140 = v138 + (v139 << 21) + (v139 >> 11);
  v141 = v18 + v134 - 145523070 + ((v140 | ~v136) ^ v138);
  v142 = v140 + (v141 << 6) + (v141 >> 26);
  v143 = v35 + v136 - 1120210379 + ((v142 | ~v138) ^ v140);
  v144 = v142 + (v143 << 10) + (v143 >> 22);
  v145 = v11 + v138 + 718787259 + ((v144 | ~v140) ^ v142);
  v146 = v144 + (v145 << 15) + (v145 >> 17);
  v147 = v30 + v140 - 343485551 + ((v146 | ~v142) ^ v144);
  *result += v142;
  result[1] = v4 + v146 + (v147 << 21) + (v147 >> 11);
  result[2] = v3 + v146;
  result[3] = v2 + v144;
  return result;
}

ssize_t mDNSPlatformWriteTCP(uint64_t a1, const void *a2, size_t a3)
{
  ssize_t result;
  NSObject *v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!*(_BYTE *)(a1 + 65))
    return -65569;
  if ((*(_BYTE *)(a1 + 4) & 1) == 0)
  {
    result = write(*(_DWORD *)(a1 + 16), a2, a3);
    if ((result & 0x8000000000000000) == 0)
      return result;
    if (*__error() == 35)
      return 0;
    v4 = mDNSLogCategory_Default;
    v5 = __error();
    v6 = strerror(*v5);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixWriteTCP - send %s", v7, v8, v9, v10, v11, v6);
  }
  return -1;
}

ssize_t mDNSPlatformReadTCP(uint64_t a1, void *a2, size_t a3, _BYTE *a4)
{
  int v5;
  ssize_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  NSObject *v19;
  int v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  *a4 = 0;
  if (!*(_BYTE *)(a1 + 65))
    return -65569;
  if ((*(_BYTE *)(a1 + 4) & 1) != 0)
  {
    *a4 = 1;
    return -1;
  }
  v5 = *(_DWORD *)(a1 + 16);
  result = recv(v5, a2, a3, 0);
  if (result >= 1)
  {
    mDNSPosixReadTCP_CLOSEDcount = 0;
    mDNSPosixReadTCP_EAGAINcount = 0;
    return result;
  }
  if (!result)
  {
    *a4 = 1;
    ++mDNSPosixReadTCP_CLOSEDcount;
    HIDWORD(v12) = -858993459 * mDNSPosixReadTCP_CLOSEDcount + 429496728;
    LODWORD(v12) = HIDWORD(v12);
    if ((v12 >> 2) <= 0xCCCCCCC)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv %d got CLOSED %d times", v7, v8, v9, v10, v11, v5);
      if (mDNSPosixReadTCP_CLOSEDcount >= 1000)
        __assert_rtn("mDNSPosixReadTCP", "PlatformCommon.c", 694, "CLOSEDcount < 1000");
    }
    return 0;
  }
  if (*__error() == 54)
  {
    result = 0;
    *a4 = 1;
    return result;
  }
  if (*__error() != 35)
  {
    v19 = mDNSLogCategory_Default;
    v20 = *__error();
    v21 = __error();
    strerror(*v21);
    LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv: %d (%s)", v22, v23, v24, v25, v26, v20);
    return -1;
  }
  ++mDNSPosixReadTCP_EAGAINcount;
  HIDWORD(v18) = 652835029 * mDNSPosixReadTCP_EAGAINcount + 17179864;
  LODWORD(v18) = HIDWORD(v18);
  if ((v18 >> 3) <= 0x418936)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv %d got EAGAIN %d times", v13, v14, v15, v16, v17, v5);
    sleep(1u);
  }
  return 0;
}

void DisposeTCPConn(uint64_t a1)
{
  void *v2;

  mDNSPlatformTCPCloseConnection(*(_DWORD **)(a1 + 8));
  v2 = *(void **)(a1 + 9016);
  if (v2)
    free(v2);
  free((void *)a1);
}

void mDNSPlatformTCPCloseConnection(_DWORD *a1)
{
  int v2;

  if (a1)
  {
    v2 = a1[4];
    if (v2 != -1)
    {
      shutdown(v2, 2);
      close(a1[4]);
    }
    free(a1);
  }
}

uint64_t GetPktLease(uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4)
{
  unsigned __int8 *OptRR;
  _WORD *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;

  OptRR = LocateOptRR(a2, a3, 8);
  if (!OptRR)
    return 0;
  v9 = (_WORD *)(a1 + 37920);
  if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0, 128, a1 + 37912)
    && *(unsigned __int8 *)v9 != 240
    && *(_WORD *)(a1 + 37924) == 41)
  {
    v10 = *(_QWORD *)(a1 + 37960) + 4;
    v11 = v10 + *(unsigned __int16 *)(a1 + 37932);
    while (v10 < v11)
    {
      if (*(_WORD *)v10 == 2)
      {
        *a4 = *(_DWORD *)(v10 + 4);
        *v9 = 0;
        *(_WORD *)(a1 + 38022) = 0;
        v14 = (_QWORD *)(a1 + 37976);
        v13 = *(_QWORD **)(a1 + 37976);
        v12 = 1;
        if (v13)
          goto LABEL_10;
        return v12;
      }
      v10 += 24;
    }
  }
  v12 = 0;
  *v9 = 0;
  *(_WORD *)(a1 + 38022) = 0;
  v14 = (_QWORD *)(a1 + 37976);
  v13 = *(_QWORD **)(a1 + 37976);
  if (v13)
  {
LABEL_10:
    ref_count_obj_release(v13);
    *v14 = 0;
  }
  return v12;
}

void HostnameCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v11;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  int v39;

  v11 = *(_QWORD *)(a2 + 112);
  if (!(_DWORD)a3)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2537);
    v21 = *(_DWORD *)(a1 + 64);
    if (v21 <= 1)
      v21 = 1;
    *(_DWORD *)(a1 + 12684) = v21;
    mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2539);
    if (!v11)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "HostnameCallback invoked with orphaned address record", v22, v23, v24, v25, v26, a9);
      return;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      if (*(_WORD *)(a2 + 12) == 1)
        v27 = "Registered hostname %##s IP %.4a";
      else
        v27 = "Registered hostname %##s IP %.16a";
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v27, v22, v23, v24, v25, v26, *(_QWORD *)(a2 + 40));
    }
    *(_QWORD *)(a2 + 112) = *(_QWORD *)(v11 + 2824);
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
    if (v28)
    {
      v29 = a1;
      v30 = a2;
      v31 = 0;
LABEL_24:
      v28(v29, v30, v31);
    }
LABEL_25:
    *(_QWORD *)(a2 + 112) = v11;
    return;
  }
  if ((_DWORD)a3 != -65792)
  {
    if (*(_WORD *)(a2 + 12) == 1)
      v32 = "HostnameCallback: Error %d for registration of %##s IP %.4a";
    else
      v32 = "HostnameCallback: Error %d for registration of %##s IP %.16a";
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v32, a4, a5, a6, a7, a8, a3);
    if (!v11)
    {
      v38 = (void *)a2;
LABEL_38:
      free(v38);
      return;
    }
    if (*(_DWORD *)(a2 + 344) != 4)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: HostnameCallback invoked with error code for record not in regState_Unregistered!", v33, v34, v35, v36, v37, v39);
    if (*(_DWORD *)(v11 + 808) != 4 || *(_DWORD *)(v11 + 1984) != 4)
      return;
    *(_QWORD *)(a2 + 112) = *(_QWORD *)(v11 + 2824);
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
    if (v28)
    {
      v29 = a1;
      v30 = a2;
      v31 = a3;
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  if (v11)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v13 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "HostnameCallback: Got mStatus_MemFree for %p %p %s", v14, v15, v16, v17, v18, v11);
    }
    v19 = (_QWORD *)(a1 + 14680);
    while (1)
    {
      v19 = (_QWORD *)*v19;
      if (!v19)
        break;
      if (v19 + 58 == (_QWORD *)a2 || v19 + 205 == (_QWORD *)a2)
      {
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2500);
        AdvertiseHostname(a1, v19);
        mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2500);
        return;
      }
    }
    if (!*(_BYTE *)(v11 + 472) && !*(_BYTE *)(v11 + 1648))
    {
      if (*(_QWORD *)(v11 + 200))
        mDNS_StopNATOperation_internal(a1, v11 + 8);
      v38 = (void *)v11;
      goto LABEL_38;
    }
  }
}

void AbortUnlinkAndFree(_QWORD *a1)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  BOOL v5;
  NSObject *v6;
  _QWORD *v9;
  uint8_t buf[4];
  _QWORD *v11;

  v9 = a1;
  abort_request((uint64_t)a1);
  v2 = &all_requests;
  do
  {
    v3 = v2;
    v4 = (_QWORD *)*v2;
    v2 = (uint64_t *)(*v2 + 16);
    if (v4)
      v5 = v4 == a1;
    else
      v5 = 1;
  }
  while (!v5);
  if (v4)
  {
    *v3 = a1[2];
    request_state_forget(&v9);
    return;
  }
  v6 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 134217984;
    v11 = a1;
    goto LABEL_18;
  }
  v6 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v11 = a1;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "AbortUnlinkAndFree: ERROR: Attempt to abort operation %p not in list", buf, 0xCu);
  }
}

uint64_t add_domain_to_browser(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  CFMutableArrayRef Mutable;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  __int128 v12;
  void *v13;
  id v14;
  id v15;
  NSObject *v16;
  id v17;
  NSObject *v18;
  int v19;
  id v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  id v24;
  int v25;
  ifaddrs *v26;
  sockaddr *ifa_addr;
  sockaddr *ifa_netmask;
  const char *ifa_name;
  int sa_family;
  unsigned int v31;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  BOOL v36;
  id v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t i;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  id v48;
  NSObject *v49;
  char *v50;
  id v51;
  __int32 v52;
  id v53;
  char *v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  BOOL v58;
  id v59;
  id v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  void *v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  id v70;
  NSObject *v71;
  char *v72;
  NSObject *v73;
  const char *v74;
  uint64_t v75;
  int v76;
  int v77;
  id v78;
  char *v79;
  id v80;
  NSObject *v81;
  _QWORD *v82;
  _QWORD *v83;
  _BYTE *v84;
  uint64_t v85;
  unsigned __int16 v86;
  int v87;
  unsigned __int8 *v88;
  int started;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  BOOL v98;
  char *v99;
  uint64_t v100;
  __uint64_t monotonic_time_ns;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v108;
  void *v109;
  id v110;
  int v111;
  id v112;
  void *context;
  void *v114;
  const __CFArray *v115;
  uint64_t v116;
  id v117;
  uint64_t v118;
  _BYTE *v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  _QWORD *v123;
  _QWORD *v124;
  ifaddrs *v125;
  uint64_t v126;
  unsigned int v127;
  id obj;
  char *obja;
  _QWORD v130[8];
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  int v134;
  _QWORD v135[5];
  _QWORD v136[2];
  _QWORD v137[2];
  _QWORD v138[2];
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  int32x4_t v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  _QWORD v149[4];
  id v150;
  _QWORD *v151;
  ifaddrs *v152;
  __int128 buf;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  id v169[16];
  uint8_t v170[4];
  _BYTE v171[20];
  __int16 v172;
  __int32 v173;
  __int16 v174;
  unsigned int v175;

  v4 = a1;
  v131 = 0;
  v132 = &v131;
  v133 = 0x2000000000;
  v134 = 0;
  v5 = *(_QWORD *)(a1 + 144);
  v6 = (uint64_t *)(v5 + 272);
  while (1)
  {
    v6 = (uint64_t *)*v6;
    if (!v6)
      break;
    if (SameDomainNameBytes((_BYTE *)v6 + 8, a2))
    {
      v7 = 4294901749;
      goto LABEL_158;
    }
  }
  v123 = (_QWORD *)(v5 + 272);
  if (!*(_BYTE *)(v4 + 282) || !SameDomainNameBytes(a2, "\x05local"))
    goto LABEL_121;
  if (!*(_QWORD *)(v4 + 32))
  {
    v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        goto LABEL_121;
      v23 = *(_DWORD *)(v4 + 192);
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v23;
    }
    else
    {
      v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_121;
      v19 = *(_DWORD *)(v4 + 192);
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v19;
    }
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "[R%u] No peer audit token to get unicast discovery IP addresses", (uint8_t *)&buf, 8u);
LABEL_121:
    v82 = malloc_type_calloc(1uLL, 0x3C0uLL, 0xF1748037uLL);
    if (v82)
    {
      v83 = v82;
      v84 = a2;
      if (a2 == (_BYTE *)-256)
      {
LABEL_124:
        while (v84)
        {
          v85 = *v84;
          if (v85 > 0x3F)
            break;
          if (!*v84)
          {
            v86 = (_WORD)v84 - (_WORD)a2 + 1;
            if (v86 > 0x100u)
              break;
            memcpy(v82 + 1, a2, v86);
            goto LABEL_132;
          }
          v84 += v85 + 1;
          if (a2 != (_BYTE *)-256)
            goto LABEL_123;
        }
      }
      else
      {
LABEL_123:
        if (v84 < a2 + 256)
          goto LABEL_124;
      }
      *((_BYTE *)v82 + 8) = 0;
LABEL_132:
      *((_DWORD *)v83 + 128) = *(_DWORD *)(v4 + 188);
      if (*(_BYTE *)(v4 + 280))
      {
        v87 = 0;
        *(_OWORD *)(v83 + 115) = *(_OWORD *)(v4 + 264);
      }
      else
      {
        v87 = *(_DWORD *)(v4 + 180);
      }
      *((_DWORD *)v83 + 127) = v87;
      *((_DWORD *)v83 + 129) = *(_DWORD *)(v4 + 192);
      v88 = (unsigned __int8 *)(v5 + 10);
      started = mDNS_StartBrowse((uint64_t)(v83 + 33), (unsigned __int8 *)(v5 + 10), a2, *(_QWORD *)v5, *(_DWORD *)(v4 + 240), *(_BYTE *)(v5 + 9), (*(_DWORD *)(v4 + 240) & 0x80000) != 0, (uint64_t)FoundInstance, v4);
      *((_DWORD *)v132 + 6) = started;
      if (started)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_StartBrowse returned %d for type %##s domain %##s", v90, v91, v92, v93, v94, started);
        free(v83);
      }
      else
      {
        *v83 = *v123;
        *v123 = v83;
        if (*(_DWORD *)(v4 + 244) != -1 && SameDomainNameBytes(a2, "\x05local"))
        {
          v95 = *(unsigned int *)(v4 + 244);
          if ((_DWORD)v95)
          {
            if (AWDLInterfaceID && AWDLInterfaceID == v95)
            {
              v96 = v5;
              v97 = 1;
            }
            else
            {
              v96 = v5;
              if (WiFiAwareInterfaceID)
                v98 = WiFiAwareInterfaceID == v95;
              else
                v98 = 0;
              v97 = v98;
            }
          }
          else
          {
            v96 = v5;
            v97 = (*(unsigned __int8 *)(v4 + 242) >> 4) & 1;
          }
          v99 = (char *)(v4 + 248);
          v100 = v4;
          monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
          _mdns_powerlog_bonjour_event(1, v97, v99, monotonic_time_ns);
          *(_QWORD *)(v100 + 8) = monotonic_time_ns;
          v4 = v100;
          v5 = v96;
        }
        if (mDNS_McastLoggingEnabled)
          LogMcastQuestion((uint64_t)(v83 + 33), v4, 1);
        if (callExternalHelpers(*(_QWORD *)v5, (_BYTE *)v83 + 8, *(unsigned int *)(v4 + 240), v90, v91, v92, v93, v94))
        {
          v167 = 0u;
          v168 = 0u;
          v165 = 0u;
          v166 = 0u;
          v163 = 0u;
          v164 = 0u;
          v161 = 0u;
          v162 = 0u;
          v159 = 0u;
          v160 = 0u;
          v157 = 0u;
          v158 = 0u;
          v155 = 0u;
          v156 = 0u;
          buf = 0u;
          v154 = 0u;
          ConstructServiceName(&buf, 0, v88, (_BYTE *)v83 + 8);
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG, "add_domain_to_browser: calling external_start_browsing_for_service()", v102, v103, v104, v105, v106, v111);
          external_start_browsing_for_service(*(_QWORD *)v5, (unsigned __int8 *)&buf, 12, *(_DWORD *)(v4 + 240), *(_DWORD *)(v4 + 180));
        }
      }
      v7 = *((unsigned int *)v132 + 6);
      goto LABEL_158;
    }
    __break(1u);
    goto LABEL_161;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  if (!Mutable)
    goto LABEL_121;
  v119 = a2;
  v9 = *(_QWORD *)(v4 + 32);
  v135[0] = _NSConcreteStackBlock;
  v2 = 0x40000000;
  v135[1] = 0x40000000;
  v135[2] = ___get_unicast_discovery_dns_services_block_invoke;
  v135[3] = &__block_descriptor_tmp_188;
  v115 = Mutable;
  v135[4] = Mutable;
  v10 = v135;
  context = objc_autoreleasePoolPush();
  v152 = 0;
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v149[0] = _NSConcreteStackBlock;
  v149[1] = 3221225472;
  v149[2] = __util_device_media_access_unicast_addr_enumerate_block_invoke;
  v149[3] = &unk_10013E6C0;
  v112 = v11;
  v150 = v112;
  v114 = v10;
  v151 = v10;
  v124 = objc_retainBlock(v149);
  v116 = v4;
  if (!objc_opt_class(DASession))
  {
LABEL_161:
    v24 = 0;
    a2 = v119;
    goto LABEL_30;
  }
  v169[0] = 0;
  v12 = *(_OWORD *)(v9 + 40);
  buf = *(_OWORD *)(v9 + 24);
  v154 = v12;
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[DASession getPartialIPsWithAuditToken:error:](DASession, "getPartialIPsWithAuditToken:error:", &buf, v169));
  v14 = v169[0];
  if (v14)
  {
    v15 = _system_util_log();
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v108 = v5;
      v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "description"));
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v109;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "DASession getPartialIPsWithAuditToken err %@", (uint8_t *)&buf, 0xCu);

      v5 = v108;
    }

    v17 = 0;
  }
  else if ((unint64_t)objc_msgSend(v13, "count") < 0xB)
  {
    v17 = v13;
  }
  else
  {
    v20 = _system_util_log();
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v110 = objc_msgSend(v13, "count");
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v110;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "DASession getPartialIPsWithAuditToken returned too many results (%ld)", (uint8_t *)&buf, 0xCu);
    }

    if ((unint64_t)objc_msgSend(v13, "count") > 9)
      v22 = 10;
    else
      v22 = (uint64_t)objc_msgSend(v13, "count");
    v17 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "subarrayWithRange:", 0, v22));
  }
  v24 = v17;

LABEL_30:
  if (!objc_msgSend(v24, "count"))
    goto LABEL_118;
  if (!getifaddrs(&v152))
    goto LABEL_34;
  if (!*__error())
  {
    v25 = -6700;
    goto LABEL_115;
  }
  v25 = *__error();
  if (v25)
  {
LABEL_115:
    v80 = _system_util_log();
    v81 = objc_claimAutoreleasedReturnValue(v80);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v25;
      _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "getifaddrs() failed: %{mdns:err}ld", (uint8_t *)&buf, 0xCu);
    }

    goto LABEL_118;
  }
LABEL_34:
  v26 = v152;
  if (!v152)
    goto LABEL_120;
  v117 = v24;
  v118 = v5;
  while (1)
  {
    ifa_addr = v26->ifa_addr;
    if (!ifa_addr)
      goto LABEL_111;
    ifa_netmask = v26->ifa_netmask;
    if (!ifa_netmask)
      goto LABEL_111;
    ifa_name = v26->ifa_name;
    if (!ifa_name)
      goto LABEL_111;
    sa_family = ifa_addr->sa_family;
    if (sa_family == 30)
    {
      v144 = *(int32x4_t *)&ifa_addr->sa_data[6];
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v144, (int32x4_t)xmmword_100100950)))) & 1) == 0
        || (v144.i16[0] & 0xC0FF) == 0x80FE)
      {
        goto LABEL_111;
      }
      v125 = v26;
      v143 = *(_OWORD *)&ifa_netmask->sa_data[6];
      v127 = if_nametoindex(ifa_name);
      v55 = 0;
      v56 = 0;
      v57 = 0;
      do
      {
        v58 = *((_BYTE *)&v143 + v55) != 0;
        if (*((_BYTE *)&v143 + v55))
        {
          ++v57;
        }
        else if (v56)
        {
          break;
        }
        ++v55;
        v56 = v58;
      }
      while (v55 != 16);
      v141 = 0u;
      v142 = 0u;
      v139 = 0u;
      v140 = 0u;
      v59 = v24;
      v60 = objc_msgSend(v59, "countByEnumeratingWithState:objects:count:", &v139, v169, 16);
      if (!v60)
        goto LABEL_108;
      v61 = v60;
      v62 = *(_QWORD *)v140;
      obja = (char *)(v57 + 16);
LABEL_84:
      v63 = 0;
      while (1)
      {
        if (*(_QWORD *)v140 != v62)
          objc_enumerationMutation(v59);
        v64 = *(void **)(*((_QWORD *)&v139 + 1) + 8 * v63);
        v138[0] = 0;
        v138[1] = 0;
        v137[0] = 0;
        v137[1] = 0;
        v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v64, "address"));
        v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v64, "mask"));
        if (objc_msgSend(v65, "length") != (id)16 || objc_msgSend(v66, "length") != (id)16)
          goto LABEL_106;
        objc_msgSend(v65, "getBytes:length:", v138, 16);
        objc_msgSend(v66, "getBytes:length:", v137, 16);
        v67 = 0;
        v68 = 0;
        LOBYTE(v69) = 1;
        do
        {
          v69 = v69 & (*((_BYTE *)v137 + v67) == 0);
          if (v69 == 1)
            ++v68;
          else
            *((_BYTE *)v137 + v67) = -1;
          ++v67;
        }
        while (v67 != 16);
        if ((unint64_t)&obja[-v68] > 0x10)
          break;
        v70 = _system_util_log();
        v71 = objc_claimAutoreleasedReturnValue(v70);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
        {
          v72 = v125->ifa_name;
          *(_DWORD *)v170 = 136446466;
          *(_QWORD *)v171 = v72;
          *(_WORD *)&v171[8] = 1024;
          *(_DWORD *)&v171[10] = v127;
          v73 = v71;
          v74 = "PartialIP - Mask doesn't overlap IPv6 Interface %{public}s(%u)";
LABEL_104:
          _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_INFO, v74, v170, 0x12u);
        }
LABEL_105:

LABEL_106:
        if ((id)++v63 == v61)
        {
          v61 = objc_msgSend(v59, "countByEnumeratingWithState:objects:count:", &v139, v169, 16);
          if (!v61)
          {
LABEL_108:

            v5 = v118;
            goto LABEL_110;
          }
          goto LABEL_84;
        }
      }
      v75 = 0;
      v136[0] = 0;
      v136[1] = 0;
      while (1)
      {
        v76 = v144.u8[v75];
        v77 = (*((_BYTE *)v138 + v75) & *((_BYTE *)v137 + v75)) | v76 & (*((unsigned __int8 *)v137 + v75) ^ 0xFF);
        *((_BYTE *)v136 + v75) = *((_BYTE *)v138 + v75) & *((_BYTE *)v137 + v75) | v76 & ~*((_BYTE *)v137 + v75);
        if (((v77 ^ v76) & *((unsigned __int8 *)&v143 + v75)) != 0)
          break;
        if (++v75 == 16)
        {
          if ((((uint64_t (*)(_QWORD *, uint64_t, _QWORD *, _QWORD))v124[2])(v124, 30, v136, v127) & 1) == 0)
          {

            goto LABEL_113;
          }
          goto LABEL_106;
        }
      }
      v78 = _system_util_log();
      v71 = objc_claimAutoreleasedReturnValue(v78);
      if (!os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
        goto LABEL_105;
      v79 = v125->ifa_name;
      *(_DWORD *)v170 = 136446466;
      *(_QWORD *)v171 = v79;
      *(_WORD *)&v171[8] = 1024;
      *(_DWORD *)&v171[10] = v127;
      v73 = v71;
      v74 = "PartialIP - Addr and Mask don't apply to IPv6 Interface %{public}s(%u)";
      goto LABEL_104;
    }
    if (sa_family != 2)
      goto LABEL_111;
    v121 = *(_DWORD *)&ifa_addr->sa_data[2];
    v31 = bswap32(v121);
    v122 = v31;
    if (HIBYTE(v31) == 127 || (v31 & 0xFFFF0000) == -1442971648)
      goto LABEL_111;
    v125 = v26;
    v144.i32[0] = bswap32(*(_DWORD *)&ifa_netmask->sa_data[2]);
    v120 = if_nametoindex(ifa_name);
    v33 = 0;
    v34 = 0;
    v35 = 0;
    do
    {
      v36 = v144.i8[v33] != 0;
      if (v144.i8[v33])
      {
        ++v35;
      }
      else if (v34)
      {
        break;
      }
      ++v33;
      v34 = v36;
    }
    while (v33 != 4);
    v147 = 0u;
    v148 = 0u;
    v145 = 0u;
    v146 = 0u;
    obj = v24;
    v37 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v145, &buf, 16);
    if (v37)
      break;
LABEL_109:

    v5 = v118;
LABEL_110:
    a2 = v119;
    v24 = v117;
    v26 = v125;
LABEL_111:
    v26 = v26->ifa_next;
    if (!v26)
      goto LABEL_118;
  }
  v38 = (unint64_t)v37;
  v39 = 0;
  v40 = *(_QWORD *)v146;
  v126 = v35 + 4;
  for (i = *(_QWORD *)v146; ; i = *(_QWORD *)v146)
  {
    if (i != v40)
      objc_enumerationMutation(obj);
    v42 = *(void **)(*((_QWORD *)&v145 + 1) + 8 * v39);
    LODWORD(v143) = 0;
    LODWORD(v138[0]) = 0;
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "address"));
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "mask"));
    if (objc_msgSend(v43, "length") == (id)4 && objc_msgSend(v44, "length") == (id)4)
    {
      objc_msgSend(v43, "getBytes:length:", &v143, 4);
      objc_msgSend(v44, "getBytes:length:", v138, 4);
      v45 = 0;
      v46 = 0;
      LOBYTE(v47) = 1;
      do
      {
        v47 = v47 & (*((_BYTE *)v138 + v45) == 0);
        if (v47 == 1)
          ++v46;
        else
          *((_BYTE *)v138 + v45) = -1;
        ++v45;
      }
      while (v45 != 4);
      if ((unint64_t)(v126 - v46) <= 4)
      {
        v48 = _system_util_log();
        v49 = objc_claimAutoreleasedReturnValue(v48);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
        {
          v50 = v125->ifa_name;
          *(_DWORD *)v170 = 67109890;
          *(_DWORD *)v171 = v138[0];
          *(_WORD *)&v171[4] = 2082;
          *(_QWORD *)&v171[6] = v50;
          *(_WORD *)&v171[14] = 1024;
          *(_DWORD *)&v171[16] = v120;
          v172 = 1024;
          v173 = v144.i32[0];
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_INFO, "PartialIP - with (Mask 0x%08X) doesn't overlap IPv4 Interface %{public}s(%u) with (Mask 0x%08X)", v170, 0x1Eu);
        }
LABEL_64:

        goto LABEL_65;
      }
      LODWORD(v137[0]) = bswap32(v143 & LODWORD(v138[0]) | v121 & ~LODWORD(v138[0]));
      v52 = v144.i32[0];
      if (((LODWORD(v137[0]) ^ v122) & v144.i32[0]) != 0)
      {
        v53 = _system_util_log();
        v49 = objc_claimAutoreleasedReturnValue(v53);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
        {
          v54 = v125->ifa_name;
          *(_DWORD *)v170 = 67110146;
          *(_DWORD *)v171 = v137[0];
          *(_WORD *)&v171[4] = 1024;
          *(_DWORD *)&v171[6] = v52;
          *(_WORD *)&v171[10] = 2082;
          *(_QWORD *)&v171[12] = v54;
          v172 = 1024;
          v173 = v120;
          v174 = 1024;
          v175 = v122;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_INFO, "PartialIP - Addr 0x%08X and (Mask 0x%08X) doesn't apply to Interface %{public}s(%u) with Addr 0x%08X", v170, 0x24u);
        }
        goto LABEL_64;
      }
      if ((((uint64_t (*)(_QWORD *, uint64_t, _QWORD *, _QWORD))v124[2])(v124, 2, v137, v120) & 1) == 0)
        break;
    }
LABEL_65:

    if (++v39 >= v38)
    {
      v51 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v145, &buf, 16);
      if (!v51)
        goto LABEL_109;
      v38 = (unint64_t)v51;
      v39 = 0;
    }
  }

LABEL_113:
  v24 = v117;
  v5 = v118;
  a2 = v119;
LABEL_118:
  if (v152)
  {
    freeifaddrs(v152);
    v152 = 0;
  }
LABEL_120:

  objc_autoreleasePoolPop(context);
  *((_DWORD *)v132 + 6) = 0;
  v130[0] = _NSConcreteStackBlock;
  v130[1] = v2;
  v130[2] = __add_domain_to_browser_block_invoke;
  v130[3] = &unk_10013BE70;
  v130[4] = &v131;
  v130[5] = a2;
  v4 = v116;
  v130[6] = v116;
  v130[7] = v5;
  mdns_cfarray_enumerate(v115, (uint64_t)v130);
  CFRelease(v115);
  v7 = *((unsigned int *)v132 + 6);
  if (!(_DWORD)v7)
    goto LABEL_121;
LABEL_158:
  _Block_object_dispose(&v131, 8);
  return v7;
}

uint64_t mDNS_StartBrowse(uint64_t a1, unsigned __int8 *a2, _BYTE *a3, uint64_t a4, int a5, char a6, char a7, uint64_t a8, uint64_t a9)
{
  uint64_t started;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15927);
  started = mDNS_StartBrowse_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15929);
  return started;
}

uint64_t ReconfirmAntecedents(uint64_t result, _BYTE *a2, int a3, uint64_t a4, int a5)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  uint64_t v29;
  unsigned int v30;
  _BYTE *v31;
  uint64_t v33;
  uint8_t buf[4];
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  _BYTE *v45;

  v33 = result;
  if (a4)
  {
    v8 = 0;
    v31 = (_BYTE *)(result + 47032);
    v30 = a5 + 1;
    while (1)
    {
      v29 = v8;
      v9 = *(_QWORD **)(v33 + 8 * v8 + 272);
      if (v9)
        break;
LABEL_59:
      v8 = v29 + 1;
      if (v29 == 498)
        return result;
    }
    while (1)
    {
      v10 = v9[2];
      if (v10)
        break;
LABEL_58:
      v9 = (_QWORD *)*v9;
      if (!v9)
        goto LABEL_59;
    }
    while (1)
    {
      if (*(_BYTE *)(v10 + 109) || *(_QWORD *)(v10 + 32) != a4 || *(_DWORD *)(v10 + 28) != a3)
        goto LABEL_57;
      v11 = *(unsigned __int16 *)(v10 + 12);
      if (v11 <= 0x20)
      {
        switch(*(_WORD *)(v10 + 12))
        {
          case 0xC:
            goto LABEL_17;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_57;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_14;
          default:
            if (v11 == 2 || v11 == 5)
              goto LABEL_17;
            break;
        }
        goto LABEL_57;
      }
      switch(v11)
      {
        case '!':
          v12 = (_BYTE *)(*(_QWORD *)(v10 + 48) + 10);
          break;
        case '$':
LABEL_14:
          v12 = (_BYTE *)(*(_QWORD *)(v10 + 48) + 6);
          break;
        case '\'':
LABEL_17:
          v12 = (_BYTE *)(*(_QWORD *)(v10 + 48) + 4);
          break;
        default:
          goto LABEL_57;
      }
      result = SameDomainNameBytes(v12, a2);
      if ((_DWORD)result)
      {
        v13 = *(unsigned __int8 **)(v10 + 40);
        v14 = v13;
        if (v13 == (unsigned __int8 *)-256)
          goto LABEL_24;
LABEL_21:
        v15 = 257;
        if (v14 < v13 + 256 && v14)
        {
          do
          {
            v16 = *v14;
            if (v16 > 0x3F)
              break;
            if (!*v14)
            {
              v17 = -2128831035;
              v15 = (unsigned __int16)((_WORD)v14 - (_WORD)v13 + 1);
              if ((_WORD)v14 - (_WORD)v13 != 0xFFFF)
                goto LABEL_31;
LABEL_33:
              v20 = v12;
              if (v12 == (_BYTE *)-256)
                goto LABEL_37;
LABEL_34:
              v21 = 257;
              if (v20 < v12 + 256 && v20)
              {
                do
                {
                  v22 = *v20;
                  if (v22 > 0x3F)
                    break;
                  if (!*v20)
                  {
                    v23 = -2128831035;
                    v21 = (unsigned __int16)((_WORD)v20 - (_WORD)v12 + 1);
                    if ((_WORD)v20 - (_WORD)v12 != 0xFFFF)
                      goto LABEL_44;
LABEL_46:
                    v26 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_54;
                    }
                    else
                    {
                      v26 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_54:
                        GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(_QWORD *)(v10 + 48) + 4), v31);
                        *(_DWORD *)buf = 67110403;
                        v35 = a5;
                        v36 = 2048;
                        v37 = a4;
                        v38 = 1024;
                        v39 = v17;
                        v40 = 1024;
                        v41 = v23;
                        v42 = 2160;
                        v43 = 1752392040;
                        v44 = 2085;
                        v45 = v31;
                        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "ReconfirmAntecedents: Reconfirming (depth=%d, InterfaceID=%p, name_hash=%x, target_name_hash=%x) %{sensitive, mask.hash}s", buf, 0x32u);
                      }
                    }
                    result = mDNS_Reconfirm_internal(v33, v10, 0x1388u);
                    if (a5 <= 4)
                      result = ReconfirmAntecedents(v33, *(_QWORD *)(v10 + 40), *(unsigned int *)(v10 + 24), a4, v30);
                    goto LABEL_57;
                  }
                  v20 += v22 + 1;
                  if (v12 != (_BYTE *)-256)
                    goto LABEL_34;
LABEL_37:
                  ;
                }
                while (v20);
                v21 = 257;
              }
LABEL_44:
              v24 = v21;
              v23 = -2128831035;
              do
              {
                v25 = *v12++;
                v23 = 16777619 * (v23 ^ v25);
                --v24;
              }
              while (v24);
              goto LABEL_46;
            }
            v14 += v16 + 1;
            if (v13 != (unsigned __int8 *)-256)
              goto LABEL_21;
LABEL_24:
            ;
          }
          while (v14);
          v15 = 257;
        }
LABEL_31:
        v18 = v15;
        v17 = -2128831035;
        do
        {
          v19 = *v13++;
          v17 = 16777619 * (v17 ^ v19);
          --v18;
        }
        while (v18);
        goto LABEL_33;
      }
LABEL_57:
      v10 = *(_QWORD *)v10;
      if (!v10)
        goto LABEL_58;
    }
  }
  return result;
}

void FoundInstance(uint64_t **a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  unsigned int v13;
  int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  size_t v40;
  unsigned __int16 *v41;
  BOOL v42;
  char *v43;
  int v44;
  char *v45;
  uint64_t v46;
  const void *v47;
  __int16 *v48;
  unsigned int v49;
  __int16 *v50;
  uint64_t v51;
  int validation_result;
  int v53;
  size_t v54;
  unsigned __int16 *v55;
  BOOL v56;
  int v57;
  char *v58;
  uint64_t RDataBytesPointer;
  const void *v60;
  __int16 *v61;
  __int16 *v62;
  int v63;
  char *v64;
  uint64_t v65;
  const void *v66;
  unsigned int v67;
  __int16 *v68;
  int v69;
  char *v70;
  int v71;
  char *v72;
  int v73;
  char *v74;
  char *v75;
  int v76;
  int v77;
  NSObject *v78;
  int v79;
  unsigned int v80;
  int v81;
  const char *v82;
  uint64_t v83;
  const void *v84;
  __int16 *v85;
  int v86;
  char *v87;
  int v88;
  char *v89;
  NSObject *v90;
  int v91;
  unsigned int v92;
  _BYTE *v93;
  uint64_t v94;
  char *v95;
  int v96;
  int v97;
  NSObject *v98;
  char *v99;
  int v100;
  NSObject *v101;
  int v102;
  unsigned int v103;
  _BYTE *v104;
  uint64_t v105;
  uint64_t v106;
  const void *v107;
  __int16 *v108;
  unsigned int v109;
  __int16 *v110;
  uint64_t v111;
  const void *v112;
  __int16 *v113;
  __int16 *v114;
  int v115;
  NSObject *v116;
  NSObject *v117;
  int v118;
  _BYTE *v119;
  uint64_t v120;
  uint64_t v121;
  const void *v122;
  unsigned int v123;
  __int16 *v124;
  uint64_t v125;
  const void *v126;
  __int16 *v127;
  _BYTE *v128;
  uint64_t v129;
  int v130;
  int v131;
  _BYTE *v132;
  uint64_t v133;
  int v134;
  unsigned int v135;
  int v136;
  NSObject *v137;
  uint32_t v138;
  _BYTE *v139;
  uint64_t v140;
  __int16 *v141;
  NSObject *v142;
  int v143;
  unsigned int v144;
  unsigned int v145;
  size_t v146;
  unsigned int v147;
  int v148;
  __int16 *v149;
  NSObject *v150;
  int v151;
  unsigned int v152;
  _BYTE *v153;
  uint64_t v154;
  int v155;
  unsigned int v156;
  _BYTE *v157;
  uint64_t v158;
  int v159;
  int v160;
  _BYTE *v161;
  uint64_t v162;
  NSObject *v163;
  int v164;
  unsigned int v165;
  unsigned int v166;
  size_t v167;
  unsigned int v168;
  __int16 *v169;
  NSObject *v170;
  int v171;
  unsigned int v172;
  _BYTE *v173;
  uint64_t v174;
  _BYTE *v175;
  uint64_t v176;
  int v177;
  int v178;
  _BYTE *v179;
  uint64_t v180;
  __int16 *v181;
  NSObject *v182;
  int v183;
  unsigned int v184;
  size_t v185;
  unsigned int v186;
  int v187;
  __int16 *v188;
  NSObject *v189;
  int v190;
  _BYTE *v191;
  uint64_t v192;
  _BYTE *v193;
  uint64_t v194;
  int v195;
  __int16 *v196;
  NSObject *v197;
  NSObject *v198;
  int v199;
  unsigned int v200;
  size_t v201;
  unsigned int v202;
  NSObject *v203;
  int v204;
  _BYTE *v205;
  uint64_t v206;
  int v207;
  unsigned int v208;
  size_t v209;
  unsigned int v210;
  _BYTE *v211;
  uint64_t v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  const void *v218;
  unsigned int v219;
  const char *v220;
  NSObject *v221;
  uint32_t v222;
  int v223;
  int v224;
  int v225;
  int v226;
  unsigned int v227;
  size_t v228;
  unsigned int v229;
  const void *v230;
  int v231;
  unsigned int v232;
  unsigned int v233;
  unsigned int v234;
  size_t v235;
  unsigned int v236;
  __int16 *v237;
  void *v238;
  const void *v239;
  int v240;
  unsigned int v241;
  unsigned int v242;
  const void *v243;
  unsigned int v244;
  int v245;
  const void *v246;
  int v247;
  __int16 *v248;
  int v249;
  unsigned int v250;
  size_t v251;
  unsigned int v252;
  __int16 *v253;
  const void *v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  size_t v258;
  const void *v259;
  int v260;
  unsigned int v261;
  int v262;
  unsigned int v263;
  size_t v264;
  unsigned int v265;
  const void *v266;
  int v267;
  const void *v268;
  int v269;
  const void *v270;
  int v271;
  unsigned int v272;
  size_t v273;
  unsigned int v274;
  __int16 *v275;
  const void *v276;
  int v277;
  unsigned int v278;
  size_t v279;
  const void *v280;
  int v281;
  int v282;
  int v283;
  __int16 *v284;
  __int16 *v285;
  unsigned int v286;
  unsigned int v287;
  unsigned int v288;
  unsigned int v289;
  __int16 *v290;
  NSObject *v291;
  __int16 *v292;
  NSObject *v293;
  unsigned int v294;
  NSObject *v295;
  unsigned int v296;
  __int16 *v297;
  int v298;
  int v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  int v309;
  int v310;
  int v311;
  int v312;
  int v313;
  int v314;
  int v315;
  _WORD __n[7];
  timespec __tp;
  int v318;
  __int16 v319;
  int v320;
  __int16 v321;
  _BYTE v322[74];

  v8 = *(_QWORD *)(a2 + 176);
  if (*((_WORD *)a3 + 2) != 12)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: FoundInstance: Should not be called with rrtype %d (not a PTR record)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 176));
    return;
  }
  v9 = a4;
  v13 = 2 * ((_DWORD)a4 != 0);
  v14 = *(unsigned __int16 *)(a2 + 340);
  if (!*(_WORD *)(a2 + 340)
    && *(_BYTE *)(a2 + 351)
    && *(_DWORD *)(a2 + 228) >= *(unsigned __int8 *)(a2 + 351))
  {
    v13 |= 0x2000000u;
  }
  *(_QWORD *)&__n[3] = 0;
  if (*a3 == 240)
  {
    v15 = (unsigned __int8 *)(a2 + 376);
    v16 = *((_QWORD *)a3 + 3);
    v17 = v8;
    v18 = v13;
    v19 = -65554;
LABEL_12:
    GenerateBrowseReply(v15, v16, v17, (char **)&__n[3], v18, v19);
    goto LABEL_13;
  }
  if (GenerateNTDResponse((char *)(*((_QWORD *)a3 + 5) + 4), *((_QWORD *)a3 + 3), v8, (char **)&__n[3], (char *)0x42, v13, 0))
  {
    if (!SameDomainNameBytes((_BYTE *)(*(_QWORD *)(v8 + 144) + 10), "\t_services\a_dns-sd\x04_udp"))
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: FoundInstance: %##s PTR %##s received from network is not valid DNS-SD service pointer", v25, v26, v27, v28, v29, *(_DWORD *)(v8 + 176));
      return;
    }
    v15 = (unsigned __int8 *)(*((_QWORD *)a3 + 5) + 4);
    v16 = *((_QWORD *)a3 + 3);
    v17 = v8;
    v18 = v13;
    v19 = 0;
    goto LABEL_12;
  }
LABEL_13:
  v30 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *((_QWORD *)a3 + 3), 0, v20, v21, v22, v23, v24);
  v31 = a2 + 376;
  v32 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  v33 = *(_DWORD *)(v8 + 200);
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  if (!v33 || LODWORD(__tp.tv_sec) - v33 >= 300)
  {
    *(_DWORD *)(v8 + 200) = __tp.tv_sec;
    v51 = *((_QWORD *)a3 + 7);
    if (v51)
    {
      validation_result = dnssec_obj_resource_record_member_get_validation_result(v51);
      v53 = *(unsigned __int16 *)(a2 + 340);
      v55 = (unsigned __int16 *)(a3 + 12);
      v54 = *((unsigned __int16 *)a3 + 6);
      v56 = v54 < 0x201;
      if (validation_result)
      {
        if (*(_WORD *)(a2 + 340))
        {
          if (v54 >= 0x201)
          {
            v99 = (char *)malloc_type_malloc(v54, 0xA172743EuLL);
            if (!v99)
              goto LABEL_488;
            v58 = v99;
            v100 = *v55;
            v43 = v58;
            v57 = v100;
            if (v100)
            {
LABEL_28:
              v299 = v32;
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              RDataBytesPointer = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v58, v57, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1])
                goto LABEL_485;
              v60 = (const void *)RDataBytesPointer;
              v307 = v30;
              if (__n[0] >= 0x1FFuLL)
              {
                v286 = __n[0] + 2;
                v62 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v62)
                  goto LABEL_488;
                v61 = v62;
              }
              else
              {
                v61 = 0;
                v286 = 512;
                v62 = word_100164580;
              }
              v284 = v62;
              v297 = v61;
              if (v14)
                v170 = mDNSLogCategory_Default;
              else
                v170 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || v170 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_483;
                v171 = *(_DWORD *)(v8 + 192);
                v172 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                v175 = (_BYTE *)(a2 + 376);
                if (a2 == -632)
                {
LABEL_300:
                  while (v175)
                  {
                    v176 = *v175;
                    if (v176 > 0x3F)
                      break;
                    if (!*v175)
                    {
                      v223 = (unsigned __int16)((_WORD)v175 - v31 + 1);
                      goto LABEL_450;
                    }
                    v175 += v176 + 1;
                    if (a2 != -632)
                      goto LABEL_299;
                  }
                }
                else
                {
LABEL_299:
                  if ((unint64_t)v175 < a2 + 632)
                    goto LABEL_300;
                }
                v223 = 257;
LABEL_450:
                v250 = *((unsigned __int16 *)a3 + 2);
                v258 = __n[0];
                v252 = __n[0] + 2;
                if (v252 <= v286)
                {
                  v253 = v284;
                  *v284 = __rev16(v250);
                  v259 = v60;
                  v260 = v171;
                  v261 = v172;
                  v294 = v250;
                  v283 = v223;
                  memcpy(v284 + 1, v259, v258);
                  v223 = v283;
                  v250 = v294;
                  v172 = v261;
                  v171 = v260;
                }
                else
                {
                  v253 = 0;
                }
              }
              else
              {
                if (v14)
                  v170 = mDNSLogCategory_Default_redacted;
                else
                  v170 = mDNSLogCategory_mDNS;
                if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_483;
                v171 = *(_DWORD *)(v8 + 192);
                v172 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                v173 = (_BYTE *)(a2 + 376);
                if (a2 == -632)
                {
LABEL_289:
                  while (v173)
                  {
                    v174 = *v173;
                    if (v174 > 0x3F)
                      break;
                    if (!*v173)
                    {
                      v223 = (unsigned __int16)((_WORD)v173 - v31 + 1);
                      goto LABEL_446;
                    }
                    v173 += v174 + 1;
                    if (a2 != -632)
                      goto LABEL_288;
                  }
                }
                else
                {
LABEL_288:
                  if ((unint64_t)v173 < a2 + 632)
                    goto LABEL_289;
                }
                v223 = 257;
LABEL_446:
                v250 = *((unsigned __int16 *)a3 + 2);
                v251 = __n[0];
                v252 = __n[0] + 2;
                if (v252 <= v286)
                {
                  v253 = v284;
                  *v284 = __rev16(v250);
                  v254 = v60;
                  v255 = v171;
                  v256 = v172;
                  v293 = v170;
                  v257 = v250;
                  v282 = v223;
                  memcpy(v284 + 1, v254, v251);
                  v223 = v282;
                  v250 = v257;
                  v170 = v293;
                  v172 = v256;
                  v171 = v255;
                }
                else
                {
                  v253 = 0;
                }
              }
              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v171;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v172;
              HIWORD(__tp.tv_nsec) = 1024;
              v318 = v9;
              v319 = 1024;
              v320 = 0;
              v321 = 1024;
              *(_DWORD *)v322 = v307;
              *(_WORD *)&v322[4] = 2160;
              *(_QWORD *)&v322[6] = 1752392040;
              *(_WORD *)&v322[14] = 1040;
              *(_DWORD *)&v322[16] = v223;
              *(_WORD *)&v322[20] = 2101;
              *(_QWORD *)&v322[22] = v31;
              *(_WORD *)&v322[30] = 1024;
              *(_DWORD *)&v322[32] = v299;
              *(_WORD *)&v322[36] = 1026;
              *(_DWORD *)&v322[38] = validation_result;
              *(_WORD *)&v322[42] = 1024;
              *(_DWORD *)&v322[44] = v250;
              *(_WORD *)&v322[48] = 2160;
              *(_QWORD *)&v322[50] = 1752392040;
              *(_WORD *)&v322[58] = 1040;
              *(_DWORD *)&v322[60] = v252;
              *(_WORD *)&v322[64] = 2101;
              *(_QWORD *)&v322[66] = v253;
              v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                     " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_re"
                     "sult}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              v221 = v170;
              v222 = 102;
              goto LABEL_482;
            }
          }
          else
          {
            v43 = 0;
            v57 = 512;
            v58 = (char *)&unk_100164380;
            if (*((_WORD *)a3 + 6))
              goto LABEL_28;
          }
          v310 = v30;
          if (v14)
            v101 = mDNSLogCategory_Default;
          else
            v101 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v101 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
              goto LABEL_485;
            v102 = *(_DWORD *)(v8 + 192);
            v103 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v139 = (_BYTE *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_206:
              while (v139)
              {
                v140 = *v139;
                if (v140 > 0x3F)
                  break;
                if (!*v139)
                {
                  v213 = (unsigned __int16)((_WORD)v139 - v31 + 1);
                  goto LABEL_422;
                }
                v139 += v140 + 1;
                if (a2 != -632)
                  goto LABEL_205;
              }
            }
            else
            {
LABEL_205:
              if ((unint64_t)v139 < a2 + 632)
                goto LABEL_206;
            }
            v213 = 257;
          }
          else
          {
            if (v14)
              v101 = mDNSLogCategory_Default_redacted;
            else
              v101 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
              goto LABEL_485;
            v102 = *(_DWORD *)(v8 + 192);
            v103 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v104 = (_BYTE *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_110:
              while (v104)
              {
                v105 = *v104;
                if (v105 > 0x3F)
                  break;
                if (!*v104)
                {
                  v213 = (unsigned __int16)((_WORD)v104 - v31 + 1);
                  goto LABEL_422;
                }
                v104 += v105 + 1;
                if (a2 != -632)
                  goto LABEL_109;
              }
            }
            else
            {
LABEL_109:
              if ((unint64_t)v104 < a2 + 632)
                goto LABEL_110;
            }
            v213 = 257;
          }
LABEL_422:
          v226 = *((unsigned __int16 *)a3 + 2);
          LODWORD(__tp.tv_sec) = 67111683;
          HIDWORD(__tp.tv_sec) = v102;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v103;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = v9;
          v319 = 1024;
          v320 = 0;
          v321 = 1024;
          *(_DWORD *)v322 = v310;
          *(_WORD *)&v322[4] = 2160;
          *(_QWORD *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v213;
          *(_WORD *)&v322[20] = 2101;
          *(_QWORD *)&v322[22] = a2 + 376;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v32;
          *(_WORD *)&v322[36] = 1026;
          *(_DWORD *)&v322[38] = validation_result;
          *(_WORD *)&v322[42] = 1024;
          *(_DWORD *)&v322[44] = v226;
          v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
                ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, ty"
                "pe: %{mdns:rrtype}d, rdata: <none>";
          v137 = v101;
          v138 = 76;
          goto LABEL_458;
        }
        if (v54 >= 0x201)
        {
          v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
          if (!v54)
            goto LABEL_488;
          v89 = (char *)v54;
          LODWORD(v54) = *v55;
          v43 = v89;
          v88 = v54;
        }
        else
        {
          v43 = 0;
          v88 = 512;
          v89 = (char *)&unk_100164380;
        }
        if ((_DWORD)v54)
        {
          v305 = v32;
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          v125 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v89, v88, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1])
            goto LABEL_485;
          v126 = (const void *)v125;
          v314 = v30;
          if (__n[0] >= 0x1FFuLL)
          {
            v289 = __n[0] + 2;
            v127 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v127)
              goto LABEL_488;
            v297 = v127;
          }
          else
          {
            v289 = 512;
            v297 = 0;
            v127 = word_100164580;
          }
          v285 = v127;
          if (v14)
            v203 = mDNSLogCategory_Default;
          else
            v203 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v203 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT))
              goto LABEL_483;
            v204 = *(_DWORD *)(v8 + 192);
            v211 = (_BYTE *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_397:
              while (v211)
              {
                v212 = *v211;
                if (v212 > 0x3F)
                  break;
                if (!*v211)
                {
                  v249 = (unsigned __int16)((_WORD)v211 - v31 + 1);
                  goto LABEL_477;
                }
                v211 += v212 + 1;
                if (a2 != -632)
                  goto LABEL_396;
              }
            }
            else
            {
LABEL_396:
              if ((unint64_t)v211 < a2 + 632)
                goto LABEL_397;
            }
            v249 = 257;
LABEL_477:
            v272 = *((unsigned __int16 *)a3 + 2);
            v279 = __n[0];
            v274 = __n[0] + 2;
            if (v274 <= v289)
            {
              v275 = v285;
              *v285 = __rev16(v272);
              v280 = v126;
              v281 = v204;
              v296 = v272;
              memcpy(v285 + 1, v280, v279);
              v272 = v296;
              v204 = v281;
            }
            else
            {
              v275 = 0;
            }
          }
          else
          {
            if (v14)
              v203 = mDNSLogCategory_Default_redacted;
            else
              v203 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT))
              goto LABEL_483;
            v204 = *(_DWORD *)(v8 + 192);
            v205 = (_BYTE *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_386:
              while (v205)
              {
                v206 = *v205;
                if (v206 > 0x3F)
                  break;
                if (!*v205)
                {
                  v249 = (unsigned __int16)((_WORD)v205 - v31 + 1);
                  goto LABEL_473;
                }
                v205 += v206 + 1;
                if (a2 != -632)
                  goto LABEL_385;
              }
            }
            else
            {
LABEL_385:
              if ((unint64_t)v205 < a2 + 632)
                goto LABEL_386;
            }
            v249 = 257;
LABEL_473:
            v272 = *((unsigned __int16 *)a3 + 2);
            v273 = __n[0];
            v274 = __n[0] + 2;
            if (v274 <= v289)
            {
              v275 = v285;
              *v285 = __rev16(v272);
              v276 = v126;
              v277 = v204;
              v295 = v203;
              v278 = v272;
              memcpy(v285 + 1, v276, v273);
              v272 = v278;
              v203 = v295;
              v204 = v277;
            }
            else
            {
              v275 = 0;
            }
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v204;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = 0;
          v319 = 1024;
          v320 = v314;
          v321 = 2160;
          *(_QWORD *)v322 = 1752392040;
          *(_WORD *)&v322[8] = 1040;
          *(_DWORD *)&v322[10] = v249;
          *(_WORD *)&v322[14] = 2101;
          *(_QWORD *)&v322[16] = v31;
          *(_WORD *)&v322[24] = 1024;
          *(_DWORD *)&v322[26] = v305;
          *(_WORD *)&v322[30] = 1026;
          *(_DWORD *)&v322[32] = validation_result;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v272;
          *(_WORD *)&v322[42] = 2160;
          *(_QWORD *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v274;
          *(_WORD *)&v322[58] = 2101;
          *(_QWORD *)&v322[60] = v275;
          v220 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                 "ame: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d"
                 ", type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          v221 = v203;
LABEL_481:
          v222 = 96;
          goto LABEL_482;
        }
        v315 = v30;
        if (v14)
          v90 = mDNSLogCategory_Default;
        else
          v90 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v90 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
            goto LABEL_485;
          v131 = *(_DWORD *)(v8 + 192);
          v179 = (_BYTE *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_311:
            while (v179)
            {
              v180 = *v179;
              if (v180 > 0x3F)
                break;
              if (!*v179)
              {
                v224 = (unsigned __int16)((_WORD)v179 - v31 + 1);
                goto LABEL_456;
              }
              v179 += v180 + 1;
              if (a2 != -632)
                goto LABEL_310;
            }
          }
          else
          {
LABEL_310:
            if ((unint64_t)v179 < a2 + 632)
              goto LABEL_311;
          }
          v224 = 257;
        }
        else
        {
          if (v14)
            v90 = mDNSLogCategory_Default_redacted;
          else
            v90 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
            goto LABEL_485;
          v131 = *(_DWORD *)(v8 + 192);
          v132 = (_BYTE *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_196:
            while (v132)
            {
              v133 = *v132;
              if (v133 > 0x3F)
                break;
              if (!*v132)
              {
                v224 = (unsigned __int16)((_WORD)v132 - v31 + 1);
                goto LABEL_456;
              }
              v132 += v133 + 1;
              if (a2 != -632)
                goto LABEL_195;
            }
          }
          else
          {
LABEL_195:
            if ((unint64_t)v132 < a2 + 632)
              goto LABEL_196;
          }
          v224 = 257;
        }
LABEL_456:
        v262 = *((unsigned __int16 *)a3 + 2);
        LODWORD(__tp.tv_sec) = 67111427;
        HIDWORD(__tp.tv_sec) = v131;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        v318 = 0;
        v319 = 1024;
        v320 = v315;
        v321 = 2160;
        *(_QWORD *)v322 = 1752392040;
        *(_WORD *)&v322[8] = 1040;
        *(_DWORD *)&v322[10] = v224;
        *(_WORD *)&v322[14] = 2101;
        *(_QWORD *)&v322[16] = a2 + 376;
        *(_WORD *)&v322[24] = 1024;
        *(_DWORD *)&v322[26] = v32;
        *(_WORD *)&v322[30] = 1026;
        *(_DWORD *)&v322[32] = validation_result;
        *(_WORD *)&v322[36] = 1024;
        *(_DWORD *)&v322[38] = v262;
        v82 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
              ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, type"
              ": %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_457;
      }
    }
    else
    {
      v53 = *(unsigned __int16 *)(a2 + 340);
      v55 = (unsigned __int16 *)(a3 + 12);
      LODWORD(v54) = *((unsigned __int16 *)a3 + 6);
      v56 = v54 < 0x201;
    }
    if (v53)
    {
      if (v56)
      {
        v43 = 0;
        v69 = 512;
        v70 = (char *)&unk_100164380;
      }
      else
      {
        v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
        if (!v54)
          goto LABEL_488;
        v70 = (char *)v54;
        LODWORD(v54) = *v55;
        v43 = v70;
        v69 = v54;
      }
      v309 = v30;
      if ((_DWORD)v54)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v83 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v70, v69, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_485;
        v84 = (const void *)v83;
        v301 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v148 = __n[0] + 2;
          v149 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v149)
            goto LABEL_488;
          v85 = v149;
          v287 = v148;
          v297 = v149;
        }
        else
        {
          v287 = 512;
          v297 = 0;
          v85 = word_100164580;
        }
        if (v14)
          v150 = mDNSLogCategory_Default;
        else
          v150 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v150 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v155 = *(_DWORD *)(v8 + 192);
          v156 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          v157 = (_BYTE *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_248:
            while (v157)
            {
              v158 = *v157;
              if (v158 > 0x3F)
                break;
              if (!*v157)
              {
                v215 = (unsigned __int16)((_WORD)v157 - v31 + 1);
                goto LABEL_429;
              }
              v157 += v158 + 1;
              if (a2 != -632)
                goto LABEL_247;
            }
          }
          else
          {
LABEL_247:
            if ((unint64_t)v157 < a2 + 632)
              goto LABEL_248;
          }
          v215 = 257;
LABEL_429:
          v234 = *((unsigned __int16 *)a3 + 2);
          v235 = __n[0];
          v236 = __n[0] + 2;
          if (v236 <= v287)
          {
            *v85 = __rev16(v234);
            v238 = v85 + 1;
            v239 = v84;
            v240 = v155;
            v241 = v156;
            v292 = v85;
            v242 = v236;
            memcpy(v238, v239, v235);
            v236 = v242;
            v237 = v292;
            v156 = v241;
            v155 = v240;
          }
          else
          {
            v237 = 0;
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v155;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v156;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = v9;
          v319 = 1024;
          v320 = 0;
          v321 = 1024;
          *(_DWORD *)v322 = v309;
          *(_WORD *)&v322[4] = 2160;
          *(_QWORD *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v215;
          *(_WORD *)&v322[20] = 2101;
          *(_QWORD *)&v322[22] = v31;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v301;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v234;
          *(_WORD *)&v322[42] = 2160;
          *(_QWORD *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v236;
          *(_WORD *)&v322[58] = 2101;
          *(_QWORD *)&v322[60] = v237;
          v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
                 "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitiv"
                 "e, mask.hash, mdns:rdata}.*P";
        }
        else
        {
          if (v14)
            v150 = mDNSLogCategory_Default_redacted;
          else
            v150 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v151 = *(_DWORD *)(v8 + 192);
          v152 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          v153 = (_BYTE *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_237:
            while (v153)
            {
              v154 = *v153;
              if (v154 > 0x3F)
                break;
              if (!*v153)
              {
                v214 = (unsigned __int16)((_WORD)v153 - v31 + 1);
                goto LABEL_424;
              }
              v153 += v154 + 1;
              if (a2 != -632)
                goto LABEL_236;
            }
          }
          else
          {
LABEL_236:
            if ((unint64_t)v153 < a2 + 632)
              goto LABEL_237;
          }
          v214 = 257;
LABEL_424:
          v227 = *((unsigned __int16 *)a3 + 2);
          v228 = __n[0];
          v229 = __n[0] + 2;
          if (v229 <= v287)
          {
            *v85 = __rev16(v227);
            v230 = v84;
            v231 = v151;
            v232 = v152;
            v291 = v150;
            v233 = v227;
            memcpy(v85 + 1, v230, v228);
            v227 = v233;
            v150 = v291;
            v152 = v232;
            v151 = v231;
          }
          else
          {
            v85 = 0;
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v151;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v152;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = v9;
          v319 = 1024;
          v320 = 0;
          v321 = 1024;
          *(_DWORD *)v322 = v309;
          *(_WORD *)&v322[4] = 2160;
          *(_QWORD *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v214;
          *(_WORD *)&v322[20] = 2101;
          *(_QWORD *)&v322[22] = v31;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v301;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v227;
          *(_WORD *)&v322[42] = 2160;
          *(_QWORD *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v229;
          *(_WORD *)&v322[58] = 2101;
          *(_QWORD *)&v322[60] = v85;
          v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
                 "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitiv"
                 "e, mask.hash, mdns:rdata}.*P";
        }
        v221 = v150;
        goto LABEL_481;
      }
      if (v14)
        v90 = mDNSLogCategory_Default;
      else
        v90 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v90 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
        v91 = *(_DWORD *)(v8 + 192);
        v92 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        v128 = (_BYTE *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_170:
          while (v128)
          {
            v129 = *v128;
            if (v129 > 0x3F)
              break;
            if (!*v128)
            {
              v195 = (unsigned __int16)((_WORD)v128 - v31 + 1);
              goto LABEL_409;
            }
            v128 += v129 + 1;
            if (a2 != -632)
              goto LABEL_169;
          }
        }
        else
        {
LABEL_169:
          if ((unint64_t)v128 < a2 + 632)
            goto LABEL_170;
        }
        v195 = 257;
      }
      else
      {
        if (v14)
          v90 = mDNSLogCategory_Default_redacted;
        else
          v90 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
        v91 = *(_DWORD *)(v8 + 192);
        v92 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        v93 = (_BYTE *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_80:
          while (v93)
          {
            v94 = *v93;
            if (v94 > 0x3F)
              break;
            if (!*v93)
            {
              v195 = (unsigned __int16)((_WORD)v93 - v31 + 1);
              goto LABEL_409;
            }
            v93 += v94 + 1;
            if (a2 != -632)
              goto LABEL_79;
          }
        }
        else
        {
LABEL_79:
          if ((unint64_t)v93 < a2 + 632)
            goto LABEL_80;
        }
        v195 = 257;
      }
LABEL_409:
      v217 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v91;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v92;
      HIWORD(__tp.tv_nsec) = 1024;
      v318 = v9;
      v319 = 1024;
      v320 = 0;
      v321 = 1024;
      *(_DWORD *)v322 = v309;
      *(_WORD *)&v322[4] = 2160;
      *(_QWORD *)&v322[6] = 1752392040;
      *(_WORD *)&v322[14] = 1040;
      *(_DWORD *)&v322[16] = v195;
      *(_WORD *)&v322[20] = 2101;
      *(_QWORD *)&v322[22] = a2 + 376;
      *(_WORD *)&v322[30] = 1024;
      *(_DWORD *)&v322[32] = v32;
      *(_WORD *)&v322[36] = 1024;
      *(_DWORD *)&v322[38] = v217;
      v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{"
            "sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_457:
      v137 = v90;
      v138 = 70;
      goto LABEL_458;
    }
    if (v56)
    {
      v43 = 0;
      v73 = 512;
      v74 = (char *)&unk_100164380;
    }
    else
    {
      v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
      if (!v54)
        goto LABEL_488;
      v74 = (char *)v54;
      LODWORD(v54) = *v55;
      v43 = v74;
      v73 = v54;
    }
    v312 = v30;
    if (!(_DWORD)v54)
    {
      if (v14)
        v117 = mDNSLogCategory_Default;
      else
        v117 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v117 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
        v118 = *(_DWORD *)(v8 + 192);
        v161 = (_BYTE *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_258:
          while (v161)
          {
            v162 = *v161;
            if (v162 > 0x3F)
              break;
            if (!*v161)
            {
              v216 = (unsigned __int16)((_WORD)v161 - v31 + 1);
              goto LABEL_438;
            }
            v161 += v162 + 1;
            if (a2 != -632)
              goto LABEL_257;
          }
        }
        else
        {
LABEL_257:
          if ((unint64_t)v161 < a2 + 632)
            goto LABEL_258;
        }
        v216 = 257;
      }
      else
      {
        if (v14)
          v117 = mDNSLogCategory_Default_redacted;
        else
          v117 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
        v118 = *(_DWORD *)(v8 + 192);
        v119 = (_BYTE *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_148:
          while (v119)
          {
            v120 = *v119;
            if (v120 > 0x3F)
              break;
            if (!*v119)
            {
              v216 = (unsigned __int16)((_WORD)v119 - v31 + 1);
              goto LABEL_438;
            }
            v119 += v120 + 1;
            if (a2 != -632)
              goto LABEL_147;
          }
        }
        else
        {
LABEL_147:
          if ((unint64_t)v119 < a2 + 632)
            goto LABEL_148;
        }
        v216 = 257;
      }
LABEL_438:
      v245 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v118;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      v318 = 0;
      v319 = 1024;
      v320 = v312;
      v321 = 2160;
      *(_QWORD *)v322 = 1752392040;
      *(_WORD *)&v322[8] = 1040;
      *(_DWORD *)&v322[10] = v216;
      *(_WORD *)&v322[14] = 2101;
      *(_QWORD *)&v322[16] = a2 + 376;
      *(_WORD *)&v322[24] = 1024;
      *(_DWORD *)&v322[26] = v32;
      *(_WORD *)&v322[30] = 1024;
      *(_DWORD *)&v322[32] = v245;
      v82 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: "
            "%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      v137 = v117;
      v138 = 64;
      goto LABEL_458;
    }
    *(_DWORD *)&__n[1] = 0;
    __n[0] = 0;
    v111 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v74, v73, __n, (int *)&__n[1], v34, v35, v36);
    if (*(_DWORD *)&__n[1])
      goto LABEL_485;
    v112 = (const void *)v111;
    v303 = v32;
    if (__n[0] >= 0x1FFuLL)
    {
      v187 = __n[0] + 2;
      v188 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
      if (!v188)
        goto LABEL_488;
      v114 = v188;
      v288 = v187;
      v113 = v188;
    }
    else
    {
      v113 = 0;
      v288 = 512;
      v114 = word_100164580;
    }
    v297 = v113;
    if (v14)
      v189 = mDNSLogCategory_Default;
    else
      v189 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v189 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
        goto LABEL_483;
      v190 = *(_DWORD *)(v8 + 192);
      v193 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_353:
        while (v193)
        {
          v194 = *v193;
          if (v194 > 0x3F)
            break;
          if (!*v193)
          {
            v225 = (unsigned __int16)((_WORD)v193 - v31 + 1);
            goto LABEL_464;
          }
          v193 += v194 + 1;
          if (a2 != -632)
            goto LABEL_352;
        }
      }
      else
      {
LABEL_352:
        if ((unint64_t)v193 < a2 + 632)
          goto LABEL_353;
      }
      v225 = 257;
LABEL_464:
      v263 = *((unsigned __int16 *)a3 + 2);
      v264 = __n[0];
      v265 = __n[0] + 2;
      if (v265 > v288)
      {
        v114 = 0;
        goto LABEL_467;
      }
    }
    else
    {
      if (v14)
        v189 = mDNSLogCategory_Default_redacted;
      else
        v189 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
        goto LABEL_483;
      v190 = *(_DWORD *)(v8 + 192);
      v191 = (_BYTE *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_342:
        while (v191)
        {
          v192 = *v191;
          if (v192 > 0x3F)
            break;
          if (!*v191)
          {
            v225 = (unsigned __int16)((_WORD)v191 - v31 + 1);
            goto LABEL_460;
          }
          v191 += v192 + 1;
          if (a2 != -632)
            goto LABEL_341;
        }
      }
      else
      {
LABEL_341:
        if ((unint64_t)v191 < a2 + 632)
          goto LABEL_342;
      }
      v225 = 257;
LABEL_460:
      v263 = *((unsigned __int16 *)a3 + 2);
      v264 = __n[0];
      v265 = __n[0] + 2;
      if (v265 > v288)
      {
        v114 = 0;
LABEL_467:
        LODWORD(__tp.tv_sec) = 67111939;
        HIDWORD(__tp.tv_sec) = v190;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        v318 = 0;
        v319 = 1024;
        v320 = v312;
        v321 = 2160;
        *(_QWORD *)v322 = 1752392040;
        *(_WORD *)&v322[8] = 1040;
        *(_DWORD *)&v322[10] = v225;
        *(_WORD *)&v322[14] = 2101;
        *(_QWORD *)&v322[16] = v31;
        *(_WORD *)&v322[24] = 1024;
        *(_DWORD *)&v322[26] = v303;
        *(_WORD *)&v322[30] = 1024;
        *(_DWORD *)&v322[32] = v263;
        *(_WORD *)&v322[36] = 2160;
        *(_QWORD *)&v322[38] = 1752392040;
        *(_WORD *)&v322[46] = 1040;
        *(_DWORD *)&v322[48] = v265;
        *(_WORD *)&v322[52] = 2101;
        *(_QWORD *)&v322[54] = v114;
        v220 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
               "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive,"
               " mask.hash, mdns:rdata}.*P";
        v221 = v189;
        v222 = 90;
        goto LABEL_482;
      }
    }
    *v114 = __rev16(v263);
    v266 = v112;
    v267 = v190;
    memcpy(v114 + 1, v266, v264);
    v190 = v267;
    goto LABEL_467;
  }
  v37 = *((_QWORD *)a3 + 7);
  if (v37)
  {
    v38 = dnssec_obj_resource_record_member_get_validation_result(v37);
    v39 = *(unsigned __int16 *)(a2 + 340);
    v41 = (unsigned __int16 *)(a3 + 12);
    v40 = *((unsigned __int16 *)a3 + 6);
    v42 = v40 < 0x201;
    if (v38)
    {
      if (*(_WORD *)(a2 + 340))
      {
        if (v40 >= 0x201)
        {
          v95 = (char *)malloc_type_malloc(v40, 0xA172743EuLL);
          if (!v95)
            goto LABEL_488;
          v45 = v95;
          v96 = *v41;
          v43 = v45;
          v44 = v96;
          if (v96)
            goto LABEL_20;
        }
        else
        {
          v43 = 0;
          v44 = 512;
          v45 = (char *)&unk_100164380;
          if (*((_WORD *)a3 + 6))
          {
LABEL_20:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v46 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v45, v44, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1])
              goto LABEL_485;
            v47 = (const void *)v46;
            v298 = v32;
            v306 = v30;
            if (__n[0] < 0x1FFuLL)
            {
              v48 = 0;
              v49 = 512;
              v50 = word_100164580;
LABEL_265:
              v290 = v50;
              v297 = v48;
              if (v14)
                v163 = mDNSLogCategory_Default;
              else
                v163 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || v163 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_483;
                v164 = *(_DWORD *)(v8 + 192);
                v165 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                v166 = *((unsigned __int16 *)a3 + 2);
                v167 = __n[0];
                v168 = __n[0] + 2;
                if (v168 > v49)
                {
                  v169 = 0;
                  goto LABEL_435;
                }
LABEL_434:
                v169 = v290;
                *v290 = __rev16(v166);
                v243 = v47;
                v244 = v165;
                memcpy(v290 + 1, v243, v167);
                v165 = v244;
                goto LABEL_435;
              }
              if (v14)
                v163 = mDNSLogCategory_Default_redacted;
              else
                v163 = mDNSLogCategory_mDNS;
              if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
              {
                v164 = *(_DWORD *)(v8 + 192);
                v165 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                v166 = *((unsigned __int16 *)a3 + 2);
                v167 = __n[0];
                v168 = __n[0] + 2;
                if (v168 > v49)
                {
                  v169 = 0;
LABEL_435:
                  LODWORD(__tp.tv_sec) = 67111683;
                  HIDWORD(__tp.tv_sec) = v164;
                  LOWORD(__tp.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v165;
                  HIWORD(__tp.tv_nsec) = 1024;
                  v318 = v9;
                  v319 = 1024;
                  v320 = 0;
                  v321 = 1024;
                  *(_DWORD *)v322 = v306;
                  *(_WORD *)&v322[4] = 1024;
                  *(_DWORD *)&v322[6] = v298;
                  *(_WORD *)&v322[10] = 1026;
                  *(_DWORD *)&v322[12] = v38;
                  *(_WORD *)&v322[16] = 1024;
                  *(_DWORD *)&v322[18] = v166;
                  *(_WORD *)&v322[22] = 2160;
                  *(_QWORD *)&v322[24] = 1752392040;
                  *(_WORD *)&v322[32] = 1040;
                  *(_DWORD *)&v322[34] = v168;
                  *(_WORD *)&v322[38] = 2101;
                  *(_QWORD *)&v322[40] = v169;
                  v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                         " %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sen"
                         "sitive, mask.hash, mdns:rdata}.*P";
                  v221 = v163;
                  v222 = 76;
                  goto LABEL_482;
                }
                goto LABEL_434;
              }
LABEL_483:
              v248 = v297;
              if (v297)
                goto LABEL_484;
              goto LABEL_485;
            }
            v49 = __n[0] + 2;
            v50 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (v50)
            {
              v48 = v50;
              goto LABEL_265;
            }
LABEL_488:
            __break(1u);
          }
        }
        v97 = v30;
        if (v14)
          v98 = mDNSLogCategory_Default;
        else
          v98 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v98 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
            goto LABEL_485;
        }
        else
        {
          if (v14)
            v98 = mDNSLogCategory_Default_redacted;
          else
            v98 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
            goto LABEL_485;
        }
        v134 = *(_DWORD *)(v8 + 192);
        v135 = bswap32(*(unsigned __int16 *)(a2 + 340));
        v136 = *((unsigned __int16 *)a3 + 2);
        LODWORD(__tp.tv_sec) = 67110912;
        HIDWORD(__tp.tv_sec) = v134;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v135);
        HIWORD(__tp.tv_nsec) = 1024;
        v318 = v9;
        v319 = 1024;
        v320 = 0;
        v321 = 1024;
        *(_DWORD *)v322 = v97;
        *(_WORD *)&v322[4] = 1024;
        *(_DWORD *)&v322[6] = v32;
        *(_WORD *)&v322[10] = 1026;
        *(_DWORD *)&v322[12] = v38;
        *(_WORD *)&v322[16] = 1024;
        *(_DWORD *)&v322[18] = v136;
        v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
              "ash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
        v137 = v98;
        v138 = 50;
LABEL_458:
        _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, v82, (uint8_t *)&__tp, v138);
        goto LABEL_485;
      }
      if (v40 >= 0x201)
      {
        v40 = (size_t)malloc_type_malloc(v40, 0xA172743EuLL);
        if (!v40)
          goto LABEL_488;
        v87 = (char *)v40;
        LODWORD(v40) = *v41;
        v43 = v87;
        v86 = v40;
      }
      else
      {
        v43 = 0;
        v86 = 512;
        v87 = (char *)&unk_100164380;
      }
      if ((_DWORD)v40)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v121 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v87, v86, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_485;
        v122 = (const void *)v121;
        v304 = v32;
        v313 = v30;
        if (__n[0] >= 0x1FFuLL)
        {
          v123 = __n[0] + 2;
          v196 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v196)
            goto LABEL_488;
          v124 = v196;
          v297 = v196;
        }
        else
        {
          v297 = 0;
          v123 = 512;
          v124 = word_100164580;
        }
        if (v14)
          v197 = mDNSLogCategory_Default;
        else
          v197 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v197 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v207 = *(_DWORD *)(v8 + 192);
          v208 = *((unsigned __int16 *)a3 + 2);
          v209 = __n[0];
          v210 = __n[0] + 2;
          if (v210 <= v123)
          {
            *v124 = __rev16(v208);
            v270 = v122;
            v271 = v207;
            memcpy(v124 + 1, v270, v209);
            v207 = v271;
          }
          else
          {
            v124 = 0;
          }
          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v207;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = 0;
          v319 = 1024;
          v320 = v313;
          v321 = 1024;
          *(_DWORD *)v322 = v304;
          *(_WORD *)&v322[4] = 1026;
          *(_DWORD *)&v322[6] = v38;
          *(_WORD *)&v322[10] = 1024;
          *(_DWORD *)&v322[12] = v208;
          *(_WORD *)&v322[16] = 2160;
          *(_QWORD *)&v322[18] = 1752392040;
          *(_WORD *)&v322[26] = 1040;
          *(_DWORD *)&v322[28] = v210;
          *(_WORD *)&v322[32] = 2101;
          *(_QWORD *)&v322[34] = v124;
          v220 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                 "ame hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.h"
                 "ash, mdns:rdata}.*P";
          v221 = v197;
        }
        else
        {
          if (v14)
            v198 = mDNSLogCategory_Default_redacted;
          else
            v198 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v199 = *(_DWORD *)(v8 + 192);
          v200 = *((unsigned __int16 *)a3 + 2);
          v201 = __n[0];
          v202 = __n[0] + 2;
          if (v202 <= v123)
          {
            *v124 = __rev16(v200);
            v268 = v122;
            v269 = v199;
            memcpy(v124 + 1, v268, v201);
            v199 = v269;
          }
          else
          {
            v124 = 0;
          }
          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v199;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          v318 = 0;
          v319 = 1024;
          v320 = v313;
          v321 = 1024;
          *(_DWORD *)v322 = v304;
          *(_WORD *)&v322[4] = 1026;
          *(_DWORD *)&v322[6] = v38;
          *(_WORD *)&v322[10] = 1024;
          *(_DWORD *)&v322[12] = v200;
          *(_WORD *)&v322[16] = 2160;
          *(_QWORD *)&v322[18] = 1752392040;
          *(_WORD *)&v322[26] = 1040;
          *(_DWORD *)&v322[28] = v202;
          *(_WORD *)&v322[32] = 2101;
          *(_QWORD *)&v322[34] = v124;
          v220 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                 "ame hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.h"
                 "ash, mdns:rdata}.*P";
          v221 = v198;
        }
LABEL_413:
        v222 = 70;
LABEL_482:
        _os_log_impl((void *)&_mh_execute_header, v221, OS_LOG_TYPE_DEFAULT, v220, (uint8_t *)&__tp, v222);
        goto LABEL_483;
      }
      v130 = v30;
      if (v14)
        v78 = mDNSLogCategory_Default;
      else
        v78 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
      }
      else
      {
        if (v14)
          v78 = mDNSLogCategory_Default_redacted;
        else
          v78 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          goto LABEL_485;
      }
      v177 = *(_DWORD *)(v8 + 192);
      v178 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67110656;
      HIDWORD(__tp.tv_sec) = v177;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      v318 = 0;
      v319 = 1024;
      v320 = v130;
      v321 = 1024;
      *(_DWORD *)v322 = v32;
      *(_WORD *)&v322[4] = 1026;
      *(_DWORD *)&v322[6] = v38;
      *(_WORD *)&v322[10] = 1024;
      *(_DWORD *)&v322[12] = v178;
      v82 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
            "ash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_307:
      v137 = v78;
      v138 = 44;
      goto LABEL_458;
    }
  }
  else
  {
    v39 = *(unsigned __int16 *)(a2 + 340);
    v41 = (unsigned __int16 *)(a3 + 12);
    LODWORD(v40) = *((unsigned __int16 *)a3 + 6);
    v42 = v40 < 0x201;
  }
  if (v39)
  {
    if (v42)
    {
      v43 = 0;
      v63 = 512;
      v64 = (char *)&unk_100164380;
      if ((_DWORD)v40)
        goto LABEL_35;
    }
    else
    {
      v75 = (char *)malloc_type_malloc(v40, 0xA172743EuLL);
      if (!v75)
        goto LABEL_488;
      v64 = v75;
      v76 = *v41;
      v43 = v64;
      v63 = v76;
      if (v76)
      {
LABEL_35:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v65 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v64, v63, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_485;
        v66 = (const void *)v65;
        v300 = v32;
        v308 = v30;
        if (__n[0] >= 0x1FFuLL)
        {
          v67 = __n[0] + 2;
          v141 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v141)
            goto LABEL_488;
          v68 = v141;
          v297 = v141;
        }
        else
        {
          v297 = 0;
          v67 = 512;
          v68 = word_100164580;
        }
        if (v14)
          v142 = mDNSLogCategory_Default;
        else
          v142 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v142 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v143 = *(_DWORD *)(v8 + 192);
          v144 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          v145 = *((unsigned __int16 *)a3 + 2);
          v146 = __n[0];
          v147 = __n[0] + 2;
          if (v147 > v67)
          {
            v68 = 0;
            goto LABEL_412;
          }
        }
        else
        {
          if (v14)
            v142 = mDNSLogCategory_Default_redacted;
          else
            v142 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
            goto LABEL_483;
          v143 = *(_DWORD *)(v8 + 192);
          v144 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          v145 = *((unsigned __int16 *)a3 + 2);
          v146 = __n[0];
          v147 = __n[0] + 2;
          if (v147 > v67)
          {
            v68 = 0;
LABEL_412:
            LODWORD(__tp.tv_sec) = 67111427;
            HIDWORD(__tp.tv_sec) = v143;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v144;
            HIWORD(__tp.tv_nsec) = 1024;
            v318 = v9;
            v319 = 1024;
            v320 = 0;
            v321 = 1024;
            *(_DWORD *)v322 = v308;
            *(_WORD *)&v322[4] = 1024;
            *(_DWORD *)&v322[6] = v300;
            *(_WORD *)&v322[10] = 1024;
            *(_DWORD *)&v322[12] = v145;
            *(_WORD *)&v322[16] = 2160;
            *(_QWORD *)&v322[18] = 1752392040;
            *(_WORD *)&v322[26] = 1040;
            *(_DWORD *)&v322[28] = v147;
            *(_WORD *)&v322[32] = 2101;
            *(_QWORD *)&v322[34] = v68;
            v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                   "ame hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            v221 = v142;
            goto LABEL_413;
          }
        }
        *v68 = __rev16(v145);
        v218 = v66;
        v219 = v144;
        memcpy(v68 + 1, v218, v146);
        v144 = v219;
        goto LABEL_412;
      }
    }
    v77 = v30;
    if (v14)
      v78 = mDNSLogCategory_Default;
    else
      v78 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        goto LABEL_485;
    }
    else
    {
      if (v14)
        v78 = mDNSLogCategory_Default_redacted;
      else
        v78 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        goto LABEL_485;
    }
    v79 = *(_DWORD *)(v8 + 192);
    v80 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
    v81 = *((unsigned __int16 *)a3 + 2);
    LODWORD(__tp.tv_sec) = 67110656;
    HIDWORD(__tp.tv_sec) = v79;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v80;
    HIWORD(__tp.tv_nsec) = 1024;
    v318 = v9;
    v319 = 1024;
    v320 = 0;
    v321 = 1024;
    *(_DWORD *)v322 = v77;
    *(_WORD *)&v322[4] = 1024;
    *(_DWORD *)&v322[6] = v32;
    *(_WORD *)&v322[10] = 1024;
    *(_DWORD *)&v322[12] = v81;
    v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash:"
          " %x, type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_307;
  }
  if (v42)
  {
    v43 = 0;
    v71 = 512;
    v72 = (char *)&unk_100164380;
  }
  else
  {
    v40 = (size_t)malloc_type_malloc(v40, 0xA172743EuLL);
    if (!v40)
      goto LABEL_488;
    v72 = (char *)v40;
    LODWORD(v40) = *v41;
    v43 = v72;
    v71 = v40;
  }
  if (!(_DWORD)v40)
  {
    v115 = v30;
    if (v14)
      v116 = mDNSLogCategory_Default;
    else
      v116 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v116 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
        goto LABEL_485;
    }
    else
    {
      if (v14)
        v116 = mDNSLogCategory_Default_redacted;
      else
        v116 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
        goto LABEL_485;
    }
    v159 = *(_DWORD *)(v8 + 192);
    v160 = *((unsigned __int16 *)a3 + 2);
    LODWORD(__tp.tv_sec) = 67110400;
    HIDWORD(__tp.tv_sec) = v159;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
    HIWORD(__tp.tv_nsec) = 1024;
    v318 = 0;
    v319 = 1024;
    v320 = v115;
    v321 = 1024;
    *(_DWORD *)v322 = v32;
    *(_WORD *)&v322[4] = 1024;
    *(_DWORD *)&v322[6] = v160;
    v82 = "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name has"
          "h: %x, type: %{mdns:rrtype}d, rdata: <none>";
    v137 = v116;
    v138 = 38;
    goto LABEL_458;
  }
  *(_DWORD *)&__n[1] = 0;
  __n[0] = 0;
  v106 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v72, v71, __n, (int *)&__n[1], v34, v35, v36);
  if (*(_DWORD *)&__n[1])
    goto LABEL_485;
  v107 = (const void *)v106;
  v302 = v32;
  v311 = v30;
  if (__n[0] >= 0x1FFuLL)
  {
    v109 = __n[0] + 2;
    v181 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
    if (!v181)
      goto LABEL_488;
    v110 = v181;
    v108 = v181;
  }
  else
  {
    v108 = 0;
    v109 = 512;
    v110 = word_100164580;
  }
  if (v14)
    v182 = mDNSLogCategory_Default;
  else
    v182 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || v182 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
      goto LABEL_441;
    v183 = *(_DWORD *)(v8 + 192);
    v184 = *((unsigned __int16 *)a3 + 2);
    v185 = __n[0];
    v186 = __n[0] + 2;
    if (v186 > v109)
    {
      v110 = 0;
      goto LABEL_440;
    }
LABEL_439:
    *v110 = __rev16(v184);
    v246 = v107;
    v247 = v183;
    memcpy(v110 + 1, v246, v185);
    v183 = v247;
    goto LABEL_440;
  }
  if (v14)
    v182 = mDNSLogCategory_Default_redacted;
  else
    v182 = mDNSLogCategory_mDNS;
  if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
  {
    v183 = *(_DWORD *)(v8 + 192);
    v184 = *((unsigned __int16 *)a3 + 2);
    v185 = __n[0];
    v186 = __n[0] + 2;
    if (v186 > v109)
    {
      v110 = 0;
LABEL_440:
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v183;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      v318 = 0;
      v319 = 1024;
      v320 = v311;
      v321 = 1024;
      *(_DWORD *)v322 = v302;
      *(_WORD *)&v322[4] = 1024;
      *(_DWORD *)&v322[6] = v184;
      *(_WORD *)&v322[10] = 2160;
      *(_QWORD *)&v322[12] = 1752392040;
      *(_WORD *)&v322[20] = 1040;
      *(_DWORD *)&v322[22] = v186;
      *(_WORD *)&v322[26] = 2101;
      *(_QWORD *)&v322[28] = v110;
      _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEFAULT, "[R%u->mDNSQ] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x40u);
      goto LABEL_441;
    }
    goto LABEL_439;
  }
LABEL_441:
  if (v108)
  {
    v248 = v108;
LABEL_484:
    free(v248);
  }
LABEL_485:
  if (v43)
    free(v43);
  append_reply(v8, *(_QWORD **)&__n[3]);
}

void connection_termination(uint64_t a1)
{
  _BYTE *v2;
  NSObject *v3;
  _QWORD *v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  void *v18;
  _DWORD *v19;
  NSObject *v20;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  BOOL v38;
  timespec buf;
  _BYTE v40[14];
  __int16 v41;
  __int16 *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;

  v2 = &unk_100164000;
  v3 = mDNSLogCategory_Default;
  v4 = &unk_100164000;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
    goto LABEL_9;
  }
  v3 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    v12 = *(_DWORD *)(a1 + 192);
    v13 = *(_DWORD *)(a1 + 180);
    LODWORD(buf.tv_sec) = 67109634;
    HIDWORD(buf.tv_sec) = v12;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v13;
    HIWORD(buf.tv_nsec) = 2082;
    *(_QWORD *)v40 = a1 + 248;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateConnection STOP PID[%d](%{public}s)", (uint8_t *)&buf, 0x18u);
  }
LABEL_10:
  v14 = all_requests;
  if (all_requests)
  {
    v15 = &all_requests;
    do
    {
      if (*(_QWORD *)(v14 + 24) == a1)
      {
        buf.tv_sec = 0;
        v16 = (_QWORD *)*v15;
        buf.tv_sec = (__darwin_time_t)v16;
        if ((_QWORD *)v16[3] == v16)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "connection_termination ERROR (*req)->primary == *req for %p %d", v7, v8, v9, v10, v11, (int)v16);
        if (v16[12])
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "connection_termination ERROR How can subordinate req %p %d have replies queued?", v7, v8, v9, v10, v11, (int)v16);
        abort_request((uint64_t)v16);
        *v15 = v16[2];
        request_state_forget(&buf);
      }
      else
      {
        v15 = (uint64_t *)(v14 + 16);
      }
      v14 = *v15;
    }
    while (*v15);
  }
  v17 = *(_QWORD *)(a1 + 168);
  if (v17)
  {
    v18 = &unk_100150000;
    v19 = (_DWORD *)&unk_100150000;
    while (1)
    {
      v20 = *((_QWORD *)v18 + 197);
      if (v2[2416] == 1 && v20 != v4[296])
        break;
      if (os_log_type_enabled(*((os_log_t *)v18 + 197), OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(_DWORD *)(a1 + 192);
        v24 = *(_DWORD *)(a1 + 240);
        v23 = *(_DWORD *)(a1 + 244);
        GetRRDisplayString_rdb((unsigned __int8 *)(*(_QWORD *)(v17 + 56) + 8), (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v17 + 56) + 48) + 4), word_100164580);
        v25 = *(_DWORD *)(a1 + 180);
        buf.tv_sec = 0;
        buf.tv_nsec = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, &buf);
        v26 = LODWORD(buf.tv_sec) - *(_DWORD *)(a1 + 196);
        LODWORD(buf.tv_sec) = 67110915;
        HIDWORD(buf.tv_sec) = v22;
        v2 = (_BYTE *)&unk_100164000;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v24;
        v4 = (_QWORD *)&unk_100164000;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v40 = v23;
        v18 = &unk_100150000;
        *(_WORD *)&v40[4] = 2160;
        *(_QWORD *)&v40[6] = 1752392040;
        v41 = 2085;
        v42 = word_100164580;
        v43 = 1024;
        v44 = v25;
        v19 = (_DWORD *)&unk_100150000;
        v45 = 2082;
        v46 = a1 + 248;
        v47 = 1024;
        v48 = v26;
        v27 = v20;
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceRegisterRecord(0x%X, %d, %{sensitive, mask.hash}s) STOP PID[%d](%{public}s) -- duration: %{mdns:time_duration}u", (uint8_t *)&buf, 0x3Eu);
      }
LABEL_32:
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8);
      v35 = *(_QWORD *)(v17 + 56);
      *(_QWORD *)(v35 + 112) = 0;
      if (*(_BYTE *)(v17 + 40))
      {
        *(_BYTE *)(v17 + 40) = 0;
        internal_stop_advertising_service(v35 + 8, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 180));
      }
      if (v19[389])
        LogMcastService(*(_QWORD *)(v17 + 56), a1, 0);
      if (*(_QWORD *)v17)
      {
        v36 = *(unsigned int *)(a1 + 244);
        if ((_DWORD)v36)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v36)
          {
            v37 = 1;
          }
          else
          {
            if (WiFiAwareInterfaceID)
              v38 = WiFiAwareInterfaceID == v36;
            else
              v38 = 0;
            v37 = v38;
          }
        }
        else
        {
          v37 = (*(_DWORD *)(a1 + 240) >> 20) & 1;
        }
        _mdns_powerlog_bonjour_event(12, v37, (char *)(a1 + 248), *(_QWORD *)v17);
      }
      mDNS_Deregister((unsigned int *)mDNSStorage, *(_QWORD *)(v17 + 56));
      free((void *)v17);
      v17 = *(_QWORD *)(a1 + 168);
      if (!v17)
        return;
    }
    v28 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_32;
    v30 = *(_DWORD *)(a1 + 192);
    v31 = *(_DWORD *)(a1 + 240);
    v32 = *(_DWORD *)(a1 + 244);
    GetRRDisplayString_rdb((unsigned __int8 *)(*(_QWORD *)(v17 + 56) + 8), (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v17 + 56) + 48) + 4), word_100164580);
    v33 = *(_DWORD *)(a1 + 180);
    buf.tv_sec = 0;
    buf.tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, &buf);
    v34 = LODWORD(buf.tv_sec) - *(_DWORD *)(a1 + 196);
    LODWORD(buf.tv_sec) = 67110915;
    HIDWORD(buf.tv_sec) = v30;
    v18 = &unk_100150000;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v31;
    v2 = (_BYTE *)&unk_100164000;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v40 = v32;
    v4 = (_QWORD *)&unk_100164000;
    *(_WORD *)&v40[4] = 2160;
    *(_QWORD *)&v40[6] = 1752392040;
    v41 = 2085;
    v42 = word_100164580;
    v43 = 1024;
    v44 = v33;
    v19 = &unk_100150000;
    v45 = 2082;
    v46 = a1 + 248;
    v47 = 1024;
    v48 = v34;
    v27 = v28;
    goto LABEL_31;
  }
}

void mDNS_AddSearchDomain(_BYTE *a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  NSObject *v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t *v11;
  char *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned __int16 v16;
  NSObject *v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  _BYTE *v26;
  __int16 v27;
  uint64_t v28;

  v4 = &SearchList;
  while (1)
  {
    v5 = *v4;
    if (!*v4)
      break;
    if (*(_QWORD *)(v5 + 272) == a2)
    {
      if (SameDomainNameBytes((_BYTE *)(v5 + 8), a1))
      {
        v6 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          v7 = a1;
          if (a1 == (_BYTE *)-256)
          {
LABEL_10:
            while (v7)
            {
              v8 = *v7;
              if (v8 > 0x3F)
                break;
              if (!*v7)
              {
                v9 = (unsigned __int16)((_WORD)v7 - (_WORD)a1 + 1);
                goto LABEL_17;
              }
              v7 += v8 + 1;
              if (a1 != (_BYTE *)-256)
                goto LABEL_9;
            }
          }
          else
          {
LABEL_9:
            if (v7 < a1 + 256)
              goto LABEL_10;
          }
          v9 = 257;
LABEL_17:
          v21 = 141558531;
          v22 = 1752392040;
          v23 = 1040;
          v24 = v9;
          v25 = 2101;
          v26 = a1;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "mDNS_AddSearchDomain: domain already in list -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v21, 0x1Cu);
        }
        v5 = *v4;
        v10 = *(_DWORD *)(*v4 + 264);
        if ((v10 & 1) != 0)
          *(_DWORD *)(v5 + 264) = v10 & 0xFFFFFFFE;
        *v4 = *(_QWORD *)v5;
        *(_QWORD *)v5 = 0;
        goto LABEL_21;
      }
      v4 = (uint64_t *)*v4;
    }
    else
    {
      v4 = (uint64_t *)*v4;
    }
  }
  do
  {
LABEL_21:
    v11 = v4;
    v4 = (uint64_t *)*v4;
  }
  while (v4);
  if (v5)
  {
    *v11 = v5;
  }
  else
  {
    v12 = (char *)malloc_type_calloc(1uLL, 0xEC0uLL, 0xF1748037uLL);
    if (!v12)
      __break(1u);
    *v11 = (uint64_t)v12;
    v13 = a1 + 256;
    v14 = a1;
    if (a1 == (_BYTE *)-256)
    {
LABEL_27:
      while (v14)
      {
        v15 = *v14;
        if (v15 > 0x3F)
          break;
        if (!*v14)
        {
          v16 = (_WORD)v14 - (_WORD)a1 + 1;
          if (v16 > 0x100u)
            break;
          memcpy(v12 + 8, a1, v16);
          goto LABEL_35;
        }
        v14 += v15 + 1;
        if (a1 != (_BYTE *)-256)
          goto LABEL_26;
      }
    }
    else
    {
LABEL_26:
      if (v14 < v13)
        goto LABEL_27;
    }
    v12[8] = 0;
LABEL_35:
    *(_QWORD *)*v11 = 0;
    *(_QWORD *)(*v11 + 272) = a2;
    v17 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      v18 = a1;
      if (a1 == (_BYTE *)-256)
      {
LABEL_38:
        while (v18)
        {
          v19 = *v18;
          if (v19 > 0x3F)
            break;
          if (!*v18)
          {
            v20 = (unsigned __int16)((_WORD)v18 - (_WORD)a1 + 1);
            goto LABEL_45;
          }
          v18 += v19 + 1;
          if (a1 != (_BYTE *)-256)
            goto LABEL_37;
        }
      }
      else
      {
LABEL_37:
        if (v18 < v13)
          goto LABEL_38;
      }
      v20 = 257;
LABEL_45:
      v21 = 141558787;
      v22 = 1752392040;
      v23 = 1040;
      v24 = v20;
      v25 = 2101;
      v26 = a1;
      v27 = 2048;
      v28 = a2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "mDNS_AddSearchDomain: new search domain added -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, InterfaceID %p", (uint8_t *)&v21, 0x26u);
    }
  }
}

void AnswerLocalQuestionWithLocalAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _BYTE *v7;
  _BOOL4 v8;
  int v9;
  _BOOL4 v10;
  unsigned int v11;
  unsigned int v12;
  void (*v13)(uint64_t, uint64_t, uint64_t, uint64_t);
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v18;
  const char *v20;
  char *v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  _BYTE *v27;
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  _BYTE *v35;

  v5 = *(_QWORD *)(a1 + 208);
  if (!v5)
  {
    v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        return;
    }
    else
    {
      v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        return;
    }
    v22 = (char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v22);
    v28 = 136446210;
    v29 = v22;
    v23 = "AnswerLocalQuestionWithLocalAuthRecord: ERROR!! CurrentQuestion NULL while answering with %{public}s";
    v24 = v16;
    v25 = 12;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v28, v25);
    return;
  }
  v7 = (_BYTE *)(a2 + 8);
  v8 = FollowCNAME(*(_QWORD *)(a1 + 208), (unsigned __int8 *)(a2 + 8), a3);
  v9 = *(unsigned __int8 *)(a2 + 8);
  if ((v9 & 0x3C) == 0)
  {
    v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        return;
      if ((_DWORD)a3)
        v20 = "Add";
      else
        v20 = "Rmv";
    }
    else
    {
      v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      if ((_DWORD)a3)
        v20 = "Add";
      else
        v20 = "Rmv";
    }
    v27 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v27);
    v28 = 136446979;
    v29 = v20;
    v30 = 1024;
    v31 = v9;
    v32 = 2160;
    v33 = 1752392040;
    v34 = 2085;
    v35 = v27;
    v23 = "AnswerLocalQuestionWithLocalAuthRecord: *NOT* delivering %{public}s event for local record type %X %{sensitive, mask.hash}s";
    v24 = v18;
    v25 = 38;
    goto LABEL_44;
  }
  v10 = v8;
  if ((_DWORD)a3)
    *(_BYTE *)(a2 + 193) = 1;
  v11 = *(_DWORD *)(a1 + 48);
  v12 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v12;
  mDNS_VerifyLockState("Drop Lock", 0, v11, v12, (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 906);
  v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 152);
  if (!v13)
    goto LABEL_38;
  if ((_DWORD)a3)
    v14 = 1;
  else
    v14 = -1;
  *(_DWORD *)(v5 + 228) += v14;
  if (*(_DWORD *)(a2 + 172) != 4
    || (*v7 & 0x32) == 0
    || (v15 = *(unsigned __int16 *)(a2 + 12), v15 > 0x1C)
    || ((1 << v15) & 0x10001022) == 0)
  {
    v13(a1, v5, a2 + 8, a3);
LABEL_38:
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 931);
    --*(_DWORD *)(a1 + 52);
    return;
  }
  if (!v10 || *(_BYTE *)(v5 + 635))
  {
    *(_DWORD *)(v5 + 212) = 0;
    *(_BYTE *)(v5 + 355) += v14;
    v13(a1, v5, a2 + 8, a3);
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 919);
  --*(_DWORD *)(a1 + 52);
  if (v10 && *(_QWORD *)(a1 + 208) == v5)
    AnswerQuestionByFollowingCNAME(a1, v5, a2 + 8);
}

void enum_result_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *reply;
  char *v16;
  int v17;
  void *v18;
  size_t v19;
  NSObject *v20;
  int v21;
  unsigned int v22;
  int v23;
  _DWORD v24[2];
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  char *v38;
  char __s[1009];

  if (*(_WORD *)(a3 + 4) == 12)
  {
    v7 = *(_QWORD *)(a2 + 176);
    bzero(__s, 0x3F1uLL);
    v8 = *(_QWORD *)(v7 + 112) + 704;
    if (a4 || v8 != a2)
    {
      ConvertDomainNameToCString_withescape((unsigned __int8 *)(*(_QWORD *)(a3 + 40) + 4), (unsigned __int8 *)__s);
      v9 = strlen(__s);
      reply = create_reply((char *)0x40, v9 + 13, v7, v10, v11, v12, v13, v14);
      v16 = reply;
      if (v8 == a2)
        v17 = 100663296;
      else
        v17 = 0x2000000;
      *((_QWORD *)reply + 6) = 0;
      if (!a4)
        v17 = 0;
      *((_DWORD *)reply + 11) = v17;
      v18 = reply + 56;
      v19 = strlen(__s);
      memcpy(v18, __s, v19 + 1);
      v20 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_14:
          v21 = *(_DWORD *)(v7 + 192);
          v22 = bswap32(*(unsigned __int16 *)(a2 + 340));
          v23 = *(unsigned __int8 *)(a2 + 376) + 1;
          v24[0] = 67110915;
          v24[1] = v21;
          v25 = 1024;
          v26 = HIWORD(v22);
          v27 = 2160;
          v28 = 1752392040;
          v29 = 1040;
          v30 = v23;
          v31 = 2101;
          v32 = a2 + 376;
          v33 = 1024;
          v34 = a4;
          v35 = 2160;
          v36 = 1752392040;
          v37 = 2085;
          v38 = __s;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[R%d->Q%d] DNSServiceEnumerateDomains(%{sensitive, mask.hash, mdnsresponder:domain_label}.*P) RESULT %{mdns:addrmv_upper}d: %{sensitive, mask.hash}s", (uint8_t *)v24, 0x42u);
        }
      }
      else
      {
        v20 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_14;
      }
      append_reply(v7, v16);
    }
  }
}

void SendDelayedUnicastResponse(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  __int16 *v23;
  unsigned __int16 v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned __int16 v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  __int16 v37;
  _QWORD *v38;
  uint64_t v39;
  void **v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  unsigned __int16 v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  __int16 v51;
  __int16 v52;
  _QWORD *v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  NSObject *v64;
  int v65;
  int v66;
  int v67;
  int v68;
  void **v69;
  uint64_t v71;
  __int16 *v73;
  void *v74;
  uint64_t *v75;
  uint64_t v76;
  uint8_t buf[4];
  int v78;
  __int16 v79;
  int v80;
  __int16 v81;
  int v82;
  __int16 v83;
  int v84;
  __int16 v85;
  uint64_t v86;
  char v87[8];
  unsigned __int8 v88[4];
  __int16 v89;
  __int16 v90;
  unsigned int v91;
  int v92;
  _BYTE *v93;
  __int16 *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  char v102;
  char v103;
  _BYTE *v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  _BYTE v117[25];
  __int16 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  _BYTE v122[256];
  __int16 v123;
  int v124;
  int v125;
  int v126;
  __int16 v127;

  v10 = a1 + 28960;
  v76 = 0;
  v11 = (_QWORD *)(a1 + 12656);
  do
    v11 = (_QWORD *)*v11;
  while (v11 && v11[444] != a3);
  v12 = *(_QWORD *)(a1 + 12616);
  if (v12)
  {
    v13 = &v76;
    while (1)
    {
      v14 = *(_QWORD *)(v12 + 208);
      if (v14 == -1
        || *(_DWORD *)(v12 + 232) == -1
        || *(_DWORD *)(v12 + 236) == -1
        && *(_DWORD *)(v12 + 240) == -1
        && *(_DWORD *)(v12 + 244) == -1
        && *(_DWORD *)(v12 + 248) == -1)
      {
        *(_BYTE *)(v12 + 195) = 0;
      }
      v15 = v14 != a3 || *(_BYTE *)(v12 + 195) == 0;
      if (v15)
        goto LABEL_30;
      if (*a2 == 6)
      {
        if (*(_DWORD *)(v12 + 236) == a2[1] && *(_DWORD *)(v12 + 240) == a2[2] && *(_DWORD *)(v12 + 244) == a2[3])
        {
          v16 = *(_DWORD *)(v12 + 248);
          v17 = a2[4];
LABEL_20:
          if (v16 == v17)
          {
            *(_QWORD *)(v12 + 208) = 0;
            *(_BYTE *)(v12 + 195) = 0;
            *(_QWORD *)(v12 + 232) = 0;
            *(_QWORD *)(v12 + 240) = 0;
            *(_DWORD *)(v12 + 248) = 0;
            if ((!v11 || mDNSPlatformValidRecordForInterface(v12, v11[444], a3, a4, a5, a6, a7, a8))
              && !*(_QWORD *)(v12 + 256)
              && v13 != (uint64_t *)(v12 + 256))
            {
              *(_QWORD *)(v12 + 264) = -1;
              *v13 = v12;
              v13 = (uint64_t *)(v12 + 256);
            }
          }
        }
      }
      else if (*a2 == 4)
      {
        v16 = *(_DWORD *)(v12 + 232);
        v17 = a2[1];
        goto LABEL_20;
      }
LABEL_30:
      v12 = *(_QWORD *)v12;
      if (!v12)
      {
        v18 = v76;
        goto LABEL_33;
      }
    }
  }
  v18 = 0;
  v13 = &v76;
LABEL_33:
  v75 = v13;
  v71 = a3;
  v19 = a3;
  v20 = a1;
  AddAdditionalsToResponseList(a1, v18, &v75, v19, a5, a6, a7, a8);
  v21 = v76;
  if (!v76)
    return;
  v22 = a1 + 28972;
  v23 = (__int16 *)(v10 + 6);
  v73 = (__int16 *)(v10 + 10);
  do
  {
    v24 = 0;
    v74 = 0;
    *(_DWORD *)v10 = 8650752;
    v25 = v22;
    *(_QWORD *)(v10 + 4) = 0;
    do
    {
      if (!*(_QWORD *)(v21 + 264))
        goto LABEL_63;
      if ((*(_BYTE *)(v21 + 8) & 0x32) != 0)
        *(_WORD *)(v21 + 14) |= 0x8000u;
      v28 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12616), v21, (uint64_t **)&v74);
      if (v28)
        v29 = v24 + 1;
      else
        v29 = v24;
      if (*v23 || *(_WORD *)(v10 + 8) || *v73)
        v30 = 1440;
      else
        v30 = 8940;
      v31 = v22 + v30;
      v32 = v29;
      v15 = v29 == 0;
      v33 = -11;
      if (v15)
        v33 = 0;
      v34 = PutResourceRecordTTLWithLimit(v10, v25, (_WORD *)(v10 + 6), v21 + 8, *(unsigned int *)(v21 + 16), v31 + v33 - 14 * v32, v26, v27);
      v35 = v34;
      if (!v28)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
        if (v34)
          goto LABEL_57;
        goto LABEL_55;
      }
      if (!v34)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_55:
        if (!*v23)
        {
          v35 = v25;
          goto LABEL_57;
        }
        v21 = v76;
        if (!v76)
        {
          v40 = (void **)v74;
          goto LABEL_91;
        }
        while (1)
        {
LABEL_63:
          if (*(_QWORD *)(v21 + 264))
          {
            v35 = v25;
            goto LABEL_90;
          }
          if ((*(_BYTE *)(v21 + 8) & 0x32) != 0)
            *(_WORD *)(v21 + 14) |= 0x8000u;
          v44 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12616), v21, (uint64_t **)&v74);
          if (v44)
            v45 = v24 + 1;
          else
            v45 = v24;
          if (*v23 || *(_WORD *)(v10 + 8) || *v73)
            v41 = 1440;
          else
            v41 = 8940;
          v46 = v22 + v41;
          v47 = v45;
          v15 = v45 == 0;
          v48 = -11;
          if (v15)
            v48 = 0;
          v49 = PutResourceRecordTTLWithLimit(v10, v25, v73, v21 + 8, *(unsigned int *)(v21 + 16), v46 + v48 - 14 * v47, v42, v43);
          v35 = v49;
          if (v44)
          {
            if (!v49)
            {
              *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_84:
              if ((*(_BYTE *)(v21 + 8) & 0x32) != 0)
                *(_QWORD *)(v21 + 208) = -1;
              v35 = v25;
              goto LABEL_87;
            }
            v50 = *(_QWORD *)(v21 + 40);
            v51 = *v23;
            v52 = *v73;
            v53 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v53)
              goto LABEL_120;
            ++v24;
            *((_WORD *)v44 + 4) = v51 + v52 - 1;
            v53[1] = v44;
            v53[2] = v50;
            *v53 = v74;
            v74 = v53;
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            v20 = a1;
            v22 = a1 + 28972;
          }
          else
          {
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            if (!v49)
              goto LABEL_84;
          }
          if (!*v23)
          {
            v25 = v35;
            goto LABEL_84;
          }
          *(_BYTE *)(v21 + 192) = 1;
LABEL_87:
          v76 = *(_QWORD *)(v21 + 256);
          v54 = v76;
          *(_QWORD *)(v21 + 264) = 0;
          *(_QWORD *)(v21 + 272) = 0;
          *(_QWORD *)(v21 + 256) = 0;
          v25 = v35;
          v21 = v54;
          if (!v54)
            goto LABEL_90;
        }
      }
      v36 = *(_QWORD *)(v21 + 40);
      v37 = *v23;
      v38 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
      if (!v38)
LABEL_120:
        __break(1u);
      ++v24;
      *((_WORD *)v28 + 4) = v37 - 1;
      v38[1] = v28;
      v38[2] = v36;
      *v38 = v74;
      v74 = v38;
      *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_57:
      v76 = *(_QWORD *)(v21 + 256);
      v39 = v76;
      *(_QWORD *)(v21 + 264) = 0;
      *(_QWORD *)(v21 + 272) = 0;
      *(_QWORD *)(v21 + 256) = 0;
      *(_BYTE *)(v21 + 192) = 1;
      v21 = v39;
      v25 = v35;
    }
    while (v39);
LABEL_90:
    v40 = (void **)v74;
    v25 = v35;
    if (*v23)
    {
LABEL_91:
      if (v40)
      {
        bzero(v87, 0x498uLL);
        v88[0] = 32;
        v89 = 41;
        v123 = 264;
        v93 = v122;
        v94 = &v123;
        v102 = 0;
        v103 = 0;
        v95 = 0u;
        v96 = 0u;
        v97 = 0u;
        v98 = 0u;
        v99 = 0u;
        v100 = 0u;
        v101 = 0;
        v104 = v122;
        v118 = 0;
        v120 = 0;
        v121 = 0;
        v119 = 0;
        v122[0] = 0;
        v105 = 0u;
        v106 = 0u;
        v107 = 0u;
        v108 = 0u;
        v109 = 0u;
        v110 = 0u;
        v111 = 0u;
        v112 = 0u;
        v113 = 0u;
        v114 = 0u;
        v115 = 0u;
        v116 = 0u;
        memset(v117, 0, sizeof(v117));
        v90 = 1440;
        v91 = 4500;
        v92 = 1572888;
        v55 = (int *)v40[1];
        v126 = v55[1];
        v127 = *((_WORD *)v55 + 4);
        v125 = *v55;
        v124 = 720362;
        v74 = *v40;
        free(v40);
        if (*v23 || *(_WORD *)(v10 + 8) || *v73)
          v58 = 1440;
        else
          v58 = 8940;
        v59 = (char *)PutResourceRecordTTLWithLimit(v10, v25, v73, (uint64_t)v88, v91, v22 + v58, v56, v57);
        if (v59 && v74)
        {
          if (*v23 || *(_WORD *)(v10 + 8) || *v73)
            v63 = 1440;
          else
            v63 = 8940;
          v59 = AddTSRROptsToMessage(&v74, v10, (_WORD *)(v25 + 9), v59, v22 + v63, v60, v61, v62);
        }
        if (!v59)
        {
          v64 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
              goto LABEL_109;
          }
          else
          {
            v64 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            {
LABEL_109:
              v65 = *(unsigned __int16 *)(v10 + 4);
              v66 = *(unsigned __int16 *)(v10 + 6);
              v67 = *(unsigned __int16 *)(v10 + 8);
              v68 = *(unsigned __int16 *)(v10 + 10);
              GetRRDisplayString_rdb(v88, (unsigned __int16 *)v94 + 2, (_BYTE *)(a1 + 47032));
              *(_DWORD *)buf = 67110146;
              v78 = v65;
              v79 = 1024;
              v80 = v66;
              v20 = a1;
              v81 = 1024;
              v82 = v67;
              v83 = 1024;
              v84 = v68;
              v85 = 2080;
              v86 = a1 + 47032;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "SendDelayedUnicastResponse: How did we fail to have space for OPT record (%d/%d/%d/%d) %s", buf, 0x24u);
            }
          }
          v59 = (char *)v25;
        }
        v25 = (unint64_t)v59;
      }
      mDNSSendDNSMessage(v20, v10, v25, v71, 0, 0, a2, 0xE914u, 0, 0);
      v40 = (void **)v74;
    }
    if (v40)
    {
      do
      {
        v69 = (void **)*v40;
        free(v40);
        v40 = v69;
      }
      while (v69);
    }
    v21 = v76;
    v22 = a1 + 28972;
  }
  while (v76);
}

uint64_t mDNS_Reconfirm_internal(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v8;
  uint32_t v9;
  uint32_t v10;
  unsigned int v11;

  v4 = result;
  if (a3 <= 0x1388)
    v5 = 5000;
  else
    v5 = a3;
  if (v5 >= 0x10000000)
    v6 = 0x10000000;
  else
    v6 = v5;
  if (*(_BYTE *)(a2 + 109))
    v7 = dword_100158E08 + 939524096;
  else
    v7 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(result + 64);
  if (v7 - v8 > (int)(4 * v6 / 3))
  {
    v9 = *(_DWORD *)(result + 128);
    if (!v9)
    {
      do
        v10 = arc4random() & 0x3FFFFFFF;
      while (v10 > 0x38000000);
      v9 = v10 + 1;
      *(_DWORD *)(v4 + 128) = v10 + 1;
      v8 = *(_DWORD *)(v4 + 64);
    }
    v11 = v9 % (v6 / 3 + 1) + v6;
    *(_DWORD *)(a2 + 80) = -3 * v11 + v8;
    *(_DWORD *)(a2 + 16) = (4 * v11 + 999) / 0x3E8;
    return SetNextCacheCheckTimeForRecord(v4, a2);
  }
  return result;
}

void *_mdns_audit_token_copy_description(uint64_t a1, int a2)
{
  _QWORD *v4;
  _QWORD *v5;
  __int128 v6;
  uid_t v7;
  __int128 v8;
  uid_t v9;
  __int128 v10;
  gid_t v11;
  __int128 v12;
  uid_t v13;
  __int128 v14;
  gid_t v15;
  __int128 v16;
  pid_t v17;
  __int128 v18;
  int v19;
  __int128 v20;
  au_asid_t v21;
  void *v22;
  audit_token_t atoken;

  v4 = (_QWORD *)mdns_string_builder_create();
  if (!v4)
    return 0;
  v5 = v4;
  if (a2
    && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1))
  {
    goto LABEL_5;
  }
  v6 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v6;
  v7 = audit_token_to_auid(&atoken);
  v8 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v8;
  v9 = audit_token_to_euid(&atoken);
  v10 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v10;
  v11 = audit_token_to_egid(&atoken);
  v12 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v12;
  v13 = audit_token_to_ruid(&atoken);
  v14 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v14;
  v15 = audit_token_to_rgid(&atoken);
  v16 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v16;
  v17 = audit_token_to_pid(&atoken);
  v18 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v18;
  v19 = audit_token_to_pidversion(&atoken);
  v20 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v20;
  v21 = audit_token_to_asid(&atoken);
  if (mdns_string_builder_append_formatted(v5, "audit user id: %u, effective user id: %u, effective group id: %u, real user id: %u, real group id: %u, pid: %d, pid version: %d, audit session id: %d", v7, v9, v11, v13, v15, v17, v19, v21))LABEL_5:v22 = 0;
  else
    v22 = mdns_string_builder_copy_string((uint64_t)v5);
  os_release(v5);
  return v22;
}

uint64_t mdns_audit_token_create(_OWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _UNKNOWN **v4;
  void (*v5)(uint64_t);
  __int128 v6;

  v2 = _os_object_alloc(OS_mdns_audit_token, 56);
  v3 = v2;
  if (v2)
  {
    v4 = &_mdns_audit_token_kind;
    *(_QWORD *)(v2 + 16) = &_mdns_audit_token_kind;
    do
    {
      v5 = (void (*)(uint64_t))v4[2];
      if (v5)
        v5(v3);
      v4 = (_UNKNOWN **)*v4;
    }
    while (v4);
    v6 = a1[1];
    *(_OWORD *)(v3 + 24) = *a1;
    *(_OWORD *)(v3 + 40) = v6;
  }
  return v3;
}

void *_mdns_message_builder_copy_description(_QWORD *a1, int a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;

  v4 = (_QWORD *)mdns_string_builder_create();
  if (!v4)
    return 0;
  v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
    v6 = 0;
  else
    v6 = mdns_string_builder_copy_string((uint64_t)v5);
  os_release(v5);
  return v6;
}

void _mdns_message_builder_forget_resources(_QWORD *a1)
{
  void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
}

uint64_t __mdns_message_builder_write_message_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  size_t v12;
  _QWORD *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  _WORD __src[2];
  unsigned int v25;
  __int16 v26;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v6 = *(_QWORD *)(v4 + 32);
  v7 = v5[5];
  if (v5[4] - v7 >= v6)
    v8 = *(_QWORD *)(v4 + 32);
  else
    v8 = v5[4] - v7;
  if (v8)
  {
    memcpy((void *)(v5[3] + v7), *(const void **)(v4 + 24), v8);
    v5[5] += v8;
  }
  v9 = v5[6];
  v10 = __CFADD__(v9, v6);
  v11 = v9 + v6;
  if (v10)
    v11 = -1;
  v5[6] = v11;
  __src[0] = bswap32(*(unsigned __int16 *)(a2 + 52)) >> 16;
  __src[1] = bswap32(*(unsigned __int16 *)(a2 + 54)) >> 16;
  v25 = bswap32(*(_DWORD *)(a2 + 40));
  v12 = *(unsigned __int16 *)(a2 + 56);
  v26 = __rev16(v12);
  v13 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v14 = v13[5];
  if ((unint64_t)(v13[4] - v14) >= 0xA)
    v15 = 10;
  else
    v15 = v13[4] - v14;
  if (v15)
  {
    memcpy((void *)(v13[3] + v14), __src, v15);
    v13[5] += v15;
  }
  v16 = v13[6];
  v10 = __CFADD__(v16, 10);
  v17 = v16 + 10;
  if (v10)
    v17 = -1;
  v13[6] = v17;
  v18 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v19 = v18[5];
  if (v18[4] - v19 >= v12)
    v20 = v12;
  else
    v20 = v18[4] - v19;
  if (v20)
  {
    memcpy((void *)(v18[3] + v19), *(const void **)(a2 + 32), v20);
    v18[5] += v20;
  }
  v21 = v18[6];
  v10 = __CFADD__(v21, v12);
  v22 = v21 + v12;
  if (v10)
    v22 = -1;
  v18[6] = v22;
  return 1;
}

uint64_t _dnssec_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void _dnssec_obj_context_finalize(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = *(_QWORD **)(a1 + 56);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v3 = *(_QWORD **)(a1 + 64);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

void *_mdns_domain_name_copy_description(_QWORD *a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  const char *v8;
  void *v9;
  _OWORD v11[4];

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
    goto LABEL_9;
  memset(v11, 0, sizeof(v11));
  v8 = (const char *)a1[5];
  if (a3)
  {
    if ((int)DNSMessagePrintObfuscatedString((uint64_t)v11, v8) < 0)
      v8 = "REDACTED";
    else
      v8 = (const char *)v11;
  }
  if (mdns_string_builder_append_formatted(v7, "%s", v8))
LABEL_9:
    v9 = 0;
  else
    v9 = mdns_string_builder_copy_string((uint64_t)v7);
  os_release(v7);
  return v9;
}

uint64_t _mdns_domain_name_equal(uint64_t a1, uint64_t a2)
{
  size_t v2;

  if (a1 == a2)
    return 1;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2 != *(_QWORD *)(a2 + 32))
    return 0;
  if (*(_BYTE *)(a1 + 61) && *(_BYTE *)(a2 + 61))
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2) == 0;
  return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), *(unsigned __int8 **)(a2 + 24)) != 0;
}

void _mdns_domain_name_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

uint64_t _mdns_domain_name_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_domain_name_equal(a1, a2);
}

uint64_t _mdns_domain_name_cf_callback_hash(uint64_t a1)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 v6;
  int v7;
  unsigned __int8 v8;

  v2 = (os_unfair_lock_s *)(a1 + 52);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
  if (!*(_BYTE *)(a1 + 60))
  {
    v3 = -2128831035;
    v4 = *(_QWORD *)(a1 + 32);
    if (v4)
    {
      v5 = *(unsigned __int8 **)(a1 + 24);
      do
      {
        v7 = *v5++;
        v6 = v7;
        v8 = v7 + 32;
        if ((v7 - 65) < 0x1A)
          v6 = v8;
        v3 = 16777619 * (v6 ^ v3);
        --v4;
      }
      while (v4);
    }
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 60) = 1;
  }
  os_unfair_lock_unlock(v2);
  return *(unsigned int *)(a1 + 56);
}

_QWORD *mdns_domain_name_create(char *a1, _DWORD *a2)
{
  _QWORD *result;
  int v4;
  _OWORD v5[16];

  memset(v5, 0, sizeof(v5));
  v4 = DomainNameFromString(v5, a1);
  if (v4)
  {
    result = 0;
    if (!a2)
      return result;
  }
  else
  {
    result = mdns_domain_name_create_with_labels(v5, &v4);
    if (!a2)
      return result;
  }
  *a2 = v4;
  return result;
}

_QWORD *mdns_domain_name_create_with_labels(_BYTE *a1, int *a2)
{
  _QWORD *v4;
  int v5;
  _QWORD *v6;
  int v8;

  v8 = 0;
  if (!*a1)
  {
    if (_mdns_domain_name_get_root_s_once != -1)
      dispatch_once(&_mdns_domain_name_get_root_s_once, &__block_literal_global);
    v4 = (_QWORD *)_mdns_domain_name_get_root_s_root;
    if (_mdns_domain_name_get_root_s_root)
      goto LABEL_7;
  }
  v4 = _mdns_domain_name_create(a1, &v8);
  v5 = v8;
  if (v8)
  {
    v6 = 0;
  }
  else
  {
LABEL_7:
    v5 = 0;
    v6 = v4;
    v8 = 0;
    v4 = 0;
  }
  if (a2)
    *a2 = v5;
  if (v4)
    os_release(v4);
  return v6;
}

_QWORD *_mdns_domain_name_create(_BYTE *a1, int *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _UNKNOWN **v6;
  void (*v7)(_QWORD *);
  int v8;
  char *v9;
  _BYTE *v10;
  unsigned int v11;
  int v12;
  _BYTE *v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  char __s1[1009];

  v4 = (_QWORD *)_os_object_alloc(OS_mdns_domain_name, 64);
  v5 = v4;
  if (v4)
  {
    v6 = &_mdns_domain_name_kind;
    v4[2] = &_mdns_domain_name_kind;
    do
    {
      v7 = (void (*)(_QWORD *))v6[2];
      if (v7)
        v7(v5);
      v6 = (_UNKNOWN **)*v6;
    }
    while (v6);
    DomainNameDupEx(a1, v5 + 3, v5 + 4);
    bzero(__s1, 0x3F1uLL);
    v8 = DomainNameToString((unsigned __int8 *)v5[3], 0, (unsigned __int8 *)__s1, 0);
    if (v8)
    {
      v19 = v8;
      v4 = v5;
      v5 = 0;
    }
    else
    {
      v9 = strdup(__s1);
      if (!v9)
        __break(1u);
      v5[5] = v9;
      *((_DWORD *)v5 + 13) = 0;
      v10 = (_BYTE *)v5[3];
      v11 = *v10;
      if (*v10)
      {
        v12 = 0;
        v13 = (_BYTE *)v5[3];
        while (v11 <= 0x3F)
        {
          v13 += v11 + 1;
          if (v13 - v10 > 255)
            break;
          ++v12;
          v11 = *v13;
          if (!*v13)
            goto LABEL_15;
        }
        v12 = -1;
      }
      else
      {
        v12 = 0;
      }
LABEL_15:
      *((_DWORD *)v5 + 12) = v12;
      v14 = v5[4];
      if (v14)
      {
        if (*v10 - 65 >= 0x1A)
        {
          v16 = 1;
          while (v14 != v16)
          {
            v17 = v10[v16++] - 65;
            if (v17 <= 0x19)
            {
              v18 = v16 - 1;
              goto LABEL_24;
            }
          }
          v18 = v5[4];
LABEL_24:
          v15 = v18 >= v14;
        }
        else
        {
          v15 = 0;
        }
      }
      else
      {
        v15 = 1;
      }
      v4 = 0;
      v19 = 0;
      *((_BYTE *)v5 + 61) = v15;
    }
  }
  else
  {
    v19 = -6728;
  }
  if (a2)
    *a2 = v19;
  if (v4)
    os_release(v4);
  return v5;
}

void ___mdns_domain_name_get_root_block_invoke(id a1)
{
  _QWORD *v1;
  char v2;

  v2 = 0;
  v1 = _mdns_domain_name_create(&v2, 0);
  *((_DWORD *)v1 + 2) = 0x7FFFFFFF;
  *((_DWORD *)v1 + 3) = 0x7FFFFFFF;
  _mdns_domain_name_get_root_s_root = (uint64_t)v1;
}

void mdns_system_remove_network_policy(void *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  if (objc_opt_class(NEPolicySession))
  {
    objc_msgSend(a1, "removeAllPolicies");
    objc_msgSend(a1, "apply");

  }
  objc_autoreleasePoolPop(v2);
}

uint64_t mdns_system_is_signed_result_uuid_valid(uint64_t a1)
{
  void *v2;
  id v3;
  uint64_t v4;
  id v5;
  NSObject *v6;
  NSObject *v7;
  id v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  id v13;

  v2 = objc_autoreleasePoolPush();
  if (_os_feature_enabled_impl("mDNSResponder", "revoke_media_sessions"))
  {
    if (objc_opt_class(DASession))
    {
      v3 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", a1);
      v9 = 0;
      v4 = (uint64_t)+[DASession networkingAllowedWithUUID:error:](DASession, "networkingAllowedWithUUID:error:", v3, &v9);
      v5 = v9;

      if (mdns_system_log_s_once != -1)
        dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6694);
      v6 = (id)mdns_system_log_s_log;
      v7 = v6;
      if (v5)
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109378;
          v11 = v4;
          v12 = 2112;
          v13 = v5;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed networkingAllowedWithUUID: -- allowed: %{BOOL}d, error: %@", buf, 0x12u);
        }
        v4 = 0;
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109120;
        v11 = v4;
        _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "networkingAllowedWithUUID: -- allowed: %{BOOL}d", buf, 8u);
      }

    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v4 = 1;
  }
  objc_autoreleasePoolPop(v2);
  return v4;
}

uint64_t internal_start_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  NSObject *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  int v17;
  __int16 v18;
  _BYTE *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  int64_t v26;
  uint64_t result;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  int v38;
  _OWORD v39[16];

  memset(v39, 0, sizeof(v39));
  DomainnameToLower(*(_BYTE **)(a1 + 32), (uint64_t)v39);
  v6 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      goto LABEL_28;
    v11 = *(_QWORD *)(a1 + 32);
    if (v11)
    {
      v14 = *(_BYTE **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_16:
        while (v14)
        {
          v15 = *v14;
          if (v15 > 0x3F)
            break;
          if (!*v14)
          {
            v16 = (unsigned __int16)((_WORD)v14 - v11 + 1);
            goto LABEL_27;
          }
          v14 += v15 + 1;
          if (v11 != -256)
            goto LABEL_15;
        }
      }
      else
      {
LABEL_15:
        if ((unint64_t)v14 < v11 + 256)
          goto LABEL_16;
      }
      v16 = 257;
    }
    else
    {
      v16 = 0;
    }
  }
  else
  {
    v6 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_28;
    v11 = *(_QWORD *)(a1 + 32);
    if (v11)
    {
      v12 = *(_BYTE **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_7:
        while (v12)
        {
          v13 = *v12;
          if (v13 > 0x3F)
            break;
          if (!*v12)
          {
            v16 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_27;
          }
          v12 += v13 + 1;
          if (v11 != -256)
            goto LABEL_6;
        }
      }
      else
      {
LABEL_6:
        if ((unint64_t)v12 < v11 + 256)
          goto LABEL_7;
      }
      v16 = 257;
    }
    else
    {
      v16 = 0;
    }
  }
LABEL_27:
  v17 = *(unsigned __int16 *)(a1 + 4);
  v31 = 141558787;
  v32 = 1752392040;
  v33 = 1040;
  v34 = v16;
  v35 = 2101;
  v36 = v11;
  v37 = 1024;
  v38 = v17;
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "internal_start_advertising_service - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d", (uint8_t *)&v31, 0x22u);
LABEL_28:
  v18 = *(_WORD *)(a1 + 4);
  v19 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v39, v7, v8, v9, v10);
  if (v19)
  {
    *v19 = HIBYTE(v18);
    v19[1] = v18;
    v19[2] = 1;
    v24 = v19 + 3;
  }
  else
  {
    v24 = 0;
  }
  v31 = 0;
  v25 = putRData((unint64_t)&compression_base_msg, v24, (unint64_t)&compression_base_msg + &unk_1000022F8, a1, v20, v21, v22, v23);
  v26 = v25 - v24;
  PrintHelper((uint64_t)"internal_start_advertising_service", (uint64_t)&unk_1001499E7, (unsigned __int16)((_WORD)v24 - (unsigned __int16)&unk_1001499E7), (uint64_t)v24, (unsigned __int16)((_WORD)v25 - (_WORD)v24));
  result = xD2DMapToTransportType(*(_QWORD *)(a1 + 24), a2, &v31);
  if ((_DWORD)result == 4)
  {
    v28 = 0;
    v29 = v31;
    do
    {
      if (v29 != (_DWORD)v28 && &_D2DStartAdvertisingPairOnTransport)
      {
        if ((v28 & 0x7FFFFFFE) == 2)
          _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLAdvertise"), (unsigned __int8 *)v39, *(unsigned __int16 *)(a1 + 4), a3);
        result = D2DStartAdvertisingPairOnTransport(&unk_1001499E7, v24 - (char *)&unk_1001499E7, v24, v26, v28);
      }
      v28 = (v28 + 1);
    }
    while ((_DWORD)v28 != 4);
  }
  else if (&_D2DStartAdvertisingPairOnTransport)
  {
    v30 = result;
    if ((result & 6) == 2)
      _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLAdvertise"), (unsigned __int8 *)v39, *(unsigned __int16 *)(a1 + 4), a3);
    return D2DStartAdvertisingPairOnTransport(&unk_1001499E7, v24 - (char *)&unk_1001499E7, v24, v26, v30);
  }
  return result;
}

_BYTE *DomainnameToLower(_BYTE *result, uint64_t a2)
{
  int v2;
  _BYTE *v3;
  _BYTE *v4;
  char v5;
  int v6;
  char v7;

  v2 = *result;
  if (*result)
  {
    v3 = result;
    do
    {
      *(_BYTE *)(a2 + v3 - result) = v2;
      v4 = &(v3++)[a2 - (_QWORD)result + 1];
      do
      {
        v6 = *v3++;
        v5 = v6;
        v7 = v6 + 32;
        if ((v6 - 65) < 0x1A)
          v5 = v7;
        *v4++ = v5;
        --v2;
      }
      while ((_BYTE)v2);
      v2 = *v3;
    }
    while (*v3);
  }
  else
  {
    v3 = result;
  }
  *(_BYTE *)(a2 + v3 - result) = 0;
  return result;
}

void PrintHelper(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  NSObject *v10;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;

  if (mDNS_LoggingEnabled != 1)
    return;
  v10 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State)
  {
    v10 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_11;
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
  {
LABEL_10:
    v14 = 136447235;
    v15 = a1;
    v16 = 1024;
    v17 = a3;
    v18 = 2160;
    v19 = 1752392040;
    v20 = 1040;
    v21 = a3;
    v22 = 2101;
    v23 = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%{public}s: LHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P", (uint8_t *)&v14, 0x2Cu);
  }
LABEL_11:
  if (!a4)
    return;
  v13 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
      return;
  }
  else
  {
    v13 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
      return;
  }
  v14 = 136447235;
  v15 = a1;
  v16 = 1024;
  v17 = a5;
  v18 = 2160;
  v19 = 1752392040;
  v20 = 1040;
  v21 = a5;
  v22 = 2101;
  v23 = a4;
  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%{public}s: RHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P", (uint8_t *)&v14, 0x2Cu);
}

uint64_t xD2DMapToTransportType(uint64_t a1, int a2, _DWORD *a3)
{
  NSObject *v3;
  NSObject *v6;
  NSObject *v8;
  _BOOL4 v10;
  uint64_t result;
  const char *v12;
  NSObject *v14;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v20;
  char v21;
  NSObject *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;
  uint64_t v26;

  *a3 = 1;
  if ((~a2 & 0x120000) == 0)
  {
    v3 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        return 4;
      LOWORD(v25) = 0;
    }
    else
    {
      v3 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        return 4;
      LOWORD(v25) = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: call all active plugins since both kDNSServiceFlagsIncludeP2P and kDNSServiceFlagsIncludeAWDL are set", (uint8_t *)&v25, 2u);
    return 4;
  }
  if ((a2 & 0x20000) != 0)
  {
    v8 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      v10 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v10)
        return result;
      LOWORD(v25) = 0;
      v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }
    else
    {
      v8 = mDNSLogCategory_D2D_redacted;
      v16 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
      v17 = v16;
      result = 0;
      if (!v17)
        return result;
      LOWORD(v25) = 0;
      v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }
LABEL_37:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v25, 2u);
    return 0;
  }
  if ((a2 & 0x100000) != 0)
  {
    v14 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_41:
        *a3 = 0;
        return 4;
      }
      LOWORD(v25) = 0;
    }
    else
    {
      v14 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_41;
      LOWORD(v25) = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: call AWDL and NAN plugins since kDNSServiceFlagsIncludeAWDL is set", (uint8_t *)&v25, 2u);
    goto LABEL_41;
  }
  if (a1 != -3)
  {
    if (AWDLInterfaceID && AWDLInterfaceID == a1)
    {
      v6 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 134217984;
          v26 = a1;
          goto LABEL_62;
        }
      }
      else
      {
        v6 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 134217984;
          v26 = a1;
LABEL_62:
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: returning D2DAWDLTransport for interface index %p", (uint8_t *)&v25, 0xCu);
        }
      }
      return 2;
    }
    v21 = gSensitiveLoggingEnabled;
    v22 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State)
      v21 = 0;
    if (WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1)
    {
      if ((v21 & 1) != 0)
      {
        v22 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 134217984;
          v26 = a1;
LABEL_69:
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: returning D2DWiFiAwareTransport for interface index %p", (uint8_t *)&v25, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 134217984;
        v26 = a1;
        goto LABEL_69;
      }
      return 3;
    }
    if ((v21 & 1) != 0)
    {
      v22 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 134217984;
        v26 = a1;
LABEL_73:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: no matching plugins for interface index %p", (uint8_t *)&v25, 0xCu);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      v25 = 134217984;
      v26 = a1;
      goto LABEL_73;
    }
    return 1;
  }
  v8 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    v20 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v20)
      return result;
    LOWORD(v25) = 0;
    v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }
  v8 = mDNSLogCategory_D2D_redacted;
  v23 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
  v24 = v23;
  result = 0;
  if (v24)
  {
    LOWORD(v25) = 0;
    v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }
  return result;
}

void internal_stop_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  NSObject *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  _BYTE *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  __int16 *v27;
  _OWORD v28[16];

  memset(v28, 0, sizeof(v28));
  DomainnameToLower(*(_BYTE **)(a1 + 32), (uint64_t)v28);
  v6 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      goto LABEL_7;
  }
  else
  {
    v6 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_7;
  }
  GetRRDisplayString_rdb((unsigned __int8 *)a1, (unsigned __int16 *)(*(_QWORD *)(a1 + 40) + 4), word_100164580);
  v24 = 141558275;
  v25 = 1752392040;
  v26 = 2085;
  v27 = word_100164580;
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "internal_stop_advertising_service: %{sensitive, mask.hash}s", (uint8_t *)&v24, 0x16u);
LABEL_7:
  v11 = *(_WORD *)(a1 + 4);
  v12 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v28, v7, v8, v9, v10);
  if (v12)
  {
    *v12 = HIBYTE(v11);
    v12[1] = v11;
    v12[2] = 1;
    v17 = v12 + 3;
  }
  else
  {
    v17 = 0;
  }
  v24 = 0;
  v18 = putRData((unint64_t)&compression_base_msg, v17, (unint64_t)&compression_base_msg + &unk_1000022F8, a1, v13, v14, v15, v16);
  v19 = v18 - v17;
  PrintHelper((uint64_t)"internal_stop_advertising_service", (uint64_t)&unk_1001499E7, (unsigned __int16)((_WORD)v17 - (unsigned __int16)&unk_1001499E7), (uint64_t)v17, (unsigned __int16)((_WORD)v18 - (_WORD)v17));
  v20 = xD2DMapToTransportType(*(_QWORD *)(a1 + 24), a2, &v24);
  if ((_DWORD)v20 == 4)
  {
    v21 = 0;
    v22 = v24;
    do
    {
      if (v22 != (_DWORD)v21 && &_D2DStopAdvertisingPairOnTransport)
      {
        D2DStopAdvertisingPairOnTransport(&unk_1001499E7, v17 - (char *)&unk_1001499E7, v17, v19, v21);
        if ((v21 & 0x7FFFFFFE) == 2)
          _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLAdvertise"), (unsigned __int8 *)v28, *(unsigned __int16 *)(a1 + 4), a3);
      }
      v21 = (v21 + 1);
    }
    while ((_DWORD)v21 != 4);
  }
  else if (&_D2DStopAdvertisingPairOnTransport)
  {
    v23 = v20;
    D2DStopAdvertisingPairOnTransport(&unk_1001499E7, v17 - (char *)&unk_1001499E7, v17, v19, v20);
    if ((v23 & 6) == 2)
      _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLAdvertise"), (unsigned __int8 *)v28, *(unsigned __int16 *)(a1 + 4), a3);
  }
}

void D2D_stop_advertising_record(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;

  v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1)
    v10 = 0x20000;
  else
    v10 = (v9 == 2) << 20;
  if (callExternalHelpers(*(_QWORD *)(a1 + 32), *(_BYTE **)(a1 + 40), v10, a4, a5, a6, a7, a8))
    internal_stop_advertising_service(a1 + 8, v10, 0);
}

BOOL callExternalHelpers(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;

  v9 = (a3 & 0x120001) != 0 && a1 == 0;
  return (v9 || mDNSPlatformInterfaceIsD2D(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) || a1 == -5)
      && IsLocalDomain(a2);
}

uint64_t D2D_start_advertising_record(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  uint64_t result;

  v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1)
    v10 = 0x20000;
  else
    v10 = (v9 == 2) << 20;
  result = callExternalHelpers(*(_QWORD *)(a1 + 32), *(_BYTE **)(a1 + 40), v10, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
    return internal_start_advertising_service(a1 + 8, v10, 0);
  return result;
}

void external_connection_release(_BYTE *a1)
{
  uint64_t i;
  NSObject *v3;
  uint64_t v6;
  int v7;
  uint8_t buf[4];
  uint64_t v9;
  __int16 v10;
  int v11;

  for (i = D2DRecords; i; i = *(_QWORD *)i)
  {
    if (*(_WORD *)(i + 36) != 12 || !SameDomainNameBytes((_BYTE *)(i + 936), a1))
      continue;
    v3 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
    }
    else
    {
      v3 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
    }
    v6 = *(_QWORD *)(i + 8);
    v7 = *(_DWORD *)(i + 16);
    *(_DWORD *)buf = 134218240;
    v9 = v6;
    v10 = 1024;
    v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "external_connection_release: Calling D2DRelease - instanceHandle: %p, transportType: %d", buf, 0x12u);
LABEL_13:
    if (&_D2DRelease)
      D2DRelease(*(_QWORD *)(i + 8), *(unsigned int *)(i + 16));
  }
}

uint64_t xD2DParseCompressedPacket(_BYTE *a1, unsigned int a2, const void *a3, unsigned int a4, int a5, _QWORD *a6)
{
  unint64_t v12;
  _BYTE *v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  const char *v18;
  int v19;
  size_t v20;
  unsigned int v21;
  char *v22;
  unsigned int v23;
  int v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  int v30;
  NSObject *v32;
  uint32_t v33;
  uint64_t v34;
  int v38;
  NSObject *v39;
  uint8_t *j;
  uint64_t v41;
  uint8_t *i;
  uint64_t v43;
  int v44;
  _BYTE *v45;
  uint8_t v46[4];
  uint64_t v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint8_t *v51;
  __int16 v52;
  unsigned int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  unsigned int v57;
  uint8_t buf[16];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint8_t v74[16];

  v12 = (unint64_t)&a1[a2];
  v13 = skipDomainName((unint64_t)a1, a1, v12);
  if (v13)
    v14 = v13 + 3 == (_BYTE *)v12;
  else
    v14 = 0;
  if (!v14)
  {
    v15 = 4294901745;
    v16 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        return v15;
      *(_WORD *)buf = 0;
      v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }
    else
    {
      v16 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
        return v15;
      *(_WORD *)buf = 0;
      v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }
    v32 = v16;
    v33 = 2;
    goto LABEL_41;
  }
  v19 = v13[2];
  if (v19 != 1)
  {
    v34 = mDNSLogCategory_D2D;
    v15 = 4294901745;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        return v15;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v19;
      v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }
    else
    {
      v34 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
        return v15;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v19;
      v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }
    v32 = v34;
    v33 = 8;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, v18, buf, v33);
    return v15;
  }
  v20 = a2;
  v15 = 4294901745;
  if ((char *)&compression_base_msg + v20 + a4 + 32 >= (char *)&compression_base_msg + &unk_1000022F8)
    return 4294901757;
  v45 = (char *)&compression_base_msg + v20 + 39;
  v21 = *(unsigned __int16 *)v13;
  memcpy(byte_1001499E7, a1, v20);
  v22 = (char *)&byte_1001499E7[v20 - 1];
  if (*v22 == 1)
  {
    v23 = __rev16(v21);
    *(_DWORD *)v22 = 384;
    v22[4] = BYTE1(a5);
    v22[5] = a5;
    v22[6] = BYTE1(a4);
    v22[7] = a4;
    memcpy(v22 + 8, a3, a4);
    *a6 = &v22[a4 + 8];
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    *(_OWORD *)buf = 0u;
    v59 = 0u;
    if (!getDomainName((unint64_t)&compression_base_msg, byte_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, buf))buf[0] = 0;
    if (v23 != 12)
      goto LABEL_46;
    v24 = buf[0];
    if (!buf[0])
      goto LABEL_46;
    v25 = 0;
    v26 = 0;
    v27 = buf;
    while (1)
    {
      v28 = v26;
      v26 = v25;
      v25 = v27;
      if ((unint64_t)v26 | (unint64_t)v28)
      {
        if (v26 && v28)
        {
          v38 = SameDomainLabelPointer(v26, "\x04_sub");
          if (v38 && LabelPairIsForService(v25))
          {
LABEL_45:
            *v22 = 0;
            *v45 = 1;
          }
LABEL_46:
          if (mDNS_LoggingEnabled == 1)
          {
            v39 = mDNSLogCategory_D2D;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
              {
                for (i = buf; ; i += v43 + 1)
                {
                  if (i >= v74 || !i || (v43 = *i, v43 > 0x3F))
                  {
                    v44 = 257;
                    goto LABEL_67;
                  }
                  if (!*i)
                    break;
                }
                v44 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
LABEL_67:
                *(_DWORD *)v46 = 141559299;
                v47 = 1752392040;
                v48 = 1040;
                v49 = v44;
                v50 = 2101;
                v51 = buf;
                v52 = 1024;
                v53 = v23;
                v54 = 1024;
                v55 = a5;
                v56 = 1024;
                v57 = a4;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "xD2DParseCompressedPacket: Our Bytes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, TTL: %u, rdata length: %u", v46, 0x2Eu);
              }
            }
            else
            {
              v39 = mDNSLogCategory_D2D_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
              {
                for (j = buf; ; j += v41 + 1)
                {
                  if (j >= v74 || !j || (v41 = *j, v41 > 0x3F))
                  {
                    v44 = 257;
                    goto LABEL_67;
                  }
                  if (!*j)
                    break;
                }
                v44 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
                goto LABEL_67;
              }
            }
          }
          return 0;
        }
      }
      else if (LabelPairIsForService(v27))
      {
        goto LABEL_45;
      }
      v29 = &v25[v24];
      v30 = v29[1];
      v27 = v29 + 1;
      v24 = v30;
      if (!v30)
        goto LABEL_46;
    }
  }
  return v15;
}

void xD2DReceiveResponse(unint64_t a1, int a2)
{
  uint64_t *v4;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"xD2DReceiveResponse", 486);
  v4 = &AWDLInterfaceID;
  if (a2 != 2)
    v4 = &WiFiAwareInterfaceID;
  mDNSCoreReceiveResponse((uint64_t)mDNSStorage, compression_base_msg, a1, 0, 0xE914u, (__int128 *)&AllDNSLinkGroup_v6, 0xE914u, 0, 0, *v4);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"xD2DReceiveResponse", 489);
}

uint64_t xD2DParse(_BYTE *a1, unsigned int a2, const void *a3, unsigned int a4, char **a5)
{
  uint64_t v6;
  unsigned __int8 *LargeResourceRecord;
  char v8;
  NSObject *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  int v18;
  size_t v19;
  char *v20;
  char *v21;
  _BYTE *i;
  uint64_t v23;
  unsigned int v24;
  size_t v25;
  _WORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v33;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  char *v45;

  v33 = 0;
  v6 = xD2DParseCompressedPacket(a1, a2, a3, a4, 120, &v33);
  if ((_DWORD)v6)
    return v6;
  LargeResourceRecord = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)compression_base_msg, byte_1001499E7, v33, 0, 192, (uint64_t)mDNSStorage + &loc_100009418);
  v8 = gSensitiveLoggingEnabled;
  v9 = mDNSLogCategory_D2D;
  if (mDNSLogCategory_D2D == mDNSLogCategory_State)
    v8 = 0;
  if (LargeResourceRecord && *((unsigned __int8 *)&dword_100158DD0 + &loc_100009418) != 240)
  {
    if ((v8 & 1) != 0)
    {
      v9 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_39;
      v10 = qword_100162208;
      if (qword_100162208)
      {
        v11 = (_BYTE *)qword_100162208;
        if (qword_100162208 == -256)
        {
LABEL_11:
          while (v11)
          {
            v12 = *v11;
            if (v12 > 0x3F)
              break;
            if (!*v11)
            {
              v17 = (unsigned __int16)((_WORD)v11 - qword_100162208 + 1);
              goto LABEL_38;
            }
            v11 += v12 + 1;
            if (qword_100162208 != -256)
              goto LABEL_10;
          }
        }
        else
        {
LABEL_10:
          if ((unint64_t)v11 < qword_100162208 + 256)
            goto LABEL_11;
        }
        v17 = 257;
      }
      else
      {
        v17 = 0;
      }
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        goto LABEL_39;
      v10 = qword_100162208;
      if (qword_100162208)
      {
        v15 = (_BYTE *)qword_100162208;
        if (qword_100162208 == -256)
        {
LABEL_23:
          while (v15)
          {
            v16 = *v15;
            if (v16 > 0x3F)
              break;
            if (!*v15)
            {
              v17 = (unsigned __int16)((_WORD)v15 - qword_100162208 + 1);
              goto LABEL_38;
            }
            v15 += v16 + 1;
            if (qword_100162208 != -256)
              goto LABEL_22;
          }
        }
        else
        {
LABEL_22:
          if ((unint64_t)v15 < qword_100162208 + 256)
            goto LABEL_23;
        }
        v17 = 257;
      }
      else
      {
        v17 = 0;
      }
    }
LABEL_38:
    v18 = WORD6(xmmword_1001621E0);
    GetRRDisplayString_rdb((unsigned __int8 *)&xmmword_1001621E0 + 8, (unsigned __int16 *)(qword_100162210 + 4), (_BYTE *)&xmmword_1001621E0 + &unk_100002398 + 8);
    *(_DWORD *)buf = 141559299;
    v35 = 1752392040;
    v36 = 1040;
    v37 = v17;
    v38 = 2101;
    v39 = v10;
    v40 = 1024;
    v41 = v18;
    v42 = 2160;
    v43 = 1752392040;
    v44 = 2085;
    v45 = (char *)&xmmword_1001621E0 + &unk_100002398 + 8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "xD2DParse got record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash}s", buf, 0x36u);
LABEL_39:
    if (WORD2(xmmword_1001621F0) >= 0x109u)
      v19 = WORD2(xmmword_1001621F0) + 936;
    else
      v19 = 1200;
    v20 = (char *)malloc_type_calloc(1uLL, v19, 0xF1748037uLL);
    if (!v20)
      __break(1u);
    v21 = v20;
    *a5 = v20;
    mDNS_SetupResourceRecord((uint64_t)(v20 + 24), 0, -3, SWORD6(xmmword_1001621E0), 0x1C20u, 8, 5, (uint64_t)FreeD2DARElemCallback, 0);
    for (i = (char *)&xmmword_1001621E0 + &unk_100002090 + 12;
          mDNSStorage == (uint64_t *)-46516 || i < byte_10016437C;
          i += v23 + 1)
    {
      if (!i)
        break;
      v23 = *i;
      if (v23 > 0x3F)
        break;
      if (!*i)
      {
        v24 = (_DWORD)i - mDNSStorage + 19277;
        if ((unsigned __int16)v24 <= 0x100u)
        {
          memcpy(v21 + 676, &byte_10016427C, (unsigned __int16)v24);
          goto LABEL_53;
        }
        break;
      }
    }
    v21[676] = 0;
LABEL_53:
    v25 = WORD2(xmmword_1001621F0);
    *((_WORD *)v21 + 22) = WORD2(xmmword_1001621F0);
    v26 = (_WORD *)*((_QWORD *)v21 + 9);
    *v26 = v25;
    memcpy(v26 + 2, (const void *)(qword_100162210 + 4), v25);
    *((_DWORD *)v21 + 12) = DomainNameHashValue(*((_QWORD *)v21 + 8));
    SetNewRData((uint64_t)(v21 + 32), 0, 0, v27, v28, v29, v30, v31);
    v6 = 0;
    goto LABEL_54;
  }
  if ((v8 & 1) != 0)
  {
    v13 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v14 = v13;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "xD2DParse: failed to get large RR", buf, 2u);
    }
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    v14 = v9;
    goto LABEL_30;
  }
  v6 = 4294901759;
LABEL_54:
  WORD4(xmmword_1001621E0) = 0;
  HIWORD(xmmword_100162240) = 0;
  if ((_QWORD)xmmword_100162220)
  {
    ref_count_obj_release((_QWORD *)xmmword_100162220);
    *(_QWORD *)&xmmword_100162220 = 0;
  }
  return v6;
}

void FreeD2DARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  uint64_t *v6;
  BOOL v7;
  char v8;
  NSObject *v9;
  _BYTE *v10;
  _QWORD *v11;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  _BYTE *v16;

  if (a3 == -65792)
  {
    v5 = &D2DRecords;
    do
    {
      v6 = v5;
      v5 = (uint64_t *)*v5;
      if (v5)
        v7 = v5 + 3 == (uint64_t *)a2;
      else
        v7 = 1;
    }
    while (!v7);
    v8 = gSensitiveLoggingEnabled;
    v9 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State)
      v8 = 0;
    if (v5)
    {
      if ((v8 & 1) != 0)
      {
        v9 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        v10 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v10);
        v13 = 141558275;
        v14 = 1752392040;
        v15 = 2085;
        v16 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FreeD2DARElemCallback: Found in D2DRecords: %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
      }
      v11 = (_QWORD *)*v6;
      *v6 = *(_QWORD *)*v6;
      free(v11);
      return;
    }
    if ((v8 & 1) != 0)
    {
      v9 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        return;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }
    v12 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v12);
    v13 = 141558275;
    v14 = 1752392040;
    v15 = 2085;
    v16 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FreeD2DARElemCallback: Could not find in D2DRecords: %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
  }
}

BOOL LabelPairIsForService(unsigned __int8 *a1)
{
  uint64_t v1;
  unsigned __int8 *v2;
  int v3;
  unsigned __int8 *v4;

  v1 = *a1;
  if (!*a1)
    return 0;
  v3 = a1[1];
  v2 = a1 + 1;
  if (v3 != 95)
    return 0;
  v4 = &v2[v1];
  return SameDomainLabelPointer(&v2[v1], "\x04_tcp")
      || SameDomainLabelPointer(v4, "\x04_udp") != 0;
}

void external_start_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  uint64_t *v10;
  NSObject *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t *j;
  uint64_t v17;
  uint8_t *i;
  uint64_t v19;
  unsigned int v20;
  _BYTE *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t *v28;
  _WORD *v29;
  uint8_t *k;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  NSObject *v35;
  _OWORD *v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint64_t v40;
  unsigned __int16 *v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  _OWORD __src[16];
  uint8_t buf[4];
  uint64_t v49;
  __int16 v50;
  int v51;
  __int16 v52;
  _OWORD *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;

  memset(__src, 0, sizeof(__src));
  DomainnameToLower(a2, (uint64_t)__src);
  v10 = D2DFindInBrowseList(__src, a3);
  if (*v10 && *(_DWORD *)(*v10 + 268))
    goto LABEL_40;
  v46 = 0;
  v11 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      goto LABEL_24;
    for (i = (uint8_t *)__src; ; i += v19 + 1)
    {
      if (i >= buf || !i || (v19 = *i, v19 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }
      if (!*i)
        break;
    }
    v20 = (_DWORD)i - __src + 1;
  }
  else
  {
    v11 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_24;
    for (j = (uint8_t *)__src; ; j += v17 + 1)
    {
      if (j >= buf || !j || (v17 = *j, v17 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }
      if (!*j)
        break;
    }
    v20 = (_DWORD)j - __src + 1;
  }
LABEL_23:
  *(_DWORD *)buf = 141558787;
  v49 = 1752392040;
  v50 = 1040;
  v51 = (unsigned __int16)v20;
  v52 = 2101;
  v53 = __src;
  v54 = 1024;
  v55 = a3;
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "internal_start_browsing_for_service: starting browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x22u);
LABEL_24:
  v21 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)__src, v12, v13, v14, v15);
  if (v21)
  {
    *v21 = BYTE1(a3);
    v21[1] = a3;
    v21[2] = 1;
    v22 = v21 + 3;
  }
  else
  {
    v22 = 0;
  }
  v23 = v22 - (_BYTE *)&unk_1001499E7;
  PrintHelper((uint64_t)"internal_start_browsing_for_service", (uint64_t)&unk_1001499E7, (unsigned __int16)(v22 - (_BYTE *)&unk_1001499E7), 0, 0);
  v24 = xD2DMapToTransportType(a1, a4, &v46);
  if ((_DWORD)v24 == 4)
  {
    v25 = 0;
    v26 = v46;
    do
    {
      if (v26 != (_DWORD)v25 && &_D2DStartBrowsingForKeyOnTransport)
      {
        if ((v25 & 0x7FFFFFFE) == 2)
          _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLBrowse"), a2, a3, a5);
        D2DStartBrowsingForKeyOnTransport(&unk_1001499E7, v23, v25);
      }
      v25 = (v25 + 1);
    }
    while ((_DWORD)v25 != 4);
  }
  else if (&_D2DStartBrowsingForKeyOnTransport)
  {
    v27 = v24;
    if ((v24 & 6) == 2)
      _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLBrowse"), a2, a3, a5);
    D2DStartBrowsingForKeyOnTransport(&unk_1001499E7, v23, v27);
  }
LABEL_40:
  v28 = D2DFindInBrowseList(__src, a3);
  if (!*v28)
  {
    v29 = malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
    if (!v29)
      __break(1u);
    *v28 = (uint64_t)v29;
    v29[132] = a3;
    for (k = (uint8_t *)__src; k < buf; k += v31 + 1)
    {
      if (!k)
        break;
      v31 = *k;
      if (v31 > 0x3F)
        break;
      if (!*k)
      {
        v32 = (_DWORD)k - __src + 1;
        if ((unsigned __int16)v32 <= 0x100u)
        {
          memcpy(v29 + 4, __src, (unsigned __int16)v32);
          goto LABEL_51;
        }
        break;
      }
    }
    *((_BYTE *)v29 + 8) = 0;
  }
LABEL_51:
  v33 = *v28;
  v34 = *(_DWORD *)(*v28 + 268) + 1;
  *(_DWORD *)(v33 + 268) = v34;
  v35 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
      return;
    v37 = (_OWORD *)(v33 + 8);
    v38 = (unsigned __int16 *)(v33 + 264);
    v39 = (unsigned __int16 *)(v33 + 8);
    if (v33 == -264)
    {
LABEL_59:
      while (v39)
      {
        v40 = *(unsigned __int8 *)v39;
        if (v40 > 0x3F)
          break;
        if (!*(_BYTE *)v39)
        {
          v44 = (unsigned __int16)((_WORD)v39 - (_WORD)v37 + 1);
          goto LABEL_76;
        }
        v39 = (unsigned __int16 *)((char *)v39 + v40 + 1);
        if (v33 != -264)
          goto LABEL_58;
      }
    }
    else
    {
LABEL_58:
      if (v39 < v38)
        goto LABEL_59;
    }
    v44 = 257;
    goto LABEL_76;
  }
  v35 = mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
  {
    v37 = (_OWORD *)(v33 + 8);
    v38 = (unsigned __int16 *)(v33 + 264);
    v42 = (unsigned __int16 *)(v33 + 8);
    if (v33 == -264)
    {
LABEL_67:
      while (v42)
      {
        v43 = *(unsigned __int8 *)v42;
        if (v43 > 0x3F)
          break;
        if (!*(_BYTE *)v42)
        {
          v44 = (unsigned __int16)((_WORD)v42 - (_WORD)v37 + 1);
          goto LABEL_76;
        }
        v42 = (unsigned __int16 *)((char *)v42 + v43 + 1);
        if (v33 != -264)
          goto LABEL_66;
      }
    }
    else
    {
LABEL_66:
      if (v42 < v38)
        goto LABEL_67;
    }
    v44 = 257;
LABEL_76:
    v45 = *v38;
    *(_DWORD *)buf = 141559043;
    v49 = 1752392040;
    v50 = 1040;
    v51 = v44;
    v52 = 2101;
    v53 = v37;
    v54 = 1024;
    v55 = v45;
    v56 = 1024;
    v57 = v34;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "D2DBrowseListRetain - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u", buf, 0x28u);
  }
}

uint64_t *D2DFindInBrowseList(_BYTE *a1, int a2)
{
  uint64_t *v2;
  uint64_t i;

  v2 = &D2DBrowseList;
  for (i = D2DBrowseList; i; i = *(_QWORD *)i)
  {
    if (*(unsigned __int16 *)(i + 264) == a2)
    {
      if (SameDomainNameBytes((_BYTE *)(i + 8), a1))
        return v2;
      i = *v2;
    }
    v2 = (uint64_t *)i;
  }
  return v2;
}

void external_stop_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  NSObject *v14;
  _OWORD *v15;
  unsigned __int16 *v16;
  unsigned __int16 *j;
  uint64_t v18;
  NSObject *v19;
  uint8_t *kk;
  uint64_t v21;
  unsigned __int16 *i;
  uint64_t v23;
  uint8_t *jj;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t *v29;
  uint64_t *v30;
  NSObject *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint8_t *m;
  uint64_t v37;
  uint8_t *k;
  uint64_t v39;
  int v40;
  _BYTE *v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  char v47;
  _QWORD *v48;
  _QWORD *v49;
  NSObject *v50;
  uint8_t *n;
  unsigned int v53;
  uint64_t v54;
  uint8_t *ii;
  uint64_t v57;
  int v58;
  int v59;
  _OWORD v60[16];
  uint8_t buf[4];
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  _OWORD *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  uint64_t v70;
  __int16 v71;
  __int16 *v72;

  memset(v60, 0, sizeof(v60));
  DomainnameToLower(a2, (uint64_t)v60);
  v10 = D2DFindInBrowseList(v60, a3);
  v11 = *v10;
  if (*v10)
  {
    v12 = v10;
    v13 = *(_DWORD *)(v11 + 268) - 1;
    *(_DWORD *)(v11 + 268) = v13;
    v14 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
        goto LABEL_41;
      v15 = (_OWORD *)(v11 + 8);
      v16 = (unsigned __int16 *)(v11 + 264);
      for (i = (unsigned __int16 *)(v11 + 8); ; i = (unsigned __int16 *)((char *)i + v23 + 1))
      {
        if (i >= v16 || !i || (v23 = *(unsigned __int8 *)i, v23 > 0x3F))
        {
          v26 = 257;
          goto LABEL_40;
        }
        if (!*(_BYTE *)i)
          break;
      }
      v26 = (unsigned __int16)((_WORD)i - (_WORD)v15 + 1);
    }
    else
    {
      v14 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_41;
      v15 = (_OWORD *)(v11 + 8);
      v16 = (unsigned __int16 *)(v11 + 264);
      for (j = (unsigned __int16 *)(v11 + 8); ; j = (unsigned __int16 *)((char *)j + v18 + 1))
      {
        if (j >= v16 || !j || (v18 = *(unsigned __int8 *)j, v18 > 0x3F))
        {
          v26 = 257;
          goto LABEL_40;
        }
        if (!*(_BYTE *)j)
          break;
      }
      v26 = (unsigned __int16)((_WORD)j - (_WORD)v15 + 1);
    }
LABEL_40:
    v28 = *v16;
    *(_DWORD *)buf = 141559043;
    v62 = 1752392040;
    v63 = 1040;
    v64 = v26;
    v65 = 2101;
    v66 = v15;
    v67 = 1024;
    v68 = v28;
    v69 = 1024;
    LODWORD(v70) = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "D2DBrowseListRelease - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u", buf, 0x28u);
LABEL_41:
    v29 = (uint64_t *)*v12;
    if (!*(_DWORD *)(*v12 + 268))
    {
      *v12 = *v29;
      free(v29);
    }
    v30 = D2DFindInBrowseList(v60, a3);
    if (*v30 && *(_DWORD *)(*v30 + 268))
      return;
    v59 = 0;
    v31 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        goto LABEL_66;
      for (k = (uint8_t *)v60; ; k += v39 + 1)
      {
        if (k >= buf || !k || (v39 = *k, v39 > 0x3F))
        {
          v40 = 257;
          goto LABEL_65;
        }
        if (!*k)
          break;
      }
      v40 = (unsigned __int16)((_WORD)k - (unsigned __int16)v60 + 1);
    }
    else
    {
      v31 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_66;
      for (m = (uint8_t *)v60; ; m += v37 + 1)
      {
        if (m >= buf || !m || (v37 = *m, v37 > 0x3F))
        {
          v40 = 257;
          goto LABEL_65;
        }
        if (!*m)
          break;
      }
      v40 = (unsigned __int16)((_WORD)m - (unsigned __int16)v60 + 1);
    }
LABEL_65:
    *(_DWORD *)buf = 141558787;
    v62 = 1752392040;
    v63 = 1040;
    v64 = v40;
    v65 = 2101;
    v66 = v60;
    v67 = 1024;
    v68 = a3;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "internal_stop_browsing_for_service: stopping browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x22u);
LABEL_66:
    v41 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v60, v32, v33, v34, v35);
    if (v41)
    {
      *v41 = BYTE1(a3);
      v41[1] = a3;
      v41[2] = 1;
      v42 = v41 + 3;
    }
    else
    {
      v42 = 0;
    }
    v43 = v42 - (_BYTE *)&unk_1001499E7;
    PrintHelper((uint64_t)"internal_stop_browsing_for_service", (uint64_t)&unk_1001499E7, (unsigned __int16)(v42 - (_BYTE *)&unk_1001499E7), 0, 0);
    v44 = xD2DMapToTransportType(a1, a4, &v59);
    if ((_DWORD)v44 == 4)
    {
      v45 = 0;
      v46 = v59;
      do
      {
        if (v46 != (_DWORD)v45)
        {
          if (&_D2DStopBrowsingForKeyOnTransport)
          {
            D2DStopBrowsingForKeyOnTransport(&unk_1001499E7, v43, v45);
            if ((v45 & 0x7FFFFFFE) == 2)
              _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLBrowse"), a2, a3, a5);
          }
        }
        v45 = (v45 + 1);
      }
      while ((_DWORD)v45 != 4);
    }
    else if (&_D2DStopBrowsingForKeyOnTransport)
    {
      v47 = v44;
      D2DStopBrowsingForKeyOnTransport(&unk_1001499E7, v43, v44);
      if ((v47 & 6) == 2)
        _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLBrowse"), a2, a3, a5);
    }
    v48 = (_QWORD *)D2DRecords;
    if (D2DRecords)
    {
      while (1)
      {
        v49 = v48;
        v48 = (_QWORD *)*v48;
        if (*((unsigned __int16 *)v49 + 18) != a3 || !SameDomainNameBytes((_BYTE *)v49 + 676, v60))
          goto LABEL_109;
        v50 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State)
          break;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          for (n = (uint8_t *)v60; ; n += v54 + 1)
          {
            LOWORD(v53) = 257;
            if (n >= buf || !n)
              break;
            v54 = *n;
            if (v54 > 0x3F)
            {
              LOWORD(v53) = 257;
              break;
            }
            if (!*n)
            {
              v53 = (_DWORD)n - v60 + 1;
              break;
            }
          }
LABEL_107:
          v58 = (unsigned __int16)v53;
          GetRRDisplayString_rdb((unsigned __int8 *)v49 + 32, (unsigned __int16 *)(v49[9] + 4), word_100164580);
          *(_DWORD *)buf = 141559299;
          v62 = 1752392040;
          v63 = 1040;
          v64 = v58;
          v65 = 2101;
          v66 = v60;
          v67 = 1024;
          v68 = a3;
          v69 = 2160;
          v70 = 1752392040;
          v71 = 2085;
          v72 = word_100164580;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "xD2DClearCache: Clearing and deregistering cache record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
        }
LABEL_108:
        mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v49 + 3));
LABEL_109:
        if (!v48)
          return;
      }
      v50 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_108;
      for (ii = (uint8_t *)v60; ; ii += v57 + 1)
      {
        LOWORD(v53) = 257;
        if (ii >= buf || !ii)
          break;
        v57 = *ii;
        if (v57 > 0x3F)
        {
          LOWORD(v53) = 257;
          goto LABEL_107;
        }
        if (!*ii)
        {
          v53 = (_DWORD)ii - v60 + 1;
          goto LABEL_107;
        }
      }
      goto LABEL_107;
    }
    return;
  }
  v19 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
      return;
    for (jj = (uint8_t *)v60; ; jj += v25 + 1)
    {
      if (jj >= buf || !jj || (v25 = *jj, v25 > 0x3F))
      {
        v27 = 257;
        goto LABEL_113;
      }
      if (!*jj)
        break;
    }
    v27 = (unsigned __int16)((_WORD)jj - (unsigned __int16)v60 + 1);
  }
  else
  {
    v19 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
      return;
    for (kk = (uint8_t *)v60; ; kk += v21 + 1)
    {
      if (kk >= buf || !kk || (v21 = *kk, v21 > 0x3F))
      {
        v27 = 257;
        goto LABEL_113;
      }
      if (!*kk)
        break;
    }
    v27 = (unsigned __int16)((_WORD)kk - (unsigned __int16)v60 + 1);
  }
LABEL_113:
  *(_DWORD *)buf = 141558787;
  v62 = 1752392040;
  v63 = 1040;
  v64 = v27;
  v65 = 2101;
  v66 = v60;
  v67 = 1024;
  v68 = a3;
  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "D2DBrowseListRelease item not found in the list - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d", buf, 0x22u);
}

void initializeD2DPlugins()
{
  CFRunLoopRef Main;
  int v1;
  char v2;
  uint64_t v3;
  int v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint32_t v8;
  int v9;
  int v10;

  if (&_D2DInitialize)
  {
    Main = CFRunLoopGetMain();
    v1 = D2DInitialize(Main, xD2DServiceCallback, mDNSStorage);
    v2 = gSensitiveLoggingEnabled;
    v3 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State)
      v2 = 0;
    if (v1)
    {
      v4 = v1;
      if ((v2 & 1) != 0)
      {
        v3 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          return;
        v9 = 67109120;
        v10 = v4;
        v5 = "D2DInitialiize failed: %d";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          return;
        v9 = 67109120;
        v10 = v4;
        v5 = "D2DInitialiize failed: %d";
      }
      v6 = v3;
      v7 = OS_LOG_TYPE_ERROR;
      v8 = 8;
    }
    else
    {
      if ((v2 & 1) != 0)
      {
        v3 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        LOWORD(v9) = 0;
        v5 = "D2DInitialize succeeded";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          return;
        LOWORD(v9) = 0;
        v5 = "D2DInitialize succeeded";
      }
      v6 = v3;
      v7 = OS_LOG_TYPE_DEFAULT;
      v8 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, (uint8_t *)&v9, v8);
  }
}

void xD2DServiceCallback(int a1, int a2, uint64_t a3, uint64_t a4, _BYTE *a5, unint64_t a6, _OWORD *a7, unint64_t a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v27;
  NSObject *v30;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  char v42;
  NSObject *v43;
  char v44;
  char v45;
  uint64_t *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  NSObject *v55;
  uint64_t v57;
  _BYTE *v58;
  unsigned __int16 v59;
  uint64_t v60;
  _BYTE *v62;
  unsigned __int16 v63;
  uint64_t v64;
  int v65;
  int v66;
  uint8_t *v67;
  NSObject *v68;
  os_log_type_t v69;
  uint32_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  NSObject *v75;
  int v76;
  int v77;
  NSObject *v78;
  uint64_t v79;
  uint64_t v80;
  NSObject *v81;
  uint64_t v82;
  uint64_t v83;
  _BYTE *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  char v88;
  NSObject *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  _BYTE *v93;
  uint64_t v94;
  void *v95;
  _BYTE *v96;
  uint64_t v97;
  uint64_t v98;
  _BYTE *v99;
  uint64_t v100;
  uint64_t v101;
  _BYTE *v102;
  uint64_t v103;
  _BYTE *v104;
  uint64_t v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  NSObject *v111;
  int v112;
  int v113;
  int v114;
  uint64_t v115;
  NSObject *v116;
  uint64_t v117;
  _BYTE *v118;
  uint64_t v119;
  _BYTE *v120;
  uint64_t v121;
  int v122;
  int v123;
  uint64_t v124;
  _BYTE v125[20];
  _BYTE buf[18];
  __int16 v127;
  _BYTE v128[44];

  v16 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v16, v17, v18, v19, v20, v21, v22, v23);
  if (a6 >= 0x10000)
  {
    v24 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        goto LABEL_12;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a6;
      goto LABEL_11;
    }
    v24 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a6;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "xD2DServiceCallback: keySize too large - key size: %zu", buf, 0xCu);
    }
  }
LABEL_12:
  if (a8 < 0x10000)
    goto LABEL_23;
  v27 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = a8;
  }
  else
  {
    v27 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = a8;
  }
  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "xD2DServiceCallback: valueSize too large - value size: %zu", buf, 0xCu);
LABEL_23:
  v30 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      goto LABEL_33;
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&buf[4] = a1;
    goto LABEL_32;
  }
  v30 = mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&buf[4] = a1;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "xD2DServiceCallback -- event: %{public, mdnsresponder:d2d_service_event}d", buf, 8u);
  }
LABEL_33:
  PrintHelper((uint64_t)"xD2DServiceCallback", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
  switch(a1)
  {
    case 0:
      if (a2)
      {
        v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = a2;
            v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }
        else
        {
          v40 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = a2;
            v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }
        goto LABEL_153;
      }
      if (!a8 || !a6 || !a5 || !a7)
      {
        v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }
        else
        {
          v71 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }
        goto LABEL_153;
      }
      if ((a4 & 0xFFFFFFFE) != 2)
      {
        *(_QWORD *)v125 = 0;
        v76 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
        if (v76)
        {
          v77 = v76;
          v78 = mDNSLogCategory_D2D;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v77;
              goto LABEL_239;
            }
          }
          else
          {
            v78 = mDNSLogCategory_D2D_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v77;
LABEL_239:
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "xD2DAddToCache: xD2DParse failed - error: %d", buf, 8u);
            }
          }
          PrintHelper((uint64_t)"xD2DAddToCache", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
          v86 = *(_QWORD *)v125;
          goto LABEL_241;
        }
        v86 = *(_QWORD *)v125;
        v87 = mDNS_Register((unsigned int *)mDNSStorage, *(_QWORD *)v125 + 24);
        v88 = gSensitiveLoggingEnabled;
        v89 = mDNSLogCategory_D2D;
        if (mDNSLogCategory_D2D == mDNSLogCategory_State)
          v88 = 0;
        if (v87)
        {
          v90 = v87;
          if ((v88 & 1) != 0)
          {
            v91 = mDNSLogCategory_D2D_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_241;
            v92 = *(_QWORD *)(v86 + 64);
            if (v92)
            {
              v93 = *(_BYTE **)(v86 + 64);
              if (v92 == -256)
              {
                while (1)
                {
LABEL_224:
                  if (!v93)
                    goto LABEL_286;
                  v94 = *v93;
                  if (v94 > 0x3F)
                    goto LABEL_286;
                  if (!*v93)
                    break;
                  v93 += v94 + 1;
                  if (v92 != -256)
                    goto LABEL_223;
                }
                v107 = (unsigned __int16)((_WORD)v93 - v92 + 1);
              }
              else
              {
LABEL_223:
                if ((unint64_t)v93 < v92 + 256)
                  goto LABEL_224;
LABEL_286:
                v107 = 257;
              }
            }
            else
            {
              v107 = 0;
            }
            v110 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(_QWORD *)(v86 + 72) + 4), word_100164580);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)&buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(_QWORD *)&buf[10] = 1752392040;
            v127 = 1040;
            *(_DWORD *)v128 = v107;
            *(_WORD *)&v128[4] = 2101;
            *(_QWORD *)&v128[6] = v92;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v110;
            *(_WORD *)&v128[20] = 2160;
            *(_QWORD *)&v128[22] = 1752392040;
            *(_WORD *)&v128[30] = 2085;
            *(_QWORD *)&v128[32] = word_100164580;
            v111 = v91;
          }
          else
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
LABEL_241:
              if (!v86)
                goto LABEL_153;
LABEL_301:
              v95 = (void *)v86;
              goto LABEL_305;
            }
            v101 = *(_QWORD *)(v86 + 64);
            if (v101)
            {
              v102 = *(_BYTE **)(v86 + 64);
              if (v101 == -256)
              {
                while (1)
                {
LABEL_269:
                  if (!v102)
                    goto LABEL_287;
                  v103 = *v102;
                  if (v103 > 0x3F)
                    goto LABEL_287;
                  if (!*v102)
                    break;
                  v102 += v103 + 1;
                  if (v101 != -256)
                    goto LABEL_268;
                }
                v108 = (unsigned __int16)((_WORD)v102 - v101 + 1);
              }
              else
              {
LABEL_268:
                if ((unint64_t)v102 < v101 + 256)
                  goto LABEL_269;
LABEL_287:
                v108 = 257;
              }
            }
            else
            {
              v108 = 0;
            }
            v112 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(_QWORD *)(v86 + 72) + 4), word_100164580);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)&buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(_QWORD *)&buf[10] = 1752392040;
            v127 = 1040;
            *(_DWORD *)v128 = v108;
            *(_WORD *)&v128[4] = 2101;
            *(_QWORD *)&v128[6] = v101;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v112;
            *(_WORD *)&v128[20] = 2160;
            *(_QWORD *)&v128[22] = 1752392040;
            *(_WORD *)&v128[30] = 2085;
            *(_QWORD *)&v128[32] = word_100164580;
            v111 = v89;
          }
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "xD2DAddToCache: mDNS_Register failed - error: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x3Cu);
          goto LABEL_301;
        }
        if ((v88 & 1) != 0)
        {
          v89 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v98 = *(_QWORD *)(v86 + 64);
            if (v98)
            {
              v99 = *(_BYTE **)(v86 + 64);
              if (v98 == -256)
              {
LABEL_260:
                while (v99)
                {
                  v100 = *v99;
                  if (v100 > 0x3F)
                    break;
                  if (!*v99)
                  {
                    v109 = (unsigned __int16)((_WORD)v99 - v98 + 1);
                    goto LABEL_308;
                  }
                  v99 += v100 + 1;
                  if (v98 != -256)
                    goto LABEL_259;
                }
              }
              else
              {
LABEL_259:
                if ((unint64_t)v99 < v98 + 256)
                  goto LABEL_260;
              }
              v109 = 257;
            }
            else
            {
              v109 = 0;
            }
LABEL_308:
            v114 = *(unsigned __int16 *)(v86 + 36);
            v115 = *(_QWORD *)(v86 + 56);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(_QWORD *)(v86 + 72) + 4), word_100164580);
            *(_DWORD *)buf = 141559555;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v109;
            v127 = 2101;
            *(_QWORD *)v128 = v98;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v114;
            *(_WORD *)&v128[14] = 2048;
            *(_QWORD *)&v128[16] = v115;
            *(_WORD *)&v128[24] = 2160;
            *(_QWORD *)&v128[26] = 1752392040;
            *(_WORD *)&v128[34] = 2085;
            *(_QWORD *)&v128[36] = word_100164580;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "xD2DAddToCache: mDNS_Register succeeded - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, Interface ID: %p, auth record: %{sensitive, mask.hash}s", buf, 0x40u);
          }
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          v98 = *(_QWORD *)(v86 + 64);
          if (v98)
          {
            v104 = *(_BYTE **)(v86 + 64);
            if (v98 == -256)
            {
LABEL_278:
              while (v104)
              {
                v105 = *v104;
                if (v105 > 0x3F)
                  break;
                if (!*v104)
                {
                  v109 = (unsigned __int16)((_WORD)v104 - v98 + 1);
                  goto LABEL_308;
                }
                v104 += v105 + 1;
                if (v98 != -256)
                  goto LABEL_277;
              }
            }
            else
            {
LABEL_277:
              if ((unint64_t)v104 < v98 + 256)
                goto LABEL_278;
            }
            v109 = 257;
          }
          else
          {
            v109 = 0;
          }
          goto LABEL_308;
        }
        *(_DWORD *)(v86 + 16) = a4;
        *(_QWORD *)v86 = D2DRecords;
        *(_QWORD *)(v86 + 8) = a3;
        D2DRecords = v86;
        goto LABEL_153;
      }
      *(_QWORD *)buf = 0;
      v47 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 4500, buf);
      if (!v47)
        goto LABEL_177;
      v48 = v47;
      v40 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }
      else
      {
        v40 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }
LABEL_153:
      KQueueUnlock((uint64_t)"xD2DServiceCallback", v33, v34, v35, v36, v37, v38, v39);
      return;
    case 1:
      if (a2)
      {
        v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }
        else
        {
          v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }
LABEL_149:
        v67 = buf;
LABEL_150:
        v68 = v40;
LABEL_151:
        v69 = OS_LOG_TYPE_ERROR;
        v70 = 8;
LABEL_152:
        _os_log_impl((void *)&_mh_execute_header, v68, v69, v41, v67, v70);
        goto LABEL_153;
      }
      if ((a4 & 0xFFFFFFFE) == 2)
      {
        *(_QWORD *)buf = 0;
        v49 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 0, buf);
        if (!v49)
        {
LABEL_177:
          xD2DReceiveResponse(*(unint64_t *)buf, a4);
          goto LABEL_153;
        }
        v50 = v49;
        v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }
        else
        {
          v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }
LABEL_231:
        v67 = v125;
        goto LABEL_150;
      }
      v72 = D2DRecords;
      *(_QWORD *)v125 = 0;
      if (!a8 || !a6 || !a5 || !a7)
      {
        v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_WORD *)buf = 0;
          v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }
        else
        {
          v71 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_WORD *)buf = 0;
          v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }
LABEL_193:
        v67 = buf;
        v68 = v71;
        v69 = OS_LOG_TYPE_ERROR;
        v70 = 2;
        goto LABEL_152;
      }
      v73 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
      if (v73)
      {
        v74 = v73;
        v75 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_235;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v74;
        }
        else
        {
          v75 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_235;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v74;
        }
        _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "xD2DFindInList: xD2DParse failed - error: %d", buf, 8u);
LABEL_235:
        PrintHelper((uint64_t)"xD2DFindInList", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
        v95 = *(void **)v125;
        if (!*(_QWORD *)v125)
          goto LABEL_153;
        goto LABEL_305;
      }
      if (v72)
      {
        v79 = *(_QWORD *)v125;
        v80 = *(_QWORD *)v125 + 32;
        while (*(_DWORD *)(v79 + 48) != *(_DWORD *)(v72 + 48)
             || !resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v79 + 88), *(_QWORD *)(v72 + 88))|| *(unsigned __int16 *)(v79 + 36) != *(unsigned __int16 *)(v72 + 36)|| *(unsigned __int16 *)(v79 + 38) != *(unsigned __int16 *)(v72 + 38)|| *(unsigned __int16 *)(v79 + 44) != *(unsigned __int16 *)(v72 + 44)|| *(_DWORD *)(v79 + 52) != *(_DWORD *)(v72 + 52)|| !SameRDataBody(v80, (unsigned __int16 *)(*(_QWORD *)(v72 + 72) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(_BYTE **)(v79 + 64), *(_BYTE **)(v72 + 64)))
        {
          v72 = *(_QWORD *)v72;
          if (!v72)
            goto LABEL_205;
        }
        free((void *)v79);
        v116 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          {
            v117 = *(_QWORD *)(v72 + 64);
            if (v117)
            {
              v120 = *(_BYTE **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_325:
                while (v120)
                {
                  v121 = *v120;
                  if (v121 > 0x3F)
                    break;
                  if (!*v120)
                  {
                    v122 = (unsigned __int16)((_WORD)v120 - v117 + 1);
                    goto LABEL_336;
                  }
                  v120 += v121 + 1;
                  if (v117 != -256)
                    goto LABEL_324;
                }
              }
              else
              {
LABEL_324:
                if ((unint64_t)v120 < v117 + 256)
                  goto LABEL_325;
              }
              v122 = 257;
            }
            else
            {
              v122 = 0;
            }
            goto LABEL_336;
          }
        }
        else
        {
          v116 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v117 = *(_QWORD *)(v72 + 64);
            if (v117)
            {
              v118 = *(_BYTE **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_316:
                while (v118)
                {
                  v119 = *v118;
                  if (v119 > 0x3F)
                    break;
                  if (!*v118)
                  {
                    v122 = (unsigned __int16)((_WORD)v118 - v117 + 1);
                    goto LABEL_336;
                  }
                  v118 += v119 + 1;
                  if (v117 != -256)
                    goto LABEL_315;
                }
              }
              else
              {
LABEL_315:
                if ((unint64_t)v118 < v117 + 256)
                  goto LABEL_316;
              }
              v122 = 257;
            }
            else
            {
              v122 = 0;
            }
LABEL_336:
            v123 = *(unsigned __int16 *)(v72 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v72 + 32), (unsigned __int16 *)(*(_QWORD *)(v72 + 72) + 4), word_100164580);
            *(_DWORD *)buf = 141559299;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v122;
            v127 = 2101;
            *(_QWORD *)v128 = v117;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v123;
            *(_WORD *)&v128[14] = 2160;
            *(_QWORD *)&v128[16] = 1752392040;
            *(_WORD *)&v128[24] = 2085;
            *(_QWORD *)&v128[26] = word_100164580;
            _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "xD2DRemoveFromCache: removing record from cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
          }
        }
        mDNS_Deregister((unsigned int *)mDNSStorage, v72 + 24);
        goto LABEL_153;
      }
LABEL_205:
      v81 = mDNSLogCategory_D2D;
      if ((gSensitiveLoggingEnabled & 1) != 0)
      {
        v82 = *(_QWORD *)v125;
        if (mDNSLogCategory_D2D != mDNSLogCategory_State)
        {
          v81 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            v83 = *(_QWORD *)(v82 + 64);
            if (v83)
            {
              v84 = *(_BYTE **)(v82 + 64);
              if (v83 == -256)
              {
                while (1)
                {
LABEL_211:
                  if (!v84)
                    goto LABEL_288;
                  v85 = *v84;
                  if (v85 > 0x3F)
                    goto LABEL_288;
                  if (!*v84)
                    break;
                  v84 += v85 + 1;
                  if (v83 != -256)
                    goto LABEL_210;
                }
                v106 = (unsigned __int16)((_WORD)v84 - v83 + 1);
              }
              else
              {
LABEL_210:
                if ((unint64_t)v84 < v83 + 256)
                  goto LABEL_211;
LABEL_288:
                v106 = 257;
              }
            }
            else
            {
              v106 = 0;
            }
LABEL_303:
            v113 = *(unsigned __int16 *)(v82 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v82 + 32), (unsigned __int16 *)(*(_QWORD *)(v82 + 72) + 4), word_100164580);
            *(_DWORD *)buf = 141559299;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v106;
            v127 = 2101;
            *(_QWORD *)v128 = v83;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v113;
            *(_WORD *)&v128[14] = 2160;
            *(_QWORD *)&v128[16] = 1752392040;
            *(_WORD *)&v128[24] = 2085;
            *(_QWORD *)&v128[26] = word_100164580;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "xD2DFindInList: Could not find in D2DRecords - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
LABEL_304:
            v95 = (void *)v82;
LABEL_305:
            free(v95);
            goto LABEL_153;
          }
          goto LABEL_253;
        }
      }
      else
      {
        v82 = *(_QWORD *)v125;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
      {
        v83 = *(_QWORD *)(v82 + 64);
        if (v83)
        {
          v96 = *(_BYTE **)(v82 + 64);
          if (v83 == -256)
          {
            while (1)
            {
LABEL_248:
              if (!v96)
                goto LABEL_283;
              v97 = *v96;
              if (v97 > 0x3F)
                goto LABEL_283;
              if (!*v96)
                break;
              v96 += v97 + 1;
              if (v83 != -256)
                goto LABEL_247;
            }
            v106 = (unsigned __int16)((_WORD)v96 - v83 + 1);
          }
          else
          {
LABEL_247:
            if ((unint64_t)v96 < v83 + 256)
              goto LABEL_248;
LABEL_283:
            v106 = 257;
          }
        }
        else
        {
          v106 = 0;
        }
        goto LABEL_303;
      }
LABEL_253:
      if (!v82)
        goto LABEL_153;
      goto LABEL_304;
    case 2:
      v42 = gSensitiveLoggingEnabled;
      v43 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State)
        v42 = 0;
      if (a2)
      {
        if ((v42 & 1) == 0)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DServiceResolved: Unexpected result - result: %d";
          v67 = buf;
          v68 = v43;
          goto LABEL_151;
        }
        v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_153;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = a2;
        v41 = "xD2DServiceResolved: Unexpected result - result: %d";
        goto LABEL_149;
      }
      if ((v42 & 1) != 0)
      {
        v43 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_170;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          goto LABEL_170;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
      }
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "xD2DServiceResolved: Starting up PAN connection - instanceHandle: %p", buf, 0xCu);
LABEL_170:
      if (&_D2DRetain)
        D2DRetain(a3, a4);
      goto LABEL_153;
    case 3:
      v44 = gSensitiveLoggingEnabled;
      v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State)
        v44 = 0;
      if (a2)
      {
        if ((v44 & 1) != 0)
        {
          v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }
        goto LABEL_149;
      }
      if ((v44 & 1) != 0)
      {
        v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_153;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
        v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          goto LABEL_153;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
        v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }
      goto LABEL_176;
    case 4:
      v45 = gSensitiveLoggingEnabled;
      v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State)
        v45 = 0;
      if (a2)
      {
        if ((v45 & 1) != 0)
        {
          v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            goto LABEL_153;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = a2;
          v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }
        goto LABEL_149;
      }
      if ((v45 & 1) != 0)
      {
        v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_153;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
        v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          goto LABEL_153;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = a3;
        v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }
LABEL_176:
      v67 = buf;
      v68 = v40;
      v69 = OS_LOG_TYPE_DEFAULT;
      v70 = 12;
      goto LABEL_152;
    case 5:
      if (a2)
        goto LABEL_153;
      if ((_DWORD)a4 == 2)
      {
        v46 = &AWDLInterfaceID;
      }
      else
      {
        if ((_DWORD)a4 != 3)
          goto LABEL_153;
        v46 = &WiFiAwareInterfaceID;
      }
      if (a8 != 16)
        goto LABEL_153;
      v51 = *v46;
      *(_DWORD *)v125 = 6;
      *(_OWORD *)&v125[4] = *a7;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 695);
      v52 = 0;
      while (1)
      {
        v124 = v52;
        v53 = (_QWORD *)mDNSStorage[v52 + 34];
        if (v53)
          break;
LABEL_137:
        v52 = v124 + 1;
        if (v124 == 498)
        {
          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 710);
          goto LABEL_153;
        }
      }
      while (1)
      {
        v54 = v53[2];
        if (v54)
          break;
LABEL_136:
        v53 = (_QWORD *)*v53;
        if (!v53)
          goto LABEL_137;
      }
      break;
    default:
      goto LABEL_153;
  }
  while (1)
  {
    if (*(_QWORD *)(v54 + 32) != v51 || !mDNSSameAddress((int *)(v54 + 132), v125))
      goto LABEL_135;
    v55 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State)
      break;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_INFO))
    {
      v57 = *(_QWORD *)(v54 + 40);
      if (v57)
      {
        v58 = *(_BYTE **)(v54 + 40);
        if (v57 == -256)
          goto LABEL_109;
LABEL_106:
        v59 = 257;
        if ((unint64_t)v58 < v57 + 256 && v58)
        {
          while (1)
          {
            v60 = *v58;
            if (v60 > 0x3F)
            {
LABEL_127:
              v59 = 257;
              goto LABEL_130;
            }
            if (!*v58)
              break;
            v58 += v60 + 1;
            if (v57 != -256)
              goto LABEL_106;
LABEL_109:
            if (!v58)
              goto LABEL_127;
          }
          v59 = (_WORD)v58 - v57 + 1;
        }
LABEL_130:
        v65 = v59;
      }
      else
      {
        v65 = 0;
      }
LABEL_133:
      v66 = *(unsigned __int16 *)(v54 + 12);
      *(_DWORD *)buf = 141559555;
      *(_QWORD *)&buf[4] = 1752392040;
      *(_WORD *)&buf[12] = 1045;
      *(_DWORD *)&buf[14] = 20;
      v127 = 2101;
      *(_QWORD *)v128 = v125;
      *(_WORD *)&v128[8] = 2160;
      *(_QWORD *)&v128[10] = 1752392040;
      *(_WORD *)&v128[18] = 1040;
      *(_DWORD *)&v128[20] = v65;
      *(_WORD *)&v128[24] = 2101;
      *(_QWORD *)&v128[26] = v57;
      *(_WORD *)&v128[34] = 1024;
      *(_DWORD *)&v128[36] = v66;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "Removing cached peer record -- peer address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d", buf, 0x3Cu);
    }
LABEL_134:
    mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v54);
LABEL_135:
    v54 = *(_QWORD *)v54;
    if (!v54)
      goto LABEL_136;
  }
  v55 = mDNSLogCategory_D2D_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_INFO))
    goto LABEL_134;
  v57 = *(_QWORD *)(v54 + 40);
  if (v57)
  {
    v62 = *(_BYTE **)(v54 + 40);
    if (v57 == -256)
      goto LABEL_120;
LABEL_117:
    v63 = 257;
    if ((unint64_t)v62 < v57 + 256 && v62)
    {
      while (1)
      {
        v64 = *v62;
        if (v64 > 0x3F)
        {
LABEL_128:
          v63 = 257;
          goto LABEL_132;
        }
        if (!*v62)
          break;
        v62 += v64 + 1;
        if (v57 != -256)
          goto LABEL_117;
LABEL_120:
        if (!v62)
          goto LABEL_128;
      }
      v63 = (_WORD)v62 - v57 + 1;
    }
LABEL_132:
    v65 = v63;
  }
  else
  {
    v65 = 0;
  }
  goto LABEL_133;
}

xpc_object_t mrc_xpc_create_reply(void *a1, int a2, void *a3)
{
  xpc_object_t reply;
  uint64_t uint64;

  reply = xpc_dictionary_create_reply(a1);
  if (reply)
  {
    uint64 = xpc_dictionary_get_uint64(a1, "id");
    xpc_dictionary_set_uint64(reply, "id", uint64);
    xpc_dictionary_set_int64(reply, "error", a2);
    if (a3)
      xpc_dictionary_set_value(reply, "result", a3);
  }
  return reply;
}

void *mrc_xpc_dns_proxy_params_get_output_interface(void *a1, BOOL *a2)
{
  xpc_object_t value;
  void *uint64_limited;
  BOOL v6;
  xpc_object_t v7;
  BOOL v9;

  v9 = 0;
  value = xpc_dictionary_get_value(a1, "output_interface");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v9);
  if (a2)
  {
    if (v9)
    {
      v6 = 1;
    }
    else
    {
      v7 = xpc_dictionary_get_value(a1, "output_interface");
      v6 = v9;
      if (!v7)
        v6 = 1;
    }
    *a2 = v6;
  }
  return uint64_limited;
}

const char *mrc_xpc_dns_proxy_params_get_nat64_prefix(void *a1, _QWORD *a2)
{
  xpc_object_t value;
  void *uint64_limited;
  const char *result;
  size_t v7;
  BOOL v8;

  v8 = 0;
  value = xpc_dictionary_get_value(a1, "nat64_prefix.bit_len");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, &v8);
  result = 0;
  if (!v8 || (unint64_t)uint64_limited > 0x80)
    return result;
  if (!uint64_limited)
  {
    result = "";
    if (!a2)
      return result;
    goto LABEL_9;
  }
  v7 = 0;
  result = (const char *)xpc_dictionary_get_data(a1, "nat64_prefix.bits", &v7);
  if (!result || v7 < ((unint64_t)uint64_limited + 7) >> 3)
    return 0;
  if (a2)
LABEL_9:
    *a2 = uint64_limited;
  return result;
}

BOOL mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(void *a1, BOOL *a2)
{
  xpc_object_t object;
  void *v5;
  BOOL v6;

  object = _mdns_xpc_dictionary_get_object(a1, "force_aaaa_synth", (const _xpc_type_s *)&_xpc_type_BOOL);
  v5 = object;
  if (a2)
  {
    if (object)
      v6 = 1;
    else
      v6 = xpc_dictionary_get_value(a1, "force_aaaa_synth") == 0;
    *a2 = v6;
  }
  return v5 == &_xpc_BOOL_true;
}

uint64_t mrc_xpc_dns_service_registration_params_get_definition_type(void *a1, BOOL *a2)
{
  xpc_object_t value;
  uint64_t result;
  BOOL v6;
  BOOL v7;

  v7 = 0;
  value = xpc_dictionary_get_value(a1, "definition_type");
  result = _mdns_xpc_object_get_uint64_limited(value, 0xFFuLL, &v7);
  if (a2)
  {
    v6 = v7 && (result - 1) < 2;
    *a2 = v6;
  }
  return result;
}

void *mrc_xpc_discovery_proxy_params_get_interface(void *a1, BOOL *a2)
{
  xpc_object_t value;

  value = xpc_dictionary_get_value(a1, "interface");
  return _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, a2);
}

uint64_t mrc_xpc_record_cache_flush_params_get_key_tag(void *a1, BOOL *a2)
{
  xpc_object_t value;

  value = xpc_dictionary_get_value(a1, "key_tag");
  return (unsigned __int16)_mdns_xpc_object_get_uint64_limited(value, 0xFFFFuLL, a2);
}

void *_mdns_dns_push_service_definition_copy_description(uint64_t a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t (*v12)(void);
  char *v13;
  const char *v14;
  const __CFSet *v15;
  _QWORD v17[6];
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
  {
    v8 = 0;
    goto LABEL_28;
  }
  v7 = v6;
  if (a2
    && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1))
  {
    goto LABEL_4;
  }
  v9 = *(const char **)(a1 + 64);
  if (!v9)
    v9 = "";
  if (mdns_string_builder_append_formatted(v7, "interface: %s/%u", v9, *(_DWORD *)(a1 + 72))
    || mdns_string_builder_append_formatted(v7, ", hostname: "))
  {
LABEL_4:
    v8 = 0;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 32);
    if (v10)
    {
      if (a3)
      {
        v11 = (_QWORD *)(v10 + 16);
        while (1)
        {
          v11 = (_QWORD *)*v11;
          if (!v11)
            break;
          v12 = (uint64_t (*)(void))v11[3];
          if (v12)
          {
            v13 = (char *)v12();
            goto LABEL_18;
          }
        }
        v13 = 0;
LABEL_18:
        v14 = "REDACTED";
        if (v13)
          v14 = v13;
      }
      else
      {
        v13 = 0;
        v14 = *(const char **)(v10 + 40);
      }
    }
    else
    {
      v13 = 0;
      v14 = "NO HOSTNAME";
    }
    if (mdns_string_builder_append_formatted(v7, "%s", v14))
      goto LABEL_29;
    if (mdns_string_builder_append_formatted(v7, ", port: %u", *(unsigned __int16 *)(a1 + 76)))
      goto LABEL_29;
    if (mdns_string_builder_append_formatted(v7, ", domains: {"))
      goto LABEL_29;
    v20[3] = (uint64_t)"";
    v15 = *(const __CFSet **)(a1 + 48);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___mdns_dns_push_service_definition_copy_description_block_invoke;
    v17[3] = &unk_100139B10;
    v18 = a3;
    v17[4] = &v19;
    v17[5] = v7;
    if (!mdns_cfset_enumerate(v15, (uint64_t)v17) || mdns_string_builder_append_formatted(v7, "}"))
    {
LABEL_29:
      v8 = 0;
      if (!v13)
        goto LABEL_27;
      goto LABEL_26;
    }
    v8 = mdns_string_builder_copy_string((uint64_t)v7);
    if (v13)
LABEL_26:
      free(v13);
  }
LABEL_27:
  os_release(v7);
LABEL_28:
  _Block_object_dispose(&v19, 8);
  return v8;
}

void _mdns_dns_push_service_definition_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  void *v7;

  v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    os_release(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0;
  }
  v7 = (void *)a1[8];
  if (v7)
  {
    free(v7);
    a1[8] = 0;
  }
}

BOOL ___mdns_dns_push_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t (*v4)(uint64_t, _QWORD, uint64_t);
  char *v5;
  const char *v6;
  int appended;
  _BOOL8 result;

  if (*(_BYTE *)(a1 + 48))
  {
    v3 = (_QWORD *)(a2 + 16);
    while (1)
    {
      v3 = (_QWORD *)*v3;
      if (!v3)
        break;
      v4 = (uint64_t (*)(uint64_t, _QWORD, uint64_t))v3[3];
      if (v4)
      {
        v5 = (char *)v4(a2, 0, 1);
        goto LABEL_8;
      }
    }
    v5 = 0;
LABEL_8:
    v6 = "REDACTED";
    if (v5)
      v6 = v5;
  }
  else
  {
    v5 = 0;
    v6 = *(const char **)(a2 + 40);
  }
  appended = mdns_string_builder_append_formatted(*(_QWORD **)(a1 + 40), "%s%s", *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v6);
  if (v5)
    free(v5);
  result = appended == 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = ", ";
  return result;
}

_QWORD *mdns_dns_push_service_definition_create()
{
  uint64_t v0;
  _QWORD *v1;
  _UNKNOWN **v2;
  void (*v3)(_QWORD *);
  CFMutableArrayRef Mutable;
  CFMutableSetRef v5;
  CFMutableArrayRef v6;

  v0 = _os_object_alloc(OS_mdns_dns_push_service_definition, 88);
  v1 = (_QWORD *)v0;
  if (v0)
  {
    v2 = &_mdns_dns_push_service_definition_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_dns_push_service_definition_kind;
    do
    {
      v3 = (void (*)(_QWORD *))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[5] = Mutable;
    if (!Mutable
      || (v5 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[6] = v5) == 0)
      || (v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks), (v1[7] = v6) == 0))
    {
      os_release(v1);
      return 0;
    }
  }
  return v1;
}

uint64_t mdns_dns_push_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  _QWORD *v4;
  uint64_t v5;
  char *string;
  _QWORD *v7;
  int v8;
  void *v9;
  xpc_object_t optional_array;
  void *v11;
  size_t count;
  size_t v13;
  size_t v14;
  char *v15;
  void *v16;
  void *v17;
  xpc_object_t v18;
  void *v19;
  size_t v20;
  size_t v21;
  size_t v22;
  char *v23;
  _QWORD *v24;
  void *v25;
  xpc_object_t v26;
  void *v27;
  size_t v28;
  size_t v29;
  size_t v30;
  const UInt8 *data;
  CFDataRef v32;
  CFDataRef v33;
  xpc_object_t value;
  unsigned int uint64_limited;
  unsigned int v36;
  xpc_object_t v37;
  unsigned int v38;
  BOOL v39;
  BOOL v40;
  xpc_object_t v41;
  unsigned __int16 v42;
  xpc_object_t object;
  xpc_object_t v44;
  void *v45;
  BOOL v47;
  size_t length;
  int v49;
  BOOL v50;

  v49 = 0;
  v4 = mdns_dns_push_service_definition_create();
  v5 = (uint64_t)v4;
  if (!v4)
  {
    v8 = -6729;
    v49 = -6729;
    if (!a2)
      goto LABEL_45;
LABEL_44:
    *a2 = v8;
    goto LABEL_45;
  }
  string = (char *)xpc_dictionary_get_string(a1, "srv_name");
  if (string)
  {
    v7 = mdns_domain_name_create(string, &v49);
    v8 = v49;
    if (v49)
      goto LABEL_43;
    v9 = v7;
    mdns_dns_push_service_definition_set_srv_name(v5, v7);
    if (v9)
      os_release(v9);
  }
  optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (optional_array)
  {
    v11 = optional_array;
    count = xpc_array_get_count(optional_array);
    if (count)
    {
      v13 = count;
      v14 = 0;
      do
      {
        v15 = (char *)xpc_array_get_string(v11, v14);
        if (!v15)
          goto LABEL_41;
        v16 = (void *)mdns_address_create_from_ip_address_string(v15);
        if (!v16)
          goto LABEL_41;
        v17 = v16;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 40), v16);
        os_release(v17);
      }
      while (v13 != ++v14);
    }
  }
  v18 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
  if (v18)
  {
    v19 = v18;
    v20 = xpc_array_get_count(v18);
    if (v20)
    {
      v21 = v20;
      v22 = 0;
      do
      {
        v23 = (char *)xpc_array_get_string(v19, v22);
        if (!v23)
          goto LABEL_41;
        v24 = mdns_domain_name_create(v23, &v49);
        v8 = v49;
        if (v49)
          goto LABEL_43;
        v25 = v24;
        CFSetAddValue(*(CFMutableSetRef *)(v5 + 48), v24);
        if (v25)
          os_release(v25);
      }
      while (v21 != ++v22);
    }
  }
  v26 = mdns_xpc_dictionary_get_optional_array(a1, "certificates");
  if (v26)
  {
    v27 = v26;
    v28 = xpc_array_get_count(v26);
    if (v28)
    {
      v29 = v28;
      v30 = 0;
      do
      {
        length = 0;
        data = (const UInt8 *)xpc_array_get_data(v27, v30, &length);
        if (!data)
          goto LABEL_41;
        v32 = CFDataCreate(kCFAllocatorDefault, data, length);
        if (!v32)
        {
          v8 = -6729;
          goto LABEL_42;
        }
        v33 = v32;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 56), v32);
        CFRelease(v33);
      }
      while (v29 != ++v30);
    }
  }
  v47 = 0;
  value = xpc_dictionary_get_value(a1, "ifindex");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v47);
  if (!v47)
    goto LABEL_41;
  v36 = uint64_limited;
  v47 = 0;
  v50 = 0;
  v37 = xpc_dictionary_get_value(a1, "interface_scope");
  v38 = _mdns_xpc_object_get_uint64_limited(v37, 0xFFuLL, &v50);
  v39 = !v50 || v38 >= 3;
  v40 = !v39;
  v47 = v40;
  if (v39)
    goto LABEL_41;
  mdns_dns_push_service_definition_set_interface_index(v5, v36, v38);
  v47 = 0;
  v41 = xpc_dictionary_get_value(a1, "port");
  v42 = (unsigned __int16)_mdns_xpc_object_get_uint64_limited(v41, 0xFFFFuLL, &v47);
  if (!v47)
    goto LABEL_41;
  *(_WORD *)(v5 + 76) = v42;
  v47 = 0;
  object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
  v47 = object != 0;
  if (!object
    || (*(_BYTE *)(v5 + 79) = object == &_xpc_BOOL_true,
        v47 = 0,
        v44 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL),
        v47 = v44 != 0,
        !v44))
  {
LABEL_41:
    v8 = -6705;
LABEL_42:
    v49 = v8;
LABEL_43:
    v4 = (_QWORD *)v5;
    v5 = 0;
    if (!a2)
      goto LABEL_45;
    goto LABEL_44;
  }
  v45 = v44;
  v8 = 0;
  v4 = 0;
  *(_BYTE *)(v5 + 80) = v45 == &_xpc_BOOL_true;
  v49 = 0;
  if (a2)
    goto LABEL_44;
LABEL_45:
  if (v4)
    os_release(v4);
  return v5;
}

void mdns_dns_push_service_definition_set_srv_name(uint64_t a1, void *object)
{
  void *v4;

  if (object)
    os_retain(object);
  v4 = *(void **)(a1 + 24);
  if (v4)
    os_release(v4);
  *(_QWORD *)(a1 + 24) = object;
}

void mdns_dns_push_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  void *v4;

  *(_BYTE *)(a1 + 78) = a3;
  if (*(_DWORD *)(a1 + 72) != a2)
  {
    *(_DWORD *)(a1 + 72) = a2;
    v4 = *(void **)(a1 + 64);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(a1 + 64) = 0;
      a2 = *(_DWORD *)(a1 + 72);
    }
  }
  if (a2)
  {
    if (!*(_QWORD *)(a1 + 64))
      *(_QWORD *)(a1 + 64) = mdns_system_interface_index_to_name(a2);
  }
  else
  {
    *(_BYTE *)(a1 + 78) = 0;
  }
}

void *_dnssec_obj_rr_ds_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  void *v4;
  char *v5;
  size_t v6;
  char *v7;
  int v8;
  char *v9;
  char *v10;
  unsigned __int8 *v11;
  unsigned int digest_length;
  char *v13;
  _BOOL4 v14;
  int v15;

  v4 = (void *)snprintf(0, 0, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 2), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3));
  v5 = (char *)v4 + 2 * rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
  v6 = (size_t)(v5 + 1);
  if (v5 == (char *)-1 || (v7 = (char *)malloc_type_calloc(1uLL, (size_t)(v5 + 1), 0xF1748037uLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    v4 = v7;
    v8 = snprintf(v7, v6, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 2), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3));
    if (v8 >= 1)
    {
      v9 = (char *)v4 + v6;
      v10 = (char *)v4 + v8;
      v11 = (unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 4);
      digest_length = rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
      v13 = put_hex_from_bytes(v11, digest_length, v10, v9 - v10);
      v14 = v13 == v10;
      if (v13 == v10)
        v15 = -6751;
      else
        v15 = 0;
      if (!a2)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  v15 = -6700;
  v14 = 1;
  if (a2)
LABEL_8:
    *a2 = v15;
LABEL_9:
  if (v14)
  {
    free(v4);
    return 0;
  }
  return v4;
}

_QWORD *dnssec_obj_rr_ds_create(unsigned __int8 *a1, __int16 a2, const void *a3, unsigned int a4, int a5, int *a6)
{
  _QWORD *v6;
  _QWORD *v13;
  int v14;
  _UNKNOWN **v15;
  void (*v16)(_QWORD *);
  _QWORD *v17;
  int v19;

  v19 = 0;
  if (a4 <= 4)
  {
    v6 = 0;
    v17 = 0;
    v14 = -6705;
    v19 = -6705;
  }
  else
  {
    v13 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
    if (v13)
    {
      v6 = v13;
      v15 = &_dnssec_obj_rr_ds_kind;
      v13[1] = &_dnssec_obj_rr_ds_kind;
      do
      {
        v16 = (void (*)(_QWORD *))v15[2];
        if (v16)
          v16(v6);
        v15 = (_UNKNOWN **)*v15;
      }
      while (v15);
      ++*(_DWORD *)v6;
      dnssec_obj_rr_init_fields((uint64_t)v6, a1, 43, a2, a3, a4, a5, (uint64_t)_dnssec_obj_rr_ds_copy_rdata_rfc_description, &v19);
      v14 = v19;
      if (!v19)
      {
        ++*(_DWORD *)v6;
        v19 = 0;
        v17 = v6;
        goto LABEL_9;
      }
    }
    else
    {
      __break(1u);
    }
    v17 = 0;
  }
LABEL_9:
  if (a6)
    *a6 = v14;
  if (v6)
    ref_count_obj_release(v6);
  return v17;
}

uint64_t dnssec_obj_rr_ds_validates_dnskey(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned __int16 *v4;
  int v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  _BYTE *v13;
  uint64_t result;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  size_t OutputSize;
  int v23;
  _OWORD __s2[4];
  _BYTE v25[1032];

  v4 = *(unsigned __int16 **)(a1 + 24);
  if (*(unsigned __int16 *)(a2 + 80) != bswap32(*v4) >> 16)
  {
    result = 0;
    v6 = -88989;
    goto LABEL_33;
  }
  v5 = *((unsigned __int8 *)v4 + 2);
  v6 = -88890;
  if ((v5 - 5) > 0xB || ((0xD2uLL >> (v5 - 5)) & 1) != 0)
  {
LABEL_32:
    result = 0;
LABEL_33:
    v23 = v6;
    goto LABEL_34;
  }
  v7 = *((unsigned __int8 *)v4 + 3);
  v8 = v7 > 4;
  v9 = (1 << v7) & 0x16;
  if (v8 || v9 == 0)
  {
    v6 = -88988;
    goto LABEL_32;
  }
  v23 = 0;
  v13 = *(_BYTE **)(a2 + 24);
  result = dnssec_obj_rr_dnskey_is_valid_for_dnssec(v13, &v23);
  if (!(_DWORD)result)
    goto LABEL_34;
  if (v5 != v13[3])
  {
    result = 0;
    v6 = -88990;
    goto LABEL_33;
  }
  if (ref_count_obj_compare(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16), 1))
  {
    result = 0;
    v6 = -88991;
    goto LABEL_33;
  }
  memset(__s2, 0, sizeof(__s2));
  v15 = -88988;
  if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3) - 1 > 3
    || *(_BYTE *)(*(_QWORD *)(a1 + 24) + 3) == 3
    || (v16 = dword_1001009F0[(unsigned __int16)(*(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3) - 1)],
        bzero(v25, 0x408uLL),
        v17 = dword_100100A20[v16 - 1],
        v15 = -6700,
        CCDigestInit(v17, v25)))
  {
    result = 0;
    v23 = v15;
    goto LABEL_34;
  }
  v18 = CCDigestUpdate(v25, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16), *(_QWORD *)(*(_QWORD *)(a2 + 16) + 24));
  if (v18)
    v19 = -6700;
  else
    v19 = 0;
  if (v18
    || ((v20 = CCDigestUpdate(v25, *(_QWORD *)(a2 + 24), *(unsigned __int16 *)(a2 + 36))) != 0
      ? (v19 = -6700)
      : (v19 = 0),
        v20 || ((v21 = CCDigestFinal(v25, __s2)) != 0 ? (v19 = -6700) : (v19 = 0), v21)))
  {
    v23 = v19;
    if (v19)
    {
      result = 0;
      goto LABEL_34;
    }
    OutputSize = 0;
  }
  else
  {
    OutputSize = CCDigestGetOutputSize(v17);
    v23 = 0;
  }
  if (OutputSize == rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36))
    && !memcmp((const void *)(*(_QWORD *)(a1 + 24) + 4), __s2, OutputSize))
  {
    v23 = 0;
    result = 1;
  }
  else
  {
    result = 0;
    v23 = -88992;
  }
LABEL_34:
  if (a3)
    *a3 = v23;
  return result;
}

void *mdns_cf_callback_retain(int a1, void *object)
{
  os_retain(object);
  return object;
}

void mdns_cf_callback_release(int a1, void *object)
{
  os_release(object);
}

const char *mdns_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

uint64_t mdns_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v4)(uint64_t, uint64_t);

  if (a1 == a2)
    return 1;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 == *(_QWORD *)(a2 + 16) && (v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 32)) != 0)
    return v4(a1, a2);
  else
    return 0;
}

BOOL mdns_cfarray_enumerate(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  BOOL v6;
  CFIndex i;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
    return 1;
  }
  else
  {
    v5 = Count;
    v6 = 0;
    for (i = 0; i != v5; v6 = i >= v5)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      if (((*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex) & 1) == 0)
        break;
      ++i;
    }
  }
  return v6;
}

BOOL mdns_cfset_enumerate(const __CFSet *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  void **v6;
  uint64_t v8;
  char v9;
  _BYTE v10[7];
  void *values[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;

  Count = CFSetGetCount(a1);
  if (Count < 1)
    return 1;
  v5 = Count;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)values = 0u;
  v12 = 0u;
  if ((unint64_t)Count <= 0x40)
  {
    v6 = values;
    CFSetGetValues(a1, (const void **)values);
    while (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) != 0)
    {
      ++v6;
      if (!--v5)
        return 1;
    }
    return 0;
  }
  v8 = a2;
  v9 = 1;
  memset(v10, 0, sizeof(v10));
  CFSetApplyFunction(a1, (CFSetApplierFunction)_mdns_cf_applier_function, &v8);
  return v9 != 0;
}

void _mdns_cf_applier_function(uint64_t a1, _BYTE *a2)
{
  if (a2[8])
    a2[8] = (*(uint64_t (**)(void))(*(_QWORD *)a2 + 16))();
}

void mdns_cfbag_enumerate(const __CFBag *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  void **v6;
  uint64_t v7;
  char v8;
  _BYTE v9[7];
  void *values[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  Count = CFBagGetCount(a1);
  if (Count >= 1)
  {
    v5 = Count;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    *(_OWORD *)values = 0u;
    v11 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      v7 = a2;
      v8 = 1;
      memset(v9, 0, sizeof(v9));
      CFBagApplyFunction(a1, (CFBagApplierFunction)_mdns_cf_applier_function, &v7);
    }
    else
    {
      v6 = values;
      CFBagGetValues(a1, (const void **)values);
      do
      {
        if (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) == 0)
          break;
        ++v6;
        --v5;
      }
      while (v5);
    }
  }
}

void mdns_cfdictionary_apply(const __CFDictionary *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  void **v6;
  void **v7;
  uint64_t v8;
  char v9;
  _BYTE v10[7];
  void *values[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  void *keys[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;

  Count = CFDictionaryGetCount(a1);
  if (Count >= 1)
  {
    v5 = Count;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    *(_OWORD *)keys = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    *(_OWORD *)values = 0u;
    v12 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      v8 = a2;
      v9 = 1;
      memset(v10, 0, sizeof(v10));
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)_mdns_cfdictionary_applier_function, &v8);
    }
    else
    {
      v6 = keys;
      v7 = values;
      CFDictionaryGetKeysAndValues(a1, (const void **)keys, (const void **)values);
      do
      {
        if (((*(uint64_t (**)(uint64_t, void *, void *))(a2 + 16))(a2, *v6, *v7) & 1) == 0)
          break;
        ++v7;
        ++v6;
        --v5;
      }
      while (v5);
    }
  }
}

void _mdns_cfdictionary_applier_function(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (a3[8])
    a3[8] = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
}

BOOL mdns_odoh_config_is_valid_inner(unsigned __int16 *a1, unint64_t a2)
{
  uint64_t v3;
  _BOOL8 result;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _QWORD v18[2];

  if (a1)
  {
    if (a2 > 0xB)
    {
      v10 = *a1;
      if (v10 == 256 || v10 == 1791)
      {
        v11 = bswap32(a1[1]) >> 16;
        if (v11 + 4 > a2)
        {
          if (_mdns_crypto_log_s_once != -1)
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
          v12 = _mdns_crypto_log_s_log;
          result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            v17 = 67109120;
            LODWORD(v18[0]) = v11;
            v5 = "Config length field is too large: %hu";
            v6 = v12;
            v7 = 8;
            goto LABEL_31;
          }
          return result;
        }
        if ((bswap32(a1[5]) >> 16) + 8 != v11)
        {
          if (_mdns_crypto_log_s_once != -1)
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
          v15 = _mdns_crypto_log_s_log;
          result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            v16 = (bswap32(a1[5]) >> 16) + 8;
            v17 = 67109376;
            LODWORD(v18[0]) = v11;
            WORD2(v18[0]) = 2048;
            *(_QWORD *)((char *)v18 + 6) = v16;
            v5 = "Config length does not match: %hu != %zu";
            v6 = v15;
            v7 = 18;
            goto LABEL_31;
          }
          return result;
        }
        if (a1[2] == 0x2000 && a1[3] == 256 && a1[4] == 256)
          return 1;
        if (_mdns_crypto_log_s_once != -1)
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
        v13 = _mdns_crypto_log_s_log;
        result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result)
          return result;
        LOWORD(v17) = 0;
        v14 = "Config details are not supported";
      }
      else
      {
        if (_mdns_crypto_log_s_once != -1)
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
        v13 = _mdns_crypto_log_s_log;
        result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result)
          return result;
        LOWORD(v17) = 0;
        v14 = "Config version is not supported";
      }
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v14, (uint8_t *)&v17, 2u);
      return 0;
    }
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v3 = _mdns_crypto_log_s_log;
    result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v17 = 134217984;
      v18[0] = a2;
      v5 = "Config length is too short: %zu";
      v6 = v3;
      v7 = 12;
LABEL_31:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v17, v7);
      return 0;
    }
  }
  else
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v8 = _mdns_crypto_log_s_log;
    result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(v17) = 0;
      v5 = "Config is NULL";
      v6 = v8;
      v7 = 2;
      goto LABEL_31;
    }
  }
  return result;
}

uint64_t __mdns_encrypt_oblivious_request_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  memcpy((void *)(*(_QWORD *)(a1 + 32) + a3), __src, __n);
  return 1;
}

void ___mdns_crypto_log_block_invoke(id a1)
{
  _mdns_crypto_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "crypto");
}

dispatch_data_t mdns_decrypt_oblivious_response(NSObject *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  _BOOL8 v17;
  unsigned int v18;
  size_t v19;
  unsigned __int8 *v20;
  unsigned __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  NSObject *v29;
  const char *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  char *v34;
  char *v35;
  void *v36;
  void *v37;
  NSObject *v38;
  void *v39;
  void *v40;
  int v41;
  NSObject *v42;
  void *v43;
  void *v44;
  int v45;
  int v46;
  NSObject *v47;
  size_t v48;
  size_t v49;
  void *v50;
  void *v51;
  int v52;
  NSObject *v53;
  void *v54;
  unsigned __int16 *v56;
  unsigned __int16 *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  const char *v61;
  NSObject *v62;
  uint32_t v63;
  size_t v64;
  uint64_t v65;
  dispatch_data_t v66;
  unsigned __int16 *v67;
  size_t v68;
  size_t v69;
  size_t v70;
  uint64_t v71;
  size_t v72;
  size_t size;
  _QWORD applier[5];
  uint8_t buf[4];
  unint64_t v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  _BYTE v80[18];

  if (!a2 || !a3 || !a4)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v29 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_WORD *)buf = 0;
    v30 = "Parameters are invalid";
    goto LABEL_21;
  }
  v9 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  v10 = cchpke_params_sizeof_kdf_hash();
  v11 = cchpke_params_sizeof_aead_tag(v9);
  v12 = cchpke_params_sizeof_aead_key(v9);
  v13 = dispatch_data_get_size(a1);
  if (v13 <= v11 + 5)
  {
    if (_mdns_crypto_log_s_once == -1)
    {
LABEL_19:
      v29 = _mdns_crypto_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
        return 0;
      *(_WORD *)buf = 0;
      v30 = "Invalid encrypted response length";
LABEL_21:
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v30, buf, 2u);
      return 0;
    }
LABEL_80:
    dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    goto LABEL_19;
  }
  v14 = v13;
  v15 = (unsigned __int8 *)malloc_type_calloc(1uLL, v13, 0xF1748037uLL);
  if (!v15)
  {
LABEL_79:
    __break(1u);
    goto LABEL_80;
  }
  v16 = v15;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = __mdns_decrypt_oblivious_response_block_invoke;
  applier[3] = &__block_descriptor_tmp_3;
  applier[4] = v15;
  v17 = dispatch_data_apply(a1, applier);
  if (*v16 != 2)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v31 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_70;
    v32 = *v16;
    *(_DWORD *)buf = 67109120;
    LODWORD(v76) = v32;
    v26 = "Invalid message type %u";
LABEL_30:
    v27 = v31;
    v28 = 8;
LABEL_31:
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v26, buf, v28);
LABEL_70:
    v54 = v16;
LABEL_71:
    free(v54);
    return 0;
  }
  size = v12;
  v18 = *(unsigned __int16 *)(v16 + 1);
  v19 = __rev16(v18);
  if (v14 <= v19 + 5 + v11)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v31 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_70;
    *(_DWORD *)buf = 67109120;
    LODWORD(v76) = v19;
    v26 = "Invalid response nonce length %hu";
    goto LABEL_30;
  }
  v72 = v10;
  v20 = &v16[v19 + 3];
  v22 = *(unsigned __int16 *)v20;
  v21 = (unsigned __int16 *)(v20 + 2);
  v23 = bswap32(v22) >> 16;
  if (v14 != v19 + 5 + v23)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v33 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_70;
    *(_DWORD *)buf = 134218752;
    v76 = v14;
    v77 = 2048;
    v78 = v19 + 3;
    v79 = 2048;
    *(_QWORD *)v80 = 2;
    *(_WORD *)&v80[8] = 2048;
    *(_QWORD *)&v80[10] = v23;
    v26 = "Invalid ciphertext length: %zu != %zu + %zu + %zu";
    v27 = v33;
    v28 = 42;
    goto LABEL_31;
  }
  v24 = v23 - v11;
  if (v24 <= 3)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v25 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_70;
    *(_DWORD *)buf = 134217984;
    v76 = v24;
    v26 = "Invalid plaintext length: %zu";
    v27 = v25;
    v28 = 12;
    goto LABEL_31;
  }
  v67 = v21;
  v68 = v19 + 3;
  v71 = ccsha256_di(v17);
  if (a5 + v19 == -2)
    goto LABEL_79;
  v69 = v24;
  v70 = a5 + v19 + 2;
  v34 = (char *)malloc_type_calloc(1uLL, v70, 0xF1748037uLL);
  if (!v34)
    goto LABEL_79;
  v35 = v34;
  memcpy(v34, a4, a5);
  *(_WORD *)&v35[a5] = v18;
  memcpy(&v35[a5 + 2], v16 + 3, v19);
  if (!size)
    goto LABEL_79;
  v36 = malloc_type_calloc(1uLL, size, 0xF1748037uLL);
  if (!v36)
    goto LABEL_79;
  v37 = v36;
  if (cchpke_initiator_export(a2, 13, "odoh response", size, v36))
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v38 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "cchpke_initiator_export failed", buf, 2u);
    }
    free(v37);
    v39 = v35;
LABEL_69:
    free(v39);
    goto LABEL_70;
  }
  if (!v72)
    goto LABEL_79;
  v40 = malloc_type_calloc(1uLL, v72, 0xF1748037uLL);
  if (!v40)
    goto LABEL_79;
  v41 = cchkdf_extract(v71, v70, v35, size, v37, v40);
  free(v37);
  free(v35);
  if (v41)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v42 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v76) = v41;
      _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Secret extract error: %d", buf, 8u);
    }
    v39 = v40;
    goto LABEL_69;
  }
  v43 = malloc_type_calloc(1uLL, size, 0xF1748037uLL);
  if (!v43)
    goto LABEL_79;
  v44 = v43;
  v45 = cchkdf_expand(v71, v72, v40, 8, "odoh key", size, v43);
  if (v45)
  {
    v46 = v45;
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v47 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v76) = v46;
      _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Secret key expand error: %d", buf, 8u);
    }
    free(v40);
    v39 = v44;
    goto LABEL_69;
  }
  v48 = cchpke_params_sizeof_aead_nonce(v9);
  if (!v48)
    goto LABEL_79;
  v49 = v48;
  v50 = malloc_type_calloc(1uLL, v48, 0xF1748037uLL);
  if (!v50)
    goto LABEL_79;
  v51 = v50;
  v52 = cchkdf_expand(v71, v72, v40, 10, "odoh nonce", v49, v50);
  free(v40);
  if (v52)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v53 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v76) = v52;
      _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Secret nonce expand error: %d", buf, 8u);
    }
    free(v44);
    v39 = v51;
    goto LABEL_69;
  }
  v56 = (unsigned __int16 *)malloc_type_calloc(1uLL, v69, 0xF1748037uLL);
  if (!v56)
    goto LABEL_79;
  v57 = v56;
  v58 = ccaes_gcm_decrypt_mode();
  v59 = ccgcm_one_shot(v58, size, v44, v49, v51, v68, v16, v69, v67, v57, v11, (char *)v67 + v69);
  free(v44);
  free(v51);
  free(v16);
  if (v59)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v60 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_87;
    *(_WORD *)buf = 0;
    v61 = "Decrypt error: decrypt_error";
    v62 = v60;
    v63 = 2;
LABEL_86:
    _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v61, buf, v63);
LABEL_87:
    v54 = v57;
    goto LABEL_71;
  }
  v64 = bswap32(*v57) >> 16;
  if (v69 < v64 + 4)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v65 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_87;
    *(_DWORD *)buf = 134218752;
    v76 = v69;
    v77 = 2048;
    v78 = 2;
    v79 = 1024;
    *(_DWORD *)v80 = v64;
    *(_WORD *)&v80[4] = 2048;
    *(_QWORD *)&v80[6] = 2;
    v61 = "Invalid plaintext length: %zu < %zu + %hu + %zu";
    v62 = v65;
    v63 = 38;
    goto LABEL_86;
  }
  v66 = dispatch_data_create(v57 + 1, v64, 0, 0);
  free(v57);
  return v66;
}

uint64_t __mdns_decrypt_oblivious_response_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  memcpy((void *)(*(_QWORD *)(a1 + 32) + a3), __src, __n);
  return 1;
}

void mdns_power_cancel_all_events(const void *a1)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  const __CFString *v9;
  const __CFDate *v10;
  const __CFString *v11;
  IOReturn v12;
  NSObject *v13;
  os_log_type_t v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const __CFString *v18;
  __int16 v19;
  const __CFString *v20;
  __int16 v21;
  const __CFDate *v22;

  v2 = IOPMCopyScheduledPowerEvents();
  if (v2)
  {
    v3 = v2;
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, i);
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("scheduledby"));
        if (Value)
        {
          v9 = Value;
          if (CFEqual(Value, a1))
          {
            v10 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, CFSTR("time"));
            v11 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("eventtype"));
            v12 = IOPMCancelScheduledPowerEvent(v10, v9, v11);
            if (_mdns_power_log_s_once != -1)
              dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_156);
            v13 = _mdns_power_log_s_log;
            if (v12)
              v14 = OS_LOG_TYPE_ERROR;
            else
              v14 = OS_LOG_TYPE_INFO;
            if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v14))
            {
              *(_DWORD *)buf = 134218754;
              v16 = v12;
              v17 = 2112;
              v18 = v9;
              v19 = 2112;
              v20 = v11;
              v21 = 2112;
              v22 = v10;
              _os_log_impl((void *)&_mh_execute_header, v13, v14, "IOPMCancelScheduledPowerEvent -- error: %{mdns:err}ld, id: %@, type: %@, time: %@", buf, 0x2Au);
            }
          }
        }
      }
    }
    CFRelease(v3);
  }
}

void ___mdns_power_log_block_invoke(id a1)
{
  _mdns_power_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "power");
}

uint64_t mdns_power_schedule_wake(int a1)
{
  CFAbsoluteTime Current;
  CFDateRef v3;
  CFDateRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  uint64_t v9;
  NSObject *v10;
  os_log_type_t v11;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  CFDictionaryRef v17;
  void *values[3];
  void *keys[2];
  const __CFString *v20;

  valuePtr = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(kCFAllocatorDefault, Current + (double)a1);
  if (!v3)
    return 4294960567;
  v4 = v3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v5)
  {
    v6 = v5;
    *(_OWORD *)keys = *(_OWORD *)&off_100139BF0;
    v20 = CFSTR("leeway");
    values[0] = CFSTR("com.apple.mDNSResponder");
    values[1] = v4;
    values[2] = v5;
    v7 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v7)
    {
      v8 = v7;
      v9 = IOPMRequestSysWake();
      if (_mdns_power_log_s_once != -1)
        dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_156);
      v10 = _mdns_power_log_s_log;
      if ((_DWORD)v9)
        v11 = OS_LOG_TYPE_ERROR;
      else
        v11 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v11))
      {
        *(_DWORD *)buf = 134218242;
        v15 = (int)v9;
        v16 = 2112;
        v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v10, v11, "IOPMRequestSysWake -- error: %{mdns:err}ld, request: %@", buf, 0x16u);
      }
      CFRelease(v8);
    }
    else
    {
      v9 = 4294960567;
    }
    CFRelease(v4);
  }
  else
  {
    v9 = 4294960567;
    v6 = v4;
  }
  CFRelease(v6);
  return v9;
}

char *_mdns_resource_record_copy_description(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v16;
  uint64_t v17;
  char __s1[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;

  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)__s1 = 0u;
  v19 = 0u;
  v16 = 0;
  v17 = 0;
  if (_mdns_resource_record_copy_description_bytes(a1, a2, a3, (uint64_t)__s1, 512, &v17, &v16, a8))
    return 0;
  if (v16 > 0x1FF)
  {
    v12 = v16 + 1;
    if (v16 == -1)
      goto LABEL_9;
    v13 = (char *)malloc_type_malloc(v16 + 1, 0xA172743EuLL);
    if (!v13)
      goto LABEL_9;
    v8 = v13;
    if (_mdns_resource_record_copy_description_bytes(a1, a2, a3, (uint64_t)v13, v12, 0, 0, v14))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

void _mdns_resource_record_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

uint64_t _mdns_resource_record_copy_description_bytes(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  const char *v18;
  unsigned int v19;
  uint64_t v20;
  void *v22;
  char *v23;

  v13 = 0;
  v22 = 0;
  v23 = (char *)a4;
  v14 = a4 + a5;
  if (a2)
  {
    v15 = mdns_snprintf_add(&v23, a4 + a5, "<%s: %p>: ", a4, a5, (uint64_t)a6, (uint64_t)a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8));
    if ((v15 & 0x80000000) != 0)
      goto LABEL_15;
    v13 = v15;
  }
  v16 = *(unsigned __int8 **)(a1 + 32);
  if (v16)
  {
    v17 = DNSRecordDataToStringEx(v16, *(unsigned __int16 *)(a1 + 56), *(unsigned __int16 *)(a1 + 52), 0, 0, a3, (uint64_t)&v22);
    if ((_DWORD)v17)
    {
      v20 = v17;
      goto LABEL_16;
    }
    v18 = (const char *)v22;
  }
  else
  {
    v18 = 0;
  }
  if (!v18)
    v18 = "<NO RDATA>";
  v19 = mdns_snprintf_add(&v23, v14, "%s", a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (char)v18);
  if ((v19 & 0x80000000) != 0)
  {
LABEL_15:
    v20 = 4294960596;
    goto LABEL_16;
  }
  if (a6)
    *a6 = &v23[-a4];
  v20 = 0;
  if (a7)
    *a7 = v13 + v19;
LABEL_16:
  if (v22)
    free(v22);
  return v20;
}

void *mdns_resource_record_create(void *a1, __int16 a2, __int16 a3, int a4, const void *a5, unsigned int a6)
{
  uint64_t v12;
  uint64_t v13;
  _UNKNOWN **v14;
  void (*v15)(uint64_t);
  void *result;
  void *v17;

  v12 = _os_object_alloc(OS_mdns_resource_record, 64);
  v13 = v12;
  if (!v12)
    return (void *)v13;
  v14 = &_mdns_resource_record_kind;
  *(_QWORD *)(v12 + 16) = &_mdns_resource_record_kind;
  do
  {
    v15 = (void (*)(uint64_t))v14[2];
    if (v15)
      v15(v13);
    v14 = (_UNKNOWN **)*v14;
  }
  while (v14);
  *(_QWORD *)(v13 + 24) = a1;
  os_retain(a1);
  *(_DWORD *)(v13 + 40) = a4;
  *(_DWORD *)(v13 + 44) = 0;
  *(_WORD *)(v13 + 52) = a2;
  *(_WORD *)(v13 + 54) = a3;
  *(_WORD *)(v13 + 56) = a6;
  if (!a6)
    return (void *)v13;
  result = malloc_type_malloc(a6, 0xA172743EuLL);
  if (result)
  {
    v17 = result;
    memcpy(result, a5, a6);
    *(_QWORD *)(v13 + 32) = v17;
    return (void *)v13;
  }
  __break(1u);
  return result;
}

void *_mdns_string_builder_copy_description(_QWORD *a1, int a2)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  size_t v9;
  void *result;

  v4 = (_QWORD *)mdns_string_builder_create();
  if (!v4)
    return 0;
  v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)
    || mdns_string_builder_append_formatted(v5, "capacity: %zu, string length: %zu", a1[4], a1[5]))
  {
    goto LABEL_4;
  }
  v7 = (const char *)v5[3];
  if (v7)
  {
    v8 = v5[5];
    v9 = v8 + 1;
    if (v8 == -1)
    {
LABEL_4:
      v6 = 0;
LABEL_12:
      os_release(v5);
      return v6;
    }
  }
  else
  {
    v7 = "";
    v9 = 1;
  }
  result = malloc_type_malloc(v9, 0xA172743EuLL);
  if (result)
  {
    v6 = result;
    memcpy(result, v7, v9);
    goto LABEL_12;
  }
  __break(1u);
  return result;
}

void _mdns_string_builder_finalize(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t mdns_string_builder_create()
{
  uint64_t v0;
  uint64_t v1;
  _UNKNOWN **v2;
  void (*v3)(uint64_t);

  v0 = _os_object_alloc(OS_mdns_string_builder, 48);
  v1 = v0;
  if (v0)
  {
    v2 = &_mdns_string_builder_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_string_builder_kind;
    do
    {
      v3 = (void (*)(uint64_t))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    *(_QWORD *)(v1 + 32) = 0;
  }
  return v1;
}

uint64_t mdns_string_builder_append_formatted(_QWORD *a1, char *__format, ...)
{
  uint64_t result;
  char i;
  size_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  va_list va;

  va_start(va, __format);
  if (a1[3] || (result = _mdns_string_builder_grow_buffer(a1, a1[4]), !(_DWORD)result))
  {
    for (i = 1; ; i = 0)
    {
      v6 = a1[4] - a1[5];
      v7 = vsnprintf((char *)(a1[3] + a1[5]), v6, __format, va);
      if ((v7 & 0x80000000) != 0)
      {
        *(_BYTE *)(a1[3] + a1[5]) = 0;
        return 4294960596;
      }
      v8 = v7;
      if (v6 > v7)
      {
        result = 0;
        a1[5] += v8;
        return result;
      }
      if ((i & 1) == 0)
        break;
      v9 = a1[5];
      v10 = v7 + 1;
      v11 = __CFADD__(v9, v10);
      v12 = v9 + v10;
      if (v11)
        return 4294960567;
      v13 = a1[4];
      if (v13 < 0)
        return 4294960567;
      if (v12 <= 2 * v13)
        v14 = 2 * v13;
      else
        v14 = v12;
      result = _mdns_string_builder_grow_buffer(a1, v14);
      if ((_DWORD)result)
        return result;
    }
    return 4294960534;
  }
  return result;
}

uint64_t _mdns_string_builder_grow_buffer(_QWORD *a1, unint64_t a2)
{
  size_t v3;
  size_t v4;
  size_t v5;
  void *v6;
  void *v7;
  const void *v8;
  void *v9;
  uint64_t result;

  if (a1[3] && a1[4] >= a2)
    return 0;
  if (a2 <= 0x40)
    v3 = 64;
  else
    v3 = a2;
  v4 = malloc_good_size(v3);
  if (v4 < v3)
    return 4294960534;
  v5 = v4;
  v6 = malloc_type_calloc(v4, 1uLL, 0xF1748037uLL);
  if (!v6)
  {
    __break(1u);
    return 0;
  }
  v7 = v6;
  v8 = (const void *)a1[3];
  if (v8)
  {
    memcpy(v6, v8, a1[5] + 1);
    v9 = (void *)a1[3];
    if (v9)
      free(v9);
  }
  result = 0;
  a1[3] = v7;
  a1[4] = v5;
  return result;
}

uint64_t mdns_string_builder_append_description(_QWORD *a1, uint64_t a2, char a3)
{
  _QWORD *v4;
  uint64_t (*v5)(uint64_t, _QWORD, _QWORD);
  const char *v6;
  char *v7;
  uint64_t appended;

  v4 = (_QWORD *)(a2 + 16);
  while (1)
  {
    v4 = (_QWORD *)*v4;
    if (!v4)
      break;
    v5 = (uint64_t (*)(uint64_t, _QWORD, _QWORD))v4[3];
    if (v5)
    {
      v6 = (const char *)v5(a2, 0, a3 & 1);
      if (v6)
      {
        v7 = (char *)v6;
        appended = mdns_string_builder_append_formatted(a1, "%s", v6);
        free(v7);
        return appended;
      }
      return 4294960567;
    }
  }
  return 4294960567;
}

uint64_t mdns_string_builder_append_description_with_prefix(_QWORD *a1, const char *a2, uint64_t a3, char a4)
{
  uint64_t result;

  if (!a2)
    return mdns_string_builder_append_description(a1, a3, a4);
  result = mdns_string_builder_append_formatted(a1, "%s", a2);
  if (!(_DWORD)result)
    return mdns_string_builder_append_description(a1, a3, a4);
  return result;
}

uint64_t mdns_string_builder_append_sockaddr_description(_QWORD *a1, uint64_t a2, char a3)
{
  int v6;
  int *v7;
  uint64_t result;
  char v9;
  unsigned int v10;
  BOOL v11;
  const void *v12;
  BOOL v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  char v18[16];
  _OWORD v19[2];
  __int128 v20;

  v6 = *(unsigned __int8 *)(a2 + 1);
  if (v6 != 30)
  {
    if (v6 != 2)
      return mdns_string_builder_append_formatted(a1, "UNHANDLED ADDRESS FAMILY: %d");
    v7 = (int *)(a2 + 4);
    if ((a3 & 1) == 0)
    {
      memset(v18, 0, sizeof(v18));
      if (inet_ntop(2, v7, v18, 0x10u))
      {
LABEL_5:
        result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_22:
        if ((_DWORD)result)
          return result;
        if ((a3 & 2) == 0 && *(_WORD *)(a2 + 2))
          return mdns_string_builder_append_formatted(a1, ":%d");
        return 0;
      }
      if (*__error())
      {
        result = *__error();
        if ((_DWORD)result)
          return result;
        goto LABEL_5;
      }
      return 4294960596;
    }
    v20 = 0u;
    *(_OWORD *)v18 = 0u;
    memset(v19, 0, sizeof(v19));
    v10 = bswap32(*v7);
    v16 = *v7;
    v17 = v10;
    if (v10)
      v11 = v10 == 2130706433;
    else
      v11 = 1;
    if (v11)
    {
      if (_GetCUSymAddr_SNPrintF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64, "%#.4a", COERCE_DOUBLE(&v17)) & 0x80000000) == 0)
      {
        goto LABEL_21;
      }
    }
    else
    {
      v15 = _DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)&v16, 4);
      if ((v15 & 0x80000000) == 0)
        goto LABEL_21;
    }
    v18[0] = 0;
LABEL_21:
    result = mdns_string_builder_append_formatted(a1, "<IPv4:%s>");
    goto LABEL_22;
  }
  if ((a3 & 2) != 0 || !*(_WORD *)(a2 + 2))
  {
    v9 = 1;
  }
  else
  {
    result = mdns_string_builder_append_formatted(a1, "[");
    if ((_DWORD)result)
      return result;
    v9 = 0;
  }
  v12 = (const void *)(a2 + 8);
  if ((a3 & 1) != 0)
  {
    v20 = 0uLL;
    *(_OWORD *)v18 = 0uLL;
    memset(v19, 0, sizeof(v19));
    if (*(_QWORD *)(a2 + 8) | *(_QWORD *)(a2 + 15))
      v13 = 1;
    else
      v13 = *(unsigned __int8 *)(a2 + 23) >= 2u;
    if (v13)
    {
      if ((_DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)v12, 16) & 0x80000000) == 0)
      {
LABEL_42:
        result = mdns_string_builder_append_formatted(a1, "<IPv6:%s>");
        goto LABEL_43;
      }
    }
    else
    {
      if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      {
        dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
        v12 = (const void *)(a2 + 8);
      }
      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64, "%.16a", *(double *)&v12) & 0x80000000) == 0)
      {
        goto LABEL_42;
      }
    }
    v18[0] = 0;
    goto LABEL_42;
  }
  *(_OWORD *)v18 = 0uLL;
  memset(v19, 0, 30);
  if (!inet_ntop(30, v12, v18, 0x2Eu))
  {
    if (!*__error())
      return 4294960596;
    result = *__error();
    if ((_DWORD)result)
      return result;
  }
  result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_43:
  if (!(_DWORD)result)
  {
    v14 = *(_DWORD *)(a2 + 24);
    if (!v14
      || ((memset(v18, 0, sizeof(v18)), LOBYTE(v19[0]) = 0, !if_indextoname(v14, v18))
        ? (result = mdns_string_builder_append_formatted(a1, "%%%u"))
        : (result = mdns_string_builder_append_formatted(a1, "%%%s")),
          !(_DWORD)result))
    {
      if ((v9 & 1) == 0)
        return mdns_string_builder_append_formatted(a1, "]:%d");
      return 0;
    }
  }
  return result;
}

void *mdns_string_builder_copy_string(uint64_t a1)
{
  const char *v1;
  uint64_t v2;
  size_t v3;
  void *v4;
  void *result;

  v1 = *(const char **)(a1 + 24);
  if (v1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = v2 + 1;
    if (v2 == -1)
      return 0;
  }
  else
  {
    v1 = "";
    v3 = 1;
  }
  result = malloc_type_malloc(v3, 0xA172743EuLL);
  if (result)
  {
    v4 = result;
    memcpy(result, v1, v3);
    return v4;
  }
  __break(1u);
  return result;
}

uint64_t resource_record_as_rrsig_get_covered_type(uint64_t a1)
{
  uint64_t result;

  if (*(_WORD *)(a1 + 4) != 46)
    return 0;
  result = rdata_parser_rrsig_check_validity(*(_QWORD *)(a1 + 40) + 4, *(unsigned __int16 *)(a1 + 12));
  if ((_DWORD)result)
    return bswap32(*(unsigned __int16 *)(*(_QWORD *)(a1 + 40) + 4)) >> 16;
  return result;
}

uint64_t resource_record_as_ds_refers_to_supported_key_algorithm(uint64_t a1)
{
  unsigned int v1;
  BOOL v2;
  unint64_t v3;
  uint64_t result;
  NSObject *v5;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;

  if (*(_WORD *)(a1 + 4) == 43)
  {
    v1 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 6) - 5;
    v2 = v1 > 0xB;
    v3 = (0xF2DuLL >> v1) & 1;
    if (v2)
      return 0;
    else
      return v3;
  }
  v5 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result)
      return result;
LABEL_14:
    v7 = 136447234;
    v8 = "me->rrtype == kDNSRecordType_DS";
    v9 = 2082;
    v10 = "";
    v11 = 2082;
    v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    v13 = 1024;
    v14 = 183;
    v15 = 2048;
    v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v7, 0x30u);
    return 0;
  }
  v5 = mDNSLogCategory_DNSSEC_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
    goto LABEL_14;
  return result;
}

BOOL resource_record_as_rrsig_covers_wildcard_rr(uint64_t a1)
{
  _BOOL8 result;
  _BYTE *v3;
  int v4;
  unint64_t v5;
  _BYTE *v6;
  int v7;

  if (*(_WORD *)(a1 + 4) != 46)
    return 0;
  result = rdata_parser_rrsig_check_validity(*(_QWORD *)(a1 + 40) + 4, *(unsigned __int16 *)(a1 + 12));
  if (result)
  {
    v3 = *(_BYTE **)(a1 + 32);
    v4 = *v3;
    if (*v3)
    {
      v5 = 0;
      do
      {
        ++v5;
        v6 = &v3[v4];
        v7 = v6[1];
        v3 = v6 + 1;
        v4 = v7;
      }
      while (v7);
    }
    else
    {
      v5 = 0;
    }
    return v5 > *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 7);
  }
  return result;
}

BOOL resource_record_as_denial_of_existence_proves_wildcard_answer(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)a1 + 7);
  return v1
      && *a1 == 240
      && !*(_DWORD *)(v1 + 32)
      && !*(_BYTE *)(v1 + 40)
      && (v3 = *(_QWORD *)(v1 + 48)) != 0
      && *(_DWORD *)(v3 + 16) == 5;
}

BOOL resource_record_get_insecure_validation_usable(unsigned __int8 *a1)
{
  uint64_t v1;
  _BOOL8 result;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;

  if (*a1 != 240)
    return 0;
  v1 = *((_QWORD *)a1 + 7);
  if (!v1)
  {
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      v5 = mDNSLogCategory_DNSSEC;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    else
    {
      v5 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    v6 = 136447234;
    v7 = "me->dnssec != NULL";
    v8 = 2082;
    v9 = "";
    v10 = 2082;
    v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    v12 = 1024;
    v13 = 354;
    v14 = 2048;
    v15 = 0;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v6, 0x30u);
    return 0;
  }
  if (*(_DWORD *)(v1 + 32) == 1)
    return *(_BYTE *)(v1 + 44) != 0;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    v5 = mDNSLogCategory_DNSSEC;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result)
      return result;
    goto LABEL_22;
  }
  v5 = mDNSLogCategory_DNSSEC_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_22:
    v6 = 136447234;
    v7 = "me->aware_type == dnssec_aware_rr_validated";
    v8 = 2082;
    v9 = "";
    v10 = 2082;
    v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_resource_record_member.c";
    v12 = 1024;
    v13 = 226;
    v14 = 2048;
    v15 = 0;
    goto LABEL_23;
  }
  return result;
}

uint64_t resource_record_get_cache_record(uint64_t a1)
{
  NSObject *v2;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;

  if (a1)
    return *(_QWORD *)(a1 + 16);
  v2 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
  {
    v2 = mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
      return 0;
    goto LABEL_11;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
  {
LABEL_11:
    v5 = 136447234;
    v6 = "me->dnssec != NULL";
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    v11 = 1024;
    v12 = 324;
    v13 = 2048;
    v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v5, 0x30u);
  }
  return 0;
}

uint64_t resource_record_get_expiration_time(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  NSObject *v4;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;

  if (!a1)
  {
    v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
        return 0;
    }
    else
    {
      v4 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 0;
    }
    v9 = 136447234;
    v10 = "me->dnssec != NULL";
    v11 = 2082;
    v12 = "";
    v13 = 2082;
    v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    v15 = 1024;
    v16 = 364;
    v17 = 2048;
    v18 = 0;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v9, 0x30u);
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
  {
    v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      v4 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 0;
      goto LABEL_26;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_26:
      v9 = 136447234;
      v10 = "cr != NULL";
      v11 = 2082;
      v12 = "";
      v13 = 2082;
      v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
      v15 = 1024;
      v16 = 367;
      v17 = 2048;
      v18 = 0;
      goto LABEL_27;
    }
    return 0;
  }
  if (*(_BYTE *)(v1 + 109))
    v2 = dword_100158E08 + 939524096;
  else
    v2 = *(_DWORD *)(v1 + 80) + 1000 * *(_DWORD *)(v1 + 16);
  if (v2 <= 1)
    return 1;
  else
    return v2;
}

uint64_t resource_record_get_actual_ttl(uint64_t a1, uint64_t a2)
{
  int expiration_time;
  uint64_t result;
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;

  if (!*(_DWORD *)(a2 + 8))
    return 0;
  expiration_time = resource_record_get_expiration_time(*(_QWORD *)(a2 + 56));
  if (expiration_time)
  {
    if (expiration_time - *(_DWORD *)(a1 + 64) >= 0)
      return (expiration_time - *(_DWORD *)(a1 + 64)) / 0x3E8u;
    else
      return 0;
  }
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    v6 = mDNSLogCategory_DNSSEC;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result)
      return result;
    goto LABEL_14;
  }
  v6 = mDNSLogCategory_DNSSEC_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
LABEL_14:
    v7 = 136447234;
    v8 = "expiration_time != 0";
    v9 = 2082;
    v10 = "";
    v11 = 2082;
    v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    v13 = 1024;
    v14 = 394;
    v15 = 2048;
    v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v7, 0x30u);
    return 0;
  }
  return result;
}

uint64_t resource_records_have_same_dnssec_rr_category(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v3;
  int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  if ((a1 != 0) != (a2 != 0))
    return 0;
  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 32);
    if (a2)
    {
      v4 = *(_DWORD *)(a2 + 32);
      if ((v3 == 0) == (v4 == 0))
      {
        v5 = v3 == 1;
LABEL_10:
        v6 = v4 == 1;
        return v5 ^ v6 ^ 1u;
      }
    }
    else if (v3)
    {
      v6 = 0;
      v5 = v3 == 1;
      return v5 ^ v6 ^ 1u;
    }
    return 0;
  }
  v5 = 0;
  if (!a2)
  {
    v6 = 0;
    return v5 ^ v6 ^ 1u;
  }
  result = 0;
  v4 = *(_DWORD *)(a2 + 32);
  if (v4)
    goto LABEL_10;
  return result;
}

BOOL identical_dnssec_validated_same_name_resource_record(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    return 0;
  if (*(_DWORD *)(v2 + 32))
    return 0;
  v4 = *(_QWORD *)(a2 + 56);
  if (!v4
    || *(_DWORD *)(v4 + 32) != 1
    || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0;
  }
  if (*(_WORD *)(a1 + 12))
    return SameRDataBody(a1, (unsigned __int16 *)(*(_QWORD *)(a2 + 40) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
  return 1;
}

uint64_t _mdns_symptoms_report_dns_server_symptom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  uint64_t v5;
  uint64_t v6;

  if (_mdns_symptoms_get_reporter_s_once != -1)
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_358);
  result = _mdns_symptoms_get_reporter_s_reporter;
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    v4 = *(unsigned __int8 *)(a2 + 1);
    if (v4 == 2)
    {
      v5 = 16;
      goto LABEL_9;
    }
    if (v4 == 30)
    {
      v5 = 28;
LABEL_9:
      v6 = symptom_new();
      symptom_set_additional_qualifier(v6, 1, v5, a2);
      return symptom_send(v6);
    }
  }
  return result;
}

void ___mdns_symptoms_get_reporter_block_invoke(id a1)
{
  if (&_symptom_framework_init)
    _mdns_symptoms_get_reporter_s_reporter = symptom_framework_init(101, "com.apple.mDNSResponder");
}

void _mdns_symptoms_report_resolved(CFArrayRef theArray, const __CFArray *a2, _OWORD *a3, int a4, unsigned int a5, int a6, const unsigned __int8 *a7, _OWORD *a8)
{
  uint64_t v15;
  CFIndex Count;
  CFIndex v17;
  CFIndex v18;
  CFDataRef deep_copy_data;
  const __CFData *v20;
  CFDataRef v21;
  const __CFData *v22;
  uint64_t v23;
  __int128 v24;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v27;
  const UInt8 *v28;
  NSObject *v29;
  __int128 v30;
  uint64_t v31;
  const void *ValueAtIndex;
  const char *v33;
  CFIndex v34;
  _BYTE atoken[38];
  __int16 v37;
  CFIndex v38;
  __int16 v39;
  CFIndex v40;
  __int16 v41;
  char *v42;
  char __str[16];
  __int128 v44;
  __int128 v45;
  __int128 v46;

  if (_mdns_symptoms_get_reporter_s_once != -1)
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_358);
  v15 = _mdns_symptoms_get_reporter_s_reporter;
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    Count = CFArrayGetCount(theArray);
    v34 = Count - 1;
    if (Count >= 1)
    {
      v17 = CFArrayGetCount(a2);
      if (v17 >= 1)
      {
        v18 = v17;
        deep_copy_data = _mdns_symptoms_create_deep_copy_data(theArray);
        if (deep_copy_data)
        {
          v20 = deep_copy_data;
          v21 = _mdns_symptoms_create_deep_copy_data(a2);
          if (v21)
          {
            v22 = v21;
            v23 = symptom_new(v15, 413699);
            symptom_set_qualifier(v23, a5, 4);
            symptom_set_additional_qualifier(v23, 2, 32, a3);
            if (a4)
              symptom_set_qualifier(v23, 1, 2);
            v45 = 0u;
            v46 = 0u;
            *(_OWORD *)__str = 0u;
            v44 = 0u;
            if (a8)
            {
              symptom_set_additional_qualifier(v23, 3, 32, a8);
              v24 = a8[1];
              *(_OWORD *)atoken = *a8;
              *(_OWORD *)&atoken[16] = v24;
              audit_token_to_pid((audit_token_t *)atoken);
              snprintf(__str, 0x40uLL, " delegated token: %lld");
            }
            else if (a7)
            {
              symptom_set_additional_qualifier(v23, 4, 16, a7);
              memset(atoken, 0, 37);
              uuid_unparse_lower(a7, atoken);
              snprintf(__str, 0x40uLL, " delegated uuid: %s");
            }
            else if (a6)
            {
              symptom_set_qualifier(v23, a6, 1);
              snprintf(__str, 0x40uLL, " delegated pid: %lld");
            }
            Length = CFDataGetLength(v22);
            BytePtr = CFDataGetBytePtr(v22);
            symptom_set_additional_qualifier(v23, 5, Length, BytePtr);
            v27 = CFDataGetLength(v20);
            v28 = CFDataGetBytePtr(v20);
            symptom_set_additional_qualifier(v23, 6, v27, v28);
            symptom_send(v23);
            if (_mdns_symptoms_log_s_once != -1)
              dispatch_once(&_mdns_symptoms_log_s_once, &__block_literal_global_8);
            v29 = _mdns_symptoms_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_symptoms_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              v30 = a3[1];
              *(_OWORD *)atoken = *a3;
              *(_OWORD *)&atoken[16] = v30;
              v31 = audit_token_to_pid((audit_token_t *)atoken);
              ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
              *(_DWORD *)atoken = 67110658;
              v33 = "";
              *(_DWORD *)&atoken[4] = a5;
              *(_WORD *)&atoken[8] = 2048;
              if (a4)
                v33 = " (browse)";
              *(_QWORD *)&atoken[10] = v31;
              *(_WORD *)&atoken[18] = 2112;
              *(_QWORD *)&atoken[20] = ValueAtIndex;
              *(_WORD *)&atoken[28] = 2082;
              *(_QWORD *)&atoken[30] = v33;
              v37 = 2048;
              v38 = v34;
              v39 = 2048;
              v40 = v18;
              v41 = 2082;
              v42 = __str;
              _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "[R%u] Report pid: %lld %@%{public}s (cnames %ld) (addrs %ld)%{public}s", atoken, 0x44u);
            }
            CFRelease(v20);
            CFRelease(v22);
          }
          else
          {
            CFRelease(v20);
          }
        }
      }
    }
  }
}

CFDataRef _mdns_symptoms_create_deep_copy_data(CFPropertyListRef propertyList)
{
  CFDataRef result;
  CFDataRef v2;
  CFDataRef Data;

  result = (CFDataRef)CFPropertyListCreateDeepCopy(kCFAllocatorDefault, propertyList, 0);
  if (result)
  {
    v2 = result;
    Data = CFPropertyListCreateData(kCFAllocatorDefault, result, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFRelease(v2);
    return Data;
  }
  return result;
}

void ___mdns_symptoms_log_block_invoke(id a1)
{
  _mdns_symptoms_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "symptoms");
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

void __http_task_create_dns_query_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  id HeuristicsQueue;
  NSObject *v13;
  void *v14;
  BOOL v15;
  id v16;
  id v17;
  NSObject *v18;
  id v19;
  id v20;
  _QWORD block[4];
  id v22;
  BOOL v23;

  v20 = a2;
  v7 = a3;
  v8 = a4;
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  if (v9)
  {
    if (v8)
    {
      nw_activity_complete_with_reason(v9, 3);
      goto LABEL_5;
    }
    nw_activity_complete_with_reason(v9, 2);
LABEL_10:
    HeuristicsQueue = getHeuristicsQueue();
    v13 = objc_claimAutoreleasedReturnValue(HeuristicsQueue);
    dispatch_async(v13, &__block_literal_global_6441);
LABEL_17:

    goto LABEL_18;
  }
  if (!v8)
    goto LABEL_10;
LABEL_5:
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "domain"));
  if (objc_msgSend(v10, "isEqualToString:", NSURLErrorDomain))
    v11 = objc_msgSend(v8, "code") == (id)-999 || objc_msgSend(v8, "code") == (id)-1009;
  else
    v11 = 0;

  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "domain"));
  if (objc_msgSend(v14, "isEqualToString:", NSURLErrorDomain))
    v15 = objc_msgSend(v8, "code") == (id)-1001;
  else
    v15 = 0;

  if (!v11)
  {
    v16 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "URL"));
    v17 = getHeuristicsQueue();
    v18 = objc_claimAutoreleasedReturnValue(v17);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = __dns_heuristics_report_resolution_failure_block_invoke;
    block[3] = &unk_10013EAC0;
    v22 = v16;
    v23 = v15;
    v13 = v16;
    dispatch_async(v18, block);

    goto LABEL_17;
  }
LABEL_18:
  objc_msgSend(v7, "statusCode");
  v19 = objc_msgSend(v20, "_createDispatchData");
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

id _http_task_create_data_task(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  id v13;

  v3 = a1;
  v4 = a2;
  v8 = 0;
  v9 = &v8;
  v10 = 0x3032000000;
  v11 = __Block_byref_object_copy_;
  v12 = __Block_byref_object_dispose_;
  v13 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = ___http_task_create_data_task_block_invoke;
  v7[3] = &unk_10013BB70;
  v7[5] = v4;
  v7[6] = &v8;
  v7[4] = v3;
  _http_task_shared_session_critical_region(v7);
  v5 = (id)v9[5];
  _Block_object_dispose(&v8, 8);

  return v5;
}

void sub_100054BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___http_task_create_data_task_block_invoke(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v2 = (void *)g_shared_session;
  if (!g_shared_session)
  {
    if (_http_task_create_shared_session_s_once != -1)
      dispatch_once(&_http_task_create_shared_session_s_once, &__block_literal_global_126);
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSURLSessionConfiguration ephemeralSessionConfiguration](NSURLSessionConfiguration, "ephemeralSessionConfiguration"));
    objc_msgSend(v3, "setHTTPCookieStorage:", 0);
    objc_msgSend(v3, "setURLCache:", 0);
    objc_msgSend(v3, "setURLCredentialStorage:", 0);
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObjects:](NSSet, "setWithObjects:", CFSTR("User-Agent"), CFSTR("Accept-Language"), 0));
    objc_msgSend(v3, "set_suppressedAutoAddedHTTPHeaders:", v4);

    objc_msgSend(v3, "set_allowsTLSSessionTickets:", 1);
    objc_msgSend(v3, "set_allowsTCPFastOpen:", 1);
    objc_msgSend(v3, "set_disableAPWakeOnIdleConnections:", 1);
    v5 = objc_alloc_init((Class)NSOperationQueue);
    if (_mdns_resolver_queue_s_once != -1)
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    v6 = (id)_mdns_resolver_queue_s_queue;
    objc_msgSend(v5, "setUnderlyingQueue:", v6);

    v7 = objc_claimAutoreleasedReturnValue(+[NSURLSession sessionWithConfiguration:delegate:delegateQueue:](NSURLSession, "sessionWithConfiguration:delegate:delegateQueue:", v3, _http_task_create_shared_session_delegate, v5));
    v8 = (void *)g_shared_session;
    g_shared_session = v7;

    v2 = (void *)g_shared_session;
  }
  v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "dataTaskWithRequest:completionHandler:", a1[4], a1[5]));
  v10 = *(_QWORD *)(a1[6] + 8);
  v11 = *(void **)(v10 + 40);
  *(_QWORD *)(v10 + 40) = v9;

}

void _http_task_shared_session_critical_region(void *a1)
{
  void (**v1)(_QWORD);

  v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
}

void ___http_task_create_shared_session_block_invoke(id a1)
{
  MDNSHTTPSessionDelegate *v1;
  void *v2;

  +[NSURLSession _disableAppSSO](NSURLSession, "_disableAppSSO");
  +[NSURLSession _disableATS](NSURLSession, "_disableATS");
  v1 = objc_alloc_init(MDNSHTTPSessionDelegate);
  v2 = (void *)_http_task_create_shared_session_delegate;
  _http_task_create_shared_session_delegate = (uint64_t)v1;

}

void *http_task_create_pvd_query(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id data_task;
  void *v17;
  void *v18;
  _QWORD v20[4];
  id v21;
  id v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  id v29;

  v7 = a1;
  v8 = a4;
  v9 = objc_autoreleasePoolPush();
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("https://%s/.well-known/pvd%s"), a2, a3));
  v11 = objc_alloc((Class)NSMutableURLRequest);
  v12 = objc_msgSend(objc_alloc((Class)NSURL), "initWithString:", v10);
  v13 = objc_msgSend(v11, "initWithURL:", v12);

  objc_msgSend(v13, "setHTTPMethod:", CFSTR("GET"));
  objc_msgSend(v13, "setValue:forHTTPHeaderField:", CFSTR("application/pvd+json"), CFSTR("accept"));
  objc_msgSend(v13, "setValue:forHTTPHeaderField:", CFSTR("application/pvd+json"), CFSTR("content-type"));
  v24 = 0;
  v25 = &v24;
  v26 = 0x3032000000;
  v27 = __Block_byref_object_copy_;
  v28 = __Block_byref_object_dispose_;
  v29 = 0;
  v29 = (id)nw_activity_create(33, 3);
  if (v25[5])
    nw_activity_activate();
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = __http_task_create_pvd_query_block_invoke;
  v20[3] = &unk_100139D30;
  v14 = v7;
  v21 = v14;
  v23 = &v24;
  v15 = v8;
  v22 = v15;
  data_task = _http_task_create_data_task(v13, v20);
  v17 = (void *)objc_claimAutoreleasedReturnValue(data_task);
  if (v17 && v25[5])
  {
    v18 = (void *)nw_activity_create(33, 3);
    objc_msgSend(v17, "set_nw_activity:", v18);

  }
  _Block_object_dispose(&v24, 8);

  objc_autoreleasePoolPop(v9);
  return v17;
}

void sub_100055038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __http_task_create_pvd_query_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v3;
  id v4;
  id v5;
  __int128 v6;
  _QWORD block[5];
  __int128 v8;

  v3 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __http_task_create_pvd_query_block_invoke_2;
  block[3] = &unk_10013BB70;
  block[4] = a2;
  v6 = *(_OWORD *)(a1 + 40);
  v4 = (id)v6;
  v8 = v6;
  v5 = a2;
  dispatch_async(v3, block);

}

void __http_task_create_pvd_query_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  double v12;
  id v13;

  v2 = a1[4];
  if (v2)
  {
    v13 = (id)objc_claimAutoreleasedReturnValue(+[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:", v2, 0, 0));
    v3 = objc_opt_class(NSDictionary);
    if ((objc_opt_isKindOfClass(v13, v3) & 1) != 0)
    {
      v4 = (void *)_CFXPCCreateXPCObjectFromCFObject(v13);
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("expires")));
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("seconds-remaining")));
      if (v4)
      {
        v7 = objc_opt_class(NSString);
        if ((objc_opt_isKindOfClass(v5, v7) & 1) == 0 || v6)
        {
          if (v6)
            xpc_dictionary_set_uint64(v4, "seconds-remaining", (uint64_t)objc_msgSend(v6, "unsignedLongLongValue"));
        }
        else
        {
          v8 = objc_alloc_init((Class)NSDateFormatter);
          v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSTimeZone timeZoneForSecondsFromGMT:](NSTimeZone, "timeZoneForSecondsFromGMT:", 0));
          objc_msgSend(v8, "setTimeZone:", v9);

          v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSLocale localeWithLocaleIdentifier:](NSLocale, "localeWithLocaleIdentifier:", CFSTR("en_US_POSIX")));
          objc_msgSend(v8, "setLocale:", v10);

          objc_msgSend(v8, "setDateFormat:", CFSTR("yyyy-MM-dd'T'HH:mm:ss'Z'"));
          objc_msgSend(v8, "setFormatterBehavior:", 0);
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "dateFromString:", v5));
          objc_msgSend(v11, "timeIntervalSinceNow");
          xpc_dictionary_set_uint64(v4, "seconds-remaining", (unint64_t)v12);

        }
      }
      nw_activity_complete_with_reason(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40), 2);
      (*(void (**)(void))(a1[5] + 16))();

    }
    else
    {
      nw_activity_complete_with_reason(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40), 3);
      (*(void (**)(void))(a1[5] + 16))();
    }

  }
  else
  {
    nw_activity_complete_with_reason(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40), 3);
    (*(void (**)(void))(a1[5] + 16))();
  }
}

void http_task_cancel(void *a1)
{
  void *v2;

  v2 = objc_autoreleasePoolPush();
  objc_msgSend(a1, "cancel");

  objc_autoreleasePoolPop(v2);
}

void __http_task_prepare_for_system_sleep_block_invoke(id a1)
{
  void *v1;

  if (g_shared_session)
  {
    objc_msgSend((id)g_shared_session, "invalidateAndCancel");
    v1 = (void *)g_shared_session;
    g_shared_session = 0;

  }
}

uint64_t _dnssec_obj_domain_name_compare(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;

  if (a1 == a2)
    return 0;
  v6 = *(unsigned __int8 **)(a1 + 16);
  v7 = *(unsigned __int8 **)(a2 + 16);
  if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24))
  {
    if (!*(_BYTE *)(a1 + 36))
    {
      *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(_BYTE **)(a1 + 16));
      *(_BYTE *)(a1 + 36) = 1;
    }
    if (*(_BYTE *)(a2 + 36))
    {
      v8 = *(_DWORD *)(a2 + 32);
    }
    else
    {
      v8 = domain_name_labels_compute_hash(v7);
      *(_DWORD *)(a2 + 32) = v8;
      *(_BYTE *)(a2 + 36) = 1;
    }
    if (*(_DWORD *)(a1 + 32) == v8)
      return domain_name_labels_canonical_compare(v6, v7, a3);
  }
  if ((a3 & 1) == 0)
    return domain_name_labels_canonical_compare(v6, v7, a3);
  else
    return 2;
}

void _dnssec_obj_domain_name_finalize(uint64_t a1)
{
  void *v2;
  _QWORD *v3;

  if (*(_BYTE *)(a1 + 37))
  {
    v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  v3 = *(_QWORD **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

unsigned __int8 *dnssec_obj_domain_name_create_with_labels(unsigned __int8 *a1, char a2, int *a3)
{
  unsigned __int8 *v3;
  unsigned __int8 *v7;
  int v8;
  _UNKNOWN **v9;
  void (*v10)(unsigned __int8 *);
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  char v16;
  unsigned __int8 *v17;
  int v19;
  _BYTE *v20;
  unsigned __int8 *v21;
  BOOL v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  int v27;
  int v28;

  v7 = (unsigned __int8 *)malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (v7)
  {
    v3 = v7;
    v9 = &_dnssec_obj_domain_name_kind;
    *((_QWORD *)v7 + 1) = &_dnssec_obj_domain_name_kind;
    do
    {
      v10 = (void (*)(unsigned __int8 *))v9[2];
      if (v10)
        v10(v3);
      v9 = (_UNKNOWN **)*v9;
    }
    while (v9);
    ++*(_DWORD *)v3;
    if ((a2 & 1) == 0)
    {
      v19 = *a1;
      if (*a1)
      {
        v20 = a1;
        do
        {
          v21 = v20 + 1;
          v20 += v19 + 1;
          while (1)
          {
            v22 = __OFSUB__(v19--, 1);
            if (v19 < 0 != v22)
              break;
            v23 = *v21++;
            if ((v23 - 65) < 0x1A)
              goto LABEL_7;
          }
          v19 = *v20;
        }
        while (*v20);
      }
      *((_QWORD *)v3 + 2) = a1;
      v24 = *a1;
      v25 = a1;
      if (*a1)
      {
        v25 = a1;
        do
        {
          v26 = &v25[v24];
          v27 = v26[1];
          v25 = v26 + 1;
          v24 = v27;
        }
        while (v27);
      }
      v16 = 0;
      v15 = v25 - a1;
      goto LABEL_12;
    }
LABEL_7:
    v28 = 0;
    v7 = domain_name_labels_create(a1, &v28);
    v8 = v28;
    if (!v28)
    {
      v11 = *v7;
      v12 = v7;
      if (*v7)
      {
        v12 = v7;
        do
        {
          v13 = &v12[v11];
          v14 = v13[1];
          v12 = v13 + 1;
          v11 = v14;
        }
        while (v14);
      }
      v15 = v12 - v7;
      *((_QWORD *)v3 + 2) = v7;
      v16 = 1;
LABEL_12:
      v3[37] = v16;
      *((_QWORD *)v3 + 3) = v15 + 1;
      *((_DWORD *)v3 + 8) = 0;
      v3[36] = 0;
      *((_QWORD *)v3 + 5) = 0;
      goto LABEL_13;
    }
  }
  else
  {
    __break(1u);
  }
  if (v7)
  {
    free(v7);
    v8 = v28;
    if (!v28)
    {
LABEL_13:
      v8 = 0;
      v17 = v3;
      v3 = 0;
      if (!a3)
        goto LABEL_15;
      goto LABEL_14;
    }
  }
  v17 = 0;
  if (a3)
LABEL_14:
    *a3 = v8;
LABEL_15:
  if (v3)
    ref_count_obj_release(v3);
  return v17;
}

unsigned __int8 *dnssec_obj_domain_name_create_concatenation_with_subdomain(_BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned __int8 *result;
  int v5;
  _OWORD __dst[16];

  v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    result = 0;
    if (!a3)
      return result;
  }
  else
  {
    result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)__dst, 1, &v5);
    if (!a3)
      return result;
  }
  *a3 = v5;
  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_parent_domain(_BYTE *a1, unint64_t a2, int *a3)
{
  unsigned __int8 *result;
  int v5;
  int v6;

  result = domain_name_labels_get_parent(a1, a2);
  if (result)
  {
    v6 = 0;
    result = dnssec_obj_domain_name_create_with_labels(result, 1, &v6);
    v5 = v6;
    if (!a3)
      return result;
  }
  else
  {
    v5 = -6710;
    if (!a3)
      return result;
  }
  *a3 = v5;
  return result;
}

BOOL dnssec_obj_domain_name_is_sub_domain_of(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3;
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  unint64_t v13;
  unsigned __int8 *parent;
  _BOOL8 result;
  NSObject *v16;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  v3 = *a1;
  if (*a1)
  {
    v4 = 0;
    v5 = a1;
    do
    {
      ++v4;
      v6 = &v5[v3];
      v7 = v6[1];
      v5 = v6 + 1;
      v3 = v7;
    }
    while (v7);
  }
  else
  {
    v4 = 0;
  }
  v8 = *a2;
  if (*a2)
  {
    v9 = 0;
    v10 = a2;
    do
    {
      ++v9;
      v11 = &v10[v8];
      v12 = v11[1];
      v10 = v11 + 1;
      v8 = v12;
    }
    while (v12);
  }
  else
  {
    v9 = 0;
  }
  v13 = v4 - v9;
  if (v4 <= v9)
    return 0;
  if (v13 < 0x100)
  {
    parent = domain_name_labels_get_parent(a1, v13);
    if (parent)
      return domain_name_labels_canonical_compare(parent, a2, 1) == 0;
    v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    else
    {
      v16 = mDNSLogCategory_Default_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    v18 = 136447234;
    v19 = "parent_labels != NULL";
    v20 = 2082;
    v21 = "";
    v22 = 2082;
    v23 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    v24 = 1024;
    v25 = 163;
    v26 = 2048;
    v27 = 0;
    goto LABEL_30;
  }
  v16 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
    if (!result)
      return result;
    goto LABEL_21;
  }
  v16 = mDNSLogCategory_Default_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_21:
    v18 = 136447234;
    v19 = "sub_labels_label_count - labels_label_count <= UINT8_MAX";
    v20 = 2082;
    v21 = "";
    v22 = 2082;
    v23 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    v24 = 1024;
    v25 = 159;
    v26 = 2048;
    v27 = 0;
LABEL_30:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v18, 0x30u);
    return 0;
  }
  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_closest_common_ancestor(unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v6;
  unint64_t v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 *parent;
  unsigned __int8 *v25;
  unsigned __int8 *result;
  int v27;

  if (a1 == a2)
  {
    v12 = a1;
  }
  else
  {
    v6 = *a1;
    if (*a1)
    {
      v7 = 0;
      v8 = *a1;
      v9 = a1;
      do
      {
        ++v7;
        v10 = &v9[v8];
        v11 = v10[1];
        v9 = v10 + 1;
        v8 = v11;
      }
      while (v11);
    }
    else
    {
      v7 = 0;
    }
    v13 = *a2;
    if (*a2)
    {
      v14 = 0;
      v15 = a2;
      do
      {
        ++v14;
        v16 = &v15[v13];
        v17 = v16[1];
        v15 = v16 + 1;
        v13 = v17;
      }
      while (v17);
    }
    else
    {
      v14 = 0;
    }
    v12 = a1;
    if (*a1)
    {
      v12 = a1;
      do
      {
        v18 = &v12[v6];
        v19 = v18[1];
        v12 = v18 + 1;
        v6 = v19;
      }
      while (v19);
    }
    if (v7 >= v14)
      v20 = v14;
    else
      v20 = v7;
    if (v20)
    {
      v21 = v14 - 1;
      v22 = v7 - 1;
      v23 = 1;
      do
      {
        parent = domain_name_labels_get_parent(a1, v22);
        v25 = domain_name_labels_get_parent(a2, v21);
        if (domain_name_label_canonical_compare(parent, v25, 1))
          break;
        ++v23;
        --v21;
        --v22;
        v12 = parent;
      }
      while (v23 <= v20);
    }
  }
  v27 = 0;
  result = dnssec_obj_domain_name_create_with_labels(v12, 1, &v27);
  if (a3)
    *a3 = v27;
  return result;
}

uint64_t dnssec_obj_domain_name_get_nsec3_hashed_name(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int8 *v4;
  unsigned int v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _BYTE *parent;
  int v16;
  _BYTE *v17;
  _BYTE *v18;
  int v19;
  int v20;
  _BYTE *v21;
  _BYTE *v22;
  int v23;
  size_t v24;
  uint64_t v25;
  uint64_t OutputSize;
  int v27;
  uint64_t v28;
  unint64_t encoded_string_length;
  unsigned __int8 *v30;
  NSObject *v31;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  int v37;
  _OWORD v38[16];
  char v39;
  char v40[96];
  uint64_t v41;
  unsigned __int8 __dst[512];
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  _BYTE __src[520];

  result = *(_QWORD *)(a1 + 40);
  if (a2 && !result)
  {
    v4 = *(unsigned __int8 **)(*(_QWORD *)(a2 + 16) + 16);
    v5 = *v4;
    if (!*v4)
      goto LABEL_33;
    v6 = 0;
    v7 = *(unsigned __int8 **)(a2 + 24);
    v8 = *v7;
    v9 = (unint64_t)v7[2] << 8;
    v10 = v7[3];
    v36 = v7[4];
    v11 = v7 + 5;
    v12 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16);
    do
    {
      ++v6;
      v13 = v12 + v5;
      v14 = *(unsigned __int8 *)(v13 + 1);
      v12 = v13 + 1;
      v5 = v14;
    }
    while (v14);
    if (!v6)
    {
LABEL_33:
      v34 = -6742;
      goto LABEL_34;
    }
    parent = domain_name_labels_get_parent(v4, 1uLL);
    if (v8 == 1)
      v16 = 0;
    else
      v16 = -6735;
    v37 = v16;
    if (v8 != 1)
    {
      v34 = -6735;
      goto LABEL_34;
    }
    v35 = parent;
    v17 = domain_name_labels_create(*(_BYTE **)(a1 + 16), &v37);
    v18 = v17;
    v19 = v37;
    if (!v37)
    {
      v20 = *v17;
      v21 = v17;
      if (*v17)
      {
        v21 = v17;
        do
        {
          v22 = &v21[v20];
          v23 = v22[1];
          v21 = v22 + 1;
          v20 = v23;
        }
        while (v23);
      }
      memset(__dst, 0, 511);
      memset(__src, 0, 511);
      bzero(buf, 0x408uLL);
      if (!CCDigestInit(8, buf))
      {
        v24 = v21 - v18 + 1;
        __memcpy_chk(__src, v18, v24, 511);
        v25 = v9 + v10 + 1;
        while (!CCDigestUpdate(buf, __src, v24)
             && !CCDigestUpdate(buf, v11, v36)
             && !CCDigestFinal(buf, __src))
        {
          OutputSize = CCDigestGetOutputSize(8);
          if (!OutputSize)
          {
            v27 = -6735;
            goto LABEL_25;
          }
          v24 = OutputSize;
          CCDigestReset(buf);
          if (!--v25)
          {
            memcpy(__dst, __src, v24);
            v27 = 0;
            goto LABEL_25;
          }
        }
      }
      v27 = -6700;
LABEL_25:
      v37 = v27;
      v28 = CCDigestGetOutputSize(8);
      memset(v40, 0, sizeof(v40));
      v41 = 0;
      encoded_string_length = base_x_get_encoded_string_length(2, v28);
      if (encoded_string_length >= 0x40)
      {
        v19 = -6751;
        v37 = -6751;
        if (!v18)
          goto LABEL_31;
        goto LABEL_30;
      }
      v39 = encoded_string_length;
      v40[encoded_string_length] = 0;
      base_32_hex_encode(__dst, v28, 1, v40);
      memset(v38, 0, sizeof(v38));
      domain_name_labels_concatenate(&v39, v35, (char *)v38, &v37);
      v19 = v37;
      if (!v37)
      {
        v30 = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)v38, 1, &v37);
        v19 = v37;
        if (!v37)
        {
          *(_QWORD *)(a1 + 40) = v30;
          v37 = 0;
        }
      }
    }
    if (!v18)
    {
LABEL_31:
      if (!v19)
        return *(_QWORD *)(a1 + 40);
      v34 = v19;
LABEL_34:
      v31 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          return 0;
      }
      else
      {
        v31 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
          return 0;
      }
      *(_DWORD *)buf = 136447234;
      v44 = "err == 0";
      v45 = 2082;
      v46 = "";
      v47 = 2082;
      v48 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_domain_name.c";
      v49 = 1024;
      v50 = 413;
      v51 = 2048;
      v52 = v34;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
      return 0;
    }
LABEL_30:
    free(v18);
    v19 = v37;
    goto LABEL_31;
  }
  return result;
}

uint64_t *AuthGroupForName(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t *i;

  for (i = *(uint64_t **)(a1 + 8 * (a2 % 0x1F3) + 24); i; i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 2) == a2 && SameDomainNameBytes((_BYTE *)i[4], a3))
      break;
  }
  return i;
}

uint64_t *InsertAuthRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  _BYTE *v10;
  _BYTE *v11;
  unsigned __int16 v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t *v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t **v25;
  uint64_t v26;
  _BYTE *v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  _BYTE *v31;
  uint64_t v32;
  unsigned __int16 v33;
  NSObject *v34;
  uint64_t v36;
  _BYTE *v37;
  uint64_t v38;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  int v44;
  NSObject *v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t v48;
  _BYTE *v49;
  uint64_t v50;
  int v51;
  int v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  uint64_t v58;

  v9 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (v9)
    goto LABEL_2;
  v10 = *(_BYTE **)(a2 + 40);
  v11 = v10;
  if (v10 == (_BYTE *)-256)
    goto LABEL_7;
LABEL_4:
  v12 = 257;
  if (v11 < v10 + 256 && v11)
  {
    while (1)
    {
      v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_12:
        v12 = 257;
        goto LABEL_14;
      }
      if (!*v11)
        break;
      v11 += v13 + 1;
      if (v10 != (_BYTE *)-256)
        goto LABEL_4;
LABEL_7:
      if (!v11)
        goto LABEL_12;
    }
    v12 = (_WORD)v11 - (_WORD)v10 + 1;
  }
LABEL_14:
  if (*(_BYTE *)(a1 + 12))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR ERROR! Cache already locked!", v4, v5, v6, v7, v8, v52);
    v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(_QWORD *)(a2 + 40);
        if (v16)
        {
          v17 = *(_BYTE **)(a2 + 40);
          if (v16 == -256)
          {
LABEL_24:
            while (v17)
            {
              v18 = *v17;
              if (v18 > 0x3F)
                break;
              if (!*v17)
              {
                v42 = (unsigned __int16)((_WORD)v17 - v16 + 1);
                goto LABEL_94;
              }
              v17 += v18 + 1;
              if (v16 != -256)
                goto LABEL_23;
            }
          }
          else
          {
LABEL_23:
            if ((unint64_t)v17 < v16 + 256)
              goto LABEL_24;
          }
          v42 = 257;
        }
        else
        {
          v42 = 0;
        }
        goto LABEL_94;
      }
      return 0;
    }
LABEL_44:
    v14 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a2 + 40);
      if (v16)
      {
        v28 = *(_BYTE **)(a2 + 40);
        if (v16 == -256)
        {
LABEL_48:
          while (v28)
          {
            v29 = *v28;
            if (v29 > 0x3F)
              break;
            if (!*v28)
            {
              v42 = (unsigned __int16)((_WORD)v28 - v16 + 1);
              goto LABEL_94;
            }
            v28 += v29 + 1;
            if (v16 != -256)
              goto LABEL_47;
          }
        }
        else
        {
LABEL_47:
          if ((unint64_t)v28 < v16 + 256)
            goto LABEL_48;
        }
        v42 = 257;
      }
      else
      {
        v42 = 0;
      }
LABEL_94:
      *(_DWORD *)buf = 141558531;
      v54 = 1752392040;
      v55 = 1040;
      v56 = v42;
      v57 = 2101;
      v58 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Failed to allocate memory for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
      return 0;
    }
    return 0;
  }
  *(_BYTE *)(a1 + 12) = 1;
  v9 = *(uint64_t **)(a1 + 16);
  if (!v9)
  {
    v19 = (uint64_t *)malloc_type_calloc(1uLL, 0xB0uLL, 0xF1748037uLL);
    if (!v19)
    {
LABEL_43:
      __break(1u);
      goto LABEL_44;
    }
    v9 = v19;
    *v19 = 0;
    *(_QWORD *)(a1 + 16) = v19;
  }
  *(_QWORD *)(a1 + 16) = *v9;
  v20 = *(_DWORD *)(a1 + 8);
  v21 = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = v21;
  if (v21 >= v20)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RR Auth now using %ld objects", v4, v5, v6, v7, v8, v21);
      v20 = *(_DWORD *)(a1 + 8);
    }
    if (v20 >= 0x3E8)
      v22 = 1000;
    else
      v22 = 100;
    if (v20 < 0x64)
      v22 = 10;
    *(_DWORD *)(a1 + 8) = v22 + v20;
  }
  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 10) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *(_OWORD *)v9 = 0u;
  *(_BYTE *)(a1 + 12) = 0;
  v23 = *(_DWORD *)(a2 + 24);
  v24 = a1 + 8 * (v23 % 0x1F3);
  v26 = *(_QWORD *)(v24 + 24);
  v25 = (uint64_t **)(v24 + 24);
  *v9 = v26;
  *((_DWORD *)v9 + 2) = v23;
  v9[2] = 0;
  v9[3] = (uint64_t)(v9 + 2);
  v9[5] = 0;
  if (v12 <= 0x80u)
  {
    v27 = v9 + 6;
  }
  else
  {
    v27 = malloc_type_malloc(v12, 0xA172743EuLL);
    if (!v27)
      goto LABEL_43;
  }
  v9[4] = (uint64_t)v27;
  v30 = *(_BYTE **)(a2 + 40);
  v31 = v30;
  if (v30 == (_BYTE *)-256)
  {
LABEL_56:
    while (v31)
    {
      v32 = *v31;
      if (v32 > 0x3F)
        break;
      if (!*v31)
      {
        v33 = (_WORD)v31 - (_WORD)v30 + 1;
        if (v33 > 0x100u)
          break;
        memcpy(v27, v30, v33);
        goto LABEL_64;
      }
      v31 += v32 + 1;
      if (v30 != (_BYTE *)-256)
        goto LABEL_55;
    }
  }
  else
  {
LABEL_55:
    if (v31 < v30 + 256)
      goto LABEL_56;
  }
  *v27 = 0;
LABEL_64:
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40)))
  {
    v34 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_104;
      v36 = *(_QWORD *)(a2 + 40);
      if (v36)
      {
        v37 = *(_BYTE **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_74:
          while (v37)
          {
            v38 = *v37;
            if (v38 > 0x3F)
              break;
            if (!*v37)
            {
              v44 = (unsigned __int16)((_WORD)v37 - v36 + 1);
              goto LABEL_103;
            }
            v37 += v38 + 1;
            if (v36 != -256)
              goto LABEL_73;
          }
        }
        else
        {
LABEL_73:
          if ((unint64_t)v37 < v36 + 256)
            goto LABEL_74;
        }
        v44 = 257;
      }
      else
      {
        v44 = 0;
      }
      goto LABEL_103;
    }
    v34 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v36 = *(_QWORD *)(a2 + 40);
      if (v36)
      {
        v40 = *(_BYTE **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_83:
          while (v40)
          {
            v41 = *v40;
            if (v41 > 0x3F)
              break;
            if (!*v40)
            {
              v44 = (unsigned __int16)((_WORD)v40 - v36 + 1);
              goto LABEL_103;
            }
            v40 += v41 + 1;
            if (v36 != -256)
              goto LABEL_82;
          }
        }
        else
        {
LABEL_82:
          if ((unint64_t)v40 < v36 + 256)
            goto LABEL_83;
        }
        v44 = 257;
      }
      else
      {
        v44 = 0;
      }
LABEL_103:
      *(_DWORD *)buf = 141558531;
      v54 = 1752392040;
      v55 = 1040;
      v56 = v44;
      v57 = 2101;
      v58 = v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Already have AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
    }
  }
LABEL_104:
  *v25 = v9;
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40)) != v9)
  {
    v45 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v46 = *(_QWORD *)(a2 + 40);
        if (v46)
        {
          v49 = *(_BYTE **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_120:
            while (v49)
            {
              v50 = *v49;
              if (v50 > 0x3F)
                break;
              if (!*v49)
              {
                v51 = (unsigned __int16)((_WORD)v49 - v46 + 1);
                goto LABEL_131;
              }
              v49 += v50 + 1;
              if (v46 != -256)
                goto LABEL_119;
            }
          }
          else
          {
LABEL_119:
            if ((unint64_t)v49 < v46 + 256)
              goto LABEL_120;
          }
          v51 = 257;
        }
        else
        {
          v51 = 0;
        }
        goto LABEL_131;
      }
    }
    else
    {
      v45 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v46 = *(_QWORD *)(a2 + 40);
        if (v46)
        {
          v47 = *(_BYTE **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_111:
            while (v47)
            {
              v48 = *v47;
              if (v48 > 0x3F)
                break;
              if (!*v47)
              {
                v51 = (unsigned __int16)((_WORD)v47 - v46 + 1);
                goto LABEL_131;
              }
              v47 += v48 + 1;
              if (v46 != -256)
                goto LABEL_110;
            }
          }
          else
          {
LABEL_110:
            if ((unint64_t)v47 < v46 + 256)
              goto LABEL_111;
          }
          v51 = 257;
        }
        else
        {
          v51 = 0;
        }
LABEL_131:
        *(_DWORD *)buf = 141558531;
        v54 = 1752392040;
        v55 = 1040;
        v56 = v51;
        v57 = 2101;
        v58 = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Not finding AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
      }
    }
  }
LABEL_2:
  *(_QWORD *)v9[3] = a2;
  v9[3] = a2;
  return v9;
}

uint64_t *RemoveAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v5;
  uint64_t *v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD **v9;
  _BYTE *v10;
  _QWORD *v11;
  NSObject *v12;
  NSObject *v15;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  _BYTE *v22;

  v5 = (unsigned __int8 *)(a3 + 8);
  v6 = AuthGroupForName(a2, *(_DWORD *)(a3 + 24), *(_BYTE **)(a3 + 40));
  v7 = v6;
  if (!v6)
  {
    v15 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        return v7;
    }
    else
    {
      v15 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        return v7;
    }
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)buf = 141558275;
    v20 = 1752392040;
    v21 = 2085;
    v22 = (_BYTE *)(a1 + 47032);
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "RemoveAuthRecord: ERROR!! AuthGroup not found for %{sensitive, mask.hash}s", buf, 0x16u);
    return v7;
  }
  v9 = (_QWORD **)(v6 + 2);
  v8 = (_QWORD *)v6[2];
  if (v8)
  {
    v10 = (_BYTE *)(a1 + 47032);
    while (v8 != (_QWORD *)a3)
    {
      v11 = (_QWORD *)*v8;
      v9 = (_QWORD **)v8;
LABEL_16:
      v8 = v11;
      if (!v11)
        goto LABEL_17;
    }
    v12 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        v11 = (_QWORD *)**v9;
        *v9 = v11;
        goto LABEL_16;
      }
    }
    else
    {
      v12 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_15;
    }
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), v10);
    *(_DWORD *)buf = 141558275;
    v20 = 1752392040;
    v21 = 2085;
    v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "RemoveAuthRecord: removing auth record %{sensitive, mask.hash}s from table", buf, 0x16u);
    goto LABEL_15;
  }
LABEL_17:
  v7[3] = (uint64_t)v9;
  return v7;
}

uint64_t mDNS_AddressIsLocalSubnet(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t *v3;
  uint64_t *v4;

  if (*a3 == 6)
  {
    v4 = *(uint64_t **)(a1 + 12656);
    if (v4)
    {
      while (*((_DWORD *)v4 + 890) != 6
           || v4[444] != a2
           || !*((_BYTE *)v4 + 3671)
           || ((a3[1] ^ *((_DWORD *)v4 + 891)) & (_DWORD)v4[448]) != 0
           || ((a3[2] ^ *((_DWORD *)v4 + 892)) & *((_DWORD *)v4 + 897)) != 0
           || ((a3[3] ^ *((_DWORD *)v4 + 893)) & (_DWORD)v4[449]) != 0
           || ((a3[4] ^ *((_DWORD *)v4 + 894)) & *((_DWORD *)v4 + 899)) != 0)
      {
        v4 = (uint64_t *)*v4;
        if (!v4)
          return 0;
      }
      return 1;
    }
  }
  else if (*a3 == 4)
  {
    v3 = *(uint64_t **)(a1 + 12656);
    if (v3)
    {
      while (*((_DWORD *)v3 + 890) != 4
           || v3[444] != a2
           || !*((_BYTE *)v3 + 3671)
           || ((a3[1] ^ *((_DWORD *)v3 + 891)) & (_DWORD)v3[448]) != 0)
      {
        v3 = (uint64_t *)*v3;
        if (!v3)
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

void AnswerQuestionByFollowingCNAME(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  __int16 v7;
  _BYTE *v8;
  int v9;
  unsigned int v10;
  int v12;
  NSObject *v13;
  unsigned int v15;
  _BYTE *v16;
  uint64_t v17;
  NSObject *v18;
  unsigned int v20;
  _BYTE *v21;
  uint64_t v22;
  _BYTE *v24;
  uint64_t v25;
  _BYTE *v27;
  uint64_t v28;
  int v29;
  unsigned __int16 v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  unint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  unsigned __int16 v41;
  NSObject *v42;
  unsigned int v43;
  _BYTE *v44;
  uint64_t v45;
  _BYTE *v46;
  uint64_t v47;
  int v48;
  char v49;
  void *v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  unsigned int v56;
  void *v57;
  uint64_t v58;
  int v59;
  uint8_t buf[4];
  unsigned int v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  int v65;
  __int16 v66;
  uint64_t v67;
  __int16 v68;
  unsigned int v69;
  __int16 v70;
  int v71;

  v6 = *(_QWORD *)(a3 + 40);
  v7 = v6 + 4;
  v8 = (_BYTE *)(a2 + 376);
  v9 = SameDomainNameBytes((_BYTE *)(a2 + 376), (_BYTE *)(v6 + 4));
  v10 = *(unsigned __int8 *)(a2 + 353);
  if (v10 <= 9 && v9 == 0)
  {
    v57 = *(void **)(a2 + 72);
    v56 = *(unsigned __int16 *)(a2 + 340);
    *(_QWORD *)(a2 + 72) = 0;
    v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_57;
      v20 = __rev16(v56);
      v21 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_26:
        while (v21)
        {
          v22 = *v21;
          if (v22 > 0x3F)
            break;
          if (!*v21)
          {
            v30 = (_WORD)v21 - v7 + 1;
            goto LABEL_56;
          }
          v21 += v22 + 1;
          if (v6 != -260)
            goto LABEL_25;
        }
      }
      else
      {
LABEL_25:
        if ((unint64_t)v21 < v6 + 260)
          goto LABEL_26;
      }
      v30 = 257;
    }
    else
    {
      v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_57:
        v31 = (_QWORD *)(a2 + 260);
        v59 = *(_DWORD *)(a2 + 268);
        v58 = *(_QWORD *)(a2 + 260);
        *(_DWORD *)(a2 + 268) = 0;
        *(_QWORD *)(a2 + 260) = 0;
        v32 = *(unsigned __int16 *)(a2 + 340);
        if (*(_WORD *)(a2 + 340))
        {
          v33 = *(_QWORD *)(a2 + 80);
          if (v33)
            v34 = *(_QWORD *)(v33 + 24);
          else
            v34 = -1;
          v35 = *(_QWORD *)(a2 + 96);
          *(_QWORD *)(a2 + 88) = v34;
          *(_QWORD *)(a2 + 96) = 0;
        }
        else
        {
          v35 = 0;
        }
        mDNS_StopQuery_internal(a1, a2);
        v36 = *(_QWORD *)(a3 + 40);
        v37 = (const void *)(v36 + 4);
        v38 = v36 + 260;
        v39 = (_BYTE *)(v36 + 4);
        if (v38)
        {
LABEL_64:
          if ((unint64_t)v39 < v38)
            goto LABEL_65;
        }
        else
        {
LABEL_65:
          while (v39)
          {
            v40 = *v39;
            if (v40 > 0x3F)
              break;
            if (!*v39)
            {
              v41 = (_WORD)v39 - (_WORD)v37 + 1;
              if (v41 > 0x100u)
                break;
              memcpy(v8, v37, v41);
              goto LABEL_73;
            }
            v39 += v40 + 1;
            if (v38)
              goto LABEL_64;
          }
        }
        *v8 = 0;
LABEL_73:
        *(_DWORD *)(a2 + 200) = DomainNameHashValue((unint64_t)v8);
        if (!*(_WORD *)(a2 + 340) || !IsLocalDomain(v8))
        {
LABEL_99:
          v49 = *(_BYTE *)(a2 + 353) + 1;
          *(_BYTE *)(a2 + 353) = v49;
          mDNS_StartQuery_internal(a1, a2);
          *(_BYTE *)(a2 + 353) = v49;
          *v31 = v58;
          *(_DWORD *)(a2 + 268) = v59;
          if (v32)
          {
            v50 = v57;
            if (!v35)
              goto LABEL_109;
            if (*(_QWORD *)(a2 + 40))
              goto LABEL_123;
            if (*(_QWORD *)(a2 + 96))
              goto LABEL_123;
            v52 = *(_QWORD *)(a2 + 80);
            if (!v52)
              goto LABEL_123;
            v53 = *(_QWORD *)(v35 + 32);
            v54 = *(_QWORD *)(v52 + 24);
            if (v53)
              v53 = *(_QWORD *)(v53 + 24);
            if (v54 != v53)
            {
LABEL_123:
              if (*(_UNKNOWN ***)(v35 + 16) == &_mdns_querier_kind
                && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v35 + 64) + 16) + 144))
              {
                v51 = atomic_load((unsigned int *)(v35 + 208));
                *(_DWORD *)v31 += v51;
              }
              mdns_client_invalidate(v35);
            }
            else
            {
              os_retain((void *)v35);
              v55 = *(void **)(a2 + 96);
              if (v55)
                os_release(v55);
              *(_QWORD *)(a2 + 96) = v35;
            }
          }
          else
          {
            v50 = v57;
            if (!v35)
              goto LABEL_109;
          }
          os_release((void *)v35);
LABEL_109:
          if (v50)
          {
            if (*(_QWORD *)(a2 + 40))
            {
              CloseSocketSet((uint64_t)v50);
              free(v50);
            }
            else
            {
              *(_QWORD *)(a2 + 72) = v50;
              *(_WORD *)(a2 + 340) = v56;
            }
          }
          return;
        }
        v42 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v43 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v46 = (_BYTE *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_88:
              while (v46)
              {
                v47 = *v46;
                if (v47 > 0x3F)
                  break;
                if (!*v46)
                {
                  v48 = (unsigned __int16)((_WORD)v46 - v7 + 1);
                  goto LABEL_97;
                }
                v46 += v47 + 1;
                if (v6 != -260)
                  goto LABEL_87;
              }
            }
            else
            {
LABEL_87:
              if ((unint64_t)v46 < v6 + 260)
                goto LABEL_88;
            }
            v48 = 257;
            goto LABEL_97;
          }
        }
        else
        {
          v42 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v43 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            v44 = (_BYTE *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_80:
              while (v44)
              {
                v45 = *v44;
                if (v45 > 0x3F)
                  break;
                if (!*v44)
                {
                  v48 = (unsigned __int16)((_WORD)v44 - v7 + 1);
                  goto LABEL_97;
                }
                v44 += v45 + 1;
                if (v6 != -260)
                  goto LABEL_79;
              }
            }
            else
            {
LABEL_79:
              if ((unint64_t)v44 < v6 + 260)
                goto LABEL_80;
            }
            v48 = 257;
LABEL_97:
            *(_DWORD *)buf = 67109891;
            v61 = v43;
            v62 = 2160;
            v63 = 1752392040;
            v64 = 1040;
            v65 = v48;
            v66 = 2101;
            v67 = v6 + 4;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "[Q%d] AnswerQuestionByFollowingCNAME: Resolving a .local CNAME -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x22u);
          }
        }
        *(_BYTE *)(a2 + 638) = 1;
        goto LABEL_99;
      }
      v20 = __rev16(v56);
      v27 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_42:
        while (v27)
        {
          v28 = *v27;
          if (v28 > 0x3F)
            break;
          if (!*v27)
          {
            v30 = (_WORD)v27 - v7 + 1;
            goto LABEL_56;
          }
          v27 += v28 + 1;
          if (v6 != -260)
            goto LABEL_41;
        }
      }
      else
      {
LABEL_41:
        if ((unint64_t)v27 < v6 + 260)
          goto LABEL_42;
      }
      v30 = 257;
    }
LABEL_56:
    *(_DWORD *)buf = 67110147;
    v61 = v20;
    v62 = 2160;
    v63 = 1752392040;
    v64 = 1040;
    v65 = v30;
    v66 = 2101;
    v67 = v6 + 4;
    v68 = 1024;
    v69 = v10;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[Q%u] AnswerQuestionByFollowingCNAME: following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, referral count: %u", buf, 0x28u);
    goto LABEL_57;
  }
  v12 = v9;
  v13 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      v15 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v16 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_13:
        while (v16)
        {
          v17 = *v16;
          if (v17 > 0x3F)
            break;
          if (!*v16)
          {
            v29 = (unsigned __int16)((_WORD)v16 - v7 + 1);
            goto LABEL_54;
          }
          v16 += v17 + 1;
          if (v6 != -260)
            goto LABEL_12;
        }
      }
      else
      {
LABEL_12:
        if ((unint64_t)v16 < v6 + 260)
          goto LABEL_13;
      }
      v29 = 257;
      goto LABEL_54;
    }
  }
  else
  {
    v13 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v15 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      v24 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_34:
        while (v24)
        {
          v25 = *v24;
          if (v25 > 0x3F)
            break;
          if (!*v24)
          {
            v29 = (unsigned __int16)((_WORD)v24 - v7 + 1);
            goto LABEL_54;
          }
          v24 += v25 + 1;
          if (v6 != -260)
            goto LABEL_33;
        }
      }
      else
      {
LABEL_33:
        if ((unint64_t)v24 < v6 + 260)
          goto LABEL_34;
      }
      v29 = 257;
LABEL_54:
      *(_DWORD *)buf = 67110403;
      v61 = v15;
      v62 = 2160;
      v63 = 1752392040;
      v64 = 1040;
      v65 = v29;
      v66 = 2101;
      v67 = v6 + 4;
      v68 = 1024;
      v69 = v10;
      v70 = 1024;
      v71 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[Q%u] AnswerQuestionByFollowingCNAME: Not following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, referral count: %u, self referential: %{mdns:yesno}d", buf, 0x2Eu);
    }
  }
}

uint64_t PerformNextPunycodeConversion(uint64_t a1, char *a2)
{
  unsigned int v2;
  const char *v4;
  _BYTE *v5;
  unint64_t v6;
  const char *v7;
  uint64_t result;
  unsigned __int8 *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  UIDNA *v13;
  int32_t v14;
  char *v15;
  unsigned __int8 *v16;
  size_t v17;
  unsigned __int8 *v18;
  uint64_t v19;
  UIDNAInfo v20;
  UErrorCode pErrorCode;

  v2 = *(unsigned __int8 *)(a1 + 376);
  if (!*(_BYTE *)(a1 + 376))
    return 0;
  v4 = 0;
  v5 = (_BYTE *)(a1 + 376);
  v6 = a1 + 632;
  v7 = (const char *)(a1 + 376);
  while (1)
  {
    result = 0;
    if (v2 > 0x3F)
      return result;
    v9 = (unsigned __int8 *)&v7[v2 + 1];
    if ((unint64_t)v9 >= v6)
      return result;
    v10 = 0;
    while ((v7[v10 + 1] & 0x80000000) == 0)
    {
      if (v2 == ++v10)
        goto LABEL_10;
    }
    v4 = v7;
LABEL_10:
    v2 = *v9;
    v7 = (const char *)v9;
    if (!*v9)
    {
      if (v4)
      {
        v11 = &a2[v4 - v5];
        v12 = a2 + 256;
        pErrorCode = U_ZERO_ERROR;
        v20 = (UIDNAInfo)xmmword_100100A00;
        v13 = uidna_openUTS46(0x22u, &pErrorCode);
        v14 = uidna_nameToASCII_UTF8(v13, v4 + 1, *(unsigned __int8 *)v4, v11 + 1, (_DWORD)v12 - ((_DWORD)v11 + 1), &v20, &pErrorCode);
        uidna_close(v13);
        if (pErrorCode == U_ZERO_ERROR && !v20.errors && v14 < 64)
        {
          *v11 = v14;
          v15 = &v11[v14 + 1];
          if (v15)
          {
            v16 = (unsigned __int8 *)&v4[*(unsigned __int8 *)v4 + 1];
            v17 = 257;
            v18 = v16;
            if (v16 == (unsigned __int8 *)-256)
            {
LABEL_18:
              while (v18)
              {
                v19 = *v18;
                if (v19 > 0x3F)
                  break;
                if (!*v18)
                {
                  v17 = (unsigned __int16)((_WORD)v18 - (_WORD)v16 + 1);
                  break;
                }
                v18 += v19 + 1;
                if (v16 != (unsigned __int8 *)-256)
                  goto LABEL_17;
              }
            }
            else
            {
LABEL_17:
              if (v18 < v16 + 256)
                goto LABEL_18;
            }
            if (&v15[v17] <= v12)
            {
              memcpy(a2, v5, ((_DWORD)v4 - (_DWORD)v5));
              memcpy(v15, v16, v17);
              return 1;
            }
          }
        }
      }
      return 0;
    }
  }
}

uint64_t CheckForSoonToExpireRecordsEx(uint64_t a1, _BYTE *a2, unsigned int a3, int a4, int a5)
{
  int v7;
  uint64_t *v8;
  uint64_t v9;
  BOOL v11;
  unsigned int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  int v15;
  unsigned int v17;

  v7 = *(_DWORD *)(a1 + 64);
  v8 = CacheGroupForName(a1, a3, a2);
  if (v8)
  {
    v9 = v8[2];
    if (v9)
    {
      v11 = a4 < 0 || a4 == 255;
      v12 = v7 - 0x10000000;
      while (1)
      {
        if (v11)
        {
          v13 = 1;
          if (a5 < 0)
            goto LABEL_14;
        }
        else
        {
          v13 = *(unsigned __int16 *)(v9 + 12) == a4;
          if (a5 < 0)
          {
LABEL_14:
            v14 = 1;
            goto LABEL_15;
          }
        }
        v14 = *(unsigned __int16 *)(v9 + 14) == a5;
LABEL_15:
        if (v13 && v14)
        {
          v15 = dword_100158E08 + 939524096;
          if (!*(_BYTE *)(v9 + 109))
            v15 = *(_DWORD *)(v9 + 80) + 1000 * *(_DWORD *)(v9 + 16);
          if ((int)(v15 - v12) > 0 && v7 + 1000 - v15 > -1)
            v12 = v15;
        }
        v9 = *(_QWORD *)v9;
        if (!v9)
          goto LABEL_26;
      }
    }
  }
  v12 = v7 - 0x10000000;
LABEL_26:
  if (v12 <= 1)
    v17 = 1;
  else
    v17 = v12;
  if ((int)(v12 - (v7 - 0x10000000)) <= 0)
    return 0;
  else
    return v17;
}

uint64_t DetermineUnicastQuerySuppression(uint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  NSObject *v5;
  unsigned int v7;
  _BYTE *v8;
  uint64_t v9;
  _BYTE *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  const char *v16;
  _DWORD v18[2];
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;

  if (*(_BYTE *)(a1 + 654))
  {
    v3 = " (blocked by policy)";
    v4 = 1;
    goto LABEL_3;
  }
  if (!a2)
  {
    if (!*(_BYTE *)(a1 + 638))
    {
      v3 = " (no DNS service)";
      v4 = 2;
      goto LABEL_3;
    }
    return 0;
  }
  v13 = *(_DWORD *)(a1 + 324);
  if ((v13 & 0x8000000) != 0 && (*(_WORD *)(a2 + 276) & 8) != 0)
  {
    v3 = " (interface is cellular)";
    v4 = 3;
    goto LABEL_3;
  }
  if ((v13 & 0x20000000) != 0 && (*(_WORD *)(a2 + 276) & 0x40) != 0)
  {
    v3 = " (interface is expensive)";
    v4 = 4;
    goto LABEL_3;
  }
  if ((v13 & 0x2000) != 0 && (*(_WORD *)(a2 + 276) & 0x80) != 0)
  {
    v3 = " (interface is constrained)";
    v4 = 5;
    goto LABEL_3;
  }
  if (!*(_BYTE *)(a1 + 636) || *(unsigned __int8 *)(a1 + 672) - 3 < 2)
    return 0;
  v14 = *(unsigned __int16 *)(a1 + 342);
  if (v14 == 28)
  {
    if ((*(_WORD *)(a2 + 276) & 4) == 0)
    {
      v3 = " (AAAA records are unusable)";
      goto LABEL_51;
    }
    return 0;
  }
  if (v14 != 1 || (*(_WORD *)(a2 + 276) & 2) != 0)
    return 0;
  v3 = " (A records are unusable)";
LABEL_51:
  v4 = 6;
LABEL_3:
  v5 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      v7 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
      v8 = (_BYTE *)(a1 + 376);
      if (a1 == -632)
      {
LABEL_11:
        while (v8)
        {
          v9 = *v8;
          if (v9 > 0x3F)
            break;
          if (!*v8)
          {
            v15 = (unsigned __int16)((_WORD)v8 - (a1 + 376) + 1);
            goto LABEL_43;
          }
          v8 += v9 + 1;
          if (a1 != -632)
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        if ((unint64_t)v8 < a1 + 632)
          goto LABEL_11;
      }
      v15 = 257;
      goto LABEL_43;
    }
  }
  else
  {
    v5 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v7 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
      v11 = (_BYTE *)(a1 + 376);
      if (a1 == -632)
      {
LABEL_19:
        while (v11)
        {
          v12 = *v11;
          if (v12 > 0x3F)
            break;
          if (!*v11)
          {
            v15 = (unsigned __int16)((_WORD)v11 - (a1 + 376) + 1);
            goto LABEL_43;
          }
          v11 += v12 + 1;
          if (a1 != -632)
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v11 < a1 + 632)
          goto LABEL_19;
      }
      v15 = 257;
LABEL_43:
      v16 = DNSTypeName(*(unsigned __int16 *)(a1 + 342));
      v18[0] = 67110403;
      v18[1] = v7;
      v19 = 2160;
      v20 = 1752392040;
      v21 = 1040;
      v22 = v15;
      v23 = 2101;
      v24 = a1 + 376;
      v25 = 2082;
      v26 = v16;
      v27 = 2082;
      v28 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[Q%u] DetermineUnicastQuerySuppression: Query suppressed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{public}s%{public}s", (uint8_t *)v18, 0x36u);
    }
  }
  return v4;
}

BOOL QuestionSendsMDNSQueriesViaUnicast(uint64_t a1)
{
  int v2;
  int v3;

  if (*(_WORD *)(a1 + 340))
    return 0;
  v2 = *(_DWORD *)(a1 + 304);
  if (v2 == 6)
  {
    v3 = *(_DWORD *)(a1 + 312) | *(_DWORD *)(a1 + 308) | *(_DWORD *)(a1 + 316) | *(_DWORD *)(a1 + 320);
  }
  else
  {
    if (v2 != 4)
      return 0;
    v3 = *(_DWORD *)(a1 + 308);
  }
  return v3 != 0;
}

uint64_t mDNS_PurgeBeforeResolve(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  uint64_t v17;

  result = (uint64_t)CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 376));
  if (result)
  {
    v10 = *(_QWORD *)(result + 16);
    if (v10)
    {
      while (1)
      {
        result = SameNameRecordAnswersQuestion((unsigned __int8 *)(v10 + 8), 0, a2, v5, v6, v7, v8, v9);
        if ((_DWORD)result)
          break;
LABEL_14:
        v10 = *(_QWORD *)v10;
        if (!v10)
          return result;
      }
      v11 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_13:
          result = mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v10);
          goto LABEL_14;
        }
      }
      else
      {
        v11 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_13;
      }
      GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(_QWORD *)(v10 + 48) + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      v15 = 1752392040;
      v16 = 2085;
      v17 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "mDNS_PurgeBeforeResolve: Flushing %{sensitive, mask.hash}s", buf, 0x16u);
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t SetNextCacheCheckTimeForRecord(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;

  v3 = result;
  if (*(_BYTE *)(a2 + 109))
    v4 = dword_100158E08 + 939524096;
  else
    v4 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 88) = v4;
  v5 = *(_QWORD *)(a2 + 64);
  if (v5 && *(_DWORD *)(v5 + 32) == 1 && *(_BYTE *)(a2 + 108) != 4)
    *(_BYTE *)(a2 + 108) = 4;
  v6 = *(_QWORD *)(a2 + 96);
  if (!v6)
  {
    v12 = *(_DWORD *)(a2 + 24);
    goto LABEL_20;
  }
  v7 = *(unsigned __int8 *)(a2 + 108);
  if (v7 < 4)
  {
    if (*(_BYTE *)(a2 + 108) || *(_BYTE *)(a2 + 130))
    {
      v8 = -4;
    }
    else if (*(_WORD *)(v6 + 340))
    {
      v8 = -4;
    }
    else
    {
      v8 = -5;
    }
    v9 = 1000 * *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 88) = v4 + (int)v9 / 20 * (v8 + v7);
    v10 = v9 / 0x32;
    v11 = 1;
    if (v9 >= 0x64)
    {
      do
        v11 = (2 * v11) | 1;
      while (v11 < v10);
    }
    do
      result = arc4random();
    while ((result & v11) > v10);
    v4 = *(_DWORD *)(a2 + 88) + (result & v11);
    *(_DWORD *)(a2 + 88) = v4;
    v12 = *(_DWORD *)(a2 + 24);
    if (*(_QWORD *)(a2 + 96))
    {
      v13 = *(_DWORD *)(a2 + 16);
      if (*(unsigned __int8 *)(a2 + 108) <= 3u)
      {
        v14 = (int)(1000 * v13) / 50;
        goto LABEL_28;
      }
      goto LABEL_22;
    }
LABEL_20:
    v14 = 60000;
    goto LABEL_28;
  }
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)(a2 + 16);
LABEL_22:
  if (v13)
    v15 = 100;
  else
    v15 = 0;
  if (v13 <= 0xA)
    v14 = v15;
  else
    v14 = 1000;
LABEL_28:
  v16 = v14 + v4;
  v17 = v3 + 4 * (v12 % 0x1F3);
  if (*(_DWORD *)(v17 + 4264) - v16 >= 1)
    *(_DWORD *)(v17 + 4264) = v16;
  if (*(_DWORD *)(v3 + 88) - v16 >= 1)
    *(_DWORD *)(v3 + 88) = v16;
  return result;
}

BOOL SameResourceRecordNameClassInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int vars0;

  if (a2)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (!v8 || ((v9 = *(_QWORD *)(a2 + 32)) != 0 ? (v10 = v8 == v9) : (v10 = 1), v10))
    {
      if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
      {
        return SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40)) != 0;
      }
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SameResourceRecordSignature ERROR: r2 is NULL", a4, a5, a6, a7, a8, vars0);
  }
  return 0;
}

void ActivateUnicastRegistration(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  NSObject *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  char *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;

  v4 = *(unsigned __int16 *)(a2 + 12);
  if (v4 == 16)
  {
    v5 = (uint64_t *)(a2 + 88);
  }
  else
  {
    if (v4 != 12)
      goto LABEL_11;
    v5 = (uint64_t *)(a2 + 72);
  }
  v6 = *v5;
  if (*v5)
  {
    v7 = (unsigned __int8 *)(v6 + 8);
    if (*(_WORD *)(v6 + 12) == 33)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        v8 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), (_BYTE *)(a1 + 47032));
        DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration: Found Service Record %s in state %d for %##s (%s)", v9, v10, v11, v12, v13, a1 + 47032);
      }
      *(_DWORD *)(a2 + 344) = *(_DWORD *)(v6 + 344);
    }
    else
    {
      v14 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration: ERROR!! Resource record %s wrong, expecting SRV type", v15, v16, v17, v18, v19, a1 + 47032);
    }
  }
LABEL_11:
  v20 = (unsigned __int8 *)(a2 + 8);
  if (*(_DWORD *)(a2 + 344) == 8)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v21 = mDNSLogCategory_Default;
      v22 = (_BYTE *)(a1 + 47032);
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v22);
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration record %s in regState_NoTarget, not activating", v23, v24, v25, v26, v27, (int)v22);
    }
  }
  else
  {
    v28 = *v20;
    if (v28 == 1)
      v29 = 3;
    else
      v29 = 1;
    if (mDNS_LoggingEnabled == 1)
    {
      if (v28 == 1)
        v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to DeregPending";
      else
        v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to Pending";
      v31 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, v30, v32, v33, v34, v35, v36, a1 + 47032);
    }
    *(_DWORD *)(a2 + 344) = v29;
    *(_DWORD *)(a2 + 180) = 0;
    *(_DWORD *)(a2 + 184) = 0;
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
    *(_DWORD *)(a2 + 352) = 0;
    *(_BYTE *)(a2 + 348) = 1;
    *(_WORD *)(a2 + 358) = 0;
    *(_BYTE *)(a2 + 592) = 0;
    *(_DWORD *)(a2 + 604) = 0;
    if (*(_QWORD *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
      *(_QWORD *)(a2 + 584) = 0;
    }
    v37 = *(_DWORD **)(a2 + 376);
    if (v37)
    {
      CancelGetZoneData(a1, v37);
      *(_QWORD *)(a2 + 376) = 0;
    }
    v38 = *(_QWORD *)(a2 + 384);
    if (v38)
    {
      DisposeTCPConn(v38);
      *(_QWORD *)(a2 + 384) = 0;
    }
    v39 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (*(_DWORD *)(a1 + 12680) - v39 >= 0)
      *(_DWORD *)(a1 + 12680) = v39;
  }
}

uint64_t *CheckAuthRecordConflict(uint64_t a1, uint64_t a2)
{
  uint64_t *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (result)
  {
    v10 = result[2];
    if (v10)
    {
      while (1)
      {
        v11 = *(_QWORD *)(a2 + 96);
        if (!v11)
          v11 = a2;
        v12 = *(_QWORD *)(v10 + 96);
        if (!v12)
          v12 = v10;
        if (v11 != v12
          && *(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(a2 + 12)
          && SameResourceRecordNameClassInterface(v10, a2, v4, v5, v6, v7, v8, v9)
          && (!resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v10 + 64), *(_QWORD *)(a2 + 64))
           || *(unsigned __int16 *)(v10 + 12) != *(unsigned __int16 *)(a2 + 12)
           || *(unsigned __int16 *)(v10 + 14) != *(unsigned __int16 *)(a2 + 14)
           || *(unsigned __int16 *)(v10 + 20) != *(unsigned __int16 *)(a2 + 20)
           || *(_DWORD *)(v10 + 28) != *(_DWORD *)(a2 + 28)
           || !SameRDataBody(v10 + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)))
        {
          break;
        }
        v10 = *(_QWORD *)v10;
        if (!v10)
          return 0;
      }
      return (uint64_t *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IdenticalResourceRecord(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
    return 0;
  result = resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a1 + 56), *(_QWORD *)(a2 + 56));
  if (!(_DWORD)result)
    return result;
  if (*(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0;
  }
  result = SameRDataBody(a1, (unsigned __int16 *)(*(_QWORD *)(a2 + 40) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if ((_DWORD)result)
    return SameDomainNameBytes(*(_BYTE **)(a1 + 32), *(_BYTE **)(a2 + 32)) != 0;
  return result;
}

uint64_t CheckAuthIdenticalRecord(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t i;
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;

  v3 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (!v3)
    return 0;
  for (i = v3[2]; i; i = *(_QWORD *)i)
  {
    if (*(_QWORD *)(i + 32) == *(_QWORD *)(a2 + 32))
    {
      v5 = *(unsigned __int8 *)(i + 8);
      v6 = *(unsigned __int8 *)(a2 + 8);
      v7 = v6 == 1 || v5 == 1;
      v8 = v7 || v5 == v6;
      v9 = v8 || (v6 | v5) == 18;
      if (v9
        && *(_DWORD *)(i + 24) == *(_DWORD *)(a2 + 24)
        && resource_records_have_same_dnssec_rr_category(*(_QWORD *)(i + 64), *(_QWORD *)(a2 + 64))
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a2 + 12)
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(unsigned __int16 *)(i + 20) == *(unsigned __int16 *)(a2 + 20)
        && *(_DWORD *)(i + 28) == *(_DWORD *)(a2 + 28)
        && SameRDataBody(i + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(_BYTE **)(i + 40), *(_BYTE **)(a2 + 40)))
      {
        if (*(_BYTE *)(i + 8) != 1)
          return i;
        *(_BYTE *)(i + 191) = 0;
      }
    }
  }
  return i;
}

void IncrementAutoTargetServices(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _BYTE *v5;
  int *v6;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t i;
  int v18;
  _BYTE v19[30];

  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    v4 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      v5 = (_BYTE *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v5);
      v18 = 141558275;
      *(_QWORD *)v19 = 1752392040;
      *(_WORD *)&v19[8] = 2085;
      *(_QWORD *)&v19[10] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "IncrementAutoTargetServices: called for RRLocalOnly() record: %{sensitive, mask.hash}s", (uint8_t *)&v18, 0x16u);
    }
    return;
  }
  v6 = (int *)(a1 + 19900);
  if (!*(_QWORD *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
    goto LABEL_12;
  v7 = *(_DWORD *)(a1 + 19904) + 1;
  *(_DWORD *)(a1 + 19904) = v7;
  v8 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    v9 = *(_DWORD *)(a1 + 19908);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    v18 = 67109891;
    *(_DWORD *)v19 = v7;
    *(_WORD *)&v19[4] = 1024;
    *(_DWORD *)&v19[6] = v9;
    *(_WORD *)&v19[10] = 2160;
    *(_QWORD *)&v19[12] = 1752392040;
    *(_WORD *)&v19[20] = 2085;
    *(_QWORD *)&v19[22] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "IncrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s", (uint8_t *)&v18, 0x22u);
    v7 = *(_DWORD *)(a1 + 19904);
  }
  if (*(_DWORD *)(a1 + 19908) + v7 == 1)
  {
    *(_DWORD *)(a1 + 116) = 0;
    v10 = 1;
    if (!*(_BYTE *)(a1 + 120))
    {
      *(_BYTE *)(a1 + 120) = 1;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 64);
      v10 = 0;
    }
  }
  else
  {
LABEL_12:
    v10 = 1;
  }
  if ((*(_QWORD *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
    && *(_WORD *)(a2 + 12) == 33
    && *(_BYTE *)(a2 + 120) == 1)
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2)
    {
      v11 = *(_DWORD *)(a1 + 10920) + 1;
      *(_DWORD *)(a1 + 10920) = v11;
      v12 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        v18 = 67109635;
        *(_DWORD *)v19 = v11;
        *(_WORD *)&v19[4] = 2160;
        *(_QWORD *)&v19[6] = 1752392040;
        *(_WORD *)&v19[14] = 2085;
        *(_QWORD *)&v19[16] = a1 + 47032;
        v13 = "IncrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s";
LABEL_30:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&v18, 0x1Cu);
      }
    }
    else
    {
      v14 = *(_QWORD *)(a2 + 32);
      if (AWDLInterfaceID && AWDLInterfaceID == v14)
      {
        v12 = mDNSLogCategory_State;
      }
      else
      {
        v12 = mDNSLogCategory_State;
        if (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v14)
        {
          v16 = *v6 + 1;
          *v6 = v16;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
            v18 = 67109635;
            *(_DWORD *)v19 = v16;
            *(_WORD *)&v19[4] = 2160;
            *(_QWORD *)&v19[6] = 1752392040;
            *(_WORD *)&v19[14] = 2085;
            *(_QWORD *)&v19[16] = a1 + 47032;
            v13 = "IncrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s";
            goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      v15 = *(_DWORD *)(a1 + 10924) + 1;
      *(_DWORD *)(a1 + 10924) = v15;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        v18 = 67109635;
        *(_DWORD *)v19 = v15;
        *(_WORD *)&v19[4] = 2160;
        *(_QWORD *)&v19[6] = 1752392040;
        *(_WORD *)&v19[14] = 2085;
        *(_QWORD *)&v19[16] = a1 + 47032;
        v13 = "IncrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s";
        goto LABEL_30;
      }
    }
LABEL_31:
    if (v10)
    {
      for (i = *(_QWORD *)(a1 + 12656); i; i = *(_QWORD *)i)
      {
        if (*(_BYTE *)(i + 3670))
          AdvertiseInterfaceIfNeeded((_DWORD *)a1, i);
      }
    }
  }
}

void mDNS_UpdateAllowSleep(uint64_t a1)
{
  int *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  uint32_t v17;
  IOPMAssertionID v18;
  const char *v19;
  uint64_t v20;
  CFStringRef v21;
  CFStringRef v22;
  const __CFString *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint8_t buf[4];
  uint64_t v29;
  _OWORD v30[8];

  memset(v30, 0, sizeof(v30));
  if (!*(_BYTE *)(a1 + 144))
    goto LABEL_11;
  v2 = (int *)(a1 + 19888);
  if (*(_DWORD *)(a1 + 19888))
  {
    mDNS_snprintf(v30);
    v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_20;
      v15 = *v2;
      *(_DWORD *)buf = 67109120;
      LODWORD(v29) = v15;
      v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }
    else
    {
      v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_20;
      v4 = *v2;
      *(_DWORD *)buf = 67109120;
      LODWORD(v29) = v4;
      v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }
    v16 = v3;
    v17 = 8;
    goto LABEL_19;
  }
  if (!mDNSCoreHaveAdvertisedMulticastServices(*(_QWORD *)(a1 + 12616))
    || (v13 = *(_QWORD *)(a1 + 12656)) == 0)
  {
LABEL_11:
    if (!*(_DWORD *)(mDNSStorage[0] + 584))
      return;
    v14 = mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_36;
      }
    }
    else
    {
      v14 = mDNSLogCategory_SPS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetAllowSleep Destroying NoIdleSleep power assertion", buf, 2u);
      }
    }
    IOPMAssertionRelease(*(_DWORD *)(mDNSStorage[0] + 584));
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
    return;
  }
  while (!*(_BYTE *)(v13 + 16))
  {
    v13 = *(_QWORD *)v13;
    if (!v13)
      goto LABEL_11;
  }
LABEL_42:
  if (!*(_BYTE *)(v13 + 3671)
    || *(_BYTE *)(v13 + 3673)
    || *(_BYTE *)(v13 + 3678)
    || mDNSPlatformInterfaceIsD2D(*(_QWORD *)(v13 + 3552), v6, v7, v8, v9, v10, v11, v12))
  {
LABEL_40:
    while (1)
    {
      v13 = *(_QWORD *)v13;
      if (!v13)
        goto LABEL_11;
      if (*(_BYTE *)(v13 + 16))
        goto LABEL_42;
    }
  }
  if (*(_BYTE *)(v13 + 3672))
  {
    if (SupportsInNICProxy(v13))
      goto LABEL_40;
    v27 = v13 + 3606;
    mDNS_snprintf(v30);
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v29 = v27;
        v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
        goto LABEL_59;
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v29 = v27;
        v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
        goto LABEL_59;
      }
    }
  }
  else
  {
    v25 = v13 + 3606;
    mDNS_snprintf(v30);
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v29 = v25;
        v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
        goto LABEL_59;
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v29 = v25;
        v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
LABEL_59:
        v16 = v26;
        v17 = 12;
LABEL_19:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v5, buf, v17);
      }
    }
  }
LABEL_20:
  v18 = *(_DWORD *)(mDNSStorage[0] + 584);
  if (v18)
  {
    IOPMAssertionRelease(v18);
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
  }
  v19 = getprogname();
  v20 = getpid();
  v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s.%d %s"), v19, v20, v30);
  v22 = v21;
  if (v21)
    v23 = v21;
  else
    v23 = CFSTR("mDNSResponder");
  IOPMAssertionCreateWithName(CFSTR("NoIdleSleepAssertion"), 0xFFu, v23, (IOPMAssertionID *)(mDNSStorage[0] + 584));
  if (v22)
    CFRelease(v22);
  v24 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_33;
    }
  }
  else
  {
    v24 = mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetAllowSleep Creating NoIdleSleep power assertion", buf, 2u);
    }
  }
}

void getKeepaliveRaddr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v6;
  uint64_t v7;
  NSObject *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  __int16 v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  __int16 v20;
  __int16 v21;
  _BYTE v22[6];
  uint64_t v23;
  uint64_t v24;
  int v25;

  v23 = 0;
  v24 = 0;
  v25 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  if (*(_WORD *)(a2 + 12) == 10)
  {
    v6 = *(_BYTE **)(a2 + 40);
    v7 = *v6 ? *v6 + 1 : 0;
    if (SameDomainLabelPointer(&v6[v7], "\n_keepalive"))
    {
      mDNS_ExtractKeepaliveInfo(a2, &v19, &v23, (_DWORD *)a3, (uint64_t)v22, &v18, &v17, &v21, &v20, &v16);
      if (!v19 || v23 == 4 || (_DWORD)v23 == 6 && !(v24 | HIDWORD(v24) | v25 | HIDWORD(v23)))
        goto LABEL_8;
      if (*(_DWORD *)a3 == 6)
      {
        if (vorr_s8(*(int8x8_t *)(a3 + 4), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a3 + 4), *(int8x16_t *)(a3 + 4), 8uLL)))
        {
          v15 = v21 == 0;
        }
        else
        {
          v15 = 1;
        }
        if (v15)
          goto LABEL_8;
      }
      else if (*(_DWORD *)a3 == 4 && !*(_DWORD *)(a3 + 4) || !v21)
      {
        goto LABEL_8;
      }
      if (!v20)
      {
LABEL_8:
        v8 = mDNSLogCategory_Default;
        v9 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v9);
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "getKeepaliveRaddr: not a valid record %s for keepalive %#a:%d %#a:%d", v10, v11, v12, v13, v14, (int)v9);
      }
    }
  }
}

void mDNS_ExtractKeepaliveInfo(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, unsigned int *a6, unsigned int *a7, _WORD *a8, _WORD *a9, _WORD *a10)
{
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unint64_t v24;
  unsigned int v25;
  unsigned __int8 *ValueForIPv6Addr;
  int v27;
  int v28;
  _BYTE *v29;
  uint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  unsigned __int8 *v34;
  int v35;
  unsigned int v36;
  unsigned int *v37;
  NSObject *v38;
  _BOOL4 v40;
  unsigned int v41;
  _WORD *v42;
  _BOOL4 v43;
  NSObject *v44;
  unsigned __int8 *v45;
  uint8_t buf[4];
  int v50;

  if (*(_WORD *)(a1 + 12) != 10)
    return;
  v15 = *(_BYTE **)(a1 + 40);
  v16 = *v15 ? *v15 + 1 : 0;
  if (!SameDomainLabelPointer(&v15[v16], "\n_keepalive"))
    return;
  v22 = (unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 5);
  v23 = &v22[*(unsigned __int16 *)(a1 + 20)];
  v24 = (unint64_t)(v23 - 1);
  if (v22 >= v23 - 1)
    return;
  v25 = 0;
  v45 = v23 - 2;
  while (1)
  {
    v28 = *v22;
    ValueForIPv6Addr = v22 + 2;
    v27 = v28;
    if (v28 <= 99)
    {
      if (v27 == 68)
      {
        *a4 = 6;
        v31 = v24;
        v32 = a4 + 1;
      }
      else
      {
        if (v27 != 72)
          goto LABEL_21;
        *a3 = 6;
        v31 = v24;
        v32 = a3 + 1;
      }
      ValueForIPv6Addr = GetValueForIPv6Addr((unint64_t)ValueForIPv6Addr, v31, v32, v17, v18, v19, v20, v21);
      goto LABEL_30;
    }
    switch(v27)
    {
      case 'd':
        *a4 = 4;
        v29 = (_BYTE *)v24;
        v30 = (uint64_t)(a4 + 1);
        goto LABEL_17;
      case 'm':
        ValueForIPv6Addr = (unsigned __int8 *)GetValueForMACAddr((unint64_t)ValueForIPv6Addr, v24, a5, v17, v18, v19, v20, v21);
        goto LABEL_30;
      case 'h':
        *a3 = 4;
        v29 = (_BYTE *)v24;
        v30 = (uint64_t)(a3 + 1);
LABEL_17:
        ValueForIPv6Addr = GetValueForIPv4Addr(ValueForIPv6Addr, v29, v30, v17, v18, v19, v20, v21);
        goto LABEL_30;
    }
LABEL_21:
    if ((unint64_t)ValueForIPv6Addr >= v24)
    {
      v25 = 0;
      goto LABEL_30;
    }
    v25 = 0;
    v33 = v24 - (_QWORD)ValueForIPv6Addr;
    v34 = ValueForIPv6Addr;
    while (1)
    {
      v35 = *v34;
      if (v35 == 32)
        goto LABEL_31;
      ValueForIPv6Addr = v34 + 1;
      if ((v35 - 58) <= 0xFFFFFFF5)
        break;
      v25 = v35 + 10 * v25 - 48;
      ++v34;
      if (!--v33)
      {
        ValueForIPv6Addr = (unsigned __int8 *)v24;
        goto LABEL_30;
      }
    }
    if (v34 != v45 || *v34)
      break;
LABEL_30:
    v34 = ValueForIPv6Addr;
    if (!ValueForIPv6Addr)
      goto LABEL_54;
LABEL_31:
    switch(v27)
    {
      case 'a':
        v36 = bswap32(v25);
        v37 = a7;
        goto LABEL_45;
      case 'b':
      case 'e':
      case 'f':
      case 'g':
      case 'j':
      case 'k':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'u':
      case 'v':
        goto LABEL_35;
      case 'c':
      case 'd':
      case 'h':
      case 'i':
      case 'm':
        goto LABEL_49;
      case 'l':
        v41 = bswap32(v25) >> 16;
        v42 = a8;
        goto LABEL_48;
      case 'r':
        v41 = bswap32(v25) >> 16;
        v42 = a9;
        goto LABEL_48;
      case 's':
        v36 = bswap32(v25);
        v37 = a6;
LABEL_45:
        *v37 = v36;
        goto LABEL_49;
      case 't':
        *a2 = v25;
        goto LABEL_49;
      case 'w':
        v41 = bswap32(v25) >> 16;
        v42 = a10;
LABEL_48:
        *v42 = v41;
        goto LABEL_49;
      default:
        if (v27 == 68 || v27 == 72)
          goto LABEL_49;
LABEL_35:
        v38 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          v40 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
          v34 = (unsigned __int8 *)v24;
          if (!v40)
            goto LABEL_49;
LABEL_52:
          *(_DWORD *)buf = 67109120;
          v50 = v27;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "mDNS_ExtractKeepaliveInfo: unknown value %c\n", buf, 8u);
          v34 = (unsigned __int8 *)v24;
          goto LABEL_49;
        }
        v38 = mDNSLogCategory_Default_redacted;
        v43 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        v34 = (unsigned __int8 *)v24;
        if (v43)
          goto LABEL_52;
LABEL_49:
        v22 = v34 + 1;
        if ((unint64_t)(v34 + 1) >= v24)
          return;
        break;
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForKeepalive: *ptr %d, ptr %p, limit %p, ptr +1 %d", v17, v18, v19, v20, v21, v35);
LABEL_54:
  v44 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "mDNS_ExtractKeepaliveInfo: Cannot parse\n", buf, 2u);
    }
  }
  else
  {
    v44 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_60;
    }
  }
}

_BYTE *GetValueForIPv4Addr(_BYTE *result, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  NSObject *v12;

  if (result >= a2)
  {
    v8 = 0;
LABEL_15:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv4Addr: Address malformed dots %d", a4, a5, a6, a7, a8, v8);
    return 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = a2 - result;
    do
    {
      v11 = *result;
      if (v11 == 32)
        goto LABEL_12;
      if ((v11 - 48) > 9)
      {
        if (v11 != 46)
        {
          if (!*result && result == a2 - 1 && v8 == 3)
          {
            *(_BYTE *)(a3 + 3) = v9;
            return ++result;
          }
          v12 = mDNSLogCategory_Default;
          goto LABEL_22;
        }
        if (v9 > 0xFF || v8 >= 3)
        {
          v12 = mDNSLogCategory_Default;
LABEL_22:
          LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "GetValueForIPv4Addr: something wrong ptr(%p) %c, limit %p, dots %d", a4, a5, a6, a7, a8, (int)result);
          return 0;
        }
        *(_BYTE *)(a3 + v8++) = v9;
        v9 = 0;
      }
      else
      {
        v9 = v11 + 10 * v9 - 48;
      }
      ++result;
      --v10;
    }
    while (v10);
    result = a2;
LABEL_12:
    if (v8 != 3)
      goto LABEL_15;
    *(_BYTE *)(a3 + 3) = v9;
  }
  return result;
}

_BYTE *GetValueForIPv6Addr(unint64_t a1, unint64_t a2, _QWORD *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  _BYTE *v15;
  int v16;
  int v17;
  int v18;
  _BYTE *v19;
  NSObject *v20;
  char *v21;
  uint64_t v23;
  int v24;
  int v26;
  __int128 __src;

  if (a1 >= a2)
  {
    v12 = 0;
LABEL_25:
    v20 = mDNSLogCategory_Default;
    v26 = v12;
    v21 = "GetValueForIPv6Addr: no trailing bytes after colon, numBytes is %d";
LABEL_26:
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, v21, a4, a5, a6, a7, a8, v26);
    return 0;
  }
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  __src = 0uLL;
  v14 = a2 - a1;
  v15 = (_BYTE *)(a1 + 1);
  while (1)
  {
    v16 = *(v15 - 1);
    if (v16 == 32)
      break;
    if ((v16 - 48) >= 0xA)
    {
      if ((v16 - 65) >= 6)
      {
        if ((v16 - 97) > 5)
          goto LABEL_12;
        v17 = -87;
      }
      else
      {
        v17 = -55;
      }
    }
    else
    {
      v17 = -48;
    }
    v18 = v17 + v16;
    if (v18 == -1)
    {
LABEL_12:
      if (v16 == 58)
      {
        if (v11)
        {
          if ((unint64_t)v15 < a2 && *v15 == 32)
          {
            v20 = mDNSLogCategory_Default;
            v21 = "GetValueForIPv6Addr: Trailing colon";
            goto LABEL_26;
          }
          if (v12 >= 14)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:1: numBytes is %d", a4, a5, a6, a7, a8, v12);
            return 0;
          }
          *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
          if (v12 == 13)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:2: numBytes is %d", a4, a5, a6, a7, a8, 15);
            return 0;
          }
          v13 = 0;
          v11 = 0;
          v12 += 2;
        }
        else
        {
          if (v9)
          {
            if (!v12)
            {
              v19 = v15;
              if ((unint64_t)v15 < a2 && *v15 == 32)
              {
                *__dst = 0;
                __dst[1] = 0;
                return v19;
              }
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr: zeroFillStart non-zero %d", a4, a5, a6, a7, a8, v10);
            return 0;
          }
          v11 = 0;
          v9 = 1;
          v10 = v12;
        }
      }
      goto LABEL_21;
    }
    v13 = v18 | (16 * v13);
    v11 = 1;
LABEL_21:
    ++v15;
    if (!--v14)
    {
      v19 = (_BYTE *)a2;
      if (!v11)
        goto LABEL_25;
      goto LABEL_30;
    }
  }
  v19 = v15 - 1;
  if (!v11)
    goto LABEL_25;
LABEL_30:
  if (v12 >= 15)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:3: numBytes is %d", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
  if (v10)
  {
    if (v10 < 1)
      v10 = 0;
    else
      memcpy(__dst, &__src, v10);
    LODWORD(v23) = v10;
    if (14 - v12 >= 1)
    {
      v24 = v12 - 14;
      LODWORD(v23) = v10;
      do
      {
        *((_BYTE *)__dst + (int)v23) = 0;
        LODWORD(v23) = v23 + 1;
      }
      while (!__CFADD__(v24++, 1));
    }
    if ((int)v23 <= 15)
    {
      v23 = (int)v23;
      do
        *((_BYTE *)__dst + v23++) = *((_BYTE *)&__src + v10++);
      while ((_DWORD)v23 != 16);
    }
    return v19;
  }
  if (v12 == 14)
  {
    *(_OWORD *)__dst = __src;
    return v19;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6addr: Not enough bytes for IPv6 address, numBytes is %d", a4, a5, a6, a7, a8, v12 + 2);
  return 0;
}

unint64_t GetValueForMACAddr(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;
  int v10;
  int v11;
  char v13;

  if (a1 >= a2)
  {
    v10 = 0;
LABEL_22:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForMACAddr: Address malformed colons %d", a4, a5, a6, a7, a8, v10);
    return 0;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = *(unsigned __int8 *)(a1 + v8);
    if (v11 == 32 || v8 > 0x10)
      break;
    v13 = v11 - 48;
    if ((v11 - 48) >= 0xA)
    {
      if ((v11 - 65) > 5)
      {
        if ((v11 - 97) > 5)
        {
          if (v11 == 58)
          {
            if (v10 >= 5)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForMACAddr: Address malformed colons %d val %d", a4, a5, a6, a7, a8, v10);
              return 0;
            }
            *(_BYTE *)(a3 + v10) = v9;
            v9 = 0;
            ++v10;
          }
          goto LABEL_13;
        }
        v13 = v11 - 87;
      }
      else
      {
        v13 = v11 - 55;
      }
    }
    v9 = v13 | (16 * v9);
LABEL_13:
    if (a2 - a1 == ++v8)
      goto LABEL_20;
  }
  a2 = a1 + v8;
LABEL_20:
  if (v10 != 5)
    goto LABEL_22;
  *(_BYTE *)(a3 + 5) = v9;
  return a2;
}

uint64_t mDNSCoreHaveAdvertisedMulticastServices(uint64_t result)
{
  uint64_t v1;
  int v2;
  _BYTE *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    while (1)
    {
      v2 = *(unsigned __int16 *)(v1 + 12);
      if (v2 == 10)
      {
        v3 = *(_BYTE **)(v1 + 40);
        if (*v3)
          v4 = *v3 + 1;
        else
          v4 = 0;
        if (SameDomainLabelPointer(&v3[v4], "\n_keepalive"))
          return 1;
        v2 = *(unsigned __int16 *)(v1 + 12);
      }
      if (v2 == 33
        && (*(_QWORD *)(v1 + 32) || *(_BYTE *)(v1 + 122) || IsLocalDomain(*(_BYTE **)(v1 + 40)))
        && *(_WORD *)(*(_QWORD *)(v1 + 48) + 8) != 2304)
      {
        return 1;
      }
      v1 = *(_QWORD *)v1;
      if (!v1)
        return 0;
    }
  }
  return result;
}

void AdvertiseInterfaceIfNeeded(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  BOOL v5;
  BOOL v6;
  int v7;

  v4 = *(_QWORD *)(a2 + 3552);
  if (AWDLInterfaceID)
    v5 = AWDLInterfaceID == v4;
  else
    v5 = 0;
  if (v5 || (WiFiAwareInterfaceID ? (v6 = WiFiAwareInterfaceID == v4) : (v6 = 0), v6))
  {
    if (a1[2730] || a1[2731])
    {
      v7 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    if (a1[4975])
      AdvertiseInterface((uint64_t)a1, a2, 0);
    if (a1[2730])
    {
      v7 = 1;
LABEL_16:
      AdvertiseInterface((uint64_t)a1, a2, v7);
    }
  }
}

void mDNS_RandomizedHostNameCallback(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t j;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _OWORD v33[4];

  if (a3 == -65548)
  {
    memset(v33, 0, sizeof(v33));
    GetRandomUUIDLabel(v33);
    if (SameDomainLabelPointer(v33, a1 + 10664))
      IncrementLabelSuffix((unsigned __int8 *)v33, 0);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16690);
    *(_BYTE *)(a1 + 10664) = 0;
    AppendDomainLabel((_BYTE *)(a1 + 10664), (unsigned __int8 *)v33);
    AppendLiteralLabelString((_BYTE *)(a1 + 10664), "local");
    DeadvertiseAllInterfaceRecords(a1, 2);
    AdvertiseNecessaryInterfaceRecords(a1);
    for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
    {
      if (*(_BYTE *)(i + 120))
      {
        if ((*(_DWORD *)(i + 172) & 0xFFFFFFFE) == 2
          || ((v12 = *(_QWORD *)(i + 32), AWDLInterfaceID) ? (v13 = AWDLInterfaceID == v12) : (v13 = 0),
              v13 || (WiFiAwareInterfaceID ? (v14 = WiFiAwareInterfaceID == v12) : (v14 = 0), v14)))
        {
          D2D_stop_advertising_record(i, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, i);
          D2D_start_advertising_record(i, v15, v16, v17, v18, v19, v20, v21);
        }
      }
    }
    for (j = *(_QWORD *)(a1 + 12624); j; j = *(_QWORD *)j)
    {
      if (*(_BYTE *)(j + 120))
      {
        if ((*(_DWORD *)(j + 172) & 0xFFFFFFFE) == 2
          || ((v23 = *(_QWORD *)(j + 32), AWDLInterfaceID) ? (v24 = AWDLInterfaceID == v23) : (v24 = 0),
              v24 || (WiFiAwareInterfaceID ? (v25 = WiFiAwareInterfaceID == v23) : (v25 = 0), v25)))
        {
          D2D_stop_advertising_record(j, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, j);
          D2D_start_advertising_record(j, v26, v27, v28, v29, v30, v31, v32);
        }
      }
    }
    mDNS_Unlock_(a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16707);
  }
}

uint64_t *GetFirstAddressRecordEx(uint64_t *result, int a2)
{
  uint64_t v2;
  BOOL v3;
  BOOL v4;
  BOOL v5;

  if (result)
  {
    while (1)
    {
      if (*((_BYTE *)result + 3670))
      {
        v2 = result[444];
        v3 = WiFiAwareInterfaceID && WiFiAwareInterfaceID == v2;
        v4 = v3;
        v5 = AWDLInterfaceID != v2 || AWDLInterfaceID == 0;
        if (v5 && !v4)
          break;
      }
      result = (uint64_t *)*result;
      if (!result)
        return result;
    }
    if (a2)
      result += 297;
    else
      result += 3;
  }
  return result;
}

void DeadvertiseAllInterfaceRecords(uint64_t a1, char a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 12656); i; i = *(_QWORD *)i)
  {
    if (*(_BYTE *)(i + 3670))
      DeadvertiseInterface(a1, i, a2);
  }
}

uint64_t AdvertiseNecessaryInterfaceRecords(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *(uint64_t **)(result + 12656);
  if (v1)
  {
    v2 = result;
    do
    {
      if (*((_BYTE *)v1 + 3670))
        result = AdvertiseInterfaceIfNeeded(v2, v1);
      v1 = (uint64_t *)*v1;
    }
    while (v1);
  }
  return result;
}

unint64_t CompleteRDataUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  unint64_t result;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, uint64_t);

  v10 = *(_QWORD *)(a2 + 48);
  v11 = *(unsigned __int16 *)(a2 + 20);
  result = SetNewRData(a2 + 8, *(_QWORD *)(a2 + 304), *(unsigned __int16 *)(a2 + 312), a4, a5, a6, a7, a8);
  *(_QWORD *)(a2 + 304) = 0;
  v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 320);
  if (v13)
    return v13(a1, a2, v10, v11);
  return result;
}

void RecordProbeFailure(_DWORD *a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  unsigned int v5;
  NSObject *v6;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  _DWORD v16[2];
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;

  v2 = a1[16];
  a1[3166] = v2;
  v3 = a1[3167] + 1;
  a1[3167] = v3;
  if (v3 >= 0xF)
  {
    v5 = v2 + 5000;
    if (v5 <= 1)
      v5 = 1;
    a1[3168] = v5;
    v6 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        return;
      v8 = *(_QWORD *)(a2 + 40);
      if (v8)
      {
        v9 = *(_BYTE **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_13:
          while (v9)
          {
            v10 = *v9;
            if (v10 > 0x3F)
              break;
            if (!*v9)
            {
              v14 = (unsigned __int16)((_WORD)v9 - v8 + 1);
              goto LABEL_33;
            }
            v9 += v10 + 1;
            if (v8 != -256)
              goto LABEL_12;
          }
        }
        else
        {
LABEL_12:
          if ((unint64_t)v9 < v8 + 256)
            goto LABEL_13;
        }
        v14 = 257;
      }
      else
      {
        v14 = 0;
      }
      goto LABEL_33;
    }
    v6 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a2 + 40);
      if (v8)
      {
        v12 = *(_BYTE **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_22:
          while (v12)
          {
            v13 = *v12;
            if (v13 > 0x3F)
              break;
            if (!*v12)
            {
              v14 = (unsigned __int16)((_WORD)v12 - v8 + 1);
              goto LABEL_33;
            }
            v12 += v13 + 1;
            if (v8 != -256)
              goto LABEL_21;
          }
        }
        else
        {
LABEL_21:
          if ((unint64_t)v12 < v8 + 256)
            goto LABEL_22;
        }
        v14 = 257;
      }
      else
      {
        v14 = 0;
      }
LABEL_33:
      v15 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      v16[0] = 67110147;
      v16[1] = v3;
      v17 = 2160;
      v18 = 1752392040;
      v19 = 1040;
      v20 = v14;
      v21 = 2101;
      v22 = v8;
      v23 = 2082;
      v24 = v15;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Excessive name conflicts (%u) for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s); rate limiting in effect",
        (uint8_t *)v16,
        0x2Cu);
    }
  }
}

uint64_t *mDNSGetTSRForAuthRecordNamed(uint64_t *a1, _BYTE *a2, int a3)
{
  uint64_t *v3;
  int v7;
  NSObject *v8;
  int v9;
  int v10;

  v3 = a1;
  if (a1)
  {
    while (*((_WORD *)v3 + 6) != 41
         || *((_DWORD *)v3 + 6) != a3
         || !SameDomainNameBytes((_BYTE *)v3[5], a2))
    {
      v3 = (uint64_t *)*v3;
      if (!v3)
        return v3;
    }
    v7 = *(unsigned __int16 *)(v3[6] + 4);
    if (v7 != 65002)
    {
      v8 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
          v9 = 67109120;
          v10 = v7;
          goto LABEL_14;
        }
      }
      else
      {
        v8 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        {
          v9 = 67109120;
          v10 = v7;
LABEL_14:
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "mDNSGetTSRForAuthRecordNamed: Found OPT that is not kDNSOpt_TSR (%d)", (uint8_t *)&v9, 8u);
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t *mDNSGetTSRForCacheGroup(uint64_t a1)
{
  uint64_t *result;
  int v2;
  NSObject *v3;
  int v6;
  int v7;

  result = *(uint64_t **)(a1 + 16);
  if (result)
  {
    while (*((_WORD *)result + 6) != 41)
    {
      result = (uint64_t *)*result;
      if (!result)
        return result;
    }
    v2 = *(unsigned __int16 *)(result[6] + 4);
    if (v2 != 65002)
    {
      v3 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          return 0;
        v6 = 67109120;
        v7 = v2;
      }
      else
      {
        v3 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          return 0;
        v6 = 67109120;
        v7 = v2;
      }
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "mDNSGetTSRForCacheGroup: Found OPT that is not kDNSOpt_TSR (%d)", (uint8_t *)&v6, 8u);
      return 0;
    }
  }
  return result;
}

BOOL ResourceRecordIsValidAnswer(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;

  result = 0;
  if ((*(_BYTE *)(a1 + 8) & 0x3C) != 0)
  {
    v1 = *(_QWORD *)(a1 + 72);
    if (!v1 || (*(_BYTE *)(v1 + 8) & 0x3C) != 0)
    {
      v2 = *(_QWORD *)(a1 + 80);
      if (!v2 || (*(_BYTE *)(v2 + 8) & 0x3C) != 0)
      {
        v3 = *(_QWORD *)(a1 + 88);
        if (!v3 || (*(_BYTE *)(v3 + 8) & 0x3C) != 0)
          return 1;
      }
    }
  }
  return result;
}

uint64_t CompleteDeregistration(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;

  v4 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
    goto LABEL_9;
  }
  v4 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    v13 = 141558275;
    v14 = 1752392040;
    v15 = 2085;
    v16 = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CompleteDeregistration: called for Resource record %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
  }
LABEL_10:
  *(_BYTE *)(a2 + 8) = 8;
  *(_BYTE *)(a2 + 192) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(_WORD *)(a2 + 130) = 0;
  if (*(_BYTE *)(a2 + 193))
  {
    AnswerAllLocalQuestionsWithLocalAuthRecord((_QWORD *)a1, a2, 0, v7, v8, v9, v10, v11);
    *(_BYTE *)(a2 + 193) = 0;
  }
  return mDNS_Deregister_internal(a1, a2, 0);
}

BOOL FollowCNAME(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v4;

  if (!a3 || *(_WORD *)(a1 + 342) == 5 || *((_WORD *)a2 + 2) != 5 || *a2 == 240)
    return 0;
  if (!*(_QWORD *)(a1 + 144))
    return 1;
  v4 = *((_QWORD *)a2 + 7);
  if (!v4)
    return 0;
  return *(_DWORD *)(v4 + 32) == 1;
}

void AdjustUnansweredQueries(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v2 = 1000 * *(_DWORD *)(a2 + 16);
  if (*(_BYTE *)(a2 + 109))
  {
    v3 = dword_100158E08;
    v4 = 939524096;
  }
  else
  {
    v4 = *(_DWORD *)(a2 + 80);
    v3 = 1000 * *(_DWORD *)(a2 + 16);
  }
  v5 = v3 + v4;
  v6 = *(_DWORD *)(a1 + 64);
  if (v6 - v5 < 0)
  {
    v7 = *(unsigned __int8 *)(a2 + 108);
    if (v7 <= 3)
    {
      if ((v2 + 19) > 0x26)
      {
        v14 = (v5 - v6) / (v2 / 20);
        if (v14 >= 4)
          v14 = 4;
        if (4 - v7 > v14)
        {
          if (v14 <= 1)
            LOBYTE(v14) = 1;
          *(_BYTE *)(a2 + 108) = 4 - v14;
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        v8 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "AdjustUnansweredQueries: WARNING: unusually small TTL (%d ticks) for %s", v9, v10, v11, v12, v13, v2);
      }
    }
  }
}

void MakeNegativeCacheRecordForQuestion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MakeNegativeCacheRecord(a1, a2, a3 + 376, *(_DWORD *)(a3 + 200), *(_WORD *)(a3 + 342), *(_WORD *)(a3 + 344), 1, a4, *(void **)(a3 + 80), 0);
}

void ReleaseCacheRecord(uint64_t a1, uint64_t a2)
{
  void *v4;
  BOOL v5;
  void *v6;
  uint64_t *v7;
  uint64_t *v8;
  void *v9;
  NSObject *v10;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  _BYTE *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  BOOL v25;
  void *v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;

  v4 = *(void **)(a2 + 48);
  if (v4)
    v5 = v4 == (void *)(a2 + 152);
  else
    v5 = 1;
  if (!v5)
    free(v4);
  *(_QWORD *)(a2 + 48) = 0;
  v6 = *(void **)(a2 + 56);
  if (v6)
  {
    os_release(v6);
    *(_QWORD *)(a2 + 56) = 0;
  }
  v7 = CacheGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (!v7)
  {
    v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_42;
      v12 = *(_QWORD *)(a2 + 40);
      if (v12)
      {
        v13 = *(_BYTE **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_21:
          while (v13)
          {
            v14 = *v13;
            if (v14 > 0x3F)
              break;
            if (!*v13)
            {
              v18 = (unsigned __int16)((_WORD)v13 - v12 + 1);
              goto LABEL_41;
            }
            v13 += v14 + 1;
            if (v12 != -256)
              goto LABEL_20;
          }
        }
        else
        {
LABEL_20:
          if ((unint64_t)v13 < v12 + 256)
            goto LABEL_21;
        }
        v18 = 257;
      }
      else
      {
        v18 = 0;
      }
    }
    else
    {
      v10 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_42;
      v12 = *(_QWORD *)(a2 + 40);
      if (v12)
      {
        v16 = *(_BYTE **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_30:
          while (v16)
          {
            v17 = *v16;
            if (v17 > 0x3F)
              break;
            if (!*v16)
            {
              v18 = (unsigned __int16)((_WORD)v16 - v12 + 1);
              goto LABEL_41;
            }
            v16 += v17 + 1;
            if (v12 != -256)
              goto LABEL_29;
          }
        }
        else
        {
LABEL_29:
          if ((unint64_t)v16 < v12 + 256)
            goto LABEL_30;
        }
        v18 = 257;
      }
      else
      {
        v18 = 0;
      }
    }
LABEL_41:
    v19 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    v27 = 141558787;
    v28 = 1752392040;
    v29 = 1040;
    v30 = v18;
    v31 = 2101;
    v32 = v12;
    v33 = 2082;
    v34 = v19;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "ReleaseCacheRecord: ERROR!! cg NULL for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)&v27, 0x26u);
    goto LABEL_42;
  }
  v8 = v7;
  v9 = *(void **)(a2 + 40);
  if (v9 && v9 != (void *)v8[4])
    free(v9);
LABEL_42:
  *(_QWORD *)(a2 + 40) = 0;
  if (!*(_QWORD *)(a2 + 32))
    *(_DWORD *)(a1 + 248) -= *(unsigned __int16 *)(a2 + 20);
  v20 = *(_QWORD **)(a2 + 64);
  if (v20)
  {
    ref_count_obj_release(v20);
    *(_QWORD *)(a2 + 64) = 0;
  }
  v21 = *(_QWORD **)(a2 + 120);
  if (v21)
  {
    do
    {
      v22 = v21;
      *(_QWORD *)(a2 + 120) = *v21;
      v23 = (_QWORD *)v21[6];
      v24 = v21 + 19;
      if (v23)
        v25 = v23 == v24;
      else
        v25 = 1;
      if (!v25)
      {
        free(v23);
        v22[6] = 0;
      }
      v26 = (void *)v22[5];
      if (v26)
      {
        free(v26);
        v22[5] = 0;
      }
      if (!v22[4])
        *(_DWORD *)(a1 + 248) -= *((unsigned __int16 *)v22 + 10);
      *v22 = *(_QWORD *)(a1 + 264);
      *(_QWORD *)(a1 + 264) = v22;
      --*(_DWORD *)(a1 + 244);
      v21 = *(_QWORD **)(a2 + 120);
    }
    while (v21);
  }
  else
  {
    v22 = *(_QWORD **)(a1 + 264);
  }
  *(_QWORD *)a2 = v22;
  *(_QWORD *)(a1 + 264) = a2;
  --*(_DWORD *)(a1 + 244);
}

uint64_t CheckProxyRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int *v10;
  _BYTE *v11;
  int v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  *(_QWORD *)(result + 12640) = a2;
  if (a2)
  {
    v8 = a2;
    v9 = result;
    v10 = (int *)(result + 19888);
    v11 = (_BYTE *)(result + 47032);
    do
    {
      result = v8 + 8;
      if (*(_BYTE *)(v8 + 8) != 1 && *(_DWORD *)(v8 + 126))
      {
        if (*(_QWORD *)(v9 + 15120) && (v12 = *(_DWORD *)(v8 + 168), *(_DWORD *)(v9 + 64) - v12 < 0))
        {
          if (*(_DWORD *)(v9 + 108) - v12 >= 1)
            *(_DWORD *)(v9 + 108) = v12;
        }
        else
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v13 = mDNSLogCategory_Default;
            v14 = *v10;
            GetRRDisplayString_rdb((unsigned __int8 *)result, (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), v11);
            LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "CheckProxyRecords: Removing %d H-MAC %.6a I-MAC %.6a %d %s", v15, v16, v17, v18, v19, v14);
          }
          v20 = *(_QWORD *)(v9 + 15112);
          if (v20)
          {
            if (v20 != *(_QWORD *)(v8 + 32))
              mDNSPlatformUpdateProxyList(v20, a2, a3, a4, a5, a6, a7, a8);
          }
          *(_QWORD *)(v9 + 15112) = *(_QWORD *)(v8 + 32);
          result = mDNS_Deregister_internal(v9, v8, 0);
          v21 = *(_QWORD *)(v9 + 12640);
          if (v21 != v8)
            goto LABEL_17;
        }
      }
      v21 = *(_QWORD *)v8;
      *(_QWORD *)(v9 + 12640) = *(_QWORD *)v8;
LABEL_17:
      v8 = v21;
    }
    while (v21);
  }
  return result;
}

void mDNS_SendKeepalives(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  _BYTE v16[6];
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int16 v23;
  uint64_t v24;
  unsigned int v25;

  for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
  {
    v24 = 0;
    v25 = 0;
    v23 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v14 = 0;
    v15 = 0;
    if (*(_DWORD *)(i + 126))
    {
      mDNS_ExtractKeepaliveInfo(i, &v25, &v20, &v17, (uint64_t)v16, (unsigned int *)&v24 + 1, (unsigned int *)&v24, &v15, &v14, &v23);
      v8 = v25;
      if (v25)
      {
        if (v20 != 4
          && ((_DWORD)v20 != 6 || v21 | HIDWORD(v21) | v22 | HIDWORD(v20))
          && v17 != 4
          && ((_DWORD)v17 != 6 || v18 | HIDWORD(v18) | v19 | HIDWORD(v17)))
        {
          v9 = HIDWORD(v24);
          if (HIDWORD(v24))
          {
            v10 = v24;
            if ((_DWORD)v24)
            {
              if (v15)
              {
                if (v14)
                {
                  v11 = v23;
                  if (v23)
                  {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepalives: laddr %#a raddr %#a lport %d rport %d", v3, v4, v5, v6, v7, (int)&v20);
                    v13 = *(_DWORD *)(i + 176);
                    if (!v13 || (int)(*(_DWORD *)(a1 + 64) - v13) >= 0)
                    {
                      mDNSPlatformSendKeepalive((uint64_t)&v20, (uint64_t)&v17, &v15, &v14, v9, v10, v11, v12);
                      v13 = *(_DWORD *)(a1 + 64) + 1000 * v8;
                      if (v13 <= 1)
                        v13 = 1;
                      *(_DWORD *)(i + 176) = v13;
                    }
                    if ((int)(*(_DWORD *)(a1 + 112) - v13) >= 1)
                      *(_DWORD *)(a1 + 112) = v13;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t mDNS_SetUpDomainEnumeration(unsigned int *a1, uint64_t a2, int a3)
{
  _DWORD *v4;
  int v6;
  NSObject *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t result;
  int v11;
  NSObject *v12;
  _BYTE *v13;
  uint64_t v14;
  NSObject *v15;
  _BYTE *v16;
  uint64_t v17;
  NSObject *v18;
  _BYTE *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  _BYTE *v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  const char *v42;
  __int16 v43;
  _BYTE v44[14];
  __int16 v45;
  _BYTE v46[14];

  if (a3 != 2)
    return 4294901752;
  v4 = *(_DWORD **)(a2 + 272);
  if (!v4)
    return 0;
  v6 = v4[176];
  if (v6 == 2)
  {
    v11 = v4[177];
    if (v11 != 1)
    {
      if (v11 || (int)(a1[16] - v4[178]) < 0)
        return 0;
      v12 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
          goto LABEL_116;
        v29 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_84:
          while (v29)
          {
            v30 = *v29;
            if (v30 > 0x3F)
              break;
            if (!*v29)
            {
              v34 = (unsigned __int16)((_WORD)v29 - a2 + 1);
              goto LABEL_115;
            }
            v29 += v30 + 1;
            if (a2 != -256)
              goto LABEL_83;
          }
        }
        else
        {
LABEL_83:
          if ((unint64_t)v29 < a2 + 256)
            goto LABEL_84;
        }
        v34 = 257;
      }
      else
      {
        v12 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
          goto LABEL_116;
        v13 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_26:
          while (v13)
          {
            v14 = *v13;
            if (v14 > 0x3F)
              break;
            if (!*v13)
            {
              v34 = (unsigned __int16)((_WORD)v13 - a2 + 1);
              goto LABEL_115;
            }
            v13 += v14 + 1;
            if (a2 != -256)
              goto LABEL_25;
          }
        }
        else
        {
LABEL_25:
          if ((unint64_t)v13 < a2 + 256)
            goto LABEL_26;
        }
        v34 = 257;
      }
LABEL_115:
      v41 = 136446979;
      v42 = "automatic browse domain";
      v43 = 2160;
      *(_QWORD *)v44 = 1752392040;
      *(_WORD *)&v44[8] = 1040;
      *(_DWORD *)&v44[10] = v34;
      v45 = 2101;
      *(_QWORD *)v46 = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Stopping the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x26u);
LABEL_116:
      result = mDNS_StopQuery_internal((uint64_t)a1, (uint64_t)(v4 + 2));
      if (!(_DWORD)result)
      {
        mDNS_DeregisterDomainsDiscoveredForDomainEnumeration(a1, a2, 2, v36, v37, v38, v39, v40);
        result = 0;
        v4[176] = 0;
      }
      return result;
    }
    v18 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_111:
        result = 0;
LABEL_112:
        v4[176] = 1;
        return result;
      }
      v20 = (_BYTE *)a2;
      if (a2 == -256)
      {
LABEL_52:
        while (v20)
        {
          v21 = *v20;
          if (v21 > 0x3F)
            break;
          if (!*v20)
          {
            v33 = (unsigned __int16)((_WORD)v20 - a2 + 1);
            goto LABEL_110;
          }
          v20 += v21 + 1;
          if (a2 != -256)
            goto LABEL_51;
        }
      }
      else
      {
LABEL_51:
        if ((unint64_t)v20 < a2 + 256)
          goto LABEL_52;
      }
      v33 = 257;
    }
    else
    {
      v18 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_111;
      v27 = (_BYTE *)a2;
      if (a2 == -256)
      {
LABEL_76:
        while (v27)
        {
          v28 = *v27;
          if (v28 > 0x3F)
            break;
          if (!*v27)
          {
            v33 = (unsigned __int16)((_WORD)v27 - a2 + 1);
            goto LABEL_110;
          }
          v27 += v28 + 1;
          if (a2 != -256)
            goto LABEL_75;
        }
      }
      else
      {
LABEL_75:
        if ((unint64_t)v27 < a2 + 256)
          goto LABEL_76;
      }
      v33 = 257;
    }
LABEL_110:
    v41 = 136447235;
    v42 = "automatic browse domain";
    v43 = 1024;
    *(_DWORD *)v44 = 1;
    *(_WORD *)&v44[4] = 2160;
    *(_QWORD *)&v44[6] = 1752392040;
    v45 = 1040;
    *(_DWORD *)v46 = v33;
    *(_WORD *)&v46[4] = 2101;
    *(_QWORD *)&v46[6] = a2;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Resuming the %{public}s enumeration - active client count: %u, domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x2Cu);
    goto LABEL_111;
  }
  if (v6 == 1)
  {
    if (v4[177])
      return 0;
    v15 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
      {
        v24 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_68:
          while (v24)
          {
            v25 = *v24;
            if (v25 > 0x3F)
              break;
            if (!*v24)
            {
              v32 = (unsigned __int16)((_WORD)v24 - a2 + 1);
              goto LABEL_104;
            }
            v24 += v25 + 1;
            if (a2 != -256)
              goto LABEL_67;
          }
        }
        else
        {
LABEL_67:
          if ((unint64_t)v24 < a2 + 256)
            goto LABEL_68;
        }
        v32 = 257;
        goto LABEL_104;
      }
    }
    else
    {
      v15 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        v16 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_39:
          while (v16)
          {
            v17 = *v16;
            if (v17 > 0x3F)
              break;
            if (!*v16)
            {
              v32 = (unsigned __int16)((_WORD)v16 - a2 + 1);
              goto LABEL_104;
            }
            v16 += v17 + 1;
            if (a2 != -256)
              goto LABEL_38;
          }
        }
        else
        {
LABEL_38:
          if ((unint64_t)v16 < a2 + 256)
            goto LABEL_39;
        }
        v32 = 257;
LABEL_104:
        v41 = 136447235;
        v42 = "automatic browse domain";
        v43 = 2160;
        *(_QWORD *)v44 = 1752392040;
        *(_WORD *)&v44[8] = 1040;
        *(_DWORD *)&v44[10] = v32;
        v45 = 2101;
        *(_QWORD *)v46 = a2;
        *(_WORD *)&v46[8] = 1024;
        *(_DWORD *)&v46[10] = 60;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Planning to stop the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, grace period: %ds.", (uint8_t *)&v41, 0x2Cu);
      }
    }
    result = 0;
    v4[176] = 2;
    v35 = a1[16] + 60000;
    if (v35 <= 1)
      v35 = 1;
    v4[178] = v35;
    return result;
  }
  if (v6 || v4[177] != 1)
    return 0;
  v7 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    v22 = (_BYTE *)a2;
    if (a2 == -256)
    {
LABEL_60:
      while (v22)
      {
        v23 = *v22;
        if (v23 > 0x3F)
          break;
        if (!*v22)
        {
          v31 = (unsigned __int16)((_WORD)v22 - a2 + 1);
          goto LABEL_97;
        }
        v22 += v23 + 1;
        if (a2 != -256)
          goto LABEL_59;
      }
    }
    else
    {
LABEL_59:
      if ((unint64_t)v22 < a2 + 256)
        goto LABEL_60;
    }
    v31 = 257;
  }
  else
  {
    v7 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    v8 = (_BYTE *)a2;
    if (a2 == -256)
    {
LABEL_12:
      while (v8)
      {
        v9 = *v8;
        if (v9 > 0x3F)
          break;
        if (!*v8)
        {
          v31 = (unsigned __int16)((_WORD)v8 - a2 + 1);
          goto LABEL_97;
        }
        v8 += v9 + 1;
        if (a2 != -256)
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      if ((unint64_t)v8 < a2 + 256)
        goto LABEL_12;
    }
    v31 = 257;
  }
LABEL_97:
  v41 = 136446979;
  v42 = "automatic browse domain";
  v43 = 2160;
  *(_QWORD *)v44 = 1752392040;
  *(_WORD *)&v44[8] = 1040;
  *(_DWORD *)&v44[10] = v31;
  v45 = 2101;
  *(_QWORD *)v46 = a2;
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Starting the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x26u);
LABEL_98:
  result = mDNS_GetDomains_Internal((uint64_t)a1, (uint64_t)(v4 + 2), 2, (char *)a2, 0, (uint64_t)FoundNonLocalOnlyAutomaticBrowseDomain, 0);
  if (!(_DWORD)result)
    goto LABEL_112;
  return result;
}

void BeginSleepProcessing(uint64_t a1)
{
  const __SCDynamicStore *v2;
  const __SCDynamicStore *v3;
  const __CFString *NetworkInterfaceEntity;
  const __CFArray *v5;
  const __CFArray *v6;
  BOOL v7;
  NSObject *v8;
  int CStringPtr;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  const __CFArray *v24;
  const __CFArray *v25;
  BOOL v26;
  NSObject *v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  char *v37;
  int v38;
  int v39;
  unsigned __int8 *v40;
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(uint64_t, unsigned __int8 *, uint64_t);
  unsigned __int8 *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  void **v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const __CFDictionary *v70;
  io_service_t MatchingService;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  io_object_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  CFTypeID v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  NSObject *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  char v102;
  uint64_t *v103;
  int i;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  kern_return_t v121;
  int v122;
  char *v123;
  uint64_t v124;
  void *v125;
  unsigned int *v126;
  uint64_t v127;
  size_t outputStructCnt;
  __int16 outputStruct;
  __int128 inputStruct;
  void *v131[2];
  void *v132[2];
  io_connect_t connect;
  io_object_t object;
  CFTypeRef cf;
  _QWORD v136[128];
  io_name_t v137;
  io_name_t className;

  bzero(v136, 0x400uLL);
  *(_DWORD *)(a1 + 180) = *(_DWORD *)(a1 + 64);
  v2 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:SPSAddresses"), 0, 0);
  v3 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:SPSOPTRecord"), 0, 0);
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, CFSTR("BonjourSleepProxyAddress"));
  if (NetworkInterfaceEntity)
  {
    v5 = SCDynamicStoreCopyKeyList(v2, NetworkInterfaceEntity);
    if (v5)
    {
      v6 = v5;
      if (SCDynamicStoreSetMultiple(v2, 0, v5, 0))
        v7 = 1;
      else
        v7 = mDNS_LoggingEnabled == 0;
      if (!v7)
      {
        v8 = mDNSLogCategory_Default;
        CStringPtr = CFStringGetCStringPtr(NetworkInterfaceEntity, 0x600u);
        v10 = SCError();
        SCErrorString(v10);
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "mDNSPlatformClearSPSData: Unable to remove %s : error %s", v11, v12, v13, v14, v15, CStringPtr);
      }
      CFRelease(v6);
    }
  }
  v23 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, CFSTR("BonjourSleepProxyOPTRecord"));
  if (v23)
  {
    v24 = SCDynamicStoreCopyKeyList(v2, v23);
    if (v24)
    {
      v25 = v24;
      if (SCDynamicStoreSetMultiple(v3, 0, v24, 0))
        v26 = 1;
      else
        v26 = mDNS_LoggingEnabled == 0;
      if (!v26)
      {
        v27 = mDNSLogCategory_Default;
        v28 = CFStringGetCStringPtr(v23, 0x600u);
        v29 = SCError();
        SCErrorString(v29);
        LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "mDNSPlatformClearSPSData: Unable to remove %s : error %s", v30, v31, v32, v33, v34, v28);
      }
      CFRelease(v25);
    }
  }
  if (v2)
    CFRelease(v2);
  v35 = &unk_100158000;
  if (v3)
    CFRelease(v3);
  if (NetworkInterfaceEntity)
    CFRelease(NetworkInterfaceEntity);
  if (v23)
    CFRelease(v23);
  if (!*(_BYTE *)(a1 + 143))
  {
    if ((mDNS_LoggingEnabled & 1) != 0)
    {
      v37 = "BeginSleepProcessing: m->SystemWakeOnLANEnabled is false";
LABEL_35:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v37, (uint64_t)v18, v19, v20, v21, v22, v122);
      goto LABEL_36;
    }
LABEL_39:
    HIDWORD(v127) = 0;
    v38 = 0;
    v39 = 1;
LABEL_40:
    v40 = *(unsigned __int8 **)(a1 + 12616);
    *(_QWORD *)(a1 + 12640) = v40;
    if (v40)
    {
      do
      {
        if (*((_WORD *)v40 + 6) == 10)
        {
          v41 = (_BYTE *)*((_QWORD *)v40 + 5);
          v42 = *v41 ? *v41 + 1 : 0;
          if (SameDomainLabelPointer(&v41[v42], "\n_keepalive") && v40[8] != 1)
          {
            if (v35[3304] == 1)
            {
              v43 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(v40 + 8, (unsigned __int16 *)(*((_QWORD *)v40 + 6) + 4), (_BYTE *)(a1 + 47032));
              v44 = v43;
              v35 = &unk_100158000;
              LogMsgWithLevel(v44, OS_LOG_TYPE_DEFAULT, "DoKeepaliveCallbacks: Invoking the callback for %s", v45, v46, v47, v48, v49, a1 + 47032);
            }
            v50 = (void (*)(uint64_t, unsigned __int8 *, uint64_t))*((_QWORD *)v40 + 13);
            if (v50)
              v50(a1, v40, 4294901754);
          }
        }
        v51 = *(unsigned __int8 **)(a1 + 12640);
        if (v51 == v40)
        {
          v51 = *(unsigned __int8 **)v40;
          *(_QWORD *)(a1 + 12640) = *(_QWORD *)v40;
        }
        v40 = v51;
      }
      while (v51);
    }
    goto LABEL_54;
  }
  if (!mDNSCoreHaveAdvertisedMulticastServices(*(_QWORD *)(a1 + 12616)))
  {
    if ((mDNS_LoggingEnabled & 1) != 0)
    {
      v37 = "BeginSleepProcessing: No advertised services";
      goto LABEL_35;
    }
    goto LABEL_39;
  }
  v36 = *(_QWORD *)(a1 + 12656);
  if (!v36)
  {
LABEL_36:
    v38 = 0;
    HIDWORD(v127) = 0;
    v39 = 1;
LABEL_37:
    if (v35[3304] == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Did not register with an in-NIC proxy - invoking the callbacks for KA records", (uint64_t)v18, v19, v20, v21, v22, v122);
    goto LABEL_40;
  }
  while (!*(_BYTE *)(v36 + 16))
  {
    v36 = *(_QWORD *)v36;
    if (!v36)
      goto LABEL_36;
  }
  v38 = 0;
  v127 = 0;
  v55 = (char *)&inputStruct + 4;
  v56 = v131;
  v39 = 1;
  v57 = 1;
LABEL_69:
  *(_BYTE *)(v36 + 3675) = 0;
  if (!*(_BYTE *)(v36 + 3671)
    || mDNSPlatformInterfaceIsD2D(*(_QWORD *)(v36 + 3552), v16, v17, (uint64_t)v18, v19, v20, v21, v22))
  {
    if (v35[3304] == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s Ignoring for registrations", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
    goto LABEL_73;
  }
  if (*(_BYTE *)(v36 + 3672))
  {
    v58 = *(_QWORD *)(v36 + 3552);
    v59 = a1 + 12656;
    v126 = (unsigned int *)v56;
    while (1)
    {
      v59 = *(_QWORD *)v59;
      if (!v59)
        break;
      if (*(_QWORD *)(v59 + 3552) == v58)
      {
        do
        {
          if (*(_QWORD *)(v59 + 3552) == v58 && (_DWORD)v127 && *(_DWORD *)(v59 + 3560) == 4)
          {
            v60 = 0;
            while (2)
            {
              v61 = v136[v60];
              v62 = a1 + 12656;
              while (1)
              {
                v62 = *(_QWORD *)v62;
                if (!v62)
                  break;
                if (*(_QWORD *)(v62 + 3552) == v61)
                {
                  while (*(_QWORD *)(v62 + 3552) != v61
                       || *(_DWORD *)(v62 + 3560) != 4
                       || (*(_DWORD *)(v62 + 3584) & *(_DWORD *)(v62 + 3564)) != (*(_DWORD *)(v59 + 3584) & *(_DWORD *)(v59 + 3564)))
                  {
                    v62 = *(_QWORD *)v62;
                    if (!v62)
                      goto LABEL_93;
                  }
                  if ((v35[3304] & 1) != 0
                    && (LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s : Already registered for the same subnet (IPv4) for interface %s", (uint64_t)v18, v19, v20, v21, v22, (int)"skipSameSubnetRegistration"), v35[3304] == 1))
                  {
                    v63 = v55;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s : Skipping full sleep proxy registration on %s", v65, v66, v67, v68, v69, (int)"BeginSleepProcessing");
                  }
                  else
                  {
                    v63 = v55;
                  }
                  v64 = 1;
                  goto LABEL_104;
                }
              }
LABEL_93:
              if (++v60 != v127)
                continue;
              break;
            }
          }
          v59 = *(_QWORD *)v59;
        }
        while (v59);
        break;
      }
    }
    v63 = v55;
    v64 = 0;
LABEL_104:
    if (SupportsInNICProxy(v36))
    {
      v70 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(v36 + 3606));
      MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v70);
      if (MatchingService)
      {
        v77 = MatchingService;
        memset(className, 0, sizeof(className));
        memset(v137, 0, sizeof(v137));
        IOObjectGetClass(MatchingService, className);
        cf = 0;
        object = 0;
        v78 = RegistryEntrySearchCFPropertyAndIOObject(v77, CFSTR("mDNS_KEY"), &cf, &object);
        IOObjectRelease(v77);
        if (v78)
        {
          v55 = v63;
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: No mDNS_IOREG_KEY for interface %s/%s kr %d", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
          v35 = (_BYTE *)&unk_100158000;
          v56 = (void **)v126;
          goto LABEL_73;
        }
        IOObjectGetClass(object, v137);
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: Interface %s service %s parent %s", v79, v80, v81, v82, v83, v36 + 3606);
        v84 = CFGetTypeID(cf);
        if (v84 != CFStringGetTypeID() || !CFEqual(cf, CFSTR("2009-07-30")))
        {
          v95 = mDNSLogCategory_Default;
          CFStringGetCStringPtr((CFStringRef)cf, 0);
          LogMsgWithLevel(v95, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: mDNS_IOREG_KEY for interface %s/%s/%s value %s != %s", v96, v97, v98, v99, v100, v36 + 3606);
          v101 = -65537;
          v55 = v63;
LABEL_123:
          v56 = (void **)v126;
LABEL_124:
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          IOObjectRelease(object);
          v102 = v64;
          if (v101)
            v102 = 1;
          if ((v102 & 1) != 0)
          {
            v35 = (_BYTE *)&unk_100158000;
          }
          else
          {
            v103 = *(uint64_t **)(a1 + 12616);
            v35 = &unk_100158000;
            for (i = 0; v103; v103 = (uint64_t *)*v103)
            {
              if ((*((_BYTE *)v103 + 123) & 1) != 0 && *((_BYTE *)v103 + 8) == 8 && *((_BYTE *)v103 + 192))
              {
                v103[26] = -1;
                i = 1;
              }
            }
            HIDWORD(v127) = i;
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s using local proxy", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
            v57 = 0;
            v39 = 0;
            v136[v127] = *(_QWORD *)(v36 + 3552);
            LODWORD(v127) = v127 + 1;
          }
          goto LABEL_73;
        }
        if (!UseInternalSleepProxy)
        {
          v55 = v63;
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: Not using internal (NIC) sleep proxy for interface %s", v85, v86, v87, v88, v89, v36 + 3606);
          goto LABEL_122;
        }
        connect = 0;
        v55 = v63;
        if (IOServiceOpen(object, mach_task_self_, 0x6D444E53u, &connect))
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: IOServiceOpen for %s/%s/%s failed %d", v90, v91, v92, v93, v94, v36 + 3606);
LABEL_122:
          v101 = -65537;
          goto LABEL_123;
        }
        *(_OWORD *)v131 = 0u;
        *(_OWORD *)v132 = 0u;
        inputStruct = 0u;
        LODWORD(inputStruct) = 21;
        DWORD2(inputStruct) = GetPortArray(1, 0);
        HIDWORD(inputStruct) = GetPortArray(2, 0);
        v105 = CountProxyRecords(v63);
        v131[0] = (void *)(v105 | 0xC00000000);
        v125 = malloc_type_calloc(1uLL, DWORD1(inputStruct) + 12, 0xF1748037uLL);
        if (!v125)
          goto LABEL_174;
        v123 = v55;
        if (v105)
        {
          v111 = malloc_type_calloc(1uLL, 8 * v105, 0xF1748037uLL);
          if (!v111)
          {
LABEL_174:
            __break(1u);
            return;
          }
        }
        else
        {
          v111 = 0;
        }
        v131[1] = v111;
        v124 = (uint64_t)v111;
        if (DWORD2(inputStruct))
        {
          v112 = malloc_type_calloc(1uLL, 2 * DWORD2(inputStruct), 0xF1748037uLL);
          if (!v112)
            goto LABEL_174;
        }
        else
        {
          v112 = 0;
        }
        v132[0] = v112;
        if (HIDWORD(inputStruct))
        {
          v113 = v112;
          v114 = malloc_type_calloc(1uLL, 2 * HIDWORD(inputStruct), 0xF1748037uLL);
          v112 = v113;
          if (!v114)
            goto LABEL_174;
        }
        else
        {
          v114 = 0;
        }
        v132[1] = v114;
        if (mDNS_LoggingEnabled == 1)
        {
          v115 = v112;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: msg %p %u RR %p %u, UDP %p %u, TCP %p %u", v106, v107, v108, v109, v110, (int)v125);
          v112 = v115;
        }
        if (v124)
        {
          GetProxyRecords((unint64_t)v125, v123, v124, v126, v107, v108, v109, v110);
          v112 = v132[0];
        }
        if (v112)
          DWORD2(inputStruct) = GetPortArray(1, (unsigned __int16 *)v112);
        if (v132[1])
          HIDWORD(inputStruct) = GetPortArray(2, (unsigned __int16 *)v132[1]);
        outputStruct = 0;
        outputStructCnt = 2;
        v121 = IOConnectCallStructMethod(connect, 0, &inputStruct, 0x30uLL, &outputStruct, &outputStructCnt);
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: IOConnectCallStructMethod for %s/%s/%s %d", v116, v117, v118, v119, v120, v36 + 3606);
        if (v121)
          v101 = -65537;
        else
          v101 = 0;
        if (v132[1])
        {
          free(v132[1]);
          v132[1] = 0;
        }
        v55 = v123;
        if (v132[0])
        {
          free(v132[0]);
          v132[0] = 0;
        }
        v56 = (void **)v126;
        if (v131[1])
        {
          free(v131[1]);
          v131[1] = 0;
        }
        free(v125);
        IOServiceClose(connect);
        goto LABEL_124;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: No service for interface %s", v72, v73, v74, v75, v76, v36 + 3606);
    }
    v55 = v63;
    v56 = (void **)v126;
    goto LABEL_73;
  }
  if (v35[3304] == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s not capable of magic packet wakeup", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
  *(_BYTE *)(v36 + 3675) = 1;
  ++v38;
LABEL_73:
  while (1)
  {
    v36 = *(_QWORD *)v36;
    if (!v36)
      break;
    if (*(_BYTE *)(v36 + 16))
      goto LABEL_69;
  }
  if (v57)
    goto LABEL_37;
LABEL_54:
  if (v39)
  {
    if (v35[3304] == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Not registering with Sleep Proxy Server", (uint64_t)v18, v19, v20, v21, v22, v122);
    v52 = a1;
    v53 = 1;
    v54 = 1;
LABEL_62:
    SendSleepGoodbyes(v52, v53, v54, v18, v19, v20, v21, v22);
    return;
  }
  if (v38)
  {
    if (v35[3304] == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Not registering with Sleep Proxy Server on all interfaces", (uint64_t)v18, v19, v20, v21, v22, v122);
    v52 = a1;
    v53 = 0;
    v54 = 0;
    goto LABEL_62;
  }
  if (HIDWORD(v127))
  {
    if (v35[3304] == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Sending goodbyes for WakeOnlyService", (uint64_t)v18, v19, v20, v21, v22, v122);
    SendResponses(a1, v16, v17, v18, v19, v20, v21, v22);
  }
}

void *__mDNSPostResponseDelayMetrics_block_invoke(uint64_t a1)
{
  uint64_t v1;
  xpc_object_t empty;
  void *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  empty = xpc_dictionary_create_empty();
  v3 = empty;
  if (empty)
  {
    v4 = 0;
    v5 = *(unsigned int *)(v1 + 24);
    for (i = 28; i != 62; i += 2)
      v4 += *(unsigned __int16 *)(v1 + i);
    v7 = v5 + v4;
    xpc_dictionary_set_uint64(empty, "answer_count_cache_hit", v5);
    xpc_dictionary_set_uint64(v3, "answer_count_total", v7);
    xpc_dictionary_set_uint64(v3, "delay_1s", *(unsigned __int16 *)(v1 + 28));
    xpc_dictionary_set_uint64(v3, "delay_2s", *(unsigned __int16 *)(v1 + 30));
    xpc_dictionary_set_uint64(v3, "delay_3s", *(unsigned __int16 *)(v1 + 32));
    xpc_dictionary_set_uint64(v3, "delay_4s", *(unsigned __int16 *)(v1 + 34));
    xpc_dictionary_set_uint64(v3, "delay_5s", *(unsigned __int16 *)(v1 + 36));
    xpc_dictionary_set_uint64(v3, "delay_6s", *(unsigned __int16 *)(v1 + 38));
    xpc_dictionary_set_uint64(v3, "delay_7s", *(unsigned __int16 *)(v1 + 40));
    xpc_dictionary_set_uint64(v3, "delay_8s", *(unsigned __int16 *)(v1 + 42));
    xpc_dictionary_set_uint64(v3, "delay_9s", *(unsigned __int16 *)(v1 + 44));
    xpc_dictionary_set_uint64(v3, "delay_10s", *(unsigned __int16 *)(v1 + 46));
    xpc_dictionary_set_uint64(v3, "delay_11s", *(unsigned __int16 *)(v1 + 48));
    xpc_dictionary_set_uint64(v3, "delay_12s", *(unsigned __int16 *)(v1 + 50));
    xpc_dictionary_set_uint64(v3, "delay_13s", *(unsigned __int16 *)(v1 + 52));
    xpc_dictionary_set_uint64(v3, "delay_14s", *(unsigned __int16 *)(v1 + 54));
    xpc_dictionary_set_uint64(v3, "delay_15s", *(unsigned __int16 *)(v1 + 56));
    xpc_dictionary_set_uint64(v3, "delay_20s", *(unsigned __int16 *)(v1 + 58));
    xpc_dictionary_set_uint64(v3, "delay_infinity", *(unsigned __int16 *)(v1 + 60));
  }
  return v3;
}

void GenerateNegativeResponseEx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  __int16 v10;
  uint64_t v14;
  NSObject *v15;
  unsigned int v18;
  _QWORD *v19;
  uint8_t buf[4];
  unsigned int v21;

  v9 = *(_QWORD *)(a1 + 208);
  if (!v9)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GenerateNegativeResponse: ERROR!! CurrentQuestion not set", a4, a5, a6, a7, a8, a9);
    return;
  }
  v10 = a4;
  v14 = a1 + 37920;
  v15 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
  {
    v15 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
    goto LABEL_11;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
  {
LABEL_11:
    v18 = bswap32(*(unsigned __int16 *)(v9 + 340)) >> 16;
    *(_DWORD *)buf = 67109120;
    v21 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "[Q%d] GenerateNegativeResponse: Generating negative response for question", buf, 8u);
  }
LABEL_12:
  MakeNegativeCacheRecord(a1, a1 + 37912, v9 + 376, *(_DWORD *)(v9 + 200), *(_WORD *)(v9 + 342), *(_WORD *)(v9 + 344), 60, a2, *(void **)(v9 + 80), v10);
  AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37912, a3);
  if (*(_QWORD *)(a1 + 208) == v9)
    *(_DWORD *)(v9 + 212) = 0;
  *(_WORD *)v14 = 0;
  *(_WORD *)(v14 + 102) = 0;
  v19 = *(_QWORD **)(v14 + 56);
  if (v19)
  {
    ref_count_obj_release(v19);
    *(_QWORD *)(v14 + 56) = 0;
  }
}

void CheckRmvEventsForLocalRecords(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;

  v8 = a1[1580];
  if (v8)
  {
    while (*(_BYTE *)(v8 + 193) && *(_BYTE *)(v8 + 8) == 1)
    {
      *(_BYTE *)(v8 + 8) = 8;
      AnswerAllLocalQuestionsWithLocalAuthRecord(a1, v8, 0, a4, a5, a6, a7, a8);
      v10 = a1[1580];
      if (v10 == v8)
      {
        *(_BYTE *)(v8 + 8) = 1;
        *(_BYTE *)(v8 + 193) = 0;
        if ((*(_DWORD *)(v8 + 172) & 0xFFFFFFFE) != 4)
          break;
        CompleteDeregistration((uint64_t)a1, v8);
        v10 = a1[1580];
      }
      if (v10 == v8)
        break;
LABEL_9:
      v8 = v10;
      if (!v10)
        return;
    }
    v10 = *(_QWORD *)v8;
    a1[1580] = *(_QWORD *)v8;
    goto LABEL_9;
  }
}

void DiscardDeregistrations(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 12640);
  if (v2)
  {
    v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      goto LABEL_10;
    }
    v3 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:
      GetRRDisplayString_rdb((unsigned __int8 *)(v2 + 8), (unsigned __int16 *)(*(_QWORD *)(v2 + 48) + 4), (_BYTE *)(a1 + 47032));
      v7 = 141558275;
      v8 = 1752392040;
      v9 = 2085;
      v10 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "DiscardDeregistrations ERROR m->CurrentRecord already set %{sensitive, mask.hash}s", (uint8_t *)&v7, 0x16u);
    }
  }
LABEL_11:
  v6 = *(_QWORD *)(a1 + 12616);
  for (*(_QWORD *)(a1 + 12640) = v6; v6; *(_QWORD *)(a1 + 12640) = v6)
  {
    while ((*(_QWORD *)(v6 + 32) || *(_BYTE *)(v6 + 122) || IsLocalDomain(*(_BYTE **)(v6 + 40)))
         && *(_BYTE *)(v6 + 8) == 1)
    {
      CompleteDeregistration(a1, v6);
      v6 = *(_QWORD *)(a1 + 12640);
      if (!v6)
        return;
    }
    v6 = *(_QWORD *)v6;
  }
}

uint64_t *CacheHasAddressTypeForName(uint64_t a1, _BYTE *a2, unsigned int a3)
{
  uint64_t *result;
  int v4;

  result = CacheGroupForName(a1, a3, a2);
  if (result)
  {
    for (result = (uint64_t *)result[2]; result; result = (uint64_t *)*result)
    {
      v4 = *((unsigned __int16 *)result + 6);
      if (v4 == 1 || v4 == 28)
        break;
    }
  }
  return result;
}

void SendARP(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t i;
  _BYTE *v13;
  _BYTE *v14;
  int v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v9 = (char *)(a1 + 28972);
  v10 = *(_QWORD *)(a3 + 32);
  v11 = (_QWORD *)(a1 + 12656);
  do
  {
    v11 = (_QWORD *)*v11;
    if (!v11)
    {
      v22 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SendARP: No interface with InterfaceID %p found %s", v23, v24, v25, v26, v27, v10);
      return;
    }
  }
  while (v11[444] != v10);
  for (i = 0; i != 6; ++i)
    v9[i] = *(_BYTE *)(a7 + i);
  v13 = v9 + 6;
  v14 = v11 + 450;
  v15 = 6;
  do
  {
    v16 = v13;
    *v13++ = *v14;
    --v15;
  }
  while (v15);
  v17 = 0;
  *(_QWORD *)v13 = 0x406000801000608;
  v13[8] = 0;
  v18 = v16 + 11;
  v13[9] = a2;
  do
    *v18++ = v14[v17++];
  while (v17 != 6);
  for (j = 0; j != 4; ++j)
    *v18++ = *(_BYTE *)(a4 + j);
  for (k = 0; k != 6; ++k)
    *v18++ = *(_BYTE *)(a5 + k);
  for (m = 0; m != 4; ++m)
    *v18++ = *(_BYTE *)(a6 + m);
  mDNSPlatformSendRawPacket(v9, (uint64_t)v18, *(_QWORD *)(a3 + 32));
}

void SendNDP(uint64_t a1, int a2, char a3, uint64_t a4, int8x8_t *a5, int *a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  __int16 *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  _QWORD *v17;
  __int16 v18;
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t i;
  _BYTE *v23;
  _BYTE *v24;
  uint64_t j;
  _BYTE *v26;
  uint64_t v27;
  __int16 v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t k;
  _BYTE *v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  __int16 v45;
  uint64_t v46;
  char v47;
  __int16 v48;
  char v49;
  __int16 v50;

  v10 = (void *)(a1 + 28972);
  v45 = 767;
  v46 = 0;
  v47 = 0;
  v48 = -255;
  v49 = *(_BYTE *)(a7 + 13);
  v50 = *(_WORD *)(a7 + 14);
  if (a2 == 135)
    v11 = &v45;
  else
    v11 = (__int16 *)a7;
  v12 = *(_QWORD *)(a4 + 32);
  v13 = (_QWORD *)(a1 + 12656);
  do
  {
    v13 = (_QWORD *)*v13;
    if (!v13)
    {
      v29 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a4 + 8), (unsigned __int16 *)(*(_QWORD *)(a4 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, "SendNDP: No interface with InterfaceID %p found %s", v30, v31, v32, v33, v34, v12);
      return;
    }
  }
  while (v13[444] != v12);
  v14 = 0;
  v15 = (_BYTE *)(a1 + 28972);
  do
    *v15++ = *(_BYTE *)(a8 + v14++);
  while (v14 != 6);
  v16 = 0;
  v17 = v13 + 450;
  do
  {
    if (a6)
    {
      v43 = *a6;
      v18 = *((_WORD *)a6 + 2);
    }
    else
    {
      v43 = *(_DWORD *)v17;
      v18 = *((_WORD *)v17 + 2);
    }
    v44 = v18;
    v15[v16] = *((_BYTE *)&v43 + v16);
    ++v16;
  }
  while (v16 != 6);
  v19 = 0;
  v20 = v15 + 6;
  *((_WORD *)v15 + 3) = -8826;
  v15[8] = 96;
  *(_DWORD *)(v15 + 9) = 0;
  *(_WORD *)(v15 + 13) = 14880;
  v21 = v15 + 16;
  v20[9] = -1;
  do
    *v21++ = a5->i8[v19++];
  while (v19 != 16);
  for (i = 0; i != 16; ++i)
  {
    v23 = v21;
    *v21++ = *((_BYTE *)v11 + i);
  }
  *v21 = a2;
  *(_WORD *)(v21 + 1) = 0;
  v21[3] = 0;
  v21[4] = a3;
  *(_WORD *)(v21 + 5) = 0;
  v24 = v23 + 9;
  v21[7] = 0;
  if (a2 == 135)
  {
    for (j = 0; j != 16; ++j)
    {
      v26 = v24;
      *v24++ = *(_BYTE *)(a7 + j);
    }
    if (vorr_s8(*a5, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5->i8, *(int8x16_t *)a5->i8, 8uLL)))
    {
      v27 = 0;
      *(_WORD *)v24 = 257;
      v24 = v26 + 3;
      do
      {
        if (a6)
        {
          v41 = *a6;
          v28 = *((_WORD *)a6 + 2);
        }
        else
        {
          v41 = *(_DWORD *)v17;
          v28 = *((_WORD *)v17 + 2);
        }
        v42 = v28;
        *v24++ = *((_BYTE *)&v41 + v27++);
      }
      while (v27 != 6);
    }
  }
  else
  {
    for (k = 0; k != 16; ++k)
    {
      v36 = v24;
      *v24++ = a5->i8[k];
    }
    v37 = 0;
    *(_WORD *)v24 = 258;
    v24 = v36 + 3;
    do
    {
      if (a6)
      {
        v39 = *a6;
        v38 = *((_WORD *)a6 + 2);
      }
      else
      {
        v39 = *(_DWORD *)v17;
        v38 = *((_WORD *)v17 + 2);
      }
      v40 = v38;
      *v24++ = *((_BYTE *)&v39 + v37++);
    }
    while (v37 != 6);
  }
  *(_BYTE *)(a1 + 28991) = (_BYTE)v24 - (a1 + 98);
  *(_WORD *)(a1 + 29028) = ~(unsigned __int16)IPv6CheckSum((uint64_t)a5, (uint64_t)v11, (unsigned __int16 *)(a1 + 29026), ((_BYTE)v24 - (a1 + 98)));
  mDNSPlatformSendRawPacket(v10, (uint64_t)v24, *(_QWORD *)(a4 + 32));
}

uint64_t BuildQuestion(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5, uint64_t **a6, unsigned int *a7, uint64_t a8)
{
  unint64_t v14;
  unint64_t v15;
  _BOOL4 v16;
  unsigned __int16 v17;
  uint64_t result;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  BOOL v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t i;
  BOOL v35;
  uint64_t *v36;
  uint64_t v37;
  unint64_t v38;
  _BOOL4 v39;
  unint64_t *v40;
  unsigned int v41;

  if ((*(_DWORD *)(a5 + 232) || *(_BYTE *)(a5 + 352)) && *(_BYTE *)(a1 + 12))
  {
    v14 = a3 + 1452;
    v15 = a3 + 1452 - *a7;
    v16 = *(_BYTE *)(a2 + 3677) != 0;
    if (*(_BYTE *)(a2 + 3677))
      v17 = 0x8000;
    else
      v17 = 0;
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v14 = a3 + 1452;
    v15 = a3 + 1452 - *a7;
  }
  result = (uint64_t)putQuestion(a3, *a4, v15, (unsigned __int8 *)(a5 + 376), *(unsigned __int16 *)(a5 + 342), *(unsigned __int16 *)(a5 + 344) | v17, (uint64_t)a7, a8);
  if (result)
  {
    v19 = result;
    v38 = v14;
    v41 = *a7;
    v20 = CacheGroupForName(a1, *(_DWORD *)(a5 + 200), (_BYTE *)(a5 + 376));
    v26 = v20;
    v27 = *a6;
    v40 = a4;
    v39 = v16;
    if (v20)
    {
      v28 = v20[2];
      if (v28)
      {
        while (1)
        {
          if (*(_QWORD *)(v28 + 32) != *(_QWORD *)(a5 + 64)
            || (*(_BYTE *)(v28 + 8) & 0x32) != 0
            || ((v29 = (uint64_t *)(v28 + 72), !*(_QWORD *)(v28 + 72)) ? (v30 = v27 == v29) : (v30 = 1),
                v30
             || *(unsigned __int16 *)(v28 + 20) > 0x400u
             || !SameNameRecordAnswersQuestion((unsigned __int8 *)(v28 + 8), 0, a5, v21, v22, v23, v24, v25)
             || *(_DWORD *)(v28 + 80) - *(_DWORD *)(a1 + 64) + ((1000 * *(_DWORD *)(v28 + 16)) >> 1) < 1001))
          {
            v29 = v27;
          }
          else
          {
            *v27 = v28;
            v31 = v41 + *(unsigned __int16 *)(v28 + 22) + 12;
            v32 = *(unsigned __int16 *)(a3 + 4);
            v41 += *(unsigned __int16 *)(v28 + 22) + 12;
            if (v32 >= 2 && v19 + v31 >= v38)
            {
              *(_WORD *)(a3 + 4) = v32 - 1;
              v36 = *a6;
              v37 = **a6;
              if (!v37)
                return 0;
              result = 0;
              do
              {
                *v36 = 0;
                v36 = (uint64_t *)(v37 + 72);
                v37 = *(_QWORD *)(v37 + 72);
              }
              while (v37);
              return result;
            }
          }
          v28 = *(_QWORD *)v28;
          v27 = v29;
          if (!v28)
            goto LABEL_27;
        }
      }
    }
    v29 = *a6;
LABEL_27:
    *v40 = v19;
    *a7 = v41;
    *a6 = v29;
    if (v39)
    {
      v33 = *(_DWORD *)(a1 + 64);
      if (v33 <= 1)
        v33 = 1;
      *(_DWORD *)(a5 + 216) = v33;
    }
    if (v26)
    {
      for (i = v26[2]; i; i = *(_QWORD *)i)
      {
        if (*(_QWORD *)(i + 32) == *(_QWORD *)(a5 + 64))
        {
          if (*(_QWORD *)(i + 72))
            v35 = 1;
          else
            v35 = v29 == (uint64_t *)(i + 72);
          if (!v35 && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, a5, v21, v22, v23, v24, v25))
          {
            ++*(_BYTE *)(i + 108);
            *(_DWORD *)(i + 104) = *(_DWORD *)(a1 + 64);
            SetNextCacheCheckTimeForRecord(a1, i);
          }
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t *UnsafeBufferPointer(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *result;
  uint64_t *v6;
  _BYTE *v7;

  result = mDNSGetTSRForAuthRecordNamed(a1, *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (result)
  {
    v6 = result;
    v7 = *(_BYTE **)(a2 + 40);
    while (1)
    {
      a3 = (uint64_t **)*a3;
      if (!a3)
        break;
      if (SameDomainNameBytes(a3[2], v7))
      {
        if (a3[1])
          return 0;
        return (uint64_t *)(v6[6] + 8);
      }
    }
    return (uint64_t *)(v6[6] + 8);
  }
  return result;
}

BOOL AddRecordInProbe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (*(_BYTE *)(a3 + 194))
    return 0;
  v7 = mDNSGetTSRForAuthRecordNamed(*(uint64_t **)(a1 + 12616), *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (*(_QWORD *)(a3 + 88) && v7 == 0)
    return 0;
  v15 = v7;
  v16 = *(_QWORD *)(a3 + 32);
  if (v16)
  {
    if (v16 != a4)
      return 0;
  }
  else if (!mDNSPlatformValidRecordForInterface(a3, a4, v8, v9, v10, v11, v12, v13))
  {
    return 0;
  }
  if (v15)
  {
    v17 = *(_QWORD *)(a2 + 96);
    if (!v17)
      v17 = a2;
    v18 = *(_QWORD *)(a3 + 96);
    if (!v18)
      v18 = a3;
    if (v17 == v18)
      return SameResourceRecordNameClassInterface(a2, a3, v8, v9, v10, v11, v12, v13);
  }
  if (*(_BYTE *)(a3 + 8) == 2 || *(_QWORD *)(a3 + 88))
    return SameResourceRecordNameClassInterface(a2, a3, v8, v9, v10, v11, v12, v13);
  return 0;
}

char *AddTSRROptsToMessage(_QWORD *a1, unint64_t a2, _WORD *a3, char *__dst, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v13;
  char *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  _BYTE *v22;
  uint64_t v23;
  int v24;
  int v25;
  _OWORD v27[2];
  __int128 v28;
  __int128 v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[28];

  v52 = 0u;
  memset(v53, 0, sizeof(v53));
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  LOWORD(v38) = 264;
  v28 = 0u;
  v29 = 0u;
  v13 = __rev16((unsigned __int16)*a3);
  memset(v27, 0, sizeof(v27));
  WORD2(v27[0]) = 41;
  *((_QWORD *)&v28 + 1) = &v38;
  WORD6(v27[0]) = 24;
  v14 = __dst;
  while (1)
  {
    a1 = (_QWORD *)*a1;
    if (!a1)
      break;
    v15 = a1[1];
    HIDWORD(v38) = *(_DWORD *)(v15 + 4);
    LOWORD(v39) = *(_WORD *)(v15 + 8);
    LODWORD(v15) = *(_DWORD *)v15;
    DWORD1(v38) = 720362;
    DWORD2(v38) = v15;
    v14 = putRData(a2, v14, a5, (uint64_t)v27, a5, a6, a7, a8);
    if (!v14)
    {
      v16 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
          v18 = a1[2];
          if (v18)
          {
            v19 = (_BYTE *)a1[2];
            if (v18 == -256)
            {
LABEL_13:
              while (v19)
              {
                v20 = *v19;
                if (v20 > 0x3F)
                  break;
                if (!*v19)
                {
                  v24 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                  goto LABEL_36;
                }
                v19 += v20 + 1;
                if (v18 != -256)
                  goto LABEL_12;
              }
            }
            else
            {
LABEL_12:
              if ((unint64_t)v19 < v18 + 256)
                goto LABEL_13;
            }
            v24 = 257;
          }
          else
          {
            v24 = 0;
          }
LABEL_36:
          v25 = *(_DWORD *)(a1[1] + 4);
          *(_DWORD *)buf = 141558787;
          v31 = 1752392040;
          v32 = 1040;
          v33 = v24;
          v34 = 2101;
          v35 = v18;
          v36 = 1024;
          v37 = v25;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "AddTSRRDataToMessage: TSR can't be written -- name %{sensitive, mask.hash, mdnsresponder:domain_name}.*P hashkey %x", buf, 0x22u);
        }
      }
      else
      {
        v16 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
          v18 = a1[2];
          if (v18)
          {
            v22 = (_BYTE *)a1[2];
            if (v18 == -256)
            {
LABEL_24:
              while (v22)
              {
                v23 = *v22;
                if (v23 > 0x3F)
                  break;
                if (!*v22)
                {
                  v24 = (unsigned __int16)((_WORD)v22 - v18 + 1);
                  goto LABEL_36;
                }
                v22 += v23 + 1;
                if (v18 != -256)
                  goto LABEL_23;
              }
            }
            else
            {
LABEL_23:
              if ((unint64_t)v22 < v18 + 256)
                goto LABEL_24;
            }
            v24 = 257;
          }
          else
          {
            v24 = 0;
          }
          goto LABEL_36;
        }
      }
      return 0;
    }
  }
  if (v14 == __dst)
    return __dst;
  *a3 = bswap32((_DWORD)v14 - (_DWORD)__dst + v13) >> 16;
  return v14;
}

void TimeoutQuestions_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;

  v11 = *(_QWORD *)(a1 + 208);
  if (v11)
  {
    v12 = mDNSLogCategory_Default;
    v13 = v11 + 376;
    DNSTypeName(*(unsigned __int16 *)(v11 + 342));
    LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions ERROR m->CurrentQuestion already set: %##s (%s)", v14, v15, v16, v17, v18, v13);
  }
  *(_QWORD *)(a1 + 208) = a2;
  if (a2)
  {
    do
    {
      v19 = *(_DWORD *)(a2 + 240);
      if (v19)
      {
        if (!*(_BYTE *)(a2 + 637))
        {
          v20 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions: ERROR!! TimeoutQuestion not set, but StopTime set for %##s (%s)", v21, v22, v23, v24, v25, a2 + 376);
          v19 = *(_DWORD *)(a2 + 240);
        }
        if (*(_DWORD *)(a1 + 64) - v19 < 0)
        {
          if (*(_DWORD *)(a1 + 184) - v19 >= 1)
            *(_DWORD *)(a1 + 184) = v19;
        }
        else
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions: question %p %##s timed out, time %d", a4, a5, a6, a7, a8, a2);
          *(_BYTE *)(a2 + 355) = 0;
          GenerateNegativeResponseEx(a1, a3, 3, 0, a5, a6, a7, a8, v27);
          if (*(_QWORD *)(a1 + 208) == a2)
            *(_DWORD *)(a2 + 240) = 0;
        }
      }
      v26 = *(_QWORD *)(a1 + 208);
      if (v26 == a2)
      {
        v26 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a1 + 208) = v26;
      }
      a2 = v26;
    }
    while (v26);
  }
  *(_QWORD *)(a1 + 208) = 0;
}

void SendWakeup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  _BYTE *v7;
  uint64_t *v8;
  uint64_t i;
  _WORD *v10;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t j;
  uint64_t v16;
  NSObject *v17;
  int v20;
  uint64_t v21;

  v7 = (_BYTE *)(a1 + 28972);
  v8 = (uint64_t *)(a1 + 12656);
  do
  {
    v8 = (uint64_t *)*v8;
    if (!v8)
    {
      v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          return;
        v20 = 134217984;
        v21 = a2;
      }
      else
      {
        v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        v20 = 134217984;
        v21 = a2;
      }
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SendARP: No interface with InterfaceID %p found", (uint8_t *)&v20, 0xCu);
      return;
    }
  }
  while (v8[444] != a2);
  for (i = 0; i != 6; ++i)
    v7[i] = *(_BYTE *)(a3 + i);
  v10 = (_WORD *)(a1 + 28978);
  do
  {
    v11 = v10;
    *(_BYTE *)v10 = *((_BYTE *)v8 + 3600);
    v10 = (_WORD *)((char *)v10 + 1);
    LODWORD(i) = i - 1;
  }
  while ((_DWORD)i);
  *v10 = 16904;
  *(_DWORD *)((char *)v11 + 3) = -1;
  *(_WORD *)((char *)v11 + 7) = -1;
  v12 = a1 + 28992;
  do
  {
    v13 = 0;
    v14 = v12;
    do
    {
      *(_BYTE *)(v12 + v13) = *(_BYTE *)(a3 + v13);
      ++v13;
    }
    while (v13 != 6);
    v12 += 6;
    LODWORD(i) = i + 1;
  }
  while ((_DWORD)i != 16);
  for (j = 0; j != 6; ++j)
    *(_BYTE *)(v14 + j + 6) = *(_BYTE *)(a4 + j);
  v16 = v14 + 12;
  mDNSPlatformSendRawPacket((void *)(a1 + 28972), v14 + 12, a2);
  if (!a5)
  {
    *((_WORD *)v7 + 2) = -1;
    *(_DWORD *)v7 = -1;
    mDNSPlatformSendRawPacket(v7, v16, a2);
  }
}

uint64_t ResourceRecordIsValidInterfaceAnswer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;

  v9 = *(_QWORD *)(a1 + 32);
  if (v9)
  {
    result = v9 == a2;
    if (v9 != a2)
      return result;
  }
  else
  {
    result = mDNSPlatformValidRecordForInterface(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
  }
  return ResourceRecordIsValidAnswer(a1);
}

uint64_t AddRRSetAdditionalsToResponseList(uint64_t result, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  uint64_t v13;

  if ((*(_BYTE *)(a4 + 8) & 0x32) != 0)
  {
    for (i = *(_QWORD *)(result + 12616); i; i = *(_QWORD *)i)
    {
      if (*(_DWORD *)(i + 24) == *(_DWORD *)(a4 + 24)
        && i != a4
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a4 + 12)
        && (*(_BYTE *)(i + 8) & 0x32) != 0
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a4 + 14))
      {
        result = ResourceRecordIsValidInterfaceAnswer(i, a5, a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          result = SameDomainNameBytes(*(_BYTE **)(i + 40), *(_BYTE **)(a4 + 40));
          if ((_DWORD)result)
          {
            if (!*(_QWORD *)(i + 256) && *a2 != (uint64_t *)(i + 256))
            {
              **a2 = i;
              v13 = *(_QWORD *)(a3 + 272);
              if (!v13)
                v13 = a3;
              *(_QWORD *)(i + 272) = v13;
              *a2 = (uint64_t *)(i + 256);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t IPv6CheckSum(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned __int16 *v8;
  unsigned int i;
  int v10;
  unsigned int v11;
  __int128 v13;
  __int16 v14;
  char v15;
  char v16;
  int v17;

  v14 = 0;
  v15 = BYTE1(a4);
  v16 = a4;
  v17 = 973078528;
  if (a4 < 1)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = a4 + 2;
    do
    {
      v6 = *a3++;
      v4 += v6;
      v5 -= 2;
    }
    while (v5 > 2);
  }
  v7 = ((HIWORD(v4) + (unsigned __int16)v4) >> 16) + (unsigned __int16)(HIWORD(v4) + v4);
  if (v7 == 0xFFFF)
    v7 = 0;
  else
    v7 = (unsigned __int16)v7;
  v8 = (unsigned __int16 *)&v13;
  for (i = 42; i > 2; i -= 2)
  {
    v10 = *v8++;
    v7 += v10;
  }
  v11 = ((HIWORD(v7) + (unsigned __int16)v7) >> 16) + (unsigned __int16)(HIWORD(v7) + v7);
  if (v11 == 0xFFFF)
    LOWORD(v11) = 0;
  return (unsigned __int16)v11;
}

void SendSleepGoodbyes(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  uint64_t i;
  _DWORD *v11;
  void (*v12)(uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t *j;

  *(_BYTE *)(a1 + 141) = 2;
  if ((_DWORD)a2)
  {
    v9 = *(uint64_t **)(a1 + 12656);
    if (v9)
    {
      while (!*((_BYTE *)v9 + 16))
      {
        v9 = (uint64_t *)*v9;
        if (!v9)
          goto LABEL_5;
      }
LABEL_26:
      *((_BYTE *)v9 + 3675) = 1;
      while (1)
      {
        v9 = (uint64_t *)*v9;
        if (!v9)
          break;
        if (*((_BYTE *)v9 + 16))
          goto LABEL_26;
      }
    }
  }
LABEL_5:
  if ((_DWORD)a3)
  {
    for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
    {
      if (!*(_QWORD *)(i + 32) && !*(_BYTE *)(i + 122) && !IsLocalDomain(*(_BYTE **)(i + 40)))
      {
        v11 = *(_DWORD **)(i + 376);
        if (v11)
        {
          *(_WORD *)(i + 358) = 0;
          CancelGetZoneData(a1, v11);
          *(_QWORD *)(i + 376) = 0;
        }
        if (*(_QWORD *)(i + 584))
        {
          mDNS_StopNATOperation_internal(a1, i + 392);
          *(_QWORD *)(i + 584) = 0;
        }
        if (*(_DWORD *)(i + 344) == 7)
        {
          *(_DWORD *)(i + 344) = 2;
          v12 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(i + 320);
          if (v12)
            v12(a1, i, *(_QWORD *)(i + 624), *(unsigned __int16 *)(i + 616));
          SetNewRData(i + 8, *(_QWORD *)(i + 632), *(unsigned __int16 *)(i + 618), (uint64_t)a4, a5, a6, a7, a8);
          *(_OWORD *)(i + 624) = 0u;
        }
        uDNS_DeregisterRecord(a1, i);
      }
    }
  }
  for (j = *(uint64_t **)(a1 + 12616); j; j = (uint64_t *)*j)
  {
    if (*((_BYTE *)j + 8) == 8 && *((_BYTE *)j + 192))
      j[26] = -1;
  }
  SendResponses(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t mDNS_GetDomains_Internal(uint64_t a1, uint64_t a2, int a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned __int8 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;

  *(_QWORD *)(a2 + 136) = a5;
  *(_DWORD *)(a2 + 324) = 0;
  *(_DWORD *)(a2 + 342) = 65548;
  *(_BYTE *)(a2 + 641) = 0;
  *(_WORD *)(a2 + 639) = 0;
  *(_BYTE *)(a2 + 652) = 0;
  *(_DWORD *)(a2 + 632) = 0;
  *(_WORD *)(a2 + 636) = 0;
  *(_DWORD *)(a2 + 244) = getpid();
  *(_DWORD *)(a2 + 248) = 0;
  *(_QWORD *)(a2 + 152) = a6;
  *(_QWORD *)(a2 + 176) = a7;
  v13 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
  *(_BYTE *)(a2 + 376) = 0;
  if (AppendDNSNameString((_BYTE *)(a2 + 376), v13, v14, v15, v16, v17, v18, v19)
    && (a4 ? (v20 = a4) : (v20 = "\x05local"), AppendDomainName((_BYTE *)(a2 + 376), v20)))
  {
    return mDNS_StartQuery_internal(a1, a2);
  }
  else
  {
    return 4294901756;
  }
}

void mDNS_DeregisterDomainsDiscoveredForDomainEnumeration(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t **v13;
  uint64_t v14;

  v8 = a2 + 8 * a3;
  v9 = *(uint64_t **)(v8 + 256);
  if (v9)
  {
    v10 = *v9;
    if (*v9)
    {
      v13 = (uint64_t **)(v8 + 256);
      do
      {
        v14 = *(_QWORD *)(v10 + 256);
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (_BYTE *)v10, a3, 1, a5, a6, a7, a8);
        free((void *)v10);
        v10 = v14;
      }
      while (v14);
      v9 = *v13;
    }
    *v9 = 0;
  }
}

void mDNSCoreRestartAddressQueries(int a1, void (*a2)(uint64_t *), void (*a3)(uint64_t *, uint64_t), uint64_t a4)
{
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t);
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  char *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;

  mDNS_VerifyLockState("Check Lock", 1, dword_100158DF8, dword_100158DFC, (uint64_t)"mDNSCoreRestartAddressQueries", 7121);
  if (a2)
    a2(mDNSStorage);
  if (qword_100158EB0)
  {
    v5 = mDNSLogCategory_Default;
    v6 = qword_100158EB0 + 376;
    DNSTypeName(*(unsigned __int16 *)(qword_100158EB0 + 342));
    LogMsgWithLevel(v5, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: ERROR!! m->RestartQuestion already set: %##s (%s)", v7, v8, v9, v10, v11, v6);
  }
  v12 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  qword_100158EB0 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  for (i = 0; qword_100158EB0; v12 = qword_100158EB0)
  {
    v14 = *(_QWORD *)(v12 + 8);
    qword_100158EB0 = v14;
    if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(v12 + 152) == GetZoneData_QuestionCallback)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        v31 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v12 + 342));
        LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Skipping GetZoneDataQuestion %p %##s (%s)", v32, v33, v34, v35, v36, v12);
      }
      if (v14)
      {
        v37 = mDNS_LoggingEnabled;
        do
        {
          if (v12 == *(_QWORD *)(v14 + 104) + 832 && v37 != 0)
          {
            v39 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v14 + 342));
            LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Question %p %##s (%s) referring to GetZoneDataQuestion %p, not stopping", v40, v41, v42, v43, v44, v14);
            v37 = mDNS_LoggingEnabled;
          }
          v14 = *(_QWORD *)(v14 + 8);
        }
        while (v14);
      }
      goto LABEL_36;
    }
    v15 = *(unsigned __int16 *)(v12 + 342);
    v16 = v15 > 0x1C;
    v17 = (1 << v15) & 0x10000022;
    v18 = v16 || v17 == 0;
    if (!v18 && (!a1 || *(_BYTE *)(v12 + 641)))
    {
      if (CacheRecordRmvEventsForQuestion(v12))
      {
        if (LocalRecordRmvEventsForQuestion(v12))
        {
          if (mDNS_LoggingEnabled)
          {
            v24 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v12 + 342));
            LogMsgWithLevel(v24, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Stop question %p %##s (%s), AppendSearchDomains %d", v25, v26, v27, v28, v29, v12);
          }
          mDNS_StopQuery_internal((uint64_t)mDNSStorage, v12);
          v30 = *(void (**)(uint64_t))(v12 + 160);
          if (v30)
            v30(v12);
          *(_QWORD *)(v12 + 8) = i;
          goto LABEL_37;
        }
        if (mDNS_LoggingEnabled)
        {
          v45 = mDNSLogCategory_Default;
          v46 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Local Record RMV events";
          goto LABEL_35;
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        v45 = mDNSLogCategory_Default;
        v46 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Cache Record RMV events";
LABEL_35:
        LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, v46, v19, v20, v21, v22, v23, v54);
      }
    }
LABEL_36:
    v12 = i;
LABEL_37:
    i = v12;
  }
  if (a3)
    a3(mDNSStorage, a4);
  if (i)
  {
    do
    {
      v47 = *(_QWORD *)(i + 8);
      *(_QWORD *)(i + 8) = 0;
      if (mDNS_LoggingEnabled == 1)
      {
        v48 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(i + 342));
        LogMsgWithLevel(v48, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Start question %p %##s (%s)", v49, v50, v51, v52, v53, i);
      }
      mDNS_StartQuery_internal((uint64_t)mDNSStorage, i);
      i = v47;
    }
    while (v47);
  }
}

BOOL CacheRecordRmvEventsForQuestion(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL8 result;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v28;
  _BYTE *v29;
  unsigned __int16 v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v34;
  _BYTE *v35;
  unsigned __int16 v36;
  uint64_t v37;
  _BYTE *v39;
  unsigned __int16 v40;
  uint64_t v41;
  _BYTE *v43;
  unsigned __int16 v44;
  uint64_t v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  int v54;
  uint8_t buf[4];
  unsigned int v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  int v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;

  if (*(_QWORD *)((char *)&xmmword_100158E94 + 4))
  {
    v2 = mDNSLogCategory_Default;
    v3 = DWORD1(xmmword_100158E94) + 376;
    DNSTypeName(*(unsigned __int16 *)(*(_QWORD *)((char *)&xmmword_100158E94 + 4) + 342));
    LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "CacheRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)", v4, v5, v6, v7, v8, v3);
  }
  for (i = *(_QWORD *)((char *)&xmmword_100158E84 + 12); i != a1 && i != 0; i = *(_QWORD *)(i + 8))
    ;
  if (!i && !*(_BYTE *)(a1 + 355))
  {
    *(_QWORD *)((char *)&xmmword_100158E94 + 4) = a1;
    v18 = CacheGroupForName((uint64_t)&mDNSStorage, *(_DWORD *)(a1 + 200), (_BYTE *)(a1 + 376));
    if (!v18 || (v24 = v18[2]) == 0)
    {
LABEL_104:
      result = *(_QWORD *)((char *)&xmmword_100158E94 + 4) == a1;
      *(_QWORD *)((char *)&xmmword_100158E94 + 4) = 0;
      return result;
    }
    while (*(unsigned __int8 *)(v24 + 8) == 240)
    {
      v25 = *(_QWORD *)(a1 + 144);
      if (v25)
      {
        if (*(_BYTE *)(v25 + 24))
          break;
      }
      v32 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
      {
        v32 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_103;
        v34 = *(_QWORD *)(v24 + 40);
        if (v34)
        {
          v43 = *(_BYTE **)(v24 + 40);
          if (v34 == -256)
          {
LABEL_69:
            if (v43)
              goto LABEL_70;
          }
          else
          {
            while (2)
            {
              v44 = 257;
              if ((unint64_t)v43 >= v34 + 256 || !v43)
              {
LABEL_99:
                v47 = v44;
                goto LABEL_100;
              }
LABEL_70:
              v45 = *v43;
              if (v45 <= 0x3F)
              {
                if (!*v43)
                {
                  v44 = (_WORD)v43 - v34 + 1;
                  goto LABEL_99;
                }
                v43 += v45 + 1;
                if (v34 != -256)
                  continue;
                goto LABEL_69;
              }
              break;
            }
          }
          v44 = 257;
          goto LABEL_99;
        }
        v47 = 0;
LABEL_100:
        v51 = *(_QWORD *)(v24 + 96);
        if (v51)
          LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 340)) >> 16;
LABEL_102:
        v52 = bswap32(*(unsigned __int16 *)(a1 + 340));
        v53 = *(unsigned __int16 *)(v24 + 12);
        v54 = *(_DWORD *)(a1 + 228);
        *(_DWORD *)buf = 67110659;
        v56 = HIWORD(v52);
        v57 = 2160;
        v58 = 1752392040;
        v59 = 1040;
        v60 = v47;
        v61 = 2101;
        v62 = v34;
        v63 = 1024;
        v64 = v53;
        v65 = 1024;
        v66 = v51;
        v67 = 1024;
        v68 = v54;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Suppressing RMV events for question - rr name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, current active question: Q%u, current answers: %u", buf, 0x34u);
        goto LABEL_103;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v34 = *(_QWORD *)(v24 + 40);
        if (!v34)
        {
          v47 = 0;
          goto LABEL_95;
        }
        v35 = *(_BYTE **)(v24 + 40);
        if (v34 == -256)
          goto LABEL_47;
        while (2)
        {
          v36 = 257;
          if ((unint64_t)v35 >= v34 + 256 || !v35)
          {
LABEL_94:
            v47 = v36;
LABEL_95:
            v51 = *(_QWORD *)(v24 + 96);
            if (v51)
              LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 340)) >> 16;
            goto LABEL_102;
          }
LABEL_48:
          v37 = *v35;
          if (v37 <= 0x3F)
          {
            if (!*v35)
            {
              v36 = (_WORD)v35 - v34 + 1;
              goto LABEL_94;
            }
            v35 += v37 + 1;
            if (v34 != -256)
              continue;
LABEL_47:
            if (v35)
              goto LABEL_48;
          }
          break;
        }
        v36 = 257;
        goto LABEL_94;
      }
LABEL_103:
      v24 = *(_QWORD *)v24;
      if (!v24)
        goto LABEL_104;
    }
    if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v24 + 8), 0, a1, v19, v20, v21, v22, v23))
      goto LABEL_103;
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_87;
      v28 = *(_QWORD *)(v24 + 40);
      if (v28)
      {
        v29 = *(_BYTE **)(v24 + 40);
        if (v28 == -256)
          goto LABEL_31;
LABEL_28:
        v30 = 257;
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_76:
              v30 = 257;
              goto LABEL_83;
            }
            if (!*v29)
              break;
            v29 += v31 + 1;
            if (v28 != -256)
              goto LABEL_28;
LABEL_31:
            if (!v29)
              goto LABEL_76;
          }
          v30 = (_WORD)v29 - v28 + 1;
        }
LABEL_83:
        v46 = v30;
      }
      else
      {
        v46 = 0;
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_87:
        --*(_DWORD *)(a1 + 228);
        if (*(unsigned __int16 *)(v24 + 20) >= 0x401u)
          --*(_DWORD *)(a1 + 232);
        if ((*(_BYTE *)(v24 + 8) & 0x10) != 0)
          --*(_DWORD *)(a1 + 236);
        AnswerCurrentQuestionWithResourceRecord((uint64_t)&mDNSStorage, v24, 0);
        if (*(_QWORD *)((char *)&xmmword_100158E94 + 4) != a1)
          goto LABEL_104;
        goto LABEL_103;
      }
      v28 = *(_QWORD *)(v24 + 40);
      if (v28)
      {
        v39 = *(_BYTE **)(v24 + 40);
        if (v28 == -256)
          goto LABEL_58;
LABEL_55:
        v40 = 257;
        if ((unint64_t)v39 < v28 + 256 && v39)
        {
          while (1)
          {
            v41 = *v39;
            if (v41 > 0x3F)
            {
LABEL_77:
              v40 = 257;
              goto LABEL_85;
            }
            if (!*v39)
              break;
            v39 += v41 + 1;
            if (v28 != -256)
              goto LABEL_55;
LABEL_58:
            if (!v39)
              goto LABEL_77;
          }
          v40 = (_WORD)v39 - v28 + 1;
        }
LABEL_85:
        v46 = v40;
      }
      else
      {
        v46 = 0;
      }
    }
    v48 = bswap32(*(unsigned __int16 *)(a1 + 340));
    v49 = *(unsigned __int16 *)(v24 + 12);
    v50 = *(unsigned __int8 *)(a1 + 355);
    *(_DWORD *)buf = 67110403;
    v56 = HIWORD(v48);
    v57 = 2160;
    v58 = 1752392040;
    v59 = 1040;
    v60 = v46;
    v61 = 2101;
    v62 = v28;
    v63 = 1024;
    v64 = v49;
    v65 = 1024;
    v66 = v50;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Calling AnswerCurrentQuestionWithResourceRecord (RMV) for question - rr name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, local answers: %u", buf, 0x2Eu);
    goto LABEL_87;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    v11 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a1 + 342));
    LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "CacheRecordRmvEventsForQuestion: Question %p %##s (%s) is a new question", v12, v13, v14, v15, v16, a1);
  }
  return 1;
}

uint64_t LocalRecordRmvEventsForQuestion(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  unsigned int v26;
  BOOL v27;
  int v28;
  BOOL v29;
  _BYTE *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t result;

  if (*(_QWORD *)((char *)&xmmword_100158E94 + 4))
  {
    v2 = mDNSLogCategory_Default;
    v3 = DWORD1(xmmword_100158E94) + 376;
    DNSTypeName(*(unsigned __int16 *)(*(_QWORD *)((char *)&xmmword_100158E94 + 4) + 342));
    LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)", v4, v5, v6, v7, v8, v3);
  }
  for (i = *(_QWORD *)((char *)&xmmword_100158E84 + 12); i != a1 && i != 0; i = *(_QWORD *)(i + 8))
    ;
  if (i)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v11 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a1 + 342));
      LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: New Question %##s (%s)", v12, v13, v14, v15, v16, a1 + 376);
    }
  }
  else
  {
    *(_QWORD *)((char *)&xmmword_100158E94 + 4) = a1;
    v17 = AuthGroupForName((uint64_t)&xmmword_100158E94 + &unk_1000017A8 + 4, *(_DWORD *)(a1 + 200), (_BYTE *)(a1 + 376));
    if (v17)
    {
      v24 = v17[2];
      if (v24)
      {
        v25 = &unk_100158000;
        do
        {
          if (*(_DWORD *)(v24 + 172) == 4 && (*(_BYTE *)(v24 + 8) & 0x32) != 0)
          {
            v26 = *(unsigned __int16 *)(v24 + 12);
            v27 = v26 > 0x1C;
            v28 = (1 << v26) & 0x10001022;
            v29 = v27 || v28 == 0;
            if (!v29 && LocalOnlyRecordAnswersQuestion(v24, a1, v18, v19, v20, v21, v22, v23))
            {
              if (v25[3304] == 1)
              {
                v30 = v25;
                v31 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v24 + 8), (unsigned __int16 *)(*(_QWORD *)(v24 + 48) + 4), word_100164580);
                v32 = v31;
                v25 = v30;
                LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: Delivering possible Rmv events with record %s", v33, v34, v35, v36, v37, (int)word_100164580);
              }
              if (*(_DWORD *)(a1 + 228) && *(_BYTE *)(a1 + 355))
              {
                AnswerLocalQuestionWithLocalAuthRecord((uint64_t)&mDNSStorage, v24, 0);
                if (*(_QWORD *)((char *)&xmmword_100158E94 + 4) != a1)
                {
                  result = 0;
                  *(_QWORD *)((char *)&xmmword_100158E94 + 4) = 0;
                  return result;
                }
              }
              else
              {
                v38 = mDNSLogCategory_Default;
                DNSTypeName(*(unsigned __int16 *)(a1 + 342));
                LogMsgWithLevel(v38, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: ERROR!! CurrentAnswers or LOAddressAnswers is zero %p %##s (%s) CurrentAnswers %d, LOAddressAnswers %d", v39, v40, v41, v42, v43, a1);
              }
            }
          }
          v24 = *(_QWORD *)v24;
        }
        while (v24);
      }
    }
    *(_QWORD *)((char *)&xmmword_100158E94 + 4) = 0;
  }
  return 1;
}

void mDNSCoreRestartQueries(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  int v14;
  uint64_t v15;
  uint64_t j;

  v2 = *(_QWORD *)(a1 + 208);
  if (v2)
  {
    v3 = mDNSLogCategory_Default;
    v4 = v2 + 376;
    DNSTypeName(*(unsigned __int16 *)(v2 + 342));
    LogMsgWithLevel(v3, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartQueries: ERROR m->CurrentQuestion already set: %##s (%s)", v5, v6, v7, v8, v9, v4);
  }
  v10 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 208) = v10;
  if (v10)
  {
    do
    {
      v11 = *(_QWORD *)(v10 + 8);
      *(_QWORD *)(a1 + 208) = v11;
      if (*(_WORD *)(v10 + 340) && *(int *)(v10 + 212) >= 1 && !*(_QWORD *)(v10 + 40))
      {
        v12 = *(_QWORD *)(v10 + 96);
        if (v12)
        {
          mdns_client_invalidate(v12);
          os_release(*(void **)(v10 + 96));
          *(_QWORD *)(v10 + 96) = 0;
        }
        ActivateUnicastQuery(a1, v10, 1);
        v11 = *(_QWORD *)(a1 + 208);
      }
      v10 = v11;
    }
    while (v11);
    for (i = *(_QWORD *)(a1 + 192); i; i = *(_QWORD *)(i + 8))
    {
      if (!*(_WORD *)(i + 340) && *(int *)(i + 212) >= 1 && !*(_QWORD *)(i + 40))
      {
        *(_BYTE *)(i + 352) = 2;
        v14 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(i + 208) = v14 - 334;
        *(_DWORD *)(i + 212) = 334;
        *(_DWORD *)(i + 224) = 0;
        v15 = *(_QWORD *)(i + 56);
        if (v15)
        {
          for (j = 0; j != 128; j += 16)
          {
            if (*(_DWORD *)(v15 + j + 8) - v14 < 0)
              *(_QWORD *)(v15 + j) = 0;
          }
        }
        *(_DWORD *)(a1 + 92) = v14;
      }
    }
  }
}

void mDNSCoreRestartRegistration(_DWORD *a1, uint64_t a2, int a3)
{
  int v6;
  char v7;
  _BYTE *v8;
  uint64_t v9;
  unsigned __int8 v10;

  if (!*(_QWORD *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
    return;
  v6 = *(unsigned __int8 *)(a2 + 8);
  if (v6 != 2)
  {
    if (v6 != 16 || *(_QWORD *)(a2 + 88))
    {
      v7 = 0;
      goto LABEL_10;
    }
    *(_BYTE *)(a2 + 8) = 2;
  }
  v7 = 3;
LABEL_10:
  *(_BYTE *)(a2 + 190) = v7;
  if (*(_WORD *)(a2 + 12) == 10
    && ((v8 = *(_BYTE **)(a2 + 40), *v8) ? (v9 = *v8 + 1) : (v9 = 0),
        SameDomainLabelPointer(&v8[v9], "\n_keepalive")))
  {
    *(_BYTE *)(a2 + 191) = 0;
  }
  else
  {
    if (a3 >= 0)
      v10 = a3;
    else
      v10 = 4;
    if (*(unsigned __int8 *)(a2 + 191) < v10)
      *(_BYTE *)(a2 + 191) = v10;
  }
  *(_QWORD *)(a2 + 200) = 0;
  InitializeLastAPTime(a1, a2);
}

void mDNSCoreMachineSleep(uint64_t a1, int a2)
{
  unsigned __int8 *v4;
  NSObject *v5;
  const char *v7;
  int v8;
  int v9;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  int v20;
  NSObject *v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  char v39;
  NSObject *v40;
  uint64_t v41;
  NSObject *v42;
  const char *v43;
  uint64_t i;
  NSObject *v45;
  uint64_t v48;
  int v49;
  unsigned int v50;
  uint64_t DNSServiceManager;
  int v52;
  unsigned int v53;
  NSObject *v54;
  const char *v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  _BYTE buf[24];
  __int128 v61;

  v4 = (unsigned __int8 *)(a1 + 15104);
  v5 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_14;
    v7 = "Sleeping";
    v8 = *(unsigned __int8 *)(a1 + 141);
    v9 = *(_DWORD *)(a1 + 64);
    if (!a2)
      v7 = "Waking";
    goto LABEL_13;
  }
  v5 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    v7 = "Sleeping";
    v8 = *(unsigned __int8 *)(a1 + 141);
    v9 = *(_DWORD *)(a1 + 64);
    if (!a2)
      v7 = "Waking";
LABEL_13:
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s (old state %d) at %d", buf, 0x18u);
  }
LABEL_14:
  if (a2)
  {
    if (*(_BYTE *)(a1 + 141))
      return;
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8231);
    if (*(_QWORD *)(a1 + 15120))
    {
      v11 = v4[5];
      v12 = *(_DWORD *)(a1 + 48);
      v13 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v13;
      mDNS_VerifyLockState("Drop Lock", 0, v12, v13, (uint64_t)"mDNSCoreMachineSleep", 8236);
      v4[5] = 2;
      if (v11 == 1)
        mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15128, 0, v14, v15, v16, v17, v18);
      mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNSCoreMachineSleep", 8243);
      --*(_DWORD *)(a1 + 52);
    }
    v19 = *(void **)(a1 + 15024);
    if (v19)
    {
      CloseSocketSet(*(_QWORD *)(a1 + 15024));
      free(v19);
      *(_QWORD *)(a1 + 15024) = 0;
    }
    *(_BYTE *)(a1 + 141) = 1;
    if (!*(_BYTE *)(a1 + 143) || (v20 = *(_DWORD *)(a1 + 148)) == 0)
    {
      v50 = *(_DWORD *)(a1 + 64) + 10000;
      if (v50 <= 1)
        v50 = 1;
      *(_DWORD *)(a1 + 148) = 0;
      *(_DWORD *)(a1 + 152) = v50;
      ++*((_DWORD *)v4 + 1214);
      DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager)
      {
        mdns_dns_service_manager_enumerate(DNSServiceManager, (uint64_t)&__block_literal_global_47);
        if (_mdns_resolver_queue_s_once != -1)
          dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
        dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &__block_literal_global_4830);
      }
      BeginSleepProcessing(a1);
LABEL_110:
      v54 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          v55 = "?";
          v58 = *(unsigned __int8 *)(a1 + 141);
          if (v58 == 2)
            v55 = "Sleeping";
          v57 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = v58;
          if (v58 == 1)
            v55 = "Transferring";
          goto LABEL_123;
        }
      }
      else
      {
        v54 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          v55 = "?";
          v56 = *(unsigned __int8 *)(a1 + 141);
          if (v56 == 2)
            v55 = "Sleeping";
          v57 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = v56;
          if (v56 == 1)
            v55 = "Transferring";
LABEL_123:
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = v55;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v57;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: m->SleepState %d (%{public}s) seq %d", buf, 0x18u);
        }
      }
      v48 = a1;
      v49 = 8279;
      goto LABEL_125;
    }
    v21 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        v52 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v52;
        goto LABEL_106;
      }
    }
    else
    {
      v21 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      {
        v22 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v22;
LABEL_106:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: Re-sleeping immediately after waking; will delay for %d ticks",
          buf,
          8u);
      }
    }
    v53 = *(_DWORD *)(a1 + 148) + 10000;
    if (v53 <= 1)
      v53 = 1;
    *(_DWORD *)(a1 + 152) = v53;
    goto LABEL_110;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8288);
  *(_DWORD *)(a1 + 152) = 0;
  if (*(_BYTE *)(a1 + 141))
  {
    *(_BYTE *)(a1 + 141) = 0;
    ++*(_BYTE *)(a1 + 142);
    v23 = *(_DWORD *)(a1 + 64) + 5000;
    if (v23 <= 1)
      v23 = 1;
    *(_DWORD *)(a1 + 148) = v23;
  }
  if (v4[5] == 3)
  {
    v4[5] = 0;
    mDNSCoreBeSleepProxyServer_internal(a1, *v4, v4[1], v4[2], v4[3], v4[4]);
  }
  ++*((_DWORD *)v4 + 1215);
  v24 = Querier_GetDNSServiceManager();
  if (v24)
  {
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __mdns_dns_service_manager_handle_wake_block_invoke;
    *(_QWORD *)&v61 = &__block_descriptor_tmp_48;
    *((_QWORD *)&v61 + 1) = v24;
    mdns_dns_service_manager_enumerate(v24, (uint64_t)buf);
  }
  mDNSCoreRestartQueries(a1);
  v25 = *(_DWORD *)(a1 + 64);
  if ((v25 + 1000) <= 1)
    v26 = 1;
  else
    v26 = v25 + 1000;
  *(_DWORD *)(a1 + 12684) = v26;
  v27 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_44:
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v26 - v25;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v25;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep waking: NextSRVUpdate in %d %d", buf, 0xEu);
    }
  }
  else
  {
    v27 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_44;
  }
  v28 = time(0);
  v29 = 0;
  v30 = v28 - *(_DWORD *)(a1 + 156);
  do
  {
    v59 = v29;
    v31 = *(_QWORD **)(a1 + 8 * v29 + 272);
    if (v31)
    {
      while (1)
      {
        v32 = v31[2];
        if (v32)
          break;
LABEL_76:
        v31 = (_QWORD *)*v31;
        if (!v31)
          goto LABEL_77;
      }
      while (1)
      {
        if (*(_QWORD *)(v32 + 32))
        {
          mDNS_Reconfirm_internal(a1, v32, 0x1388u);
        }
        else if (v30 >= 1)
        {
          v33 = (4 * *(_DWORD *)(v32 + 16) - 8) / 5u;
          v34 = *(_DWORD *)(a1 + 64);
          v35 = *(_DWORD *)(v32 + 80);
          v36 = (v34 - v35) / -1000 + v33;
          if (v30 > 0x2A300 || v30 >= v36)
          {
            v41 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                goto LABEL_71;
            }
            else
            {
              v41 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                goto LABEL_71;
            }
            GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(_QWORD *)(v32 + 48) + 4), (_BYTE *)(a1 + 47032));
            *(_DWORD *)buf = 141558787;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 2085;
            *(_QWORD *)&buf[14] = a1 + 47032;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v61) = v30;
            WORD2(v61) = 1024;
            *(_DWORD *)((char *)&v61 + 6) = v36;
            v42 = v41;
            v43 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging cache entry SleptTime %d, Remaining TTL %d";
            goto LABEL_70;
          }
          v37 = -1000 * v30 + v35;
          *(_DWORD *)(v32 + 80) = v37;
          v38 = v34 - (v37 + 1000 * v33);
          v39 = gSensitiveLoggingEnabled;
          v40 = mDNSLogCategory_Default;
          if (mDNSLogCategory_Default == mDNSLogCategory_State)
            v39 = 0;
          if ((v38 & 0x80000000) == 0)
          {
            if ((v39 & 1) != 0)
            {
              v40 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              {
LABEL_69:
                GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(_QWORD *)(v32 + 48) + 4), (_BYTE *)(a1 + 47032));
                *(_DWORD *)buf = 141558787;
                *(_QWORD *)&buf[4] = 1752392040;
                *(_WORD *)&buf[12] = 2085;
                *(_QWORD *)&buf[14] = a1 + 47032;
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v61) = v36;
                WORD2(v61) = 1024;
                *(_DWORD *)((char *)&v61 + 6) = v30;
                v42 = v40;
                v43 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging after adjusting the remaining TTL %d by %d seconds";
LABEL_70:
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, v43, buf, 0x22u);
              }
            }
            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
              goto LABEL_69;
            }
LABEL_71:
            mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v32);
            goto LABEL_72;
          }
          if ((v39 & 1) != 0)
          {
            v40 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              goto LABEL_75;
          }
          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
LABEL_75:
            GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(_QWORD *)(v32 + 48) + 4), (_BYTE *)(a1 + 47032));
            *(_DWORD *)buf = 141558787;
            *(_QWORD *)&buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 2085;
            *(_QWORD *)&buf[14] = a1 + 47032;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v61) = v36;
            WORD2(v61) = 1024;
            *(_DWORD *)((char *)&v61 + 6) = v30;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Adjusted the remain ttl %u by %d seconds", buf, 0x22u);
          }
        }
LABEL_72:
        v32 = *(_QWORD *)v32;
        if (!v32)
          goto LABEL_76;
      }
    }
LABEL_77:
    v29 = v59 + 1;
  }
  while (v59 != 498);
  for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
  {
    if (*(_QWORD *)(i + 32) || *(_BYTE *)(i + 122) || IsLocalDomain(*(_BYTE **)(i + 40)))
      mDNSCoreRestartRegistration((_DWORD *)a1, i, -1);
    else
      ActivateUnicastRegistration(a1, i);
  }
  v45 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      goto LABEL_95;
    }
  }
  else
  {
    v45 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
LABEL_95:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: recreating NAT mappings in 5 seconds", buf, 2u);
    }
  }
  RecreateNATMappings(a1, 5000);
  v48 = a1;
  v49 = 8418;
LABEL_125:
  mDNS_Unlock_(v48, (uint64_t)"mDNSCoreMachineSleep", v49);
}

uint64_t mDNS_DeregisterService_drt(unsigned int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  _BYTE *v24;
  uint64_t v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  _BYTE *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;

  v9 = a2 + 2408;
  if (!*(_WORD *)(*(_QWORD *)(a2 + 2456) + 8))
    return mDNS_Deregister(a1, a2 + 2408);
  if (!*(_BYTE *)(a2 + 1240))
    return 4294901755;
  if (*(_BYTE *)(a2 + 1240) == 1)
  {
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Service set for %##s already in the process of deregistering", a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 2448));
    result = 0;
    *(_BYTE *)(a2 + 16) = 0;
  }
  else
  {
    mDNS_Lock_(a1, (uint64_t)"mDNS_DeregisterService_drt", 17677);
    v13 = *(_QWORD **)(a2 + 24);
    mDNS_Deregister_internal((uint64_t)a1, v9, 3);
    mDNS_Deregister_internal((uint64_t)a1, a2 + 3584, 3);
    mDNS_Deregister_internal((uint64_t)a1, a2 + 56, a3);
    for (; v13; v13 = (_QWORD *)*v13)
      mDNS_Deregister_internal((uint64_t)a1, (uint64_t)(v13 + 2), 3);
    v14 = a2 + 1232;
    if (*(_DWORD *)(a2 + 32))
    {
      v15 = 0;
      v16 = 0;
      do
      {
        mDNS_Deregister_internal((uint64_t)a1, *(_QWORD *)(a2 + 40) + v15, a3);
        ++v16;
        v15 += 1176;
      }
      while (v16 < *(unsigned int *)(a2 + 32));
    }
    if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4 && IsLocalDomain(*(_BYTE **)(a2 + 1272)) && s_presense)
    {
      v17 = *(_BYTE **)(a2 + 1272);
      v18 = *(unsigned int *)(a2 + 1256);
      v19 = *(_QWORD *)(a2 + 1264);
      v20 = _unicast_assist_cache_log();
      v21 = objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        if (v17)
        {
          v24 = v17;
          if (v17 == (_BYTE *)-256)
            goto LABEL_26;
LABEL_23:
          v23 = 257;
          if (v24 < v17 + 256 && v24)
          {
            while (1)
            {
              v25 = *v24;
              if (v25 > 0x3F)
              {
LABEL_31:
                v23 = 257;
                goto LABEL_33;
              }
              if (!*v24)
                break;
              v24 += v25 + 1;
              if (v17 != (_BYTE *)-256)
                goto LABEL_23;
LABEL_26:
              if (!v24)
                goto LABEL_31;
            }
            v23 = (unsigned __int16)((_WORD)v24 - (_WORD)v17 + 1);
          }
        }
        else
        {
          v23 = 0;
        }
LABEL_33:
        *(_DWORD *)buf = 68158466;
        v27 = v23;
        v28 = 2098;
        v29 = v17;
        v30 = 1024;
        v31 = v18;
        v32 = 1024;
        v33 = v19;
        _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "unicast assist auth_rmv %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d", buf, 0x1Eu);
      }

      objc_msgSend((id)s_presense, "removeQhash:forInterface:", v18, v19);
    }
    v22 = mDNS_Deregister_internal((uint64_t)a1, v14, a3);
    mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_DeregisterService_drt", 17705);
    return v22;
  }
  return result;
}

void mDNSCoreBeSleepProxyServer_internal(uint64_t a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6)
{
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  int *v21;
  int v22;

  v12 = (unsigned __int8 *)(a1 + 15104);
  v13 = *(_DWORD *)(a1 + 48);
  v14 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v14;
  mDNS_VerifyLockState("Drop Lock", 0, v13, v14, (uint64_t)"mDNSCoreBeSleepProxyServer_internal", 18285);
  if (!a2)
  {
    v20 = *(void **)(a1 + 15120);
    if (v20)
    {
      CloseSocketSet(*(_QWORD *)(a1 + 15120));
      free(v20);
      *(_QWORD *)(a1 + 15120) = 0;
    }
  }
  if (v12[5] == 1 && *v12 != a2)
  {
    v12[5] = 2;
    mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15128, a2 != 0, v15, v16, v17, v18, v19);
  }
  *v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  v12[4] = a6;
  if (a2)
  {
    if (*(_QWORD *)(a1 + 15120) || (v21 = mDNSPlatformUDPSocket(0), (*(_QWORD *)(a1 + 15120) = v21) != 0))
    {
      if (!v12[5])
        SleepProxyServerCallback(a1, a1 + 15128, -65792, v15, v16, v17, v18, v19);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreBeSleepProxyServer: Failed to allocate SPSSocket", v15, v16, v17, v18, v19, v22);
    }
  }
  else if (v12[5])
  {
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreBeSleepProxyServer turning off from state %d; will wake clients",
        v15,
        v16,
        v17,
        v18,
        v19,
        v12[5]);
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 64);
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNSCoreBeSleepProxyServer_internal", 18321);
  --*(_DWORD *)(a1 + 52);
}

void SleepProxyServerCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _OWORD v11[4];

  if (a3 == -65792)
  {
    if (*(_BYTE *)(a1 + 141))
    {
      *(_BYTE *)(a1 + 15109) = 3;
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 15120);
      *(_BYTE *)(a1 + 15109) = v10 != 0;
      if (v10)
      {
        memset(v11, 0, sizeof(v11));
        LOBYTE(v11[0]) = mDNS_snprintf((char *)v11 + 1);
        mDNS_RegisterService((unsigned int *)a1, a2, (const char *)v11, "\f_sleep-proxy\x04_udp", "\x05local", 0, **(_WORD **)(a1 + 15120), 0, (unsigned __int16 *)"", 1u, 0, 0, 0, (uint64_t)SleepProxyServerCallback, 0, 0);
      }
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleep Proxy Server %#s %s", a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 2448));
    }
  }
  else if (a3 == -65548)
  {
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0);
  }
}

size_t mDNS_RenameAndReregisterService(unsigned int *a1, uint64_t a2, const char *a3)
{
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t result;
  uint64_t v17;
  BOOL v18;
  _OWORD v19[16];
  _OWORD v20[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  if (*(_BYTE *)(a2 + 2528))
    v6 = 0;
  else
    v6 = (_BYTE *)(*(_QWORD *)(a2 + 2456) + 10);
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  v7 = *(_QWORD *)(a2 + 24);
  DeconstructServiceName(*(char **)(a2 + 2448), &v25, (uint64_t)v20, v19);
  if (!a3)
  {
    v21 = v25;
    v22 = v26;
    v23 = v27;
    v24 = v28;
    a3 = (const char *)&v21;
    IncrementLabelSuffix((unsigned __int8 *)&v21, 1);
  }
  SameDomainNameBytes(v19, "\x05local");
  if (*(_QWORD *)(a2 + 3888))
    CompleteRDataUpdate((uint64_t)a1, a2 + 3584, v8, v9, v10, v11, v12, v13);
  v14 = *(_QWORD *)(a2 + 3632);
  if (v14 == a2 + 4492)
    v15 = 0;
  else
    v15 = *(_QWORD *)(a2 + 3632);
  result = mDNS_RegisterService(a1, a2, a3, (unsigned __int8 *)v20, v19, v6, *(_WORD *)(*(_QWORD *)(a2 + 2456) + 8), v15, (unsigned __int16 *)(v14 + 4), *(_WORD *)(a2 + 3604), *(_QWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_QWORD *)(a2 + 1264), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(_DWORD *)(a2 + 48));
  if (!(_DWORD)result && v7)
  {
    do
    {
      v17 = *(_QWORD *)v7;
      result = mDNS_AddRecordToService((uint64_t)a1, a2, v7, *(_QWORD *)(v7 + 64), *(_DWORD *)(v7 + 32), 0);
      if ((_DWORD)result)
        v18 = 1;
      else
        v18 = v17 == 0;
      v7 = v17;
    }
    while (!v18);
  }
  return result;
}

uint64_t NSSCallback(uint64_t a1, uint64_t a2)
{
  uint64_t (**v2)(void);
  uint64_t result;

  v2 = *(uint64_t (***)(void))(a2 + 112);
  if (*v2)
    return (*v2)();
  return result;
}

size_t mDNS_AddRecordToService(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  uint64_t v9;
  _BOOL4 v10;
  BOOL v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  int v17;
  int v18;
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  unsigned __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t **v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  size_t v41;

  v9 = *(_QWORD *)(a2 + 1264);
  v10 = (a6 & 0x100000) == 0;
  v11 = (a6 & 0x20000) != 0 && v9 == 0;
  v12 = !v11;
  if (!v11)
    v10 = 1;
  if (v10)
    v13 = 1;
  else
    v13 = 3;
  if (v9)
    v14 = 1;
  else
    v14 = (a6 & 0x100000) == 0;
  if (v14)
    v15 = 0;
  else
    v15 = 2;
  if (v12 == 1)
    v13 = v15;
  if (v9 == -5 || v9 == -3)
    v17 = 5;
  else
    v17 = v13;
  if (v9 == -2)
    v18 = 4;
  else
    v18 = v17;
  *(_QWORD *)a3 = 0;
  mDNS_SetupResourceRecord(a3 + 16, a4, v9, *(_WORD *)(a3 + 28), a5, 2, v18, (uint64_t)ServiceCallback, a2);
  v19 = a2 + 2416;
  v20 = *(_BYTE **)(a2 + 2448);
  v21 = v20;
  if (v20 == (_BYTE *)-256)
  {
LABEL_31:
    while (v21)
    {
      v22 = *v21;
      if (v22 > 0x3F)
        break;
      if (!*v21)
      {
        v23 = (_WORD)v21 - (_WORD)v20 + 1;
        if (v23 > 0x100u)
          break;
        memcpy((void *)(a3 + 668), v20, v23);
        goto LABEL_39;
      }
      v21 += v22 + 1;
      if (v20 != (_BYTE *)-256)
        goto LABEL_30;
    }
  }
  else
  {
LABEL_30:
    if (v21 < v20 + 256)
      goto LABEL_31;
  }
  *(_BYTE *)(a3 + 668) = 0;
LABEL_39:
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddRecordToService", 17524);
  v30 = *(unsigned __int16 *)(a3 + 28);
  if (v30 == 33)
  {
    if ((*(_BYTE *)v19 & 0x32) != 0)
      goto LABEL_50;
  }
  else if (v30 == 16 && (*(_BYTE *)(a2 + 3592) & 0x32) != 0)
  {
    v19 = a2 + 3592;
    goto LABEL_50;
  }
  v31 = *(uint64_t ***)(a2 + 24);
  if (!v31)
    goto LABEL_52;
  while (*((unsigned __int16 *)v31 + 14) != v30 || ((_BYTE)v31[3] & 0x32) == 0)
  {
    v31 = (uint64_t **)*v31;
    if (!v31)
      goto LABEL_52;
  }
  v19 = (uint64_t)(v31 + 3);
LABEL_50:
  v32 = *(_DWORD *)(a3 + 32);
  if (v32 != *(_DWORD *)(v19 + 8))
  {
    v33 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 24), (unsigned __int16 *)(*(_QWORD *)(a3 + 64) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "mDNS_AddRecordToService: Correcting TTL from %4d to %4d for %s", v34, v35, v36, v37, v38, v32);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(v19 + 8);
  }
LABEL_52:
  v39 = (_QWORD *)(a2 + 24);
  do
  {
    v40 = v39;
    v39 = (_QWORD *)*v39;
  }
  while (v39);
  *(_QWORD *)(a3 + 104) = a2 + 2408;
  v41 = mDNS_Register_internal(a1, a3 + 16, v24, v25, v26, v27, v28, v29);
  if (!(_DWORD)v41)
    *v40 = a3;
  mDNS_Unlock_(a1, (uint64_t)"mDNS_AddRecordToService", 17567);
  return v41;
}

uint64_t CheckTSRForResourceRecord(int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  NSObject *v8;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  const char *v15;
  int v16;
  timespec v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;

  v2 = 0;
  if (!a1 || !a2)
    return v2;
  v4 = *(_QWORD *)(a2 + 40);
  if (*(_DWORD *)(v4 + 12) != a1[1])
    return 0;
  v5 = 604800;
  v6 = *(_DWORD *)(v4 + 8);
  v7 = *a1;
  if (*a1 <= 0x93A80)
  {
    v5 = *a1;
    goto LABEL_17;
  }
  v8 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
    goto LABEL_16;
  }
  v8 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CheckTSR - Out of range pktTimeSinceReceived %d in Pkt record", (uint8_t *)&v18, 8u);
  }
LABEL_17:
  v18.tv_sec = 0;
  v18.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v18);
  v11 = LODWORD(v18.tv_sec) - v5;
  v12 = v6 - (LODWORD(v18.tv_sec) - v5);
  if (v12 < 0)
    v12 = LODWORD(v18.tv_sec) - v5 - v6;
  if (v12 < 3)
    return 1;
  if (v6 < v11)
    v2 = 0xFFFFFFFFLL;
  else
    v2 = 2;
  v13 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      v14 = a1[1];
      v15 = "win";
      v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11)
        v15 = "lose";
      goto LABEL_33;
    }
  }
  else
  {
    v13 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v14 = a1[1];
      v15 = "win";
      v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11)
        v15 = "lose";
LABEL_33:
      LODWORD(v18.tv_sec) = 67110146;
      HIDWORD(v18.tv_sec) = v11;
      LOWORD(v18.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v18.tv_nsec + 2) = v14;
      HIWORD(v18.tv_nsec) = 2082;
      v19 = v15;
      v20 = 1024;
      v21 = v6;
      v22 = 1024;
      v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "CheckTSR - pktTimeOfReceipt: %d %x %{public}s ourTimeOfReceipt: %d %x", (uint8_t *)&v18, 0x24u);
    }
  }
  return v2;
}

uint64_t CreateNewCacheEntryEx(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  int v9;
  uint64_t *v10;
  uint64_t v13;
  int v14;
  unsigned int v15;
  char v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  _WORD *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  void *v39;
  uint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  unsigned __int16 v43;
  uint64_t v44;
  BOOL v45;
  _DWORD *v46;
  uint64_t CacheEntity;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t **v69;
  _BYTE *v70;
  _BYTE *v71;
  uint64_t v72;
  __int128 v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t i;
  int v80;
  unsigned int v81;
  int v82;
  NSObject *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint32_t v98;
  uint64_t v99;
  NSObject *v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  _BYTE *v110;
  _BYTE *v111;
  unsigned int v112;
  uint64_t v113;
  uint64_t v114;
  unsigned __int16 v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _BYTE *v121;
  _BYTE *v122;
  _BYTE *v123;
  _BYTE *v124;
  uint64_t v125;
  unsigned __int16 v126;
  int v128;
  int v129;
  int v130;
  _BOOL4 v131;
  int v132;
  int v133;
  uint64_t v134;

  v8 = a7;
  v9 = a5;
  v10 = (uint64_t *)a3;
  v13 = a1 + 37924;
  v14 = *(unsigned __int16 *)(a1 + 37924);
  switch(v14)
  {
    case 6:
      v15 = 532;
      break;
    case 26:
      v15 = 514;
      break;
    case 17:
      v15 = 512;
      break;
    default:
      v15 = *(unsigned __int16 *)(a1 + 37932);
      break;
  }
  v16 = a7;
  if ((a7 & 0xC) != 0)
  {
    v17 = (a7 & 8) >> 2;
    if ((a7 & 4) != 0)
      v17 = 1;
    if ((a7 & 2) != 0)
      return 0;
    v131 = (a7 & 4) == 0;
    v132 = a7 & 0xC;
    v129 = v17;
    v133 = a4;
    v134 = a6;
    v18 = ((a7 & 8) == 0) | ((a7 & 4) >> 2);
  }
  else
  {
    v132 = 0;
    v133 = a4;
    v134 = a6;
    v129 = 0;
    v18 = 1;
    v131 = 1;
  }
  v130 = v18;
  if (!a3)
  {
    v41 = *(_BYTE **)(a1 + 37952);
    v42 = v41;
    if (v41 == (_BYTE *)-256)
      goto LABEL_29;
LABEL_26:
    v43 = 257;
    if (v42 < v41 + 256 && v42)
    {
      while (1)
      {
        v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_35:
          v43 = 257;
          goto LABEL_37;
        }
        if (!*v42)
          break;
        v42 += v44 + 1;
        if (v41 != (_BYTE *)-256)
          goto LABEL_26;
LABEL_29:
        if (!v42)
          goto LABEL_35;
      }
      v43 = (_WORD)v42 - (_WORD)v41 + 1;
    }
LABEL_37:
    CacheEntity = GetCacheEntity(a1, 0, 0, a4, a5, a6, a7, a8);
    if (!CacheEntity)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Failed to allocate memory for %##s", v48, v49, v50, v51, v52, *(_QWORD *)(v13 + 28));
      goto LABEL_42;
    }
    v10 = (uint64_t *)CacheEntity;
    v25 = a1 + 8 * a2;
    *(_QWORD *)CacheEntity = *(_QWORD *)(v25 + 272);
    *(_DWORD *)(CacheEntity + 8) = *(_DWORD *)(v13 + 12);
    *(_QWORD *)(CacheEntity + 16) = 0;
    *(_QWORD *)(CacheEntity + 24) = CacheEntity + 16;
    if (v43 <= 0xB8u)
    {
      v53 = (_BYTE *)(CacheEntity + 40);
    }
    else
    {
      v53 = malloc_type_malloc(v43, 0xA172743EuLL);
      if (!v53)
        goto LABEL_150;
    }
    v69 = (uint64_t **)(v25 + 272);
    v10[4] = (uint64_t)v53;
    v70 = *(_BYTE **)(v13 + 28);
    v71 = v70;
    if (v70 == (_BYTE *)-256)
    {
LABEL_54:
      while (v71)
      {
        v72 = *v71;
        if (v72 > 0x3F)
          break;
        if (!*v71)
        {
          v115 = (_WORD)v71 - (_WORD)v70 + 1;
          if (v115 > 0x100u)
            break;
          memcpy(v53, v70, v115);
          goto LABEL_132;
        }
        v71 += v72 + 1;
        if (v70 != (_BYTE *)-256)
          goto LABEL_53;
      }
    }
    else
    {
LABEL_53:
      if (v71 < v70 + 256)
        goto LABEL_54;
    }
    *v53 = 0;
LABEL_132:
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(_BYTE **)(v13 + 28)))
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Already have CacheGroup for %##s", v116, v117, v118, v119, v120, *(_QWORD *)(v13 + 28));
    *v69 = v10;
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(_BYTE **)(v13 + 28)) != v10)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Not finding CacheGroup for %##s", a4, a5, a6, a7, a8, *(_QWORD *)(v13 + 28));
  }
  v19 = GetCacheEntity(a1, v10, a3, a4, a5, a6, a7, a8);
  if (!v19)
  {
LABEL_42:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "No cache space: Delivering non-cached result for %##s", v20, v21, v22, v23, v24, *(_QWORD *)(v13 + 28));
    v59 = *(_QWORD *)(a1 + 208);
    if (v59)
    {
      v60 = mDNSLogCategory_Default;
      v61 = v59 + 376;
      DNSTypeName(*(unsigned __int16 *)(v59 + 342));
      LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "NoCacheAnswer ERROR m->CurrentQuestion already set: %##s (%s)", v62, v63, v64, v65, v66, v61);
    }
    v67 = *(_QWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 208) = v67;
    if (v67)
    {
      do
      {
        if (RecordAnswersQuestion(a1 + 37920, 0, v67, v54, v55, v56, v57, v58))
          AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37912, 2);
        v68 = *(_QWORD *)(a1 + 208);
        if (v68 == v67)
        {
          v68 = *(_QWORD *)(v67 + 8);
          *(_QWORD *)(a1 + 208) = v68;
        }
        v67 = v68;
      }
      while (v68);
    }
    v25 = 0;
    *(_QWORD *)(a1 + 208) = 0;
    return v25;
  }
  v25 = v19;
  v128 = v9;
  v26 = (void *)(v19 + 152);
  *(_QWORD *)(v19 + 48) = v19 + 152;
  v27 = (void *)(v19 + 152);
  if (v15 < 0x45)
    goto LABEL_19;
  v28 = malloc_type_calloc(1uLL, v15 + 4, 0xF1748037uLL);
  if (!v28)
  {
LABEL_150:
    __break(1u);
    goto LABEL_151;
  }
  v27 = v28;
  *(_QWORD *)(v25 + 48) = v28;
  *(_WORD *)(v25 + 20) = v15;
  *v28 = v15;
LABEL_19:
  v29 = *(_OWORD *)(a1 + 37928);
  *(_OWORD *)v25 = *(_OWORD *)(a1 + 37912);
  *(_OWORD *)(v25 + 16) = v29;
  v30 = *(_OWORD *)(a1 + 37944);
  v31 = *(_OWORD *)(a1 + 37960);
  v32 = *(_OWORD *)(a1 + 37992);
  *(_OWORD *)(v25 + 64) = *(_OWORD *)(a1 + 37976);
  *(_OWORD *)(v25 + 80) = v32;
  *(_OWORD *)(v25 + 32) = v30;
  *(_OWORD *)(v25 + 48) = v31;
  v33 = *(_OWORD *)(a1 + 38008);
  v34 = *(_OWORD *)(a1 + 38024);
  v35 = *(_OWORD *)(a1 + 38056);
  *(_OWORD *)(v25 + 128) = *(_OWORD *)(a1 + 38040);
  *(_OWORD *)(v25 + 144) = v35;
  *(_OWORD *)(v25 + 96) = v33;
  *(_OWORD *)(v25 + 112) = v34;
  v36 = *(_OWORD *)(a1 + 38072);
  v37 = *(_OWORD *)(a1 + 38088);
  v38 = *(_OWORD *)(a1 + 38120);
  *(_OWORD *)(v25 + 192) = *(_OWORD *)(a1 + 38104);
  *(_OWORD *)(v25 + 208) = v38;
  *(_OWORD *)(v25 + 160) = v36;
  *(_OWORD *)(v25 + 176) = v37;
  v39 = *(void **)(v25 + 56);
  if (v39)
    os_retain(v39);
  *(_QWORD *)(v25 + 40) = v10[4];
  *(_QWORD *)(v25 + 48) = v27;
  *(_BYTE *)(v25 + 10) = 0;
  if ((v16 & 2) != 0)
  {
    v45 = *(unsigned __int8 *)(v25 + 8) != 240;
    v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 0;
    *((_QWORD *)v46 + 2) = v25;
    *((_BYTE *)v46 + 40) = v45;
LABEL_61:
    ++*v46;
    ref_count_obj_release(v46);
    *(_QWORD *)(v25 + 64) = v46;
    v27 = *(void **)(v25 + 48);
    v40 = v134;
    goto LABEL_62;
  }
  v40 = v134;
  if (v132)
  {
    if ((v131 & v130 & 1) != 0)
      return 0;
    if (!v129)
    {
LABEL_151:
      *(_QWORD *)(v25 + 64) = 0;
      return 0;
    }
    v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 1;
    *((_QWORD *)v46 + 2) = v25;
    v46[10] = v129;
    *((_BYTE *)v46 + 44) = (v16 & 0x10) != 0;
    goto LABEL_61;
  }
LABEL_62:
  *(_DWORD *)(v25 + 84) = v133;
  if (v27 == v26 && v15 >= 0x45)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "rr->resrec.rdata == &rr->rdatastorage but length > InlineCacheRDSize %##s", v20, v21, v22, v23, v24, *(_QWORD *)(v13 + 28));
    v27 = *(void **)(v25 + 48);
LABEL_69:
    memcpy(v27, *(const void **)(v13 + 36), v15 + 4);
    goto LABEL_70;
  }
  if (v27 != v26 && v15 <= 0x44)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "rr->resrec.rdata != &rr->rdatastorage but length <= InlineCacheRDSize %##s", v20, v21, v22, v23, v24, *(_QWORD *)(v13 + 28));
    goto LABEL_70;
  }
  if (v15 >= 0x45)
    goto LABEL_69;
LABEL_70:
  *(_QWORD *)v25 = 0;
  *(_QWORD *)(v25 + 120) = 0;
  if (v40)
  {
    v73 = *(_OWORD *)v40;
    *(_DWORD *)(v25 + 148) = *(_DWORD *)(v40 + 16);
    *(_OWORD *)(v25 + 132) = v73;
  }
  if (!*(_QWORD *)(v25 + 32))
    *(_DWORD *)(a1 + 248) += *(unsigned __int16 *)(v25 + 20);
  if ((v8 & 1) != 0)
    *(_BYTE *)(v25 + 109) = 1;
  *(_BYTE *)(v25 + 129) = 0;
  if (!v128)
  {
    v110 = (_BYTE *)v10[4];
    v111 = v110;
    if (v110 == (_BYTE *)-256)
      goto LABEL_119;
LABEL_116:
    v112 = 257;
    if (v111 >= v110 + 256 || !v111)
      goto LABEL_137;
    while (1)
    {
      v113 = *v111;
      if (v113 > 0x3F)
      {
LABEL_128:
        v112 = 257;
        goto LABEL_137;
      }
      if (!*v111)
        break;
      v111 += v113 + 1;
      if (v110 != (_BYTE *)-256)
        goto LABEL_116;
LABEL_119:
      if (!v111)
        goto LABEL_128;
    }
    v112 = (unsigned __int16)((_WORD)v111 - (_WORD)v110 + 1);
    if ((_WORD)v111 - (_WORD)v110 != 0xFFFF)
    {
LABEL_137:
      v121 = malloc_type_malloc(v112, 0xA172743EuLL);
      if (v121)
      {
        v122 = v121;
        v123 = (_BYTE *)v10[4];
        v124 = v123;
        if (v123 == (_BYTE *)-256)
        {
LABEL_140:
          while (v124)
          {
            v125 = *v124;
            if (v125 > 0x3F)
              break;
            if (!*v124)
            {
              v126 = (_WORD)v124 - (_WORD)v123 + 1;
              if (v126 > 0x100u)
                break;
              memcpy(v121, v123, v126);
              goto LABEL_148;
            }
            v124 += v125 + 1;
            if (v123 != (_BYTE *)-256)
              goto LABEL_139;
          }
        }
        else
        {
LABEL_139:
          if (v124 < v123 + 256)
            goto LABEL_140;
        }
        *v121 = 0;
LABEL_148:
        *(_QWORD *)(v25 + 40) = v122;
        return v25;
      }
    }
    goto LABEL_150;
  }
  AddCacheRecordToCacheGroup((uint64_t)v10, (_QWORD *)v25);
  for (i = *(_QWORD *)(a1 + 192); i; i = *(_QWORD *)(i + 8))
  {
    if (i == *(_QWORD *)(a1 + 200))
      break;
    if (RecordAnswersQuestion(v25 + 8, 0, i, v74, v75, v76, v77, v78))
    {
      v80 = *(_DWORD *)(a1 + 132);
      if (*(_DWORD *)(i + 220) != v80)
      {
        *(_DWORD *)(i + 220) = v80;
        if (!*(_WORD *)(i + 340))
        {
          v89 = *(_DWORD *)(i + 212);
          if (v89 >= 1 && !*(_QWORD *)(i + 40))
          {
            v90 = *(_DWORD *)(i + 224) + 1;
            *(_DWORD *)(i + 224) = v90;
            if (v90 >= 0xA && v89 >= 9019 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(i + 256) <= 999)
            {
              v91 = mDNSLogCategory_Default;
              DNSTypeName(*(unsigned __int16 *)(i + 342));
              LogMsgWithLevel(v91, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd: %##s (%s) got immediate answer burst (%d); restarting exponential backoff sequence (%d)",
                v92,
                v93,
                v94,
                v95,
                v96,
                i + 376);
              v97 = *(_DWORD *)(a1 + 64);
              do
                v98 = arc4random() & 0xFFF;
              while (v98 > 0xFA0);
              *(_DWORD *)(i + 208) = v98 + v97 - 334;
              *(_DWORD *)(i + 212) = 334;
              SetNextQueryTime(a1, i);
            }
          }
        }
      }
      v81 = *(_DWORD *)(i + 228) + 1;
      *(_DWORD *)(i + 228) = v81;
      if (*(unsigned __int16 *)(v25 + 20) >= 0x401u)
        ++*(_DWORD *)(i + 232);
      if ((*(_BYTE *)(v25 + 8) & 0x10) != 0)
        ++*(_DWORD *)(i + 236);
      if (v81 >= 0xFA1)
      {
        v82 = CacheRecordAdd_msgcount++;
        if (v82 <= 9)
        {
          v83 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(i + 342));
          LogMsgWithLevel(v83, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd: %##s (%s) has %d answers; shedding records to resist DOS attack",
            v84,
            v85,
            v86,
            v87,
            v88,
            i + 376);
        }
        *(_DWORD *)(v25 + 16) = 0;
        *(_BYTE *)(v25 + 108) = 4;
      }
    }
  }
  if (!*(_DWORD *)(v25 + 84))
  {
    v99 = *(_QWORD *)(a1 + 208);
    if (v99)
    {
      v100 = mDNSLogCategory_Default;
      v101 = v99 + 376;
      DNSTypeName(*(unsigned __int16 *)(v99 + 342));
      LogMsgWithLevel(v100, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd ERROR m->CurrentQuestion already set: %##s (%s)", v102, v103, v104, v105, v106, v101);
    }
    v107 = *(_QWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 208) = v107;
    if (v107)
    {
      do
      {
        if (v107 == *(_QWORD *)(a1 + 200))
          break;
        if (RecordAnswersQuestion(v25 + 8, 0, v107, v74, v75, v76, v77, v78))
          AnswerCurrentQuestionWithResourceRecord(a1, v25, 1);
        v108 = *(_QWORD *)(a1 + 208);
        if (v108 == v107)
        {
          v108 = *(_QWORD *)(v107 + 8);
          *(_QWORD *)(a1 + 208) = v108;
        }
        v107 = v108;
      }
      while (v108);
    }
    *(_QWORD *)(a1 + 208) = 0;
  }
  SetNextCacheCheckTimeForRecord(a1, v25);
  v109 = *(_DWORD *)(v25 + 132);
  if (v109 == 6)
  {
    if (!*(_QWORD *)&vorr_s8(*(int8x8_t *)(v25 + 136), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v25 + 136), *(int8x16_t *)(v25 + 136), 8uLL)))return v25;
  }
  else if (v109 != 4 || !*(_DWORD *)(v25 + 136))
  {
    return v25;
  }
  if (!mDNSAddrIsDNSMulticast((_DWORD *)(v25 + 132)))
  {
    v114 = *(_QWORD *)(v25 + 32);
    if (mDNS_AddressIsLocalSubnet(a1, v114, (_DWORD *)(v25 + 132)))
      unicast_assist_addr_add(*(_BYTE **)(v25 + 40), *(_DWORD *)(v25 + 24), *(unsigned __int16 *)(v25 + 12), *(unsigned __int8 *)(v25 + 8), (int *)(v25 + 132), v114);
  }
  return v25;
}

_QWORD *AddCacheRecordToCacheGroup(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  v2 = a2[8];
  if (!v2 || *(_DWORD *)(v2 + 32))
  {
    v4 = *(_QWORD **)(a1 + 24);
    result = (_QWORD *)(a1 + 24);
    *v4 = a2;
LABEL_4:
    *result = a2;
    return result;
  }
  v5 = (_QWORD *)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 16);
  if (v6)
  {
    while (1)
    {
      v7 = v5;
      v5 = v6;
      if (*((_WORD *)v6 + 6) == 5)
      {
        v8 = v6[8];
        if (v8)
        {
          if (!*(_DWORD *)(v8 + 32))
            break;
        }
      }
      v6 = (_QWORD *)*v5;
      if (!*v5)
        goto LABEL_13;
    }
    v6 = v5;
    v5 = v7;
  }
LABEL_13:
  *a2 = v6;
  *v5 = a2;
  v9 = *(_QWORD **)(a1 + 24);
  result = (_QWORD *)(a1 + 24);
  if (v5 == v9)
    goto LABEL_4;
  return result;
}

uint64_t RefreshCacheRecord(uint64_t a1, int8x8_t *a2, __int32 a3)
{
  int8x8_t v6;
  __int32 v7;
  __int32 v8;
  int8x8_t v9;
  _BOOL4 v10;
  _BOOL4 IsDNSMulticast;
  _BOOL4 v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t *v16;
  uint64_t *v17;
  int v18;
  NSObject *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  uint64_t v28;
  _BYTE *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int8x8_t v35;
  int v38;
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  uint64_t v53;

  v6 = a2[12];
  if (!*(_QWORD *)&v6 || *(_WORD *)(*(_QWORD *)&v6 + 340))
    goto LABEL_66;
  v7 = a2[16].i32[1];
  if (v7 == 6)
  {
    v9 = vorr_s8(a2[17], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2[17].i8, *(int8x16_t *)a2[17].i8, 8uLL));
    v8 = v9.i32[0] | v9.i32[1];
  }
  else
  {
    if (v7 != 4)
    {
      v10 = 0;
      goto LABEL_9;
    }
    v8 = a2[17].i32[0];
  }
  v10 = v8 != 0;
LABEL_9:
  IsDNSMulticast = mDNSAddrIsDNSMulticast((_DWORD *)&a2[16] + 1);
  v12 = IsDNSMulticast;
  if (a2[13].i32[0] && v10)
  {
    v13 = a2[16].u8[2];
    v14 = a2[13].u8[4] | IsDNSMulticast;
    v15 = v14 == 0;
    if (v14)
      v16 = &sUnicastAssist_MulticastCount;
    else
      v16 = &sUnicastAssist_UnicastCount;
    v17 = &sNonUnicastAssist_MulticastCount;
    v18 = v15;
    if (v15)
      v17 = &sNonUnicastAssist_UnicastCount;
    if (!a2[16].i8[2])
      v16 = v17;
    ++*v16;
    v19 = mDNSLogCategory_Analytics;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Analytics == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics, OS_LOG_TYPE_DEBUG))
      {
        v25 = "*";
        if (v18)
          v21 = "*";
        else
          v21 = "";
        v38 = 136316930;
        if (v18)
          v25 = "";
        if (v13)
          v26 = v21;
        else
          v26 = "";
        v39 = v26;
        v40 = 2048;
        if (v13)
          v23 = v25;
        else
          v23 = "";
        if (v13)
          v21 = "";
        v41 = sUnicastAssist_UnicastCount;
        if (v13)
          v24 = "";
        else
          v24 = v25;
        goto LABEL_57;
      }
    }
    else
    {
      v19 = mDNSLogCategory_Analytics_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics_redacted, OS_LOG_TYPE_DEBUG))
      {
        v20 = "*";
        if (v18)
          v21 = "*";
        else
          v21 = "";
        v38 = 136316930;
        if (v18)
          v20 = "";
        if (v13)
          v22 = v21;
        else
          v22 = "";
        v39 = v22;
        v40 = 2048;
        if (v13)
          v23 = v20;
        else
          v23 = "";
        if (v13)
          v21 = "";
        v41 = sUnicastAssist_UnicastCount;
        if (v13)
          v24 = "";
        else
          v24 = v20;
LABEL_57:
        v42 = 2080;
        v43 = v23;
        v44 = 2048;
        v45 = sUnicastAssist_MulticastCount;
        v46 = 2080;
        v47 = v21;
        v48 = 2048;
        v49 = sNonUnicastAssist_UnicastCount;
        v50 = 2080;
        v51 = v24;
        v52 = 2048;
        v53 = sNonUnicastAssist_MulticastCount;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "dnssd_analytics_update_unicast_assist Assist(unicast %s%lld, multicast %s%lld) NonAssist(unicast %s%lld, multicast %s%lld)", (uint8_t *)&v38, 0x52u);
      }
    }
  }
  if (!v12 && v10)
  {
    v28 = (uint64_t)a2[4];
    if (mDNS_AddressIsLocalSubnet(a1, v28, (_DWORD *)&a2[16] + 1))
    {
      v29 = (_BYTE *)a2[5];
      v30 = a2[3].i32[0];
      v31 = a2[1].u16[2];
      v32 = a2[1].u8[0];
      if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
        _unicast_assist_addr_update_ex(v29, v30, v31, v32, (int *)&a2[16] + 1, v28, 1);
    }
  }
  a2[16].i8[2] = 0;
LABEL_66:
  a2[10].i32[0] = *(_DWORD *)(a1 + 64);
  a2[2].i32[0] = a3;
  a2[13].i8[4] = 0;
  if (a2[1].i8[2])
    a2[1].i8[2] = 1;
  v33 = *(_QWORD *)(a1 + 37968);
  if (v33)
  {
    v34 = *(_QWORD *)(v33 + 24);
    if (v34)
    {
      v35 = a2[7];
      if (v35)
      {
        if (*(_BYTE *)(v34 + 281) == 5 && v34 == *(_QWORD *)(*(_QWORD *)&v35 + 24))
        {
          *(_QWORD *)(*(_QWORD *)&v35 + 40) = *(_QWORD *)(v33 + 40);
          a2[13].i8[5] = 1;
        }
      }
    }
  }
  return SetNextCacheCheckTimeForRecord(a1, (uint64_t)a2);
}

void mDNSCoreReceiveForQuerier(unint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  char *v8;

  v8 = (char *)mDNSStorage + &loc_100004E28;
  *((_WORD *)v8 + 2) = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &loc_100004E28 + 4)) >> 16;
  *((_WORD *)v8 + 3) = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &loc_100004E28 + 6)) >> 16;
  *((_WORD *)v8 + 4) = bswap32(*(unsigned __int16 *)((char *)&dword_100158DD0 + &loc_100004E28)) >> 16;
  *((_WORD *)v8 + 5) = bswap32(*(unsigned __int16 *)((char *)&dword_100158DD0 + &loc_100004E28 + 2)) >> 16;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13702);
  mDNSCoreReceiveResponse((uint64_t)mDNSStorage, (unsigned __int8 *)v8, a1, 0, 0, 0, 0, a2, a3, a4);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13704);
}

void mDNSCoreReceiveResponse(uint64_t a1, unsigned __int8 *a2, unint64_t a3, __int128 *a4, unsigned int a5, __int128 *a6, unsigned __int16 a7, uint64_t a8, _QWORD *a9, uint64_t a10)
{
  void *v16;
  _BOOL4 v17;
  uint64_t *v18;
  int v19;
  int v20;
  _UNKNOWN **v21;
  uint64_t v22;
  unsigned __int8 *v23;
  unsigned __int8 *OptRR;
  _BYTE *v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 v28;
  char *v29;
  unsigned __int16 *v30;
  unsigned int v31;
  unsigned __int8 *v32;
  char *v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  int v37;
  int v38;
  NSObject *v39;
  const char *v40;
  uint64_t v41;
  BOOL v42;
  _BOOL4 v43;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  unsigned __int16 *v49;
  NSObject *v50;
  _QWORD *v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned __int8 *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  NSObject *v68;
  _BYTE *i;
  unsigned __int16 v71;
  uint64_t v72;
  _BYTE *j;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  BOOL v80;
  NSObject *v81;
  unsigned int v83;
  int v84;
  const char *v85;
  int v86;
  int v87;
  const char *v88;
  const char *v89;
  char v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v93;
  _QWORD *v94;
  int v95;
  const char *v96;
  int v97;
  unsigned __int8 *v98;
  int v99;
  char v100;
  unsigned __int8 *LargeResourceRecord;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  void *v111;
  _QWORD *v112;
  unsigned int v113;
  _DWORD *v114;
  int v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  NSObject *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unsigned int v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _BOOL8 v141;
  int v142;
  int v143;
  __int16 *v144;
  int v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  NSObject *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  _BYTE *v161;
  char **v162;
  unsigned int v163;
  NSObject *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  _BYTE *v173;
  unsigned __int16 v174;
  uint64_t v175;
  NSObject *v176;
  int v177;
  int v178;
  NSObject *v179;
  int v180;
  uint64_t v181;
  NSObject *v182;
  unsigned __int8 *v184;
  _BYTE *v185;
  unsigned __int16 v186;
  uint64_t v187;
  _BOOL4 v188;
  int v189;
  unsigned int v190;
  uint64_t v191;
  NSObject *v192;
  const char *v193;
  char v194;
  NSObject *v195;
  int v196;
  NSObject *v197;
  uint64_t *v198;
  unsigned __int8 *v199;
  int v200;
  NSObject *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  NSObject *v209;
  int v210;
  const char *v211;
  NSObject *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  int v218;
  uint64_t *v219;
  int v220;
  NSObject *v222;
  char v224;
  NSObject *v225;
  _BOOL4 v227;
  int v228;
  void *v229;
  int v231;
  NSObject *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  _BYTE *v238;
  char **v239;
  uint64_t *v240;
  uint64_t *v241;
  uint64_t *v242;
  int v243;
  NSObject *v244;
  uint64_t v245;
  _BYTE *v246;
  unsigned __int16 v247;
  uint64_t v248;
  unsigned int v249;
  uint64_t *v250;
  int8x8_t *v251;
  int8x8_t *v252;
  _DWORD *v253;
  uint64_t v254;
  uint64_t v255;
  int8x8_t v256;
  int8x8_t *v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  unsigned __int8 v265;
  int8x8_t *v266;
  int v267;
  NSObject *v268;
  int v269;
  const char *v270;
  const char *v271;
  const char *v272;
  const char *v273;
  const char *v274;
  uint64_t v275;
  NSObject *v276;
  NSObject *v277;
  NSObject *v278;
  unsigned int v279;
  int v280;
  unsigned int v281;
  int v282;
  const char *v283;
  const char *v284;
  int v285;
  int v286;
  int v287;
  int v288;
  unsigned __int8 v289;
  uint64_t v290;
  uint64_t v291;
  unsigned int v292;
  _BYTE *v293;
  unsigned int v295;
  uint64_t v296;
  unsigned __int16 v297;
  int v298;
  uint64_t v299;
  char v300;
  NSObject *v301;
  const char *v302;
  uint64_t v303;
  _BYTE *v304;
  uint64_t v305;
  _QWORD *v306;
  uint64_t v307;
  int v308;
  _QWORD *v309;
  _BYTE *v310;
  uint64_t v311;
  _BYTE *v312;
  unsigned __int16 v313;
  uint64_t v314;
  unsigned __int16 v315;
  unsigned __int16 v316;
  int v317;
  int v318;
  const char *v319;
  uint64_t v320;
  NSObject *v321;
  uint64_t v324;
  unsigned int v325;
  unsigned int v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  int v332;
  uint64_t v333;
  uint64_t CacheEntity;
  int v335;
  int v336;
  unsigned int v337;
  uint64_t v338;
  NSObject *v339;
  const char *v340;
  NSObject *v341;
  BOOL v342;
  uint64_t v343;
  _BYTE *v344;
  uint64_t v345;
  _BOOL4 v346;
  uint64_t v347;
  NSObject *v348;
  uint64_t v349;
  _BYTE *v350;
  uint64_t v351;
  uint64_t v352;
  __int32 v353;
  unsigned int v354;
  int8x8_t v355;
  int v356;
  NSObject *v357;
  int v358;
  unsigned __int8 *v359;
  int v360;
  int v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  int v367;
  NSObject *v368;
  int v369;
  int8x8_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  int8x8_t *v376;
  __int16 v377;
  uint64_t v378;
  NSObject *v379;
  __int32 v382;
  int8x8_t v383;
  unsigned int v384;
  int v385;
  uint64_t v386;
  char *v387;
  NSObject *v388;
  unsigned int v391;
  int v392;
  const char *v393;
  uint64_t k;
  uint64_t v396;
  uint64_t v397;
  _QWORD *v398;
  NSObject *v399;
  uint64_t v401;
  _BYTE *v402;
  unsigned __int16 v403;
  uint64_t v404;
  _BYTE *v406;
  unsigned __int16 v407;
  uint64_t v408;
  uint64_t v409;
  _QWORD *v410;
  int v411;
  const char *v412;
  _QWORD *v413;
  uint64_t v414;
  unsigned int v415;
  uint64_t *v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  int v425;
  int v426;
  uint64_t v427;
  int v428;
  int covered_type;
  unsigned int v430;
  int v431;
  int v432;
  int v433;
  uint64_t v434;
  uint64_t v435;
  int v436;
  unsigned int v437;
  uint64_t v438;
  NSObject *v439;
  int v440;
  uint64_t v441;
  _QWORD *v442;
  uint64_t v443;
  BOOL v444;
  uint64_t v445;
  NSObject *v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  int v452;
  unsigned int v453;
  int v454;
  uint64_t v455;
  os_log_type_t v456;
  os_log_type_t v457;
  NSObject *v458;
  os_log_type_t v459;
  unsigned int v460;
  _QWORD *v461;
  char v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t *v465;
  uint64_t v466;
  int v467;
  int v468;
  unsigned int v469;
  unsigned __int8 *Question;
  int v471;
  unint64_t v472;
  uint64_t v473;
  uint64_t DNSQuestion;
  int v475;
  uint64_t v476;
  unsigned int v477;
  _BYTE *m;
  uint64_t v479;
  unsigned __int8 *v480;
  unsigned __int16 v481;
  int v482;
  unsigned __int8 *v483;
  unsigned __int8 *v484;
  int v485;
  unint64_t v486;
  BOOL v487;
  _BYTE *v488;
  uint64_t v489;
  unsigned __int16 v490;
  const void *v491;
  _BYTE *v492;
  uint64_t v493;
  unsigned __int16 v494;
  unint64_t v495;
  _BYTE *v496;
  uint64_t v497;
  _BYTE *v498;
  _BYTE *v499;
  _BYTE *v500;
  _BYTE *v501;
  uint64_t v502;
  unsigned __int16 v503;
  int8x8_t *v504;
  uint64_t *v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t *v511;
  int v512;
  uint64_t v513;
  int v514;
  _QWORD *v515;
  int v516;
  uint64_t v517;
  _BYTE *v518;
  _BYTE *v519;
  uint64_t v520;
  unsigned __int16 v521;
  uint64_t v522;
  unsigned __int16 v523;
  uint64_t v524;
  int8x8_t *v525;
  _QWORD *v526;
  int v527;
  NSObject *v528;
  int v529;
  _BOOL4 v530;
  char v531;
  _BOOL4 v532;
  int v533;
  NSObject *v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  int v539;
  unsigned int v540;
  _BYTE *kk;
  unsigned __int16 v542;
  uint64_t v543;
  unsigned int v544;
  unsigned __int8 *Authorities;
  uint64_t *v546;
  uint64_t v547;
  unsigned int v548;
  char v549;
  int v550;
  int v551;
  _BYTE *v552;
  _BYTE *v553;
  int v554;
  int v555;
  NSObject *v556;
  int v557;
  unsigned int v558;
  _BYTE *ii;
  unsigned __int16 v560;
  uint64_t v561;
  _BYTE *n;
  uint64_t v563;
  _BYTE *jj;
  uint64_t v565;
  int v566;
  const char *v567;
  int v568;
  const char *v569;
  unsigned __int8 *v570;
  unsigned int v571;
  int v572;
  uint64_t v573;
  uint64_t v574;
  unsigned int v575;
  int v576;
  unsigned __int8 *v577;
  int v578;
  _QWORD *v579;
  unsigned int v580;
  unsigned int v581;
  unsigned int v582;
  int v583;
  int v584;
  unint64_t v585;
  unsigned __int8 *v586;
  unsigned __int8 *v587;
  unsigned int v588;
  unsigned __int8 *v589;
  unsigned int v590;
  int v591;
  uint64_t v592;
  unint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  unsigned __int8 *v597;
  unsigned int v598;
  _BYTE *v599;
  int v600;
  _BYTE *v601;
  _BYTE *v602;
  int v603;
  uint64_t v604;
  uint64_t v605;
  unsigned int v606;
  unint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  unsigned int v611;
  unint64_t v612;
  uint64_t v613;
  unint64_t v614;
  unint64_t v615;
  _QWORD *v616;
  uint64_t v617;
  _UNKNOWN **v618;
  void (*v619)(uint64_t);
  int v620;
  uint64_t v621;
  unint64_t v622;
  unint64_t encoded_string_length;
  _BYTE *parent;
  unsigned __int8 *v625;
  int v626;
  unsigned __int8 *v627;
  unsigned int v628;
  const void *v629;
  unsigned int v630;
  uint64_t v631;
  unint64_t v632;
  unsigned int v633;
  uint64_t v634;
  unsigned int v635;
  uint64_t v636;
  unint64_t v637;
  uint64_t v638;
  uint64_t v639;
  unsigned int v640;
  _QWORD *v641;
  uint64_t v642;
  _UNKNOWN **v643;
  void (*v644)(uint64_t);
  int v645;
  unsigned __int8 *v646;
  unsigned int v647;
  int v648;
  unsigned int v649;
  unsigned int v650;
  __int16 *v651;
  _OWORD *v652;
  uint64_t v653;
  uint64_t v655;
  uint64_t v656;
  unint64_t v657;
  _BYTE *v658;
  int v659;
  _BYTE *v660;
  _BYTE *v661;
  int v662;
  uint64_t v663;
  NSObject *v665;
  _QWORD *v666;
  _UNKNOWN **v667;
  void (*v668)(_QWORD *);
  int v669;
  uint64_t v670;
  _BOOL4 v672;
  NSObject *v673;
  int v674;
  _BOOL4 v675;
  _BOOL4 v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v682;
  NSObject *v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  _BOOL4 v690;
  _BOOL4 v691;
  int v692;
  int v693;
  char v694;
  int8x8_t v695;
  unsigned __int8 *p_dst;
  _QWORD *v697;
  char v698;
  uint64_t v699;
  uint64_t v700;
  unsigned __int8 *v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  char *v705;
  unsigned __int8 *v706;
  uint64_t v707;
  unsigned __int8 *v708;
  uint64_t v709;
  char *v710;
  unsigned __int8 *v711;
  uint64_t v712;
  unsigned __int16 v713;
  unsigned __int16 v714;
  unsigned __int16 v715;
  unsigned __int16 v716;
  const char *v717;
  uint64_t v718;
  const char *v719;
  NSObject *v720;
  const char *v721;
  uint64_t v722;
  const char *v723;
  int v724;
  const char *v725;
  NSObject *v726;
  int v727;
  const char *v728;
  uint64_t v729;
  NSObject *v730;
  unsigned __int8 *v731;
  uint64_t v732;
  unsigned __int8 *v733;
  uint64_t v734;
  NSObject *v735;
  unsigned __int8 *v736;
  uint64_t v737;
  unsigned __int8 *v738;
  uint64_t v739;
  unsigned __int16 v740;
  unsigned __int16 v741;
  int v742;
  const char *v743;
  uint64_t *v744;
  uint64_t v745;
  unsigned int v746;
  uint64_t v747;
  uint64_t v748;
  unsigned int v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  int v758;
  uint64_t v759;
  int v760;
  uint64_t v761;
  _QWORD *v762;
  int v763;
  const char *v764;
  NSObject *v765;
  int v766;
  unsigned int v767;
  __int32 v768;
  int v769;
  uint64_t v770;
  int v771;
  uint64_t v772;
  unsigned __int8 *v773;
  _QWORD *v774;
  char v775;
  NSObject *v776;
  unsigned __int8 *v777;
  unsigned __int16 v778;
  uint64_t v779;
  const char *v780;
  unsigned __int8 *v781;
  unsigned __int16 v782;
  uint64_t v783;
  unsigned __int8 *v784;
  unsigned __int16 v785;
  uint64_t v786;
  unsigned __int8 *v787;
  unsigned __int16 v788;
  uint64_t v789;
  int v790;
  int v791;
  const char *v792;
  uint64_t v793;
  const char *v794;
  uint64_t v795;
  _QWORD *v796;
  uint64_t v797;
  const char *v798;
  uint64_t v799;
  NSObject *v800;
  uint64_t v801;
  uint64_t v802;
  BOOL v803;
  unsigned __int8 v805;
  NSObject *v806;
  unsigned __int8 v808;
  uint64_t v810;
  _QWORD **v811;
  uint64_t v812;
  _QWORD **v813;
  uint64_t v814;
  _QWORD **v815;
  uint64_t v816;
  _QWORD **v817;
  uint64_t v819;
  int v820;
  const char *v821;
  _DWORD *v822;
  const char *v823;
  unsigned __int16 v824;
  const char *v825;
  uint64_t v826;
  int v827;
  _DWORD *v828;
  unsigned int v829;
  unsigned int v830;
  int v831;
  unsigned int v832;
  uint64_t v833;
  int8x8_t *v834;
  unsigned int v835;
  _QWORD *v836;
  _QWORD *v837;
  _QWORD *v838;
  unsigned int v839;
  unsigned __int8 *v840;
  unsigned __int8 *v841;
  unsigned int v842;
  unsigned __int8 *v843;
  uint64_t *v844;
  uint64_t v845;
  NSObject *v846;
  uint64_t v847;
  uint64_t v848;
  int v849;
  __int128 *v850;
  BOOL v851;
  int v853;
  int v854;
  _BYTE *v855;
  unsigned int v856;
  unsigned __int8 *v858;
  int v859;
  char v860;
  _BYTE *v861;
  unsigned int v862;
  int v863;
  _BOOL4 v864;
  int v865;
  __int128 *__src;
  _BOOL4 IsDNSMulticast;
  char v868;
  int v869;
  unint64_t v870;
  int v871;
  _BOOL4 v872;
  int v873;
  uint64_t v874;
  unsigned int v875;
  int v876;
  _QWORD *v877;
  uint64_t v878;
  _BYTE *v879;
  int v880;
  int v881;
  int v882;
  int v883;
  NSObject *v884;
  os_log_type_t v885;
  uint64_t v886;
  int v887;
  unsigned int v888;
  uint64_t *v889;
  unsigned int v890;
  unsigned int v891;
  unsigned int v892;
  unsigned int v893;
  int v894;
  unsigned int v895;
  int v896;
  int v897;
  uint64_t v898;
  unsigned __int16 v899;
  unsigned __int8 *v900;
  uint64_t v901;
  uint64_t v902;
  unsigned __int8 *Answers;
  unsigned __int8 *v904;
  uint64_t NewCacheEntry;
  uint64_t v906;
  uint64_t v907;
  _BYTE *v908;
  int v909;
  char *v910;
  uint64_t v911;
  __int16 v912;
  int v913;
  int v914;
  int v915;
  _QWORD v916[300];
  _QWORD v917[100];
  __int128 __dst;
  __int128 v919;
  __int128 v920;
  __int128 v921;
  __int128 v922;
  __int128 v923;
  __int128 v924;
  __int128 v925;
  __int128 v926;
  __int128 v927;
  __int128 v928;
  __int128 v929;
  __int128 v930;
  __int128 v931;
  __int128 v932;
  __int128 v933;
  _BYTE v934[22];
  __int16 v935;
  int v936;
  __int16 v937;
  _BYTE *v938;
  __int16 v939;
  uint64_t v940;
  __int16 v941;
  const char *v942;
  __int16 v943;
  uint64_t v944;
  __int16 v945;
  uint64_t v946;
  __int16 v947;
  _BYTE *v948;
  _BYTE v949[200];
  unsigned int v950;
  int v951;
  unsigned __int16 v952;
  unsigned __int16 v953;
  __int16 v954;
  _BYTE v955[256];
  _BYTE v956[64];
  _OWORD v957[15];
  _OWORD v958[5];
  _OWORD v959[5];
  _OWORD v960[15];
  _BYTE v961[129];
  __int128 v962;
  __int128 v963;
  __int128 v964;
  __int128 v965;
  __int128 v966;
  __int128 v967;
  _BYTE v968[117];
  unsigned __int16 v969;
  _BYTE v970[156];
  int v971;
  _BYTE v972[10632];
  _OWORD v973[2];
  __int128 v974;
  __int128 v975;
  __int128 v976;
  __int128 v977;
  __int128 v978;
  __int128 v979;
  __int128 v980;
  __int128 v981;
  __int128 v982;
  __int128 v983;
  __int128 v984;
  __int128 v985;
  __int128 v986;
  __int128 v987;

  v16 = (void *)a10;
  if (!a6)
  {
    IsDNSMulticast = 0;
    if (a4)
      goto LABEL_3;
LABEL_5:
    v17 = 1;
    goto LABEL_6;
  }
  IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
  if (!a4)
    goto LABEL_5;
LABEL_3:
  v17 = mDNS_AddressIsLocalSubnet(a1, a10, a4) != 0;
LABEL_6:
  v864 = v17;
  v911 = 1;
  if (a10 && (v18 = *(uint64_t **)(a1 + 12656)) != 0)
  {
    while (v18[444] != a10
         || *((_DWORD *)v18 + 890) != 4
         || *((unsigned __int8 *)v18 + 3564) != 169
         || *((unsigned __int8 *)v18 + 3565) != 254)
    {
      v18 = (uint64_t *)*v18;
      if (!v18)
        goto LABEL_13;
    }
    v844 = v18;
  }
  else
  {
LABEL_13:
    v844 = 0;
  }
  v892 = *((unsigned __int16 *)a2 + 3);
  v19 = *((unsigned __int16 *)a2 + 4);
  v20 = *((unsigned __int16 *)a2 + 5);
  v907 = a8;
  if (!a8)
  {
    v22 = 0;
LABEL_21:
    a8 = 0;
    goto LABEL_22;
  }
  v21 = *(_UNKNOWN ***)(a8 + 16);
  if (v21 == &_mdns_querier_kind)
    v22 = a8;
  else
    v22 = 0;
  if (v21 != &_mdns_subscriber_kind)
    goto LABEL_21;
LABEL_22:
  v896 = IsResponseMDNSEquivalent(v907, (uint64_t)a9);
  v910 = 0;
  if (a10 || v907 || (a2[2] & 2) == 0 || v892 && v19 | v20)
  {
    v850 = a4;
    __src = a6;
    v890 = v19 + v892;
    v23 = (unsigned __int8 *)(a1 + 37920);
    OptRR = LocateOptRR((unint64_t)a2, a3, 14);
    v878 = a1;
    v870 = a3;
    v906 = v22;
    v858 = (unsigned __int8 *)(a1 + 37920);
    v901 = a8;
    if (!OptRR)
    {
      v29 = 0;
      LODWORD(v25) = IsDNSMulticast;
      goto LABEL_72;
    }
    LODWORD(v25) = IsDNSMulticast;
    if (!GetLargeResourceRecord(a1, (unint64_t)a2, OptRR, a3, a10, 128, a1 + 37912)
      || *v23 == 240
      || *(_WORD *)(a1 + 37924) != 41)
    {
      v29 = 0;
      goto LABEL_64;
    }
    v26 = *(_QWORD *)(a1 + 37960);
    v27 = v26 + 4 + *(unsigned __int16 *)(a1 + 37932);
    if (v26 + 4 >= v27)
    {
      v29 = 0;
      v910 = 0;
      a3 = v870;
      goto LABEL_64;
    }
    v28 = 0;
    v29 = 0;
    v30 = (unsigned __int16 *)(v26 + 16);
    while (1)
    {
      if ((__int16)*(v30 - 6) == -534)
      {
        ++v28;
        v31 = *v30;
        v32 = DomainNamePtrAtTSRIndex((unsigned __int16 *)a2, v870, v31);
        if (v32)
        {
          v33 = UnsafeBufferPointer((unint64_t)a2, v32, v870, (uint64_t)(v30 - 6));
          if (!v33)
          {
            v41 = mDNSLogCategory_mDNS;
            v42 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
            v16 = (void *)a10;
            v23 = v858;
            if (v42)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
              {
LABEL_51:
                v45 = *((_QWORD *)v858 + 3);
                v46 = *((_DWORD *)v30 - 2);
                v47 = *((_DWORD *)v30 - 1);
                v48 = *v30;
                *(_DWORD *)v961 = 67110144;
                *(_DWORD *)&v961[4] = v28;
                *(_WORD *)&v961[8] = 2048;
                *(_QWORD *)&v961[10] = v45;
                *(_WORD *)&v961[18] = 1024;
                *(_DWORD *)&v961[20] = v46;
                *(_WORD *)&v961[24] = 1024;
                *(_DWORD *)&v961[26] = v47;
                *(_WORD *)&v961[30] = 1024;
                *(_DWORD *)&v961[32] = v48;
                v39 = v41;
                v40 = "mDNSCoreReceiveResponse: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
LABEL_52:
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, v40, v961, 0x24u);
              }
            }
            else
            {
              v41 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                goto LABEL_51;
            }
            a1 = v878;
            goto LABEL_54;
          }
          *(_QWORD *)v33 = v29;
          v29 = v33;
          a1 = v878;
          v16 = (void *)a10;
        }
        else
        {
          v34 = mDNSLogCategory_mDNS;
          v35 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
          if (v35)
          {
            v16 = (void *)a10;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
              goto LABEL_39;
          }
          else
          {
            v34 = mDNSLogCategory_mDNS_redacted;
            v43 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
            v16 = (void *)a10;
            if (v43)
            {
LABEL_39:
              v36 = *((_QWORD *)v858 + 3);
              v37 = *((_DWORD *)v30 - 2);
              v38 = *((_DWORD *)v30 - 1);
              *(_DWORD *)v961 = 67110144;
              *(_DWORD *)&v961[4] = v28;
              *(_WORD *)&v961[8] = 2048;
              *(_QWORD *)&v961[10] = v36;
              *(_WORD *)&v961[18] = 1024;
              *(_DWORD *)&v961[20] = v37;
              *(_WORD *)&v961[24] = 1024;
              *(_DWORD *)&v961[26] = v38;
              *(_WORD *)&v961[30] = 1024;
              *(_DWORD *)&v961[32] = v31;
              v39 = v34;
              v23 = v858;
              v40 = "mDNSCoreReceiveResponse: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
              goto LABEL_52;
            }
          }
          a1 = v878;
        }
      }
      v23 = v858;
LABEL_54:
      v49 = v30 + 6;
      v30 += 12;
      if ((unint64_t)v49 >= v27)
      {
        v910 = v29;
        a3 = v870;
        LODWORD(v25) = IsDNSMulticast;
        if (v29)
        {
          v50 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
              goto LABEL_1997;
          }
          else
          {
            v50 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_1997:
              v819 = *((_QWORD *)v23 + 3);
              GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((_QWORD *)v23 + 5) + 4), (_BYTE *)(v878 + 47032));
              *(_DWORD *)v961 = 67109634;
              *(_DWORD *)&v961[4] = v28;
              v16 = (void *)a10;
              *(_WORD *)&v961[8] = 2048;
              *(_QWORD *)&v961[10] = v819;
              a1 = v878;
              *(_WORD *)&v961[18] = 2082;
              *(_QWORD *)&v961[20] = v878 + 47032;
              LODWORD(v25) = IsDNSMulticast;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "mDNSCoreReceiveResponse: Received TSR(%u) if %p %{public}s", v961, 0x1Cu);
            }
          }
        }
        v22 = v906;
        a8 = v901;
LABEL_64:
        *(_WORD *)v23 = 0;
        *((_WORD *)v23 + 51) = 0;
        v52 = (_QWORD *)*((_QWORD *)v23 + 7);
        if (v52)
        {
          ref_count_obj_release(v52);
          *((_QWORD *)v23 + 7) = 0;
        }
LABEL_72:
        v53 = v890 + v20;
        v900 = a2;
        if ((_DWORD)v25)
        {
          Answers = LocateAnswers((unint64_t)a2, a3);
          goto LABEL_74;
        }
        v55 = ((a2[3] & 0xFu) < 0xA) & (0x209u >> (a2[3] & 0xF));
        if (v22)
          v56 = ((a2[3] & 0xFu) < 0xA) & (0x209u >> (a2[3] & 0xF));
        else
          v56 = 1;
        if (!v56)
          v53 = 0;
        Answers = a2 + 12;
        if (*((_WORD *)a2 + 2) && (unint64_t)(a2 + 12) < a3)
        {
          v882 = v53;
          v57 = 0;
          v871 = 0;
          if (v22)
            v55 = 1;
          v888 = v55;
          v879 = (_BYTE *)(a1 + 47032);
          v58 = a2 + 12;
          while (2)
          {
            bzero(v961, 0x2B8uLL);
            Answers = getQuestion((unint64_t)a2, v58, a3, (uint64_t)v16, v961);
            if (!Answers || a8)
              goto LABEL_135;
            if (v907)
            {
              v59 = 0;
              goto LABEL_93;
            }
            v59 = ExpectingUnicastResponseForQuestion(*(_QWORD *)(a1 + 192), a7, *(_WORD *)a2, (uint64_t)v961, __src == 0);
            if (v59)
            {
LABEL_93:
              if (v888)
              {
                v60 = CacheGroupForName(a1, *(unsigned int *)((char *)&v966 + 7), v970);
                if (v60)
                {
                  v66 = v60[2];
                  if (v66)
                  {
                    while (1)
                    {
                      if (v907)
                      {
                        v67 = *(_QWORD **)(v66 + 56);
                        if (v67)
                          v67 = (_QWORD *)v67[3];
                        if (v67 != a9 || !Client_SameNameCacheRecordIsAnswer(v66, v907))
                          goto LABEL_131;
                      }
                      else if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v66 + 8), 0, v59, v61, v62, v63, v64, v65))
                      {
                        goto LABEL_131;
                      }
                      if (!*(_BYTE *)(v66 + 109))
                        break;
LABEL_131:
                      v66 = *(_QWORD *)v66;
                      if (!v66)
                        goto LABEL_132;
                    }
                    v68 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      {
                        v874 = *(_QWORD *)((char *)&v962 + 7);
                        for (i = v970; ; i += v72 + 1)
                        {
                          v71 = 257;
                          if (i >= v972 || !i)
                            break;
                          v72 = *i;
                          if (v72 > 0x3F)
                          {
                            v71 = 257;
                            break;
                          }
                          if (!*i)
                          {
                            v71 = (_WORD)i - (unsigned __int16)v970 + 1;
                            break;
                          }
                        }
LABEL_129:
                        v76 = v71;
                        v77 = DNSTypeName(v969);
                        v78 = *(_QWORD *)(v66 + 32);
                        GetRRDisplayString_rdb((unsigned __int8 *)(v66 + 8), (unsigned __int16 *)(*(_QWORD *)(v66 + 48) + 4), v879);
                        *(_DWORD *)v934 = 134220035;
                        *(_QWORD *)&v934[4] = v874;
                        *(_WORD *)&v934[12] = 2160;
                        *(_QWORD *)&v934[14] = 1752392040;
                        v935 = 1040;
                        v936 = v76;
                        v937 = 2101;
                        v938 = v970;
                        v939 = 2160;
                        v940 = 1752392040;
                        v941 = 2085;
                        v942 = v77;
                        v943 = 2048;
                        v944 = v78;
                        v945 = 2160;
                        v946 = 1752392040;
                        v947 = 2085;
                        v948 = v879;
                        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEBUG, "Making record answered by the current response as expired if it is not refreshed in the response - Q interface ID: %p, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, RR interface ID: %p, RR description: %{sensitive, mask.hash}s.", v934, 0x58u);
                        a2 = v900;
                        a3 = v870;
                        a8 = v901;
                      }
                    }
                    else
                    {
                      v68 = mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                      {
                        v874 = *(_QWORD *)((char *)&v962 + 7);
                        for (j = v970; ; j += v75 + 1)
                        {
                          v71 = 257;
                          if (j >= v972 || !j)
                            break;
                          v75 = *j;
                          if (v75 > 0x3F)
                          {
                            v71 = 257;
                            goto LABEL_129;
                          }
                          if (!*j)
                          {
                            v71 = (_WORD)j - (unsigned __int16)v970 + 1;
                            goto LABEL_129;
                          }
                        }
                        goto LABEL_129;
                      }
                    }
                    a1 = v878;
                    *(_DWORD *)(v66 + 80) = *(_DWORD *)(v878 + 64) + ~(1000 * *(_DWORD *)(v66 + 16));
                    *(_BYTE *)(v66 + 108) = 4;
                    goto LABEL_131;
                  }
LABEL_132:
                  v16 = (void *)a10;
                  v23 = v858;
LABEL_135:
                  ++v57;
                  v58 = Answers;
                  v80 = v57 >= *((unsigned __int16 *)a2 + 2) || Answers == 0 || (unint64_t)Answers >= a3;
                  if (!v80)
                    continue;
                  LODWORD(v25) = IsDNSMulticast;
                  v53 = v882;
                  v22 = v906;
                  if (!v871)
                    goto LABEL_74;
                  v81 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                      return;
                    v83 = bswap32(*(unsigned __int16 *)a2) >> 16;
                    v84 = *((unsigned __int16 *)a2 + 3);
                    v85 = "s,";
                    v86 = *((unsigned __int16 *)a2 + 4);
                    v87 = *((unsigned __int16 *)a2 + 5);
                    *(_DWORD *)v961 = 67110658;
                    if (v84 == 1)
                      v85 = ", ";
                    *(_DWORD *)&v961[4] = v83;
                    *(_WORD *)&v961[8] = 1024;
                    if (v86 == 1)
                      v88 = "y,  ";
                    else
                      v88 = "ies,";
                    *(_DWORD *)&v961[10] = v84;
                    v89 = "s";
                    *(_WORD *)&v961[14] = 2082;
                    *(_QWORD *)&v961[16] = v85;
                    if (v87 == 1)
                      v89 = "";
                  }
                  else
                  {
                    v81 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      return;
                    v391 = bswap32(*(unsigned __int16 *)a2) >> 16;
                    v392 = *((unsigned __int16 *)a2 + 3);
                    v393 = "s,";
                    v86 = *((unsigned __int16 *)a2 + 4);
                    v87 = *((unsigned __int16 *)a2 + 5);
                    *(_DWORD *)v961 = 67110658;
                    if (v392 == 1)
                      v393 = ", ";
                    *(_DWORD *)&v961[4] = v391;
                    *(_WORD *)&v961[8] = 1024;
                    if (v86 == 1)
                      v88 = "y,  ";
                    else
                      v88 = "ies,";
                    *(_DWORD *)&v961[10] = v392;
                    v89 = "s";
                    *(_WORD *)&v961[14] = 2082;
                    *(_QWORD *)&v961[16] = v393;
                    if (v87 == 1)
                      v89 = "";
                  }
                  *(_WORD *)&v961[24] = 1024;
                  *(_DWORD *)&v961[26] = v86;
                  *(_WORD *)&v961[30] = 2082;
                  *(_QWORD *)&v961[32] = v88;
                  *(_WORD *)&v961[40] = 1024;
                  *(_DWORD *)&v961[42] = v87;
                  *(_WORD *)&v961[46] = 2082;
                  *(_QWORD *)&v961[48] = v89;
                  _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "[Q%d] Ignoring %2d Answer%{public}s %2d Authorit%{public}s %2d Additional%{public}s", v961, 0x38u);
                  return;
                }
              }
              else
              {
                v871 = 1;
              }
            }
            break;
          }
          v16 = (void *)a10;
          goto LABEL_135;
        }
LABEL_74:
        bzero(v917, 0x320uLL);
        bzero(v916, 0x960uLL);
        v887 = 0;
        if (!v896 && v22)
        {
          v54 = *(unsigned __int8 *)(*(_QWORD *)(v22 + 88) + 70);
          if ((v54 & 4) != 0)
            v887 = (v54 >> 1) & 1;
          else
            v887 = 0;
        }
        v836 = 0;
        v90 = 0;
        if (v53 < 1 || !Answers)
        {
          v862 = 0;
          v91 = 0;
          goto LABEL_908;
        }
        v862 = 0;
        v91 = 0;
        if ((unint64_t)Answers >= a3)
          goto LABEL_908;
        v92 = a8;
        v93 = 0;
        v880 = 0;
        v94 = 0;
        v875 = 0;
        v862 = 0;
        v859 = 0;
        v828 = (_DWORD *)(a1 + 19912);
        if ((unint64_t)__src | v907)
          v95 = (int)v25;
        else
          v95 = 1;
        v876 = v95;
        v898 = a1 + 37912;
        v872 = (v22 | v92) != 0;
        v855 = (_BYTE *)(a1 + 47032);
        v830 = bswap32(a5) >> 16;
        v96 = "uni";
        if ((_DWORD)v25)
          v96 = "multi";
        v825 = v96;
        if (v887)
          v97 = 2;
        else
          v97 = 0;
        v832 = v97 | (v92 != 0);
        v826 = a1 + 12656;
        v834 = (int8x8_t *)&v911;
        v98 = Answers;
        v883 = v53;
        v868 = (char)v25;
LABEL_171:
        if (v880)
          v99 = 1;
        else
          v99 = v876;
        if (v93 >= v890)
          v100 = 0x80;
        else
          v100 = -96;
        if (v93 < v892)
          v100 = -64;
        LargeResourceRecord = GetLargeResourceRecord(a1, (unint64_t)a2, v98, a3, (uint64_t)v16, v100 & 0xE0, v898);
        if (!LargeResourceRecord)
        {
          v386 = v906;
          goto LABEL_981;
        }
        v98 = LargeResourceRecord;
        if (DPCFeatureEnabled_sOnce != -1)
          dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
        if (DPCFeatureEnabled_sEnabled)
        {
          if (v896)
          {
            if (!v901)
            {
              v102 = *((_QWORD *)v23 + 4);
              v103 = *((unsigned __int16 *)v23 + 2);
              v104 = *((unsigned __int16 *)v23 + 3);
              if (DPCFeatureEnabled_sEnabled)
              {
                if (_DPCGetRegisteredSubscriber(v16, v102, v103, v104))
                  goto LABEL_203;
              }
            }
          }
        }
        if (v872)
        {
          if (v94)
            goto LABEL_198;
          v109 = mdns_cache_metadata_create();
          v94 = (_QWORD *)v109;
          if (v906)
          {
            v110 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v906 + 64) + 16) + 144);
            if (v110 == 1)
            {
              if (*(_BYTE *)(v906 + 250))
                v110 = 2;
              else
                v110 = 1;
            }
            *(_DWORD *)(v109 + 48) = v110;
            mdns_cache_metadata_set_extended_dns_error(v109, *(void **)(v906 + 160));
          }
          if (v901)
          {
            v94[5] = *(_QWORD *)(v901 + 120);
            mdns_dns_push_service_definition_set_srv_name((uint64_t)v94, a9);
            goto LABEL_198;
          }
          mdns_dns_push_service_definition_set_srv_name((uint64_t)v94, a9);
          if (v94)
LABEL_198:
            os_retain(v94);
          v111 = (void *)*((_QWORD *)v23 + 6);
          if (v111)
            os_release(v111);
          *((_QWORD *)v23 + 6) = v94;
        }
        if (*v23 == 240)
          goto LABEL_203;
        v837 = v94;
        if (v887)
        {
          v114 = _dnssec_obj_resource_record_member_new();
          v114[8] = 0;
          *((_QWORD *)v114 + 2) = v898;
          *((_BYTE *)v114 + 40) = 1;
          ++*v114;
          ref_count_obj_release(v114);
          *((_QWORD *)v23 + 7) = v114;
          v94 = v837;
        }
        v115 = *((unsigned __int16 *)v23 + 2);
        switch(v115)
        {
          case 5:
            if (!SameDomainNameBytes(*((_BYTE **)v23 + 4), (_BYTE *)(*((_QWORD *)v23 + 5) + 4)))
              goto LABEL_226;
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: CNAME loop domain name %##s", v104, v105, v106, v107, v108, *((_QWORD *)v23 + 4));
LABEL_203:
            *(_WORD *)v23 = 0;
            *((_WORD *)v23 + 51) = 0;
            v112 = (_QWORD *)*((_QWORD *)v23 + 7);
            break;
          case 41:
            v116 = *((_QWORD *)v23 + 5);
            v117 = v116 + 4 + *((unsigned __int16 *)v23 + 6);
            if (v116 + 4 < v117)
            {
              v118 = v116 + 8;
              do
              {
                if (*(_WORD *)(v118 - 4) == 4 && !*(_BYTE *)v118 && *(_DWORD *)(v118 + 2))
                {
                  ClearProxyRecords(a1, v118, *(_QWORD *)(a1 + 12624));
                  ClearProxyRecords(a1, v118, *(_QWORD *)(a1 + 12616));
                }
                v119 = v118 + 20;
                v118 += 24;
              }
              while (v119 < v117);
            }
            *(_WORD *)v23 = 0;
            *((_WORD *)v23 + 51) = 0;
            v112 = (_QWORD *)*((_QWORD *)v23 + 7);
            v94 = v837;
            break;
          case 250:
            goto LABEL_203;
          default:
LABEL_226:
            if (!v896)
            {
              v120 = *((_DWORD *)v23 + 2);
              if (v120 >= 0x189374)
                v120 = 1610612;
              v121 = v120 + (v120 >> 2) + 2;
              if (v121 <= 0xF)
                v121 = 15;
              *((_DWORD *)v23 + 2) = v121;
            }
            v904 = v98;
            if ((v25 & 1) != 0)
            {
              if (!v844 || !*((_BYTE *)v844 + 3674) || *((_WORD *)v23 + 2) != 1 || v23[148] != 169 || v23[149] != 254)
                goto LABEL_301;
              if (mDNS_LoggingEnabled == 1)
              {
                v122 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((_QWORD *)v23 + 5) + 4), v855);
                v123 = v122;
                v94 = v837;
                LogMsgWithLevel(v123, OS_LOG_TYPE_DEFAULT, "mDNSResponder: Dropping LinkLocal packet %s", v124, v125, v126, v127, v128, (int)v855);
              }
              goto LABEL_203;
            }
            if (__src && (v99 & 1) != 0)
              goto LABEL_242;
            if (!v907)
            {
              v135 = *(_QWORD *)(a1 + 192);
              LOBYTE(v25) = v868;
              if (!v135)
                goto LABEL_298;
              v136 = *(unsigned __int16 *)a2;
              while (1)
              {
                if (!*(_QWORD *)(v135 + 40) && !*(_BYTE *)(v135 + 354))
                {
                  v137 = *((_QWORD *)v23 + 3);
                  if ((!v137 || (v138 = *(_QWORD *)(v135 + 136)) == 0 || v137 == v138)
                    && ((v139 = *((_QWORD *)v23 + 6)) != 0 && *(_QWORD *)(v139 + 24) || !v137 || !*(_WORD *)(v135 + 340)))
                  {
                    v140 = *(_QWORD *)(v135 + 144);
                    v141 = v140 && *(_BYTE *)(v140 + 24) != 0;
                    if (RRTypeAnswersQuestionType((uint64_t)v23, *(unsigned __int16 *)(v135 + 342), v141, v104, v105, v106, v107, v108))
                    {
                      v142 = *(unsigned __int16 *)(v135 + 344);
                      if ((*((unsigned __int16 *)v23 + 3) == v142 || v142 == 255)
                        && *((_DWORD *)v23 + 4) == *(_DWORD *)(v135 + 200)
                        && SameDomainNameBytes(*((_BYTE **)v23 + 4), (_BYTE *)(v135 + 376)))
                      {
                        if (*(_WORD *)(v135 + 340))
                        {
                          if (*(unsigned __int16 *)(v135 + 340) == v136)
                          {
                            if (__src)
                            {
                              v144 = *(__int16 **)(v135 + 72);
                              if (!v144)
                                v144 = &zeroIPPort;
                            }
                            else
                            {
                              v144 = (__int16 *)(v135 + 338);
                            }
                            if ((unsigned __int16)*v144 == a7)
                            {
LABEL_291:
                              v16 = (void *)a10;
                              v145 = v859;
                              if (a10)
                                v145 = 1;
                              v859 = v145;
                              v146 = v880;
                              if (a10)
                                v146 = 1;
                              v880 = v146;
                              v99 = 1;
                              goto LABEL_300;
                            }
                            if (mDNS_LoggingEnabled == 1)
                            {
                              v846 = mDNSLogCategory_Default;
                              DNSTypeName(*(unsigned __int16 *)(v135 + 342));
                              GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((_QWORD *)v23 + 5) + 4), v855);
                              LogMsgWithLevel(v846, OS_LOG_TYPE_DEFAULT, "WARNING: Ignoring suspect uDNS response for %##s (%s) from %#a:%d %s", v147, v148, v149, v150, v151, v135 + 376);
                            }
LABEL_298:
                            v16 = (void *)a10;
                            if (!a10)
                              v99 = 0;
LABEL_300:
                            a1 = v878;
                            goto LABEL_301;
                          }
                        }
                        else if (v864)
                        {
                          v143 = *(_DWORD *)(v135 + 216);
                          if (v143)
                          {
                            if ((*(_DWORD *)(v878 + 64) - v143) < 0x7D0)
                              goto LABEL_291;
                          }
                        }
                      }
                    }
                  }
                }
                v135 = *(_QWORD *)(v135 + 8);
                if (!v135)
                  goto LABEL_298;
              }
            }
            v129 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v907 + 16) + 88))(v907, v102, v103, v104);
            v130 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v907 + 16) + 80))(v907);
            if (!v130)
            {
              v16 = (void *)a10;
              LOBYTE(v25) = v868;
              goto LABEL_301;
            }
            v131 = v130;
            v132 = *((unsigned __int16 *)v23 + 3);
            if (v132 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)(v907 + 16) + 96))(v907))
            {
              v16 = (void *)a10;
              LOBYTE(v25) = v868;
              v98 = v904;
              goto LABEL_301;
            }
            v98 = v904;
            if (*(_UNKNOWN ***)(v907 + 16) == &_mdns_querier_kind
              && (v133 = *(unsigned __int8 *)(*(_QWORD *)(v907 + 88) + 70), (v133 & 4) != 0))
            {
              v134 = (v133 >> 1) & 1;
            }
            else
            {
              v134 = 0;
            }
            LOBYTE(v25) = v868;
            if (!RRTypeAnswersQuestionType((uint64_t)v23, v129, v134, v104, v105, v106, v107, v108))
            {
              v16 = (void *)a10;
              goto LABEL_301;
            }
            v16 = (void *)a10;
            if (SameDomainNameBytes(*((_BYTE **)v23 + 4), *(_BYTE **)(v131 + 24)))
LABEL_242:
              v99 = 1;
LABEL_301:
            if (v896 && *((_WORD *)v23 + 2) != 47)
            {
              v152 = *(_QWORD *)(a1 + 12640);
              if (v152)
              {
                v153 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v152 + 8), (unsigned __int16 *)(*(_QWORD *)(v152 + 48) + 4), v855);
                LogMsgWithLevel(v153, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse ERROR m->CurrentRecord already set %s", v154, v155, v156, v157, v158, (int)v855);
              }
              v159 = *(_QWORD *)(a1 + 12616);
              *(_QWORD *)(a1 + 12640) = v159;
              if (v159)
              {
                while (2)
                {
                  v160 = *(_QWORD *)v159;
                  *(_QWORD *)(a1 + 12640) = *(_QWORD *)v159;
                  if (v99)
                  {
LABEL_307:
                    if (!PacketRRMatchesSignature(v898, v159, v103, v104, v105, v106, v107, v108))
                      goto LABEL_445;
                    v161 = (_BYTE *)*((_QWORD *)v858 + 4);
                    v162 = &v910;
                    do
                    {
                      v162 = (char **)*v162;
                      if (!v162)
                        goto LABEL_329;
                    }
                    while (!SameDomainNameBytes((_BYTE *)v162 + 20, v161));
                    v163 = CheckTSRForAuthRecord(*(uint64_t **)(a1 + 12616), (int *)v162 + 2, *(_DWORD *)(v159 + 24), *(_BYTE **)(v159 + 40));
                    if (v163)
                    {
                      if (v163 != -1)
                      {
                        v98 = v904;
                        goto LABEL_445;
                      }
                      v164 = mDNSLogCategory_mDNS;
                      v98 = v904;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          v172 = *(_QWORD *)(v159 + 40);
                          if (v172)
                          {
                            v185 = *(_BYTE **)(v159 + 40);
                            if (v172 == -256)
                              goto LABEL_375;
LABEL_372:
                            v186 = 257;
                            if ((unint64_t)v185 < v172 + 256 && v185)
                            {
                              while (1)
                              {
                                v187 = *v185;
                                if (v187 > 0x3F)
                                {
LABEL_438:
                                  v186 = 257;
                                  goto LABEL_442;
                                }
                                if (!*v185)
                                  break;
                                v185 += v187 + 1;
                                if (v172 != -256)
                                  goto LABEL_372;
LABEL_375:
                                if (!v185)
                                  goto LABEL_438;
                              }
                              v186 = (_WORD)v185 - v172 + 1;
                            }
LABEL_442:
                            v210 = v186;
                          }
                          else
                          {
                            v210 = 0;
                          }
LABEL_443:
                          v211 = DNSTypeName(*(unsigned __int16 *)(v159 + 12));
                          *(_DWORD *)v961 = 141559043;
                          *(_QWORD *)&v961[4] = 1752392040;
                          *(_WORD *)&v961[12] = 1040;
                          *(_DWORD *)&v961[14] = v210;
                          *(_WORD *)&v961[18] = 2101;
                          *(_QWORD *)&v961[20] = v172;
                          *(_WORD *)&v961[28] = 2082;
                          *(_QWORD *)&v961[30] = v211;
                          *(_WORD *)&v961[38] = 1024;
                          v16 = (void *)a10;
                          *(_DWORD *)&v961[40] = a10;
                          _os_log_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface %d due to TSR conflict", v961, 0x2Cu);
                          v98 = v904;
                        }
                      }
                      else
                      {
                        v164 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
                          v172 = *(_QWORD *)(v159 + 40);
                          if (v172)
                          {
                            v173 = *(_BYTE **)(v159 + 40);
                            if (v172 == -256)
                              goto LABEL_321;
LABEL_318:
                            v174 = 257;
                            if ((unint64_t)v173 < v172 + 256 && v173)
                            {
                              while (1)
                              {
                                v175 = *v173;
                                if (v175 > 0x3F)
                                {
LABEL_437:
                                  v174 = 257;
                                  goto LABEL_440;
                                }
                                if (!*v173)
                                  break;
                                v173 += v175 + 1;
                                if (v172 != -256)
                                  goto LABEL_318;
LABEL_321:
                                if (!v173)
                                  goto LABEL_437;
                              }
                              v174 = (_WORD)v173 - v172 + 1;
                            }
LABEL_440:
                            v210 = v174;
                          }
                          else
                          {
                            v210 = 0;
                          }
                          goto LABEL_443;
                        }
                      }
                      D2D_stop_advertising_record(v159, v165, v166, v167, v168, v169, v170, v171);
                      mDNS_Deregister_internal(a1, v159, 4);
                      goto LABEL_445;
                    }
LABEL_329:
                    if (!resource_records_have_same_dnssec_rr_category(*((_QWORD *)v858 + 7), *(_QWORD *)(v159 + 64))|| *((unsigned __int16 *)v858 + 2) != *(unsigned __int16 *)(v159 + 12)|| *((unsigned __int16 *)v858 + 3) != *(unsigned __int16 *)(v159 + 14)|| *((unsigned __int16 *)v858 + 6) != *(unsigned __int16 *)(v159 + 20)|| *((_DWORD *)v858 + 5) != *(_DWORD *)(v159 + 28)|| !SameRDataBody((uint64_t)v858, (unsigned __int16 *)(*(_QWORD *)(v159 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                    {
                      v98 = v904;
                      if (!*((_DWORD *)v858 + 2) || !PacketRRConflict(a1, v159, v898))
                      {
                        if (*((unsigned __int16 *)v858 + 2) == *(unsigned __int16 *)(v159 + 12) && (*v858 & 0x10) != 0)
                        {
                          v177 = *(_DWORD *)(a1 + 64);
                          if ((v177 - *(_DWORD *)(v159 + 288)) >= 0x1F5
                            && ResourceRecordIsValidAnswer(v159))
                          {
                            *(_QWORD *)(v159 + 208) = -1;
                            *(_DWORD *)(a1 + 100) = v177;
                          }
                        }
                        goto LABEL_445;
                      }
                      v176 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_352;
                      }
                      else
                      {
                        v176 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_352:
                          v178 = *((_DWORD *)v858 + 5);
                          GetRRDisplayString_rdb(v858, (unsigned __int16 *)(*((_QWORD *)v858 + 5) + 4), v855);
                          *(_DWORD *)v961 = 67109891;
                          *(_DWORD *)&v961[4] = v178;
                          v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(_QWORD *)&v961[10] = 1752392040;
                          *(_WORD *)&v961[18] = 2085;
                          *(_QWORD *)&v961[20] = v855;
                          LOBYTE(v25) = v868;
                          *(_WORD *)&v961[28] = 1024;
                          *(_DWORD *)&v961[30] = (_DWORD)v16;
                          _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Pkt Record: %08X %{sensitive, mask.hash}s (interface %d)", v961, 0x22u);
                        }
                      }
                      v179 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_358;
                      }
                      else
                      {
                        v179 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_358:
                          v180 = *(_DWORD *)(v159 + 28);
                          GetRRDisplayString_rdb((unsigned __int8 *)(v159 + 8), (unsigned __int16 *)(*(_QWORD *)(v159 + 48) + 4), v855);
                          *(_DWORD *)v961 = 67109635;
                          *(_DWORD *)&v961[4] = v180;
                          v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(_QWORD *)&v961[10] = 1752392040;
                          *(_WORD *)&v961[18] = 2085;
                          *(_QWORD *)&v961[20] = v855;
                          _os_log_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Our Record: %08X %{sensitive, mask.hash}s", v961, 0x1Cu);
                        }
                      }
                      if (*(_QWORD *)(v159 + 88))
                      {
                        do
                        {
                          v181 = v159;
                          v159 = *(_QWORD *)(v159 + 88);
                        }
                        while (v159);
                        v182 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          v184 = v858;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_381;
                        }
                        else
                        {
                          v182 = mDNSLogCategory_mDNS_redacted;
                          v188 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                          v184 = v858;
                          if (v188)
                          {
LABEL_381:
                            v189 = *(_DWORD *)(v181 + 28);
                            GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                            *(_DWORD *)v961 = 67109635;
                            *(_DWORD *)&v961[4] = v189;
                            v98 = v904;
                            *(_WORD *)&v961[8] = 2160;
                            *(_QWORD *)&v961[10] = 1752392040;
                            *(_WORD *)&v961[18] = 2085;
                            *(_QWORD *)&v961[20] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Dep Record: %08X %{sensitive, mask.hash}s", v961, 0x1Cu);
                          }
                        }
                      }
                      else
                      {
                        v181 = v159;
                        v184 = v858;
                      }
                      v190 = *(unsigned __int8 *)(v181 + 190);
                      if (v190 >= 4)
                      {
                        v191 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_401;
                        }
                        else
                        {
                          v191 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_401;
                        }
                        GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                        *(_DWORD *)v961 = 141558275;
                        *(_QWORD *)&v961[4] = 1752392040;
                        *(_WORD *)&v961[12] = 2085;
                        *(_QWORD *)&v961[14] = v855;
                        v192 = v191;
                        v193 = "mDNSCoreReceiveResponse: Already reset to Probing: %{sensitive, mask.hash}s";
LABEL_400:
                        _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_DEFAULT, v193, v961, 0x16u);
                        goto LABEL_401;
                      }
                      v194 = gSensitiveLoggingEnabled;
                      v195 = mDNSLogCategory_mDNS;
                      if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        v194 = 0;
                      if (v190 == 3)
                      {
                        if ((v194 & 1) != 0)
                        {
                          v195 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_401;
                        }
                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          goto LABEL_401;
                        }
                        GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                        *(_DWORD *)v961 = 141558275;
                        *(_QWORD *)&v961[4] = 1752392040;
                        *(_WORD *)&v961[12] = 2085;
                        *(_QWORD *)&v961[14] = v855;
                        v192 = v195;
                        v193 = "mDNSCoreReceiveResponse: Ignoring response received before we even began probing: %{sensi"
                               "tive, mask.hash}s";
                        goto LABEL_400;
                      }
                      if ((v194 & 1) != 0)
                      {
                        v195 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_404:
                          GetRRDisplayString_rdb(v184, (unsigned __int16 *)(*((_QWORD *)v184 + 5) + 4), v855);
                          *(_DWORD *)v961 = 141559299;
                          *(_QWORD *)&v961[4] = 1752392040;
                          *(_WORD *)&v961[12] = 1045;
                          *(_DWORD *)&v961[14] = 20;
                          *(_WORD *)&v961[18] = 2101;
                          *(_QWORD *)&v961[20] = v850;
                          *(_WORD *)&v961[28] = 1024;
                          *(_DWORD *)&v961[30] = v830;
                          *(_WORD *)&v961[34] = 2160;
                          *(_QWORD *)&v961[36] = 1752392040;
                          *(_WORD *)&v961[44] = 2085;
                          *(_QWORD *)&v961[46] = v855;
                          LOBYTE(v25) = v868;
                          _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Received from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d %{sensitive, mask.hash}s", v961, 0x36u);
                        }
                      }
                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        goto LABEL_404;
                      }
                      v196 = *(unsigned __int8 *)(v181 + 8);
                      if (v196 != 2)
                      {
                        if (v196 != 32)
                        {
                          if (v196 == 16)
                          {
                            v197 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              a1 = v878;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                goto LABEL_449;
                            }
                            else
                            {
                              v197 = mDNSLogCategory_mDNS_redacted;
                              a1 = v878;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_449:
                                GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                                *(_DWORD *)v961 = 141558275;
                                *(_QWORD *)&v961[4] = 1752392040;
                                *(_WORD *)&v961[12] = 2085;
                                *(_QWORD *)&v961[14] = v855;
                                LOBYTE(v25) = v868;
                                _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Resetting to Probing: %{sensitive, mask.hash}s", v961, 0x16u);
                              }
                            }
                            *(_BYTE *)(v181 + 8) = 2;
                            *(_WORD *)(v181 + 190) = 1028;
                            InitializeLastAPTime((_DWORD *)a1, v181);
                            RecordProbeFailure((_DWORD *)a1, v181);
                            goto LABEL_401;
                          }
                          v209 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                              goto LABEL_455;
                          }
                          else
                          {
                            v209 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                            {
LABEL_455:
                              GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                              *(_DWORD *)v961 = 67109635;
                              *(_DWORD *)&v961[4] = v196;
                              *(_WORD *)&v961[8] = 2160;
                              *(_QWORD *)&v961[10] = 1752392040;
                              *(_WORD *)&v961[18] = 2085;
                              *(_QWORD *)&v961[20] = v855;
                              _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_ERROR, "mDNSCoreReceiveResponse: Unexpected record type %X %{sensitive, mask.hash}s", v961, 0x1Cu);
                            }
                          }
                          v859 = 1;
                          a1 = v878;
                          goto LABEL_402;
                        }
                        v201 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          a1 = v878;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                            goto LABEL_452;
                        }
                        else
                        {
                          v201 = mDNSLogCategory_mDNS_redacted;
                          a1 = v878;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                          {
LABEL_452:
                            GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                            *(_DWORD *)v961 = 141558275;
                            *(_QWORD *)&v961[4] = 1752392040;
                            *(_WORD *)&v961[12] = 2085;
                            *(_QWORD *)&v961[14] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_ERROR, "mDNSCoreReceiveResponse: Unexpected conflict discarding %{sensitive, mask.hash}s", v961, 0x16u);
                          }
                        }
                        ++v828[1];
LABEL_493:
                        D2D_stop_advertising_record(v181, v202, v203, v204, v205, v206, v207, v208);
                        mDNS_Deregister_internal(a1, v181, 2);
                        goto LABEL_401;
                      }
                      v198 = *(uint64_t **)(v878 + 15096);
                      if (v198)
                      {
                        a1 = v878;
                        do
                        {
                          if (*((_DWORD *)v198 + 6) == *(_DWORD *)(v181 + 24)
                            && resource_records_have_same_dnssec_rr_category(v198[8], *(_QWORD *)(v181 + 64))&& *((unsigned __int16 *)v198 + 6) == *(unsigned __int16 *)(v181 + 12)&& *((unsigned __int16 *)v198 + 7) == *(unsigned __int16 *)(v181 + 14)&& *((unsigned __int16 *)v198 + 10) == *(unsigned __int16 *)(v181 + 20)&& *((_DWORD *)v198 + 7) == *(_DWORD *)(v181 + 28)&& SameRDataBody((uint64_t)(v198 + 1), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((_BYTE *)v198[5], *(_BYTE **)(v181 + 40)))
                          {
                            if (mDNS_LoggingEnabled == 1)
                            {
                              v232 = mDNSLogCategory_Default;
                              GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                              LogMsgWithLevel(v232, OS_LOG_TYPE_DEFAULT, "mDNSCoreRegisteredProxyRecord: Ignoring packet registered with sleep proxy : %s ", v233, v234, v235, v236, v237, (int)v855);
                            }
                            goto LABEL_401;
                          }
                          v198 = (uint64_t *)*v198;
                        }
                        while (v198);
                        v199 = *(unsigned __int8 **)(v878 + 15096);
                        if (v199)
                        {
                          if (mDNS_LoggingEnabled != 1)
                          {
                            v200 = 0;
                            goto LABEL_458;
                          }
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Stored Proxy records :", v104, v105, v106, v107, v108, v820);
                          v199 = *(unsigned __int8 **)(v878 + 15096);
                          if (v199)
                          {
                            v200 = mDNS_LoggingEnabled;
                            do
                            {
LABEL_458:
                              if (v200)
                              {
                                v212 = mDNSLogCategory_Default;
                                GetRRDisplayString_rdb(v199 + 8, (unsigned __int16 *)(*((_QWORD *)v199 + 6) + 4), v855);
                                LOBYTE(v25) = v868;
                                LogMsgWithLevel(v212, OS_LOG_TYPE_DEFAULT, "%s", v213, v214, v215, v216, v217, (int)v855);
                                v200 = mDNS_LoggingEnabled;
                              }
                              v199 = *(unsigned __int8 **)v199;
                            }
                            while (v199);
                          }
                        }
                      }
                      v218 = *(_DWORD *)(v181 + 180);
                      a1 = v878;
                      if (v218 && *(_DWORD *)(v878 + 136) == *(_DWORD *)(v181 + 184))
                        goto LABEL_401;
                      v219 = (uint64_t *)v826;
                      while (1)
                      {
                        v219 = (uint64_t *)*v219;
                        if (!v219)
                          break;
                        if (v219[444] == a10)
                        {
                          v220 = v218 + 1;
                          *(_DWORD *)(v181 + 180) = v218 + 1;
                          *(_DWORD *)(v181 + 184) = *(_DWORD *)(v878 + 136);
                          if ((v25 & 1) == 0)
                            goto LABEL_483;
                          if (!*((_BYTE *)v219 + 3677) || v220 > 1)
                            goto LABEL_483;
LABEL_472:
                          v222 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              goto LABEL_498;
                          }
                          else
                          {
                            v222 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
LABEL_498:
                              v231 = *(unsigned __int8 *)(v181 + 190);
                              GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                              *(_DWORD *)v961 = 67110659;
                              *(_DWORD *)&v961[4] = v231;
                              v98 = v904;
                              *(_WORD *)&v961[8] = 1024;
                              *(_DWORD *)&v961[10] = 1000;
                              *(_WORD *)&v961[14] = 1024;
                              *(_DWORD *)&v961[16] = v220;
                              *(_WORD *)&v961[20] = 1024;
                              *(_DWORD *)&v961[22] = 1;
                              *(_WORD *)&v961[26] = 1024;
                              *(_DWORD *)&v961[28] = a10;
                              *(_WORD *)&v961[32] = 2160;
                              *(_QWORD *)&v961[34] = 1752392040;
                              *(_WORD *)&v961[42] = 2085;
                              *(_QWORD *)&v961[44] = v855;
                              LOBYTE(v25) = v868;
                              _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: ProbeCount %u; restarting probing after %u-tick pause due to po"
                                "ssibly spurious multicast conflict (%d/%u) via interface %d for %{sensitive, mask.hash}s",
                                v961,
                                0x34u);
                            }
                          }
                          *(_BYTE *)(v181 + 190) = 3;
                          a1 = v878;
                          *(_DWORD *)(v181 + 284) = *(_DWORD *)(v878 + 64) - *(_DWORD *)(v181 + 280) + 1000;
                          SetNextAnnounceProbeTime(v878, v181);
LABEL_401:
                          v859 = 1;
LABEL_402:
                          v16 = (void *)a10;
                          goto LABEL_445;
                        }
                      }
                      v220 = v218 + 1;
                      *(_DWORD *)(v181 + 180) = v218 + 1;
                      *(_DWORD *)(v181 + 184) = *(_DWORD *)(v878 + 136);
                      if (v218 + 1 < 2)
                        v224 = (char)v25;
                      else
                        v224 = 0;
                      if ((v224 & 1) != 0)
                        goto LABEL_472;
LABEL_483:
                      v225 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        a1 = v878;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          goto LABEL_491;
                      }
                      else
                      {
                        v225 = mDNSLogCategory_mDNS_redacted;
                        v227 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                        a1 = v878;
                        if (v227)
                        {
LABEL_491:
                          v228 = *(unsigned __int8 *)(v181 + 190);
                          GetRRDisplayString_rdb((unsigned __int8 *)(v181 + 8), (unsigned __int16 *)(*(_QWORD *)(v181 + 48) + 4), v855);
                          *(_DWORD *)v961 = 67110147;
                          *(_DWORD *)&v961[4] = v228;
                          v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(_QWORD *)&v961[10] = 1752392040;
                          *(_WORD *)&v961[18] = 2085;
                          *(_QWORD *)&v961[20] = v855;
                          LOBYTE(v25) = v868;
                          *(_WORD *)&v961[28] = 2082;
                          *(_QWORD *)&v961[30] = v825;
                          *(_WORD *)&v961[38] = 1024;
                          *(_DWORD *)&v961[40] = a10;
                          _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: ProbeCount %u; will deregister %{sensitive, mask.hash}s due to %{pu"
                            "blic}scast conflict via interface %d",
                            v961,
                            0x2Cu);
                        }
                      }
                      ++*v828;
                      goto LABEL_493;
                    }
                    v98 = v904;
                    if (*((_DWORD *)v858 + 2) >= *(_DWORD *)(v159 + 16) >> 1 || *(_BYTE *)(a1 + 141))
                    {
                      if (*(void **)(v159 + 208) == v16)
                      {
                        *(_QWORD *)(v159 + 208) = 0;
                        *(_BYTE *)(v159 + 195) = 0;
                      }
                    }
                    else
                    {
                      v229 = *(void **)(v159 + 208);
                      if (v229)
                      {
                        if (v229 == v16)
                          goto LABEL_445;
                        *(_QWORD *)(v159 + 208) = -1;
                      }
                      else
                      {
                        *(_QWORD *)(v159 + 208) = v16;
                      }
                      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64);
                    }
LABEL_445:
                    v160 = *(_QWORD *)(a1 + 12640);
                  }
                  else if (v864)
                  {
                    if (*(_BYTE *)(v159 + 8) != 2)
                      goto LABEL_445;
                    goto LABEL_307;
                  }
                  v159 = v160;
                  if (!v160)
                    break;
                  continue;
                }
              }
            }
            v23 = v858;
            if (v99)
              goto LABEL_505;
            v291 = v911;
            if (v911 == 1)
            {
              v16 = (void *)a10;
            }
            else
            {
              v16 = (void *)a10;
              v94 = v837;
              while (1)
              {
                v292 = *(unsigned __int16 *)(v291 + 12);
                if (v292 <= 0x20)
                {
                  switch(*(_WORD *)(v291 + 12))
                  {
                    case 0xC:
                      goto LABEL_654;
                    case 0xD:
                    case 0xE:
                    case 0x10:
                    case 0x11:
                    case 0x13:
                    case 0x14:
                      goto LABEL_658;
                    case 0xF:
                    case 0x12:
                    case 0x15:
                      goto LABEL_648;
                    default:
                      if (v292 != 2 && v292 != 5)
                        goto LABEL_658;
                      goto LABEL_654;
                  }
                }
                if (v292 == 33)
                {
                  v293 = (_BYTE *)(*(_QWORD *)(v291 + 48) + 10);
                  goto LABEL_656;
                }
                if (v292 == 36)
                  break;
                if (v292 == 39)
                {
LABEL_654:
                  v293 = (_BYTE *)(*(_QWORD *)(v291 + 48) + 4);
                  goto LABEL_656;
                }
LABEL_658:
                v291 = *(_QWORD *)(v291 + 112);
                if (v291 == 1)
                  goto LABEL_700;
              }
LABEL_648:
              v293 = (_BYTE *)(*(_QWORD *)(v291 + 48) + 6);
LABEL_656:
              if (*(_DWORD *)(v291 + 28) != *((_DWORD *)v858 + 4)
                || !SameDomainNameBytes(v293, *((_BYTE **)v858 + 4)))
              {
                goto LABEL_658;
              }
              v301 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                {
                  v302 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                  v303 = *((_QWORD *)v858 + 4);
                  if (v303)
                  {
                    v310 = (_BYTE *)*((_QWORD *)v858 + 4);
                    if (v303 == -256)
                    {
LABEL_707:
                      while (v310)
                      {
                        v311 = *v310;
                        if (v311 > 0x3F)
                          break;
                        if (!*v310)
                        {
                          v316 = (_WORD)v310 - v303 + 1;
                          goto LABEL_732;
                        }
                        v310 += v311 + 1;
                        if (v303 != -256)
                          goto LABEL_706;
                      }
                    }
                    else
                    {
LABEL_706:
                      if ((unint64_t)v310 < v303 + 256)
                        goto LABEL_707;
                    }
                    v316 = 257;
LABEL_732:
                    v317 = v316;
                  }
                  else
                  {
                    v317 = 0;
                  }
LABEL_733:
                  GetRRDisplayString_rdb((unsigned __int8 *)(v291 + 8), (unsigned __int16 *)(*(_QWORD *)(v291 + 48) + 4), v855);
                  *(_DWORD *)v961 = 141559555;
                  *(_QWORD *)&v961[4] = 1752392040;
                  *(_WORD *)&v961[12] = 2085;
                  *(_QWORD *)&v961[14] = v302;
                  *(_WORD *)&v961[22] = 2160;
                  *(_QWORD *)&v961[24] = 1752392040;
                  *(_WORD *)&v961[32] = 1040;
                  *(_DWORD *)&v961[34] = v317;
                  *(_WORD *)&v961[38] = 2101;
                  *(_QWORD *)&v961[40] = v303;
                  *(_WORD *)&v961[48] = 2160;
                  *(_QWORD *)&v961[50] = 1752392040;
                  *(_WORD *)&v961[58] = 2085;
                  *(_QWORD *)&v961[60] = v855;
                  _os_log_impl((void *)&_mh_execute_header, v301, OS_LOG_TYPE_DEBUG, "Found a matching entry in the CacheFlushRecords - new rrtype: %{sensitive, mask.hash}s, matched name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, description: %{sensitive, mask.hash}s", v961, 0x44u);
                  a1 = v878;
                  v23 = v858;
                  v98 = v904;
                }
              }
              else
              {
                v301 = mDNSLogCategory_Default_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                {
                  v302 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                  v303 = *((_QWORD *)v858 + 4);
                  if (v303)
                  {
                    v304 = (_BYTE *)*((_QWORD *)v858 + 4);
                    if (v303 == -256)
                    {
LABEL_681:
                      while (v304)
                      {
                        v305 = *v304;
                        if (v305 > 0x3F)
                          break;
                        if (!*v304)
                        {
                          v315 = (_WORD)v304 - v303 + 1;
                          goto LABEL_730;
                        }
                        v304 += v305 + 1;
                        if (v303 != -256)
                          goto LABEL_680;
                      }
                    }
                    else
                    {
LABEL_680:
                      if ((unint64_t)v304 < v303 + 256)
                        goto LABEL_681;
                    }
                    v315 = 257;
LABEL_730:
                    v317 = v315;
                  }
                  else
                  {
                    v317 = 0;
                  }
                  goto LABEL_733;
                }
              }
LABEL_505:
              v238 = (_BYTE *)*((_QWORD *)v23 + 4);
              v239 = &v910;
              do
              {
                v239 = (char **)*v239;
                if (!v239)
                  goto LABEL_525;
              }
              while (!SameDomainNameBytes((_BYTE *)v239 + 20, v238));
              v240 = CacheGroupForName(a1, *((_DWORD *)v23 + 4), *((_BYTE **)v23 + 4));
              if (!v240)
              {
LABEL_525:
                v847 = 0;
                v16 = (void *)a10;
                goto LABEL_526;
              }
              v847 = (uint64_t)v240;
              v241 = mDNSGetTSRForCacheGroup((uint64_t)v240);
              v242 = v241;
              if (!v241)
                goto LABEL_753;
              v243 = CheckTSRForResourceRecord((int *)v239 + 2, (uint64_t)(v241 + 1));
              if (v243 != 2)
              {
                if (v243 == -1)
                {
                  v244 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
                      v245 = *((_QWORD *)v858 + 4);
                      if (!v245)
                      {
                        v318 = 0;
                        goto LABEL_740;
                      }
                      v312 = (_BYTE *)*((_QWORD *)v858 + 4);
                      if (v245 == -256)
                        goto LABEL_718;
LABEL_715:
                      v313 = 257;
                      if ((unint64_t)v312 < v245 + 256 && v312)
                      {
                        do
                        {
                          v314 = *v312;
                          if (v314 > 0x3F)
                            break;
                          if (!*v312)
                          {
                            v313 = (_WORD)v312 - v245 + 1;
                            goto LABEL_739;
                          }
                          v312 += v314 + 1;
                          if (v245 != -256)
                            goto LABEL_715;
LABEL_718:
                          ;
                        }
                        while (v312);
                        v313 = 257;
                      }
LABEL_739:
                      v318 = v313;
                      goto LABEL_740;
                    }
                  }
                  else
                  {
                    v244 = mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                    {
                      v245 = *((_QWORD *)v858 + 4);
                      if (v245)
                      {
                        v246 = (_BYTE *)*((_QWORD *)v858 + 4);
                        if (v245 == -256)
                          goto LABEL_520;
LABEL_517:
                        v247 = 257;
                        if ((unint64_t)v246 < v245 + 256 && v246)
                        {
                          while (1)
                          {
                            v248 = *v246;
                            if (v248 > 0x3F)
                            {
LABEL_734:
                              v247 = 257;
                              break;
                            }
                            if (!*v246)
                            {
                              v247 = (_WORD)v246 - v245 + 1;
                              break;
                            }
                            v246 += v248 + 1;
                            if (v245 != -256)
                              goto LABEL_517;
LABEL_520:
                            if (!v246)
                              goto LABEL_734;
                          }
                        }
                        v318 = v247;
                      }
                      else
                      {
                        v318 = 0;
                      }
LABEL_740:
                      v319 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                      *(_DWORD *)v961 = 141559043;
                      *(_QWORD *)&v961[4] = 1752392040;
                      *(_WORD *)&v961[12] = 1040;
                      *(_DWORD *)&v961[14] = v318;
                      *(_WORD *)&v961[18] = 2101;
                      *(_QWORD *)&v961[20] = v245;
                      *(_WORD *)&v961[28] = 2082;
                      *(_QWORD *)&v961[30] = v319;
                      *(_WORD *)&v961[38] = 1024;
                      *(_DWORD *)&v961[40] = a10;
                      _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - flushing cache group %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface %d due to TSR conflict", v961, 0x2Cu);
                      v98 = v904;
                    }
                  }
                  v320 = *(_QWORD *)(v847 + 16);
                  if (v320)
                  {
                    while (2)
                    {
                      if (*(_WORD *)(v320 + 12) != 41)
                      {
                        mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v320);
                        v321 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_751;
                        }
                        else
                        {
                          v321 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_751:
                            v324 = *(_QWORD *)(v320 + 32);
                            GetRRDisplayString_rdb((unsigned __int8 *)(v320 + 8), (unsigned __int16 *)(*(_QWORD *)(v320 + 48) + 4), v855);
                            *(_DWORD *)v961 = 67109635;
                            *(_DWORD *)&v961[4] = v324;
                            v98 = v904;
                            *(_WORD *)&v961[8] = 2160;
                            *(_QWORD *)&v961[10] = 1752392040;
                            *(_WORD *)&v961[18] = 2085;
                            *(_QWORD *)&v961[20] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl((void *)&_mh_execute_header, v321, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - flushed interface %d %{sensitive, mask.hash}s", v961, 0x1Cu);
                          }
                        }
                      }
                      v320 = *(_QWORD *)v320;
                      if (!v320)
                        break;
                      continue;
                    }
                  }
                }
LABEL_753:
                v325 = *((_DWORD *)v239 + 2);
                if (v325 < 0x93A81)
                {
                  v326 = *((_DWORD *)v858 + 2);
                  *(_QWORD *)&v961[8] = 0;
                  *(_QWORD *)v961 = 0;
                  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v961);
                  v332 = *(_DWORD *)v961;
                  v333 = (uint64_t)v242;
                  if (v242)
                    goto LABEL_757;
                  CacheEntity = GetCacheEntity(v878, (_QWORD *)v847, v327, v328, v329, v330, v331, v108);
                  if (CacheEntity)
                  {
                    v333 = CacheEntity;
                    *(_QWORD *)(CacheEntity + 48) = CacheEntity + 152;
                    *(_DWORD *)(CacheEntity + 12) = 94371881;
                    *(_QWORD *)(CacheEntity + 40) = *(_QWORD *)(v847 + 32);
                    v335 = *(_DWORD *)(v847 + 8);
                    *(_DWORD *)(CacheEntity + 20) = 917518;
                    *(_DWORD *)(CacheEntity + 24) = v335;
                    AddCacheRecordToCacheGroup(v847, (_QWORD *)CacheEntity);
LABEL_757:
                    v336 = v332 - v325;
                    a1 = v878;
                    *(_DWORD *)(v333 + 80) = *(_DWORD *)(v878 + 64);
                    v337 = *(_DWORD *)(v333 + 16);
                    if (v337 <= v326)
                      v337 = v326;
                    *(_DWORD *)(v333 + 16) = v337;
                    v338 = *(_QWORD *)(v333 + 48);
                    a3 = v870;
                    if (v242 && v336 - *(_DWORD *)(v338 + 8) < 1)
                    {
                      v16 = (void *)a10;
                      v23 = v858;
                      v113 = v883;
                      v98 = v904;
                    }
                    else
                    {
                      *(_DWORD *)(v338 + 4) = 720362;
                      *(_DWORD *)(v338 + 8) = v336;
                      *(_DWORD *)(v338 + 12) = *((_DWORD *)v239 + 3);
                      *(_WORD *)(v338 + 16) = 0;
                      v339 = mDNSLogCategory_Default;
                      v98 = v904;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                        {
                          if (v242)
                            v340 = "Updated";
                          else
                            v340 = "Added";
LABEL_794:
                          GetRRDisplayString_rdb((unsigned __int8 *)(v333 + 8), (unsigned __int16 *)(*(_QWORD *)(v333 + 48) + 4), v855);
                          *(_DWORD *)v961 = 136315651;
                          *(_QWORD *)&v961[4] = v340;
                          *(_WORD *)&v961[12] = 2160;
                          *(_QWORD *)&v961[14] = 1752392040;
                          *(_WORD *)&v961[22] = 2085;
                          *(_QWORD *)&v961[24] = v855;
                          _os_log_impl((void *)&_mh_execute_header, v339, OS_LOG_TYPE_DEBUG, "AddOrUpdateTSRForCacheGroup: %s TSR %{sensitive, mask.hash}s", v961, 0x20u);
                        }
                      }
                      else
                      {
                        v339 = mDNSLogCategory_Default_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                        {
                          if (v242)
                            v340 = "Updated";
                          else
                            v340 = "Added";
                          goto LABEL_794;
                        }
                      }
                      a1 = v878;
                      v16 = (void *)a10;
                      v23 = v858;
LABEL_526:
                      v113 = v883;
                    }
                  }
                  else
                  {
                    v348 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      a1 = v878;
                      a3 = v870;
                      v16 = (void *)a10;
                      v23 = v858;
                      v113 = v883;
                      v98 = v904;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                        goto LABEL_527;
                      v349 = *(_QWORD *)(v847 + 32);
                      if (v349)
                      {
                        v350 = *(_BYTE **)(v847 + 32);
                        if (v349 == -256)
                        {
LABEL_816:
                          while (v350)
                          {
                            v352 = *v350;
                            if (v352 > 0x3F)
                              break;
                            if (!*v350)
                            {
                              LOWORD(v350) = (_WORD)v350 - v349 + 1;
                              goto LABEL_852;
                            }
                            v350 += v352 + 1;
                            if (v349 != -256)
                              goto LABEL_815;
                          }
                        }
                        else
                        {
LABEL_815:
                          if ((unint64_t)v350 < v349 + 256)
                            goto LABEL_816;
                        }
                        LOWORD(v350) = 257;
LABEL_852:
                        LODWORD(v350) = (unsigned __int16)v350;
                      }
                      else
                      {
                        LODWORD(v350) = 0;
                      }
                    }
                    else
                    {
                      v348 = mDNSLogCategory_Default_redacted;
                      a1 = v878;
                      a3 = v870;
                      v16 = (void *)a10;
                      v23 = v858;
                      v113 = v883;
                      v98 = v904;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                        goto LABEL_527;
                      v349 = *(_QWORD *)(v847 + 32);
                      if (v349)
                      {
                        v350 = *(_BYTE **)(v847 + 32);
                        if (v349 == -256)
                        {
LABEL_803:
                          while (v350)
                          {
                            v351 = *v350;
                            if (v351 > 0x3F)
                              break;
                            if (!*v350)
                            {
                              LOWORD(v350) = (_WORD)v350 - v349 + 1;
                              goto LABEL_850;
                            }
                            v350 += v351 + 1;
                            if (v349 != -256)
                              goto LABEL_802;
                          }
                        }
                        else
                        {
LABEL_802:
                          if ((unint64_t)v350 < v349 + 256)
                            goto LABEL_803;
                        }
                        LOWORD(v350) = 257;
LABEL_850:
                        LODWORD(v350) = (unsigned __int16)v350;
                      }
                      else
                      {
                        LODWORD(v350) = 0;
                      }
                    }
                    *(_DWORD *)v961 = 141558531;
                    *(_QWORD *)&v961[4] = 1752392040;
                    *(_WORD *)&v961[12] = 1040;
                    *(_DWORD *)&v961[14] = (_DWORD)v350;
                    *(_WORD *)&v961[18] = 2101;
                    *(_QWORD *)&v961[20] = v349;
                    _os_log_impl((void *)&_mh_execute_header, v348, OS_LOG_TYPE_ERROR, "AddOrUpdateTSRForCacheGroup: No cache record for new TSR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v961, 0x1Cu);
                  }
LABEL_527:
                  v94 = v837;
                  if (!*(_DWORD *)(a1 + 240))
                    goto LABEL_701;
                  v249 = *((_DWORD *)v23 + 4);
                  v842 = v249 % 0x1F3;
                  v250 = (uint64_t *)v847;
                  if (v847 || (v250 = CacheGroupForName(a1, v249, *((_BYTE **)v23 + 4))) != 0)
                  {
                    v848 = (uint64_t)v250;
                    v251 = (int8x8_t *)(v250 + 2);
                    v252 = (int8x8_t *)v250[2];
                    if (v252)
                    {
                      v253 = (_DWORD *)(a1 + 4 * v842 + 4264);
                      while (1)
                      {
                        v254 = *((_QWORD *)v858 + 6);
                        if (!v16
                          || v254 && (v255 = *(_QWORD *)(v254 + 24)) != 0 && (*(_WORD *)(v255 + 276) & 0x6000) == 0x2000)
                        {
                          v256 = v252[7];
                          if (v256)
                            v256 = *(int8x8_t *)(*(_QWORD *)&v256 + 24);
                          if (v254)
                            v254 = *(_QWORD *)(v254 + 24);
                          if (*(_QWORD *)&v256 != v254)
                            goto LABEL_634;
                        }
                        else if ((void *)v252[4] != v16)
                        {
                          goto LABEL_634;
                        }
                        v257 = v252 + 1;
                        v258 = *((_QWORD *)v858 + 7);
                        v259 = (uint64_t)v252[8];
                        if (resource_records_have_same_dnssec_rr_category(v258, v259)
                          && *((unsigned __int16 *)v858 + 2) == v252[1].u16[2]
                          && *((unsigned __int16 *)v858 + 3) == v252[1].u16[3]
                          && *((unsigned __int16 *)v858 + 6) == v252[2].u16[2]
                          && *((_DWORD *)v858 + 5) == v252[3].i32[1])
                        {
                          if (SameRDataBody((uint64_t)v858, (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                          {
                            v822 = v253;
                            v265 = *v858;
                            if ((*v858 & 0x10) != 0)
                            {
                              a1 = v878;
                              v98 = v904;
                              v266 = v834;
                              if (!*(_QWORD *)&v252[14] && v834 != &v252[14])
                              {
                                *v834 = (int8x8_t)v252;
                                v252[14] = (int8x8_t)1;
                                v266 = v252 + 14;
                              }
                              if ((v257->i8[0] & 0x10) == 0)
                              {
                                v275 = *(_QWORD *)(v878 + 192);
                                if (v275)
                                {
                                  do
                                  {
                                    if (RecordAnswersQuestion((uint64_t)&v252[1], 0, v275, v260, v261, v262, v263, v264))
                                      ++*(_DWORD *)(v275 + 236);
                                    v275 = *(_QWORD *)(v275 + 8);
                                  }
                                  while (v275);
                                  v265 = *v858;
                                }
                                v257->i8[0] = v265;
                              }
                            }
                            else
                            {
                              a1 = v878;
                              v98 = v904;
                              v266 = v834;
                            }
                            v834 = v266;
                            if (!SameRDataBody((uint64_t)v858, (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainNameCS))
                            {
                              v252[2].i32[0] = 0;
                              v252[10].i32[0] = *(_DWORD *)(a1 + 64);
                              v252[13].i8[4] = 4;
                              SetNextCacheCheckTimeForRecord(a1, (uint64_t)v252);
                              v276 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                v253 = v822;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                  goto LABEL_591;
                              }
                              else
                              {
                                v276 = mDNSLogCategory_Default_redacted;
                                v253 = v822;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_591:
                                  GetRRDisplayString_rdb((unsigned __int8 *)&v252[1], (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), v855);
                                  *(_DWORD *)v961 = 141558275;
                                  *(_QWORD *)&v961[4] = 1752392040;
                                  *(_WORD *)&v961[12] = 2085;
                                  *(_QWORD *)&v961[14] = v855;
                                  _os_log_impl((void *)&_mh_execute_header, v276, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change old: %{sensitive, mask.hash}s", v961, 0x16u);
                                }
                              }
                              v277 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                v16 = (void *)a10;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                  goto LABEL_597;
                              }
                              else
                              {
                                v277 = mDNSLogCategory_Default_redacted;
                                v16 = (void *)a10;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_597:
                                  GetRRDisplayString_rdb(v858, (unsigned __int16 *)(*((_QWORD *)v858 + 5) + 4), v855);
                                  *(_DWORD *)v961 = 141558275;
                                  *(_QWORD *)&v961[4] = 1752392040;
                                  *(_WORD *)&v961[12] = 2085;
                                  *(_QWORD *)&v961[14] = v855;
                                  LOBYTE(v25) = v868;
                                  _os_log_impl((void *)&_mh_execute_header, v277, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change new: %{sensitive, mask.hash}s", v961, 0x16u);
                                }
                              }
                              v278 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                  goto LABEL_633;
                                if (v252[12])
                                {
                                  v281 = v252[2].u32[0];
                                  if (v252[13].u8[4] > 3u)
                                  {
                                    if (v281 <= 0xA)
                                    {
                                      if (v281)
                                        v280 = 100;
                                      else
                                        v280 = 0;
                                    }
                                    else
                                    {
                                      v280 = 1000;
                                    }
                                  }
                                  else
                                  {
                                    v280 = (int)(1000 * v281) / 50;
                                  }
                                }
                                else
                                {
                                  v280 = 60000;
                                }
                              }
                              else
                              {
                                v278 = mDNSLogCategory_Default_redacted;
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_633;
                                if (v252[12])
                                {
                                  v279 = v252[2].u32[0];
                                  if (v252[13].u8[4] > 3u)
                                  {
                                    if (v279 <= 0xA)
                                    {
                                      if (v279)
                                        v280 = 100;
                                      else
                                        v280 = 0;
                                    }
                                    else
                                    {
                                      v280 = 1000;
                                    }
                                  }
                                  else
                                  {
                                    v280 = (int)(1000 * v279) / 50;
                                  }
                                }
                                else
                                {
                                  v280 = 60000;
                                }
                              }
                              v285 = *(_DWORD *)(a1 + 64);
                              v286 = v280 + v252[11].i32[0] - v285;
                              v287 = *v253 - v285;
                              v288 = *(_DWORD *)(a1 + 88) - v285;
                              *(_DWORD *)v961 = 67109888;
                              *(_DWORD *)&v961[4] = v286;
                              *(_WORD *)&v961[8] = 1024;
                              *(_DWORD *)&v961[10] = v842;
                              *(_WORD *)&v961[14] = 1024;
                              *(_DWORD *)&v961[16] = v287;
                              *(_WORD *)&v961[20] = 1024;
                              *(_DWORD *)&v961[22] = v288;
                              _os_log_impl((void *)&_mh_execute_header, v278, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change in %d slot %3d in %d %d", v961, 0x1Au);
                              goto LABEL_633;
                            }
                            v353 = *((_DWORD *)v858 + 2);
                            if (v353)
                            {
                              ++v828[19];
                              a3 = v870;
                              if (v252[1].i8[2] == 2 && !v252[10].i32[1])
                              {
                                v354 = *(_DWORD *)(a1 + 64);
                                if (v354 <= 1)
                                  v354 = 1;
                                v252[10].i32[1] = v354;
                              }
                              if (v353 == 4500 && v252[2].i32[0] == 4500)
                              {
                                if ((v355 = v252[4], AWDLInterfaceID) && AWDLInterfaceID == *(_QWORD *)&v355
                                  || WiFiAwareInterfaceID && WiFiAwareInterfaceID == *(_QWORD *)&v355)
                                {
                                  v356 = v252[1].u16[2];
                                  if (v356 == 33 || v356 == 28)
                                  {
                                    v357 = mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                        goto LABEL_870;
                                    }
                                    else
                                    {
                                      v357 = mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                      {
LABEL_870:
                                        GetRRDisplayString_rdb((unsigned __int8 *)&v252[1], (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), v855);
                                        v370 = v252[4];
                                        *(_DWORD *)v961 = 141558531;
                                        *(_QWORD *)&v961[4] = 1752392040;
                                        *(_WORD *)&v961[12] = 2085;
                                        *(_QWORD *)&v961[14] = v855;
                                        LOBYTE(v25) = v868;
                                        *(_WORD *)&v961[22] = 2048;
                                        *(int8x8_t *)&v961[24] = v370;
                                        _os_log_impl((void *)&_mh_execute_header, v357, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Keeping Standard TTL for %{sensitive, mask.hash}s %p", v961, 0x20u);
                                      }
                                    }
                                  }
                                }
                              }
                              a1 = v878;
                              RefreshCacheRecord(v878, v252, v353);
                              v16 = (void *)a10;
                              if (*(int8x8_t **)(v848 + 24) != v252)
                              {
                                while (1)
                                {
                                  v376 = v251;
                                  v251 = (int8x8_t *)*v251;
                                  if (!v251)
                                    break;
                                  if (v251 == v252)
                                  {
                                    *v376 = *v252;
                                    break;
                                  }
                                }
                                *v252 = 0;
                                AddCacheRecordToCacheGroup(v848, v252);
                              }
                              v377 = *((_WORD *)a2 + 1);
                              v252[13].i16[3] = v377;
                              v252[1].i8[1] = HIBYTE(v377) & 0xF;
                              if (a10)
                              {
LABEL_877:
                                if ((v257->i8[0] & 0x10) == 0)
                                {
                                  v300 = 0;
                                  goto LABEL_895;
                                }
                                v378 = *(_QWORD *)(v878 + 192);
                                if (v378)
                                {
                                  while (*(_QWORD *)(v378 + 40)
                                       || *(_BYTE *)(v378 + 632)
                                       || *(int *)(v378 + 212) < 1
                                       || !RecordAnswersQuestion((uint64_t)&v252[1], 0, v378, v371, v372, v373, v374, v375))
                                  {
                                    v378 = *(_QWORD *)(v378 + 8);
                                    if (!v378)
                                      goto LABEL_885;
                                  }
                                  v385 = *(_DWORD *)(v878 + 64);
                                  *(_DWORD *)(v378 + 256) = v385;
                                  *(_DWORD *)(v378 + 224) = 0;
                                  *(_DWORD *)(v378 + 208) = v385;
                                  *(_DWORD *)(v378 + 212) = 3600000;
                                  *(_BYTE *)(v378 + 352) = 0;
                                  *(_BYTE *)(v378 + 648) = 0;
LABEL_885:
                                  v94 = v837;
                                  v300 = 0;
                                  v16 = (void *)a10;
                                  goto LABEL_673;
                                }
                                v300 = 0;
LABEL_894:
                                v16 = (void *)a10;
LABEL_895:
                                v94 = v837;
LABEL_673:
                                if (v896 || !v252[2].i32[0] || v862 == 100 || v875 == 100)
                                  goto LABEL_674;
                                v252[16].i8[0] = 1;
                                v917[v862] = v252;
                                if (v875)
                                {
                                  v306 = v916;
                                  v307 = v875;
                                  while (!RecordInTheRRSet((uint64_t)&v252[1], (uint64_t)v306))
                                  {
                                    v306 += 3;
                                    if (!--v307)
                                      goto LABEL_693;
                                  }
                                }
                                else
                                {
LABEL_693:
                                  v306 = &v916[3 * v875];
                                  *v306 = v252[5];
                                  *((_DWORD *)v306 + 2) = v252[3].i32[0];
                                  v308 = v252[1].u16[2];
                                  if (v308 == 46)
                                    LOWORD(v308) = resource_record_as_rrsig_get_covered_type((uint64_t)&v252[1]);
                                  v309 = &v916[3 * v875];
                                  *((_WORD *)v309 + 8) = v308;
                                  ++v875;
                                  *((_DWORD *)v309 + 3) = 0;
                                  *((_BYTE *)v309 + 18) = 0;
                                }
                                a1 = v878;
                                v23 = v858;
                                ++v862;
                                ++*((_DWORD *)v306 + 3);
                                *((_BYTE *)v306 + 18) = v300;
                                v16 = (void *)a10;
                                v94 = v837;
                                v113 = v883;
                                v98 = v904;
LABEL_701:
                                *(_WORD *)v23 = 0;
                                *((_WORD *)v23 + 51) = 0;
                                v112 = (_QWORD *)*((_QWORD *)v23 + 7);
                                if (v112)
                                  goto LABEL_205;
LABEL_206:
                                if (++v93 < v113 && (unint64_t)v98 < a3)
                                  goto LABEL_171;
                                v836 = v94;
                                v29 = v910;
                                v91 = v875;
                                v90 = v859;
LABEL_908:
                                v860 = v90;
                                v875 = v91;
                                if (v29)
                                {
                                  do
                                  {
                                    v387 = *(char **)v29;
                                    free(v29);
                                    v29 = v387;
                                  }
                                  while (v387);
                                  v910 = 0;
                                }
                                if (!v896)
                                {
                                  if (v862 == 100 || v875 == 100)
                                  {
                                    v388 = mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                        goto LABEL_931;
                                    }
                                    else
                                    {
                                      v388 = mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                      {
LABEL_931:
                                        *(_DWORD *)v961 = 67109376;
                                        *(_DWORD *)&v961[4] = v862;
                                        *(_WORD *)&v961[8] = 1024;
                                        *(_DWORD *)&v961[10] = v875;
                                        _os_log_impl((void *)&_mh_execute_header, v388, OS_LOG_TYPE_FAULT, "Too many records contained in a single response - cached records: %u, record set: %u", v961, 0xEu);
                                      }
                                    }
                                  }
                                  if (v862)
                                  {
                                    for (k = 0; k != v862; ++k)
                                    {
                                      v396 = v917[k];
                                      if (v875)
                                      {
                                        v397 = 0;
                                        v398 = v916;
                                        while (!RecordInTheRRSet(v396 + 8, (uint64_t)v398))
                                        {
                                          ++v397;
                                          v398 += 3;
                                          if (v875 == v397)
                                            goto LABEL_938;
                                        }
                                        v409 = *(_QWORD *)(v396 + 64);
                                        if (v409)
                                        {
                                          v410 = &v916[3 * v397];
                                          *(_QWORD *)(v409 + 24) = *((unsigned int *)v410 + 3);
                                          *(_BYTE *)(v409 + 36) = *((_BYTE *)v410 + 18) != 0;
                                        }
                                      }
                                      else
                                      {
LABEL_938:
                                        v399 = mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled == 1
                                          && mDNSLogCategory_Default != mDNSLogCategory_State)
                                        {
                                          v399 = mDNSLogCategory_Default_redacted;
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))continue;
                                          v401 = *(_QWORD *)(v396 + 40);
                                          if (v401)
                                          {
                                            v406 = *(_BYTE **)(v396 + 40);
                                            if (v401 == -256)
                                              goto LABEL_960;
LABEL_957:
                                            v407 = 257;
                                            if ((unint64_t)v406 < v401 + 256 && v406)
                                            {
                                              while (1)
                                              {
                                                v408 = *v406;
                                                if (v408 > 0x3F)
                                                {
LABEL_970:
                                                  v407 = 257;
                                                  goto LABEL_974;
                                                }
                                                if (!*v406)
                                                  break;
                                                v406 += v408 + 1;
                                                if (v401 != -256)
                                                  goto LABEL_957;
LABEL_960:
                                                if (!v406)
                                                  goto LABEL_970;
                                              }
                                              v407 = (_WORD)v406 - v401 + 1;
                                            }
LABEL_974:
                                            v411 = v407;
                                          }
                                          else
                                          {
                                            v411 = 0;
                                          }
                                          goto LABEL_975;
                                        }
                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                        {
                                          v401 = *(_QWORD *)(v396 + 40);
                                          if (v401)
                                          {
                                            v402 = *(_BYTE **)(v396 + 40);
                                            if (v401 == -256)
                                              goto LABEL_949;
LABEL_946:
                                            v403 = 257;
                                            if ((unint64_t)v402 < v401 + 256 && v402)
                                            {
                                              while (1)
                                              {
                                                v404 = *v402;
                                                if (v404 > 0x3F)
                                                {
LABEL_969:
                                                  v403 = 257;
                                                  goto LABEL_972;
                                                }
                                                if (!*v402)
                                                  break;
                                                v402 += v404 + 1;
                                                if (v401 != -256)
                                                  goto LABEL_946;
LABEL_949:
                                                if (!v402)
                                                  goto LABEL_969;
                                              }
                                              v403 = (_WORD)v402 - v401 + 1;
                                            }
LABEL_972:
                                            v411 = v403;
                                          }
                                          else
                                          {
                                            v411 = 0;
                                          }
LABEL_975:
                                          v412 = DNSTypeName(*(unsigned __int16 *)(v396 + 12));
                                          *(_DWORD *)v961 = 141559043;
                                          *(_QWORD *)&v961[4] = 1752392040;
                                          *(_WORD *)&v961[12] = 1040;
                                          *(_DWORD *)&v961[14] = v411;
                                          *(_WORD *)&v961[18] = 2101;
                                          *(_QWORD *)&v961[20] = v401;
                                          *(_WORD *)&v961[28] = 2160;
                                          *(_QWORD *)&v961[30] = 1752392040;
                                          *(_WORD *)&v961[38] = 2085;
                                          *(_QWORD *)&v961[40] = v412;
                                          _os_log_impl((void *)&_mh_execute_header, v399, OS_LOG_TYPE_FAULT, "Answer set counter not found for the cached record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{sensitive, mask.hash}s.", v961, 0x30u);
                                        }
                                      }
                                    }
                                  }
                                }
                                if (v860)
                                {
                                  v16 = (void *)a10;
                                  a3 = v870;
                                  a2 = v900;
                                  DumpPacket(0, 0, (uint64_t)"N/A", v850, (unsigned __int16)a5, __src, a7, v900, v870, a10);
                                  a1 = v878;
                                }
                                else
                                {
                                  a1 = v878;
                                  a2 = v900;
                                  a3 = v870;
                                  v16 = (void *)a10;
                                }
                                v386 = v906;
                                v23 = v858;
                                v94 = v836;
LABEL_981:
                                *(_WORD *)v23 = 0;
                                *((_WORD *)v23 + 51) = 0;
                                v413 = (_QWORD *)*((_QWORD *)v23 + 7);
                                if (v413)
                                {
                                  ref_count_obj_release(v413);
                                  *((_QWORD *)v23 + 7) = 0;
                                }
                                v414 = v911;
                                v838 = v94;
                                if (v911 != 1)
                                {
                                  v908 = (_BYTE *)(a1 + 47032);
                                  v893 = bswap32(a5) >> 16;
                                  while (1)
                                  {
                                    v415 = *(_DWORD *)(v414 + 24);
                                    v416 = CacheGroupForName(a1, v415, *(_BYTE **)(v414 + 40));
                                    v911 = *(_QWORD *)(v911 + 112);
                                    *(_QWORD *)(v414 + 112) = 0;
                                    if (v416)
                                    {
                                      v423 = v416[2];
                                      if (v423 && v901 == 0)
                                        break;
                                    }
                                    v425 = 0;
LABEL_991:
                                    v386 = v906;
                                    if (!*(_DWORD *)(v414 + 84))
                                      goto LABEL_1110;
                                    if (*(_QWORD *)(v414 + 32))
                                    {
                                      v426 = CheckForSoonToExpireRecordsEx(a1, *(_BYTE **)(v414 + 40), *(_DWORD *)(v414 + 24), -1, -1);
                                      *(_DWORD *)(v414 + 84) = v426;
                                      if (v426)
                                        goto LABEL_1104;
                                    }
                                    else
                                    {
                                      v462 = v887;
                                      if (v425)
                                        v462 = 1;
                                      if ((v462 & 1) != 0)
                                      {
                                        if (*(_DWORD *)(a1 + 64) <= 1u)
                                          v426 = 1;
                                        else
                                          v426 = *(_DWORD *)(a1 + 64);
                                        *(_DWORD *)(v414 + 84) = v426;
LABEL_1104:
                                        v463 = a1 + 4 * (v415 % 0x1F3);
                                        if (*(_DWORD *)(v463 + 4264) - v426 >= 1)
                                          *(_DWORD *)(v463 + 4264) = v426;
                                        if (*(_DWORD *)(a1 + 88) - v426 >= 1)
                                          *(_DWORD *)(a1 + 88) = v426;
                                        goto LABEL_1110;
                                      }
                                      *(_DWORD *)(v414 + 84) = 0;
                                    }
                                    CacheRecordDeferredAdd((_QWORD *)a1, v414, v417, v418, v419, v420, v421, v422);
LABEL_1110:
                                    v414 = v911;
                                    a3 = v870;
                                    if (v911 == 1)
                                      goto LABEL_1111;
                                  }
                                  v425 = 0;
                                  while (2)
                                  {
                                    if (*(_BYTE *)(v423 + 109))
                                      goto LABEL_998;
                                    v427 = *(_QWORD *)(v414 + 32);
                                    if (v427 != *(_QWORD *)(v423 + 32))
                                      goto LABEL_998;
                                    if (!v427)
                                    {
                                      v434 = *(_QWORD *)(v414 + 56);
                                      if (v434)
                                        v434 = *(_QWORD *)(v434 + 24);
                                      v435 = *(_QWORD *)(v423 + 56);
                                      if (v435)
                                        v435 = *(_QWORD *)(v435 + 24);
                                      if (v434 != v435)
                                        goto LABEL_998;
                                    }
                                    v428 = *(unsigned __int16 *)(v414 + 12);
                                    if (v428 != *(unsigned __int16 *)(v423 + 12)
                                      || *(unsigned __int16 *)(v414 + 14) != *(unsigned __int16 *)(v423 + 14)
                                      || !resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v414 + 64), *(_QWORD *)(v423 + 64)))
                                    {
                                      goto LABEL_998;
                                    }
                                    if (v428 == 46)
                                    {
                                      covered_type = resource_record_as_rrsig_get_covered_type(v414 + 8);
                                      v35 = covered_type == resource_record_as_rrsig_get_covered_type(v423 + 8);
                                      a1 = v878;
                                      if (!v35)
                                      {
LABEL_1096:
                                        v16 = (void *)a10;
                                        goto LABEL_998;
                                      }
                                    }
                                    if (!*(_BYTE *)(v414 + 10) && *(_BYTE *)(v423 + 10))
                                      *(_BYTE *)(v414 + 10) = 1;
                                    v430 = *(_DWORD *)(a1 + 64);
                                    v431 = *(_DWORD *)(v423 + 80);
                                    v432 = v430 - v431;
                                    if ((int)(v430 - v431) <= 999)
                                    {
                                      v433 = *(_BYTE *)(v423 + 109)
                                           ? dword_100158E08 + 939524096
                                           : v431 + 1000 * *(_DWORD *)(v423 + 16);
                                      if ((int)(v433 - v430) >= 1001)
                                      {
                                        v436 = *(_DWORD *)(v423 + 16);
                                        v437 = *(_DWORD *)(v414 + 16);
                                        v94 = v838;
                                        if (v436 != v437 && v437 >= 2)
                                        {
                                          if (v436 == 240 && v437 == 60)
                                          {
                                            if (*(_WORD *)(v423 + 12) == 16)
                                              goto LABEL_1086;
LABEL_1061:
                                            if (!v896)
                                              goto LABEL_1086;
                                            goto LABEL_1062;
                                          }
                                          if (v436 != 120 || v437 != 4500)
                                            goto LABEL_1061;
                                          if (v896 && *(_WORD *)(v423 + 12) != 33)
                                          {
LABEL_1062:
                                            if (mDNSCoreReceiveResponse_lastLogWindowStartTime
                                              && v430 - mDNSCoreReceiveResponse_lastLogWindowStartTime < 0x36EE80)
                                            {
                                              v453 = mDNSCoreReceiveResponse_count;
                                            }
                                            else
                                            {
                                              v453 = 0;
                                              if (v430 <= 1)
                                                v454 = 1;
                                              else
                                                v454 = v430;
                                              mDNSCoreReceiveResponse_lastLogWindowStartTime = v454;
                                            }
                                            mDNSCoreReceiveResponse_count = v453 + 1;
                                            v455 = mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (v453 <= 0x63)
                                                v459 = OS_LOG_TYPE_INFO;
                                              else
                                                v459 = OS_LOG_TYPE_DEBUG;
                                              v885 = v459;
                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, v459))
                                                goto LABEL_1086;
                                              GetRRDisplayString_rdb((unsigned __int8 *)(v423 + 8), (unsigned __int16 *)(*(_QWORD *)(v423 + 48) + 4), v908);
                                              *(_DWORD *)v961 = 67110915;
                                              *(_DWORD *)&v961[4] = v436;
                                              *(_WORD *)&v961[8] = 1024;
                                              *(_DWORD *)&v961[10] = v437;
                                              *(_WORD *)&v961[14] = 2160;
                                              *(_QWORD *)&v961[16] = 1752392040;
                                              *(_WORD *)&v961[24] = 1045;
                                              *(_DWORD *)&v961[26] = 20;
                                              *(_WORD *)&v961[30] = 2101;
                                              *(_QWORD *)&v961[32] = v850;
                                              *(_WORD *)&v961[40] = 1024;
                                              *(_DWORD *)&v961[42] = v893;
                                              *(_WORD *)&v961[46] = 2160;
                                              *(_QWORD *)&v961[48] = 1752392040;
                                              *(_WORD *)&v961[56] = 2085;
                                              *(_QWORD *)&v961[58] = v908;
                                              v457 = v885;
                                              v458 = v455;
                                            }
                                            else
                                            {
                                              if (v453 <= 0x63)
                                                v456 = OS_LOG_TYPE_INFO;
                                              else
                                                v456 = OS_LOG_TYPE_DEBUG;
                                              v884 = mDNSLogCategory_Default_redacted;
                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, v456))goto LABEL_1086;
                                              GetRRDisplayString_rdb((unsigned __int8 *)(v423 + 8), (unsigned __int16 *)(*(_QWORD *)(v423 + 48) + 4), v908);
                                              *(_DWORD *)v961 = 67110915;
                                              *(_DWORD *)&v961[4] = v436;
                                              *(_WORD *)&v961[8] = 1024;
                                              *(_DWORD *)&v961[10] = v437;
                                              *(_WORD *)&v961[14] = 2160;
                                              *(_QWORD *)&v961[16] = 1752392040;
                                              *(_WORD *)&v961[24] = 1045;
                                              *(_DWORD *)&v961[26] = 20;
                                              *(_WORD *)&v961[30] = 2101;
                                              *(_QWORD *)&v961[32] = v850;
                                              *(_WORD *)&v961[40] = 1024;
                                              *(_DWORD *)&v961[42] = v893;
                                              *(_WORD *)&v961[46] = 2160;
                                              *(_QWORD *)&v961[48] = 1752392040;
                                              *(_WORD *)&v961[56] = 2085;
                                              *(_QWORD *)&v961[58] = v908;
                                              v457 = v456;
                                              v458 = v884;
                                            }
                                            _os_log_impl((void *)&_mh_execute_header, v458, v457, "Correcting TTL from %4u to %4u from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%u for records %{sensitive, mask.hash}s", v961, 0x42u);
                                          }
LABEL_1086:
                                          *(_DWORD *)(v423 + 16) = *(_DWORD *)(v414 + 16);
                                          v430 = *(_DWORD *)(v878 + 64);
                                        }
                                        *(_DWORD *)(v423 + 80) = v430;
                                        a1 = v878;
                                        SetNextCacheCheckTimeForRecord(v878, v423);
                                        a2 = v900;
                                        goto LABEL_1096;
                                      }
                                    }
                                    v438 = *(_QWORD *)(v423 + 32);
                                    if (v438)
                                    {
                                      if (AWDLInterfaceID && AWDLInterfaceID == v438
                                        || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v438)
                                      {
                                        v439 = mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled != 1
                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                        {
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(_BYTE *)(v423 + 109))
                                              v440 = dword_100158E08 + 939524096;
                                            else
                                              v440 = v431 + 1000 * *(_DWORD *)(v423 + 16);
LABEL_1090:
                                            v460 = v440 - v430;
                                            GetRRDisplayString_rdb((unsigned __int8 *)(v423 + 8), (unsigned __int16 *)(*(_QWORD *)(v423 + 48) + 4), v908);
                                            *(_DWORD *)v961 = 67109891;
                                            *(_DWORD *)&v961[4] = v432;
                                            *(_WORD *)&v961[8] = 1024;
                                            *(_DWORD *)&v961[10] = v460;
                                            *(_WORD *)&v961[14] = 2160;
                                            *(_QWORD *)&v961[16] = 1752392040;
                                            *(_WORD *)&v961[24] = 2085;
                                            *(_QWORD *)&v961[26] = v908;
                                            _os_log_impl((void *)&_mh_execute_header, v439, OS_LOG_TYPE_DEBUG, "Fast flushing AWDL cache record -- age: %d ticks, expire: %d ticks, record: %{sensitive, mask.hash}s", v961, 0x22u);
                                          }
                                        }
                                        else
                                        {
                                          v439 = mDNSLogCategory_Default_redacted;
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(_BYTE *)(v423 + 109))
                                              v440 = dword_100158E08 + 939524096;
                                            else
                                              v440 = v431 + 1000 * *(_DWORD *)(v423 + 16);
                                            goto LABEL_1090;
                                          }
                                        }
                                        a1 = v878;
                                        mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v423);
                                        a2 = v900;
                                        v16 = (void *)a10;
                                        v94 = v838;
                                        goto LABEL_998;
                                      }
                                      if (v430 == v431 && *(_DWORD *)(v423 + 16) == 1 && *(_BYTE *)(v423 + 108) == 4)
                                      {
                                        if (mDNS_LoggingEnabled == 1)
                                        {
                                          v445 = mDNSLogCategory_Default;
                                          GetRRDisplayString_rdb((unsigned __int8 *)(v423 + 8), (unsigned __int16 *)(*(_QWORD *)(v423 + 48) + 4), v908);
                                          v446 = v445;
                                          a1 = v878;
                                          LogMsgWithLevel(v446, OS_LOG_TYPE_DEFAULT, "Cache flush for DE record %s", v447, v448, v449, v450, v451, (int)v908);
                                        }
                                        *(_DWORD *)(v423 + 16) = 0;
                                        v16 = (void *)a10;
                                        v94 = v838;
                                      }
                                      else
                                      {
                                        if (*(_BYTE *)(v423 + 109))
                                          v452 = dword_100158E08 + 939524096;
                                        else
                                          v452 = v431 + 1000 * *(_DWORD *)(v423 + 16);
                                        v16 = (void *)a10;
                                        v94 = v838;
                                        if ((int)(v452 - v430) >= 1001)
                                        {
                                          *(_DWORD *)(v423 + 16) = 1;
                                          *(_BYTE *)(v423 + 108) = 4;
                                          *(_DWORD *)(v423 + 80) = v430 - 1;
                                        }
                                      }
                                      SetNextCacheCheckTimeForRecord(a1, v423);
                                      a2 = v900;
LABEL_998:
                                      v423 = *(_QWORD *)v423;
                                      if (!v423)
                                        goto LABEL_991;
                                      continue;
                                    }
                                    break;
                                  }
                                  a2 = v900;
                                  v94 = v838;
                                  if (!v896 && *(unsigned __int8 *)(v423 + 8) != 240)
                                  {
                                    if (v875)
                                    {
                                      v441 = 0;
                                      v442 = v916;
                                      while (!RecordInTheRRSet(v423 + 8, (uint64_t)v442))
                                      {
                                        ++v441;
                                        v442 += 3;
                                        if (v875 == v441)
                                          goto LABEL_1043;
                                      }
                                      v443 = *(_QWORD *)(v423 + 64);
                                      a1 = v878;
                                      if (v443)
                                      {
                                        v461 = &v916[3 * v441];
                                        *(_QWORD *)(v443 + 24) = *((unsigned int *)v461 + 3);
                                        v444 = *((_BYTE *)v461 + 18) != 0;
LABEL_1094:
                                        *(_BYTE *)(v443 + 36) = v444;
                                      }
                                    }
                                    else
                                    {
LABEL_1043:
                                      v443 = *(_QWORD *)(v423 + 64);
                                      a1 = v878;
                                      if (v443)
                                      {
                                        *(_QWORD *)(v443 + 24) = 0;
                                        v444 = 1;
                                        goto LABEL_1094;
                                      }
                                    }
                                  }
                                  mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v423);
                                  v425 = 1;
                                  goto LABEL_1096;
                                }
LABEL_1111:
                                if (!v896 && v862)
                                {
                                  v464 = v862;
                                  v465 = v917;
                                  do
                                  {
                                    v466 = *v465++;
                                    *(_BYTE *)(v466 + 128) = 0;
                                    --v464;
                                  }
                                  while (v464);
                                }
                                if (!v901)
                                {
                                  v912 = 0;
                                  v467 = IsResponseMDNSEquivalent(v386, (uint64_t)a9);
                                  v468 = 0;
                                  v869 = v467;
                                  if (v386 && !v467)
                                  {
                                    v469 = *(unsigned __int8 *)(*(_QWORD *)(v386 + 88) + 70);
                                    if ((v469 & 4) != 0)
                                      v468 = (v469 >> 1) & 1;
                                    else
                                      v468 = 0;
                                  }
                                  memset(v960, 0, sizeof(v960));
                                  memset(v959, 0, sizeof(v959));
                                  memset(v958, 0, sizeof(v958));
                                  memset(v957, 0, sizeof(v957));
                                  if (*((_WORD *)a2 + 2))
                                  {
                                    Question = a2 + 12;
                                    if ((unint64_t)(a2 + 12) < a3)
                                    {
                                      v471 = 0;
                                      NewCacheEntry = 0;
                                      v886 = 0;
                                      v472 = a3;
                                      v894 = 0;
                                      LOBYTE(v863) = 0;
                                      LOBYTE(v865) = 0;
                                      v877 = 0;
                                      v824 = a7;
                                      v861 = (_BYTE *)(a1 + 47032);
                                      v909 = v468;
                                      v849 = v468 ^ 1;
                                      v473 = a1 + 37912;
                                      v889 = (uint64_t *)(a1 + 37968);
                                      v845 = a1 + 37912;
                                      while (1)
                                      {
                                        bzero(v949, 0x2B8uLL);
                                        Question = getQuestion((unint64_t)a2, Question, v472, (uint64_t)v16, v949);
                                        if (Question)
                                        {
                                          if (v386)
                                          {
                                            DNSQuestion = Querier_GetDNSQuestion(v386, 0);
                                            v851 = DNSQuestion == 0;
                                            v475 = v909;
                                            v827 = v471;
                                            v902 = DNSQuestion;
                                            if (DNSQuestion)
                                              v829 = bswap32(*(unsigned __int16 *)(DNSQuestion + 340)) >> 16;
                                            else
                                              v829 = 0;
                                            v477 = v950;
                                            v831 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v386 + 16) + 96))(v386);
                                            v839 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v386 + 16) + 88))(v386);
LABEL_1132:
                                            bzero(v934, 0xB00uLL);
                                            v843 = Question;
                                            if (v475)
                                            {
                                              for (m = v955; ; m += v479 + 1)
                                              {
                                                if (m >= v956)
                                                  goto LABEL_1142;
                                                if (!m)
                                                  goto LABEL_1142;
                                                v479 = *m;
                                                if (v479 > 0x3F)
                                                  goto LABEL_1142;
                                                if (!*m)
                                                  break;
                                              }
                                              v481 = (_WORD)m - (unsigned __int16)v955 + 1;
                                              if (v481 <= 0x100u)
                                                memcpy(v934, v955, v481);
LABEL_1142:
                                              v482 = *((unsigned __int16 *)a2 + 3);
                                              if (*((_WORD *)a2 + 3))
                                              {
                                                v483 = LocateAnswers((unint64_t)a2, v870);
                                                if (v483)
                                                {
                                                  v484 = v483;
                                                  bzero(v961, 0x2C00uLL);
                                                  v485 = 0;
                                                  v486 = 0;
                                                  while ((unint64_t)v484 < v870 && v486 < 0x16)
                                                  {
                                                    v484 = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)a2, v484, v870, a10, 160, (uint64_t)mDNSStorage + &loc_100009418);
                                                    v487 = *((unsigned __int8 *)&dword_100158DD0
                                                           + &loc_100009418) != 240
                                                        && *(_WORD *)&byte_100158DD4[&loc_100009418] == 5;
                                                    if (!v487
                                                      || !*(_BYTE *)qword_100162208
                                                      || SameDomainNameBytes((_BYTE *)qword_100162208, (_BYTE *)(qword_100162210 + 4)))
                                                    {
                                                      goto LABEL_1175;
                                                    }
                                                    v488 = (_BYTE *)qword_100162208;
                                                    if (qword_100162208 == -256)
                                                    {
                                                      while (1)
                                                      {
LABEL_1156:
                                                        if (!v488)
                                                          goto LABEL_1163;
                                                        v489 = *v488;
                                                        if (v489 > 0x3F)
                                                          goto LABEL_1163;
                                                        if (!*v488)
                                                          break;
                                                        v488 += v489 + 1;
                                                        if (qword_100162208 != -256)
                                                          goto LABEL_1155;
                                                      }
                                                      v490 = (_WORD)v488 - qword_100162208 + 1;
                                                      if (v490 <= 0x100u)
                                                      {
                                                        memcpy(&v961[512 * v486], (const void *)qword_100162208, v490);
                                                        goto LABEL_1164;
                                                      }
                                                    }
                                                    else
                                                    {
LABEL_1155:
                                                      if ((unint64_t)v488 < qword_100162208 + 256)
                                                        goto LABEL_1156;
                                                    }
LABEL_1163:
                                                    v961[512 * v486] = 0;
LABEL_1164:
                                                    v491 = (const void *)(qword_100162210 + 4);
                                                    v492 = (_BYTE *)(qword_100162210 + 4);
                                                    if (qword_100162210 != -260)
                                                    {
LABEL_1165:
                                                      if ((unint64_t)v492 < qword_100162210 + 260)
                                                        goto LABEL_1166;
LABEL_1173:
                                                      v968[512 * v486 + 31] = 0;
                                                      goto LABEL_1174;
                                                    }
                                                    while (1)
                                                    {
LABEL_1166:
                                                      if (!v492)
                                                        goto LABEL_1173;
                                                      v493 = *v492;
                                                      if (v493 > 0x3F)
                                                        goto LABEL_1173;
                                                      if (!*v492)
                                                        break;
                                                      v492 += v493 + 1;
                                                      if (qword_100162210 != -260)
                                                        goto LABEL_1165;
                                                    }
                                                    v494 = (_WORD)v492 - (_WORD)v491 + 1;
                                                    if (v494 > 0x100u)
                                                      goto LABEL_1173;
                                                    memcpy(&v968[512 * v486 + 31], v491, v494);
LABEL_1174:
                                                    ++v486;
LABEL_1175:
                                                    WORD4(xmmword_1001621E0) = 0;
                                                    HIWORD(xmmword_100162240) = 0;
                                                    if ((_QWORD)xmmword_100162220)
                                                    {
                                                      ref_count_obj_release((_QWORD *)xmmword_100162220);
                                                      *(_QWORD *)&xmmword_100162220 = 0;
                                                    }
                                                    if (++v485 == v482)
                                                      break;
                                                  }
                                                  v495 = 1;
                                                  v496 = v955;
                                                  v16 = (void *)a10;
                                                  while (2)
                                                  {
                                                    if (!v486 || v495 > v486)
                                                      goto LABEL_1198;
                                                    v497 = 0;
                                                    v498 = v961;
                                                    while (!*v498 || !SameDomainNameBytes(v496, v498))
                                                    {
                                                      ++v497;
                                                      v498 += 512;
                                                      if (v486 == v497)
                                                        goto LABEL_1198;
                                                    }
                                                    v499 = &v961[512 * v497];
                                                    *v498 = 0;
                                                    v496 = v499 + 256;
                                                    if (v499 == (_BYTE *)-256)
                                                    {
LABEL_1198:
                                                      v475 = v909;
                                                      goto LABEL_1200;
                                                    }
                                                    v500 = v499 + 512;
                                                    v501 = v499 + 256;
                                                    if (v496 != (_BYTE *)-256)
                                                    {
LABEL_1188:
                                                      if (v501 < v500)
                                                        goto LABEL_1189;
                                                      goto LABEL_1196;
                                                    }
                                                    while (1)
                                                    {
LABEL_1189:
                                                      if (!v501)
                                                        goto LABEL_1196;
                                                      v502 = *v501;
                                                      if (v502 > 0x3F)
                                                        goto LABEL_1196;
                                                      if (!*v501)
                                                        break;
                                                      v501 += v502 + 1;
                                                      if (v496 != (_BYTE *)-256)
                                                        goto LABEL_1188;
                                                    }
                                                    v503 = (_WORD)v501 - (_WORD)v496 + 1;
                                                    if (v503 > 0x100u)
LABEL_1196:
                                                      v934[256 * v495] = 0;
                                                    else
                                                      memcpy(&v934[256 * v495], v496, v503);
                                                    if (++v495 == 11)
                                                      goto LABEL_1198;
                                                    continue;
                                                  }
                                                }
                                              }
                                              LODWORD(v495) = 1;
LABEL_1200:
                                              v856 = v495;
                                              v480 = v934;
                                              v477 = DomainNameHashValue((unint64_t)v934);
                                            }
                                            else
                                            {
                                              v856 = 1;
                                              v480 = v955;
                                            }
                                            v504 = 0;
                                            v881 = 0;
                                            while (2)
                                            {
                                              v505 = CacheGroupForName(a1, v477, v480);
                                              v511 = v505;
                                              if (v475)
                                              {
                                                v512 = *((unsigned __int16 *)a2 + 3);
                                                v933 = 0u;
                                                v932 = 0u;
                                                v931 = 0u;
                                                v930 = 0u;
                                                v929 = 0u;
                                                v928 = 0u;
                                                v927 = 0u;
                                                v926 = 0u;
                                                v925 = 0u;
                                                v924 = 0u;
                                                v923 = 0u;
                                                v922 = 0u;
                                                v921 = 0u;
                                                v920 = 0u;
                                                v919 = 0u;
                                                __dst = 0u;
                                                if (v512)
                                                {
                                                  if (!v505)
                                                    goto LABEL_1272;
                                                  v513 = v505[2];
                                                  if (!v513)
                                                    goto LABEL_1272;
                                                  v899 = 0;
                                                  v514 = 0;
                                                  v897 = 3601;
                                                  while (2)
                                                  {
                                                    if (v906)
                                                    {
                                                      v515 = *(_QWORD **)(v513 + 56);
                                                      if (v515)
                                                        v515 = (_QWORD *)v515[3];
                                                      if (v515 == a9 && Client_SameNameCacheRecordIsAnswer(v513, v906))
                                                      {
LABEL_1215:
                                                        if (*(unsigned __int8 *)(v513 + 8) != 240)
                                                        {
                                                          v897 = *(_DWORD *)(v513 + 16);
                                                          v516 = *(unsigned __int16 *)(v513 + 12);
                                                          if (v516 == 46)
                                                          {
                                                            if (!resource_record_as_rrsig_covers_wildcard_rr(v513 + 8))
                                                              goto LABEL_1272;
                                                            v517 = v513 + 8;
                                                            if (v899)
                                                            {
                                                              if (resource_record_as_rrsig_get_covered_type(v517) != v899)
                                                                goto LABEL_1272;
                                                              v518 = *(_BYTE **)(v513 + 40);
                                                              v519 = v518;
                                                              if (v518 == (_BYTE *)-256)
                                                              {
LABEL_1222:
                                                                while (v519)
                                                                {
                                                                  v520 = *v519;
                                                                  if (v520 > 0x3F)
                                                                    break;
                                                                  if (!*v519)
                                                                    goto LABEL_1238;
                                                                  v519 += v520 + 1;
                                                                  if (v518 != (_BYTE *)-256)
                                                                    goto LABEL_1221;
                                                                }
                                                              }
                                                              else
                                                              {
LABEL_1221:
                                                                if (v519 < v518 + 256)
                                                                  goto LABEL_1222;
                                                              }
                                                              goto LABEL_1240;
                                                            }
                                                            v521 = resource_record_as_rrsig_get_covered_type(v517);
                                                            v518 = *(_BYTE **)(v513 + 40);
                                                            v519 = v518;
                                                            v899 = v521;
                                                            if (v518 != (_BYTE *)-256)
                                                            {
LABEL_1232:
                                                              if (v519 < v518 + 256)
                                                                goto LABEL_1233;
                                                              goto LABEL_1240;
                                                            }
                                                            while (1)
                                                            {
LABEL_1233:
                                                              if (!v519)
                                                                goto LABEL_1240;
                                                              v522 = *v519;
                                                              if (v522 > 0x3F)
                                                                goto LABEL_1240;
                                                              if (!*v519)
                                                                break;
                                                              v519 += v522 + 1;
                                                              if (v518 != (_BYTE *)-256)
                                                                goto LABEL_1232;
                                                            }
LABEL_1238:
                                                            v523 = (_WORD)v519 - (_WORD)v518 + 1;
                                                            if (v523 > 0x100u)
LABEL_1240:
                                                              LOBYTE(__dst) = 0;
                                                            else
                                                              memcpy(&__dst, v518, v523);
                                                            v514 = 1;
                                                          }
                                                          else if (v899)
                                                          {
                                                            if (v516 != v899)
                                                              goto LABEL_1272;
                                                          }
                                                          else
                                                          {
                                                            v899 = *(_WORD *)(v513 + 12);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    else if (SameNameRecordAnswersQuestion((unsigned __int8 *)(v513 + 8), 0, v902, v506, v507, v508, v509, v510))
                                                    {
                                                      goto LABEL_1215;
                                                    }
                                                    v513 = *(_QWORD *)v513;
                                                    if (v513)
                                                      continue;
                                                    break;
                                                  }
                                                  if (v514)
                                                  {
                                                    v873 = 0;
                                                    v475 = 1;
                                                    goto LABEL_1273;
                                                  }
LABEL_1272:
                                                  v475 = 0;
                                                  v899 = 0;
                                                  v897 = 0;
                                                  v873 = 1;
LABEL_1273:
                                                  v16 = (void *)a10;
                                                  if (!v511)
                                                  {
LABEL_1274:
                                                    v529 = 1;
LABEL_1276:
                                                    v386 = v906;
                                                    if (!v16)
                                                      goto LABEL_1282;
LABEL_1286:
                                                    if (!v529)
                                                      goto LABEL_1867;
                                                    v532 = v953 == 6 && SameDomainNameBytes(v955, "\x05local") != 0;
                                                    if ((v532 & v849) != 0)
                                                      v544 = 86400;
                                                    else
                                                      v544 = 60;
                                                    if (*((_WORD *)a2 + 4))
                                                    {
                                                      Authorities = LocateAuthorities((unint64_t)a2, v870);
                                                      if (Authorities)
                                                      {
                                                        v843 = GetLargeResourceRecord(a1, (unint64_t)a2, Authorities, v870, (uint64_t)v16, 160, v473);
                                                        if (!v843 || *v858 == 240 || *((_WORD *)v858 + 2) != 6)
                                                          goto LABEL_1377;
                                                        v546 = CacheGroupForName(a1, *((_DWORD *)v858 + 4), *((_BYTE **)v858 + 4));
                                                        v548 = *(_DWORD *)(*((_QWORD *)v858 + 5) + 532);
                                                        if (v548 > *((_DWORD *)v858 + 2) && **((_BYTE **)v858 + 4))
                                                          v548 = *((_DWORD *)v858 + 2);
                                                        if (v544 <= v548)
                                                          v544 = v548;
                                                        NewCacheEntry = CreateNewCacheEntryEx(a1, *((_DWORD *)v858 + 4) % 0x1F3u, (uint64_t)v546, 1, 0, 0, 0, v547);
                                                        if (!v851)
                                                        {
                                                          if (*(_BYTE *)(v902 + 652))
                                                            goto LABEL_1377;
                                                        }
                                                        v549 = v909;
                                                        if (v953 != 6)
                                                          v549 = 1;
                                                        if ((v549 & 1) != 0)
                                                          goto LABEL_1377;
                                                        v550 = v955[0];
                                                        if (v955[0])
                                                        {
                                                          v551 = 0;
                                                          v552 = v955;
                                                          do
                                                          {
                                                            ++v551;
                                                            v553 = &v552[v550];
                                                            v554 = v553[1];
                                                            v552 = v553 + 1;
                                                            v550 = v554;
                                                          }
                                                          while (v554);
                                                        }
                                                        else
                                                        {
                                                          v551 = 0;
                                                        }
                                                        v570 = (unsigned __int8 *)*((_QWORD *)v858 + 4);
                                                        v571 = *v570;
                                                        if (*v570)
                                                        {
                                                          v572 = 0;
                                                          v573 = *((_QWORD *)v858 + 4);
                                                          do
                                                          {
                                                            ++v572;
                                                            v574 = v573 + v571;
                                                            v575 = *(unsigned __int8 *)(v574 + 1);
                                                            v573 = v574 + 1;
                                                            v571 = v575;
                                                          }
                                                          while (v575);
                                                        }
                                                        else
                                                        {
                                                          v572 = 0;
                                                        }
                                                        v555 = v551 - 1 - v572;
                                                        if (v551 - 1 <= v572)
                                                        {
LABEL_1377:
                                                          v555 = 0;
                                                        }
                                                        else
                                                        {
                                                          v576 = v551 - v572;
                                                          v577 = v955;
                                                          if (v576 >= 1)
                                                          {
                                                            v578 = v576 + 1;
                                                            v577 = v955;
                                                            do
                                                            {
                                                              if (!*v577)
                                                                break;
                                                              v577 += *v577 + 1;
                                                              --v578;
                                                            }
                                                            while (v578 > 1);
                                                          }
                                                          if (!SameDomainNameBytes(v577, v570))
                                                            v555 = 0;
                                                        }
                                                        *(_WORD *)v858 = 0;
                                                        *((_WORD *)v858 + 51) = 0;
                                                        v579 = (_QWORD *)*((_QWORD *)v858 + 7);
                                                        if (v579)
                                                        {
                                                          ref_count_obj_release(v579);
                                                          *((_QWORD *)v858 + 7) = 0;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v555 = 0;
                                                        v843 = 0;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v555 = 0;
                                                    }
                                                    if (v504)
                                                    {
                                                      if (v544 <= 2 * v504[2].i32[0])
                                                        v580 = 2 * v504[2].i32[0];
                                                      else
                                                        v580 = v544;
                                                      if (v580 >= 0xE10)
                                                        v544 = 3600;
                                                      else
                                                        v544 = v580;
                                                    }
                                                    if (v544 >= 0x189374)
                                                      v581 = 1610612;
                                                    else
                                                      v581 = v544;
                                                    v582 = v581 + (v581 >> 2) + 2;
                                                    if (v582 <= 0xF)
                                                      v583 = 15;
                                                    else
                                                      v583 = v582;
                                                    v584 = v909;
                                                    if (v894)
                                                      v584 = 0;
                                                    if (v584 == 1)
                                                    {
                                                      v853 = v583;
                                                      v912 = 0;
                                                      v891 = *((unsigned __int16 *)a2 + 4);
                                                      if (*((_WORD *)a2 + 4))
                                                      {
                                                        v585 = v870;
                                                        v586 = LocateAuthorities((unint64_t)a2, v870);
                                                        v877 = 0;
                                                        v895 = 3601;
                                                        LOBYTE(v865) = 0;
                                                        if (v586)
                                                        {
                                                          v587 = v586;
                                                          LOBYTE(v863) = 0;
                                                          if ((unint64_t)v586 < v870)
                                                          {
                                                            v877 = 0;
                                                            v863 = 0;
                                                            v865 = 0;
                                                            v588 = 0;
                                                            v913 = 0;
                                                            v895 = 3601;
                                                            do
                                                            {
                                                              v589 = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)v900, v587, v585, (uint64_t)v16, 160, (uint64_t)mDNSStorage+ &loc_100009418);
                                                              v587 = v589;
                                                              if (*((unsigned __int8 *)&dword_100158DD0
                                                                   + &loc_100009418) != 240)
                                                              {
                                                                v590 = xmmword_1001621F0;
                                                                if ((_DWORD)xmmword_1001621F0 == 3601)
                                                                  v591 = 3600;
                                                                else
                                                                  v591 = xmmword_1001621F0;
                                                                if (v895 < xmmword_1001621F0)
                                                                  v590 = v895;
                                                                if (v895 == 3601)
                                                                  v590 = v591;
                                                                v895 = v590;
                                                                if (WORD6(xmmword_1001621E0) > 0x2Eu)
                                                                {
                                                                  if (WORD6(xmmword_1001621E0) == 47)
                                                                  {
                                                                    if (v865 != 10)
                                                                    {
                                                                      v841 = v589;
                                                                      v627 = (unsigned __int8 *)qword_100162208;
                                                                      v628 = WORD2(xmmword_1001621F0);
                                                                      LODWORD(v973[0]) = 0;
                                                                      if (WORD2(xmmword_1001621F0) <= 3uLL)
                                                                      {
                                                                        v677 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          v587 = v589;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524;
                                                                        }
                                                                        else
                                                                        {
                                                                          v677 = mDNSLogCategory_Default_redacted;
                                                                          v587 = v589;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1524;
                                                                        }
                                                                        *(_DWORD *)v961 = 136447234;
                                                                        *(_QWORD *)&v961[4] = "rdata_len >= min_rdata_len_nsec";
                                                                        *(_WORD *)&v961[12] = 2082;
                                                                        *(_QWORD *)&v961[14] = "";
                                                                        *(_WORD *)&v961[22] = 2082;
                                                                        *(_QWORD *)&v961[24] = "/Library/Caches/com.apple"
                                                                                               ".xbs/Sources/mDNSResponde"
                                                                                               "r/mDNSShared/dns_objects/"
                                                                                               "utilities/rdata_parser.c";
                                                                        *(_WORD *)&v961[32] = 1024;
                                                                        *(_DWORD *)&v961[34] = 233;
                                                                        *(_WORD *)&v961[38] = 2048;
                                                                        *(_QWORD *)&v961[40] = 0;
                                                                        v673 = v677;
                                                                      }
                                                                      else
                                                                      {
                                                                        v629 = (const void *)(qword_100162210 + 4);
                                                                        v630 = *(unsigned __int8 *)(qword_100162210 + 4);
                                                                        v631 = qword_100162210 + 4;
                                                                        if (*(_BYTE *)(qword_100162210 + 4))
                                                                        {
                                                                          v632 = (unint64_t)v629
                                                                               + WORD2(xmmword_1001621F0);
                                                                          v633 = *(unsigned __int8 *)(qword_100162210 + 4);
                                                                          v631 = qword_100162210 + 4;
                                                                          while (!v632
                                                                               || v631 + (unint64_t)v633 + 1 <= v632)
                                                                          {
                                                                            v634 = v633 + v631;
                                                                            v635 = *(unsigned __int8 *)(v634 + 1);
                                                                            v631 = v634 + 1;
                                                                            v633 = v635;
                                                                            if (!v635)
                                                                              goto LABEL_1459;
                                                                          }
LABEL_1481:
                                                                          v653 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            v585 = v870;
                                                                            v587 = v589;
                                                                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                                                            {
                                                                              goto LABEL_1522;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            v653 = mDNSLogCategory_Default_redacted;
                                                                            v672 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            v585 = v870;
                                                                            v587 = v841;
                                                                            if (v672)
                                                                            {
LABEL_1522:
                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(_QWORD *)&v961[4] = "next_domain_name_len >= 1";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(_QWORD *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 238;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(_QWORD *)&v961[40] = 0;
                                                                              v673 = v653;
                                                                              goto LABEL_1523;
                                                                            }
                                                                          }
LABEL_1524:
                                                                          v642 = 0;
                                                                          v648 = -6705;
LABEL_1525:
                                                                          v913 = v648;
                                                                          goto LABEL_1526;
                                                                        }
LABEL_1459:
                                                                        v636 = v631 - (_QWORD)v629;
                                                                        v80 = __CFADD__(v636, 1);
                                                                        v637 = v636 + 1;
                                                                        if (v80)
                                                                          goto LABEL_1481;
                                                                        if (v637 >= WORD2(xmmword_1001621F0))
                                                                        {
                                                                          v679 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            v585 = v870;
                                                                            v587 = v589;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524;
                                                                          }
                                                                          else
                                                                          {
                                                                            v679 = mDNSLogCategory_Default_redacted;
                                                                            v585 = v870;
                                                                            v587 = v589;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1524;
                                                                          }
                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(_QWORD *)&v961[4] = "next_domain_name_len < rdata_len";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(_QWORD *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(_QWORD *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 240;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(_QWORD *)&v961[40] = 0;
                                                                          v673 = v679;
                                                                        }
                                                                        else
                                                                        {
                                                                          v638 = qword_100162210 + 4;
                                                                          if (*(_BYTE *)(qword_100162210 + 4))
                                                                          {
                                                                            do
                                                                            {
                                                                              v639 = v638 + v630;
                                                                              v640 = *(unsigned __int8 *)(v639 + 1);
                                                                              v638 = v639 + 1;
                                                                              v630 = v640;
                                                                            }
                                                                            while (v640);
                                                                          }
                                                                          if (type_bit_maps_check_length(v638 + 1, (unsigned __int16)(~(v638 - (_WORD)v629)+ WORD2(xmmword_1001621F0))))
                                                                          {
                                                                            v641 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
                                                                            if (!v641)
                                                                              goto LABEL_1999;
                                                                            v642 = (uint64_t)v641;
                                                                            v643 = &_dnssec_obj_rr_nsec_kind;
                                                                            v641[1] = &_dnssec_obj_rr_nsec_kind;
                                                                            do
                                                                            {
                                                                              v644 = (void (*)(uint64_t))v643[2];
                                                                              if (v644)
                                                                                v644(v642);
                                                                              v643 = (_UNKNOWN **)*v643;
                                                                            }
                                                                            while (v643);
                                                                            ++*(_DWORD *)v642;
                                                                            dnssec_obj_rr_init_fields(v642, v627, 47, 1, v629, v628, 1, 0, (int *)v973);
                                                                            v645 = v973[0];
                                                                            if (LODWORD(v973[0]))
                                                                            {
                                                                              a1 = v878;
                                                                              v585 = v870;
                                                                              v587 = v841;
                                                                            }
                                                                            else
                                                                            {
                                                                              v646 = dnssec_obj_domain_name_create_with_labels(*(unsigned __int8 **)(v642 + 24), 0, (int *)v973);
                                                                              *(_QWORD *)(v642 + 80) = v646;
                                                                              v645 = v973[0];
                                                                              a1 = v878;
                                                                              v585 = v870;
                                                                              v587 = v841;
                                                                              if (!LODWORD(v973[0]))
                                                                              {
                                                                                v647 = ref_count_obj_compare(*(_QWORD *)(v642 + 16), (uint64_t)v646, 0);
                                                                                v648 = 0;
                                                                                *(_BYTE *)(v642 + 88) = v647 < 2;
                                                                                goto LABEL_1525;
                                                                              }
                                                                            }
                                                                            v913 = v645;
                                                                            ref_count_obj_release((_QWORD *)v642);
                                                                            v642 = 0;
                                                                            v648 = v913;
LABEL_1526:
                                                                            *((_QWORD *)v959 + v865) = v642;
                                                                            if (v648)
                                                                              v674 = v865;
                                                                            else
                                                                              v674 = v865 + 1;
                                                                            v865 = v674;
                                                                            goto LABEL_1613;
                                                                          }
                                                                          v680 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            v585 = v870;
                                                                            v587 = v841;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524;
                                                                          }
                                                                          else
                                                                          {
                                                                            v680 = mDNSLogCategory_Default_redacted;
                                                                            v690 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            v585 = v870;
                                                                            v587 = v841;
                                                                            if (!v690)
                                                                              goto LABEL_1524;
                                                                          }
                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(_QWORD *)&v961[4] = "type_bit_maps_is_valid";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(_QWORD *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(_QWORD *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 246;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(_QWORD *)&v961[40] = 0;
                                                                          v673 = v680;
                                                                        }
                                                                      }
LABEL_1523:
                                                                      _os_log_impl((void *)&_mh_execute_header, v673, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v961, 0x30u);
                                                                      goto LABEL_1524;
                                                                    }
                                                                    v865 = 10;
                                                                  }
                                                                  else if (WORD6(xmmword_1001621E0) == 50)
                                                                  {
                                                                    if (v863 != 10)
                                                                    {
                                                                      v604 = qword_100162208;
                                                                      v605 = qword_100162210;
                                                                      v914 = 0;
                                                                      v606 = *(unsigned __int8 *)qword_100162208;
                                                                      if (!*(_BYTE *)qword_100162208)
                                                                        goto LABEL_1607;
                                                                      v607 = 0;
                                                                      v608 = qword_100162210 + 4;
                                                                      v609 = qword_100162208;
                                                                      do
                                                                      {
                                                                        ++v607;
                                                                        v610 = v609 + v606;
                                                                        v611 = *(unsigned __int8 *)(v610 + 1);
                                                                        v609 = v610 + 1;
                                                                        v606 = v611;
                                                                      }
                                                                      while (v611);
                                                                      if (v607 >= 2)
                                                                      {
                                                                        if (WORD2(xmmword_1001621F0) <= 6u)
                                                                        {
                                                                          v682 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            a1 = v878;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607;
                                                                          }
                                                                          else
                                                                          {
                                                                            v682 = mDNSLogCategory_Default_redacted;
                                                                            v691 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            a1 = v878;
                                                                            if (!v691)
                                                                              goto LABEL_1607;
                                                                          }
                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(_QWORD *)&v961[4] = "rdata_len >= min_rdata_len_nsec3";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(_QWORD *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(_QWORD *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 652;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(_QWORD *)&v961[40] = 0;
                                                                          v684 = v682;
                                                                        }
                                                                        else
                                                                        {
                                                                          v612 = v608 + WORD2(xmmword_1001621F0);
                                                                          v613 = *(unsigned __int8 *)(qword_100162210 + 8);
                                                                          v614 = qword_100162210 + 9 + v613;
                                                                          if (v614 >= v612)
                                                                          {
                                                                            v685 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607;
                                                                            }
                                                                            else
                                                                            {
                                                                              v685 = mDNSLogCategory_Default_redacted;
                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1607;
                                                                            }
                                                                            *(_DWORD *)v961 = 136447234;
                                                                            *(_QWORD *)&v961[4] = "salt + salt_len < limit";
                                                                            *(_WORD *)&v961[12] = 2082;
                                                                            *(_QWORD *)&v961[14] = "";
                                                                            *(_WORD *)&v961[22] = 2082;
                                                                            *(_QWORD *)&v961[24] = "/Library/Caches/com.a"
                                                                                                   "pple.xbs/Sources/mDNS"
                                                                                                   "Responder/mDNSShared/"
                                                                                                   "dns_objects/utilities/rdata_parser.c";
                                                                            *(_WORD *)&v961[32] = 1024;
                                                                            *(_DWORD *)&v961[34] = 659;
                                                                            *(_WORD *)&v961[38] = 2048;
                                                                            *(_QWORD *)&v961[40] = 0;
                                                                            v684 = v685;
                                                                          }
                                                                          else
                                                                          {
                                                                            v615 = v614
                                                                                 + *(unsigned __int8 *)(v613 + v608 + 5)
                                                                                 + 1;
                                                                            if (v615 > v612)
                                                                            {
                                                                              v686 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled != 1
                                                                                || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                              {
                                                                                a1 = v878;
                                                                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607;
                                                                              }
                                                                              else
                                                                              {
                                                                                v686 = mDNSLogCategory_Default_redacted;
                                                                                a1 = v878;
                                                                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1607;
                                                                              }
                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(_QWORD *)&v961[4] = "next_hashed_owner_name + hash_len <= limit";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(_QWORD *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 664;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(_QWORD *)&v961[40] = 0;
                                                                              v684 = v686;
                                                                            }
                                                                            else
                                                                            {
                                                                              v833 = qword_100162210 + 9;
                                                                              v835 = WORD2(xmmword_1001621F0);
                                                                              if (type_bit_maps_check_length(v615, (unsigned __int16)(v612 - v615)))
                                                                              {
                                                                                v840 = (unsigned __int8 *)v604;
                                                                                v616 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
                                                                                if (!v616)
                                                                                  goto LABEL_1999;
                                                                                v617 = (uint64_t)v616;
                                                                                v618 = &_dnssec_obj_rr_nsec3_kind;
                                                                                v616[1] = &_dnssec_obj_rr_nsec3_kind;
                                                                                do
                                                                                {
                                                                                  v619 = (void (*)(uint64_t))v618[2];
                                                                                  if (v619)
                                                                                    v619(v617);
                                                                                  v618 = (_UNKNOWN **)*v618;
                                                                                }
                                                                                while (v618);
                                                                                ++*(_DWORD *)v617;
                                                                                dnssec_obj_rr_init_fields(v617, v840, 50, 1, (const void *)(v605 + 4), v835, 1, 0, &v914);
                                                                                v620 = v914;
                                                                                if (v914)
                                                                                {
                                                                                  a1 = v878;
                                                                                  v585 = v870;
                                                                                  goto LABEL_1582;
                                                                                }
                                                                                v621 = *(unsigned __int8 *)(v605 + 8);
                                                                                v622 = *(unsigned __int8 *)(v621 + v608 + 5);
                                                                                encoded_string_length = base_x_get_encoded_string_length(2, v622);
                                                                                v585 = v870;
                                                                                if (encoded_string_length > 0x3F)
                                                                                {
                                                                                  v620 = -6705;
                                                                                }
                                                                                else
                                                                                {
                                                                                  v915 = 0;
                                                                                  memset(&v961[1], 0, 128);
                                                                                  v962 = 0u;
                                                                                  v963 = 0u;
                                                                                  v964 = 0u;
                                                                                  v965 = 0u;
                                                                                  v966 = 0u;
                                                                                  v967 = 0u;
                                                                                  memset(v968, 0, 31);
                                                                                  memset(v973, 0, sizeof(v973));
                                                                                  v974 = 0u;
                                                                                  v975 = 0u;
                                                                                  v976 = 0u;
                                                                                  v977 = 0u;
                                                                                  v978 = 0u;
                                                                                  v979 = 0u;
                                                                                  v980 = 0u;
                                                                                  v981 = 0u;
                                                                                  v982 = 0u;
                                                                                  v983 = 0u;
                                                                                  v984 = 0u;
                                                                                  v985 = 0u;
                                                                                  v986 = 0u;
                                                                                  v987 = 0u;
                                                                                  v961[0] = encoded_string_length;
                                                                                  v961[encoded_string_length + 1] = 0;
                                                                                  base_32_hex_encode((unsigned __int8 *)(v833 + v621 + 1), v622, 1, &v961[1]);
                                                                                  parent = domain_name_labels_get_parent(v840, 1uLL);
                                                                                  if (parent)
                                                                                  {
                                                                                    domain_name_labels_concatenate(v961, parent, (char *)v973, &v915);
                                                                                    v620 = v915;
                                                                                    a1 = v878;
                                                                                    if (!v915)
                                                                                    {
                                                                                      v625 = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)v973, 1, &v915);
                                                                                      *(_QWORD *)(v617 + 80) = v625;
                                                                                      v620 = v915;
                                                                                      if (!v915)
                                                                                      {
                                                                                        *(_BYTE *)(v617 + 88) = ref_count_obj_compare(*(_QWORD *)(v617 + 16), (uint64_t)v625, 0) < 2;
                                                                                        v620 = v915;
                                                                                        v914 = v915;
                                                                                        if (!v915)
                                                                                        {
                                                                                          v626 = 0;
                                                                                          goto LABEL_1608;
                                                                                        }
LABEL_1582:
                                                                                        v913 = v620;
                                                                                        ref_count_obj_release((_QWORD *)v617);
                                                                                        v617 = 0;
                                                                                        v626 = v913;
LABEL_1609:
                                                                                        *((_QWORD *)v958
                                                                                        + v863) = v617;
                                                                                        if (v626)
                                                                                          v692 = v863;
                                                                                        else
                                                                                          v692 = v863 + 1;
                                                                                        v863 = v692;
                                                                                        goto LABEL_1613;
                                                                                      }
                                                                                    }
LABEL_1581:
                                                                                    v914 = v620;
                                                                                    goto LABEL_1582;
                                                                                  }
                                                                                  v620 = -6736;
                                                                                }
                                                                                a1 = v878;
                                                                                goto LABEL_1581;
                                                                              }
                                                                              v687 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled == 1
                                                                                && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                              {
                                                                                v687 = mDNSLogCategory_Default_redacted;
                                                                                a1 = v878;
                                                                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                                                                {
                                                                                  goto LABEL_1576;
                                                                                }
LABEL_1607:
                                                                                v617 = 0;
                                                                                v626 = -6705;
LABEL_1608:
                                                                                v913 = v626;
                                                                                goto LABEL_1609;
                                                                              }
                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607;
LABEL_1576:
                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(_QWORD *)&v961[4] = "type_bit_maps_is_valid";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(_QWORD *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 670;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(_QWORD *)&v961[40] = 0;
                                                                              v684 = v687;
                                                                            }
                                                                          }
                                                                        }
                                                                        _os_log_impl((void *)&_mh_execute_header, v684, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v961, 0x30u);
                                                                        goto LABEL_1607;
                                                                      }
                                                                      v617 = 0;
                                                                      v626 = -6705;
                                                                      a1 = v878;
                                                                      goto LABEL_1608;
                                                                    }
                                                                    v863 = 10;
                                                                  }
                                                                }
                                                                else if (WORD6(xmmword_1001621E0) == 6)
                                                                {
                                                                  if (!v877)
                                                                  {
                                                                    bzero(v961, 0x214uLL);
                                                                    putRData(0, v961, (unint64_t)&v971, (uint64_t)&xmmword_1001621E0 + 8, v593, v594, v595, v596);
                                                                    v597 = (unsigned __int8 *)qword_100162208;
                                                                    v598 = WORD2(xmmword_1001621F0);
                                                                    v915 = 0;
                                                                    if (WORD2(xmmword_1001621F0) <= 0x15uLL)
                                                                    {
                                                                      v678 = mDNSLogCategory_Default;
                                                                      if (gSensitiveLoggingEnabled != 1
                                                                        || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                      {
                                                                        v16 = (void *)a10;
                                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                      }
                                                                      else
                                                                      {
                                                                        v678 = mDNSLogCategory_Default_redacted;
                                                                        v16 = (void *)a10;
                                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                      }
                                                                      LODWORD(v973[0]) = 136447234;
                                                                      *(_QWORD *)((char *)v973 + 4) = "rdata_len >= min_rdata_len_soa";
                                                                      WORD6(v973[0]) = 2082;
                                                                      *(_QWORD *)((char *)v973 + 14) = "";
                                                                      WORD3(v973[1]) = 2082;
                                                                      LOWORD(v974) = 1024;
                                                                      *(_DWORD *)((char *)&v974 + 2) = 117;
                                                                      WORD3(v974) = 2048;
                                                                      *((_QWORD *)&v973[1] + 1) = "/Library/Caches/com.ap"
                                                                                                  "ple.xbs/Sources/mDNSRe"
                                                                                                  "sponder/mDNSShared/dns"
                                                                                                  "_objects/utilities/rdata_parser.c";
                                                                      *((_QWORD *)&v974 + 1) = 0;
                                                                      v665 = v678;
                                                                    }
                                                                    else
                                                                    {
                                                                      v599 = &v961[WORD2(xmmword_1001621F0)];
                                                                      v600 = v961[0];
                                                                      if (v961[0])
                                                                      {
                                                                        v601 = v961;
                                                                        while (!v599 || &v601[v600 + 1] <= v599)
                                                                        {
                                                                          v602 = &v601[v600];
                                                                          v603 = v602[1];
                                                                          v601 = v602 + 1;
                                                                          v600 = v603;
                                                                          if (!v603)
                                                                            goto LABEL_1489;
                                                                        }
                                                                        goto LABEL_1497;
                                                                      }
                                                                      v601 = v961;
LABEL_1489:
                                                                      v655 = v601 - v961;
                                                                      v656 = v655 + 1;
                                                                      if (v655 == -1)
                                                                      {
LABEL_1497:
                                                                        v663 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          v16 = (void *)a10;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                        }
                                                                        else
                                                                        {
                                                                          v663 = mDNSLogCategory_Default_redacted;
                                                                          v675 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                          v16 = (void *)a10;
                                                                          if (!v675)
                                                                            goto LABEL_1535;
                                                                        }
                                                                        LODWORD(v973[0]) = 136447234;
                                                                        *(_QWORD *)((char *)v973 + 4) = "primary_name_server_len >= 1";
                                                                        WORD6(v973[0]) = 2082;
                                                                        *(_QWORD *)((char *)v973 + 14) = "";
                                                                        WORD3(v973[1]) = 2082;
                                                                        LOWORD(v974) = 1024;
                                                                        *(_DWORD *)((char *)&v974 + 2) = 122;
                                                                        WORD3(v974) = 2048;
                                                                        *((_QWORD *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                        *((_QWORD *)&v974 + 1) = 0;
                                                                        v665 = v663;
                                                                      }
                                                                      else
                                                                      {
                                                                        v657 = v655 + 21;
                                                                        if (v657 >= WORD2(xmmword_1001621F0))
                                                                        {
                                                                          v688 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            v16 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                          }
                                                                          else
                                                                          {
                                                                            v688 = mDNSLogCategory_Default_redacted;
                                                                            v16 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                          }
                                                                          LODWORD(v973[0]) = 136447234;
                                                                          *(_QWORD *)((char *)v973 + 4) = "primary_name_server_len + sizeof(rdata_soa_t) < rdata_len";
                                                                          WORD6(v973[0]) = 2082;
                                                                          *(_QWORD *)((char *)v973 + 14) = "";
                                                                          WORD3(v973[1]) = 2082;
                                                                          LOWORD(v974) = 1024;
                                                                          *(_DWORD *)((char *)&v974 + 2) = 123;
                                                                          WORD3(v974) = 2048;
                                                                          *((_QWORD *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                          *((_QWORD *)&v974 + 1) = 0;
                                                                          v665 = v688;
                                                                        }
                                                                        else
                                                                        {
                                                                          v658 = &v961[v656];
                                                                          v659 = *v658;
                                                                          if (*v658)
                                                                          {
                                                                            v660 = v658;
                                                                            while (!v599 || &v660[v659 + 1] <= v599)
                                                                            {
                                                                              v661 = &v660[v659];
                                                                              v662 = v661[1];
                                                                              v660 = v661 + 1;
                                                                              v659 = v662;
                                                                              if (!v662)
                                                                                goto LABEL_1505;
                                                                            }
                                                                            goto LABEL_1514;
                                                                          }
                                                                          v660 = v658;
LABEL_1505:
                                                                          if (v660 - v658 == -1)
                                                                          {
LABEL_1514:
                                                                            v670 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              v16 = (void *)a10;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535;
                                                                            }
                                                                            else
                                                                            {
                                                                              v670 = mDNSLogCategory_Default_redacted;
                                                                              v676 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                              v16 = (void *)a10;
                                                                              if (!v676)
                                                                                goto LABEL_1535;
                                                                            }
                                                                            LODWORD(v973[0]) = 136447234;
                                                                            *(_QWORD *)((char *)v973 + 4) = "mailbox_name_len >= 1";
                                                                            WORD6(v973[0]) = 2082;
                                                                            *(_QWORD *)((char *)v973 + 14) = "";
                                                                            WORD3(v973[1]) = 2082;
                                                                            LOWORD(v974) = 1024;
                                                                            *(_DWORD *)((char *)&v974 + 2) = 127;
                                                                            WORD3(v974) = 2048;
                                                                            *((_QWORD *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((_QWORD *)&v974 + 1) = 0;
                                                                            v665 = v670;
                                                                          }
                                                                          else
                                                                          {
                                                                            if (v657 + v660 - v658 + 1 == WORD2(xmmword_1001621F0))
                                                                            {
                                                                              v666 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
                                                                              if (!v666)
LABEL_1999:
                                                                                __break(1u);
                                                                              v667 = &_dnssec_obj_rr_soa_kind;
                                                                              v877 = v666;
                                                                              v666[1] = &_dnssec_obj_rr_soa_kind;
                                                                              do
                                                                              {
                                                                                v668 = (void (*)(_QWORD *))v667[2];
                                                                                if (v668)
                                                                                  v668(v877);
                                                                                v667 = (_UNKNOWN **)*v667;
                                                                              }
                                                                              while (v667);
                                                                              ++*(_DWORD *)v877;
                                                                              dnssec_obj_rr_init_fields((uint64_t)v877, v597, 6, 1, v961, v598, 1, 0, &v915);
                                                                              v669 = v915;
                                                                              if (v915)
                                                                              {
                                                                                v913 = v915;
                                                                                ref_count_obj_release(v877);
                                                                                v877 = 0;
                                                                                a1 = v878;
LABEL_1613:
                                                                                v16 = (void *)a10;
                                                                                goto LABEL_1401;
                                                                              }
                                                                              a1 = v878;
                                                                              v16 = (void *)a10;
                                                                              goto LABEL_1536;
                                                                            }
                                                                            v689 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled == 1
                                                                              && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                            {
                                                                              v689 = mDNSLogCategory_Default_redacted;
                                                                              v16 = (void *)a10;
                                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                                                              {
                                                                                goto LABEL_1594;
                                                                              }
LABEL_1535:
                                                                              v877 = 0;
                                                                              v669 = -6705;
LABEL_1536:
                                                                              v913 = v669;
                                                                              goto LABEL_1401;
                                                                            }
                                                                            v16 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535;
LABEL_1594:
                                                                            LODWORD(v973[0]) = 136447234;
                                                                            *(_QWORD *)((char *)v973 + 4) = "primary_name_server_len + mailbox_name_len + sizeof(rdata_soa_t) == rdata_len";
                                                                            WORD6(v973[0]) = 2082;
                                                                            *(_QWORD *)((char *)v973 + 14) = "";
                                                                            WORD3(v973[1]) = 2082;
                                                                            LOWORD(v974) = 1024;
                                                                            *(_DWORD *)((char *)&v974 + 2) = 129;
                                                                            WORD3(v974) = 2048;
                                                                            *((_QWORD *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((_QWORD *)&v974 + 1) = 0;
                                                                            v665 = v689;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                    _os_log_impl((void *)&_mh_execute_header, v665, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)v973, 0x30u);
                                                                    goto LABEL_1535;
                                                                  }
                                                                }
                                                                else if (WORD6(xmmword_1001621E0) == 46)
                                                                {
                                                                  v592 = dnssec_obj_rr_rrsig_create((unsigned __int8 *)qword_100162208, (const void *)(qword_100162210 + 4), WORD2(xmmword_1001621F0), 1, &v913);
                                                                  if (v913)
                                                                  {
                                                                    if (!v592)
                                                                      goto LABEL_1401;
                                                                    goto LABEL_1480;
                                                                  }
                                                                  v649 = __rev16(**(unsigned __int16 **)(v592 + 24));
                                                                  if (v649 == 50 || v649 == 47)
                                                                  {
                                                                    v650 = v912;
                                                                    if (v912 != 30)
                                                                    {
                                                                      v651 = &v912;
                                                                      v652 = v957;
LABEL_1479:
                                                                      *((_QWORD *)v652 + v650) = v592;
                                                                      ++*(_DWORD *)v592;
                                                                      *(_BYTE *)v651 = v650 + 1;
                                                                    }
                                                                  }
                                                                  else if (v649 == 6)
                                                                  {
                                                                    v650 = HIBYTE(v912);
                                                                    if (HIBYTE(v912) != 30)
                                                                    {
                                                                      v651 = (__int16 *)((char *)&v912 + 1);
                                                                      v652 = v960;
                                                                      goto LABEL_1479;
                                                                    }
                                                                  }
LABEL_1480:
                                                                  ref_count_obj_release((_QWORD *)v592);
                                                                }
                                                              }
LABEL_1401:
                                                              WORD4(xmmword_1001621E0) = 0;
                                                              HIWORD(xmmword_100162240) = 0;
                                                              if ((_QWORD)xmmword_100162220)
                                                              {
                                                                ref_count_obj_release((_QWORD *)xmmword_100162220);
                                                                *(_QWORD *)&xmmword_100162220 = 0;
                                                              }
                                                              ++v588;
                                                            }
                                                            while (v588 < v891 && (unint64_t)v587 < v585);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          LOBYTE(v863) = 0;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v877 = 0;
                                                        LOBYTE(v863) = 0;
                                                        LOBYTE(v865) = 0;
                                                        v895 = 3601;
                                                      }
                                                      v693 = v897;
                                                      if (v897 == 3601)
                                                        v693 = v895;
                                                      v894 = 1;
                                                      a2 = v900;
                                                      v473 = v845;
                                                      v583 = v853;
                                                    }
                                                    else
                                                    {
                                                      v693 = v897;
                                                    }
                                                    v694 = v909 ^ 1;
                                                    if (!v504)
                                                      v694 = 1;
                                                    if ((v694 & 1) != 0)
                                                    {
                                                      if ((v909 & (v693 != 3601)) == 0)
                                                        v693 = v583;
                                                      if (!v504)
                                                        goto LABEL_1755;
                                                      v703 = 0;
                                                    }
                                                    else
                                                    {
                                                      v695 = v504[8];
                                                      if (*(_QWORD *)&v695 && !*(_DWORD *)(*(_QWORD *)&v695 + 32))
                                                      {
                                                        v854 = v583;
                                                        if (!v886 && v865 | v863)
                                                        {
                                                          LODWORD(v973[0]) = 0;
                                                          if (v873)
                                                            p_dst = 0;
                                                          else
                                                            p_dst = (unsigned __int8 *)&__dst;
                                                          v697 = dnssec_obj_denial_of_existence_create(v480, v831, v839, p_dst, (unsigned __int8 *)v899, v877, (unsigned __int8 *)v960, HIBYTE(v912), (uint64_t)v959, v865, (uint64_t *)v958, v863, (uint64_t)v957, v912, (int *)v973);
                                                          v698 = gSensitiveLoggingEnabled;
                                                          v699 = mDNSLogCategory_DNSSEC;
                                                          if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                            v698 = 0;
                                                          v886 = (uint64_t)v697;
                                                          if (v697)
                                                          {
                                                            if ((v698 & 1) != 0)
                                                            {
                                                              v700 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                v701 = v480;
                                                                if (v480 == (unsigned __int8 *)-256)
                                                                {
                                                                  while (1)
                                                                  {
LABEL_1644:
                                                                    if (!v701)
                                                                      goto LABEL_1684;
                                                                    v702 = *v701;
                                                                    if (v702 > 0x3F)
                                                                      goto LABEL_1684;
                                                                    if (!*v701)
                                                                      break;
                                                                    v701 += v702 + 1;
                                                                    if (v480 != (unsigned __int8 *)-256)
                                                                      goto LABEL_1643;
                                                                  }
                                                                  v713 = (_WORD)v701 - (_WORD)v480 + 1;
                                                                }
                                                                else
                                                                {
LABEL_1643:
                                                                  if (v701 < v480 + 256)
                                                                    goto LABEL_1644;
LABEL_1684:
                                                                  v713 = 257;
                                                                }
                                                                v717 = DNSTypeName(v839);
                                                                v718 = *(unsigned int *)(v886 + 16);
                                                                v719 = "<fatal: this should never be returned>";
                                                                if (v718 <= 6)
                                                                  v719 = off_10013CEA8[v718];
                                                                *(_DWORD *)v961 = 67110659;
                                                                *(_DWORD *)&v961[4] = v829;
                                                                *(_WORD *)&v961[8] = 2160;
                                                                *(_QWORD *)&v961[10] = 1752392040;
                                                                *(_WORD *)&v961[18] = 1040;
                                                                *(_DWORD *)&v961[20] = v713;
                                                                *(_WORD *)&v961[24] = 2101;
                                                                *(_QWORD *)&v961[26] = v480;
                                                                *(_WORD *)&v961[34] = 2160;
                                                                *(_QWORD *)&v961[36] = 1752392040;
                                                                *(_WORD *)&v961[44] = 2085;
                                                                *(_QWORD *)&v961[46] = v717;
                                                                *(_WORD *)&v961[54] = 2082;
                                                                *(_QWORD *)&v961[56] = v719;
                                                                v720 = v700;
                                                                goto LABEL_1696;
                                                              }
                                                            }
                                                            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
                                                            {
                                                              v708 = v480;
                                                              if (v480 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1668:
                                                                  if (!v708)
                                                                    goto LABEL_1685;
                                                                  v709 = *v708;
                                                                  if (v709 > 0x3F)
                                                                    goto LABEL_1685;
                                                                  if (!*v708)
                                                                    break;
                                                                  v708 += v709 + 1;
                                                                  if (v480 != (unsigned __int8 *)-256)
                                                                    goto LABEL_1667;
                                                                }
                                                                v714 = (_WORD)v708 - (_WORD)v480 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1667:
                                                                if (v708 < v480 + 256)
                                                                  goto LABEL_1668;
LABEL_1685:
                                                                v714 = 257;
                                                              }
                                                              v721 = DNSTypeName(v839);
                                                              v722 = *(unsigned int *)(v886 + 16);
                                                              v723 = "<fatal: this should never be returned>";
                                                              if (v722 <= 6)
                                                                v723 = off_10013CEA8[v722];
                                                              *(_DWORD *)v961 = 67110659;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2160;
                                                              *(_QWORD *)&v961[10] = 1752392040;
                                                              *(_WORD *)&v961[18] = 1040;
                                                              *(_DWORD *)&v961[20] = v714;
                                                              *(_WORD *)&v961[24] = 2101;
                                                              *(_QWORD *)&v961[26] = v480;
                                                              *(_WORD *)&v961[34] = 2160;
                                                              *(_QWORD *)&v961[36] = 1752392040;
                                                              *(_WORD *)&v961[44] = 2085;
                                                              *(_QWORD *)&v961[46] = v721;
                                                              *(_WORD *)&v961[54] = 2082;
                                                              *(_QWORD *)&v961[56] = v723;
                                                              v720 = v699;
LABEL_1696:
                                                              _os_log_impl((void *)&_mh_execute_header, v720, OS_LOG_TYPE_DEFAULT, "[Q%u] Create the denial of existence record set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, denial type: %{public}s", v961, 0x40u);
                                                            }
                                                          }
                                                          else
                                                          {
                                                            if ((v698 & 1) != 0)
                                                            {
                                                              v704 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1702;
                                                              v705 = LODWORD(v973[0])
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              v706 = v480;
                                                              if (v480 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1660:
                                                                  if (!v706)
                                                                    goto LABEL_1686;
                                                                  v707 = *v706;
                                                                  if (v707 > 0x3F)
                                                                    goto LABEL_1686;
                                                                  if (!*v706)
                                                                    break;
                                                                  v706 += v707 + 1;
                                                                  if (v480 != (unsigned __int8 *)-256)
                                                                    goto LABEL_1659;
                                                                }
                                                                v715 = (_WORD)v706 - (_WORD)v480 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1659:
                                                                if (v706 < v480 + 256)
                                                                  goto LABEL_1660;
LABEL_1686:
                                                                v715 = 257;
                                                              }
                                                              v724 = v715;
                                                              v725 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(_QWORD *)&v961[10] = v705;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(_QWORD *)&v961[20] = 1752392040;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v724;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(_QWORD *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(_QWORD *)&v961[46] = 1752392040;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(_QWORD *)&v961[56] = v725;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              v726 = v704;
                                                            }
                                                            else
                                                            {
                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))goto LABEL_1702;
                                                              v710 = LODWORD(v973[0])
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              v711 = v480;
                                                              if (v480 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1679:
                                                                  if (!v711)
                                                                    goto LABEL_1687;
                                                                  v712 = *v711;
                                                                  if (v712 > 0x3F)
                                                                    goto LABEL_1687;
                                                                  if (!*v711)
                                                                    break;
                                                                  v711 += v712 + 1;
                                                                  if (v480 != (unsigned __int8 *)-256)
                                                                    goto LABEL_1678;
                                                                }
                                                                v716 = (_WORD)v711 - (_WORD)v480 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1678:
                                                                if (v711 < v480 + 256)
                                                                  goto LABEL_1679;
LABEL_1687:
                                                                v716 = 257;
                                                              }
                                                              v727 = v716;
                                                              v728 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(_QWORD *)&v961[10] = v710;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(_QWORD *)&v961[20] = 1752392040;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v727;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(_QWORD *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(_QWORD *)&v961[46] = 1752392040;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(_QWORD *)&v961[56] = v728;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              v726 = v699;
                                                            }
                                                            _os_log_impl((void *)&_mh_execute_header, v726, OS_LOG_TYPE_FAULT, "[Q%u] Unable to create the denial of existence record set - error: %{public}s, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.", v961, 0x58u);
                                                            a2 = v900;
                                                          }
LABEL_1702:
                                                          v695 = v504[8];
                                                          if (!*(_QWORD *)&v695)
                                                            goto LABEL_1705;
                                                        }
                                                        if (*(_DWORD *)(*(_QWORD *)&v695 + 32)
                                                          || *(_BYTE *)(*(_QWORD *)&v695 + 40))
                                                        {
LABEL_1705:
                                                          v729 = 0;
LABEL_1706:
                                                          if (v729 | v886)
                                                            goto LABEL_1728;
                                                        }
                                                        else
                                                        {
                                                          v729 = *(_QWORD *)(*(_QWORD *)&v695 + 48);
                                                          if (!v729 || !v886)
                                                            goto LABEL_1706;
                                                          if (ref_count_obj_compare(v729, v886, 1))
                                                          {
LABEL_1728:
                                                            v735 = mDNSLogCategory_DNSSEC;
                                                            if (gSensitiveLoggingEnabled == 1
                                                              && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
                                                            {
                                                              v735 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                                                              {
                                                                v736 = v480;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  goto LABEL_1732;
                                                                while (1)
                                                                {
                                                                  if (!v736
                                                                    || (v737 = *v736, v737 > 0x3F))
                                                                  {
LABEL_1747:
                                                                    v740 = 257;
                                                                    goto LABEL_1752;
                                                                  }
                                                                  if (!*v736)
                                                                    break;
                                                                  v736 += v737 + 1;
                                                                  if (v480 == (unsigned __int8 *)-256)
                                                                    continue;
LABEL_1732:
                                                                  if (v736 >= v480 + 256)
                                                                    goto LABEL_1747;
                                                                }
                                                                v740 = (_WORD)v736 - (_WORD)v480 + 1;
LABEL_1752:
                                                                v742 = v740;
                                                                v743 = DNSTypeName(v839);
                                                                *(_DWORD *)v961 = 141558787;
                                                                *(_QWORD *)&v961[4] = 1752392040;
                                                                *(_WORD *)&v961[12] = 1040;
                                                                *(_DWORD *)&v961[14] = v742;
                                                                *(_WORD *)&v961[18] = 2101;
                                                                *(_QWORD *)&v961[20] = v480;
                                                                *(_WORD *)&v961[28] = 2082;
                                                                *(_QWORD *)&v961[30] = v743;
                                                                _os_log_impl((void *)&_mh_execute_header, v735, OS_LOG_TYPE_DEBUG, "Denial of existence record changes, purging the old negative record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{public}s", v961, 0x26u);
                                                              }
LABEL_1753:
                                                              mDNS_PurgeCacheResourceRecord((unsigned int *)a1, (uint64_t)v504);
                                                              if (v693 == 3601)
                                                                v693 = v854;
LABEL_1755:
                                                              v703 = 0;
                                                              while (2)
                                                              {
                                                                MakeNegativeCacheRecord(a1, v473, (uint64_t)v480, v477, v953, v954, v693, 0, a9, *((_WORD *)a2 + 1));
                                                                if (v906 && *v889)
                                                                  mdns_cache_metadata_set_extended_dns_error(*v889, *(void **)(v906 + 160));
                                                                v744 = CacheGroupForName(a1, v477, v480);
                                                                if (v909)
                                                                {
                                                                  v746 = *(_DWORD *)(a1 + 64);
                                                                  if (v746 <= 1)
                                                                    v747 = 1;
                                                                  else
                                                                    v747 = v746;
                                                                  v748 = 2;
                                                                }
                                                                else
                                                                {
                                                                  v748 = 0;
                                                                  v747 = 1;
                                                                }
                                                                v749 = v477 % 0x1F3;
                                                                v750 = CreateNewCacheEntryEx(a1, v749, (uint64_t)v744, v747, 1, 0, v748, v745);
                                                                v757 = v750;
                                                                v758 = v909;
                                                                if (v703)
                                                                  v758 = 0;
                                                                if (v758 == 1)
                                                                {
                                                                  if ((unint64_t)(v750 + 1) < 2)
                                                                  {
                                                                    v703 = -1;
                                                                    goto LABEL_1770;
                                                                  }
                                                                  *(_BYTE *)(v750 + 128) = 1;
                                                                  v703 = v750;
LABEL_1773:
                                                                  if (NewCacheEntry)
                                                                  {
                                                                    v759 = *(_QWORD *)(v750 + 120);
                                                                    if (v759)
                                                                      ReleaseCacheRecord(a1, v759);
                                                                    *(_QWORD *)(v757 + 120) = NewCacheEntry;
                                                                  }
                                                                  if ((v909 & 1) != 0)
                                                                  {
                                                                    v760 = *(_DWORD *)(v757 + 84);
                                                                    v761 = a1 + 4 * v749;
                                                                    if (*(_DWORD *)(v761 + 4264) - v760 >= 1)
                                                                      *(_DWORD *)(v761 + 4264) = v760;
                                                                    if (*(_DWORD *)(a1 + 88) - v760 >= 1)
                                                                    {
                                                                      NewCacheEntry = 0;
                                                                      *(_DWORD *)(a1 + 88) = v760;
                                                                      goto LABEL_1784;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    *(_DWORD *)(v757 + 84) = 0;
                                                                    CacheRecordDeferredAdd((_QWORD *)a1, v757, v751, v752, v753, v754, v755, v756);
                                                                  }
                                                                  NewCacheEntry = 0;
                                                                  goto LABEL_1784;
                                                                }
LABEL_1770:
                                                                if (v750)
                                                                  goto LABEL_1773;
LABEL_1784:
                                                                *(_WORD *)v858 = 0;
                                                                *((_WORD *)v858 + 51) = 0;
                                                                v762 = (_QWORD *)*((_QWORD *)v858 + 7);
                                                                if (v762)
                                                                {
                                                                  ref_count_obj_release(v762);
                                                                  *((_QWORD *)v858 + 7) = 0;
                                                                }
                                                                if (!v555)
                                                                {
                                                                  v504 = 0;
                                                                  v386 = v906;
                                                                  v475 = v909;
                                                                  goto LABEL_1811;
                                                                }
                                                                --v555;
                                                                if (*v480)
                                                                  v480 += *v480 + 1;
                                                                v477 = DomainNameHashValue((unint64_t)v480);
                                                                continue;
                                                              }
                                                            }
                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))goto LABEL_1753;
                                                            v738 = v480;
                                                            if (v480 == (unsigned __int8 *)-256)
                                                              goto LABEL_1741;
LABEL_1740:
                                                            if (v738 < v480 + 256)
                                                            {
LABEL_1741:
                                                              while (v738)
                                                              {
                                                                v739 = *v738;
                                                                if (v739 > 0x3F)
                                                                  break;
                                                                if (!*v738)
                                                                {
                                                                  v740 = (_WORD)v738 - (_WORD)v480 + 1;
                                                                  goto LABEL_1752;
                                                                }
                                                                v738 += v739 + 1;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  goto LABEL_1740;
                                                              }
                                                            }
                                                            v740 = 257;
                                                            goto LABEL_1752;
                                                          }
                                                        }
                                                        v730 = mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v733 = v480;
                                                            if (v480 == (unsigned __int8 *)-256)
                                                            {
                                                              while (1)
                                                              {
LABEL_1720:
                                                                if (!v733)
                                                                  goto LABEL_1749;
                                                                v734 = *v733;
                                                                if (v734 > 0x3F)
                                                                  goto LABEL_1749;
                                                                if (!*v733)
                                                                  break;
                                                                v733 += v734 + 1;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  goto LABEL_1719;
                                                              }
                                                              v741 = (_WORD)v733 - (_WORD)v480 + 1;
                                                            }
                                                            else
                                                            {
LABEL_1719:
                                                              if (v733 < v480 + 256)
                                                                goto LABEL_1720;
LABEL_1749:
                                                              v741 = 257;
                                                            }
LABEL_1793:
                                                            v763 = v741;
                                                            v764 = DNSTypeName(v839);
                                                            *(_DWORD *)v961 = 141558787;
                                                            *(_QWORD *)&v961[4] = 1752392040;
                                                            *(_WORD *)&v961[12] = 1040;
                                                            *(_DWORD *)&v961[14] = v763;
                                                            *(_WORD *)&v961[18] = 2101;
                                                            *(_QWORD *)&v961[20] = v480;
                                                            *(_WORD *)&v961[28] = 2082;
                                                            *(_QWORD *)&v961[30] = v764;
                                                            _os_log_impl((void *)&_mh_execute_header, v730, OS_LOG_TYPE_DEBUG, "Denial of existence record does not change, rescuing the old negative record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{public}s", v961, 0x26u);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v730 = mDNSLogCategory_DNSSEC_redacted;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v731 = v480;
                                                            if (v480 == (unsigned __int8 *)-256)
                                                            {
                                                              while (1)
                                                              {
LABEL_1712:
                                                                if (!v731)
                                                                  goto LABEL_1748;
                                                                v732 = *v731;
                                                                if (v732 > 0x3F)
                                                                  goto LABEL_1748;
                                                                if (!*v731)
                                                                  break;
                                                                v731 += v732 + 1;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  goto LABEL_1711;
                                                              }
                                                              v741 = (_WORD)v731 - (_WORD)v480 + 1;
                                                            }
                                                            else
                                                            {
LABEL_1711:
                                                              if (v731 < v480 + 256)
                                                                goto LABEL_1712;
LABEL_1748:
                                                              v741 = 257;
                                                            }
                                                            goto LABEL_1793;
                                                          }
                                                        }
                                                        v583 = v854;
                                                      }
                                                      v504[16].i8[0] = 1;
                                                      if (v693 == 3601)
                                                        v693 = v583;
                                                      v703 = (uint64_t)v504;
                                                    }
                                                    v765 = mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1803;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v765 = mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1803:
                                                        v766 = v951;
                                                        v767 = bswap32(v952) >> 16;
                                                        v768 = v504[2].i32[0];
                                                        GetRRDisplayString_rdb((unsigned __int8 *)&v504[1], (unsigned __int16 *)(*(_QWORD *)&v504[6] + 4), v861);
                                                        *(_DWORD *)v961 = 67110403;
                                                        *(_DWORD *)&v961[4] = v766;
                                                        *(_WORD *)&v961[8] = 1024;
                                                        *(_DWORD *)&v961[10] = v767;
                                                        *(_WORD *)&v961[14] = 1024;
                                                        *(_DWORD *)&v961[16] = v768;
                                                        a2 = v900;
                                                        *(_WORD *)&v961[20] = 1024;
                                                        *(_DWORD *)&v961[22] = v693;
                                                        *(_WORD *)&v961[26] = 2160;
                                                        *(_QWORD *)&v961[28] = 1752392040;
                                                        *(_WORD *)&v961[36] = 2085;
                                                        *(_QWORD *)&v961[38] = v861;
                                                        v473 = v845;
                                                        _os_log_impl((void *)&_mh_execute_header, v765, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Renewing negative TTL from %d to %d %{sensitive, mask.hash}s", v961, 0x2Eu);
                                                      }
                                                    }
                                                    RefreshCacheRecord(a1, v504, v693);
                                                    v475 = v909;
                                                    if (!v851)
                                                    {
                                                      v769 = *(_DWORD *)(a1 + 64);
                                                      *(_DWORD *)(v902 + 256) = v769;
                                                      *(_DWORD *)(v902 + 224) = 0;
                                                      *(_DWORD *)(v902 + 208) = v769;
                                                      *(_DWORD *)(v902 + 212) = 3600000;
                                                      *(_BYTE *)(v902 + 352) = 0;
                                                      *(_BYTE *)(v902 + 648) = 0;
                                                    }
                                                    v386 = v906;
                                                    if (NewCacheEntry)
                                                    {
                                                      v770 = (uint64_t)v504[15];
                                                      if (v770)
                                                        ReleaseCacheRecord(a1, v770);
                                                      v504[15] = (int8x8_t)NewCacheEntry;
                                                    }
                                                    NewCacheEntry = 0;
LABEL_1811:
                                                    if (v703 == -1)
                                                      v771 = 0;
                                                    else
                                                      v771 = v475;
                                                    if (v771 != 1)
                                                    {
                                                      v16 = (void *)a10;
                                                      goto LABEL_1868;
                                                    }
                                                    v772 = *(_QWORD *)(v703 + 64);
                                                    if (!v772
                                                      || (*(_BYTE *)(v703 + 128) = 0, !*(_DWORD *)(v772 + 32))
                                                      && !*(_BYTE *)(v772 + 40)
                                                      && *(_QWORD *)(v772 + 48))
                                                    {
                                                      v16 = (void *)a10;
                                                      goto LABEL_1867;
                                                    }
                                                    if (!v886 && v865 | v863)
                                                    {
                                                      LODWORD(v973[0]) = 0;
                                                      if (v873)
                                                        v773 = 0;
                                                      else
                                                        v773 = (unsigned __int8 *)&__dst;
                                                      v774 = dnssec_obj_denial_of_existence_create(v480, v831, v839, v773, (unsigned __int8 *)v899, v877, (unsigned __int8 *)v960, HIBYTE(v912), (uint64_t)v959, v865, (uint64_t *)v958, v863, (uint64_t)v957, v912, (int *)v973);
                                                      v775 = gSensitiveLoggingEnabled;
                                                      v776 = mDNSLogCategory_DNSSEC;
                                                      if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        v775 = 0;
                                                      if (!v774)
                                                      {
                                                        if ((v775 & 1) != 0)
                                                        {
                                                          v776 = mDNSLogCategory_DNSSEC_redacted;
                                                          v16 = (void *)a10;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                          {
                                                            if (LODWORD(v973[0]))
                                                              v780 = "Unknown DNSSEC error.";
                                                            else
                                                              v780 = "No error.";
                                                            if (!v480)
                                                            {
                                                              v791 = 0;
                                                              goto LABEL_1923;
                                                            }
                                                            v781 = v480;
                                                            if (v480 == (unsigned __int8 *)-256)
                                                              goto LABEL_1849;
                                                            while (2)
                                                            {
                                                              v782 = 257;
                                                              if (v781 >= v480 + 256 || !v781)
                                                              {
LABEL_1920:
                                                                v791 = v782;
                                                                goto LABEL_1923;
                                                              }
LABEL_1850:
                                                              v783 = *v781;
                                                              if (v783 <= 0x3F)
                                                              {
                                                                if (!*v781)
                                                                {
                                                                  v782 = (_WORD)v781 - (_WORD)v480 + 1;
                                                                  goto LABEL_1920;
                                                                }
                                                                v781 += v783 + 1;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  continue;
LABEL_1849:
                                                                if (v781)
                                                                  goto LABEL_1850;
                                                              }
                                                              break;
                                                            }
                                                            v782 = 257;
                                                            goto LABEL_1920;
                                                          }
LABEL_1924:
                                                          v886 = 0;
                                                          goto LABEL_1867;
                                                        }
                                                        v16 = (void *)a10;
                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))goto LABEL_1924;
                                                        if (LODWORD(v973[0]))
                                                          v780 = "Unknown DNSSEC error.";
                                                        else
                                                          v780 = "No error.";
                                                        if (!v480)
                                                        {
                                                          v791 = 0;
                                                          goto LABEL_1923;
                                                        }
                                                        v787 = v480;
                                                        if (v480 == (unsigned __int8 *)-256)
                                                        {
LABEL_1878:
                                                          if (v787)
                                                            goto LABEL_1879;
                                                        }
                                                        else
                                                        {
                                                          while (2)
                                                          {
                                                            v788 = 257;
                                                            if (v787 >= v480 + 256 || !v787)
                                                            {
LABEL_1922:
                                                              v791 = v788;
LABEL_1923:
                                                              v798 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(_QWORD *)&v961[10] = v780;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(_QWORD *)&v961[20] = 1752392040;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v791;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(_QWORD *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(_QWORD *)&v961[46] = 1752392040;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(_QWORD *)&v961[56] = v798;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              _os_log_impl((void *)&_mh_execute_header, v776, OS_LOG_TYPE_FAULT, "[Q%u] Unable to create the denial of existence record set - error: %{public}s, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.", v961, 0x58u);
                                                              goto LABEL_1924;
                                                            }
LABEL_1879:
                                                            v789 = *v787;
                                                            if (v789 <= 0x3F)
                                                            {
                                                              if (!*v787)
                                                              {
                                                                v788 = (_WORD)v787 - (_WORD)v480 + 1;
                                                                goto LABEL_1922;
                                                              }
                                                              v787 += v789 + 1;
                                                              if (v480 != (unsigned __int8 *)-256)
                                                                continue;
                                                              goto LABEL_1878;
                                                            }
                                                            break;
                                                          }
                                                        }
                                                        v788 = 257;
                                                        goto LABEL_1922;
                                                      }
                                                      v886 = (uint64_t)v774;
                                                      if ((v775 & 1) != 0)
                                                      {
                                                        v776 = mDNSLogCategory_DNSSEC_redacted;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          if (v480)
                                                          {
                                                            v777 = v480;
                                                            if (v480 == (unsigned __int8 *)-256)
                                                              goto LABEL_1833;
LABEL_1830:
                                                            v778 = 257;
                                                            if (v777 < v480 + 256 && v777)
                                                            {
                                                              while (1)
                                                              {
                                                                v779 = *v777;
                                                                if (v779 > 0x3F)
                                                                {
LABEL_1885:
                                                                  v778 = 257;
                                                                  goto LABEL_1890;
                                                                }
                                                                if (!*v777)
                                                                  break;
                                                                v777 += v779 + 1;
                                                                if (v480 != (unsigned __int8 *)-256)
                                                                  goto LABEL_1830;
LABEL_1833:
                                                                if (!v777)
                                                                  goto LABEL_1885;
                                                              }
                                                              v778 = (_WORD)v777 - (_WORD)v480 + 1;
                                                            }
LABEL_1890:
                                                            v790 = v778;
                                                          }
                                                          else
                                                          {
                                                            v790 = 0;
                                                          }
                                                          v792 = DNSTypeName(v839);
                                                          v793 = *(unsigned int *)(v886 + 16);
                                                          v794 = "<fatal: this should never be returned>";
                                                          if (v793 <= 6)
                                                            v794 = off_10013CEA8[v793];
                                                          goto LABEL_1898;
                                                        }
                                                      }
                                                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        if (v480)
                                                        {
                                                          v784 = v480;
                                                          if (v480 == (unsigned __int8 *)-256)
                                                            goto LABEL_1860;
LABEL_1857:
                                                          v785 = 257;
                                                          if (v784 < v480 + 256 && v784)
                                                          {
                                                            while (1)
                                                            {
                                                              v786 = *v784;
                                                              if (v786 > 0x3F)
                                                              {
LABEL_1886:
                                                                v785 = 257;
                                                                goto LABEL_1895;
                                                              }
                                                              if (!*v784)
                                                                break;
                                                              v784 += v786 + 1;
                                                              if (v480 != (unsigned __int8 *)-256)
                                                                goto LABEL_1857;
LABEL_1860:
                                                              if (!v784)
                                                                goto LABEL_1886;
                                                            }
                                                            v785 = (_WORD)v784 - (_WORD)v480 + 1;
                                                          }
LABEL_1895:
                                                          v790 = v785;
                                                        }
                                                        else
                                                        {
                                                          v790 = 0;
                                                        }
                                                        v792 = DNSTypeName(v839);
                                                        v795 = *(unsigned int *)(v886 + 16);
                                                        v794 = "<fatal: this should never be returned>";
                                                        if (v795 <= 6)
                                                          v794 = off_10013CEA8[v795];
LABEL_1898:
                                                        *(_DWORD *)v961 = 67110659;
                                                        *(_DWORD *)&v961[4] = v829;
                                                        *(_WORD *)&v961[8] = 2160;
                                                        *(_QWORD *)&v961[10] = 1752392040;
                                                        *(_WORD *)&v961[18] = 1040;
                                                        *(_DWORD *)&v961[20] = v790;
                                                        *(_WORD *)&v961[24] = 2101;
                                                        *(_QWORD *)&v961[26] = v480;
                                                        *(_WORD *)&v961[34] = 2160;
                                                        *(_QWORD *)&v961[36] = 1752392040;
                                                        *(_WORD *)&v961[44] = 2085;
                                                        *(_QWORD *)&v961[46] = v792;
                                                        *(_WORD *)&v961[54] = 2082;
                                                        *(_QWORD *)&v961[56] = v794;
                                                        _os_log_impl((void *)&_mh_execute_header, v776, OS_LOG_TYPE_DEFAULT, "[Q%u] Create the denial of existence record set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, denial type: %{public}s", v961, 0x40u);
                                                      }
                                                      v772 = *(_QWORD *)(v703 + 64);
                                                      if (!v772)
                                                      {
                                                        v799 = mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          v16 = (void *)a10;
                                                          v475 = v909;
                                                          v533 = v881;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                          {
LABEL_1928:
                                                            *(_DWORD *)v961 = 136447234;
                                                            *(_QWORD *)&v961[4] = "me->dnssec != NULL";
                                                            *(_WORD *)&v961[12] = 2082;
                                                            *(_QWORD *)&v961[14] = "";
                                                            *(_WORD *)&v961[22] = 2082;
                                                            *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources"
                                                                                   "/mDNSResponder/mDNSMacOSX/dnssec_v2/d"
                                                                                   "nssec_mdns_core.c";
                                                            *(_WORD *)&v961[32] = 1024;
                                                            *(_DWORD *)&v961[34] = 333;
                                                            *(_WORD *)&v961[38] = 2048;
                                                            *(_QWORD *)&v961[40] = 0;
                                                            v800 = v799;
LABEL_1943:
                                                            _os_log_impl((void *)&_mh_execute_header, v800, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v961, 0x30u);
                                                            goto LABEL_1908;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v799 = mDNSLogCategory_DNSSEC_redacted;
                                                          v16 = (void *)a10;
                                                          v475 = v909;
                                                          v533 = v881;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                          {
                                                            goto LABEL_1928;
                                                          }
                                                        }
                                                        goto LABEL_1908;
                                                      }
                                                    }
                                                    if (*(_DWORD *)(v772 + 32))
                                                    {
                                                      v801 = mDNSLogCategory_DNSSEC;
                                                      v16 = (void *)a10;
                                                      v533 = v881;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        v475 = v909;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1932:
                                                          *(_DWORD *)v961 = 136447234;
                                                          *(_QWORD *)&v961[4] = "me->aware_type == dnssec_aware_rr_to_validate";
                                                          *(_WORD *)&v961[12] = 2082;
                                                          *(_QWORD *)&v961[14] = "";
                                                          *(_WORD *)&v961[22] = 2082;
                                                          *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v961[32] = 1024;
                                                          *(_DWORD *)&v961[34] = 159;
                                                          *(_WORD *)&v961[38] = 2048;
                                                          *(_QWORD *)&v961[40] = 0;
                                                          v800 = v801;
                                                          goto LABEL_1943;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v801 = mDNSLogCategory_DNSSEC_redacted;
                                                        v475 = v909;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1932;
                                                        }
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v16 = (void *)a10;
                                                      v533 = v881;
                                                      if (!*(_BYTE *)(v772 + 40))
                                                      {
                                                        if (v886)
                                                          ++*(_DWORD *)v886;
                                                        v796 = *(_QWORD **)(v772 + 48);
                                                        if (v796)
                                                          ref_count_obj_release(v796);
                                                        *(_QWORD *)(v772 + 48) = v886;
LABEL_1907:
                                                        v475 = v909;
                                                        goto LABEL_1908;
                                                      }
                                                      v802 = mDNSLogCategory_DNSSEC;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        v475 = v909;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1942:
                                                          *(_DWORD *)v961 = 136447234;
                                                          *(_QWORD *)&v961[4] = "!me->u.rr_to_validate.positive";
                                                          *(_WORD *)&v961[12] = 2082;
                                                          *(_QWORD *)&v961[14] = "";
                                                          *(_WORD *)&v961[22] = 2082;
                                                          *(_QWORD *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v961[32] = 1024;
                                                          *(_DWORD *)&v961[34] = 160;
                                                          *(_WORD *)&v961[38] = 2048;
                                                          *(_QWORD *)&v961[40] = 0;
                                                          v800 = v802;
                                                          goto LABEL_1943;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v802 = mDNSLogCategory_DNSSEC_redacted;
                                                        v475 = v909;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1942;
                                                        }
                                                      }
                                                    }
                                                    goto LABEL_1908;
                                                  }
                                                }
                                                else
                                                {
                                                  v475 = 0;
                                                  v899 = 0;
                                                  v897 = 3601;
                                                  v873 = 1;
                                                  if (!v505)
                                                    goto LABEL_1274;
                                                }
                                              }
                                              else
                                              {
                                                v899 = 0;
                                                v933 = 0u;
                                                v932 = 0u;
                                                v931 = 0u;
                                                v930 = 0u;
                                                v929 = 0u;
                                                v928 = 0u;
                                                v927 = 0u;
                                                v926 = 0u;
                                                v925 = 0u;
                                                v924 = 0u;
                                                v923 = 0u;
                                                v922 = 0u;
                                                v921 = 0u;
                                                v920 = 0u;
                                                v897 = 3601;
                                                v873 = 1;
                                                v919 = 0u;
                                                __dst = 0u;
                                                if (!v505)
                                                  goto LABEL_1274;
                                              }
                                              v524 = v511[2];
                                              if (!v524)
                                              {
                                                v529 = 1;
                                                v16 = (void *)a10;
                                                goto LABEL_1276;
                                              }
                                              v386 = v906;
LABEL_1248:
                                              v525 = v504;
                                              if (v906)
                                              {
                                                v526 = *(_QWORD **)(v524 + 56);
                                                if (v526)
                                                  v526 = (_QWORD *)v526[3];
                                                if (v526 != a9 || !Client_SameNameCacheRecordIsAnswer(v524, v906))
                                                  goto LABEL_1269;
LABEL_1256:
                                                if (*(_BYTE *)(v524 + 109))
                                                  v527 = dword_100158E08 + 939524096;
                                                else
                                                  v527 = *(_DWORD *)(v524 + 80) + 1000 * *(_DWORD *)(v524 + 16);
                                                if (((v527 - *(_DWORD *)(a1 + 64) > 0) & ~v475) != 0)
                                                {
                                                  v529 = 0;
LABEL_1281:
                                                  a2 = v900;
                                                  v16 = (void *)a10;
                                                  if (a10)
                                                    goto LABEL_1286;
LABEL_1282:
                                                  if (v953 == 6)
                                                    goto LABEL_1286;
                                                  v530 = IsLocalDomain(v955);
                                                  v531 = v909;
                                                  if (!v530)
                                                    v531 = 1;
                                                  if ((v531 & 1) != 0)
                                                    goto LABEL_1286;
                                                  if (!v529)
                                                  {
                                                    v556 = mDNSLogCategory_Default;
                                                    v533 = v881;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))goto LABEL_1907;
                                                      v557 = v951;
                                                      v558 = bswap32(v952) >> 16;
                                                      for (n = v955; ; n += v563 + 1)
                                                      {
                                                        v560 = 257;
                                                        if (n >= v956 || !n)
                                                          goto LABEL_1353;
                                                        v563 = *n;
                                                        if (v563 > 0x3F)
                                                        {
                                                          v560 = 257;
                                                          goto LABEL_1353;
                                                        }
                                                        if (!*n)
                                                          break;
                                                      }
                                                      v560 = (_WORD)n - (unsigned __int16)v955 + 1;
                                                    }
                                                    else
                                                    {
                                                      v556 = mDNSLogCategory_Default_redacted;
                                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1907;
                                                      v557 = v951;
                                                      v558 = bswap32(v952) >> 16;
                                                      for (ii = v955; ; ii += v561 + 1)
                                                      {
                                                        v560 = 257;
                                                        if (ii >= v956 || !ii)
                                                          goto LABEL_1353;
                                                        v561 = *ii;
                                                        if (v561 > 0x3F)
                                                        {
                                                          v560 = 257;
                                                          goto LABEL_1353;
                                                        }
                                                        if (!*ii)
                                                          break;
                                                      }
                                                      v560 = (_WORD)ii - (unsigned __int16)v955 + 1;
                                                    }
LABEL_1353:
                                                    v566 = v560;
                                                    v567 = DNSTypeName(v953);
                                                    *(_DWORD *)v961 = 67110403;
                                                    *(_DWORD *)&v961[4] = v557;
                                                    *(_WORD *)&v961[8] = 1024;
                                                    *(_DWORD *)&v961[10] = v558;
                                                    *(_WORD *)&v961[14] = 2160;
                                                    *(_QWORD *)&v961[16] = 1752392040;
                                                    *(_WORD *)&v961[24] = 1040;
                                                    *(_DWORD *)&v961[26] = v566;
                                                    *(_WORD *)&v961[30] = 2101;
                                                    *(_QWORD *)&v961[32] = v955;
                                                    *(_WORD *)&v961[40] = 2082;
                                                    *(_QWORD *)&v961[42] = v567;
                                                    _os_log_impl((void *)&_mh_execute_header, v556, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Skipping check and not creating a negative cache entry for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", v961, 0x32u);
LABEL_1867:
                                                    v475 = v909;
LABEL_1868:
                                                    v533 = v881;
                                                    goto LABEL_1908;
                                                  }
                                                  v533 = v881;
                                                  if (v851)
                                                    goto LABEL_1907;
                                                  v534 = mDNSLogCategory_Default;
                                                  v475 = v909;
                                                  if (gSensitiveLoggingEnabled != 1
                                                    || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                  {
                                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      v539 = v951;
                                                      v540 = bswap32(v952) >> 16;
                                                      for (jj = v955; ; jj += v565 + 1)
                                                      {
                                                        v542 = 257;
                                                        if (jj >= v956 || !jj)
                                                          goto LABEL_1359;
                                                        v565 = *jj;
                                                        if (v565 > 0x3F)
                                                        {
                                                          v542 = 257;
                                                          goto LABEL_1359;
                                                        }
                                                        if (!*jj)
                                                          break;
                                                      }
                                                      v542 = (_WORD)jj - (unsigned __int16)v955 + 1;
LABEL_1359:
                                                      v568 = v542;
                                                      v569 = DNSTypeName(v953);
                                                      *(_DWORD *)v961 = 67110403;
                                                      *(_DWORD *)&v961[4] = v539;
                                                      *(_WORD *)&v961[8] = 1024;
                                                      *(_DWORD *)&v961[10] = v540;
                                                      *(_WORD *)&v961[14] = 2160;
                                                      *(_QWORD *)&v961[16] = 1752392040;
                                                      *(_WORD *)&v961[24] = 1040;
                                                      *(_DWORD *)&v961[26] = v568;
                                                      *(_WORD *)&v961[30] = 2101;
                                                      *(_QWORD *)&v961[32] = v955;
                                                      *(_WORD *)&v961[40] = 2082;
                                                      *(_QWORD *)&v961[42] = v569;
                                                      _os_log_impl((void *)&_mh_execute_header, v534, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Generate negative response for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", v961, 0x32u);
                                                      v475 = v909;
                                                      v533 = v881;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v534 = mDNSLogCategory_Default_redacted;
                                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      v539 = v951;
                                                      v540 = bswap32(v952) >> 16;
                                                      for (kk = v955; ; kk += v543 + 1)
                                                      {
                                                        v542 = 257;
                                                        if (kk >= v956 || !kk)
                                                          goto LABEL_1359;
                                                        v543 = *kk;
                                                        if (v543 > 0x3F)
                                                        {
                                                          v542 = 257;
                                                          goto LABEL_1359;
                                                        }
                                                        if (!*kk)
                                                          break;
                                                      }
                                                      v542 = (_WORD)kk - (unsigned __int16)v955 + 1;
                                                      goto LABEL_1359;
                                                    }
                                                  }
                                                  *(_QWORD *)(a1 + 208) = v902;
                                                  if (*(_BYTE *)(v902 + 652))
                                                    *(_WORD *)(v902 + 346) = *((_WORD *)a2 + 1);
                                                  GenerateNegativeResponseEx(a1, 0, 3, *((unsigned __int16 *)a2 + 1), v535, v536, v537, v538, v820);
                                                  *(_QWORD *)(a1 + 208) = 0;
LABEL_1908:
                                                  if (v475
                                                    && (v797 = (v533 + 1),
                                                        v881 = v797,
                                                        v797 < v856))
                                                  {
                                                    v480 = &v934[256 * v797];
                                                    v477 = DomainNameHashValue((unint64_t)v480);
                                                  }
                                                  else
                                                  {
                                                    v477 = 0;
                                                    v480 = 0;
                                                  }
                                                  if (!v869 && v886)
                                                  {
                                                    ref_count_obj_release((_QWORD *)v886);
                                                    v886 = 0;
                                                  }
                                                  if (!v480)
                                                  {
                                                    v471 = v827;
                                                    Question = v843;
                                                    goto LABEL_1944;
                                                  }
                                                  continue;
                                                }
                                                v504 = (int8x8_t *)v524;
                                                if (*(unsigned __int8 *)(v524 + 8) != 240)
                                                {
                                                  if (*(_BYTE *)(v524 + 10) == 2)
                                                  {
                                                    v528 = mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1267;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v528 = mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1267:
                                                        GetRRDisplayString_rdb((unsigned __int8 *)(v524 + 8), (unsigned __int16 *)(*(_QWORD *)(v524 + 48) + 4), v861);
                                                        *(_DWORD *)v961 = 141558275;
                                                        *(_QWORD *)&v961[4] = 1752392040;
                                                        *(_WORD *)&v961[12] = 2085;
                                                        *(_QWORD *)&v961[14] = v861;
                                                        _os_log_impl((void *)&_mh_execute_header, v528, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveNoUnicastAnswers: Removing expired record%{sensitive, mask.hash}s", v961, 0x16u);
                                                      }
                                                    }
                                                    a1 = v878;
                                                    mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v524);
                                                  }
LABEL_1269:
                                                  v504 = v525;
                                                }
                                                v524 = *(_QWORD *)v524;
                                                if (!v524)
                                                {
                                                  v529 = 1;
                                                  goto LABEL_1281;
                                                }
                                                goto LABEL_1248;
                                              }
                                              break;
                                            }
                                            if (SameNameRecordAnswersQuestion((unsigned __int8 *)(v524 + 8), 0, v902, v506, v507, v508, v509, v510))
                                            {
                                              goto LABEL_1256;
                                            }
                                            goto LABEL_1269;
                                          }
                                          v476 = ExpectingUnicastResponseForQuestion(*(_QWORD *)(a1 + 192), v824, *(_WORD *)a2, (uint64_t)v949, __src == 0);
                                          v475 = v909;
                                          if (v476)
                                          {
                                            v827 = v471;
                                            v831 = 0;
                                            v851 = 0;
                                            v839 = 0;
                                            v477 = v950;
                                            v902 = v476;
                                            v829 = bswap32(*(unsigned __int16 *)(v476 + 340)) >> 16;
                                            goto LABEL_1132;
                                          }
                                        }
LABEL_1944:
                                        v803 = ++v471 >= *((unsigned __int16 *)a2 + 2) || Question == 0;
                                        v472 = v870;
                                        if (v803 || (unint64_t)Question >= v870)
                                        {
                                          v805 = v865;
                                          if (NewCacheEntry)
                                          {
                                            v806 = mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)v961 = 0;
                                                goto LABEL_1965;
                                              }
                                            }
                                            else
                                            {
                                              v806 = mDNSLogCategory_Default_redacted;
                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)v961 = 0;
LABEL_1965:
                                                _os_log_impl((void *)&_mh_execute_header, v806, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveNoUnicastAnswers: SOARecord not used", v961, 2u);
                                              }
                                            }
                                            ReleaseCacheRecord(a1, NewCacheEntry);
                                          }
                                          if (!v869)
                                          {
                                            if (v877)
                                              ref_count_obj_release(v877);
                                            v808 = v863;
LABEL_1971:
                                            v810 = HIBYTE(v912);
                                            if (HIBYTE(v912))
                                            {
                                              v811 = (_QWORD **)v960;
                                              do
                                              {
                                                if (*v811)
                                                {
                                                  ref_count_obj_release(*v811);
                                                  *v811 = 0;
                                                }
                                                ++v811;
                                                --v810;
                                              }
                                              while (v810);
                                            }
                                            if (v805)
                                            {
                                              v812 = v805;
                                              v813 = (_QWORD **)v959;
                                              do
                                              {
                                                if (*v813)
                                                {
                                                  ref_count_obj_release(*v813);
                                                  *v813 = 0;
                                                }
                                                ++v813;
                                                --v812;
                                              }
                                              while (v812);
                                            }
                                            if (v808)
                                            {
                                              v814 = v808;
                                              v815 = (_QWORD **)v958;
                                              do
                                              {
                                                if (*v815)
                                                {
                                                  ref_count_obj_release(*v815);
                                                  *v815 = 0;
                                                }
                                                ++v815;
                                                --v814;
                                              }
                                              while (v814);
                                            }
                                            v816 = v912;
                                            if ((_BYTE)v912)
                                            {
                                              v817 = (_QWORD **)v957;
                                              do
                                              {
                                                if (*v817)
                                                {
                                                  ref_count_obj_release(*v817);
                                                  *v817 = 0;
                                                }
                                                ++v817;
                                                --v816;
                                              }
                                              while (v816);
                                            }
                                          }
                                          goto LABEL_1991;
                                        }
                                      }
                                    }
                                  }
                                  if (!v467)
                                  {
                                    v808 = 0;
                                    v805 = 0;
                                    goto LABEL_1971;
                                  }
LABEL_1991:
                                  v94 = v838;
                                }
                                if (v94)
                                  os_release(v94);
                                return;
                              }
                              v379 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                  goto LABEL_897;
                              }
                              else
                              {
                                v379 = mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_897:
                                  v382 = v252[2].i32[0];
                                  GetRRDisplayString_rdb((unsigned __int8 *)&v252[1], (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), v855);
                                  *(_DWORD *)v961 = 67109635;
                                  *(_DWORD *)&v961[4] = v382;
                                  *(_WORD *)&v961[8] = 2160;
                                  *(_QWORD *)&v961[10] = 1752392040;
                                  *(_WORD *)&v961[18] = 2085;
                                  *(_QWORD *)&v961[20] = v855;
                                  LOBYTE(v25) = v868;
                                  _os_log_impl((void *)&_mh_execute_header, v379, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: rescuing RR with new TTL %u: %{sensitive, mask.hash}s", v961, 0x1Cu);
                                }
                              }
                              v383 = v252[8];
                              v16 = (void *)a10;
                              if (*(_QWORD *)&v383 && !*(_DWORD *)(*(_QWORD *)&v383 + 32) && *(_QWORD *)&v252[12])
                              {
                                v384 = *(_DWORD *)(v878 + 64);
                                if (v384 <= 1)
                                  v384 = 1;
                                *(_DWORD *)(v878 + 160) = v384;
                              }
                              goto LABEL_877;
                            }
                            a3 = v870;
                            if (v252[13].i8[5])
                              v358 = dword_100158E08 + 939524096;
                            else
                              v358 = v252[10].i32[0] + 1000 * v252[2].i32[0];
                            v16 = (void *)a10;
                            v94 = v837;
                            if (v358 - *(_DWORD *)(a1 + 64) < 1001)
                            {
                              v300 = 0;
                              goto LABEL_673;
                            }
                            if (v252[1].i16[2] == 12)
                            {
                              v359 = (unsigned __int8 *)(*(_QWORD *)&v252[6] + 4);
                              v360 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v252[5]);
                              v361 = mDNS_DomainNameFNV1aHash(v359);
                            }
                            else
                            {
                              v360 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v252[5]);
                              v361 = 0;
                            }
                            *(_QWORD *)&v934[8] = 0;
                            *(_QWORD *)v934 = 0;
                            gettimeofday((timeval *)v934, 0);
                            v367 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)a1, a10, 1, v362, v363, v364, v365, v366);
                            v368 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                goto LABEL_867;
                            }
                            else
                            {
                              v368 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_867:
                                v369 = v252[1].u16[2];
                                *(_DWORD *)v961 = 67111171;
                                *(_DWORD *)&v961[4] = v360;
                                *(_WORD *)&v961[8] = 1024;
                                *(_DWORD *)&v961[10] = v369;
                                *(_WORD *)&v961[14] = 1040;
                                *(_DWORD *)&v961[16] = 16;
                                *(_WORD *)&v961[20] = 2098;
                                *(_QWORD *)&v961[22] = v934;
                                *(_WORD *)&v961[30] = 1024;
                                *(_DWORD *)&v961[32] = v367;
                                *(_WORD *)&v961[36] = 2160;
                                *(_QWORD *)&v961[38] = 1752392040;
                                *(_WORD *)&v961[46] = 1045;
                                *(_DWORD *)&v961[48] = 20;
                                *(_WORD *)&v961[52] = 2101;
                                *(_QWORD *)&v961[54] = (char *)v252 + 132;
                                *(_WORD *)&v961[62] = 1024;
                                *(_DWORD *)&v961[64] = v361;
                                _os_log_impl((void *)&_mh_execute_header, v368, OS_LOG_TYPE_DEFAULT, "Received Goodbye packet for cached record -- name hash: %x, type: %{mdns:rrtype}d, last time received: %{public, timeval}.*P, interface index: %d, source address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, name hash if PTR: %x", v961, 0x44u);
                              }
                            }
                            v252[2].i32[0] = 1;
                            a1 = v878;
                            v252[10].i32[0] = *(_DWORD *)(v878 + 64);
                            v252[13].i8[4] = 4;
                            SetNextCacheCheckTimeForRecord(v878, (uint64_t)v252);
                            v300 = 0;
                            a3 = v870;
                            goto LABEL_894;
                          }
                          v258 = *((_QWORD *)v858 + 7);
                          v259 = (uint64_t)v252[8];
                        }
                        if (resource_records_have_same_dnssec_rr_category(v258, v259))
                        {
                          v267 = *((unsigned __int16 *)v858 + 2);
                          a1 = v878;
                          v16 = (void *)a10;
                          v98 = v904;
                          if ((v267 == 5 || v252[1].i16[2] == 5)
                            && v252[2].i32[0]
                            && v267 != v252[1].u16[2]
                            && resource_record_as_rrsig_get_covered_type((uint64_t)v858) != 5
                            && resource_record_as_rrsig_get_covered_type((uint64_t)&v252[1]) != 5
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer(v858)
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer((unsigned __int8 *)&v252[1]))
                          {
                            v268 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              {
                                v282 = v252[1].u8[2];
                                v283 = "ghost";
                                if (v282 == 1)
                                  v283 = "immortal";
                                v35 = v282 == 0;
                                v284 = "mortal";
                                if (!v35)
                                  v284 = v283;
                                v823 = v284;
                                v25 = v855;
                                GetRRDisplayString_rdb((unsigned __int8 *)&v252[1], (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), v855);
                                v821 = DNSTypeName(v252[1].u16[2]);
                                if (v252[1].u8[0] == 240)
                                  v272 = ", Negative";
                                else
                                  v272 = "";
                                v273 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                                v98 = v904;
                                v274 = "";
                                if (*v858 == 240)
                                  v274 = ", Negative";
LABEL_618:
                                *(_DWORD *)v961 = 136447747;
                                *(_QWORD *)&v961[4] = v823;
                                *(_WORD *)&v961[12] = 2160;
                                *(_QWORD *)&v961[14] = 1752392040;
                                *(_WORD *)&v961[22] = 2085;
                                *(_QWORD *)&v961[24] = v25;
                                LOBYTE(v25) = v868;
                                *(_WORD *)&v961[32] = 2082;
                                *(_QWORD *)&v961[34] = v821;
                                *(_WORD *)&v961[42] = 2082;
                                *(_QWORD *)&v961[44] = v272;
                                a2 = v900;
                                *(_WORD *)&v961[52] = 2082;
                                *(_QWORD *)&v961[54] = v273;
                                *(_WORD *)&v961[62] = 2082;
                                *(_QWORD *)&v961[64] = v274;
                                _os_log_impl((void *)&_mh_execute_header, v268, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding (%{public}s) %{sensitive, mask.hash}s rrtype change from (%{public}s%{public}s) to (%{public}s%{public}s)", v961, 0x48u);
                              }
                            }
                            else
                            {
                              v268 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                v269 = v252[1].u8[2];
                                v270 = "ghost";
                                if (v269 == 1)
                                  v270 = "immortal";
                                v35 = v269 == 0;
                                v271 = "mortal";
                                if (!v35)
                                  v271 = v270;
                                v823 = v271;
                                v25 = v855;
                                GetRRDisplayString_rdb((unsigned __int8 *)&v252[1], (unsigned __int16 *)(*(_QWORD *)&v252[6] + 4), v855);
                                v821 = DNSTypeName(v252[1].u16[2]);
                                if (v252[1].u8[0] == 240)
                                  v272 = ", Negative";
                                else
                                  v272 = "";
                                v273 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                                v98 = v904;
                                v274 = "";
                                if (*v858 == 240)
                                  v274 = ", Negative";
                                goto LABEL_618;
                              }
                            }
                            mDNS_PurgeCacheResourceRecord((unsigned int *)v878, (uint64_t)v252);
                            v16 = (void *)a10;
                          }
LABEL_633:
                          v94 = v837;
                          goto LABEL_634;
                        }
                        a1 = v878;
                        v16 = (void *)a10;
                        v94 = v837;
                        v98 = v904;
LABEL_634:
                        v252 = (int8x8_t *)*v252;
                        if (!v252)
                        {
                          a3 = v870;
                          break;
                        }
                      }
                    }
                    v23 = v858;
                    v113 = v883;
                  }
                  else
                  {
                    v848 = 0;
                  }
                  if (!*((_DWORD *)v23 + 2))
                    goto LABEL_701;
                  v289 = *v23;
                  if ((*v23 & 0x10) != 0)
                  {
                    v295 = *(_DWORD *)(a1 + 64) + 1000;
                    if (v295 <= 1)
                      v290 = 1;
                    else
                      v290 = v295;
                  }
                  else
                  {
                    v290 = CheckForSoonToExpireRecordsEx(a1, *((_BYTE **)v23 + 4), *((_DWORD *)v23 + 4), -1, -1);
                  }
                  v296 = CreateNewCacheEntryEx(a1, v842, v848, v290, 1, (uint64_t)v850, v832, v108);
                  if (v296)
                  {
                    v252 = (int8x8_t *)v296;
                    v297 = *((_WORD *)a2 + 1);
                    *(_WORD *)(v296 + 110) = v297;
                    *(_BYTE *)(v296 + 9) = HIBYTE(v297) & 0xF;
                    if ((v289 & 0x10) != 0)
                    {
                      *v834 = (int8x8_t)v296;
                      v300 = 1;
                      *(_QWORD *)(v296 + 112) = 1;
                      v834 = (int8x8_t *)(v296 + 112);
                    }
                    else
                    {
                      v298 = *(_DWORD *)(v296 + 84);
                      if (v298)
                      {
                        v299 = a1 + 4 * v842;
                        if (*(_DWORD *)(v299 + 4264) - v298 >= 1)
                          *(_DWORD *)(v299 + 4264) = v298;
                        if (*(_DWORD *)(a1 + 88) - v298 >= 1)
                          *(_DWORD *)(a1 + 88) = v298;
                      }
                      v300 = 1;
                    }
                    goto LABEL_673;
                  }
LABEL_674:
                  v23 = v858;
LABEL_700:
                  v113 = v883;
                  goto LABEL_701;
                }
                v341 = mDNSLogCategory_mDNS;
                v342 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
                v23 = v858;
                if (v342)
                {
                  a3 = v870;
                  v16 = (void *)a10;
                  v113 = v883;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
                    v343 = *(_QWORD *)(v847 + 32);
                    if (v343)
                    {
                      v344 = *(_BYTE **)(v847 + 32);
                      if (v343 == -256)
                      {
LABEL_776:
                        while (v344)
                        {
                          v345 = *v344;
                          if (v345 > 0x3F)
                            break;
                          if (!*v344)
                          {
                            LOWORD(v344) = (_WORD)v344 - v343 + 1;
                            goto LABEL_822;
                          }
                          v344 += v345 + 1;
                          if (v343 != -256)
                            goto LABEL_775;
                        }
                      }
                      else
                      {
LABEL_775:
                        if ((unint64_t)v344 < v343 + 256)
                          goto LABEL_776;
                      }
                      LOWORD(v344) = 257;
LABEL_822:
                      LODWORD(v344) = (unsigned __int16)v344;
                    }
                    else
                    {
                      LODWORD(v344) = 0;
                    }
LABEL_825:
                    *(_DWORD *)v961 = 67110147;
                    *(_DWORD *)&v961[4] = v325;
                    *(_WORD *)&v961[8] = 1024;
                    *(_DWORD *)&v961[10] = 604800;
                    *(_WORD *)&v961[14] = 2160;
                    *(_QWORD *)&v961[16] = 1752392040;
                    *(_WORD *)&v961[24] = 1040;
                    *(_DWORD *)&v961[26] = (_DWORD)v344;
                    *(_WORD *)&v961[30] = 2101;
                    *(_QWORD *)&v961[32] = v343;
                    _os_log_impl((void *)&_mh_execute_header, v341, OS_LOG_TYPE_ERROR, "AddOrUpdateTSRForCacheGroup: tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v961, 0x28u);
                  }
                }
                else
                {
                  v341 = mDNSLogCategory_mDNS_redacted;
                  v346 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
                  a3 = v870;
                  v16 = (void *)a10;
                  v113 = v883;
                  if (v346)
                  {
                    v343 = *(_QWORD *)(v847 + 32);
                    if (v343)
                    {
                      v344 = *(_BYTE **)(v847 + 32);
                      if (v343 == -256)
                      {
LABEL_785:
                        while (v344)
                        {
                          v347 = *v344;
                          if (v347 > 0x3F)
                            break;
                          if (!*v344)
                          {
                            LOWORD(v344) = (_WORD)v344 - v343 + 1;
                            goto LABEL_824;
                          }
                          v344 += v347 + 1;
                          if (v343 != -256)
                            goto LABEL_784;
                        }
                      }
                      else
                      {
LABEL_784:
                        if ((unint64_t)v344 < v343 + 256)
                          goto LABEL_785;
                      }
                      LOWORD(v344) = 257;
LABEL_824:
                      LODWORD(v344) = (unsigned __int16)v344;
                    }
                    else
                    {
                      LODWORD(v344) = 0;
                    }
                    goto LABEL_825;
                  }
                }
                a1 = v878;
                goto LABEL_527;
              }
              a1 = v878;
              a3 = v870;
              v16 = (void *)a10;
              v23 = v858;
            }
            v94 = v837;
            goto LABEL_700;
        }
        v113 = v883;
        if (!v112)
          goto LABEL_206;
LABEL_205:
        ref_count_obj_release(v112);
        *((_QWORD *)v23 + 7) = 0;
        goto LABEL_206;
      }
    }
  }
}

uint64_t IsResponseMDNSEquivalent(uint64_t a1, uint64_t a2)
{
  _UNKNOWN **v2;

  if (!a1)
    return 1;
  v2 = *(_UNKNOWN ***)(a1 + 16);
  if (v2 != &_mdns_querier_kind)
  {
    if (v2 == &_mdns_subscriber_kind && a2 != 0)
      return (*(unsigned __int16 *)(a2 + 276) >> 14) & 1;
    return 1;
  }
  return 0;
}

_BYTE *DomainNamePtrAtTSRIndex(unsigned __int16 *a1, unint64_t a2, unsigned int a3)
{
  unsigned int v6;
  int v7;
  _BYTE *Answers;

  v6 = a1[3];
  if (v6 >= a3)
  {
    Answers = LocateAnswers((unint64_t)a1, a2);
    LOWORD(v6) = 0;
    if (!Answers)
      goto LABEL_13;
    goto LABEL_10;
  }
  v7 = a1[4];
  if (v7 + v6 >= a3)
  {
    Answers = LocateAuthorities((unint64_t)a1, a2);
    if (!Answers)
      goto LABEL_13;
    goto LABEL_10;
  }
  if (v7 + v6 + a1[5] < a3)
  {
    Answers = 0;
    goto LABEL_13;
  }
  Answers = LocateAdditionals((unint64_t)a1, a2);
  LOWORD(v6) = v7 + v6;
  if (Answers)
  {
LABEL_10:
    while (a3 > (unsigned __int16)v6)
    {
      Answers = skipResourceRecord((unint64_t)a1, Answers, a2);
      if (!Answers)
        break;
      LOWORD(v6) = v6 + 1;
    }
  }
LABEL_13:
  if ((unint64_t)Answers >= a2)
    return 0;
  else
    return Answers;
}

char *UnsafeBufferPointer(unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  char *v5;
  char *v6;
  uint64_t *i;
  uint64_t v8;
  NSObject *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  _DWORD v16[2];
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  _OWORD __src[16];
  uint64_t v22;

  memset(__src, 0, sizeof(__src));
  if (!getDomainName(a1, a2, a3, __src))
  {
    v9 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
LABEL_18:
        v12 = *(_DWORD *)(a4 + 4);
        v13 = *(_DWORD *)(a4 + 8);
        v14 = *(unsigned __int16 *)(a4 + 12);
        v16[0] = 67109632;
        v16[1] = v12;
        v17 = 1024;
        v18 = v13;
        v19 = 1024;
        v20 = v14;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "TSRDataRecCreate: Bad RR domain name for TSR - tsrTime %d tsrHost %x recIndex %u", (uint8_t *)v16, 0x14u);
      }
    }
    else
    {
      v9 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_18;
    }
    return 0;
  }
  v5 = (char *)malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
  if (!v5)
    __break(1u);
  v6 = v5;
  for (i = (uint64_t *)__src; i < &v22; i = (uint64_t *)((char *)i + v8 + 1))
  {
    if (!i)
      break;
    v8 = *(unsigned __int8 *)i;
    if (v8 > 0x3F)
      break;
    if (!*(_BYTE *)i)
    {
      v10 = (_DWORD)i - __src + 1;
      if ((unsigned __int16)v10 <= 0x100u)
      {
        memcpy(v5 + 20, __src, (unsigned __int16)v10);
        goto LABEL_16;
      }
      break;
    }
  }
  v5[20] = 0;
LABEL_16:
  v11 = *(_QWORD *)(a4 + 4);
  *((_DWORD *)v6 + 4) = *(_DWORD *)(a4 + 12);
  *((_QWORD *)v6 + 1) = v11;
  return v6;
}

uint64_t PacketRRMatchesSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  int v14;

  if (!a1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PacketRRMatchesSignature ERROR: pktrr is NULL", a4, a5, a6, a7, a8, v14);
    return 0;
  }
  v10 = *(_QWORD *)(a1 + 32);
  if (v10)
  {
    v11 = *(_QWORD *)(a2 + 32);
    if (v11 && v10 != v11)
      return 0;
  }
  if (((*(_BYTE *)(a2 + 8) & 0x32) == 0 || *(_DWORD *)(a2 + 126))
    && *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12))
  {
    return 0;
  }
  if (*(_QWORD *)(a2 + 32)
    || (result = mDNSPlatformValidRecordForInterface(a2, v10, a3, a4, a5, a6, a7, a8), (_DWORD)result))
  {
    if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
    {
      return SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40)) != 0;
    }
    return 0;
  }
  return result;
}

uint64_t *CheckTSRForAuthRecord(uint64_t *a1, int *a2, int a3, _BYTE *a4)
{
  uint64_t *result;

  result = mDNSGetTSRForAuthRecordNamed(a1, a4, a3);
  if (result)
    return (uint64_t *)CheckTSRForResourceRecord(a2, (uint64_t)(result + 1));
  return result;
}

uint64_t RecordInTheRRSet(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int covered_type;
  BOOL v7;

  v4 = *(unsigned __int16 *)(a2 + 16);
  v5 = *(unsigned __int16 *)(a1 + 4);
  covered_type = resource_record_as_rrsig_get_covered_type(a1);
  v7 = v4 == v5 || covered_type == v4;
  if (v7 && *(_DWORD *)(a2 + 8) == *(_DWORD *)(a1 + 16))
    return SameDomainNameBytes(*(_BYTE **)a2, *(_BYTE **)(a1 + 32));
  else
    return 0;
}

BOOL PacketRecordMatches(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24))
    return 0;
  v5 = a1;
  if (!resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a1 + 64), *(_QWORD *)(a2 + 64))
    || *(unsigned __int16 *)(v5 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(v5 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(v5 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(v5 + 28) != *(_DWORD *)(a2 + 28)
    || !SameRDataBody(v5 + 8, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(_BYTE **)(v5 + 40), *(_BYTE **)(a2 + 40)))
  {
    return 0;
  }
  do
  {
    v6 = v5;
    v5 = *(_QWORD *)(v5 + 88);
  }
  while (v5);
  return v6 == a3;
}

void mDNSCoreReceiveUpdate(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9;
  unsigned __int16 v11;
  __int128 *v12;
  unsigned __int16 *v16;
  _BYTE *v17;
  unint64_t v18;
  unsigned __int8 *OptRR;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  unsigned int v28;
  int v29;
  __int128 v30;
  _QWORD *v31;
  char v32;
  char v33;
  int v34;
  unsigned __int8 *Authorities;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  _BYTE *v43;
  int v44;
  size_t v45;
  void *v46;
  uint64_t v47;
  char v48;
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BYTE *v57;
  _BYTE *v58;
  uint64_t v59;
  unsigned __int16 v60;
  _WORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned __int8 *v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  unsigned int v76;
  _BYTE *v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  unsigned int v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  _BYTE *v91;
  int v92;
  unsigned __int8 *v93;
  int v94;
  int v95;
  _BYTE *v96;
  uint64_t v97;
  int v98;
  unsigned __int8 *v99;
  int v100;
  int v101;
  _BYTE *v102;
  uint64_t v103;
  int v104;
  unsigned __int8 *v105;
  int v106;
  int v107;
  uint64_t v108;
  int v109;
  unsigned __int8 *v110;
  int v111;
  int v112;
  int v113;
  unsigned __int8 *v114;
  unsigned int v115;
  int v116;
  int v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  unsigned int v121;
  uint64_t v122;
  int v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  unsigned int v127;
  int v128;
  int v129;
  int v130;
  uint64_t v131;
  BOOL v132;
  int v133;
  unsigned __int8 *v134;
  unsigned __int16 *v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  _QWORD *v142;
  int v145;
  unsigned __int16 v146;
  __int128 *v147;
  NSObject *v148;
  int v149;
  int *v150;
  char v151;
  __int128 v152;
  int v153;
  char v154[8];
  char v155[4];
  __int16 v156;
  __int16 v157;
  int v158;
  int v159;
  uint64_t v160;
  _BYTE *v161;
  _WORD *v162;
  uint64_t v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  int v171;
  char v172;
  int v173;
  char v174;
  __int16 v175;
  _BYTE *v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  _BYTE v189[25];
  int v190;
  int v191;
  __int16 v192;
  __int128 v193;
  uint64_t v194;
  _BYTE v195[256];
  _WORD v196[4];
  int v197;

  v9 = a7;
  v11 = a5;
  v12 = (__int128 *)a4;
  v152 = 0uLL;
  v153 = 0;
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received Update from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes", a4, a5, (uint64_t)a6, a7, a8, a4);
  if (a8)
  {
    v16 = *(unsigned __int16 **)(a1 + 15120);
    if (v16)
    {
      bzero(v154, 0x498uLL);
      if (*v16 == v9)
      {
        v17 = (_BYTE *)(a1 + 37921);
        if (mDNS_PacketLoggingEnabled == 1)
          DumpPacket(0, 0, (uint64_t)"UDP", v12, v11, a6, v9, (unsigned __int8 *)a2, a3, a8);
        v18 = a1 + 28972;
        OptRR = LocateOptRR(a2, a3, 20);
        if (OptRR)
        {
          v25 = a1 + 28960;
          if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0, 128, a1 + 37912)
            && *(unsigned __int8 *)(a1 + 37920) != 240
            && *(_WORD *)(a1 + 37924) == 41
            && (v26 = (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4),
                v27 = (unsigned __int16 *)((char *)v26 + *(unsigned __int16 *)(a1 + 37932)),
                v26 < v27))
          {
            v28 = 0;
            do
            {
              v29 = *v26;
              if (v29 == 4)
              {
                if (!*((_BYTE *)v26 + 4))
                {
                  v30 = *(_OWORD *)(v26 + 2);
                  v153 = *((_DWORD *)v26 + 5);
                  v152 = v30;
                }
              }
              else if (v29 == 2)
              {
                v28 = *((_DWORD *)v26 + 1);
              }
              v26 += 12;
            }
            while (v26 < v27);
          }
          else
          {
            v28 = 0;
          }
          *(_BYTE *)(a1 + 37920) = 0;
          *(_WORD *)(a1 + 38022) = 0;
          *v17 = 0;
          v31 = *(_QWORD **)(a1 + 37976);
          if (v31)
          {
            ref_count_obj_release(v31);
            *(_QWORD *)(a1 + 37976) = 0;
          }
        }
        else
        {
          v28 = 0;
          v25 = a1 + 28960;
        }
        *(_WORD *)v25 = *(_WORD *)a2;
        *(_WORD *)(v25 + 2) = 168;
        *(_QWORD *)(v25 + 4) = 0;
        if (v28 && *(_DWORD *)((char *)&v152 + 2))
        {
          v150 = (int *)(a1 + 19888);
          if (*(_DWORD *)(a1 + 19888) + *(unsigned __int16 *)(a2 + 8) < 10001)
          {
            v146 = v11;
            v147 = v12;
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received Update for H-MAC %.6a I-MAC %.6a Password %.6a seq %d", v20, v21, v22, v23, v24, (int)&v152 + 2);
            if (v28 >= 0x15180)
              v34 = 86400;
            else
              v34 = v28;
            v145 = v34;
            Authorities = LocateAuthorities(a2, a3);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(_QWORD *)(a1 + 12624), a8);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(_QWORD *)(a1 + 12616), a8);
            if (*(_WORD *)(a2 + 8) && Authorities && (unint64_t)Authorities < a3)
            {
              v41 = 0;
              v42 = a1 + 37912;
              v43 = (_BYTE *)(a1 + 37920);
              v149 = 1000 * v145;
              do
              {
                Authorities = GetLargeResourceRecord(a1, a2, Authorities, a3, a8, 160, v42);
                if (Authorities && *v43 != 240)
                {
                  v44 = *(unsigned __int16 *)(a1 + 37924);
                  switch(v44)
                  {
                    case 6:
                      v45 = 532;
                      break;
                    case 26:
                      v45 = 514;
                      break;
                    case 17:
                      v45 = 512;
                      break;
                    default:
                      v45 = *(unsigned __int16 *)(a1 + 37932);
                      break;
                  }
                  v46 = malloc_type_calloc(1uLL, v45 + 912, 0xF1748037uLL);
                  if (!v46)
                    __break(1u);
                  v47 = (uint64_t)v46;
                  if ((*v43 & 0x10) != 0)
                    v48 = 2;
                  else
                    v48 = 8;
                  v151 = v48;
                  *(_WORD *)(a1 + 37926) &= ~0x8000u;
                  if (*(_WORD *)(a1 + 37924) != 10
                    || ((v49 = *(_BYTE **)(a1 + 37952), *v49) ? (v50 = *v49 + 1) : (v50 = 0),
                        !SameDomainLabelPointer(&v49[v50], "\n_keepalive")))
                  {
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(_QWORD *)(a1 + 12624));
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(_QWORD *)(a1 + 12616));
                  }
                  mDNS_SetupResourceRecord(v47, 0, a8, *(_WORD *)(a1 + 37924), *(_DWORD *)(a1 + 37928), v151, 0, (uint64_t)SPSRecordCallback, v47);
                  v57 = *(_BYTE **)(a1 + 37952);
                  v58 = v57;
                  if (v57 == (_BYTE *)-256)
                  {
LABEL_63:
                    while (v58)
                    {
                      v59 = *v58;
                      if (v59 > 0x3F)
                        break;
                      if (!*v58)
                      {
                        v60 = (_WORD)v58 - (_WORD)v57 + 1;
                        if (v60 > 0x100u)
                          break;
                        memcpy((void *)(v47 + 652), v57, v60);
                        goto LABEL_71;
                      }
                      v58 += v59 + 1;
                      if (v57 != (_BYTE *)-256)
                        goto LABEL_62;
                    }
                  }
                  else
                  {
LABEL_62:
                    if (v58 < v57 + 256)
                      goto LABEL_63;
                  }
                  *(_BYTE *)(v47 + 652) = 0;
LABEL_71:
                  *(_WORD *)(v47 + 20) = GetRDLength((uint64_t)v43, 0, v51, v52, v53, v54, v55, v56);
                  v61 = *(_WORD **)(v47 + 48);
                  *v61 = v45;
                  memcpy(v61 + 2, (const void *)(*(_QWORD *)(a1 + 37960) + 4), v45);
                  *(_BYTE *)(v47 + 122) = 1;
                  *(_DWORD *)(v47 + 140) = v153;
                  *(_OWORD *)(v47 + 124) = v152;
                  if (*(_WORD *)(a1 + 37924) == 12)
                  {
                    v69 = *(unsigned __int8 **)(a1 + 37952);
                    v70 = *v69;
                    if (*v69)
                    {
                      v71 = 0;
                      v72 = -1;
                      v73 = *(_QWORD *)(a1 + 37952);
                      do
                      {
                        v74 = v71;
                        v75 = v73 + v70;
                        v76 = *(unsigned __int8 *)(v75 + 1);
                        v73 = v75 + 1;
                        v70 = v76;
                        ++v72;
                        ++v71;
                      }
                      while (v76);
                      if (v72 - 1 >= 0)
                      {
                        if (v72 != 1)
                        {
                          do
                          {
                            if (!*v69)
                              break;
                            v69 += *v69 + 1;
                            --v74;
                          }
                          while (v74 > 1);
                        }
                        if (SameDomainNameBytes(v69, "\ain-addr\x04arpa"))
                        {
                          v77 = *(_BYTE **)(a1 + 37952);
                          LODWORD(v78) = *v77;
                          if (!*v77)
                            goto LABEL_121;
                          v79 = -1;
                          v80 = -2;
                          v81 = -3;
                          LODWORD(v62) = -4;
                          v82 = *v77;
                          v83 = *(_QWORD *)(a1 + 37952);
                          do
                          {
                            v84 = v79;
                            v85 = v80;
                            v86 = v81;
                            v87 = v62;
                            v88 = v83 + v82;
                            v89 = *(unsigned __int8 *)(v88 + 1);
                            v83 = v88 + 1;
                            v82 = v89;
                            ++v79;
                            ++v80;
                            ++v81;
                            v62 = (v62 + 1);
                          }
                          while (v89);
                          v90 = v79 - 5;
                          if (v79 - 5 >= 0)
                          {
                            v91 = *(_BYTE **)(a1 + 37952);
                            if (v79 - 2 < 1)
                            {
LABEL_89:
                              if ((v78 - 4) >= 0xFFFFFFFD)
                              {
                                v92 = 0;
                                v78 = v78;
                                v93 = v91 + 1;
                                while (1)
                                {
                                  v95 = *v93++;
                                  v94 = v95;
                                  if ((v95 - 58) < 0xFFFFFFF6)
                                    break;
                                  v92 = v94 + 10 * v92 - 48;
                                  if (!--v78)
                                  {
                                    if (v92 <= 255)
                                    {
                                      *(_BYTE *)(v47 + 148) = v92;
                                      v96 = v77;
                                      if (v79 - 3 >= 1)
                                      {
                                        v96 = v77;
                                        do
                                        {
                                          if (!*v96)
                                            break;
                                          v96 += *v96 + 1;
                                          --v85;
                                        }
                                        while (v85 > 1);
                                      }
                                      v97 = *v96;
                                      if ((v97 - 4) >= 0xFFFFFFFD)
                                      {
                                        v98 = 0;
                                        v99 = v96 + 1;
                                        while (1)
                                        {
                                          v101 = *v99++;
                                          v100 = v101;
                                          if ((v101 - 58) < 0xFFFFFFF6)
                                            break;
                                          v98 = v100 + 10 * v98 - 48;
                                          if (!--v97)
                                          {
                                            if (v98 <= 255)
                                            {
                                              *(_BYTE *)(v47 + 149) = v98;
                                              v102 = v77;
                                              if (v79 - 4 >= 1)
                                              {
                                                v102 = v77;
                                                do
                                                {
                                                  if (!*v102)
                                                    break;
                                                  v102 += *v102 + 1;
                                                  --v86;
                                                }
                                                while (v86 > 1);
                                              }
                                              v103 = *v102;
                                              if ((v103 - 4) >= 0xFFFFFFFD)
                                              {
                                                v104 = 0;
                                                v105 = v102 + 1;
                                                while (1)
                                                {
                                                  v107 = *v105++;
                                                  v106 = v107;
                                                  if ((v107 - 58) < 0xFFFFFFF6)
                                                    break;
                                                  v104 = v106 + 10 * v104 - 48;
                                                  if (!--v103)
                                                  {
                                                    if (v104 <= 255)
                                                    {
                                                      *(_BYTE *)(v47 + 150) = v104;
                                                      if (v90 >= 1)
                                                      {
                                                        do
                                                        {
                                                          if (!*v77)
                                                            break;
                                                          v77 += *v77 + 1;
                                                          --v87;
                                                        }
                                                        while (v87 > 1);
                                                      }
                                                      v108 = *v77;
                                                      if ((v108 - 4) >= 0xFFFFFFFD)
                                                      {
                                                        v109 = 0;
                                                        v110 = v77 + 1;
                                                        while (1)
                                                        {
                                                          v112 = *v110++;
                                                          v111 = v112;
                                                          if ((v112 - 58) < 0xFFFFFFF6)
                                                            break;
                                                          v109 = v111 + 10 * v109 - 48;
                                                          if (!--v108)
                                                          {
                                                            if (v109 > 255)
                                                              goto LABEL_152;
                                                            *(_BYTE *)(v47 + 151) = v109;
                                                            v113 = 4;
                                                            goto LABEL_150;
                                                          }
                                                        }
                                                      }
                                                    }
                                                    goto LABEL_152;
                                                  }
                                                }
                                              }
                                            }
                                            goto LABEL_152;
                                          }
                                        }
                                      }
                                    }
                                    break;
                                  }
                                }
                              }
                            }
                            else
                            {
                              v91 = *(_BYTE **)(a1 + 37952);
                              while (*v91)
                              {
                                v91 += *v91 + 1;
                                if (--v84 <= 1)
                                {
                                  LODWORD(v78) = *v91;
                                  goto LABEL_89;
                                }
                              }
                            }
                          }
                          else
                          {
LABEL_121:
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetIPFromName: Need six labels in IPv4 reverse mapping name %##s", v64, v65, v66, v67, v68, *(_QWORD *)(a1 + 37952));
                          }
                        }
                        else if (SameDomainNameBytes(v69, "\x03ip6\x04arpa"))
                        {
                          v114 = *(unsigned __int8 **)(a1 + 37952);
                          v115 = *v114;
                          if (!*v114)
                            goto LABEL_151;
                          v116 = -1;
                          v117 = -32;
                          v118 = *(_QWORD *)(a1 + 37952);
                          do
                          {
                            v119 = v117;
                            v120 = v118 + v115;
                            v121 = *(unsigned __int8 *)(v120 + 1);
                            v118 = v120 + 1;
                            v115 = v121;
                            ++v116;
                            ++v117;
                          }
                          while (v121);
                          if (v116 - 33 >= 0)
                          {
                            if (v116 != 33)
                            {
                              do
                              {
                                if (!*v114)
                                  break;
                                v114 += *v114 + 1;
                                --v119;
                              }
                              while (v119 > 1);
                            }
                            v122 = 0;
                            while (*v114 == 1)
                            {
                              v123 = v114[1];
                              v124 = v123 - 48;
                              v125 = v123 - 65;
                              if ((v123 - 97) >= 6)
                                v126 = -1;
                              else
                                v126 = v123 - 87;
                              v127 = v123 - 55;
                              if (v125 > 5)
                                v127 = v126;
                              if (v124 <= 9)
                                v127 = v124;
                              if (v114[2] != 1)
                                break;
                              v128 = v114[3];
                              if ((v128 - 48) >= 0xA)
                              {
                                if ((v128 - 65) >= 6)
                                {
                                  if ((v128 - 97) > 5)
                                    break;
                                  v129 = -87;
                                }
                                else
                                {
                                  v129 = -55;
                                }
                              }
                              else
                              {
                                v129 = -48;
                              }
                              if ((v127 & 0x80000000) != 0)
                                break;
                              v130 = v129 + v128;
                              if (v130 < 0)
                                break;
                              *(_BYTE *)(v47 + 163 + v122--) = v127 | (16 * v130);
                              v114 += 4;
                              if (v122 == -16)
                              {
                                v113 = 6;
LABEL_150:
                                *(_DWORD *)(v47 + 144) = v113;
                                break;
                              }
                            }
                          }
                          else
                          {
LABEL_151:
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetIPFromName: Need 34 labels in IPv6 reverse mapping name %##s", v64, v65, v66, v67, v68, *(_QWORD *)(a1 + 37952));
                          }
                        }
                      }
                    }
LABEL_152:
                    if (*(_DWORD *)(v47 + 144))
                    {
                      v131 = *(_QWORD *)(a1 + 15112);
                      if (v131)
                        v132 = v131 == a8;
                      else
                        v132 = 1;
                      if (!v132)
                        mDNSPlatformUpdateProxyList(v131, v62, v63, v64, v65, v66, v67, v68);
                      *(_QWORD *)(a1 + 15112) = a8;
                    }
                  }
                  v133 = *(_DWORD *)(a1 + 64);
                  *(_DWORD *)(v47 + 164) = v133;
                  *(_DWORD *)(v47 + 168) = v149 + v133;
                  if (*(_DWORD *)(a1 + 108) - (v149 + v133) >= 1)
                    *(_DWORD *)(a1 + 108) = v149 + v133;
                  *(_DWORD *)(v47 + 176) = 0;
                  mDNS_Register_internal(a1, v47, v63, v64, v65, v66, v67, v68);
                  ++*v150;
                  mDNS_UpdateAllowSleep(a1);
                  v42 = a1 + 37912;
                  if (mDNS_LoggingEnabled == 1)
                  {
                    v134 = (unsigned __int8 *)(v47 + 8);
                    v148 = mDNSLogCategory_Default;
                    v135 = (unsigned __int16 *)(*(_QWORD *)(v47 + 48) + 4);
                    v136 = *v150;
                    GetRRDisplayString_rdb(v134, v135, (_BYTE *)(a1 + 47032));
                    v42 = a1 + 37912;
                    LogMsgWithLevel(v148, OS_LOG_TYPE_DEFAULT, "SPS Registered %4d %X %s", v137, v138, v139, v140, v141, v136);
                  }
                }
                *v43 = 0;
                *(_WORD *)(a1 + 38022) = 0;
                *v17 = 0;
                v142 = *(_QWORD **)(a1 + 37976);
                if (v142)
                {
                  ref_count_obj_release(v142);
                  *(_QWORD *)(a1 + 37976) = 0;
                }
              }
              while (++v41 < *(unsigned __int16 *)(a2 + 8)
                   && Authorities != 0
                   && (unint64_t)Authorities < a3);
            }
            v25 = a1 + 28960;
            if ((*(_BYTE *)(a1 + 28963) & 0xF) != 0)
            {
              v11 = v146;
              v12 = v147;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d: Out of memory", v36, v37, v38, v39, v40, (int)v147);
              ClearProxyRecords(a1, (uint64_t)&v152, *(_QWORD *)(a1 + 12624));
              ClearProxyRecords(a1, (uint64_t)&v152, *(_QWORD *)(a1 + 12616));
              v18 = a1 + 28972;
            }
            else
            {
              v155[0] = 32;
              v160 = 0;
              v161 = v195;
              v156 = 41;
              v196[0] = 264;
              v162 = v196;
              v163 = 0;
              v171 = 0;
              v172 = 0;
              v173 = 0;
              v174 = 0;
              v175 = 0;
              v164 = 0u;
              v165 = 0u;
              v166 = 0u;
              v167 = 0u;
              v168 = 0u;
              v169 = 0u;
              v170 = 0;
              v176 = v195;
              v191 = 0;
              v192 = 0;
              v194 = 0;
              v193 = 0u;
              v190 = 0;
              v195[0] = 0;
              v177 = 0u;
              v178 = 0u;
              v179 = 0u;
              v180 = 0u;
              v181 = 0u;
              v182 = 0u;
              v183 = 0u;
              v184 = 0u;
              v185 = 0u;
              v186 = 0u;
              v187 = 0u;
              v188 = 0u;
              memset(v189, 0, sizeof(v189));
              v157 = 1440;
              v158 = 4500;
              v159 = 1572888;
              v196[2] = 2;
              v197 = v145;
              v18 = PutResourceRecordTTLWithLimit(a1 + 28960, a1 + 28972, (_WORD *)(a1 + 28970), (uint64_t)v155, 0x1194uLL, a1 + 37912, v39, v40);
              v11 = v146;
              v12 = v147;
              if (!v18)
                goto LABEL_178;
            }
          }
          else
          {
            v32 = 5;
            if (mDNSCoreReceiveUpdate_msgs_262 <= 99)
            {
              ++mDNSCoreReceiveUpdate_msgs_262;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d: Too many records %d + %d = %d > %d", v20, v21, v22, v23, v24, (int)v12);
              v32 = *(_BYTE *)(v25 + 3) | 5;
            }
            *(_BYTE *)(v25 + 3) = v32;
          }
        }
        else
        {
          if (mDNSCoreReceiveUpdate_msgs > 99)
          {
            v33 = 1;
          }
          else
          {
            ++mDNSCoreReceiveUpdate_msgs;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d:%s%s", v20, v21, v22, v23, v24, (int)v12);
            v33 = *(_BYTE *)(v25 + 3) | 1;
          }
          *(_BYTE *)(v25 + 3) = v33;
        }
        mDNSSendDNSMessage(a1, v25, v18, a8, 0, *(unsigned __int16 **)(a1 + 15120), (int *)v12, v11, 0, 0);
LABEL_178:
        mDNS_SendKeepalives(a1);
      }
    }
  }
}

void mDNSCoreReceiveUpdateR(uint64_t a1, unsigned __int16 *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int PktLease;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _BYTE *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  _BYTE *v25;
  uint64_t v26;
  unsigned int v27;
  _BYTE *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  char *v44;
  char *v45;
  int v46;
  int v47;
  SCDynamicStoreRef v48;
  SCDynamicStoreRef v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int RemoteMacinternal;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  _BYTE *v62;
  CFTypeRef v63;
  const __CFDictionary *v64;
  CFStringRef v65;
  CFMutableDictionaryRef v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  CFStringRef v77;
  CFStringRef v78;
  const __CFDictionary *v79;
  const void *Value;
  NSObject *v81;
  char *v82;
  uint64_t v83;
  int *v84;
  uint64_t v85;
  uint64_t v86;
  unsigned __int16 v87;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  SCDynamicStoreRef v102;
  const __SCDynamicStore *v103;
  const __CFString *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __CFDictionary *Mutable;
  CFDataRef v111;
  NSObject *v112;
  char *v113;
  int v114;
  int v115;
  int v116;
  const char *v117;
  uint64_t v118;
  int v119;
  char *v121;
  uint64_t v122;
  uint64_t v123;
  _BYTE *v124;
  int store;
  SCDynamicStoreRef storea;
  NSObject *key;
  const __CFString *keya;
  _BYTE v129[20];
  int v130;
  int v131;
  __int16 v132;
  UInt8 bytes[4];
  uint64_t v134;
  _BYTE v135[8940];
  _BYTE v136[48];
  __int16 *v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;
  char v145;
  char v146;
  _BYTE *v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  _BYTE v160[25];
  __int16 v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  _BYTE v165[256];
  __int16 v166;
  unsigned __int16 v167[2];
  char v168;
  char v169;
  int v170;
  __int16 v171;
  int v172;
  __int16 v173;
  int v174;
  __int16 v175;
  __int128 v176;

  v5 = a1;
  if (a5)
  {
    v6 = a5;
    v130 = 0;
    PktLease = GetPktLease(a1, (unint64_t)a2, a3, &v130);
    if (PktLease)
      v14 = v130;
    else
      v14 = 3600;
    store = v14;
    v15 = &unk_100158000;
    if (PktLease && mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS Update response contains lease option granting %4d seconds, updateid %d, InterfaceID %p", v9, v10, v11, v12, v13, v14);
    v16 = *(_QWORD *)(v5 + 12640);
    if (v16)
    {
      v17 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v16 + 8), (unsigned __int16 *)(*(_QWORD *)(v16 + 48) + 4), (_BYTE *)(v5 + 47032));
      LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveUpdateR ERROR m->CurrentRecord already set %s", v18, v19, v20, v21, v22, v5 + 47032);
    }
    v23 = *(_QWORD *)(v5 + 12616);
    *(_QWORD *)(v5 + 12640) = v23;
    if (v23)
    {
      v24 = 0;
      v123 = v6;
      v124 = (_BYTE *)(v5 + 47032);
      v25 = (_BYTE *)(v5 + 47032);
      v119 = ~(1 << v6);
      v118 = v6 >> 5;
      v122 = v5;
      do
      {
        v26 = *(_QWORD *)(v23 + 32);
        if ((v26 == v6 || !v26 && (*(_BYTE *)(v23 + 122) || IsLocalDomain(*(_BYTE **)(v23 + 40))))
          && *(unsigned __int16 *)(v23 + 358) == *a2)
        {
          if (((unint64_t)(v6 + 5) > 3 || v6 == -4) && v6 <= 0x3F)
            *(_DWORD *)(v23 + 4 * v118 + 360) &= v119;
          if (!*(_QWORD *)(v23 + 360))
            *(_WORD *)(v23 + 358) = 0;
          v27 = 1000 * store + *(_DWORD *)(v5 + 64);
          if (v27 <= 1)
            v27 = 1;
          *(_DWORD *)(v23 + 352) = v27;
          ++v24;
          if (v15[3304] == 1)
          {
            key = mDNSLogCategory_Default;
            v28 = v15;
            if (*(_DWORD *)(v23 + 126))
              v29 = "transferred";
            else
              v29 = "registered";
            GetRRDisplayString_rdb((unsigned __int8 *)(v23 + 8), (unsigned __int16 *)(*(_QWORD *)(v23 + 48) + 4), v25);
            v115 = (int)v29;
            v15 = v28;
            v5 = v122;
            v6 = v123;
            LogMsgWithLevel(key, OS_LOG_TYPE_DEFAULT, "Sleep Proxy %s record %2d %5d 0x%x 0x%x (%d) %s", v30, v31, v32, v33, v34, v115);
          }
          if (*(_DWORD *)(v23 + 126))
          {
            *(_WORD *)(v23 + 130) = 0;
            *(_DWORD *)(v23 + 126) = 0;
            *(_BYTE *)(v23 + 192) = 0;
            mDNS_Deregister_internal(v5, v23, 0);
          }
        }
        v35 = *(_QWORD *)(v5 + 12640);
        if (v35 == v23)
        {
          v35 = *(_QWORD *)v23;
          *(_QWORD *)(v5 + 12640) = *(_QWORD *)v23;
        }
        v23 = v35;
      }
      while (v35);
      if (v24)
      {
        memset(v129, 0, sizeof(v129));
        bzero(bytes, 0x22F8uLL);
        v41 = v5 + 12656;
        v42 = (_QWORD *)(v5 + 12656);
        while (1)
        {
          v42 = (_QWORD *)*v42;
          if (!v42)
            break;
          v43 = v42;
          if (v42[444] == v6)
            goto LABEL_42;
        }
        v43 = 0;
LABEL_42:
        v44 = (char *)v43 + 3606;
        if (v42)
          v45 = v44;
        else
          v45 = 0;
        *(_OWORD *)v129 = *(_OWORD *)a4;
        *(_DWORD *)&v129[16] = *(_DWORD *)(a4 + 16);
        v46 = *(_DWORD *)v129;
        if (v15[3304] == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformStoreSPSMACAddr : Storing %#a on interface %s", v36, v37, v38, v39, v40, (int)v129);
        v121 = v45;
        if (v46 == 4)
          v47 = 2;
        else
          v47 = 30;
        v176 = *(_OWORD *)&v129[4];
        v132 = 0;
        v131 = 0;
        memset(v136, 0, 46);
        v48 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:StoreSPSMACAddress"), 0, 0);
        v49 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:GetIPv6Addresses"), 0, 0);
        storea = v49;
        if (!v48 || !v49)
        {
          v62 = v15;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StoreSPSMACAddressinternal: Unable to accesss SC Dynamic Store", v50, v51, v52, v53, v54, v114);
          v63 = 0;
          v64 = 0;
          v65 = 0;
          v66 = 0;
          keya = 0;
          v61 = -1;
          if (!v48)
          {
LABEL_73:
            if (storea)
              CFRelease(storea);
            if (keya)
              CFRelease(keya);
            if (v66)
              CFRelease(v66);
            if (v64)
              CFRelease(v64);
            if (v65)
              CFRelease(v65);
            if (v63)
              CFRelease(v63);
            if (v61)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSStoreSPSMACAddress : failed", v67, v68, v69, v70, v71, v116);
            *(_DWORD *)bytes = 8650752;
            v134 = 0;
            bzero(v136, 0x498uLL);
            v136[8] = 32;
            *(_DWORD *)&v136[12] = 94371881;
            v166 = 264;
            *(_QWORD *)&v136[40] = v165;
            v137 = &v166;
            v145 = 0;
            v146 = 0;
            v138 = 0u;
            v139 = 0u;
            v140 = 0u;
            v141 = 0u;
            v142 = 0u;
            v143 = 0u;
            v144 = 0;
            v147 = v165;
            v161 = 0;
            v162 = 0;
            v164 = 0;
            v163 = 0;
            v165[0] = 0;
            v159 = 0u;
            memset(v160, 0, sizeof(v160));
            v157 = 0u;
            v158 = 0u;
            v155 = 0u;
            v156 = 0u;
            v153 = 0u;
            v154 = 0u;
            v151 = 0u;
            v152 = 0u;
            v149 = 0u;
            v150 = 0u;
            v148 = 0u;
            *(_QWORD *)&v136[16] = 0x18001800001194;
            do
              v41 = *(_QWORD *)v41;
            while (v41 && *(_QWORD *)(v41 + 3552) != v6);
            v168 = 0;
            v169 = *(_BYTE *)(v5 + 142);
            v170 = *(_DWORD *)(v5 + 24);
            v171 = *(_WORD *)(v5 + 28);
            v172 = *(_DWORD *)(v41 + 3600);
            v173 = *(_WORD *)(v41 + 3604);
            v174 = 0;
            v175 = 0;
            v167[0] = 4;
            if (*(unsigned __int16 *)(v5 + 24) == *(unsigned __int16 *)(v41 + 3600))
            {
              v87 = 14;
              if (*(unsigned __int16 *)(v5 + 26) == *(unsigned __int16 *)(v41 + 3602))
              {
                if (*(unsigned __int16 *)(v5 + 28) == *(unsigned __int16 *)(v41 + 3604))
                  v87 = 8;
                else
                  v87 = 14;
              }
            }
            else
            {
              v87 = 14;
            }
            v167[1] = v87;
            if (v62[3304] == 1)
            {
              v88 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(&v136[8], v167, v124);
              LogMsgWithLevel(v88, OS_LOG_TYPE_DEFAULT, "Generated OPT record : %s", v89, v90, v91, v92, v93, (int)v124);
              v94 = *(unsigned int *)&v136[16];
            }
            else
            {
              v94 = 4500;
            }
            v95 = PutResourceRecordTTLWithLimit((unint64_t)bytes, (unint64_t)v135, (_WORD *)&v134 + 3, (uint64_t)&v136[8], v94, (unint64_t)v136, v85, v86);
            if (v95)
            {
              LOWORD(v134) = bswap32((unsigned __int16)v134) >> 16;
              WORD1(v134) = bswap32(WORD1(v134)) >> 16;
              WORD2(v134) = bswap32(WORD2(v134)) >> 16;
              HIWORD(v134) = bswap32(HIWORD(v134)) >> 16;
              v101 = v95 - (_QWORD)v135;
              if ((_DWORD)v95 == v135)
                goto LABEL_115;
              v102 = SCDynamicStoreCreate(0, CFSTR("mDNSResponder:StoreOwnerOPTRecord"), 0, 0);
              if (v102)
              {
                v103 = v102;
                v104 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s%s%s"));
                Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (Mutable)
                {
                  v111 = CFDataCreate(0, bytes, (int)v101 + 12);
                  CFDictionarySetValue(Mutable, CFSTR("OwnerOPTRecord"), v111);
                  if (v111)
                    CFRelease(v111);
                  SCDynamicStoreSetValue(v103, v104, Mutable);
                }
                else
                {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformStoreOwnerOptRecord: Could not create CFDictionary dictionary to store OPT Record", v105, v106, v107, v108, v109, (int)"State:/Network/Interface/");
                }
                CFRelease(v103);
                if (v104)
                  CFRelease(v104);
                if (Mutable)
                  CFRelease(Mutable);
                goto LABEL_115;
              }
              v112 = mDNSLogCategory_Default;
              v113 = "mDNSPlatformStoreOwnerOptRecord: Unable to accesss SC Dynamic Store";
            }
            else
            {
              if (v62[3304] != 1)
                goto LABEL_115;
              v112 = mDNSLogCategory_Default;
              v113 = "mDNSGenerateOwnerOptForInterface: Failed to generate owner OPT record";
            }
            LogMsgWithLevel(v112, OS_LOG_TYPE_DEFAULT, v113, v96, v97, v98, v99, v100, v116);
            goto LABEL_115;
          }
LABEL_72:
          CFRelease(v48);
          goto LABEL_73;
        }
        v132 = 0;
        v131 = 0;
        RemoteMacinternal = GetRemoteMacinternal(v47, &v176, (uint64_t)&v131);
        if (RemoteMacinternal)
        {
          v61 = RemoteMacinternal;
          v62 = v15;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StoreSPSMACAddressinternal: Failed to determine the MAC address", v56, v57, v58, v59, v60, v114);
          v63 = 0;
          v64 = 0;
          v65 = 0;
          v66 = 0;
          keya = 0;
          goto LABEL_72;
        }
        v117 = "State:/Network/Interface/";
        keya = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s%s%s"));
        v66 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v66)
        {
          v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%02x:%02x:%02x:%02x:%02x:%02x"), v131, BYTE1(v131), BYTE2(v131), HIBYTE(v131), v132, HIBYTE(v132));
          CFDictionarySetValue(v66, CFSTR("MACAddress"), v77);
          if (v77)
            CFRelease(v77);
          if (inet_ntop(v47, &v176, v136, 0x2Eu))
          {
            v78 = CFStringCreateWithCString(0, v136, 0x8000100u);
            CFDictionarySetValue(v66, CFSTR("IPAddress"), v78);
            if (v78)
              CFRelease(v78);
            v62 = v15;
            v65 = CFStringCreateWithFormat(0, 0, CFSTR("State:/Network/Interface/%s/IPv6"), v121);
            if (v65)
            {
              v79 = (const __CFDictionary *)SCDynamicStoreCopyValue(storea, v65);
              v64 = v79;
              if (v79)
              {
                Value = CFDictionaryGetValue(v79, CFSTR("Addresses"));
                if (Value)
                {
                  v63 = CFRetain(Value);
                  CFDictionarySetValue(v66, CFSTR("RegisteredAddresses"), v63);
LABEL_71:
                  SCDynamicStoreSetValue(v48, keya, v66);
                  v61 = 0;
                  goto LABEL_72;
                }
              }
            }
            else
            {
              v64 = 0;
            }
            v63 = 0;
            goto LABEL_71;
          }
          v62 = v15;
          v83 = mDNSLogCategory_Default;
          v84 = __error();
          LODWORD(v117) = strerror(*v84);
          v82 = "StoreSPSMACAddressinternal: inet_ntop failed: %s";
          v81 = v83;
        }
        else
        {
          v62 = v15;
          v81 = mDNSLogCategory_Default;
          v82 = "StoreSPSMACAddressinternal: SPSCreateDict() Could not create CFDictionary dict";
        }
        LogMsgWithLevel(v81, OS_LOG_TYPE_DEFAULT, v82, v72, v73, v74, v75, v76, (int)v117);
        v63 = 0;
        v64 = 0;
        v65 = 0;
        v61 = -1;
        goto LABEL_72;
      }
    }
  }
LABEL_115:
  if (*(_DWORD *)(v5 + 152))
    *(_DWORD *)(v5 + 180) = *(_DWORD *)(v5 + 64);
}

void ClearKeepaliveProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int (**v16)(_QWORD, const char *);
  _BYTE *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  NSObject *v27;

  v8 = *(_QWORD *)(a1 + 12640);
  v9 = &unk_100164000;
  if (v8)
  {
    v10 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "ClearKeepaliveProxyRecords ERROR m->CurrentRecord already set %s", v11, v12, v13, v14, v15, a1 + 47032);
  }
  *(_QWORD *)(a1 + 12640) = a3;
  if (a3)
  {
    v16 = (unsigned int (**)(_QWORD, const char *))&unk_10014C000;
    do
    {
      if (*(_QWORD *)(a3 + 32) == a4
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_WORD *)(a1 + 37924) == 10)
      {
        v17 = *(_BYTE **)(a1 + 37952);
        v18 = *v17 ? *v17 + 1 : 0;
        if (((unsigned int (**)(_BYTE *, const char *))v16)[203](&v17[v18], "\n_keepalive"))
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v27 = *((_QWORD *)v9 + 295);
            v19 = *(_DWORD *)(a1 + 19888);
            GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (_BYTE *)(a1 + 47032));
            v9 = &unk_100164000;
            v26 = v19;
            v16 = (unsigned int (**)(_QWORD, const char *))&unk_10014C000;
            LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "ClearKeepaliveProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s", v20, v21, v22, v23, v24, v26);
          }
          DeregisterProxyRecord(a1, a3);
        }
      }
      v25 = *(_QWORD *)(a1 + 12640);
      if (v25 == a3)
      {
        v25 = *(_QWORD *)a3;
        *(_QWORD *)(a1 + 12640) = *(_QWORD *)a3;
      }
      a3 = v25;
    }
    while (v25);
  }
}

void ClearIdenticalProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;

  v6 = *(_QWORD *)(a1 + 12640);
  if (v6)
  {
    v7 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v7, OS_LOG_TYPE_DEFAULT, "ClearIdenticalProxyRecords ERROR m->CurrentRecord already set %s", v8, v9, v10, v11, v12, a1 + 47032);
  }
  *(_QWORD *)(a1 + 12640) = a3;
  if (a3)
  {
    do
    {
      if (*(_QWORD *)(a1 + 37944) == *(_QWORD *)(a3 + 32)
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_DWORD *)(a3 + 24) == *(_DWORD *)(a1 + 37936)
        && resource_records_have_same_dnssec_rr_category(*(_QWORD *)(a3 + 64), *(_QWORD *)(a1 + 37976))
        && *(unsigned __int16 *)(a3 + 12) == *(unsigned __int16 *)(a1 + 37924)
        && *(unsigned __int16 *)(a3 + 14) == *(unsigned __int16 *)(a1 + 37926)
        && *(unsigned __int16 *)(a3 + 20) == *(unsigned __int16 *)(a1 + 37932)
        && *(_DWORD *)(a3 + 28) == *(_DWORD *)(a1 + 37940)
        && SameRDataBody(a3 + 8, (unsigned __int16 *)(*(_QWORD *)(a1 + 37960) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(_BYTE **)(a3 + 40), *(_BYTE **)(a1 + 37952)))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v20 = mDNSLogCategory_Default;
          v19 = *(_DWORD *)(a1 + 19888);
          GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), (_BYTE *)(a1 + 47032));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "ClearIdenticalProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s", v13, v14, v15, v16, v17, v19);
        }
        DeregisterProxyRecord(a1, a3);
      }
      v18 = *(_QWORD *)(a1 + 12640);
      if (v18 == a3)
      {
        v18 = *(_QWORD *)a3;
        *(_QWORD *)(a1 + 12640) = *(_QWORD *)a3;
      }
      a3 = v18;
    }
    while (v18);
  }
}

void SPSRecordCallback(uint64_t a1, char *a2, int a3)
{
  NSObject *v6;
  NSObject *v9;
  unsigned __int8 *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BYTE v22[24];
  __int16 v23;
  char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;

  if (a3 == -65792)
  {
    --*(_DWORD *)(a1 + 19888);
    if (!a2)
      goto LABEL_40;
    goto LABEL_39;
  }
  if (!a3)
    return;
  v6 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
    goto LABEL_11;
  }
  v6 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_11:
    GetRRDisplayString_rdb((unsigned __int8 *)a2 + 8, (unsigned __int16 *)(*((_QWORD *)a2 + 6) + 4), (_BYTE *)(a1 + 47032));
    v21 = 67109635;
    *(_DWORD *)v22 = a3;
    *(_WORD *)&v22[4] = 2160;
    *(_QWORD *)&v22[6] = 1752392040;
    *(_WORD *)&v22[14] = 2085;
    *(_QWORD *)&v22[16] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SPS Callback %d %{sensitive, mask.hash}s", (uint8_t *)&v21, 0x1Cu);
  }
LABEL_12:
  if (a3 != -65548)
    return;
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"SPSRecordCallback", 12908);
  v9 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (unsigned __int8 *)(a2 + 8);
      v13 = (_QWORD *)(a1 + 12656);
      while (1)
      {
        v13 = (_QWORD *)*v13;
        if (!v13)
          break;
        v14 = v13;
        if (v13[444] == *((_QWORD *)a2 + 4))
          goto LABEL_32;
      }
      v14 = 0;
LABEL_32:
      if (v13)
        v15 = (char *)v14 + 3606;
      else
        v15 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    v9 = mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (unsigned __int8 *)(a2 + 8);
      v11 = (_QWORD *)(a1 + 12656);
      while (1)
      {
        v11 = (_QWORD *)*v11;
        if (!v11)
          break;
        v12 = v11;
        if (v11[444] == *((_QWORD *)a2 + 4))
          goto LABEL_28;
      }
      v12 = 0;
LABEL_28:
      if (v11)
        v15 = (char *)v12 + 3606;
      else
        v15 = 0;
LABEL_35:
      GetRRDisplayString_rdb(v10, (unsigned __int16 *)(*((_QWORD *)a2 + 6) + 4), (_BYTE *)(a1 + 47032));
      v21 = 136447491;
      *(_QWORD *)v22 = v15;
      *(_WORD *)&v22[8] = 2160;
      *(_QWORD *)&v22[10] = 1752392040;
      *(_WORD *)&v22[18] = 1045;
      *(_DWORD *)&v22[20] = 6;
      v23 = 2101;
      v24 = a2 + 126;
      v25 = 2160;
      v26 = 1752392040;
      v27 = 2085;
      v28 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Conflicting mDNS -- waking %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P %{sensitive, mask.hash}s", (uint8_t *)&v21, 0x3Au);
    }
  }
  if (*(_DWORD *)(a2 + 126))
  {
    SendWakeup(a1, *((_QWORD *)a2 + 4), (uint64_t)(a2 + 132), (uint64_t)(a2 + 138), 0);
    ScheduleWakeup(a1, *((_QWORD *)a2 + 4), (unsigned __int16 *)a2 + 63, v16, v17, v18, v19, v20, v21);
  }
  mDNS_Unlock_(a1, (uint64_t)"SPSRecordCallback", 12916);
  --*(_DWORD *)(a1 + 19888);
LABEL_39:
  free(a2);
LABEL_40:
  mDNS_UpdateAllowSleep(a1);
}

void ScheduleWakeup(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint8_t *v18;
  int v20;
  __int16 v21;

  if (*(_DWORD *)a3)
  {
    ScheduleWakeupForList(a1, a2, a3, *(_QWORD *)(a1 + 12624), a5, a6, a7, a8, v20);
    ScheduleWakeupForList(a1, a2, a3, *(_QWORD *)(a1 + 12616), v12, v13, v14, v15, a9);
    return;
  }
  v16 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return;
    v21 = 0;
    v18 = (uint8_t *)&v21;
    goto LABEL_12;
  }
  v16 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    v18 = (uint8_t *)&v20;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "ScheduleWakeup ERROR: Target HMAC is zero", v18, 2u);
  }
}

void ScheduleWakeupForList(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (*(_DWORD *)a3)
  {
    v9 = a4;
    *(_QWORD *)(a1 + 12640) = a4;
    if (a4)
    {
      do
      {
        if (*(_QWORD *)(v9 + 32) != a2
          || *(_BYTE *)(v9 + 8) == 1
          || *(unsigned __int16 *)(v9 + 126) != *a3
          || *(unsigned __int16 *)(v9 + 128) != a3[1]
          || *(unsigned __int16 *)(v9 + 130) != a3[2])
        {
          goto LABEL_11;
        }
        if (mDNS_LoggingEnabled == 1)
        {
          v13 = mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
          LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "ScheduleWakeupForList: Scheduling wakeup packets for %s", v14, v15, v16, v17, v18, a1 + 47032);
        }
        mDNS_Deregister_internal(a1, v9, 0);
        v19 = *(_QWORD *)(a1 + 12640);
        if (v19 == v9)
        {
LABEL_11:
          v19 = *(_QWORD *)v9;
          *(_QWORD *)(a1 + 12640) = *(_QWORD *)v9;
        }
        v9 = v19;
      }
      while (v19);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ScheduleWakeupForList ERROR: Target HMAC is zero", a4, a5, a6, a7, a8, a9);
  }
}

void DeregisterProxyRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_WORD *)(a2 + 130) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(_BYTE *)(a2 + 192) = 0;
  mDNS_Deregister_internal(a1, a2, 0);
  v10 = *(_QWORD *)(a1 + 15112);
  if (v10 && v10 != *(_QWORD *)(a1 + 37944))
    mDNSPlatformUpdateProxyList(v10, v3, v4, v5, v6, v7, v8, v9);
  *(_QWORD *)(a1 + 15112) = *(_QWORD *)(a1 + 37944);
}

void mDNS_StartDomainEnumeration()
{
  uint64_t v0;
  _DWORD *v1;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartDomainEnumeration", 16097);
  v0 = qword_10015C518;
  if (!qword_10015C518)
    goto LABEL_9;
  while (!SameDomainNameBytes((_BYTE *)v0, "\x05local"))
  {
    v0 = *(_QWORD *)(v0 + 296);
    if (!v0)
      goto LABEL_9;
  }
  v1 = *(_DWORD **)(v0 + 272);
  if (v1)
  {
LABEL_8:
    ++v1[177];
    mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v0, 2);
LABEL_9:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartDomainEnumeration", 16130);
    return;
  }
  v1 = malloc_type_calloc(1uLL, 0x2D0uLL, 0xF1748037uLL);
  if (v1)
  {
    *(_QWORD *)(v0 + 272) = v1;
    goto LABEL_8;
  }
  __break(1u);
}

uint64_t UpdateInterfaceProtocols(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  int v3;

  *(_WORD *)(result + 17) = 0;
  v1 = (uint64_t *)xmmword_10015BF38;
  if ((_QWORD)xmmword_10015BF38)
  {
    v2 = *(_QWORD *)(result + 3552);
    do
    {
      if (v1[444] == v2)
      {
        v3 = *((_DWORD *)v1 + 890);
        if (v3 == 6)
        {
          if (*((_BYTE *)v1 + 3671))
            *(_BYTE *)(result + 18) = 1;
        }
        else if (v3 == 4)
        {
          if (*((_BYTE *)v1 + 3671))
            *(_BYTE *)(result + 17) = 1;
        }
      }
      v1 = (uint64_t *)*v1;
    }
    while (v1);
  }
  return result;
}

void AdjustAddressRecordSetsEx(uint64_t a1, int a2)
{
  uint64_t v2;
  BOOL v3;
  _QWORD *v4;
  _QWORD *v8;
  uint64_t *FirstAddressRecord;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  __int16 *v24;

  v2 = *(_QWORD *)(a1 + 3552);
  if (AWDLInterfaceID)
    v3 = AWDLInterfaceID == v2;
  else
    v3 = 0;
  if (!v3)
  {
    v4 = &unk_100150000;
    if (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v2)
    {
      v8 = (_QWORD *)xmmword_10015BF38;
      FirstAddressRecord = GetFirstAddressRecordEx((uint64_t *)xmmword_10015BF38, a2);
      if (v8)
      {
        v10 = FirstAddressRecord;
        if (a2)
          v11 = a1 + 2376;
        else
          v11 = a1 + 24;
        do
        {
          v12 = v8[444];
          if (AWDLInterfaceID)
            v13 = AWDLInterfaceID == v12;
          else
            v13 = 0;
          if (v13)
            goto LABEL_40;
          v14 = v4[139];
          if (v14 && v14 == v12)
            goto LABEL_40;
          v16 = (uint64_t)(a2 ? v8 + 297 : v8 + 3);
          if (*(_QWORD *)(v16 + 96) != v11)
            goto LABEL_40;
          if (v10)
            v17 = (uint64_t)v10;
          else
            v17 = v16;
          *(_QWORD *)(v16 + 96) = v17;
          v18 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_33:
              GetRRDisplayString_rdb((unsigned __int8 *)(v16 + 8), (unsigned __int16 *)(*(_QWORD *)(v16 + 48) + 4), word_100164580);
              *(_DWORD *)buf = 141558275;
              v22 = 1752392040;
              v23 = 2085;
              v24 = word_100164580;
              v4 = (_QWORD *)&unk_100150000;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Changed RRSet for %{sensitive, mask.hash}s", buf, 0x16u);
            }
          }
          else
          {
            v18 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              goto LABEL_33;
          }
          v19 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_39:
              v20 = *(_QWORD *)(v16 + 96);
              *(_DWORD *)buf = 134217984;
              v22 = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "New RRSet:        %lx", buf, 0xCu);
            }
          }
          else
          {
            v19 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              goto LABEL_39;
          }
LABEL_40:
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
    }
  }
}

void RestartARPProbing(_DWORD *a1, uint64_t a2)
{
  int v2;

  *(_BYTE *)(a2 + 8) = 2;
  *(_BYTE *)(a2 + 190) = 3;
  ++*(_BYTE *)(a2 + 189);
  v2 = a1[16];
  if (*(_BYTE *)(a2 + 191) == 4 && v2 - *(_DWORD *)(a2 + 284) >= 0)
  {
    InitializeLastAPTime(a1, a2);
  }
  else
  {
    *(_BYTE *)(a2 + 191) = 4;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = v2 + 9000;
    SetNextAnnounceProbeTime((uint64_t)a1, a2);
  }
}

void mDNSCoreReceiveRawTransportPacket(uint64_t a1, unsigned __int16 *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, int8x8_t *a7, unint64_t a8, uint64_t a9, unsigned __int16 a10)
{
  int v11;
  _DWORD *v12;
  uint64_t v13;
  BOOL v14;
  __int16 *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  _BOOL4 v24;
  int v25;
  const char *v26;
  _BOOL4 v27;
  int8x8_t *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned __int16 v37;
  __int16 v38;
  unsigned int v39;
  int8x8_t *v40;
  _BOOL4 v41;
  int v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  const char *v52;
  _BYTE *v53;
  void *v54;
  const char *v55;
  void *v56;
  void *v57;
  int v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  void *v66;
  _BYTE *v67;
  const char *v68;
  const char *v69;
  _BYTE *v70;
  _BYTE *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int8x8_t *v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  uint64_t *v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  _BYTE *v110;
  uint64_t v111;
  _BYTE *v112;
  uint64_t v113;
  BOOL v114;
  unsigned __int8 *v115;
  NSObject *v116;
  _QWORD *v117;
  int v118;
  _QWORD *v119;
  int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  __int8 v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  int64_t v137;
  int v139;
  int v140;
  int v141;
  int v142;
  NSObject *v144;
  char *v146;
  const char *v147;
  NSObject *v149;
  NSObject *v150;
  NSObject *v151;
  uint64_t v153;
  NSObject *v154;
  int v155;
  _BYTE *v156;
  int v157;
  __int16 v158;
  uint64_t v159;
  unsigned int v160;
  int v161;
  char v162[6];
  uint64_t v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  int v168;

  v11 = a5;
  v12 = a4;
  v13 = a1;
  v14 = (_DWORD)a5 == 17 || (_DWORD)a5 == 6;
  v15 = (__int16 *)a7 + 1;
  if (!v14)
    v15 = &zeroIPPort;
  v16 = (unsigned __int16)*v15;
  if ((int)a5 <= 16)
  {
    if ((_DWORD)a5 == 1)
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring %d-byte ICMP from %#a to %#a", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8 - a6);
      return;
    }
    if ((_DWORD)a5 == 6)
    {
      v155 = (unsigned __int16)*v15;
      v17 = *(_QWORD *)(a1 + 12616);
      if (v17)
      {
        v142 = a7->u16[0];
        while (1)
        {
          v159 = 0;
          v160 = 0;
          v158 = 0;
          v163 = 0;
          v164 = 0;
          v165 = 0;
          v166 = 0;
          v167 = 0;
          v168 = 0;
          v161 = 0;
          if (*(_DWORD *)(v17 + 126))
          {
            mDNS_ExtractKeepaliveInfo(v17, &v160, &v166, &v163, (uint64_t)v162, (unsigned int *)&v159 + 1, (unsigned int *)&v159, (_WORD *)&v161 + 1, &v161, &v158);
            if (v160)
            {
              if (v166 != 4
                && ((_DWORD)v166 != 6 || v167 | HIDWORD(v167) | v168 | HIDWORD(v166))
                && v163 != 4
                && ((_DWORD)v163 != 6 || v164 | HIDWORD(v164) | v165 | HIDWORD(v163)))
              {
                v18 = HIDWORD(v159);
                if (HIDWORD(v159))
                {
                  v19 = v159;
                  if ((_DWORD)v159)
                  {
                    v20 = HIWORD(v161);
                    if (HIWORD(v161))
                    {
                      v21 = (unsigned __int16)v161;
                      if ((_WORD)v161)
                      {
                        if (v158
                          && mDNSSameAddress((int *)&v166, a4)
                          && mDNSSameAddress((int *)&v163, a3)
                          && v20 == v155
                          && v21 == v142)
                        {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v17 = *(_QWORD *)v17;
          if (!v17)
            goto LABEL_29;
        }
        v16 = v155;
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: Found a Keepalive record from %#a:%d  to %#a:%d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)a3);
        v133 = a7[1].i8[5];
        v13 = a1;
        if ((v133 & 5) != 0)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: waking because of RST or FIN th_flags %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a7[1].u8[5]);
          v27 = 1;
          v12 = a4;
        }
        else
        {
          v134 = bswap32(v18);
          v135 = bswap32(v19);
          v136 = bswap32(a7->u32[1]);
          v137 = a8 - (_QWORD)a7 - (((unint64_t)a7[1].u8[4] >> 2) & 0x3C);
          v27 = (int)(bswap32(a7[1].u32[0]) - v134) >= 1 && (int)(v136 - v135) >= 0 && v137 > 0;
          if ((v133 & 0x10) != 0 && v137 <= 0 && v135 - v136 == 1)
            mDNS_SendKeepaliveACK(a1, v17);
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: End %p, hlen %d, Datalen %d, pack %u, seq %u, pseq %u, ack %u, wake %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8);
          v13 = a1;
          v12 = a4;
          v16 = v155;
          if (!v27)
            return;
        }
      }
      else
      {
LABEL_29:
        v22 = a7[1].u8[5];
        v24 = (v22 & 4) == 0 && (v22 & 3) != 1;
        v16 = v155;
        if (v155 == 5632)
          v25 = v24;
        else
          v25 = v24 & (v22 >> 1);
        if (mDNS_LoggingEnabled == 1)
        {
          v26 = "Received";
          if (!v25)
            v26 = "Ignoring";
          v12 = a4;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte TCP from %#a:%d to %#a:%d%s%s%s", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v26);
          v27 = 0;
          v13 = a1;
          if (!v25)
            return;
        }
        else
        {
          v27 = 0;
          v13 = a1;
          v12 = a4;
          if (!v25)
            return;
        }
      }
      goto LABEL_158;
    }
LABEL_68:
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring %d-byte IP packet unknown protocol %d from %#a to %#a", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8 - a6);
    return;
  }
  if ((_DWORD)a5 != 17)
  {
    if ((_DWORD)a5 != 58)
      goto LABEL_68;
    if ((unint64_t)a7 + a10 > a8)
      return;
    v29 = (int8x8_t *)(a3 + 1);
    v30 = IPv6CheckSum((uint64_t)(a3 + 1), (uint64_t)(a4 + 1), (unsigned __int16 *)a7, a10);
    if (v30)
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "IPv6CheckSum bad %04X %02X%02X from %#a to %#a", v31, v32, v33, v34, v35, v30);
      return;
    }
    v44 = v13 + 12656;
    do
    {
      v44 = *(_QWORD *)v44;
      if (!v44)
        return;
    }
    while (*(_QWORD *)(v44 + 3552) != a9);
    v45 = v13;
    mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawND", 17938);
    if (a7->u8[0] != 135 || (v49 = *(_QWORD *)(v13 + 12616)) == 0)
    {
LABEL_113:
      if (*a2 != *(unsigned __int16 *)(v44 + 3600)
        || a2[1] != *(unsigned __int16 *)(v44 + 3602)
        || a2[2] != *(unsigned __int16 *)(v44 + 3604))
      {
        v78 = a7->u8[0] == 136 ? &a7[1] : v29;
        if (v78->i32[0] || v78->i32[1] || v78[1].i32[0] || v78[1].i32[1])
        {
          v79 = *(_QWORD *)(v45 + 12616);
          if (v79)
          {
            v80 = v44 + 3606;
            do
            {
              if (*(_QWORD *)(v79 + 32) == a9
                && *(_BYTE *)(v79 + 8) != 1
                && *(_DWORD *)(v79 + 144) == 6
                && *(_DWORD *)(v79 + 148) == v78->i32[0]
                && *(_DWORD *)(v79 + 152) == v78->i32[1]
                && *(_DWORD *)(v79 + 156) == v78[1].i32[0]
                && *(_DWORD *)(v79 + 160) == v78[1].i32[1]
                && *(unsigned __int8 *)(v79 + 189) <= 0x13u)
              {
                if (*(_WORD *)(v79 + 126) || *(_WORD *)(v79 + 128) || *(_WORD *)(v79 + 130))
                {
                  RestartARPProbing((_DWORD *)v45, v79);
                  if (*a2 == *(unsigned __int16 *)(v79 + 132)
                    && a2[1] == *(unsigned __int16 *)(v79 + 134)
                    && a2[2] == *(unsigned __int16 *)(v79 + 136))
                  {
                    if (mDNS_LoggingEnabled == 1)
                    {
                      v154 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(_QWORD *)(v79 + 48) + 4), (_BYTE *)(v45 + 47032));
                      LogMsgWithLevel(v154, OS_LOG_TYPE_DEFAULT, "%-7s NDP %s from owner %.6a %.16a for %.16a -- re-starting probing for %s", v81, v82, v83, v84, v85, v80);
                    }
                  }
                  else
                  {
                    v150 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(_QWORD *)(v79 + 48) + 4), (_BYTE *)(v45 + 47032));
                    LogMsgWithLevel(v150, OS_LOG_TYPE_DEFAULT, "%-7s Conflicting NDP from %.6a %.16a for %.16a -- waking H-MAC %.6a I-MAC %.6a %s", v86, v87, v88, v89, v90, v80);
                    ScheduleWakeup(v45, *(_QWORD *)(v79 + 32), (unsigned __int16 *)(v79 + 126), v91, v92, v93, v94, v95, v140);
                  }
                }
                else if (mDNS_LoggingEnabled == 1)
                {
                  v151 = mDNSLogCategory_Default;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(_QWORD *)(v79 + 48) + 4), (_BYTE *)(v45 + 47032));
                  LogMsgWithLevel(v151, OS_LOG_TYPE_DEFAULT, "%-7s NDP from %.6a %.16a for %.16a -- Invalid H-MAC %.6a I-MAC %.6a %s", v96, v97, v98, v99, v100, v80);
                }
              }
              v79 = *(_QWORD *)v79;
            }
            while (v79);
          }
        }
      }
      mDNS_Unlock_(v45, (uint64_t)"mDNSCoreReceiveRawND", 18014);
      return;
    }
    v50 = v44 + 3606;
    v51 = (_BYTE *)(v13 + 47032);
    v52 = "NDP Req from owner -- re-probing";
    v53 = &unk_100158000;
    v54 = &unk_100164000;
    v55 = "Reached maximum number of restarts for probing - %s";
    v56 = &AllHosts_v6;
    v57 = &AllHosts_v6_Eth;
    while (1)
    {
      if (*(_QWORD *)(v49 + 32) != a9
        || *(_BYTE *)(v49 + 8) == 1
        || *(_DWORD *)(v49 + 144) != 6
        || *(_DWORD *)(v49 + 148) != a7[1].i32[0]
        || *(_DWORD *)(v49 + 152) != a7[1].i32[1]
        || *(_DWORD *)(v49 + 156) != a7[2].i32[0]
        || *(_DWORD *)(v49 + 160) != a7[2].i32[1])
      {
        goto LABEL_112;
      }
      v153 = v50;
      v58 = *a2;
      if (v58 != *(unsigned __int16 *)(v49 + 132)
        || a2[1] != *(unsigned __int16 *)(v49 + 134)
        || (v59 = (char *)v52, a2[2] != *(unsigned __int16 *)(v49 + 136)))
      {
        v59 = "Ignoring  NDP Request from      ";
        if (*(_BYTE *)(v49 + 191) != 4)
        {
          if (v58 != *(unsigned __int16 *)(v44 + 3600)
            || a2[1] != *(unsigned __int16 *)(v44 + 3602)
            || (v59 = "Creating Local NDP Cache entry  ", a2[2] != *(unsigned __int16 *)(v44 + 3604)))
          {
            if (vorr_s8(*v29, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29->i8, *(int8x16_t *)v29->i8, 8uLL)))
              v59 = "Answering NDP Probe   from      ";
            else
              v59 = "Answering NDP Request from      ";
          }
        }
      }
      v156 = v51;
      if (v53[3304] == 1)
      {
        v144 = *((_QWORD *)v54 + 295);
        v146 = v59;
        GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(_QWORD *)(v49 + 48) + 4), v51);
        LogMsgWithLevel(v144, OS_LOG_TYPE_DEFAULT, "%-7s %s %.6a %.16a for %.16a -- H-MAC %.6a I-MAC %.6a %s", v60, v61, v62, v63, v64, v153);
        v59 = v146;
        v57 = &AllHosts_v6_Eth;
        v56 = &AllHosts_v6;
        v55 = "Reached maximum number of restarts for probing - %s";
        v54 = &unk_100164000;
        v53 = &unk_100158000;
        v52 = "NDP Req from owner -- re-probing";
        v51 = v156;
      }
      if (v59 == v52)
      {
        if (*(unsigned __int8 *)(v49 + 189) <= 0x13u)
        {
          v67 = v51;
          v68 = v52;
          RestartARPProbing((_DWORD *)v45, v49);
          v57 = &AllHosts_v6_Eth;
          v56 = &AllHosts_v6;
          v55 = "Reached maximum number of restarts for probing - %s";
          v54 = &unk_100164000;
          v53 = (_BYTE *)&unk_100158000;
          v52 = v68;
          v51 = v67;
LABEL_111:
          v50 = v153;
          goto LABEL_112;
        }
        v50 = v153;
        if (v53[3304] == 1)
        {
          v149 = *((_QWORD *)v54 + 295);
          v71 = v51;
          v72 = (char *)v55;
          GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(_QWORD *)(v49 + 48) + 4), v51);
          LogMsgWithLevel(v149, OS_LOG_TYPE_DEFAULT, v72, v73, v74, v75, v76, v77, (int)v71);
          v57 = &AllHosts_v6_Eth;
          v56 = &AllHosts_v6;
          v55 = v72;
          v54 = &unk_100164000;
          v53 = (_BYTE *)&unk_100158000;
          v52 = "NDP Req from owner -- re-probing";
          v51 = v71;
          goto LABEL_111;
        }
      }
      else
      {
        if (v59 == "Creating Local NDP Cache entry  ")
        {
          v69 = v52;
          v70 = v53;
          mDNSPlatformSetLocalAddressCacheEntry((int *)(v49 + 144), (const void *)(v49 + 132), a9, v46, v47, v48, (uint64_t)v56, (uint64_t)v57, v139);
LABEL_109:
          v57 = &AllHosts_v6_Eth;
          v56 = &AllHosts_v6;
          v55 = "Reached maximum number of restarts for probing - %s";
          v54 = &unk_100164000;
          v53 = v70;
          v52 = v69;
          goto LABEL_110;
        }
        if (v59 == "Answering NDP Request from      ")
        {
          v69 = v52;
          v70 = v53;
          SendNDP(v45, 136, 64, v49, a7 + 1, 0, (uint64_t)v29, (uint64_t)a2);
          goto LABEL_109;
        }
        v50 = v153;
        if (v59 == "Answering NDP Probe   from      ")
        {
          v65 = v56;
          v66 = v57;
          SendNDP(v45, 136, 0, v49, a7 + 1, 0, (uint64_t)v56, (uint64_t)v57);
          v57 = v66;
          v56 = v65;
          v55 = "Reached maximum number of restarts for probing - %s";
          v54 = &unk_100164000;
          v53 = (_BYTE *)&unk_100158000;
          v52 = "NDP Req from owner -- re-probing";
LABEL_110:
          v51 = v156;
          goto LABEL_111;
        }
      }
LABEL_112:
      v49 = *(_QWORD *)v49;
      if (!v49)
        goto LABEL_113;
    }
  }
  v36 = __rev16(a7->u16[2]);
  if (v36 < 8)
    return;
  v37 = v36 - 8;
  if (v16 == 54028)
  {
    v41 = 0;
    if ((unint64_t)&a7[1] + 2 > a8 || v37 < 0x6Eu)
      goto LABEL_153;
    if (a7[1].i8[0] == 19)
    {
      v41 = a7[1].u8[1] == 136;
      goto LABEL_153;
    }
LABEL_152:
    v41 = 0;
    goto LABEL_153;
  }
  if (v16 != 37905)
  {
    v41 = 1;
    goto LABEL_153;
  }
  if ((unint64_t)&a7[1] + 1 <= a8 && v37 == 1 && a7[1].u8[0] == 255)
    goto LABEL_152;
  if ((unint64_t)&a7[1] + 4 > a8 || a7[1].i8[0] || a7[1].i8[1] || a7[1].i8[2])
  {
    v38 = 0;
    v39 = 8;
  }
  else
  {
    v39 = 12;
    if (a7[1].i8[3])
    {
      v39 = 8;
      v38 = 0;
    }
    else
    {
      v38 = -4;
    }
  }
  v40 = &a7[3 * v39];
  v41 = 1;
  if ((unint64_t)&v40[3] + 4 <= a8 && (unsigned __int16)(v38 + v37) >= 0x1Cu && (v40[2].i8[1] & 0x10) != 0)
  {
    v42 = v40[2].u8[2];
    if (v42 == 34 || v42 == 5)
    {
      v41 = 0;
      v43 = "Ignoring";
    }
    else
    {
      v43 = "Received";
    }
    if (mDNS_LoggingEnabled != 1)
      goto LABEL_157;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte IKE ExchangeType %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v43);
  }
LABEL_153:
  if (mDNS_LoggingEnabled == 1)
  {
    v101 = "Received";
    if (!v41)
      v101 = "Ignoring";
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte UDP from %#a:%d to %#a:%d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v101);
  }
LABEL_157:
  v27 = 0;
  if (!v41)
    return;
LABEL_158:
  mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawTransportPacket", 18170);
  v102 = *(uint64_t **)(v13 + 12616);
  if (v102)
  {
    if (v11 == 6)
      v103 = "\x04_tcp";
    else
      v103 = "\x04_udp";
    v147 = v103;
    v157 = v16;
    do
    {
      if (v102[4] == a9
        && *((_BYTE *)v102 + 8) != 1
        && *((_DWORD *)v102 + 36)
        && mDNSSameAddress((int *)v102 + 36, v12))
      {
        v109 = *(uint64_t **)(v13 + 12616);
        if (v109)
        {
          while (1)
          {
            if (v109[4] == a9
              && *((unsigned __int16 *)v109 + 63) == *((unsigned __int16 *)v102 + 63)
              && *((unsigned __int16 *)v109 + 64) == *((unsigned __int16 *)v102 + 64)
              && *((unsigned __int16 *)v109 + 65) == *((unsigned __int16 *)v102 + 65)
              && *((_BYTE *)v109 + 8) != 1
              && *((_WORD *)v109 + 6) == 33
              && *(unsigned __int16 *)(v109[6] + 8) == v16)
            {
              v110 = (_BYTE *)v109[5];
              v111 = *v110 ? *v110 + 1 : 0;
              v112 = &v110[v111];
              v113 = *v112 ? *v112 + 1 : 0;
              if (SameDomainLabelPointer(&v112[v113], v147))
                break;
            }
            v109 = (uint64_t *)*v109;
            if (!v109)
              goto LABEL_183;
          }
        }
        else
        {
LABEL_183:
          if (v16 == 37905)
            v109 = v102;
          else
            v109 = 0;
        }
        if (v109)
          v114 = 1;
        else
          v114 = !v27;
        if (v114)
          v115 = (unsigned __int8 *)v109;
        else
          v115 = (unsigned __int8 *)v102;
        if (v115)
        {
          v116 = mDNSLogCategory_Default;
          v117 = (_QWORD *)(v13 + 12656);
          while (1)
          {
            v117 = (_QWORD *)*v117;
            if (!v117)
              break;
            v118 = (int)v117;
            if (v117[444] == v102[4])
              goto LABEL_203;
          }
          v118 = 0;
LABEL_203:
          if (v117)
            v121 = v118 + 3606;
          else
            v121 = 0;
          GetRRDisplayString_rdb(v115 + 8, (unsigned __int16 *)(*((_QWORD *)v115 + 6) + 4), (_BYTE *)(v13 + 47032));
          LogMsgWithLevel(v116, OS_LOG_TYPE_DEFAULT, "Waking host at %s %#a H-MAC %.6a I-MAC %.6a for %s", v122, v123, v124, v125, v126, v121);
          ScheduleWakeup(v13, v102[4], (unsigned __int16 *)v102 + 63, v127, v128, v129, v130, v131, v141);
          v16 = v157;
        }
        else if (mDNS_LoggingEnabled == 1)
        {
          v119 = (_QWORD *)(v13 + 12656);
          while (1)
          {
            v119 = (_QWORD *)*v119;
            if (!v119)
              break;
            v120 = (int)v119;
            if (v119[444] == v102[4])
              goto LABEL_208;
          }
          v120 = 0;
LABEL_208:
          if (v119)
            v132 = v120 + 3606;
          else
            v132 = 0;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleeping host at %s %#a %.6a has no service on %#s %d", v104, v105, v106, v107, v108, v132);
        }
      }
      v102 = (uint64_t *)*v102;
    }
    while (v102);
  }
  mDNS_Unlock_(v13, (uint64_t)"mDNSCoreReceiveRawTransportPacket", 18195);
}

void mDNS_SendKeepaliveACK(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  _BYTE v21[6];
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned __int16 v28;
  uint64_t v29;
  unsigned int v30;

  v29 = 0;
  v30 = 0;
  v28 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v19 = 0;
  v20 = 0;
  mDNS_ExtractKeepaliveInfo(a2, &v30, &v25, &v22, (uint64_t)v21, (unsigned int *)&v29 + 1, (unsigned int *)&v29, &v20, &v19, &v28);
  if (v30
    && v25 != 4
    && ((_DWORD)v25 != 6 || v26 | HIDWORD(v26) | v27 | HIDWORD(v25))
    && v22 != 4
    && ((_DWORD)v22 != 6 || v23 | HIDWORD(v23) | v24 | HIDWORD(v22))
    && HIDWORD(v29)
    && (v9 = v29, (_DWORD)v29)
    && v20
    && v19
    && (v10 = v28) != 0)
  {
    HIDWORD(v29) = bswap32(bswap32(HIDWORD(v29)) + 1);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepaliveACK: laddr %#a raddr %#a lport %d rport %d", v4, v5, v6, v7, v8, (int)&v25);
    mDNSPlatformSendKeepalive((uint64_t)&v25, (uint64_t)&v22, &v20, &v19, HIDWORD(v29), v9, v10, v11);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    v12 = mDNSLogCategory_Default;
    v13 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v13);
    LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepaliveACK: not a valid record %s for keepalive", v14, v15, v16, v17, v18, (int)v13);
  }
}

void SetDynDNSHostNameIfChanged(_BYTE *a1)
{
  _BYTE *v2;
  uint64_t v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *i;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;

  if (!SameDomainNameBytes(a1, byte_10015C620))
  {
    if (byte_10015C620[0])
      mDNS_RemoveDynDNSHostName(byte_10015C620);
    v2 = a1;
    if (a1 == (_BYTE *)-256)
    {
LABEL_6:
      while (v2)
      {
        v3 = *v2;
        if (v3 > 0x3F)
          break;
        if (!*v2)
        {
          v4 = (_WORD)v2 - (_WORD)a1 + 1;
          if (v4 >= 0x101u)
            break;
          memcpy(byte_10015C620, a1, v4);
          if (byte_10015C620[0])
          {
            mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_10015C620, 1, v5, v6, v7, v8, v9, v10);
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_AddDynDNSHostName %##s", v11, v12, v13, v14, v15, (int)byte_10015C620);
            v16 = xmmword_10015C720;
            if ((_QWORD)xmmword_10015C720)
            {
              v17 = (uint64_t *)&xmmword_10015C720;
              while (1)
              {
                v18 = SameDomainNameBytes(byte_10015C620, (_BYTE *)(v16 + 208));
                v24 = (uint64_t *)*v17;
                if (v18)
                  break;
                v16 = *v24;
                v17 = (uint64_t *)*v17;
                if (!*v24)
                  goto LABEL_25;
              }
              if (v24)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DynDNSHostName %##s already in list", v19, v20, v21, v22, v23, (int)byte_10015C620);
                return;
              }
            }
            else
            {
              v17 = (uint64_t *)&xmmword_10015C720;
            }
LABEL_25:
            v25 = (char *)malloc_type_calloc(1uLL, 0xB10uLL, 0xF1748037uLL);
            if (v25)
            {
              *v17 = (uint64_t)v25;
              for (i = byte_10015C620; i < (char *)&xmmword_10015C720 && i != 0; i += v28 + 1)
              {
                v28 = *i;
                if (v28 > 0x3F)
                  break;
                if (!*i)
                {
                  v29 = (_DWORD)i - mDNSStorage - 14423;
                  if ((unsigned __int16)v29 <= 0x100u)
                  {
                    memcpy(v25 + 208, byte_10015C620, (unsigned __int16)v29);
                    goto LABEL_37;
                  }
                  break;
                }
              }
              v25[208] = 0;
LABEL_37:
              v30 = *v17;
              *(_DWORD *)(v30 + 808) = 4;
              *(_DWORD *)(v30 + 1984) = 4;
              *(_QWORD *)(v30 + 2816) = DynDNSHostNameCallback;
              *(_QWORD *)(*v17 + 2824) = 0;
              AdvertiseHostname((size_t)mDNSStorage, *v17);
            }
            else
            {
              __break(1u);
            }
          }
          return;
        }
        v2 += v3 + 1;
        if (a1 != (_BYTE *)-256)
          goto LABEL_5;
      }
    }
    else
    {
LABEL_5:
      if (v2 < a1 + 256)
        goto LABEL_6;
    }
    byte_10015C620[0] = 0;
  }
}

void DynDNSHostNameCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mDNSPlatformDynDNSHostNameStatusChanged(*(unsigned __int8 **)(a2 + 40), a3, a3, a4, a5, a6, a7, a8);
}

void mDNS_StartExit()
{
  NSObject *v0;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t j;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v19;
  NSObject *v22;
  char v23;
  NSObject *v24;
  const char *v25;
  unsigned __int8 *v26;
  NSObject *v27;
  int v30;
  NSObject *v31;
  uint8_t buf[4];
  _BYTE v33[24];

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartExit", 19155);
  v0 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }
  v0 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit", buf, 2u);
  }
LABEL_11:
  v3 = dword_100158E08 + 5000;
  if ((dword_100158E08 + 5000) <= 1)
    v3 = 1;
  dword_100158E14 = v3;
  mDNSCoreBeSleepProxyServer_internal((uint64_t)mDNSStorage, 0, 0, 0, 0, 0);
  for (i = xmmword_10015C720; (_QWORD)xmmword_10015C720; i = xmmword_10015C720)
    mDNS_RemoveDynDNSHostName((_BYTE *)(i + 208));
  v10 = (_QWORD *)SearchList;
  if (SearchList)
  {
    do
    {
      while (1)
      {
        v11 = (_QWORD *)v10[471];
        if (!v11)
          break;
        v10[471] = *v11;
        mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v11 + 1), 0);
      }
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  for (j = qword_10015C518; j; j = *(_QWORD *)(j + 296))
  {
    v13 = 0;
    do
    {
      mDNS_DeregisterDomainsDiscoveredForDomainEnumeration((unsigned int *)mDNSStorage, j, v13, v4, v5, v6, v7, v8);
      v13 = (v13 + 1);
    }
    while ((_DWORD)v13 != 5);
  }
  DeadvertiseAllInterfaceRecords((uint64_t)mDNSStorage, 3);
  while (1)
  {
    v14 = xmmword_10015C748;
    if (!(_QWORD)xmmword_10015C748)
      break;
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, xmmword_10015C748);
    *(_QWORD *)(v14 + 152) = 0;
    *(_WORD *)(v14 + 160) = 0;
    *(_WORD *)(v14 + 176) = 0;
    *(_QWORD *)(v14 + 164) = 0;
  }
  v15 = qword_10015BF28;
  if (qword_10015BF28)
  {
    v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_36;
    }
    else
    {
      v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_36;
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(v15 + 8), (unsigned __int16 *)(*(_QWORD *)(v15 + 48) + 4), word_100164580);
    *(_DWORD *)buf = 141558275;
    *(_QWORD *)v33 = 1752392040;
    *(_WORD *)&v33[8] = 2085;
    *(_QWORD *)&v33[10] = word_100164580;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: ERROR m->CurrentRecord already set %{sensitive, mask.hash}s", buf, 0x16u);
  }
LABEL_36:
  v19 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_45:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Deregistering duplicate resource records", buf, 2u);
    }
  }
  else
  {
    v19 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_45;
    }
  }
  DeregLoop(*((uint64_t *)&xmmword_10015BF10 + 1));
  v22 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_53;
    *(_WORD *)buf = 0;
  }
  else
  {
    v22 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_53;
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Deregistering resource records", buf, 2u);
LABEL_53:
  DeregLoop(xmmword_10015BF10);
  if (dword_100158E2C - dword_100158E08 <= 999)
  {
    dword_100158E2C = dword_100158E08;
    HIDWORD(qword_100158E18) = 0;
  }
  v23 = gSensitiveLoggingEnabled;
  v24 = mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State)
    v23 = 0;
  if ((_QWORD)xmmword_10015BF10)
  {
    if ((v23 & 1) != 0)
    {
      v24 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_69;
      *(_WORD *)buf = 0;
      v25 = "mDNS_StartExit: Sending final record deregistrations";
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_69;
      *(_WORD *)buf = 0;
      v25 = "mDNS_StartExit: Sending final record deregistrations";
    }
  }
  else if ((v23 & 1) != 0)
  {
    v24 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_69;
    *(_WORD *)buf = 0;
    v25 = "mDNS_StartExit: No deregistering records remain";
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_69;
    *(_WORD *)buf = 0;
    v25 = "mDNS_StartExit: No deregistering records remain";
  }
  _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
LABEL_69:
  v26 = (unsigned __int8 *)*((_QWORD *)&xmmword_10015BF10 + 1);
  if (*((_QWORD *)&xmmword_10015BF10 + 1))
  {
    while (1)
    {
      v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
        break;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_78;
LABEL_79:
      v26 = *(unsigned __int8 **)v26;
      if (!v26)
        goto LABEL_80;
    }
    v27 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_79;
LABEL_78:
    v30 = v26[8];
    GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((_QWORD *)v26 + 6) + 4), word_100164580);
    *(_DWORD *)buf = 67109635;
    *(_DWORD *)v33 = v30;
    *(_WORD *)&v33[4] = 2160;
    *(_QWORD *)&v33[6] = 1752392040;
    *(_WORD *)&v33[14] = 2085;
    *(_QWORD *)&v33[16] = word_100164580;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Should not still have Duplicate Records remaining: %02X %{sensitive, mask.hash}s", buf, 0x1Cu);
    goto LABEL_79;
  }
LABEL_80:
  if (dword_100158DD8)
    DiscardDeregistrations((uint64_t)mDNSStorage);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartExit", 19270);
  v31 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
  }
  else
  {
    v31 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: done", buf, 2u);
}

void DeregLoop(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned __int8 *v4;
  int v5;
  const char *v6;
  uint64_t v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  __int16 *v18;

  qword_10015BF28 = a1;
  if (a1)
  {
    v1 = a1;
    while (1)
    {
      v2 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
        break;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v4 = (unsigned __int8 *)(v1 + 8);
        v5 = *(unsigned __int8 *)(v1 + 8);
        if (v5 == 1)
          v6 = "Accelerating";
        else
          v6 = "Initiating  ";
LABEL_16:
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(_QWORD *)(v1 + 48) + 4), word_100164580);
        *(_DWORD *)buf = 136447235;
        v10 = v6;
        v11 = 2048;
        v12 = v1;
        v13 = 1024;
        v14 = v5;
        v15 = 2160;
        v16 = 1752392040;
        v17 = 2085;
        v18 = word_100164580;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DeregLoop: %{public}s deregistration for %p %02X %{sensitive, mask.hash}s", buf, 0x30u);
      }
LABEL_17:
      if (*(_BYTE *)(v1 + 8) == 1)
      {
        if (*(unsigned __int8 *)(v1 + 191) >= 2u)
        {
          *(_BYTE *)(v1 + 191) = 1;
          *(_DWORD *)(v1 + 284) = dword_100158E08 - *(_DWORD *)(v1 + 280);
          SetNextAnnounceProbeTime((uint64_t)mDNSStorage, v1);
        }
      }
      else
      {
        mDNS_Deregister_internal((uint64_t)mDNSStorage, v1, 1);
      }
      v8 = qword_10015BF28;
      if (qword_10015BF28 == v1)
      {
        v8 = *(_QWORD *)v1;
        qword_10015BF28 = *(_QWORD *)v1;
      }
      v1 = v8;
      if (!v8)
        return;
    }
    v2 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    v4 = (unsigned __int8 *)(v1 + 8);
    v5 = *(unsigned __int8 *)(v1 + 8);
    if (v5 == 1)
      v6 = "Accelerating";
    else
      v6 = "Initiating  ";
    goto LABEL_16;
  }
}

void mDNS_FinalExit()
{
  int v0;
  NSObject *v1;
  uint64_t v4;
  __CFRunLoop *Main;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *v7;
  const void *v8;
  const void *v9;
  __CFRunLoop *v10;
  const void *v11;
  int v12;
  int v13;
  char v14;
  uint64_t v15;
  int v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint32_t v20;
  int v21;
  uint64_t i;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  _QWORD *v26;
  _QWORD **v27;
  _QWORD *v28;
  _QWORD *v29;
  int v30;
  NSObject *v31;
  unsigned __int8 *v34;
  NSObject *v35;
  int v38;
  NSObject *v39;
  uint8_t buf[4];
  _BYTE v41[10];
  _BYTE v42[6];
  uint64_t v43;
  __int16 v44;
  __int16 *v45;

  v0 = dword_100158EBC;
  v1 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }
  v1 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: mDNSPlatformClose", buf, 2u);
  }
LABEL_11:
  v4 = mDNSStorage[0];
  if (*(_DWORD *)(mDNSStorage[0] + 568))
  {
    Main = CFRunLoopGetMain();
    RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    CFRunLoopRemoveSource(Main, RunLoopSource, kCFRunLoopDefaultMode);
    IODeregisterForSystemPower((io_object_t *)(mDNSStorage[0] + 572));
    IOServiceClose(*(_DWORD *)(mDNSStorage[0] + 568));
    IONotificationPortDestroy(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    v4 = mDNSStorage[0];
    *(_DWORD *)(mDNSStorage[0] + 568) = 0;
  }
  if (*(_QWORD *)(v4 + 504))
  {
    v7 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v7, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 512));
    v4 = mDNSStorage[0];
    v8 = *(const void **)(mDNSStorage[0] + 512);
    if (v8)
    {
      CFRelease(v8);
      v4 = mDNSStorage[0];
      *(_QWORD *)(mDNSStorage[0] + 512) = 0;
    }
    v9 = *(const void **)(v4 + 504);
    if (v9)
    {
      CFRelease(v9);
      v4 = mDNSStorage[0];
      *(_QWORD *)(mDNSStorage[0] + 504) = 0;
    }
  }
  if (*(_QWORD *)(v4 + 520))
  {
    v10 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v10, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 520), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 520));
    v4 = mDNSStorage[0];
    v11 = *(const void **)(mDNSStorage[0] + 520);
    if (v11)
    {
      CFRelease(v11);
      v4 = mDNSStorage[0];
      *(_QWORD *)(mDNSStorage[0] + 520) = 0;
    }
  }
  v12 = *(_DWORD *)(v4 + 528);
  if ((v12 & 0x80000000) == 0)
  {
    close(v12);
    *(_DWORD *)(mDNSStorage[0] + 528) = -1;
  }
  if (&_D2DTerminate)
  {
    v13 = D2DTerminate();
    v14 = gSensitiveLoggingEnabled;
    v15 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State)
      v14 = 0;
    if (v13)
    {
      v16 = v13;
      if ((v14 & 1) != 0)
      {
        v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_40;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v41 = v16;
        v17 = "D2DTerminate failed: %d";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          goto LABEL_40;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v41 = v16;
        v17 = "D2DTerminate failed: %d";
      }
      v18 = v15;
      v19 = OS_LOG_TYPE_ERROR;
      v20 = 8;
    }
    else
    {
      if ((v14 & 1) != 0)
      {
        v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_40;
        *(_WORD *)buf = 0;
        v17 = "D2DTerminate succeeded";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          goto LABEL_40;
        *(_WORD *)buf = 0;
        v17 = "D2DTerminate succeeded";
      }
      v18 = v15;
      v19 = OS_LOG_TYPE_DEFAULT;
      v20 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
  }
LABEL_40:
  v21 = time(0);
  for (i = *(_QWORD *)mDNSStorage[0]; i; i = *(_QWORD *)(i + 3680))
  {
    if (*(_BYTE *)(i + 3696))
      *(_DWORD *)(i + 3704) = v21;
    *(_BYTE *)(i + 3696) = 0;
  }
  ClearInactiveInterfaces(v21);
  CloseSocketSet(mDNSStorage[0] + 8);
  v23 = 0;
  v24 = 0;
  do
  {
    v25 = &mDNSStorage[v23];
    v26 = (_QWORD *)v25[34];
    if (v26)
    {
      v27 = (_QWORD **)(v25 + 34);
      do
      {
        v29 = v26 + 2;
        v28 = (_QWORD *)v26[2];
        if (v28)
        {
          do
          {
            *v29 = *v28;
            if (v28[12])
              ++v24;
            ReleaseCacheRecord((uint64_t)mDNSStorage, (uint64_t)v28);
            v28 = (_QWORD *)*v29;
          }
          while (*v29);
        }
        v26[3] = v29;
        ReleaseCacheGroup((uint64_t)mDNSStorage, v27);
        v26 = *v27;
      }
      while (*v27);
    }
    ++v23;
  }
  while (v23 != 499);
  v30 = qword_100158EC4;
  if (v24 != (_DWORD)qword_100158EC4)
  {
    v31 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_63;
      goto LABEL_62;
    }
    v31 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_62:
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)v41 = v0;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = v24;
      *(_WORD *)v42 = 1024;
      *(_DWORD *)&v42[2] = v30;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "*** ERROR *** rrcache_totalused %u; rrcache_active %u != m->rrcache_active %u",
        buf,
        0x14u);
    }
  }
LABEL_63:
  v34 = (unsigned __int8 *)xmmword_10015BF10;
  if ((_QWORD)xmmword_10015BF10)
  {
    while (1)
    {
      v35 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
        break;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_72;
LABEL_73:
      v34 = *(unsigned __int8 **)v34;
      if (!v34)
        goto LABEL_74;
    }
    v35 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_73;
LABEL_72:
    v38 = v34[8];
    GetRRDisplayString_rdb(v34 + 8, (unsigned __int16 *)(*((_QWORD *)v34 + 6) + 4), word_100164580);
    *(_DWORD *)buf = 134218755;
    *(_QWORD *)v41 = v34;
    *(_WORD *)&v41[8] = 1024;
    *(_DWORD *)v42 = v38;
    *(_WORD *)&v42[4] = 2160;
    v43 = 1752392040;
    v44 = 2085;
    v45 = word_100164580;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit failed to send goodbye for: %p %02X %{sensitive, mask.hash}s", buf, 0x26u);
    goto LABEL_73;
  }
LABEL_74:
  if (qword_10015DBE8)
  {
    ref_count_obj_release((_QWORD *)qword_10015DBE8);
    qword_10015DBE8 = 0;
  }
  v39 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
  }
  else
  {
    v39 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: done", buf, 2u);
}

uint64_t _DNS64RestartQuestion(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  const char *i;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;

  mDNS_StopQuery_internal(a1, a2);
  *(_BYTE *)(a2 + 672) = a3;
  if ((a3 - 3) < 2)
  {
    v15 = 1;
LABEL_22:
    *(_WORD *)(a2 + 342) = v15;
    return mDNS_StartQuery_internal(a1, a2);
  }
  if ((a3 - 1) <= 1)
  {
    v11 = (_BYTE *)(a2 + 376);
    *(_QWORD *)(a2 + 673) = *(_QWORD *)(a2 + 376);
    *(_QWORD *)(a2 + 680) = *(_QWORD *)(a2 + 383);
    for (i = "\bipv4only\x04arpa"; ; i += v14 + 1)
    {
      if ("\bipv4only\x04arpa" == (char *)-256)
      {
        if (!i)
          goto LABEL_18;
      }
      else if (i >= "r_count_total" || i == 0)
      {
        goto LABEL_18;
      }
      v14 = *(unsigned __int8 *)i;
      if (v14 > 0x3F)
        goto LABEL_18;
      if (!*i)
        break;
    }
    v16 = (_DWORD)i - "\bipv4only\x04arpa" + 1;
    if ((unsigned __int16)v16 <= 0x100u)
    {
      memcpy(v11, "\bipv4only\x04arpa", (unsigned __int16)v16);
      goto LABEL_19;
    }
LABEL_18:
    *v11 = 0;
LABEL_19:
    if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1)
      dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_574);
    *(_DWORD *)(a2 + 200) = _DNS64IPv4OnlyFQDNHash_sHash;
    v15 = 28;
    goto LABEL_22;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS64RestartQuestion: unrecognized DNS64 state %d", v6, v7, v8, v9, v10, a3);
  return mDNS_StartQuery_internal(a1, a2);
}

uint64_t _DNS64TestIPv6Synthesis(uint64_t a1, uint64_t a2, int *a3)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[2];
  int v10;
  unsigned int v11;
  void *v12;

  v12 = 0;
  v11 = 0;
  v9[0] = 0;
  v9[1] = 0;
  if (_DNS64GetPrefixes(a1, a2, &v12, (int *)&v11))
  {
    v7 = 0;
    v4 = (char *)v12;
    if (!v12)
      return v7;
    goto LABEL_9;
  }
  v10 = *a3;
  v4 = (char *)v12;
  if (!v11)
  {
LABEL_6:
    v7 = 0;
    if (!v4)
      return v7;
    goto LABEL_9;
  }
  v5 = 0;
  v6 = 16 * v11;
  while (!nw_nat64_synthesize_v6(&v4[v5], &v10, v9))
  {
    v5 += 16;
    if (v6 == v5)
      goto LABEL_6;
  }
  v7 = 1;
  if (v4)
LABEL_9:
    free(v4);
  return v7;
}

uint64_t _DNS64GetPrefixes(uint64_t a1, uint64_t a2, _QWORD *a3, int *a4)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  uint64_t v22;

  v22 = 0;
  if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1)
    dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_574);
  v8 = 4294901742;
  v9 = CacheGroupForName(a1, _DNS64IPv4OnlyFQDNHash_sHash, "\bipv4only\x04arpa");
  if (v9)
  {
    v10 = v9;
    v11 = v9[2];
    if (v11)
    {
      v12 = 0;
      do
      {
        v13 = *(_QWORD *)(v11 + 56);
        if (v13)
          v13 = *(_QWORD *)(v13 + 24);
        if (v13 == a2 && *(_WORD *)(v11 + 12) == 28 && *(unsigned __int8 *)(v11 + 8) != 240 && !*(_QWORD *)(v11 + 32))
          ++v12;
        v11 = *(_QWORD *)v11;
      }
      while (v11);
      if (v12)
      {
        v14 = malloc_type_calloc(v12, 0x10uLL, 0xF1748037uLL);
        if (v14)
        {
          v15 = v14;
          v16 = v10[2];
          if (v16)
          {
            v17 = 0;
            do
            {
              v18 = *(_QWORD *)(v16 + 56);
              if (v18)
                v18 = *(_QWORD *)(v18 + 24);
              if (v18 == a2
                && *(_WORD *)(v16 + 12) == 28
                && *(unsigned __int8 *)(v16 + 8) != 240
                && !*(_QWORD *)(v16 + 32))
              {
                *((_OWORD *)v14 + v17) = *(_OWORD *)(*(_QWORD *)(v16 + 48) + 4);
                v17 = (v17 + 1);
              }
              v16 = *(_QWORD *)v16;
              if (v16)
                v19 = v17 >= v12;
              else
                v19 = 1;
            }
            while (!v19);
          }
          else
          {
            v17 = 0;
          }
          v20 = nw_nat64_copy_prefixes_from_ipv4only_records(v14, v17, &v22);
          free(v15);
          if (v20 >= 1)
          {
            v8 = 0;
            *a3 = v22;
            *a4 = v20;
            return v8;
          }
        }
        else
        {
          __break(1u);
        }
        return 4294901759;
      }
    }
  }
  return v8;
}

